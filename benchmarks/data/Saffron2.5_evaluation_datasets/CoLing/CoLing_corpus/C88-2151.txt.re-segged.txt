Using Constraints in a
Constructive Version of GPSG
Wilhelm WEIS WEBER
Technical University of Berlin
Institute for Software and Theoretical Computer Science 
Project Group KIT
Sekr . FR 512
Franklinstr . 28/29
D-1000 Berlin10
Email : we is web@db0tuil1.bitnet

Complex categories are caracteristic of unification grammars as for example GPSG\[  Shieber86a  \] . They are sets of pairs of feature . s and values . The unification , which can be applied to two or more categories , is the essential operation . 
The papers of \[ Shieber 85\] ,  \[  Barton85\] and \[ Ristad86\] deal with the influence of complex categories on the efficiency of the parsing algorithm  . This is one problem from using complex categories  , another one arises when using a constructive version of GPSG  ( see\[Busemann/Hanense hild88\] in this volume )  . Namely that the application of admissibility conditions  , e . g . LP statements and FCRs 1 , to a local treet is prevented because particular feature values of eat-egories int are not yet specified  , but they will be instantiated later somewhere else in the complete tree  . Similar problems are described ? in \ [ Karttunen86\] for D-PATR . 
This work describes the latter problem and will present a solution working with computation  , evaluation and propagation of constraints within local trees  ( depth 1 )  . The constraint evaluation will reject local trees if the constraints of the subtrees of the daughters are violated  . 
1 Introduction
First of all some fundamentals of a constructive version of GPSG which has been developed within the projects  K1T-NASEV and its successor KIT-FAST 2 will be described ( for details see\[ Hanen-1 LP = Linear Precedence ; FCR = Feature Co-o ecmenee Rstriction KIT-FAST ( FAST = Functor-Argument Structure for Translation  ; KIT = Kilnstliche Intelligenz Lind Textvexsteben = Artificial Intelligence and Text Understanding  ) as well as ils predecessor KIT-NASEV ( NASEV = Neue Analyse-und Synthese veffahrm zur mase hinelle a  0bersetzang = New Metheds of Analysis and Synthesisfc ~ Machine Translation  ) constitute he Berlin component of the complementary ~ h project of EUROTRA-D  , which reeeive ~ gnmts by the Federal Minister for Research and Technology undereontra~t  1013211  . 
738 schild/Busemann88\] , \[Keller87\] , \[Busemann87\] and\[Weis-weber87\]) . The reader's familarity with the fundamental knowledge of GPSG as presented in \[  GKPS85\] will be assumed . 
1.1 The Grammar Format
The ID/LP format of the grammar allows the explicit formulation of generalizations about the partial order of the daughters of the ID rules via LP statements  . ID rules are tuples of the form ( ( mother )  --- )   ( daughters ) ) , for example ( S~NP , VP ) , where ( daughters ) is a multiset of categories which can be dominated by the category  ( mother )  . Lexical rules are of the form ( ( mother )  ---?  ( wordform ) ) . 
LP statements are of the form ' ( category t )  <  ( categor Y 2 ) ' , for example the LP statement NP < VP requires that the category NP must precede the category VP in a sequence of daughters of any local tree licensed by an ID rule of the grammar  . 
For every grammar a set F = f ~, f2 . . . . . fn of syntactic features exists with IFI = n . The number ' n ' of features can vary from grammar to grammar  , but for a particular grammar it is constant . 
Each feature f i has its domain D(f i ) . A complex category C is an n-tuple with C~D ( f1 ) xD ( f2 ) x . . . xD ( f n ) and the position T of the tuple represents he value of the feature f i  . 
Example : F = N , VrBAR , PER , PLU , GEN position if eature fi domain D(fl ) 1N + , -2v + , -3BAR 10 , 1 , 24 PER 1 , 2 , 35 PLU + , -6 CAS nom , gen , dat , ecThe category C =\ [+ N , -V , BAR2 , nom\]will be represented as (+ , - , 2 , X , _ , nom ) . C is the category traditionally called a nominative NP  . If a feature Value of , a ea/tegory is not specified , like PERa~d//11 ?/ PLU in C , it will be noted as ~ variable 3 . ~ evalue of ~ feature fl of 3 A variable fature value will be noted as a capital letter  ( e . g . X , Y , Z ) when the same variable value is needed at another place  , otherwise it will be noted as ' . .
the category C can be expressed with C(fl ), e . g . C(CAS ) = nom or C(PER ) = X . It is possible that a feature can have a category as its value  , e . g . SLASH . 
In the following some predicates on feature values are used  . They are ' spec','atom ' and ' cat ' . The semantics of them is as follows : spec ( C ( f ) ) ?~ C ( f ) is specified either with an atomora category atom  ( C ( t ) ) ?~ C ( f ) is specified with an atom cat ( C ( f ) ) ?:~ C ( f ) is specified with a category 1 . 2 Feature lnstant iat ion The Feature Instantiation Principles  4 are not the subject of this paper . Only one thing needs to be said at this point , that is that the FIPs are not only regarded as filters for local trees as in \[  GKPS85\]  , but in the constructive version of GPSG they propagate values of features within a local tree from them other to the daughters and vice versa  , or from one daughter to another if this feature value is affected by one of the FIPs  ( i . e . it is a HEAD , FOOT or agreement feature ; a brief outline of the work which is done by the AP is given in section  2  . 1) . In this case the FIPs are construction principles which propagate information from one point of a local tree to possibly many other points which require this information  . In cases where a value is not specified ( i . e . it is a variable ), the variable is propagated . The FIPs are also filters for local trees and will reject local trees which have categories where the values of one of the features are not consistent  . 
Before discussing the Feature Cooccurrence Restrictions  ( FCRs ) two definitions are necessary to be able to define legal categories  . 
Definition : extension
A category E is the extension of a category C ( C  ~ E ) iff ( i ) VfeF : atom ( C ( f ) ) ~ atom ( E ( f ) ) A C ( f ) = E ( f ) 5 and ( ii ) VfeF : cat ( C ( f ) ) ::? . cat(E(f ))^ C(f)~_E(f )
Definition : unifiable
Two categories A and B are unifiable ( AIIB )  ?:~
Vf ~ F : ~ spec ( A ( f ) ) v ~ spec ( B ( f ) ) v ( ( atom ( A ( f ) ) A atom ( B ( t ) ) )  ~  ( Aft ) = B ( f ) ) ) v ( ( cat ( A ( f ) ) A cat ( B ( f ) ) )  ~  ( Aft ) ldB ( f ) ) ) The FCRs in the constructive version of GPSG are not only predicates on categories  , they are also modified to become more functional by instantiating variable feature values if necessary  . FCRs are implications of the form ( n , ADB ) . ' n ' is the number of this FCR , ' A ' is the condition category for the application of this FCR  4 I a the following they . are called FIPs . 1" he FIPs are the Foot Feature Principle ( FFP ) , the Agreement , Principle ( AP ) and the Head Feature Convention ( I-IFC )  . 
For detailed discussion of the FIPs see\[ Busemanng7\]  , \[ Hauenschild /
Busemann 881 and\[Weisweber87\].
5',,' v ' .  '-4 , ' ~' and ' ~' are the logical operators ' and ' , ' or ' , ' not ' , ' equivalence ' and ' implicatioff , respectively , and ' B ' is the consequence category . This FCR is applicable to a category C if C is an extension of A and  , if so , C has to be unifiable with B . If C and B are not unifiable the category C is not legal  . 
Definition : legal
A category C is legal ?: ~
V(n , A  ~ B ) EFCR : ( A  ~ C ) v ( A_ECAB 13C ) If the FCRs are applied to the category C and an FCR  ( n , ADB ) is applicable to C and the consequence category B is unifiable with C and at least one feature f exists where ~ spec  ( C ( f ) ) and spec ( B ( f ) )  ( B  ~ C )  , then all those values C ( f ) are instantiated with B ( f )   ( C ( f ) := B ( f ) ) . The FCRs have to be applied to a category C until no feature values of C are instantiated by them any longer  , because the instantiation may cause other FCRs to be applicable  . 
1.3 The Admissibility of Trees
To generate syntactic structures ( trees ) during analysis or synthesis , ID rules are mapped into local trees in which all categories a relegal  . 
This mapping is called a projection.
Definition : projection
The projection ? ~ ID ? LT is a relation from the set ID of ID rules to the set LT of local trees  . A tuple ( r , t ) is an element of ?(( r , t ) e ~) where r = ( r ' , C0-->Cl . . . . . Cn ) and _/?\ if fit meets the condition ~ ( C i ) = ~ with 0_<i , j ~ n where the total one-to-one , onto function ~ maps the set Co . . . . . C , ~ of categories of the ID rule r ' into the set C  ~   . . . . . C , t of categories of the local tree t : 0: Co . . . . . c . - ~ C6 . . . . . c ~ The function ? p meets the following conditions : ?  ( C0 ) = C~A ? p ( Ct ) = qA1 < i , j < nAV ~ ( Ck ) : 0 < k < nA ? ~ ( Ck ) is legala ( CkE_O ( Ck )   ) When a local tree has been proved to be a projection of an ID rule  , the FIPs are applied to it . Despite the fact that the projection already includes the application of the FCRs to the categories of a local tree  , they still have to be applied every time one of the FIPs  ( FFP , AP , HFC ) has been applied to the local tree , because a ch of them may instantiate a feature value of a category of the local tree and therefore another FCR may be applicable to that category  . The last check for admissibility is the application of the LP statements  . The sequence of the daughters of the local tree must not conflict with any LP statement of the grammar  ( it has to be LP-consistent )  . 
Before ' LP-consistency ' can be defined , the transitive LP-relation ( LP+ ) has to be defined . 
Definition : transitive LP . relation 1 )   ( Ci < Ca ) ? LP = ~ ( 121 ~ C2 ) ELP+2 )   ( C1  ~  C2 ) ? LP+A ( C ~ ~ C  ~ ) ELP ? AC~~_C2 =* ( C1 tC3 ) ? LP+consistenc ~' . 
Deflnitloni LP . consistency
A local treet is LP-consistent with respect o a grammar with the transitive LP-relation ~ iff 
VCI , C\]:1<ij<n^~precedes~-~3C\[ , Cj : Ci ~ C\[ACj ~_qA ( C j ~ : CI ) eLP + In other words , when a category C\[precedes a category Ojina local tree t  , they must not conflict with the transitive LP -relation  ( C \] , and must not be extensions of two categories CI and Cj  , respectively , where Cj must precede CI ) . 
Now the definition of the admissibility of trees can be given  . 
Definition : admissibility of trees
A tree is admissible iff all of its local trees are admissible  . A local tree is admissible iff it is a projection of a lexical rule or iff it-is the projection of an ID rule and-satisfies all of the FIPs and - is LP-consistent  . 
2 LP-Consistency and Legality
The first chapter of this paper illustrates how to build up the syntactic structure  ( a tree ) in the constructive version of GPSG , but it also sketches roughly the way this can generally be done in  , unification grammars . First of all complex categories are assembled to form a local tree and subsequently the feature values of the categories are instantiated by different procedures  ( for example in GPSG by the FIPs and in the Lexical Functional Grammar  ( LFG ) described in \[ Bresnan/Kaplan82\] by the evaluation of the f-descriptions )  . The admissibility of those local trees is determined by some predicates  ( in GPSG by the LP statements and the FCRs and in LFG by existential constraints with the operator ' = c ' and the negative xistential constraints with the special value ' none '  )  . These predicates can only be applied when particular feature values are specified  . But when the admissibility of a local tree is to be proved  , it cannot be guaranteed that all feature values have been locally instantiated  . In some cases it is possible that . a feature value is not locally instantiated rather that it is instantiated somewherels e in another local tree belonging to the complete tree and therefore the admissibility of a local tree is not a local matter any more  . 
In this chapter the problems which arise from checking the LP-consistency and the legality in the constructive version of GPSG are described in the sections  2  . 2 and 2 . 3 respectively . Section 2 . 4 briefly outlines the two possible solutions proposed by \[  Keller87\]  . But first of all a sample grammar is given to be used for examples  . 
2.1 A Sample Grammar
To illustrate the problems arising from checking the LP-consistency of a sequence of complex daughter categories and from ehecldng the legality of complex categories of a local tree  , a sample grammar is given here . 

The set of syntactic features is F = fl , f2, f3 . A category is a triple
CeD(fI)xD(f2)xD(f3).
Features : f , D(f , ) = a , b , c , d , ef2D(f2) = +'"* f3D(f3) = 1 , 2 , 3ID = (( a , X , l)--~Co , Y , 1) , ( c , Z , 2)) , (I ) (( b , X , _)~( d , Y , 3) , ( e , * , 1)) (2) Lexical rules : (( e , _ , _)--~e ) , (( d ~_ , _)--~d ) , (( c , - , _)--~cm ) , (( e , + J - - ~ c p ) LP = (_ , * , _) < (_ , + , _) , LP += (-- , * , -) ~ (- , +~) ,  . (1)(_,-,_3<(_:,_)(_,-,_)~C,*,-3,(2)
C , -,_) ~ C , +,_) (3)
FCR = (1, Co , -,_ . ) D(_ , _ , l )) ,  (2 , ( d , + , _)D (_ , _ , 2 ) )  Suppose that the feature f2 is an agreement feature and that a local tree t which is a projection of this ID rule has been constructed  , then the Agreement Principle ( AP ) forces X = Y = Z and therefore the
AP has to consider three cases 6: 1 ) If at least two values are instantiated with different values then the AP has to reject  ( the predicative iew of the F1Ps which is still preserved in the constructive rs ion of GPSG  )  . 
2 ) If at least one value is instantiated then the other variable values are instantiated with that value by the AP  ( propagation of instantiated feature values )  . 
3) If all values are not specified , i . e . they are variables , then the AP will identify all values with one variable  ( propagation of variable feature values )  . 
Whenever an admissible local treet is a projection of ID rule  ( 1 )  , the values of the feature f2(X , Y , Z ) have to be identical and we can apply case ( 3 ) to the local tree t . 
2.2 ID/LP Specific Problems
In this section only LP-consistency is considered and the legality of categories i ignored  . In some cases there are categories of local trees which have feature values not yet specified when the LP-consistency has to be checked  , and this possibly means that one or more ( transitive ) LP statements cannot be applied to the given sequence of daughters  . 
There axe two strategies for processing natural language with ID/LP grammars ODLPG  ) : 1 ) The indirect method , where an IDLPG is translated into an equivalent contextfree grammar  ( CFG )   ( see\[Kilbury 84\] )  . 
2) The direct method , where the ID rules and LP statements are used directly during processing  ( see\[Shieber84\] , \ [ Kilbury 84\] , [Dtrre/Momma85\] , \[Busemann87\] and\[Weisweber87\]) . 
No matter which method is used some problems arise  . Firstly the 6 For the sake of simplicity the AP of the constructive version of GPSG is not described in detail here  ( see footnote 4 )  , problems in using the indirect method are described  . Suppose ID rule ( 2 ) is to be translated into equivalent contextfree rules  . In order to do that , all permutations of the daughters have to be computed and the LP-consisteney of the resulting sequences has to be proved  . 
Tiros the possible candidates for contextfree rules are the following :  ( 2a )   ( ( b , X , _)---> ( e , * , l)(d , X , 3)) and (2b ) (( b , X , _)---)( d , X , 3)(e , * , l )) To prove the LP-consisteucy of (2a ) , ( C1~Ca ) must not be an element of LP+ , where C1~(d , X , 3) and CaE ( e , * , l ) . If such an element exists , the sequence of daughters in ( 2a ) is not LP-consistent and has to be rejected . The only candidate from LP+is (2) , but it cannot be applied because (_ , ~ , _)~( d , X , 3) , and so(2a ) is a valid contextfree rule . But when X is instantiated with '-' later on during processing  , the local treetl which is licensed by ( 2a ) has to be rejected because it violates the transitive LP statement  ( 2 )  . 
tl :/( b , -,_) . . . . > . .
( e , \] el ) ( d = 3)
The same problem arises when the direct method is used  . Suppose the string'ed cm'is to be analysed , After the terminal symbol'e'has been read , it . is reduced to(e , ~,_) . This category can be dominated in ID rule ( 2 ) b ~ canse ( e , _ , _) and ( e , * , l ) are unifiable . Then'd ' is read and reduced to ( d , _ , _ ) which can also be dominated in ID role ( 2 ) and it is unifiable with ( d , X , 3) . Nowtile daughters of ID rule ( 2 ) are complete and before they can be reduced to the mother category  ( b , X , 1) , the l , P-consistency of the sequence ' ( e , * , l)(d , X ~) ' as above has to be proved . For the above mentioned reason " , his sequence is LP-consistent and is reduced to ( b , X , 1) . This category can be dominated in ID rule ( 1 ) and up to this point the following partial tree t2 can be constructed . 
t'2:/(b , X , ~( a'X'1) ( c--~c , X , 2) ( d , ld , 3 ) Every local tree in the partial tree t 2 is LP-consistent . Now the telxninal symbol ' era ' is read and reduced to  ( c , - , _) . This category is unifiable with ( c , X , 2 ) in t 2 and the local treelicensed by a lexical rule can be added to ta  . Wlmn the two categories are unified 7 the variable X is instantiated with '-' everywhereint  2  . The result is that the sequence of daughters ' ( e , * , l)(d , - , 3)' is not LP-e on sistent any more , beeanse now it violates the transitive LP statement  ( 2 )  . If instead the next input symbol after the string ' ed'is'cp '  , no problems with the LP-consistency arise . 
2?3 FCR Specific Problems
Similar problems like those with the LP . .consistency appear when the FCRs are applied to the categories of a local tree  . Suppose that In the constructiversion of GPSG , unification is used for tree formation . In the version of \[ GKPS85\] the root category R of a subtree has to be identical with a & mghter category C of a local tree  ( i . e . R__ . C and C~R ) . 
the partial tree t2 has already teen constructed . All of its categories a relegal . 
Suppose that the next input symbol after the string'ed'is'cp'  . This terminal symbol is reduced to ( c , + , _) which can be unified with ( c , X , 2) in t . 2 and the variable X is instantiated with '+' . Thus all variables X in t ~ have to be replaced by '+' and the category  ( d , X , 3) becomes ( d , + , 3) . Now FCR2 is applicable because ( d , + , 3) is an extension of the condition category ( d , + , _)(( d , + , _)c(d , + , 3)) , but it is not unifiable with the consequence ategory  ( _ , _ , 2) (-~(( d , + , 3)\[J ( .   .   .   .  2 ) ) ) and thus it is not legal and has to be rejected . 
2.4 Two Possible Solutions
According to \[ Keller 87\] , the problems described in the sections 2 . 2 and 2 . 3 can be solved in two ways . One way would be to check the LP-consistency of all local trees and the legality of all categories after the entire tree for the input string has been constructed  . The other way would be to restric the grammar format and/or the FIPs  . 
The disadvantage of the former solution is its in efficency  . The checks have to be done in addition after the processing of the input string is terminated because some trees have not already been rejected  , although it would have been possible to do so . 
The disadvantage of the latter solution is made obvious by two examples  . The format of the categories , for example , can be restricted by assuring that them other category in a local tree is fully specified  , i . e . a feature must not have a variable as its value . This would involve a loss of the grammar's descriptive power  . Another way would be to restrict the FIPs by assuring that they don't propagate variable feature values  , which would involve GPSG losing some of its generality  . 
3 Constraints
In both cases ( LP-consistency and legality ) the problems are caused by categories of local trees which are not extensions of tile categories in the LP statements  o1" of the condition categories in the FCRs , but which have been unifiable with them . This is the case when a feature of a category of the local tree has a variable as its value and the same feature value is specified in the corresponding category of the LP statements or the FCRs  . 
This fact means that the LP statements or the FCRs are not locally applicable in some cases  , and so the admissibility of the local trees can only be assured with certain constraints which can be fulfilled later on  , when the variable is instantiated during processing  . 
3.1 Computing Constraints from LP
To compute the constraints resulting from the LP statements  , the abovementioned cases have to be first identified  . Suppose that the sequence ' AB ' of categories i to be checked for LP-consisteney and an LP statement B":<A'exists where B\[JB ' and B '\[~B and A ' ~_A  . 
This LP statement is not applicable to ' AB ' because B ' ~ B  , though B'HB . This means that at least one feature f exists , where spec(B'(f )) and -- , spec(B(f )) . Thus the sequence ' AB' is LP-with the above mentioned condition  , and since all values B ( fl ) for those features flare variables ( ~spec ( B ( f i ) ) )   , they must not be instantiated with the values B ' ( f i ) which are already specified . When the values B ( f i ) are instantiated by the FIPs or by the FCRs in the local tree  , there is no problem in determining the admissibility  . But when the variable feature values B ( f i ) are propagated to the mother by the FIPs , they can possibly be instantiated in another local tree and those variable values B  ( f i ) have to be constrained . 
Computing the set of constrqints LPc
When the LP-consistency of a sequence of daughters in a local treet is checked for every pair of daughters Q  , q , where 1 < i < j < n , the set LPc(i , j ) of LP constraints i computed as follows : 1 )  ~  ( C j ~ C i ) ELP+:Cj~~jjACi ~ C\[~t is not LP -consistent  2  ) V ( Cj ~: Ci ) ~ LP+: ( Cj LJ qAC j~q ) v ( C~L\]o , ^ c ~ ~ Cl ) t is LP-consistent with the LP constraints : LPc ( i , j ) = ( Oj(f ) , Cj(f )) lspec(Cj(f )) and ~ spec(Oj(f )) u(Q(0 , Ci ( f ) )l spec ( Ci ( f ) ) and ~ spec ( ~ ( f ) ) 3 ) --~= I ( C j ~ : C ) ELF+: ( Cj L\]C^C ~ IJ q ) t is LP-consistent with LPc ( i , j ) = LPc(i , j ) is a set of tuples ( Vt , Vp ) of feature values . Vt is the variable feature ~ , alue of a category of a local tree . Vp is the specified feature value of the LP statement which will become applicable to the corresponding daughters of the subtree if the values V t of all tuples in LP c  ( i d ) are specified and equal to their corresponding values Vp  . 
In this case the subtree has to be rejected.
The set of all LP constraints LPc ( 0 ) for the ' local tree in which C~is the mother category is  ?1 LPc ( 0 ) = LPc ( i , j)\[1<i<j < nu ; L . ) 4eval_lp ( LPc ( i ) ) where eval_lp ( LPc ( i ) ) is the evaluation of the LP constraints of the subtree in which the daughter ~ is the root category  . The set of LP constraints of a projection of a lexical rule is LPc  ( 0 )  =  , since lexical rules have only one daughter ( a wordform )  . 
The evaluation ' eval_lp '
The evaluation ' evall p ' is either defined or undefined  (  . 1 . ) . If it is undefined , the corresponding local tree is rejected , because one of the subtrees of the daughters of that local tree is not LP-consistent  . 
1) eval_lp(LPc(i )) = . L ? : ~3C ? LPc(i ) : ( V(V t , V2 ) EC:spec ( V1 ) Aspec ( V2 ) ^ V1 = V2 )  2 ) eval_lp ( LPc ( i ) ) = LPc ( i ) -C~LPc ( i ) l3 ( V1 , V2 ) ~C : spec ( V0 Aspec ( V2 ) AV1 ~ V23 ) ev all p ( LPc ( i ) ) =  CI ( C = C'-M ) ^C " ~ LPc ( i ) ^ C ? where M = ( Vl , V2 ) \[spec ( V1 ) ^ spec ( V2 ) AV1 = V2 The first case ( 1 ) means that if one set C of tuples exists in the set LPc  ( i ) of one daughter of the local tree , where all values of all tuples are specified and equal  , then an LP statement will be applicable somewhere in the subtree of this daughter  , and it will reject the subtree because some sister categories in the subtree are not LP -consistent anymore  . 

The second case ( 2 ) removes all sets S of tuples from LPc ( i ) of one daughter which include one tuple with two different specified values  . This means that the LP statement which has caused the computation of S will not be applicable anymore  . 
The third case ( 3 ) removes all tuples with two equally specified values from all sets of tuples in LPc  ( i ) of one daughter , because they need not be evaluated for a second time  . 
3.2 Computing Constraints from FCRs
To compute constraints resulting from FCRs , the categories have to be identified which are not an extension of a condition category of an FCR  , but unifiable with it . Suppose that the FCRs are to be applied to the category C  , and that an FCR(n , A~B ) exists where A\[3C and A~C . The FCR'n'is not applicable to C . This may change if a feature value is instantiated  . It is the same situation as in section 3 . 1 , but here the computing of constraints i somewhat different  , because the application of an FCR to a category may cause that another FCR will become applicable to that category  . FCR constaa ints only have to be computed when ~ ( BL\]C )  , or Bl_JC and B~C ( the case ~ ( BHC ) means that if the FCR will be applicable to C , it will reject C , and the second case means that if the FCR will become applicable to C  , it will instantiate one or more features in C , but the category always remains legal with respect to this FCR  )  . The case ~( BIIC ) is the crucial one , because the legality of the category C can only be assured with the constraint that the set of possibly applicable FCRs  , with the abovementioned conditions on the consequence a tegory  , still have to be checked for applicability . 
Computing the set of constraints FCRc
For all categories C\[where 0 < i < n in a local tree t the set APP ( i ) of all numbers of FCRs which may still be applicable to Q is computed as follows:  1  )  3  ( k , ADB ) ~FCR:AEQA - ~ ( B\[3CD = ~ CI not legal 2 ~ V ( k ) A  ~ B ) ~FCR:ALJ q^A~qA ( -~ ( BL\]q ) v ( ( B LJ CD ^ ( B ~ q ) ) ) ~ qlegal and k ~ AFP ( i )  3 ) V ( k , A  ~ B ) ~ FCR : ~ ( ALJ q ) v ( A_EC ) ^BIIq ) q is legal and APP ( i ) = The set of all FCR constraints FCRc ( 0 ) for the local tree in which C8 is them other category is where evalf cr ( FCRc ( 1 ) ) is the evaluation of the FCR constraints from the subtree in which the daughter q is the root category  . 
FCRc(0) is a set of tuples ( Ci , APP(i)) . C i is a copy of a category of the subtree in which C  8 is the root category and APP ( i ) includes the numbers of all FCRs which may still be applied to Ci if particular feature values of this category are going to be instantiated  . The only new set APP in a local tree is computed from them other  ) because the evaluation of the FCR constraints on the subtre~s of the daughters includes the application of the applicable FCRs to the daughter categories  ( because they are the root categories of the subtrees  )  . Thus the remaining tuples of the daughters and their subtrees will be computed by the evaluation  . The set of FCR constraints on a projection of a lexical rule is FCRc  ( 0  )  =  ( C  ~ , 

The evaluatim ~' evalj cr '
The evaluation ' eval for ' is either defined or undefined  (  . L ) . If it is undefined , the con'esponding local tree is rejected , because one or more categories of the subtrees of the daughters of that local tree are not legal  . 
1) evalf cr(FCRc(i )) = . L ? = : , 3(C , APP)~FCRc(i ): keAPP^(k , A ~ B)eFCR^AcC^- , ( B\[JC ) 2) evalf cr(FCRc(i )) = ( C , M ) I(M = APP-S )^( C , APP)eFCRc(i ) ^ Me where S = k\[(k , A  ~ B ) eFCR ^ ( -~ ( AHC ) v ( Ac_C^B\[JC ) ) The first case ( 1 ) means that if the set FCRc ( i ) of a subtree of one daughter C\[includes one tuple  ( C , APP ) in which the category C is not legal with respect othe FCR  ( k , A  ~ B ) where ' k ' is in the set APP of numbers of FCRs , then the subtree has to be rejected , because the category C in this subtree is no longer legal  . 
The second case ( 2 ) removes all the numbers ' k ' of FCRs from the set APP of all tuples in FCRc  ( i )  , where the FCR(k , ADB ) is no longer applicable to the category Cor where it has been successfully applied to the corresponding category  . 
3.3 Evaluation and Propagation
After a local neet has been proved to be a projection of an ID rule  , all F1Ps are applied to t , the FCRs to its mother , and the set APP ( 0 ) of the numbers of all FCRs which possibly will be applicable to them other  , is computed . After that the FCR constraints on the subtrees of the daughters are evaluated  , which means that all applicable FCRs are applied to the daughters and to all other categories of their stth trecs  . The remaining FCR constraints from the evaluation  , and the FCRcon :; traint(C ~ , APP(0)) on the mother , will then be combined to form the new FCR constraint set FCRc  ( 0 ) on the gubtree in which C~is the root category . The new FCR constraint set is propagated to the mother  . 
Next the LP- . consistency of the daughters has to be checked , and during this check the new LP constraints on the daughters are computed  . These constraints are combined with the LP constraints resulting fl'om the evaluation of the LP constraints on the subtrees of the daughters  , to form the entire set of LP constraints LPc ( 0 ) on the subtree in which C/~is the root category which is then also propagated to the mother  . 
4 Conclusion
With this method of constraint computation , evaluation and propagation , " a new definition of the admissibility of trees is necessary  . 
Definition : admissibility of trees
A tree is adndssible iff all of its local trees are admissible and the evaluations ' evalf cr ' and ' evall p ' of constraints of the root category are defined and both are the empty set  . A local treet is admissible iff it is a projection of a lexical rule or iff it-is a projection of an ID rule with the FCR constraint  ( C  ~ , APP ( 0 ) ) on the mother C /~ and - satisfies all of the FlPs and - is LP-consistent with the LP constraints LPc  ( i , j ) on all daughters C\[and ~ which , are propagated to them other where 1 _ < i < j < n and - the evaluation ' eval_fcr ( FCRc ( i ) )' of every daughter C \[ isdef ined where 1 ~ i < n and their results are propagated to the mother and - the evaluation ' eval_lp  ( LPc ( i ) )' of every daughter C i is defined where 1 ~ i ~ n and their results are propagated to the mother  . 
The consequence for the root category R of an entire tree of one input string of a natural anguage will be the fact that all features fi of R  , where ~ spec(R(f i )) , and where fl is needed for the evaluation of the constraints of the tree  , have to be instantiated according to their domain D  ( f i ) because such a tree represents a class of ambiguou solutions  . After that the constraints on every tree of this class are evaluated and only the trees where FCRc  ( 0  ) and LPc ( 0  ) are defined and their evaluation is are admissible  . 
References\[Barton85\]:G . E . Barton Jr . ; " The Computational Difficulty of ID/LP Parsing  "  ; 23rd Ann . Meet . of the ACL at University of Chicago ; Chicago 1985\[Bresnau/Kaplan82\]:J . Bresnun , R . M . Kaplan ; " Lexical Functional Grmnmar : A Formal System of Grammatical Representation "  ; i : MIT Press Series on Cognitive Theory and Mental Repr  . pp . 173-28I ; Cambridge 1982\[Busemann 87\]: S . Busemann ; " Generierungmit GPSG "; in : K . Morik ( ed . ) Proceedings of the llth German Workshop on Artifical Intelligence pp  . 355-364 ; Springer-Verlag ; Geseke 1987\[Busemann/Hauense hild88\]:S . Busemann , C . Hauenschild ; " A Constructive View of GPS Gor How To Make It Work "  ;   12th International Conference on Computational Linguistics  , Budapest 1988\[DSr re/Momma 851: J . D ~ rre , S . Momma ; " Modifikation endes Earley-Algorithmus undihre Verw endungflitID/LP-Grammatiken "  ; Manuscript of the Department for Linguistics / Romanistics at the University of 
Stuttgart 1985\[GKPS85\]:G . Gazdar , E . Klein , G . Pullum , I . Sag ; " Generalized Phrase Structure
Grammar " ; Oxford ; Blackwell 1985\[Hanenschild/Buse , nann 88\]:C . Hanenschild , S . Busemann ; " A Constructive Version of GPSG for Maschine Translation " in Steiner  , Schmidt , Zelinsky-Wibbelt ( eds . ) " From Syntax to Semantics - Insights from
Maschina Translation " , Frances Pinter\[Karttunen84\]:L . Karttunen ; "D-PATR : A Development Environment for Unification-Based Grammars "  ; llth International Conference on
Computational Linguistics , Bonn 1986\[Keller 87\]: W . Keller ; " An Overview of the Project NASEV Parser " ; Manuscript , 
University of Sussex 1987\[Kilbury 84\]: J . Kilbury ; " Earley-basierte Algorithmenfilr direktes Parsenmit ID/LP-Grammatiken "  ; KIT-Report 16 ; T ( . I Berlin 1984\[Ristad86\]:E . S . Ristad ; " Computational Complexity of Current GPSG Theory  "  ; 24th Ann . Meet . of the ACL at Columbia University ; New York 1986\ [ Shieber 84\]: S . M . Shieber ; "Direct Parsing of ID/LP Grammars " ; Linguistics and
Philosophy 71984 pp . 135-154\[Shieber 86 al : S . M . Shieber ; " An Introduction to Unification-based Approaches to Grammar "  ; CSLI Lecture Notes Number 4 , Ventura Hall , Stanford
University , Stanford 1986l Shieber 86b\]:S . M . Shieber ; " A Simple Reconstruction fGPSG " ; Proceedings of the llth International Conference on Computational Linguistics  ; Bonn 1986 pp . 211-215 ?\[ Weisweber 87\]: W . Weisweber ; "E in Dominanz-Chart-Parser fiir genemlisierte Phrasenstrukturgrammatiken "  ; KiT-Report 45 , TU Berlin
