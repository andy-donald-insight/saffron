LHIP : Extended DCGs for Confignrable Robust Parsing * 
Afzal Ba \] lim Graham Russell
ISSCO , University of Geneva , 54 Routedes Acacias , Geneva , CH-1227 Switzerland
emai hafzal@divsun . unige . ch , russell@divsun . unige . ch
Abstract
We present LHIP , a system for incremental grammar development using an extended DCG formalism  . ' rite system uses a robust is land-based parsing method controlled by user-defined performance thresholds  . 
Keywords : I ) CG , head , island parsing , robust parsing , Prolog 1 LHIP Overview This paper describes LII II' ( Left-Ilead corner Island Parser )  , a parser designed for broadcoverage handling of lm restricted text  . The system interprets an extended DCG formalism to produce a robust analyser that finds parses of the input made from ' islands ' of terminals  ( corresponding to terminals consumed by successful grammar rules  )  . It is currently in use for processing dialogue tr , 'm scripts from the tICRC Map Task Corpus ( Anderson et al ,  1991) , although we expect its eventual applications to he much wider  .   1 Transcribed natural speech contains a number of frequent characteristic ' un-grmnmatical ' phenomena : filled pauses  , repetitions , restarts , etc . ( asine . g . RightI'll have .   .   . you know , like I ' ll have to .   .   . so I'm going between the picket fence and the mill  , right . ) . ~While a full analysis of a conversation might well take these into account  , for many purposes they represent a signific mlt obstacle to analysis  . LIIIP provides a processing method wl fich allows selected portions of the input to be ignored or handled differently  . 
The chief modifications to the standard Prolog * gramma rule ' format are of two types : one or more rlght-hand side  ( RtIS ) items may be marked * This work was carried out under grants no s  .  20-33903 . 92 and 12-36505 . 92 from the Swiss National

tNote that the input consists of wr/t ten texts within the Map Task Corpus  ; LtIIP is not intended for use in speech processing  . 
2This example is taken fronlthe MapTask Corpus.
as ' heads ' , and one or more RHS items may be marked as ' ignorable '  . We expand on these points and introduce other differences below  . 
The behavior lr of LHIP can bes the understood in terms of the notions of island  , span , cover and threshold : Island : Within an input string consisting of the terminals  ( tl , t2 ,   .   .   . tn ) , ~ island is a subsequence ( ti , ti+l ,   .   . , ti+,,), whose length is m+1 . 
Span : The span of a grammar rule R is the length of the longest is l and  ( tl ,   .   .   . tj ) such that tern finals tl and t i are both consumed  ( directly or indirectly ) by R . 
Cow . ' r : A rule R is said to cover m items if rn terminals are consumed within the island described by R  . The coverage of R is then rn . 
Threshold : The threshold of a rule is the minimum ~  ; alue for the ratio of its coverage c to its span s which must hold in order for the rule to succeed  . Note that c <_ s , aud that if c--s the rule has completely covered the span  , consuming all terminals . 
As implied here , rules need not cover all of the input in order to succeed  . More specifically , the constraints applied in creating islands are such that is hmds do not have to be adjacent  , but may be separated by non-covered input . Moreover , an island may itself contain input which is unaccounted for by the grammar  . Islands do not overlap , although when multiple an Myses exist they will in general involve different segmentations of the input into islands  . 
There are two notions of non-coverage of the input : sanctioned and unsanetloned non-coverage  . The latter case arises when the grammar simply does not account for some term in M  . 
S~mc tioned non-coverage means that some number of special ' ignore ' rules have been applied which simulate coverage of input materialying between the ish ' mds  , thus in effect making the islands contiguous . Those parts of the input that have been ' ignored ' are considered to have been dividually or as a class  . It is this latter capability which distinguishes ignore rules from regular rules  , as they are functionally equivalent otherwise , mainly serving as a notation alaid for the grammar writer  . 
Strict adjacency between RHS clauses can be specified in the grammar  . It is possible to define global and local thresholds for the proportion of the spanned input that must be covered by rules  ; in this way , the user of an LHIP grammar can exercise quite fine control over the required accuracy and completeness of the analysis  . 
A chart is kept of successes and failures of rules  , both to improve efficiency and to provide a means of identifying unattached constituents  . In addition , feedback is given to the grammar writer on the degree to which the grammar is able to cope with the given input  ; in a context of grammar development , his may serve as notification of areas to which the coverage of the grammar might next be extended  . 
The notion of ~ head'employed here is connected more closely with processing control than linguistics  . In particular , nothing requires that a head of a rule should share any information with the LItS item  , although in practice it often will . 
Heads serve as anchor-points in the input string around which islands may be formed  , and are accordingly treated before nonhead items ( RHS items are reordere during compilation-see below  )  . In the central role of heads , Lt IIP resembles parsers devised by Kay ( 1989 ) and van Noord ( 1991 )  ; in other respects , including the use which is made of heads , the approaches are rather different , however . 
2 The LHIP System
In this section we describe the LHIP system.
First , we define what constitutes an acceptable LHIP grammar  , second , we describe the process of converting such a grammar into Prolog code  , and third , we describe the analysis of input with such a grammar  . 
LHIP graxnmars are an extended form of Prolog DCG graznmars  . The extensions can be summarized as follows : a1 . one or more \[ tHS clauses may be nominated as heads  ; Z A version of LHIP exists which permits a form of negation on RHS clauses  . That version is not described here . 
2 . one or more P~tlSclauses may be marked as optional  ;  3 . ' ignore ' rules may be invoked ; 4 . adjacency constraints may be imposed between l ~tIS clauses  ;  5 . a global threshold level may be set to determine the minimum fraction of spanned input that may be covered in a parse  , and 6 . a local threshold level may be set in a rule : to override the global threshold witl f in that " ru le  . 
We provide a syntactic definition ( below ) of a LHIP gramma rule , using a notation with syntactic rules of the form C - ~  F1 I i f2--- IF nwtfich indicates that the category C may take any of the forms  F1 to F , ~ . An optional item in a form is denoted by surrounding it with square brackets '\[  .   .   .  \ ] '  . Syntactic categories are italieised , while term in Ms are underlined : ' .   .   .  '  . 
ALtl IP gran una rule has the form : lhi V rute ~\ [-\] term\[#T\]~~__~>U~i ~ bodywhere T is a value between zero and one  . If present , this value defines the local threshold fraction for that rule  . This local threshold value over rules the global threshold  . The symbol '-' before tile name of a rule marks it as being an ' ignore ' rule  .   0nly a rule defined this way can be invoked as an ignore rule in an RHS clause  . 
lhip body => lh.ip clause
II hip clause zlhip body flhip clause ; lhipbody
I lhip clause-lhip body
I(~_"lhip body ?_))
The connectives ' , ' and ~; ~ have the same precedence as in Prolog , while ~'' has the same precedence as ~' . Parentheses may be used to resolve ambiguities . The connective ' ~' is used to indicate that strings subsumed by two RHS clauses are ordered but not necessarily adjacent in the input  . Thus'A ~ /3' indicates that A precedes I3 in the input , perhaps with some intervening material . The stronger constraint of immediate precedence is marked by ':'  ; ' A : B ' indicates that the span of A precedes that of B  , and that there is no 1recovered input between the two . Disjunction is expressed by ~' , and optional R/IS clauses are surrounded by ' (  ?  .   .   .  ?)'  . 
502 lhip clause ~ temn?te ~ nn ~ . string ? . _ ~ string-term\[\] ~ r do a eod ~__ The symbol '* ' is used to indicate a head clause  . A rule name is a Prolog term , and only rules and terminal items may act as heads within a rule body  . The symbol '@' introduces a ter-minM string . As previously said , the purpose of ignore rules is simply to consume input terminals  , and their intended use is in facilitating repMrs in analysing input that contains the false starts  , restarts , fdled pauses , etc . mentioned above . These rules are referred to individually hy preceding their name by the '-' symbol  . They can also be referred to as a class in a rule body hy the speciMI ~  . tIS clause '\[\]' . If used in a rule body , they indicate that input is potentially ignored -the problems that ignore rules are intended to repair will not always occur  , in which case tile rules succeed without conslmfing any input  . There is a semantic restriction on the body of a rule which is that it must contain at least one clause which necessarily covers input  ( optional clauses and ignore rules do not necessarily cover input  )  . 
The following is an example of a Lt IIP rule.
Here , the subrule ' conjunction ( Conj ) ' is marked as a head and is therefore valuated before either of  , s(s )) ' or's(S0':s(conjunct(Conj , SI , Sr )) ~> s(St ) , * conjunct lon(Conj ) , s(S ~) . 
tIow is such a rule converted into Prolog code by the LHIP system ? First  , the rule is read and the RHS clauses are part it ioned into those marked as heads  , and those not . A record is kept of their original ordering , and this record allows each clause to be constrMned with respect to the clause that precedes it  , as well as with respect to the next head clause wM ch follows it  . 
Additional code is added to maintain a chart of known successes and failures of each rule  . Each rule name is turned into the name of a Prolog clause  , and addltion M arguments are added to it . 
These arguments are used for the input , the start and endpoints of the area of tlm input in which the rule may succeed  , tile start and endpoints of the actual part of the input over which it in fact succeeds  , the number of terminal items covered within that island  , a reference to the point in the chart where the result is stored  , and a list of pointers to sub-results . The converted form of tile above rule is given below  ( rMnus the code for chart maintenance ) : s ( conjunct ( H , I , J ) , A , B , C , D , E , F , 
ELIK\]-K , G ) :- lhip_threshold valuo(M) , conjunction(H , A , B , C , O , P , Q , 
RS ,_), s(l,A,B,fl,D,_,T,CR,_).
s(J,A.P,C,~,E,U,s-E l,_),
F is U+Q+T ,

The important points to note about this con-vetted form are the following :  1  . the conjunction clause is searched for before either of the two sclauses  ;  2 . the region of the input to be searched for the conjunction clause is the stone as that for the rule's LIIS  ( B C ) : its island extends from 0 top and covers Q items ;  3 . the search region fortile firsts clause is B -0 ( i . e . from tile start of tile LHS search region to tile start of the conjunction island  )  , its island starts at D and coversTitems ; 4 . the search region for tile seconds clause is PC ( i . e . from the end of the conjunction island to the end of the LIIS search region  )  , its islandends at E and covers II items ; 5 . the island associated with the rule as a whole extends from D to E and covers F items  , where F is U+Q+T ; 6 . lhip_throshold_value/lunifies its argument M with the current global threshold value  . 
In the current implementation fLI\[IP , compiled rules are interprete depth-first and left-to-right by the standard Prolog theorem -prover  , giving an an Myser that proceeds in a topdown , qeft-head-corner ' fashion . Because of the reordering carried out during compilation  , the situation regarding left-recursion is slightly more subtle than in a conventional DCG  . The ' s(conjunct ( . . . ))' rule shown above is a case in point . While at first sight it appears left-recursive , inspection of its converted form shows its true leftmost subrule induce left-recursion as well as eliminating it  , in which case LIIIP will suffer from the same termination problems as an ordinary DCG formalism interpreted in this way  . And as with an ordinary DCG formalism , it is possible to apply different parsing methods to LHIP in order to circumven these problems  ( see e . g . Pereira and Shieber , 1987) . A related issue concerns the in-terp retation of embedded Prolog code  . Reordering of lZHS clauses will result in code which precedes a head within a LtHP rule being evaluated after it  ; judicious freezing of goals and avoidance of unsafe cuts are therefore required  . 
LHIP provides a number of ways of applying a grammar to input  . The simplest allows one to enumerate the possible analyses of the input with the grammar  . The order in which the results are produced wi U reflect the lexical ordering of the rules as they are converted by LHIP  . With the threshold level set to 0 , all analyses possible with the grammar by deletion of input terminals can be generated  . Thus , supposing a suitable grammar , for the sentence John saw Mary and Mark saw them there would be analyses corresponding to the sentence itself  , as well as John saw Mary , Johnsaw Mark , John saw them , Mary saw them , 
Mary and Mark saw them , etc.
By setting the threshold to 1 , only those par-tial analyses that have no unaccounted for terminals within their spans can succeed  . Hence , Mark saw them would receive a valid analysis , as would Mary and Mark saw them , provided that the grammar contains a rule for conjoined NPs  ; John saw them , on the other hand , would not . As this example illustrates , a partial analysis of this kind may not in fact correspond to a true subparse of the input  ( since Mary and Mark was not a conjoined subject in the original  )  . Some care must therefore be taken in interpreting results  . 
A number of built-in predicates are provided which allow the user to constrain the behaviour of the parser in various ways  , based on the notions of coverage , span and threshold : lhip_phraso(+C , + S ) Succeeds if the input S can be parsed as an instance of category C  . 
lhip_cv_phrase(+C,+S )
As for lhip_phrase/2 , except that all of the input must be covered . 
lhip_phrase(+C,+S,-B,-E,-Coy)
As for lhip_phrase/2 , except that B binds to the beginning of the island described by this application of C  , Ebinds to the position immediately following the end  , and Coybinds to then tunber of tern finals covered  . 
lhip_mc_phrasos(+C,+S,-Coy,-Ps )
The maximal coverage of $ by C is Cov . Ps is the set of parses of S by C with coverage Coy  . 
lhip_rain max_phrases (+ C , + S , -Coy , -Ps ) As for lh ? p_mc_phrases\]4 , except that Ps is additionally the set of parses with the least span  . 
lhipseq_phrase(+C,+S,-Seq)
Succeeds if Soq is a sequence of one or more parses of S by C such that they are nonoverlapping and each consumes input that precedes that consumed by the next  . 
lhipmax T_phrasos (+ C,+S,-MaxT )
MaxT is the set of parses of S by C that have the tfighes threshold value  . On backtracking it returns the set with the next highesthreshold value  . 
In addition , other predicates can be used to search the chart for constituents that have been identified but have not been attached to the parse tree  . These include : lhip_successLists successful rules  , indicating island position and coverage . 

As for lhip_success , but list souly the most specific successful rules  ( i . e . those which have themselve succeeded but whose results have not been used elsewhere  )  . 
lhip_ms_success(N )
As for lhip_ms_succoss , but lists only successful instances of rule N . 
Even if a sentence receives no complete analysis , it is likely to contain some parsal fle substrings  ; results from these are recorded together with their position within the input  . By using these predicates , partiM but possibly useful information can be extracted from a sentence despite a global failure to parse it  ( see section 4 )  . 
The conversion of the grammar into Prolog code means that the user of the system can easily develop an Mysis tools that apply different constraints  , using the tools provided as building blocks . 
5043 Using LHIP
As previously mentioned , LHIP facilitates acyclic approach to grammar development  . Suppose one is writing an English grammar for the Map Task Corpus  , and that the following is the first attempt at a rule for noun phrases  ( with appropriate rules for determiners and nouns ) : up ( N , D , A ) #0 . 5  , -~--~> determiner(D ) , * no , ,n ( N ) While tiffs rule will adequately an Myse simple NPs such as your map  , or a missionary camp , on a NP such as the bottom right hand corner it will give analyses for the bottom  , the right hand and the corner . Worse still , in a long sentence it will join determiners from the start of the sentence to nouns that occur in the latter hMf of the sentence  . The number of superfluous an Myses can be reduced by imposing a local threshoh level  , of say 0 . 5 . By looking at the various analyses of sentences in the corpus  , one can see that this rule gives the skeleton for noun phrases  , but from the fraction of coverage of these parses one c  , ' m also see that it leaves out an importmlt feature  , adjec-fives , which are optionally found in noun phrases . 
np(N,D,A ) #0 . 5 ~ , - ~> determiner(D ) , (? adjectives(A )?) , * noun(N ) . 
With rids rule , one can now handle such phrases as the lefthand bottom corner  , and abanana tree . Suppose further that this rule is now applied to tile corpus  , and then the rule is applied again but with a local threshold level of  1  . 
By looking at items parsed in the first case but not in the second  , one can identify features of nolm phrases found in tlle corpus that are not covered by the current rules  . T iffs might include , for instance , phrases of the form a slightly dip-pingline . One can then go hark to the grammar a zld see that the noun phrase rule needs to bcchanged to account for certain types of modifier including adjectives and adverbial modifiers  . 
It is Mso possible to set loom thresholds dynamically  , by making use of the ' prolog code ' facility : np  ( N , D , A )  #T  ~ , ,~> determiner(D ) , (? adjectives(A )?) ,  *  . o  ~ . ( N ) . 
set_dynamic_threshold(A,T).
In this way , the strictness of a rule may be varied according to information originating either within the part icular un-time invocation of the rule  , or elsewhere in the current parse . For example , it would be possible , by providing a suitable definition for set_dynamic_threshold/2  , to set T to 0 . 5 when more titan one optional adjective has been found  , and 0 . 9 otherwise . 
Once a given rule or set of rules is stabl % and tile writer is satisfied with the performtmce of that part of the grammar  , a local threshold value of 1 mayb c assigned so that superfluous parses will not interfere with work elsewhere  . 
The use of the chart to store known results and failures allows the user to develop hybrid parsing techniques  , rather than relying on the default depth-first topdown strategy given by analysing with respect o the topmost category  . 
For instance , it is possible to an Mysethein put in ' layers ' of linguistic categories  , perhaps starting by analysing noun phrases , then prepositions , verbs , relative clauses , clauses , conjuncts , and finally complete sentences . Such a strategy allows the user to perform processing of results between these layers  , w : hich can be useful in trying to find the ' best ' analyses first  . 
4 Partial results
The discussion of built-ln predicates mentioned facilities for recovering partial parses  . Here we ilhlstrate this process , and indicate what further use might be made of tile information titus obtained  . 
In the following example , tile chart is inspected to reveal what constituents have been built during at ~ iled parse of the truncated sentence Have you the tree by the brook that  .   .   . :> lhip_phrase(~(S ) , \[ have , you , the , tree , by , the , brook , that\]) . 
no > lhip success.
(- I )  \[7--8 ) /I "*> Obrook ( -1 )  \[5--6 ) /I "'> ? by ( -I )  \[1--2 ) /I "'> e have ( - i )  \[8--9 ) /2-->? that ( -1 )  \[3--4 ) /2"'> O the ( - i ) \[6--Z ) /I "'> e the ( -1 )  \[2--3 ) /1"'> ? you ( 4 )  \[2--8 ) 14--> np ( nppp ( you , pp(by , np(the , brook , B )))) (4)\[3--8)/5"'> np(nppp(np(the , tree , C ) , pp(by , np(the , brook , D )))) (5)\[3--8)/2"'> rip(rip(the , brook , A )) (5)\[6--8)/2"'> np(np(the , brook , G )) (5)\[3--5)/2"'> np(np(the , tree , E )   )   ( 7 )  \[4--5 ) /I "'> noun ( tree )   ( 8 )  \[7--8 ) /I "'> noun ( brook )   ( 9 )  \ [2 - -3 ) l1"'> np ( you )   ( 10 )  \[5--8 ) /3 - -> p p ( pp ( by , np(the , brook , F ) ) )   ( 11 )  \[3--4 ) /l "'> det ( the )   ( 11 )  \[6--7 ) /1"'> det ( the ) yes Each rule is listed with its identifier ( '-1' for lexical rules )  , the island wtfich it has analysed with beginning and ending positions  , its coverage , and the representation that was constructed for it  . 
From this output it can be seen that the grammar manages reasonably well with noun phrases  , but is unable to de M with questions ( the initial auxiliary have remains unattached )  . 
Users will often be more interested in the successful application of rules which represent maximal constituents  . These are displayed by lhip_ms_succoss :> lhip_ms_success  . 
(-1 )  \[1--2 ) /1"'> ? have ( -1 )  \[8--9 ) /1"'> ? that ( 4 )  \[2--8 ) /4--> np ( nppp ( you , pp(by , np(the , brook , J )))) (4)\[3--8)/5"'> np(nppp(np(the , tree , I ) , pp(by , np ( the , brook , I )))) (5)\[3--8)/2"-> np(np(the , brook , K )) yes Here , two unattached lexical items have been identified  , together with two instances of rule 4 , which combines a NP with a postmodifying PP . 
The first of these has analysed the island you the tree by the brook  , ignoring the tree , while the second has analysed the tree by the brook  , consuming all terminals . There is a second analysis for the tree by the bTvok  , due to rule 5 , which has been obtained by ignoring the sequence tree by the  . From this information , a user might wist t to rank the three results according to their respective span : coverage ratios  , probably preferring the second . 
5 Discussion
The ability to deal with large amomlts of possibly ill-formed text is one of the principal objectives of current NLP research  . Recent proposals include the use of probabil is tic methods  ( see e . g . 
Briseoe and Carroll ,  1993 ) and large robust deterministic systems like Hindle's Fidditch  ( Hindle ,  1989) .   4 Experience so far suggests that systems like LII IP may in the right circumstances provide an alternative to these approaches  . It combines the advantages of Prolog-interpreted DCGs  ( ease of modification , parser output suitable for direct use by other programs  , etc . ) with the abil ity to relax tile adjacency constraints of that form & llsm in a flexible and dynamic manner  . 
LIHP is based on the assumption that partial results can be useful  ( often much more useful than no result at all )  , and that an approximation to complete coverage is more useful when it comes with indications of how approximate it is  . 
This latter point is especially important in cases where a grammar must be usable to some degree at a relatively early stage in its development  , as is , for example , the case with the development of a grammar for the Map Task Corpus  . In the near future , we expect to apply LHIP to a different problem , that of defining a restricted language for specialized parsing  . 
The rationale for the distinction between sanctioned and unsanctioned non-coverage of input is twofold  . First , the qgnore ' facility permits different categories of unidentified input to be distinguished  . For example , it may be interesting to separate material which occurs at the start of the input from that appearing elsewhere  . Ignore rules have a similar flmctionality to that of normal rules  . In particular , they can have arguments , and may therefore be used to assign a structure to unidentified input so that it may be flagged as such within an overall parse  . Secondly , by setting a threshold value of 1 , LtIIP can be made to perform llke a standaxdly interpreted Prolog DCG  , though somewhat more efficiently a Indeed , the ability of Fidditch to return a sequence of parsed but unattached phrases when a global analysis fails has clearly influenced the design of LHIP  . 
506 due to the use of the chart.~
A number of possible extensions to the system can been v is aged  . Whereas at present each rule is compiled individually  , it would be preferable to enhance preprocessing in order to compute certain kinds of global information from the grammar  . One improvement would be to determine possible linking of ' root-to-head'sequences of rules  , and index these to terminal items for use as an oracle during an Mysis  . A second would be to identify those items whose early analysis would most strongly reduce the search space for subsequent processing and sc  , ' m the input to begin parsing at those points rather titan proceeding strictly front left to right  . This further suggests the possibility of a parallel approach to parsing  . 
We expect that these measltres would increase the efficiency of LHIP  . 
Currently , also , results are returned in an order determined by the order of rules in the grammar  . 
It would be preferable to arrange matters in a more cooperative fashion so that the best  ( those with the highest coverage to span ratio ) are displayed first . Support for bidirectional parsing ( see Satta and Stock , to appear ) is another candidate for inclusion in a later version  . These appear to be longer-term research goals , however .   6 Acknowledgments : The authors would like to thank Louisdes Tombe and Dominique Estival for comments on earlier versions of this paper  . 
References
Anderson , A . tI . , M . Bader , E . G . Bard , E . Boyle , G . Doherty , S . Garrod , S . Isard , J . Kowtko , J . 
McAllister , J . Miller , C . Sotillo , It . Thompson and It . Weinert (1991) " The IIC\]LC Map Task Corpus " , Language and Speech 34(4) ,  351-366 . 
Briscoe , T . and J . Carroll ( 1993 ) " Generalized Probabilistie LR Parsing of Natural Language  ( Corpora ) with Unification-Based Grammars " Computational Linguistics  19  ( 1 )  ,  2559 . 
Hindle , D .   ( 1989 ) " Acquiring Disambiguation Rules from Text " . Proceedings of the 27th Annual Meeting of the Association for Computational Linguistics  ,  118-125 . 
S in large grammars there is a significant time gain  . 
The chart's main advantage , however , is in identifying unattached constituents and allowing a ' layered ' approach to analysis of input  . 
6Source code for the LHIP system has been made publicly available  . For information , contact the authors . 
Kay , M . (1989) " Head-Driven Parsing " , Proceedings of the Workshop on Parsing Technologies  ,  5262 . 
Pereira , F . C . N . and S . M . Shieber ( 1987 ) Prolog and Natural Language Analysis , CSLI Lecture
Notes No . 10, Stanford University.
Satta , G . and O . Stock ( to appear ) " Bidirectional ContextFree Grammar Parsing for Natural Language Processing "  , Artificial Intelligence . 
van Noord , G .   ( 1991 ) " Head Corner Parsing for Discontinuous Constituency "  , Proceedings of the 29th Annual Meeting of the Association for
Computational Linguistics , 114-121.

