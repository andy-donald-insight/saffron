GENERATION FROMUNDER-AND
OVERSPECIFIEDSTRUCTURES*
DIETERKOHL
Universitlit Stuttgart
Institut fiirma.~chiltelleSl ) rachverarbeitung
Computer linguistik
Azenbcrg strmge 12
D-7000 Stuttgart1

EMAIL : dietert ~ adler . i)hilosol)hie . uni-stuttgart . d(,
Abstract
This paper describes informally an algorithm for the generation froll lun  ( er-all ( over spceified feature structures . 
The generator require ~ a grammar , : t goal category m~et a feature structure mq input  , and derives all strings whose corl'eSl ) on dillg features trltCtl lreisllotill Colltrluiction to the input structure  . 
1 Introduction
In this paper I will present all algorithut for generation fronlunder-all d overspccitied feattlrcs truetltres in the Lr '  (  ; fi'amework1 . Tile algorithm makes use of the concept of generation as slructu T~-driven deriva-tz on as it is described ill  114  ,  15 ,  16\] . Most of tile time the algorithm works topdown breadth-first  , similar to the gcncrator described ill \[7\] and \[61  . Only forthccreation of the final structure tile algorithm works botton l-Ill  )  ,   2 Motivation The algorithm given ill \[14\] allows to generate fi'om a fltlly specified feature structure  , e . g . tile input structure is equal to a structure that would be derived during parsing  . For ai ) plication so tlter than testing a granllnar for overgeneration the equality-condition is too restrictive  . 
The algorithm given in \[15\] and \[16\] then Mlows to generate frolual luuder spceified structure  , if there is a fully specified ( semantic ) predicatc-argontent-structure which is nnt ~ dlowed to be extended during generation  , e . g . tile l ) redicate-argunlent structure must be conqllete and coherent with respect to the target grammar  , One of the disadvantages of this algorithm is , that it must be marked for titile generator , which substructure is not allowed to be changed during generation  . Further , in certain applications , the condition that there is a partiM feature structure which is complete and coherent with respect to the target grammar might be  , also too restrictive . 
The generator described in this paper had been de -y cleped for projects whielt are involved in machine translation  . While one of the projects makes use only of syntactic information encoded in a feature structure the other in ' eject uses semantic information ~ s well  . In I ) oth cases the in I ) ut feature structure for tile generator is at least undersl  ) eeified with respect to * The work reported here is part of the Sonder-forschungs be reich  340 Sp~ch theo , ' et is cheG ~ ltndla gender ( ' omputerling u ? ~ tiklFor details of the LF e , formalism see (1b the target grammar , not only for al ; omic attribute va lue pail's but also fro ' complex pairs  . This means tile gencrator has to introduce information into the given feature structure to get a structure which is valid with l-espect o tile target grt unmm~r  . 
In both projects a similar architecture is used : 2   1  . parse a sentell Ce and return the feature structure 
F p2 . extrat:tile inforlnation for the translation from 
Fp and build F , j3 . generate fron lF 9 a sentence In such an architecture the creation of F g is usually independent of the target grammar  , in the sense that the creation is not automatical lycout roUed by tile target gralnular  . 
In machiuctraaslation the grammars used for parsing and for generation are basically spccilic for tile two single languages one wants to translate between  . It is usually desirable to sl ) eeify F ~ only in , ~srudimentary and ms general lnauller ; L  ~ ; possible . This luean stile details of how to generate a wdid surface string of tim target language are only known in the target grammar  , rather than spelled out illth " translation relation  . Ill other words , a single grammar G describes only the relation of a surface string of a language L and a feature structure valid for tile grammar G of L  . 
~trther , a valid feature structure for G will represent only information ecessary for L  , but not neeessarily information necessary for the lauguage to translate into  . For example , a gram laar fro ' German will describe afl ~ atttre structure which h  , ' us information for the tenses past , present , and future , but no information about progressivems it is required for English  . 
Therefore , illtile translation German to English the generator has to generate froln a feature structure which might be underspecified with respect to tense information  , while ill the translation Englislt to German the generator has to generate from a feature structure which might be overspecified with respect to tense information  . 
ht general , in describing the translation relation between two languages onelta  . stoface tile probleuts of interfaces : ? Infornmtion is missing and must be derived froin tim target graln mar  , e . g . tile input structure is uuder , ~ pecified . 
2For the re~ons of this architecture see for example  \[4\]  . 
There are also other MT projects like GRADE ( see\[9\] , \[10\] and\[8\] ) which nl~tke use of a similar architecture . 
ACRESDE COLING-92 . NANTES . 2328 AOt3T 1992686 Prec . oF COLING-92 . NANTES , AUG .  2328 ,   1992 ? There is more information than defined by tile target grammar  , e . g . there is no string of the target language for which the grammar describes a feature structure which contains all attribute-vahle pairs given ill theiu put structure FS  9  . The input structure is overspcc if led and the overspce-if  ) cation could be ignored duriuggeueration . 
? There is informatiou which is incousisteut with the target grammar  , e . g . the input structure is ill for rned with respect to the target gramnlar  . 
This require some error treatment.
All algorithm for generation then h~s to provide uwchanisms which allow geueration from underspeci -fled structures as well as from overspecilic d ones  . This will allow to deal with certain types of trauslation mismatches as they are described for example in  \[2\]  . 
Further , the treatm cutoffll formed structures hou hlbe such  . that the invl did elements of the input structure could hema devisible for debugging purposes  , ill-stead of just failing to generate anything . As it turned on t , even for ulediuul sized grallllnars it Call be conlequited ill  ) cult for a linguist to debug the grammar if there is only a debugger available which had been develolled for the gener Ml  ) urpnse programming language the system is in q ) lemented ill , e . g . prolog . 
3 Terminology
The alger ) tirol has been deve hlped for grammars written in the Ll  . ' c ; - formalism . Thisuleal ! s , it works on a eou text-frec grammar G with annotated f cat m'e descriptions  . Given a feature structure FSi , as input the algorithm has to generate all those surface strings  , for which G;Ls sociates a feature structure
FS , j , with FSI ~ coutpatihle to FS , ~.
V ~ rhatco're , pal ) hie means depends on tile kind of application the generator is used iu : ? If the application is to test a grammar for over-geu  (  , ration , FS in lnust lie equal to FSu , e . g . lieiuformation is introduced into or deleted from FSi  , , during geueration , and \]i ~ Si , , unifies ill terms of feature unification with FS , j . 
? If the all l ) licatiou is to test whether a structure of a certain attribute might be sufficient for genera -lieu  , i . e . whether the senlautic structure does not m ' er generate  , FSI , ~ must I ) e subsumed by FS , ~ , e . g . all information of FSI , , nlust be required for generation , and it is only allowed to introduce iMonnation lute FS in  . 
? If the application is machiue trauslation , FSi , , and FSI ~ must unify , e . g . FSI , , might contain nlore inlorulation and , also less iu forluatiout h~t . u
FSu .
Del ) endiugontile al ) l ) licati ( m the algorithm is i ) arametrized as to whether it allows the introduction of information into FSi  , and whether it allows
FSI , to be overspecified.
For those not familiar with LFGI will give a short overview of tile elements of the feature descriptious as I will use them afterwards  . In general a feature deseril ) tiou consists of a coujuuction of equations or a disjunction of feature descriptions  . In this paper I will only cousider feature descriptions without dis-junctious  . The equations are distinguished into ? defining equations indicated by tile operator = ? inequatimts indicated by the operator #? constraining equations indicated by the operator = eAll equation consists of a reference to a structure  , tile el ) era ) or , and , ' L , ~second argulue ut of the operatiououe of ? all atomic v ~ due likera as ? a semantic form  , indicated by double quotes , with anatou ) icuaule aud all optional arguule ut list , , i . e . " man " , " give ( Suu J , ot ~ J "? a referelle e to a structure A reference to a structure is either a mete -variable or a path applied to a mete-variable  . Examl ) les are ? the meta-w triable 1 , which stands for the structure assnciated with tilen lother llode  , e . g . the category given on tile lefthand side of a rule  . 
? ttw meta-vari Milc1 , which stands furtile structure a . ssociate(1 with a ( laughteruo de of a rule , e . g . the nolle on the right hand side of a rule where tile feature description is an annotation of  . 
?( ~ GENI ) ER ) , which refers to a structure under the attril lute  (  ; \[ . ; NDI . ~ Rilltile feature structure associated with tile mother node  . 
Equations , which have references on both sides of a equatiou arc called ree ~ ttr  ( trtey quations . 
Semantic forms describe unique vMues , e . g . while two atoufic values unify if they are described by the same fern  )  , two semantic forms will not . The arguments of a semantic form of at ) attribute A are paths which are members of the governable f~mctions of A  . This set will be named as gf(A ) .  % ) alh ) w semantic forms ) ~ spossil ) levalues tiltally attribute is a generalization of the Ilse of sltnlantic for lll Sa  , s they are given in \[1\] where semantic forms are only values of the at-tr ihute PRED  . Semantic forms contain all information ueeessary to test the conditiol m of CO ml  ) leteness and coherence . 
3.1 Coherence and Completeness
Using the generalization tile conditious of completeness and coherence ms given in  \[3  , pp .   211/212\] are reformulated ~ s ? A feature structure 5' is locMly complete iff for each attribute A in S where gf  ( A ) is nonempty tile governable functions defined by tile v Mue of A existill S with a value for the attribute A  , and if all values required are defined . A structure is conq ) lcteif all of its substructures are locally complete  . 
? A feature structure S is loe Mly coherent , iff for each attribute G of S which is member of g f  ( A ) G is governed by the value of A , e . g . the argu-lueut list of the vMue of A contains G , and if , all attributes of S are given by tile grammar . A structure is coherent if , all of its substructures are locally coherent . 
Ac~rEs DECOLING-92 . Nniv rI , kS . 2328 ^ olyr 1992687 PRec . OFCOLING-92 . NANTES . AUG .  2328 .   1992 The struett n'e FS derived in the generation process must at least fttllfiqll these contlitions of completeness and coherence  , e . g . ally violation of one of these conditions is treated as an error  . Since the input structure FSi , , should be part of the derived structure , the conditions for attribate-valae pairs of the input structure are modified to be able to use the input structure to control the generation process and tobcable to allow overspecification  , a ? If an attribute A of FSi , is licensed by a defining equation or in equation in the rules of tile grammar which are not explicitly excluded by FSi  , , it shouhl be checked that A is actually con -stnned daring generation  . This condition extends the condition of coml ) leteness . 
? If an attribute A of FSi , does not occur in any equation of the graulmar , tim input structure is ovcr specified . It depends on the application , whether this type of overspeeification is allowed  , e . g . wheth crit should be consider cda . saviolation of the coherence condition or shoult l be ignored  . 
? If an attribute A of FSi , is not lie eased by a defining eqnation or an in equation in the rules of the granunar which are not explicitly excluded by FSi  , the input structur c is overspecified . It depcnds on tb call plication whether this type of overspecifie atiml is allowed  . In ease overspecification is allowed , A and its value are ignored , otherwise it is treated , as a violation of the coherence condition . 
As indicated by tile last extension to the coherence and completeness conditions  , it depends on the application what kind of input structure is considered to be a valid one for the target gralon lar  . Ill case a grammar should he tested for overgeneration avalid input structure is not allowed to be extended tlnriug generation and is not a nowed to be ow ~ r specific t l  . 
In the case of machine translation the input structure can be considered as a valid one  , even it is underspecified . Del ) ending on the language pair it might be also a pl ) ropriate to consider an overspeeified input structure msvalid  . 
4 The Algorithm
The algorithm works on a granmmrtle scription and an input feature structure  . The grammar description cuasists of contextfree rules with annotated feature descriptions  . 
For siml ) licity it is assumed that the annotated feature descriptions do not contain disjunctions  . A disjunction in a feature description can always be transformed into a disjunction of nodes on the c-structure level  . Furthernmre , a siugleode is a concatenation of terminal and uon-termiual nodes  , and for each category C of a grammar the rules for C are treated as one disjunction  . 
a This meal m , it is not sufficient to require , that the inptlt structure has to Ilnify with a structure derived from the grammar to get a generatim ~  , since this would allow to produce sentences which do not contain all of the semantics given in the in ptll structure as well ms to produce sentences with any kind of possible modifiers the grammar could derive  , that is infinile many . 
Tim algorithm starts witb a current category C ~ , initialized with the gual category , and a current feature structure FS ~ , initialized with the input feature structure FS in . 
The algorithm proceeds as follows : ? Match the current feature strncture FS~with the current category C~bymatehiugFS ~ with the feature descriptions FDi of the nodes Ni on the right hand side of tile rule for Cc  , where FSc is bound to them at a variable T which deaotates the structure associated with the nlother node C  , , on the left hand side . The matching works topdown I ) readth-first . During tile match FS ~ will lint be nm dified . 
? Eztend FS, . by the application of a feature description FD . 
4.1 Matching
The matching of the current feature structure FSe with the current category C~will alwayste  , 'minate . 
During the matching a structure which is used as a chart and an agenda is built which keeps track of ? which structures are already matched with which categories  . 
? whether there occurs a trivial recursion , e.g.
given a structure and a category there is a recursion on tile c-structure level which uses the salne structure  . 
? tim use of whicb nodes can be constrained by tim input strncture  , and what is tile result , e . g . 
is the usage of the node excluded or licened by tile input structure  . 
? which nodes are lmrelye ontroUed ontile e -structure level  , e . g . there it ~ no equation for a node which d cnotates the structure of the mother node  . Such nodes b are to produce only finite many snh strings  . 
For each category C~fll its rules arc considered in parallel  , which avoids ally dependency almut the ordering of the single rules for C  . 
For each node N on the righthand side of C~the input feature structure is matched with its feature description FD  . This match results ill at least one of the following descriptions : Exclusion : FSc is not coml  ) atil ) le with FD . Therefore the node N will be excluded . Other results of the matching are of no relevance  . The exclusion of N excludes those nodes which are part of the same rule as N  . 
Activation : FD defines a path-value-pair which is already part of FS ~  , or FD defines are entrency which already exists illFSc  . 
Examination : In FD occurs are entrane equation where only one of the paths exists illFS ~  . The resulte zamination contains the category CN named by the node N and tile associated substructure FS  . .
Tilefolh ) wing cases are distinguished : Amw~s DEC OL1 NG-92 . NANTES , 2328 AOt ~ q"1992688 PROC . Or COLING-92, NANTES , AUO .  2328 ,   1992 trivial equation : N is a nonterminal node . 
The cat gories C , : and CN are associated with tile same ( sub ) structure . Beside 1"- . \[ equations uf the form ( 1 X )  =  ( 1 X ) are also considered , astriviM equations . 
(1X ) = l : N is a nonterminal node . The category CA " will be matched with the structure denotated by  ( ~ X )  . 
( ~ X)-(~Y ): N is a iron-terminal ( lode . Tile category CN will be matched for ( . \[ Y ) with the structure denotated by (1X ) . This ease covers the treatment of multiple ro ~ ) ted structnres as theyn light occur in graln nlars written in all IIPS t  ; style 4 . 
(TX ) = (1V ): C'~will be mat , : hed for ( 1Y ) with tile structure denotated by ( 1 X )  . 
Uncontrolled : FD does not contain any equation which can be applied oil FSc  . In this case FS~does note on troll theoceurcnce of tile substring associated with the node N  , and it depends on tile partial c-structure alone given IW the category C ~  , whether there are tiniteninny substrings described  . 
Su spension : FD contains equations which allow controll of generation by FS  ,  . , but FS , , does not contain enough information to make a ( teci-sional ) out exc\[usiol L activation or exatninatiol t . 
Therefore , the matching of N with FS~has to he decided later  . In case the application forbids introduction of infornmtion into FS ~  . during gemeration the conditions of suspension will lead to immediate x clusion  . 
Onlytile results activation and examination may occure in parallel The result examination causes a further exanfination of the category CN with tile selected  ( sub ) -structure , if they have ( lot Mready ( ) ( ! elie X alllined and are not already under exaluilla-lion  . Thus tho matching of a category with a ( sub ) -structure is performed only once during the matching of the input feature structure with the goal category  . 
This guarantuecs the termination of the matching and is efficient  . 
Since the matching works topdown breadth-first it isllOSSible to detect inconsistencies between theiupttt feature structure and parts of the rules fairly early  . 
From the complete match it is possible to deter : mine the set of these attribute=value pairs  , which are part of tile original input structure and which could I  ) e used either by a defining equation or all incquation  . These attribute-value pairs are marked that they have to be used which is an equivalent of adding tempora rely constraining equations to the grammar  , which guarantee that a maxinm mo fill-formation from the input structure is used for generation  . It should be noted , that this step is only necessary , if overspecification f the input structure is allowed  . Otherwise all attribute value pairs of the input structure could be marked at star  ( up that they have to be used during generation . 
The matching produces a set of II ossible solutions . 
This makes it possible to distinguish a failure caused by an illegal input structure from the generate-and-test Iie haviour of the backtracking * nechanism  . Since 4For a description of Ites(\]se~11 l\] . 
there is enough ill for nlation of the current goal in tile generation process  , it is possil ) let o produce an error message which descril ) es * the c-structure build so far * the node and its ammtated feature description which is inconsistent with the input structure * the part of tile input structure which caused the failure ~ l  ( challer rorluess age v ? onld lie intern ( s of the grammar rather than in terms of the i in plention lan=guage of the algorithm  . An error message ou hlbe I couldn't yenemt caTt NP for the structure \[ PRH  )   ( u  a ( (\] spt:c idef J because SPEC ' : idef is ille . rlal for the grammar . 
Since it is distinguish c < I which parts of the structure are intruducc during generation it is possible to show tufty those faihu'es which are caused by the original input struct tu'e  . This would also allow one to ignore illegal parts of the inliut structure mnpletely all dt\[  ) ev ~ 211 ~ Cllcl ' ; ttcfr ( ) lllill form cd structures . Incon ( flint to the cmue of overspccification this would require repairing either tile input structure or extending tile target gr ~  . (nlllar . 
4.2 Extension
Tile extension of FS~by a feature description FD means  , that all information fi'om FD is incorporated into FS  , , . Since only non-disjuuctiw ~ , feature descriptions are cmtsideretlitis not necessary to describe tile treatment of disjunctive information  . The only source of alternatives are the rules . These alternatives are treated by backtracking . The selection of alternatives starts with those disjuncts  , which do not lead to reeursion . This guarantees that recurs ( on is applied oaiy in those ca . ses , where it could be part of tile c-structure to generate  . 
The extension h~t~several aspects . First , it is made explicit in tile feature structure which attrilm te-value pairs are defined by the grammar  , and how often a definition h ~ uoceure during tile generation  . The latter information is used to stop the generation from infinite lool is I  ) y giving a maximum a monnt of repeated definitions of the same l  ) i eee of information . Reason-able limits are values between 10 and 20 . It should be noted that the semantic foT ~ ns of LFG reduce this linf it to  1 for attributes which take a semantic for ( ( ( as value 5 . 
Second , a partial representation f the e-strncture is builtin parallel to the feature structure  , which allows at the end of the generation process to extract the surface string by a traversal of the complete c-structure  . 
Third , it can be deternfined which attribute-value pairs have been introduced into the original structure  . Only these attrilm te-value pairs are relevant to reexamine suspended nodes  . 
SF or LFG grammars this aspect of semantic forms is the main reason that tile generation will terminate without he superficial limltati ! m of repeated definitions  . 
ACRESDECOLING-92, NANTES . 2328 AOI3T 1992689 PROC . oF COLING-92, NANTEs , Auo .  2328, 1992 4 . 3 The main loop 1 . For each node Nj of the right hand side of the rule of the current category Cc match tlle annotated feature description FDj with the current feature structure FS ~  . The matching ternfiuates always , and during the matching no new information is introduced into FSc  . The match deter-miues , whether the node Nj might be excluded , activated , suspeuded , and whether the category N should be examined for some part of FSc  . 
2 . If there areuo nodes left which can be activated  , nodes which are still suspended axe excluded at td tile filial coherence and completeness tests are performed on the input structure FSI  ,  . In case of success the surface string can be extracted from the c-structure which is built in parallel to the derivation of the input feature structure  . 
Ill case of failure , other solutions are tried by backtracking . 
3 . Select only these nodes which can be activated which will not lead to a recursion  . Extend the partial feature structures associated with these nodes by applying the annotated feature descriptions  . 
4 . Compaxe those nodes again which have beens us -pended ms in step  1  . 
5 . Repeat the steps 3 aud 4 until there are no nodes left which can be activated aud which do not lead to it recursion  . 
6 . Nodes which could be activated but lead to re -cursiou axe activated only in case there is ltO indication that the recursion conld be applied in finite many times  . 
7. Contimte with step 2.
5 Example
In order to illustrate howt be algorithm works , I willoaly give a very simple and somewhat superficial example  . For more detailed examples especially on the treatment of recursion see  \[5\]  .   7 The exant ple makes nse of the grammax in figure 1 to generate a German sentence with a simple NP and all intransitive verb  . The grammar is written illausual LFG notation . The input feature structure for genera-tiun is given in figure  2  . For the example it is assumed that the feature stucture contains the semantic representation of the analysis of the Englisb sentence the man is running which should be translated into German  , The goal category for generation is S . 
The generation starts with the matching of S with FSo  . The NP node of the right haud side of the S rule is suspended  , since there is no attribute SUBJ in the input structure  . The trivial equation of the V1 a node immediately leads to the matching of FSo with the category VP  . The trivial equation on the V node leads in turn to the matching of the category V with FSo  . The existence of ( SEMREL ) = r~n in FSo 6In this paper in finite loops are only assumed in case the limit of repeate definitions is reached  . A more detailed treatment of the detection of i af ln ite lo ops is given in  \[51 ~ There would be note tlollgh space to show a more complicated example in this paper  . 
lUalUUder:rennt:rannte:
S ~ NP VP(TSUBJ ) = IT = l
NP ~ DN

NP ~ N

VP ~ Vl = l
N ,   ( TPRED ) = " mmm " ( 1NUM ) = sg ( TGENDER ) = mas ( TCASE )  #gen ( \]" SEMREL ) = " man " ( TSEMNUM ) = sg
D ,   ( TSPEC ) = def ( j " GENDER ) = mas ( 1 CASE ) = nom ( TNUM ) = sg ( TSEM SPEC ) = def
V ,   ( TPRED ) : " rennen ( SUBJ ) "  ( 1" TENSE ) = present ( TSUBJ CASE ) :- nor a ( ISUBJ NUM ) : sg ( TSEMREL ) = " run " ( \]" SEMTIMESTART ) = now ( 1" SEMARG 1 )  =  ( TSUBJSEM ) 
V ,   ( TPRED ) = " rennen ( SUBJ ) "  ( TTENSE ) = past ( \]" SUBJ CASE ) = nor a ( TSUBJ NUM ) = sg ( \[ SEMREL ) --" run " ( TSEMTIMESTART )  = \] ) as t ( ISEMTIMEEND ) = past ( TSEM ARG1 )  =  ( 1"SUBJSEM ) 
Figure 1: Example grammar would allow to activate botb verbs of the example lexicon  , but the equation ( TSEMTIMEEND ) = past excludes the eutry for rannte . 
The resulting partial c-structure of the match is
S--NP ... suspended ...
VP--V--"rennt "
Tile following attribute value l ) alrs of FSo must be used during generation : ( SF , MREL )   ( SEMARG1 )   ( SE 1 v l TIMESTART ) Since tile solution set of the match does not require to use  ( SEMTIMEEND ) tiffs information can be ignored for the further generation  , although it had been used to exclude an entry . This shows a case of overspeci-fieatiou , where an attribute is in the set of possible attributes of a gramntax but is not always determined by the grammax  . 
The extension of FSo then leads to the structure in figure  3  . It should be noted that the algorithm autontatically selected the semantic head  , although ACTESDECOLING-92 . NANTES , 2328 AOt ~ q"1992690 PROC . OFCOLING-92, NAh'TES , AUG .  2328 ,   1992 feature structure c-strnctnre\]"rau"I+L+ , , L altG1 53/S , ' , ' ? clef / //\ [\] s , + , \[\] sg'//Figure2:Inl ) ut structure for geucration the bead is eml ) edded in at substructure . Tiffs means the algorithn lisimplicit head -driven without any as-sunq  ) tions which part of an in j ) ut structure the head should be . As it is shown il l\[5\] , this allows to generate in cases of head -switching  , where syntactic att ( l semantic head differ . 
\[\]5 EM
PRED'\['ENSI'~\[REL " ruu'l\]
A , tGl\[\]\['s~::,~c'?;nan"l
Ll ' IMF\[~\[E'~AD tT::'t ; : re\]J " renneu ( SUBI ) " l ) resents+?\[++:+'+l ; llll_tsm M\[\]J Figure 3: First extension of the input structure T it ( " introduction of SUBJ leads to tim matching of the suspended NPim de with FSo  . The equation ( TSUBJ ) = J . leads to then mt chiug of the category
NP with FS4.
For the NP rule there are three nodes to be matched with  FS4  . Siuccon all three nodes a trivial equation is at motated  , the categories D and N have to be matched with FS4  . The equations ( l SEMREL ) = man and ( TSEMNUM ) =sgactivate stile noun curry , and requires that ( SEM lt EL ) and ( SEMNUM ) of FS4nlust bensed for geueratiou . 
The equation ( 1"SEM SPEC ) = dcf activates the determiner entry and requires to use  ( SEM SPEC ) of
FS4.
The two alternatives of the NP rule " allow to consider twolms sible extension shown in table  1  . 
Since ( SEM SPEC ) of FS4 must be used , the second alternative will be rejected by tile final constraint test  . 
Therefore , the only solution is tile first alternative . 
This results in tile e-struct nrc
S - - NP - - D - - " der "
NIllnanllll
VP--V--"rennt " from which the string der mannrennt is generated  . 


: ? nt/SEM\[\]/~IP ~ . ", nauu " // GENDEItin ; ~ s
Lsvl . : cdefJ\[\]Im'+MX\]IPRE1 ) "tltanun\[GI~\]NDI~RIll as\]
NP--D-"der "

NP--N)'nlann "
Table 1: Possible exteusious of the NP rule 6 Comparison with Shiebers approach The semantic-head driven  , algorithm give u in \[13\] also starts with a to l ) -down in italizatiou with a I ) ottom-ul ) generation . In Shieberctal the nodes whiclle outam the semantic head arc determined during tile couq  ) ilation of the grammar . This seems to be a bit problenmtic furgram luars which describe head-switching t  ) he nomc nons , ~ in 100 l~tres of wine , where a possibh ~ ananlysis is that 100 litres syntactically governsultn . e , but semantically is a moditic r of wine . The algorithmll reseuted here does not require to ll recomlm tetile nodes which contain tile semantic head  , but finds the headrelew mt for the give u input structure automatically  . 
Tile problem with free variables for the coherence constraint given in Slficb crctal does not occur for the algurit bml/reseuted in this paper  , since it " always distinguishes between the struetnre and the descril  ) -tiun of the structur c , and keeps track of which parts of the structure are already derived during genera-tiun  . Since the a\[gorithlnI ) resented here always hmq in furmatim lat ) out w l f i ( : hparts are from the original input structure and which ones have been added  , it is possible to check the coherence couditiuu at any step of the generation process  . In addition , the solution in Sl fieber et al with binding variable seems somewhatll roblematic  , since it requires to know for sure , that the variable part of the semantics houhtuot lie exteuded  . 
The augmentation of the generator described ill Shiet  ) er et al with a chart to avoid rc computation at t ( lel infinatered tm daucies is an integral part of the algorithut presented here  . 
7 Summary
Illtiffs l ) a peran algoritlun had t ) een described which can be used to generate from filly specified feature structures a  . swell as front variants of under - or overspecified feature structures in the LFG framework  . 
The algorithm covers the cases given it , 114\] and\[151&s a subset . The treatment of recursion allows even for infinite many possible generations that the so ht -tions can I  ) e presented one by one , e . g . the generator will not go into an infinite loop between two solutions  . 
The generator is implicit head-driven , e . g . it selects the head automatically for a given input structure with respect o the target grammar  . As it is shown in ACTESDECOLING-92 , NAMES , 2328^O ~ rt'1992691 PROC . OFCOLING-92 . N^N'rEs , AUG .  2328 .   1992   \[5\] this behaviour of the algorithm allows the efficient tr catment of head-switching phenomenons  . 
It has been shown , that the algorithm provides information which allows in ease of failure to produced ebugging information in terms of the target grammar  , rather than in terms of the programming language the algorithm is iml  ) lemented in . 
The algorithm is implemented in PROLOG in the ed -inburgh syntax  . Currently the implemention of the delmgging meehmfisms is incomplete  . 
Although it is not shown in tiffspaper , the technique used for the generator could be easily adopted for parsing  , where the input string take stile part of the iuput feature structure  . Ill this sense tile c-structure is only considered as an auxiliary structure where the gramntar describes basically a relation between a sur-face string and a feature structure  . To adoptile technique for parsing would have the advantages ? to use basically the same macl finery for parsing and generation where then mehinery is optimized for each task  , ? to have the same improved possibilities for debugging  , and e to allow to start the parsing of striugs while they are typed in  , and not only after the complete string to be parsed is known  . 
One of the major goals for the fi~ture development of the algorithm is to reduce the use of backtracking  , as much as possible by using disjunctions as part of the features trncture  . 
The algorithm should be also applicable to other grammar formalisms like PATR-II  ( see\[12\] ) which make use of a context-fl'ee backbone and anotated descriptions  . It is also intended tonsetlte algoritlnn for formalisms like ItPSC  . 
References\[11 Joan Bresnan , editor . The Mental Representation of Grammatical Relations  . MIT Press , Cambridge , Massachusetts , first edition ,  1982 . 
\[2\] Megumi Kameyama , Ryo Ochitani , and Stanley Peters . Resolving translation mismatches with information flow  . Iu Proceedings of the 29th Annual Meeting of the Association for Computa . 
tional Linguistics , pages 193200 , Berkley , California , USA , 1821 June 1989 . University of California , Association for Computational Linguistics . 
\[3\] Ronakl M . Kaplan and Joan Bresuan . Lexical-flmctional grammar : a formal system for grammatical representation  . IJoan Bresnan , editor , The Mental Representation fGrammatical Re-lation . s , chapter 4, pages 173281 . MIT Press,
Cambridge , Massachusetts , 1982.
\[4\] Ronald M . Kaplan , Klaus Netter , Jiirgen Wedekiud , and Annie Zaenen . Translation by structural correspondences . In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics  , 
Manchester , 1989.
\[5\]Dieter Kohl . Generie run gaus unter-undiiber spezifizier ten Merkmals strukturen in LPG  . 
Arbeit spapiere ties SFB 340 Sprach theoretische Grund lagenflit die Computerlinguistik Berieht Nr  . 9 , Institut fiirnlaschinelle Sprachverarbeitung , Universit?t Stuttgart , July 1991 . 
\[6\]Dieter Kohl and Stefan Momma . LFG based generation in ACORD . In Gabriel Bes , editor , The Construction of a Natural Language and Graphic Interface Results and perspectives from the ACORD project  . Part Generation ill ACORD , Chapter 5 . Springer , ( to appear ) 1992 . 
\[7\] Stefan Momma and Jochen Di Jrre . Genera-lion from fstructures . In Ewan Klein and Jo-hun van Benthem , editors , Categories , Polymor . 
phism and Unification . Cognitive Scieuee Centre , University of Edinburgh and Institute for Language  , Logic and Information , University of Amsterdam , Edinburgh and Amsterdam ,  1987 . 
\[8\] Makoto Nagao . The transferl ) hase of timnm machine translation system . In Proceedings of the 11th International Conference on Computational Linguistics  , pages 97-103 ,  1986 . 
\[9\] Makoto Nagao , Toyoaki Nishida , and Junichi Tsujii . Dealing with incompleteness of linguistic knowledge in language translation  . In Proceedings of the lOlh International Conference on Computational Linguistics  , pages 420427 ,  1984 . 
\[10\] Junichi Nakamura , JmMehi Tsujii , and Makoto Nagao . Grannnar writing system GRADE of rnn-mae hine translation project and itselm rae-teristics  . In Proceedings of the lOth International Conference on Computational Linguistics  , pages 338343 ,  1984 . 
Ill\]Carl J . Pollard and Ivan A . Sag . Information-Based Syntax and Semantics . Vol . 1Fundamentals , volume 13 of CSLI Lecture Notes . Univ . 
Press , Chicago , 1987.
\[12\]StuartM . Shieber , Hans Uszkoreit , Fernando C . N . Pereira , J . Robinson , and M . Tyson . 
The formalism and implementation of PATR-Ii . In B . J . Grosz and M . E . Stiekel , editors , Research on Interactive Acquisition and Use of Knowledge  . SRI report , 1983 . PATR refereue e . 
\[13\]StuartM . Shieber , Gertjan van Noord , Robert C . Moore , and Fernando C . N . Pereira . Semantic-head-driven generation . Computational Linguistics ,  16(1):30 42 , March 1990 . Refs for bottom-
Ul ) geueration problems.
\[14\] Jiirgen Wedekind . A concept of derivation for LFG . In Proceedings of the 11th International Conference on Computational Linguistics  , pages 486-489 , Bonn , West Germany , 2526 August 1986 . Institut fiir Kommunikations - for sclmng und Pbonetik  , University of Bonn . 
\[15\]J iir gen We de kind . Generation as structured riven derivation . In Proceedings of the 12th In . 
ternational Cortference on Computational Linguistics  , pages 732-737 , Budapest , Hungary , August I988 . 
\[16\] Jiirgen Wedekind . Uniflkations grammatiken undihre Logik . Dissertatiou , Universit/i . t
Stuttgart , Stuttgart , 1990.
ACRESDE COLING-92 , NANTES , 2328 A Ot Tr 1992692 PROC . OFCOLING-92 . NANTES , AUG .  2328, 1992
