1. Introduction
When a language is analyzed in accordance with a phrase 
structure grammar , it is customary to regard a terminal str ing 
x as gran~matical according to a grammar G if one can start from 
the inltial string of the grammar and app ly the rules of G  , succes-isively rewriting strings unti lx is obtained  . With the resulting derivation of a generated string x  . . . , a s t ruc tura l descr ip t ion of x i s assoc ia ted cons is t ing of a labe led bracket ing wh ich indicates the nonterminal symbol  ( s ) rewritten to obtain substrings of x . When a phrase structure grammar contains on ly context-free rules  , each generated string can be analyzed and it sstructural des-criptions computed wi th considerable efficiency  . In the event that some rules are context-sens itive  , however , no general analysis procedure of comparab leefficiency is known  . In this paper I discuss a means for allow ing the use of context-sensitive rules in the description of context-free languages to the end of provid-ing greater economy of description and analysis  . I will show that if phrase structure grammars are allowed to define languages in a different way than is usual  , then certain context-free languages can be analyzed more quickly  , using less storage than under the standard in terp retation  , although no noncontext-free languages can be so analyzed  . Furthermore , the new way in which a grammar defines a language seems to be a more adequate reconst ruc  --2 -tion of the use to which context-sensiti ve rules were put in immed-late constituent analysis  . 
Assume we are given a phrase structure grammar G and a string x and we ask whether it is possible to analyzex in accor-dance with the rules of G  . The answer is in the affirmative if Gass igns some labeled bracketing to x as its st ructural description  . 
This suggests that we think of x as being prov ided with an arbi-trary well  , formed labeled bracketing ~ and check whether each phrase of x determined by a matched pair of labeled brackets in :: is divided into subphrases in accord with the rules of G  . For a phrase to satisfy a rule R of G , the matched pair of brackets deter-mining that phrase must enclose the particular sequence of phrases and members of Gfsterm in a l vocabulary that ~ says the phrase mayimedia tely contain  . Furthermore , if R is context-sensitive with context ~_i_""'~m  ----~1" "" ~ ~-- n ' then immediately to the left n ( right ) in x of the phrase in question must be a sequence yl  .   .   . ym(Zl .   .   . z ) of strings such that ( a ) Yl = ? ti ( z_j--Sj ) if --~ i ( - ~ j ) is in --"- TIn "~--* the terminal vocabulary and _  ) is a phase of typedd according to the labeled bracketing ? p of x if ai  ( ~ . ) is in the non-terminal vocabulary , for 1 < i < m(1 < j < n ) ~ . If some well --3 -formed labeled bracketing of x is analyzab leby G in this fashion  , we can think of it as a structural descrip tion assigned to x by G--  . 
If G is context-free , the language associated with it in this ra the rw natural fashion is clearly the same as the language generated by G in the usual fash ion and the structural descriptions as s igned to strings by G are the same in the two cases  . If G contains rules with nonnull context , however , it is not obvious whether the language associa ted in the above manner is the same as the language generated  . So that we can investigate this question , let us proceed with precise definitions of the new concepts which have appeared info rmall y  . 
Z . Definitions
For familiar concepts I will simply refer to definitions in the llterature  ( cf . Peters and Ritchie , 1969b) . Recall that a ( context-sensitive ) phrase structure grammar is an ordered quadrup le  ( VT , V_~ , S__ , I ~) SUCh that ~ T and ~ are finite , nonempty , disjoint sets ( the tern ~- in alvocabulary and nonterminal vocabulary  , res-pectively ) , S is a member of V----Nm finite set of rules of the type  ( i )  ,   ( the initial symbol ) and R is a -_- I_~_-4-where > O , m , n > O , AEVb/ , y . , CL , SEVU~(l<i <, _~- j-k-T .   .   .   . 
1 < j < m , I < k < n ) and ~> , / and ~ are special symbols not in VTUV_N . The rule ( l ) is often written as (2) . 
The notation ( I ) more clearly brings out the possibiliti es for immediate constituency allowed by the rule and the contextual conditions imposed by the rule on those possibilities  . Let L = f'\[AJ_AE__NV and R--\]AI_AE VN  . ~ be sets of left and right labeled brackets . 
Definition I : A labeled bracketing ( finite string over VT ~ . JR ) ~ miss aid to be well-formed ff ( i ) ~E_V T ,   ( ii ) ~_=\[A ~-\] A or ( iii ) ~= ~_wj where ~ and_w are well-formed labe led bracketings and AEV ~  . 
The language generated by G ( written L ( _G ) ) and the set of s t ruc tura l descr ip t ions generated by G  ( written L ( G ) ) a re as usua l ( cf . Peters and Ritchie , 1967 b , Definitions in ?2) , A set_L of strings is called a context- sensitive language if there is a phrases t ructure grammar ~ such that L =  L  ( G )  . Ap~ase struc-ture grammar_G is context-f ree if every rule  ( 1 ) of G has m---n = 0 ( i . e . CtI .   .   . a = ~"'" ~ n = e , ~vhere e is the empty-5-string ) . A set L of string s is a context-free language if there is wa context-free grammar G such that L--=L  ( G )  . 
Definition 2: A triple ( ~--1' ~ ' ~-3 ) is caned a nod__ . e of a well-formed labeled bracketing ~ if ~ --   ~-1 ~ ~ and there are AE ~ N - - - - - 2  -  -3 --_ and a well-formed labeled bracketing ~ such that  ~--2 - -\[ A ~-\] A " The node ( ~I '~--7 . ' ~3  ) satisfies rule ( I ) if there are labeled bracketings ~-0'~---1 .   .   .   .   . ~--m ' ~ .   .   .   .   . a_~n,X_0, ~ .   .   .   .   . _Y , .   .   .   .   . ~'-- P0'--Pl .   .   .   .   . P--n'--~I .   .   .   .   . ~ such that-i_-~___-__(i ) ~_i = ~ . 0o'1 . ~ . 1 . . . O'm ~ m,~Z=\[_A'X . o ~ I_Y , i . .- ~ j_')C(L . \]_A and ~= ~ Zl ~ . . .  ,~ . _ ~ p . --3 ( ii ) ~ x__j , pE(LUR )*, I < i < m , O < j < ~ . , O < k<_~-ia,~d~_i , -"~_i ~ Z ~( iii ) ~=\ [ .  (~ . , \], ~ CL . E-~N ( O1' we 11-f?rmed)jI < i < m , -C~~~~--~_ , i < j < ~ and ~- j_C-'~-J-~=IEY ~ . '\] y . , if ~~ v(~j,~on-formed--T,l<k<n . : ~ r5~-~~' wellformed .   .   .   .   . 
Definition 3: The debracketing function d is the homomorph ism from  ( V_TUhUR ) * onto ~ T * defined by 3 . 
-6-a_ . if ~ vT(i)d(ct ) = -- and e , if a ELUR(ii ) d(v$_ . _ ) = D ( cp ) d ( ~ ) for any labeled bracketings ? p and ~_ . 
A labeled bracketing ? p is analyzed by Gifd ( cp ) EVT ~ , if there is a we U-formed labeled bracketing ~ such that ~= IS ~--\] S and if every node of Cp satisfies some member of R  . We say that a string x is parsed by G if there is a \] a beled bracketing ? p such that cp is analyzed by G and d  ( cp ) = x . The set of labeled bracket-ings analyzed'by G will be written A  ( ~ and the set of strings parsed by G will be written P  ( G )  . 
The Languages Parsed by Phrase Structure Grammars We can think of the labeled bracket ings analyzed by a phrase structure grammar G as being strings over a terminal vocabu-la ry which is the union of CJs terminal vocabu lary and its set of left and right labeled brackets  . We may then ask what type of language A(G ) is . Theorem 1 provides the answer that A ( G ) is a context-free language and from this Theorem  3  . 8 of Peters and Ritchie ( 1969 a ) follows immediately as Corollary1 . We now proceed to state these results . 
Theoreml : ~ fG is a phrase structure grammar  , then A(G ) i-7- is a context-free language . 
? V , S ,  1~ ) be any phrase structure Proof : Let G_-- ( VT-~N grammar and let L and R be the cor responding set of left and right labeled brackets  . To prove the theorem , it suffices to describe a pushdown-storage automaton M which accepts A  ( G ) since pushdow no storage automata ~ accept just the context-free languages  ( Chomsky ,  1963 , Theorem 6) . I will describe the automaton M informally since this will provide more insight in to its operation  . Formal construction of M from this descrip tion is a straightforward ? and tedious exercise and is therefore omitted  . 
I ~ can receive as input any string over VUL UR  . 
wT
Its pushdown-store can contain symbols from ~ TU~NUI ~ UR'  , where 1~ t is a set of symbols each corresponding to the string resulting from inserting as ingle IT pointer "  ( I ) in the left-context portion c ~ a rule ( e . g .   ( 3 ) ) or to the s t r ing resu l t ing f rom inser t ion of a  1 in any string which is the right-context Q fa rule of R  ( e . g . ~--1"'" I ~ .   .   .   . ~)-m-'I-~1 (3) A ~>, r .   .   . , ~ II~---I--CLI .   .   .   .   .   . ~-- i -- m ~''" ~"- n -8 -M contains a finite set of states suff icient to " remember " two tables : a rule table and a right-context table  . The rule plays a dual role ; it is used to determine i hat a node of the input is tentatixely indicated as satisfy ing a rule only if the left-context of that rule is indeed satisfied when the lef t bracket determining the node is reached in the input and it is used to store an ind icator at that point which will allow M to check as the input is read further whether the immediate constituency and the right- context of the node areas required by the ru le  . 
The right-context table is used in checking whether the right-context of a rule tent at ively identified as being satisfied by a node does indeed appear immediately to the r ight of the right bracket determining that node  . For each rule ( I ) of 1 ~ , the rulemtable contains m~- 1 positions and the ith position contains an entry consisting either of the symbol  ( 3 ) or the symbol ( 4 )  . 
..i
The rule table will be updated as the input i s read so that when any position correspond ing to any rule  ( I ) of R contains them entry ( 3 )  , then immediately to the left in the input of the scanned symbol is a string analyzable asc ~  1   .   .   . cLi . j Thus if a pointerm appears in the entry of a position immedi'ately to the left of the symbol ~  ( dash )   , then the left-context of the corresponding -9   . 
rule iss a Us?ied at that point in the input . It is clear that the rule table ran be " remembered " in a finite set of states  . For each dis-tinct string ~ .   .   .   J3 appearing as the right-context of a ~ eule in R  , the right-context table contains n ? 1_ . positions the i_th one of which tain either the entry_i  . ., or : .   .   . I . When the right bracket determining a node is reached in the input  , a position corresponding to the right- context of the rule which wastent at lvely identified as being satisfied at the node receives a pointer to the left of its l of t most symbol  . As the input is read further , pointers are advanced to the right in this s tring as each "" successive portion of the context appears under the scanning head  . This allows M to check whether the tentative ly identified rule is indeed satisfied by the node  . ! I Reme~n bering W ' the right-context table a l so requires only a finite number of sta tes  . 
When started in its initial state scanning the leftmost symbol on the input tape with an empty pushdown-store  , _M prints S on the store and initializes its tables as follows : for each rule  ( 1 ) of 1~ maco ~ responding position of the rule tab le receives the entry  ( 4 ) and each position of the right-context table receives an entry with a pointer at its extreme right  . At each successive step of its computation , M performs whichever one of the operations ( 5  )   .   .   . 
(8 ) is possible in view of the top symbol on its pushdown-store  , the scanned symbol on its input tape and the contents  -10-of its tables . If none of the operations can be performed , M blocks and fails to accept the input . Since M is nondeterministic , a particular input string is accepted if some computation of M on that input terminates in the accepting state with an empty pushdown-store  . 
(5) If you see a nonterminal symbol A , on top of the pushdown-store if the scanned input symbol is \[ A and if some rule table m position contains the entry  ( 3 ) with A to the left of the arrow and a poin terim mediately to the left of the dash  , then ( i ) advance the input tape one square ,   ( ii ) remove the symbol A from the top of the pushdown -store  . ( iii ) for every r~etable entry ~-->_61 .   .   . &/--~ I """\] A .   .   . ~ ~ V .   .   . V nondeterministically decide whether to - - - v -  -1 --wleave it unchanged or to change it to B_ - -> tl  .   .   . 8 u/\[~--I ''" ~ . ~ v - - ~1 .   .   . v and insert in the pushdown-store the single symbol B -->  5   .  --  .   .   .   .   .   . -- I "'" ~/-~ i ' " Al . L - ~ _ ~ ~ ( iv ) for every right-context table entry_81 .   .   . \[ A .   .   .   5 nondeterrninistically-k decide whether to leave it unchanged or to change it to  8_1   .   . , 8k \] and inserttm single symbol 61 .   .   . _AI .   .   . 8k in the p . shdown-store and ( v ) insert in the pushdown-store the ~+ 2_ symbols\[kl"'"~-~n'\]A'-Y .   .   .   .   . Y--I(so that Y-'I is , on top ) . 
(6 ) If y Ou see a member a of V on top of the pushdown -store  , --- T -11-i f the scanned input symbol is a and if every r ight-context table entry has a pointer ei the rat its extreme right or immediately to the left of an a  , then ( i ) advance the input tape one square ,   ( ii ) for every rule table entry ( 3 ) change it to A---~--YI"'"-Y/l .   .   . ? rt?C4) or the I is next to the dash , ( iii ) for every entry_51 .   .   . ~ a .   .   .  _ . 5 k in the r ight - context tab le change i t to 5   .   .   . 5k\]and enter--15 .   .   . a \ [ .   .   . 5 in the appropriate table position and ( iv ) remove --1----k the ( 7 ) 
I as qll l~re , and ( iii ) a from the top of the pushdown-store . 
If a right bracket \] A is on top of the pushdown-store and if is the scanned input symbol  , then ( i ) advance the input tape one ( ii ) remove the symbol \] A from the top of the pushdown-store if every right-context table entry has a pointer at its extreme right  , then nondeterministic any decide whether or not to enter the accepting state  . 
(8 ) If you see a member of 1~ to n top of the pushdown-store , then enter it in the appropriate position of the rule table or the right-context tab le  . 
Let ~ be any labeled bracketing in ~) . Since ~ is analyzed by Cb every node ( ~I ' ~ Z'~-3 ) of ~ satisfies some rule in_R , say(I ) ? By Definition 2 , ~_ can be factored into T~_fs , a's , \[ A , -12-X_'s , w_Bs , \] A ' ~ Bs and _~'s with the appropriate properties  . But then as M scans the first symbol of ai t can advance a pointer past---- I ai ni ts rule table  ( and store the resulting symbol if ~ I is a- lmember of V  )  . Continuing in this fashion , M can advance a pointer across the entire le ft-context of  ( l ) since if any c~i is in_VN , the symbol ( 3 ) appears in the pushdown-store just below the\ ] ~ i determining the node which satisfied th is portion of the environ-ment and thus wil lbere entered in the rule table for further advancement of the pointer just after the corresponding \] CLi has been scanned on the input tape and hence just in time for ~ i + I to be spotted  . 5 o the pointer in the left-context of ( I ) will be immediately to the left of the dash when the first symbol of  ~-2 is scanned . At this time the A which can be on top of the pushdown-store can be removed and replaced bY_~l "'" Z\]AI--~l ''"  4" then as each is scanned M can proceed ultimate ly removing the \] A from the pushdown-store and entering \] --~ I "" "- n ~ in the right -context table  . The pointer can be advanced across the ~ j~s just as across the a ~ s and thus the right- context table will contain no --' ibar to acceptance of ~ when the end of the input tape is reached  . 
For this reason A4 accepts cp.
For the other direction , let ~ be any string which is -13-accepted by M , it is clear that ~ must be well-formed . Let (~--1'~Z'~--3) by a node of p_ . Consider a computation by which I ~ accepts q ~ and let  ( I ) be the rule which was utilized by operation ( 5 ) when the first symbol of ~ was scanned on the input tape  . 
From the desceiption of Mone can find the ~ Is  , a_ts , \[ A '_~' s? . ' s , \] AO's and Y's of Definition 2 and thus determine that the node satisfies ru le  ( I )  . But since (~--1'~--2'~--3) was any node of ~ , ~ is analyzed by G , completing the sketch of the proof of the theorem  . 
Corolla ry1 : For every phrase structure grammar_G , P ( G ) is a context-free language and conversely . 
Proof : Let G be any phrase structure grammar . By Theorem 1 , A(G_) is a context-free language . By Definition 3 , P ( G ) is the image of A ( G ) under the homomorphism d . The context-free languages are closed under homomorphism  ( Chomsk'y ,  1963 , Theorem 31) . 
Therefore P(G ) is a context-free language . For the converse , let G by any context-free grammar . Clearly L ( G ) GA ( G ) since any labeled bracketing that can be obtained by rewriting the initial symbol of G is analyzed by G  . But A(_G ) ~ L(G ) also since at opto bottom , left to right derivation of any ~ EA ( G ) can be obtained by reading off the left labeled brackets of q ~_ Thus L  ( G ) --- A ( G ) and -14-? oL ( G ) = d ( L ( G ) ) = d ( A ( _G ) ) = P ( ~ )  . 
Remark : For any phrase struct unregrammar G , a pushdown-storage automaton M ' accepting I~G ) can be obtained from the automaton M described in the proof of Theorem  1 by altering operations ( 5 ) and ( 7 ) so that they apply regardless of what input symbol is scanned and do not move the input tape  . 
4 o Applications
In a context-free grammar , the only way to express grammatical agreement between phrases which are not immediate consti tuents of the same phrase is by introducing additional nonterrninal symbols and ru les into the gramraar  . For example , there are good reasons to split an English declarative sentence into a subject noun phrase and a predicate verb phrase  . The noun phrase will contain the subject noun as a constituent and the verb phrase wil l contain the main verb of the sentence  . Now the noun and verb must agree in number and person and with the constituency described the only way to achieve this effect with context -free rules is by means of rules such as  ( 9 )  . 
(9) S-->NP VPsgsg
S ~> NP pl VP pl-1 5-
NP--~DetsgNsg
NPpl-->DetNpl
VP ~ Vsgsg
VP pl ~> Vpl
VP--> VNPsgsg
VP pl ~> Vpl NP
NP-->NPsg
NP-->NP
It would be better to use context-sensitive rules such as in  ( 10 ) to describe these constructions . 
(10) S-->NP VP
NP-->Det N
N - -> Nsg
N-->Nll1
VP ~> V
VP - -> VNP
V - -> Vsg/Nsg
V ~> Vp1/Np1
If we are concerned only with analyzing context- free languages  , we can use such rules to parse sentences rather than to generate them  . 
Straightforward modification of existing context-free analysis  -16 -computer programs such as that of Earley ( 1969 ) will permit them to handle arbitrary phrase structure grammars with the same ef ficiency they possess for context-free grammars  . Thus for each grammar G , there is a constant ~ G such that Earley tsp rogram can parse an input string of length n in an amount of time no more than kn  3 But ~- G depends on the number of rules in G , so using -' G--? fewer context-sensiti ve rules rather than more context-freer u lescan speedup parsing by a constant factor  . This gain in speed could be of signifi cance in natural language processing situat ions  . 

Chomsky , N . (1963) " Formal Properties of Grammar ", In K . Bush , R . Luce and E . Galanter ( ed8 . ) Handbook of Mathematical
Psychology , Vol . If , New York , W Hey.
Earley , J .   ( 1969 ) " An Efficient Context-Free Parsing Algorithm "   ( to appear )  . 
Peters , S . and 1% . W . Ritchie ( 1969 a ) " Context Sensitive Immediate Constituent Analys is ~ Context-Free Languages Revisited It  , ( submitted to J . A . C . M .  )  . 
(1969b ) " On the Generative Power of Transformational Grammars "  , ( submitted to Information Sciences ) . 
