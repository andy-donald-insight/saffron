DATATYPES IN COMPUTATION ALPHONOLOGY
Ewan Klein
University of Edinburgh , Centre for Cognitive Science
2 Buccleuch Place , l ~; dinl ) urghEll 891 , W , Scotland
Entail : kloin@od , ac.uk

This paper exanfines certain aspects of phonological structure from the viewpoint of a hstract data types  , Our imnlediate goal is to find a format for l ) honological representation which will be reasonably f  , ' fithful to the concerns of theoreti:cal phonology while I  ) eing rigorous enough to a ( I-rail a computational interl ) retation . The longer term goal is to incorporate such representations into all appropriate general framework for llatn-rallanguage processing  , i 1 Introduction One of the dominant paradignls ill cnr rell coln-put at  . ional linguistics is l ) rovided by unification-based grammar formalisms . Such formalisms ( of . 
IS hieber 1986 ; Kaspert ~ Rounds 1986 ) ) describe hierarchic~d feature st l ' t le t l l res  , which iHinally ways would appear to be an ideal selling \[ brformal phonological analyses  .  1 , ' eature bundles have long been used l ) y phonologists , and more recent work on socalled feature geonletry  ( e . ~ . 
(Clements 1985; Sagey 19 , ~6 ) ) has introduced hierarchy into such represenlations  . Nevertheless . 
there are reasons to step back from standard feature-based apl ~ roaches  , and instead to adopl the algebraic perspective of abstracl data types  ( AD'P ) which has been widely adopted iu com-l ) uter science . One general motivation , which we shall note . xplore here . is thai I heaclivily of grant lnar writing , viewed as a process of programme specification , should be amenable Iosl ~ p-wise refinement in which the set of solnecessarily isomorphic  ) n , odels admitted by a loose I The work reported in this paper has\[  ) ?:~ , 1 ,  ~ ; tlrie dollt its part of the research i ) rf ) glitli/lll ( !Sol\]l ( ' \] . llnl&l\[(~oFiin/llllic&\[i Olllesea . rch((:Illl'C . sl/pp Ol'led ) 3 the OKE conomic and Social Rescalch ( : ouncilaml the project Computation all ) houoh ) gy: . , I (' onst~aint-fh~s?d Approach , funded by the IlV . ~ q cience and Engineering I(t . 
search Council , under grant (; R/(;-22081 . 1 amglalt ' fultoSteven Bird . Kimba Newton and ' l'm/v Simou\[mdi>cussions relating to this work  . 
AcrEsDECOLING-92 , NAtc ~ S ,   2328 Ao ~ rr 1992 specilication is gradually narrowed down to au , fiqtm ' algebra ( cf . ( Sannella & Tarleeki 1987) for an overview , and ( Newton in prep . ) for the apldication to grammar writing ) . A second mo-tivation , discussed in detail by ( Beierle & Pletat 1988 ; Beierle K ~ Pletat 1989 ; Beierle et al 1988) , is to use equational ADTS to provide a mathematical foundation for h ~ ature structures  . A third motivation , dominant in this pal)er , is to use the AI ) Tappl ' oach lo provide a richer array of explicit data types than are readily admitted by " p't lre ' feature structure approaches  . Briefly , in their raw form , \ [ eature terms ( i . e . , fnrnlalislns for describing h~alure stru ( : tures ) do not always provide a perspicuous format for representing strllc-tIIre  . 
On the ADT approach , complex data types are built up from atomic types by means of con-structor functions  . For example .   .   .   .   ( where we use the underscore '_' to mark the position of the fimction's arguments  ) creates elements of type List . Adalaty pemay also have selec-tor functions for taking data elements apart  . 
Thus , selectors for lhety peL ? st are the functions f irst and last  . Standard feature-bossed encoding of lisls uses only selectors for the data type  ; i . e . the feature labels FIRST and LAS Till (  1  ) FIRST : o "117 LAST: ( FIRST : o " 217 LAST : nil ) t lowever , the list constructor is left implicit , That is , the feature term encoding tells you how lists are pulled apart  , but does not say how they are built up . When we confine our at lention just to lists , lhis is not much to worry about , l to wever , tile situation becomes less satisfactory when we at I elnpI'to encode a larger variety of data structures into one and the same feature term  ; say , for example , standard lis(s , associatiw ~ lists ( i . e . 
strings ) , constituent structure hierarchy , and autosegment alssociation . In order to distinguish axtequately between elements of such data types  , we really need to know the logical properties of their respective constructors  , and this is a wl 149 P Rec . oF COLING-92 . NANTES . AUG .  2328 .   1992 ward when the constructors are not made explicit . For computational phonolo Kv , it is not an unlikely scenario to be confronted with such a variety of data structures  , since one may well wish to study the complex interaction between  , say , non-linear teml ) or al relations and prosodic hierarchy . As a vehicle for computational implementation , the uniformity of standard attribute/value notation is extremely usefld  . As a vehicle for theory development , it can be extraord in a rilyuu-perspicuous . 
The approach which we present here treats phonological concepts as abstract data types  . A par-ticularly convenient development environlnent is provided by the language OBJ  ( Goguen & Winkler 1988 )  , which is based on order sorted equa , tiona Jlogic , and all the examples given below ( except where explMtl yiudicated to the contrary ) run in the version of OBJ3 released by sltI in 1988  . The denotalional semantics of a . nOB . \] module is an algehra , while its operational semantics is based on order sorted rewritiug  . I 11 . 1 and 1 . 2 give a more detai led introduction into the formal framework  , while ? 2 and 3 il hlstrate the approach with some phonological examples  . 
1.1 Abstract Data Types
A data type consists of one or more domains of data items  , of which certaiu elements are designated as basic  , together with a set of operatious on the domains which suffice to generate al\]data items in the domains fl ' om the I  ) asic items . 
A data type is abstract if it is independenl of any particular ret  ) resentational scheme . A fundamental claim of the ADJ group ( cf . ( Goguen . 
Thatcher , ~Wagner 1976)) and llluch subsequent work ( cf .   ( Ehrig & MMn "1985 ) ) is that abstracl data types are ( to be modelled as ) algebras : and moreover , that the models of abstract data types are ilfitial alget  ) ras . ~ The signature of a mauy-sorted algebra is al ) air = < S , O consistiug of a set S of sorts and ase ~ O of constant and operation symbols  . A speci-fication is a pair ( rE > consisting of a signal are together with a set g of equations over terms constructed from symbols in O and variables of the sorts in S  . A model for a speciIic a . tion is ~ An initial algebra is characlerized uniquely up to so morphism as the semantics of a specification : there is a unique homomorphisnl from the initial algebrain lot'vely algebra of the specification  . 
an algebra over the signature which satisfies all the equations ?  . Initial algebras play a special role as the semantics of an algebra  . An initial algebra is minimal , in the sense expressed by the principles " no junk ' and ' no confusion '  . ' No junk ' means that the algebra only contains data which are denoted by variable-fl ' eetrms built up from ol  ) eration symbols in the signature . ' No confusion ' means that two such terms t and t ~ denote the same object in the algebra only if the equation t = F is derivable from the equations of the specification  . 
Specifications are written in a convent oh M format consisting of a declaration of sorts  , operation symbols ( op ) , and equations ( oq ) . Preceding the equations we list all the variables  ( var ) which figure in them . As an illustration , we give below an OBJ sl ) ecification of the data type LIST 1 . 
(2 ) obj LIST1 is sorts Ell Listopnil : -> List . 
op . ~: EliList->List.
ophead : List->Eli.
optail : List->List.
var X : Eli.
vatL : List.
eq(X.nil ) = X .
eqhead(X , L ) = X .
eqtail(X . L ) = L .

The sort list betweeu the : and the -> in an operation declaration is called the arity of the operation  , while the sort after the -> is its values or t . Together . tiwal'ity and value sort consti-lute the rank of an operation  . The declaration opnil : -> Elt means that n il is a constant of s or lEll  , The specitication ( 2 ) fails to guarantee that there are any objects of El/:  . While we could of course add soule constants of this sort  , we would like to have a more general solution . In a particular application , we might want to define phonological words as a L is to f syllables  ( plus other constraints , of course ) , and phonological phrases as a List of words , rl ' hatis , we need to parame-terlze the type LIST1 with respect to the class of elements which constitute the lists  . 
Before turning to parameterization , we will first see how a many-sorted specification language is generalized to an order sorted language by introducing a subsort relation  . 
Sul)l ) ose , for exanlple , that we adopt the claim Aeries DECOLING-92 , NANTES , 2328^offr 1992150 PROC . OFCOLING-92, NAN'rEs , AUo .  2328 , 1992 that all syllables have (' lonsets : ( . Moreover . we wish to divide syllables into the subclasses l mavy and light  . Obvimusly we wan ! heavy and light syllables to inherit the l  ) roperties of the clas > of all syllables , e . g . , they haw'('1 on sets . We usel to avy < Syll to stale that Heavy is a subsorl of tile sort Syll  . Weinlerl ) l'et this to mean thailheclass of heavy syllables is a subse ! of the class  ( if all syllables . Now , let on set_:Syll->Noralie all operation which select stllet its ! mora of a syllable  , antile tusimpose the Iollowing con-straint ( where Cv is a sul ) sor ! of N or a )  :  ( 3  ) varS : Syll . var CV:Cv . 
eq on set S = CV ,
Then tile framework of or ( lersorted algebra ell-sures that onset is also delined for obje  ( ' l > of s ) i't
Heavy.
llx ~ turlling to lists , the speciIication ill ( , I ) ( sli ~ hll . v simplified from that used h > ((; oguen , k : Wink hq 988 )   ) introduces Eliall dNeList ( not lOlUl ) t3 lists ) as subsorts of List . and thereby ! rein ' ores on LISTI in a number of resi  ) ects , h , addition . 
tile specification is parameter ! zeal . Thai is . il characterizes a list of X s , where the paralneler X can be instantiated tm any module which satisliestile condition TRIV  ; the laller is what (( ; oy ; uell & Winkler 1988 call a " requiren lenltheory ' , and in lhiscase simply iml ) oses on any inpul moduh , that it have a sot ! which can be mal ) p ( ' ( Ito Ihesort Eli . 
(4 ) objLIST\[X::TRIV\]issortsList NeList  , subsorts Elt < Ne List < List , opnil : -> List . 
op ._: ListList->List.
op .: Ne List List -> Ne List.
ophead : NeList->Eft , optail : NeList->Llst . 
vat X ; Elt.
vatL : List.
eq(X , nil ): X .
eqhead(X.L ) = X , eqtail(X . L ) = L.

Notice that the list constrllctor_ . _llOWi ) el ' forlls the additional fluter ! onolappend , allowing I wolist stmlie concatenated , h , addition . ! he selectors l lave beellmade'safe ' , illl he Sellse thai they only apply to objects ( i . e . . nonemply lisls ) for which they giwrsensible results : for whal . ill LISTI , would have been the meaning of head ( nil ) ? allere , the term mNSET ief ( ! lS tolh ( ' in ilalmmao\[asyll M ) leinlly man's ( 198 , t ) velsion of t it ( ' iil ( nai ( th ( ! ol 3   2 Metrical Trees : \ sa further illustrat ion  , we give below a speci-lit'ation of the datalyp ( !BINTREE . This module has two parameters , bolh of whose requirelnent theories are TRIV .  4  ( 5 ) ob 3 BINTREE\[NONTERMTERM::TRIV\]is sorts Tree Netree  . 
subsorts Eli . TERMNetree < Tree.
op_\[_ . _\]:E It . NONTER MTree Tree -> Netree . 
op_\[_\]:E It . NONTERNEft.TERM->Tree.
oplabel_:Tree->EIt.NflNTERM.
opleft_:Netree->Tree , opright_:Netree->Tree . 
varsElE2: Tree , varsh:EIt.NONTERM.
eqlabel(h\[El , E2\]) = A , eqlabel(h\[El \]) = A . 
eqleft ( h\[E1, E2\]):E1.
eqright ( h\[E1, E2\]) = E2.
( ~ it do \ Vecanl ~ mx ~ inslanl , iale 1 he formal paranmters of th0 module in ( 5 ) with inpmmodule . s whi Ehsupplyal ) ln ' opria lesels of il Olll , erlnina \] and terminal symbols , l , elususeui ) percase quoted identifiers ( eMnenls of the OB . Ii nodule QID ) for nonterminals . and lowercase for terminals . The specitlca-lion in ( 5 ) allows us to treat term in Ms as trees , st ; I hala binary tree . rooted illanode'A , can have lerminals as its daughters , l to wever , weills ( ) allow terminals to be directly dominated by a n ( m-branching molher node . \ [ Ioth possibilities occur in the examples below  .   ( 6 ) illustrates the instantiation of tornlal parameters by an actual module  , namely QID . using the make construct . 
16 make BINTREE-QID is BINTREE\[QID , QID\]endm Then exlexal nph , shows Nellie reductions in this module , obt , aiued by treating the equations as rewrite rules applying fi'om left to right  . 
~' l'hcn~tatir , a Elt . NONTERN . EIt .   TEPd4 utilizes a qual-!lit : at ! on M the sort Eliby the input module's paranleter labch this is simply to allow disaml figult tion  . 
ACRESDE COLING-92 , NAMES , 2328 AO~'1992151 Paoc . OFCOLING-92, NANTES , AUG . 2328,1992 (7) left('h\['a,'b\]) . 
left (' A\['B\['a\] , ' C\['b \]\]) . 
" ~' B\['a\]left('A\['B\['a , ' b \] , ' c \]) . 
~*' B\['a , ' b\]right(left(~A\[('B\['a , ' b \]) , ' c \])) . 
label('A\['a,'b\]).
.x ~ JA labe l ( r ight ( ' A \ [ ' a , * B\['b , ' c\]\])) . 
~4 JB
Suppose we now wish to modify the definition of b inary trees to obtalu metrical trees  , These are binary trees whose branches are ortlered according to whether they are labelled ' s "  ( strong ) or ' w' ( weak )  . 
? v
In addition , all trees have at listinguishetlle af node called the ' designated terminal element '  ( dte )   , which is connected to theroe ! of the tree I ) y a path of ' s ' nodes . 
Let us define's ' and " w't ot>e our nonterminals :  ( 8 ) obj MET is sorts Labelopssw : -> Label . 

In order to buihl tilt , data iype of metric all r ? , e ~ on top of binary trees , we can import Ill ( , mod-uh , BINTREE , suitably instantial ell , using OB . l's extending construcl . Notice thai we use MET to in~tantiate the parameter which fixes BINTFLEE's ~ etOf nonterminal symbols  . ~191 objHETTREE is extending BINTREE\[MET , QID\]* ( sort Id to Leaf ) op die:Tree->Leaf . 
vatL : Leaf.
vats T1T2:Tree.
' ~'\[' he * construcl tells , s thaithei ) ri , cipal ~ . Ol ~ of OlD . 
llalnely Id , is mappe ((1)), asig , tai, . e . ; o*pl , is nl ) to lllc sort Leaf in METTREE . ceq signals the presen ( co\[a ( -otl-difiona Icquation . = = is a buill-inI ) olymou ) hicc qualil > operation in OBJ . 
Acres DECOLING-92 . NAm , ' ~% 2328A or ~ r1992 vars X : Label . 
eqdte(X\[L\])=L .
ceq die(X\[T1 , T2\]) = die T1 if labelTI == s . 
ceq die(X\[T1 , T2\]) = die T2 if labelT2==s . 

The equation state that the dte ( designated terminal element ) of a tree is the dte of its strong subtree . Another way of stating this is that the informat i on about dte element of a subtree T is per co lated up to its parent node  ,   . just in case Tistile " s ' branch of that node . 
The specification METTREE can be criticised on a number of grounds  , it has to use conditional equations in a cumber some way to test which daughter of a  1  ) inary tree is labelled's' , Moreover . it fails to capture the restriction that nob in ary tree can have daughters which are both weak  . or both strong . That is , it fails to capture the essential property of metrical trees  , namely that metrical strength is a relational notion  . 
What we require is a method for encoding the fob lowing information at a not le : " my left  ( or right ) daughter is strong " . One economica J method of doing this is to label ( all and only ) branching nodes in a binary tree with one of the following two lahels : ' sw '  ( my left daughter is strong )  , ' ws'(myright daughter is strong ) . Thus , we replace
MET with the following : obJ MET2 is sorts Labelopesw~s :-> Label . 

We can now simplify both BINTREE and ME'l'll : ; t'\]:objB INTREE2\ [NONTERMTERM::TRIV\] is sorts TreeNetree , subsorts EIt . TERMNetree < Tree . 
op_\[_,j:EIt . NONTER MTree Tree -> Netree . 
oplabel_:Tree->EIt.NONTERM.
opleft : Netree -> Tree.
opright_:Netree->Tree.
rare ElE2: Tree.
varsA:E It . NONTERM .
eqlabel(A\[El,E2\]) = A.
eqleft ( A\[E1, E2\]) = El.
eqright ( A\[El , E2\]) = E2.
eu do obj METTREE2 is extending
BINTREE2\[MET2, QID\]*(sortId to Leaf).
ophie_:Tree->Leaf.
152 Pgoc . OFCOLING-92, NAr CrES , AUO . 2328, 1992 varL : Leaf . 
vars TIT2: Tree.
eqdteL = L .
eq dt eT = if labelT == s w then die ( leftT ) elsedte ( rightT ) f i . 
ends 3 Feature Geometry
The p~rticul ~ r feature geometry we shM1 specify here is based on the articul ~ to ryst ructure defined in  ( Browman & Goklstein 1989 ) Y The five active articulators are grouped into a hierarchical structure involving at ongue node and an oral node  , an shown in the following diagram . 
root glot , talrelic oraltongue labial coronal dorsal This structul'e is specilied via term  ( ' on stl ' UCO l ' ~ ( __ a ,   , a .   .   .   . which ~ i .   .   .   .   .   . standar<i ), (, ~ iti . . . . . . t encoding of features . F , a chfeal ttrevahl c is expressed as allatura J ltUlnl  ) or \[ ) ow ( ' ell0 and 4 . 
representing the constriction degree of the ( ' or resl ) onding articulator . For examl ) le , the tert u 4 , 0 : Tongue is an item of son Tongue con sistieg of the value  , I for the Ioalure (' o ) to N . .\\[ . 
and 0 for the DORSAl , ; this in turu express ( , > a situation where there is maximal coast i ' ictlon of the tongue tip  , and minimal constriction of the tongue I ) od y . Of course , this encoding is rather crude , and l ) ossil ) ly sacrifices clarily for cot , cision . However , it sultices as a workiage x ; , leple . 
We will returi/to constri(qioll degt'e es)el()w . 
The four sorts Gesture , Root . Oral and Tongueill ( lO ) at ld the first three ol ) erator ~ cal ) turo ) h ( ' + ; For spa (: (! reasons w (+ hil VC Oltlittcd ; ItlXdi ~ ( II~H ) I ) O\[\]~rowlnan ( k ! Go histein's COllStricliolt\]o (  ; ttion (('\[) . in(\](:Oltslfit:tiollShe+l )(!( ; S ) pltl ' ill littlClt ,  . ~*'~(' al SOhax, . omitted ( liesupralary llgea \] node , since its i ~ hono\]ogi(allobt-somewhat dubious . 
desired tree structure , using an approach which should be familiar by uow  . For example , the third constructor takes the constriction degrees of Glottal and Volicgestures  , and combines them with a complex item of sort Ora l to build all item of sortRoot  . The specifie ~ ttion imports the um ( hdeNAT of natural numbers to provide values for constriction degrees  . 
(10) obj FEATS is extending NAT , sores Gesture Root Oral Tongue . 
subsorts RatRoot Oral Tongue < Gesture.
op_,:NatNat->Tongue.
op_,_:TongueNat->Oral.
op .   .   .   .   . : NatNatOral->Root , op_!coronal:Tongue-->Nat . 
op ! dorsal:Tongue->Nat.
of ! labial : Oral->Nat.
op ! tongue : Oral -> Tongue.
op_!glottal:Root->Nat.
op ! relic : Root->Nat.
op_!oral:Root->Oral.
vats CCIC 2:Nat.
vats 0 Oral.
vats TT ongue.
eqCl , C2! coronal = CI.
eqCI , C2! dorsal = C2 , eqTC ! tongue=T . 
eqTC ! labial = C ? eqC1 , C2)0 ! glottal = C1 . 
eqC1, C ?,, O!velic = C2.
eq CI , C2, 0 ! oral = 0.

A Veadopt the uol ; atiollal coilventiOll of prependint ~ a'!"to the same of seh : ctors which colrespond directly to features  . For example , the ! coronal sele Cor is a funct ; ion defined on conl-pIoxilenls of SOl " ( Tollguo which rettzrlls air item ( ) f sort Nat , reln'e seetiug the constriction degree ? ca\]u ( ' for ( ' or onality . 
Sonn'illustrative reductions in the FEATS module are given l  ) elow . 
( Ill 3, 4, 4, 1, 11! oral.
~-, 4, 1, 113, 4, t4, 1, 1 ~ or a ~! to ~ gue.
...4,13, 4, 4, 1, 1! oral ! tongue ! coronal.
III1 lie . .\ I)'1 ~ pplo~-lch to leal Ill'e st rtlcI tires , feel'i-leant 3 is represented by eqttating the values of ~ ( '\] ( ' ( ' to l ' ~ . I'IIIIS . Sill ) pose I h ; ll two 5 egnlents S1 , $2' ~ hale ; tvoicings l ) e(:ilication . We can write th\] , ~> t~f ~> llows:ACN:'SDECOLING+92 , NANTES , 2328 AO~rt 992153 P Rec . of COLING ?92, NAN'rEs , AUG .  2 . 3-28 ,  1992  ( 12 ) S 1 ! glottal = S2 ! glottal This structure sharing is consistent with one of the main motivating factors behind autosegmen-tal phonology  , namely , the undesirability of rules such as \[~ voice\] --\[~ nasal I  . 
Now we can illustrate the flmction of selectors in phonological rules  . Consider the case of 1' ; 11-glish regular plural formation (- s) , where the voicing of the suffix seglnent agrees with that of the immediately preceding segment  , unless it is a coronal fricative ( in which case there musl be an intervening vowel )  . Suppose we introduce the variables S1$2: Root , where S1 is the stem-final segment and S2 is the suffix . The rlllenllls\[also be able to access tile coronal node of  $1  . 
Making use of the selectors , this is simply $2! oral ! tongue ! coronal ( a not a . tion reminiscent of paths in feature logic . ( Kasperkllonnds 1986)) . The rule must test whether this coronal node contains a fi'icative specification  . This necessitates an extension to our specification  , which is described below . 
Browman & Goldstein (19S9 . 234 ff ) define " constriction degree percolation ' , based on whalthey call ~ tubegeometry ' . The vocal traccan b ( , viewed as an interconnected set of tllbes , and the articulators correspond to valves which have a mmlber of settings ranging from fifly open to fiflly closed  . As already mentioned , these ~ el-tings are called constriction degrees  ( ! cds )  . where fully closed is the maximal constriction and fully open is the minimal constriction  . 
The net constriction degree of the oral cavity may be expressed as the maximum of the constriction degrees of the lips  , tongue tip and Iongue body . The net constriction degree of the oral and nasal cavities together is simply the minimmn of the two component constriction degrees  . To recast this in the present framework is straight\[or-ward  . However , we teed lo first define the operations max and rain over pairs of naltlra\]  1111111-bers  :  ( 13 ) obj MINMAX is protecting NAT . 
ops minmax : NatNat->Nat.
rare MN : Nat.
extending FEATS+MINMAX.
op_!cd:Gesture->Nat.
ops clocrit narrow mid wide obsopen : Gesture -> Bool  . 
vatG : Gesture.
vatN~1N 2:Nat.
vars0:Oral.
vars T : Tongue.
eqN ! cd = N , eqN1,N2!cd = max(N1,N2).
eqT,N ! cd = max(T ! cd,N).
eqN1,N2,0!cd~max(Nl,min(N2,0!cd)).
eqclo(G ) = S!cd == 4.
eqcrit(G ) = G!cd == 3.
eq narrow(G ) = G!cd == 2.
eqmid(G ) = G!cd == I.
eqwide(G ) = G!cd == O.
eqobs(G ) = G!cd>2.
eqopen(G ) = G ! cd < 3.

The specification CD allows classification i to five basic constriction degrees  ( c ' lo , crit , narrow , mid , and wide ) by means of corresponding one-place predicates , i . e . boolean-valued operations over gestures . For example , the fifth equation above states that G has the constriction degree c to  ( i . e . elm(G ) is true ) if and only if 6! cd == 4 . 
The working of these predicates i illustrated be -low :  ( 15 )  3  , 0  , 4  , 1  , 1! oral ! tongue ! cd . 
~4 3  , 0  , 4  , 1  , 1! oral ! cd~4a , o , 14  , ~ , 1 ~ cd . 
~3 mid(3,0,4,1,1 ! or all ~ ial).
true wide (3, O , 4, 1, l ! oral ! labial).
false open (3, 0, 4, 1, l\]oral ! labial).
true cl0 (3, 0, 4, 1, 1! oral ! tongue).
true
Reference seqmin(M , N ) =  if M <= N then M else N f i . Beierb . C . & : U . Pletat (1988) . Feature Graphs eqmax(M , N ) =  if M >= N then M else N f i . and Abstract Data Types : A Unifying Ap-endo proach  . Proeeed in 9 . ~ of the 12th lnterua-tional Conj , ' fence on Compvtational Lin- ( 14 ) obj C Disguistic , ~ , pp 4045 , Budapest , Ilnngary . 
AcrEsDECOLING-92 . NANTEs , 2328 ho ~"1992154 PROC . OFCOLING-92, NAhn'ES , AUG . 2328, 1992 Beierle , C . & II . Pletat (19881 . The Algebra of Feature Gr Nlh Specifications . W?~slie-port 94, IBMT 11-80 . 89-029 , In M Germany , Institute for Knowledge Based Syslems . 

Beierle , C . , U . Pletat & tI . lisz koreit (1988) . Ale
Algebraic Chara . cterization fs ' ruF.
LILOG Report 40, IBM Germany , Stuttgart.
Bird , S . (19901. Constraint-Based Phonology.
PhD Thesis . University of I " dinburgh.
Bird , S . ~ z1'; . Klein (1090) . Phonological events . 
Journal of Linguistics , 26, 33-56.
Browman , C . & L . Goldstein (1989) . Articula-tory gestures as llhonological units . Phouofogy , 6, 201-251 . 
Cardclli , L . (19881 A Semantics of Multiple Inheritance . Mformation and (' omputatiml . 

Clements , G . N . (19851 The Geometry of Phonological Features . Phonolo : ly ) ? arl ~'* ok .  2 . 

D6rre , J . & A . Eisele (1991) . A Coumrehensiw ' Unification-Based Grammar Formalisln  . I ) t,-liverable R3 . I . B . DYANAr , Sl'RIT Basic lie-search Action BR 3175, . January 1991 . 
Ehrig , tl . & B . Mahr (1985) l,mdam~utal . ~ of . , l/-gebruic Spceificotiou 1: Equation samlllli-lial Semauties , llerlin : Springer Vcrlag . 
Goguen , J . A . , & T . Winkler (19 SS)"ln frodue-ingOB,I3' . Technic M Report SR14', SL-SS-9 . 
Sl/1lntex ' national , (: oinlluter Sciellrel , al ) oratory , Menlo Park , (' A . 
Goguen , , I . A . , J . W . ' l:h~tcher and E . G . Wagner ( 19761' An Initial Algebra Apl ) roaeh to the Specification , Correctness and hnl ) le-mentation of Abstracll ) at a Typ (  , s ' . In R . 
Yehled . )  ( hwrent J ) ' ends in Programming Methodology II : 1 ) at a Structuring . pp 8014, 1 . Englewood (' lifts . NJ : Prenficellall . 
flyman , L . M .  (198,1) . On the weightlessness of syllable on sets . In Brugm ~ m & Macaulay ( eds . ) Proceedings of the Tenth Annual Meeting of the Berkeley Linguistics Society  . 
University of California ., Berkeley.
I ,\[ asper , ll . ~ W . llounds (19861 . A Logical Semantics for Feature Structures . Proceedings of the 24th Anmwl Meeting of the ACL , Cohuntfia University , New York , NY ,  1986 , 11t 1257-265 . 
Klein , E . (1991), Phonological Data Types . Ill Klein , E . and F . Veltlnan ( eds ) The Dynam-ics of lnteu , ' ctatiou : Proceedings of a Symposium on Natural Language and Speech  , Brusse Ls , November 26/27 ,  1991 . Springer

Newton , M . ( in prel ) m ' ~ tion ) . Grammars and Specification Languages . PhD Thesis , (' en-tre for Cognitive Science , University of Ed-in bnrgh . 
Real ) e , M .  (1991) . Fonnda . tions of L ! nification ~
Based Grammar Formalism . Deliverable \] ~ . %2 . .:k . DYANAES PRITBasic \] l . eseareh
Artion BR 3175, . July 1991.
Rounds , W . , k " A , Manaster-Ramer (1987) . Al , ogica ~ t Version of Functional Gr ~ unm ~ r . 
Proce~ . ding . , " of 25th Ammal Meeting of the . , lssoeiatior ~ for Computational Linguistics ,  6 9  , hdy 1987 . Stanford University , Stanford , ('A , 8996 . 
Sagey , E .  (1!1861 . ' l'he RepTr , sentation of Features a ~ d Relations ill Non -Linear Phonology  . Phi ) Thesis . MIT , Camhridge , Mass . 
Salmella 1) . ~: A . Tarlecki ( 1987 ) Some thoughtsm/algebraic specilira , tion . I , FCS Report Series I " , CS1 , 1;'C8- , ~7-21 , l , aboratory for Foundations of Co\[llt ) uler Science , University of

Shieber , S .  (1986) . A ~ Introduction to Uni-fication-Based Approaches to Grammmar  . 
CSI , I Lecture Note Series , University of
Chicago Press , Chicago.
Smolka , C, . and II . Ai't-Kaci ( 1 9891 ' Inheritancellier archies : Semantics and Unifiea ~- lion '  . .Iour~lol of Symbolic (' omputation ,  7 ,  '3 , t' , 1 370 . 
ACRESDE COLING-92 . NANTES , 2328 AOt ~' r1992155 PROC . OFCOLING O2 . NANTES , Aua .  2328, 1992
