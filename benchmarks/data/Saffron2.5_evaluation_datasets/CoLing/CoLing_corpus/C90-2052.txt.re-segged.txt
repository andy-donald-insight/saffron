Reversible Unification Based Machm . Franslatlon
Gertjan van Noord
OTS RUU Trans10
3, 512 JK Utrecht

March 28, 1990

\[ n this paper it will be shown how unification grammars can be used to build a reversible machine translation system  . 
Unification grammars are often used to define the relation between strings and meaning representations in a declarative way  . Such grammars are sometimes used in a bidire cLi on alway  , thus the same grammar is used for both parsing and generation  , in this paper 1 will show how ~ . ouse bidirectional unification grammars to dethlerever sible relations between language dependent meaning representations  . Furthermore it is shown how to obtain a completely reversible MT system using a series of  ( bidirectional ) unification grammars . 
l Introduction
The notion of a rew : rsible MT system was first expressed by L and sbergen  \[11\]  . Such a system will in principle produce a set of possible translations  , by employing linguistic knowledge only . Choosing the bestiranslation from the set . of linguistically possible translations will rsually require other sources of knowledge  , either incorporated in the systen lor provided ( interactively ) by the . user . The relation ' possible translation ' is symmetric whereas the relation ' best translation ' is not  . 
Thus an MT system may consist of a reversible core  , implement i ~: g the symmetric relation ~ possible translation '  , and additional components ( not necessarily reversible ) to select tile best translation . 
Not only is it pos . siblc to build reversible ( modules of ) MT systems ; it has also been claimed that reversible systems are preferable  . For example Isabelle \[6\] clahns that reversible MT systems are to be preferred to oth-  ( :rsbe ( : ~ nlse in reversible MT systems a better understanding of the translation re  . lation is achieved ; such systems will eventually exhibit better practic M performance  . Moreover , the arguments in favour of using bidirectional grammars in  NL1   )  , such as those given in \[1 , 8\] carry over to translation as well . 
Because o \[ tile declarative nature of unification - and logic grammar form Misms grammars written in these formalisms are increasingly used in a bidirection alway  , thus thesa . megrammar is used for both parsing and generation  . Some recent developments are reported in \[3 ,  24 ,  16 ,  21 ,  2 ,  18 ,  19 ,  22 ,  20\] . 
In this paper I will show how to use such bidirectional unification grammars to build a completely reversible  , multilingual , MT system . For each language there is a unification grammar that defines a reversible relation between strings and language dependent lnean-ing representations  ( logical forms )  . Moreover , for each language pair ( or set of languages ) there is a unification grammar that defines a reversible relation between such language dependent logic M forms  . Translation is thus detined by a series of three unification granrmars  . 
A specific version of the system that is described here is implemented as the  ( : ore of the experiments ! MiMo2 translation system \[23\]  . This system aims at translating international news items on felc text  . Apart from unification grammars the system rises a bidirectional two-level orthography component  . Language de . -pendent meanings are represented as simple predicate argument structures with some extra labels indicating ' universal ' meaning such as tense and aspect  . The cur . -rent system ( November 1989 ) includes grammars for
Dutch , Spanish and English.
The paper is setup as follows . In section 2 , I will give some examples that show how bidirectional uni-tication grammars can be used t  . o define relation ~ between logical forms of diiferent languages  . In section 3 , reversibility is detined in terms of symmetry and con > patability  . Possible approaches to obtedure versibility are discussed  . In section 4 , I wilt compare the current approach with some other approaches in tile unification based translation paradigm and discuss some problems and future directions  . 
2 Unif ication-based Transfer in this section 1 wilt give some exan@les of the use of a unification grammar  ( in PATRII\[17\]notation ) to define the relation between language dependent logical forms  . For illustrative purposes I will assume logical fl  ) rms are represented by feature structures consisting of the attributes pred  , ar . ql ,   art2 together with some attributes representing ' univers M ' meaning such as tense  , aspect , munber and person ; I will not touch upon issues such a ~ squant if ication and modification  . 
The logical forlns of English and Spanish are labeled by the attributes  9 b and s p respectively . As an example ians ' is represented as in figure 1  . Such feature struc-Figure 1: An example of a logical form gb = pred = open_fire_at ? ~ ulttber :  . sg\[wed=civilian \] arg2 = number -- pltures will often be related illa straightforward way to a Spanish equivalent  . , except for the value of the prod attributes . A very simple rule in PATRII style may look as in figure  2  . This rule simply states that the
Figure 2: A simple rule 0--+123 ( 0 gbpred )  =  ( 1gb )   ( 0 g bargl )  =  ( 2gb )   ( 0gb arg2 >= ( 3gb )   ( 0 sppred ) = < 1 s p )   ( 0 spgl )  =  ( 2s p > ( 0 sparg 2 )  =  ( 3 sp ) translation of a logical form is composed of the translation of its arguments  . If the rule applies to the feature structure in 1 tile three daughters of the rule will be instantiated as in figure  3  , and the value of sp will be bound to the sp values of these daughters  . An example
Figure 3: Three instantiations\[gb = open_fire_at\]\[ 1 gb = namber = pl ' ~ umber ~- sg of the rule for the first daughter will be a lexical entry and looks asiu figure  4  . The simple English expression ' army ' has to be translated as a complex expression iSpanish : ' Nerzamilitar '  . The rule will look a . sin 5 where it is assumed that the construction is analyzed in Spanish as an ordinary noun-adjective construction  , and where the logical form of the adjective takes the logical form of the noun as its argument  . The translation for ' civilian ' is defined in a similar rule  ( although the translation of ' number ' is different  )  . Note that this example of complex transfer is similar to the famous's chimmel-grey horse ' cases  . As a result of the rule
Figure 4: A lexical entry 0--~<0 gb ) = open_fire_at ( 0 sp > = romper_el_fuego_a Figure 5: A rule for ' fuerzar nilitar ' 0  ---~  ( 0 gbpred )  =  , army ( 0 appred pred ) = militar ( 0s parglpred ) = fuerza ( 0s pargln mnber )  =  ( 0 gb number  applications the feature structure in figure  1 will get instantiated to tile feature structure in  6  , from which the generator generates the strir ~ g' Lafllerzamilitar rompioel fue goal a poblacion civil '  . 
Figure 6: The feature structure after transfer 9b = sppred = open_fire_at\[pred .   .   .   .   .   .   . y\]argl:-xn . ur  ~ zbe , = s 9 pred=civilian arg2 = : t~umber ---- plpred = romper_el_fuego_a ar  9   1  =  at92  = \]  ar91 pred=\]uerza , z t t r l l b e v ~ . sffpred = poblacioI ~ at 9!L , ; . , arnber = s 9 In the foregoing examples the relation between Iogi-car forms is rather straightforward  . Note however that tile full power of a unification grammar can be used to settle more difficult translation cases  , because differellt attributes can be used to represent the ' translational syntax '  . For instance we can build a tree as value of the attribute tree to represetlttile derivational history of the translation process  . Or we can % hread ' informa-tion through different nodes to be able to make translations dependent on each other  . Translation parameters such as style and subject field can be percolated as attributes of nodes to obtain consistent translations  ; but these attributes themselves need not be translated  . 
3 Reversible Unitication

A unification grammar defined in formalism such as PATRII and  1  ) CG \[12\] usually defines a relation between a string of words and a logical form  . In sign-based approaches such as UCG \[26\] and flPSG \[14\] this string of words is not assigned a privileged status but is the value of one of the attributes of a feature structure  . I will assume a formalism similar to PATR II , sented as the value of one of the attributes of a feature structure  . Thus more generally , unification grammars define relations between the values of two  ( or more 1 ) attributes - for example the relation between the value of the attributes string and If  , or between the value of the attributes sp and gb ; these relations are all relations between feature structures  . 
3.1\] Reversibility
I will call a binary relation reversible if the relation is symmetric and computable  . Both symmetry and computability will be explained in the following subsections  . A grammar G is reversible for a relation R iffR is reversible and defined by G  . For example , a grammar that relate strings to logical forms is reversible if both the parsing and generation problem is computable  , and the relation between strings and logical forms is symmetric  ; the parsing problem is computable if for a given string all corresponding logical forms can be enumerated by some terminating procedure  ; such a procedure should halt if the given string does not have a corresponding logical form  . Thus : reversible -- symmetric + computable . Note that reversibility as defined here is different from bidirectionality  . The latter merely says that grammars are to be used in two directions  , but does not state how the two directions relate . 
It is easy to see that a composition of reversible relations is a a reversible relation too  ; i . e . if some feature structure fl is related to some feature structure f ~ via the reversible relations  . R i ( f i , fi+l ) , each defined by some reversible grammar Gi , then R'(fl , fn ) is reversible . Thus an MT system that defines a relation R ( , % , s t ) via the relations t ~( s ~ ,  5) , Ry(l  ~ , lt ) and Ra(lt , s t ) is reversible if R1 , 2 , 3 are reversible . 
3.1.1 Symmetry
A relation RCA x B is symmetric iff R(a , b ) implies R(b , a ~) where a and a ' are equivalent . For an MT system we want to define ' equivalence ' in such a way that the translation relation is a symmetric relation between strings  , t to wever , strings are feature structures thus w c must define equivalence for feature structures to obtain this effect  . 
Unification grammars as they are commonly used implement a rather weak notion of equivalence between feature structures : feature structures a and b are equiv- 
Ment if they ca ~ ~ if >.:
Definition I ( Weak equivalence)
Two feature structures fl , f2 are weakly equivalent iffflUf2 exists . 
if feature structures are taken to stand for all their groum liust ancest his yields an acceptable version of sym  ; ~ e . try . Moreover , under the assumption that 1 Note that it is possible to define a unification gra~nmar that relate several language dependent logical forms  ; in this approach a multilingual transfer system consists of only one transfer gramm  , ' m feature structures which represent strings are always ground  ( i . e . these feature structures cannot be extended ) , this results in a symmetric relation between ( feature structures that represent ) strings . 
It is also possible to define a ' strong ' notion of equivalence for feature structures that does not rely on this assumption  . 
Definition 2 ( Strong equivalence ) Two feature structures fl , f2 are strongly equivalent ( fl = -- f2 ) iff/2EA and AEf2 . 
A grammar that defines a computable rlation between two attributes under the strong definition of equivalence might be cM led strongly reversible  . Similarly a weakly reversible grammar is reversible under a weak definition of equivalence  . Again these results can be gener Mized to a series of unification grammars  . The strong version of equivalence can be motivated on the ground that it may be easier to obtain computability  ; this is the topic of the next subsection . In section 3 . 2 I will discuss possible relaxations of the strong version of equivalence to obtain ' mildly ' reversible grammars  . 
3.1.2 Computability
A relation RCA xB is computable iff for a given aEA the set bCB\]R  ( a , b ) can be enumerated by some terminating procedure . To discuss cornputabil-ity it is useful to look a bit more careful at the relations we are interested in  . These relations are all binary relations between feature structures  , t to wever , in tile case of the relation between strings and logical forms  , strings will always be related to logical forms and logical forms will be related to strings  . Similarly for the relation between l ) ut ch and Spanish logical forms . 
Clearly , the domain and range of the relation is structured and can be partioned into two sets A and  \]3  , \[ or example the set of feature structures representing strings and the set of feature structures representing logical forms  . The relation RCAUBxAUB can be partitioned similarly into the relations rCAxI\] and its inverse  , r-~CBxA . The problem to compute R is now replaced by two problems : the computation of r and r  -1  . For example the problem to compute the relation between logical forms and strings consists of the parsing - and generation problem  . It is now possible to incorporate the notion of equivalence  , to obtain a definition of a parser , generator and translator . For example , an Mgorithm that computes the foregoing relation r will enumerate for a given feature structure f l all features trnctures fy  , such that r(f a , f y ) and f ~ and f3 are equivalent . In the case of strong equivalence this implies that f l ~  f3   ( completeness )  , and faUfl ( coherence ) . In other words , the input should not be extended ( coherence ) and should completely be derived ( completeness )  . This usage of the terms completeness and coherence was introduced in  \[24\]  . In the following I will discuss ways to obtain computability of one such partition  . 
It is wellknown that relations defined by unrestricted unification grammars are not computable in general a ~ s decidable whether the relation is defined for some given input  . Usually some constraint on grammar side fined to remedy this  . For example the off-line-parsability constraint \[13  ,   5\] ensures that the recognition problem is solvable . Moreover this constraint also implies that the parsing problem as defined here is computable  ; i . e . 
the proof procedure will always terminate ( because the constraint implies that there is a limit to the depth of possible parse trees for all strings of a given length  )  . 
llowever the off-line-parsability constraint assumes a contextfree base of the formalism  . A generalization of the off-line-parsability constraint for any binary relation defined by unification grammars will consist of three parts  ; the first and third of these parts are usually implicit in the case of parsing  . 
Pirst , the value of the input must be builtinawell -behaved composition alway  . For example in the case of parsing : each daughter of a rule dominates part of the string dominated by the mother of that rule  . Similarly for transfer and generation : each daughter of a rule has a value for If that is part of the value of If of the mother  . 
Second , a special condition is defined for rules where the input vMue of the mother is the same as the input value of one of the daughters  . \[: or parsing such rules have exactly one daughter  . A chain of applications of such rules is disallowed by some constraint or other  ; this is the core of most definitions of the offline parsability o constraint  . For example in \[13\] such a chain is disMlowed as the principal functor of a term may only occur once in a chain  . For a slightly more general definition , cf .  \[5\] . For generation and transfer a similar constraint can be defined  . In the terminology of \[18 ,   19\] the ' head ' of a rule is a daughter with the same logical form as its mother  . A chain of these heads must be disallowed . 
Third , the input should not get extende during the proof procedure  . In the case of parsing this is achieved eaMly because the input is ground  2  . For generation and transfer this is not necessarily the case  . This is the point where the usefulness of the coherence condition comes in  ; the coherence requirement explicitly states that extension of the input is not allowed  . For this reason strong reversiblity may be easier to obtain than weak reversibility  . In the next subsection I will discuss two relaxations of strong symmetry that will not affect the computability properties discussed here  . 
Generalizing the terminology introduced by \[13\] a proof procedure is strongly stable iff it always terminates for grammars that adhere to a generalized offline parsability constrMnt  . In \[15\] a general proof procedure for DCG based on head -driven generation  \[18  ,  19 ,   22\] is defined that is strongly stable for a specific instantiation of the generalized offline parsability constraint  . 
?' Note that this is the reason that most DCG parsers expect that the input value of the string has an atomic tail  , i . e . parse(\[john , kisses , mary \] , ~) will work fine , but parse (\[ john , kisses , mary \] X\] , X ) will cause problen as . 
3.2 Possible relaxations
It is easy to see that the completeness and coherence requirenrents makelife hard for the rule writer as she/he needs to know exactly what the possible values of inputs are for some component  . It is possible to relax the completeness and coherence requirement in two ways that will not affect the reversibility properties between strings  . The usefl finess of these relaxations depends on the analyses a user wishes to define  . 
3 . 2 . 1 Cyc l i c and non-cyc l i c a t t r ibutes The first relaxation assumes that there is a sort system defined for feature structures that makes it possible to make a distinction between cyclic and noncyclic attributes  ( cf .  \[5\]) . For the moment a noncyclic attribute may be defined a  . s an attribute with a finite number of possible values  ( i . e . it is not recursive ) . For example the attributes argland arg2 will be cyclic whereas number will be noncyclic . The completeness and coherence condition is restricted to cyclic attributes  . As the proof procedure can only further instantiate noncyclic attributes no termination problems occur because there are only a finite number of possibilities to do this  . The definition of ' equivalence ' for feature structures is now slightly changed  . \[\[b define this properly it is necessary to define the notion noncyclic extension  . A noncyclic extension of a feature structure only instantiates noncyclic attributes  . This results in the following definition of equivalence : Definition  3   ( Non-cyclic equivalent ) Two feature structures f : , f2 are non . cyclic equivalent ifff ~_=__ f ~ where f ~ are noncyclic extensions of f  , ~ . 
It will be clear that the usefulness of this definition depends heavily on the style of grammar writing that is used  . Note that it is of course also possible to declare for each noncyclic attribute whether the completeness and coherence requirements hold  . 
3.2.2 Reentrancles
The second relaxation is not without ramifications for the organization of a transfer grammar  . Tlf is relaxation has to do with reentrancies in feature structures  . 
Some constructions such as control verbs and relative clauses may be represented using reentrancies  ; for example ' the soldiers tried to shoot the president ' may be represented by a feature structure where the first argument of ' try ' is reentrant with the first argument of ' shoot '  , cf . figure 7 . The translation of such logical forms to Dutch equivalents can be defined as in rule  8  . 
In this rule the reentrancy is explicitly mentioned for two reasons  . The first reason is simply that in the case of different possible translations of  ar91 we want the same translation for both argland the embedded argl  . Note that the translation of ' soldier ' into Dutch can be both ' solda at ' or ' militair '  . If the reentrancy is not mentioned the system has to try to generate from four different Dutch logical forms  , two of which without matching argl's . 

Figure 7: A logical form contain in greentrancy gb = pred = tryargl=\[\]\[pred=soldier number=pl\] ar  . q 2 = argl =\[\] pred = president arg2 = nu'mber=sg Figure 8: Translating subject control 0  - -  . 123  ( 0 gbpred )  =  ( 1gb ) < 0 nl pred = < ~ ~ p > ( 0 n l a r g l )  =  ( 0 nlarg2 argl ) < ogb ~ rg1 >= < 2gb )   ( 0 nl~rg1>=<2 ~ p > < 0 gbarg2 = ( 3 gb > < o n:L ~ g2  =  <3 ~ p > The reentrancy is also mentioned because this is required by the completeness condition  . It is possible to relax the completeness and coherence condition with respect to these reentrancies  , again without directing the reversibility properties of the system by slightly changing the definition of equiva \] ence  . There is a tradeoff between simplicity of the transfer grammar  ( in the presence of this relaxation ) and the efficiency of the system . In the case of this relaxation the system will eventually lind the good translations  , but it may take a while . On the other hand , if we are to mention all ( possibly unbounded ) reentrancies xplicitly then the transfer grammar will have to be complicated by a threading mechanism to derive such reentrancies  . Again , the specific use o:\[reentrancies in the logical forms that are defined will deterlnine whether this relaxation is desired or not  . 
4 Final remarks
The objective to build a reversible MT system using a series of unification grammars is similar to the objective of the CRITTER system as expressed in  \[3  ,  7\] , and the work of Zajacin\[25\] . Instead of using unification grammars CRITTER uses logic grammars  ; Zajacuses a type system including an inheritance mechanism to define transfer-like rules  . In these two approaches less attention is being paid to an exact definition of reversibility  ; although our work may be compatible with these approaches  . 
A somewhat different approach is advocated in \[9\]  . 
In that approach a system is described where an I , FG grammar for some source language is augnlented with equations that define  ( part of ) the target level representations . A generator derives from this partial description a string according to some LFG grammar of the target language  . Instead of a series of three grammars this architecture thus assumes two grammars  , one of which both defines the source language and the relation with the target language  . The translation relation is not only defined between logical forms but may relate ~ ll levels of representation  ( c . structure , f-structure , a-structure ) . Although in this approach monolingual grammars may be used in a bidirectional way it is unclear whether the translation equations can be used bidirectionally  3 An important problem for the approach advocated here is the problem of logical form equivalence  . Shieber \[16\] noted that unification grammars usually define a relation between strings and some canonical ogical form  . Depending on the nature of logical forms that are being used  , sever M representations of a logical form may have the same ' meaning '  ; just as in first order predicate calculus the formulas pvq and qvp are logically equivalent  ; a unification grammar will not know of these equivalences and  , consequently , all equivalences have to be defined separately ( if such equivalents are thought of as being translational equiwdents  )  ; for example in a transfer grammar two rules may be defined to translate pVq into both p ' V q ' and q ' Vp ' if these formulas arc thought of  , ~ being equivalent . Of course this technique can only be applied if the number of equivalences is finite  , it is not possible to define that p is equivalent with  .   .   .   .   . p for any even number of --' s . 
The approach discussed so far can be extended just as unification grammars for parsing and generation have been extended  . Apart from equation M constraints it will be useful to add others such as disjunction and negation  . Moreover it seems useful to allow some version of universal constraints or some inheritance mech -an is rn to be able to express generalizations and exceptions more easily  . 

I want to thank Joke Dorrepaal , Pimvander Eijk , Maria Florenza , Dirk Iteylen , Steven Krauwer , Jan Landsbergen , Michael Moortgat , II erbert Ruessink and Louisdes Tornbe . I was supported by the European Community and the NBBI through the Eurotra project  . 
References\[1\]DouglasE . Appelt . Bidirection algr~nmars and the design of natm'al language generation systems  . In Theoretical Issues in Natural Language Processing  3  ,  1987 . 
\[2\] Jonathaal Calder , Mike Rcape , and t lenk Zeev at . An algorittma for generation i unification catcgorial grammar  . In Fourth Con . ference of the European Chapter of the Association for Computational Linguistics  ,  1989 . 
\[3\] Marc Dymetman ~ ld Piel Te Is a bell c . Reversible logic grannnars for machine translation  . In Proceedings of the Second International Conference on Theoretical  3Although parsing of LFG's is decidable no such result is available for generation  ; ote furthermore that according to \[9\] extension is Mloweddm'ing generation . 
3 03 and Methodological issues in Machine Translation of 
Natural Languages , 1988.
\[4\] Barbara Qrosz , Karen Sparek Jones , and Bonny Lynn Webber , editors . Readings in Natural Language Processing . Morgan Kaufinann , 1986 . 
\[5\] Andrew Haas . A generalization of the offline parsable grammars  . In '27th Annual Meeting oJ the Association for Computational Linguislies  ,  1989 . 
\[6\]Pien'eIsabelle . Towards reversible MT systems . In MT
Summit \] I , 1989.
\[7\] Pien'eIsabelle , Marc Dymetman , and Elliott Macldo-vitch . CRITTER : a translation system for a ~' ie ultur M market reports  . In Proceedingso/the 12th International Conference on Computational Linguistics  , Budapest ,  1988 . 
\[8\] Paul S . Jacobs . Achieving bidirection ' Mity . In Proceeding so \] the 12th International Conference on Computational Linguistics  ,  1988 . 
\[9\] Ronald Kaplan , Klaus Netter , Jiirgen Wedekind , and Annie Zaenen . Translation by structural correspondences . In Fourth Conference o \] the European Chapter of the Association for Computational Linguistics  ,  1989 . 
\[10\] Margaret King , editor . Machine Translation , the State o \] the . 4f t . Edinburgh University Press , 1987 . 
\[11\] Jan Landsbergen . Isomorphic grammars and their use in the Rosetta translation system  ,  1984 . paper presented at the tutorial on Machine Translation  , Luganot 984 , Also appears in \[10\] . 
\[12\] Femando C . N , Pereira and David WaITen . Definite clause grammars for language analysis - a survey of the form Mism and a comparison with augmented transition networks  . Artificial Intelligence , 13, 1980 . reprinted in 114\] . 
\[13\] Femando C . N . Pereira and David Wan'ca . Parsing as deduction . In 21st Annual Meeting of the Association/or Computational Linguistics  ,  1983 . 
\[14\] Carl Pollard and Ivan Sag . In . formation Based Syntax and Semantics . Center for the Study of Langalage and
Information Stanford , 1987.
\[15\] Herbert Ruessink attd Gertjan van Noor d , Remarks on the bottom-up generation Mgorithm . Technical report , Department of Linguistics , OTSRUUU trecht ,  1989 . 
\[16\]StuartM . Stfieber . Amfiform architecture for parsing and generation  . In Proceedingso/the 12th International Conference on Computational Linguistics  ,  1988 . 
\[17\]StuartM . SIfieber , Hans Uszkoreit , Fernando C . N . 
Pereira , J . Robinson , and M . Tyson . Tile formalism and implementation of PATR-II . In B . J . Grosz and M . E . Stickel , editors , Research on Interactive Acquisition and Useo\] Knowledge  . SRI report , 1983 . 
\[18\]StuartM . Shieber , Gertjan van Noord , Robert C . 
Moore , and Fernando C . N . Pereira . A semantic-head-driven generation Mgorithm for unification based for-mMisms  . In 27th Annual Meeting of the Association . for Computational Linguistics , 1989 . 
\[19\]StuartM . Shieber , Gertjan van Noord , Robert C . 
Moore , and Fernando C . N . Pereira . Semantic-head-driven generation . Computational Linguistics , 1990 . 
To appear.
\[20\] Tomek Strzalkows ld . Automated inversiot ) of a unification parser into a unification generator  . Technical report , Courant Institute of Mathematical Sciences , New York University ,  1989 . technical report 465 . 
\[21\] Gertjauvan Noor d . BUG : A directed lmt to m-up generator for unification ba~sedfonnMisms  . Working Pa-persia Natural Language Processing , Katholieke Universiteit Leuven , Stichting Taaltechnologie Utrecht ,  4 ,  1989 . 
\[22\] Gertjan van Noor d . An overview of head-driven bottom-up generation . In Robert Dale , Chris Mellish , and Michael Zock , editors , Current Research in Natural Language Generation .  1990 . 
\[23\] Gertjanvail Noor d , Joke Dorrepa M , Louisdes Tombe , and Pimvander Eijk . The MiMo2 research system . 
OTSRUUU trecht.
\[24\] Jiirgen Wedekind . Generation as structured riven derivation . In Proceedingso/the 12th International Conference on Computational Linguistics  ,  1988 . 
\[25\]RdmiZajac . A transfer model using a typed feature structure rewriting system with inherit cnce  , In 27th Annual Meeting of the Association for Computational 
Linguistics , 1989.
\[26\]\[ leak Zeev at , Ewau Klein , and Jo Calder . Unification categorial grammar . In Nicholast I addock , Ewan Klein , and Glyn Morrill , editors , Categorial Grammar , Unification Grammar and Parsing . Centre for Cognitive Science , 1987 . Volume 1 of Working Papel . 's in Cognitive Science . 

