Programming of Reversible Systems in Computat ional Linguistics 
Gerhard Engelien , Forschungsgruppe LIMAS , Bonn ~ ~ I ~ ~ ~ ~ ~"

In mypaper I shall report on some aspects of programming rever- 
sible systems , in particular the special problems invo lved with programming non-numerical systems  .  / (~  . j  ~ Dr . Alfred Hoppe of Forschuugsgruppe LIMAS has developed a pro-/cedure for a reversible data flow  ( Figure I )  . ' In the matrix /% hree ~- different quant ities are connected together  . For analysis ~ hegrammatical description of an inflected form is determined by combin ing the inflection class with the ending  . For example the German verb ~ ehen is composed of the stem ~ e h and the ending e_~u  . 
The lexicon tells us that ~ eh belongs to inf lection class B  . By combining the channels of inflection c lass B and the ending e__u  . u /- . 
we are able to determine the grammatical descr iption of the v ~ L ?  )   ( which is in this case ambiguous )   . Each of these groups contains , ~ a series of binary variables whose value is either zero or one  . 
The synthesis processunites the channels wi th the grammatical variables  , the result being the appropriate ending . 
The matrices contain only " and " and " or " gates and an element which can block the flow in one direction  , ascertain linguistic forms will be an a lyzed but not syuthesized  . Techuical ~ lized , ~ the matrix d~s plays an example of parallel processing which is both complex as well as rapid  . 
For the present time the LIMAS system will be programmed for con-ventional computers  , which operate more or less sequentially . 
Thus programming such a matrix involves simula ting this parallel data flow on a sequentia lly operatiug machine  . One must , however , take into consideration that this will resu lt in an increase of running time  . But for purposes of testing whether or not the end data have been correctly combined to del iver the final result this time increase is irrelevant  . 
Besides the parallel processing one must a lso consider reversi-bility  . We have discovered that reversibility has not made pro-gramming more difficult  ; on the contrary , it has facilitated the program debugging process  . 
At first the matrices will be programmed to flow only in the di-rection of synthes is  . For a halys is one would have to write every possible form of a large number of words on punch cards in order to test all the variat ions  . This , of course , would require an immense amount of work . It is a great deal simpler to let the computer print out the inflected forms  , and then check the output to see if they are correct  . The feature of reversibility thus makes it possible to test both directions  , i . e . analysis and syn-thesis , at the same time . 
-I-.8-2-
I would like to discuss briefly various procednres which facili-tate the simulat ion process  . All descriptive categories such as case , numbe ~ , person , etc . are coordinated with the various en-dings . The problem is therefore to compute the combined values of certain binary variab les from the combined values of certain o the r binary variables  . List processing is probably the bests ui -ted method for this type of problem  . 
Figure 2
Ending ? X?.
geh/en
Inflection Class ? X ? ?

Grammatical Information . X . . . X . . .
I-pl 3-pletc.
The variables assume their meaning according to the arrangement in the rows and columns  . It is obvious that each line of such al is t can be stored in one or more machine words  . 
It is necessary to have a program which will encode endings  , in-flection classes , and grammatical information in bi~-combina  -  , ions , and a search program which can locate the respective bit-combinations in the list ? For analysis the suffix bit pattern and inflection class bit pattern a reg iven  , and the list is searched for the line in wh ich they are stored ? This line also conta ins the grammatical bit pattern  , the object of the search . 
The results can be printed out with the he lp of a decoding pro-gram  , or else they can remain encoded and be processed at a higher level in the ~ ystem  . The synthesis process is similar except that the grammatical bit pattern is given in p lace of the suffix bit pattern  . The suffix bit pattern is then the objec t of the search  . 
The list method has the advantage that necessary expansions or changes can easily be carried out during the developing stages w it hout affecting the actual program  . 
Another programming possibility results f roma formula-like representation ? All variables of a line in the list are to be consecutively indexed ?  ( a1 , a2 ,   . . . , an ) Wi th the a id o f log ica l funct ions ( e . g . the Boolean full form ) it is possible to represent the process in the following way : ai ~ Fi  ( aI , a2 ,   . . . , a n ) i = 1 , nfA search procedure is no longer necessary . Instead , as many logical equations will be computed as there are variables ? Of course the variab les will have to remain stored ? until the f inal result is available  . It is possible to obtain these formula-li ke representations automatically from the l ists  , and to auto --3 -~matically minimize the obtained fo rmulas  , i . e . to establish the smallest number of binary operations  . 
The lists can also be stored in a three-d i mensional binary matrix  . 
E\>Ki ~ , g , e ~
Such matrices can be processed by formulas of the following type : 

G g ? : : : : : E e ^ e
E e ~ G g ^( ~( K k g I ~ . , g , e))g-( . here ~, ~ are binary operators . 
The procedure becomes clear if one imagines that the list is divided into sublists  , and that for any given channel only one of the sublists is to be searched  . The saving of time which resuits from such a procedure is evident  . 
One can also increase the throughput by taking into account the frequency of the forms  , in that the list is arranged in decrea-sing order of frequency  . 
If the matrices are internally wired these considerations are no longer valid  , as the acceleration factor would be about 1000  . 
There are several basic features which dist inguish numerical from non-numerical data processing  . Numerical data processing ~ s generally characterized by : A relatively small amount of input n  , """ output
Extensive internal computation
Most conventional computers are designed for such tasks  . On the other hand non-numerical work involves  : 
A large amount of input """" output A relat ively small amount of actual computation The use of a large storage capacity 
No floating point computation
Forschungsgruppe LIMAS uses the computing center at the Institut ~ f ~ r  . Instrumentelle Mathematik at Bonn University . T ~ main programming language is FORTRANII?Al though FORTRAN was developed for numerical purposes it represents a relatively useful compromise between the various programming languages ? The flexible sub-program system and  , the possibility of calling machine language programs from FORTRAN programs serve to faci ! ~ tate the programmiDg of non-numerical problems  . ~ In order to simplify and expedite the programss a computer with the following features would be desirable ~ 
Byte-structure storage
Magnetic tape readers which operate in both di rections 
A large disk storage area
A- , high-speed printer with upper ~ and lowercase and ' special characters A sophisticated  , wired addressing procednre The last desideratum is justified in that non-numerical data pro  -  . . . . . . ue~s ing i s - h igh ly dependent on ~ ddress man ipu la%ion  . -~s same reason , relative .   .   .   .   .   .   .   . addressing addresslng ~ in ~- i-~ect-r ~ uur sxve and multiple addressing should be available  . It should also be possible to an nex extra hardware such as Dr  . Hcppe's matrix . 
Wired search and sorting programs would also Me practical  . 
With this sketch of some technical aspects of data processing I shall close my remarks  . Thank you . 

