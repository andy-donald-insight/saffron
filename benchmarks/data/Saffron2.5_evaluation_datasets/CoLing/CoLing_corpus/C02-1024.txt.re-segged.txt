Interleaved semantic interpretation in environment -based parsing 

William Schuler
Computer and Information Science Dept.
University of Pennsylvania
Philadelphia , PA 19103


This paper extends a polynomial-time parsing algorithm that resolves structural ambiguity in input sentences by calculating and comparing the denotations of rival constituents  , given some model of the application environment ( Schuler ,  2001) . The algorithm is extended to incorporate a full set of logical operators  , including quantiers and conjunctions , into this calculation without increasing the complexity of the overall algorithm beyond polynomial time  , both in terms of the length of the input and the number of entities in the environment model  . 
1 Introduction
The development of speaker-independent mixed -initiative speech interfaces  , in which users not only answer questions but also ask questions and give instructions  , is currently limited by the inadequacy of existing corpus-based disambiguation techniques  . 
This paper explores the use of semantic and pragmatic information  , in the form of the entities and relations in the interfaced application's runtime environment  , as an additional source of information to guide disambiguation  . 
In particular , this paper extends an existing parsing algorithm that calculates and compares the denotations of rival parse tree constituents in order to resolve structural ambiguity in input sentences  ( Schuler ,  2001) . The algorithm is extended to incorporate a full set of logical operators into this calculation so as to improve the accuracy of the resulting denotations and thereby improve the accuracy of parsing without increasing the complexity of the overall algorithm beyond polynomial time  ( both in terms of the length of the input and the number of entities in the environment model  )  . This parsimony is achieved by localizing certain kinds of semantic relations during parsing  , particularly those between quantiers and their restrictor and body arguments  The author would like to thank David Chiang  , Karin Kipper , and Alexander Koller , as well as the anonymous reviewers for comments on this material  . This work was partially supported by NSF IIS-9900297 and DARPA N66001-00-1-8915  . 
(similar to the way dependencies between predicate and argument head words are localized in lexicalized formalisms such as tree adjoining grammars  )  , in order to avoid calculating exponential higher -order denotations for expressions like generalized quantiers  . 
2 Basic algorithm
This section describes the basic environment-based parser  ( Schuler , 2001) which will be extended in Section 3 . Because it will crucially rely on the denotations  ( or interpretations ) of proposed constituents in order to guide disambiguation  , the parser will be dened on categorial grammars ( Ajdukiewicz , 1935; Bar-Hillel ,  1953) , whose categories all have well de-ned types and worst-case denotations  . These categories are drawn from a minimal set of symbols C such that : 
NP2C and S2C ; if ; ?2C then=?2C and n?2C : Intuitively , the category NP describes a noun phrase and the category S describes a sentence  , and the complex categories = ? and n ? describe ` a lacking a ? to the right ' and ` a lacking a ? to the left'respectively  ; so for example SnNP would describe a declarative verb phrase lacking an NP subject to its left in the input  . 
The type T and worst-case ( most general ) denotation W of each possible category are dened below  , given a set of entities E as an environment : T ( S ) = t : truth value W ( S ) = fTRUE ; FALSEg
T ( NP ) = e : entityW(NP ) = E
T (=?) = hT (?) ; T ( ) iW (=?) = W (?)  W ( ) T ( n ?) = hT (?) ; T (   ) iW ( n ? ) = W ( ? )  W (   ) The denotation D of any proposed constituent is constrained to be a subset of the worst-case denotation W of the constituent's category  ; so a constituent of category NP would denote a set of entities  , feSnNP would denote a set of entity  truth value pairs  , fhe denotation of a constituent can contain more than 
O(jEjv ) dierent elements , where v is a valency measure of the number of NP symbols occurring within the constituent's category  . 
This paper will use the following denition of a categorial grammar  ( CG ) : Denition A categorial grammar G is a formal grammar  ( N ;  ; P ) such that :  is an ite set of words w ;  P is an ite set of productions containing : ! w for all  w2  , with 2C , ! = ?? for every rule = ?!::: in P , ! ? n ? for every rulen ?!::: in P , and nothing else ;  N is the nonterminal set fj !::: 2Pg . 
and the following deductive parser , extended later to handle a richer set of semantic operations  . The parser is dened with :  constituent chart items [ i  ; j ; ] drawn from In
In the input can be characterized by category ;  a lexical item [ i ; j ; ] for every rule ! w 2 P if w occurs between positions i and j in the input  ;  a set of rules of the form : [ i ; k ; = ?] [ k ; j ; ?] [ i ; j ; ] for all ! = ? ?2P ; i ; j ; k2In[k ; j ; n ?] [ i ; k ; ?] [ i ; j ; ] for all ! ? n ? 2P ; i ; j ; k 2 In and can recognize an n-length input as a constituent of category  ( for example , as an S ) if it can deduce the chart item [0 ; n ;  ] . 
This parser can be implemented in a dynamic programming algorithm  , using the recursive function :
F ( x ) = _ aks : t : ak  xk^i = 1
F ( ai ) ( where x ; ak are proposed constituents drawn from Inn
W ;= FALSE , and
V ;= TRUE) , by recording the result of every recursive sub -call to F  ( x ) in a chart , then consulting this chart on subsequent calls to F  ( x ) for the same x constituent . 

Since the indices in every rule's antecedent constituents ak each cover smaller spans than those in the consequent x  , the algorithm will not enter into an innite recursion  ; and since there are only nent rules that could prove any consequent x  ( two rule forms for = and n , each with n dierent values of k ) , the algorithm runs in polynomial time : O ( n The resulting chart can then be annotated with backpointers to produce a polynomial-sized shared forest representation of all possible grammatical trees  ( Billot and Lang ,  1989) . 
Traditional corpus-based parsers select preferred trees from such forests by calculating Viterbi scores for each proposed constituent  , according to the recursive function :

V(x ) = max aks : t : akxk
Yi = 1

V ( ai)!P ( akj  x)
These scores can be calculated in polynomial time , using the same dynamic programming algorithm as that described for parsing  . A tree can then be selected , from the topdown , by expanding the highest-scoring rule application for each constituent  . 
The environment-based parser described here uses a similar mechanism to select preferred trees  , but the scores are based on the presence or absence of entities in the denotation  ( interpretation ) of each proposed constituent :
D(x ) = max aks : t : akxk
X i=1

D(ai )! + (1 if D(x ) 6= ; 0 otherwise where the denotation D ( x ) of a proposed constituent x is calculated using another recursive function : 
D(x ) = [ aks:t:akxkoni = 1
D ( ai ) ! on (
R ( x ) if k = 0 fhig otherwise in which R ( x ) is a lexical relation dened for each axiom x of category equal to some subset of ' sworst-case denotation W  (   )  , as dened above . 

The operator on is natural ( relational ) join on the elds of its operands :
A on B = fhemax(a ; b)ijheai2A ; hebi2 Bg where a ; b  0 ; and  is a projection that removes the rst element of the result  ( corresponding the most recently discharged argument of the head or functor category  ) :  A = fheai j hea i2Ag This interleaving of semantic evaluation and parsing for the purpose of disambiguation has much in common with that of Dowding et al  ( 1994 )  , except empty constituents in an analysis , but other metrics are possible . 

So a lexical relation for the constituent ` lemon ' of category NP would contain all and only the lemons in the environment  , and a lexical relation for the constituent ` falling ' of category SnNP would contain a mapping from every entity in the environment to some truth value  ( TRUE if that entity is falling , FALSE otherwise ): e . g . fhlem on
NP[lemon]fl
P:NP nNP/NP[in]f hb
NP [ bin ] fb
P : NP nNP/NP [ by ] fhm
NP [ machine ] fm
PP:NPnNP[in]fhl
PP:NP nNP [ by ] fhb
NP[lemon]fl
NP [ bin ] fb
PP:NPnNP[in]fhl
NP[lemon]fl
Figure 1: Denotation-annotated forest for ` lemon in bin bin by machine  . ' that in this case , constituents are not only semantically type -checked  , but are also fully interpreted each time they are proposed  . 
Figure 1 shows a sample denotation-annotated forest for the phrase ` the lemon in the bin by the machine  '  , using the lexicalized grammar : lemon , bin , machine : NP the:NP=NP in , by : NP nNP = NP in which the denotation of each constituent  ( the set in each rectangle ) is calculated using a join on the denotations of each pair of constituents that combine to produce it  . In this example , the right-branching tree would be preferred because the denotation resulting from the composition at the root of the other tree would be empty  . 
Since this use of the join operation is linear on the sum of the cardinalities of its operands  , and since the denotations of the categories in a grammar G are bounded in cardinality by O  ( jEjv ) where v is the maximum valency of the categories in G  , the total complexity of the above algorithm can be shown to be O  ( nv ) : polynomial not only on the length of the input n  , but also on the size of the environment E ( Schuler ,  2001) . 
3 Extended algorithm
The above algorithm works well for attaching ordinary complements and modiers  , but as a semantic theory it is not su?ciently expressive to produce correct denotations in all cases  . For example , the lexical relations dened above are insu?cient to represent quantiers like ` no '  ( using category NP = NP ) in the phrase ` the boy with no backpack . ' lemoccurs with conjunctions ; for example , the word ` and ' ( using category NP nNP = NP ) in the phrase ` the child wearing glasses and bluepants '  , also cannot be properly represented as a lexical relation  . 

This raises the question : how much expressivity can be allowed in a shared semantic interpretation without exceeding the tractable parsing complexity necessary for practical environment-based parsing ? In traditional categorial semantics  ( Montague , 1973; Barwise and Cooper , 1981; Keenan and Stavi ,  1986 ) quantiers and noun phrase conjunctions denote higher-order relations : that is  , relations between whole sets of entities instead of just between individuals  . Under this interpretation , a quantier like ` no ' would denote a set of pairs fhAi and Bi are disjoint subsets of E  , corresponding to an acceptable pair of restrictor and body sets satisfying the quantier ` no '  . Unfortunately , since the cardinalities of these higher-order denotations can be exponential on the size of the environment E  ( there are 2 jEj possible subsets of E and 2   2jEj possible combinations of two such subsets )  , such an approach would destroy the polynomial complexity of the environment-based parsing algorithm  . 

Assigning the identity relation fhethequantier would incorrectly yield the set of boys with a backpack as a denotation for the full noun phrase  ; and assigning the converse relation ( from each entity in the environment to every other entity fheyield the set of boys with anything that is not a backpack  . 

The identity relation fheyields a correct interpretation in verb phrase conjunction  , would yield an incorrect denotation for the noun phrase ` glasses and bluepants  , ' containing only entities which are at once both glasses and pants  . 
However , if the number of possible higher-order functions is restricted to anite set  ( say , to some subset of words in a lexicon ) , it becomes tractable to store them by name rather than by denotation  ( i . e . assets ) . Such function can then discharge all their rst -order arguments in a single derivational step to produce arst-order result  , in order to avoid generating or evaluating any higher-order partial results  . Syntactically , this would be analogous to composing a quantier with both a noun phrase restrictor and a body predicate  ( e . g . a verb or verb phrase ) at the same time , to produce another rst-order predicate ( e . g . a verb phrase or sentence ) . Since a generalized quantier function merely counts and compares the cardinalities of its arguments in a linear time operation  , this analysis provides a tractable shortcut to the exponential calculations required in the conventional analysis  . 
Note that this analysis by itself does not admit productive modication of quantiers  ( because their functions are drawn from some nite set  ) or of quan-tied noun phrases ( because they are no longer derived as a partial result  )  . This causes no disruption to the attachment of non-conjunctive modiers  , because ordinary syntactic modiers of quantier constituents are seldom productive  ( in the sense that their composition does not yield functions outside some niteset  )  , and syntactic modiers of NP constituents usually only modify the restrictor set of the quantier rather than the entire quantied function  , and can therefore safely be taken to attach below the quantier  , to the unquantied NP . 
But this is not true in cases involving conjunction  . Conjoined quantiers , like ` some but not all , ' cannot always be dened using a single standard lexical function  ; and conjunctions of quantied noun phrases , like ` one orange and one lemon ' , cannot be applied to unquantied subconstituents ( syntactically , because this would fail to subsume the second quantier  , and semantically , because it is not the restrictor sets which are conjoined  )  . Keenan and Stavi ( 1986 ) model conjunctions of quantiers and quantied noun phrases using lattice operations on higher -order sets  , but as previously stated , these higher-order sets preclude tractable interleaving of semantic interpretation with parsing  . 
The solution proposed here is to treat each quan -tier or quantied noun phrase conjunction as an elliptical conjunction of two completers t-order predicates  ( e . g . verb phrases or sentences ) , each subsuming a dierent quantier and noun phrase restrictor  ( in the case of NP conjunction )  , but sharing or duplicating a common body predicate  . This analysis requires multiple components to keep track of the duplicated material above the conjunction  , but as long as the number of components is bounded  , the polynomial complexity of the parsing algorithm is containing  ( duplicated ) one orange ( unduplicated ) and one lemon ( unduplicated ) Figure 2: Duplicated verb in NP conjunction . 


Figure 2 shows a duplicated verb predicate in the derivation of an NP conjunction  . The conjoined constituents ( the shaded regions in the gure ) are each composed of two components : one for the NP itself  , containing the quantier and the restrictor predicate  , and one for the verb which supplies the body predicate of the quantier  . Since the conjoined constituents both correspond to complete quanti-er expressions with no unsatised rst-order arguments  , their categories are that of simplers t-order predicates  ( they are each complete verb phrases in essence : ` containing one or ange ' and ` containing one lemon '  )  . The conjunction then forms a larger constituent of the same form  ( the unshaded outline in the gure )  , with a lower component containing the conjoined constituents ' NP components concatenated in the usual way  , and an upper component in which the conjoined constituents ' non-NP components are identied or overlapped  . If the duplicated components do not cover the same string yield  , the conjunction does not apply . 
Note that , since they are only applied to ordinary rst-order predicates  ( e . g . sentences or verb phrases ) in this analysis , conjunctions can now safely be assigned the familiar truth-functional denotations in every case  . 

Also , since the resulting constituent has the same number of components as the conjoined constituents  , there is nothing to prevent its use as an argument in subsequent conjunction operations  . 
A sample multicomponent analysis for quantiers is shown below  , allowing material to be duplicated both to the left and to the right of a conjoined NP : some  , all , no , etc . : X n NP q  NP q n NP q  NP q = NP 
X = NP q  NP q n NP q  NP q = NP 
The lexical entry for a quantier can be split in this mechanism to produce appropriate semantic representations for NP and other conjunctions  , but for dierent reasons . 
8e . g . for the word ` and ': fh:::TRUE ; ::: TRUE ; ::: TRUEi ; h::TRUE ; :: FALSE ; :: FALSEi ; h::FALSE ; :: TRUE ; :: FALSEi ; h::FALSE ; :: FALSE ; : : FALSE igway into a number of components , the last ( or lowest ) of which is not duplicated in conjunction while others may or may not be  . These include a component for the quantier NP q = NP   ( which will ultimately also contain a noun phrase restrictor of category NP   )  , a component for restrictor PPs and relative clauses of category NP qnNP q that are attached above the quantier and duplicated in the conjunction  , and a component for the body ( a verb or verb phrase or other predicate ) of category XnNP q or
X = NP q . The subscript q species one of an ite set of quantiers  , and the subscript  indicates an unquantied NP . 
The deductive parser presented in Section 2 can now be extended by incorporating sequences of recognized and unrecognized components into the constituent chart items  . As constituents are composed , components are shifted from the unrecognized sequence c to the recognized sequence hic  ; jc ; ci , until the unrecognized sequence is empty . 
The extended parser is dened with :  chart items of the form [ i  ; j ;  ; ] , where  is a sequence of unrecognized components ,  is a sequence of recognized components ha ; b ; i , and i ; j ; k ; a ; b ; care indices in the input . Each item [ i ; j ;   ; hic ; jc ; ci ] indicates that the span from i to j in the input can be characterized by the categories cat positions ic to jc respectively  , so that if these spans are concatenated in whatever order they occur in the input string  , they form a grammatical constituent of category with unrecognized components   . 
 a lexical item [ i ; j ;   ; hi ; j ; i ] for every rule ! w 2 P if w occurs between positions i and j in the input  ;  a set of rules for all i ; j ; k ; a ; b ; c 2 In Two rules to invoke left and right function application to an existing component : [ i  ; k ;  =? ; hi ; k ; = ? i][k ; j ; ? ; hk ; b ; ? = " i ] [ i ; j ;   ; hi ; b ; = " i ]! = ??2P , [ k ; j ; n ? ; hk ; j ; n ? i][i ; k ; ? ; ha ; k ; ? n " i ] [ i ; j ;   ; ha ; j ; n " i ] ! ? n?2P , Two rules to invoke left and right function application to a fresh component : [ i  ; k ;  =? ; hi ; k ; = ? i][k ; j ;  =?? ; ] [ i ; j ;   ; hi ; k ; = ? i ]! = ??2P , [ k ; j ; n ? ; hk ; j ; n ? i][i ; k ;  n ?? ; ] [ i ; j ;   ; hk ; j ; n ? i ] ! ? n?2P , Two rules to discharge empty components : [ i ; j ;  =?? ; ] [ i ; j ;   ; ] [ i ; j ;  n ?? ; ] [ i ; j ;   ; ] Three rules to skip conjunctions , by adding a gap between the components in a constituent  ( therst rule consumes the conjunction to create a partial result of category Conj  , and the latter two use this to skip the opposing NP  ) : [ k ; j ; ? ; ] [ i ; j ;  Conj ; ] [ i ; k ; Conj ; hi ; k ; Conji ] [ k ; j ;  Conj ; ] [ i ; j ; ? ; ] [ i ; k ; ? ; ] [ i ; k ; ? ; ] [ i ; j ; ? ; ] [ k ; j ;  Conj ; ] Two rules to reassemble discontinuous constituents  ( again , using a partial result Conj to reduce the number of ranging variables  ) : [ a ; c ; Conj ; ha ; c ; Conji ] [ i ; j ;   ;  hc ; b ; ? i][i ; j ;   ;  ha ; b ; Conji ] [ i ; j ;   ;  hc ; b ; Conji ] [ i ; j ;   ;  ha ; c ; ? i][i ; j ;   ;  ha ; b ; ? i]T wo rules to combine adjacent components : [ i  ; j ;   ;  ha ; c ; ?="ihc ; b ; " i][i ; j ;   ;  ha ; b ; ? i][i ; j ;   ;  hc ; b ; ?n"iha ; c ; " i][i ; j ;   ;  ha ; b ; ? i ] And one rule to apply quantier functions : [ i  ; j ;   ;  ha ; b ; ? qi ] [ i ; j ;   ;  ha ; b ; ?  i]The parsing and scoring functions remain identical to those in Section  2  , but an additional k = 1 case containing a modied projection function  is now added to the interpretation function  , in order to make the denotations of quantied constituents depend on their associated quanti ers : 
D ( x ) = [ aks:t:akx > > > > > < > > > > > > >
R(x ) if k = 0  q
D ( aa=[:::h:::?qi][:::h:::?i]koni=1
D ( ai ) otherwise
The modied projection function evaluates a quan -tier function q on some argument denotation A  , comparing the cardinality of the image of the restrictor set in A with the the cardinality of image of the intersected restrictor and body sets in A:q 
A = fhea ; tijh ; ea ; i2A ; t = q(jRj ; jSj)
R = Aonfh ; ea ; ig ;
S = Aonfh ; ea ; TRU Eigg
This algorithm parses a categorial grammar in the usual way constituents are initially added to the chart as single components covering a certain yield in the input string  ( the indices of the component are the same as the indices of the constituent itself  )  , and they are combined by concatenating the yields of smaller constituents to make larger ones until a conjunction is encountered  . When a conjunction is 0   1   2   3   4 containing one or angean done lemon [0  ;  1 ; SnNP q = NP q h0 ;  1 ; SnNP q = NP q f h o .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (1) [1; 4; XnNP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (2) [1; 4; XnNP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (3) [1; 4; XnNP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (4) [1; 4; XnNP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (5) [0; 4; SnNPq ; h0;1; SnNP q = NP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . (6) [0; 4; SnNPq ; h0;1; SnNP q = NP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  (7) [0 ;  4 ; SnNP q ; h0 ;  1 ; SnNP q=NP  ih1 ;  2 ; NP  i]f x .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  (8) [0 ;  4 ; SnNP q ; h0 ;  1 ; SnNP q=NP  ih3 ;  4 ; NP  i]fx(9) [0 ;  4 ; SnNP q ; h0 ;  1 ; SnNP q=NP  ih1 ;  4 ; NP  i]fx(10) [0 ;  4 ; SnNP q ; h0 ;  4 ; SnNPqi]fx Figure 3: Sample derivation of conjoined NP . 
encountered immediately to the left or right of a recognized constituent constituent x  , and another constituent of the same category is found immediately beyond that conjunction  , the parser creates a new constituent that has the combined yield of both constituents  , but copies x's component yield ( the string indices of x's original components ) with no change . 
This has the eect of creating two new constituents every time two existing constituents are conjoined : each with a dierent component yield  , but both with the same ( combined ) constituent yield . These new discontinuous constituents ( with component yields that do not exhaust their constituent yields  ) are still treated as ordinary constituents by the parser  , which combines them with arguments and modiers until all of their argument positions have been successfully discharged  , at which point pairs of discontinuous constituents with the same constituent yield can be reassembled into whole or at least less discontinuous constituents again  . 
A sample derivation for the verb phrase ` containing one or angean done lemon  , ' involving conjunction of existentially quantied noun phrases  , is shown in Figure 3 , using the above parse rules and the lexicalized grammar : containing : SnNP q = NP q q  NP q n NP qNP q = NP  
X = NP q  NP q n NP q  NP q = NP  orange , lemon:NP  and : ConjFirst the parser applies the skip conjunction rules to obtain the discontinuous constituents shown after steps  ( 1 ) and ( 2 )  , and a component is discharged from each of the resulting constituents using the empty component rule in steps  ( 3 ) and ( 4 )  . The constituents resulting from ( 3 ) and ( 4 ) are then composed with the verb constituent for ` containing ' in steps  ( 5 ) and ( 6 )  , using the left attachment rule for fresh components  . The quantiers are then applied in steps ( 7 ) and ( 8 )  , and the resulting constituents are reassembled using the conjunction rules in step  ( 9 )  . The adjacent components in the constituent resulting from step  ( 9 ) are then merged using the combination rule in step  ( 10 )  , producing a complete gapless constituent for the entire input  . 
Since the parser rules are xed , and the number of components in any chart constituent is bounded by the maximum number of components in a category  ( in as much as the rules can only add a component to the recognized list by subtracting one from the unrecognized list  )  , the algorithm must run in polynomial space and time on the length of the input sentence  . Since the cardinality of each constituent's denotation is bounded by jEjv  ( where E is the set of entities in the environment and v is the maximum valency of any category  )  , the algorithm runs in worst-case polynomial space on jEj  ; and since there is no more than one set composition operation performed when a rule is applied  , and each composition operation runs in worst-case quadratic time on the size of its composed sets  ( due to the quantier operation )  , the algorithm runs in worst-case polynomial time on jEj as well  . 
4 Evaluation
The extended parser described above has been implemented and evaluated on a corpus of  340 spoken instructions to simulated humanlike agents in a controlled  3D environment ( that of children running a lemon a dest and , which was deemed suitably familiar to undergraduate student subjects  )  . The parser was run on the word lattice output of a no-the-shelf speech recognizer  ( CMU Sphinx II ) and the parser chart was seeded with every hypothesized word  . The parser was also compared with the recognizer by itself  , in order to determine the degree to which an environment-based approach could complement corpus-based disambiguation  . The systems were evaluated as word recognizers ( i . e . ignoring the brackets in the parser output ) on the rst 100 sentences of the corpus ( corresponding to the rsts even of 33 subjects )  ; the latter 240 sentences were reserved for training the recognizer and for developing the grammar and semantic lexicon  . 
The average utterance length was approximately three seconds  ( subsuming about 300 frames or positions in the parser chart )  , containing an average of nine words . Parsing time averaged under 40 seconds per sentence on a P4-1500MHz   , most of which was spent in forest construction rather than denotation calculation  . 
Accuracy results show that the parser was able to correctly identify a signicant number of words that the recognizer missed  ( and vice versa )  , such that a perfect synthesis of the two ( choosing the correct word if it is recognized by either system  ) would produce an average of 8 percentage points more recall than the recognizer by itself on successful parses  , and as much as 19 percentage points more for some subjects : subject precrec all fail precre call recall  0   76   79   18   72   74   92   1   77   75   28   63   55   83   2   70   71   33   49   54   69   3   71   67   43   49   45   69   4   66   54   37   44   39   67   5   53   52   54   36   31   72   6   84   84   50   56   63   83 all 68   67   37   53   50   75 which indicates that the environment mayoer a useful additional source of information for disambiguation  . Though it may not be possible to implement a perfect synthesis of the environment-based complete analyses of the input  , even if the correct tree is not among them . 
and corpus-based approaches , if even half of the above gains can be realized , it would mark a signicant advance . 
5 Conclusion
This paper has described an extension to an environment-based parsing algorithm  , increasing its semantic coverage to include quantier and conjunction operations without destroying its polynomial worst-case complexity  . Experiments using an implementation of this algorithm on a corpus of spoken instructions indicate that  1  ) the observed complexity of the algorithm is suitable for practical user interface applications  , and 2 ) the ability to draw on this kind of environment information in an interfaced application has the potential to greatly improve recognition accuracy in speaker-independent mixed-initiative interfaces  . 

Kazimierz Ajdukiewicz .  1935 . Die syntaktische konnex-it at . In S . McCall , editor , Polish Logic 1920-1939 , pages 207231 . Oxford University Press . Translated from Studia Philosophica 1:127 . 
Yehoshua Bar-Hillel .  1953 . A quasi-arithmetical notation for syntactic description  . Language , 29:4758 . 
Jon Barwise and Robin Cooper .  1981 . Generalized quantiers and natural language . Linguistics and Philosophy , 4 . 
Sylvie Billot and Bernard Lang .  1989 . The structure of shared forests in ambiguous parsing  . In Proceedings of the 27 th Annual Meeting of the Association for Computational Linguistics  ( ACL'89 )  , pages 143151 . 
Ver onica Dahl and Michael C . McCord .  1983 . Treating coordination in logic grammars . American Journal of
Computational Linguistics , 9(2):6991.
John Dowding , Robert Moore , Fran  cois Andery , and Douglas Moran .  1994 . Interleaving syntax and semantics in an e?cient bottom-up parser  . In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics  ( ACL'94 )  . 
Joshua Goodman .  1999 . Semiring parsing . Computational Linguistics , 25(4):573605 . 
E . Keenan and J . Stavi .  1986 . A semantic characterization of natural language determiners  . Linguistics and
Philosophy , 9:253326.
Richard Montague .  1973 . The proper treatment of quan-tication in ordinary English  . In J . Hintikka , J . M . E . 
Moravcsik , and P . Suppes , editors , Approaches to Natural Langauge , pages 221242 . D . Riedel , Dordrecht . 
Reprinted in R . H . Thomasoned . , Formal Philosophy,
Yale University Press , 1994.
William Schuler .  2001 . Computational properties of environment-based disambiguation  . In Proceedings of the 39th Annual Meeting of the Association for Computational Linguistics  ( ACL'01 )  , Toulouse , France . 
Stuart M . Shieber , Yves Schabes , and Fernando C . N . 
Pereira .  1995 . Principles and implementation of deductive parsing  . Journal of Logic Programming , 24:336 . 
