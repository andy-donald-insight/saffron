Semantic Construction from Parse Forests
Michael Schiehlen *
Institute for Computational Linguistics , University of Stuttgart , 
Azenbergstr . 12, 70174 Stuttgart
mike?adler,ims.uni:stuttgart , de

The paper describes a system which uses packed parser output directly to build semantic representations  . More specifically , the system takes as input Packed
Shared Forests in the sense of Tomita ( l_bmita ,  1985 ) and produces packed Underspeeified Discourse Representation Structures  . The algorithm visits every node in the Parse Forest only a bounded number of times  , so that a significant increase in efficiency is registered for ambiguous sentences  . 
1 Introduction
One of the most in l ; eresting problems comes about by the tendency of natural language discourse to be ambiguous and open to a wide variety of interpretations  . Generating representations for all the interpretations is nol  , feasible in view of the strict comput a , ional bounds imposed on NLP systems . Instead , two other routes have been tmr-sued : ( 1 ) the integration of further disambiguating knowledge and heuristics into the system or  ( 2 ) the general ; ion on of a single semantic represent , a-lion that summarizes all the interI > retations i the hope that the application task will force a distin < :- lion between the int  ; er pretations only in few cases . 
Such a summary repre . sentation is called underspecified if a procedure is given with it to < terive a set of real semantic representations fl ' omit  . By now ~ several techniques are kIlown to underspecify quantifier scope ambiguities  ( Alshawi ,  1992) , ( Reyle ,  1993) . In this paper Discourse Representation Structures  ( Kampm M Reyle ,  1993 ) are employed as underlying semantic ret ) resentations . 
For underspecification with respect os <: opeat n bi -gullies the present approach makes use of Under- * This work was funded by the Germ  ; m Federal Ministry of Edu (: ation , Science , Research and Te ( : h-no log y ( BMBF ) in the flamework of the Verbmobil Project under Grant  01  . IV1 . 01 U . Many thanks are due to M . Dorna , J . D Srre , M . Einele , E . KSnig-Bamner , C . Rohrer , C . J . Rupp , attd C . Vogel . 
speeilied Discourse Representation Theory ( Reyle ,  1993) . Another strand of research as looked al ; compact representations for parse outputs ( Ear-Icy ,  1970) , ( Tomita , 1985) and etticien I , parsing algorithms 1 , odeliver such ret > resentalions . Unfortunately , advances made in this area ( lid not ; have impact on semantic onstruction . It ; was still necessary to first unpack the compacl ; parsing ret ) -resentation and derive the individual parse trees from it before going about generating semant  ; ic representations . So in this area another applica-lion for semantic underspecitieation is lurking  . 
Several approaches to underspecifica , i on axe conceival ) le . (1) Operation M Underspecilical , ion : Construction operations that ; involve art ) it rary choices are delayed and carried out only on demand  ( Alshawi ,  1992) , ( Pinkal ,  1995) .   ( 2 ) Iep-resentational Underspeeification : The ambiguil  ; ies are represented ( explicitly or implicitly ) in a for-realism . A resolution procedure derives the hill-fledged semantic representations  . This t ) aperopts for the second approach ( for motivation see chapter 7 )  . hel , we en the t ) arser and the semantic (: on-sl ; rllc ; ion coln ponen , ~(;oo . 
? Parse forests/charts ( Alshawi , 1992).
? Underspecified " trees " with abstract donfi -nanee information  ( Pinlml ,  1 . 995) . 
? Fully specified parse trees ( Egg and Lebet ; h ,  1995) . The syntactic ambiguities are ol ) -rained by re-ambiguat ; ionithesemanl ; ice o Hlponent . 
Our choice are parse forests since there are wellknown methods of construction for t  , hemand it is guarant ; eed that every syntactic ambiguit ; y can be represented in this way . ISu'thermore a wide range of existing parsing systems  , e . g . ( Block and Schachtl ,  1992) , produce packed representations of this kind . 
2 Outline of the System
Let us begin wil ; harough sketch of the arc tfitec-lure of the systmn  . The semantic cons ; rllcl ; ion module works on parse forests and presut ) t ) osester 6 )  . The semantic grammar must be correlated with the syntactic grammar so that there is a one-to-one mapping between lexical entries and rules  . 
input string
IParser using : Syntactic Grammar 4, parse forest
Iemantic Construction Module using : Semantic Grammar $ packed UDRS Inside the semantic on struction module three processes are distinguished  . They are described in turn ( see chapter 4 and 6) . 
parse forest disambiguated parse forest
I Semanticoi astruction proper using : Semantic Grammar $ packed UDRS $ F Determining unambiguous arguments \] packed UDRS  3 Packed Shared Forests In this section a formal description of packed shared forests in the sense of Tomita  ( Tomita , 1985) is given . 
Let a context-free grammar G be a quadruple < N  , T , R , S > where N and T are finite disjoint sets of nonterminal symbols and terminal symbols  , respectively , R is a set of rules of the form A-+a ( A is a nonterminal and a a possibly empty string of nonterminal or terminal symbols  )  , S is a speciM nonterm in ~ l , called start symbol . 
An ordered directed graph marked according to grammar ~ is a triple < V  , E , m > so that V is a finite set of vertices or nodes  , E a finite set of edges e of the form ( v l , ( v2 ,  . . .   , vn )) ( viCV , n > 2 , estarts at v l , vl is the predecessor of v2 ,   .   .   .   , vn ) , m is the marking function which associates with each vertex at errain ai or nontermin aisymbol or the special symbole  . misrestricted so that the vertices on each edge are marked with the  , symbols of a rule in 6 , the empty string being represented by the additional symbol ~  . A parse tree is an ordere directed acyclic graph  ( DAG ) satisfying the following constraints . 
1 . There is exactly one vertex without predecessors , called the top vertex or root . The root is marked with the start symbol . 
2 . For every vertex there is at most one edge starting at the vette ?  . Vertices that do not begin edges are called leaves  , such that do are called inner nodes . 
3 . Every vertex except heroot has exactly one predecessor  . 
ADAG satisfying the constraints ( 12 ) is called Shared Forest , a DAG only satisfying ( 1 ) is a Packed Shared Forestor parse forest ( see figure 1 )  . A packed shared forest for an input string a obeys the further constraint that  , there must be at most one vertex for each grammar symbol and substring of a  . Thus , if a consists of n words , there will be at most k*n 2 vertices in the parse forest for it ( k being constant )  . Parse forests can be efficiently constructed using conventional parsing algorithms  ( Tomita ,  1985) , ( Earley ,  1970) . 
4 Determin ing Tree Read ings f rom a Fores t A tree reading of forest F is a tree in F that  ; contains the root and all leaves . Tree readings are treated as objects . An edge is used in a tree reading if it is one of the tree's edges  . Let us now define a disambiguated parse forest ( DPF for short )  . ADPF 79 is a quadruple < V , D , E' , m > such that ? V and D are finite disjoint sets . V is the set of vertices and D is the set of tree readings  . 
? E ' is a finite set of edges of the form ( vl , v2 ,  . . . , vn ), dl , .   .   . , d , ~) . The third element is a set of tree readings ( CD ) and encodes the tree readings in which the edge is used  . 
? m is a marking function from vertices to grammar symbols  . 
To derive a DPF from a parse forest every edge must be assigned a set of tree readings  . There is no simple way to determine from a parse for es the number of its tree readings  . So instead of postu-lating a fixed set of readings the present approach uses pointers  ( implemented as Prolog variables ) to refer to sets of tree readings . Two operations disjoint union and multiplication are defined for these sct pointers  . Both operations are monotonic in the sense that the pointers are not altered  , their value is only specified . Let si be a set of tree readings . 

The operator tJ differs from the set-theoretic notion of disjoint union in that it is neither commutative nor associative  . This is so because on the implementational level commu-tativity and associativity would necessitate an abstract data type  , thus a costly overhead . 
?8 1 X 82
In general , sl and s2 correspond to formulae invo ! ving atomic sets and 0 operators\[Sl = SllU .   .   . U81m and s2 = s21U . . . U82 n . 

Z , , ' n p v d n p d n
Is a waman in the apt with a tel
Figure 1: a parse forest with a tree reading all : edges used in dlare shown as broken lines The operation x introduces m * n new atomic sets s~j and splits the former atomic sets such that Vi :   1 < i<m : Sli=s~l 0   .   .   . 0s ~ , , and Vj : 1< <_j < n : s2j = s~j0"' .   .   . US mj . 
The sets Sl and s2 are now equal modulo as-sociativity and commutativity  . Consider the following example : ( 81 0 82 0 83 ) X ( 8 a08 b )  --  (  . ~ , 0s ~0 ~) = (4 o0 d ~)0 ( A , , 0  , ~ , ,)' 0 ( s~o ' 0 . ~,,)' (, . 0*b ) = ( . % 0 4 .  0 4 . )0(4b0 , 5~ 0  , '~ ) We begin by associating a particular set pointer sl with the root vertex  . Sl refers to the , total set of tree readings of the forest ; since the root vertex figures in all trees derivable from the forest  . We then traverse the graph in topdown fashion applying to each new vertex v the following procedure : Let ei be the set of tree readings at edge i ending in v  , and b  #the set of tree readings at edge j starting in v  . Then the following actions must be performed . 
? Apply the procedure to all successors of v . This step yields for each edge j starting in v and for each vertex u at the end of j a set of tree readings b ~  , , . 
? bj = b ; 1X .   .   . Xb ,, for each edge j starting inv ? ( bl 0 .   .   . 0 bn)x(el 0 .   .   . 0 era ) If a vertex v h~s already been encountered the only action required is to connecthe edge information on v's predecessor w with the edge information already present on vertex v  . In particular , the successors of v need not be checked again . 
Let k be the edge ( ) vet ' which the vertex v was reached from another vertex w in the topdown traversal  . Let C'k , t , be the set of tree readings determined for edge k at vertex w and e k  , , the set of tree readings determined for the edge at vertex v  . 
?(' ~ kvXCkw 5 Packed Underspecified Discourse
Representation Structures
In this section an extension to UDRSs ( Reyle ,  1993 ) to express referentially underspecified semantic representations is presented  . 
First a detinition of UDRSs is given . AUDRS/J is a quadruple < L , R , C , <_> where L and R are disjoint finite sets of labels and discourse referents  , respectively . The order relation < forms a semilattice ow , rL  with one-element lq . C is a set of conditions of the following form ? 1 : x , where lC12 , xE:R . .
* 1: p(xl , .   .   . , x , , ), where IE 12, xi, .   .   .   , : r , ~CT t , and p is an n-place predicate ? I : 11 = >12 , where l , ll , 12C 12 ? l : -~ ll , where 1 , 11 ~?*1:llV 12 , where l , ll , l . ~ C ?* ll~12, where ll , l . ~ E12
In UDRSs 12 = L and "~= R.
To get packed UDRSs the UDRS language is extended by adding reified contexts  ( semantic readings ) to it . The idea of using context variat ) lestore present ambiguou structures originally stems fl ' om the literature on constraint-based formalisms  ( DSrre and Eisele ,  1990) . A packed UDRS is a quintuple < L , R , D , C ' , 5> where L , R , < are the same as in UDRSs , D is a finite set of contexts which is disjoint from L and R  . C ' is defined as in UDRSs except that ( 1 ) any condition may arguments may ~ not , only be labels but also functions from contexts to labels  ( ? = LU ( D - - ~ L ) ) , and the same holds for discourse referents ( 7? = RtA ( D  ~ R ) ) . If a function A ~ X l , B  ~ x2 replaces a discourse referent in a packed UDRS , this intuitively means that the argument slot is filled by x t in reading A and by  x2 in reading B . 
As an example for a packed UDRS consider the following representation for Isaw every man with a telescope  . 
Ii : ianchor(i , . speaker ) t2: sce(el , i , xl ) 12_<1T13_<lT12_<1413: every(x1 , 15 , 14) 15: man(x1) A-+/2 , B-+15: with ( A-~ttl , g--~~1 , X2) A-~12 , B"~/5_<1~16_<1T 16:x 216: telescope ( x2 ) In the implementation contexts are represented by Prolog variables  . In this way disambiguation is ensured to be monotonic1: A context d can be cancelled by grounding the Prolog variable representing d to a specific atom " no "  . The formalism also allows any kind of partially disambiguated structure since th c variables for the readings do not interact  . 
In the above version of UDRS packing , disjuncts are re\[fled . Another way to represent referential ambiguities is to retry argument slots using additional variable names  ( L and X below , not to be mistaken as discourse referents ) . Disjunctions are then represented directly . 
1T : ianchor(i , speaker ) 12: see ( el , i , xl ) l . ~< IT 13 < ~ ll 12~14/3: every ( xl , 15  , /4)/5:man(x1)
L : with(X , x.2)
L < 16 la < 17 16: x 2/6: telescope ( x2 )   ( L-~/2AX ~- el ) V ( L = 15 AX = Xl )   1Another way to see that the resolution procedure ~ s monotonic is to assume a semilattice over context sets with respec to the subset relation  . Cancelling a context from a set makes it more specific in the semilattice  . 
6 Building Semantic
Representations
UDRS construction ( Frank and Reyle ,  1992) , ( Bos ,  1995 ) is different from conventional semantic construction in that embedding is not represented directly but by means of labels  . Tile only semantic composition operation is concatenation  . In addition labels and discourse referents are matched as specified in the semantic part  ; of the gramma rules ( the " semantic grammm '") . In the semantic grmn nmrevery nonterminal is assigned a list of arguments  . For every operator ( e . g . an NP ) a lower label and a series of upper labels must be given  . The lower label points to material which must be in the scope of the operator  ( e . g . tile verb ) . The upper labels refer to thcminimal scope domain tile operator must occur in  . This domain differs for indefinite NPs and quantifier NPs since these types of NPs are subject to different island constraints  ( only indefinites can be raised over clause boundaries  )  . Furthermore , the semantic grammar specifies the UDRS conditions introduced by lexical items and rules and determines the arguments to be matched in rules and lexical items  . It also gives the direction of this matching by fixing in which lexical item an argument originates  ( see last slot of lcxi-cal entries )  . If an argument originates in an item ( be cml scitise . g . its instance discourse referent or label ) then the value of this argument is un-ambigous for the item  2  . In adjunct \ [ on structures , the modified constituent assigns and the modifier receives the shared discourse referent  . Consider the following example grammar 3 . 
start symbol ( s/\[_Event , _Verb L , Top , Top\] , \[ Top\]) . Z originating arguments/\[Event , Verb L , Dota L , TopL\]---> np/\[X , VerbL , Dom L , TopL\] , vp/\[Event , X , Verb L , Dom L , TopL\] . 
vp/\[Event , X , VerbL , DomL , TopL\]---> vt/\[Event , X , Y , VerbL , Domi \] , np/\[Y , VerbL , DomL , TopL\] . 
np/\[X , VerbL , DomL , TopL\]--->det/\[X , NounL , VerbL , DomL , TopL\] , n/\[X , NounL , DomL , TopL\] . 
lex(a , det/\[X , Lab , VerbL , _DomL , TopL\] , \[ leq(VerbL , Lab ) , leq(Lab , TopL) , 
Lab : X\],\[X\]) . ~ originating argument eA similar train of thought lies behind the notion of " focus " proposed by Tomita  ( Tomita ,  1985) . A " focus " in a rule is the constituent which gets assigned all argument fi'om the " ba  ( : k ground " constituents of the rule . Ill general this notion of focus must be fein-t\ [vised to individual argmnents  . Constituent 1can be focus with respecto argument i while constituent  2 is focus for argument j in a rule . 
a ThcProlog symboleq represents he UDRS subordination relation <  . 
910 lex ( every , de\]/\[X , Res L , Verb L , Dom L , _TopL\] , \[ leq(+Lab , Dotal ) , leq(VerbL , S(opeL ) , 
Lab : every ( X , Res L , Scope L ) 1 , \[ X , Lab , Scope L\]) . 
lex(man , n/IX , Lab , _DomL , _TopL\] , \[ Lab : man(X)\] , \[ Lab\]) . 
lex(saw , vt/\]Event , X , Y , Lab , DotaL\] , \[ Lab : see ( Event , X , Y ) , leq(Lab , DotaL)\] , \] Lab , Event \]) . 
Let us turn now t ; otim semanl ; ie construction component ;  . The tree readings of the DPF correspond to the contexts of t impacked UDRS  . The motivation behind this layout is that ; in most eases syn-taclic ambiguity has some impact on the semantic readings  4  . The construction algorithm traverses the DPF and assigns to each vertex the argument list associated with its category in the semantic grammar  . The arguments on this list are not arguments proper as they would be if only pm'se trees were considered  , but f l , nc tions fl ' om contexts to arguments proper . These flmctions at '( . ' total only t br the root and the leaves , for inner nodes v they are restricted to the union  D1 of the . context sets at \]; hedgesst ; arl , ing at v . A predicate match1 matches arguments proper as given in the lexical e  . ntries and the starl ; symbol de ( : laratkmon to tim ( -lions as used in the rules . 
Let D1 be a context set dl , .   .   .   , dn , let LexArg be an argument as provided l ) y a lexicMite morstart symbol declaration i , let Art bemt argument as occurring attached to a nonterminal on the righthand side of a grammar ule  . 
Then the predicate match 1 unifies
LexArg with Art if LexArg does not originate in I  . If LexArg does , Arg is unified with the fimction dl-9
LexArg , ..., dn-+LcxAr.q.
Let us assume a boi , to ln-ut ) traversal of the parse forest and let e be the edge fi'om v to one of il  ; ssuccessors w . Then the arguments already presenl ; aat ; w must be matched with the arguments predicted for w by the semantic rule corresponding to e  ( predicate match 2 )   . Let D2 be the context set , assigned to e . Then only the argunmnt values of the contexl , s in D2 are unified . In \] , his way it is guaranteed l ; hat argument matching is done 4If several tree readings correspond to a single context  ( semantic reading ) this is reeognised in the la . st step ( determining unambiguous arguments ) where the tree readings are merged . 
' ~ The boLl ; ore-up ; kssuml ) tion makes sure that vertex whast ) een treated . 
as it would be done in the underlying trees : Tile contexts clearly separate the information flow  . 
Let D2 be the context set dl , .   .   .   , d , ~ ate , let Upper Arg be an argument as provided by the semantic rule corresponding to edge e  , let Lower Arg be an argument as attached to the vertex w  . 
Then the predicate match 2 unifies
Upper Arg with the restriction of the flmction Lower Arg to the context  ; s in D2 dl-~vl ,   .   .   . , d , ~ v , ( a subset of Lower Arg) . 
In the linM step the packed UDRS is traversed at t ( tfl metions whet ' (  ; alleon texl ; spoint to a single value are replaced by this vahm  . 
7 Comparison with Other

This seel ; ion discusses two evaluation criteria for approaches to semantic underspecification  . The present , proposal is measured against the criteria , and so are the Minimal I/ , eeursion Semantics approach ( Egg and Lebelh ,  1995) , the Radical Un-der speeifieation approach ( Pinkal ,  1995) , and the Core Language Engine approach ( Alshawi ,  1992) . 
The first criterion is coverage . Several types of syntactic ambiguities can be distinguished  . 
? adjunct \] on ambiguities ( arising from attach-men\]of PPs , adjectives , adverbial sllb clauses , and other modifiers ) ? coordinatkmambiguities ? 0-role assignment ambiguities ( arising fi'om scrambling ) ?arn higuities arising from multi-part-of-speech words  ( A subcase of this type of ambiguity is tit (  ; treatment of ml known input words . ) The MRS approach is restricted to adjunct\]on ambiguities  , while the othex approaches are applicable to all the kinds of ambiguities mentioned  . A drawback of the MRS approach might be that it generates semantic readings which are not licensed by the syntactic structure  . To give an example consider the sentence lsawa ' man in the a part-merit with a telescope  . MRS produces a spurious reading in which the PP with a telescope adjoins to the NP a man while the PP in the apartment modifies the hill sentence  . Remember that MRS does not use . a parse forest as input structure but an arbitrary parse tree  , i . e . one speeitic syntactic reading . MRS re-ambiguates the parse tree only a fi ; erwards within semantic on strn ~: tion . At this point information about positions in the input  ; string is lost . 
Another test is the uscht lness of the representation for fllrther processing  . Such processes at '( . '? disambiguation by sort ; hierarchies ? theorem proving n = l n=2   n=3   n=4   n=5   n=6   n=7   n=8 

U-Nodes U-Time ( per reading ) 75 msec (37 . 5 msec ) 180 msec (36 . 0 msec ) 430 msec (30 . 7 msec ) 11 15 msec (26 . 5 msec ) 3 145 msee (23 . 8 msec ) 10 505 msec(24 . 5 m see ) 32 195 m see (22 . 5 msec ) 131 125 mscc (27 . 0 msec )
S-Time ( per reading ) 15 msec (7 . 5 msec ) 70 msec (14 . 0 msec ) 355 msec (25 . 4 msec ) 2225 msec(53 . 0 msec ) 16895 msec(128 . 0 msec ) 176930 msec(412 . 4 msec ) 44 16 30 m see (308 . 8 reset ) 433 1120 msee (890 . 8m see )
Table 1: Result of Experiment ? transfer and generation All these processes can successfully handles co -pally underspecified structures  ( for sortal disambiguation and transfer see the Core Language Engine  ( Alshawi ,  1992) , for theorem proving see the Underspecified DRS formalism  ( Reyle ,  1993)) . In the Core Language Engine approach to syntactic underspecification the representation must be unpacked to perform disambiguation by sorts  . This seems to be true for any approach relying on delay of semantic on struction operations : In order to apply the sortal restrictions of  , e . g . , a verb to one of its argument discourse referents it must be known which discourse referents could possibly fill the argument slot  . Moore and Alshawi ( AI-shawl ,  1992 ) explain their reluctance to apply sort restrictions already in the packed structure with the maintenance overhead in associating semantic records with vertices of the forest  . In the packed UDRS approach the problem is handled by explicitly enumerating all possible readings  . Then , the maintenance effort is reduced to the effort of extrapolating the tree readings from the parse forest  . None of the compared approaches makes any claims about theorem proving and transfer  . In the packed UDRS approach it is conceivable to delay actual disambiguation as long as possible : Apart from the potential representation freferen -tim ambiguities by functions packed UDRSs look exactly like UDRSs  . So if only referentially unambiguous conditions must be consulted in a proof  , a UDRS theorem prover may be used . 
8 Efficiency
This section reports on an experiment in which the efficiency of the proposed underspecified construction mechanism was measured against the cost of generating all UDRSs separately  . Table 1 compares the time behaviour of constructing one underspccified structure  ( U-Time ) with the time needed for constructing of the whole bunch of specified structures  ( S-Time )  . The experiment was conducted on a SPARC station 20 using input sentences of the form Isawaman ( with a telescope ff . 
Visibly the time needed per reading remains approximately constant in the construction of the underspecified representation whereas it grows sharply when the ambiguities are enumerated  . 

Hiyan Alshawi , ed .  1992 . The Core Language Engine . 
MIT Press , Cambridge , Massachusetts.
Hans Ulrich Block and Stefanie Schachtl .  1992 . Trace and Unification Grammar . In Proceedings of the fiftecnth International Conference on Computational Linguistics  , pages 87--94 , Nantes , France , August . 
Johan Bos .  1995 . Predicate Logic Unplugged . In Proceedings of the Tenth Amsterdam Colloquium , ILLC/Department of Philosophy , University of Amsterdam , Amsterdam , Holland , December . 
Jochen D5 rrc and Anch'eas Eisele .  1990 . Feature Logic with Disiunctive Unification . In Proceedings of the 13th International Conference on Computational Linguistics  , Helsinki , Finland . 
Jay Earley .  1970 . An Efficient Context-lh'ee P~rsing Algorithm . In Communications of the ACM ,  13(2) , pages 94-102 , February . 
Markus Egg and Kai Lcbcth .  1995 . Semantic underspecification admodifier attachment ambiguities  . In James Kilbury , Richard Wiese ( ed . ) , Integrative Ans\[itzein der Compuler linguistik . Beitrilgezur 5 . Faehtagung der Sektion Computer linguistik der Deutschcn Gesellsch aftiir Sprachu Jissenschaft  ( DG fS )  , pages 19--24 , Di is seldorf , Germany . 
Anette Frankaud Uwe Reyle .  1992 . I Iow to Cope with Scrambling and Scope . In GSrz , G . ( ed . ) KONVENS'92 . Reihe Informatikaktuell , Springer Berlin , pages 121-130 , N/i rnberg , Germany . 
ttansKamp and UweReyle . 1993. From Discourse to
Logic . Kluwer , Dordrecht , tolland.
Manfred Pinkal . 1995. Radical Underspecification.
In Procc ~ lings of the Tenth Amsterdam Colloquium , ILLC/Department of Philosophy , University of Am-sterdazn , Amsterdam , IIolland , December . 
Uwe Reyle .  1993 . Dealing with Ambiguities by Underspecification : Construction  , Representation ad Deduction . In Journal of Semantics , 10, 2, pages 123-179 . 
Masaru Tomita .  1985 . Efficient Parsing for Natural
Language . Kluwer , Dordrecht , Holland.

