ACHIEVING FLEXIBILITYIN UNIFICATION FOR MALISMS
Lena Str Smb~ick1
Department of Computer and Information Science,
Link6ping University , S-58183 Link 6ping , Sweden

We argue that flexibility is an important property for unification-based formalisms  . By flexibility we mean the ability for the user to modify and extend the formalism according to the needs of his problem  . The paper discusses some properties necessary to achieve a flexible formalism and presents the FLUF formalism as a realization of these ideas  . 
1 MOTIVATION
Unification based-formalisms are in common use within natural language processing and many different formalisms have been defined  . PATR-II ( Shieber et al ,  1983 ) is the most basic and a kind of common denominator which other formalisms are extensions of  . Other formalisms are STUF ( Beierle et al ,  1988) , TFS ( Emele & Zajac ,  1990) , CUF ( D6 rre & Eisele , 1991) and , ALE ( Carpenter ,  1992) . These formalisms include , for example , disjunction , various variants of negation and typing . When vaa ' ious grammatical theories , such as LFG ( Kaplan & Bresnan , 1983) or HPSG ( Polku'd & Sag , 1987) are included , the range of extensions suggested to unification -based grammars becomes very wide  . There are also many variant proposals on how the same extension should be used and interpreted  . 
When using these formalisms for a particular problem  , it is oRen the case that the constructions provided do not con'espond to the needs of your problem  . It could either be the case that you want an additional construction or that you need a slight modification of an existing one  . Since the extensions are nmnerous it seems hard to include everything in one single formalism  . 
In some formalisms , especially TFS and CUF , the user is allowed to define new constructions . This is an interesting property that I will develop further to achieve flexibility  . In a flexible formalism , the user can define all the construction she needs or modify definitions provided by the formalism  . With this kind of formalism problem such as those mentioned above would not arise  . 
1. Email address : lestr@ida.liu.se
A flexible formalism would be a useful tool for delining various kinds of knowledge needed at different levels in a natural language system  . It would be a great advantage to be able to use the same system for all levels  , but adjusting it to suit the variou structures that are needed at each level since the relations between the different levels would be clearer and it would be easier to share structures between the levels  ( cf . Seiffert (1992) for more motiwttion ) . 
Another advantage with such a formalism is that it can be used to define and test extensions and w ~ rious grammatical formalisms for the purpose of comparison  . 
Flexible formalisms allow the user to defnean expensive x tension and use it for the cases where here ally needs it  . Thus an extension that is considered too expensive to be provided by a general formalism  , can be included as it can provide a more efficient representation of some particular phenomenon  . This is particularly important since , in natural language processing , it is common that expensive constructions are required for few and limited cases  . 
However , if the user is allowed to define expensive constructions  , an additional goal , predictability , must be considered . By this I mean that inefficient computations hould be necessary only when the construction causing the inefficiency really participates in the computation  . This idea was discussed in StrOmb/ick ( 1992 ) where I give a predictable algorithm for unification of feature structures containing disjunction  . 
The goal of predictability is closely related to modularity  , since if it is possible to make different constructions independent of each other  , it is easier to find predictable algorithms for them  . Since this paper will discuss properties of a flexible formalism rather than unification algorithms there  , will be no further discussion of predictability . 
In the following I first discuss the most important properties of a flexible formalism  . I then present a flexible formalism , FLUF , by using it to define PATR-I\[ . The size of this paper does not admit a thorough description of FLUF and its semantics  . This is given in StrOmbfick ( l994a , 1994b ) . 
8 42   2 ACHIEVING FLEXIBILITY in this section l state some necessary properties of a flexible formalism  . 
It is essential that the formalism does not provide a single basic construction i which all other structures must be defined  , as this often leads to clums y representations . Instead the user defines everything he needs . The retbrcaflexible formalism must provide some way of defining structures and objects  . These can be divided into two groups ; those that are used as general elements in the t ' ormalism  , for example feature structures or the empty set ; and those that m'especific for a particular problem  , for example the attribute number . 
In addition to the elements defined in a fonnalism the user needs other ways of describing his objects  , e . glogical operators , uc has conjunction and disjunction , and functions , such as concatenation flists . Important to note here is that these constructs do not add further elements to the defined language  , they just specify additional syntax for describing the objects  . 
Anothe requirement to raflexible formalism is that the usernms t define the behaviour of his elements  , that is , how they unify with each othe LSimilarly , when defining some additional syntax , henms t specify the meaning of it . I have chosen to do this by stating constraint relations  , which means that results from term rewriting systems  ( Middeltorp & Halnoen , 1992) and algebraic specification ( Ehrig & Mahr , 1985) can be applied . Using constraint relations it can be specified that two defined object should be interpreted as the same  , or that one object should subsume some other object  . 
The last property I want to mention is the use of an inheritance hierarchy furthedel initions  . This is a good way of taking advantage of similarities between different extensions and also a suitable way of defining linguistic knowledge  ( see , f i ) r example , the articles in Computational Linguistics 18(2 , 3)) . 
By using an inheritance net for defining new constructions in the formalism several other benefits arc obtained  . One is that if the mathematical properties of a construction are known  , this knowledge can be used instead of defining the construction with constraint relations  . The inheritance net alows us to replace the construction defined with constraint relations with a predefined mathematical domain provided that both the properties of this domain and how objects unifies are known  . 
The inheritance netalo provides ways to i in prove the efficiency in in ~ plementations of the system  . 
Since a defined construction corresponds to a node in ~ cept noun  ; \]
Fig . 1: AFLUF definition the net ( together with inherited information )  , known unification algorithms t brobjects corresponding to this node can be used  . This gives the design of a fullscale implementation as a library of the most common extensions  , where the user can choose which he wants and define new ones or changexisting definitions only when necessary  . 
3 THEFLUF FOR MALISM
In this section I show how the FLUF formalism works by defining feature structures as they are used in PATR-ll  . I have defined conjunction and disjunction and some minimalinguistic knowledge  . The inheritance hierarchy expressing the definition is shown in Fig  .  1 . 
First the objects needed to build feature structures are defined  . This is done using classes . The objects needed are attributes and values . These are the two subclasses of top . Values are divided into atomic and complex values  , corresponding to the two classes at om ' and fs ' . 
The two chtsses top and value are used to build up the hierarchy and contain no object definitions of their own  , all objects are defined in atom , attribute and f ~ , l show the definitions of Is ' and attribute below  . The definition of atom is very similar to the definition of attribute  . 
chtssIs ; is a value ; consmtct or empty ; constructor add_pair : attribute , value , Is ; constraint empty > add pair ( A , V , FS ); constraint add_pair(A , U , add pair ( A , V , FS )) = add pair ( A , and(U , V) , FS ); constraint add pair ( A , U , add pair ( B , V , FS )) = add pair ( B , V , add pair ( A , U , FS )) . 
class attribute ; is a top ; constructor instances.

A class definition contains the name of the class and the parent in the hierarchy  . Furthermore , classes can contain constructor and constraint definitions  . The constructor definition state what elements the class contains  . In the definition offs above , the class contains one element empty , and one element add_pair ( A , V , FS ) for each possible instantiation of A as an attribute  , Vasavalue and FS as afs . In the definition of add ~ pair the symbols after : refer to the type of the arguments to add pair  . Here it can be noted that FLUF makes use of typed terms  . In the example siomit the types when writing terms since they are clear from the context  . 
The definition of attribute makes use of a special constructor instances  . This constructor means that the elements in the class are defined as objects below it  . 
In the definition offs constraint relations are used  . 
In FLUF '=' is used to specify that two terms should be interpreted as equal and '<' or '>' to specify the subsumption order between the defined elements  . 
The reason for having both >- and <- relations i that the left hand side of a relation is seen as the expression being defined and the righthand sideas what it is defined as  . 
In the example above the first constraint tells us that empty should subsume very constructor starting with add pair  .   2 The second relation states that fs's containing the same attribute more than once should have the same interpretation as the structure containing the attribute only once with the conjunction of the two values as its value  . The third equation says that the attribute order in afsisir relevant  . 
Next conjunction and disjunction are added . They do not add any new elements to our language and are defined as functions  . For a function the name of the function , the type of the result and the number and type of arguments to the function are specified  . To give the meaning of function expression constraints are specified as relations in the same way as for classes  . The definitions of and and or are given below . 
function and ; result value ; arguments value , value ; constraint and ( X , Y ) < X ; constraint and ( X , Y)<Y . 
function or ; result value ; 2 . Here there is a slight difference from PATR-II since empty does not subsume atoms  . The interpretation used in PATR-II can be obtained by defining empty as a value  . 
arguments value , value ; constraint or ( X , Y ) > X ; constraint or(X , Y)>Y . 
By these definitions both functions give a value as result and take two values as their arguments  . The constraint definition of and tells us that and is subsumed by its arguments  , while or subsumes its arguments . 
Next , some linguistic knowledge is defined . First the attributes and atoms used by the application are given  . This can be done using objects . An object is specified by just giving a name and a parent in the inheritance hierarchy  . What is special here is that object definitions are only allowed if there is an ancestor in the hierarchy which has a constructor specified as instances  . As an example I give the definition of cat . 
object cat ; is a attribute.
When defining linguistic knowledge , concept definitions are used to group it into conceptual parts  . In a concept definition the name of the concept and its parent in the inheritance hierarchy are specified  . It is also possible to specify a requirement as a typed term  . The meaning of such a requirement specification is that all objects that are of this concept must contain at least the information given by the require ~ ment  . Two concept definitions from the example are word cat and verb  . Their definitions are given below . 
concept word cat ; is a atom.
concept verb ; is afs ; requires add pair ( cat , v , empty) . 
With this definition of PATR~II grammar rules can be represented as feature structures  . The terms in FLUF allows assigning variables to subterms which gives a simple representation f coreferences in PATR dl  . 
A declarative and operational the semantics of FLUF is given in S  tr0mbgck   ( 1994b )  . The declarative semantics i an initial algebra semantics where the elements given by a definition are interpreted on a partial order  . The operational semantics amounts to giving a unification algorithm which in many ways is similar to narrowing  ( see , for example , Middeltorp & Hamoen (1992)) . The FLUF formalism is sound , but not fully complete . 
4 FURTHEREX AMPLES
In this section I give two further examples that demonstrate the flexibility of FLUF  . The first example ~~'///// ~ . add pair ~ a , v , closcd )
Fig .   2: The subsumption order for closed feature structures shows how fixed arity feature structures  ( used in , for example , STUF ( Beierle et al , 1988)) can be defined . 
class fs ; is a value ; constructor empty ; constructor closed ; constructor add pair : attribute , value , fs ; constraint empty > closed ; constraint empty > add_pair(A , V , FS ); constraint add_pair(A , U , add_pair(A , V , FS )) = add_pair(A , and(U , V) , FS ); constraint add_pair(A , U , add pair ( B , V , FS )) = add pair ( B , V , add pair ( A , U , FS )) . 
Compared to the definition of fi'given previously  , a new constructor closed is added . The idea here is that a feature structurended with closed has a fixed arity and cannot be extended with new attributes  . The given constraint relations would give us the subsumption order shown in Fig  .  2 . The most general structure is at the top . The shadowed areas represent feature structures not explicitly written in the figure  . 
The next example shows how different interpretations of sets can be detined in FLUE First I give a definition of sets corresponding to that used in HPSG  ( Pollard & Moshier ,  1990) . 
class set ; is a . . . ; constructor empty ; constructor Mdelem(w due , set ); constraint add_elem(V , addelem(V , S )) = add_elem(V , S ); constraint addelem(Vl , addelem(V2 , S )) = addelem(V2 , add_elem(V1 , S )) . 
Here the two constructors for sets empty and add elem are detined  . The two constraint relations in the definition say that each element only occurs once in a set and that the element order in a set is irrelevant  . With this definition the unifications below hold . 
To increase readability I have used the common notation for sets  . 
X,Y Ua = aX,YU a,b = a,b
In the first example the first constraint rule , identifying X and Y , is used . 
For some linguistic phenomena it would be more useful to have an interpretation fsets where unification works like union  . In FLUF this can be obtained by the definition below  . 
class set ; is a . . . ; constructor empty ; constructor addelem ( value , set ); constraint empty > addelem(V , S ); constraint add Mem(V1 , addelem(V2 , S )) = addelem(V2 , add_elem(V1 , S )) . 
The difference between this detinition aM the previous one is that empty subsume all other sets  . An element is also allowed to occur more than once in a set  . 
With this second efinition the first unification above has three possible results  . 
\[ a,YX,YUa = tX,a\[x,Y,a
In the first result a is identified with X , in the second with Y , and in the third with neither of them . Pres-ently FLUF gives all these three results as alternatives of the unilication  . 
The reason why a set can be extended with newele . .
ments in the second definition but not in the first is that the semantics of FLUF assumes that if two expressions are not ordered by some constraint relation they are in comparable  . Thus in the first definition sets are only related if all their elements are  . FLUF assumes that all delined constructions are monotonic  , so by the constraint relation given for empty in the second definition it can be concluded  , for example , that ( a > a , b . 
Other examples of what can be defined in FLUF are lists '  , trees and strings . It is also easy to define functions such as concatenation flists in FLUF  . 
5 DISCUSSION
This paper discusses how a flexible unification for ~ realism that can be used to obtain tailored unifiers for specific problems can be designed  . I identify some important properties of a formalism that can be used to obtain flexibility  . These are that the usernms t be allowed to define the elements he needs and functions on them  . He must also have some way of defining the behaviour of his elements and functions  . I observe that there are several advantages with using an inheritance hierarchy for detining the formalism and linguistic knowledge  . 

I present the FLUF formalism as a concretization f these ideas of a flexible formalism  . As for the expressiveness of FLUF , it is still limited . There is a need for extending the hierarchy to allow for multiple inheritance and nonmonotonicity  . Str6mb ~ ick ( 1994a ) provides more discussion on the expressiveness of FLUE There is very little discussion about unification algorithms in this paper  . There is , however , a pilot implementation f the FLUF formalism . The implementation handles everything described above  , but is very inefficient since it is based directly on operational semantics  . There are , however , several improvements that can be made , for example applying existing results for more efficient narrowing  ( Hanus ( 1993 ) gives an overview ) and integrating existing unification algorithms for some commonly used structures such as feature structures  . The idea of integrating existing algorithms ensures us a more predictable behaviour for FLUKE Another possibility is to use ideas from constraint logic programming  ( Jaffar & Lassez ,  1987) . This is particularly important in applications where this system is combined with some other process  , for example , a parser . 

This work has been supported by the Swedish Research Council for Engineering Sciences  . I am also grateful to Lars Ahrenberg for guidance on this work  . 

Beierle , C , UPletat , and HUszkoreit (1988) . An Al-gebraic Characterization fSTUF . LILOG Report IBM Deutschland , P . O . Box 8008 80,7000 Stuttgart 80, West Germany . 
Carpenter , B , (1992) . The Logic of Typed Feature Structures with Applications to Unification Grammars  , Logic Programs and Constraint Resolution . 
Cambridge Tracts in Theoretical Computer Science 32  , Cambridge University Press . 
Computational Linguistics 18(2-3) . Special Issue on Inheritance in Natural Language . June and September 1992 . 
D6rre , J , and A Eisele (1991) . A Comprehensive Uni-fication-Based Grammar Formalism  . DYANA Report . Deliverable R3,1B . January 1991 . 
Ehrig , H and B Mabr (1985) . Fundamentals of Alge-braic Specifications 1 . Equations and Initial Semantics . Springer-Verlag , Berlin , Heidelberg . 
Emele , MC , and R Zajac (1990) . Typed Unification Grammars . Proc .   13th International Conference on Computational Linguistics  , Helsinki , Finland , Vol 3 , pp 293-298 . 
Hanus , M , (1993) . The Integration of Functions into Logic Programming : From Theory to Practice  . Man-uscript , Max-Planck-Institut fiir informatik , Saar-brticken . 
Jaffar , J , and JL Lassez (1987) . Constraint Logic Programming . In Proceedings of the 14th ACM symposium of Principles of Programming Languages  . 
Munchen , Germany . pp 11-119.
Kaplan , R . and J . Bresnan (1983) . A Formal System for Grammatical Representation , I:J Bresnan Ed . , The Mental Representation f Grammatical Relations  , MIT Press , Cambridge Massachusets . 
Middeltorp , A , and E Hamoen (1992) . Couuter exam-ples to Completeness Results for Basic Nan'owing  . 
In : H . Kirchner and G . Levi Ed . , Proceedings of the 3rd international conference on Algebraic and Logic Programming  , Volterra , Italy . pp . 244-258, LNC6 32,

Pollard , C and Ivan AS (1987) . Information Based Syntax and Semantics . Vol 1 . CSLI Lecture notes,
CSLI Stanford.
Pollard , CJ , and MD Moshier (1990) . Unifying Partial Descriptions of Sets . Manuscript . 
Seiffert , R(1992) . How coukt a good system for practical NLP look like ? Paper presented at the workshop on Coping with Linguistic Ambiguity in  7q~ed Feature Formalism at the European Conference on Artifieial Intelligence  . Vienna , Austria . 
Shieber , SM , HUszkoreit , FCN Pereira , J Robinson , and M Tyson (1983) . The Formalisms and Implementation fPATR-II . In : Barbara Grosz and Mark Stickel , Ed . , Research on Interactive Acquisition and Use of Knowledge  . SRI Final Report 1984 , SRI International , Menlo Park , California . 
Str6mbdck , L(1992) . Unifying Disjunctive Feature Structures . Proc .   14th International Conference on Computational Linguistics  , Nantes , France , Vol 4 , pp 1167-1171 . 
Str6mbfick , L(1994a ) . FLUF : A Flexible Unification Formalism-the idea  . Technical Report . LITH-IDA-

Str6mb/ick , L(1994b ) . FLUF : A Flexible Unification Formalism-Syntax and Semantics  . Technical Re~port . LITH-IDA-R-94-13 . 

