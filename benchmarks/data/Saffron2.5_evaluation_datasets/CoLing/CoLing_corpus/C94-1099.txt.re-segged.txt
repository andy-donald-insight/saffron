ATOOLFORCOLLECTING DOMAIN DEPENDENT
SORTAL CONSTRAINT SFROM CORPORA
Frangois Andry * , Marl ( Gawron , John Dowding , and Robert Moore
SRI International , Menlo Pmq % CA
* CAPGEMINI Innovation , Boulogne I : lill a . ncourt , France
Internet : and ry@cap sogeti.fi:
Topical paper : Tools for NL Understanding

1 ABSTRACT
In this paper , we describe a tool designed to generate semiautomatically the sortal constraints specific to a domain to be used in a natural anguage  ( NL ) understanding system . This tool is evaluated using the Sll , IGeminiNL understanding system in tile ATIS domain  . 
of work we put into the first domain application 1 . 
In this paper , we describe tile results of using this semiautomatic tool top or t the  ( ' , e , udlii NL system to the ATIS domahi , a ( lomlt in that ( ienlini hadah'eady been ported to , arid for which it \] ladachiew ~ , dhighperl ' orluance ~ ttldgi ' al'l-illiati-cal coverage using handwritten sortal constraints  . 
Chossing a known domain , rather than a new one , allowed us to compare tile performance of tile derived sorts to the handwritten ones  , holding the domain , grammar , and lexicon constant . It also allowed us to evahlate the selni-~ultoma . tically obtained cown'age using the ewduation tools provided for the A'I?IS corpus  . 
2 INTRODUCTION
The construction of a knowledge base related to a specific domain for a NL understanding system is time consuming  . In the Gemini system , the domain-specific knowledge base includes a sort hierarchy and a set ot"s or trules tha ~ provide  ( largely domain-specific ) selectional restrictions for ew~ry predicate invoked by the lexicon and the grammar  . The selectional restrictions provide a source of constraints over and above syntactic on straints for choosing the correct analysis of a sentem : e  . The sort rules are generally entered by a linguist  , by hand , from the study of a corpus and while tuning the grammar  . 
I Iowever , the use of an interactiw ; tool that can help the linguist to acquire this knowledge from a  corpus\[a\]\[5\]  , can drastically reduce the time dedicated to this task  , and also improve the quality of the knowledge base in terms of both accuracy and coniple teness  . ' l'he reduction in the amount of etfort to develop the knowledge base becomes obvious when porting an existing system to a new domain  . At SR , I , our main concern was to port Gemini , our NL understanding system to other domains without investing the same amount  3 PARSING WITH SORTS Gemini\[2\] implements a clear separation Imtween syntactic and sem~mtic information  . Each syntactic node invokes a set of semantic rules which result in the bnihling of a set of logical forms for that node  . Select lomd restrictions are enforced on the logical for nlsthrough the sorts nlechanism : All prcdl cations in : ~ cat l diihd  . elogical form I lall StI ) elicensed by some sorts rule . The sorts are located in ~ conceptual hierarchy of approx hmd  ; cly 200 concepts mid are imphmle iH . ed as Pro\]og terms such that n lol'e gell or ai sorts SllltSlllllelliore specific  sorts\[6\]  . Failure to match any available sorts rule can thus heimpler nented as unification-failure  . 
Geminiparser creates logical forms expressions like the fbllowing one : exi  . sl . s(A;\[flighl\]) , \[ and , \[fli~lht , ( A;\[fli ~ . lht\])\]; [ prop\] , \[ to , ( A;\[flight\]) , (' I : ~05'! I'ON' ; \[ city\])\] ; \[prop\]\] ; ~ r , op\]) ; \[ prop\]In these logical form expressions , every subexpression is assigned a sort , represented as the IT heactual dom ; dn is AirTrans portation ( ATIS ) used as a benchmaxk in the ARPA community . 
598 right-hand-side of a '; ' operator\[l\] . Sorts rules for predicates are declared with sor/2 clauses : ~ or ( ' l ~ O , ?' rON ' ,  \[ , ,; ey\]) . 
sot(to , (\[\[ flight\] , [ city\]\] , \ [ prot , \]) ) . 
The above declarations lic . ense the use of ' BOSTON ' as a zero-ary predicate with " resulting " sort\[city\]and'to'as a two-place predicate relating flights and cities with resulting sort\[prop\]  ( or proposition )  . 
In the ATIS application domain , for exaulple , the subject ( or actor ) of the verb deparl , as in ' the morning flights deparling for denver  '  , can 1) ea flight . For this , we use the following set of sort definitions : . ~ o , '(d~v , , , ' t , (\[\[ d~v ~ , ,'~ , , , '~\]\] , \[ p , ,ov \])) so , ,(ftighl , (\[\[ fligtd\]\] , \[prop\])) so ,  . ( acto, . ,(\[\[\[ departure\],\[flivhl\]\],\[p, . np\] ) ) ' Phe tirst two definitions make depart and flight p  , ' e dieates compatible with departure and llight ewmts respectively  , returning a proposition ; the third makes a elora relation that ( : an hold between flights and tlights , also returning all roposi-Lion . A simple example of a logical formlice . nsed by these rules follows ( with the results or t\[prop\]suppressed ) : q term (   .   .   .   .   .   .   . ((X;\[flight\]),\[ . rid , \[ flight , ( X;\[flight\])\] , ezists(Y;\[flight\]) ,  \[ . , ,, I,\[a~v . , . t,(r;\[, t~v . , . t , ,~\])\] , ( v;\[ , l~v , ,~t , , , ,d ) , \[ actor , ( Y ;\[ del > art , vre\]) , ( X ; \[flighl\] ) \]\] ) \] ) Which would be roughly the logical form for ' a deparling flight '  . 
4 SORTACQUISITION't'heapl ) roach we have taken is to start fi'omanil , itial " schematic " sorts fih : we call the signature file  ( explained below )  , which essentially allows all predicate argument coml  ) inations . We tJlell hal'-vest a set of preliminary sort rules by parsing a large corpus  . The logical forms that induce these preliminary rules  e61rle fron a parses that ; essentially incorporate only syntactic on straints  . The resu\]l-ing sorts rules are filtered by \] lalld all d the process is iterated with an increasingly accurate sorts file  , converging rapidly on the sorts file specific to the application domain  ( fig .  1) . 
4 . 1 S ignature and l Les t r i c t ions If we started the abow ~ iteration process with no sortal information  ,  . then the logical forms resulting \[- co , , i , , 5; .   .   .   . 
. \] _~ ~ . - - - - - 7 ~ step : : lSg \] t . l ' ~ . ' e "~':--- Figure 1: lterative Acquisition of Sorts . 
froll la parse would colH . ailliios or talill\['Ol'nlatioil , alld only vacn on sortal rules wotlld\] ) e harvested . 
"\['\] le first stel ) is tllls to huild an initial sort file we call the signat ' ure\[il ~  . The idea is to assign lexical predicates inherent sorts  , but not to assign assign ally rllles which constrain which lexica\]itelns  ( : all coln hine with which . The signature file , then , is m~t just domain-independe . nt . It has no information at all a hout semanticoml >inal  ; o . 
rial Imssil ) ilities , not even those determined by the lallg tla , ~ e ( for example , that the verb break does not allow prolmsitional subjects  )  . The reason for this is so that it can be generated largely automatically from the lexicon  . 
4.2 The Signature
I , etsIm , e ; in with certain inherently relational predicates , for which the sigllatn refile gives only an arity and the result sort  . I " or example the signature fc ~ r the predica . tesal ( corresponding to the preposition ) and actor ( corresponding to logical subject ) wouhl be the same : . ~# . , . ~,,, . ,, . ( . t,(IX , r \], b ,, ' ov\]) . ~ i ~ t , . ,v,,, . ,~( . , , z , , , . , ( IX , v\] , \[ v , ' , ,v \] ) This signature is u~ed as the sort rule R~r at and actor in the sorts tool's first iteration  . The efl > ctist . olimit the choice of sorts rules for the seln ' edicates  1  . orules which are further instantiat , ions their sign at m ' os , that is , to rules licensing them to tion . The object in successive iterations will be to assign these relational predicate substantive sortal constraints  , thus constraining head modifier relations and the parse possibilities  . 
Verbs , nouns , some adjective and adverbs , on the other hand , have signatures with fully or partially instanciated arguments : For example  , in the ATIS domain , the verbs depart , get_in , mad the nouns data , flight have the signatures : signature ( depart , (\[\ [ departure\]\]~\[prop\])) si~nat ~ , re(get_in , (\[\[ a , ' ri~at\]\] , \[ prop\])) signature(data , (\[\[ information \]\] , b , rop\])) slgnature(flight , (\[\[ flight\]\] , \[prop\] ) ) These declarations have no effect on the combinatorial possibilities of these words  ( they tell us nothing about what can be the subject of the verb depart or what verbs the noun flight can be subject of  )  , but when a logical form is built up fl'om a syntactically licensed parse  ( like the one give . n above for a departing flight ) , these sortal declarations will " fill in " the sorts for the connecting predicate actor  , generating the sort rulc : slgnature ( actor , (\[\[ departure \] , \[ flight\]\] , [ prop\]) Thus in the signature file , lexical predicates have their own " inherent " sort rules  , which then help build up the sort rules for the relational predicates  . The inherent sort rules for adjectives like cheap and late will constrain only their first argument  . The reason for this is that it is this first argument that modifiers  ( such as intensifying adverbs and specifiers )  , will hook onto . 
*ig . ature ( eheap , (\[\[ eost_soa\] , A , n \] , \[ prop\])) ~ ignat ~ re(tate , (\[\[ temporal_stage \] , A ,  13\] , \[ p , ' op\] ) ) At the same time the argument position filled in by what the adjectives modify is left unconstrained  . The signature filethns makes no commitment about what sorts of things can be late or cheap  ; it just needs to say there is such a thing as lateness and cheapness  . This is why for a new domain the signature file can be generated largely automatically  , using a new inherent sort for each new lexical item  , ms signing the type of predicate appropriate to its grammatical category  . 
All zero-arity predicates ( names ) need to have inherent sorts . Certain general ' tool words ' which include numbers  , dates , time , and commons words , will receive the same signatures in any do-main : signature  ( 3 , (\[ number \])) signature ( lriday , (\[\ [ day\]\] , [ prop\])) signature ( pm , (\[ nonagent \])) signature ( yes , (\[ p , ' op\])) In addition to this , however , there is a whole list of words specific to the dorna in which riced to be inherently sorted  . This part of creating a signature file will need to be done by band : signature  ( ' NASIIYILLE' , (\[ city \])) signature (' AIl ~_ CANA 1kA ' , (\[ airline \])) signature (' LA_GUAfUglA ' , (\[ airport \])) 4 . 3 Ext rac t ing the Sor ts We now give a more detailed example of hows or trules are extracted fl'om logical forms  ( bFs ) built by the parser . For '* hemorning flights flying to denver ' , we obt~dn roughly the following Logical 1 , ~ orm:qterm(the;\[non_symmetric_determiner\] , 
A ;\[ flight\] , \[ and , \[fllqht , ( A ;\[flltfl , t \])\] , \[ n_n_rel , ( z ~;\ [ dau-Va , ' t\])\[ and , \[morning , (13;\[day-part\])\]\];\[\[da : , /-v . .'tl \], \[ prop\],
A ;\[ flight\]\] , ea : isZs(U;\[flight\] ,  \[ , , . d ,
If In , ( C;\[flight\])\] , \[ actor , ( C;\[ftlght\]) , ( A;\[flight\])\] , \[ has_aspect , ( C;\[flight\]) , ( in_progress;\[aspect\])\] , \[ to , ( C;\[flight\]) , (' D:;:NV:~':e';\[e'it , v\])\]\])\]);\[yli , jl ; t\]TheeXLracLiotlprocessCOllSiStSOfa recursive exploration of the logical form and retrie  , val of each predirate gild its arglllliellts , l d or example , from the LFs above , our tool would extract the following sort definitions set  7 : so t ( flight , \[\[ flight\]I , [ prop\])~o ~( . .o . , i , , g , \[\[, t . u-v . .~\]\], \[ v~ov \]) sor(n_n_rel , \[(\[\[, lay . port\]\] , bJrop\]) , \[ flight\]\] , b , rop\]) sot(fly , \[\[ flight\]\] , [ prop\])s or ( ael or , \[\[fti~aht\] , \[ftiyht\]\] , \ [ prop\]) sot(to , \[\[ flight\] , \[ city\]\] , \[ prop\])s or ( frag-nl , , \[\[ flight \]\] , b , ' rop\] ) 2 For reason of efficiency and simplification , we exclude some very common predicates independent of the domain  , such as ' and ' , ' equal ' , exists ' , ' has_aspect ' , ; tnd'qterm ' . 
600s or ( np_frag , \[\[ prop\]\] , [ prop\])When constrained only by signatures , the parser typically finds a large number of logical forms  . The sorts tool provides the option of harvesting sort rules in one of two ways  , either from all generated logical forms , or only from the Preferred Logical I'brm ( PLF ) . The parse preference component implemented in Geminic hooses the best intepretation from the chart  , based on syntactic heuristics\[2\] , and provides a set of PLFs . 
In addition to the extraction of the sort rules , we also calculate tire occurrence ? i of each sort rule for all the sentences of the corpus  . We then normalized ? i by the number of logical forms that include the sort rule  ( N i )  . F , ach value Oi is stored along with its sort , rule and used to calculate the probabilities related to the sort rule : -~ = o  6  ) i In fact three sets of probabilitilies are calculated for each rule R :  ( 1 ) Global probability of sort rule R : the number of invocations of rule  1% normalized by the number of LFs containing I ~ and divided by the total n mn bcr of rule invocations in the corpus  ;   ( 2 ) Conditional probability of rule 1~ given a particular predicate ;   ( 3 ) Conditional probability of 1% given the predicate in l ~ and an argument of the same sort as the first argument of R  . .
Also , associated to each sort definition , we keep the list of the indexes of a small set of sentences which contain the corresponding sort definition in its logical form  . This set is used as a sample for the set editor tool  . 
4.4 The Argument Restrictions
The argument restrictions are instantiated versions of the signatures for each predicate  . For example , after parsing and extraction from tire logical forms  , the arguments X and Y of the signature associated to the preposition at will help to generate a list of several sort definition such as : so  ,  . ( . t , (\[\[ . i ~ po~t\],\[eitu\]\],\[p , . op \]) as in :' the aiport at Dallas ', so ~( . t,(\[\[dom . in_e,~nt\],\[~i . r ~_ Vo ; n *\]\] , b " op \]) as in : ' departure at 9 prn ' . 
5 SORTEDITING
At each step of tire process , after parsing , tile linguist , using the interactive sort editor , can examine the new sort file which has been generated and choose which sortal definition need to be eliminated  . Statistical information ~ sociated to each sort definition helps him decide which ones are rev -elant or not  . We have also included tire possiblility of adding a sort definition  , although this kind of operation should be very rare  . In fact the main activity of the linguist using the sort editor tool  , will be to filter the sort definitions generated by the parsing of the corpus  . 
5.1 Description of the tool
The sort editor tool is all interactive , window-based program . It hms a main window for displaying and editing the sorts and a set of buttons that help the user to either display additional information or perform actions such as : ? load or save a sort file  , ? select a fimctor among tile list . of Ml fimctors and disphty the list of its possible arguments  , result and probabilities , ? deletion and insertion of a sort definition , ? display a sample of sentences associated to a specific sort definition  , ? mapping between the sort definitions and a reference sort file  ( for evaluation )  , ? changing the way the sort definitions are displayed  ( result or not , mapping or not , global prolmhility , conditional to a functor , or relative to the first argument of a definition  )  , ? use of a threshold on the ln'ol > abilities to filter the sort definitions  , ? retrieve I . he list or I ' unctors giw ma certain argu-\[I ( HIL ) ? display the sentences associated to a sort definition  , ? display the list of predicates which have been excluded form the extraction  , ? specification of a sortal hierarchy to be used with the sort definitions for the next iteration  , ? use of a whiteboard to save specific sentences and information daring a session  . 
The tool uses ProXT , the Quintus Prolog interface to MOTIF widget , set and the X-Toolkit . 
6016 EVALUATION AND RESULTS
Evaluate the porting to a new domain requirer nea -suring how the new sort file contributes to perform the target task within the new domain  . This kind of evaluation is difficult because it is hard to separate the contribution of the grammar and the contribution of the sorts constraints  . One way to evaluate our tool would be to have a file of " correct " sortal constraints that we use as a reference to check the ones we generate with our tool  . "rite problem is that this kind of file does not exist for new domMns  , since obtaining such file is precisely the purpose of our tool  . 
The approach we have chosen was to use the sort file built by hand for the ATIS corpus and to check this ' reference file ' against the new sort file we intend to build  , using our tool on a corl ) us of the same domain e . 
6.1 Building the signature file
For the this first experimental exercise with the sort tool  , we built the signature file somewhat differently than we wonld build it for a new application  . In order to facilitate evaluating tl , e tool , our goal this time was to come up with a signature file be compatible with the reference file built by hand  . 
The tirst step in the experiment was to automatically extract the signatures from the lexicon and reference sorts file  , which contains nearly 2200 sort definitions . Signatures are largely predictable from the grammatical category of a word  1"o   , ' example , most of the verbs ( except the auxiliaries ) with one argmnent , receiw ' . dasignature identical to the sort definition . On the other \[ laad , nlosl . 
of the prepositions received a signature with all their arguments replaced by a varial  ) h . ' ( since they are domain-specific ) . In this maid envoyage of the sort acquisition system  , the signatures chosen for verbs , adjectives and nouns were made coml ) ati-ble with the sort hierarchy used by the reference sorts file  . In porting to a new domain , the lexical signatures would presumahly use an automatically generated sort hierarchy  , almost entirely fi at , with a unique lexical sort for each lexical item . 
In addition to this , some signatures , for logical predicates and predicates introduced in semantic rules  , were added by hand . These represent a little bit more titan 15% of the final signature file which contains a total of  1357 signatures , llalf of these signatures are zero-arity predicates mostly automatically built from the lexicon  . 
6.2 Parsing Madeow
The next step of our experiment was to parse a corpus from the A'I'IS domain using the signature file we haw  ; Imilt . For this , we have used the MADCOW corpus\[4\] , that includes 724: t sentences of various length ( from 1 to 36 words ) with a large linguistic coverage from this domain  . This process had been done in both modes LFs anti PLI  , ' s . q ' he idea was to compare the result in both modes  , to check whether the use of parsing preferences was relewmt for the extraction of tiles or t definitions or if we had to use all the Logical l  , ' orms from tile parsing . 
The first iteration of parsing MAI ) COWIn'O-dated 5917 and 2275 sort rules a respectively for the LI , 's and PLFs modes . 
6 . 3 Mapp ing corpus and re ference rules For this firstewthmtion  , we also used a feature of our tool which ranmap each sort rule produced by the extraction phase against the rules of a reference sort file  . ' i ' he mapping consists of assigning one of the following categories to each corpus acquired sort rule : ? Exact : the corpus rule match exactly with a reference rule  , ? Incompatible : the corpus rule does not match with any reference rule  , ? Sabsnmed-by:tile corpus rule is subsumed by at least one reference rule  , ? ~ tlh stunes : the corpas rule subsumes at least one re\['ereace rule  , ? ln comparal ) h ~: the corpus rule is in comlmrabh : wil . hnthmstone reference rule . 
q'he following table shows the repartition of mapping categories modes IA  , 's and PLl:s:xact1--40 Ia 27 Ih ~ compatible

Subsumes_hl comparahh . "" total_D ~ ~ a Siuce zero-arity sort l ) redical csh ~ Lvea signature identical t , otheir sort rule , only sorts rules with at least an argmnmlt were extra  ( : teduring the parsing <> fMAI ) COW . 
4' l'wo sort rules are incomparable , whell they unify each other while none of them subsumes the other one  . 

Tim first comments concerning these figures is that the percentage of incompatible rules is higher for the LFs than the PLFs mode  ( respectively 52% vs 30% )  , and the number of ' exact's or ts is more than half for lAPs than PLFs  . This shows that the use of Preferred Logicall " orms for parsing is more efl\]cient in extracting the ' good sorts '  . 
tIowever , the figures do not give an exact idea of the completeness and precision of our tool  , since there is a large number of rules sulsumed by otlmrones  ( more than 30% for I , Fs and almost 50% for PLies mode ) . In fact , some of tile corpus rules are subsuined by more general rules ill the reference sort file while providing the same coverage as the references or t rules  . 
Therefore , the precision of our tool fc ) rthel'Ll"s mode just after the extraction phase can be estimated between  16%   ( exacts rules ) and 55% ( exact rules plus subsumed n\]les )  . This\[mmlergets better and more precise very q , ,ickly after the first iteration of editing since the work of the lin-gnist is precisely to remove most of the incompatible and incomparable rules and rules whi : h are either to  ( ) general or too speciiic . 
Theovt, . rge . neration of the tool just after parsing , for the Pl , l , 's mode , can I ) e estimated to at least 30% ( the percentage of incorrect rules )  . 
After tile first iteration of editing , this number decreases very quickly since low probahilitles help the ling nist to eliminate rules that are in comIati-hie or ineom parable  . 
There eall for the Pl , Fs mode after parsing , which is the ratio of the ' Exact ' corpus rules by the number of reference rules used for the mappillg in our evaluation  ( 636 nonzero-arity sorts rules )  , can be estimated to at least 57% . 
A more precise estimation of the exact ram > bet of ' Exact'rules could be CO mlmted by using the sortal hierarchy  , and generate t br the two sets of rules ( corpus and reference ) all the rules that can be subsumed , and realize the malplng only with these rules . 
7 CONCLUSION
This first evahm tion of our tool in the ATIS domain shows tlmt the acquisition of sorts from a corpus can be partially automated  , reducing drastically the time the linguistic dedicates to this task  ( the precision converges in few editing iteration )  . 
In addition to this , the possibility of a systematic examination for all predicates with crosschecldng tools such as sentence visualisation and funet or browing helps the linguist to establish strict a qui-sition methods for the knowledge base in new do-nlgins  . 
In addition to this , the tool can also lie used to improve an existing knowledge /  ) as e . For example , the study of the ineoml ) at ilderules d , ,r-ing this \[ i , 'st evaluatio , lhelped us . odiscover new rules that will increase the coverage of  ( ie mini in the ATIS system . 
8 Acknowledgements
This research was supported hythe Alwmced Ie -search Projects Agency mtder contract with the Of lice of Nawdlh ~ sear  ( : h , and by a grant of the \] , avoisier Program from thel " renchl ; ' reign Ollice . The views ~ uul conclusions contained in this document are thosenf the ~ ulthors and should  , , ot be interpreted as necessa . r-ily represe , lti , lgtile . officialiolicie . s , either exl ) ressed or implied , tf the Adwmcedlh:sear:hlrojectsAgency1th:U . S .  (' , over nnxe , tt , or those of the Sciel ~ Lific Missionfthel " renchl " oreign Ollice  . 
References\[l\]Alshawi,I1 . ( ed . ), The Core Lawfuage l'/n . -9b ~ e , MIT Press , 1!)92 . 
\[2\]I ) owding J . , Gawron , I . M . , Appelt 1) . , Bear J . , Cherny L . , Moore IL and Mortal1) . , % II" , MINI : A Natural I , anguage Systenl Fro'Spoken-l , anguage Understanding " , Proceedings of the 31st Meeting of the Association for Computational \ [ , inguistics , Ohio State II niw ' . rsity , Columbus , Ohio , pp . 5d-6l , 1993\[3\](', rishnmn R . , llirschman L . and Ngo'I' . N . , " l ) is e overy Procedures for Subhmguage Selectional Patterus : Initial li '  , xperinlents " , Comlmtalio ' , al Liwlui . ~lics , Vol . 12:3pp . 205, 198 ( i . 
\[4\] Ilirschrnal , l, . , " Multi- . Sitel ) at a Colhx ' . ti < m for a Sl ) oken , ai , g , mge2 rpus " , MAI ) COW , inl ' roccedings of the I ) AI~I'A ? ' peech . and Nal-urall , a ~ tguage Workshop , pp . 7-ld , II'e . J992 . 
\[5\]l , ang I " . M . , llir sehman1, . , " hnproved lorta-bitity and l'arsing Through hlte  , ' aetive Acquisition of Semantic hfforna ~ tio , ," , In #ec-ond Confi:rence on Applied Nal'ural Lang ' uagcl ' rocessiu  9'  , Feb .  1988 . 
\[6\] Mellish , C . , " Implenlenting Systemic Classification by Uld Iieation "  . Compulational Li ~> g' . islics , V'ol . 14, pp .  40-511, 1988 . 

