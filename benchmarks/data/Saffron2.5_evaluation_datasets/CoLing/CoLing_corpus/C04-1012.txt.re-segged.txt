Restrictions on Monadic ContextFree Grammars
Akio Fujiyoshi
Department of Computer and Information Sciences , Ibaraki University
4-12-1 Nakanarusawa , Hitachi , Ibaraki ,  316-8511 , Japan


In this paper , subclasses of monadic contextfree tree grammars ( CFTGs ) are compared . 
Since linear , nondeleting , monadic CFTGs generate the same class of string languages as tree adjoining grammars  ( TAGs )  , it is examined whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages  . Epsilon-freeness on linear , nondeleting , monadic CFTG is also examined . 
1 Introduction
The contextfree tree grammars ( CFTGs ) were introduced by W . C . Rounds (1970) as tree generating systems , the definition of which is a direct generalization of contextfree grammars  ( CFGs ) from strings to rooted , ordered , labeled trees . For the application of CFTGs to natural languages  , many kinds of restrictions on CFTGs have been considered because the string languages generated by CFTGs are exactly indexed languages  , whose emptiness problem and uniform membership problem are exponential time complete  , i . e . , nonre-stricted CFTGs are formidable . One approach to define subclasses of CFTGs is to restrict the ranks of nonterminals  . The rank of a nonterminal is a natural number assigned to each nonterminal by which the number of children of the node labeled by the nonterminal is fixed  . Through this approach , the simplest model of CFTGs is regular tree grammars  ( RTGs )   ( Brainerd ,  1969) , where the ranks of nonterminals are all 0 . The string languages generated by RTGs are the languages generated by contextfree grammars  ( CFGs )  . Since recent research on natural languages has suggested that formalisms for natural languages need to generate a slightly larger class of languages than CFGs  , this paper focuses on monadic CFTGs , where the ranks of nonterminals are either 0 or 1 . 
Another formalism of tree generating systems is tree adjoining grammars  ( TAGs )   ( Joshi et al , 1975; Joshi and Schabes , 1996; Abeille ? and Rambow ,  2000) . TAGs have been widely studied relating them to natural languages  , and it was shown that TAGs have the same generative power of string languages as other formalisms for natural languages developed independently such as head grammars  , combinatory categorial grammars and linear indexed grammars  ( Vijay-Shanker and Weir ,  1994) . 
It is also noteworthy that there are recognition algorithms for the string languages generated by TAGs that run in O  ( n6 ) and O ( M ( n2 ) ) time ( Ra-jasekaran , 1996; Rajasekaran and Yooseph ,  1998) . 
From the viewpoint of CFTG , the languages generated by TAGs were examined ( Fujiyoshi and Kasai , 2000; Fujiyoshi , 2004; Mo?ennich ,  1997) , and it was shown that linear , nondeleting , monadic CFTGs generate the same class of string languages as TAGs and a strictly larger class of tree languages than TAGs  . Linearity is a restriction on CFTGs that requires the number of occurrences of every variable in the right hand side of a rule be no more than  1  , and nondeletion requires all variables in the left hand side of a rule occur at least once in the right hand side  . In other words , linear , nondeleting , monadic CFTGs are those with nonterminals of rank  0 and 1 only and with exactly one occurrence of a variable in every righthand side of a rule for a nonterminal of rank  1  . 
In this paper , the subclasses of monadic CFTGs are compared to examine whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of string languages as TAGs  . It is shown that nondeletion is unnecessary since for any linear  , monadic CFTG , there exists an equivalent linear , nondeleting , monadic CFTG . On the other hand , it is shown that linearity is necessary since there exists a nonlinear  , monadic CFTG which is not weakly equivalent to any linear  , monadic CFTG . 
For the development of parsing algorithm , the property of epsilon-freeness is very important  , and in this paper , epsilon-freeness on linear , monadic CTFGs is also considered . Epsilon-freeness is a restriction on grammars that requires no use of epsilon-rules  , that is , rules defined with the empty string . It is shown that for any linear , monadic CFTG , there exists an epsilon-free , linear , nondeleting , monadic CFTG that generate the same string language  . 
2 Preliminaries
In this section , some terms , definitions and former results which will be used in the rest of this paper are introduced  . 
2 . 1 Ranked Alphabets , Trees and Substitution A ranked alphabet is a finite set of symbols in which each symbol is associated with a natural number  , called the rank of a symbol . Let ? be a ranked alphabet . For n ? 0 , it is defined that ? n = a ?? the rank of a is n  . 
The set T ? ( trees over ? ) is the smallest set of strings over ? , parentheses and commas such that ( 1 ) ?0 ? T ? and ( 2 ) if ?1 ,  ?2 ,   .   .   .   , ? n?T ? and a ? ? n for some n ? 1 , then a (?1 ,  ?2 ,   .   .   . , ? n ) ?

Let ? be the empty string . Let ? be the special symbol that may be contained in  ?0  . The yield of a tree is a function from T ? into ? ? defined as follows  . For ? ? T ? , (1) if ? = a ?(?0 ? ?) , yield (?) = a , (1?) if ? = ? , yield (?) = ? , and (2) if ? = a(?1 ,  ?2 ,   .   .   . , ? n ) for some a ? ? n and ?1, ?2, .   .   .   , ? n?T ? , yield(?)=yield(?1) ? yield(?2) ? ? ? yield(?n) . 
Let X be the fixed countable set of variables x1 , x2 ,   .   .   . . It is defined that X0 = ? and for n ? 1 , Xn = x1 , x2 ,   .   .   . , xn . x1 is situationally denoted by x . T ? ( X n ) is defined to be T ? ? X ntaking the ranks of elements in X are all  0  . For ? ? T?(Xn ) and ?1, ?2, .   .   . , ? n?T ?( X ), ?[?1, ?2, .   .   .   , ? n ] is defined to be the result of substituting each ? i  ( 1 ? i ? n ) for the occurences of the variable xi in ? . 
A tree ? ? T ? ( X n ) is linear if no variable occurs more than once in  ?  , and nondeleting if all variables in Xn occur at least once in ?  . The set of all linear trees and all nondeleting trees in T ?  ( X n ) are denoted by T ? ( dXne ) and T ? ( bXnc )  , respectively . 
In this papaer , the conventional way of illustrating trees is used  . See Figure 1 . The tree A(b(a ) , a , B(E , d )) is illustrated as (1) . An arbitrary tree ? ? T ? is illustrated as (2) . When the variables of a tree ? ? T ? ( X3 ) occur in the order of x1 , x2 , x3 , x1 , the tree is illustrated as (3) . 
2.2 Context Free Tree Grammars
The contextfree tree grammars ( CFTGs ) were introduced by W . C . Rounds (1970) as tree generating systems . The definition of CFTGs is a direct generalization of contextfree grammars  ( CFGs )  . 

ED % ( DG ? ? x1 x2 x3 x1 (1) (2) (3)
Figure 1: Trees
A contextfree tree grammar ( CFTG ) is a four-tuple G = ( N , ? , P , S ) , where : ? N and ? are disjoint ranked alphabets of nonterminals and terminals  , respectively . 
? P is a finite set of rules of the form
A(x1, x2, .   .   . , xn ) ? ? with n ? 0, A ? Nn and ? ? TN ? ?( Xn) . For A?N0, rules are written as A ?? instead of
A ( ) ? ? .
? S , the initial nonterminal , is a distinguished symbol in N0 . 
For a CFTGG , the one-step derivation
G ? is the relation on TN ??? TN ?? such that for a tree ? ? TN ??  , if ? = ? ?[ A(?1 ,  ?2 ,   .   .   .   , ?n )] for some ??? TN ?? ( dX1  e ) ? TN ?? ( bX1c ) , A?Nn and ?1 ,  ?2 ,   .   .   . , ? n ? TN ??, and A(x1, x2, .   .   . , xn ) ? ? is in P , then ?
G ???[? [?1, ?2, .   .   . , ? n ]] . Figure 2 is an example of a one-step derivation where the rule A  ( x ) ? ? is applied to the tree ? = ? ? [ A ( ??? ) ] and the tree ??[?[???]] is obtained . 
A n ( n-step ) derivation is a finite sequence of trees ?0 ,  ?1 ,   .   .   .   , ? n?TN ?? such that n ? 0 and ?0 G ? ?1 G ? ? ? ? G ? ? n . When there exists a derivation ?0, ?1, .   .   .   , ? n , it is writen that ?0Gn ?? nor ?0G ? ? ? n . 
The tree language generated by G is the set
L(G ) = ? ? T ? SG ? ? ? . The string language generated by G is LS ( G ) = yield ( ? ) ? ? L ( G )  . 
Note that LS(G ) ?(?0??)?.
? ?$???? ????????? xx$*x
Figure 2: One-step derivation
Let G and G ? be CFTGs . G and G ? are equivalent if L(G ) = L(G ?) . G and G ? are weakly equivalent if
LS(G ) = LS(G?).
2.3 Restrictions on CFTGs
ACFTG G = ( N , ? , P , S ) is monadic if the rank of any nonterminal is 0 or 1  , i . e . , N = N0 ? N1 and Nn = ? for n ? 2 . G is linear if for any rule A(x1, x2, .   .   .   , xn ) ? ? in P , ? ? TN ?? ( dXne ) , and nondeleting if for any rule A(x1 , x2 ,   .   .   . , xn ) ? ? in P , ?? TN ?? ( bXnc) . 
ACFTG G = ( N , ? , P , S ) is epsilon-free if for any rule A(x1 , x2 ,   .   .   . , xn )? ? in P , the symbol ? doesn?t occur in ? . 
When G is monadic , all rules are either of the form A ( x ) ? ? with A ? N1 and ? ? TN ?? ( X1 ) or of the form B ? ? with B ? N0 and ? ? TN ?? . 
When G is monadic , linear and nondeleting , for any rule A(x ) ? ? with A ? N1 in P , there exists exactly one occurrence of x in ? . 
For linear , nondeleting , monadic CFTGs , the following results are known . 
Theorem 2 . 1 ( Fujiyoshi and Kasai ,  2000 ) The class of string languages generated by linear  , nondeleting , monadic CFTGs coincides with the class of string languages generated by TAGs  . 
Theorem 2 . 2 ( Fujiyoshi and Kasai , 2000) For any linear , nondeleting , monadic CFTG , there exists a weakly equivalent linear , nondeleting , monadic CFTG G = ( N , ? , P , S ) that satisfies the following conditions : ? For anya ??  , the rank of a is either 0 or 2 . 
? For each A ? N0 , if A ? ? is in P , then either ? = a with a ? ? 0 , or ? = B(C ) with B ? N1 and C ? N0 . See (1) and (2) in Figure 3 . 
$ D$%&$ x$x % & x$x
Ex &
Ex & (1) (2) (3) (4) (5)
Figure 3: Strong normal form ? For each A?N1 , if A(x ) ? ? is in P , then ? is one of the following forms : ? = B ( C ( x ) ) with B , C ? N1 , ? = b(C , x ) with b ? ?2 and C ? N0 , or ? = b(x , C ) with b ? ?2 and C ? N0 . 
See (3), (4) and (5) in Figure 3.
If a linear , nondeleting , monadic CFTG satisfies the condition of Theorem 2 . 2 , it is said that the grammar is in strong normal form1  . 
3 Linearity and Nondeletion on Monadic

Because linear , nondeleting , monadic CFTGs generate the same class of string languages as TAGs  , the question is whether the restrictions of linearity and nondeletion on monadic CFTGs are necessary to generate the same class of languages  . First , it will be shown that nondeletion is unnecessary . 
Theorem 3 . 1 For any linear , monadic CFTG G , there exists an equivalent linear , nondeleting , monadic CFTG G ? . 
Proof . Let G = ( N , ? , P , S ) be a linear , monadic CFTG . An equivalent linear , nondeleting , monadic CFTG G ? = ( N ? , ? , P ? , S ) can be constructed as follows . 
The set of nonterminal is N ? = N ?0 ? N ?1 such that N ?0  =  N0 ? AA ? N1 and N ?1  =  N1  . 
For the preparation of the definition of P ? , for ? ? TN ?? ( X1 ) we define ? ( ? ) ? TN ??? ( X 1 ) as the smallest set satisfying the following conditions : ????  ( ? ) D 1We say ? strong ? because a grammar in this normal form only preserves weak equivalence  . 
 x *???*? ( 1 ) ????? x ? ???* ?*? ( 2 )  ^ ?? ? ?? ??  *? * ?  ( 3 )  ^ ??? ???
Figure 4: The three different cases ? If ??? ( ? ) and ? = ? ? [ B ( ??? ) ] for some B ? N1 , ??? TN ??? ( dX1  e ) ? TN ??? ( bX1c ) and ???? TN ??? , then ??[ B]??(?) . 
The set of rules is defined as follows.
P ? = A ? ? ? A ? N 0 , A ? ? ? P , ????(?) ? A(x ) ? ? ? A?N 1 , A(x ) ? ? ? P , ????(?) ? TN ??? ( bX1c ) ? A ? ? ? A?N 1 , A(x ) ? ? ? P ,  ?? ? ? ( ? ) ? TN ??? Because of the construction of N ? and P  ?  , G ? is monadic and nondeleting . 
To show the equivalence of G and G ? , we prove the following statement holds for any ? ? TN ?? and ? ? T ? by induction on the length of derivations : ? 
G ??? if and only if there exits ts ? ??? ( ? ) such that ??
G ? ? ? ? .
We start with proving ? only-if ? part . Let ?
Gk ? ?.
If k = 0, then clearly ? = ?, ???(?) and ?
G ? ? ? ? . For k ? 1 , assume that the statement holds for any derivation of length less than k  . If a rule of the form A ? ? with A ? N0 is used at the first step , the proof is rather simple , so we only prove the other case . Suppose that a rule A ( x ) ? ? with A ? N1 is used at the first step and ? = ? ? [ A ( ??? ) ]
G ???[?[???]]
G ??? for some ??? TN ?? ( dX1  e ) ? TN ?? ( bX1c ) and ???? TN ?? . By the induction hypothesis , there exist ???(??[?[???]]) such that ?
G ? ? ? ? . Here , we have to think of the three different cases : ( 1 )  ? ? ? ( ?? )  ,   ( 2 ) ? can be written as ??[??] for some ???? ( ?? ) and ???? ( ? )  , and ( 3 ) ? can be written as ??[??[???]] for some ???? ( ?? )  , ????(?) and ?????(???) . See Figure 4 . In the case (1), ???(?) and ?
G ? ? ? ? .
In the case (2) , A ??? is in P ? and therefore , ??[ A ]??(?) and ??[ A]
G ? ??? [??]
G ? ? ? ? . And in the case (3) , A(x ) ? ? ? is in P ? and therefore , ??[ A (???)]??(?) and ??[ A (???)]
G ? ? ? ? [ ? ? [ ? ? ?]]
G ? ? ? ? .
The ? if ? part is proved as follows . Let ??
G ? k ? ? for some ????(?) . If k = 0, then clearly ?? = ?, ?= ?? and ?
G ? ?? . For k ? 1 , assume that the statement holds for any derivation of length less than k  . The rule used at the first step is one of the following forms :  ( 1 ) A ? ? ? with A ? N0 , (2) A(x ) ? ? ? with A ? N1 , or (3) A ? ? ? with A?N ?0 ? N0 . The proof of the case ( 1 ) is similar to the proofs of the other cases , so we start proving the case (2) . In the case (2), ?? = ? ? ? [ A(????)]
G ? ? ? ? ? [ ? ? [ ? ? ? ?]]
G ? ? ? ? for some ? ? ? ?
TN ???( dX1  e ) ? TN ??? ( bX1c ) and ????? TN ??? . By the definition of P ? , A(x ) ? ? is in P such that ????(?) . By the induction hypothesis , for any ? ? TN ? ? such that ? ? ? [ ? ? [ ? ? ?(?) , ? G ??? . By the definition of ? , there exists ??? TN ?? ( X1 ) and ???? TN ?? such that ? = ? ? [ A ( ??? ) ] G ???[?[???]] , and ???[??[????]]??(??[?[???]]) . Therefore , ?
G ? ?? .
And in the case (3), ?? = ? ? ?[ A]
G ????? [??]
G ? ? ? ? for some ? ? ? ? T N ? ? ? ( dX1  e ) ? TN ??? ( bX1c )  . By the definition of P ? , A(x ) ? ? is in P such that ????(?) . By the induction hypothesis , for any ? ? TN ?? such that ???[??]??(?) , ? G ??? . By the definition of ? , there exists ??? TN ?? ( X1 ) and ???? TN ?? such that ? = ? ? [ A ( ??? ) ] G ???[?[???]] , and ???[??]??(??[?[???]]) . Therefore , ?
G ? ?? .
Because ?( S ) = S,L(G ) = L(G ?).
Next , consideration will be given to whether the restriction of linearity can be removed from monadic CFTGs to generate the same class of languages  . The answer is negative . The following example is a nonlinear , monadic CFTG that generates a string language that no linear  , monadic CFTG can generate . 
Example 3 . 2 The following is an example of a monadic CFTG that generates the string language  Lw4 = w w w w w ? a , b + . G = ( N , ? , P , S ) where N =  S , A , the ranks of S and A are 0 and 1 , respectively , ? = a , b , c , d , the ranks of a , b , c and d are 0 ,  0 , 2 and 4 , respectively , and P consists of the following rules :
S?A(a ), S?A(b ), A(x ) ? d(xxxx),
A(x ) ? A(c(xa )), and A(x ) ? A(c(xb)).
Because G has the rule A(x ) ? d(x x x x ) , G is not linear . 
Theorem 3 . 3 There exists a monadic CFTG which is not weakly equivalent to any linear  , monadic

Proof . It is known that the string language Lw4 in Example 3  . 2 cannot be generated by any TAG . It cannot be generated by any linear , monadic CFTG , neither . 
4 Epsilon-Freeness on Linear , Monadic

According to our definition of CFTGs , they are allowed to generate trees with the special symbol ?  , which is treated as the empty string while taking the yields of trees  . In this section , it will be seen that for any linear , monadic CFTG , there exists a weakly equivalent epsilon-free , linear , nondeleting , monadic CFTG . Because any epsilon-free CFTG cannot generate a tree with ?  , it is clear that for a CFTG with epsilon-rules , there generally doesn?t exist an equivalent epsilon-free CFTG  . 
Theorem 4 . 1 For any linear , monadic CFTG G = ( N , ? , P , S ) , if ?6 ? LS(G ) , then there exists a weakly equivalent epsilon -free  , linear , nondeleting , monadic CFTG G ? . If ? ? LS(G ), then there exists
G ? whose epsilon-rule is only S??.
Proof . Since it is enough to show the existence of a weakly equivalent grammar  , without loss of generality , we may assume that G is in strong normal form . We may also assume that the initial nonterminal S doesn?t appear in the right hand side of any rule in P  . 
We first construct subsets of nonterminals E0 and E1 as follows . For initial values , we set E0 = A ? N0A ? ? ? P and E1 = ? . We repeat the following operations to E0 and E1 until no more operations are possible : ? If A ? B  ( C ) with B ? E1 and C ? E0 is in
P , then add A ? N0 to E0.
? If A(x ) ? b(C , x ) with C ? E0 is in P , then add A?N1 to E1 . 
? If A(x ) ? b(x , C ) with C ? E0 is in P , then add A?N1 to E1 . 
? If A(x ) ? B(C(x )) with B , C ? E1 is in P , then add A?N1 to E1 . 
In the result , E0 satisfies the following.
E0 = A ? N0 ? ? ? T ? , AG ??? , yield (?) = ? We construct G ? = ( N ? , ?? , P ? , S ) as follows . 
The set of nonterminals is N ? = N ?0 ? N ?1 such that N ?0  =  N0 ? AA ? N1 and N ?1  =  N1  . The set of terminal is ?? = ? ? c , where c is a new symbol of rank 1 . The set of rules P ? is the smallest set satisfying following conditions : ? P ? contains all rules in P except rules of the form A ? ?  . 
? If S?E0, then S ? ? is in P?.
? If A?B(C ) is in P and C?E0, then A ?
B is in P?.
? If A(x ) ? B(C(x )) is in P , then A?B(C ) is in P ? . 
? If A(x ) ? b(C , x ) or A(x ) ? b(x , C ) is in P and C?E 0 , then A(x ) ? c(x ) is in P ? . 
? If A(x ) ? b(C , x ) or A(x ) ? b(x , C ) is in P , then A ? c(C ) is in P ? . 
To show LS(G ?) = LS(G ) , we prove the following ( i ) ,   ( ii ) and ( iii ) hold by induction on the length of derivations : ( i ) For A ? N0 , AG ????? and ??? T ? if and only if A
G ??? for some ? ? T ? such that yield ( ? ) = yield ( ?? )  6= ? . 
( ii ) For A?N1 , A(x)G ????? and ??? T?(X1) if and only A(x )
G ??? for some ? ? T ? ( X1 ) such that yield ( ? ) = yield ( ?? )  . 
( iii ) For A?N?0 ? N0 , AG ????? and ??? T ? if and only if A(x )
G ??? for some ? ? T ? ( X1 ) such that yield ( ?[?] ) = yield ( ?? )  6= ? . 
We start with ? only if ? part . For 0-step derivations , ( i ) ,   ( ii ) and ( iii ) clearly hold since there doesn?t exists ?? ? T ? nor ??? T ?  ( X1 ) for each statement . 
We consider the cases for 1-step derivations.
[ Proof of ( i )] If A
G ? ??? and ??? T ? , then ?? = a for some a ? ?0 and the rule A ? a in P ? has been used . Therefore , A ? a is in P and A
G?a .
[ Proof of ( ii )] If A(x )
G ? ??? and ??? T?(X1) , then ?? = c ( x ) and the rule A ( x ) ? c ( x ) in P ? has been used . By the definition of P ? , A(x ) ? b(C , x ) or A(x ) ? b(x , C ) is in P for some C ? E0 . There exists ? ? T ? such that

G ??? and yield (?) = ?. Therefore , A(x)
G ? b(C , x)
G ? ? b(?,x ) or A(x )
G ? b(x,C )
G ? ? b(x ,  ?) , and yield(b (? , x )) = yield(b(x , ?)) = yield(c(x )) . 
[ Proof of ( iii ) ] There doesn?t exists ??? T ? such that A
G ? ? ? ? .
For k ? 2 , assume that ( i ) ,   ( ii ) and ( iii ) holds for any derivation of length less than k . 
[ Proof of ( i )] If A
G ? k ? ? ? , then the rule used at the first step is one of the follwoing form:  ( 1 ) 
A?B(C ) or (2) A ? B . In the case (1), A
G??B(C )
G ????? [??] = ?? for some ???
T?(X1) and ??? T ? such that B(x)G ????? and

G ? ? ? ? ? . By the induction hypothesis of ( ii ) , there exists ? ? T ? ( X1 ) such that B ( x ) G ??? and yield ( ? ) = yield ( ? ? )  . By the induction hypothesis of ( i ) , there exists ? ? T ? such that CG ??? and yield  ( ? ) = yield ( ? ? )  . By the definition of P?,
A?B(C ) is in P . Therefore , A
G?B(C )
G ??? [?] and yield(?[?]) = yield(??[??]) . In the case (2),

G ? ? B
G ? ? ? ? ? . By the definition of P ? , A ? B(C ) is in P for some C ? E0 . There exists ? ? T ? such that C
G ??? and yield (?) = ? . By the induction hypothesis of ( iii ) , there exists ? ? T?(X1) such that

G ??? and yield(?[?]) = yield(??).Therefore,

G?B(C )
G ??? [?] and yield(?[?]) = yield(??).
[ Proof of ( ii )] If A(x )
G ? k ? ? ? , then the rule used at the first step is one of the follwoing form:  ( 1 ) A ( x ) ? B ( C ( x ) ) , (2) A(x ) ? b(C , x ) or (3) A(x ) ? b(x , C ) . Be casue these rule are in P , the proofs are direct from the induction hypothesis like the proof of the case  ( 1 ) of ( i )  . 
[ Proof of ( iii )] If A
G ? k ? ? ? , then the rule used at the first step is one of the follwoing form:  ( 1 ) A ? B ( C ) or ( 2 ) A ? c ( C )  . In the case (1),

G??B(C )
G ? ? ? ? ? [ ? ?] = ? ? for some ? ? ? T ? ( X1 ) and ??? T ? such that B ( x ) G ????? and C
G ? ? ? ? ? .
By the induction hypothesis of ( ii ) , there exists ? ? T ? ( X1 ) such that B ( x ) G ??? and yield ( ? ) = yield ( ?? )  . By the induction hypothesis of ( iii ) , there exists ? ? T ? ( X1 ) such that C ( x ) G ??? and yield ( ?[?] ) = yield ( ? ? )  . By the definition of P ? , A(x ) ? B(C(x )) is in P . Therefore,

G?B(C(x ))
G ???[?] and yield(?[?[?]]) = yield(??[??]) . In the case (2), A
G??c(C )
G ? ? ? c ( ?? ) =?? for some ??? T ? such that CG ????? . By the induction hypothesis of ( i ) , there exists ? ? T ? such that C
G ??? and yield(?)=yield(??) . By the definition of P ? , A(x ) ? b(C , x ) or A(x ) ? b(x , C ) is in P . Without loss of generality , we may assume that A(x ) ? b(C , x ) is in P . Therefore,

G ? b(C , x)
G ? ? b(? , x ) and yield(b (? , x ) [?]) = yield(c (??)) . 
The ? if ? part is similarly proved as follows . For 0-step derivations , ( i ) ,   ( ii ) and ( iii ) clearly hold since there doesn?t exists ? ? T ? nor ? ? T ?  ( X1 ) for each statement . 
The cases for 1-step derivations are proved.
[ Proof of ( i )] If A
G ? ? and ? ? T ? , then ? = a for some a ? ?0 and the rule A?a in P has been used . Therefore , A ? a is in P ? and A
G??a .
[ Proof of ( ii ) and ( iii ) ] There doesn?t exists ? ? T ? such that A
G ? ?.
For k ? 2 , assume that ( i ) ,   ( ii ) and ( iii ) holds for any derivation of length less than k . 
[ Proof of ( i )] If A
Gk ?? , then the rule used at the first step must be of the form A ? B  ( C )  . Thus,

G?B(C )
G ??? [?] = ? for some ? ? T ? ( X1 ) and ? ? T ? such that B ( x ) G ??? and C
G ? ?? .
Here , we have to think of the two cases : ( 1 ) yield ( ? ) 6= ? and ( 2 ) yield ( ? )  = ? . In the case (1) , by the induction hypothesis of ( ii ) , there exists ?? ? T ? ( X1 ) such that B ( x ) G ????? and yield ( ?? ) = yield ( ? )  , and by the induction hypothesis of ( i ) , there exists ??? T ? such that CG ????? and yield  ( ?? ) = yield ( ? )  . By the definition of P ?, A ?
B(C ) is in P . Therefore , A
G??B(C )
G ? ???[??] and yield(??[??]) = yield(?[?]) . In the case (2), C?E0 . Thus , A ? B is in P ? . By the induction hypothesis of ( iii ) , there exists ??? T?(X1) such that B
G ? ??? and yield(??)=yield(?[?]) . Therefore , A
G ? ? B
G ????? and yield(??)=yield(?[?]).
[ Proof of ( ii )] If A(x )
Gk ?? , then the rule used at the first step is one of the follwoing form:  ( 1 ) A ( x ) ? B ( C ( x ) ) , (2) A(x ) ? b(C , x ) or (3) A(x ) ? b(x , C ) . The proof of the case ( 1 ) is direct from the induction hypothesis . In the case (2),

G ? b(C , x)
G ? ? b(?,x ) = ? for some ? ? T ? such that C
G ? ?? . Here , we have to think of the two cases : ( a ) yield ( ? ) 6= ? and ( b ) yield ( ? )  = ? . 
( a ) If yield (?) 6= ? , then by the induction hypothesis of ( i ) , there exists ??? T ? such that

G ????? and yield(??)=yield(?) . By the definition of P ? , A(x ) ? b(C , x ) is in P ? . Therefore,

G ? ? b(C , x)
G???b (?? , x ) and yield(b (?? , x )) = yield(b (? , x )) . ( b ) If yield (?) = ? , then C?E0 and A(x ) ? c(x ) is in P ? . Therefore , A(x )
G??c(x ) and yield(c(x )) = yield(b(?,x)) . The proof of the case ( 3 ) is similar to that of the case ( 2 )  . 
[ Proof of ( iii )] If A(x )
Gk ?? , then the rule used at the first step is one of the follwoing form:  ( 1 ) A ( x ) ? B ( C ( x ) ) , (2) A(x ) ? b(C , x ) or (3) A(x ) ? b(x , C ) . In the case (1),

G?B(C(x ))
G ??? [?] = ? for some ?, ? ?
T?(X1) such that B(x)G ??? and C(x )
G ? ?? . By the definition of P ?, A ? B(C ) is in P ? . By the induction hypothesis of ( ii ) , there exists ???
T? ( X1 ) such that B ( x ) G ????? and yield ( ? ? ) = yield ( ? )  . By the induction hypothesis of ( iii ) , there exists ??? T ? such that CG ????? and yield  ( ? ? ) = yield ( ?[?] )  . Therefore , A
G??B(C )
G ?????[??] and yield(??[??]) = yield(?[?[?]]) . In the case (2),

G ? b(C , x)
G ? ? b(?,x ) = ? for some ? ?
T ? such that CG ??? and yield (?) 6= ? . By the definition of P ?, A ? c(C ) is in P ? . By the induction hypothesis of ( i ) , there exists ???
T ? such that CG ????? and yield ( ? ? ) = yield ( ? )  . 
Therefore , A
G??c(C )
G ??? c (??) and yield(c (??)) = yield(b(? , x ) [?]) . The proof of the case ( 3 ) is similar to that of the case ( 2 )  . 
By(i ), we have the result LS(G ?) = LS(G).
5 Conclusions
In this paper , the desirable features of linear monadic CFTGs have been discovered : the restriction of nondeletion doesn?t affect their generative power of tree languages  , and the restriction of epsilon-freeness can be assumed when their generation of string languages is considered  . The key to the proofs of this paper was the simplicity of the definition of linear  , monadic CFTGs and their normal form . 
Recently , the class of grammars called mildly context -sensitive grammars has been studied very actively  , to which TAGs and other well-established formalisms for natural languages belong  . Since it is not difficult to study formal properties of linear  , monadic CFTGs , they are helpful tools for the study of mildly context-sensitive grammars  . 

Anne Abeille ? and Owen Rambow , editors . 2000.
Tree adjoining grammars : formalisms , linguistic analysis and processing . CSLI Publications,
Stanford , California.
Walter S . Brainerd .  1969 . Tree generating regular systems . Information & Control , 14(2):217?231 . 
Akio Fujiyoshi and Takumi Kasai .  2000 . Spinal-formed contextfree tree grammars . Theory of
Computing Systems , 33(1):59?83.
Akio Fujiyoshi .  2004 . Epsilon-free grammars and lexicalized grammars that generate the class of the mildly context -sensitive languages  . In 7th International Workshop on Tree Adjoining Grammar and Related Formalisms : Proceedings of the 
Workshop , Vancouver , pages 16?23.
Aravind K . Joshi and Yves Schabes , 1996 . Handbook of Formal Languages , volume 3 , chapter Tree-adjoining grammars , pages 69?124 . 
Springer , Berlin.
Aravind K . Joshi , Leon S . Levy , and Masako Takahashi .  1975 . Tree adjunct grammars . J . Computer & System Sciences , 10(1):136?163 . 
Uwe Mo?ennich .  1997 . Adjunction as substitution : an algebraic formulation of regular  , contextfree and tree adjoining languages . In G . V . Morrill GJ . Kruijff and R . T . Oehrle , editors , Formal Grammars 1997: Proceedings of the Conference , Aix-en-Provence , pages 169?178 . 
Sanguthevar Rajasekaran and Shibu Yooseph.
1998. TAL recognition in O(M(n2)) time.J.
Computer & System Sciences , 56(1):83?89.
Sanguthevar Rajasekaran .  1996 . Tree-adjoining language parsing in O(n6) time . SIAM J . Comput . , 25(4):862?873 . 
William C . Rounds .  1970 . Mapping and grammars on trees . Mathematical Systems Theory , 4(3):257?287 . 
K . Vijay-Shanker and David J . Weir . 1994.
The equivalence of four extensions of contextfree grammars  . Mathematical Systems Theory , 27(6):511?546 . 
