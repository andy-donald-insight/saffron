ContextFree Grammar Rewriting and the Transfer of Packed Linguistic 

Marc Dymetman
Xerox Research Centre Europe
6, chemin de Maupertuis
38240 Meylan , France
dymetman@xrce.xerox.com
Fr~dfiric Tendeau
Lernout & Hauspie
Koning Albert-Ilaan 64
B-1780 Wemmel , Belgium
Frederic . Tendeau@lhs.be

We propose an algorithm for the trausfer of packed linguistic structures  , that is , finite collections of labelled graphs which share certain subparts  . A labelled graph is seen as a word over a vocabulary of description elements  ( nodes , arcs , labels ) , and a collection of graphs as a set of such words  , that is , as a hm-guage over description elements . A packed representation for the collection of graphs is then viewed as a contextfree grammar which generates such a language  . We present an algorithm that uses a conventional set of transferules but is capable of rewriting the CFG representing the source packed structure into a CFG representing the target packed structure that preserves the compaction properties of the source CFG  . 
1 Introduction
There is currently much interest in translation models that support some amount of ambiguity preservation between source and target exts  , so as to minimize disambiguation decisions that the system  , or an interactive user , has to make during the translation process ( Kay et al ,  1994) . .
An important aspectol ' such models is the ability to handle  , during all the stages of the translation process , packed linguistic structures , that is , structures which factorize in a compact fashion all the different readings of a sentence and obviate the need to list and treat all these readings in isolation of each other  ( as is standard in more traditional models for machine translation  )  . 
In the case of parsing , and more specifically , parsing with unification-based formalism such as LFG  , techniques for producing packed structures have been in existence for some time  ( Maxwell and Kaplan , 1991; Maxwell and Kaplan , 1993; Maxwell and Kaplan , 1996; D6rre , 1997; Dymetman ,  1997) . More recently , techniques have been appearing for the generation from packed structures  ( Shemtov ,  1997) , the transfer between packed structures ( Emele and Dorna , 1998; Rayner and Bouillon ,  1995) , and the integration of such mechanisms into the whole translation process  ( Kay , 1999; Frank ,  1999) . 
This paper focuses on the problem of transfer . The method proposed is related to those of ( Emele and Dorna , 1998) and ( Kay ,  1999) . As in these approaches , we view packed representations a being descriptions of a finite collection of directed labelled graphs  ( similar to the functional structures of LFG )  , each representing a different non-ambiguous reading  , which share certain subparts . 
The representations of ( Emele and Dorna , 1998) and ( Kay ,  1999 ) arc based on a notion of propositional contexts ( see ( Maxwell and Kaplan ,  1991)) , where each possible non-ambiguous reading included ill the packed source representation is extracted by selecting the value  ( true or false ) of a certain number of propositional variables that index elements of the labelled source graph  . 
Transfer is then seen as a process of rewriting source graph elements  ( e . g , nodes labelled with French lexemes ) into target graph elements ( e . g . nodes labelled with English lexemes ) , while preserving the propositional contexts in which these graph elements were selected  . 
In contrast , our approach , following ( Dymetman ,  1997) , views a packed representation as being a grammar ( more specifically , a context-flee grammar ) over the vocabulary of graph elements ( labelled nodes and edges )  , where each word ( in the sense of form a language theory ) generated by the grammar represents one of the possible non-ambiguous readings of the packed representation  . I other terms , the collection of non-ambiguous graphs belonging to the packed representation is seen as a km -guage over a vocabulary of graph elements  , and a packed representation is seen as a grammar which generates such a language  . Packing comes fi'om the fact that a contextfree grammar is an cM cicnt representation lbr the language it generates  . Another essential feature of such a representation is that it is interaction-free  , that is , each nondeterministic op-down traversal of the grammar succeeds without ever backtracking and it results in a certain reading  , without he need for checking the consistency of a set of associated propositional constraints : the representation for the collection of readings is as direct as can be while permitting a filctorization of common parts  . 
Based on this notion , we present an algorithm for transfer which , starting fi'om a finite set of rewriting patterns  ( the transfer lexicon )  , associates with a given context-fi'e e grammar e presenting the source packed structure a contextfree grammare presenting the tat'-get packed structure  . Therefore , the target representation remains interaction-fi ' ee and transparently encodes the target structures  ; furthermore , under certain natural " locality " conditions on the rewriting rules  ( the graph elements in their lefthand sidestend bebe " close " from each other in the source grammar derivations  )  , the target grmn mar preserves much of the factorization and compaction properties of the so tu'ce grammar  . 
The paper is struct tu'ed in the following way . Sec-commutative hmguagcs over graph description elements  , and how contextfree grammars provide concise specili-cations for these languages  . Section 3 extends the standard notion of non-ambiguous transfer to that of ambiguous transfer  . Section 4 presents the basic hmguagc-theoretic formalism needed and introduce some opera-or son languages  . Section 5 presents I he detailed rewriting algorithm , which applies these operators not directly to hm guages  , but to the contextfree grammar specify-ing them . Section 6 gives an example of the algorithm in operation . 
2 Ambiguous structures as languages
O : see/sawz .   .   .   .   .   .   .   .   .   .   .   .   .  -  . __argl ~ - - ' ~ ~ at ' g2 - - - - - . * nod " " mod1:i2:lightz_~-Z--\\-- . \Jlfnl()(\]--~~ , ---- IIlOd\ 7: green I/g reen2   err'g2 ~ ~ l
J4: hill-m(~dxt5: wilhar ? , 2 \[  ( ~: lelescope Figure 1 : An informal graphical representation f the 20 possible analyses for " I saw the green light on the hill with a telescope "  . 
Let's consider the sentence " I saw the green light on the hill with a telescope "  . In Fig . I , we have represented in lbnnally the set of possible analyses for this sentence  . Labels on the nodes correspond to predicate names  ( ' on ' , ' hill ' , etc ) . A slash is used to indicate different possible readings for a node  ; for instance , we assume that the surface form " saw " can correspond to the verbs " to see " or " to saw "  , and that " green " is ambiguous between the color adjective " greenl " and the noun "  green2"   ( grass ylawn )  . Relations betwee nodes are indicated by labels on the edges joining two nodes : ' argl ' and '  arg2' for tirst and second argument , ' rood ' for mod-ilier . The solid edges correspond to relations which are satistied in all the readings for be sentence  , dotted edges to relations that are satistied only for certain readings  . 
Thus , the preprositional phrase " on the hill " can modify either " light " or " see/saw "  , the phrase " with a telescope " either " hill " , " light " , or " see/saw ' . The informal picture of Fig .   1 does not make explicit exactly which structures are actually possible analyses of the sentence  . For instance the two crossing edges modo3 and rood25   ( where indices are used to denote the origin and destination of the edge  ) cannot appear together in a reading of the given sentence  . As a consequence only five of the apparent 2 x 3 preposition alttachments combinations are possible  , which multiplied by the four possible lexical variants for " saw " and " green " gives  20 possible readings for tim sentence . 
Each of these readings is a graph where nodes 0 and 7 now carry one label , and where one ' rood ' edge has been selected for the attachment of nodes  3 and 5  . One way to describe such a graph is by listing a collection of " description elen mnts " for it  , where each such dement is either a labelled node such as sccoor a labelled edge such as  rood27  . Using this format , the pragmatically preferred analysis for our sentence is the set SCCo  , mg lol , i l , arg202 , light 2 , mod 27 , gwen lT , mod . 23, on 3, arg234, hill4, modo5, with ~,, zug2 . ~a , tclescope ~ . 
If we consider the collection of all possible analyses  , we then obtain a collection of sets of description elements  . It is convenient to view such a collection as a commutative language over the vocabulary of all possible description elements  ; each word in such a hmguage corresponds to one analysis and is a list of description elements the order of which is considered irrelevant  . 
The main advantage of taking this view of ambiguous structures is that fomml language theory provides standard tools for representing languages compactly  . Thus it is wellknown in computational lexicography tlmt a large list of word strings can be represented efliciently by means of a tinite-stale at l tomaon which factorizes common subsrings  . Such a representation is both compact and " explicit ": accessing and using it is as direct as the flat list of words would be  . 
Although one might think o1' using tinite-statc models for representing compaclly the language associated with a collection of graphs  , they do not seem as relevant as contextfree models for our purposes  . The reason is that the source packed representations are typically obtained as the results of chart-parsing processes  . A chart used in the parsing of a context-fi'e e grammar can itself be viewed as a contextfree grammar  , which is a specialization of the original granllllarl ' or the string being parsed  , and which directly generate stim deriwltion trees for this string relative to the ott  , q , ," "' o' . a L grammar ( Billot and Lang , 1989) .   1 The generalization of this approach to uni -tication grammars  ( ot ' the LFG or DCG type ) proposed in ( Dymemmn , 1997) shows that , in tt , rn , chart-parsing with these unilication grammars conducts naturally to packed representations for the parse results very close to the ones we are about to introduce  . 
Let's consider the CFG Go:
S ~ SAW()r ~ W nltD3
Saw-9I ) 0 a.'gl01i,arg2 o:~Lt < irr
Lit ; in ' --4" O~H ~ nI nod 27 light 2
Gi~lit~N--+gr cell l7\[green 27
O~-9 on 3 arg 23 a hill 4
W . ll-9 with5 a/g256 telcs cope ~ i1)0-9 seco\]sawo
I ) 3-9 modo 3 D30\[mod . 2 aI ) 32
D30-4 modo5\]mod4 ~
D32-9 modo5\]mod.2 ~\] mod4 ~
Nontenninals of that grammar arc written in uppercase  , terminals ( which are graph description elements ) in lower case . It can be verified that the language generated by this grammar is the collection of commutative words I This contextfree grammar has polynomial size relative to the length of the string  . While it is also possible in principle to use a linite-stale model for representing lhesallle sel of derivation trees  , it can be showl I halsuch at model may be exponential relative to string length  ( remark due to John Maxwell )  . 
1 017 corresponding precisely to all the possible analyses for the sentence  . 
The fact that there are 20 such words can be established by a simple bottom -up computation ivolving multiplications and sums  . I 1' we call ambiguity degree ad ( N ) of a nonterminal N timnt unber of words it generates  , then it is obvious that , for instance , ad(D30) = 2 , ad(D3) = 2+3 , ad(S ) = 4 . 1 . 1-5 = 20 . In fact , it is the multiplications which appear in such computations which are responsible for the compactness of the grammar as compared to the direct listing of the words : each time a multiplication appears  , a factorization is being cashed in .   2   3 Transfer as language rewriting When working with non-ambiguous structures  , transfer is a rewriting process which takes as input a source-language graph and constructs a target-language raph by applying transferules of the formlhs  --4 rhs , where lhs and rhs are finite sets of description elements for source graph and target graph respectively  . In outline , the " non-ambiguous " transfer process works in the Mlowing way : for each non overlapping covering of the source graph with lefthand sides of transferules  , the corresponding righthand sides are produced and taken togethere present a target graph  ( this is a nondeterministic ftmction as there can be several such coverings  )  . 
In the case of ambigt , ous structures , the aim of transfer is to take as input a language of source graphs and to produce a language of target graphs  . The language of target graph should be equal to the union of all the graphs that would have obtained if one had enumerated one-by-one the source graphs  , applied non-ambiguous transfer , and taken the collection of all target graphs obtained  . The goal of ambiguous transfer is to perform the same task on the basis  o1' a compact representation for the collection of source graphs  , yielding a compact representation for the collection of target graphs  . 
For illustratkm purposes , we will consider the following collection of transferules : see o--+voit b  , sawo-+sciero , gl " eenl7 - - + Vel 17 , green 27-+ gazon T , light 2 , rood 27 , green l7--+ lcu2 , rood ' 27 , vcrlT , light2 - - + lumi & e2 , etc . 
We have only listed a few rules , and have assumed that the remaining ones are straighlorward one-to-one correspondences  ( 11 --+ jet , medea-+mod'o3\[weprime labels such as mod , argl . . . . in order to have disjointness of source and target vocabulary \]  , etc . ))2 As the example shows , conlexl-flee representations of ambiguous slructures have the important properly  ( related to their inte , ' a clion-freeness as described in the i , ~troduction ) of being easily " countable " . 
This is to be contrasted with other possible representations for ambigu-ous structures  , uchasones based on propositional xioms determining which desc  , ' iption elemenls can be jointly p , esent in a given analysis . 
In these representations , the problem of determining whether there exists one structure satisfying the specification can be of high complexity  , let alne the problem of counting such structures . 
3In practice , real transfer rules are not specialized lbr specific nodes  , but are panerns containing variables instead of imlnbers  ; in order to oh-4 Formal aspects The cotn mutative monoid over an alphabet A is denoted by C  ( ~* )  , and its words are represented by vectors of NA , indexed by . .4 and with entries ill N . For each wENA , the c(mlponent indexed by a C . .4 is denoted by w \[ , \] and tells how many a's occur in w . The product ( concatenation ) of wl and ' w2 in C ( . A *) is the vector wENAs . t . VetCA:w\[,\]=wl\[,\]+"w2\[,1 . A language of the commutative monoid is a subset of C  ( A* )  . 
The subword relation is denoted by --< . For a language L , we write : v --< L iff there exists wELs . t . v-<w . 
The rewriting is performed from as our cc language ?s over an alphabet Es to a target  language/27  , over a nal-Es ) w . r . t , aphabet ET ( disjoint fi'om set of rewriting rules 7~ CP , s+xP'T*(rules have the form A-+p ) . We assume in the sequel that any a GES appears at most once in any left hand side of each rule of " R  . and also at most once in any word of ? s . This property is preserved by all the rewritings that we are going to in t  , 'oduce . 
Let's deline LItS(A-+p ) = A . For RC ~ . , we define L . , ~&,( R ) = aEP's'\[3 re17, s . t . et-e,LHS(,') . 
Tim rewriting is al ' unction qSre . taking ?, 9 and yielding
L ; T , delined as: ,  /  , ~(? s ) = mp ,   , I ~ , , ~ ? s . , ~ , , =, x ~ . . . %,/~ kl--~'pl G"J ~ A . . . AAp'-q , flpG " R . .
5 Algorithm
In order to implement he function ( ) n , it is useful to introduce rewriting functions q~- - + t  , and q~?r . They apply to any language L over C(E *) , where E = Es , tOET . 
They are detined as : ~ x-+,,(r ) = m " I awCL
O~(L ) = wcLI~v\[.1 = 0.
The ~ x-~p functions are applied so that source symbols are guaranteed to be removed one by one from ?  . s ': we consider E . s ' is totally ordered by < and we write E . 5'=\[(/,1, a2, . . . , aN \] , with ai < eti + l ; then consider the partition of 7~ . : 7Zl , J ~2 . . . . . T~Ns . t . R . 1 contains all ~ . 
rules with al in LHS , " R . 2 contains all 7? rules with a 9but notal in LHS , etc , " R . N contains all 7Z rules with only a N in LHS . Then we deline a third rewriting function q ' ) 7? ~ : ~ l , , e , (L ) = qSv(L)UU ,  . eT ~, 4, . (c) . 
Lemma . ?7' can be obtained l ; ' om?s by applying the T ~ i iteratively in the following manner : ~ b ~/ ~ N  ( (/ ) ' ~ N - - I ( '" " J ) '\]  ~ l ( CS )  ?" " ) ) = j ~'\]'" PROOF SKETCII . For 1_< j < N , we deline ?' J = pl ''' ppx\]~*tJEJ ~ . S,zEES *, p > O , w = At ' " . Apa ;, Vk < pAk-4Ph . GOi <_jT ~ i,Vi ~ jetiT ~ Z . 
It is cleat " that ? N = ? T-Furthermore , we have L ; 1=(/)'\]~1(?S ) , and it is easy to show that , for 2_ . 5_n < N , ? n = ()'1?,~(/3, z-~) . From this we have immediately CN=~,~,(~,~_,( . . "~'~1 ( Cs )- .   . )) = Or . 
In order to obtain ? r , we will start from ? . s ' and actually apply the ~ bTa ~' s not on languages directly but on raing  , ' otmd , rules , as the ones we are considering , a simple preproces , sing , step is necessary . 
1018 timgrm nnmrs that deline them . Tiffs computation is performed by the algorithm that we now present  . 
Let/2~ , be detined by the CFG Go = ()2 , Ale , 7) o , So ) . 
For AGiV'o , these to 1' all rules having A as I . HS is notated A-->~A-~a . < ; %  ( t-This additive notation is a for-111111 represenlion of A-~cqI ct2  \]  . . . ltcnce A-+0 means that no rule delines A . 
First () 7, ' . 1 is@plied on Go , which builds G1 = (~ l , Af : I ,  791 ,   , 91 ) , Ihen ?-~= is applied on G1 to produce G: , and so forth . Each time , new nonterminals are introduced : of the form ( A ) -~ , , ( A) , x-4 oor(A)~r , where A~N'i-~ , AGNs + , pENT * , and a GS , s . Each one is defined by a formal sum as we saw above  . 
The order of symbols in the RHSs of gramma rules is irrelevant since we consider commutative languages  . 
Hence the RHSs ot'grammarrt , les can be denoted by : c/3s . t . x ~ C(~*) and /':/ EC(N'*) , where iV " is the set o1' all nonterminals considered . 
The algorithm consists of the procedure and functions described below and uses an agenda which contains Dewi ~ on-terminals to be defined in Gi  . The agenda is handled with a table : each hen -terminal is treated once  . 
procedure main is for iG1 , ..., N do
Initialize 79 i with 79i_~; if " R , i #0 then Initialize Agenda with ( Si_1) 7 , LI ; repeat remove NonTerml ' ron~Agenda ; case NonTerm is when ( A ) 7 , , , ~: add to 79 i when ( A ) x4 t , : add to " l~i(A)x-~ . ~ ~ . .~->, . :7 , ,  ,   , l~x-+~ , ( , ~); when ( A ) , : add to " Pi end case ; until Agenda is empty Reduce Gi whose axiom is Si  =   ( Si - ~ ) n  ~ ; /: t : I ' ClllOVC nonterminals that are non -praductive  ( ?  ( A )  = ~ ) or in accessihle fi'om Si . */ endfor ; end procedure ; flmction R '7 , ' , ( x4) is // fl = At .   .   . A k if ~ j ~ 1, . . . , ks . t . VaEL, . ,,&,('R . i ), a-<?(Aj ) // if all rewritings in " R . ic an only q/ . '/ bctA . 4 then add ( Aj ) vv . ito Agenda ; retnrn xAI "?" Aj-1(Aj ) vz ~ Aj+I ? ? . A ~; el , ; e return , ~( a'f l ) + y ~ , , . ~x . , ~,, . ( a'/~); end function ; (1) (2) flmction'I , ~( xfl ) is // fl = At- . -A~ . 
if ~ j < J , . . . , a : s . t . a -< Z ; (&) then /* j is unique , see below*/add(Aj ) ~ t()Agenda ; return : rA~- . " Aj-1(Aj ) ~ rAj+1- . .A ~ . ; (3) el , ;e if a-qx then return O ; else return x f l ; end fimction ; flmction ff'X-+p(a ; fl)i~/fl = A1 .   .   . Ak // A is seamhed within a : AI .  ?  . - 4k if ~ j < 1, . . . , ks . t . Va-<k , a-<12 ( Aj ) ~ ~ if Afalls // entirely within ? ( Aj ) then the rewriting applies only to A . i then add ( Aj ) > ,--,, p to Agenda ; return xA ~ .   . " Aj-1(Aj ) ,   ,   , ~ oAj+I?--Ak ; (4) else // A is searched wilh in several symboL v
Consider A = y , waw . 2.."Wk s.t.
-the longest common subwordot'x and ~ is y , -- V(t-d , Wj , ( t . . . ~? ( Aj ) // wj is Aj contribution to A if such decomposition of A exists // that is  , it is // entirely covered by x and some Aj's then /* it is mffque : see below */ add to Agenda all  ( Aj ) wj---~S . I . Wj~e;l/all those that contribute , - et , ,,-,, . , . /: j(FI , , , ~#~(Aj ) , ~ , -~) ( Fiw , = , A ;)/ , ; ( 5 )   //77te rewriting is actually cqq died : y is deleted . fioma : ; // each contributing ( i . e . none ) wj is to be deleted //( i . e . rewritten to eit , Aj ) ; non-contributing Aj's//J vntaintm toudted ; at tdp is inserted . 
else // A cannot be pJvd tu'ed by xfl return O ; ~ ~ NoJv writing is ~ q q dicable endfnnctlon ; Unicity of j in f f h r , and unicity of the sequence in ff , ) , + p:consider A-~a : XY 7C79i-1 ; as each source symbol occurs at most once in every word of ?  ( Si-1 )   , the same holds for /_2 ( A ) hence the sets of source symbols occurring in ? ( X ) an 0? ( Y ) are disioint . 
6 Example
Consider ~2 , s , =\[ i ~ , green It , grccn 27 , seed . . . . \[ so that " R . 
is partitioned in ~ . 1=ij ~ jel,"R . 2 = green 17-+ VCl't 7, grccnlrmod . 27 light2-~lbu2 rood 27 verl 7, etc . Each other " R . i contains a single rule . 
The lirst iteration of the algorithm computes the grammar Gt = ff " R  . , ( Go ) . The resuh is : ( So ) ? , h-+(S , xw ) ? q()NW in ,  1)3 , ( SAW ) ' p ~ , --+ DO at glolar , g2o2L ~ , ,r ,  . icl , gKillrl "---) " Orl !, ~ Nmod 27\]ight2,
GR li I:N-+gmen 17Igm cn2r,
On--~onamg2a4hill4,
Wr,~-+with ~, ar.g256 tcles cop ca , etc.
We see that the only nonterminals which have been redefined are  , 5' =  , 5' o and Saw . The computation of ( , 5' o ) ~ has been done through step ( I ) in the algorithm . This is because the terminals in lefb handskies of  77q   , nm nely the single terminal i ~ , are all " concentrated " on the single nonterminal Saw on the right hand side of St  . This leads in turn to a requirement for a definition of  ( Saw ) hi , which is fulfilled by step (5) in the algorithm , at which time the rewriting of il into jel is performed  . 
For any group of rules " R . i , as long as all terminals in the lefthand sides of rules ol " R  . i a , ' ethus concentrated on at most one nonterminal in a right hand side  , no expansion of rules is necessary . It is only when the terminals start to be distributed on several RHS terminals or nonterminals that an expansion is required  . 
This situatien is illustrated by the second iteration which maps  G1 into ( 7 ,  2 =  , I , ~ , , . e((71) . The result is: ( ( SAw ) ~q ) g2-+DO argl01 rag202 ( L , ?; , r)r?2j Oh(L , t; , ' r)~2-+(GR , ~ , N ) ~ mod . 2 r light . >, I(G'w . ' ~ N)g , ' ee , , tv -+ , , e , ', 7 mod . 2 r light2,\[(GR , ~, ~ . Je, . ee , ,tr -+ , feu2mo~gr vertr , ( GRI ~ , !N ) ~-+ green 27 ON-+o113 at g2a4 hill 4 , ( Gl~l~N)gmenl 7"-+ vertr-+vertrW , ,H -+ with ~ arg256 telescope6 , ( GlmIN ) green l7-+ e-+e , etc . 
This time , the terminals in lefthand sides of T~2 a regrcen l7  , n lod 27 and light > We first need to compute ( ( S0 ) ~ ) Tz = . Again , our three terminals are all concentrated on ( SAw ) Tz  ~ . We thus only have to definc (( Saw ) Tq)g2 . Once again , the three terminals are concentrated on L , ~; , r , ' , and we have to define ( L  ~ . ,)r?~ . 
At this point , something interesting happens . It is not the case any more that one nonterminal on the right hand side of the rule defining L~H  . r concentrates all our terminals . In fact , G~H  ~ only " touches " grcenlT , but not the other two terminals . The algorithm then has recourse to step (2) , which leads it to dc tine three rules for ( L~?; . ,)r ?= , involving recursive calls to ~ I ' gr ~ o , ,~ ~  , teen lT--f~ett7 , ~ feet ~ ,   , The fi~stg .  ,  . g~lTmod 271 " glt'2--+ feu2 mod27 vertT "" . 
of these calls involves step (3) , the second , step (4) , and the third , step (5) , leading to the three exlmnsions shown for ( L , ?~ . ' r)Tz ~ , and eventually to the definitions for the three variants of the nonterminal GEN  . 
The remaining iterations of the rewriting procedures arc of the same type as the first iteration  . They lead finally to a target grammar of the form : S'-+SAw'ON'W in  ( D3'SAw'-+D0'a tgli1al~2 to2L , m'/jelgIdl rrt -+ aR , ~* ~ dII 10C ~ . 27\]tllli ~ . rc2
IGRHN " I170~27 lumi&'e.2
If ~ lJ2 n\]0 C~27 vert7
Om:N'--+gazon 7Wrm'~aVCC5 argO56hmette6Gm . : I : N "--+ Vel't7 ON'--+ SUI'3   ~11"~'r'~34   colline4   D30'  -+  mo4  . 5 Imo 4 . 5D 3'-+ ,   no4a   D30'  \]  mO4a   D32' DO'-+voiro Isciero D32' - - + mo ~ g ~ I mo4~ I meal45 which is only slightly less compact than the source grammar  . It can be checked that this grammar enumerates 30 target graphs , the difference of 10 with the source grammar being due to the addition of the French variant " feuvert " along with " lumi ~ revcrte " for translating " greenlight "  . 
7 Conclusion
We have presented a model and an algorithm for the transfer of packed linguistic representations based on the view that :  ( 1 ) packed representations are best seen as contextfree grammars over graph description elements  , an approach which permits factorization of common parts while maintaining a transparent  , easily computable , relationship to the set of structures represented  ( interaction-freeness , countability ) 4 , and ( 2 ) transfer is a rewriting process that takes as input such a contextfree representation ad that outputs a target contextfree  4properties that we believe are essential to all such representations  , whether they are mad explicit or not . 
representation which maintains these beneficial proper-tics  . Although proofs have not been provided here , the algorithm can be shown to satisfy our initial formal definition of transfer as nond cterministic  , exhaustive , nonoverlapping replacement of description elements in the source structure by their counterparts as specilied in the rewriting rules  . Tim methodes cribed in this paper bears some obvious analogy to the classical problem of mapping a contextfree language into another context-fi'e e language by way of a finite-state transducer  ( Harrison ,  1978) . It would be an interesting research question to make this analogy formal  , the main difference here being the need to work with a commutative concatenation  , as opposed to the standard non-commutative concatenation which is more directly connected with the automaton view of transductions  . 

Thanks to our colleagues Eric de la Clergerie , Max Copper-man , Andreas Eisele , Martin Emele , Anette Frank , Pierre Isabelle , Ron Kaplan , Martin Kay , Berna ~ zl Lang , John Maxwell and Hadar Shemtov for extended is cussions and comments at various stages in the preparation of this paper  . 

S . Billet and B . Lang .  1989 . The structure of shared forests in ambiguous parsing  . In 27th Meeting of the Association for
Computational Lhlguistics.
J . I ) 6 rre .  1997 . Efficient construction of underspecified semantics under massive ambiguity  . In Prec . ACL , Madrid . 
M . Dymetman .  1997 . Interaction-free grammars , chart-parsing , and the compact representation of ambiguity . In
Prec . I . ICAI , Nagoya.
Martin Emele and Michaell ) or na .  1998 . Ambiguity p , ' eserv-ing machine translation using tracked representations  . In Proceedings of Coling-ACL'98 , pages 365-371 , Montreal , 

Anette Frank .  1999 . From parallel grammar development towards machine translation  . In Proceedings of MT Summit VII . MT hl the Great 7) ' anslation Et : a , pages 134-142 , Kent Ridge Digital Labs , Singapore , September . 
Michael A . ltarrison .  1978 . hm-oduction to Formal Lcmguage
Theoty . Addison-Wesley , Reading , MA.
M . Kay , J . M . Gawron , and R Norvig .  1994 . Verbmobiha translation system for face to fitce dialog  . CSLI . 
Martin Kay .  1999 . Chart translation . In Proceedings of MT Summit VII . MT in the Great 7) ' anslation Era , pages 914 , Kent Ridge Digital Labs , Singapore , September John Maxwell and Ronald Kaplan .  1991 . A method for disjunctive constraint satisfaction . In Masaru Tomita , editor , Current Issues in Pat Mng Technology . Kluwer , Dordrecht . 
John T . Maxwell and Ronald M . Kaplan .  1993 . T be interface between phrasal and functional constraints  . Computational Linguistics ,  19(4):571-590 , l ) e cember . 
John T . Maxwell and Ronald M . Kaplan.
1996 . An efficient parser for LFG . In IO ' twt LFG Colference , Grenoble , France , August . 
http://www-csli . stanford , edu/user/mutt / . 
M . Rayner and P . Bouillon .  1995 . Hybrid Transfer in an English-French Spoken Language Translator In Proceedings of lA  '95  , Montpellim , France , Jtme . 
H . Shemtov .  1997 . Ambiguity Management hz Natural Language Generation  . Ph . D . thesis , Stanford . 

