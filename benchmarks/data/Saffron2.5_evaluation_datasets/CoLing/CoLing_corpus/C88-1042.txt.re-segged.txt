All Active Bilingual Lexicon for Macldne Translation 
lgal GOLAN , Shalom I . APPIN *, MoriRIMON
IBM Israel Scientific Center,
The Technion City , llaif a 32000, Israel
(*) Main affiliation : The University of tlaif a
Email address : golan and/or lappin and/or rimon@ israearn  . bitnet

An approach totile Transfer phase of a Machine Translation system is presented  , where the bilingual lexicon plays an active role , guiding Transfer by means of executable descriptions of word senses  . The means for lexical sense specification are , however , general enough and can in principle apply to other system arthitectures  , e . g . in tile Generation phase if Transfer is intentionally kept minimal  . The active lexicon is the one and only systea ~ component which is exposed to users and can serve to linguistically control Transfer effects  . A unified approach to lexicon creation and maintenance is proposed  , which contains means to gradually refine sense specification and tailor the definitions to specific text domains  . The underlying linguistic principles , the nature of sense distinction required to t translation  , and tilt : formal structure of the lexicon are discussed  . 
I?httroduction
While melbods of monolingual Analysis and Generation are also treated in other contexts  , bilingual Transfer problems are hardly in w ~stigated outside the context of Machine Translation  . 
Research in Machine Translation can , in this case , make a specific contribution to Computation all , inguistics . The general issue here is tire formal representation f phrase structures and lexical units and the methodology for specifying transf -ormations between these representations in two  ( or more ) languages . The role of tile bilingual lexicon in the Transfer activity  , at tdits power to assist in the resolution of mapping problems  , is a key element . 
In tillspaper we present an approach to the formal representation of bilingual exical knowledge and to the way this knowledge is incorporated into the translation process  . In section 2 we describe the role and place of the bilingual lexicon in the translation process  , present the concept of executable descriptions of word senses as lexical definitions  , and discuss some aspects of practical usage . Our approach to the sense distinction required for translation  , which is different from monolingual sense distinction  , is discussed in section 3 . In section 4 we make a few methodological comments , arguing that wha ! is often portrayed as the ideal Transfer-based architecture  , is not the only , and not necessarily the best way to achieve modularity and savework  . Section 5 contains a formal definition of the lexicon specification language with some discussion of its features and the intended restrictions on the power given to the lexicographer  . Finally , an additional example is given in detail in section  6  . 
This work has been carried out as part of the MENTOR project  , where several groups in European IBM Scientific Centers are collaborating on M  ( A ) T research . The approach presented here has been developed and prototyped by the group in Ilaifa  , Israel , as part of the proposal fortire design of Transfer-related operations  . The examples below involve translations from English into Ilebrew  . 
We thank our colleagues Danit Ben-Ari , Esther Bentur and Maria Vilkuna for their contributions and comments  . 
2 . " lhe Role and Content of the Bilingt , alLexicon\[Cullingford 87\] describes an MT system which is purely lexicon driven  . Ills system follows the Conceptual Processing model  , and is not Transfer-based , hence the emphasis there is on deep Analysis and Generation  . Many other systems distinguish between I . exical Transfer and Structural Transfer , but they take different approaches to the actual separation of these two subprocesses  . In the work reported here , an attempt was made to strictly separate lexicon -driven selection of target language equivalents from the global mapping of syntactic structures in the SIA into those of tile'I'I ~  ( cf . \[Biewer85\]) . ' lhe lexicon lookup phase , which takes place before phrase structure transformations  , gets as its input the internal data representation provided by the SL parser  ( PEG\[Jensen86\] , in outprototype ) . The terminal nodes ( leaves of a parse tree ) are searched in a predefined order for certain parts of speech  . 
For each word in turn a target equivalent is selected from the bilingua lexicon and attached to the corresponding node in the parse  . Features may also be added to other affected nodes  . 
flowever , no structural modifications are made . Structural transformations are carried out as an independent subprocess  , upon completion of tire bilingua lexical phase , and are not discussed in this paper . 
Since in many cases , and ill fact for most verbs , several alternative translations exist , tile selection is done by texical differentiation rules  . These rules refer to the syntactic environment of tile word in the parse tree and to a limited number of semantic features  . The rules can access any node and attribute identified by the parser  . Given that the rules are stated in terms of the SL phrase structure  , it seems more natural to apply them as close to Analysis as possible  . Nevertheless , the sense distinction cannot be done as part of SL Analysis itself  , as in many cases it depends on factors which may vary from one TL to another  . 
The subprocess of bilingual lexical substitution proceeds uni-directionally  . No iterations take place for any given phrase . In some cases this may require extensive searching of ' the phrase The fill lowing abbreviation ~ are u ~ ed throughouthi ~ pal ~ er : SL=:Source Language  , BL = Bi Lingual , TL = Target Language tiation rules . 
The differentiation rules which comprise an entry in the bilingual lexicon are stated in a special language  , and are directly executable by a set of functions  ( LISP , in our implementation ) . Although the phrase attributes and features they can refer to are similar  , to some extent , to what is done in certain other systems ( see for example\[Nagao86\] )  , it seems that action rules are more-flexible and powerful than static form-oriented structures  . In fact , each statement in the set of rules which comprises a given lexical entry defines a correspondence between a syntactic environment  ( with semantic decoration ) in the source language and a translation into the target language  . 
Consider , for example , one of the four rules which comprise the entry for the verb " avoid " in the English-ilebrew lexicon  . 
This particula rule identifies the case where the current verb node  ( CN ) has a postmodifier noun phrase and the head noun of that noun phrase has the semantic attribute Animate  ( e . g . 
" She avoids her old father . ") . In that case the Hebrew translation should be " r  ~   pr3rEn  ~" . In terms of the lexicon specification language and the attributes used by the PEG parser  , the rule looks as follows : If ( CN hasPost brother ( ( CAT NP ) (ANIMATE + ) )  ) 
Then < Put(HEB " 13 p~nnn "); >;
The put instruction attaches the tlebrew translation as a feature on the current node  ( CN is the default node assumed when no explicit node name is specified for put  )  . 
Certain lexical rules can be simply and elegantly formulated in terms of functions which identify grammatical relations of various kinds  . Thus , for example , the rule for translating the verb " return " can be specified in terms of the feature Passive  , and the presence or absence of a direct object . The set of rules which follows makes the required is tinction between the ergative  ( intransitive ) sense and the transitive reading of the verb :
Start RETURN VERB1 If ( call OBJECT ) Then < Put ( HEB " " l~t l ' l , " l "); end ;>;@ Example : Ron returned the book . 
@ Example : The book was returned.
2 Put(ItEB "' tin ") ;  @  ( this is the defaul translation ) @ Example : Ron returned early . 

Ideally , the feature OBJECT could be defined as part of the information provided by the parser  . However , if for some reason the parser does not identify such relations  , it can be defined as a function , written in the lexicon specification language described in this paper  , which will evaluate the parse tree during Transfer  . An example of such a function , which is included as a utility function in the active bilingual lexicon system  , is given in \[ Golan88\] , an extended version of this paper . This function tests a tree for the presence of a constit-uent which is the direct object of a given verb  . If the verb appears in the passive voice , it assumes existence of a direct object ( note that the active voice is selected for the ltebrew equivalent even in the passive case  ; passivization is done later in Generation ) . 
It may be necessary to define functions which identify more complex grammatical relations than the direct object of a given verb  . It is , for example , necessary to refer to the relation'head noun argument  , with property P , of an adjective ' , when formulating the rule for an adjective like " available ": 
Start AVAIL ABLE ADJ
If ( Call N-of-ADJ ( HUMAN))
Then < Put(ItEB"~I ~") ; >@ Example : The doctor is not available now . 
@ Example : Any available sales person can help you . 
Else < Put(HEB " ~ l~lr3") ;  >  ; @ Example : This book is available in every store . 

The algorithm N-of-AD . I , given in detail in section 6 below , characterizes a parameterized function which identifies the head noun argument  , with property P , of a given adjective . 
This algorithm is written in the lexicon specification language and is also included as a utility function in the lexicon system  . 
Rules which employ this function can render the translation of an adjective dependent upon the modified noun phrase having specific attributes  . It should also be noted that the function N-of -ADJ identifies the noun when the adjective acts as a pronominal modifier as well as when it appears in the VP predicative form  . 
It is important ore cognize that functions of this kind are useful to the extent hat they can be employed in a significant number of lexical rules  . There are , however , many cases in which the translation rules must be formulated directly as search procedures on trees  . There are no obvious general grammatical functions which can be used to define the syntactic relations that must be tested in order to determine translation in these cases  . Consider , for example , the set of rules for the adverb " precisely ":
Start PRECISELY ADVERB 1 If ( CN has ancestor ( (CAT NP PP ) ) ) 
Then < Put ( IIEB " p ~ , ' l't ") ; end ; >  ; @ Example : This is precisely the question . 
@ Example : Rin a spoke precisely to the point.
2 Put ( tlEB " p ~ rll3a ") ; @ Example : Ronformulated his answer precisely . 

The disjunctive relation of being the descendent of either an NP or a PP does not seem to be the sort of grammatical relation which one would wish to encode in a general grammatical function  . 
Similarly , consider the set of rules below , which are part of the definition of the verb " allow "  . The case where this verb appears in an active voice and forms part of the verb-particle construction " allow for " are identified by searching the tree for the preposition " for " which may be the head of a possibly nonadjacent PP :  1 If ( CN hasFirstPost brother ( name-l ( (CAT PP ) ) has Son name-2C ( CATPREP ) (base " for" ) ) ) )
Then < Put(IlEB"l~a'~nanp ' ~");
Put in name 2 (11 EB "") ; end ;  >  ; @ Example : Ronallowed for the results . 
2If ( CN hasPost brother ( A ( (CAT AVP ) ) has Descendent ( name-l ( (CAT PREP ) (base " FOR " ) ) before B ( (CAT NP ) ) ) ) ) 
Then < Put(HEB " l~a'~nanp ~");
Put in named ( IIEB "") ; end ;  > ; @ Example : Ronallowed reluctantly and cautiously@for the results  . 
In fact , the basic need to look for a no no adjacent particle is rather common  . It may justify inclusion of generalized " postbrother " will enable the statement of the sense distinction above as one rule  . However , the detailed design of such generalized relations is very complex and is not yet included in our model  . 
The " allow for " example presents yet another problem for translation  . The Ilebrew translation " llaton 3 . tlptJ " consists of two words which have individual verb and noun entries in the TL lexicon  . If the target translation is a recognized collocation or idiomit can be specified as such in the TL lexicon  . But there are cases where an SL entry must be rephrased in the ' FL as an adhoc combination of words which does not form a lexical entity  . In that case the lexical rule must mark words with corresponding parts of speech  , or provide alternative information which will serve later in Generation to properly decide on the required morphological manipulation  . 
Generally , our experiments with actual lexical entries lead us to believe that the most efficient strategy for formulating lexical rutes is to use a combination of general functions and rule -specific search procedures  . A formal description of the specification language and a detailed example of its expressive power amgiven in sections  5 and 6 below . 
Ti recreation of a largescale fullfledged BL lexicon is a very heavy tar  ; k , impeding development of product level systems . 
There is no way to avoid it , but there are ways to facilitate the practical development of the lexicon by making the process more modular  . The scheme presented in this paper enables the system lexicographers - and each individual user -to proceed in steps  . As a first , rough , approximation , one may sinr ply define one " defaul translation " ; e . g . , for the verb " type ": Start TYPE VERB Put ( \[IEB"'o ~9" r ~" )  ; Finish This will account for the use of " type " in the sense of " type-write "  . Later , other senses can be defined ( e . g .  ") , ll~ro " , for " classify ") , going from the most frequent in a given context to the relatively rare ones  , thus achieving an increasingly refined level of sense specification  . The optimal level of detail may depend on user needs and on specific text domains  . In fact , different sense distinctions may be required for different domains  . 
The user can modify the lexicon accordingly , or define his/her own private add end a lexicon , overriding identical entries in the main lexicon . 
The lexicon of the system is accessible to revision by users  . 
l-lowevel , users cannot modify the global transformations which map syntactic structures in tile St  . into those of the TL , nor can they interfere with morphological aspects of Generation  ( TL values in the bilingual lexicon are given in a canonical form  ; e . g . for ttebrew verbs : 3rd person-singular-past tense-active voice )  . Consequently , user influence is constrained in such a way that it cannot disrupt the functioning of the large scale architecture of the system  , but can at most affect lo?al changes of a lexically based nature  . 
This is one obvious advantage of the strict separation between bilingual lexical transfer and general phrase structure transf-ormations  . Another benefit of this approach is the restriction of the structures that must be considered for transformations to standard  , non-distorted SL phrase structures , as provided by the SL parser . This eliminates complications and loss of generality of the structural transformations  . Also , from a software engineering perspective , it is clearly advantageous to keep the two subprocesses independent of each other  . 
l lowew ~ r , the extent to which this separation can be maintained is not evident  . In certain cases , e . g . when there is no simple way to preserve tire part of speech in translation  , lexi-con-driven modifications of the phrase structure could facilitate the process  . In such cases , which are fortunately not very common , we will consider attachment of " transformation triggers " to nodes  , based on the bilingual lexicon processing . 
Technically , this can be easily done in our specification for -realism  . The lexical phase itself will not make any changes in phrase structure  , and only one pass of structural transf-ormations will still be required  . 
Indeed , as \[ Mel by 86\] points out , the whole issue of lexical transfer and in particular the effect lexical transfer has on the overall quality of translation deserves further study  . 
3 . Sense Distinction Characteristics The highest level of distinction in the bilingual lexicon is the part of speech  . Within each part of speech one may distinguish different senses  ( and specify lexical rules ) as required in light of TL sense distinctions . According to one initially plausible view , it is possible to make use of the subcategorization information present in standard monoliugual dictionaries to obtain the necessary syntactic information for disambiguating dif -tcrent senses of words in the SL  . In fact , we have found this view to be untenable . Thus , for example , among the 13 senses that \[ l . ongman 78\] distinguishes for the verb " hold " , many are mapped to the ltebrew verb " p ~ trl , -l " , even when they belong to diffelent syntactic categories as defined in l  . ongmans system . On the other hand , consider the different uses of " hold " in the following sample sentences : - She is holding tile baby-We held our breath in fear 
We were holding a meeting
Although l . ong man makes a distinction between the three senses  ( cases 1 , 3 , and 13 , respectively ) , all of them are classi--tied as TI verbs according to Longman's coding system  , which is the only feasible instrument for cornputer reference  , h-tllebrew , different w . q bs nmst be used (" p ~ t lnW , "' 1 t1 ~" , " t3 ~ rF ) " , respectively ) . Moreover , even under the same sense (10) , tw ~ sample sentences are given , which in ltebrew require differ c ~ lt verbs :
What he said still holds ( " qprr ' ) -Can the good weather hold '? ( "' l ~ N r3n " ) As a second example of the inadequacy of standard monolingual subcategorization  , consider l . ongman's class of T3 verbs . -verbs which take infintival complements with " to " and NP objects  . E . g . : want Rontowinask Rontoleavetell Ronto comel lowever  , each of the corresponding \[ lebrew verbs has a dis  . 
tinct sube a tegorization frame : -" lnSll~l~l ~ n~2tl  ?  ( want that R on will w in ) -": a~tg~\]Ytt3~p:at3" ( ask from R onto leave ) -" R~ttt ~ lrtt ~ lrJlR " ( tell to Ronto come ) 
Note that the form - . " a ~ ty , I 13~9 ~ par 3" ( ask that R on will leave ) is also valid ill I lebrew , but as a translation of " ask that Ronleaves " rather than " askR onto leave "  . Therefore , Transfel and not Generation seems to us the natural place to decide on the appropriate form  . 

These , examples illustrate the lack of isomorphism between subcategorization patterns for specific verbs in English and their counterparts in Hebrew  . It is reasonable to expect that , generally , subcategorization is not invariant under translation between most SL-TL pairs  ( cf e . g . \[ Warwick 87\]) . As\[Nagao86\]points out , " it is not exceptional , but rather usual , that a verb of SL has to be translated into different target lexical items  , even though the native speakers of SL cannot clearly realize the meaning difference "  . Consequently , we have found it useful to construct algorithms which map lexical items  , considering subcategorization properties and sense distinctions of both SL and TL  . This is especially useful for verbs , but the same specification formalism is used for all other lexical categories  , making use of syntactic information in different ways  . 
We anticipate that the construction of a large scale lexicon will be facilitated by the existence in the SL of subclasses of items  , in each lexical category , which have identical or highly similar subcategorization frames  , and which correspond to items in the TL with similar frames  . The entries for the elements of such subclasses can be handled by algorithms whose statements have more or less the same selection conditions  . 
In constructing the BL lexicon of our system we have followed a lexicalist view of syntax  . In particular , our view of the interaction of the syntactic omponent and the lexicon in Transfer is inspired by the projection principle \[ Chomsky  1981\]  . This principle states that the syntactic structure of a phrase  ( at any level of representation ) !s a projection of the argument structure imposed by the lexical entry of the head of the phrase  . 
Mapping of a lexical item in the SL onto a counterpart in the TL depends upon a matching of the subcategorization frames of the two items  . This matching requires recognition of an SL item in a tree as the head of a subphrase which satisfies the argument structure specified by the antecedent conditions of one of the statements in its lexical entry  . Translation of any subclause begins with its head  , as this determines the argument structure of the clause  . 
It is necessary to qualify this characterization f our approach in an important respect  . Although our algorithms are stated primarily in terms of the syntactic information provided by the parser  , we have found it necessary to supplement this information with a restricted list Of general semantic features  . For example , consider the verb " run " . On its intransitive use , it translates in tollebre was " p ~" , while its transitive use corresponds to the ttebrew causative verb " ~  , "1" . l lowever , intransitive " run " allows certain NP adverb complements  , as in " runamile " . To identify these NPs as adverbial phrases and so preserve the intransitive sense of " run "  , we attach attributes Time or Distance to the entries of nouns like " time " and " mile " in the SL lexicon  . The algorithm for " run " can then recognize it as having its intransitive sense when it takes only one complement and the head N of this NP contains one of these attributes  . Features such as 1luman/Non-human , Concrete/Abstract , etc . , and a small number of domain specific features ( e . g . hardware device , software component , state , etc . , for the domain of computer manuals ) are also included . 
There is yet another kind of feature marker that we include in the SL lexicon  , and which we call " list marker " . These markers assist disambiguation in cases where a few nouns can be grouped together  , usually for computational efficiency , although their common denominator has no obvious name  . 
For example , in the sense distinction for the verb " assume " , if the complement is an NP with a noun in the set \[ office  , chair-manship , position ,  . . . \] , then the ttebrew verb-equivalent is different from other subcases of " assume "  . We give this group of nouns a name and mark the nouns in the group accordingly  . Then one can refer to this name as a feature . Indeed , nouns in such groups have semantic similarities , and in principle , they are equivalent to traditional semantic markers  . The point is that list markers can be formed in an adhoc fashion  , without worrying about the generality of the group  , or finding an appropriate label for it . 
The different mechanisms presented above provide , in fact , various levels of characterization of the relation between a given verb and a noun  ( or an NP ) to which it refers : subcategorization requirement for the very existence of a noun  ( NP ) in a given position ( e . g . as a direct object ) ; a more constricting requi~ement for the existence of a noun with specified semantic features  ( defined as such , or by means of lists , in the SL lexicon ) ; and a particula requirement for the existence of a specific noun  ( or group of nouns )  . 
The sense distinction for multi-sense nouns ( homonyms and polysemes ) and other parts of speech is done according to basically the same strategy which we use for verbs  ; namely application of context-sensitive differentiating rules  . Generally , nouns and adjectives are less ambiguous for translation  , but the ambiguity , when it exists , is more difficult to resolve at the sentence level without extensive semantic and pragmatic knowledge  . Still , many cases can be resolved by rules of the kind shown above  . For example , although nouns , unlike most verbs , do not require complement structures , disambiguation in the source language can sometimes be facilitated by rules which refer to the presence of optional N complements  . Consider , for example , the noun " statement " . When it has a ' that'S'complement ( " a statement that R in a has been promoted " ) it translates tollebrew "~9~ra ~" when it occurs with a PP complement headed by " of " with an NP object headed by an inanimate noun  ( " statement of the theory " )  , it translates to " tq ~ X g ~ : l " . 
When sense distinction cannot be expressed in terms of our system  ( e . g . for the homonymous noun " bank ") , we specify only the more common sense in the given text domain  . In the future , we may mark such cases so that the information about the lexical ambiguity can be made available to an interactive disambiguation module  . 
For adjectives , the characterization is done in most cases by reference to semantic features of the noun  ( s ) they modify . In some cases different ranslations will be required for an adjective when it appears as a prenominal modifier or in the VP predicative form :- Myold friend is not old " lpt  '0~R   ~9~9 p ~ ln "1:lrlW The syntactic distinction between the two forms of " old "  , and the selection of the different\[lebrew equivalents  ( " IPt " , " p ~ rn ') , are easy to specify in our formalism ( cf . the definition of N-of-ADJ in section 6 below ) . 
4. Some Methodological Aspects
From the discussion and examples above , it is apparent hatour lexicon specifies bilingual information in great detail  . This may seem to conflict with certain modern approaches to Transfer methodology  , where the guiding view is " small ( and simple ) is beautiful " . \[ lsabelle86\] , \[Arnold87\] , and others , advocate an approach where the BL lexicon states only facts like : or "  n9~9" in Ilebrew , when the verb takes a sentential object ) know->kennen ( ill German ; or " conaitre " in French ; or "'1~3 , '19" intlebrew , when the verb takes a nominal object ) The selection of the correct translation is then done in the Generation t/hase  , based on restrictions on tile target language . 
We claim that this approach is problematic for the following reasons  . 
First , the " know " example , although widely quoted in the literature , is rather simplistic . Even in the monolingual subcategor-ization for " know " in\[Longman  78\]  , there are 15 different frames , re : my of which require a different verb , or verb form , use of a preposition , or even a completely different syntactic structure in Ilebrew  . Ill addition , there are verb-particle and other collocations which would be quite difficult  ( and unna-tural ) to handle if decisions were postponed to the monolingual Generation  ( " know of " , " know better " , " knowX to be Y " , are some examples which hold not only for 1 lebrew )  . It is not single words but patterns and structures that must be handled sirnuitaneously  . 
Second , one should note that the mechanism presented in this paper may also  , ill principle , be applied to Generation rather than Trans Dr ; the conditions will then be stated in terms of tile target language  . By the same token , certain differentiating rules may be also applied as part of Analysis  ( or post-Ana-lysis )  , t lowever , we feel that the right place for this kind of processing is in Transfer  . At least when the target and source languages are linguistically renlote  ( as , for example , in the case of English and llehrew ) , severely restricting the scope of BL operatimls may result in loss of information vital for translation on the way to Generation  ; e . g . dependence on tense or voice , when tile structural expressions of these properties are differentirt the SL and TL  . Alternatively , such information could be carried forward to Generation  , but then Generation loses its primarily monolingual nature  . 
Allowing Transfer to pass forward alternative translations for SI~lexical entries  , may result in a large number of possible sentence t ~ anslations which must be handled by Generation  . 
Even if conceptually viable , this strategy is computationally highly unattractive  . A similar comment is often made in other contexts  ( e . g . Analysis-cf . \[Stallard 87\]) . 
Finally , it ~& ould been lphasized that keeping Transfer small is not  , in itself , the crucial issue . More important , it seems to us , is the isolation of bilingual considerations .   ( Isolation should not be mistaken for serialization of SI  , -BL-TL operations , which is not at all required . Ideally , isolated modules could even work in parallel , as suggested by \[ Isabelle 86\]) . In fact , trying to minimize bilingual Transfer at any cost may yield unnecessarily complex Generation and/or Analysis  , which are forced to handle problems that are not inherently within their scope  . If , for example , Generation has to consider patterns that were . nly created by phenomena illa certain source language but were not fully resolved in Transfer  , then minimizing Transfer represents no real gain in nmdularity or language independence  . Nor does it save lexicographic effort , as in any case , the linguistic classification and judgement process re  , nainsb : ~ . sically tile same , even if shifted to other system components . 
A remark is in order concerning multi-target generality  . In principle , it is technically possible to add tags attile put statement  , along with the ItEB tag , to define multilingual translations ( cf . e . g . Boitetg6\]) . l lowever , from our discussion of ttredifference between monolingual subcategorization patterns and the sense distinctions needed for translation  , it follows that the algorithms in the lexicon must be further refined in order to cove  , " all subsenses needed for a set of given target languages  . For any one language in the set , many of the differentiating rules will be redundant  ( see " voirtradn " definitions in \[ Boitet86\] )  . In practice , it would be better to construct distinct variants of the lexicon for different arget languages  . This need not significantly increase the lexicographic work required  , as it is possible to use an existing lexicon as the basis for constructing new variants  . The linguistic reevaluation of senses is required anyway  . What is important is that all target languages use the same structure and formalism  . 
5 . The Specification Language \[ Slocum 87\] claims ( correctly , ill our view ) that " lexical entries for computer use tend to be\[ormally stated  , compact , and thus cryptically encoded " . While the formal style is inevitable , we have tried to avoid compactness and cryptical expression by allowing the lexicographer to state the lexical facts and the effects they have on processing in terms that are directly related to the logic of the linguistic process  . Therefore , tile set of available instructions i rather simple and intuitive  . We have tried to allow enough expressive power to support a variety of requirenlents for bilingual lexical mapping  , while restricting the scope of operations as much as possible  , to reduce complexity and avoid undesired side effects on other entries or suh systems  . We have also emphasized ease of maintenance and testing  , and strict isolation of the lexical subsystem from other parts of the translation system  . 
Each entry in tile bilingual lexicon is in fact a mini-program  . 
Although executable declarations may look complicated at first glance  , they have , in our view , many advantages over a rigid data structure . The specification formalism may be less neat and " natural " thant tremetalanguage\[Isabelle  86\] hopes for , but it call be made more " user friendly " through the introduction of higher level abbreviations on top of the basic language  , as required by users . Some functions for abbreviated writing were mentioned in section  :2 above . Other mechanisms ( e . g . 
macros ) can be used to tailor the specification style to individual tastes  . 
The program which comprises a lexical entry is initiated by reference to a lexical item that appears on tile Sl  . parse tree . 
The programternlinates when an end instruction is reached  , or when the last instruction in the program is executed  . A function is terminated by a return instruction . 
The instructions allow the lexicographer to check for the existence of a  ) articular condition or pattern on the parse tree by an appropriate/_f instruction  ; control tile seqnencing of instructions by using ago to instruction  ; and decide on a particular translation for a word by using a put instruction  ( this is not allowed in the case of a function )  . 
The following represent stile current inventory of lexieal operations supported by the specification formalism  . It may be necessary to extend this formalism as more experience is gained with actual lexical entries  . 
The syntax of the specification language is given below  . Bold letters denote nonterminal constructs , normal letters denote terminals ( keywords ) . The notation used is as follows :== a meta -symbol  . \[ term \] I a meta-symbol denoting choice .   ( term ) + nila representation of the null string or list  . ( term )*() <>; terminals . 
program==tart access-key statement+finish statement==\[label:\]instructionuric or no appearance of term  . 
one or more appearances of term.
zero or more appearances of term.
instruction == end ; Igoto ( label ) ; Iput\[inu-name\](allowed-attribute value) ; I call function-name ( parameter-list ) ; I if ( condition ) then < instruction +>\ [ else < instruction +> \]  ; function-name==user-delined-\[unction-name\[ pr-defined-\[unction-name user-defined-function == define user-delined-\[unetion-name In -statement+finishhi-statement==\[label:\] \[ n-instruction fn-instruction==go to  ( label )  ; I return ( true ) ; I return ( false ) ; I call pre-defined-function-name ( parameter-list ) ; I if ( condition ) then <\[ n-instruction +>\ [ else <\[ n - instruction +>\]  ; condition == call fimction-name I simple-pattern \ [ not  ( condition ) L ( condition ) and ( condition ) I ( condition ) or ( condition ) simple-pattern == n-name ( attribute-pair + ) In-name has\[no \] relation pattern pattern -condition==node has\[no \] relation pattern node :=\[ n-name\]  ( attribute-pair + ) In-name relation :=\[ first\]prebrotherI\ [ first\]post brotherI\[first\]soni father I ancestor\[\[last\]prebrother\[\[ last\]post brother\[\[last\]s on I descendent I relative pattern == simple-pattern-condition     ( pattern-condition ) I ( pattern\[not\]before pattern ) I ( pattern\[not\]after pattern ) simple-pattern-condition == node I ( node , ) + node \[ ( node or node )  \]  ( node and node ) u-name==mainIcn\]name parameter-list== niliparameter+attribute-pair ==  ( attribute-name value + ) value == string\[keyI ( value + ) label := I lanleaccess-key==lexical item followed by part of speech  . 
attribute-name==name allowed-attribute==an attribute-name the user is allowed by the system to change  . 
pre-defincd-function-name == a name of a function defined by the system  . 
user-defined-function-name==name name==a string of letters and digits starting with a letter  . 
parameter == a parameter passed to a function.
comment == each line starting with @ is a comment . 

The programs and functions in the dictionary include names for various entities  . The scope of these names is limited as much as possible in order to facilitated ebugging and maintenance  ( e . g . a name of a label or of a particular pattern ( node ) is recognized only within the program in which it appears  )  . 
The user's ability to define variables and names is also intentionally restricted  . There are two special names : MAIN , the name of the root of the parse tree ; and CN ( Current Node ) , the name of the leaf node representing the word for which the program wa :  ; invoked . 
Additional information about the semantics Of names  , a formal definition of the relations between odes  ( e . g . prebrother , first prebrother , descendent , relative , etc . ) and the keywords Before and After , etc . , are provided in \[ Golan 88\] , an extended version of this paper . 
6. An Additional Example
The following is the function N-of-ADJ , introduced in section 2 above , which identifies the head noun argument , with property P , of a given adjective . It is a somewhat simplified version which deals with the major relevant phrase structures  . It is given here mainly to illustrate the expressive power of the specification folmalism as a general tool for pattern matching on parse trees  . 
Define N-of . ADJ@The funclion N-of-ADJ returns a True/False value @ The parameter P refers to a feature that can get+/-values If  ( CN has Ancestor ( A ( ( CAT AJP ) ) has Postbrother
F (( CATNPNOUN)(P +)))
Then < Return ( True ) ;  >  ; @ John is an old and valued friend . 
@ John spoke to many old and valued friends.
If ( CN has Ancestor ( A ( (CAT AJP ) ) has Prebrother F ( (CAT NP NOUN PRON )   ( Wtlnil ) (P + ) ) ) )
Then < Return ( True ); >;@ John is very old , @Mary is very old and tired . 
If ( CN has Ancestor ( A ( ( CAT QUES ) ) has First Son
F (( CATNPPRON ) ( WHl ))))
Then < If ( F (( P +))) Then < Return ( True ); >
Else < Return ( False ) ;  >  ;  >  ; @Who is competent ?@ Who does John expect o seem old ?@ What does John expect o seem old ? 
If ( CN has Ancestor B((CATINFCL )))
Then < If ((( B has Preb rother
F ( ( CAT NP NOUN PRON ) (WH nil ) (P + ) ) ) or ( Bhas Father ( C ( ( CAT AJP ) ) has Prebrother F ( ( CAT NP NOUN PRON ) (WH nil ) (P + ) )  )   )   ) or ( Bhas Father ( C ( ( CAT INFCL ) ) has Prebrother F ( ( CAT NP NOUN PRON ) (WH nil ) (P + ) )  )   )   ) 
Then < Return ( True ) ;  >  ;  >  ; @ John wants to be rich and famous . 
@ Billis certain to be happy.
@Mary wants to seem to be competent and punctual.
5 If ( CN has Ancestor ( A ( ( CAT RELCL ) ) has Prebrother F ( (CAT NOUN ) (P + ) ) ) ) Then < Return ( True )  ;  >  ; 

References \[ Arnold 87\] Doug Arnold and Louis des Tombe : " Basic Theory and Methodology in Eurotra "  , in Machine Translation . "1 fieoretical and Methodological Issues , Sergei Nirenburg ( ed . ),
Cambridge University Press , 1987.
\[Biewer85-1 Axel Biewer , Christian Feneyrol , Johannes Ritzke and Ervin Stegentritt : " ASCOF- A Modular Multilevel System for French-German Translation "  , Computational Linguistics , vol 11 , no . 23, April-September 1985 . 
\[B0it et86\] Christian Boitet and N . Nedobejkine : " Toward Integrated Dictionaries for M  ( a ) T " , Proe . of COLING'86,
Bonn , August 1986.
\ [ Chomsky 81\] Noam Chomsky : Lectures on Government and Binding  , For is Publications , Dordrecht , Holland ,  1981 . 
\[ Culling\[ord87\] Richard E . Cullingford and Boyan A . 
Onyshkevych : " An Experimentation in Lexical -driven Machine Translation "  , in Machine Translation . 712 eoretical nd Methodological Issues , Sergei Nirenburg ( ed . ), Cambridge Uni?versity Press , 1987 . 
\[Golan88\]Igal Golan , Shalom Lappin and Mori Rimon : " An Active Bilingual Lexicon for Machine Translation "  , Technical Report 88 . 242, IBMIsrael Science and Technology , July 1988 . 
\[Isabelle 86\] Pierrel sabelle and Elliott Mack Iovitch : " Transfer and MT Modularity "  , Proc . of COLING'86, Bonn,
August 1986.
\[ Jensen 86\] Karen Jensen : PEG 1986: A Broad-coverage Computational Syntax of English , Technical Report , IBMT . 
J . Watson Research Center , February 1986.
\[Longman 78\] Longman Dictionary of Contemporary Engfish , Longman Group lad . , Harlow and London , England , 1978 (1986 edition ) . 
\[ Melhy86\]Alan K . Melby : " Lexieal Transfer : a Missing Element in Linguistic Theories "  , Proe . of COIANG'86, Bonn,
August 1986.
\[ Nagao 86\] Makato Nagao and Junichi Tsujii : " The Transfer Phase of the Mu Machine Translation System "  , Proc . 
of COLING'86, Bonn , August 1986.
\[ Slocum 87\] Jonathan Slocum and Martha Morgan : " The Role of Dictionaries and Machine-Readable Lxicons in Translation "  , International Lexicon Workshop , Stanford , July-Au-gust 1987 . 
\[Stallard 87\] David Stallard : " The Logical Analysis of Lexical Ambiguity "  , 25th Annual Meeting of the ACL , Stanford , July 1987 \[ Warwick 87\] Susan Warwick : " Automated Lexical Resources in Europe "  , International Lexicon Workshop , Stanford , July-August 1987 . 

