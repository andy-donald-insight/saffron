A Simple Transformation for Oflqine-Parsable Grammars and its 
Termination Properties
Marc Dymetman *
Rank Xerox Research Centre
6, chemin de Maup crtu is
Meylan , 38240 Fra , nce
dyraetman Oxerox , fr
Abstract We present , in easily reproducible terms , a simple transformation for offline-parsable grammars which results in a provably terminating parsing program directly topdown interpretable in Prolog  . The transformation consists in two steps : ( 1 ) removal of empty-productions , followed by : (2) left-recursion elimination . It is related both to left-corner parsing ( where the grammar is compiled , rather than interpreted through a parsing program  , and with the advantage of guaranteed termination in the presence of empty productions  ) and to the Generalized Greibach Normal Form for I ) CGs ( with the advantage of imple-mentation simplicity )  . 
1 Motivation
Definite clause grammars ( DCGs ) are one of the simplest and most widely used unification grammar formalisms  . They represent a direct augmentation of contextfree grammars through the use of  ( term ) unification ( a fact that tends to be masked by their usual presentation based on the programming language Prolog  )  . It is obviously important oask wether certain usual methods and algorithms pertaining to CFGs can be adapted to DCGs  , and this general question informs much of the work concerning I  ) CGs , as well as more complex unification grammar formalisms  ( to cite only a few areas : Earley parsing , LR parsing , left-corner parsing , Greibach Norinall , 'orm) . 
One essential complication when trying to generalize CFG methods to the I  ) CG domain lies in the fact that , whereas the parsing proble in for ClOGs is decidable  , the corresponding problem for DCGs is in general an-decidable  . This can be shown easily as a consequence of the noteworthy fact that any definite clause program can be viewed as a definite clause grammar " on the empty string "  , that is , as a DCG where no terminals other than \[\] are allowed on the right hand sides of rules  . The ~ Itlring-completeness of defnite clanse programs the refbre implies the undecidability of the parsing problem for this snb class of DCGs  , and a for-tiori for DCGs in general .   1 In order to guarantee good * Tha alks to Pierre Isabelle and Frangols Perrault for their comments  , and to C , \[ TI ( Montreal ) for its support during the preparation of this paper  . 
1I ) CGs on I , he empty string might be dismissed as extreme , computation M properties for DCGs , it is then necessary to impose certain restrictions on their form such as o\[fline -parsability  ( OP )  , a nomenclature introduced by Pereira and Warren \[11\]  , who define an OPDCG as a grammar whose contextfree skeleton CFG is not infinitely ambiguous  , and show that OPDCGs lead to a decidable parsing problem  .   2 Our aim in this paper is to propose a simple transformation l bran arbitrary OPDCG putting it into a form which leads to the completeness of the direct topdown interpretation by the standard Prolog interpreter : parsing is guaranteed to enumerate all solutions to the parsing problem and terminate  . Thee . xistence of such a transformation is kuown : in \[1  ,  2\] , we have recently introduced a " Generalized Greibach Normal Form "  ( GGNF ) for DCGs , which leads to termination of topdown interpretation it he OP case  . lIowever , the awdlable presentation of the GGNF transformation is rather complex  ( it involves an algebraic study of the fix points of certain equational systems representing grammars  . ) . Our aim here is to present a related , but much simpler , transformation , which from a theoretical viewpoint performs omewhat less than the GGNF transformation  ( it ; involves some encoding of the initial DCG , which the ( ~ GNF does not , and it only handles of lline-parsable grammars , while the GGNF is defined for arbitrary DCGs ) , a but in practice is extremely easy to implement and displays a comparable behavior when parsing with an OP grammar  . 
3' he transformation consists of two steps : ( 1 ) empty-production elimination and ( 2 ) left-recursion elimination . 
The empty-production elimination Mgorithm is inspired by then snal procedure for contextfree grammars  . But there are some notable differences , due to the fact that removal of empty-productions is in general impossible for non-OPI  ) CGs . The empty-but they are in fact at the core of the of lline-parsability concept  . 
See note 3.
2' l The concept of oflline A ~ arsability ( under a different name ) goes back to \[8\] , where it is shown to be linguistically relevant . 
a The GGNF factorizes an arbitrary DCG into two components : a " unit sub-DCG on the empty string  "  , and another paa't consisting of rules whose right hand side starts with at m'mi-nal  . The decidability of the DCG depends exclusively on certain simple textual properties of the unit sub-DCG  . This sub-l ) CG can be eliminated fl ' om the GGNF if and only if the DCG is of Illne-parsable  . 
1226 production elimination a ( gor ith misguaranteed to terminate only in the OP ease  . ' tIt produces aI ) C ( \] declaratively equivalent othe . original grammar . 
The left-recursion elimination ~ dg or it hnt is adapted from a transR  ) rmation proposed in \[4\] in the context of a certain formalism ( " l , exical Grammars " ) which we presented as a possible basis for bui ( ding reversible grammars , a The key observation ( in slightly different terms ) was that , in aI ) CG , if a nontermiual g is defined ( it crMly by the two rules ( the first of which is left-reeursive ) : :+\ '  ) - - + g ( Y )  , a(v , x ) . 
,(x ) --, ~( x).
then the replacement of these two rules by the three rules  ( where d_tc is a new nonterminal symbol , which represents a kind of " transitive c ( osure " of d ) : g ( X )  -  , t(Y ) , d_tc(r , X ) . 
,/_re(X , x)-+\[\].
d_tc(X,Z)-,d(X,V ), d_tc(r,Z).
l ) reserves the declarative semantics o1' tim grammar , s We remarked in \[4\] that this transformation : ' is closely re ( ated to le ( 't< . orner pa . rsing ", but did not give details . In a recent paper \[7\] , Mark Johnson introduces " a left-corner program transR  ) rmation for natural ( an-guage parsing " , which has some similarity to the a bow ~ t ransformation  , but whic . his applied to definite clause programs , rather than to () CGs . lie proves that this transformation respects deelarative equival cnee  , and also shows , using a mode(q ; heoretic approach , the close connection of his transformation with  ( eft-corner parsing\[12 ,  9 ,  1()\] . r ( t 1TlUSt be noted that the left-reeursion elimination procedure can  1  ) ea * pplied to any \] ) C ( ~ , whether OP or not . Even in the case where the grammar is OP , however , it wil ( not ( ead to a terminating parsing algorithm unless empty l  ) roductions have been prea ( ably eliminated from the grammar , al ) roblemwl firh is shared by the usual left-corner parser-interpreter  . 
4' Fhe fact that the standard (' , ' F G empty q ) roduction elinfionation transformation is always possible is relal  . ed to the fact that this transformation does not preserve degrees of ambiguity  . 
For instance the infinitely ambiguous grammar S ~ \[ b \] A  , AA , A-+\[\] is simplified into the grammar S-+\[ b \]  . This type of simplification is generally impossible in a I  ) UG . Consider for in sl . . . . . . . tim " g , ' . . . . . . . . . . . "' s(X)-~\[ . . . . . . . be , '\] a(X ), a( . . . . . . . ( X )) --+ a(x ), ~40) -+\[\] . 
572 hexnethod goes back to a transh ) rmation used to compileo at . certain local cases of left-reeursion li'om I ) CGs in the context of the Machine Translation prototy l  ) eCItlTTER\[3\] . 
6 A proof of this fact , baaed on a comparison of proot k trees for the original and the transformed grammar  , is giwm in\[2\] . 
? His paper does not state termination conditions for the transformed program  . Such tern fination conditions w ( mM probably involve some generalized notion of o\ [ t tine-parsability  \[6  ,  5 ,  13\] . By contrast , we prove term l nation only for I ) CGs which arc OP in the original sense of Pereira and Warren  , but this ca . seSeelll StollStO represent llltlch of the core issue  , & lidLo lead to some directexl . ensions .  \] , ' or instance , the I ) CG transformation proposed here can I ) e directly applied to " guided " programs in the sense of  \[4\]  . 
Dae to the space available , we do not give here colrectncs sproof ~ J br the algorithms presented  , butez ' peet to publish them in a tidier version of this paper  . These algorithms have actually been implemented in a slightly extended version  , where the * , / are also used to decide whether the grammar proposed for " transformation is in factoJfline -parsable or not  . 
2 Empty-productionel inlination ( t can be proven that , if I ) CG0 is an OP ( ) CG , the tb ( lowing transformation , which involves repeated partial evaluation of rules that rewrite into the empty string  , terminates after a finite number of steps and produces a grammm : I  ) CG without empty-l ) roductions which is equivalent to the initial g rammar on non-eml  ) tystrings : sinimt : a not lline q ) ars ~ t ble DC ( -II . 
ont Imt : a DCG without empty rules equivalent o DC  ( II on nonempty strings . 
alg , or ithm : initialize I , IST1 to a list of the rules of D(X ;\ [ , :; elI , IST2 to the empty fist . 
while there exists ; mempty rule El/:/l(T ,   .   .   . , Tk ) -,\[\] in LISTI do:
In oveF , RtoI , IS'I'2.
ti ) reach rule R : B ( . . . ) - + ~ in LIST1 such that ( ~  ( : ontains an instance of A (  . . . )  ( including new such rules created inside this loop  ) do : tilreach such instance A ( SI . . . . , Sk ) unifiable with
A(TI , . . . , 7' k ) do : ~ q ) pend to 13S'l'l ; ~ rule IU : ll ( . . . ) ? ~ d obtained from R by removing A ( , q l , . . . . S'k ) lrom ( ~  ( or by replacing it with \[\] if this was the only nonterminal in or  )  , nnd by unifying the Ti's with the , 5'i's . 
set I ) C(I to LISTI.
For instance the grammar consisting in the nine rules appearing above the separation in lig  . 1 is transformed into the grammar ( see figure ) : ~ (  , s(NP , vt , )) --?  , , v(NP ) , vv(W') . 
, , . p(',~v(~'~, c'))-+,,Up ), co ,, p(c).
, , ( , , . ( V covte ) - ~\ [ peovte\].
vv(vv(~'(.~te~p ), c )) ~\[, te~v\],eo,~,v(c).
eo ,, V (,'.( C , a )) ? eo , ,, ~, ( c ), ad , ~( A).
, dv(ad ,, ( l~e , ' e))- . \[ t , e~4 a , tv(adv(todav )) - , \[ today \] , ~ V('P04 , ~; o ~ O ) , C)--co . , . V(C) . 
, ~ p(,~p(N , nil )) - ~, 4N).
eo , ~ v(c(,'t,A))-+,,,t4A).
vp(v(*t ~, ~ p ), , . it )) - ~ N ~ V\].
.q . s("V ('~ V ('4 V "")), , , . it ), Vt ')) - . ~ V(VV ) . 
I ~ When DCG0 is not OP , the transl\]~rl natiott ~ xlay produce an infinite lllll\[lh  ( !l " Ofl'Lll ( !8 , bill a simple extension of the aid ( > rithm can detect this situation : the transform at hm stops and the dr  ; mimer is decl ; ~ red not to be Ot ) . 
1 227   3 Left-recursion elimination The transformation can be logically divided into two steps :  ( 1 ) an encoding of DCG into a " generic " form DCG ' , and ( 2 ) a simple replacement of a certain group of left -recursive rules in DCG ' by a certain equivalent nonleft-recursive group of rules  , yielding a topdown interpretable DCG " . An example of the transformation DCG----+ DCG' - - - - + DCG " is given in fig  .  2 . 
The encoding is performed by the following algo-r ithm : input : an oittine-parsable DCG without empty rules  . 
output : an equivalent " encoding " DCG'.
algorithm : initialize LIST to a list of the rules of DCG  . 
initialize DCG ' to the list of rules ( literally ) : g ( X ) -- ~ g ( Y )  , d(Y , X ) . 
g(x )-, t(x).
while there exists a rule R of the form A(T1 . . . . . Tk ) --, B(S1 . . . . . Sl ) ain LIST do : remove R from LIST . 
add to DCG ' a rule R ': d(B(?'l . . . . . Sl ), A(T1 . . . . . Tk )) --+ ~' , where c ~ is obtained by replacing any C(V1 ,   . . . , Vm ) in a by g(C(V1, . . . , Vm )) , or is set to \[\] in the case where oe is empty . 
while there exists a rule R of the form A(TI . . . . . Tk ) -+\[ terminal \] ~ in LIST do : remove R from LIST  . 
add to DCG ' a rule R ': t(A(T1 . . . . . TI ~)) - . \[terminal \] # , where cJ is obtained by replacing any C(V1 ,   . . . , Vm ) in ~ byg (6'( V1 . . . . . Vm )) , or is set to \[\] in the ease where c ~ is empty . 
~ fhe procedure is very simple . It involves the creation of a generic nonterminal g  ( X )  , of arity one , which performs a task equivalent to the original nonterminals s  ( X 1 ,   .   .   . , Xn ), vp(X1, .   .   . , Xra ), .   .   .   . The goal g(s(X1, .   .   .   , Xn )) , for instance , plays the same role for parsing a sentenee as did the goals  ( X 1 ,   .   .   . , Xn ) in the original grammar . 
Two further generic nonterminals are introduced : fiX  ) accounts for rules whose right-hand side begins with a terminal  , while d(Y , X ) accounts for rules whose right-hand side begins with a nonterminal  . The rationale behind the encoding is best understood fi'mn the following examples  , where ~ represents rule rewriting : vp ( vp ( v ( sleep )  , C )) - , \[ sleep\] , comp(C ) g(vp(v ( sleep) , C ))) ~\[ sleep\] , g(comp(C )) g(X)-~\[sleep\] , ( x : ~ p(~p ( ~( sleep) , c )) , g(co . ~ p(c'))! . 
s(s(NP , VP )) -- + np(NP) , vp(VP ) g(s(s(NP , VP ))) ---* g(np(NP)) , g(vp(VP )) g(X)~g(y ) , ( X = s(s(NP , VP )) , Y = np(NP ) , g(vp(VP )) ; The second example illustrates the role played by d  ( Y , X ) in the encoding . This nonterminal has the following interpret at ion : X is an " immediate " extension of Y using the given rule  . In other words , Y corresponds to an " immediate left-corner " of X  . 
The left-recnrsion elimination is now performed by the following " algorithm "  :9 in tmt : a DCG'encoded as above . 
output : an equivalent nonleft-recursive DCG".
algorithm : initialize DCG " to DCG'.
in DCG ", replace literally the rules : g(X ) - ~ . q(g ), d(Y,X ) . 
g(X)-~t(X).
by the rules : g(X ) ---+ t(Y ), d - ( Y ; X).
d_tc(X,X)--~\[\].
d_tc(X,Z)--+d(X,Y ), d_tc(Y,Z).
In this transformation , the new nonterminald_tc plays the role of a kind of transitive closure of d  . It can be seen that , relative to DCG " , for any string w and for any ground term z , the fact that . q(z ) rewrites into w--or , equivalently , that there exists a ground term x such that t ( x ) d_tc ( x , z ) rewrites in to w--is equivalent othe existence of a sequence of ground terms x = xl  ,   .   .   . , xa = z and a sequence of strings w l , .   .   .   , wk such that t(xl ) rewrites into wi , d(xl , x2) rewrites in to w; ,   . . . , d(xk-1 , x k ) rewrites into we , and such that w is the string concatenation w = wl " " wk  . 
From our previous remark on the meaning of d(Y , X ) , this can be interpreted as saying that " consituent x is a left-corner of constituent z  "  , relatively to string w . 
The grammar DCG"can now be compiled in the standard way---via the adjunetion of two " differential list " arguments --- into a Prolog program which can bcexecute directly  . If we started from an oflline-parsable grammar DCGO  , this program will enumerate all solutions to the parsing problem and terminate after a finite number of steps  .  1?
References\[1\]MarcDymetman . A Generalized Greibach Normal Form for Definite Clause Grammars  . In Proceedings of the 15th International Conference on 9In practice , this and the preceding algorithm , which are dis-sociated here for exposition reasons  , are lumped together . 
1?There exist of course DCGs which do not contain empty productions and which are not OP  . :\[' hey are characterized by the existence of cycles of " chain-rules " of the form : al  (  . . . ) - + a2( . . . ) . 
.  .   .   .   . am-l ( . . . )-+ am ( . . . ) . , with am = al . But , if we start with an OPDCG0 , the empty-production elimination algorithm cannot produce such a situation  . 

I , ISTI delete LIST 2s(s(NP , VP )) -- ~ np(NP) , vp ( VP ) . 
np(np(N,C ))-+ n(N ), comp(C).
, , ( , , . ( wopl ~)) -.\[ v ~ ov u ,\].
n ( , ~( , jo ~)) - ~\ [\].
~ V(~V ( ,,(~ t ~. e ~), c )) -+\[ ~ v \], e o . ~ V(C').
comp(c(C,A )) - ~ corn p(C ), adv(A).
adv(adv(herc ))-+\[ h , . re\].
adv(adv(today )) --+\ [ today\].
np(nV ( , 4 you )), C ) ~ corny(C).
rip(rip(N , nil )) -+ n(N).
comp(c(nil , a )) -+ adv(A).
' oV(,,p(~(~l~V ), hi0)-~\[.~mV\].
,, p(,~(,(yo ~)),, ~ i ~) --,\[\].
~( , ( , ~p( , w( , ~(vo , O ) , ~ iO , vt , )) ~ v ~ , ( w , ) , n ( , 4 , , o , ,)) --+ \[\] . 
comv(niO-~\[\].
, ~ v ( , , p ( , , ( vo , *)), ~ il ) -.\ [\].
Figure 1: Empty-production elimination.
Computational Linguistics , volume 1 , pages 366372 , Nantes , l , ' rance ,   . \] uly 1992 . 
\[21\[Marcl ) ymetman . Transform at kms degrammaires logiques et rd versibilit den Traduction Autom ~  , -tique . Th#~sed'Etat , 1992 . Universit d Joseph Fourier ( Grenoble 1) , Grenoble , France . 
\[3\] Marc Dymetman and Pien'es a belle . Reversible logic grarn mars for machine translation  . \[ n Proceedings of the , 5'econd International Uo'l@rence on 7'heorelical and Methodological Issues in Machine Translation of Natural Languages  , Pittsburgh , PA , June 1988 . Carnegie Mellon University . 
\[4:\] Marcl ) ymetman , Pierre Isabelle , and Frangois Perrault . Asymmetrical pproach to parsing and generation . In Proceedings of the 13lh International Conference on Computational Liuguislics  , volume 3 , pages 90-96 , Itels in k i , August 1 !) 90 . 
\[5\] Andrew tlaas . A generalization of the o\[tine-parsable grammars  . In Proceedings of the 27lh Annual Meeting of the Association for Computational Linguislics  , pages 23742 , Vancouw ~ r , B C , 
Canada , June 1989.
\[6\] Mark Johnson . Attribute Value Logic and the Theory of Grammar . CSLlecture note No .  16 . 
Center for the . Study of I , anguagcand Informwtion , Stanford , CA ,  1( . )88 . 
\[7\] Mark Johnson . A left-corner program transforn , a-tion for natural anguage parsing , ( forthcoming ) . 
\[8\]R . Kaplan and J . lh:es nan . Lexica \] flmctional grammar : aR ) rmal system for grammatical representation . In Bresnan , editor , The Men*al\]cp-resenialion of Grammatical ltelations  , pages 173-281 . MIT Press , Cambridge , MA , 1982 . 
\[9\]Y . Matsumoto , II . Tanaka , lI . \] firikawa , H . Miyoshi , and I\[ . Yasukawa . BUP : a bottom-uppm:ser embedded in Pro\[og . New Generalion
Computing , 1(2):145-158, 1983, \[10\] Fermmdo C . N . Pereira and Stuart M . Shieber . 
Ibvlog and Natural Language Analysis . CSI , Ilec-tm:enote No .  10 . Center for tim Study of Language and Information , Stan'ord , CA ,  1987 . 
liltI:'ernando C . N . l'ercira and \]) avid .  71) . Warren . Parsing as deduction . In Proceedil ~ gs of the 211h Annual Meeling of the Association for Com -pulalional Linguistics  , pages 137-144 , MIT , Cambridge , MA , June 1983 . 
\[12\]D . , I . losen crantz and P . M . Lewis . Deterministic left-corner parsing . In Eleventh Annual Sym . po-sium on Switching and Automata Theor?/ , pages 13953 . IEEE , 1970 . F , x tended Abstract . 
\[13\]StuartM . Shieber . Constraint-Based Grammar Formalisms . MI'I'Press , Cambridge , MA , 1992 . 

I)CGs(s(NP,VP )) ---, np(NP ), vp(VP).
np(np(N,C )) ~ n(N ), comp(C).
, ~( , ~( people )) - ~\ [ p ~ ople\].
vp(v(sleep ), C )) ~\[ sleep\],eomp(C).
cornp(c(C,A )) - ~ comp(C ), adv(d).
ad~(~dv(here )) - ~\[ here\].
adv(adv(today )) ~\ [ today\].
np(np(n(you )), C)--~comp(C).
np(,~p(N ,, ~ i l )) -~, ~( N).
comp(e(nil,A))--+adv(A).
vp(v ( sleep ), nil )) ~\[, sleep\].
s(s(np(n ( you )), nil ), VP )) --+ vp(YP).
DCG'g(X)-~g(Y ), d(Y,X).
g(X)--t(X).
d(np(NP ), s(s(NP,VP ))) -- ~ g(vp(VP)).
d(n(N ), np(N,C ))) - + g(comp(C)).
t(n(n(people )))-+\[ people\].
t(vp(vp(~(steep) , C ))) ~\[ sleep\] , g(eomp(C )) . 
d(comp(C ), comp(c(C,A ))) ~ g(adv(A)).
t(adv(adv(here ))) ~\[ here\].
t(adv(adv(today ))) -- ~\ [ today\].
d(eomp(C ), np(np(~(yo , ,)), C )) - ~\[\].
d ( ,,( N ),, ~ p(N , nil ))) - +\ [\].
d(adv(A ), corap(e(nil , A ))) - ~\[\].
d(~p(W ) , s(s( , ~ p(np(~(yo ~)) , nil ) , VP ))) - ~\[\] , 
DCG"g(x)-~t(y ), d_te(Y,X).
d_te(X,X)~\[\].
d_te(X,Z)-~d(X,Y ), d_tc(Y,Z).
d(np(NP ), s(s(NP,VP ))) - ~ g(vp(VP)).
d(n(g ), np(np(g,C ))) -- + g(comp(C)).
t(,(n(people ))) - ~\[ peopZe\].
t(vp(vp(v(sleep) , C ))) ~\[ sleep\] , g(comp(C )) . 
d(comp(C ), comp(e(C,A ))) ~ a(adv(A)).
t(adv(adv(here )))-+\[ here\].
t(adv(adv(today ))) --*\ [ today\].
d(comp(C ), np(n(you )), C )) --+\[\].
d(n(N ), np(np(N , nil )))-+\[\].
d(adv(A ), comp(c(nil.A ))) --+\[\].
t(vp(v p(v(sleep ), nil ))) --*\[ ~ leep\].
d(vp(VP ) , s(s(np(np(n(you )) , nil ) , VP )))--~\[\] . 
Figure 2: Encoding ( DCG ' ) of a grammar ( DCG ) and left-reeursion elimination ( I ) CG" )  . 

