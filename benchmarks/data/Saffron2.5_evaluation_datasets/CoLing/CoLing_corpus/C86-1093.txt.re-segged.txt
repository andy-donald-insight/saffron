SCSI_: a linguistic specification language for MT 
paper presented for

Bonn , 2529 August 1986

R@miZAOAC
GETA , BP 68
Unl verstt 6 de Grenoble
3840 2 Sa4nt-Martin-d'H ~ res , FRANCE ABSTRACT Nowadays , Mr systems grow to such as tze that a first specification step is necessary if we want to be able to master their developement and maintenance  , for the software part as well for the l inguistic part  ( " lingwares " )   . 
Advocating for a clean separation between l inguistic tasks and programming tasks  , we first introduce a specification / implementation/validation framework for NLP then SCSL  , a language for the specification of an a lysis and generation modules  . 
KEY WORDS Machine Translation , Natural Language Processing , Specification Language . 
I . INTRODUCTION
In most Nt_P and second generation MT systems , the information computed during the process i s generally represented as abstract trees  , very common description tools used in lingu istics  . The modules implementing the Various steps are written in Specialized Languages for Linguistic Programming  ( SLLP )   ( see for example < Vauquots 85a > , < Nakamure B4> , < S\]ocum84> , < Masse 4>) . 
In spite of the expressive power of SLLP compared to tradltionnal programming languages such as LISP  , the conception and the maintenance of programs become more and more difficult as the complexity of " ltngwares " grows  . 
To take up this challenge , we introduce in the field of computational linguistics the specification/Imp lementation/validation framework which has been proved valuable in tradt tionnal p rogramming  . This leads to the into ductton of new tools and new working methods  . 
The expected benefits for computation all inguists are allowing them to facilita te the conception of the linguistic parts of NLP systems  , tO increase the speed of realisatt on , to trn prove the reliability of the final system and to facilitate the maintenance  . 
Writing an analysis program with a SLLP , the computational linguist must define the set of strings to be analysed  , the structural descriptor corresponding to an input string  , the strategies used for the computation of the descriptor  , the heuristics used for ambiguity cho ices and the treatment of wrong Inputs  ( errors )   . He generally writes a more or less precise and comprehensive document on those problems and begin programming from scratch  . This method is highly unfeasible with la rgeling wares  , We advocate for the use of a more stringent methodology which consist of : I  . Specify formally ( Ile . using a formal language ) the valid inputs and the corresponding outputs : the specification must be comprehensive and neutral with respect to the choices of implementation  . At this stage , the computational linguist is concerned only with linguistic problems  , not with programming . An interpreter for the specification language should be used to write and debug the specification  . 
2 . Specify the implementation choices for data structures and control  ( decompost to n into modules , strategies and heuristics ) and the treatement of errors . This specification depends on the Input / output specification and may partially depend on the ktnd of SLLP to he used for imp lementation  . 
It should be as formal as possible , at least a strictly normalized document  . 
3 . Implement the module specified using a part icular 

4 . Validate the implemerl tatton : the in terp reter of the specification language should be used to prepare a set of valid inputs/outputs  ; the results of the execution of the module to be validated on the input set is compared to ti~e output set  . 
An Integrated software environement offer ing the developement tools and Insuring the coherence between the developement steps shou ld be provided to facilitate the use of the methodology  . 
As a first step toward this direction , we introduce a linguistic specific at i on language fop which an interpreter is be ing Implemented  . Those tools are used in the first and four th steps as defined below and are being In tegrated in a specialized envlronement based on the specification language <  Yam86>  . 
II . LINGUISTIC SPECIFICATION 1 . ASPECIFICATION FOR MALISM Before presenting the specification language itself  ,   atrial1 consider wllat properties that such a language we should have  . 
Most problems in NLP systems are found in the analysis stage  ( and some in the transfer stage in MT systems )   . 
The major gain should be to clarify the ana lysis stage using the proposed framework  . Thus , a linguistic specification language should : define the set of valid inputs t rings  ; define the correspending oup uts ( structural descriptors of strings )   ; define the mapping between those two sets . 
Analysis and synthesis ar'e two complementary views of a language defined by a formal grammar  . We should reasonably expect that a linguist ic specification language should be equa lly Llsed for the specification of an a lysis and synthesis modules <  KeyS4>  . 
Formal grammars define formal languages , and formal grammars does not make arly re ference tO the situation  ( the global context in which sentences are produced  )   , thus formal languages used to describe natural language subsets must allow the expression of ambiguities and paraphrases  . An element of the mapping should be a couple ( string , tree ) where many trees are generally associated to one string and conversely  , many strings are associated to one tree . 
The advantage of modularity is admitted and the description of the mapping should be done piece by piece  , each piece describing a partial mapping and the total mappings  ( e , g . unification as In FUGs < Kay 84>) . 
An Important feature of such a language Is that a linguistic specification should be wrtt ten by linguists who have no a prior iknowledge In computer science : a linguist must be able to concentrate only on \] tgu is ttc problems and not on computers ctence problems  . The formalism should be clean of all computer science impurities  , the mechanism of composition should be c lear and simple  . 
Within this framework , a graphic formalism for the specific at ion of procedural analysis or generation grammars  , the " Static Grammars " ( SG ) formalism has been developped at GETA under the direction of Pr  . B . Vauquois < Vauquois 85b > . This formalism is now used tn the French MT National Project to specify the grammar so fanln dustrla English-French system  . Up to now , SGs were hand-written and cannot be edited on computer because of the use of graphs  . This formalism has been modified tnorder to realize a software on vlronement based on SG  ( structural editor , interpreter , graphic outputs .   .   .   .  )  . 
It ts called " Structural Correspondence Specification Language "  ( SCSL )   . A grammar written in SCSLtS called " St ructural Correspondance Specification Grammar "  ( SCSG )  . 
SCSI_(sect . III ) allows one to write the grammar of any in teresting formal language such as programming languages or subsets of natural languages  . This formalism is quite general and does not depend on a particular linguistic theory  . GETA , under the direction of Pr . B . Vauquois , has elaborated its own linguistic f ramework and methodology from which this work directly descends  , but it is nevertheless perfectly possib le to write grammars within different l inguistic frameworks  . We emphasize this point because the dist inction between the formalism properties and the linguistic theory propertiests not always clear  . 
Moreover , t t may be tempting to wire the properties o f some linguistic theory within a parti cular formalism  , and thists sometimes done , leading to confusion . 
2 . IMPLEMENTATION AND VALIDATION OFLIN GUISTIC MODULES As mentioned earlier  , a SCSG Is used for the specification of analysis or generation modules written in one of the SLLP of the ARIANE system  . Defining a mapping , a SCSGIs neutral with respect to imp lementation choices whic  l3 are essentially algorithmic In nature ( organteation in modules , control , etc ) and with respect to intrinsic ambiguity choices which are essentially heurist i c in nature  . 
The same SCSG may be used to specify the lnputs /ouputs of different procedural g rammars  , each of which implementing differents t rategies and heuristics for comparative purposes ? the result must nevertheless cor respond to the same specification  . 
The interpreter ( not yet fully implemented ) ts used for debugging a SCSG ( tests , traces .   .   .   .   ) and for the empirical validation of p rocedural grammars for analysis or gener at ion : the function computed by a procedural g rammar must be included tn the mapplng defined by the SCSG spect fiying the procedural g rammar  . 
The interpreter may compute the trees cor responding to an input string  ( analysis ) or the strings corresponding to an input t ree  ( generation )   . A chart identifier may define an entry po in t for the interpreter  . 
Beforeen execution , one can type in different trace commands . At the end of an execution , the trace and the derivation may be printed . 
Qne can trace for different charts ( step-by-step or otherwise ) a tentative application of a chart , a suce s s , a failure ore combination of these parameters  . In the step-by-step mode , the interpreter stops on each traced trial /suces s/failure and it is possible to type In new commands  ( trace , untraoe , stop ) and chose the next chart to be applied . 
An output trace element have the following general pattern  ( several levels of details are avaible ) : < chart td > , < tree_o courence > , < string_occurence > . 
III . THELANGUAGE
To give a flavour of the specification language  , we introduce esimplified version . Unnecessary ( but essential for practical use ) constructs of the language are removed . A more abstract view has been studied tn < Zehar  tnB6>  . 
A SCSG describe simultaneously : the set of s trings of the language  ; the set of structural descriptors of the language : the mapping between those two sets  . 
ASCSGts composed of " charts " . The mapping between the string language and the tree language Is decrt bed in parts : a chart decrf bes a partial mapping  ( set of valid sub-strings <-> set of val id sub-trees  )   , the total mapptng is obtained by the composi tion of partial mappings  ( sect . IV ) . 
SCSLIs a language using keywords : every impor tant syntactic unit begins with a keyword  ( e . g . CHART ) . 
Identifiers begin with at least one let ter  , designators begins with at least one digi t  . Designators are preceded by a prefix indicat ing their type  , A SCSG begins with the declaration of labe ls and decorations  , and then followed by the charts . Charts consist of a tree part and a forest part describing respectively a treep at tern and a forest pattern  . We then have the contexts part and lastly the constraints part  ( sect . III . 2 )  . 
SCSL do not have the concept of as stgnement : a chart defines correspondence between a tree end a forest constrained by a boolean expression on the patterns of the chart  . 
The basic construct of the language is a labe led and decorated tree pattern : each node of the described trees is a couple  ( label , decoration ) . The label have tile string basic type , the decoration have a hierarchical defini tion which use the SCALAR and SET const ructors  . A constraint Is a boolean expression on the labels and decoration soft be nodes of the patterns  . 
i . LABEL ~ DECORATION AND TREE PATTERNS Most of SLLP use trees as basic data structure  , Some associate to a tree or to a node attr ibutes  , essentially a set of variable/value pa irs which may be manipulated with a few operators  . To offer a more powerful description too l  , a SCSL node tree ts a couple ( label , decoration ) where the decoration is a hierarchical att ribute structure  . Thists intended to Facilitate the man ipulation of complex sets of attributes through a unified view  . 
t.t . Label
The label Is traditionally a non-term in a l of a grammar  , butttmay be viewed as a particular att ribute of a tree  . The type definition of labels ts expressed with a regular expression  . The operation on this type tsequality . 
Exem ~:
LABEL lbl = (" b " . (" a ")*) ++" S "+" A "+" B"1 . 2  . Decoration The decoration is interpreted as an oriented non-ordered tree where attr ibute identifiers  ( SCALAR or SET type ) are the labels of the nodes and the values o f the attributes are the forests that they dominate  ( in the INTEGER types with the associated operators  ) ? For the SCALAR type , the operation is equality , For the SET type , the operations are union , Intersection and set difference , Relational operators are equality , menbership and inclusion . 
The operations are defined on a hierarchica lset structure : one must indicate on whlch level an operation is defined by suffix ing the operator with an integer  . The default value is the first level ; "*" is used for the deepest level . 
Examples : a(b , c(e , f , g(gl , g2))) = a(c(h , f , g ) , b ) ts true a a
IIII bccb___1 = 1I
IIl II\[efghfga(b , c(e , f , g(gl , g2))) = 2 a(d , c(e , g )) Is false a ! I!Ibedc
I \]!\ [\[ efgeg
I ! glg2a(b , c(e , a
IIbc
I ef gglg2f , g(gl , g2))) =* a(c(e , g(gl , g2) , f ) , b ) Istrue : ai
IIb cegf\[glg2
FqY ~ AE~of decoration for noun phrases :
DECORATION deco:SET ( semantic relation : SCALAR ( instrument , quantfter , qualifier ) , syntactic_function : SCALAR ( coordination , governor , subject ) , category : SCALAR ( noun : SCALAR ( semantic : SET ( animate , measure )) , adjective : SCALAR ( ordinal , cardinal , noun phrase quantifier ) determiner : SCALAR ( quantifier )   , subordlnator:SCALAR(preposition )) 1 . 3  . free . pattern The basic notion of the language is a labeled and decorated tree  . The types of a node , a tree , a forest are defined by the declaration of the labels and the decorations  . 
A chart should be a comprehensive descript ion of a linguistic fact which Bay I lave different rea\]ls at lons : the decorat i on allow the manipulation of sets of a ttributes at different levels of  detat1   , the structure should describe a whole fami ly of trees  , The structure of a tree pattern is descr ibed wtth designators whtch are Implicit l y declared  . The scope of s designator Is reduced to a char t  . A designator begins wt thoned tg it , a node designator is prefixed wtth ,   . t , . The content of a node is accessed by means of decoration and label identifiers : the labe l of a node  . 1 is accessed by 1b1 ( . 1  )   ( if tile label is declared as " bl " )   , t ts decoration by deco ( . 1 )  . 
a treede ! ~ is prefixed with "~" . The tree may be reduced to a single node . 
a forest designator Is prefixed with "$" . The forest may be empty , A tree pattern describe a set of trees , each tree being completely describe in wid th and depth  . 
E_x arq pIe_ : the pattern . 0 ( $2 ,  . 3 (  . 4,$5),$6): ?0 fII$2 . 3 $6  . 4&5 may belnstant lated by : z ~"0 = a .   .   .   .   .   .   .   .   .   .   .   .   . $2 = b(c , d ), e , f(g)
IIII . 3= h be f h , 4= i ! II .   .   .   . & S = k(i , m ) if g ! ~$ 6= c dik ___ l .   .   .   . 

Imtlere , abels are for a couple ( a bel , decorattot )) . 
2. CHARTS
A chart has the following pattern :
CHART < chart id > < TREE > -- tree pattern , < FOREST > -- sequence of tree patterns , < I_E FTCONTEXT > -- set of cuts of the der ivation tree < RIGIITCONTEXT > -- contain ing the tree pattern  . 
< CONSTRAINTS > -- boo\]e an expression \] abels and -- decorations  . 
2. I . Tree and forest parts
The tree part describes a set of trees with the following syntax : 
TREE < tree pattern >
The forest part describes a set of sub-str ings with the following syntax : 
FOREST < forest_pattern >
The element of the forest pattern may be : a string element described direct y  ; -a sub-string described indirectly us ing the corresponding structure  ( tree )   , defined by some chart . 

The forest pattern is a sequence of treep at terns described by a regular-like notation : a tree pattern suffixed by "+" may be i terated  , by "?" optional and by "*" optional or Ite rated  . Contrary to regular expressions , one can use these notations for single tree patterns only  . 
TO have stmp \] ernotations , an iterated tree pattern , e . g , ( . 1 (  . 2,,3))*, w111 be written . 1  .  ( ,2 ,  . 3  ) and the same convention wiil hold for "?" and "+"  . Such a pattern must be used as a whole and is interpreted as a list : a boolean express ion on nodes of such a pattern is interpreted as an expression on the nodes of each tree of the list  . 
E?am J ~_ Le .  :  . 1? ,  . 3 , ($4) ,  . 5+($6) the node designated by . 1 may be absent ; the tree designated by . 3 ($4) may be absent or iterated ; the tree designated by . 5($6) must be present and may be iterated ; 2 . 2  . Correspondance and constraints a ~ llclt corres  J3ondance between tree and forest To avoid the dupli cation of the same constraints in the tree part and in the forest part  , we allow the followlng notation facili t y  . 
The same node designators in the tree pattern and the forest pattern represent distinct objects related to each other in the follow lngmanner : if C  ( T . x ) is tile set of constraints on a node T . x of the tree part and C(F . x ), the set of constraints on the node F . x of the forest part , then node T . x verify C(T , x ) and the constraints of C(F , x ) which are not contradictory with those of C  ( T . x ) ( and conversely for node F . x ) . 
This relation may also be explicitly stated for nodes having different des ignators using the predeftned CORRES funct ion  . 
Some formal constraints linking the tree pattern and the forest pattern a rever if ied at compile time to ensure decidabili t y  . 
b ) Constraints
The constraints part is a boolean express ion on labels and decorations of chart pat tern nodes  . Ail classical boolean operators are avai lable  ( and , or , exclusive or , not , imply , equivalent ) . 
Designators are prefixed by A for the tree part and F for the forest part  . An expression using non-prefixed designators is interpreted as an expression on the des ignators of the tree part and of tile fo rest part  . The designators of context patterns Bust bed ifferent from the tree part end forest part designators  . 
CONSTRAINTSCORRES(T . 1, F . 4) & degre(T . O ) = degre(F . 4) &(( degre(T . 3) ~= degreO&degre(F . l ) = degre(F . 3)) V(degre(T . 3) = degreO&degre( . 1) = degre( . 4  )   )   ) A tree pattern of the context pattern i8 a member of a cut of the derivation tree of the context-free skeleton  ; a context pattern describes a set of cuts in the derivation tree  ( sect . IV . 2 )  . 
A context pattern is a forest pattern where each tree pattern may be prefixed by the " not " boolean operator  (  "^" )   , indicating the mandatory absence of the tree pattern  . Context designators must not be used in other parts of the chart  . 
E xamll3Le ~: we give some examples of right contexts and their interpretations  . The constraint 6( . 5  ) is written for a boolean express to m on the label and decoration of  , 5  . 
there exists a cut such that the first e lement of this cut verify C: 
RCTX . 5($6) CONSTRAINTSC ( . 5  ) ? he first element of each cut verifies C  (   . 5 ) :
RCTX ^ . 5($6) CONSTRAINTS^C ( . S * ) there exists a cut and there exists an e lement of this cut such that  6   (   . 5): RCTX&4*, . 5($6) CONSTRAINTSC ( . 5 )  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +
CHART bx 39
TYPE : simple NOUN PHRASES.
CASES : absorption of left and right adverbs . 
EXAMPLES : " some of the books " , " at least two tables " . 
TREE . 0 (  . 17 , $5 ,  . 2 , $6 ,  . 37) FOREST . 1? ,  . 0 ( $5 ,  . 2 , $6) ,  . 3?
RCTX .4($7)
CONSTRAINTS--constraints on tree nodes : e tiq  ( T . O ) = " nps " & k(T , O ) = np&sf(T , t ?) = des&sf(T . 3?  ) = des--constraints on forest nodes : & et iq  ( F , O ) = ' np " & k(F . O ) = np & etiq(F . i ?)^=" ago ''&( cat(F . t ) = 2 a(npmd ) V cat(F . 1) = 2a(npq tf )) & sf(F . 2) = gov&cat(F , 3?) = 2a(npmd)&(EXIST(F . I ?) VEXIST(F . 3?  )   ) -- EXIST is a predeflned boolean functiqn- -testing the existence of an instance : - -there must be an instance of  . 1 or . 3 - - const ra in ts on r ight context and fo res t nodes : &  ( EXIST (   . 3?) => ( etlq ( . 4)^: " np ' ' Vettq(F . 3  ) = " ago " )   ) FtL guPet : Example of a simple chart for English  2   . 3  . Contexts A partial mapping described by a chart in a context-free manner may be subor d inated to contextual constraints on the lef tor right context of the described set of sub-strings  . This is a powerful tool to describe contextual constraints  , co-references , wh-movements , etc . 
A context elememt is a sub-string which is described with a corresponding treep at tern  . 

Instance of tree and forest : patterns for " some of the books ":  , 0 <  .   .   .   . npc " . l . 3? <- . t?<-"some " . 2$5 <-" of " . 3, " the " . 4  . 2<-" books " . 5 $6 <- .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +
Ibx 39!\[
TREE " rips ".1 I
II
I\[fIIflfIfi ! " some " . 2" of " . 3" the " . 4" books " . 51 ? " np (:" . t : deco(k(np ), cat(n )) 1" sonic " . 2: deco(cat(a(npqtf )) , sf(des )) l"of " , 3: deco(cat(s(prep ))) , sf(reg )) f " the " . 4: deco(cat(d ), sf(des )) f " books " . 5: deco(cat(n(nc )), sf(gov )) I
Il !
FOREST " np " . l !!! fIl1r ! " some ", 2" of " . 3" the " . 4" books " . 5 ! i " np " . l:deco(k(np ), cat(n ))! " some " . 2: deco(cat(a(npqtf )))\[" of " . 3: deco(cat(s(prep ))) , sf(reg )) !" the " . 4; deco(cat(d ), sf(des )) I " books " . 5: deco(eat(n(no )) , sf ( gov )   ) !! Ftqure 2 : Chart instance on " some of the books " iV . THE DERIVATION MECHANISM 1 . ELEMENTOF 1HE MAPPING An element of the mapping defined by a SCSG is a couple  ( string , tree ) where the correapondance is defined for , each subtree , The string is displayed as a linearg raph labeled wtth string elements  ( terminals of the grammar )   . 
The tree is a correspondance tree : to each node is associated a list of paths of the string graph  ( the correspondance ts generally not project ive  , e . g . 
representing the " respectlvly " construct).
of the couple for the string " some of the books ":- i  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + iT
Ibx 39 I!TREE : l
I"nps ".1\[\[ Ift ! ~ f\[I
T ~ i I!i
I " some " . 2" of " . 3" the " . 4" books " . 5! f!l " npc " . l : deco(k(np ), cat(n )); (0, 4) . !!" some " . 2: deco(cat(a(npqtf )) , sf(des )); (0 , t ) . lI"of " . 3: deco(cat(s(prep ))) , sf(reg )); ( t , 2 )  . !!" the " . 4: deco(cat(d ), sf(des )); (2, 3) . ! I " books " . 5: deco(cat(n(llc )) , sf(gov )); (3 , 4 )  . \[ r ! SII ~ ING : I , i ! O - " SO lile " . 2-1 = " of " . 3  . 2 - " the " . 4-3-" books " . 5-4\[!" some " . 2: deeo(cat(a(npqtf ))) (0, 1) . II " of " . 3: deco(cat(s(prep )))) (1, 2) . ll " the " . 4: deco(cat(d )) (2, 3) . t ! " bools " . 5: deoo(cat(n(llc ))) (3, 4) .  1 4  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + FQ ~ Eure 3 : A pilcation of bx39 on " some of the books " 2   . DERIVATION INTHECONIEXT-FREE FRAME WORK In the context-freefr ~  , * mework , Schart may be see ~ lasa rule In the PRQLOG\ ] Ifly  , your : 4 .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  4 . 
f t
IClIART ( tree , string ) -> r!TERMINAL ( node l , sstring t)\[f <* chart , tree : ! , sstrtng2>\[
I !
IEVAL ( constraints ) I ! ARC(tree , string , context );\[\[ , \[ I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + ClIART ts the chart identifier , ~\[' eezs trln9 ~ is the computed couple , TERMINAL is a string element definit ion  , -* chart , ~ vartable that will betnstant lated wi thach art t dent tflet  , EVALts a predicate that evaluate the constra ntspart  , ARC make the reduction and memorize the ( : on texts for future evaluation . 
The algortthm of the context-free skele to n is a bottom-up version of Earley's a lgorithm defined and used by Qut?lton <  Outnton80> in the KEAL speech recognition system . 
For the sake of clarity , the input tape and the factorized stack may be represented as a C-graph  . 
Executing an analysts , tile Interpreter receives a \] tnear labe led C-graph and t ~ orks by adding on arcs for each reduced constituent  . An arc Is labeled by a correspondance tree , the contexts to be evaluated and pointers to the reduced constituents  . 

Exam loJe of a derivation tree for the str ing " some of the books "  . The couple calculated Is written best de the chart identifiers  . 

DERIVATIONTREE : bx39 < nps(some , of , the , books ) (0 , 4 ) >
I " some " bx38 < rips(of , the , books ) 1 , 4) >

I1" of " bx3 ? < nps(the , beoka(2,4) >
I !
I1" the " bx5 < npe(books ) (3, 4) >
I " books "
STRING :
O-"some " - I - -" of " -2 -" the " -3 -" books " -4 F  ~ 4 : Derivation for " some of the books " 3  . CONTEXTEVAL UATIONA context is evaluated dur ing a traversal of the cuts of the derivat ion tree which go through the node containing the couple  ( string , tree ) . 
A context pattern memorized on an arc(x , y ) describes cuts tn the derivation tree . For a C-graph with Input node I and output node O  , these cuts are represented by paths from y to O ( for a right context )   . A right context evaluation is thus reduced to the search of a sub-C-graph from y to  0  . 
V . CONCLUSION
In the study and developement of future indust rial MT systems  , the definition and Implementation of lingu is tic parts raise many problems partly due to the size of the systems  , and we hardly need rigorous methods of deve lopement  . The challengets to theorize the line of ac tivities which go from the formal spec if ication of an Informal problem to the pre of of correctness of the corresponding program  , and this In the field of linguistic p rogramming  . 
As a first step in this direction , within the specification/Implement at ion/validation framework  , a software envtronement Is being developed based on a linguistic specification language  . 
Thts language allows linguists to specify analysis and generation modules fop natural language subsets and the interpreter allows empirical validation ef implement at ions  . The language is actually used to specify the grammars of the French MT National Project  , and for all new developements carried out in GETA  . 
For further work , extensions are studted , specially the specification of trans fer modules  . Work is also being engaged to develop r igorous linguistic programming methods us ingSLLP provided with SCSG specific at ions  . 
REF_~_ERENCES < Better 85>: BOITETC . , GUILLAUMEP . , QUEZEL-AMBRUNAZM . A case a tud~tn software evolution : from ARIANE  78  , 4 to ARIANE 85 Proceedlrlgs of the Conference an Theoreti cal and Methodological Issuest n Machine Translation of Natural Languages  , Colgate University , 14 amtlton , N . -Y . , U . S . A , August 1416, 1989 . 
< Kay 84>:KAYM . Functtonnal Unification Grammar : a fo rmalism for Machine Translation Proceedings of 
COLING-84< Mass 84> " MAASH . ~D . The MTs stem SUS ? presented at the ISSCOTutor ialon Mac'-hlne Translation  , Lugano , Switzerland , Aprt l2-6 ,  1984 . 
< Nakamura 84>: NAKA MURAd . , TSUdId . , NAGAOM . Grammar Nrtttrl ~ ~ of Mu-Machlne Trans ~ at ~ Project and its caracterlsttcs Proceed ings of 

< OutntonSO > : OUINTONP . Contribution Ai are connaissance de la paro le  . Utllisatton dem~tho desheuristi ~ our\ ] are connaissance dephrases Th~se de Docteuras Sciencesen Math & matt que a  , Universlt 6 de 9ennes ,  1980 . 
<Slocum84>: SLOCUMd . METAL : the LRC Machine translation S~stem presented at the ISSCO futortal on Machine Translation  , Lugano , S~itzerland , April 2-6 ,  1984 , < Vauquots 85a >: VA UO UO IS 8 . , BO\[~ETC . Automated Translation at Grenoble Univers ~ t ~Computational Linguistics  , ll/l , pp 2836 , danuary-March 1985 . 
< Vauquo is 85b >: VA UQU OISB . , CHAPPUYS . Static Grammars ; a formalls m for the description of ltn quts tic models Proceedings of the Conference on Theoretical and Methodologt ca  1 issues in Machiner rans latlon of Natural Languages  , Colgate University , It amtlt on , N . -Y . , U . S . A , August 1416, 1985 . 
<Yan86>: YANY . -F . Structural CoPre ~ on dance Stoecl fleatlon Environement ~ gs of  COLING-86 < Zahar ln86>  :  ZAI4ARIN Y . Strategies and Heuristics In the Analys is of a Na  ~1~ L ~ lu ~ Lu ~ - ~ a ~ li ~ e ~ a - ~ on Ph . D . Thesis , Uni ~ ve ~ rssitt5 at ~ nsls M-a ~ Penang , Marchi 986 . Research work under the GETA-USMG Cooperation ( GETA document )   . 

