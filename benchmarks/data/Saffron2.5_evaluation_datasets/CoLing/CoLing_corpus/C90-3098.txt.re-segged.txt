USING THESAMESYSTEMFORAN ALYZING AND SYNTHESIZ INGSENTENCES 
Phillipe Rincel * and Paul Sabatier **
? Bull S . A . , CE1)IAG , 68 Route de Versailles , 78430 Louveciennes , France . 
?* CNRS , Groupe Intelligence Artificielle , Facult 6 des Sciences de Lumin y , 13288 Marseille , Cedex 9 , France . 

We specify the advantages of guided composition of sentences and illustrate them with examples from Leader  , a natural language interface we have developped . Guided composition is achieved by using the same grammar for analysis and for synthesis  . We detail the problems we have encountered and we provide solutions for partial synthesis  . We give the principles of the analysis-synthesis algorithm  . 

Natural Language Interface , Guided Composition , Analysis , 
Syn~esis , lh'o log.
1. INTRODUCTION
The quality of a natural language interface must be estimated not only in terms of linguistic overage but also in terms of procedures dealing with unexpected expressions  ( incorrect formulations or correct ones , not provided by the interface ) . 
Knowi_ng that error recovery is a complex task in the " restricted " framework of prograr runing languages  ( limited syntax and rlgourously defined semantics )  , one can appreciate the difficulty of endowing natural language interfaces with such capabilities  . One can resort to flexible parsing for analysing " deviant " expressions typed by users\[ Carbonell and Hayes  1983\]  , but this method can mislead them about the interface's real capabilities \ [ Mathieu and Sabatier  1986  ; 
Sabatier 1987\].
Our approach is quite different . We have developped a generator of natural language  ( French and English ) interfaces to relational databases , Leader\[Benoit et al .  1988\] . An interesting characteristics that our system can lead the user towards provided fommlations in a user-friendly way  . The user can compose step by step questions by means of information dynamically synthesized by Leader  . The same system with the same grammar is used both in analysis and synthesis  . We specify in this paper the advantages of guided composition  . We detail the problems we have encountered and we provide solutions for partial synthesis  . We give the principles of the analysis-synthesis algorithm  . 
2, ADVANTAGES OF GUIDED COMPOSITION
We may distinguish two kinds of conununication with natural language interfaces : - a " free " mode : the user types sentences without knowing the limits of the interface but he hopes it will understand him  . Trivial reality : user's freedom will always be the freedom the system will grant him  . 
-aguided mode : the system guides the user while he compose sentences  ( guided composition )  . 
Unlike the " free " mode , with guided composition users quickly perceive the limits of the interface  . The designer doesn't have to program all the expressions or structures having the same meaning  . Unique forms and structures are sufficient . He may forget the others . A user-friendly interface with a guided composition mode must lead users towards non ambiguous formulations  , as in Leader . So , it is not necessary to produce paraphrases for want of clarification from the user  . 
We give now an example of a session with Leader.
In this application , the system interfaces a database that contains information regarding Nobel Prizes  . ( The original session is in French ) . 
The user types :
Give the ...
Byame recursor return , the user asks to be guided . And Leader synthesizes expected expressions following the word the : age average of coutLtry mannatiotuality person  womaP1 Using a mouse , the user selects and clicks the word person . 
H is sentence becomes:
Give the person ...
By a cursor return , heasks for assistance . And Leader synthesizes : that who
The user selects who . And so on.
Give the person who ...
didrugtref used receh Jed 4401
Next step : the user selects received and decides to continue without may assistance until the conjonction and : Give the person who received the Nobelprize of 
Physics in 1921 and ...
Attiffs point , Leader synthesizes : his ~ herage his/her nationality in 
Aad the user completes his question :
Give the person who received the Nobelprize of Physics in  1921 and his ~ her nationality ? 3  . PROBLEM SBOUND TO PARTIAL SYNTHESIS After the last word of anfimompleted sentence composed by the user  , Leader's grammar runs in synlhesis and produces a list of possible following words or expressions  . The main problem of this kind of synthesis ( we call it partial aynthesis ) is that a word ( or an expression ) that has been synthesized by the system ( and selected by the user to compose his sentence ) must not lead to a fim ~ redead end . For exmnple , after a noun phrasetile system may synthesize the relative pronoun who if and only if  , in the application domain , there is a verb that can take this noun phrase as subject  . If there is no such a verb , the relative pronoun who must not be synthesized . 
One can avoid deadends by developping a semantic algrm ~ unar with symbols reflecting the semantics of the application domain like in Tennant's menu-based system\[Tennant  1984\]  . This is not the case with Leader . Leader is a generator of nalurall mlguage interfaces  . Leader's grammar is portable to different domains  . Symbols reflect linguistical properties . Associated to particular symtx ~ ls , general conditions access to the sem~mtic model of the application domain  . Because of the partial synthesis problem , calls to these conditions must be placed in tim granmar before concerned symbols  . Their evaluation is done before the rewriting of symbols  . 
The following simplified rules ( in a DCG style ) ilh~slrate the principle involved in the synthesis  ( or not ) of a relative pronoun . The general condition possible_case takes the concept associated to the noun ~ md verifies if it can be a case  ( agent , object , etc . ) of a verb . Only the different values of possible case are dependant of the application domain  . 
np-->det , noun(Concept ), relative ( Concept).
relative ( Concept ) --> possible_case(Concept , Case , Verb ) , relative_pronoun ( Case ) , incomplete sentence ( Cc as ' e , Verb) . 
relative ( Concept ) -->\[1.
Another problem of partial synthesis is the problem of variable symbols  . By variable symbols , we mean words or expressions that are not defined in the lexicon of the system because they are too numerous or infinite  , llke integers , dates , or proprer norms for exmnple . If these expression stxzlong to those following a given word  , one can't synttm size them . In this case , Leader produces a message expliciting the type associated to the expected expressions  . For example , after the incomplete question : Give the persons who received the Nobelprize of Physics before  . . . 
Leader will synthesize : < enter a year , example . "1945> < enterapers on , example : Einstein > Concerning variables ymlmls , Leader displays messages when running in synflms is  , but collects and parses expressions when running in analysis  . 
The right placement of calls to conditions in the granunar  ( not to lead to a dead end )  , and the management of variable symbols were the two major problems we encountered and solved with partial synthesis  . 
4. PRINCIPLES OF ANALY SIS-SYNTHI,~SIS
The potential reversibility of certain programs written in Prolog is wellknown  . So , in order to facilitate the implementation fa granm ~ arrmming tx~thinm ~ alys is and in synthesis  , we have decided to program Leader in this language  . The core of the system is a Metamo ~ hosis Grmnmar \[ Colmerauer  1975\] using immediate Prok ; g strategy : topdown , left-to-right , depth-first , non-detem finistic . 
In order to synthesize all the possible expressions following a given word  , the granm'tar must contain no cuts ( and no negation by failure )  . For example , the two following grmn mar rules : pp ( object )  --> ! , np . 
pp(Case ) --> prep(C ~ s'e) , np must be replaced by the following ones : pp ( object ) --> np . 
pp(Case ) -->\[ difi Case , objeet ) , prep(Case ) , t  ~ D . 
difl X , Y ) is the coroutine builtin predicate thai controls at all times the validity of the inequalion between X and Y  . It fails as soon as X and Y be comequal , and tile progn unback tracks . 
We give now file principles of our analysis -synthesis algorithm  . To each word typed by the user ( or selected by him in the synthesized list )  , one associates an integer corresponding to its position in the sentence  . For example , for the question : 2 .   441 Give the persons w tuo received the Nobel prize of
Physics ? we will have the following association : Give  ( 1 ) the ( 2 ) persons ( 3 ) who ( 4 ) received ( 5 ) the ( 6 ) Nobel ( 7 ) prize ( 8 ) of ( 9 ) Physics ( 10 )  ?  ( 11 ) The algorithm needs an integer , called rightmost , whose value is the integer associated to the righmms tword accepted by the granunar in the user's sentence  . At the beginning of the analysis-synthesis , the value of rigth most is 0 . rigth most increases according to the words accepted  , but rightmost never decreases : backtracking in the application of gramma rules has no effect on rightmost  . The algorithm needs another integer , called current , whose value is the integer associated to the current word to be analysed in the sentence  . At the beginning of the analysis-synthesis , the value of current is 0 . 
current increases according to the words accepted , but also can decrease when backtracking occurs in the application of grammar rules  . For a given complete or incomplete user's sentence  , rules of grammar are applied until terminal symbols  . 
When a terminal symbol must be applied , the following ( meration is done . If the terminal symbol expected by the grammar ule matches with ~ e current word of the sentence  , we have the followings it , ration : If current > right tru'zgt , then , we do : ri@gmos := currem "
Clt/'ren\[~::clgrretg "+" i else , we do : current := current + 1 If the terminal symbol 1" expected by the grmmnar rule doesn't match with the current word of the gr~mm'Lar  , the situation is : If current < righztm- ) st then we do nothing , else , we record T as ~ m expected word instead of tire cmT entword in the sentence  . 
At the end , if the analysis succeexts , the users's sentence is accepted . If it fails , we display the user's sentence until the word W whose associated integer has the value of rightmost  , and we display all the terminal symbols T recorded as possible words fol ! owing W  . Then , the user selects an expected word and comp ! et es or no this sentence  . And the sentence is analysed from tim beginning . 
As we mention it above , calls to conditions may occur in a gramma rule . Their evaluation can produce several solutions , it is in fact the nature of the words encountered that limik ~ then unlber of solutions  . The partial synthesis imposes to place may condition in a grammar rule before the concerned symbol in order to evaluate the condition before the rewriting of the symbol  . This method is not efficient when the rewriting of the concerned symbol leads to a part of the sentence yet accepted  . The evaluation of the condition could be done after  . 
So , for each call to a condition that may occur in a giammar rule  , we place it before and after the concerned symbol  . The condition will be evaluated before if : current = right mz ~ stand after if : current < rightmost Cohnerauer first  , with intire natural language interface to a database on planets  , Orbis\[Colmerauer and Kittredge 1982\] , used the same grammar for analyzing sentences and synthesizing expected words after an erroneous ont  . Our algoritlun differs from Orb is ' one on the following points  . We introduce and manage variable symbols . We don't reanalyze the incomplete ( or erronexms ) sentence for synthesizing expected words : we do it in one pass  . Efficiency in time is better by evaluating conditions before or after the concerned symbols according to the values of current and righlmost  . 
5. CONCLUSION
Partial synthesis is an interesting challenge when one decides to use the same system for analysing and synthesizing sentences  . If Prolog seems u ) be a fairly technical solution , fundamental problems must be solved like writing sizable nonambiguous grannnar with natural phenomena like trroforms  ( pronouns , ellipsis , etc . ) , or mastering the control of partial synthesis for avoiding arty future dead end  . \[ mader illustrates a path we have decid ~ i to follow and investigate  . 
6 , ACKNOWLEDGMENTS\[xzader has been developped at Bull CEDIAG  ( Artificial Intelligence Development Center )  , 784 30L * mveciennes , France . We thank Pascale Benoit and Domh-&lue Vienne for their contributions  . 
7. REFERENCES
Benoit P . , Rincel Ph . , Sabatier P . , Vienne D . , A User-Friendly Natural Language Intoface to Oracle  , European Oracle Users ' Group Conference , Paris ,  1988 . 
Carbonell J . , ttayes P . , Recovery Strategies For Parsing Extragrarrg natical Language  , American Journal of Computational Linguistics ,  9 ,  34 ,  1983 . 
Colmerauer A . , Metamorphosis Grarmnarx , in Natural Language Conummication With Computers , Bole L . 
Ed . , Springer Verlag ,  1978 ; First appeared as Les Grammaires de Mdtamor phose , GIA Report , Luminy , Universit 6 . Aix-M ~ seille 2,1975 . 
Cohnerauer A . , Kittredge R . , ORBIS ,   9th Intemat kmai Conference on Computational Linguistics  , 
COLING , 1982.
Mathieu Y . , Sabatier P . , lnterfacile : Linguistic Coverage and Query Reformulation  ,   11 th International Conference on Computational Linguistics  , COLING , 1986 Sabatier P . , Contribution au ddveloppement d'interfaces en langage natmel  , Th~sed'Et at , Universitd Paris 7 ,  1987 . 
H ., Menu-Based Natural Language Understanding,
National Computer Conference , 1984.
Tennant 44 23
