Condi Lioned Unifica Liou for Naturall , an ~ uage Process in p , 

This paper prescnLs what wcc . allacondi Liol'mdunification , a
r'm'wmeLhod of unificatiol ' ~ for processing natural languages  . 
The key idea is to annotate L he patterns w iL ha cer Lcdn sort of conditions  , so that they carry abundant in for rnation . '\]' his met . bedt . ransmits in forrna Lionfrornone pattern to another more efl'icien LlyLhanproecdurc aLLachmenLs  , in which information cort Lain cd in the procedure is embcddcd in the progran l rather L h a n d i r c c l  . /ya L Lachcd Lopa LL ( ms Coupled wilt techniques in for rnall inguistics > i \]\] or covcr  , conditiorled unification serves most . types o1" opcrations for natlu'ai\]ar/guage processil'q ~ ,  . 
KS it if/asida\]'\]\]ecL roLechllica\[1 , be ' A . or yUl\]lczorloI4 , 7 ~ aktlra Mtl Fa , Niibari-Gurl , 
Ibaraki , \[t ObJapan ( \[3 ) ptlt_tllSpsrln rnb ( prcs on L , P , N ): not Alr d~'-tng(P , N)l~ut_Lns , psnnl:nl ) ( T , l " , N ): not_pres(T ) no L_3rd sng(lst . , , N) . not pres(past ) not_~rd~'-;ng(;~nd , N ) not pres ( past 4~a ' rtlclp\]e ) r lotA/rd , sr~g ( , ' Wd , plural ) not pres(basc ) . 
1. Introduction
A currcr'd,majort . rcrY . t of naturulla ~/ guage processing is e hara . cterized by Lh cover all use o\[unificat ion  ( Sttiebc ~ r ( 198' l )  , Kay (1985) , Proudir : ~ and Pollard (1 , 985) , Percira (198b ) , Shicbcr (1985) , etc ) reflec Linglhe recent developmer its in nonLra  . nsforma LJonal linguistic\[ormalis rns  , such as Lexical Func Uonal Grammar ( lrcsnan ( 198 E ) ) , Generalizcd Phrase St . r'tJcl . ur((\] rarn rnar(GPS(\])(Gazdar , Klein , Pulhlm and Sag(I985)) , iI cad Grammar ( Polard (19f1 , 1)) , and tIcad-l ) riven Phrase Structure Grammar ( lIPS (  ; ) ( Pc\]lard (1985 a . , b )) . These formal is nlsdispense wiLt , qlobal opcra-Lioitssue hast . rans for nla Lion , all d instead cxp ! oith ~ cal operations each C ' Ollf'lrled wttJ/i\[lalocal tree Such local operations ar'c for unulatcd in Lcrms of uni ~ca Lion \] Iowev cr  , L heordinary unification as in Prolog is insufficient  , seeur rorn both scientific ( here , alias lirigu Jsl , ic ) and cng in ( . ' ering poilfl ' . ? of vicw'\['he F , robh -' trl is that p , ttc\]~\[\]sLobctl\[li ( i e ( wiL\]leach other lack the cape . cityrot car-rying irf for rnaLionInL his papcrwe\[  ) rcs cnlanewm cL hod of unifica Lion which we ( call conditioned unification . The essence of the methodist . odeal wit . hpaLL crnsaimo Lated by seine sort of condit , ioils . The see on di Lioi < ls are so corts l , rain cd/-IsLo'o ecfficicntly operated on  , and yet to be able to carry rich enough in form a Liont  . oca D Lure linguistic gcneralizations . 
2. The Problem
Ordinary patterns as it/Pr(;h)gIs . el < cxprcssiv cpower , t ) es at lSCvar\[ablcs the FcirlarcSil ) i\[ ) lyil\] ( iClCl"tlliltdt ( 7 alld Ihtis car'ry almost no i r f fqrrna l ion ' l'herc for c  , stielpal L ( msaud unification among thcmar cm suffie i0nt for ' capturl ngt\]le ~ , i <' al/l r Y latical <! , > erm ' a lixatior ~ and tim process : n ~> effi ci  ( ncy . \], Ituslooka . tsome c : < amph . ~s below A ~ , , l'anl matical catc?>ory is assumed Lo be it llst of features A feature consisLs of a feature naln c and aw~hic  , and rcprcs cnLcd as at . cmn like tt ~ rn . e(vat , z() . 
'\[' hc\]cxical entry of English vcrbp'u , t , for instance , cannot . be described as a I'ro locp at Lcrn , bill needs some a rlllO-Lation(i . c . , p~ztIm . s~)s?t . ~ zmS(T , P , N )) as in (1) (1) k:xi corl(puL , Itensc('I') , p ( ms or l ( \]' ) > number ( N ) I ) : put_Lns_psnn rnb ( T , P , N ) let (? , fca LLIIC Solincr Lhanten , s e . , perso?t , and ? lattn her arc omit Led , arm predicate p~ztmtm . spsTt~z?n . bisd cfinc . dc , s in (2) For a biLm or cCOIT/I ) Ii : aL cd instance , conm dcr the rela-tionship between a synLacLic gap and iLs filler  . In GPSG , IIPSC , cte .   , tiffs relationship is ; captured in terms of the SI , ASI\[fea / . urc , which reprcs cnts gaps in the category of \] U ~ . i ~ tkiscraz U , for cxampl c , th cSI , ASII feature is spcc if lcdas\[NIj\]ller'e SI  , ASI is assumed to take as its wdue a list of catcgorn cs  . SL a Lcd below is a simpli l3cd principle about the disti'ibution of th is featqrc in I  . yptca\]cascs (3) lualocaltr'ec , Lhcrllotl ; cr catcgor/sS\] , ASI \] tea . Lure is obl . a Jncd by cone at cr ~ atir , g from h . fi\[ . Lorip , ht the SI , ASI If cat , wcs of heyd e . , . ight crsIn order to describe : this principle , s('nnetlting : u or c than anlerc patt . crntslcquir(x\]again : ( i ) IocalJr'cc . ( lslc , sh(X)\] , Ismsh(?)l , Islash(Z )\]) - append(Y , Z , X ) l ' eaturc so th cr than SI , A Slarcomitted herc . 
The socalled procedure altachm cnts is the most coln-rnonway or conllfl cln cntJnp  , the \]) oor clcscripliv ccapacM . yor ordinary patterns \[" or instance , you may regard Lhc bodies of \] h ) rnelaus ( s ( 1 ) and ( 4 ) as at la , _hed procedures The dr ' awbacl < of procedure at Lachr ~ lcnlisut the fact t  . hnt theouly way of using Lhc procc clurcs Is to execute thorn I " or t  . his reason , proecdur , sarc Irmr cly embedded lu programs , rcAhcr than at . lath ( x \] to those paL terrls which th ( scitrotu'ams operate on Theirt for rna Lion which \[  ) ro ( (durcs cantain car/rx~t  U . ' nera \]\] y be I ~ . ' , rric da FOllll da ( ross scvc ; a/partials\[rtlC\[tlI ( sci \] chOf which it pFoocc\]arc dirccl ly operates on  , bccaus c > on ccaprocc(lurciscxccnt . td , the informs . lion whk hit c . ontain c : dispalqially lost For instance , when Icxical entry (1) is cxploi Lecl , p ~ ztJ . n . spstt . n ;/ m , 6(?', I ), /\ i ) is cxecut . cd and 7' and/~arcil ~ stanliatcd Lobe preset ~ . t and Ist , ics p ( cLivc\[y'l'h'dsIc\[Lbchh~distheinformaLion a botl L the other ways Loinstan- 
Lia Lc those wwi ablcs.
Actual procedure attaclu'ncrd . smusLbearr-ar<e , ed so that inforn laton shouhl not be it ) stwhelt procedures arc cxc cutcd Freeze of Prolog  ( Colmcraucr ( 1982 ) ) , for instanc / , is amcans of tinsarr ~ ingern cnt . \]\] y exc(tll . i \ [\] g freeze(V ,  "~) , atomic formula ~ is frozen ; i . c , the exccu Llon of '~ is > - uspcnded until w ~riable X is instant tat  . cd\]f'?con-tams . '(, thcl'c for c,lop(fullyuot . sor nuch lrt for rn at . iol ~ is test . 
whcc ? is cxecuLed
N cvc . rth cless , freeze is problematic in two rcspt ( ts Virsk , irJorn\]ation cart still be lost when the frozen pro--ccdtll'CSLI Fecxccnted  . See on d , to onlt lCh illforrllatiol3 cat \] be accumulat cd whilc several procedures arc frozen Suppose  , for it lst . ance , tha L freeze IX , t ~ tet ~ ber ( . Y,\[a , 6)) and fr < , t ~ . ~<~ . ( r ,, ~ . ',~, . ~ . ,'(' . I ~' . ~ I )) have bccn execut , cd'\['herr , X and Y can be ulfif\]cd with each other witt ~ ou L a wakening ciLb cr procedure  . In that ( asc , Lhoi if for n/at , ion that X may bct ) is redundant bct wccnL hcI . wo procc dures , and Litcother part or irl for nm Li on those Droecdtlrescontain is Ill  ( Of \] " sist cit LW hat one might hope here is\[o Jrlstitntiatc  ) (  ( and Y ) to be bIf we had cxect it cd freeze ( Y , member(Y , It , cL ) irist cad of freeze(Y , rn . ernber(Y , Ib , cI ), computational in t . 
After all , it is up to a programmer to Lakea deliberate care so that information should t  ) eefficiently transmitted across patterns This causes sewral problems interwoven with one another  . First , since those programs reflect the intended order of execution  , they fad to straightforwardly capture the nni for rnit Jes captured by rules or pr inciples such as  ( 3 )  . Accordingly , programnnng takes rnuch labor ' . 
Moreover , the resulting programs work efficiently only along t  . he initially in Ler~ded order . 
3 o Conditioned Unification 3 . 1  . Conditioned Patterns These problems will be . settled if we earl attach informa-tion to patterns  , instead of attaching procedures to pro-g ramsl\[erewc consider that such informat ion is carried by some conditions on variab les Variables are then regarded as carrying some information rather than remain : - ings imply ind c term in a tcI-y a conditioned pal  . ternlet . us refer to a pair o\[a pattern and a condition on the w ~ riables contained in that pat  . -tern . l ~' or simplicity , assume LhaL the condition of a condi-tioned pattern consists of atomic formulas of Pro /og whose argument positions are filled with variables appearing mtile patt x  . ' rn , and that the pre ( h cates heading those atomic formulas are defh ~ edinl  . erms of Horn clauses . For instance , we would hkc to regard the whole tbing in (  \[ ) or ( 4 ) as a con-dJtion cd pattern . 
?3.2. Modular Conditions
The conditions in conditioned patterns must not be executed  , or the contained information would be partia lly lost Tile conditions have to be some how joined when conditioned patterns are unif ied  , so t . hat the information they contain should bet ransmitted properly in tile sense that the result-ing cond it  . ion is equivalent\[o the Logical conjunct ion of tam input renditions and contains nciCrmrrcdnndant norine on sistent informat ion  . We call sueta unification a cond it ioned unification A simple way to reduce redundancy and inconsistency in a  ( ' . on di Lion is to let each part of each possible value of each variable bes Llbj cct to at  , most one constraint . \], eLus formulate this below . We say that a condition is superficial l y modular  , when no variable appears twice in that rendit i on F or instance  ,   ( Sa ) is a superficially modular condition , whereas ( Sb , c ) are not . ( Conditions are some . 
times wr ' it terr as lists of atomic for rnu las  )   ( ' , 9 a\[a(X , Y ) , b(Z ) , a(U , v)\]b . la(X , Y ) , b(Y)\]e\[a(X , Y , X ) \] l , ' urther we say that a condition ~ I'is modular  , when all the relevant renditions are superf icially modular  , lIere , the relevant , conditions are I and the bodies of Hornc lauses reached by descending along the defini tions of the predi-cat  . es appearing in ? . A predicate is said to be modular when its de finition contains only those Iiornc lauses whose bodies are modular condit ions  . A predicate is potentially modular when it is equivalent to some modular predicate A modular condition does not  . impose two constraints on any one part . of any variable , and th crc for e contains ne>k her redundancy nor ineonsistency  , ltere a Rer we consider that the condition m (  . ' very conditioned pattern should be modu lar  . 
a . a . l ' J x pressive Power
Conditioned patterns can carry rich enough informa-tion for capturing the linguistic generality  . Obviously , at instance ,   ( I ) is regarded as a conditioned pattern with modular condition \[ pztt_g'ms_pstt~q  , r  ~ zb(T , P , N )\] . Moreover , also some recursiv c predicates are modular , as is demonstrated below . 
(6) aappcnd(\[\] , Y , Y ): append(\[UIX\] , Y , \[UIZ\]):-append(X , Y , Z ) . 
bsublist(\[\], Y).
sub\]ist(\[UI<I,\[UIY\]):-sublist(X,Y ) . 
sublJst(X , \[UIY \]) :- sublist(X , Y ) . 
Thus , (4) is also a conditioned pattern.
\] lowever , some recursive predicates are not potential l y modular  . They include reverse ( the binary predieate which is satisfied i ~rits two arguments are the reversals of each oilier  , as in reverse (\[ to t , b \] , c , all , \[ d , c , \[ ctb\]\])) ,   . perm ( L be binary predicate satisfied iff its a rguments arc permu-tat  , ions of each other , as in perm (\[ i ,  2 ,  3\] ,  \[2 ,  1 ,  3\])) , subset ( the binary predicate which obtains iff the f irst argument is a subset of the second  , as in s~zbset(\[d!b\] , to , b , c , all )) , etc . 
New . 'rtheless , t . his causes no problem regarding natural language proeessing  , because potentially in finite patterns corne up only out of features such as SLASt\[  , which do not require those nonruodular pred icates  . 
3.4. The Unifier
Shown below is a ' trace of the conditioned un ification between conditioned patter ' us  ( 7 ) and ( 8 )   ( here we use the same notation for e on dit . ioned patterns as for II or n clauses ) , where the predicates therein have been defied as in  ( 9 )  . 
(The def in i t ions of c0 and e3 are not exploited . ) First , we unif y i X , ) 2Z , g/\] and\[A ,  7\] , C , D \] with one another and get . 
X-A , Y :/3 , Z = C , and W = D\]n the environment under lifts uni fication  , the two conditions are concatenated , resulting in \[ c0(X ) , eI(Y , Z ) , e2(Z , W )\] . The major task of this conditioned unifi cation is to obtain a modular condition equivalent to this rmn-rnodular conditio rl This is tire job of funcl  . ion ~ tod ~ zlayi , ze . Mod ~ zla . ~tzerails function ~; ~ ttegrctte , which r'eLt lrns an atomic formula equi wr lent Lo the gives condition  . The Lcrminatior ~ of a ? r to dulct , ' ize or an ir ~ fegrate is indicated by ~ preced ing there Lurn-waluc  , with the same amount of indentation as the out set of this function-rail was indicated witb Whenan ~ ztegro  , tecalls a ~ zodula ~'- ize , the alphabetic identifier of the exploi ted Ilorn clause is indicated to the h  . ' fth and side , and the temporal unification to the right -hand side  . Atomic formulas made in integrate is written following  4  . Each l I or n clause entered into the definit ion is shown following % and given an alphabet ic identifier indicated to the right-hand side  . 
(7) IX , Y , Z , W\]:--e0(X ), el(Y,Z).
(8)\[A,\]~,C,D\]:-e2(C,D).
(9) e*(0,\]) . ( a)e~(q , e ) ( b ) ca(l , P ): - e : Xl') . ( c)c~(e , 0) . (d ) modularize(\[e0(X ) , cl(Y , Z ) , c2(Z , W ) \] ) integrate ( \[ e0 ( X ) \] cO ( X ) integ Pate ( \[ cl ( Y , Z ) , e2(Z , W )\]) c4(Y , Z , W ) ( a ) modularize(\[e2(1 , W )\]) Y = 0 , Z = 1 integrate ( to 2 ( 1'W ) \] ) * eS ( W )   ( c ) rnodularize ( \[ e3 ( P )  \ ]  ) W = P integrate ( \[ e3 ( P )  \ ]  ) = ~ e3 ( P ) tea ( p ) \] c ~ ( p ) :- ca ( P )  . (0=:> eS(W ) -~\[ c,~)(w)\]1' o4(o , :, w): . ~:', ~( w) . ( j ) ( b ) n : odular : ' zc(\[c2(2 , W ) i ) ? :- q ,  '/ , : ~ i : , t . o~ra~,' . (Im<3 ( aW ) \] ) * cO ( W )   ( d ) nladularizc ( lI ) w = . : o =-~\[\] cS(0)(k ) =+ c6(W ) > Ics(w)J"o , 3( q ,  ~ , w ) : o6(w ) . (I ) => c4(Y , Z , W ) ->\[ co(x ) , <:4(<z , W)l We CaN refine Lhe progra\]'no\["btt ~ . grcs , ta so that it should avoidally predica Lewiose defini Lioncoiu Lains only onellorn clause  . For instance , Lhe defini Lion of cb cons is Ls only o\[ ( i ) InsLead of ( j )  , Lhere R ) re , we may rove cd (0 ,  1 , P ): c3(P ) Also(1) can bc replaced by c4 (0 ,  2> 0) , based on ( k ) We areable Lo work out r'ccursiv ccondiL ions from F  , lvor ; recursiv ccoI : dit . iolls , l Vor example , consid or how X and Zar cunifiod under " t , haconclit , iol : (10) , whore ~ rte ' n ~ be . r is defined as in (11) (10)\ [ n , e:n her(X , Y ) , o0(z)\](11) n/cinber(A , IAIIJl ) . ( a ) member ( A , ICI i ~ i ) : - i . . . . . . . her(A , it ) ( b ) The Lracc of this ulfif\]cat . k ~ n is show l ~ b('\]:'w , whc's'c prcdica . l ~' c1 is rccursiv cly ( \] o/~ll/Cd based on Lhci' (  , ctlrsiv (! dcfill JLioH of 77"~(?77 , t)I ~ , ?' modularizc(lmcmbcr(X , Y ) , cO(X)I ) in t . cgraLo(Imember(X , Y ) , cO(X)\]) , el(X , Y ) ( a ) modularize(\[cO(A)\])X = A , V - . \[AIll\]int . e<~' ; ratc ( IcO ( A ) I ) => oO ( A )  =~ 1 <: ) ( A ) \]1' cI ( A , \[AI~<J ) : -- c0 ( A )   ( 1 ) ) n : odu lar i zc ( lmcn , bcr(A ,  11) , c0(A ) l ) X : : A , Y : :\[ c ! i ; IJ nl . c<qral . e(\[nlernbcr(A , I ~) , cO(A)I ) : ~ el(A , 1 ~) : :>\[ cl(A , 33) 11'ci(A , I clt < l ) : c ~( A ,  13) . 
...> c : ( X,Y ) : . ~\ [ o : ( x,Y)I
ILJs a job of in , tegra , te , Lohandlere , cursive de , hiLton . The lasLg ? l , te . g ?, ts , te . above recognizes Lhat . the first 4m . tegrate , which is Lrying Lo(\]c Nr/cc1 , was called wit . h the same argu-IT l C r l I . S except , the variable narnes , llen cct . he last " in ttegrct te simply re Lul'nsc . I(A , H ) , because t , hcconLent , or clisnow bring worked ou Ltlrl do YLhcJ'\ ] rsl  . ~? ttegro . tear id thus it is rednndanLfol't , helas L~t fegrate Lo\[urLhcrexaminec1 . 
It is not . a \] ways possible fro ' the above unifier t  . ~ unifypa LL(2i "\[/ stlrl(\](~rroc . tlr'sivoCol\]d\[Liol/S\["orJ//sLalloL ' , J\[Cf/ill IO Lunify X with ) " under\[appe~td . ( X , Y , Z )\] , becal_ts cL he resulting condi Lion is no L pots nLia \]\] yrnodular  , llowcver , such as itua Liol'l CtOCS FioLseolnt . ooccur Jnactual\[al:g:lagc proccss-ir:g . 
4. Conclusiori
We have prc . ' - ~ er , Leda newnle/hoda\[umfiealion , wh , chwccallo . coildi Lior ~ c(\]tltti ( loa Lioli , Whcl'epaLL or ils to be uniPlc ( \]"' reanno Laked by a certain sort . of corld it . ions on lhevariables wifichoctroi " ill those patt  . crn . <; . The socondi Lions ares or ' est . ricted t . ha LL hey conlain as lit . Lie redundancy a <'; possible , and d'ms arc always assured to be satisf iable  . 
This method has Lhefo/h ) wtng welcome characteristics l " h's t , I . he\] ) attorns to b cunified can carry at ) llllda\]'lL infos'mat . i on rcprcs cnLcd by t . he condition shan :, ~ in !,; on t . h Clll The expressive capacity of L he , < ? condi Lion , sissl:fl'Jcen\[forcap-t . uring \] JH ~ U , IIih LJ (: ~ sCHCl'a\]i' , ,iOS ~ ccor ld , such irf format . ion is cf reclivcly Ir ' ansr nitLed , by h~t . egrat . \ [ n ? the col~dil , ion . ~v ; her , pat . ' . .crl:,<s o . roun if ' ied Unlike procedure a LL acl : ment . s , in thil ~ COllne (: lion , Ll/cinforn Ga Lioi ~- conveying < . 'fficicl:cy of our Coltdilioi oi oi oi oi oi ue dun if ' i cat . \[ on is no afl'c'(gcd by the direct . io noft . i ~ c da La . flowTherefore,O/ll"col'l(\]lioned unifies . Lionisoo ; rn-plel/lyr(ver's Jbk < and ' , hnsis\[n'on:ising its aLos \] for dcscril ) h'T><~l'all/lllilrsfOF bolhSCllL ( Hb ': C comprel/ensiol : slid prochl ( d tollOwing t . oL hese cllar ' act(!risLics , Otll conditioned unif'ca Lianl ) r ' avhesa now prog , ra . unniiug1 . 1aradigtnfoiI/illt/l'/tllar/y,/lag( . "\[) l ' OCCSSil/lJ > , r cph ~ . cing proccd/1F caLt , o . ctl-I3:ont . s which haw3tradl Lionally el2 joye di . \] lcLlbiq/lityLhat . 
t.hcy do no L descrvc
Rcfer'cnees
Brc . ~nan,J(cd ) (1, 98~) Th,a Me~ztalife prese . ?l , tat ~ . o~l,uf()rcv,>n?n:l . /'/, ctz/,/fetc# . /'~o?l . s,MI'P Press,C0 . rnbF id Fc , Mas-sa(htme Lt . sColnmraucr , A . (198g ) I'roLog11\] fefere ~ a , ceMc ~ . mt~ . f . o . n . d 77 t , eoretical . Model , I !' , IACNRS\[163 , Grouped ' In Lellig cnceArti ~ ciclh: , Univ crsit . L'dc Marseille , Marselle . 
( b:zdar , G , E . Klein , C , K . Puhlm , and \] A % ag(198'0) Ca'e'Kl rercllized . \[-' h , rase St , ru , ct ~ zre . (,)' omzmct ~', Hasil I ~ lackwcll,

Kay , M ( 1985 ) "\] bwsing in\]"unctiona/l\]nffk: ation  ( h'am . 
nlar , " Ncs , t~x . rat / , csm , g  ~ zaga/J ~ s , rs ' Otg , pp 251278 , C , ,anl bri<t<e>e 1 . Jldversi/y Press , Cambridge , \]' hl<q \] and l Jereira , I " ,  (; . N(198'o ) " ASI . rllettlse-~harJrLt~\]&'pr'es cnta-tiou for Unif\ ] caLiol!\[~ascd  (   ; roml/lar J " or rua \] isi'ns , ' I : ~' occerecl , 7\]7) , ( JS of th . e . iT <' h'c/ . All . Tt % czl , Mee?'i , ?) , \[\] of the AssQcI , u , tio T i , for O ) Trtp 7 l . tcs . i; , io?) , ? l\[ , q , 'n , g~zgstT , c&L Jnlversity of Cluca . go , (; hic ~, fV ), Illinois . 
Pollard , CJ (198, 1) Ce~i . eral'i , zed/Jh , rq , meh'trizct ~ zre . O'q . ~Y, . 
? m . ar,/lead(#'tl . ~zT)wt . rs , cz~rl , Nahl . r a , f , Lmtg ~ x . u . ges , \]) oc . '-1 oraldi . '-;sertat . ion, . < ' g t . anford / . Jlli V Crsi Lv , SL alq for d , Caifornia I ' ollard , (7J . (198 ha)l,~cDzre N~te . ~ mi . ttead-Driv cm . \] qu'cs , se ~' ~? ' ttc ~\ [ l / . '/' ck(,~Przt7%Tn , u . ?', (\](? il . ( ~ l ' for I\]V : Sitldy of l , atly tlag c and \[ n for I/M tti Ol LPollard , C < J(l ) ~) b ) "\[ qn'aseS\[ . l ' llcLtlFe(\]ralnmar ~4 , 1L hotl LMotaltll(s , "\] Troceeel . 'n . gsOfth,7l7)l/,rfh,Ig:eS,t ( . ' OU . : ~ t('n ~ tfe're . " n , ceo'n , \]<' or ? ~ csl/ , zlU/~z'L < ~' Zt , cs , I . Jtlivcr , ' siLy of Lgouthern California , LosAr:gelc . s,Ca/ifort/is\])roudin,I ) and C . JPollard(\]gfk )) " Pal' . <; in gll cad Driven IJi/i <' as ( St . iu . lct . Hro(b ' alnn/ar , "/5" ocee U . i ? Ws of H ~ . e2,' rcl,A?t?ttDcd,Mc . .r;f'/,'n . g of : , h , eAS . S'OC? . a . ~'/, O?Z for CoT ~ tplx , ~ ci , tmor ~ z/ . 
/ittgw , Tlslic . s , Jniversi Lyof Chicago , Chicago , Illinois . 
Shiebcr , SM(198 , t)"TheI)csi?n of a('omputerI , ar/guage for I , in , o::i:-;I . ich : folrtw . Lion , "/ Xrsc ~ eel'i ? tcj . ~ cJfti ?: . 7Of , h , l ? ~, ter?m , ~ io?ta . tL?mfere ~? . ceo'n . Co?n . pw . ta . tio ? w*l\[mWu , 3, sif . on , SL anfovdUr~i , : ersiLy , Stratford , C . alJfornia Shiel > ci , SM(198b)-b':-dn<qrrml vict : <'> nt . oI '; xlcnd\[JarsillgAIF or it . hlusfor (7 onlp\]cx-Feal . tlre-Based \]' or nlalisms , " lS " cceecli'n , < j s ~ f th . e23 rclAl ), n , lm . 1 . Mee/b : Tt . q f ) f t l i , e . Assoczo , tzo ?, . , fnr ( . ' e ~? A plztu , tiottat / , 7, t ~, g n . i , sti , cs , Umwn'sil . yo\[Ch / (: ago , (; llJca/;o , Illinois
