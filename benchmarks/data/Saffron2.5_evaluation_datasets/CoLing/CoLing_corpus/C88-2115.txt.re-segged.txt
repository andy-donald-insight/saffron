Machine Translation : The Languages Network
( versus the intermediate language.)
P . C . ROLF
Dpt . of Computational Linguistics
Literary Faculty
Nijmegen University
NL 6500 HD Nijmegen
The Netherlands

Jonathan Slocmn/Slocum ,   1985/ divides MT techniques from a linguistic point of view into three two-way perspectives which are not quite disjunct : " direct versus indirect  ; interlingua versus transfer ; and local versus global scope . " . 
in this paper we present a research paradigm which  , in fact , does not exactly match any of these perspectives : The Languages Network  . 
In this paradigm each pair of languages will he treated as within a transfer application hut with t be characteristics of indirect translation : analysis of the source language and synthesis of the target language are not totally dependent on each other  . 
The proees must be split up into a large number of pieces which can be connected into a huge network performing MT from and into several languages  . 
hnplementations of this paradigm are ) eing carried out by the author hymeans of the translator generator SYGMART  ( see/Chauch6/ , /Chauch ~ , 1974/ and/Rolf ,  1985/) , which pernfits the linguist to implement whatever he wants in the field of MT in an efficient way on a wide range of computers  ( t?om Atari1040 STf via SUN's to IBM
VM/CMS main frames).
1The goal of the intermediate language.
In discussions on translation systems , the question is often asked whether the system is based on directranslation  , whether it works according to he transfer method  , or whether it uses an intermediate language . "\[' his question suggests that translation systems can he defined exactly by dividing them into these three categories  . 
It is our conviction that solving problems in translation is more complex than is suggested by this question  . In this paper we will show precisely where this question is inadequate  , by looking at some aspects of the translation process  . 
1.1 Why an intermediate language ?
The idea which leads to the definition of an intermediate language originates from the wish that  , in translation from one source language into several target languages  , no completely different ransla-tion should have to he made for each pair of languages  . 
Brandt Corstius/Brandt Corstius , 1978/expresses this idea as follows ( the citation has been translated from Dutch into English  ) : " Instead of making 90 programs in order to translate ten languages into one another  ( from each language into each of the nine others )  , it would be sufficient to have 20 translation programs ( from each language into Maehinish , and fi'om Machinish into each of the languages ) . It is even conceivable that eighteen progrmns would be sufficient  , if one of the ten languages i given the role of this intermediate language  . " This standpoint implies an " efficient " method in terms of the amount of work  , without indicating whether this method solves also any principal problems with respect o machine translation  . 
On the contrary , Brandt Corstius remains ceptical about this . 
1.2 What shall be defined ?
Ideally the intermediate language will have to be an unambiguous representation f the meaning of  ( each of ) the source language ( s )  . 

This implies that a language should be found in which it is possible to represent all possihle meanings in an unanfl  ) iguous way . 
If Brandt Corstius is followed in this , then in the translation h'om and into natural anguage this would have to he one of the natural languages  . But one of the main characteristics of natural anguage is precisely that it is efficient  , which implies that with few words and constructions a lot can be expressed in very many different circumstances  . 
The way in which each individual natural hulguage is et Flcient differs from language to hmguage : ambiguities and vagueness in a source language cannot usually be projected in a one-to-one col ' respondenee onto a target language  . 
So it would seem to be not entirely plausihle to select an intermediate language from the languages to he translated  , seeing that tt ~ demand of unambiguity is too heavy precisely for natural anguage  . 
An intermediate language should not only be unaml ) iguous , hut it should also be able to represent all possible meanings  . We , are convinced that for every sentence of a natural anguage an imfinite set of meanings is possible  , since meaning depends on the universe of discourse and the set of possible universes of discourse is infinitely large  . 
All in all there is enough cause for a fundamental pproach to the prohlem : what is to be achieved in defining an intermediate language in the macl fine translation of a set of natural languages from and into each of themenfl  ) ers of that set ? The need for an intermediate language originates  , on the one hand , from the idea that the analysis of a source language will be largely the same  , irrespective of the target language into wieh it is to be translated  , and on the other hand , from the need to analyse the source language in such a way that all ambiguities have been solved  , and that therefore the generation of the target language can take place without any further prohtems  . 
With respect o the former , we , too , believe that the idea that the analysis of a source language is partly the same  , irrespective of the selected target language , is entirely correct . 
When we plot the translation process on a line from source language to target language  , this will be the part which is close to the source language : to put it in rather more linguistic terms : the morphological analysis and that part of the other syntactic analysis that can be smmned up in the term surface grammar  , so in any case the NP and VP detection , for instance . We shall return to this below . 
The second need , viz . completely disambiguating the source language , would seem to be too heavy a demand , as was formulated before , with reference to ~ all possible universes of discourse '  . The two needs that have been mentioned cannot be fulfilled  , but it can be maintained that there is no need for the entire analysis of the source language and the entire generation of the target language to be done over and over again for every pair of languages  . It has to be deternfined what the two paths , analysis and generation , will look like . Parts of these two paths will renmin the stone , for the source language irrespective of the target language  , and for the target language irrespective of the source language  . 
2 The analysis of the source language.
Since there is no reason to adopt an intermediate language as has been argued  , the problem facing us is the analysis of the source language  , as well as the generation of the target language and the process between analysis and generation  , which will be discussed in the following two sections  . 
The point of departure for both these sections , and , in fact , for this paper is the hypothesis that t be meaning of the source language depends on the objective one has in mind  . In the case of machine translation the meaning , expressed in the translation , depends on the target language defined . 
In this lineot arguing translating i . ' ~ therefore always a matter of a specific relat : ionship between two lauguages  . When we plot the process of translation on a line  , however ~ we can distinguis b three phases , which can he referred to as analysis , translation and generation . The present and the next following two sections have been divided on the basis of this principle  . 
2.1 What is analysis ?
The analysis or a source language can be defined , in a very abstract way ~ as the addition of information to the input  . It may seem trivial , but this st ; u ' ting point implies that no information must be lost in the analysing stage  , lnlbrmation may only be added . This also implies that the input order must not be changed  . So , in our view , a dependency grammar is not suitable for the analysis because of the loss of the input order  . 
Changes in the input order can only be brought about on the basis of requirements posed by the target langnage  . 
This brings us to a second aspect of the analysing stage : in this stage only source language inherent data are worked with  , to be subdivided into static ( lexical ) and dynaufic ( granmmtical ) data . 
\]' he fact that in : he analysing stage solely data inherent to the source language are used  , does not mean that the target language has not b ~ ing to do with the nature of the analysis  . That would clash with our starting point , viz . that the meaning of the source language depends on the target language  . 
The influence of the ( set of ) target language ( s ) extends over the way it1 which the analysis is carried out , in other words , what type of information has to be added to the text of the source language  . 
Let us take , by way of example , the translation Dutch-English . We will assume ( for convenienee's sake ) that in Dutch the word order in sube lauses iS ( ubject ) -O ( bject ) -V ( erb )  , while in English the standard word order in subclauses iS  ( ubject ) -V ( erh ) -O ( bject )  . 
The change fr ( )m S-O-V into S-V-O does not belong to the analysing stage of Dutch  , lbrit implies lnss of infornmtiou because of the word order c bange  . ~\] owever , the translation i to English requires fron ~ the analysing stage of Dutch that  , among other things , the categories S~0 and V area ~; signed . The assignment of S and 0 implies that NP's have to be ibn : od , etc . 
The analysing stage comprises all stages which belong to morphofogy ~ surface grammar and possibly a large number of matters that belong to the field of semazatic nter pretation  ( see/Bakel ,  1984/) . 
This last category , semantic interpretation , is close to the translation stage and will possibly be different for groups of target languages  . 
in the section headed ' Prospect'we will indicate schematically how this semantic interpretation has to be situated in the whole of the translation process  . 
2.2 Algorithmic consequences.
.~ ; tarting ii ' om the assumption that the addition of information  ( committing abstractions ) is brought about , anmng other things , by the application of some sort of dependency structure  , what is needed is a form of graphic representation  . 
For many languages , and certainly also for Dutch , the traditional tree structure clashes with our demand formulated earlier  , that information should be retained : the original word order nmst benmintained during the an Mysing stage  .   ( In Dutch a postmodifier in an NP is often extraposed  , e . g . " Ikhebdenmn gezienmet debril . "\]? ans-\[ated word by word : " I have the man seen with the spectacles  . ") \] , hn'ther more linguists should have the possibility of expressing linguistic notions in a way which is adequate to them  . For this purpose a distinction has been made , in the SYGMART system , between the morphololgical nalys is , which operates on words ( the subsystem OPALE ) and a tree transformational prt ( the subsystem TELESI )  , whicilol ) eral . es on nndti-dimensional trees over text ( s )   ( the notion sentence does not exist in SYGMART )  . 
The surface greml mar and the semantic interpretation cannot here-for ebe algorithmically distinguished  . 
This multi--dimensionality enat ) les the linguist to establish relationships between sentence constituents which are far apart  , without having to extract them out of their original order  . This multidimensionality has to be looked upon as ' the definition of graphs more complex than trees overt be input  . For a more detailed discus . 
sion of them nlt l-dimension Mity the reader is referred  to/Chauch6  ,  1984/ . 
Our arguulents for not using the traditional grmm natical types are given in / Roll  ,  1986/ . Part of the analysis of Dutch is shown in
Appendix A.
3 The t'eans lation.
The translation stage is the stage between the source language inherent analysis and the target language inherent generation  . This stage can be roughly compared to a transfer component  , as suggested in the beginning of section / . 
Two features arc characteristic for the translation  , viz . word order change and the addition of target language features  . 
Word order change ( s )   ( better : conlpouent or category n lovement ) is ( are ) not per definition carried out separately for all possible target languages  . If in the example of the word order change in subclauses  , presented in the previouse clion , the rule SOV --- ) SVO has to beal ) plied to a subset of the target languages , tb is can be done t br the entire sul ) set prior to the introduction of target language specific features  . 
This introduction of target language specific features is clone by the lexical translation  , or the translation of the words . We will assume here that the analysing stage has provided all the necessary information to gel : the correct ranslation for every word  . 
Because of the information added in the analysing stage the correct translation of a word implies the translation of a complex datastrut-'ture into another complex data structure  , in which the written base for in in both cases is hut one w due of that data structnre  . 
On the basis of information that comes in after the lexical translation  , further word or . der changes will generally have to take place , as well as the generation of grannnatical structures  . 
A simple exaulple in this connection is the folh ) wiug : the I ) utr hver bh lijven is translated into English keel  )   , but in Dutch blijven is completed by an infinitive  ( bll jven wach ten )  , whereas in English a gerund is expected ( keep waiting )  . 
If on the basis of the new lexical information further grann natieal rules have to be applied  , such as nmving the verb in the gerund con-strut ( ion ( Dutch " ikblljfophemwaehten " into Englisb " l keep waiting for hiln '  )  , these rules also belong to the translation stage , not to the generation stage , unless the rules apply to all possible source languages with respectoEnglish  . 
As in the previou section , here , too , the demand made of the algorithmic procedures and the possibility of building and manipulating conlptex data structures is heavier than in traditional gramlnatical types  . Within SYGMART the subsystem TELESI is used for the translation stage  , which does not imply that for each pair of languages a separate TELESI implementation has to be made after all : SYGMART provides for the application of different TELES Igram--narsone after another  . 
4 The generation of the target language.
1 5-om the previou sections it has already be conle apparent that the generation of the target language does not come into play  , until only target language inhdrent matters are at issues matters which holdir respective of the source language that is used  . 
They are in artycase all matters of a morphological nature which in the entire translation process are the last to be dealt with  . In the translator generator SYGMART the generating morphology is treated by the sul  ) systen )   . AGATE . 

If there are grammatical rules which also have to be applied independently of the source language  , they also belong to the generating stage , in our setup . These rules will not be many , for that would imply that in a target lauguage certain constructions should occur for which in no  ( source ) language an analogous constrnction was to be found  . 
In our setup the technical three-way division of SYGMART  ( OPA-LE , string into tree , TELES I tree into tree via network , AGATE , tree into string ) cannot be measured in a one-to-one correspondence onto the three-way division of the translation process  , viz . analyses , Irans-lation and generation . The morphological nalys is always takes place in OPALE and is a  , rather small , part of the entire analysis . The greatest part of the analysis , consequently , takes place in TELES1 . 
Everytlfing belonging to the translation hapI ) ens in TELESI . As far as the generation is concerned , a small part is possibly carried out in TELESI , but the morphological generation , aturally , takes place in AGATE . 
5 Prospect : The Languages Network.
From the foregoing it can be deduced that as far as we are concerned the question formulated in the beginning disregards the complexity of the translation of natural language from and into one another  . In general the analysis of the source language is the most important component : once the analysis has been carried out on all possible levels in all possible details  , generating the target language is ' relatively ' siml  ) le : at that stage word meanings have , of course , been disambiguated , semantic interpretation have been assigned , references have been determined , etc . , but all this has been done in relation to the meaning  , viz . the translation . 
Seeing that we analyse on the basis of the requirements of the target language  , analysis is only partly an unambiguous notion : not all the abstractions will be equal for all the target languages  , nor will they be required for all the target languages  . 
If for each pair of languages the entire process is plotted on a line from source language to target language  , it will be possible to point to a number of points on that line  , where analyses will go into different directions ( depending on the subset of target languages ) and Where translati6ns and generations merge . These lines together form the languages network . 
On the hasis of such a network it will be possible  , in the future , to formulate relationships with reference to the affinity of languages mutually  . This may sound speculative , but we are convinced that what has been presented cannot be reduced to the definition of a single intermediate language  , unless it is done for subsets of natural languages which have been defined precisely  . Our objections ? to this are formulated in/Roll ' ,  1986/ . 
/6 References.
\[Chauehd , 1982\]
Chauchd , J . , V . Cheboldaeff , R . Leseoeur , M . Jatteau , R apport deprd sentation du project relat if b l'6crlture desspecifications d ' unsyst$mede tradnct lonassist de parordinateur  , SLIGOS , Conseil , assistenee etrdalisations , produits informatiques , services degestion , Avril 1982 . 
\[Chauclff , 1984\]
Chaueh ~, J . ,Un outil multidimensionnel de l'analyse du discours  , in : Proceedings of Coling 84 , Stanford University , California , pp .  11 - 15, 1984 . 
\[L and sbergen , 1982\]
Landsbergen , J . Machine Translation based on logically ? isomorphic Montague grammars  , in : Horecky , J . ( ed . ) , COLING 82 , pp 175-182 , North-Holl and Amsterdam ,  1982 , \[L and sbergcn , 1984\] Landsbergen , Jan , Isomorphic Grammars and their use in the Rosetta Translation System  , Pbilips Research Laboratories Eind hoven-the Netherlands  ,   ( presented at the Tutorial on Machine Translation , 
April 2-6, 1984, Lngano ), 1984.
\[Rolf , 1983\]
Rolf , P . C . , Vertalen van getalsnamen , Verslagen Computerlingu ~' stiek
No . 3-1983, KU Nijmegen.
\[Roll , 1985\]
Rolf , P . C . , Beschrljving van het vertaalsysteem SYGMART , versie 4 , intern verslag KUN ij megen ,  1985 . 
\[Rolf , 1986\]
Rolf , P . C . and J . Chaucht 4 , Machine Translation and the SYGMART system . , in : Computers and the Hmnanities , 1986, Vol . 20, no 4, pp 283-288 . 
\[Slocum , 1985\]
Slocum , Jonathan , A Survey of Machine Translation : its History , Current Status , and Future Prospects . in : Computational Linguistics , Vol 11 , Number 1 , January-March 1985 . 
\[Witkam , 1983\]
Witkam , A . P . M . , Distributed Language Translation , Feasibility Study of a Multilingual Facility for Videotex Information Networks  , BSO , 
Utrecht , 1983.
A An example of the analysis of Dutch.
The following is an extract of a running implementation fapart of the analysis of Dutch in the SYGMART system  . It can be regarded as one of the nodes in the proposed Languages Network  . 
This node constitutes a network in itself , with four possibl entry points , e haracterised by "& ENTREE : " , and several end nodes , e haraeterised by "-->% STOP . ' . 
\[Brandt Corstius , 1978\]
Brandtcorstius , H , Computer-Taalkunde , Muiderberg ,  1078 . 
\[ Bakel , 1984\]
Bakel , Janvan , Automatic Semantic Interpretation , For is
Publications , Dordreeht , 1984.
\[Barr , 1981\]
Barr , Avron and Edwarda . Feigenbanm , The Handbook of Artificial
Intelligence , Stanford , 1981, VoI . L\[Chauchd , 1974\] Chauchd , Jacques , ' Prans ducteurs 8z Arbor escences , Etudes etr ~ alisations de syst ~ mes appliqu ~ es aux grammaires transformationnelles  , Thbsed ' Et at , Grenoble ,  1974 . 

Chauchdl J . , Systb . medemanipulations algorithmique set r6cursives detexte , SYGMART , Labotatoire detraitement del ' information , Le Havre , France . 

/* Basis grammatica's*/"&GRAH:NP(E).
FINDKERN : 0 ( 1 ( *  )   )  / 1:  ( ( NRDS00RT=SUBST ) I ( PRON=PERS ) )& ( CATEGORY '= NCKERN ) => x ( Y ( 1 )   ) / x : ( CATEGORY = NBAR )   ; 
Y : ( CATEGORY = NCKERN).
FINAPQP 2:0 ( I(2) ,  *  , 3)/2:(NRDSOORT=ADJ)I(NRDS00RT=TELW) ; 3: CATBGORY = ~ BAR => X(*O < , 1>* , Y(l(2) , *3< , >*) , *O<3 , >*)
X : 0;
Y : 3; 1: I(SUBCAT(2)).

RESTADJ : 0(1(2(0)) ,  *  , 3(4))/2:WRDSOORT=ADJ ; 3: CATEGORY = NBAR ; 4: CAYEGORY = AP => X(*O < , l>* , Y(Z(2 , *4< , >*) , *3<4 , >*) , *O<3 , >*) /
X : 0;
Y : 3;
Z : 4.
FINDEOPI : 0(1(2) , * , 3)/2:(WRDSOORT=LIDW)I(WRDEOORT=TELW)
LOCDE~PI(0,2,3) => X(*O <, l >*, Y(l(2), 3), * O < 3, >*)/
X : 0;
Y : ( KENCAT (3)); 1: I(KENCAT(2)).
RESDEQPI : 0(%1(Z2),*,3(4))/
O : ( Vt\]RM='SENTENCE ***** ~ ) I ( VORM='BIJZIN*****' ) I ( CATEGORY = PVWWCL )  ; 2: ( NRDSOORT '= LIDW)&(WRDSOORT '= TELW)/
CATRES(3,4)=>X(*O <, I >*, ZI(Z2), ?(3(4)), * O < 3, >*)/
X : 0;
Y : ( KENCAT (3)).
ONLYAD 3:0(1(2(*)))/
O : ( VORM='SENTENCE *****' ) I ( VORH='BIJZIN*****' ) I ( CATEGORY = PVNNCL )  ; 1: CATEGORY '= AP ; 2: WRDSODRT = ADJ => X(*O < , I>* , Y(I(2) , KERN(EMPT)) , * O<I , >*) /
X : O;
Y : ( CATEGORY = NBAR ); 1: I(SUBCAT(2));
KERN : ( CATEGORY = NCKERN).

&GRAM:NPCONS(E).
PREPCON : 0(1(2) , * , 3)/2:NRDSOORT=PREP ; 2: CATEGORY=NP=>X(*O< , l>* , Y(2 , 3) , *O<3 , >*) /
X : 0;
Y :* PkEP .
-.-> ~ NUL.
~GRAM:WWCI . US(E).
FINDWWCL:TOP(I , *, 2)/
TOP:VORM='SENTENCE *****' ;1:(WERKW'=WERKN . -> O ) &( WERKW '= PV )& ( WERKW '= PV\[IMPERAT) ;  2:  ( WERKW ^= WERKW->O ) a ( WERKW'=PV ) ~ ( WERKW^=PV\]IMPERAT ) 
WWCL(I , 2) => NEWTOP(*TOP < , I>* , NEW(1 , 2) , *TOP<2 , >*) /
NEWTOP:TOP;
NEW : ( CATEGORY = WWCL ; VERBUM=VERBUM(1)) ; 2: ( KENWW(I , 2)) . 
FIBYP VCL:TOP ( I , *, 2)/
TOP:VORM='SENTENCE ***** ~ ; 1: ( WERKW ~>= PV ) ; 2: ( WERKW '= WERKW -> O)/
PVWWCL(1 , 2) => NEWTOP(*TOP < , I>* , NEW(1 , 2) , *TOP<2 , >*)
NEWTOP:TOP ; 1:I(WERKW:PV);
NEW : * PVWWCL ; 2: ( KENWW(I , 2)).
FBYP VCI , 2:TOP(2,*,I)/
TOP:VORM='SENTENCE *****';
I : ( WERKW ~>= PV ) ; 2: ( WERKW '= WERKW -> O ) & ( CATEGOR ?'= WWCL)
PVWWCL(1 , 2) => NEWTOP(*TOP < , 2>* , NEW(2 , 1) , *TfP<I , >*)
NEWTOP ; TOP ; 1:I(WEREW = PV);
NEW : * PVWWCL ; 2: ( EENWW(I , 2)).
FINDP VCL:TOP ( I , 2)/
TOP:VORM='SENTENCE *****';
I:(WERKW ~>= PV ); 2: ( WERKW ~= WERKW->O)/
PVWWCL(I , 2) => NEWTOP(*TOP < , I>* , NEW(1 , *TDP<I , 2>* , 2) , *TDP<2 , >*) /
NEWTOP:TOP ; 1:I(WERKW=PV);
NEW : * PVWWCL ; 2: ( KENWW(I , 2)).
FINDPV:TOP (1)/
TOP:VORM='NENTENCE *****' ; 1: ( WERKW ?>= PV ) => NEWTOP(*TDP < , I>* , NEW(NEWI(1)) , * TOP < I , >*) /
NEWTOP:TOP;
NEW : ( CATEGORY = PV);
NEWt : ( WERKW = PV ; <(VERBSORT(1)'~>=COPULA):VERBSORT=ZELFST #
VERBSORT=COPULA >).

hGRAM:BYZIN(E).
BYZBEG : TOP (*)/
TOP : ( PRON = RELPRON ) I ( VOEGWRD=ON DER ) => NEWTOP ( NEWR ( TSP ) ) / NEWTOP : ( VORM='BIJZIN ****' ; P~ON=PRON(TOP)) . 
BYZREST : 0 ( I(2) , * , 3)/2:VORM='BIJZIN ****' ;  3:  ( CATEGORY '= WWCL ) k ( CATEGORY'=PVWWCL ) ~ ( CATEGORY '= PV ) :> NEW TDP ( *O< , 1>* , I(NEW2(*2< , >* , 3)) , *O<3 , >*) /
NEWTOP : O;
NEW 2:2.
BYZEND : 0(1(2) , *  , 3)/2:VflRH='BIJZIN ****' ;  3:  ( CATEGORY = PV ) i ( CATEGORY=PVWWCL ) i ( CATEGDRY : WWCL ) => NEWTOP ( *O< , I>* , I(NEW2(*2< , >* , 3)) , *9<3 , >*)
NEWTOP : O;
NEW 2:2.
RELBYNP:TOP(I , * , 3(4))/1:CATEGORY = NP ;  4:  ( VORM='BIJZIN ****' ) h ( PItON = RELPRUN ) => NEWTOP ( *TOP< , I>* , I(3(4)) , *TOP<3 , >*) /
NENTOP:TOP.
--> ZNUL.
a ENTREE : TELWRD(1).
DELTIGEN : 0(1(*) ,  *  , 2  ( *  )   )  / 2:  ( ( VORM='tig' ) \[ ( VORH = ' on ' ) ) :> o ( 1 ) I
I:I(<VORH(2):'tig':SOORT=SOORT(2)>).
KEERSM : 0(1(*) ,  *  , 2(*))/1:SOORT:EENHEID ; 2: SOORT=TIENTAL=>0(2 , 1)  . 
DEL_ENHO : 0(1(*) ,  *  , 2 (* )  ,  *  , 3(*))/i:(SOORT=DUIZTAL ) ; 2: ( SDORT = EENHEID ) ; 3: ( SOORT = HONDTAL ) => 0 (1 , 2)/3:3(REPR=REPR(2)) . 
VULOP : 0(1(*), *,2(*))/
O : ( WRDSDORT = TELW)/
AANW(I , 2) = >0(1, 2, 2) 3: ( KENTEL(J)).
VULAAN : 0(1(*) , *  )  / 1:  ( SOORT : DUIZTAL ) I ( SOORT=HONDTAL ) I ( SOORT = TIENTAL ) : > o ( 1 , 2)/2: ( KENTEL(1)) . 

DEL_DU(*(*);O(2)):0(1(*),*,2(*))/
I : ( SOORT = EENEEID ) I(SOORT=COMBI) ;  2:  ( SOORT = DUIZTAL ) J ( SOORT = HONDTAL )  => 0 ( 2 )  / 2: 2 ( REPR=REPR ( 1 ) ) . 
--> ~ ST fP .
a ENTREE : ENGTLWD(I).
TranstelSHLT ( Transtel ) : blad ( * ) / blad: ( TRANS = TRANS->O ) => blad/blad:blad ( TRANS=TRANS ( DICT ( * ) ) )  . 
CENGORD : O(een (*) , * , en(*) , * , tien(*) , * , tig(*))een:SODRT = EENHEID ; on : VORH='en' ; tien:(S00RT = TIENTAL )) ( SDDRT = EENEEID ) ; tig:VORH = ' tig ' => O(tien , tig , een) . 
__>ZSTOP .






--> ~ STOP.
& GRAM:HOUDOP(E).
--> ZSTOP.
/* Netwer kvangrammatica'S*/&ENTREE:SEPARATE ( 1 )  . 
ONBEKEND(*(*) ; O ( 1 ) )$TRF ( HDUDOP ) : 0 ( 1 ) /i : DICT ~> = ONBEKEND = > 0 ( 1 )  . 
LEESTSHLT(ONBEKEND ) : 1(2(4(*) , * , 3(*)))/3:LEEST-=LEEST->O=>NEWl(*I < , 2>* , 4) , NEW2(3 , *l<2 , >*) /
NEWI:I.
LEEST2 $ ELT(ONBEKEND ) : 1(2(4(*) , * , 3(*)))/4:LEEST'=LEEST->O=>NEW1(*1< , 2>* , 4) , NEW2(3 , *1<2 , >*) /
NEW 1:1.

O(1(P1),2 ( P2))/
PI:LEEST = EOSENT;
P2: LEEST = EOSENT => Y(*O< , I>* , 1(P1) , X(*O<I , 2>* , 2(P2)) , *O<2 , >*) /
X : ( VORM='SENTENCE *****');
Y : O.
SPLITOP$HLT:O(I(P ))/
P:LEEST=EOSENT=>Y(X(*O <, I>e,I(P )), * O<I , >*)/
Y : O;
X : ( VORM='SENTENCE *****').
--> PREPROC.
&ENTREE : PREPROC(U , PREPROC , PREPROC).
WW2(*(*); O(2)):0(1(3(2(*))))/
O:VORM='SENTENCE *****';
I : WRDSOORT = WRDSOORT->O ; 2: WRDSOORT=VERB=>0 ( 1 ( 3 ( 2 ) ) ) /1:I ( VERBUM=VERBUM ( 2 ) ) . 

WW l (*(*); l(2)):1 (2(*))/
I:WRDSBORT:WRDSOORT->O ; 2: WRDSOORT = VERB => i(2)/
I : I(VERBUM = VERBUM(2)).
TEINF(*(*);TOP(4 , 2)): 0(1(2) , * , 3(4))/2:VORH=Jte ~; 4: WERKW@>=INF=>TOP(*O< , I>* , NEWTOP(X(2 , 4)) , *O<3 , >*) /
TOP : O;
NEWTOP:(WRDSOORT=WRDSODRT(4); WERKW=TEINF ;
VERBSORT=VERBSORT(4)) ; 2:2(WRDSOORT=WRDSOORT->0) ; 4:4 ( WERKW = INF ) ; X : ( WERKW = TEINF ; VERBSORT=VERBSDRT(4)) . 
--> TELW : 0 ( * ) / O : ( WRDSDORT = TELW ) a ( SODRT ^= CYFER )  & ( SOORT '= SOORT->O )   . 
--> FIND NPCL.
~GRAM:TELW(E).
TELWDRD(@TELWRD ; O ) : 0 ( 1 ( * ) ) / 1:  ( WRDSOORT = TELW ) & ( SOORT'=CYFER ) ~ ( SOORT '= SDORT->O ) = > o ( 1 )  , --> FIND NP CL . 
--> ZNUL.
&GRAM:FINDNPCL(I).











--> FIBYZ:0/O : ( PRON = RELPRON ) \] ( VOEGWRD=ONDER )  . 
--> RELBYZIN : 0: RDSODRT = PREP).
--> TRANS LAT.
~GRAM:FIBYZ(I).



--> RELBV gIN:0/O : ( PRON = RELPRON ) ( ( WRDSOORT=PREP )  . 
--> TRANS LAT.
&GRAM:RELBYZIN(I).


--> TRANS LAT.
&GRAM:TRANSLAT(U , TRANSLAT , TRANSLAT ) :< STAM ^= STAM->O:TRANS=TRANS ( DICT ( * ) )> . 
--> ZSTOP.

