1 965 International Conference on Computational Linguistics 
SOME MATHE MATICAL ASPECTS ONSYNT ACTICDISCRIPTION
Itiroo Sakai
Project on Linguistic Analysis
Ohio State University
216 North Oval Drive
Columbus , Ohio 43210
U.S.A.
Sakai1
Abstract . The purpose of this paper is to help linguists contruct a consistent  , sufficient and less redundant syntax of language . 
An acceptable string corresponds to an expression or an utterance : it may be a natural text  , a string of morphemes , a tree structure or any kind of representation . A sharp distinction is made between the syntactic function which is an attribtrins and the distribution class which is a set of strings  . Syntactic function of a continuous or discontinuous string is defined as the set of all the acceptable contexts of the string  , and is called a complete neighborhood . Two contexts are equivalent if they acceptor reject any given string at the same time  . An elementary neighborhood is the set of all contexts equivalent to one context  . 
Four simple distribution classes are proposed and their properties are discussed  . 
Concatenation rules of a language can be described in terms of concatenated complete neighborhoods or concatenated distribution classes  . Some possible representations and their consequences are discussed  . 
Transformational rules are also described in a similar way  . However , there is another problem of correspondence of original strings to their transforms  . It is useful to establish subsets of elementary neighborhoods and this subclassification may contribute to a simplification of the clums y representation of derivational history  . 
Finally , some trivial but practically useful conventions are described  . 
1. Introduction.
~he grammar of a language should be consistent throughout its whole system  . No features should be left unformulated in order that the grammar be a complete one  . At the same time , it is desirable to prepare the grammar as compact as possible  . These are important requirements especially when the grammar is a machine-oriented one  . The knowledge on the formal properties of syntax will help us construct an objective system of grammar  . Every term used in a description should be rigorously defined and no ambiguous expressions are allowed  . If the consequence of grammar rules deviates from the proper usage of the language ~ we will be able to trace back the definitions and locate the source of trouble  . 
When the grammar rules are given in terms of concatenated symbols  , we must know the formal definition of the symbols before writing a program by which the rules are applied to the text  . If a grammar rule describes the nature of a P -marker  , the label given to each node in the P-marker must have an unambiguous definition which relates the meaning of the symbol to the strings supplied as texts  . 
Sahai2
We need , at least , an objective criterion by which we can specify a language  . This criterion will be a dichotomous decision whether or not a given symbol string belongs to the language in question  . We leave the decision to native speakers and consider the acceptable strings undefined  . A substring of an acceptable string is said to have a syntactic function or a part of speech  . The syntactic function of as ~ boistring is considered as the set of all acceptable utterances in which the string occurs  . We eliminate the string in question and define its syntactic function as the set of all acceptable contexts of the string  . The set of all acceptable contexts of a string is called a complete neighborhood  . 
A distribution class can be defined as a set of strings whose complete neighborhoods are related to a given set of contexts in a specified way  . We propose four simple definitions of distribution classes  . 
With these fundamental concepts of parts of speech and distribution classes  , we can proceed to a more formal system of syntactic description  . However , a few questions may be immediately raised . Is it really possible to construct a grammar in such an elementary way ? How can we list the elements of a set picking them up out of a practically infinite nmmber of strings even though each string is assumed to be of finite length ? Is it not useless to establish such sets for a natural language  , most of which are likely to have only one element ? Etc  . Etc . 
We should be better off if we were to create a new languaze by preparing a grammar and a lexicon  . Unfortunately the situation is quite contrary when we are to handle a natural language  . The language exists . We want to find out a grammar that accounts for all and only the acceptable strings of the language  . We regard a language L as a set of strings generated by a machine M  , whose internal structure is not known to us . We can observe only a part of the set of generated strings in a limited length of time  . We want to construct a hypothetical machanism M ' that generates all and only the strings in L  . The internal structure of M and ~' ~ may not be the same  . ~% e output of M ' is checked if it is an element of L  , and strings are supplied to M ' to see if M ' accepts a string if and only if it is an element of L  . To do this , we must have the set L , or a mechanism which tells us whether or not the given string belongs to L  . We call this mechanism a normative device . It is a native speaker if a natural language is to be discussed  . We simplify the situation by assuming a few separate strata in the mechanism  . A string generated is supposed to have been transferred from a stratum to another before it becomes a string of natural language  . An utterance has a few different forms corres-
Sakai3 ponding to the strata . Each form has its own grammar . The normative device will be a linguist in this case  . 
Since the number of strings is practically infinite  , a linguist trying to constuct a grammar will find it advantageous to establish rules that hold for a set of strings or for a set of relevant facts  . A linguistic phenomenon may be analyzed from various points of view which will help him avoid listing a tremendous number of phenomena and rules  . He will attach certain markers to the string m according to the way he considers consistent with his usage of language  . He will then write down the rules in terms of the markers  . He may also establish his rules in terms of sets of strings which share some common features in their mai~ers  . The procedure of using these rules consists of two parts  . ~% eone is a routine that compares a rule with the text and decides whether or not the rule is to be applied  . The other is a transfer routine by which the relevant infon~ation is read out of the applicable rules and transferred to the text  . In these procedures , both comparison and transfer are carried out with the coded markers  . It is important that the meaning of the codes is unambiguously defined so that the code obtained in the text is exactly what the linguist wants to mean  . 
Some of his rules may account for a certain n~mber of text she has examined but may fail to account for some others or to rule out similar but inconsistent facts  . He will test his rules by applying them to a natural text or by generating strings  . The normative device will tell him whether or not a string supplied to it is acceptable but not tell him why  . It is obvious that these procedures cannot be carried out practically on every string that may be supplied to a machine in the future  , and that no body will be able to predict what can occur when an arbitrary string is supplied to the machine  . Nevertheless , it is required that a grammar may deal with most of the texts supplied in the future  . 
His ~ rammar is inevitably affected by the nature of the normative device  . 
If the normative device is so strict as to reject every string which fails to meet such requirements as that its style must be just an ordinary one  , the statement must be logically correct , the lexical usage must conform with the regular way of the language  , etc . , etc . , then the linguist must prepare a separate rule for almost every string  . He can break down the decision procedure into a few separate steps  . The first device will accept a string if it finds the internal relationship of the string is acceptable  , regardless of the reality the string designates . If the grammar is to be applied to input texts
Sakai 4 whose structure is always grammatically correct and unambiguous  , a grammar which satisfies the requirement of this device ~ wl ~ be enough  . However , it will give many unusual strings if it is used in random generation and many ambiguous alternatives if it is used for analysis  , ~h?second device may reject tl % ose strings whose structure shows an unallowable combination of lexical elements  , thus eliminating some of the ambiguous alternatives in analysis and suppressing the output with improper usage of lexical elements in synthesis  . 
The third device may reject as unacceptable those strings which are not logic-ally consistent  . If one wants to have more rigorous grammar that may be used for random generation of only non -surprising sentences  , he may add more devices to the preceding ones , so that the grammar may be tested from such points of view  . He will prepare his grammar keeping the characteristics of his normative device in mind  . A number of digits will be assigned to the coded form of markers corresponding to each step of decision  . ~ne procedure will be programmed so as to handle these digits independently  , thus allowing a number of rules to be applied to the same string  , if certain digits are related to each other , and a particular combination , of codes is to obey a particular rule , the rule will be prepared independently and the general procedure will be prohibit-ed  . ~ nisis done by a simple technique in coding and programming  . 
As we see on the following pages , a number of similar but different represent aions are possible  . If we are not ready to understand the exact meaning of codes and rules and to prepare the right program for the representation chosen  , the rules established on the basis of ad hoc definitions will result in a chaos  . The formal property is not confined to a certain language  , but it is common to many , probably to all , languages . A grammar will not deviate greatly from its proper constuction if its formal property is carefully examined  . 
~. Symbo ! ~ String ; Language.
2 . __~I . Symbol is an undefined term . Morphs , morphemes , lexes , lexemes , or some other units may be regarded as symbols . Any unit consisting of a number of symbols is called a string  . All the strings are possible strings . If a string is considered " ~ ~ mean lnu ? , then it is an acceptable string . Each acceptable string is an undefined term . 
These definitions are quite fon~al . If we confine ourselves to the problems in morphotactics  , the symbols are morphs and the acceptable strings are what are called expressions or utterances  . A symbol may be a morpheme and a linear arrangement of morphemes is an acceptable string if it is reco~jnized as a mori:  , hemio = , j ::' osentatic no fanu-ctu : '- . , <= e ' . A string need not always be a linear a , ~ ra~gemen % of " ~ ~- " al~mo . We may rega~t . ~ labeled tree called a P-marker as a str ing ~ and a labeled node as are  -0resu~r lon of the subsZrin ~ dominated by the node ~ al ~ ouZ ~  . . ~ e te rm s t r in ~ seems inadequate in th is oa~e A node represents a P - marRer cons is t in / of a l l +~  . he terminal and non-terminal nodes it dominates  . We can regard a P-marker as a L='ee-l/icestr in Z of P-markers dominated by the former  .  "'- ~'~  .   .   .   .  " ~  . . . . . , "~ : ~ o ~ e . x~nc of .   .   .   .   .   .   .   . es may be added to the syn-tactic tree in o rder Zo indicate there ! ations h  i3 a ~= on 1%he constituents . We call this renresentation an et ~ provis ionally  . Wel : ~ ayreoardanetas a string co ~ . " sisting ~: . . . . . . "~ -~ "  . . . . . . . e . of labeled nouns , w ; : ose arrangement is shovm by two kinds of b ranches  . 
We define a langua='e as a see of accei=table . . . . ihc ~" , . -'-_s ~ r ~_ nj s . acce . n = a3 ~ e string of a natural-'a ,  " - :  , ' < ~ is considered = o have as . . . . .  ~ "  .   . . ly vers ions as the nusoer of s t ra ta es tab l is hed " bL rlinouist  . Ear = . v , ~- . >; ion of at . accen , tables ~ cz~ing is an element of the language defined on the st  ,  . ~ atm = i . nou =, = ~:; . , on . A transfer from one version to another is essentially a translation  . 
2 . p . Su~o ' . ~ ose we have a Linearsz , r:Ln:j . !,', e ~, n?cer'r'a ~ oD thes Lrzng by delet . n ~ some of the s ~ . : ools therein and .   . ~  .  ~  . . . . . . . . ~ . . . no "-" as : p ~ bol of absence " to each point o f deletion  , if a symbol , , o - absence is foiio' , Jed by another . , . , , , e & lauu . y , ~ . . . . "" ~"~' -~ ne,y are cont rac ted to one . A ~ < .   .   .   .   .   . . . . . e~zstrin ~ is continuous if it is not in terrupted  , % - ~ ~ ? ~ the nodes in a syntactic tree are palatially ordered  . A node includes a ~ ot ~ ~ . . . . . if the linear str ~_ng .   .   .   .   . covered 0y znel at terms a part of the linears ~ l ~ , a covered by the for = ' ~ er . At : cee-iike strmn\[~\] is continuous ~ if and only if  ( i \] all the nodes of the sLrin ~ are inc luded in one node D  , and ( 2 ) there are nood : er nodes which are not in c lude dir ~ D ? ? ~  . ~ ?  . ~~*~~? IA ; % etstrl n < is continuous , 4 ~ and only m ~ ~ . ~ es~jntact motree is continu-ous and no branches of ~ ne second '  4  " -"~' '"  , ~ . nQ are broW < ello . ~ . 
Anyo .  ~  . . . . . . .  ~ ~ . - ~ ~ , I . . . . . . . . s 3~ a sL r in Z is ca l led a se&~nent , it may be either continu-ous or U~CO ~ uoZnUOGo  . ~ discoP . tiZlUOUS sec ', ', ~ enL consists of a few nar~sse . na-rated from each otl . er . Eacho ~ , z ~ to fse <': :: e : <%: : sCa ~__ ~ , ~ afra - ~ , ,lent wh ich is necessar i l y con'~inuous ( ~- az-l < er-i . ~- . odes ~ itdl ) . 
~ . boll ~ el ~: .   .   .   .   .   .   .   .   .  ( ,~_ ,, . ,,, ~, . 
5  . ? =- Contexti:2 . cce'-'-,<:3_eConbe :, := . 
Let r be a strin ~ an & ~ eLs be a seonenu of r  . ~:, es ~ . ~, ~ r may be con-tinuous or discontinuous .   ; lheother : taru ~ c of z "_~ ~ ~ s called the co ~ -' ~ c  . ~ . ~ of s .   .   .   .   .   .  ~  . ~ . ~ u . . . . ~ . ~ Lf . eZ:iWe; . sa ~, rc ~ . s&i % ~ c, . ., . z . , ~,_~ u . ~, ~ OOl % Le \] < LO - " S ~ or c is .   .   .   .   .   .   . - ~- acc ~ i ~ u ~ m ~ to s . 
?  . , f , ~> . q ~ i . O ? f the discussion is confined to a co ~ . ~- :  . eecr . rases cruc zurc_an : Cu ~ je , it seems more convenient to modify the concepts acceptable string and context  ; any immediate constituent of an acceptables zring is also acceptable  , and a context is acceptable to a string if the string  , its context and the whole string are all acceptable  , if the constituents are continuous , the situation becomes simpler . ~ necontext c = r()t is acceptable to s , if r , s , t , audrst are all acceptable . Either rort may be absent . 
3.2. Neighborhood.
A context is an interrupted string which becomes a continuous string if an appropriate segment is supplied to its points of interruption  . Let y = set(cl , c2 , --- , cn ) be a set of contexts and lets be a string . If all the contexts in y become acceptable strings when s is supplied to them  , then these ty defines a pro-perty of s . We call these tyan acceptable neighborhood of s  . If y is an acceptable neighborhood of stringsSl , s2 , s3 , for instance , then we say y is an acceptable neighborhood of
S = set(sl , s2 , s3) , and we consider these ty represents a syntactic property common to all the strings in S  . ~ ote that our neighborhood is not the same as the okrjest nost j  ( Kulagina ,  1958) . A set of acceptable strings with a strings is called a paradigm of s  ( Parker-Rhodes ,  1961) ; our neighborhood is a paradigm in which the strings is lacking  . 
4. Eouivalence of Contexts.
Let c and c be two contexts . Suppose a string s is acceptable to both z 3 c and c . , and another . . . . . " ~ ~ ~ ? ~ ing t is not acceptable to c . or c . . In this case , ! j i , \] we cannot tell the difference between c . and cas far as the acceptance of l 3 the strings s and t are concerned . We say these contexts are equivalent to each other and write cie qvcj  , if the condition " c is acce ~ tabie to ~ ~ ring s  , if and only if c is acceptable to s " is satisfied for every possible strings of the language  . ? he relation of equivalence is symmetric , reflexive , and transitive : ( i ) c . ecvc . ; (2) if c i e q v c j , then c ~ e q v c i ;
Sakai7(3) if cieqvc . and ceqvCk , then c . eQvck-j . i " ~ . Complete Neighborhood . 
~ u  ~ . Let y be an arbitrary set of contexts , it may include contexts which are not equivalent to each other and may not include all the contexts which are equivalent to some context in it  . ~ hecomolete , n-'ei '' ~ . .~ o~nooa '~ " N ( y ) of y is the set of all contexts equivalent to some context c'iny:N  ( y ) = set ( c:ceqvc'~"~C'inosomey ;  . 
A set of contexts is complete or is a complete neighborhood if and only if it is the complete neighborhood of itself  . Take a string s and let C ( s ) be the set of all the contexts acceptable to it . We show ~ u ~ C(s ) is . a complete . 
( l ) (2)
If afthen then then then therefore c6C(s) , then c?W ( C(s )); that is C(s)ccAN(c(s)) , ceqvc ' for some c ' in C(s ) , ceqvc ' and c'is acceptable to s , c is acceptable to s , ogc(s ) , 
N(c(s )) C(s).
From(i ) and (2), we have : c(s).
Therefore , C(s ) is complete . We call C ( s ) the complete neighborhood of the strings . 
We may pick up an arbitrary segment of an acceptable string  , call the other part the context of the segment and establish a complete neighborhood of the segment  . This kind of complete neighborhood contributes nothing to a grammar but some redundant rules  . These practically nonsensical complete neighborhoods give rise to no trouble  , because they never appear in any rule of the language  . 
? he complete neighborhood C ( s ) of a string s is considered to correspond to the syntactic function or the Dart of speech of the strings  . The elements of C ( s ) shire a common property that everyone of them can be an acceptable context of s  , while no other context ~ which do not belong to C ( s ) are acceptable to s . ? his property of C ( s ) leads us to the application of complete neighborhood to a given set of contexts supplied as text  . 
Let S be an arbitrary set of contexts . Some elements of S may be accepted by s and some others may not  . The elements accepted by smust , at the same time , belong ~ oC(s ) , that is , CoC(s ) ~ S . If
Sakai8
C(s)~s = 0 , then the strings cannot occur under the contextual condition defined by S  , and vice versa . If
C(s)DS = C(t)~S , then we have no means to distinguish the syntactic function of s and t with respect to the given S  . If S is the set of all the possible contexts of the language  , then c(s)Ns = c(s ) for any strings . If c(s ) = c(t ) , then we have no means to d~stlngml snznes~tacti c function of s and t so far as only the acceptability is concerned  . 
5 . 2 . It occurs very often that a string r behaves like a strings under a certain condition  , and like tunder another condition . This phenomenon will be restated as follows : for some set S ' of contexts  , 
C(r)Ns '= c(s ) Os , , and for another set S " of contexts , 
C(r)ns , , = c(t)Ns , , .
We put x = C(r ), y = C(s ), z = c(t).
~ , ~ en , xN ~' Ns ,   , = y q s , Ns , , and xNs ' N s "= ~ O s ' , q s " . 
Taking the union of these two , we have x('ls ,   . qs , , = ( yd ~) Ns ' lqs , , . 
This means that racce ~ ots every context in ~'~ S " if it is acceptable to sort  . Now , we will see the behavior of r with respect to the context set 
S = S ' ~ S " .
xNs = x ~ ( s ' d s " )  =  ( xqs ' ) 19  ( xOs " )  =  ( yNS ' ) U ( z~s " )  ~_ ( y . qS)U(zNS)t = ( yU7) Os . 
This results u ~'> e ~+ ~ oo_~that the behavior of r may be interpreted in terms of y and z  , and that y and z may account for something lacking in x with respect to 

( ydz ), qs = ( ydz)~(s,ds , ,)
C ? ~_"=( yns')d(YO , s ") W ( z , ~ s ') O(zGs ") : C < D s')0( y , ~ s , ,) d ( z f~s , ) d(x  ~ Os , , )  -=  ( x0 ( s ' U ~' ) ) O ( y D s " ) U ( z ~ s ' )   , ' r = H~<q ' . ~ , . ., y ,% - ~ .  ~\]  .  ,  . < ig : :' . ta~F'? . 
o . _ . We z lave seen above Bhataco: ; : piete ; ; eishborhood x : c (:~) is ir . ~er preted inte:m ; ~ sofy:c(s ) and z : ~< u) . 
: '  , ' eca'~ex~pect~s ) and "" ~ ea~kL ; :ray re-~-~ese=zazmon O7 as ' , mp . eraria more specific syntactic func-cion , if
C(r ): c(s)Oc(t ) , c(~)/c(t ) , c(~)Io , c(~)Io , then , for some c in C(s ) and some c in C(t ) , we have c . noze cvc ~ . 
\]- o6 . 2 . kse~o ? all . . . . . . .  ~- , . ut ~ zj equivalent contexts , called an elementary neighborhood , leads us to a concept of the ultimate unit of syntactic function  . Given the elementary neighborhood e(i ) with c . as an element is defined ! a context ci , ase(i ) = set(c:ceqvc . ) . 

Since the equivalence is symmetric , reflexive and transitive , any two distinctele:: ; e -= ~ ary neizhborhoods have no elements in common . 
6 . __~ . Let x be a co , mi ~ ieteneid_borhood and e ( i ) an elementary neighborhood . 
~ an element c in x~s a:: , emoer of e(i ) ~ then e(i)r-:: , b ~ causex is co ' . rS ie ~ e ' " ~- . in "? ~ a . an element cx ; then the remsane ( i ) such \]_ that ?() . C ~ eix : U e ( i ) for all ek ~ ) ' s ~= ving at leas ~ one element in x . Every elementary
Sakaii 0 neighborhood is complete . An intersection of complete neighborhoods is complete  . 
Everyunion of elementary neighborhoods is a complete neighborhood  . 
2" Distribution Class.
We have thus far discussed the syntactic function of symbol strings in terms of their acceptable contexts  . A context is an environmental condition in which a string occurs  . Given a context , we can classify the strings into two distinct categories : the one is a class of strings that can occur in the given environment and the other is the class of strings that cannot occur therein  . 
If there exists at least one context c in which both s and t can occur  , then c~C(s ) and c~C(t ) , that is c~C(s)NC(t)#O . 
We define the set of all strings t , that can replaces in some contexts , as
G(C(s )) = set(t:C(t)NC(s)#0).
We introduce a convention
A ( = ) B which means that the intersection of the two sets A and B is not empty: 
G(C(s )) = set(t:C(t )(=) C(s)).
Suppose a string t can occur wherevers can occur , buts cannot always occur in the contexts accepted by t  . In this case , c(t)oC(s) . 
We define
H(C(s )) = set(t:C(t)OC(s)).
The distribution class I ( C ( s ) ) is a set of all the strings t that can be always replaced by s : 
I(C(s )) = set(t:C(t)cC(s)).
That the two strings s and t are mutually replace able means that s can occur where vert can occur and conversely t can occur wherevers can occur  . 
In other words , any context c is accepted by t , if and only if it is accepted by s : cgC ( t ) if and only if c ~ C ( s )   , or C(t ) = C(s ) . 
We indicate the set of such strings t by
J(C(s )) = set(t:C(t ) = C(s)).
Other distribution classes are defined as sets of strings whose complete neighborhoods are related to a certain complete neighborhood in a specified way  . Let x be an arbitrary complete neighborhood . The simple types of
Sakaill distribution classes mentioned above are written as 
G(x ) = set(t:C(t )(=) x),
H(x ) = set(t:C(t)2x),
I(x ) = set(t:C(t ) ~ x),
J(x ) = set(t:C(t ) = x).
A distribution class is said to be real if it is not empty  , and imaginary if it is empty . 
able string s and only these.
and their contexts
Suppose , for instance , that a language consists of the accept-they are ( flying/red/making ) planes , a ( flying/red ) saucer is an object , (flying/making ) planes is an industry , 
We observe the strings sI = flying , s2 = red , s3=making cI = they are () planes , c2=a ( ) saucer is an object , c3=() planes is an industry . 
The complete neighborhoods of the strings are
C(sl ) = C(flying ) = set(cl , c2~c3),
C(s2) = C(red ) = set(cl,c2),
C(s3) = C(making ) = set(cl , c3).
The distribution classes are determined by these neighborhoods  . 
types above are given in the table below.
i:s IC(s . ) G(C(s . )) I(c(s . )) lll!i:flying(Cl , C2 , C3) ( Sl , S2 , S3) ( sl ) ( Sl , S2 , S3) 2: red(Cl , C2) ( Sl , S2 , S3) ( Sl , S2) ( s2) 3: making(ci , c3) ( Sl , S2 , S3) ( Sl , S3) ( s3)
The simple
J(C(s .)) l(sa)(s3)
Sakai12
The elementary neighborhoods e ( i ) = set ( c : ceq vci )  , i = i ,  2 , 3 are found by consulting the table below , where "+" on the ith row and J-th column means " cj is acceptable to si "  . 
: cIc2.c ~
Sl :+ ?+ s2:++-s3:+-+ e ( 1 ) = set ( c : ceq vcI ) = set ( cl )  , e(2) = set(c2) , e(3) = set(c3) . 

C(sl ) = e(1) ~ e(2) ~ e(3),
C(s2) = e(1) Ue(2),
C(s ~) = e(1) U e (3).

( i)J(x ) = H(x ) , qZ(x ); (2) H(x ) Uz(x ) ~_G(x ) , 

(1) t ~ J(x ) , if and only if C(t ) = x , " C ( t ) ~ x and " t6H ( x ) and " t ~ H ( x ) N i ( x )  . 
(2) t6_H(x ) UZ(x ) , if and only if t ~ H(x ) or " C(t ) ~ xx#O . 
C(t)cx , t6I(x ) , tdi(x ) , or C(t ) :' x , for x/O , then C(t )(=) x if and only if t ~ G(x ) . 
7 . 2 . Ale equality C ( t ) = C ( s ) of two sets is symmetric , reflexive and transitive . ~ erefore,
J(x ) = J(y ) if and only if J(x ) (=) J(y).
This means that any two different sets have no elements in common and  , consequently , that every element belongs to one and only one set of the form J  ( x )  . 

If X is an elementary neighborhood , then
G ( x ) = set ( t:C ( t )   ( = ) x ) = set ( t:C ( t ) ~x ) m = : ~ ( x ) if x/O ; 
I ( x ) = set ( t:C ( t ) C x ) = set ( t:C ( t ) = x ) : J ( x )   , so that C(t ) is also elementary . 

then if
Sakai13
If x is any complete neighborhood and if C ( t ) is elementary for all t , 
G ( x ) = set ( t:C ( t )   ( = ) x ) = set ( t:C ( t ) ~x ) m = I ( x )   ; 
H ( x ) = set ( t:C ( t ) D x ) m = set ( t:C ( t ) = x ) : J ( x ) x/O , so that x is also elementary . 
7 . _~_~ . If C ( t ) is elementary for all t and x is also elementary and nonempty  , then 7-4 . If (1) (2) (3)

(1) if and only if


I ! (2) if and only if

G(x ) = ~( x ) = I(x ) = J(x).
X = yUz , then
G(x ) = G(y)UG(z),
H(x ) = a(y ) ~ ~( z),
I(x ) ~ i(y)OI(z).
t ~ G(x ) = G(y  ~ z),
C(t ) (=) x = y~z , c(t ) (:) y or c(t ) (:) z , t ~ G ( y ) or t ~ G(z ) , t6G ( y)UG(z ) . 
t?H(x ),
C(t ) ox = yUz ,
C(t)2Y and C(t)_Oz , t6H(y ) and t~(z),
It (3) if and only if then if and only if ~. ~ A.
( l ) (2)

( l ) if and only if l ! then if and only if ( 2 ) if and only if
T !8.

t ~ H(y ) ~ H(z).
t ~ I(y)UI(z ) , c(t)~y or c(t)~y~z:x , t?Z(x ) . 
If x : yNz , then
G(x ) ~ G(y ) ~ G(z),
Z(x ) = Z(y)NZ(z).
C(t)~z , t?G(x),
C(t)~x#O,c(t)~y~z/o ,
C(t)~y#0 and t ~ G(y)~d(z).
t ~ I(x ), c(t)C_x = yAz ,
C(t ) ~ y and , C(t)~z , t ~ I(y ) and t ~ I(z ) , tEl(y)~Z(z ) . 
- - - - - ~ rn
Sakai14

Cqn catenation of Strings.
Let p be a string and let rI , r2 , c~t)~z#0 , be segments of p which do not mutually overlap . A segment t consisting of r l , r2 ,  --- , rn  is the concaten-ation of these segments . It is a segment of p , consisting of fragments of --- arranged in their relative order in the original string p  . Itrl , r2 ,   , rn is convenient to assign a definite notational order to a concatenation in order to specify the arrangement of fragments  . 
8.2. Concatenation of Contexts.
Letrl , r2 ,  --- , rnbe segments of p with no fragments in common . 
c(r ) of r in p , plli = i ,  2 ,  --- , n correspond uniquely to the segments ri , ' l ~ e contexts respectively , and so does c(t ) to
P the concatenation
Sakai15
We write t = rlr2---rn.
Cp ( ri ) Cp ( r2 ) ---Cp ( rn ) = Cp ( t ) if and only if t = rl r2---rn in 8 . 3 . Concatenation of Sets . 
Let a , b , c , --- be elements of sets.

We call an ordered string of these elements a concatenation  . Let A , B,C,---besets . We define the concate-nation , of sets as AB---D = set ( ab---d : a ~ A , b ~ B ,  --- , d ~ D ) . 
In our present discussion , the elements are either all strings or all contexts  . 
8 . 3 . 1 . We confine ourselves to binary concatenations for simplicity  . The fol-lawing discussions can be easily generalized to longer concatenations  . An unambiguous concatenation , ABCD for instance , is considered as one of the three binary concatenations 
A(BCD ) , ( AB)(CD ) , ( ABC ) D when the discussion is strictly binary . In a morphographemic description , however , this is not very important . One may assume one of these three acceptable and discard the other two as unacceptable  . In a morphotactic description , someone of these three will be chosen so as to make the whole description of the language simpler  . If any one of the sets which constitute a concatenation is empty  , then the concatenation is also empty . 
We assume that the binary concatenations required by the grammar are  ( A B ) ( CD )  , A(BC ) , ( BC ) D and only these . The possible binary tree structures of ABCD are covered by 
ABCD = A(BCD)U(AB ) ( CD)U(ABC)D.
Since we are to handle binary concatenations only , we consider two concatenations of elements are different if their structures are not the same : 
Then , the condition yields(i ) (2) (3)
By assum D tion , ( AB)(CD)NA(BCD ) = O , ( AB ) ( CD ) ~( ABC)D = O . 
ABCD : ( AB ) ( CD ) ( AB ) ( CO ) IO , ~ erefore , (4) 45) because
Similarly , (6) (7)
From(2),
By (7) and (6), or , (8)
From (3),
By (4) and (5), (9)
Sakai16
A(~C)JO , ( A ~) C : O,
A(BC)N(,~)C : O.
BCD = B(CD)\[_)(BC)D = ( BC)D,(BC)D~O,
B(CD):O .
A(BCD ): A(B(CD)h ) ( Be)D):O.
A(BCD):00A((BC)D):o ,
A#O , (~ C)O#O , A((BC)O):O.
( ABC)D:(A(BC)O(AB)C)D:O.
( ABC)D = ( A(BC)~O)O : ( A(BC )) D = O,
A(BC)#O , D#O , ( A(BC )) D = 0.
Now , we can describe the syntax of these strings in terms of binary concatenations only  , if we establish the rules numbered from ( 1 ) to ( 9 )  . 
8.3.2. The following formulas are frequently used.
(1) AB = CD , if and only if A = C and B =  D , because , for any a bin AB , 
AB = CD if and only if Cab ~ AB if and only if ab ~ CD  )  "  ( ( a ~ A , b@B ) if and only if ( a ~ C , b ~ D ))
I !( a ) because if and only if
I ,
IIr ! (3) Similarly , (4) because if and only if
V ! bEB if and only if b~D )
A = C and B = D .
A(BUC ) = ABUAC , ab  ~ A ( BUC ) a6A an ~ b6BUC ( a ~ A and b ~ B ) or ab6ABorab6ACab ~ AB ~ AC . 
( AOB)C:ACUBC.
ABDCD = ( Af\]C ) ( BDD) , ab~ABtOCO ab~AB and ab~CD a ~ A and b~B and a ~ A ~ C and  ( a ~ A and b 6C ) a & Cb~B ~ D and b ~ D strings r and s , such that
C(r ): x and C(s ) = y.
By definition,
Sakai17 " ab~(ANC ) ( BlqD).
Concatenation of Complete Neighborhoods..
If the distribution classes J ( x ) and J ( y ) are real , then there exist p(ri ) = --- r . ---l with the segment r . in it is acceptable if and only if p(r ) .   .   .   . r --- is acceptable , and the string p(s .  )  .   .   .   .  2? - - -3 3  . is acceptable if and only if p(s ) .   .   .   . s--- is acceptable . Suppose
P ( risj ) = --- ri---sj---is a string with both r . and s . in it . Any such stringix acceptable if and lj only if the string p  ( r . s ) :--- r . - - - s - -- ll is acceptable , and P ( r is ) is acceptable if and only if p ( rs )   .   .   .   . r - - - s - - - is acceptable . ~ nerefore , P ( risj ) is acceptable if and only if p ( rs ) is acceptable . That is
C(risj ) = C(rs).
We define the concatenation C ( r ) C ( s ) of complete neighborhoods as the complete I % neighborhood C  ( rs ) of the concatenated strings . Generally , we put x y : c(r s ) , r  ~ J(x ) , s6J ( y ) for any com ~ plete neighborhoods x and y , where J(x ) and J(y ) may be real or imaginary . Note , however , that if x : C(r ) , y : c(s ) , 
C ( ri ) = x for all r l in J ( x ) and C ( s j ) = y for all s3 in J ( y )  . 
Any string
Sakai18 then xy = C(rs) , while xy = C ( rs ) does not always result in x : C ( r ) or y = C ( s )  . 
We have generalized and transferred the concatenation of strings to concatenated sets of strings and then to concatenated complete neighborhoods  . 
The complete neighborhood representation provides us with a less complicated approach  , especially when the strings are syntactically ambiguous  . The distribution class J ( x ) means the narrowest classification of strings and no further subclassification is possible  , while its complete neighborhood x can be subclassified if x is not an elementary neighborhood  . If rgJ(x ) and x = yUz , then we can talk about imaginary strings r ' and r "  , such that
C(r ') = y and C(r ") = z.
These imaginary strings , always referred to implicitly in terms of distribution classes  , can be discussed explicitly in terms of complete neighborhoods  . 
9 . 2 . We make distinction between the concatenation x y : c  ( r ) c ( s ) of complete neighborhoods and the complete neighborhood z : C  ( rs )   . 
~% eformer means a set consisting of concatenated contexts  . The properties of the language is introduced when it is written in the form x y = z or C  ( r ) C ( s ) : C ( rs )  , where the proper tyx of r and the property y of s result in another property z of rs  . Thus , z can be an empty set even if neither xnory is empty  , and ambiguous even if neither xnory is ambiguous  . 
9 . 3 . We find it advantageous to have a system which represents every complete neighborhood in a unified way  . We saw that a complete neighborhood x can be represented by a union of elementary neighborhoods e  ( i ) : x = Oe ( i ) with x ~ e ( i ) ~ O . 
Let us introduce coefficients x(i ) , such that x ( i ) : o if = i if and no other cases possibly occur . 
x(i)e(i ) = e(i ) = 0 e(i) , Ox = o , e(i)--x;
We put if x?i ): l , if x(i ): o.
Sakai19
In virtue of these coefficients , we can write (1) If then
If then ~\] erefore , for we have (2) If then x = Dx(i)e(i ) , y = ~ y(j)e(j ) , z = Uz(k)e(k ) . 
z = xO y , xUY = ( Ux ( i ) e ( i ) ) U ( O y ( j ) e ( j )   ) = U ( x ( k ) + y ( k ) )e ( k ) = Uz ( k ) e ( k )  . 
e(k)c_xore(k)~y , e(k)~_z .
x(k)+y(k ) = z(k) ,  0~-0=0 , l + O=0 + l=1 + l=1 . 
z = xy , z = ( Ux ( i ) e ( i )   )   ( ~ y ( j ) e ( j )   ) = DUx ( i ) y ( j ) e ( i ) e ( j ) = UUz ( i , j)e(i)e(j) . 
By the definition of concatenation , e(i ) e(j ) ~ xy if and only if
That is , if and only if
Therefore , for we have e(i ) Cx and z(i , j ) = 1x(i ) = y(j ) = 1 . 
x(i)y(j ) = z(i , j ) , 1X l = l , 0XO=0Xl = IXO = O . 
e(j)cy .
Writing we have if and only if e(i)e(j)~z
Therefore , for the expression z(i , j)a(i , j , k ) = z(k ) , we have 1X1 = l , e(i)e(j ) = Ua(i , j , k)e(k ) "
Z = xy = U ~ z(i , j)e(i)e(j):UUUz(i , j)a(i , j , k)e(k ) = Uz(k)e(k ) , e(k)~z and e(k)~e(i)e(j ) . 
(3 ) A concatenation of two elementary neighborhoods is a complete neighborhood  , and it is also a union of elementary neighborhoods : 
Sakai 2010.
i0.i.
because if and only if then , if and only if l0 . 2 . 
because if and only if
II


I ! then if and only if lo ._.._5.5.
because if and only if



I1 then if and only if 10.4.
because if and only if then if and only if 0 XO = OXI = 1XO   =0  . 
Concatenation of Distribution Classes.
G(u)G(v ) ~ G(uv) , r~?G ( u ) ~( v)r?G ( u ) and s?G(v)
C ( r ) NU/0 and C ( s ) ~ V/0 ( C ( r ) ~ u ) (C ( s ) ~v ) = C ( r ) C ( s ) Nuv/o
C(rs ) ~ uvJ0 rs?G(uv).
H(u)H(v)c ~ ( uv) , rsE~(u ) ~( v)r ~ H(u ) and sgH(v)
C(r ) Du and C(s ) ~ v
C ( r ) ~ u = u and ~ C ( s ) ~v = v ( C ( r ) ~ u ) (C ( s ) Nv ) = C ( r ) C ( s ) Nuv : uv
C(r)C(s)~uv
C(rs ) 2 uvrs ~ H(uv).
I(u)I(v)~I(uv) , rs?I(u)I(v)r~I(u ) and s~I(v )
C(r ) cu and C(s ) ~ v
C ( r ) ~ u = C ( r ) and C ( s ) ~ v = C ( s )   ( C ( r ) ~ u ) (C ( s ) Dv ) : C ( r ) C ( s ) Duv:C ( r ) C ( s ) 
C(r)C(s ) cuvm
C(rs ) cuv
N rs6I(uv).
J(u)J(v)CJ(uv ), rs~J(u)J(v)r ~ J(u ) and
C(r ) = u and
C(r)C(s ) = uv
C(rs ) : uvrs ? J(uv).
s6J(v )
C(s ) = v
Sakai21i ! . Rules for Recognition and Generation . 
Each rule of a grammar indicates the arrangement of a few items to be concatenated  , accompanied by some other necessary informations . We assume the items arranged in a rule are either complete neighborhoods or distribution classes  . Let us see what happens during the generation and recognition of a string of symbols  . 
In case a grammar is given in terms of complete neighborhoods  , the input text is converted to a string of complete neighborhoods before the syntactic analysis begins  . At the very end of generation , a terminal node accompanied by a complete neighborhood x is replaced by a strings whose complete neighborhood C  ( s ) shares at least one elementary neighborhood with x  . 
~ nen the syntactic rules are expressed in terms of sets of strings  , the input text to be analyzed is replaced by a string of distribution classes  . 
If a symbol string belongs to more than two sets of strings  , their meet replaces the symbol string . At the end of a generation , the synthesized output string is obtained by replacing the set of strings on @ ach terminal node by a string which is a member of the ' set  . 
ll . 1 . An acceptable string can be generated and analyzed making use of a tree with its nodes marked by complete neighborhoods  . The expansion of a node z to a concatenation x y of nodes x and y implies z~x y  , because otherwise further expansion of x and y may yield a structure which cannot be accepted by z  . Transformational rules can be a ? plied more freely because a transformation does not imply such a restriction  . However , attention a hould be paid not to add any other contexts to the complete neighborhoods attached to the nodes already generated  . Finally , each terminal node is replaced by a lexical element  . ~% estring obtained after applying all the obligatory rules must be an acceptable string  . 
~neanalysis is carried out by testing all the possible transformations and trying all the possible contractions  . At any rate , both generation and analysis can be carried out if we have a set of rules which gives concatenation z = x---y for any x  ,  --- , y of the language , and the transform y ( 1 ) y ( 2 ) ---y ( n ) of any string x ( 1 ) x ( 2 ) ---X ( m ) of complete neighborhoods . 
ll . 2 . Acceptable strings are also generated by starting from the node P  ( O ) which is the set of all acceptable strings . It is replaced by its subset
P ( 1 ) P ( 2 ) ---P ( i ) ---P ( m ) ~ P ( O ) which is a concatenation of nodes P ( i ) ' s . Each node P ( i ) also represents a set of strings , and it may or may not be replaced again by
P ( il ) --- P ( ij ) --- P ( in ) ~ P ( i).
Sakai22
On each step of expansion , a choice is made by taking a subset of strings . 
~ e possible choice becomes narrower and narrower . It is expected that the string obtained by applying obligatory rules and by replacing each terminal node by a lexical element is an acceptable string  . 
~ is is not always true if the replacement of a node is independent of the other nodes already generated  . % his difficulty is overcome by executing a syntactic analysis after every step of expansion  . If the analysis does not prove the possibility of obtaining an acceotable string  , another subset should be chosen as a candidate . ~necheck by analysis should be tried after a transformation if it is a local or a generalized one  . All the nodes , terminal and nonterminal , are sets of symbol strings . A generated string of nodes is analyzed by tracing back the path of generation  . If the analysis goes back to P ( O ) which covers the whole string , the generation is acceptable , and not acceptable if otherwise . 
Any given string can be analyzed by applying rules to the string  , in this case , however , the tree structure is not known . Rules should be tested on every possible combination of terminal and nonterminal nodes  , so that the whole string may be covered by a single node and the possible derivational history may be accounted for by the concatenation ai and transformational rules  . 
11 . 3 . ~ iheRules for generation and those for recognition are essentially the same  . They may be prepared in terms of complete neighborhoods or distribution classes  . ~le rules will be prepared without any formal ambiguity if their definitions are carefully observed  . Some formal systems are given in the following pages as examples of s in : pie types of grammar  . 
.  .   .   . Re , , resen ~ . ~< ~ on ~ Concatenation Rklles ! 2 . Conu ~ lete Neighborhood ~~- ~ c ~, . 
We say a set of concatenation rules is con~plete if it gives the concatenation 
Z = xy of any complete neighborhoods x and y of the language  . It is not necessary , however , to list all theioossible x ' s and y's . Much less number of rules can cover all ~ he ~ ossible com ! iet e  nei~3hborhoods if their use is yrcper ! y programmed . 
We consider a rule f(uv ; w ) represents a relation between the concatenated complete neighborhoods uv and another complete neighborhood w  . Each rule
Sakai23 uv (=) w,
UV:DW,
UV ~ W , will give information to xy if x ( = ) u and y ( = ) v : ( xNu ) (yNv ) : xyuv ; which is a part of x y = z . 
In order to obtain th ~ given concatenation x y , we determine a set R ( x  y ) of rules applicable to x y . Each rule is decided whether or not it is applicable to x y by the condition g  , so that f(uv ; w ) 6 R(x y ) if and only if g(x ; u ) and g(y ; v) . 
~% e term w is read out of the rules in R ( x  y ) so that z = xy may be determined , it is obvious that there exist certain restrictions in choosing the type f of rules  , the condition g for determining R(x y ) , and the procedure of finding z . We have to specify these three for the grammar to be written  . 
When the complete neighborhood z is given and its expansion x y is to be found  , the set E ( z ) of applicable rules is determined by the condition h  ( z ; w):
R(z ) = set(f(uv;w):h(z;w)).
The situation is a little complicated in this case  . We can possibly expect a case where both z = xlY 1 and z = x2Y   2 are true under the condition xI~x 2  =  0 and/or Yl ~ Y2 = O . 
Note that this is not the case of formal concatenation of sets 
NCO = ( ANC ) ( BNO).
The concatenations xiYI and x2Y   2 happened to be z by the syntactic reason of the language being studied  . A storage space is assigned to each xi Yi as so on as any rule in R  ( z ) proves a possibility , and xiYi is modified every time a rule is applied to it  . However , if x . ~x . and Yi ~ Yj'i - ~ then either xiYi or xj yj is just trivial  . The choice depends upon the type of rules and the program which applies the rules to the text  . Finally , we have a set of xi ~ accompanied by the subset R  ( z ; i ) of R(z ) . Possible types of rules for this purpose will not be discussed here  , because the principle is similar to the case of finding z from x and y  . 
In order to see some properties of rules , we assume simple forms of f(uv;w):
Sakai24 ( i ) if and only if
T !( a ) if and only if

I'I (3) similarly , if and only if
UV = W .
The condition g will be assumed simply as (=) , o _ , c_ , or = . 
The condition of constituents can be replaced by a condition imposed on the whole concatenation : x  y  ( = ) uvxyNuv = ( x  ~ u )   ( yDv ) /0 x ( = ) u and y ( = ) v ; xyEuvxyZuv = ( x  ~ u ) (y Nv ) = uv ( 4 ) if and only if u = xNuxDux y~_uv
X ~ Uxy = UV
X = U and v = y ~ v and y ~ v ; and y~v ; and y = v . 
12 . 1 . Suppose we have the rules of the formuv (=) w , applicable to xy if x (=) u and y (=) v . 
Then , for such a rule , we have x y (=) uv (=) w.
We can also assume the rules are applicable if x y ~ uv  , xy ~_uv , xy = UV . 
We cannot decide which part of w belongs to uv , unless some other information is available . 

then 12.2.1.
UV  ~ W be applicable to xy if and only if x~u and y ~_ v  . 
~ enxy~uv ~ w.
This is true for any rule in
R(xy ) = set(uv ~ w : xy~uv).
If each rule represents the relation uv ~ wu ( x  ~ u )   ( y~v ) = xy~uv ~ xynw . 
Let the rules of the form
If the set R ( x ~ has sufficient rules to give x y : U w , we can find x y by simply taking the union of all the w's in R  ( xy )  . 
12~2,2. If the rule ~ are applicable to xy when
Sakai25x ~_u and yc_v , xycuv = w.
Wele % ow that a concatenation xy of any two neighborhoods is broken then doom to the concatenations of elementary neighborhoods e  ( i ) e ( j ) and that each e ( i ) e ( j ) is represented as a union of elementary neighbor hoeds  . 
If x = e(1) , y = e(2)0 e(3) ~ e(4) , for instance , and if we have the rules e(1) e(2) ~ e(5) 0 e (6) , e(1) e(3) ~ e(5) and e(1) e(4) ~ e(6) , then xy~e(5) Ue (6) . 
These rules will be broken downase ( 1 ) e ( 2 ) ~ e ( 5 ) e ( 1 ) e ( 2 ) ~ e ( 6 ) e ( 1 ) e ( 3 ) ~ e ( 5 ) e ( i ) e ( 4 ) ~ e ( 6 )  , and then contracted as e ( l ) (e ( 2 )   ( + ) e ( 3 ) ) D e ( 5 ) e ( 1 ) (e ( 2 )   ( t ) e ( 4 ) ) ~ e ( 6 )  , where the symbol (+) means an alternative choice . 
~e number of elementary neighborhoods increases rapidly as the linguistic analysis becomes more precise  , and hence a grammar prepared in terms of e ~ ementary neighborhoods comprises a great number of entries  . However , this type of rules is preferred when a particular technique is available on machine  ( Opler et al ,  1963) . 
12_~ . . Let us consider a set of rules of the form uv ~ W  . 
We assume a rule is applicable to xy if x ( : ) u and y ( : ) v . 
We have , then , u ) ( yv ): xy Ouv xyw.
Sakai 2612 . 3 . 1 . Suppose the rules of the formuv_~w are applicable to xy if and only if x ~ u and y ~ v  . 
For all the rules in the set R ( x  y ) of applicable rules , we have xy ~_ uv cw . 
12.3.2. Let the set R(xy ) of applicable rules be
R(xy ) = set(uv ~ w:x~u , y~v).
Then , for each rule in R(x y ) , we have x y ~ u v ~ w . 
Taking all the rules in R(xy ) , we can expect x y = Dw , and , if the set of rules is prepared so as to meet this condition  , we can find xy by taking the intersection of w's in R  ( xy )  . 
12.4. Let the rules be given in the form
UV = W ~ and let R ( x  y ) be the set of rules such that x ( = ) u and y ( = ) v . 
12 . 4 . 1 . If R ( x  y ) is the set of all the rules satisfying the condition xou and y ~_ v  , then we have x y ~ uv = w for all the rules in R ( x  y )  . Then , xy ~_ Uuv = Uw , where the union is to cover all the rules in R ( x  y )  ; if the rules are prepared so that x y = Uuv , then we can find the concatenation simD1y by taking the union of w's of the rules in R ( xy )  . 
12 . 4 . 2 . if the rules are pre ~ fared so that they may be applied to xy when x ~_ u and y C v  , then xy~_uv = w . 
If x y = ~ uv is true for all the rules in R(x y ) , then we can find the desired concatenation by xy = Nw  . 
12 . 4 . 3 . T = ~ the rules are represented in terms of elementary neighborhoods in 
Sakai27 the form e(i)e(j ) = w(i , j ) , then , in virtue of the coefficients x(i ) and y(j ) , we have x~U = X~e(i ) = x(i)e(i) , y ~ v y S e ( j )') e(j ) == y k j , ( X Du)(y ~ V ) = x(i)y(j)e(i)e(j) . 
Therefore , a rule is applicable to ~ y if x(i ) = y(j ) = i . 
The result z = xy is obtained as the union of all the w  ( i , j ) 's of the applicable rules : z = Uw = ~ x ( i ) y ( j ) w ( i4j )  . 
12 . 5 . The rules are prepared and used more freely according to the given condition and requirement  . In the following scheme ( S'akai ,  1961) , a com-plete neighborhood is represented by a code consisting of a number of digits and each digit is checked  , modified and transferred independently . 
Suppose x and y are given and their concatenation z = x y is required  . 
Both x and y can be syntactically ambiguous and their ambiguity is to be reduced in the course of finding z  . Initially , z is assumed to be the set of all the possible contexts  , x , y and z are transferred to a temporary storage space  ( xl , Yl , Zl ) . A rule is applicable if x (=) u , y (=) v and z (=) w , and the set ( xl , Yl , Zl ) is modified every time a rule is applied . If a rule proves xI (=) u , Yl (=) v , zI0w = O , then the rule is not applied to this set , and another set ( x2 , Y2 , Z2 ) is stored in another storage space as another possible result  . All the applicable rules are applied one after another to all the possible sets of  ( xi , Yi , Zi ) . Similar procedure is repeated over a gain on two languages simultaneously  , so that the syntactic structure can be transferred from the tree structure in one language to that of another language  . ~ he form of the tree is preserved but their nodes are marked by the labels specific to each language  , input , intermediate or output language . 
13 . Distribution Class Representation of Concatenation Rules  . 
Possible concatenation of a language can be formulated as concatenated sets of strings  . Let
R = set(r:h(r ))
Sakai28 and S=set ( s : h ( s ) ) be sets of strings satisfying the conditions h ( r ) and h ( s )  , respectively , and let their concatenation have the property k ( rs )  , so that rsET = set(t:k(t )) . 
We consider the concatenation rules of the form
RS~T , which reads : if ? then r6R and s ? S , rsKT . 
The point of this representation is that , and s6Sh~Si~---OSk , then as many rules are applicable to rs and they givers EN---S %: The intersection T ' has less number of elements and  , if the rules are precise , the character of the strings in it is determined as precisely as required  . Of course , these procedures are not to be done by listing up all the members of the sets  . Each set in the rules is represented by a code . Every entry of the lexicon has a code and it can be determined whether or not the string belongs to any given set  . These codes are to be generated and attached to rs to indicate that it belongs to the set T '  . 
Practically , it is convenient to classify the strings in terms of their complete neighborhoods : 
R = set(r:h(C(r ); u )) = R(u),
S = set(s:h(C(s ); v )) = S(v),
T = set(t:k(C(t ); w )) = T ( w).
A grammar of concatenation will be given as a set of rules of the form 
R(u)S(v)c with a relation f(uv;w) , and the rules can be described in a number of different ways according to the choice of R  ( u ) S ( v )  , T ( w ) and f(uv;w) . In order to see the principle , we simplify the situation by making use of the distribution classes G  , H , I and J , and by assuming the relation f(uv;w ) as uv (=) w , 
UV ~ W ~
Sakai29
EV~w , or uv = w.
lhetype of T ( w ) is chosen so that the grammar may describe the language adequately  . 
13.___~1. GRen resentation.
If then then
If then then
If then
If then
Put ~( u ) = G(u) , rEG(u ) , sEG(v ) , rsEG(u)G(v ) ~ G(uv) , 
C(rs ) (=) uv (=) w.
r ~ G(u ) , s ~ G(v ) , uv ~ w , rsEG(u)G(v)cG(uv) , 
C(rs ) (:) uv ~ w.
rEG(u ) , s ~ ~( v ) , uv ~ w , rs 6S(u)G(v)CG(uv)cG(w ) . 
rEG(u ) , sgG(v ) , uv = w , rs ~ G(u)G(v ) ~ G(UV ) = G(w ) . 
s(v ) = G(v).
uv (=) w , necessarily elementary.
13.2. HRe-o resentation.
Put ~( u ) = : ~( u ), S(v ) = ~( v).
Even if a few rules are applicable to rs in these cases  , that is , rsEG(w ~) ~ G(wi ) ~---~ G(wx) , we have no simple way to find C(rs ) from w's . We cannot specify a set of less members which adequately indic'ates the property of rs  , unless more specific information is available . 
13 . 1 . 1 . Suppose , however , u and v are elementary . 
If C(r )( =) u and C(s ) (=) v , then C(r ) ~ u , C(s ) ~ v . 
That is , r ~ G(u ) = H(u ), s~G(v ) = H(v).
For further discussion , see " H Representation " , where u or v is not necessa-rily elementary . 
13.1.2. Assume C(r ) and C(s ) are elementary.
If C(r )( =) u and C(s ) (=) v , then C(r ) ~ u and C(s ) ~ v . 
That is , r ~ l(u ) and sEI(v).
For further discussion , see " I Representation " , where no neighborhoods are if then . z , 3 . 2 . .l . 
then then then then
We put
If r ~ H(u ), s6H(v ), rs6H(u)~(v)_~H(uv).
uv (=) w,rs~H(u)H(v)~H(uv),
C(r ~) o_uv (=) w,
C(rs )(=) w,rs6G(w).
S~<ai30~(w ) = Q(w).
However , there is no simple procedure of finding the intersection of G  ( w ) 's . 
We cannot specify the features of the strings by finding more rules applicable tors  , unless more specific informaion is available . 
13 . 2 . 2 . If uv ~ w , then rs ~ H(u)H(v)~H(uv)~H(w ) , because H ( uv ) = H ( wUwi ) = H ( w ) ~ H ( w ' ) ~ H ( w )  . 
We put T ( w ) = H ( w ) to have the rules of the form If a number of rules are applicable and rs ? H  ( uh ) ~ ( vh ) c_X ( w , n ) rs 6H ( ui ) H ( vi ) ~- H ( wi ) rs ~ X ( uk ) ~: ( vk ) c_~ ( wk )  , then rs ? H ( wh ) ~ H ( wi ) ~--- OH ( wk )  = :~ ( whCwiU---Owk ) ' then C ( rs ) O_wh Uwi U---Owk " The rules of this type are essentially the same as the rules of complete neighborhood sxy~uv ~ w  , although they are encoded as the sets of strings ;  13 . 2 .  7  . If uv ~_ w , then C(rs)~_uv ~_ w , then rs 6G(w ) . 
13.2.4. Put
UV = W .
Then rs ~ H(u)H(v)~H(uv ) = H(w).
Sakai31
The situation is the same as the case above , where uv ~ w . 
13.3., I , Re , presentation.,

R(u ) = i(u ), S(v ) = l(v).
If r ? i ( u ) , s6i(v ) , then rs ~ I(u ) I(v)~l(uv) . 
!3.3.1. If uv (=) w , then C(rs ) cuv (=) w.
No relationship is relevant between C(rs ) and w.
13.3.2. Ifurn_w , then C(rs)cuv ~ w.

No definite T ( w ) is available , such that I(u ) l(v)~_T ( w ) . 
13 . _~3 . . We consider the rules of tie type i ( u ) I ( v ) with uv ~ w . 
If r?i(u ), s?1<v ), then rsI(uv ) = i(w).
If an mmber of rules are applicable to rs , then rs ? I ( wh ) NI ( wi ) ~--- OI ( wk ) = I ( wh ~ wi~---~Wk )  . 
% herefore , the rules of this type are equivalent to those of the type x y C u v C w  . 
13.3.4. Put ? Then
UV = W , rs ~ I(u ) i(v)~I(uv ) = I(w).
This is the same to the case mentioned above.
13.4. J Reoresentation.
Put ~( u ) = J(u ), S(v ) = J(v).
This type of grammar is not practical because every real distribution class J of the language must be listed in the rules  , k ~: is condition corresponds to the com ~ let e neighborhood representation of rules f  ( uv ; w ) applicable to xy only if x = u and y = v . 
13 . 5 . Practically , the rules can be written more freely and the program can be more flexible and efficient  , provided that a more sophisticated
Sakai 32 scheme is introduced to the GRepresentation and the condition f  ( uv ; w ) . ~ is is realized by representing the sets of strings by codes  , so that the union and the intersection of any two sets are determined by the operation on the codes  . 
14. Some Remarks on Transformation.
14 . 1 . It is generally agreed that we generate acceptable strings by starting with an axiom and expanding it repeatedly into a string of constituents  . This procedure is taken care of by concatenation rules  . After generating one or more strings by this procedure  , they are transformed to yield another string . 
Let us imagine another function of our normative device  . We give it a pair r = ( r ' , r " ) of acceptable strings r ' = r' ( 1 ) r' ( 2 ) --- r ' ( i ' ) --- r ' ( m ' ) and r "= r " ( 1 ) r" ( 2 ) ---r" ( i" ) ---r" ( m" )  . 
The pair r will be referred to as a string r = r ( 1 ) r ( 2 ) ---r ( i ) ---r ( m ) with m = m ' + m " . 
We put m "= 0 if the string r " is absent . We then give it another acceptable strings = s ( 1 ) s ( 2 ) ---s ( j ) ---s ( n )  , and ask it whether or not the strings as an expression is true if both r ' and r " are true  . If the device says " yes " , we consider the strings is generated from r by a transformation  . We call r the original string and sits or a no_o ~ . n . If it says ~' no " , no such transformation exists . Conversely , we ask it whether or not r ' and r " are true if s is true  . If the device says T ~ X r ~ f ~ , we consider an inverse transformation exists , such that s is expressed by r ' and r " . We can find many cases in which the device would say " yes " for transformation but " no " for inverse transformation  . Some information is supposed to have been lost in generating the strings  , which cannot be retrieved unless appropriate , possibly nonlinguistic , information is supplied . ~% is situation is beyond the scope of Syntaetics . 
A transformation or an inverse transformation is called singularly if r " in r is absent  , and it is a generalized one if both r ' and r " are present  . If it is an embedding transformation , r ' and r " are called matrix and constituent strings  , respectively . 
If we understand the transformation in the sense mentioned above  , the transfer of syntactic structure from one language to another is also a trans- 
Sakai33 formation ( Gross , 1962).
14 . 2 . If it is known that r is transfor ~ ed to s , then . . . . . ~ n ~ of act ms used to generate a particular string  . If r is known to be an inverse transform of s , then this is used to recognizes , giving a possible derivational history . 
if no other such transformations are found , r is the only nearest history . 
Otherwise , the ambiguous history is to be accounted for by other rules  . 
If we find r and s such that r is true if and only if s is true  , then we say r and s are equivalent and writer eq vs  . 
Obviously , this equivalence is symmetric , reflexive , and transitive . A transformation that transforms a string into an equivalent string is called an equivalence transformation  , if we have a grammar consisting of equivalence transformations only  , it can be used for both synthesis and analysis . 
Let us confine ourselves to the equivalence transformations in order to simplify the discussion  , and assume we have a set of rules or a normative device  . A generalized transformation transforms ao airr =   ( r'r " ) of strings into one strin~s . ~ einverse transformation by the same rule dissolves a strings into a pair of strings  ( r ' , r ") . ~ en , r ' or r " is regarded as ans , and , if we find an appropriate rule , it is again dissolved into two acceptable strings  . By repeating the same , we have a number of equivalence relations which can be arranged as a tree : seq v  ( r ( 1 )  , r(2)); r(1) eqv(r(ll ) , r(12)); r(2) eq v(r (21) , r(22)); r(ll ) eqv(r(lll) , r(ll2)); r(12) eqv(r(121) , r(122)) ; If an acceptable string t can no longer be dissolved into two acceptable strings  , we call taterminal or an atomic acceptable string  . ~n roughout this procedure , the strings are expected to become shorter and simpler  , because equivalent information is expressed by many separate strings  . It will be still possible to transform an atomic string to another atomic string by means of a singulary transformation  . We have different atomic strings which are mutually equivalent  . We may pick up one of them and call it a kernel string  . 
1~e sequence of inverse transformations is not always uniquely determined  . 
There can be other orders of dissolving a given string into atomic strings  . 
We can make the grammar less redundant by studying the possible sequences of 
Sakai34 inverse transformations . If the rules are all equivalence rules , there is no theoretical problem of ambiguity ? ~ neinvestigation of these problems requires quite a different treatment  , and will not be included in this paper . 
14 . 3 . Sometimes , it is considered more linguistically reasonable to assume " S ~ rln ~ or that a string is not acceptable but its transform is an acceptable ~"  ~ ~  . 
a constituent of an acceptable string , in some other cases , as ~ ing may be an acceptable string and its transform may not be an acceptable string or a constituent thereof In other wo ~ as  , a transformation is applied to an unacceptable string or a transformation results in an m % acceptable string  . We may prepare the rules in such a way that a sequence of obligatory transform-ations is contracted to a single ~ ale  . This seems formally simpler and consistent . However ~ it will result in a more entangled system of grammar  . We admit some of such strings as potentially acceptable and indicate it by a marker  , This convention is some t~nes useful not merely as a technique but also as a consistent and more plausible derivation of acceptable strings  . It is known that a string of a Chinese dialect marked potentially acceptable for the derivation of apparently inconsistent strings is quite acceptable in another dialect  ( Wang ,  1964) . 
14 . 4 . A generalized transformational rule consists of terms u and v  , where u = ( u ' , u ") = u(1) u(2)---u(i)---u(m) , u '= u , (1) u '(2) --- u '( i')---u'(m') , u "= u , (1) u "(2) --- u "( i ") --- u "( m ") , m = mr . ~m  ~ r , ube comes v~v = v (!) v (2) --- v(j)---v(n ) . 
Most rules are accompanied by a number of restrictions imposed on the original strings and their transforms as well as some manipulations of strings  . 
~ ese are classified into a few types and subroutines are to be prepared for them  . Some of the operations are listed below , which have been picked upsporadically from the rules for generating Chinese strings  ( Hasimoto ,  1964) . 
(0 ) A routine supervising the subroutines takes care of the whole procedure of applying the rules to a string  , if the rules are prepared in a defin-ite format , they are automatically checked and applied to the given string  . 
( I ) Certain segments r ( h ) and r ( i ) in the original string must or must not share a certain feature in common and/or a segment r  ( j ) must or must not have a certain feature . 
Sakai35 ( 2 ) The segment r ( i ) of the original string and the segment ~ ( o ) of the transform must or must not have the same feature specified by the rule  . 
(3 ) Some segments in the transform must satisfy the condition similar to  ( I )  . 
(4 ) Absence and/or presence of particular segments must be ~ cnec~ed  . 
(5 ) Positions of certain segments in the string must be found  . 
(6 ) A check of the derivational history some t ~ les decides the recursive application of the rule ~  ( 7 ) The tree structure must or must not be changed by the final procedure of a transformation  . 
~  . No rule describes a transformation of an individual string r into an individual strings  . The rule says , if the string r has the feature u : u ( 1  ) u ( 2 ) - - - u ( i ) - - - u ( m )   , then it is transformed to another strings which has the feature v : v  ( 1 ) v ( 2 ) ---v ( j ) ---v ( n )  . 
What are these features ? They must be defined on the basis of the answers of our normative device  . The program must be consistent with the features defined  . Once a program is written and decided to be used , the program is the definition . If the program is modified , the rules and the lexicon are to be modified . 
Since the transformations are applied to P -markers  , a string is considered to be a treelike string , if it is a linear string of terminal nodes , the other nonterminal nodes and the branches are to be determined by virtue of the concatenation rules  . We consider the labels u ( i ) and v ( j ) are complete neighborhoods , if the concatenation rules are written in terms of complete neighborhoods  . If the concatenation rules are written in terms of distribution classes  , u ( i ) 's and v ( j ) ' s are considered to be distribution classes . 
14 . 6 . The complete neighborhoods are defined on the basis of concatenated strings and we have to associate them with the labels given to the nodes of our transformational rules in order that the kernel strings can be transformed  . 
Let us see what happens when the nodes are assumed to be complete neighborhoods  . 
Let p = ( p ' , p ") be a pair of acceptable strings p ' and p " , and let r = r ( 1 ) ---r ( i ) ---r ( m ) be a segment of p . The pair p is transformed by T into
Sakai 36 q = T ( p) , and the segment appears in qass=s ( 1 ) ---s ( j ) ---s ( n )  . 
Some strings may have been added and some others may have been deleted  . 
Putx(i ) : C(r(i )) , x : C(r ) ~ y(j ) = C(s(j )) , y : C(s ) . 
By definition , x : x(1)---x(i)---x(m) , y = y(1) --- y(j)---y(n ) . 
Any string belongs to one and only one distribution class J  . 
instead of

T ( r(1)---r(i)---r(n )) = s(1) --- s(j)---s(n) , we write
T ( J ( x ( 1 ) )---J ( x ( i ) )---J ( x ( m ) ) ) = J ( y ( 1 ) )---J ( y ( j ) )---J ( y ( n ) ) . 
Since all the elements in a J has the same complete neighborhood  , we rewrite the above as T ( x ( 1 ) ---x ( i ) ---x ( m ) ) = y ( 1 ) ---y ( j ) ---y ( n )  . 
This is rewritten again by breaking down in the form 
X = x(1)---x(i)---x(m) , y : T ( x ) = y(1) --- y(j)---y(n ) . 
If we have a complete set of rules which gives the concatenation of any complete neighborhoods of the language  , then we can find the complete neighborhood x . The transformation takes place when x is changed to y  . The string y is to be generated in virtue of the information brought forward from x and the structural requirement of y itself  . A transformation is then interpreted as : ~ ne complete neighborhood x of the node dominating the string x  ( ! ) ---x ( i ) ---x ( m ) of complete neighborhoods is transformed to another complete neighborhoody of the node dominating the string y  ( 1 ) ---y ( j ) ---y ( n )  . 
Sakai37
This interpretation , however , suggests a few problems ,  14_~ . We know that J ( x ( 1 ) )---J ( x ( i ) )---J ( x ( m ) )  ( J ( x )   , 
J(y(1)) - - - J(y(j )) - - - J(y(n )) mJ(Y)"
The statement " x is transformed to y " is a generalization of the original fact  , and this generalization is not always true . The text should be checked before a transformational rule is applied to it  . Some separate steps for this purpose will save the machine time  . 

A text to be parsed must consist of segments specified by the rule  . The correct segmentation can be done by finding the tree structure of the ! text  . Therefore , the concatenation rules must be prepared so as to ~ account for the structure of any acceptable str in G  . 
Not all the trees of the specified form undergo the inverse transformation so that the derivational history may be traced back  . The nodes are labeled . A tree of a form can correspond to a number of trees whose nodes have different labels  . 
When a string is being synthesized , the text is given as a pair of P-markers . A rule can be applied only if the P-markers meet the condition specified by the rule  . 
We may regard the structure mentioned above as a representation of derivational history  . The history can be recorded by listing all the derivational steps the string has experienced  . This representation , however , will be redundant and inefficient , because it is likely to occur that an identical series of transformations is applied to strings of different history  . On the other hand , it is also possible that the strings p and q of different histories result in an identical string s by a transformation and the strings is ambiguous in that the s from p can undergo a sequence of transformations and the s from q another  ; thus the structure itself cannot be an absolutely reliable marker  . 
We think it more practical to associate the rules with the features in the P-marker to which the rules are applied  . ' ~ lese features should correspond to the series of transformations applicable to the P-marker in case of synthesis and the series of inverse transformations in case of analysis  . We have some rules with notes on the type of transformations to which the resultant strings may be exposed  ( Hasimoto ,  1964) . 
15 . Complete Neighbor hppds and Transformational . Rules . 
Let us assume u ( i ) 's and v ( j ) 's are complete neighborhoods . 
Saka ? 38 ~ . Two strings r and s may replace th ~ same nonterminal node to yield a longer acceptable string  . However , when a transformation T is to be applied , they must hav ~ the specified structure ; thu ~ the str!n~p with ra~a~e~ment in it may be transformed by T  , while the string q which differs from p only in that it has the segments in the place of r may not  . The lack of q by T means
C(r)/C(s).
1_~,2 . Because of this complexity involved in natural languages  , we encounter a difficulty when we try to prepare a set of syntactic data for practical purposes  . We refine the definition of complete neighborhood in such a way that C  ( r ) of a string r is the set of all contexts of r which appear in the strings to which no transformations have ever been applied during their derivation  . 
The difference between r and s is found in their internal structure  , if the machine is given only the input string to be parsed  . In order to indicate this difference , we put c ( r ) UO ( r ) = where C ( r ) is defined over ~ . , e sez of kernel strings , D(r ) is defined over the set of transforms , E ( r ) is defined over the set of kernel strings and transforms  . 
L etc ( i ) be an elementary neighborhood defined over the set of kernel strings  , and let r be a real or imaginary string such that
C(r ) = o(i).
Let d(i ; j ) be the elementary neighborhood defined over the set of all the possible transforms of which r is a segment  , where j corresponds to the possible sequence of transformations  . P utting c(i)~d(i ; j ) = e(i ; j) , we have the elementary neighborhoode ( i ; j ) defined over the set of kernel strings and transforms  . The see ( i ; j )' s are no longer necessarily disjoint : e(i ; j)~e(i ; j ') ~ c(i ) . 
l_l_l ~ . ~e separation of kernel strings and transforms still involves a considerable complexity  . Let q be a transform . It is a transform generated by a transformation in a sequence of transformations and it can be an original string to be transformed by the following transformation  . 
A transformation is accompanied by the set P of original strings and the set Q of transforms : 
P = set(p : T is applicable top),
Sakai39
Q = set(q:q = T ( p ), pinP).
We simplify the situation by defining the complete neighborhoods over P and over Q  . The feature of T is shown more explicitly in this way  . Let A be a node and imagine a derivation by the context sensitive rules 
A ~> BC
BF/---Cc-->G/B---where the s~n bols are assumed to be complete neighborhoods  . Let B be replaced by F first to yield FC , and the third rule can no longer be applied because of the lack of its necessary environment B - - -  . When these rules are to be used in analysis , none of the contexts --- CorB --- is relevant in the given string FG of complete neighborhoods  . We can get rid of this difficulty by defining B and C over a set of strings and F and G over another  , and by considering a transformation from BC to FG  , prohibiting the operations on the strings FC and

l~tp = p(1)---p(i)---p(m ) be a string in P , and let q = q ( 1 ) ---q ( j ) ---q ( n ) = T ( p ) be the transform of p by T . We define the complete neighborhood of ~ ( i ) over P and that of q ( j ) over Q . By modifying the meaning of the notation , we put x(i ) = C(p(i )) over P , y(j ) = D(q(j )) over Q . 
The requirement that p ( i ) should appear as q ( j ) in Q gives p ( i ) = q ( j )  , c(p(i ))  #o , 
O(q(j )) 0; if p(i ) does not occur in Q , then x ( i ) = C ( p ( i ) ) over P = E ( p ( i ) ) over P ~ Q ; if q(j ) does not occur in P , then y ( j ) = D ( q ( j ) ) over Q = E ( q ( j ) ) over P ~ Q . 
The relational conditions imposed on the segments p  ( i ) of the original string
Sakai40 and q ( j ) of the transform are indicated in terms of E ( p ( i ) ) and E ( q ( j ) ) , or by a relation between C(p(i )) and D(q(j )) . 
be set Q can include a part of the set P ' of original strings to which another transformation T ' can be applied  . ~ hus , we can classify the strings with respect to possible transformations  . We have no positive grounds to assume any natural language has a stratified system of layers arranged one over another  .  ? -~ 15 . 4 . Let u = ( u ' u " ) = u ( i ) ---u ( i ) ---u ( z ) be a pair of concatenations u '= u ' ( 1 ) ---u' ( i' ) ---u' ( m ' )   . and u "= u " ( 1  ) - - - u " ( i " ) - - - u " ( m " ) of complete neighborhoods u ' ( i' ) ' s and u " ( i" ) 's defined over P . If the string is linear , the nonterminal nodes are to be determined by concatenation rules  . We assume the rules of the form f(T ( u ); v ) mean , over Q , a relation between T ( u ) and v . We assume further a rule is applicable to the given pair of concatenated complete neighborhoods x =  ( x ' , x ") = x(1)---x(i)---x(m ) if the condition g(x ; u ) holds . That is , if g(x ; u ) over P , then f(T ( u ); v ) over Q . 
We expect to find the transform T ( x ) in terms of v of the rules in the set
R(x ) = set(f(T ( u) ; v ) : g(x ; u )) of the applicable rules . 
Given the rules of the same form and a string represented by a concatenation y = y  ( 1 ) ---y ( j ) ---y ( n ) of complete neighborhoods , an inverse transformation is to be carried out by finding the set 
R(y ) = set(f(T ( u) ; v ) : h(y ; v )) of applicable rules . 
With all the linguistic difference between the concatenation rules and transformational rules  , they exhibit formal similarities when the labels are 
Sakai41 assumed to be the sets of contexts . We will not repeat a similar discussion on the choice of f  ( T ( u )  ; v ) , g(x ; u ) , h(y ; v ) or the algorithm for finding x or y . 
16 . Distribution Classes and Transformational Rules . 
Let p be a string and T ( p ) its transfo~n by the transformation T . Let P be a set of string sp to which T is applicable  . We defined the transform T ( P ) of P as the set of all T ( p ) 's:
T ( P ) = set(T ( p ): pinP).
A rule will be written in the form f(T ( P ) ; Q ) to indicate a relation between the sets T ( P ) and Q . 
In order to specify the sets a little closer to the form of rules usually prepared by linguists  , we put p = p ( 1 ) p ( a ) - - - p ( i ) - - - p ( m ) q = q ( 1 ) q ( 2 ) ---q ( j ) ---q ( n )  , where p(i)'s and q(j)'s are segments in p and q , respectively . Then we put
P : P(1)---P ( i)---P ( m)
Q = Q(1)---Q(j)---Q(n) , which are to be understood as concatenated sets if strings  . 
A rule of the form f(T ( P ) ; Q ) is applicable to the string p , if p(i)~P ( i ) for i = i ,  2 ,  --- , m , giving T ( p ) 6 T ( P ) , so that f(T ( P ) ; Q ) provides us with the information governed by this rule  . Each string in the lexicon and each constituent in the string under analysis or synthesis is given a marker which indicates whether or not it belongs to any set of strings  , provided that the sets are established systematically  . Because of the ambiguous property of real strings  , the markers will be given in terms of complete neighborhoods defined over the set of  ( potentially ) acceptable strings . 
17 . Establish !~ ent and Representation of Complete Neighborhoods  . 
A syntactic function is called a complete neighborhood if it is defined as a set of contexts  . We use conventional terms and redefine them as symbols assigned to complete neighborhoods  . .
17 . 1 . In establishing a set of complete neighborhoods of a natural language  , we assize a few of them as undefined terms and derive the others by hypothetical concatenation rules  . Sometimes , there will be a choice among a few hypothetical
Sakai 42 rules . We take one of them to define a complete neighgorhood and regard the others as the property of the complete neighborhood defined by the former  . 
Thus , we distinguish two kinds of rules : definition rules and property rules  . 
Le taxb = c and xd = f be hypothetical rules . If one decides to regard the former as the definition of x  , the latter is a property of x . ~% is method is applied not only to phrase structure grammar but also to transformation alo ~ ammar  , because both transformations and inverse transformations are applied to a  ( pair of ) P-marker ( s ) to yield another ( pair of ) P-marker ( s )  . 
Every time a definition rule is established as a hypothesis  , it must be tested as to whether or not it contradicts any other definition rules  .  "~ ~ , oproperty rules should contradict any other rules  . % ~ nenever a contradiction is found , the source of trouble must be found out by tracing back the definition rules  , and the hypothesis that has given rise to the trouble must be modified  . 
17 . ___~2 . The complete neighborhoods of all the acceptable strings  ( as distinguished from the other ambiguous interpretations of the same string  ) are identical to each other and consist of one element indicating that the strings are acceptable  . It seems adequate , for most of the natural languages , to admit two complete neighborhoods , nominals and verbals , although there are no rigid grounds . Many others are derived from hypothetical concatenations that can occur in acceptable strings  . 
The prepositions in many European languages are subclassified by the case of the nominals they govern  , and the nominals by their case , gender and number . 
A rule for yielding prepositional phrases will be stated as follows : a preposition that governs nominals of case c  , followed by a nominal of case c ' , of any gender and of any number , results in a prepositional phrase , provided the cases c and c ' are the same . As suggested in this example , subclassific-ation and desub classification are useful to describe syntax  . A number of indices are made use of in subclassifying a broadly defined complete neighborhood  . The example above will be rewritten , by introducing the indices c for case , g for gender and n for nu~nber , and a coefficient d(c , c') , in the form prep(c)n(c';g ; n ) = d(c , c ') prep-n , where d(c , c ') = 1 if c = c' , = 0 if c~c' . 
Sakai 43 % he indices g and n are arbitrary if the preposition in question takes nominals of any gender and of any number  . 
Usually , a linguist will define completen , ~ g ~ no or noocs broadly so that the majority of acceptable  . . . . .   . . . . ~ rmn ~ may be generated and recognized correctly  . 
As his analysis proceeds further in c ~ e o a 1 ~ , he ~ ill take an exa~mT ~ le that is not generated or recognized correctly by his broadly defined complete neighborhoods : generation may give him some unacceptable strings or the syntactic analysis may give himerroneous or unnecessarily ambiguous interpretations  . 
He will then trace back the definitions and find out some of his rules hold in his example with respect to a subset of one of his complete neighborhoods  . 
Suppose he has a set R ( x  y ) of rules to concatenate x and y . His new example will indicate that the rules are not always true  . He may then establish the subsets x ' , x " , y ' , y " , and a new set of rules which allows x'y ' and x " y  ~'  , for instance , but not x ' y " or x " y ' . 
17 . 3 . Let a broadly classified complete neighborhood be shown by a symbol  , say , v . If a subclassification thereof is desired , we introduce an ind exp , such that v : v(pl)Uv(p2) U---Uv(pn ) . 
When the subclassification is not necessary , we put p = O ; v(o ) : Uv(pi ) , i : l , e ,  --- , n . 
The union of a few subsets are written as v < Pl , P3 , P5): v(PI)Uv(P3) UV(Ps) , etc . 
If a complete neighborhood is to be subclassified from a few different points of view  , ~smany indices are introduced : v(p;q ) , v(p;q;r ) , etc ; v(Pl , P2; q ) = v(Pl;q)~v(P2; q) , v(p ; ql , q a ): v ( ~; q l ) U v ( p ; q a ) , v(p ; o ) nv < o ; q ) : ( Uv(p ~ qj )) ~( Uv(pi~q )) = v(p ; q ) , etc . 
Hence , for the distribution classes ~( V(Pl , pa ; ~)) : H(V ( ~ l;q )) NX(v(P a ; q)) , 
I(v(p;q )) = !( v < p;o )) ~\] i(v(o ; q)),
Sakai 44 etc.
Sometimes , an index depends upon other indices : v(p ; q(r ; ~ ; t )) , for example . ~% emeanings of r , s and t depend upon the meaning of q . 
The above scheme may be further generalized . Let a complete neighborhood be represented by a number of indices  ( a ; b ; c ; --- ; n ) , where the broad class symbol is one of the indices and each index represents a classification from a certain point Of view  . 
It will be of interest to compare these indices with the concept of " razbijenije "  , " okrjestnostj " ( Kulagina , 1958) or " sememe " ( lamb ,  1962) . ~ nisk in d of representation , used by many research groups , enables us to describe the syntax of a language systematically  . Each digit can be regarded as an indication of a certain feature common to some elementary neighborhoods  , and classifies them according to their specific features  . 
1_~ . 4 . Suppose a concatenation rule f(uv ; w ) is to be applied to a text xy of complete neighborhoods to determine z = xy  , and the complete neighborhoods are represented by the indices in the form x =  ( a ( x )  ; b(x) ; --- ; n(x )) , y = ( a(y ); b(y ); ---; n(y)) , z = ( a(z ); b(z ); ---; n(z)) , u : ( a(u ); b(u ); ---; n(u)) , v = ( a(v ); b(v ); ---; n(v)) , w = ( a(w ); b(w ); v--; n(w )) . 
If a rule indicates the relation between the pair ( i ( u )  , j(v )) of indices and an index k(w ) , and if all the others are independent of these , we have u = ( o ;  - - -  ; o ; i(u ) ; O ;  - - -  ; o ) , v : ( o ; ---; O ; j(v ); O ; ---; O) , 
Fw = ( O ; ---; O ; k ~ w ); O ; ---; O).
If the pairs ( i(x ) , i(u )) , ( j(y ) , j(v )) and ( k(z ) , k ( w ) ) satisfy the condition specified by the grammar system being used  , the rule is applied to xy and gives a z modified by this rule  . ~nerule gives no information as for the other indices  . This information should not be lost if it is in x or y  . 
We have to indicate in the rule how to transfer the information to z from x or y  . A simple method was used in a translation program  ( Sakai ,  1961) . 
A transformational rule requires that certain features of the original 
Sakai 45 string are carried forward to its transform . ~ l is requirement is usually indicated by the identity of features of certain segments in the original string and its transform  . The use of rules is to be programmed in such a way that  , if the rules are applicable to the string regardless of a certain index  , the value of the index in the original string is transferred to the corresponding index of the transform  , and vice versain case of an inverse transformation  . 
17_~ . . An extremely simplified example is given . % ~ necomplete neighborhoods are no longer treated as sets  . The symbol ~'+" means " or " . The symbol "=" does not necessarily mean an identity : it can be replaced by a narrow  . The segments of the string ~ heyarered ~ ianes 1   2   3   4 are rePresented in the form ( h , k ) : ( i , i ) = they ,  (1 , 3) = they are red (2 , 3) = are red , etc . 
Both ( h , i)(j , k ) and ( h , i ) *( j , k ) mean the concatenation of the strings ( h , i ) and ( j , k ) . The following abbreviations are used . 
adj : adjective adj-pred:adjectival predicate an im : animate compl : complement in an im: inanimatem:masculinen:nominal n/n : modifier of nominal nom:nominative pl : plural pn : pronouns : sentence v : verbal-k : ends with k-t : ends with t 
Sakai 46
Input Langua ~ e . . . . .
( l , 4) ( v ; s ) = ( l , 1) ( pn ; 3rd " ' ~), ~ . - ~ (2 , 2) ( v ; be ; pres ; 3rd ; pl ) * (3 , 4) ( n ; p !) (3 , 4) ( n ; pl ) : (~ , 3) ( ac , j ) ~ (4 , ~)(:~ , ;'?l)
Intermediate Renresentaion.
(l , 4)(v ) = ( i , l)(pn;3rd' , p- , ; ' nom ) ' ~ (2 , 2) ( conula ; pres) .  * (3 , & )( n ; compl ; pi ) (3 , 4) ( n ; comp !; pl ) = (3~3)(n/n )* (4 , 4)(n;compi;pi)
Output Lan ~ uae ( Russian ) ( i , l ) ( pn ; 3rd ; pl;nom ) = on(Dl ; nom ) = oni(2 , 2) ( copula ; pres ) = ( ) (3 , 3) ( red ) ( n/n ) = krasn(adj ; hard ) (4 , 4) ( plane ) ( n ; comp! ; l ) = ( rubank(-k ) ~ samol jet(-t )) ( n ; m ; pl ; nom ) = ( rubanki+samcijety)(n ; m ; pi ; nom ) (3 , 4) ( n ; compl ; pl ) = ( b , b)ta~:;na ; ~ J ~ (4 , ~)( n ; m ; pl ; nom ) = (3 , 3)-yje(4 , 4) '  .   .   .   .   .   . '"" I " UO ~' . -~- i -= , ') = ~ samoljety )( i , 4) ( v ) ( i , i ) ~ , ~ ,  )<~  . ontok ~' as nvje ( . . . . . . . 
Output L~n , ': ua::e:-""(1 , 1)(pn ; Srd ; pl ; nom ) = ( i ~ are(anim ) ~ sore(inanim )) ( pn ; pl ; nom ) (2 , 2)(copula ; pres ) = ar(v ; % ; pres:final ) = ar-u(3 , 3) ( red ) ( n/n ) = aka(adj-pred~n/n ) (4 , 4) ( plane ) ( n ; compl ; p !) = ( keimen ? hikooki)(n ; in an im ; compl ) (3 , 4) ( n ; compl ; pl ) = ((3 ,  . -5)-i(4 , 4)) ( n ; in anim)-de(l , 4) ( V ) = ( l , !) ( anim , : in an im~pn ; pi;nom )*( ~ , 4) ( n ; in anim)-de * (2 , 2) ( v ; %; lores ; ~ in ai ) = ( l , i ) t l n a n ~ m ; p n ; ip ; nom j * < p , 4) ( u ; mz ~ on mm)-~e*(2 , 2)(v ; 4 ; pres ; final ) = sorera ( ga~wa ) akai ( heimen+hikooki ) dearu 17 . 6 . We observe in ~ heabove example ~ hat the index of an animate or an inanimate object affects the choice of a lexicai element in Japanese while it is not relevant in ~ zlzsn  . if ' h is phenomenon may be considered syntactic in one lauguage and semantic in another  . Take two languages A and B , and suppose A has a syntactic markero ' ~ qender and  '5 does not . The gender is considered syntactic in A and sema : r ~ i ciu S  . The syntactic genders are sometimes arbitrary and cannot beal '  . ~- , ?/~ nrcse : :' veci'a the ~ rans zer process from one language to another  . We will , :~ v ~-~= t;o--'~*e . , ~ ar < . ~~:-twose ; oarate_procedures for handling . ~ r ; . ~  . . . . . . . armse ~ . ~ . ~ res::~ec ~ toozher indices gender . Si : : ; ilar ~-"- ~ . . . . . . : ~ e choice of iexical elements de\]cends greatly upon the habitual usage ~  . ~ onissi ; t ; iiar when we observe some combinations of of language  , k ~ ne = -' ~ . . . . . . . 
longer constituents . . The ch,:, . ice of constituents is limited by logical , semantic or habitual reasons as indicated by the branches of ' the second kind 
Sakai47 in the net strings . Sometimes the choice is quite capricious . It seems more practical to handle this kind of information separately  ( Matthews ,  1965) , corresponding to the separate normative devices the lin&~ist has conjectured  . 

The need of defining distribution classes was recognized when I was with the Machine Translation Project  , bniversity of California . The basic approach was worked out at the First Research Center  , Defense Agency of Japan , and was refined and finished at the Project on Linguistic Anaiysis  , Ohio State University . I appreciate the encouragement of these organizations  . 

Gross , M . : On the Equivalence of Models of Languages Used in the Fields of Mechanical Translation and Information Retrieval  , NATO Advanced Study Institute on Automatic Translation of Languages  , Venice ,  1962 . 
Hasimoto , A . Y . : Revised Rules of Mandarin Grammar , Project on Linguistic Analysis , Ohio State University , Columbus , Ohio ,  1964 . 
Kulagina , O . S . : ObOdnom Sposobje Oprjedje ljenija Grammatic eskix Ponjatijna Bazje Tjeorii ~ ho~estv  , Probljemy Kibjernjetiki , Vypuski , Moskva ,  1958 . 
Lamb , S . M . : Outline of Stratificational Grammar , University of California , 
Berkeley , California , 1962.
~ t the ws , P . H . : Problems of Selection in Transformational Grammar  , private circulation , indiana University , to appear in the Journal of Linguistics , 
No . l , 1965.
Opler , A . ; Silverstone , R . ; Saleh , Y . ; Hildebran , M . ; Slutzky , I . : The Applic-ation of Table Processing Concept to the Sakai Translation Technique  , Mechanical Translation , vol . 7, No . 2, 1963 . 
Parker-Rhodes , A . F . : A New Model of Syntactic Description ,   1961 International Conference on Machine Translation of Languages and Applied Language ~ alys is  , Her Majesty's Stationary Office , London . 
Sakai , I . : Syntax in Universal Translation , 1961 International Conference ( See above) . 
Wang , W . S . : Two Aspect Markers in Mandarin , Project on Linguistic Analysis ( See above ) , Report No .  8, 1964 . 
Sakai48

AI . Sets.
a ~ A ; ~ in A : ~ is an element of the set A ; ~ belongs to A ; ~ is in A . 
a ~ A ; ~ not in A : a ~ A is not true.
A ( = ) B : there is at least one element which belongs to both A and B  . 
A ~ B ; B ~ A : if a ~ A , then a ~ B ; A is a subset of B ; B is a superset of A . 
A = B : a ~ A if and only if a ~ B ; A ~ B and A ~ B .
A #B : A = B is not true.
A = O : there is no element in the set A ; the set A is empty . 
A = set(a , b , c , d ) : A is a set whose elements are a , b , c and d . 
A = set(ai:i = 1, 2, ---): A = set(al , a2,---).
A = set ( a:f ( a ) ): a ~ A if and only if f ( a ) is true . 
A = B~C : A = set(a:a ~ Bora ~ C) ; A is the union of B and C . 
A = Usi , i = l , a , ---:~: BIUB2U---?A = UB for f ( B ) : A is the union of all B's satisfying f ( B )  . 
A = B~C : A = set(a:a ~ B and a ~ C) ; A is the intersection or meet of B and C . 
A = Di'i = 1, 2, ---:, = nB2n--
A = ~ B for f ( B ) : A is the intersection of all B's satisjying f ( B )  . 
A2. Boolean Coefficients.
We introduce coefficients which indicate presence or absence of sets  . 
The value of a coeffi-ax = 0 = empty set , if a = O , = x , if a = ! . 
The suma ? b and the product ab = aXb are determined by axUbx =  ( a+b ) x = x , if a = I or b : l , = O , if a = b = O , and ax ~ by = ab ( xDY )  =  ( aXb ) (x ~ y ) = xDY , if a = b : i , = O , if a = 0 or b = O . 
Therefore , the coefficients are Boolean : 0+0 = O , 0 + i=i+0=i+i = i , 0X0 = 0 XI=iX0 = O , IX i = i . 
Consequently , for concatenation , we have ( ax)(by ) = abxy . 
Let a , b , etc . be the coefficients and x , y , etc . sets . 
cient is either 0 or i:
Sakai 49
Table of Contents 1.

















Symbol ; String ; Language.
Context : Neighborhood.
Equivalence of Contexts.
Complete Neighborhood.
Elementary Neighborhood.
Distribution Class.

Concatenation of Complete Neighborhoods.
Concatenation of Distribution Classes.
Rules for Recognition and Generation.
Complete Neighborhood Representatic n of Concatenation Rules  . 
Distribution Class Representation of Concatenation Rules  . 
Some Remarks on Transformation.
Complete Neighborhoods and Transformational Rules.
Distribution Classes and Transformational Rules.
Establishment and Representation of Complete Neighborhoods  . 



Table of Contents.
