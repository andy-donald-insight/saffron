Constraining Tree Adjoining Grammars by Unification 
Karin Harbusch
Deutsches Forschungszentrumfiir Kiinstliche lntelligenz 
Stuhls at zenhaus weg 3,6600 Sa r briicken 11
F . R . G .
Phone : (+49681) 3025271 , Fax : (+49681) 3024261
E-Mail : harbusch@dfki.uni-sb.de

In a proposal , Vijay-Shanker and Joship resented a definition for combining ttw two formalisms Tree Adjoining Grammars and PATR unification  . The essential idea for that combination is the separation of the two recursion operations - adjoining and unification-to preserve all properties of both formalisms which is not desirable for natural anguage applications  . In this paper , a definition for the integrated use of both processes i given and the remaining properties of the resulting formalism are discussed- especially weighing the appropriateness of this d ~finition for natural anguage processing  . 
i 1 Introduction iln the field of natural anguage analysis  , Unification Grammars are a main research topic . Presently , Unification is defined as extension of context -fleegrm nm~s  . 
Knowingth , e formalism of Tree Adjoining Grammars ( in the following called TAGs in short )  , which is closely related to contextfreegr , ' tmmars ( in the I611 owing abbreviated CFG ) , the idea arises to replace the contextfree grammar in a Unification Grammar by  ; tTAG . The advantage of TAGs is that complete context-fl ' eederivation trees or parts of them build the rq les of that grammar type  ( e . = . , , with the intention of ~ e presenting a whole linguistic phenomenon  )  . The ~ ecursion operation for TAGs allows the replacement of nodes by a tree  ( defined by a TAG-rule )  , so that largert ; tructure u ' ees are processed . 
In the literature , a first definition for combining these two formalisms was proposed  , where the main idea is Iosepwate the two recursion processes-adjoining and unification - to preserve all properties of both Herea different approach is chosen  , where both recursion processes are integrated . The main point to emphasize here is that the different approaches not only represent a  . ' ; witch between two modes of interpreting the same definition  , but a change in the properties of the resulting formalism  . 
This can be sirnply demonstrated by the property of monotonicity of the unification  . Associated with each lree of a TAG all sp ? ification rules for the unification are interpreted at once  ( e . g . , represented as links between the DAG representation of the specification rules at each node in the tree  )  . If now the recursion process of TAGs , the adjoining operation , combines two trees , which both have DAGs , a strategy for reinterpretation of specification information must be defined  , because an adjoining modifies inner nodes , where links still are installed . 
lathe following , the two formalisms are briefly revisited to have a common terminological basis with ritereader  , before the existing definition of Tree Adjoining Grammars with Unification is presented  . In contrast to this approach , the new definition is motivated and its properties are discussed  . Finally , our experience with an implementation f that definition in the application domain of syntax analysis  ( e . g . , in a natural language dialogue system ) is summarized . 
2 The Two Basic Formal i sms TAG and PATR In this section  , the formalism of TAGs is motivated to be appropriate to replace a contextfree grammar in natural language description  . Weighing the disadvantages remaining for TAGs , which are these ane as for CFGs , the same extending formalism as for CFGs- Unification Grammars-has been chosen to resolve these disadvantages for TAGs  . 
2.1 A Short Outline of Tree Adjoining

In 1975 , the formalism of Tree Adjoining Grammars ( TAGs ) was introduced by Aravind K . Joshi , Leon S . 
Levy and Masako Takahashi ( see\[Joshi et al75\] )  . 
Since then , a wide variety of properties-formal properties as well as linguistically relevant ones-were studied  ( see , e . g . ,\[ Joshi85\] for a good overview) . 
The following example describing the crossed dependencies in Dutch should illustrate the formalism  ( see Figure 1 , where the node numbers written in slanted font should be ignored here  , they make sense in combination with Figure 3) . A TAG is a tree generation system . It consists of two different sets of trees , which are combinable . Intuitively , the set of initial trees can be seen as contextfree derivation trees  . 
This means , the start symbol is the root node , all inner nodes are nonterminals and all leaves are terminals  ( e . g . , in Figure 1 tree ~) . The second set , the auxiliary trees , which can replace a node in an initial tree ( which is possibly modified by further adjoinings ) during the process of adjoining , must have a form that again a derivation tree results  . The trees ~31 and \[~2 demonstrate that restriction . A special leaf ( the foot node ) must exist , labelled with the same nonterminal as the root node is labelled with  . Further , it is obligatory that an auxiliary tree derives at least one terminal  . The union of the initial mid the auxili ~ u : y trees  , so to speak the set of rules of a ' FAG , is called lhese to felementary trees . 

Treey in Figure 1 shows a TAG derivation tree , which is an initial tree with an arbitrary number of adjoinings  ( here \[51 is adjoined at the node S*inct and ~2 in the node S * in the adjoined tree 131  )  . 
or : So0vr ?
Nl Pol1 VP zwern-iol2 men ~0111~30121
Marie 13x : Slo ~= : S~o
A ("/ X y
N $ 1121V 121122 Janzag 1111\[I
Piet ~. Soo
I too ? ~ laten
Jan NP 111 VP_zag


Figure 1: A small sample TAG demonstrating the process of adjoining The most obvious property of TAG rules  ( elementary trees )  , which arises from the close relation with contextfree derivation trees-with which linguists are familiar - is the easy way to write and understand such rules  . The advantage instead of a contextfree grammar producing the derivation trees is that related facts can be described in one rule  . E . g . , in Figure 1 , each tree contains exactly the dependent pieces without any further processing  ( for more examples see , e . g . ,\[ Kroch,
Joshi85\]).
With the close relation between TAGs and CFGs , one can think that both formalisms are equivalent  . But TAGs are more powerful . In the linguistic community , it is discussed controversially , how powerful a linguistic formalism should be ( see , e . g . , Pullum 84\] or\[Shieber85\]) . TAGs are mildly context-sensitive , which means that they can describe some context -sensitive languages  , but not all ( e . g . , www with w e  a , b , but ww is acceptable for a TAG ) . There is the thesis that natural anguage can be described very well by a mildly context-sensitive formalism  . But this can only be empirically confirmed by describing difficult linguistic phenomenons  ( here , the example in Figure 1 can only give an idea for the appropriateness of TAGs fbr natural language description  )  . 
If an efficient implementation faparser for TAGs is desired  ( e . g . , in a natural anguage access ystem to an expert system  )  , the existence of polynomial time acceptors for the word problem of TAGs becomes relevant  ( upper time bound O ( n4 log n )  , see\[Harbusch89\]) . On the basis of thi ~ efficient algorithm the new definition has been implemented which is mentioned later in the summary  . 
With this short impression of some advantages of the TAG formalism  , the disadvantages s bould now be tackled . The main property , which has its roots in the close relation to contextfree grammars  , is the same problem with subcategorisation . Further information encoded in the category name leads to combinatory explosion of the grammar  . In the framework of CFGs , this disadvantage is removed by defining a Unification Gr ~ Jnrn arc ? tending a context-free grcunmar  . 
2.2 PATR Unification Briefly Revisited
A Unification Grammar U ( brief ! y called UG or PATR grammar ) consists of a CFG G , where each rule is extended by a possibly empty set of specification rules  ( for a good introduction to Unification Grammars , e . g . , see\[Shieber 87\]) . Such a rule consists of two paths which , are unified . A path consists of a number uniquely referring to a constituent in the contextfree rule together with a list of feature names and/or an atomic value  . 
A pair ( contextfree rule , list of specification rules ) is called unification rule . E . g . , ( (S NP VP ) )  ( ( ( 0 fset ) (1 fset ) ) ( (lfset syntax ) (2 fset syntax ) ) ( (2 fset syntax verbform ) active ) ) ) ) is such a rule . Another representation of the specification rules is a DAG  ( directed acyclic graph )  . Figure 2 shows this representation for the above described exauaple rule  . It is built by representing the numbers , feature names and values as nodes which are connected in the way riley are put together in the string representation  . Common prefixes are represented only once . 
0 - - - ? set ~ , )  1 -- fset-L syntax ~ 2 --fset--syntax-X-verb form --' active Figure  2: Example of a DAG representation 168   2  . 
The pro~'ess of recursion-called unificat ion - is defined as an operation of union on all specification rules according to a contextfree derivation  , loosely spoken . 
Moreh ) rmally , the result of the unification of two DAGs x and y  ( UNIFY ( x , y )) is defined inductively as a new DAG z , where - z = x , if x = y , -z = x , if x is atomic and y is empty , and vice versaz = y , if y is atomic and x is empty , - if neither xnory is atomic , then V features I such that II , ul~x , II , vley , I 1 , UNIFY(u , v ) Iez and V features I such that II , wl~(uuv)-(ur~v ) , 
II , wlez.
It is easy to see that this extension of the contextfree formalism allows us to introduce various additional information by specification rules  . The main problem of the formalism is that it has Turing capacity - and so all disadvan'tages inherited with this power  . Informally , this paper shows that the combination with TAGs restricts the power of unification  . 
3 The Two Different Definitions of TAGs with Unification Although Turing capacity is not a wishful property  , unification seems to be a good extension for TAGs as speeifiation rules :  ( ( ( 10  ( 11  ( (11 well . In this section , two different definitions for TAGs with Unification  ( UTAGs ) are presented in a common terminology to simplify their comparison  . 
3.1 Tile Definition of tile Grammar for
TAGs with Unification
Same as to define specification rules according to a contextfree rule  , where the relation between both sets is represented by unique node numbers to refer to the different constituents in a rule  . Here , according to an initial or an auxiliary tree , these specifications are defined between father and sons or between brothers via unique node numbers all over the trees  . The trees c ~ , 131 and ~2 in Figure 1 ( now interpreting the unique node numbers of the elementary trees  ) together with the according specifications in Figure  3 describe an example TAG with Unification , which produces the propagation of some syntactic and senmntic information from the lexical items to the root node of the different subsentences  . 
Note that the unique node numbers are also helpful to identify the individual adjoined trees in the derivation tree  . To prevent heambiguity resulting from adjoining the same tree more than once  , the node number of the eliminated node is taken as a prefix for all new nodes  . 
( ( (00 fset ) (01 fset ) )  ( (01 fset ) (02 fset ) )  ( (01 fset ) (012 set ) )  ( (011 fset ) (012 fset ) )  ( (012 fset ) (0121 fset ) )  ( (011 fset ) (0111 fset ) ) ) fsetsem_role depsent action )   ( ( ( 20 fsetsere_role dep_sentaction ) fset sem_role action ) )  ( 22 fsetsere_role action ) ) fset ) (12 fset ) )  ( (20 fset sem role dep_sent dep_sent action )   ( (11 fset ) (112 fset ) )  ( (111 fset ) (112 fset ) )  ( (111 fset ) (1111 fset ) )  ( (11 2 fset ) (1121 fset )   ( (112 fset sem_role dep_sent actor )   ( 1121 fsetsem_role actor ) ) ) 
Lexicon ( 22 fsetsem__role dep_sentaction ) )  ( (21 fset ) (22 fset ) )  ( (211 fset ) (211 fset ) )  ( (22 fset ) (222 fset ) )  ( (22 fset sem_role dep_sent dep sent actor )   ( 221 fsetsem_role depsentact pr ) )  ( (22 fset sere_role dep sent actor )   ( 221 fsetsem_role actor ) ) )  :  ( Marie ( ( N ( ( syntax hum ) sing ) ( ( syntax case ) nom ) ( ( syntaxpers )  3 )   ( ( synt_role subject ) Marie ) (sem_role actor ) Marie ) ) )   ( ( N ( ( syntax hum ) sing ) ( ( syntax case ) dat ) ( ( syntaxpers )  3 )   ( ( syntrole d_obj ) Marie )   ( ( sere_role recipient ) Marie ) )  )   ( ( N ( ( syntax num ) sing ) ( ( syntax case ) acc ) ( ( syntaxpers )  3 )   ( ( syntrole i d obj ) Marie ) ( ( sem_role recipient ) Marie ) ) ) )  . . . same information for Jan and Piet . . . 
(zwemmen ( ( V ( ( syntax verbform ) inf ) ( ( synt role verb ) zwemmen )   ( ( synt role subject ) ) ( (synt_role d_obj ) NONE )   ( ( syntrole i d obj ) NONE ) ( ( sem_role action ) zwemmen ) )  ( laten ( ( V ( ( syntax verbform ) inf )   ( ( syntrole verb ) laten ) syntroled_obj ) NONE )   ( ( syntrole i d obj ) NONE ) ( ( (sem role action ) laten ) ) )   ( zag ( ( V ( ( syntax verbform ) f in )   ( ( syntax pers )  3 ) ( ( syntax hum ) sing )   ( ( syntrole verb ) zagen ) ( ( synt_roled_obj ) NONE )   ( ( synt_role i d obj ) NONE ) ( ( sem_role action ) zagen ) ) ) Figure 3: Specification rules for c ~ ,   131 and 132 in Figure 1   3   169 To get an impression of what that grammar does , one can read all relations between father and sons in all initial and auxiliary trees as contextfree rules annotated with the corresponding specification rules  . 
To realize this partial interpretation of specification rules  , the following sets for each node x are defined : l " x := the set of all specification rules with x father or brother of the other mentioned node in that rule  , Sx := the set of all specification rules , where x is a son of the further mentioned node in that rule and  0x := the set of all specification rules , where a value of x is defined . 
It is easy to see that for each node these sets can be automatically computed  . E . g , for the node 01 in c ~ , 1"01:=(((00fset ) (01fset)) , ((01fset ) (02fset)) , $01:=(((01fest ) (012fset)) ,  001 := ~ . Vijay-Shanker and Joship refer to write the grammar in the  1"   ( TOP , or briefly called t ) and $ ( BOTTOM , b ) terminology , which allows slide differences in expressiveness , e . g . , a nonempty TOP set of the root node of an auxiliary tree can be specified  . 
The Unification Grammar , consisting of all rules built by interpreting each father and all its sons in all elementary trees as contextfree rules  , together with all TOP sets , can be interpreted as described in section 2 . 2 . 
But it is important to note , the two result in grammars are not equivalent , because the contextfree grammar doesn't require the derivation of the whole tree  , if one contextfree rule out of it is in use . 
Considering this simple and intuitive interpretation fa UTAG  , the problem of defining adjoining and unification directly for such a grammar becomes obvious  . Only the relations between father and sons or brothers are interpreted directly  , although there are links defined over a whole tree  . This is exactly the point , where the two defin ~ . tions differ . 
3.2 The Definition of Vijay-Shanker and

The definition of Vijay-Shanker and Joshi separates this local information  ( for a description of their approach see , e . g . ,\[ Vijay-Shanker 87\]) . It reminds us of the interpretation fattributes after computing the contextfree derivation tree for an Attribute Grammar  ( e . g . , see\[Aho et al86\]) . 
In their approach , the 1" and $ sets remain isolated until all adjoinings are made  . With this strategy it is clear that the unification cannot be used to reduce the number of structure trees  , which are unificationally ill-formed . 
More formally spoken , the adjoining is defined as described in Figure 4   ( for the reason of uniquely referencing to the 1" and $ sets at each node X , t and b with different bar levels are used ) . After all adjoinings were made , all 1" and $ sets at each node are unified . 
The disadvantage of this sequential interpretation of adjoining and unification can be demonstrated by the example grammar  . In the lexicon , all names , " Marie " , " Piet " and " Jan " , have three different cases ( nominative , dative and accusative ) . Therefore , three structurally equivalent trees are produced for each tree c ?  , \[~1 and ~2 . 
These are structurally combined by adjoining . Out of this collection , by the specification rule , which demands a subject , unification selects one correct reading . But this is checked after building nine different derivation trees  . 
Figure 4: The adjoining definition for the approach of
Vijay-Shanker and Joshi
One way to handle that problem is to use unification with disjunction to reduce the set of structurally equivalent trees  . But this doesn'tackle the problem fundamentally , because it cannot reduce ambiguities , which only can be eliminated by interpreting the specification rules at once  . This integration is realized in our new approach . The different approaches are abbreviated with SUTAG for the more sequential approach of Vijay -Shanker and Joshi  , and IUTAG for a more integrated approach , which is presented now . 
3.3 All Integrated Definition for TAG and
Unification
The basis for our definition is a UTAG given in the notation as described in section  3  . 1 . For each elementary tree , a set of specification rules is defined , which can be interpreted as unified DAGs over the whole tree  . E . g . , the path " fset sem_role action " of node 01 has the value " z wemmen " . 
If an adjoining should happen in a node X , for this node the sets '\[' X , SX and < ) X are computed because this node and with it " all links from its DAG to other DAGs are replaced by an auxiliary tree  . Structurally , the adjoining looks like the original one for TAGs  ( and same as for SUTAGs )  . In the case of an adjoining , a node in an ( possibly modified ) initial tree should be replaced by a whole auxiliary tree  \[3  , and all links that node had have to be modified by the information of ~  . 
You can imagine the new linked DAGs all over the adjoined Iree as being a filter for the former propagated information  . E . g . , information passing a node X , where an adjoining will take place , must not be supported by the path from the root to the foot node of the adjoined auxiliary tree  . So the propagation is stopped somewhere in the tree  . 
More formally spoken , the definition of adjoining can be given as described in Figure  5  . The DAG of the node , in which the adjoining will take place , is represented by $ and $ sets . 
Here , r and f stand for the whole DAG of the root and foot node of the auxiliary tree  , which will be adjoined . 
But it is obvious that the 1" set of r is empty as well as the $ set off . This is clear because there exists no father of the root and no son of the foot node where these links can end  . 
Using the same terminology for the auxiliary tree as in Figure  4   ( r is separated in t " and b ' , and fint " and b ") , one can write instead of " UNIFY(t , r ) " as well 17 o4 " UNIFY(t , b ') " and for " UNIFY(b , f ) " as well " UNIFY(b , t ")" . What becomes obvious is that in the : cesulting m ~ each node has a DAG  , which is connected with the DAGs of its neighbors in the tree  . This was lheaim of the new definition , always to produce linked DAGs all over the derivation tree to test for failure of an ification at once  . 
~iIFY(t'r )
NIF ?( b , f)
Figure 5: Tile adjoining definition for IUTAGs ~ ut this is not the complete definition  ; there are two things to be added . One is the concrete handling of the elimination of links and the second is the reintroduction of the value definition of the eliminated node  . 
t ~ eginning with the elimination of links , the separation into q " and $ at a node X , an adjoining will take place , means that all information propagated along the node X is eliminated  ( e . g . , one can imagine a reason maintenance system to keep track of that task  , so that unification is no more commutative and independent from the time of introducing information  )  . E . g . , information t'rom a leaf is propagated to the root of the whole tree  . 
This propagation can be interrupted , modit'ied or keptt m touched if an adjoining takes place  . Intuitively , the adjoined tree can be imagined as a filter for the propa-?~ation  . 
Some extra computation must be done fortile reintro-duction of ' d invalue in l\-  ) rmation ( 0X ) in the following way . Since tim node , in which a value is defined , will be eliminated in the case of an adjoining , the question arises , what should happen to the value definition ? tlere  , it was decided to find a point for the reintro -duction of that information  . The first idea can be to say , i . ~y definition add it to the root node . But now a fail cant , ,e produced in the case ltmt lhe adjoined tree adds parts ~ f the path to reach that value  ( e . g . , if the value definition in node X with the node number  01 is ( (01 ilset ) val ) and in tile root node ( 10 ) of the adjoined tree , dm specification rule exists ( (10 fset next )   ( 11 fset ) ) , atail is produced because fset has at the same time a feature and a value as  successo0  . To allow this property to be interpreted without failure  , which is desirable for iheidea of defining a filter via adjoining  , a computation t ) fsuch paris of paths in the adjoined tree is done to find the maximal extension of the path  , behind which the value can be added without producing a fail  . 
in this process , called computation of the inheritance history , all maximal prefixes of paths in the adjoined auxiliary tree are computed  . Out of this set , those candidates are chosen , which have the value definition as prefix p . Behind these maximal paths the value is reintroduced  . Because this selection does not always have a unique path at exactly one node as result  ( e . g . , if ~- oot and foot node add two different feature names behind p  , but between both no propagation occurs ) , at the end of both paths the value is reintroduced by definition  . It is clear that the computation of the inheritance history can be done once for all paths in all auxiliary trees  , so that this part of the definition doesn't extend the execution time very much  . The most elaborate work has to be done in reconstructing the correct links all over the derivation tree after an adjoining  . In the worst case , changes of propagation all over the derivation tree are required  . 
To give an idea of how this definition works , in Figure 6 the changes during the adjoining of \[31 and 132 in a are represented . Here only the nomin at vereading is in use , because the lexical reading with case dative and accusative produces a fail in unification with the valency description of the verbs  . Concentrating on the feature path " fset sere_role "  ( note , we don't claim that this is a serious semantics of the sentence !  )  , first the meaning of " Mariez wemmen " is produced  ( action is " zwemmen " and actor is " Marie " )  , which is modified during the adjoining by " Pi et laten " and " Janzag "  . 
3.4 Tile Comparison of tile Properties of
SUTAG and IUTAG
Finally , let's weigh the two approaches . A first impression in reading both definitions can be that the differences are marginal  . It is simply a decision in ordering processes . But a second look offers that there , are more differences . The ideas of what should be represented by an adjoining are different  . A SUTAG supports the monotone idea behind unification and the parallel and absolute presence of propagated knowledge  ( what is written in tile '1" and , \[ , sets should be propagated exactly fiom that node all over the tree with ot  , t any more changes ) . In a UTAG , the idea of filtering propagated information has the highest priority  . Specification information should be revisable by new adjoinings  . Each of the two approaches works more efficient for different problem classes  , which cannot be characterized in more detail here . 
For SUTAGs , the main disadvantage is the late interpretation f the specifcation rules  . Especially he relies the motivation for the definition of IUTAGs  . In the abovementioned example , the focus in describing the advantage of online unification is demonstated by the representation f the intermediate states of the DAGs  , but it is clear as well , how the lexical readings with case equal dative or accusative for " Marie "  , " Pict " and " Jan " are eliminated . 
Another distinguishing feature of IUTAGs is that unification is not further a monotone process as it is in SUTAGs  ( same as for UGs )  . Links , which have been installed , can be eliminated . This is the more formally circumscribed effect of a filter  , which is the intuitive idea behind that definition  . It is obvious that the realization of that fact is more expensive than to wait until all adjoinings are realized  . But it comes up with a reduction of execution time for invalid readings  . 
Actually , this is a tradeoff , which has more or less effect on the time complexity in the relation in which specification rules are used to subcategorize and restrict the structural descriptions  . Therefore , both definitions probably have more lxz r fect application domains  . 
A point which was mentioned as a disadvantage of the Unification formalism  , was the Turing capacity . For both definitions of UTAGs , the power is restricted in a 5   i71 wayt ! hatnopath can be introduced via specifications without adding a piece of structure  , because the definition of an elementary tree requires a nonempty leaf  . Therefore , the defined unification process under lies the constant growth property  . At the moment , it is not yet clear , what class of languages can exactly be described with that formalism  , but it is obvious that it is less powerful than Turing machines  ( e . g . , languages such as a 2n are not describable) . But a result for an upper time bound of an algorithm for that formalism is yet unknown  . 
by 1' ( 01 ) reaching 01 in cc by 1' ( 11 ) reaching 11 in ~1: and reintroduced at 11 ( and reintroduced at 20 ~ ryd!oining , of 131)' , after adjoining of \[32 ) ntax-vero form-in!~set ' ~" .   .   .   .   .   . fsett-syntax-verb form-infy\[It\[ulevero -zwemmen  ,  ~ ,   . ^,  .   .   .   .   .   . a ~,^~~:1i- . dobj-NONEL d_obj-NONE i dobj gem role -action tz wemmen /  ,  7 .  - ,  . 
- ~ , sem_role , ~ actlon-laten ,  -  , ~ ~ ~ sent kac_tj . oj3,,oy4,(01) reacning01 in c-- .   .  ,  .   . " bv . $ tl1 ~ reac ~ ( anore introouce oat 1121 .   .   .   .   . 
after adjoining of \[31 )   ( and reintroduced at 2_21 ~ , fsetr syntax~-uase-nomafter adjoining of ~9)
Ipers .   3 fset\[syntaxi-ease-nSm-num-sgi ~ pers-3 //"\[ synt_role--subject-Marie ~ num-sg\[' semrole-actor k  ,   , ~ ~ yntrole--subjeet-fPiet--~"-~~em -roleltactor ~ ~ lepsent Lact ~ information at the root of  7: fset , syntax-~erb form-fin'case-nom ' pers-3 ~syntrole ~' verb-lzagen-~subject-Jan~d _obj-NONE 
I ' id__obj-NONE \' sem_role ~ action-laten\\[ actor-Jan\I dep sent-actor --" ~\\ dep_sen ~ action  . . . . " -~ ! \[ N I " dep-sent aet?r ~ ) ~I ~ i ~- dep sentaet ~ Figure 6: Some intermediate states for an example demonstrating the adjoining definition for IUTAGs  4 Summary Also the UTAG definition can be seen purely as a theoretical result  , syntax description as the most prominent application domain has influenced the design  . Therefore , our experience with an implementation of the IUTAG definition running a natural language grammar is mentioned here  ( for all technical detail see\[Buschauertal .  89\]) . The system is written in Common LISP on a Hewlett Packard machine of the  9000 series with emphazise on efficiency . E . g . , the response time for a small test grammar and sentences of alertgth of about  10 words is less than 10 milliseconds . Presently , this pure parser is extended by tools ( e . g . , consistency check ) to build a work bench for linguists designing IUTAGs  . 
On this basis , more empirical results should be produced for that domain  . Currently , we work on further extensions of the definition ( e . g . , ID/LP for free word order in German ) . Our main emphaziselies on the aspect of incrementality  . In this paper the interpretation direction of the definitions was analysis  . But the other direction , the problems in generation are faced now , with the ambitious aim to verify that IUTAGs are appropriate for a bidirection alnd integrated description of syntactic  , semantic and pragmatic facts . 
Literature \ [ Aho et al 861 . A . V . Aho , R . Sethi , J . D . 
Ullman : Compilers : Principles , Techniques , and Tools , Addison-Wesley , Reading , Massachusetts ,  1986 . 
\[ Buschauertal . 89\]B . Buschauer , P . Poller , A . 
Schauder , K . ttarbusch : Parser fiir TAGs mit Unifikation , " AI-Laboratory " Memoin press , Department of Computer Science , University of the
Sau'land , Saarbr ~ icken , FRG , 1989.
~ ~ K . Harbusch : Effiziente
Struktur analysen atiir licher Sprachemit Tree Adjoining Grammars  , PhD Thesis , University of Saarland , 
Sa , ' ubriicken , FRG , 1989.
\[ Jo ~\] A . K . Joshi : An lntroductior ~ to Tree Adjoining Grammars  , Technical Report MS-CIS-64 , University of Pennsylvania , Philadelphia , 
Pennsylvania , 1985.
\[ Josl\]i et al . 75\]A . K . Joshi , L . S . Levy , M . 
Takahashi : Tree Adjunct Grammars , Journal of the Computer and System Sciences 10 ,  1975 . 
\[Kroch , Joshi85\]A . S . Kroch , A . K .   3oshi : The Linguistic Relevance of Tree Adjoining Grammars  , Technical Report MS-CIS-16 , University of Pennsylvania , Philadelphia , Pennsylvania ,  1985 . 
\[ Pullum 84 . \]G . Pullum : On Two Recent Attempts to Show That English is Not a CFL  , Computational
IJnguistics 10:4, 1984.
\[~ S . M . Shieber : Evidence against the Context-Freeness of Natural Langage  , Linguistics and
Philosophy 8, 1985.
\[Shieber87_\]S . M . Shieber : An Introduction to Unification-Based Approaches to Grammar  , CSLI-Lecture Notes 4 , Stanford , California ,  1987 . 
\[ Vijay-Shanker87\]K . Vijay-Shanker : A Study of Tree Adjoining Grammars  , PhD Thesis , University of Pennsylvania , Philadelphia , Pennsylvania ,  1987 . 

