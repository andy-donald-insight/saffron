PARSING ASTREETR AVERSAL
Dale Gerdemann *
Seminarf fir Sprachwissenschaft , Universitit Tbingent

This paper presents a unified approach
to parsing , in which topdown , bottom-
up and left-corner parsers m : e related
to preorder , postorder and in order tree
traversals . It is shown that the sim-
plest bottom-up and left-corner parsers
are left recursive and must be con-
verted using an extended Greibach nor-
malform . With further partial exe-
cution , the bottom-up and left-corner
parsers collapse togethe ~ as in the I\]IJP
parser of Matsumoto.
1 INTRODUCTION
In this paper , I present a unified ap-
proach to parsing , in which topdown,
bottom-up and left-corner parsers are
related to preorder , postorder and in-
order tree traversals . To some extent,
this connection is already clear since
for each parsing strategy the nodes of
the parse tree are constructed accord-
ing to the corresponding tree traversal.
It is somewhat rickier though , to ac-
tually use a tree travers a . l program as a parser since the resulting pa . rser may be left recursive . This left recursion can * The research presented in this paper was partially sponsored by TeilprojektBd " Constraints on Grammar for Efficient Generation " of the Sonderforschungsbereich  340 of the Deutsche Forschungsgemeinschaft . I wouhl also like to thank Guido Minnen and Dieter Martini for help flfl comments  . All mistakes are of course my own . 
? KI . Wilhelmstr . 113, D-72074 T ( ibingen , Germany , dg@sfs . nphil . uni-tuebingen . de . 
be eliminated , however , by employing a version of Greibach Normal Form which is extended to handle argument instantiations in definite clause grammars  . 
The resulting parsers resemble the standard Prolog versions of versions of such parsers  . One can then go one step further and partially execute the parser with respect o a particular grammar---as is normally done with definite clause gra  , ,nn~a , ' s(Per ( , ir ~ ~ Warren\[JO \]) . a surprising result of this partial execution is l  . ha . t the bottom-up and left-corner parsers become identical when they are  1  ) oth partially executed . This may explain why the BUP parser of ~/ lil . tSlll\]OtOeta\] . \[6\]\[71 was ,' eferre . dtO as a bottona-uI ) parser even though it clearly follows a left -corner strategy  . 
TREETRAVERSAL
PROGRAMS
Following O ' Keefe\[8\] , we can implement i ) reorder , postorder and in order tree tra . versals as I ) CCs , which will then 1 ) e converted directly into topdown \] ) otl . om-u1) and heft-corner l ) arsers , respectively . The general schema is : x . _order ( '\]' t'ee )  --*  ( x_ordered node labels in Tree )  . 
Note tha . t in this case , since we are most likely to call x_order with the Treeva  . riable instantiated , we are using the DCG in generation mode rather tha  . n as a parser . When used as a parser turn all trees whose x_ordertraw ~ rsal produces S  . The three , instantiations of this procedure areas\[' ollows: 
Z p reorder traversal pre(empty ) -->\[\].
pre(node(Mother , Left , Right )) -->\[ Mother\] , pre(Left ) , pre(Right ) . 
postorder traversal post(empty ) -->\[\].
post(node(Mother , Left , Right )) --> post(Left) , post(Right ) , \[ Mother \] . 
in order traversal in ( empty ) -->\[\].
in(node(Mother , Left , Right )) --> in ( Left) , \[ Mother \] , in ( Right ) . 
2.1 DIRECTENCODING OF
PARSING STRATEGIES
Analogous to these threet l'a versal programs , there are three parsing strage-gies , which differ from the tree traversal programs in only two respects  . First , the base case for a parser should be to parse a lexical item rathe  , : than to parse an empty string . And second , in the recursive clauses , the mother care . goryfits into the parse tree and is licensed by the auxiliary predicate rule  /3 but it does not figure into the string that is parsed  . 
As was the case for the three tree traversal programs  , the three parsers differ from each other only with respect to the right hand side order  . \]) ' or simplicity , I assume that phrase structure rules are binary branching  , though the approach can easily be generalized to non-biuary branching  . 1% topdown parser td(node ( PreTerm , lf(Word ))) - >\[ Word\] , word ( PreTerm , Word) . 
td(node(Mother , Left , Right )) --> rule(M other , Left , Right ) , gd(Left ) , td(Right ) . 
bottom-up parser bu(node ( PreTerm , lf(Word ))) - >\[ Word\] , word ( PreTerm , Word) . 
bu(node(Mother , Left , Right )) --> bu(Left) , bu(Right ) , rule ( Mother , Left , Right) . 
Y , left-corner parseric ( node ( PreTerm , lf(Word ))) - >\[ Word\] , word ( PreTerm , Word ) . 
ic(node ( Mother , Left , Right )) --> ic(Lef %) , rule ( Mother , Left , Right ) , ic ( Right ) . 
iks seen here the on \] y difference between the t\ ] lree strategies concerns  , he . 
choice of when to select a phrase structure rule . 2 Do you start with a . rule and then try to satisfy it as iu the topdown apl ~ roa  . ch , or do you parse the ( laugh-t(ers of a . rule . first before selecting the rule as in the bottom -up approach  , or do youl , al ( eaninte , ' mediate strategy as in the left-corneral ) l ) roach . 
lq ' he only ln ' oblematic ease is for left corner since the corresponding tre  . etraw ~' rsal in order is normally defined only for bina  , ' y trees . But in order is easily extended to nonbinary trees as follows : i  . visit the left daughter in in order , ii . visit the mot , her , iii . visit the rest ; of the . 
daughters in in order.
eAs opposed to , say , ~ t choice of whether to use operations of expanding and matching or operations of shifting and reducing  . 

GREIBACH NORMAL
FOR MPARSERS
While this approach reflects the logic of the topdown  , bottom-up and left-corner parsers in a clear way  , the resulting programs are not all usable in Prolog since the bottom-up and the left-corner parsers are left-recursive  . There exists , however , a general technique for removal of left -recursion  , namely , conversion to Oreibach normal form . The standard Oreibach normal form conversion , however , does not allow for I ) CG type rules , but we can easily take care of the Prolog arguments by a technique suggested by Problem  3  . 1 18 of Pereira & Shieber \[9\] to produce what I will call Extended Greibach Normal Form  ( ECINF )  .   3 Pereira & Shieber's idea has been more formally presented in the 
Generalized Greibaeh Normal Form of
Dymetman (\[1\]\[2\]) , however , the simplicity of the parsers here does not justify the extra complication in Dymet-man's procedure  . Using this transfor-mation , the bottom-up parser then becomes as follows : 4 a EGNF is similar to normal GNF except that the arguments attached to nonterminals must be manipulated so that the original instantiations are preserved  . For specific grammars , it is prettye~y to see that such a manipulation is possiMe  . It is nmch more dif-tl cult ( and beyond the scope of this paper ) to show that there is a general rule t br such manipulations  . 
4The Greibach NF conversion introduces one auxiliary predicate  , which ( following II opcroft & Ulhnan\[4\] ) I have called b . Of course , the GNF conversion also does not tell us what to do with the auxiliary procedures in curly brackets  . What I've done here is siln ply to put these auxiliary procedures in the transformed grammar in positions corresponding to where they occurred in the original grammar  . 
It's not clear that one can always find such a " corresponding " position  , though in the case of the bottom-up and left -corner parser such a position is easy to identify  . 
% EGNF bottom-up bu(node ( PreTerm , lf(Word ))) - >\[ Word\] , word ( PreTerm , Word) . 
bu(Node ) -->\[ Word\],word(PreTerm , Word).

b(L , node(Mother , L , R )) --> bu(R) , rule ( gother , L , R ) . 
b(L , Node ) --> bu(R ) , rule ( Mother , L , g ) , b(node ( Mother , L , R) , Node) . 
This , however is not very ef\[icient since the two clauses of both bu and b differ only in whether or not there is a final call to b  . ~ Ve can reduce l . hea . mount of backtracking by encoding this optiol mlity in the b procedure itself  . 
% Improved EGNF bottom-up bu(Node ) -->\[ Word\] , word ( PreTerm , Word ) , b(node ( PreTerm , lf(Word)) , Node) . 
b(Node , Node ) -->\[\].
b(L , Node ) --> bu(R ) , rule ( Mother , L , R ) , b(node ( Mother , L , R) , Node) . 
l~ytile same I " , GNI : transform ~ L tion and improvement , s , tile resulting left-corner parser is only minimal ly different from the bottom-up parser : 
Improved EGNF Left-corner
Ic(Node ) -->\[ Word\] , word ( PreTerm , Word ) , b(node ( PreTerm , lf(Word)) , Node) . 
398b ( Node , Node ) -->\[\].
b(L , Node ) --> rule ( Mother , L,g),
Xc(R ), b(node(Hother,L,R ), Node).
4 PARTIAL EXECUTION
The improved ECNF bottom-n paltdleft-corner parsers  ( lil Ihr now only in the position of the auxiliary l  ) redicate in curly brackets . If this auxiliary predicate is partially executed out with respect to a particular gramlnar  , the two plt rsers will become identical . For example , if we have a rule of the \[' or l ) l : s(tree(s , NP , VP )) --> np(RP) , vp ( VP ) . 
For either parser , this will result in one b clause of the form : b ( np ( NP )  , Node ) --> lc(vp(VP )) , b(node(s(tree(s , NP , VP )) , np(RP ) , vp(VP)) , Node) . 
This is essentially eqtfivalen to the kind of rules produced by Matsumoto et al  ( \[6\] \ [7 \ ]  ) in their " bottom-up " l ) arser BUI )  . sAs seen here , Mal , sumo ( . o et al were not wrong to call their parser bottom - ui  )   , but they could have just as well call edit left -corner  . 
5 CONCLUSION
In most standard presentations , impletop down , bottom-up and h' . ft-corner a This rule is not prec is (' . ly the same as ( . he rules used in BUP since Matsumoto et al con > pile their rules all tth ! further to take adv ~tll-tage of the first argument and predicate name indexing used in Prolog  . 
parsers are described in terms of pairs c ) fop ( wations such a . sexpand/ma ( , c \] l , shift/reduce or sprout/nlatch , lt lt it is en l , i rely unclear wha . (, expa . nding and matching has to do with shifting , reducing ors prouting . By relating parsing ( . otree tri ~ versal , however , it b ( :-comes much clearer how these three ap-proac\]ms 1  , oparsing rcbd ; e to each other . 
This is a natural comparison , since clearly t , hel ) OSSiloh : orders in which a tree can be traversed should not diff  ( H'frolll the possible orders in which a parse I , ree can be constructed . ~ Vhltt's new in this paper , however , is tile ideagh a . ( , such tree traversal programs could be translated in top ~ trsers usillg extended  ( ' , reibach N or , ha . 1Form . 
Such a unified approach to parsing is mostly useful simply  (  , ounderstand how the different l > arsers are related  . It is sm ' prising Cose e , for examph : , that with partial executiol L the bottom-up and \ ] el't-corn c  . r parsers be (' ome , the same . 
The similarity bel ; we eut > ot ( , om-u1) and h:ft-corner pa . rsing ha . scaused a certain all/Ollllt ( If ( : on I ' usion in the literature . 
l " or example , (, It (' . so-calh'd " botton>ui)"charti)arse . rl ) resenl , ed(among otherl ) laces ) in Cazda . r " ~ M e . llish\[3\]in fact uses a left-corner strategy . This was pointed out by Wiren\[ll \] but has not receive  ( l much attention in the litera-I . ure . It is hoped I . ha . 1, the unif i (' . dap-proa . ch to parsing l ) re . seifix : dh (: rewill hell ) 1 , oclearu I > ol , her such confusions . 
Finally , one Inight ) nentiol ) aco)l--heel . ionto C , ovcrnm (' . nt-llinding parsing ja . spresentedill , Iolms on & Stabhn '\[5\] . 
These a . uthors present a generate amd test approa . (: h , in which X barstruc-l , lli'es ~ ll Teramlomly generated m~d then tesl , edagldnst lIB principles . Once ( , he logic of the program is expressed in such a ma . uner , cfIi ( ' iency considerations are used in order to fold the testing procedures into the generation procedure  . 

One could view the strategy takel ~ in this paper as rather similar  . Running a tree traversal program in reverse is like randomly generating phrase structure  . Then these randomly generated structures are tested against the constraints  , i . e . , the phrase structure rules . 
What I have shown here , is that the decision as to where to fold in the constraints is very significant  . Folding in the constraints at different positions actually gives completely different parsing strategies  . 
References\[1\]MarcDymetman . A generalized greibach normal form for definit ; e clause grammars . In COLING-92 vol . I , pages 366-372, 1992 . 
\[2\] Marc Dymetman . Tra'asforma-tions de Grammaires logiques . Ap-plicatios au probIeThc de la re-versibilite ~ n TraduclionA~do'ma-tique  . PhD thesis , Uniw ; rsite/le
Grenoble , Grenoble , France , 1992.
The . ~ ed'Etat.
\[3\] Gerald Gazdar and Chris Mellish . Natural Lang~tage Processi . ng in Prolo 9 . Addison-Wesley , Reading , Mass , 1989 . 
\[4\] John It opcroft and .) effrcylJlhmm.
Introduction to Automata 7' h , c-ory and Computation . Addison-
Wesley , Reading , Mass , 197!).
\[5\] Mark Johnson and Edward Sta-bler , 1993 . Lecture Notes for
Course taught at the LSA Summer
School in Columbus Ohio.
\[6\]Y . Matsumoto , H.t Iirakawa.,
I Miyoshi , and I1 Yasukawa . Bup:
A bottom-up arser embedded in prolog . New Ceneration Comp ~ tl-ing , 1(2):145-158, 11983 . 

Is\]\[10\]\[11\]
Yuji Matsumoto . Natwral Language Pars in 9 Systems baaed on
Logic Programming . PM ) thesis,
Kyoto University , 1989.
Richard O ' Keefe . The Craft of
Prolog . MIT Press , Cambridge,
Mass , 1990.
Fernando C . N . Pereira and Stuart Shieber . ProIo9 and Natural
Language Analysis . CSLI Lecture
Notes No . 10. Chicago University
Press , Chicago , 1987.
Fernando C . N . Pereira and Davidl I .  1) . W ~ m : en . Definite clause grammars - asurw ' . y of the formalism and a comparison with augmented transition et works  . Arli Ji-cial \[' ntelligence , 13:231-278, 1980 . 
Also in Groszet . al .,: 1986.
I Vlats \ Viren . A comparison of rule-invocation strategies in contextfree chart parsing  . In EACL
Proceedings , 3 lh Annual Meeting , l ) ages 226-233 ,  11987 . 

