A Logic Programming View of Relational Morphology
Harvey Abramson
Institute of Industrial Science , University of Tokyo
Minato-ku , Roppongi 7-22-1, Tokyo 106, Japan
email : harvey@godzilla.i is.u-tokyo.ac.jp
Abstract
We use the more abstract term " relational morphology " in place of tile usual " two-level morphology " in order to emphasize an aspect of Koskenniemi's work which has been overlooked in favor of implementation issues using the finite state paradigm  , namely , that a mathematical relation can be specified between the lexical and surface levels of a language  . Relations , whether finite state or not , can be computed using any of several paradigms , and we present a logical reading of a notation for relational morphological rules  ( similar to that of Koskenniemi's ) which can in fact be used to automatically generate Prolog program clauses  . Like die finite state implementations , the relation can be computed in either direction , either from the surface to the lexie a level , or vice versa . At rite very least , this provides a morphological complement to logic grammars which deal mainly with syntax and semantics  , in a programming environment which is more user -friendly than the finite state programming paradigm  . The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate  . Further speed can be obtained when a Prolog compiler  , rather than an interpreter , is used for execution . 
Introduction . Kimmo Koskenniemi's socalled " two-level model " of computational morphology  ( 1983 ) in which phonological rules are implemented as finite state transducers has been the subject of a great deal of attention  . The two-level model is based partly on earlier work of Johnson  ( 1972 )  , who considered that a set of " simultaneous " phonological rules could be represented by such a transducer  , and of Kaplan and Kay ( 1983 ) who thought that ordered generative rules could be implemented as a cascading sequence of such transducers  . Koskennie miin fact implemented the phonological rules by a set of finite state tranducers unning in parallel  , rather than by a single large finite state machine into which many cascading machines could be combined  . Subsequent to Koskenniemi's original work , there was a LISP-based implementation called KIMMO  ( Kartunnen 1983 )  , and two-level descriptions of English , Rumanian , French and Japanese ( Kartunnen and Wittenburg , Khan , Lun , Sasaki Alam 1983) . A later LISP based implementation by Dalrymplet al  ( 1987 ) called DKIMMO/TWOL helped the user by converting two-level rules into finite state transducers : in earlier implementations  , and in the recent PC-KIMMO system ( Antworth 1990 )  , it was the user's task to generate the machine , s from two-level descriptions . 
However on every important contribution of Koskeaniemito morphology  , namely the notion that there is a relation between the surface and lexical " levels "  , has been somewhat overlooked by implementation issues having to do with the couversion of two -level rules into fiuite state automata in the various KIMMO systems  . The two-level rules according to this notion , unlike the rules of generative morphology which transform representations from one level to representations i the other  , express a correspondence between lexical and surface levels  . 
Furthermore since no directionality is implied ill the definition of a relation  , unlike geuerative rules , the same set of two-level rules applies both in going from surface to lexie all evels and vice versa  . Rather than being proceth tral rules , they are declarative . Consequently , any correct implementation of the two-level rules is a relational program which can be used either analytically or generatively  . We will henceforth , in order to emphasize the fact that a relation is being defined by them  , refer to relational morphology rules rather than to them a thematically neutral term " two-level rules "  . 
Despite the recognition that relational morphology rules are declarative  , the main emphasis n using them has been obscured by the original finite state implementation technique  . Recently , Bear (1986) has interpreted such rules directly , using Prolog as an implementation language . 
This , although an improvement on finite state implementations from the point of view of debugging and clarity  , still misses an important aspect of relational morphology rules as a declarative notation  , namely that if relational morphology rules define a relation between surface and lexieal levels  , then that relation can be specified and implemented using any of several different relational programming paradigms  . In this paper , we will show that logic programming , which can be viewed as a relational programming paradigm  , can be used to give a declarative reading to morphological rules  . Further , because of the execution model for logic programs  , embodied in various logic programming languages such as Prolog  , the declarative reading also has a convenient procedural reading  . That is , each relational morphological rule may be thought of as corresponding to or generating a logic program clause  . The entire set of logic program clauses generated from the relational morphological rules  , coupled with some utility predicates , then constitutes a morphological nalyser which can either be used as a standalone program or which can be coupled as a module to other linguistic tools to build a natural language processing system  . Since the roles have been transformed into logic program clauses  , they gain in speed of execution over Bear's interpretive method  , and further speed can be gained by compiling these clauses using existing Prolog compilers  . At the very least , this provides a morphological complementologic grammars  ( Abramson and Dahl 1989 ) which deal mainly with syntax and semantics , in a programming environment which we believe is more user-friendly than the finite state programming paradigm  . 
It may be argued that this is a step backwards from the linear efficiency of finite state processing  . However , when ACRESDE COLING-92 , N^N TES , 2328^o ( rr 1992850 PRoc . ov COI . ING-92, NANTES , AUG .  2328 ,   1992 discussing " efficiency " it is very important to be very precise as to where the efficiency lies and what it consists of  . Finite state processing is linear in the sense that a properly implemented finite state machine will be able to decide whether a string of length  , ~ is acceptable or not in a time which is O(n ) , i e , for large enough n , a linear multiple of n . For small values of u , depending on how much bookkeeping has to be done , " finite state algorithms " may perform worse titan algorithms which are formally O  ( n2 ) or higher . Any processing in addition to recognition may involve time factors which are more than linear  . This entirely leaves aside the question of the user-friendliness of the finite state computing paradigm  , a question of how " efficient " in human terms it is to use finite state methods  . Anyone who has trie M to implement finite state automata of substantial size directly  ( as in Koskenniemi's original implementation , the first KIMMO systems , and KIMMO-PC ) will have realised that programming finite state machines id is tastefully akin to directly programming Turing machines  . A substantial amount of software is necessary iu order to provide a development  , debugging and maintenance environment for ea ~ y use of the finite state computing paradigm  . There also remains the theoretical question as to the ' adequacy of finite state morphological descriptions for all  , or even most , human languages . However , this is a topic we shall not venture into in this paper  . 
In our method , a relatively small Prolog program generates logic programming clauses from relational morphology rules  . The generated clauses ( at least in the experiments so far ) are readable and it is easy to correlate the generated clause and the original morphological rule  , thus promoting debugging . The standard ebugging tools of Prolog systems ( at the very least , sophisticated tracing facilities ) seem sufficient to deal with rule debugging , and the readability of the generated clauses hould help in the maintenance and transference of morphological programs  . 
Thus , from the softwarengineering point of view , logic progrannming is a more sophisticated , higher-level programming paradigm than finite state methods  . Also , should finite state descriptions in the end prove inadequate  , or even in convenient , for all of morphology , logic programming provides expressive power for reasonable extension of the notation of relational morphology rules  . 
The current availability of Prolog compilers , even for small machines , provides another increment of speedy execution of the generated programs  . Many of the morphological rules produce logic program clauses in which checking of the lexical and surface elements and contexts reduce to unification followed by a recursive call of the morphology predicate  . Compiled Prolog abstract machine code for such clauses is usually very compact  . 
Prolog compiler indexing mechanisms often make it possible to access the correct clause to be applied in constant time  . 
Notational Aspects . Our table a unotation for relational morphology rules is as follows: 
LexLeft <= Lex => LexRight < :>
SarfaccLeft <= Surface => Surface Right which expresses the relation between a lexical and a surfaceua it  ( Lexaml Surface , respectively ) , provided that the left and right contexts at both the lexical and surface levels  ( LexLeft , LexRiglnt , Surface Left , and
Sufface Right ) are satisfied.
Another kind of relational morphology rule which is allowed is: 
LexLeft => Lex <= LexRight < :>
Surface Left => Surface <= Surface Right.
which expresses a relationship between Lex and Surface providing that the left and fight contexts at the lexical and surface levels are different from those specified by LexLeft  , LexRight , Sufface Left , and Surface Right . This means that either LexLefl or LexRight is not satisfied  , and also that either Surface Left or Surface Right is not satisfied  . 
More coutpact notation is also accepted , for example :
LexLeft : Surface Left <= Lex : Surface =>

LexLeft : Surface Left=>Lex : Sarface <=

In the case where a pair of lexical and surface contexts are identical  , or if the lexical and surface elements are identical  , they need not be repeated . Such compressed rules as the following are also allowed : 
Left <= Element => Right.
Left => Element <= Right.
Sets of symbols may be specified : set ( vowel , \[a , e , i , o , u\]) . 
Lexical entries may be specified as follows : lexicon : : eat = noun  , root = craps . 
lexicon : : cat = noun , root = pimlo.
This feature notation is that used in the author's Definite 
Feature Grammars ( Abrams on 1991).
Logical reading of relational morphology roles . Corresponding to a set of relational morphology rules  , a binary predicate morphology/2 specifies the relation between a lexical and a surface stream of characters : morphology  ( LexStrcam , Sufface Strcarn ) . 
In order to specify the logic program clause which corresponds to a relational morphology rule  , we have to manipulate heleft and right lexical and surface contexts  . 
We can find the right contexts within LexStream and Surface Stream  , but we have to provide a specification of the left contexts  , and we do this by defining the above binary predicate  morphology/2 in terms of a quaternary predicate morphology/4: morphology ( LexStmanL Surface Stream , 
Left LexStream , I ., eft Surface Stream).
ACn'E SDECOIJNG-92 , NArcri ; s , 2328 A of z r19021~51P~toc . oF COLING-92 . NANTES , A ~ JG .  2328 ,   1992 Left LexStream and Left Surface Str camre initially empty and are represented as reverse order lists of the left contexts which have a heady been seen  . The toplevel definition of morphology/2 is : morphology ( LexStremn , Surface St~un ) :- raor phology ( LexStream , SurfaceSu'emn , II , \[1) . 
The fundamental logic program chmseco ~ reslxmding to a relational morphology rules neham 
LexLeft <= Lex => LexRight < :>
Surface Left <= Surface => Surface Right.
is morphology ( LexS " tman ~ , Surface Stremn , Left LexStream , l . ~efiSl ~' aceS"Imam):-
LexStream = lLllLexRest\].
Surface Stream=\[SllSurface Restl , \[ exeme ( Lex , L1) , surface ( Surface , S1) , lex context ( LexLefl , Lefd . exStre , ' un , LexRight , LexRest ) , surface e on text ( Surface Left . lmftSurfaceStmam,
Surf ~ eRight , Surfhce Rest),
NewLeftLexStreaan=\[Llll~eftLexStream\] , NewLeftSurfaceS " tmanl=\[S111 . eftSuriaceStream\] , morphology ( LexRest , Surface Rest , NewLeftLexSlae at m , Newl . eti Surface ? hean 0 . 
Here , LexStream and Surface Strean lare analysed as consisting of the first characters LI and SI  , and the remaining streams , LexRest and Surface Rest . It is verified that L1 is the lexeme specified by Lcx , and S1 the surface character specified by Surface . ( Lex , Surface , LexLeft , LexRight , Surfime Left , and Surface Right are as given iurite morphology rule  . ) Contexts are checked by the subgoals lex_context and surface context  . Newleft context streams are created by prefacing the old left context streams with LI  , and S1 ( note again that the left context streams are built np in reverse order  )  . Finally , the predicate morphology/4 is recursively called on the remainder of the lexical and surface streams  , and with llu ~ new left context streams . 
Although the logical reading of this appears to involve many subgoals  , in fact t br many relational morphology rules , the subgoals are compiled a way into simple unifications  . See the Appendix which contains at . set of relational morphology rules dealing with simple English plural forms and their corresponding logic program clauses  . Space does not permit us to comnlent on file example  , or how the compiler works , but the interested reader may contact heauttmr . Further papers will deal with these topics . 
Conclusions and future research . We have provided here in the setting of logic programming a morphological complement to the logic grammars which mostly concentrate on syntax and semantics  . However , we have also provided a notation and a logical reading of that notation which suggests fi ~ rther exploration as to expressiveness and efficiency  . If the context in a relational rule is specified by a regular expressimt  , the appropriate context stream is parsed using a small logic grammar which defines such expressions  . It may however makes en ~ , in approaching nonconcatenative aspects of morphology  , to be able to specify lexical contexts with more stnmtt ~ rethml regular expressions allow  . The implementation would be easy : in place of the logic grammar used to parse regular expressions  , a more complicated logic grammar ( contextfree , at least ) would be used for lexical context verification . It is also thought that metarnles ( see Abrams on 1988 or Abramson and Dahl 1989 ) will be u ~ fulin dealing with noncone a tenative aspects of morphology  . Since the project is at a nearly stage , there is not yet a next on sive set of examples . We expect o develop a full set of rules for English morphology  , and it specification of Japanese verb forms . 
Ackunwledgment . The author wishes to acknowledge the support of Ricoh Corporation as a Visiting Information Fusion Professor at the University of Tokyo's Institute of Industrial Science  . The author " also wishes to thank Prof . Akira Ishikawa of Sophia University , Tokyo , for comments on this work . Also , thanks to Profs . lshizuka and Ishikawa for help in translating the abstract  . 
References.
Abramsou , tl .  1988 . Metarules and an approach to conjunctiou in Definite Clause Translation Grammars  . 
Proceedings of the Fifth International Conlerence and Symposium on Logic Programming  . Kowalski , R , A . & Bowen , K . A . ( editors ), MIT Press , pp .  233-248, 1988 . 
Abramson , H .  1991 . Definite Feature Grammars for Natural and Formal Languages : An Introduction to the Formalism  . Natural Language Understanding and Logic Programming  , III , edited by C . G . Browu and G . Koch,
North-Iolland , 1991.
Abranlson , H . and Dahl , V .  1989 . Logic Grammars , Symbolic Computation Series , Springer-Verlag . 
Antworth , iLL . 199 ( I . PC-KIMMO : A two-level processor for morphological nalysis  . Summer Institute of Linguistics , Dallas , Texas . 
Bear , J .  1986 . A morphological recognizer with syntactic and phonological rules  . In Proceedings of COLING'86, 272-276 . Association for Computational Liuguistics . 
Dalrymple , M . et al 1987 . DKIMMO , cTWOL : a development environment lor morphological nalysis  . 
Stanford , CA : Xerox PARC and CSLL
Johnson , C . D .  1972 . Formal aspects of phonological description . The\[\[ague:Mout on . 
Kaplan , R . M . and Kay , M .  1981 . Phonological rules and finite state transdt , cers . Paper presented at the 1981
Winter meeting of the ACL/USA.
Kartmman , L .  1983 . KIMMO : a general morphological processor . Texas Linguistic Formn 22:163-186 . 
Kartammn , L . and Wittenburg , K .  1983 . A two qevel morphological nalysis of English . Texas Linguistics
Forum 22:217-228.
ACRESDE COLING-92 , NAN t'ES , 2328 AOI\]:19928 S21'; ~ . O : . OI , COI , ING-92, NANI'ES , AUG . 2328, 1992 Khan , R .  1983 . A two-level morphological analysis of Rumanian . Texas Linguistics Forum 22:253+270 . 
Koskenuiemi , K .  1983 . Two-level morphology : a general computational model for word q bun recognition and production  . Publication No .   11 Helsiuki : University of Helsinki Department of General Linguistics  . 
Lun , S .  1983 . A two-level morphological analysis of French . Texas Linguistics Forum 22: 271-278 . 
Sasaki Alum , Y .  1983 . A two-level molphological analysis of Japanese . Texas Linguistics Forum 22:229-252 . 
Appendix . Elementary formation of plttrals in

(0) x <='+'=>\[ s , '#' l < :> x <= e =>\[ s , '#'\] + (1) z <='+'=>\[ s , '#' l < :> z <= e =>\[ s , '#'l . 
(2) y<='+'=>\[s,'#'l<:>i<=e=>Is,'#'\].
(3) s <='+'=>\[ s , '#' l < :> s <= e =>\[ s , '#'\] , (4) o <='+' =>\[ s , '#' l<:>o <= e =>\[ s , '#'\] . 
(5)\[ c , h\]<='+'=>\[s , '#' l < :>\[ c , h\]<=e => Is , '#'l . 
(6) Is , hi <='+' =>
Is , '#'\] < :>
Is , h\]<=e => Is,'#'\].
(7) <= y=>'+'<:>in(con)<---i = >.
(8) not ( set (\[\[ c , h\] , s , \[s , hl , x , z , yl )) <~:'+'~:> Is , '#' l < 7> not(set(\[\[c , h , e\] , Is , eJ , \[s , h , el , lx , eI\[z , el , \[i , e\]1)) <=0 => Is , '#'\] . 
% Note negative context here , (9) set (\[\[ c , hl , s , \[s , h\] , x , z , y \]) => e <=\[ s , '#' l<:>set(\[\[c , h\] , s , \[s , h\] , x , z , i l ) = . - c<~\[s,'#' l . 
% This is a default ale.
(10)  . _ <= i u(X , char_e ) =>_< :>_<= in(X , chare ) = > . 
set ( chare , \[a , b , c , d , f , g , h , i , j , k , l , m , u , o , p , q , r , s , t , u , v , w , x , y , z , '#' I ) . 
set(con , \[b , c , d , f , g , h , j , k , l , m , u , p , q , r , s , t , v , w , x , y , zl ) , In addition to specifying characters such as s , x , etc . , we can also del iue ~ qnences of characters noted aS lists Is  , h\] , not ( characte 0 , uot ( sequeuce ol characters ) , in(con ) means any member of the ~ tcon , whereas i u(X , charc ) is a member of the setch are ~ ssigncd to the variable X for unification in another part of the tal c  . '+' is used as a mnrphenlelamm'lary , 0 is used as the null symbol , '#' is used as a neadm~ker , and '' is used to specify a don't care context . By providing a complete specification of context we cnnld remove any consideration of ordering of the rides  , lIowever , it is convenien to depart slightly l'i ~ m~m order free formalism by allowing default rules such as our last one with don't care contexts which SlW  . cify what happens to syuubols not dealt within any of the atore-menlioned rules  , to appear at the end . 
(*) moq flology(\[l,\[1,A,B).
(0) morphology (\[+ , s , #\[A\] , \[ e , s , #1B\] , \[ xlC\] , \[ xlD\]):-morphology(Is , #1 AI , Is , #1B\] ,  \[+ , xlC\] , \[ e , xlD\]) . 
(1) monf ~ hology(\[+ , s , #1A\] , \[ e , s , #1B\] , \[ zlC\] , \[ zl D\]):-morphology(Is , #1A\] , Is , #1B\] ,  \[+ , zlCI , \[ e , zl D\]) . 
(2) ntorphology (\[+ , s , #1A\] , It , s , #1B\] , \[ ylC\] , \[ il D\]):-mnq>hology(\[s ,  #IA\] , Is , #1B\] , I + , ylC\] , \[ e , il D\]) . 
(3) morphology(l + , s#1 AI , It , s , #\[B\] , Isle\] , \[slD1):-menphology(Is , #1 AI , Is , #1B\] ,  \[~ , slCI , \[ e , slD\]) . 
(4) moq > hology(l + , s , #1A\] , \[ e , s , #1B\] , \[ olC\] , \[ oi D\]):-moq~hology(Is , #1 AI , Is , #1 BI ,  \[+ , ol C . 1,\[e , ol D\]) . 
(5) nlor phology(l + , s#1A\] , \[ e , s , #1B\] , \[ h , clC\] , \[ h , clD\]):-movpholngy(\[s , #1 AI , Is , #1 BI ,  \[+ , h , clC\] , \[ e , h , clD\]) . 
(~ , ) moq ) hology(l + , s#\[AI , le , s , #1B\] , \[ h , siC1 , \[ h , slD\]):-utor phology(\[s , #1A . I,\[s,#Ill/,\[~-, h . sIC\],\[e , h,slD\]) . 
(7) morphology (\[ y , + IA\] , lilB\] , C , IDLE\]):-con(D ) , morphulogy(\[+lA\] , B , lylC\] , \[ i , DIE \]) . 
(8) mcnphology(\[-t . , s ,  #IA\] , Is ,  #IB\] , C , 1)):-not subslxings(C , \[\[ h , el , s , \[ h , s \] , x , z , y\]) , not substrings ( D , lie , h , e\] , le , s \] , \[ e , h , s \] , \[ e , xl , \[ e , zl , It , ill ) , morphoh ~ gy(\[s , IliA\] , Is , #1 BI , I+IC\] , D ) . 
(9) moq fl~ology(\[e , A , BIC\] , \[ e , D , Ell ; I , G , 1):-not(subsUiugs(G , \[ o , I h , el , s , \[ h , si , x , z , y\]) , match ( Is ,  #1 , IA , BI )) , uot ( substrings ( H , \[ u , lh , el , s , \[ h , sl , x , z , i \]) , umteh(\[s ,  #\] , ID , El )) , moq ) hology(\[A , BIC\] , \[ D , ELF\] , \[ elG1 , \[ el Hl ) . 
(10) moq fltology(\[AIBI , \[ AICI , f ) , E ) :- charc(A) , ut or pholngy ( B , C , IAIDJ , \[ AIE\]) . 
Clause ( * ) is generated to termiuate morphologicall ) ft~cssing wh cub of lltile\[exical and surface streams ~ Ue empty  . In this case , tile left contexts are ignored . 
Chmses06 cotr cslx ) n diugto rules 06 follow the same pattern in which lcxicat and sud ~ lccsyml ~ Jls and contexts are specified within tile streams and m'e checked by unification  , followed by a recursive call to the moqfliology/4 predicate on file remainder of tile lexicalill l ( lsurfaces tfcums and wifltnew left context streams  . 
S/IC\[I clauses involving anilicatiou ol the head attda AcrEs DEC Ol  , ING-92 , NANI~S , 2328 Aoi ) r19928 S3l'l ? oc: . O;CO l,IN(;-92 . NANIES , A/JC+ .  2328 ,   1992 body which is only a recursive call of the same predicate are efficiently handled by Prolog compilers  . Clause 7 is similar excep that it also involves a check to see that the first character in the left surface context is a consonant  . 
Set definition such as : set(con , \[b , c , d , f , g , hjkl , m , n , p , q , r , s , t , v , w , x , y , zl) . 
generat ~ unit clauses : con(b ) . , con(c ) . . . . . . con(z) . 
In clause 7 , if Dincon ( D ) is instantiated ( as it is since the D represents a left context which has already been seen  )  , code generated for this by Prolog compilers amounts to something like an indexed table lookup which takes place in constantime  . Similar remarks apply to clause 10 where it is checked that A is a member of the set chare  . 
Clause 8 involves a combination of a unification check for the right context  , and a check that the left context does not consist of any of the specified strings  . Here , in order for the morphology clauses to work in both the analytical and generating directions  , the negution must be logically safe notation , i . e . , the arguments to the negation must be grounded . Logically safe negation involves the use of delaying evaluation of the negation until all arguments have been grounded  . 
Clause 9 which involves a negative context , make sure , using safe negation , that either the right context is not\[s , '#'\] or that the left context does not match any of the subslxings in the specified set  . 
Sample execution : ?- morphology(P , cries).
Root = cry % nonstandard plural formation cat = noun  , % original lexicon entry root = cry )
Suffix = s(cat = norm , % modified feature root = cry , plural = yes
P = cry+s ; % another solution ? fail .% no.
?- morphology('fox+s ', P).
P = foxes ?- morphology('piano+s ', P).
P = pianoes ; % one plural form for some nouns % which end in " o " 
P = pianos ; % another plural form fail . % no others The same clauses for the predicates morphology/2 and morphology/4 are used in solving goals in both directions . 
Japanese Summary.
~," h , 6ogfL-.)i
KoskemtiemiO 96 J\[~,:-5~L ~,~'~? ~ t/ . ,-tOP 5o  J~4 , l~t(Koskenniemi ~9~ o09~L~Jf :) I~/t ~-~
Harvey Abramson
ACI~SDE COLING-92 , NANTES , 2328 AOfJ'r1992854 Pl~OC . oi:COLING-92, NANTES , AUG .  2328, 1992
