NOTESONLR PARSER DESIGN
Christer Samuelsson
Swedish Institute of Computer Science,
Box 1263S-16428 Kls'ra , Sweden . lg-maih christer@sics . se
1 INTRODUCTION
This paper discusses the design of an LR parser for a specific high-coverage English grammar  . The design principles , though , are applicable to a large class of unification -based grammars where the constraints are realized as Prolog terms and applied monotonically through instantiation  , where there is no right movement , and where left movement is handled by gap threading  . 
The I , R . parser was constructed for experiments on probabilistic parsing and speedup learning  , see\[10\] . LI parsers are suitable for probabilistic parsing since they contain a representation of the current parsing state  , namely the stack and the input string , and since the actions of the parsing tables are easily attributed probabilities conditional on this parsing state  . LR parsers are suitable for the speedup learning application since tile learne ~ grantmar Ls much larger than the original grammar  , and the prefixes of tile learned rules overlap to a very high degree  , circumstances that are far " from ideal for the system's original parser  . Even though the seends influenced the design of the parser  , this article does not focus on these applications but rather on the design and testing of the parser itself  . 
2 LRPARSING
An LI parser is a type of shift-reduce parser originally devised by Knuth for programming languages  \[4\]  . The success of LR . parsing lies ill handling a number of grammar rules simultaneously  , rather than attempting one at a time , by the use of prefix merging . LI  ~ . parsing in general is well described in \[1\] , and its application to natural language processing in  \[12\]  . 
An LR parser is basically a pushdown automaton , i . e . it has a pushdown stack in addition to a finite set of internal states  , and a reader head for scanning the input string from left to right  , one symbol at a time . In fact , the " b " in " LW ' stands for left-to-right scanning of the input string  . The " W's t and s foreons t r , cting the rightmost derivation in reverse . 
The stack is used in a characteristic way : The items on the stack consist of alternating rammar symbols and states  . The current state is the state on top of the stack  . The most distinguishing feature of an LR . parser is however the form of the transition relation -- the action and goretables  . A nondeterministic LR parser can in each step perform one of four basic actions  . In state S with lookahead symbol Syrait can : 1 . accept(S,Sym ): llalt and signal success . 
2 . shift(S , Sym , S2): Consume the sylnbol Sym , place it ontile stack , and transit to state $2 . 
3 . reduce(S , Sym , R ) : l'op off a number of items Doratile stack corresponding to tim IIIS of grammar rule R  , inspect the stack for tile ohl state S1 , place the LttSo frulettontile stack , and transit to state $2 determined by go to ( Sl , LHS , S2) . 
4. error ( S , Sym ): Fail and backtrack.
PreIix merging is accomplished by each internal state corresponding to a set of l  ) artially processed grammar rules , socalled " dotted items " containing a dot ( . ) to mark the current position . Since the grammar of Fig . 1 contains Rules 2 ,  3 , and 4 , there will be a state containing the dotted items
VP-~V .
VP--~V . NP
VP-~V . NP NP
This state corresponds to just having found a verb  ( V )  . 
Which of the three rules to apply in the end will be determined by the rest of the in l  ) ut string ; at this point no commitment has been made to either  . 
Cornpiling L\[ . parsing tables consists of constructing the internal states  ( i . e . sets of dotted items ) and from these deriving the sl , if t , reduce , accept and to teen trie . softile transition relation . New states can be in-(h , ced from previous ones ; given a state S1 , another state S2 reachable from it . by goto ( Sl , Sym , S2) ( or shift ( Sl , Sym , S2 ) if Symisaterulinal symlml ) can be constructed as I bllows : I . Select all items in state S1 where a particular symbolgym follows immediately afte  , ' the ( lot and move the dot to after this symbol . This yiehls the kernel items of state S2 . 
2 . Construct the non-kernel closure by repeatedly adding a socalled non-kernel item  ( with the dot at the beginning of the IIIS ) for each grammar rule whose LIIS matches a syn , bo\] following the ( lot of some item in $2 . 
Consider for example the grammar of Fig . 1, which will generate the states of Fig .  2 . State I can be constructed from State 0 by adwmcing the dot in S--~ . NP VP and NP--+?NPI'P to form the items S- --+ NP  . VP and NP--~NI'?PP , which constitute tire kernel of State 1 . 
The non-kernel items are generated by the grauunar lq'-~v  ( 2 ) vs ,   . -+ VNS'(3)
VP-~VNP NP (4)
VP-+VPPI'(5)
NP-, l)etN (6)
NI'-~tb'on (7)
NI'-+NI'I'P (8) 1' t > -+ Prep NP (9)
Figure 1: A toygrainniar rules for VPs and PPs , the categories following the dot in the new items  , namely I hlles 2 ,  3 ,  4 , 5 aml 9 . 
Using this method , the set <> fall parsing slates can I > e induced from an initial state whose single kernel item has the top symbol of the grammar preceded by the dot as its RI\[S  ( the item S'--+? S of State 0 in Vig .  2) . 
The accept , shift and go to e . ntries fall out autonmtically from this procedure . Any dotted item where the dot is at the end of the I  , IIS gives rise to a reduction l ) y the corresl > on dinggramm ~ tr rule . Thus it remains to determine the lookahead sylnbols of the reduce enl  , ries . 
In Simple LIt ( SLR ) the h ) okahead is any termiual symbol that can imnlediately follow any symbol of the saltle tylie as the LIIS of tile rule  . Inl , ook A head 1 , 1L ( LALIL ) it is lilly terminal sylnbol that caliil riiu e ( liately follow the LIlS giwm that it was constructed using this rule in this state  , hi general , I , AI , R gives CO ilsiderably fewer reduce entries than SI , I . , and thus results in faster parsing . Ill the experiments this reduced the l ) arsing tiines by 30% . 
3 PROBLEM SWITHLR PARSING
Thel ) roblems of applying the Lit-parsing scheme to larget mification grammars for natural language  , rather than small context : free grammars for progranmling languages  , stem from three sources . The tirst is that syu > bol matching no h ) nger consists of checlcing atomic symbols for equality  , but rather comparing CO ml ) h~x\['ea Lur ( ~structm ' es . These condistile high lew q of ambiguity of natural hmguage and the resulting nondeterminism  . 
The third is tiles heer size . of the gratllli'mrs . 
Straight-forward resorting to a contextfree back : bone grammar and subsequent filtering using the full constraints of the underlying unification gramn rar  ( U ( 1 ) is a nal > proaehtaken byl brexample\[3\] , The I ) roblem with this al > proaehis that the I > redictive power of I  , he unification grammar is so vastly diluted when feature l > ropagation is omitted  . Firstly , the contextfree l > ack-bone gramniar will ill general allow very irutlly Illore analyses titan the unification grammar  , leading to l > o or parser performance . Secondly , the f e . ature propagation necessary for gap threa<ling to prevent n < m q  . ermination due to empty productions is obstructed . 
On the other haml , the treatment of 1 , he full \[ l ( ~constraiuts in the parsing-tal ) leconsLructioil phase is associated with an mnber of problem g most of which 
Stale 0 filate 1, q'-~. SS-+NP . VI"
S -+. NP VP NP -+ NP . PP
NP-+?l ), qNVf'-,?V
NP~?l'r on VI'-+.VNP
NP-,.NPPPVP->.VNI'NI'
State ~ VI'-~?VP 1'1'
NP ~ l ) ct . NPP-~ . ib ' cpNP , ( ; talc3, fftalc
NP ~ l'r on ., '; ' ~, q ?
Elate 5Slalc 6', S'-, NP Vf'.VP--,V.
VP-+VP . l'F VP-,V . NI'
I'P - , . Prep NI'VP-~V . NI'NP
Stale 7 NI > - ~. tel N
NP-~NI'I'P . NP-~.t'ron
State 3 NP-~?NI'PP
I'P - ~ Prep ? NP Stale O
NI'~?l)ct NVP-, VI'I'P.
Nt ' ~. Prou Slate 1 0
NP-,.NP1'1 > NP-+l)etN.
fit < de11, ~ talc12
VP-, VNP . VP ~ VNI > NP .
VI>-~VNP . NP NP-+NP . PP
N\]>--, NP . PPP--,.Prep NP
NP--,.I)ctNStale 13
NI'....15" on I'P-, lb'cvNF.
Nl ' ~ . NPP l'NP--*NP . PI'PP-- . lb ' cpNI'Pf'-~?PrepNP Figure 2: The internal stales of the toy grammar are discussed in \[  , 5\] . One of the main questions is that of c quality or similarity between linguistic objects  . 
Consider constructing the non-kernel items using U  ( ~ phrases following the dotin items ah'eady in the set fo ~/ l > rediction  . If such a phrase unifies with the IAIS lda graul marule and we add theue witem with this instantiation  , we Ilee(\[amecl , ufism to ensure termination the risk is that we add more aim more i il sl  . an Liated versiolls of the same il . e . nlhl(lelhdtely . One might object that this is easily renm died I ) y only addiug items I . hatarellot sllbs lllllled by : Lily previous ones . UN-\[' or tuna Lely , this does uot work , since it is quite possible togellerate all infinites e  ( luence of items none of which suhs unlestile other  , see\[9\] . This problem call I ) esolved by using socalled " resl ; rictors " to block out the feature l ) rol ) agatiol leading to non-termination , see Ill \] , hut still the number of items t\[lat are slight variants of one-another may I  ) equite large . In her paper\[5\] , Nakazawa proposes a simple and elegant solution to this problem : " While the CLO SUILE proced ure makes topdown predictions in the same way its beh  ) re\[using the full constraints of the unitication grammar \]  , new items ; treadded without instantlation . Since only original productions in agl ' it lll ltl ~Lrappear as items  , productions ~ treadded am new items only once and the nonterml nation problem does not occur  , as is the case of the I , R parsing algorithm with atomic categoric . s . " tile non-kernel closure is quite time-consuming for large unification grammars  . 
Empty productions are a type of gramma rules that constitutes a notorious problem for parser developers  . 
The LIIS of these grammar if les have no realization in the inlmt string since their RIIS are empty  . They are used to model movement as in the sentence Whali does John seek ei  . ,2 , which is viewed as a transforn ration of John seeks what ?  . This is an example of left movement , since the word " what " has been moved to the left  . Examples of right movement are rare in English , but frequent in other languages , the prime exarnple being German subordinate clauses  . 
The particular unification grammar used keeps track of moved phrases by employing gap threading  , i . e . bypassing around a list of moved phrases to ensure that an empty production is only applicable if there is a moved phrase elsewhere in the sentence to license its use  , see\[6\]pp .  125--129 . As LR parsing is a pars-lug strategy employing bottom-up rule prediction  , it is necessary to limit the applicability of these empty productions by the use of topdown filtering  . 
4 PARSER DESIGN
The parser was implemented and tested in SICStus Prolog using a version of the SRI Core Language Engine  ( CLE )   \[2\] adapted to the air4ravel information-service ( NFIS ) domain for a spoken-language translation task \[8\]  . The CLE ordinarily employs a shift-reduce parser where each rule is tried in turn  , although filtering using precompiled parsing tables makes it acceptably fast  . 
The ATIS domain is a common ARPA test bench , attd the CLE performance on it is comparable to that of other systems  . 
In fact , two slightly ditferent versions of tile parser were constructed  , one for the original grammar , employing a mechanism for gap handling , as described in Section 4 . 2 , and one for the learned grammar , where no such mechanism is needed , since this grammar lacks empty productions , l ~ x perirnents were carried out ow ~ r corpora of 100200 test sentences , using SLI parsing tables , to measure the impact on parser performance of the various modifications described below  . 
A depth-first , backtracking LI/ . parser was used were the parsing is split into three phases :  1  . Phase one is the LI parsing phase . The grammar used here is the generalized unification grammar described in Section  4  . 1 below . The output is a parse tree indicating howtile rules were applied to the input word string and what constraints were associated with eaelt word  . 
2 . Phase two applies the full constraints of the syntactic rules of the unification grammar and lexicon to the output parse tree of phase one  . 
3 . Phase three applies the constraints of the compositional semantic rules of the grammar  . 
For tile learned grarmnar , phase two and three coincide , since tile learned rules include coml ) ositional semantic constraints . Each rule referred to in the output parse tree of phase one may be a generalization over several ditDrent rules of t it  (  ; unification grammar . Likewise , the constraints associated with each word can be a generalization over several distinct lexicon entries  . In phase two , these difli ~ rent ways of applying the full constraints of the syntactic rules and the lexicon  , and with the learned grammar also tile compositional semantic constraints  , are attempted nondeterministically . 
The lookahead symbols , on the other hand , are ground Prolog terms . Firstly , this means that they can be computed e\[llciently in the LAI  , I . case . Secondly , this avoids trivial reduction ambignities where a particular reduction is performed once for each possible ruapping of the next word to a lookahead symbol  . 
This is done by producing the set of all possible lookahead symbols\['or the next word at once  , rather than producing one at a time non -deterministieally  . Each reduction is associated with another set of lookahead symbols  . The intersection is taken , and the result is passed onto the next parsing cycle  . 
Prefix merging means the ftrules starting with similar phrases are processed together until they branch away  . q'he problem with this in conjunction with a unification gramrnar is that it is not clear what " similar phrase " means  . The choice made here is to regard phrases that rnaptotile same CF symbol as similar : Defini tion : Two phrases are similar if they map to the same conic * t-free symbol  . 
Since the processing is performed by applying colt -straints incrementally and monotonically  , where constraints are realized as Prolog terms and these are ill-stantiated stepwise  , it is important hata UG phrase map to tile same CF symbol regardless of its degree of instantiation l ' or this delinition to be useful  . The mapping of tic phrases to CF symbols used in the experiments was the naive one  , where UG phrases map l ) ed to their syntactic ategories , ( i . e . Prolog terms mapped to their \[' unctors) , save that vert ) s with different complements ( intransitive , transitive , etc . ) were distinguished . 
4.1 G , meralization
The grammar used in phase one is no tae on texl . -fl ' ee backbone grammar , nor the original unification grammar . Instead a generalized unification grammar is employed  . This generalization is accomplish using anti -unification  . T iffs is the dual of uniIication it constructs timle as t general term that subsumes two giwm terms --- and was first described in  \[7\]  . This operation is often refe . rred to as generalization i the computational -linguistics literature  . If 7' is the anti-unification of Tt and 7) , then 7' subsumes Tl and 5" subsumes 5" . , , and if any other terrn 7" subsumes both of 7'1 and 5/~  , then T's nb sunqes 7' . Anti-unifl cation is a builtin predicate of SICStus Prolog and quite acceptably fast  . 
For each contextfree rule , a generalized UG rule is constructed that is the generalization over all UG rules one such oright al UG rule  , the full constraints of the nnification grammar are applied already ill phase one  . 
Siwilarly , the symbols of the action and goretables are not contextfree symbols  . T lie y are the generalizations of all relevant similar UG phrases  . For exam-pie , each entry in the go to table will have as a symbol the generalization of a set of UG phrases  . These UG phrases are those that map to the same contextfree symbol  ; occur in a UG rule that corresponds to an item where this CF symlmlimmed httely follows the clot  ; and ill such a UC , rule occur attile position immediately following tile clot  . For example , tile synibol of the gore ( or shift ) entry for verbs between State 1 and State 6 of Fig .   2 is the anti-unification of tim RIIS verbs of tile UG rules in apping to lhlles  2  , 3 and 4 , e . g . 
vp:\[agr=Agr\]=>\[v:\[agr=Agr , sub = intran \]\] . 
vp:\[agr=Agr\]=>\[v:\[agr=/lgr , sub = ? ran\[ , np:\[agr =\]\] . 
vp:\[agr=Jtgr\]=>\[v:\[agr=Agr , sub = ditran \] , np : last =\] , np:\[agr =\]\] . 
which is v :\[ agr =_, sub =\] . llere the vahle of the subcategorization feature subis left unspecilied  . 
l , exical arn bignit yi ii the input sentence is handled in the same wliy  . For each word , a generalized phrase is constructed from all similar phrases it can lie analyzed as  . Again , if there is no lexical ambiguity within the CF symbol  , the flll UO constraints are apl ) lied . Nothing is done about lexical an-l bignities outside of the sltnie CF symbol  , though . 
In the experiments , using the UG constraints , instead of their generalizations , for tile LR-parsing phaseled to an increase in median normalized parsing tiniel from a  . 1 to 3 . 8, i . e . by 20% . This wits also typi-Gaily tile case for the individual parsing times  . In the machine learning experiments , where normally several UG rules mapped to the same CF rule  , this effect was more marked ; it led to an increase hiparsing time by a factor of fiw  . ' . 
Ontile other hand , using truly contextfree sylnbols for I , II . parsing actually leads to non-tern qhiation due to the empty productions  . Even when banning e in pty productions , the parsing times increase , by orders of lilag ~- nitude ; timvast majority (86%) of the . test sentences were timed out after ten minutes and still the nornial-ized parsing time exceeded  100 hi more than half (  , 54%) of the cases . This shouhl be compared with the 0 , 220 tigure using generalized UGeonstraiuts . Ill the mae hine-learnlng experiments , this lead to an increase in process higtime by ~ factor  100  . 
4.2 Gaph and ling
A technique for limiting the applicability of enll  ) typro-due ? ions is eniployed in the version for tile original gr ~ ull lnar  . It is only correct for left ln ove Fl tell t . ~ illoethere are no empty productions in the learned grammar  , there is no need for gap handling here . 
The idea is that in order for an empty production to be applicable  , some gramma rule must have place da ' rite parsing time for the Lit parser divided by the parsing time for the original  ) arser . 
phrase corresponding to tile in ow ; done on the gap list . 
'\[' htl saga 1 ) list is maintained where phrases corresl ) ond-instol to tenti~dleftuloventent are added whenever ~ l state is visited where there is a " gap-adding phrase " im-n-lediately following the dot in any item  . The elements of the gap list ar0 tile corresponding CF symbols . At this point the stack is " back-checked " , as defined below , to see if the gap-adding rule really is applical de  . 
I lack-cl/eck in gineans matching the prefixes of the kernel itelns agl dnstile stack in each state  . The . rationale for this is two fohl . Firstly , capturing constraints on phrases previously obscured by grain marules that have now brancl  , ed off . Secondly , cal ) turng feature agreement between phrases lit prefixes of greater length than one  . In general this was not useful ; it simply re-suited in a small overhead . Ill conjunction with gaph and lhlg , however , it proved essential . 
The gap list is enlptled after al~plying ~ ui einpty production  . This is not correct if several phrases are mow ; d using the same gap list , or for conjunctions where tile gall threading is shared between the coitiun cts  . For the refiner reasol it wo different gap lists are employed  ( ) lie for ( auxiliary ) verbs and erief or lnaXillrlall : , rojec-tions such as  Nl's , PPs , Adjl'sa . lid AdvPs . 
Ill the experhnents , on\[it ? ins the gal ) -handlhlg pro-oedure led to non-tern-ihiatlon ; even justoln it thig the back-checking didso . Ily reinovhlgenipty productions all together , the parshigtinies decreased all Ofder of nl , % gnitude . ; tile lnedian normalized parsing tinle dropped to  0  . 270 . Thls reduced tile number of analyses of some selitences  , and n\] , % llyseato\[icesf~dled to parse at all . New ~ rtheless , this indicates that these rules liaw ~ a stroll S , adverse effect ell parser perform all ce ,   5 COMPILER DESIGN We turn now to the design of the compiler that construct stile parshlg tables for tile graln mar  . All , hough the conlpilal , ion step involves a fairal nonnt of pro-and ImStl  ) rocessing , tile latter two consist ( if rather Illlill tel'-esting ltlenial tasks . 
The llarsilig , t ; dlles are constrllcted il slng the cont , ext-free backbollel ~ rallll lial ' , liul , also here there is Ol ) llorl , unity for interleaving with the full U (-' , (' Oll-strahlts . The clom lreoller ~ d , ion w . r . t , the non-kernelit chiSis characteristic for the method  . 
The first point is viewing the closure operation as operal  . htgoi1 sots . ( Jonsider the closlt rel3 predicate of Fig .  3 . u Froin ~ ui item already hit he set , a set of non-kernelite ins is generated and its union with the original set is taken  . The . truly new items are added to tiu ; agend a driving tile process . 
The second point is nutl , ehhtg the correspond hlg phrases of the unification grammar when predicting non-kernel items  . This is done by the call to the predicate check ugrules  /4 of Fig .  3 , and ensures that the 2 \[ ainhl debted to Mats C&rlss Oli for this sc ' lielill  . ' . Alle Mclei it il nl ) lelnellt & tlol/of the \] ) l ' i l l i i i 0 1 v ! s l . 'LoperD . tlonsSllchitsilllOll ; lll dilltel'sect loll is provided by \[ . he Ol ' ? lt!l'ed- . s et-illaniliillli?1Oll package of the SICStus library . The seln'hnitiw : spresuppose that the sets ; ire represent editsel'tiered lists D . IltlCOIISlStOfgrot lndtel'illS . 
389 closure ( Set , Closure ) :- closure ( Set , Set , Closure ) . 
closure (\[\], Closure , Closure).
closure (\[ Iteml Items \] , Set O , Closure ) :- find all ( Nk ltem , nk_item(Item , NkItem) , 
Rk Items ) , union ( Set O , Nkltems , Setl , New Items ) , merge ( New Items , Items , ltems l ) , closure ( Itemsl , Setl , Closure) . 
n_k_item(item ( Rulel , _  , RHS 0 , RItS ) , item ( Rule2 , LHS2 , RHS2 , RIIS 2)):-gllS=\[LHS2I_\] , cf rule(Rule2 , LIIS2 , RtlS2) , check_ug_rules(Rule1 , Rule2 , RHS 0 , RHS ) . 
Figure 3: The non-kernel closn reflmction phrase immediately following the "  ( lot " in some UCI rule mapping to Rulol unifies with the LIIS of some UG rule mapping to  Rule2  . In item ( Ruqe , LHS , RltS 0 , RIts ) , Rule is an atomic rule identifier and RltS0 and RHS form a difference list marking the position of the  ( lot . 
This is a compromise between performing the closure operation with full UG constraints and performing it efficiently  , and achieves the same net effect as the method in Section  3 advocated by Nakazawa . Especially in the machine learning application , where rather large grammars are used , compiler performance is a most critical issue . 
In the experiments , omitting the checking of UG rules when performing the closure operation leads to non-termination when parsing  . This is because the back-checking table for the gaph and ler becomes too general  . For the learned grammar , this made constructing the internal states prohibitively time-consuming  . 
6 SUMMARY
The design of the Lit . parser and compiler is based ol , interleaving contextfree processing with applying the full constraints of the unification grammar  . 
Using a contextfree description-level has the advantages of providing a criterion for similarity between UG phrases  , allowing efficient processing both at compile time and runtime  , and providing a basis for prob-M > ilistic analysis  . The former makes prefix merging , which is timvery core of LR parsing , well-defined for unification grammars , and enables using a generalized unification grammar in the Ll parsing phase  , which is one of the major innovations of the scheme  . This and prefix merging a revital when working with the learned grammar since many rules overlap totally or partially on the contextfreelvel  . 
Interleaving contextfree processing with applying the fidl constraints of the unit l cation grammar to prune the search space restore some of the predictive power lost using a contextfree backbone grammar  . In particular , using the full U ( ~ constraints " inside " the non-kernel closure operation to achieve the effect of using the unification grammar itself for performing this operation constitutes another important in now ~tlon  . 
The experiments emphasize the importance of restricting the applicability of emI  ) typroductions through the use of topdown filtering  . Thus the main remaining issue is to improve the gaph and liIlgnm  (  ; han is rntol ) erform real gap threading . 

I wish to thank Mats Carlsson for w duabh . " advice on Prolog implementation issues and Ivan I\]ret an  , Robert Moore and Manny Iayner for clear-sighted comments on draft versions of this article and related publications  , and for useful suggestions to improvements . 
References\[1\]Aho , Alfred V . , Ra . viSet hi and . leffrey D . Ulhnan (1986) . Compiler . s , l ' rineiples , Techniques and Tools,
Addlson-Wesley.
\[2\] Alshawl , lliy an editor (1992) . 77++: Core Lan ~ luagel ' SJ-ginc , MIT Press . 
\[3\]Briscoe , Ted , and John Carroll (1993) . " Generldized Probabilistic LR Parsing of Nattmd Language  ( Corpora ) with lJnifiea . tion-Hased C , rgltll nltrs ", Computa-tional Lin . q~dslies191, pp .  25 59, 1993 . 
\[4\] Knnth , l ) on at dl " .  (1965) . " On the translation of la . n-guages from left to fight . ", h ~ formation aud Conhvl 86, pp .  607 (;:19 . 
\[5\] Nakaza . wa , Tsuneko (19' . )1) . " An I " xtended LR Parsing . 
Algorithm for Qrammltrs\[Jsingl ; ' eltture-l~ased Syntactic Categories " , EA ( . ' L91, pp .  69 -74 . 
\[6\] Pereira , l?ernando C . N . , and Stuart M . Shieber (1987) . 
Prologa , M Natural Language Analgsis , CSLILe (: ture
Note 1O.
\[7\] Plotk ht,(; or don1) .  (1970) . " A Note on Inductive (1en-eralization " , Machi ~ wlntellg + mee 5 , pp .  153-163 . 
\[8\] Rayner , M . , I1 . Alshawi , I . Bretan , 1) . C+trter , V . I ) i-ggdakis , B . ( laml ) il . ck , . I . I(a . .ia , . I . I(arlgren , It . l , yberg , P . Price , , q . Puhnan and (; . Samuelsson (1993) . " A . qpeeeh to Speech Translation System Fh , iltl " rom~tan-damComl ) onents " , I'roes . ARI ' A workshop on Iluman
Language 7ehnologg.
\[9\]$a , nuelsson , Christer (199a) . " Avoiding Non-termina-tion in Unification (' , ramm~trs " , NLULP98 , pp .  4--16 . 
\[ i0\] Samuelsson , Christer , and Manny Ibt . y , , er (1991) . 
" Quantitative Evahmtion of \]' ~ xphulation-Based L a rll-ing its itll Optimization Tool for a I+a  ) ' ge-Seale Naturall + angu , 'tgeSystem " , IJCAI91 , pp .  609-615 . 
\[11\]Shieber , Stuart M .  (1985) . " Using Restrictions to Ex-tend Parsing Algorithms for Complex-l?e  ; tture-lbtsed
Formalisms ", ACL85, pp . 145152.
\[12\]To,nita,M ~ ttsurn(I986) . EJfieicntl'a,'si ), g of Natural Lauguage . A Fast Algorithm . \[ orl )) ' aetical Sgstem . %


