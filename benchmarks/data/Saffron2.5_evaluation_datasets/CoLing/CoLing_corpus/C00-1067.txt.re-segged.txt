On Underspecified Processing of Dynamic Semantics
Alexander Keller , Joachim Niehren
University of the Saarland , Saarbriicken , Germany
koller@coli Inie hren@ps,uni-sb , de

We propose a new inference system which oper-ales on underspecified semantic representations of scope and anaphora  . This system exploits anaphoric accessibility conditions from dynamic selnantics to disambiguate scope ambiguities if possible  . The main feature of the system is that it deals with underspecified descriptions directly  , i . e . without enumeratl ng readings . 
1 Introduction
A particularly appealing aspect of lmdersl ) eci-fication ( van Deemter and Peters , 1996; Reyle , 1993; Muskens , 1995; Pinkal , 1996; Bos ,  1996 ) is that it can in principle deal very efficiently with local ambiguities-ambiguities which are only due to lack of inibrmation at an intermediate stage of processing and go a way by the end of the analysis  . An example for this effect is ( 1 ) : The scope ambiguity that is perceived alter processing the first sentence is no longer present after the second one  . This effect can be explained in a framework of dynamic selnan-tics  ( Groelmndijk and Stokhof , 1991; Kamp and Reyle ,  1993 ) by the fact that a wide-scope universal quantifier would make the indefinite in a c -cessible for anaphoric reference from the second sei/tence  . 
(1) Every man loves a woman.
Hernanle is Mary.
In this paper , we show how this particular type of local ambiguity can be processed efficiently  . The approach we proposemploys deterministic inference rules that can exclude the readings which violate anaphoric accessibility conditions without enlnnerating them  . These rules operate directly on underspecified descriptions and fully maintain underspecifiedness  . We also show how this behaviour Call be captured by constraint propagation i an existing implementation of tree descriptions using finite set constraints  ( Duchier and Niehren , 2000; Keller and Niehren , 2000; Duchier and Gardent ,  1999) . 
More specifically , we introduce DPL struc-tuT " cs ~ extended trce structures that encode formulas of dynamic predicate logic  ( DPL ) in much the same way as Egg et al's ( 1998 ) lambda structnres encode A-terms . Then we define a constraint language t br the description of DPL structures  , called CL(DPL ) , in analogy to Egg et al's constraint langague for lambda structures  ( CLLS )  . We characterize those DPL structures in which all restrictions oil anaphoric accessibility are obeyed by talking directly about the syntactic structure of a DPL formula  . This is ill contras to the standard procedure in dy-nanfic semantics  , where the dynamic behaviour is produced by the semantics of the logic  ; we do not need to ( and do not ) talk about interpretation of DPL structures and model accessibility by purely " static " means  . 
The paper is structured as follows . In Section 2 , we introduce DPL structures and tree descrit ) tions in the language CL ( DPL )  . In Section 3 , we add syntactic restrictions on admissible variable bindings to DPL structures and present axioms that characterize these restrictions  . In Section 4: , we turn these axioms into deterministic nfhrence rules and combine them with deterministic inference rules known from an existing ilfference algorithm for dominance constraints  . We obtain a procedure that can do the kind of underspccified reasoning described above without enmncrating readings  . In Section 5 , we sketch all imtflelnentation four inf'erence system based on finite set constraint progral n -ming  . This implementation can be obtained by adapting an existing ilnI  ) lelnentation fasol verfor dominance constraints . Finally , we conclude and point to further work in Section 6  . 
2 Tree Descriptions
In this section , we define the Constraint Language tbrDPL structures  , CL(DPL ) , a language of tree descriptions which conserw ~tively extends donfinance constraints  ( Marcus et al , 1983; Rainbow et al , 1995; Keller et al , 2000) by variable binding constraints . CL ( DPL ) is a close relative of the Constraint Language for et al  ,  1998) . It ; is interl ) reted over DPL structures-trees extended by a variable  1  ) inding function which can be used to encode tbrmulas of dynamic  ( or static ) predicate logic . We will define DPL structures in two steps and then the language to talk al  ) out them . 
2.1 Tree Struetures
For the definitions below , we assuln e a signature Y \] = (~12 , varl 0 , Vl~ , ~ll , Al . z , manll , likel2, . . . of node labels , each of which is equipped with a fixed arity n_ >   0  . The labels A ,_~,_V , . . . are the . 
tirst-order commctives . Nodelal ) els are . ranged over by f , g , a , b , and the arity of a lal ) elf is denoted by a r ( . /'); i . e . if J ' l,~CE then ar(f ) = n . 
Let Nl ) e the set ; of natural numbers ~.> 1.
As usual , we write N * t br the set of words over N , C for the elnl ) ty word , and 7r ~-' for the con-catellatioll of two words 7r   , 7 rtCN * . A w o r ( t 7 t is a prefiz of 7c' ( written rc_<re ' ) if there is a word 7 ru such that 7 rTrtt = 7rt . 
A node of a tree is the word rrEN * which addresses the node  . The empty word eCN * is called the root node . A tree domain A is a nonempty , t ) refixed-closed subset of N * which is closed under the left-sil  ) ling relation . 
Definition 2 . 1AtreestrllctilreiSat'a\] ) l ( :  ( A , c , ) consisting of a finite , treedmn , a in A and a total labeling t ' unction co ? : A -+ Es ' achth  , al , for all rr 6 A and iGN : cA 1 < i < We say that the nodes r 6 rcl ,   .   .   .   , 7 c~m'e in the labeling , ' elations h/ip7c:J'On ,   .   .   .   , 7r , ~) ill ! a(Tr ) = J ' and t breach 1 < i < n , ~- i = ~- i . Similarly , we say that a node ~ c properly dom , in at cs a node 7c ' and write 7r<\]+rc ' if frr is a proper prefix of 7c  ' . We take Ir and It ' to be disjoint ( ~ rJ_~r ' ) if tt ley are different and neither node dominates the other  . So any two nodes in a tree structure are in one of the four relations =  ( equality )  ,  <1 + , ~>+ ( the inverse of <1+) , or_L . We shall ~ lsot ) e interested the coml ) inations of these l " elatiolls by set operators : intersection  , coml ) lementation , union , and inversion . For instance , the dominance relation < ~* is detined as the union of node equality and proper dominance =  U<1  + . 
Finally , we detine the ternary non-intervention relation ~ ( Tr < l*T d < F r c " ) to hold if l ' it is not the case that 1 ) oth ~ r < ~ r ' and ~ r ' < re " . 
.' ~ rvara ~ ma0\lovar ? vartrvar-.
Figm'e1:I ) PL structure t br the meaning of (1).
2.2 DPL structures
Now we extend tree structures by variable binding and obtain DPL structures  . To this end , we I ) artition E into three sets : connee-tive . sEcon = V_,A,_% . . . , predicate symbols Epred=man , likes, . . . , and tcr'm symbols Ere, . ,  . = var , peter , mother_of, . . . which sub-stone , the variable symbol var and fimction sym-1) ols . 
Definition 2 . 2 ADPL structure is a triple ( A , c&A ) con . ~ isting of a trcc structure . ( A , c , ) and a partial varial ) let ) inding flmction A : AA which sati . sfies for all % ~ rt ~ A : 1 . the . < r . co , , u . fo , . 
all 7 ciCA ; 2. < the , , , , fo , .
all 7 ci ~ A ;
I ) PL structures can be used to re , present ibr-mulas of first-order predicate logic . For instance , the DPL structure in Fig . 1 represents the ( unique ) meaning of (1) . So far , however , variables bound by a quantifier do not need to be in any special position in a DPL structure  ; in particular , not in its scope . To entbrce seeping as in static predicate logic , we could simpy add the condition ~ c'<~*~r in condition  3 of Definition 2  . 2 . We will define an appropriate counterpart \]' or DPL in Section  3   ( properness )  . 
Modeling variable binding with an explicit binding flmction instead of variable nmnes was first proposed in  ( Egg et al ,  1998)  . There , binding flmctions heJp to avoid a capturing problem in the context of scope underspecitication which t  ) ecomes most ~ q ) l ) arent in the presence of ellipsis . Her ( ; the 1 ) inding flmction mainly gives us a different t ) erspective on variable binding which
I-*::=X:f(X\], .   .   . , X , , ) ( f in CE )
IxRz

I\[~A ~' .
Figure 2: Syntax of CL ( DPL ) is useflfl for defining properness of DPL structures  . 
2.3 The Constraint Language CL(DPL)
The syntax of CL(DPL ) is defined in Figure 2 . It provides constraints t brall the relations discussed above  . There are labeling constraints X : . f(X ~ , .   .   .   , X r ~) , expressive combinations XRY of dominance constraints ' with set operators  ( Dtu:hier and Niehren , 200(; Cornell ,  1994) , non-intervention constraints ~( X < 1*Y < ~* Z ) , and binding constraints a(X ) = Z . 
CL(DPL ) is interpreted over DPL structures.
A variable assignment into a DPL structure 54 is a total flmction fi'om the set of variables of a constrain to the domain of  54  . A pair (54 , oz ) of a DPL structure 54 and a variable assignment ( t into 54 satisfies a constraint qoifl ' it satisfies all of its atomic constraints  ; that is , if the relation with the same sylnbol holds of the nodes assigned to their arguments  . We also call the pair (54 , oz ) a solution and Ada model of ~ o . 
Only some of the aton fic constraints in
CL ( DPL ) are used in mlder specifie descrip-tions in t ) articular , labeling , dominance , and binding constraints ; the other constraints are helpful in processing the others  . These three types of constraints can be transparently displayed in constraint graphs  . For instance , the constraint graphill Fig .   3 represents a constraint describing the readings of example  ( 1 ) including the scope ambiguity . The nodes of the graph stand for variables in tile constraint  ; labels and solid edges represent labeling CO l > straints  , dotted edges , donlinance constraints , and dashed arrows , binding constraints , hi addition , the constraint graph represents an inequality constraint X-~=Y between each two variables whose nodes carry a label  . A constraint with the latter property is called overlap-free  . The intuition is that the solid-edge tree fragments in the constraint graph must never overlap properly in a solution  . 
3 Dynamic Semantics in CL(DPL )
The semantics of DPL is built in a way that allows quantifiers to bind only variables in certain positions : inside their scopes and  , if it is an existential quantifier , from the left hand sides of conjunctions and implications into the right hand sides  . In CL ( DPL ) , we model this as a purely syntactic restriction on the accessibility of binders which we define as a structural property of DPL structures  . DPL structures which have this property will be called proper  . 
A usefll l auxiliary concept t br the definition is that of an infimum of two nodes with respect to the dominance relation q *  , which constitutes a lower senfilattice because of the underlying treeness of DPL structures  . Furthermore , we will use the standard DPL notions of internally v @" = A  , ~ and ex-dynamic COl Ulectives ~ conternal hd , static connectives ~ con ' ~ stat=2 , V , __=:: k , _V . 
The semantics definition of DPL gives these two groups special relevance t br variable binding  . 
Now we can define pTvper\] ) PL structures as t bllows . 
Definition 3 . 1 A DPL structure 54 is called proper ' ~ for each , node ~ r of 54 on which ~ is defined , one of th , e following cases holds true wh , erep , is the i'n fimum of rc and A(TC ) . 
1 . ff =; ~( ~), or 2 . )@ r ) is labeled ' with ~_, t t l < l * . ~( Tr ) , p , 2q *% I t is labeled with art internally dynamic connective  , and no node between ttl and A(Tc ) , inclusively , is labeled with an externally static connective . 
Intuitively , the first branch of the definitiou corresponds to usual binding of variables insidetile scope of a quanfifer  . In the second branch , the positions of the variable and the ( existential ) quantifier in the DPL structure are dis- . joint , and the quantifier is dominated by tile left child of the infimum  . Then the infimum must be labeled with an internally dynamic on-nective  , and there must be no externally static connective between this node and the quantifier  . 
This restriction is what we are going to exploit r  , /?/ womb2' , 1%  . .) . . . ' :'-\ ,,'\ vat
Figure 3: Constraint graph for (1).
to capture the influence 055 scope . There is 51o such restriction for the lmth 1 ) etw cen the inti-mmn and the w ~ riM ) le . 
Sohll ; ions of & constraint hnt violate the ( ly-nmnie accessibility conditions are now excluded silnply by restricting the  , class of ~ ut missible solutions to i ) roper ones . A sexl)ected from the linguistic intuition , only ones ohd ; ion of the nm-ningex mnple ( 1 ) is proper : the one where " a woman " is assigned wide scope  ( Fig .  1) . T i t ( ; other solution is not prot ) er because the path Kern the infimum ( ( lellol ; cd by Z0 in Fig . 3) to the antecedent contains ; ~m fiversal qu ~ mtiticl " . 
Prot ) erness of ; ~ I)PI , sl ; ruct ; u 5"('(' t~slI )( ; ~txioln-atized synta , ctically : A \]) PL sl ; rucl ; urc is 1) rot ) er iff the CI ~( I)I'I ~) ~ xioms(l)y ,   , \]) to(l)yn4) in Fig . 4 ~ re , wflid over it . The rule ( Dynl ) threes univers Mqmmtifiers to bind only vari M ) les in their scopes , and the rules ( l ) yn2 ) to ( Dyn 4 ) enforce properness of binding when aw trial ) le is not in the scope of its binder . 
4 Underspecified Reasoning
We next present a procedure form M or speci-tied reasoning with dynmnics emmltics  . Th (' goal is to narrow an mMerst)ecified ( les ( ; rit)tion such that improi ) er DPL-structure , s are removed flom the solution set . Narrowing should apply as soon as possible , sounde , rspeciliedness ( : ~ m be 5 naintmned and readings need not t ) eenmner-ated . We present mlint b , rence procedure tlmt can do this and go through two exmnples  . 
4.1 Inference Procedure
This infi ; rence procedure , s'atuvatt, . sa , constrMntttccording to the rules in Figures 4 and 5  ; that is , whenever a constraint conttdns the lefl ; -hm M side of a rule , , i t adds il;s righthand side , until no new conjuncts ca , n 1) end de d . Fig . 4 contains simply the prot ) erness axioms from the , l ) revi-ous sections , turned into deterministic proof rules . The rules in Pig . 5 are t ) ropagation rules t'ronl Algorithm DO in ( Duchier and Niehren ,  2000) , plus new rules for non-intervention con-strainl ; s . Algorithm DO contains some ~ Mdi-tional rules , in I ) ari ; iculm ' distribution rules that perform case distinctions  , because DO is a complete solver tbr dominance constraints with set operators  , wl fich improves on ( Duchier and Oar-dent , 1999; Keller et M . , 1998) . We have omitted the ( list ril ) ution rules here l ) e , ( ; ause we do ' not wmlt to perform case distinctions  ; l ) ynd ding 1 ; \]1( ; 115 ~ tg ~ l , i l ~ WCCOll\]delll511 era , I ; e all proper solutions , ~: lsSchiehlen (1997) doest brUDI1T . 
The new rules ( NonI1 ) ~ md ( NonI2 ) Mlow to derive dominan ( : einfbrmation from non-intervention constraints . As we will see , the most interesting rule in Fig . 4 is ( l)yn2) , which derives explicit non-intervention it ' or ma -lionfi'om the structurMt  ) roper Lies of dynamic 1 ) inding . Note that while the rules in Fig . 5 are sound over ; my DPLs trucl ; ure , those in Fig . 
4 are only serumeve 5" proper DPL structures.
This is intended : Application of a prot ) erness rule is s'upposcd to exclude ( improper ) solutions . 
4.2 Examples
The in ii ; rence rules go along w : ty towards mak-inktile eft'cot of dynamic seminal  ; its on scope e , x t ) lie it . Let us consider ; 15( ; running example in Figure 3 to see how this works ; we show how to derive Y3 < I*X , which specifies the relative quantifier scope . 
First of all , we need to make the information ( Dyn 2 )   ( Dyn 3 )   ( Dyn 4 ) a ( x ) = YAY : V ( z ' ) Y <* X Z ( X ) = YAZ : f ( Zl , Z2) AZI < 1*YAZ2<\]*XAW:g(W1 ,  . . . , Wn ) ~ dyn ~ st~tt ( fe or , , e ~( X)=Y A Z:f ( Z1 ,   .   .   .   , Zn ) AZi<:1*XAZj < :\]* Y--+ false A ( X ) = YAZ : f ( Z 1 ,   .   .   . , Zn)AZi<l*XA&<1*Y-~false
Figure 4: Properness axioms.
( Trans ) ( Lab . Dom ) ( Neg Disj ) ( Lab . Disj ) ( Inter ) ( Inv ) ( Child . down ) ( NegDom ) ( NonI1) ( NonI2)
X < a * Y A Y < q * Z -+ X < 1 * Z x : f ( .   .   . , z , .   .   . ) x < + y
X < 1* ZAY < FZ--+X~-LY , xs , ...)
X R1 Y AX R2 Y-+X RY
XRY-+YR-1X-+-~ ( Z~<*W < a*Y ) v ~ dY ' 1 i ? j )   (  . fl ,, ~ E con-,-, co , , , ( . fl , , eE , i < j)
X i?X j where i < j if RINR 2CR
X < :\] + YAX : f(X l , ..., Xn ) A
X-~?Y AXJ_Z-+Z-~<a*Y-~ ( X <* Y < 1* Z ) AX <* Y --+ Y ~<* Z ~ ( X <\]* Y < I*Z ) AY <* Z-- , "  X-~<1*Y - - -> Xi < FY Figure 5: Propagation rules for dominance and non -intervention constr~dnts  . 
Z2 < 1* Z a explicit by application of ( Lab . Dom ) and ( Inter ) . In this instance , ( Inter ) is used as a rule of weakening . 
(Lab . Dom ) Zg : A(Za,Z4)-~Z,~<1+Za(Inter)Z . ~< Y'-Za--+Z2 < FZ3 Now we can apply the rule ( Dyn 2 ) to the variable binding constraint A ( Za ) = Y ( drawn in boldface in the graph ) and the V labeling constraint to derive a non -intervention constraint  . 
( Dyn2)Z0:A(Z:j,Z2) AZI < 1* X1AX:V_(X1)
AZ2 < q*ZaAA(Z3) = 1/
All that is left to do is to make the positive dominance intbrmation contained in the new non -intervention constraint explicit  . As the constraint also contains Zo < 1* X , we can apply ( NonI1 ) on the new non-intervention constraint and derive X ~< FY  . 
(NonIl ) = ( Zo < 1* X < 1*Y ) AZo < 1* X --+ X~<1*Y
On the other hand , we can derive non-disjointness of X and Y because  ( Trans )  , ( Lab . Dom ), and ( Inter ) allow the deriw ~ tion of
X < FW and Y < 1*W : ( NegDisj ) X <* WAY < I*W ~ X = ? Y We can now combiue all of our constraints tbrX and Y with the intersection rule and obtain  Y<1*X   , which basically determines the order of the two quantifiers :  ( Inter ) X ~<* Y AX-~?Y ~ Y <* XB y exploiting the fact that the constraint is overlap-ti'ee  ( i . e . contains an inequality cost-straint for each two labeled variables  )  , we ( : an even derive Y3<I*X by repeated application of the rules ( Child . down ), ( Lab . Disj ), ( NegDisj ), and ( NegDom) . This means that we have flflly disambiguated the scope ambiguity by saturn-tion with deterministic nference rules  . 
Now let us consider a more complicated example . Fig .   6 is the underspecified description of the semantics of  ( 2 ) Every visitor of a companys a wone of its departments  . 
The constraint graph has five solntions , three of which are proper . Unfortunately , the constraint language is not expressive nough to describe these three solution sill a single constraint : Both X and Z can be either above or below Y  , even in a proper solution , but if X is below Y , Z must be too , and if X is above Y , Z must be anywhere below X ( but ; may be above company . ""- x " .   . " i " . , "" var " researcheri " . /of ~----~ depar . tmen-gh '~; , " ~" . var\~! . ." ' Var ~ var '~ . """ var ~" . " ? i . ." " ", " . L " i . "/ var ' ~ vat ~ .   .   .   .   .   .   . 
Figure 6: Constraint graph for (2).
YI ) . In other words , this constraint is an exam-piew here the inference procedure is not strong enough to narrow the description  . In this case , we must still resort topert brming nondeterministic case distinctions  ; at worst , the rules will apply on solved forms of CL ( 1 ) PL ) constraints . 
constraints over these set variables ; examples for set constraints are VCV ' and V = V ~ UV  . 2 . The new non-intervention constraint ~ ( X < 1*Y < 1* Z ) can be encoded as
Ye <+( x)u_L(Z)u>+(Z).
5 Processing with Finite Set
Constraints
This inferen ( ' e procedure f its nicely with all im-ph ; mentation of ( lominance constraints t ) ased on constraint programming ( Marriott and Stuckey ,  1 . 998; Koller and Niehren , 2000) with tinite set constraints ( Miiller ,  1999) . Constraint pro-gramlning is a technology for solving combina-toric puzzles eificiently  . The main idea is to replace " generate and test " by " propagate and distrilmt  ( f ' . Constraint prot ~ agation t ) eribrms deterministic nferences which prune the search space  , whereas distribution tmr fonns ( nondeter-rainst c ) case distinctions . 
Duchier and Niehren ( 2000 ) show how to implenm nta ( lominance constraint solver by encoding donfinance constraints as finite set constraints and disjunctive propagators  . This solver does not handle non-intervention con -strains  , lint we show here that they cantmadded very naturally  . The ( Dyn ) rules still have to be implemented as saturation rules  . 
The idea of this implementation is to encode a solution  ( Ad ,  ~ ) of a donfinance constraints by introducing for each variable X in the constraint and each relation symbol RC  <1  + , t >+ ,  = , J_a finite set variable R(X ) . This w ~ riable is supposed to denote the set of all variables denoting nodes that are intile relation R to ~  ( X ) : l ~ , ( X ) = YeW(~o)I(M , ~) b-YI ~ . X Dominance constr ~ fints can now be stated as The bullint  ) rot ) agation tbrset constraints automatically implenmnts the rules  ( NonI1 ) and ( NonI2 )  . For instance , assume that X < 1*Yt ) e-longs to ~ ; then there will 1 ) ease t constraint Y ? <1 + ( X )  , so set constraint propagation will derive Y ~ ~_ ( Z ) Ut >+ ( Z )  . This is the mined-at (; encoding of Y_LU t >+ Z , which is equiw dent to Y ~ < 1* Z . 
6 Conclusion
In this paper , we have shown how as l ) ecific type of local anti ) gully , which is produced by the interaction of intersentential naphor and scope ambiguities  , can l ) e processed ell clearly ill the framework of underspecification  . We h~ve defined \]) PL structures , which can be used to model fonm flas of DPL , and proper DPL structures , ill which w ~ riable binding must obey the accessibility conditions of DPL  . Finally , we have shown how an underspecified description can be narrowed to a description of its proper solutions  , sometimes without even partial enumeration of readings  , and integrated this operation into all implelnentation f dominance constraints which is based on t in reset constraints  . 
Se , en from the perspective of DPL , our definition of tlrot)ern ( ; ssitmrely syntactic and technically has nothing to do with dynamic semantics  . We could state such a definition t/ecause the expli  (  ; it variable binding flmctions gave us a structure -in  ( let ) endear hndle on variable binding that excluded all tbnns of capturing  . This deviates from the standard perspective of indef-tage of being extremely modular in that the accessibility conditions are factorized out explicitly  . For instance , it is simple to represent he meaning of " Bach -Peter sentences " by relaxing these conditions  ; it should also be easy to adapt our tbrmalism to other frameworks of dynamic semantics  . Of course , the question of how to interpret a DPL structure remains open  . 
Another open question is how the approach presented here can be extended to higher-order systems of dynamic semantics  ( e . g . Dynanfic Lambda Calculus ( Kuschert , 1999)) . In this context , it could be worthwhile to restoretim distinction of variable binding and anaphoric linking from CLLS  . 
Finally , it should be interesting to find other classes of local ambiguity that lend themselves to a treatment as presented here  . So far , there are not many related examples ; one is lexical ambiguity in parsing of dependency grammar  , as presented in ( Duchier ,  1999) . However , we believe that the work presented here provides further illustration that underspecified processing can go a long way towards efficient processing of local ambiguities  . 
Acknowledgments . This work was supported by the l ) eutsche Forschungsgemeinschaft in the SFB378 . As always , we thank all members of the SFB 378 project CHORUS at the University of the Saarland . We are also grateful to the participants at the Dagstuhl workshop on Dynamic Semantics in February  1999 for comments and discussions on an earlier version of this paper  . 

Johan Bos .  1996 . Predicate logic unplugged . In Proceedings of the l Oth Amsterdam Colloquium , pages 133-143 . 
Thomas Cornell .  1994 . On determining the consistency of partial descriptions of trees  . In Proceedings of ACL . 
Denys Duchier and Claire Gardent .  1999 . A constraint-based treatment of descriptions . In 2d Int . Workshop on Comp . Semantics , pages 71-85 . 
Denys Dnchier and Joachim Niehren .  2000 . Dominance constraints with set operators . In 1st Int . 
Conf . on Computational Logic , LNCS , July.
Denys Duchier .  1999 . Axiomatizing dependency parsing using set constraints  . In Prw: . of the 6TMM . on Mathematics of Language , pages 115126 . 
Markus Egg , Joachim Niehren , Peter Ruhrberg , and t ;' e i y n X u .  1998 . Constraints over lambda-strnctures in semantic umlerspecification  . I joint 17th Int . Conf . on Comp . Ling . and 3#t'Ann . 
Meet . of the ACL ., pages 353359.
Jeroen Oroenendijk and Martin Stokhof .  1 . 991 . Dynamic predicate logic . Linguistics ~ Philosophy , 14:39-100 . 
Hans Kmnp and Uwe Reyle .  1993 . From Discourse to Logic . Kluwer , Dordrecht . 
Alexander Koller and Joachim Niehren .  2000 . Constraint progrmnming in computational linguistics  . 
In Proe . of the 8th CSLI Workshop on Logic , Language , and Computation . CSLI Press . To appear . 
Alexander Koller , Joachim Niehren , and Ralf Treinen .  1998 . Dominance constraints : Algorithms and complexity  . In 2d Conf . on Logical Asp . of Comp . Ling . To appear as LNCS in 2000 . 
Alexander Koller , Kurt Mehlhorn , and Joachim Niehren .  2000 . A polynomial-time fragment of dominance constraints  . In P~vccedings of th,c38th
ACL . To appear.
Susanna Kusclmrt .  1999 . Dynamic Meaning and Accomodation . Ph . D . thesis , Dept . of Computer
Science , University of the Saarland.
Mitchell P . Marcus , Donald Hindle , and Margaret M . Fleck .  1983 . D-theory : Talking about talking about trees . In 21st Ann . Meet . of the
ACL , pages 129136.
Kim Marriott and Peter , l . Stuckey .  1998 . Program-ruing with , Constraints : An Introduction . MIT

Tobias Mfiller .  1999 . Problem solving with filfite set constraints in Oz  . A Tutorial . Documentation of the Mozart system of Oz . www . mozart-oz , org . 
R . A . Muskens .  1995 . Order-Independence and Underspecification . In J . Oroenendijk , editor , Ellipsis , Underspccification , Events and Morvin Dynamic Semantics . DYANA Deliverable R . 2 . 2 . C . 
Manfred Pinkal . 1996. Radical underspeeification.
In Prveeedings of the l Oth Amsterdam Colloquium , pages 587-606 . 
Owen Rainbow , K . Vijay-Shanker , and David Weir.
1995. DTree Grmnmars . In Proceedings of
ACL'95.
Uwe Reyle .  1993 . Dealing with ambiguities by underspecification : construction  , representation , and deduction . , Iournal of Semantics , 10:123-179 . 
Michael Schiehlen .  1997 . Disambiguation of underspecified is course repesentation strnctnres Ul ~  ( teranaphori constraints . In 2 ~' d Int . Workshop . on
Computational Semantics , Tilburg.
Kees van Deemter and Stmfley Peters .  1996 . Semantic Ambiguity and Underspecification . CSLI


