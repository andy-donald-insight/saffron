Parallel Replacement in Finite State Calculus
Andr 6 Kempe and Lauri Karttunen
Rank Xerox Research Centre-Grenoble Laboratory
6, chemin de Maupertuis--38240 Meylan-France
kempe , kart tunen ~ xerox , fr http://www . xerox , fr/grenoble/mltt

This paper extends the calculus of regular expressions with new types of replacement expressions that enhance the expressiveness of the simple replace operator defined in Karttunen  ( 1995 )  . Parallel replacement allows multiple replacements to apply simultaneously to the same input without interfering with each other  . We also allow a replacement to be constrained by any number of alternative contexts  . With these enhancements , the general replacement expressions are more versa-tile than two-level rules for the description of complex morphologicallternations  . 
1 Introduction
A replacement expression specifies that a given symbol or a sequence of symbol should be replaced by another one in a certain context or contexts  . 
Phonological rewrite-rules ( Kaplan and Kay ,  1994) , two-level rules ( Koskenniemi 1983) , syntactic dis-arn biguation rules ( Kar\]sson et al 1994 , Koskenniemi , Tapanainen , and Voutilainen 1992) , and part-of-speech assignment rules ( Brill 1992 , Roche and Schabes 1995 ) are examples of replacement in context of finite -state grammars  . 
Kaplan and Kay ( 1994 ) describe a general method representing a replacement procedure as finite-state transduction  . Karttunen ( 1995 ) takes a somewhat simpler approach by introducing to the calculus of regular expression a replacement operator that is defined just in terms of the other regular expression operators  . We follow here the latter approach . 
In the regular expression calculus , the replacement operator ,  -> , is similar to crossproduct , in that a replacement expression describes a relation between two simple regular languages  . Consequently , regular expresmons can be conveniently combined with other kinds of coperations  , uchas composition and union to form complex expressions  . 
A replacement relation consists of pairs of strings that are related to one another in the manner sketched below : xu  . ~ y , u  ~ zupper string \[1\] x 1~ y 1~ z lower string We use ui and u ~ to represent instances of Ui  ( withiC\[1 , n \]) and 1~ and 1 ~ to represent instances of Li . 
The upper string contains zero or more instances of Ui  , possibly interspersed with other material ( denoted here by x , y , and z ) . In the corresponding lower string the sections corresponding to Ui are instances of Li  , and the intervening material remains the same ( Karttunen ,  1995) . 
The -> operator makes the replacement obligatory , (->) makes it optional . For the sake of completeness , we also define the inverse operators , <- and (<-) , and the bidirectional variants , < -> and (<->) . 
We have incorporated the new replacement expressions into our implementation of the finite -state calculus  ( Kempe and Karttunen ,  1995) . 
Thus , we can construct ransducers directly from replacement expressions as part of the general cal-cnlus  , without invoking any special rule compiler . 
1.1 Simple regular expressions
The table below describes the types of regular expressions and special symbols that are used to define the replacement operators  . 
( h ) option , \[ hI 0  \]  \[2\] h * Kleene starh + Kleene plush / Bignore ( A possibly interspersed with strings from B ) " h colnplement ( negation ) $ h contains ( at least one ) A h B concatenation hIB union hg ~ t3 intersection h - B relative complement ( minus ) h . x . B crossproduct ( Cartesian product ) h . o . 13 composition 0 or \[ Jepsilon ( the empty string )  \[ .   . \] affects empty string replacement ( see .  2 . 2 ) ? any symbol ?* the universal ( " sigma-star " ) language ( contains MI possible strings of any length including the empty string  )   . # . string begin ldng or end ( see .  2 . 1 ) Note that expressions that contain the crossproduct  (   . x . ) or the composition ( o .   .   . ) opera-to t , describe regular relations rather than regular hm guages  . A regular relation is a mapping from one regular language to another one  . tegular languages correspond to simple finite -state automata  ; regula relations are modelled by finite-state transducers  . 
In the relation A . x . B , we call the first lnern-ber , h , the upper language and the second member , B , the lower language . This choice of words is motivated by the linguistic tradition of writing the result of a rule application underneath the original form  . In a cascade of compdsitions , I~3 . .o .  1~2  .   .   .   . o . Rn , which models a linguistic derivation by rewrite -rules  , the upper side of the first relation , R1 , contains the " underlying lexical contains the resulting " surface form "  . 
We recognize two kinds of symbols : simple symbols  ( a , b , c , etc . ) and fstp'drs)ai(a:b,y:z , etc . ) . 
An Nt pair a : b can be thought of a stim crossproduct of a and b  , the minimal relation consisting of a ( the upper syml ) ol ) and b ( the lower symbol )  . 
2 Parallel Replacement
Conditional parallel replacement denotes a relation which maps a set of n expressions Ui  ( iE\[1 , n \]) in the upper language into a set of corr ~ ; sponding n expressions Li in the lower language if  , and only if , they occur between a Left and a right context ( ll , ri ) . 
U ~-> L , II l ~_ r , .   .   .   .  \[3\]  .   .   .   . U , ~-> L , ~ IIl ~_ rnUn conditiom dparallel replacement denotes a similar relation where the replacement is not constraint by contexts  . 
Conditional parallel replacement corresponds to what Kaplan and Kay  0994  ) call " batch rules " where a . set of rules ( replacements .   . ) is collected to-gel ; hermabatch and performed m parallel , at the same time , in a way that all of them work on the same input , i . e . not one applies to the output of another eplacement  . 
2.1 Examples
Regular expressions based on \[3\] can be abbreviated if some of the Ut 1 EIt-I , OWF , I pairs , and/or some of the LEI . ' T-IIGIIT pairs , are equivalent . The complex expression : a -> b , b -> cIIx_y ;   \[4\] which contains multiple replacement in one left and right context  , can be written in a more elementary way as two parallel replacements : a->bIIx_y  , b -> cIIx_y ; \[5\]cYa ? ( X Figure 1: Transducer encoding \[4\] ~ rnd \[5\]   ( Every arc with more than one label actually stands for a set of arcs with one label each  . ) Figure 1 shows the state diagram of a transducer resulting from  \[4\] or \[5\]  . ' Fhe transducer maps the string x axay by to x ax by by following the path  0   -1   -2   -1   -3   -0   -0   -0 and the string x by by x a tox cy by x a following the path  0   -1   -3   -0   -0   -0   -1   -2   . 
The complex expression a -> b , b -> cIIx_y , v_w , \[6\]a->c\[Ip-q ; contains five single parallel replacements : a- > bIIx_y  , \[7\]a->bIIv . ~ w , b -> cIIx_y , b -> cIIv_w , a->cIIp-q ;
Contexts can be unspecified as in a->bIIx _ y  , v_ , _w ;   \[8\] where a is replaced by b only when occuriug between x and y  , or after v , or before w . 
An unspecitied context is equivalent o ?% the universal  ( sigma-star ) language . Similarly , aspec-itied context , such as x_y , is actually interpreted as ?* x_y ?* , that is , implicitly extending the context o infinity on both sides of the replacement  . 
' l ' his is a useful convention , but we also need to be able to refer explicitly to the beginning or the end of a string  . For this purpose , we introduce a special symbol ,   . # . ( Kaplan and Kay , 1994, p .  349) . 
In the example a->bII . #  . -, v_7? . #  ,   ;   \[9\] a is replaced by b only when it is at the beginning of a string or /  ) etween v and the two tinal symbols of a string I . 
2  . 2 ReI ) la ( ' ement of the Empty String The language described by the UI  ) PER\[ ) art of a replacement expression 2 UPPER->LOWERIILEFT_RIVET \[10\] can contain the empty string e . In this case , every string that is in the upper-side language of the relation  , is mapped to an infinite set of strings in the lower-side language as the upper-side string can be considered as a concatenation of empty and nonempty substrings  , with eat any position and in any number . E . g . 
~*-> ~ II- ;   \[11\] maps the string bb to the infinite set of strings bb  , xbb , xbxb , xbxbx , xxbb , etc . , since the language described by a * contains e , and the string b b can be considered as a result of any one of the concatenations b ~ b  , e ~' b ~ b , e ~' b ~ b , ~ b ~ e . ~b ~ c,~e~b~b , etc . 
For many practical ) urposes it is convenient to construct a version of empty-string replacement that allows only one application between any two adjacent symbols  ( Karttunen ,  1995) . In order not to confllse the notation by a nonstandard interpretation of the notion of empty string  , we introduce a special pair of brackets ,  \[ .   . \], placed around the 1Note that . # . denotes the 1 ) eginning or the end of a string depending on whether it occurs in the left or the right context  . 
2We descr ibe this topic only for uni - d ireet ional rep!  . a ce-mer it from the upper to the lower side of a regular relation  , trot analogou statements can be made for all o the r types of replacement mentioned in section  3  . 
5 23 upper side of a replacement expression that presupposes a strict alternation of empty substrings and nonempty substrings of exactly one symbol : exeyeze  .   .   . \[12\] In applying this to the above example , we obtain \[ . a * . 1->xII- ;   \[13\] that maps the string bbonly to xbxbx since bb is here considered exclusively as a result of the concatenation c  . ~b ~? ~ b ~ . 
If contexts are specified ( in opposition to the above example ) then they are taken into account . 
2  . 3 The Algorithm 2 . 3 . 1 Aux i l i a ry Brackets The replacement of one substring by another one inside a context  , requires the introduction of auxiliary symbols ( e . g . brackets ) . Kaplan and Kay (1994) motivate this step . 
If we would use an expression like 1,\[Ui . x . Li \] ri\[14\]to map . a particular Ui ( iE . \[1 , n \]) to l , i when occuring between a left and a right context  , li and ri , then every li and ri would map substring adjacent to Ui  . 
However , this approach is impossible for the following reason  ( Kaplan and Kay , 1994): In an example like a->bIIx_x ;  \  [15\] where we expect x axax to be replaced by xbxbx , the middlex serves as a context for both a ' s . A relation described by \[14\] could not accomplish this . 
The middlex would be mapped either by an rior by anlibut not by both at the same time  . That is why only one a could be replaced and we would get two alternative lower strings  , xbxax and xaxbx . 
Therefore , we have to use the contexts , li and ri , without mapping them . For this purpose we introduce auxiliary brackets < i after every left context li and > i before every right context ri  . The replacement maps those brackets without looking at the actual contexts  . 
We need separate brackets for empty and nonempty UPPER  . If we used the same bracket for both this would mean an overlap of the substrings to replace in an example like X > l < la > l  . Here we might have to replace >1<1 and < la > l where <1 is part of both substrings . Because of this overlap , we could not replace both substrings in parallel , i . e . 
at the same time . To make the two replacements sequentially is also impossible in either order  , for reasons in detail explained in ( Kempe and Karttunen ,  1995) . 
A regula relation describing replacement in context  ( and a transducer that represents it )  , is defined by the composition of a set of " simpler " auxiliary relations  . Context brackets occur only in intermediate relations and are not present in the final re -suit  . 
2.3.2 Preparatory Steps
Before tile replacement we make the following three transformations :  ( 1 ) Complex regular expressions like \[4\] are transformed into elementary ones like \[5\]  , where every single replacement consists of only one UI-'I~ER  , one LOWER , one LEI?T and one RIGHT expression . 

 \ [  . ( a ) . \]-> bIIx_y , \[\]-> c , e -> fIIv_~ ; \[16\] would be expanded to \[ . ( a ) . \]-> bl\[x_y,\[\]->~IIv_ .   , \[ lr\]~->fIIv_w ;   ( 2 ) Since we have to use differentypes of brackets for the replacement of empty and nonempty UPPER  ( el .  2 . 3 . 1) , we split the set of parallel replacements into two groups  , one containing only replacements with empty UPPER and the other one only with nonempty UPPER  . If an UPPER contains the empty string but is not identical with it  , the replacement will be added to both groups but with a different UPPER  . E . g .  \[\] . 7\] would be split into a -> bIIx_y , e -> fIIv_ ; \[18\] the group of nonempty UPPER and\[ .   . \]-> bIIx_y , \[\]-> eIIv_~ ; \[19\] the group of empty UPPER . 
(3 ) All empty UPPER of type\[\] are transformed into type\[  .   . \] and the corresponding LOWER are replaced by their Kleene starflm ction  . 
E . g . \[19\] would be transformed into \ [ .   . \]-> bIIx_y,\[ .   . \]-> c*IIv_w ;  \  [20\] The following algorithm of conditional parallel replacement will consider all empty UPPER as being of type\[  .   . \], i . e . as not being adjacento another empty string . 
2.3.3 The Replacement itself
Apart fi'om the previously explained symbols , we will make use of the following symbols in the next regular expressions :  \[21\] < o ,   ,  \[ < , ~ I . . . I < mE\] , union of all left brackets for empty UPPER . 
> ~, ~\ [> ~ I . . . I > r , ~ \] , union of all right brackets to rempty UPPER . 
><, uE\[<~uEI > ~ uE\]<~,~,~\[<lI . . . I <-\] , union of all left brackets for nonempty UPPER . 
> ~, N,\[>1I . . . I > . , \] , union of Mlright brackets for nonempty UPPER . > < alINEl < alNE\]>al ~ N\]\]<all < all14 < aliNE > all ~> allrg > ali NE . 1 Ignore-inside operator . 
Example : abc . /x =\[ abc/x\]-\[x ?*\]-\[?* x\] , inside the string a be , i . e_laetween ' a and b and between b and c , al Lx will be ignored any number of times . 

We compose the conditional parallel replacement of the six auxiliary relations described by Kaplan and Kay  ( 1994 ) and Karttunen ( 1995 ) which are: ( 1 ) Insert Brackets\[22\] ( 2 ) Constrain Brackets ( 3 ) Left Context ( 4 ) Right Context ( 5 ) Replace ( 6 ) Remove Brackets The composition of these relations in the above order  , defines then pward-oriented replacement . 
The resulting transducer maps UPPER inside an irt -put string to LOWER : when UPl't  , ; I/ , is between l , l~\]l , "\[" and tlIGHT in the input context , leaving everything else unchanged . Other wu : iants of the replacement opel : at or will be defined later  . 
For every single replacement Ui->1 , iIIliri we introduce a separate pair of brackets < i and > i with i ?\  [1E   . .  . mE\]if UPI'E t is identical with the empty string and iff\[\]  . . . n\] if UPPEI-t does not contain the empty string  . A left bracket < i indicates the end of a complete left context  . A right bracket > i marks the beginning of a complete right context  . 
We define the component relations irl the following way  . Note that UI'PI , \] R , LOW !\] t , I , I , ; FT and IHGtIT(Ui , Li , li and ri ) stand for regular expressions of any complexity but restricted to denote regular languages  . Consequently , they are represented by networks thai ; contain n of st pairs . 
(1 ) InsertBrackets\[\]<-><~u \[23\] The relation inserts instances of all brackets on the lower side  ( everywhere and in any numl ) er and order )  . 
(2) ConstrainBraekets ~$\[>~ tz~?\[> , , uN ~ , " \] \] \[24\] "$\[ < , uF ,  \[ > , , , \]\] g ~$\[< . rove\[< , mzzI > ~ u \]\] The language does not apply to single brackets but to their types and allows them to be only in the following order : > atlNt  , 7 , *> a/IF , * < all / ';* < aa NI , :*\[25\] The composition of the steps ( 1 ) and ( 2 ) invokes this constraint , which is necessary for the tbllowing reasons : If we allowed sequences like  <3 Ua <1>3   U1   >1 we would have an overlap of the two substrin~s < a  U3 > : l and < , U1 > 1 which have to be replace a . 
Itere , either U1 or Ua could be replaced but not both at the same time  . 
If we permitted sequences like >11z<=<ll  ~'  U2   >2 we would also have an overlap of the two replacements which means we could either replace  <2   U2 > u or > lU < lle but not both . 
(3) Left Context ~~ .   .   . e ~\[26\] for all i 6\[ lE . . . mE , 1 . . . n \], li = ~$\[-\[ h . l > < au\](>< . u-<O*<,\]g~~$\[\[li . l > < ~ u \](> < . t , -< i ) * ~< i \] The constraint forces every instance of a left bracket < i to be immediately preceded by tilt  ; corresponding left context li and every instance of ' li to be immediately folk  ) wed by < i , ignoring all brackets that are different from < i irl between  , and all brackets .   .   .   .   . (< i included . ?) inside, . I i ( .   .   .   .  / . ) We , separately . , . 
make the constraints Ai for every < i and li and then intersect hem in order to get tim constraint for all left brackets and contexts  . 
(4) Right Contexto , ~ .   .   . e , o , ,\[27\] for all i 6\[1E .   .   . mE , l . . . n \], pl = ~$\[> i (> < ~ u -> i )* ~\ [ ri . l > < , u \]\] g : ~$\[">/(> < aU --> i ) *\[ ri . l > < , u \]\]' l'he constraint relates instances of right brackets > i and of right contexts ri  , at td is the mirror image of step (3) . We & ; rive it from the left context constraint by reversing every right context r ~  , before making the single constraints , ~ i ( not pi ) and revel:sing again the result after having intersected all  ) h . 
(5) Replace
EH n\] , Ar\[28\]'i'he relationmal ) severy bracketed I . Jl'l'l , ; I/ , < iUi > i for nonempty UI ' PEI and > i < i for empty UPPI  ) \] I/ . , to the corresponding bracketed LOWEll , < iLi > i , leaving everything else unchanged . 
i '\] string not'l'hetermN"n \[28means a that does contain ~ my bracketed UPPEI : . IV "= J~IEg . . . g#~mEgJ ~' lgO . . . gJ  ~ n \[29\] A particular bracketed empty UPPEll > i < i is excluded l ? om the correspondiug N  ( i ?\[ ~ Z , : ,   , lC \]) by a V ,  = ~$\[> ,  \[>< , a , ,~ - > i - < i \]* < d \[30\] and a bracketed nonempty UPPER < iUi > i is excluded from the corresponding A //  ( i ?\ [1 , n \]) by=~$\[<~\[<~UN ~ , :-<d*\[31\]
UI , /'> < all\[>allNt , 1->i \]*> i\]
I he term T ? m expression \[28\] abbrevmtes a relation that maps any bracketed- UPPER to the corresponding bracketed I  , OWER . It is the unionot ' all single TQ relations mapping all occurl : ences of one Ui  ( empty and nonempty ) to the corresponding

T ?=" R . ~r , I .   .   . I"1"?,,~;I7~I .   .   . IT ? , , \[32\] The rep lacement "/6i of nonempty UPPEIL
U i ( i ?\ [1 , n \]) is performed by : < i\[\[U ~ . Z > < . , , \ ]  . x . \[L  ~ . Z > < ~ , \ ] \] >?  \[33\] To illustrate this : Suppose we have a set of replacements containing among others a->bIIx_ y  ;   \[34:\] This particula replacement is done by mapping inside an input string every substring that looks like  ( underlined part )  \[35\]  .   .   . x > 2 > l > IE < 1N <2 < < 1 > 2 > IE < IE < I < 2 y . .  . 
using the brackets <1 and > t to a substring ( underlined part )  ?  .   . X > 2>1>lE<2 < lb > l > 2>1/~<1E<1<2 ~,' . vj . 
The replacement T ~ i of empty UPPERUi(i6\[1E , mE \]) is performed by : \[0 . x . \[\[> < au ~-< i \] Id\[<aZZN ~\]\]\]* \[37\] \[> i . x . < i \]\[0 . x . \[ Li . l > < ~ u \]\] [< i . x . > i \]\[0 . x . E\[><au ~ -> i\]IE > ~ , INE\]\]* In the following example we replace the empty  U2E by L2E   . Suppose we have in total one replacement of nonempty UPPER and two of empty UP- 
PER , one of which is\[ .   . \]-> bIIx_y ;   \[38\] This replacement is done by mapping inside a string every substring that looks like  ( underlined part )   .   .   . x > 1 > 1E > 2E < 2E < 1E < 1 y .   .   .   \[39\] using the brackets >2E<2E into a substring ( underlined part )   .   .   . x > 1 > 1 . I > 1I < 1 . I < d * \[40\]   <2Eb>2E   \[>1   I>1~   \[<1~ I <2El  *  <1E<1 y .   .   . 
The occurrence of exactly one bracket pair > iE and < iE between a left and a right context  , actually corresponds to the definition of a ( single ) empty string expressed by \[ .   . \]( ef . sac .  2 . 2) . 
The brackets \[>2E t > lEI < lEI <1\] and \[>1 \]> rEI < lE\] <2El in \[40\] are inserted on the lower side any number of times  ( including zero )  , i . e . 
they exist optionally , which makes them present if checking for the left or right context requires them  , and absent if they are not allowed in this place . 
This set of brackets does not contain those ones used for the replacement  , > i < i , because if we later check for them we do not want this check to be always satisfied but only when the specified contexts are present  , in order to be able to confirm or to cancel the replacement a posteriori  . 
This set of optionally inserted brackets equally does not contain those which potentially could be used for the replacement of adjacent nonempty strings  , i . e . > aUNE on the left and < aUNE on the right side of the expression  . Otherwise , checking later for the legitimacy of the adjacent replacements would no longer be possible  . 
(6) Remove Brackets ->\[\]\[41\]
The relation eliminates from the lower-side language all brackets that appear on the upper side  . 
3 Variants of Replacement 3 . 1 App l i cat ion of context constra ints We distinguish four ways how context can constrain the replacement  . The difference between them is where the left and the right contexts are expected  , on the upper or on the lower side of the relation  , i . e . 
LEFT and RIGHT contexts can be checked before or after the replacement  . 
We obtain these four different applications of context constraints  ( denoted by I1 ,  / /  , \\ and V ) by varying the order of the auxiliary relations ( steps ( 3 ) to ( 5 ) ) described in section 2?3 . 3 ( cf .  \[221 ) :  ( a ) Upward-oriented U1->L1 II 11_ra .   .   .   .  \[42\]  .   .   .   . U . -> L . IIIn_r .   ?  .   . Left Context . o . Right Context . o . Replace ? . .
(b ) Right-oriented U1-> LIIIh-rl .   .   .   .  \[43\] ?  .   . Righteon text . o . Replace . o . Left Context . .  . 
(c ) Left-oriented vl -> L1\\11-,'1 .   .   .   .  \[44\] ? . . LeftContext . o . Replace . o . Right Context . . . 
(d ) Downward-oriented/\]1->L1\/11_rl .   .   .   .  \[45\] ?  .   . Replace . o . Left Context . o . Right Context . . . 
The versions ( a ) to . () croughly , correspond to the three alternative interpretations of phonological rewrite rules discussed in Kaplan and Kay  ( 1994 )  . The upward-oriented version corresponds to the simultaneous rule application  ; the right-and left-oriented versions can model rightward or leftward iterating processes  , such as vowel harmony and assimilation . 
In the downward-oriented replacement the operation is constrained by the lower  ( left and right ) context . Here the Uiget mapped to the corresponding L/ just in case they end up between landri in the output string  . 
3  . 2Inverse , bidirectional and optional replacement Replacement as described above  ,  -> , maps every U on the upperside unambiguously to the corresponding Li on the lower side but not vice versa  . 
AL on the lower side gets mapped to Lior U on the upper side  . 
The inverse replacement ,  <- , maps unambiguously from the lower to the upper side only  . The bidirectional replacement ,  <-> , is unambiguous in both directions . 
Replacements of all of these three types ( directions ) can be optional ,  (->) (<-) (<->) , i . e . they are either made or not . We define such a relation by changing Af ( the part not containing any bracketed UPPER ) in expression \[28\] into ?* that accepts every substring : \[?*~\]*  ?*   \[46\] Herean Ui is either mapped by the corresponding TQ contained in  7~   ( cf . \[32\]) and therefore replaced by Li , or it is mapped by ?* and not replaced . 
4 A Practical Application
In this section we illustrate the usefulness of the replace operator using a practical example  . 
We show how a lexicon of French verbs ending in- it  , inflected in the present tense subjunctive mood , can be derived from a lexicon containing the corresponding present indicative forms  . We assume here that irregular verbs are encoded separately  . 
It is often proposed that the present subjunctive of-it verbs be derived  , for the most basic case , from a more general root ( e . g . : fin(i )) because once this stern is assumed , the snbjunctive ending itself becomes completely regular :  ( that l finish )   ( that I run ) quejefl niss-cqueje cour-equetu finiss-cs quctucour-esqueils flniss-ent qucils cour-en *'\] ? he algorithm we propose  , ere , is strMght for-ward : We first derive the present subjunctive stem from the third person pluralt  ) resent indicative ( e . g' . . . fini ~% ' ~ cour) , then append the suffix corresponding to the given person and number  . 
The first step can be described as follows : def ine LETTER :  \[47\] a Ib IcId I .   .   .   . ; define TAG:\[48\]SubjPI .   .   . IsGI .   .   . IP al .   .   . I Verbl .   .   . ; define Stem Regular :\[49\]\[\[ .   . \] <-> IndPPLP3 Verb\[\[LETTER_TAG\] . o . 
\[LexIndTAG+\]?o.
\[ ent <-> SUFF1\]_TAG\];
The first transducer in \[49\] inserts the tags of the third person plural present indicative between the word and the tags of the actually required subjunctive form  . The second transducer in\[49\] which is an indicative lexicon of-Jr verbs , concatenated with a sequence of at least one tag , provides the indicative form and keeps the initial subjunctive tags  . 
The last transducer in \[49\] replaces the suffix-cut by the symbol SUFF . E . g . : inir .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . SubjPPL P2 Verb finir_IndPPL P3_Verb SubjP PL_P2 Verb finissent .   .   .   .   .   .   .   .   .   .   .   .   .   .   . SubjPPL_P2 Verb finiss_SUFF . . . . . . . . . . . . . Subj P_PL_P2_Verb ' I ? o append the appropriate suffix to the subjunctive stem  , we use the following transducer which maps the symbol SUFF to a suffix and deletes all tags :  \[50\] define Suffix :\[ SUFF->eII_TAG*SG\[ PIIP3\]   , SUFF->es 11_TAG*SGP2 , SUFF->ionsII_TAG*PLP1 , SUFF->iezII_TAG*PLP 2 , SUFF->ent It_TAG*PLP3\] . o . 
\[TAG->\[\]\];
The complete generation of subjunctive forms can be described by the composition : define LexSnb jP :  \[51\] 
Stem Regular.o . Suffix;
The resulting ( single ) transducer LexSubjP represents a lexicon of present subjunctive forms of French verb sending in-iv  . It maps the infinitive of those verbs followed by a sequence of subjunctive tags  , to the corresponding inflected surface form and vice versa  . 
All intermediate transducers mentioned in this section will contribute to this finMt  , rans ducer bnt will themselves disappear . 
The regular expressions in this section could also be written in the two-level formalism  ( Koskenniemi ,  1983) . However , some of them can be expressed more conveniently in the above way  , espe--ciMly when tile replace operator is used . 
E . g . , the first line of \[49\] , written above as :\[ .   . \]<-> IndPPL P3 Verb IILE TTER_TAG \[52\] would have to be expressed in the two-level formalism by four rules : O : IndP <=> LETTER_  ( : PL )   ( : P3 )   ( : Verb ) TAG ; \[53\]O : PL <=> LETTER ( : Ind P )  _  ( : P3 )   ( : Verb ) TAG ; O:P3<=>LETTER ( : Ind P )   ( : PL )  _  ( : Verb ) TAG ; 0: Verb <=> LETTER ( : Ind P )   ( : PL )   ( : P3 ) TAG ; IIer e , the difficulty comes not only from the large nmn ber of rules we would have to write in the above example  , but also from the fact that writing one of lihese rules requires to have in mind all the others  , to avoid inconsistencies between them . 

This work builds on the research by Ronald Kaplan and Martin Kayon the finite-state calculus and the implementation of phonological rewrite rules  ( 1994 )  . 
Many thanks to our collegues at PARC and RXR . CG renoble who helped us in whatever espect , particularly to Annie Zaenen , Jean-Pierre Chanod , Marc Dymetman , Kenneth Beesley and Anne Schillerh ) r help fifl discussion on different topics , and to Irene
Maxwell for correcting the paper.

Brill , Eric (1992) . A Simple Rule-Based Part of Speech Tagger . I ? oc .   3rd conference on Applied Natural Language Processing  . ' lYento , Italy , pp .  1152-155 . 
Kaplan , Ronald M . , and Kay , Martin (1981) . Phonological Rules and Finite State Transducers . Atmmd Meeting of the Linguistic Society of America  . New

l(aplan , R , on ald M . and Kay , Martin (1994) . Regular Models of Phonological Rule Systems . Computational
Linguistics . 20:3, pp . 331-378.
Karlsson , Fred , Voutilainei , , Atro , Heikkil ? , Juha , and Anttila , Arto (1994) . Constraint Grammar : a Language-Independent System for Parsing Unrestricted Text  . Mouton de Gruyter , Berlin . 
Karttunen , Lauri (1995) . The Replace Operator . Prec . 
ACL-95 . Cambridge , MA , USA . crap-lg/9504032Kempe , Andre and Karttunen , Lauri (1995) . The Parallel Replacement Operation in Finite State Calculus  . 
Technical Report MLTT-021 . Rank Xerox Research Centre , Grenoble Laboratory . Dec2 1,119 95 . 
http://Www . xerox , fr/grenoble/mltt/reports/home , htral Koskenniemi , Kimmo (1983) . Two-Level Morphology : A General Computational Model for Word Form Recognition and Production  . Dept . of General Linguistics . University of Helsinki . 
Koskcnniemi , Kimmo (1990) . FiniteState Parsing and l ) is ambiguation . Prec . Coling - 90 . Helsinki , Finland . 
Koskenniemi , Kimmo , ' l ' a panainen , Pasi , and Voutilainen , Atro (1992) . Compiling and using finite-state syntactic rules . Proc . Coling-92 . Nantes , France . 
Roche , Emmanuel and Schabes , Yves (1995) . Deterministic Part-of-Speech Tagging with FiniteState Transducers  . Computational Linguistics . 21, 2, pp . 

Voutilainen , Atro (1994) . Three Studieso \] Grammar-Based Surface Parsing of Unrestricted English ~ l~xt  . 
The University of Helsinki.

