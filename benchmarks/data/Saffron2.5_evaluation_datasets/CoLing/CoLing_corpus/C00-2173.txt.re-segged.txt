XML Trans : a Java-based XML Transformation Language for 
Structured Data
Derek Walker and Dominique Petitpierre and Susan Armstrong 
Derek . Walker , Dominique . Petit : pierre , Susan . Armsl ; rong@?ssco . unige , ch
ISSCO , University of Genew
40 blvd . du Pontd ' Arve
CH-1211 Genev ~4

Abstract
The recently completed MLIS DieoProproject addressed the needt brauniform  , platform-independent interface for : accessing multiple dictionaries and other lexical resources via the In-ternet/intranets  . Lexical data supplied by dictionary publishers for the project was in a variety of SGML for n\ ] at s  . In order to trans for rn this data to a convenient standard format  ( IJTML )  , a high level transformation language was developed  . This language is simple to use , yet powerful enough to perl brm complex transformations not possible with similar transformation tools  . 
XML Transprovides rooted/recursive transductions , simila . rtotr,~nsducers used for na . tura . l language translation . The tool is written in standard . lava and is available to the general public . 
l Introduction
The MMS l ) icoPro project 1 , which ran from April 11998 to Sept 1999 , addressed the need for a uni Ibrm , plattbrm-indel ) endentier face for accessing multiple dictionaries and other lexical resources via the lnternet/intranets  . One project deliverable was a client-server tool enabling trm~slators and other language professionals connected to an intrane to consult dictionaries and related lexica  . 1 data from multiple sources . 
Dictionary data was supplied by participating dictionary publishers in a variety of proprietary formats  2  . One important Dico Promodule wa . s a transformation language capable of 1DicoPro was a project funded within the MullAlin-gum hfformation Society programme  ( MLIS )  , an EU ini-tiative launched by the European Commission's DGX Il I and the Swiss Federal OIrtce of Education and Science  . 
2 Project participants were : Ilar per Collins , Hachette
Livre , Oxford Unlversit ~ y Press.
standardizing tile variety of lexical data . Tile language needed to be straightforward enough tbr~non-program nmrtomaster  , yet powerful enough to perform all tile transfbrmation sec-essary to achieve tile desired output  . The result of our efforts , XML Trans , takes as input a well-lbrmed XML file and a file containing a set of transformation rules and gives as output the  . application of the rules to the input file . 
The transducer was designed t br the processing of large XML files  , keeping only the minimum necessary part of the document in memory at all times  . This tool should be of use for : anyone wishing to tr~ms form large amounts of  ( particularly lexical ) data from one XML representation to another . 
At ; the time XM1 ; l ? rans was being developed ( mid11998) , XML was only an emerging standard . As a . consequence , we first looked to more esta . blished SGMI ~ resources to find a . suitable trans\[brmation tool . Initial experimentation began with I ) SSSL ( Binghaln , : 1996) as a possible solution . Sometime was invested in developing a user -friendly " frontend " to the I  ) SSSL engine . jade developed by James Clark ( Clark , 1998) . This turned out to be extremely cumbersome to implement  , and was ~ ba . n do ne d . There were a number of commercial products such as Omnimark Light  ( Ominimark Corp ;  :1998) , TXL ( Legasys Corp ; 1 . 998) and PatMI , ( IBM Corp ;  1998 ) which looked promising but could not be used since we wanted our transducer to be illtile  1  ) ublic domain . 
We subsequently began to examine available XML transduction resources  . XSL ( Clark , Deach ,  11998 ) was still not mature nough to rely on as a core t brtile language  . In addition , XSL dkl not ( at the time ) provide for rooted , recursive transductions needed to convert the complex data structures found in l  ) icoPro's lexica . 1F , din1)llrgh'sLa . ngua . ge'lhchnologyGroupha,dl ) roduceda . nun ~ l)er of use f i,1 SGM\]ffXMI,ma . nipula Ciontools(I; . I'G , 11999) . Un\['ortunately none of the sema . tched our specific needs . \]~ brinstance , ~ . qml trans does not permit matching of coml ) lex expressions in voh , ing elements , text , and a?tributes . Anether I/F G tool , ~ . qu)g is more powerful , 1) ut its control files have ( in our opinion ) a . non-intuitive and COml ) lex syntax3 . 
Since a , large number of standardized XML APIs had been developed t br the Java  . program-ruing language this appeared to be a . prondsing direction . Ill addition , Java's portal ) fifty was a . 
strong dra . wing point . The API model which best suited our needs was 1 ; he " DocumentOh:jectModel " ( DOM ) with an underlying " Simple
APl for XMI2'(SAX ) I > arser.
The eventbased SAX parser reads into lneln-ory only the elements in the input document releva  . n to the tra . ns for n lalien . Inefti . '(;t,XMI,-Tra . ns is intended 1 ; o1) recess lexica J entries which a . reindel)en ( lent of ca . cA other and tha . tha . vea . few basic formats . Since only one entry is ever in memory at a . ny given point in time , extremely la . rgefiles can be I ) rocessed wil ; hlown mmory overhea . d . 
The \]) OMAI ) I is used in the tra . nsforma . tionl ) rocess to access the the element which is currently in menlory  . The element is tra . nsformed a . ccording to rules sl)ecilied in a . rule tile . These rules a . reinterpreted by XMl/l'rans as opera-lionstol > erfb rnl on the data through I  ; lloI ) OM

We begin with as \] ml ) le examl > le to illus-tra . te the kinds of transformations l > erlbrmed by XML Trans  . Then we introduce the language concepts a . nd structure of XML Trans rules and rule files . A comparison of XMLT , : a . ns with XSLT will help situate our work with respecl  ; to the state-of-the-art in XML data processing . 
2 An example transformation
A typical diction a , ry entry might ha . vea . surprisingly complex structure . The various components of the entry : head word , pa . rt-ofst ) eech , pronunciation , definitions , translations , nla . y themselves contain complex substructures . For \]) ico Pro , these structures were interl ) reted in of a The UI'G have since developed another interesting t  , rans formation tool called XMIA ) erl . 
der 1 ; o construct IITML output forty l ) ographi-calrendition and also to extract indexing in ibr-marion  . 
A fictitious source entry might be of tile form : < entry > < hw>my word </ hw><defs > < defnum="l "> first def  . </ def > < defnum="2"> second def . </ def > </ defs > </ entry >\' Ve would like to convert this entry to HTML  , extra . clingtile head word fbr indexing pnrl ) oses . 
Apl ) lying the rules which are shown in section d , XML\]'rans generates the following out l ) uC : < HTNL > <!-- INDEX="my word . . . . > < HEAD > < TITLE>my word</TITLE > </ HEAD > < BODY > < Hi > my word </ Hl > < OL > < LIV hLUE = " l " > first def  . </ Ll > < LIV hLUE = "2"> second def . </LI></OL></BODY > </ HTNL > If " this were an actual dictionary  , the XMI/l'rans1 , ransducer would iter a . te overall the entries in the diction a . ry , converting e a . (: hinturn to the
OUtl ) Ut format above.
3 Aspects of the XML Trans language
Each XML Trans rule file contains a number of rule sets as described in tile next sections  . ' l . ' he transducer attempts to match each rule in tile set sequentially until either a rulem~tchesor there are no more rules  . 
The document I ) TD is not used to check the validity of the input document  . Consequenl ; ly , input documents need not be valid XMI , , but must still be wellformed to be accel ) ted by the parser . 
The rule syntax borrows heavily from tha . to fregular expressions and in so doing it allows for very concise and compact rule specific a  . tion . As will be seen shortly , many simple rules can be expressed in a single short line  . 
1137 3.1 Rule Sets
Attile top of an XML Trans rule file at least one " trigger " is required to associate an XML element  ( e . g , an element containing a dictionary entry ) with a collection of rules , called a " rule set ~" The syntax for a " trigger " is as follows : element_name : ~ rule_set_name Multiple triggers can be used to allow different kinds of rules to process different kinds of elements  . For example:
ENTRY : 0 normal Entry Rules
COMPOUNDENTRY :@ compoundEntryRules
The ruleset itseclared with the following syntax : ?\[ rule set name \] 
For examl ) le 4: normal Entry Rules ; the rules for this set follow ; the declaration .   .   . 
The ruleset : is terminated either by the end of the fileoi : with the declaration of another rule set  . 
3.2 Variables
In XML Trans rule syntax , variables ( prefaced with "$" ) m : e implicitly declared with their first use . There are two types of variables : ? Element varial  ) les : created by an assignment of a pattern of elements to a  . vari-M ) le . . . For example : $ a = LI , where < LI > is an element . Element variables can contain one or more elements  . If a given variable $ a contains a list of elements A  , B , C ,   .   .   .   , transforming $ a will apply the transformation i sequence to < A >  ,  <13> , < C > and so on . 
? Attribute variables : created by an assignment of a pattern of attributes to a variable  . For Example : LI\[$a = TYPE \], where
TYPE is a standard XML attribute.
While variables are not strongly typed ( i . e . a list of elements is not distinguished from an individual element  )  , attribute variables cannot be used in the place of element variables and vice versa  . 
4XML~l'ans comments are preceded by a semicolon.
3.3 Rules
The basic control structure of XML Trans is the rule  , consisting of a lefthand side ( LHS ) and a right hand side ( RHS ) separated by a narrow (  " - >" )  . The LHS is a pattern of XML ele-ment ( s ) to match while the RHS is a specitic a-tion for a transfbrmation on those elements  . 
a . a . 1 The Left-h and Side
The basic building block of the MtS is the element pattern involving a single element  , its attributes and children . 
XML Trans allows for complex regular expressions of elements on the tits to match over the children of the element being examined  . The following rule will match an element < Z > which has exactly two children  , < X > and < Y > ( in the examples that \[ Bllow " . . . " indicates any completion of the rule ) : zxY -> .   .   .   ; XMH ? rans supports the notion of a logical NOT over an element expression  . This is represented by the standard "\[" symbol . Support for general regular expressions is built into the language grammar : " Y *" will match  0 or more occurences of the element < Y > , "Y + " one or more occurences , and " g ? "0 o1"l occurences . 
In order to create rules of greater generality , elements and attributes in the LHS of a . rule can be assigned to variables . Per instance , we might want to transform a given element < X > in a certain way without specifying its children  . 
The following rule would be used in such a case : ; Match X with zero or more unspecified ; children . 
X $ a * -> . . . ;
In tile rule above , the variable $ a will be either empty ( if < X > has no children )  , a single element ( if < X > has one child ) , or a list of elements ( if < X > has a series of children . Sinl-ilarly , the pattern X $ a matches and ement < X > with exactly one child  . 
If an expression contains complex patterns , it is often useful to assign specific parts to different variables  . This allows child nodes to be processed in groul ) s on the bill S , perhaps being reused several times or reordered . Consider the following rule:
Z $ a = ( XY ) *$ b = Q -> . . . ; o\['<X >, < Y > element l ) airs . The variable Sb will contain exactly one < Q > . If ' this pal ; tern cannot be matched the rule will fail . 
Attribul ; esmaya , lso1) e assigned to variables.
' l " he following three rules demonstrate some l > OS -sibilities :  ; Matchany X which has an attribute ATT
X\[Satt=ATT\]-> . . . ;  ; Matchany X which has an attribute ; ATT with the value " VALUE " . 
X\[Satt=ATT == " VALUE"\]-> . . . ;  ; Matchany X with an attribute ; which is NOT equal to " VALUE "
X\[Satt=ATT != " VALUE"\]->...;
The last tyl > e of exl ) ressions used < ) uthe IAIS a . restring expressions . Strings are considered to l ) e elements in their own right , but ; the y~l , reen closed in ( luotes and cannot have at l ; ribute patterns like regulare , h'ments(:an . A special syntax,/ .  * /  , is used to mean a , ny element which is a string . The following are some sample string matching rules :  ; Match any string / .  , / ->  .   .   . ;; Match text " suppress " & new line . 
" suppress\n "-> .   .   .  ; 3  . 3  . 2 The Right-h and Side The R , II , qSUl ) l ) lies a COll Struction pa . ttern R ) rtiletra , ns formed 1; tee node . 
A simple rule might be used to tel ) lace a , ndemen I , and its contents wit\]l some text :
X -> " Hello world " l " or the input < X > Text </ X > , this rule , yiekls the oul ; l ) ut string Hello world . A more useful rule might strip off the enclosing element using a variable refhrence on the \] JIS : $ X $ a * -> $ a For the input < X > Text </ X >  , this rule generates glleoul ; l ) lll ; Text . Elements lnay also be re-nnmed while dmir contents remain unmodified  . 
The tbllowing rule demonstrates this facility : $ X $ a*->Y$a\]i br the input < X > Text</X >  , the rule yields the outl ) ut < Y > Text </ Y > . Note that any children o\['< X > will be reproduced  , regardless of whether ghey are text elements or not  . 
Attribute varial Jes may also be , sed in XML-Trans rules . The rule below shows how this is a ecomplished : X \[$ a=ATT\]$b*->Y\[OLDATT=$a\]$b Given the input < XATT="VAL">Text</X >  , ther . le yields the output < Y
OLDATT = " VAL "> Text</Y > .
lecursion is a fundament a , \[ concept used ill writing XML Trans rules . The exl > ression@set_name ( variable mame ) tells the XML-Transtrans former to continue processing on the elements contained illtile indica  . l ; edvariable . 
l ' brinstance , @set l ( $ a ) indicates that the el--ements contained in the va . l'ial ) le $ as houkl be processed by the rules in the set set l  . Aspe:cial notation ? ( variable ~ ame ) is used to tell t ; hetrausi ' ormer to cont in , e processing with the current rule set . Thus , if dm current rule set is set 2 , the expression @ ( $ a ) indicates that \[ ) recessing sho , l < l coudnue on tile elelnent , s in Sa using the rule set set 2 . the following rule ( lemonstra , teshow 1; r ~ ll SO Flllal JOll Sca , n \]) e applied recusively to an element :
X $ a*->Y e($a ) " Text "-> " txeT "
For the input element <\> Text </\> , the rule generai ; es the output < Y > txeT </ Y > .  \] ) if l ' erent rule sets C all 1 ) e accessed as ill the following rule file segment :
X : set l@set l
X $ a*->Y ? set 2 ( $ a ) " Text "-> " txeT "@ set2 " Text "-> " Nothing " Initially , set1 is invoked to process the el <; = merit < X > , but then the ruleset set2 is in-yoked to 1 ) recess its children . Consequently , for the input <\> Text </\> , theouting ; is < Y > Nothing </ Y > . 
1 139   4 Rules for the example transforlnation The transformation of the example ill section  2 can be achieved with a few XML Trans rules . 
The main rule treats the < entry > element , creating a HTML document fl ' omit , and copying the head word to several places . The subsequent rules generate the HTML output from section  2: entry : ? entry Set@entry Set entry $ a = hwSb = defs * -> HTML?"<!--INDEX="Sa  . . . . >"
HEADTITLE$aBODYHI$a ? ( $ b ) defs?$a = def*->0L@ ( $ a ) def\[$att=NUM\]?$a*->LI\[VALUE=$att\] $ a  5 Coln parison with XSLT The advent of stable versions of XSLT  ( Clark ,  2000 ) has dramatically changed the landscape of XML transformations  , so it is interesting to compare XML Trans with recent developments with XSLT  . 
lit is evident that the set of transformations described by the XML Transtrans formation language is a subset of those described by XSLT  . In addition , XSLT is integrated with XSL allowing the style sheet author to access to the rendering aspects of XSL such as \[ brmatting objects  . 
Untbrtunately , it takes sometime to learn the syntax of XSL and the various aspects of XSLT  , such as XPath specifications . This task may be particularly difficult for those with no prior experience with SGML/XML documents  . 
In contrast , one needs only have a knowledge of regular expressions to begin writing rules with 

6 Conclusion
The XML Transtrans ducer was used to successfully convert all the lexical data for the l  ) icoProproject . There were 3 bilingual dictionairies and one monoligual dictionary totalling  140 Mb in total ( average size of 20MB )  , each requiring its own rule file ( and sometimes a rule file for each language pair direction  )  . Original SGML files were preprocessed to provide XML Trans with pure  , wellformed XML input . Inputs were in a variety of XML formats , and the output was HTMI , Rule files had an average of 178 rules , and processing time per dictionary was a I ) proxi-lnately I hour ( including pre - and postprocesss-ing steps )  . 
This paper has presented the XMI , Transtra . nsduction language . The code is portable and should be executable on any platform for which a  . \] aw ~ runtime environment exists . A freever sion of XML Trans can be downloaded from S : http://?ssco-www  . unige , ch/projects/dicopro_public/XML Trans /

Bingham , 11 . : 1996q ) SSSL Syntax, . qunlnlal'y Index ', a . thttp://www . tiac . net/uscrs/bingham/dsssl syn/ind cx , htm Clark , J . : 1998' Jade-James '\]) SSSL Engine ' , at http://www . jclark . com/iadc/Clark , J . Ed . :2000 ' XSL Transformations ( XSLT ) Version 1 . 0: W3C Recommendation 16 November 1999 , ' at http://www , w3 . ow/TR/1999/l~l'~'C-a:slt-Stylesheet Language ( XSL ) Version 1 . 0W3C
Working Draft 16-December-1998' ath ~ p://w,~w,a . o,~j/Tl ~ / iOgS/WD- . , . sl-Sheets 3', at htlp://www,w3 . org/77~,/NOI'1~'-,~7"/S'3IBM Corp . :1999 qBM/Alpha work'sl ) at ML ', at http:///www . alph , a Works . ibm . com/tech/patml Language Technology Group:1999 q , TXML version 1 . 1' at http://www . Itg . c d . ac . uk/softwarc/xml/indcx , htmILegasysCorp . :1998' The TXL Source Transfor-mat;ion System ' , at http://www . qucis . quccnsu . ca/Icgsys /
TXL_lnJ'o find cx , html
Omnimark Corp .: 1998' Omnima . rk Corporation
Home Page ', at http://www . omnimark , corn ~ 5Users will also need Sun's SAX and DOMJ ava libraries ( Java Project X ) available from : http://java . sun . com/products/java projectx / index , html :
