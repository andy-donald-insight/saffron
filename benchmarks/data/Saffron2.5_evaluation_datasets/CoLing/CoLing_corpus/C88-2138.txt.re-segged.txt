~,=~~:,, j : b~\[i- .   .   .   .   . , i ~ H '~, ~~ + :! i + ~, ~_~-
el'tileri~ti'\[Vtaibliit~-irrii'l.sl:lii~n

Oeitlpalt ~ r-Jiieiic ~, 8 ap~i ~ i ~) itl;
Oaiit ~! gi ~ J - ~' iell c ~ liUi ~ iwtr sil 7
Pltl~_~bt!rgli,i ~ Ait ; 41, ' l , t.ISA
l . e~icoii-drt vert for inalisi'ns(e,I . Categorial Gramm ~ r , i li ' , 8C 4 arid ( ~ l-J(\[ti'~rnar) , which dnr ~ ol have e ? plicil phrases litil ~ il Jre tales  , ai ' ~ sutlable for higher le , velsyritax buteel far low level b . liigu ~ ljo-spoclfi ( ; ooii ~ trtlclions Stlch as dales ( Jelyl ; th ,  15 , -JUL-1917 , at , ;) , wlitch soot ri to require lhepower of phrase . ~ iti ? ! Jollirerrilos . ' Fhlt ,; fJ~'~i)ei't31"r ) . ' lenl!~anh+ii ploi ~ ioli laihiun loll'ieditJ ceiTil : ~ llle  lext0ul  ! . , ddvoii parsllig ~ lild phras(t D , triJ cluro parsing , with a si ) c clalriit l ~ li is ~; alled ~ #raph . , sfiuct is r'ed stack . 
I . fo ~> get llngui , ~ ; lic ~ rafn rear to eilalisms earl be class illed halo I wef ~ liillles  , pht~\]se- , <; tructure-based or lexl cork driven . -\[ bt ~ phrase ? ~ trl . lCtuie . i ) ased for iiial isrlishic lude Oeflnile Clause ( -lrarn n-lar\[IJ\] , Le?fcal Ftnctioaal Granimar\[3\] , Gerleralized Phrase L ~ tructuro ( ~ raiillTlar\[ . ' J , 6 i all dF:t inclierial Uriificatio a Granlmart 7\] . \] hey all are h ~ , , . ;~-i ( ; eu contextfree phrase structure rules wlii char ~-  ) ~ugieelltet ' ~ i Hella way orarlether . Onlbe olher 1 lend , Io?icoli-driw ; iitei ' in alh ~ i ~ siucle do Catogorial Oraa I rrlar \[ l \]  , tlead-diivoliPhi'a ~ J of ~ trd clere ( -iraln nlar\[9 , 10 arid GtJ-(71 rammar\[4 ,  13\] . Alle ! tliese lexicoll . .drivon forMalislos do riot have any explioil ptiadlt JstuJClll rerillos  , but lulor fuatio e about bowtoceic birie oor is illlle ii ~ f ~ inloa high ~  ; rcoastlit Jerltisella : criedill each lexicoe or COilSiitLl ~! ~ lit which is I  ( i be combined . It Iselicit argued that Ioxicer l . -ddverltrll ' lrl ~ rtl is nlscEIn haiidle sonI?7 I ieguist lcpll (  . ~ rlOlllent tlJl/a'lfree-word-order Ifiero elogaritly  , aud also they can capture uriiversalily ( if rnlilliple languages , as described , for exarriple , by Wehilit14\] . 
I il section 2 , on lheother I'l and , it is argued that , while lexioon-driven for inalisins might be suitable  1o cope will \] linguistically " intereslh'ig " phenonioea  , they lack the power to express linguistically " enieteresting " phenoe ~ eaawhich are ellen very specific to a pallicular language  , Unfollunaiely , in order to build a praclical pai~er for a " real " taxi  , one must haudle wryirlany " uainteresting " low level pP lenornena which can aot bee a  , ,ill 7 ~ ormalized hi the lexicon-driveri way . Heriee , tf we Wahl Io build ~ praclical p ~ lrser wll h ~ theory behind lhe Ioxicori-drlventor  , i ~ alisms , iheriit lst ts senllal to eat'tibia e lexicon -driven parshlg  ( for higher level synti ~ , " ) and phlase-structere-based parsing ( lor low level delall and other liingeago-specilic /exceptioiral coiistrtictior is  )  . 
In seelion 3 , we geaeralize lho compulalleaal models of all the iexicoe-driveuur id phrase  . .st reclure-based terrnaltsiris as shift . reduce parsing .   8eclioa   4 hll reduces the 9raph-structur~Jd stack to handlerlori-deterrnia is rninshill -reduce parsing  , in so clloes <5 r!u d 6 , we do scrib ~ J the use of tile grapli . .sltuclured slack Iri I . .exlcou ddvon and i:~llrase-strucltne-based parsiug  , respecllvely . 
We then diucuss trlow to cembia el heselwo kinds of pars in fj wilhlhograph--struclurod stack  , in secllen 7 . 
lit It ) rauical af ) pll catie ii . % llii ) liiseriterictt , -J have > iliaiiy Jali\[flll ! ,  . j ~ : , ~- ip ~ . cilicph ~) il Olil Oili ~ ihalar oriot I in . quislio aliy ' iil to iu ~ linj ' LCO lisidt ~ riIi +, t . ill ~ : whl ~ s~ntendo8: " i ' ak ~ lwotable tuufasl ~ irirti'O ~ lrthrlo: , a day . 
\] cite(bile . ariioelhi ( . j wiih L Joctor Jait ) le ( ; aib(l~l  ~ Jl  #itu July J Sthfreiil < ' J , ':70I ~\[ V\] . 
Allefthose ~ ; ci ~ lenu ~ sctliltt ~ ini'lOhitereslin ! ' ~ yrltax i:/  , icaio in ~! i : ~ , hulh ave a lot of h~i ~ geage- , spccific luw . l~volcen<~tiuctiu ~, <;,: ~ dch~s"tiJl . l r t t l f l O S ~ day " . ~\[ ocelus the . it lhere i ~ t in be / turw ~ vtesiJ , ~ c if , /this palle eilhtlnapt ~ rases trllottiroitllo : < l requt Jiit  ; y > . :- . - . < inte . ger > < lilacs > < hiletie ~> < tiiNc) . uilit > atlirnerl to diu one way ~ rf ~ inotlier to cliecknlllnberttji % oni  (  , qli~lil . ~ Jinlilarar ( je Ments carl betll a dofer telos : < p~3i'SOrloilaele  > <- ( - - <: title: . <firstriarnit > < last-llaine><time > <--< hiteuer > ":" < integer::  , (" AM"I"PIVl ") tiiese OOliStM ( ; iierlsare " llliiii ii iorebtill\[ji'boc ~ . iiisewoalli , ' . ii~ , w the fti ? I Sradicest a specily I hi it ; opilt ~ lieinljna , r ~ ii ( I i list it , stamiti ~ ) rufuifliil ( ~  ( 1 u v t l l l a l i d w r i l i f i g r u l e s , litlorelei(-) , for lh ( , , I)tlrt)~l , 4 ~ afIhiguistic sludt , l lie y c ~ i l h e j usl ignore d , hipi'~lciical at ) plff;atio~l~?htl wever , we ciill no ~ . Ignero IIiolii bylilly II/Otl IS , Ifiloci , ili i Jilts ~ iileuces are iilll of tlies o " t t i i i n i e i e s t i n  ( j " p bell Oll it ; lie , tl ri folt tl ri , ' . llel 7 , Morelhari hall of\[liglish L~lidJlpr_liieso ( ji ~ ftlfli ~ li " rules lorOlVtU'snlachine trall slaiioli proj ~  . , ct , totOxaiiiplo , alelall . q , eate-Sl ) eoitic " uII iaterosliug " lew-lev ~ ; Irtlles . Itisext Jocte , d/ii at , tu(-lilypriloticai system , there ili iJst be a buncheli ' ele . < ~ like tli(~so . b Oiile v ? ilero hithe ' , ; ysteiil ; ellie ~ wisetiles y ~ lelils iiriply do ( ~ , ,J ilet wail ( , Loxleoil-diiw-~ll to rrn all sll ' is ~ ire all n reliv ; : it udb 7I hitjuisiic c . illy " iilterestirig ' l phonoineua , arid they are riots lJl to dlot li ( ~ . ' iolariluage-n ~) cificlow level conslructicns . It doe . , ; iielinal to lily sense to try to write Illose roles In tilei exice n-driveriway  , oven if il is niatheillalically passible . It is clear lll~t lhepowe rulplira , so Stil , icture is necessary far praclical applications , h , iliaiollet; , ~ i i l f j scalier is , we describe I lowte COiFi blilole ? icoil . driv ~ lipalshlCi ; ~ lrlil pllraSe-StrtlClUre . .based paisitlr i . 
3? ~ hifl-~:teduco Pa ~' slil ! ~
Lotiiscon . ~iderbelb Io?icurv . cMvel ~ and pllrase . sltt tislt Jic ~ bctscd parsing to be sllifl-reduce parshrg  . IntJliifl-rol : lucoparshi ~ i , tberoi , ~; ~ stack , arid all wolds hilh o input senie ii co are pu , < Jhod ( shiiiod ) ~ JJ it ~ I lies lacl ( frninl of tio 7' i , ( jlil . lildo higue , the first ii coii < . tilucJili . ~ s ( el words ) from the lop of the sf~-~ckareucc ~ . ~ ioilally eombin c . d(r ~ duced ), by popping tile li co ii . slittio i i isi rorn the stai . ' k , t ; /ilsptt linU~tn~w coristituent lrorettro constite onls  , alidi Ji Jsliiiigii oii ~ wCOli ~ II Iileill cilia tile stack  . Ashili , rodllce parser rio 6' dsloiJ_J(, . 4 1 controlled to determine when and how constituents should be reduced  , and when a word should be shifted . 
In phrase-structure=based parsing , it Is controlled by a set of language-specific rules  , typically a context- . free phrase structure grammar , augmented in one way or another . 
In lexicon-driven parsing , it is controlled by information encoded in each constituent obe reduced  , and ( ifarly ) a set of language universal rules which reside inside the parser permanently  , but with no language-specific outside rules . In the Categorlal Grammar formalism , this Information is encoded as complex categodes with functor and argument features  . Two elements can be reduced If and only it the category of one element is the same as the argument feature of the other element  , and the category of the new element will be the functor of the latter element  . In GB Parsing , categories are encoded In accordance with the Xbartheory  , and some language-universal rules ( often called principles ) are fired to decide whether a particular pair of elements can be reduced  . 
In bolh phrase-structure-based and lexicon-driven parsing  , there are cases where it cannot be uniquely determined whether the next action should be reduce or shift  , or cases where more than one reduce action is possible at the same time  . This means that the parser must handle some nondeterminism  , and naive techniques such as simple backtracking or breath first search would require exponential time  . The parsing time , however , can be reduced to polynomial with a graph -structured stack  , which is described In the following section . 
4. The Graph-Structured Stack
The graph-structured stack was introduced in the Genera/Ized LR Parsing algorithm  \[11  ,  12\] , to handle nondeterminism In LR parsing in polynomial time  . In this section , three key notions , splitting , combining and local ambiguity packing , are described . 
4.1. Splitting
When a stack needs to be reduced ( or popped ) In more than one way , the top of the stack Is split as in the following example  . 
Suppose that the stack Is In the following state , The leftmost element , A , is the bottom of the stack , and the rightmost element , E , is the top of the stack . In a graph-structured stack , there can be more than one top , whereas there can be at most one bottom . 
A---B---C---D---E
Suppose that the stack needs to be reduced in the following three different ways  . 
F <-- DE
G <-- DE
H<--CDE
Then after the three reduce actions , the stack looks like : /-- r //
A ~ -- B - - - C .   .   .   . G\\\ .   .   .   .   .   .   .   . l ~ 4 . 2 . Combining When an element needs to be shifted ( pushed ) onto two or more tops of the stack , It Is done only once by combining the tops of the stack  . For example , If "1" is to be shifted to F , G and H in the above example , then the stack will look like : /-- r ---\/ \/\ A---B---C  .   .   .   . G .   .   .   . 
\ / \ / \  .   .   .   .   .   .   .   . H--/4 . 3 . Local Ambiguity Pecking If two or more branches of the stack turned out to be Identical  , then they represent local ambiguity ; the Identical state of stack has been obtained in two or more different ways  . They are merged and treated as a single branch . Suppose we have two rules :
J < -- TI
J < -- G ~
After applying these two rules to the example above  , the stack will look tlke :
A---B .   .   .   . C---J\\\--H---z The branch of the stack  , "A-B-C-J " , has been obtained In two ways , but they are merged and only one Is shown in the stack  . 
5 . Lexicon-Driven Parsing with a Graph-St ructured 

There is an obvious way to implement a lexicon -driven parser with the graph-structurad stack  . Basically , the parser parses a sentence strictly from left to dg ht  , shifting a word onto the stackerie by one . The tops of the stack are Inspected to see If there are any ways to reduce the stack  ( remember , there are no outside phrase structure rules In lexicon-driven parsing  )  . The stack gets reduced non-destructive ~ y , wherever possible . A non-destructive reduce action simply adds a new branch to the stack  , without removing the old branch of the slack that has been reduced  . The following example shows the stack before and after the reductions of C and D into E  , and 8 and E into F . 
A---B---C---D/ .   .   .   .   .   .   .   .   .   .   . F // I .   .   .   .   .   .   . z ////
A---B---C---D
Repeat until no further reduce action Is possible ( note that one reduce action can trigger another reduce action  )  . When no further reduce action Is possible , the next word is shifted . When a word Is shifted , all tops of the stack are inspected whether they can be shifted the word onto  . Even when a word has been shifted onto more than one top of the stack  , there is at most one element on tim top of the stack  , due to stack combining descd bed In the previous will look like :/  .   .   .   .   .   .   .   .   .   .   . r-~\/\//////a .   .   .   . B .   .   .   . c~--D . -/ When an how top elements can be reduced Is determined by Informatk ~ nencoded In each element Itself  , and the method vartes from one formalism to another  , as described in section 2 . 
6. Phrase-Structure . Based Parsing with a
Graph-Structured Stack
Tonrita\[11 ,   12\] Introduced a generalized LR parsing algorithm , which is an LR parsing algorithm generalized to handle arbitrary contextfree grammars with the graph-structured stack  , The standard ( not generalized ) LR parsing algorithm is one of the most efficient parsing algodlhms  . It Is totally deterministic , no backtracking or search is involved , and it runs in linear time . This standard LR parsing algorithm , however , can deal with only a small subset of contextfree grammars called LR grammars  , which Is often sufliclent for programming languages but clearly not for natural languages  . I 1 , for example , a grammar is ambiguous , then Its LR table would have multiple entries , and hence deterministic parsing would be no longer possible  . By Introducing the graph-structured stack , however , mulUple entries can be handled efficiently In polynom hd time  . 
Figures 61 and 62 show an example of a non-LR grammar and IlsLR table  . Grammar symbols starting with "*" represent pro -terminals  . Entries " shn " In the action table ( tile left part of tire table ) Indicate that the action " shift one word from Input buffer onto the slack  , and go to stale n " . Entries " ren " indicate that the action " reduce constituents on the stack using rule n "  , The entry " acc " stands for the action " accept  "  , and blank spaces represent " error " . 
The go to table ( the right part of the table ) decides to what slatetire parser should go alter a reduce action  . The LR parsing algorithm pushes state numbers ( as well as constituents ) on totile stack ; the state number on lhetop of the stack indicates the current state  . The exact definition and operation of the LR parser can be found in Aho and Ullman  \[2\]  . 
We can see that there are two multiple entdes in the action table  ; on the rows of slate 11 and 12 at the column labeled "* prep " , Roughly speaking , thts Is the situation where the parser encounters a preposition of a PPright after a NP  . If this PP does not modlly the NP , then the parser can go a head to rednce the NP to a higher nontermlaal such as PP or VP  , using rule 6 or 7 , respectively ( re6 and re 7In lhe multiple entries )  . If , on the other hand , the PP does modify the NP , then the parser must wait ( sh6 ) until the PPIs completed so It can build a higher NP using rule  5  . 
With a graph-structured stack , we can handle these nondeterministic phenomena nicely  . Figure 63 shows the graph-structured stack dghl after shifting the word " with " in the sentence  "1   ( i ) s - -> NP v P ( 2 ) s --> s ~ P ( 3 ) NP -->* n ( 4 ) NP-->* det*n ( 5 ) NP--->NP PP ( 6 ) PP --'>* prep NP ( 7 ) VP -->* vNP Figure 61 : An Example Ambiguous Grammar
State * do t*n*v*prep$NPPP VPS .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
0  sh3   sh4   2 ii sh6 ace 5   2   sh7   sh6   9   8   3   shl0   4   re3   re3   re3   5   re2   re2   6   sh3   sh4 ii 7   sh3   sh4   12   8 reltel 9   re5   re5   re5   10   re4   re4   re4 
Iire6 re6 , sh 6 re 6912 re7 ,   sh6   re7   9 Figure 62: LR Parsing Table with Multiple Entries ( derived from the grammar In fig 61 )  /  .   .   .   .   .   .   .   .   .   .   .   .   .   . s .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  1  .   .   .   .   .   .   .   .   .   .   .   .   .   .  \ / \ /  .   .   .   .   .   .   .   .   .   .   .   .   . s .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . z .   .   .   .   .   .  \ \ / \ \ / /  .   .   .   .   .   .   .   .   .   . ~  .   .   .   .   .   .  12  .   .   .   .   .   .   .  \ \ / / \ \  0---NP--2---v--=7==-NP--12--~p---6---NP--ll---p--=6---NP--ll---p---6  \ \ / \ / / \  .   .   .   .   . s .   .   .   . z .   .   .   .  \  .   .   .   .   .   .   .   .   .   .   .  / \  .   .   .   .   .   .   .   .   . up .   .   .   .   .   .   .   .   .  / / \ / \  .   .   .   .   .   .   .   .   . NP .   .   .   .   .   .   .   .   .   .   .   .   .   .  6  .   .   .   .   .   .   .   .   .   .   .   .  /
Figure 63: A Greph-Structumd Stack discassions on the generalized I  . Fpa ~* Jlng algorithm can be fo ~ . ~ in Tornlta\[1"1, IV-\] . 
7. Combh=ing Phr~e-~ructure , B~sed and
Lexicon-Driven P~l~tg
Inth : ~ prevlou , ~sections , we have de ~ crib ~ dth ~ e . ~ eofth ~ g~-a~h-structured stack for lexicon -driven and phrr~se-  ; ;truciure . ba~e~i parsing . It is now rather obvious that we can combine texicoa-driver ~ and phrase-structure-based p~r ~ ing  ; there are two way , \] . 
We can enhance the generalized Lt~parsing algoriihm by allowing Io?iconsto  ( optionally ) have le?i con-driv ~ n rules . That Is , the stack is periodically inspected to see ilany parl of the stack c~n be reduce by a lexicon -driven rule inside lexicons  . Thl , ~ way I . ' . ~ preferable if a system has re . any phrase structure roles , with ~ few lexicon ? driven rules io I ~ and le certain linguistic phe  . ~ omen,~more easily . 
Alternatively , we can enhance lexicon-driven parsing described i a section  5 by allowing t be parser to reduce tops of the stacku ~ l~g out~idephr ~  . -~sestructure rules as well . That is , the stack i ~ periodically inspected to see if any part of the stack can he reduced using one of the phrase-structure rules  . This way is preferable ff~system is heavily lexicon-driven  , with a few phrase structure rule ~ to handle low level and/or exceptional phenomena  . 
8. Summary
This paper first argued that if is neces ~ r , /to enhance lexic~l-driven parsing witl ~ phrase structure rules in practical applications  . 
We then suggested a shift-reduce implementation of lexicon-driven parsing with a graph-structured stack  , which is readily combinable with a shift-reduce implementation of phrase ~ struclm~-bas~d parsing with a graph-structured stacl <  ( i . e , the generalized LH algorithm ) . 
\[1\]AO ~,, A.E.~adSteed6a ~, ~'~' J.J.
On the Ord~r of Word ~.
Llt, . ( ei:~lic ~ arid Philosophy 4(4): 5t7-SSft , t98 ~ . 
\[;:21Ahn , A.V.~ndU Umau , J.O.
fb#~ciple.~of CompilerDe~i ~ J.
A ~: : i ~ lsen We ~ dey , 1977.
t . exical- . F~_~ctloaalGra~n~r:AFormal8yste~fo ~'
Oran ~ ati ~ al ~ 3epr ~- ~ sent ~ t ~ ot\].
The Mentalfle present ~ tiottof(:;rammatic , ~ lfel:JtY~n ~ . 
r ~ lT Press , Oaa'lb~ldge , Mas . ~ anhu~et ~, " i ~ t ) 2, p ~, g ~ cJ f ~ . 
!73-26 l.
\[4\]Cl/olfl~ky , N.
Lecture t ~ on Government arid BM ding.
l-:e ~ lsP ~ b ! l cat lons , t98t.
\[5\] Oaz.da ~, O.
Phrase Structure Gmmmar ~ and Natural Langu~ge.
F'roco ~ dlng ~ of MCA 183v.'t , Aug~st , 1983.
~(6\] Dowry , D . FL , Kar~ur~en , L . arid Zwicl ~', A . IV , ' . ( ~ ditoi ') . 
Generalized Phrase Sl~tctut ~ Grammar :
Harvard University Press , C , amb ~ idge , Mass . , t985 . 
\[7\] Kay , IV l.
Parsingii ~ Func Uonal Unification Grammar.
Natural Language Parsing : P~ychological , Gompeta Eot ~ al and Iheot ~ tical Perspectives . 
Cambridge University Press , Carnbddge , England , t985 , pages 251 . .278, Chapter 7; \[8\] Perelra , P . and Warren , D . 
Definite Clause Grammar lot La Hguage Analysis.
At ~ ificial Intelligence 13: pp 231-278, May , 1980.
\[9\] Pollard , C.
Gor~eralized Phra . ~ Structure ) Grammars , \[ l~dOt ' ~ mm~m , attd Nataral Languages . 
PhD thesis , Stanford Universtly , 1984.
\[ t0\]Pollard , G.
Locturo Notes on Head-driven Phrase-~tructnre Grammar  . 

\[ t1Ten , Ira , t~l.
Efficient Parsing for Natural Langu , ~ ge.
Klawer Academic Publishers , Boston , IVtA , 1985.
\[~2\]Tomlt ~, ~.
An Efficient Augmented-Context-Free Parsing Algorithm  . 
Computational Linguistics 13(1-2):31 . .46, January-Juno , t 987 . 
\[' i ~ W ~ hdl , E.
A Govemment-Blndir to Parser for FTench.
Working Paper 48 , Instliut pour los Elu des Semantlque8 et Cogrtltlves , Univer ~ lt ~ de Cohere ,  1984 . 
\[ t4\]Wehdl , E.
Pa ~' slng with a GB-grammar.


