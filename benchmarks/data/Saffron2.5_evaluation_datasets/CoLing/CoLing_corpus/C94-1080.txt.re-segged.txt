CONCURRENTLEXICALIZED DEPENDENCYPARSING :
ABEHAVIORAL VIEWON Parse Talk EVENTS
Susanne Schacht , Udotlahn & Norbert Br6ker
CLI\]-Computational Linguistics Research Group 
Freiburg University
D-79085 I : reiburg , Germany
email : sue , hahn , nobi@coling . uni-freiburg . dcAbstract . The behavioral specification of an obj~t-or i -cnted grammar model is considered  . The model is based on full lexicalization , hcad-oricntation via valency constraints and dependency relations  , inh critanccas a means for nonredundant lexicon specification  , and conct , rrcncy of computation . The compntation model relies upon the actor l ) aradigm , with concurrency entering throt ~ ghasyn-~:hronous message passing between actors  . In pa , ticular , we here elaborate on principlcs of how the global lyz havior of a lexically distribute xl grammar and its corresponding parser can be specified in terms of evcn type networks and cvent networks  , resp . 
1 INTRODUCTION
In this paper , we propose a grammar model that combines lexical organization of grammatical knowledge with lexicalized control of the corresponding parser in a coherent object-oriented specification framework  . We build upon recent developments in the lield of linguistic grammar theory which have already iekled a rigid lexical mod  , lariza-tion , but extend thcm by assigning full procedural autonomy to lexical units  . In particular , we treat lexic , ' ll items as active lexieal processes commtnticating with each other by message passing  . Titus , they dynamically establishetero-geneous communication lines in order to dctcnn in ceach lexical item's fimctional role  . While the issue of lexieali-ze ( I control has early be cn inv cs tig at cd in the l ) aradigm of conceptual parsers ( e . g . , Riesbcck & Schank 1978) , and word expell parsing in particular ( Small & Ricger ,  1982) , we here elaborate on improving ils lcxical commt mication facilities by formalizing the pars cr's message passing protocol according to actor computation principles  . As this protocol allows for a synchronous message passing  , concurrency enters as a theoretical notion at the level of grant-mar specification  , ot only as an implcmentational fcatt trc . 
Correspondingly , we introduce a behavioral description in terms of even type networks which rc present grammatical interrelations at the level of actor definitions  , while event networks represent the I ) arsing process in terms of actual messages exchanged between instantiated actors  . The Par-se Talk model outlined in this paper can the reft  ) rebecon-sidcred as an attemptor cmedy the lack of theoretical integration of parallelism at the level of grammar design  . 
2 Parse Talk's GRAM MAR MODEL
The Parse Thlk grammar mcxlel(of . Br6kcr , Hahn & Schacht ( 1994 ) for a more comprehensive treatment ) considers dependency relations between words as the funda-meatal notion of lingnistic analysis  . This corresponds to the head-orientation found in most moder ngrammar theories  . Grammatical spccilications are given in the format of valency constraints attached to each lexical unit  , on which lhecompt ttalion of concrete dependency relations is based  . A modilic r is said to depend on its head if the modifier satisfies the constraints placed on it  . These constraints in corl ? ) rate iulormation about the hierarchy of word classes  ( encapsulating declarative and behavioral properties of lexical items  )  , nmr pho syntax ( containing Ihegram-malical conditions of the combination of lcxical items to l  ) hrascs as expressed by a unification \[ ormalism , similar to Shieber ,  1986) , linear ordering ( stating precedence relations between a head and its modiliers  )  , and permitted con-ceptnal roles ( expressed in terms of a hybrid , classilica-tion-based knowledge represenlation formalism  ; cf . MacGregor , 1991) . Dependencies are thus asymmelric binary relations that can be established by local computations involving only two lexical items  1 and simnllane on slyake grammaticals well as conceptual wellformedness criteria into account  . 
P , y way of inheritance ( for arc cc nt survey of a pl ) lying inheritance mechanisms in moder ngram lnar theory  , of . 
l ) a clemans , I)e Sine ( It & Gazdar ,  1992 ) the cnlirc collection of lexical items is nrganiz c  ( l in a lexieal hierarchy , the lexical items forming its leaves and the intermediary nodes representing grammatical generalizations in terms of word classes  . This form of specification is similar to variotts proposals currently investigated within the unification grammar connnunity  ( e . g . , Evans & Gazdar , 1990) . 
tWeexlend this definition to in coqxmL tc the notion of phrases as well  . 
A hhough phrases are not explicitly represenled ( c , g . , by nonlexical categories ) , we consider each complete suhtrce of I he delx ~ndency tree a phrase  ( I his definition allows discontinuous phrases as well  )  . A dependency is thus not trealed a ~: a relation between words  ( as in Word Grammar ( lluds on ,  199(\] , p . 1171 , but between a word and a dependent phrase ( as in l ) epcndency Unification ( \] rammar ( l lell wig ,  1988)) . The root of a phrase is taken to be the rel ~resent : ttlve of tim whole phrase  , Although the object-oriented pm-a digm seems to bc well suitexl to suppor the distribution of data through encapsulation and the distribution of control via message passing  , most object-based calculirely on synchronous messages and dmrc foredo not provide for concurrency  . One of the few exceptions that aim at the methodologically clean combination of object -oriented features with concurrency and distribution is the actor model of computation  ( Agha & Hewitt ,  1987) . It assumes a collection of independent objects , the actors , communicating via a synchronous , point-to-point message passing . All messages art guaranteed to be delivered and processed  , but in an unpredictable order and indeterminate ime  . Each actor has an identity ( its mail address ) , a state ( consisting of the addresses of its acquaintances , i . e . , the set of other actors it may send messages to ) and a behavior ( i . e . , its reaction to incoming messages ) . Tile arrival of it message at an actor is called an event  ; it triggers an action described by the corresponding method definition  , a composition of the following atomic actions : creating a new actor  ( create actor Type ( acquaintances ) ) ; sending a message to an acqtminted or a newly created actor  ( send actor message )  ; or specifying new acquaintances for itself ( become ( acquaintances ) ) . An actor system is dynamic , since new actors can be created and the communication topology is reconfignrable in the course of actor computations  . 
The actor model does not contain synchronization primitives  , but we assume one-at-a-times rialized actors for our specification  , i . e . , actors that cannot process more than out message at a time and that process each message step by step  ( cf . Hcwitt & Atkinson ( 1979 ) for expressing this convention in terms of patterns of simple actors  )  . The distribution of comlmtation among the collection of actors is dinsdmonly source of parallelism  . Furthermore , in order to compute complex , but well unders to ~ x\[and locally determined linguistic conditions and functions  , such as unification of feature structures iuld queries ent to a  ( conceptual ) knowledge base , weesud ) I is hasynchronous re-quest-reply protocol ( of . Licberman , 1987) . 
The Parse Talk model extends I he formal found alkms of the basic actor model according to the requirements setup by tilt natural anguage processing application  . These extensions are expressible by the primitives of the basic model  . We distinguish between word actors , relations between word actors and a special set of messages word actors exchange  . 
? Word Actors : The grammatical knowledge associated with each lexieal item is represented in a word actor definition  . Upon instantiation of a specific word actor , d~eacquaintances specilied in the definition will be initialized with actors which stand for the lexical item's morphosyntactic features  , its concept u , ' d representation , valency constraints and , after instantiation and subsequent parsing events  , governed lexical items and further grammatical relations  ( e . g . , adjacency , textual relations ) . 
? Word actor relations : Acquai numces of word actors are tagged according to linguistic criteria in order to serve as navigation aids in linguistic structures  ( the message distribution mechanism described below  )  . Textual relations , e . g . , are distinguished from linear adjacency and hierarchical dependency relations  . Tagging imposes a kind of typing onto acquaintances that is missing in odmractor systems  . 
? Word actor messages : In contras to simple messages which unconditionally trigger the execution of the corresponding method at the receiving actor  , we define complex word actor messages as full -lledgcd actors with independent computational capabilities  . Departure and arrival of complex messages are actions which are performed by the message itself  , laking the sender and the target actors as parameters  . Upon arrival , ' ~ complex message determines whether a copy is forwarded to selected acquaintances of its receiver and whether the receiver may process the message on its own  . Hence , we redefine a narrival event to be an uninterruptables-quence of a computation event and distribution events  . 
The computation event corresponds to an re'rival of a simple message at the receiving word actor  , i . e . an event in the basic model ; it consists of the execution of an ac-tor's lee ( hod that may change the actor ' state and trigger additional messages  . The distribution events provide for the lorwarding of the message and are realized by cre  , q tiugnew complex mess . ages . They depend on the ( unchanged ) state of the receiving actor or on the result of the computation event and take place before and after the computaliou event  . This extension accounts for the complexity of interactions I  ) ct ween word actors . 
We define tl~c semantics of a nactor program in terms of two kinds of networks  . First , we consider event types which refer to message keys and can easily be determined from  , '1 given actor program . Next , we turn to actual events that involve instantiated actors  . Both , event types and events , arc partially ordered by the transitive closures of relations all l  ( )ng them , causest and causes , resp . , that give rise to event type networks and event networks  . 
A program ( in our apl ) lication : a lexical grammar ) is given by a set of actord@nitions . The definition charac-lerizcs the type ( )1" an actor . Given a program , event types , written as I * <- key\] , can be syntactically deterlnined by inspecting the method delinitions wilh in the program  . Let an actor type a Name I ) e defined by: . ? kelg ? J . ~ a Name ( acqua intance 1 . . . acquaintance k ) meth key1 ( param1 . . . paramrn ) ( action 1) .   .   . 
methkeyn ( param1 . . . paraml )   ( action n ) with action idelincd by the following grammar fragment : action : := action  ; action \] if condition ( action )  \[ ~  ( action )  \]
I . ke J3 ? Lactor message Key ( param * ) \] be com _____~ e ( acquaintance * ) Wc may now map message keys to sets of message keys  , defining the function sctipt ~ , r ~ zme as follows : scriptaA ( ome ( ke Yi ) = send ( action ! ) with sent ( action ) := msgKeyifaction=sendactorms gKoy ( param ,   . . . ) setu ( al ) usert da2 ) if action=\[\[condition aI else a2sent ( al ) if action = if condition a 1 sent f ( (at ) usen a C ( a2 ) if action = al ; a 2 else For a program P , script is the union of all given script , m , , e with name e  aroma I P contains a delinition for a Namo and yields a set containing the keys of those messages that can be provoked by a  , nessage with the keymKey . Now , a relation between event types is delined hy causes !:  ( \[*? = mKey\] , \[*?=-nKey\] ) < cattsest : <=> nKey~scrit ) t ( mKey )  . 
Turning to actual events now , we define a nactor a/as being composed of an identity n  ( taken from lhese t of natural numbers , N ) , a state e S and a behaviore 9 . llence, . 9/, the set of actors , is a subset of NxSxO ~ . 
,5 = 2  ( y : z , ) ly is an identifier , zeA\] , an element of`5 associates acqnaintance names and values , which are actors . 
Since actors change their acquaintances , their state is valid in lime , i . e . litapartic nlar event . The state of an actor a . 
receiving a message m will be written as S ? la < = ml ' Slate changes caused by the message apply at the end of the event\[a <=-m\]  ( by executing a become action )  . 
q   #is a set of f n netions , delhted as folk > ws : The states < , e of an lictor , X ' flttile event e ( the reception of amc . ssage m ) is determined by iL , ; initial state given after its creation event , arid the repeated application of its state transition function  , transit ~ c , which maps pairs of stales ( scS ) and messages ( m ~9 ?1 c . 90 to new slates : tra , sitx : (`5x9t4-> , 5Thes and actions an actor , 1" perl k ) rms at a partict flar event are expressed as pairs of target actors and messages to be sent  ; the target actors are either , ' lcqnainlances o\["thesending actor or supplied as message parluneters  . They are determined by the function task ~( , 5 xOv 6-> 2 ( m ( ' q ) ? ~6 where ~ l ( N ) denotes the projection onto the first compo-!tent of N  , viz . N . 
The behavior of an actor A ' can then be stated by the function be ~ ar  ; e ~ Ceq  ~ that comhines trans it , @nd tas ~ . ,,f . in that it maps pairs of suites and messages to pairs consisting of the news late of the actor and a set of pairs of target actor identities and  , nessages , viz . , bebave ~: ( Sx9v~->(Sx2(Tq(&x94)) . 
Abstracting from a local actor perspective the behavior of an entire actor system  ( in our applicatkm : lhelexical parser composed of a collection of word actors  ) is determined by the way multiple events are related under I hecauses relation  ( though events are written as \[ actor <= , nessage l , the message key is used as an abbreviation for the messages in Section  5  ) :  ( \[ a~nil ,  \[ , 6<=-hi ) < ca , ses : ?~( Xl (& , '0 et as fCa(Sa , \[ a~ml ,  "0 . 
Event . ' . ; that ; ire not ordered by the transitive closure of causes can take place in parallel or  , if they refer to the same lictor , ill an arbitrary order . 
4EVENTTYPENI .,; TWORKS PECIFICATION
OF AGRAM MAR FRAGMENT
The protocol ( messages and associated actions ) for establishing dependencies on ! lined below encodes structural restrictions of the dependency structure  ( projectivity )  , ensures incremental general ! on of dependency trees  , and provides a domesticated for nl of concurrency . 
Consider a newly instantiated word actor wn ( cf . Fig . 1) se , ' ! rching bottom-up for its head by sending a search-Head message to its immediate left neighbor  , w ,  . l . The search Head message is recursiv clyforwarded by a sequence of distrihution events to the head of each receiving actor  ( i . e . , w , ,_I , wk , wj ); mess , ' lges only p . ' lss the outer fringe of the already es lablished dependency tree  ( these amcircled in lvig . 1) . Since only the actors receiving the search Head message may later governwn  , projective trees are generated 2 . 
"" X-~---search Head \] , /"' ~ i , j , k , n : text positions/zz . ~"'- o ?' i ~ . . . . . . . % I ; if lurel , \[: olwarding a search message To allow for domesticated concurrency as required for adequate linguistic and cognitive processing  ( Clark & Gibson ,  1988) , are ceipt protocol allows wn to keep track of all events  ( transitively ) caused by its search Head message . This protocol requires each actor receiving a search-Head message to reply Io the initiator of the search Head message hyare ceipt message when the receivers compu-lalion has linished  3  . Since complex messages can be quasi-recursively for warded  , the number of replies cannot be determined in advance  . Therefore , the receipt message contains all actors to which the search Head message has been dislrihnted  , enabling the initiator wn to keep I rack of all receivers and wait for a receipt message from each  4  . 
Only after all events caused by the search Head message have terminated  , the next word actor w , ,~l is instantiated by sendiag a scanNext message to the text scanning actor  . 
2Of coutsew may bel , ovemed by any word actor govem hlgw . lml '' I1J , pdue(oIh ? incremenlality of the analysis , each head c , fwj must Imhx ! ated to I heright of wn . 
3 Note Ihat " eom\[\]tllalioll " here may irldlltIe a tll  . l l l l b e f o f e v e t l l s L hat are ca used by I he so arch Hoad message  , viz . the hoad Found and hoad Aa-copted messages described below  . 
,I We plall I0 extend our algolilhm It , agCllefic\[ efl1"litla\[olI dcte clion scheme similar to tim proposal in Shavit & France  ;  , , ,  1986 . 

II'1O Cotlslrailll/I conxtraml I/ . .~ . /; ~ o ~, , t\[satisfied /\[ . . . . .  ;", . ~,,/ \[ /  .   .   .   .   . J ~' ~ JI structural \] . . ~  . ~' ~/ lambigm't yJ~~,
L-"t . I ) . ., i , . . I ? , ? . -modijiers ' j ( , . <=-, . ,, . . . , - o , j \] i < - . , , o . I . .o . .,,  .   .   .   . ,, L'/J
Figure 2. Event type network
Upon reception of a search Head message , a word actor wk checks whether wn satisfies the couslraints for one of Wk'Svalencies  . If no constraints are satislied , are ceipt message is sent back to signal termination of this particular event at wk  . If wn may I illavalency of wk , a head Found message is sent back to w , , thus possibly imposing additional grammatical restrictions on the targeted item  . If w , is still ungoverned , it adjusts its grammatical description ( and those of iLs modiliers , if necessary , by sending update Foatures to each ) and signals acceptance of the new head hya head Accepted message directed to wk  . These interrelations are sttmmarized in the event ypenet work in Fig  . 2 . 
This three-step protocol allows , qlternative attachmen L , ; to be checked in parallel ( concurrent processing of search Head messages at different actors  )  . Structural ambiguities are detected whenever a head Found message arrives at an actor wn which is already governed  . In this case , wn duplicates itself and its modifiers ( using the copyStrueture message )  , resulting in w , , and asks the prospective head to copy itself ( hysending a duplicat-eStructure message )  , wn becomes head of the copies of the modifiers of wn  ( because a chisans wering the copy-Structure message with a hoad Accepted message  ) and will be governed by the copy of the head ( because the copysends another head Found message town  ; for a more detailed discussion , of . Hahn , Schacht & BrOker , forthcoming) . 
The unpacked representation fant biguity is necessary because of the simultaneous in corpor  , ' ~ tion of conceptual analysis into the parsing process  . Difl'er cnt syntactic structures result in different conceptual nalyses  , which means fllat there is no common structure to share anymore  ( cf . 
Akasaka (1991) for a similar argument ) . The set of actors representing several readings of one lexical item can proceed concurrently  , thus introducing further concurrency . 
5EVENTNET WORKS PECIFICATION OFA
SAMPLE PARSE
We will now consider a part M event network in order to illustrate the parse of " Compaq entwickelteinen Notebook miteiner  120-MByte-Hardd is k "5  . At some point after reading the sentence , the configuration shown on I7 ig . 3 will h ; t ve been reached . The preposition \[ mit\] 6 is not yet integrate due to a mandatory valency that must tm satis-lied prior to making conceptual restrictions available  . 
Upon establishment of a corresponding dependency between Imit\]and\[ttarddisk\]  ( Fig . 3),\[mit\]slarts to search for its head . This search results in the dependency tree depicted on Fig  . 4 . 

Compaq Noel ) ooke in enmit 120-MB-ltarddisk /s ~ Jeceiner Figure 3  . Contiguration before application of " mit " via saareh Headent wickelt 
CompaqNote bookeinenmi % 120-M BIlard diskeiner i Figure 4  . After establishment of dependency The events caused by the satisfaction of the mandatory valency at \[ mit\]  ( head Ae cepted event at top left of Fig . 5)\[mit\]<=ileadAt:cepted ) il , ' igure 5 . Event network 5 A rough English translation of this reads as " Compaq develops a notebook with a  120-MByte hauldivE ' . Notice that from a syntactic per-speclive cilher I heverb " entwicla ~ lt " or the noun " Note book " may take a preposilional phrase w if ll " mlt " specifying an instrument or apart  , resp . This x ~ teutial stnlctural ambiguity dc~s not ( recur in our m~xlel due to parallelev alualicm of constraints in different knowledge sources  . 
6 Word actors represenllng a lexical item " x " will be wrilten as \[ x\]  . 
492 are specified in tim event network in Fig . 5 . The dotted line indicates an alternative possibility how these an Next event could have been triggered  . Of the two receipt events , the last one taking place triggers these an Next event  ( note that both involve the same actor , (mitt , so that they must be ordered , even in a distril ) ut cd system without global lime )  . 
6 CONCLUSIONS
The Parse Talk model of natural language understanding aims at the integration of a lexically distributed  , depen-dency-I ) ased grammar Sl ) C Cification with a solid formal foundation for concurrent  , object-oriented parsing . The associated concurrent compu~ttion model is base deltheactor paradigm of object-oriented programming  , with several extensions relating to special reqtfirements of natural langtmge processing  . These cover mechanisms for complex message distribution  , synchronization i terms of request-reply protocols  , and the distinction of dislriht , tion and computation events . We have shown how the semantic specification of actor systems can be used for the consideration of global interrelatious of word actors at the grammar level  ( even type networks ) and the parser level ( event networks )  . While event type networks provide a general , global view on the behavioral aspects of ottr grannnar specification  , the current formalisms lill lacks the ability to stlPi  ) or tretinal reasoning about computational prope  , r ties of distributed systems , such as deadlock freeness , termination . Ontim of lm rh and , event networks illustrate the cont-imtations during real parses  , but do not allow predictions in general cases . Providing a type discipline for actor deti -nitions may Ix : a reasonable apl  ) roach to till the methodological gap between both layers of description  . 
The Parse T?flk model has been exlmritnentally vali . .
dated by a prototype system , a parser for Germ ; re . The current fifll-form lexicon contains a hierarchy of  54 word class specifications and nearly 1000 lexieal entries ; a mod-ule for l nor phological nalysis is trader development  . The parser's coverage is currently restricted to the analysis of assertional sentences  , with focus on complex noun and prepositional phrases  . The Parse'l ? flk system is imple-inented in Small talk  , with extensions that allow for coarse-grained parallelism through physic  , 'd distribution in a workstation cluster ( Xu , 1993) and a synchronous ntessage passing . It is loosely coupled with lhel . OOM knowledge representation system ( MacGregor & Bates ,  1987) . We currently use a knowledge base with 120 concept delini-ions covering the domain of information technology  . Fur-thennore , an interactive graphical grammar/parserngi -neering work bench is supplied which supports the development and maintenance of the Parse Talk grammar sys-leln  . 

The work reported in this paper is funded by grants fl ' om DFG  ( grants no , lla2097/1-l , tla 2097/1-2 ) within a special research programme on cognitive linguistics  . We like to thank our colleagues , P . Neuhaus , M . Klenner , and Th . 
llanne forth , for valuable comments and supllort.

AGIIA , G . & IIE WI'Iq ; C , (1987) . Concurrent programming using actors , In A . Yonezawa & M . Tokoro , Eds . Object-Oriented Concurrent l'rogramming , pp . 37-53 . MIT Press . 
AKASAKA , K .  (1991) . Parallel parsing system based on dependency grammar  . In C . ltmwn & G . Koch , Fxls . Natural Language Under . 
standing and logic Programming , Il Lpp , 147-157 . North-Iloll and . 
BR(')KF . R , N . ;\] IAIIN , U . & SCI1 ACIIT , S .  (1994) . Concurrent lexicali-zed dependency parsing : the l ' arse Talk model COLIN  (  ; '94: Prec . 
15th Intl . Conf . on Computational Linguistics ( this volume ) . 
CI . ARK , R . &(\]\]I ~ . SON , E .  (1988) , A parallelm ( xlel for adult sentence processing . Prc , c . l Oth Annual Conf . of the Cognitive Science Society . pp . 270-276,llillsdale , NJ : 1 . . F . rllxmm . 
DAFI . EMANS , W . ; l)eSMEDT , K . & GAZI)AI ~ , (1 .  (1992) , Inheritance in natural language processing . Computationall , inguistics , lg(2), 205-218 . 
FVANS , R , & GAZI ) AR , G .  (199() . " lTae DATR Papers , Vol . 1, Univ . of Sussex , II righlon . ( Cognitive Science Research Paper , CSRP 139) . 
IIAIIN , U . ; SCIlACIIT , S . & FIR () KF . R , N . ( fonficoming ) . Concurrent , object-oriented natural language parsing : tire Parse Thlkm  ( xlel . 
International Journal of Ilnman-Computer Studies , SF , ecial Issue on Object-oriented Approaches in Artificial Inlelligenee and 
Ilnman-Computer Interaction , tlF . I . I~WIG , 1~(1988) . C . fiart parsing accolding to tire slot and filler principle  . COLING'88: Prec . 12th Intl . Conf . on Computational Linguistics . Vol . l , pp . 242-244 . 
IIF . WITI ', C . & ATKINSON , R , (1979) . Specification and proof techniques R~r smializers  . Iied ; J ; . Trans'actiom " on Software Engit ; eering,
SI ,;-S(1), 10-23.
lllJD . ' qON , R .  (1990) . English Word (; ram * mar . I ~ asil 1 ~ lackwell , I . II:n II , IMAN , I1 .  (1987) . Concmrenl object-or le , ted programming in Act 1 . In A . Yollezawa & M . Tokoro , F . ds . Object-Oriented Concurrent Prograt ~ uning . pp . 9-36 . MI'I'Press . 
Mae G R F Z ~ OI ~, R .  (1991) . " It mcw~lving technology of classilicalion-based knowledge representation syslems  . In J . Sowa , l!d . Principh ! s of Semantic Networ L~' . Exploration , ~" in the Representation of Knowledge . pp . 3g 5-4 ( X) . Morgan Kaufmam * . 
MacGl ~ liGOl(,R . & I~A'I'F . S , R .  (1987) . The LOOM Knowledge Repte . 
sentation System . University of Souhem California ( ISI Reprint
Series , ISI/RS-87-188)
RIF . SI\]F . CK , C , & SCIIANK , R , (1978) . Comprehensioll by computer : CXlW . ctation-based ; t m dysis of sentence sine on lext , In W . J , M\[ . ev-eh & G . ILF lores d ' Arcais , Eds . Sh Mies in the Perception of l . an . 
Stage . pp . 247-293. J . Wiley,
SIIAVIT , N&FRANCI'~Z,N .  (1986) . A new approach to detection of locally indicative stability  . In 1+ . Kolt , Ed . Autotm Jla , Languages and I'rogramming . Proceedings ICALP 1986 . Springer . 
SIIIF . I~ER , S .  (1986) . An In redaction to Unifteation-based Approache , ~ . 
to Gratmnar . Chicago University Press
SMAL l . , S&RIF . GFI ~ . , C .  (1982) . Parsing and comprehending wiHI word exlmrts ( a I heop )  , all dits realization ) . In W . l . efinmt & M . Rin-gle , Eds . Strategies for Naturall ~ Jnguage Proce . ~ wing . pp . g9-147 . 
L.l : . llhaum.
XU , W .  (1993) , l)L~'trilmted , Shared and PersLvtent Objects . A Model for Distributed Object Oriented Programmblg  . l . on dol ~ Universily , l ) ept , of Computer Science ( Ph . l),l)iss . ) . 

