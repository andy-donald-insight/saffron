"YD/2---A Type Description Language
for Constraint-Based Grammars
Hans-Ulrich Krieger , Ulrich Scldifer

(\] CITIII a At Research ( Je , d ; crtbrArtificiallnte , lligcnc(;(I)FI(I ) Stuhlsm ; zenhmts weg3 , 1)-(;(;\]23 S~m'l)rii(:kcn , Gc~llla , lly
Abstract 2 Motivation
This paper presents " FD ~ g , a typed feal , ure-bascdrein'c-sent , el ; i on language at t ( lild'erence system . Type definitions in TDL cons is ~ of type and feature constraints over the Imolean cmme  ( Mves . TD ? supports open - and closed-wor M reasoning over types and allows for par  ; itions and iu eompal ; i \[) leI . ypes . Working with l ) artially as well as with l hlly expanded types is possible  . E\[lieienl . reasoning in "\]'1 ) 12 is accomplished through Sl ) Ccializedmt Mules . 
Tot)teal Pat)er . 7t ~ pieArea : sofl , w;u'ef in " NI , I ' , gram--mar\['t)i'midism for Lyl)ed\['e ~ H . Hi't:st , rut:lures . 
1 Introduction
Overl ; helast lb . wyears , e o n s l ; raint-based grammar tbrmalisms have become the predom in mttt  ) ar ; t digmin natural language processing ~ uld ( : oulptltal ; iollal linguistics . Their success stems from tim feet that I ; heye ~ LIlbe seen as ; tttiol to LoIti (: , high q e . velrel ) resew-I ; ation language for linguistic knowledge which can be givent t l  ) ree is em~d ; hetn~d:ical semantics . Them Mn idea of represent ii ~ g as much linguistic knowledge as poss it  ) h~throughamfiquedatertype<diedfi'atu*'e struetur  , , Cdlows the inl , egl: , ttion of differenl ; des(:l ; i1) lion levels with oul , taking care of interface probh ! lnS . 
While the tirst N ) l ) roaehes relied ( malmotate ( tI ) hrases LIJ ll ( :l ; lll?eFIlles(e . g .   , PAr\['\[ , ?\[ l ) , 1110 (1(21711 formalism stryl , ospecify grmnmal , ical knowledge as well as lexicon entries entirely through feature  , sL ruetures , h , order to au : hievet , his goal , one must enrich the exl ) res-sive power of the lirst imilication-based form Misms with different forms of disjunctive deseril  ) tions , l , at-er , oL her operations came in t , oplay , e . g . , ( classical ) negation . Ol , her proposals consider the integration of funcl ; i on M/relatiom d del ) endencies in to t , he\[brmMism which make the mingeller al'l 'uriug-c  . omph2te(( . g . , AI , I ';\[4\]) . Howeverl , hemosl ; importantext(msion 1 ; o \[' ormalism seons is l ; softire incorporation of types , lbl:instance in modern systems like TI"S\[15\] , CUIe\[tl\] , or " FD?\[7\] . Types are ordered hierm : ehically its it is known frontol  ) jeet-oriented t ) rogranm dng languages . 
This leads l , o multiple inheritlmee in the description of linguistic entities  . Finally , reeursive types are nee- . 
essary 1 ; o describe at lelust phrase-structure ccursion which is inherent in all gramnta  . ribrmalisms which are nol ; l ) rovid cd with a contextfree loaekbone . 
ht the next section , we argue for the need and rel- . 
evmt ce of using types in CL and Nl , l) . AO ; er that , we give an overview of 7"1)? and il , sspecialized in l ~: rence modules . Espeei Mly , we have it closer look ( ) it the novel features of J'D . ~ and ltresenl , the techniques weh~tvem ployed in iulltle in ( mLing"~1 ) ? , Mode . rntylmdmdtieaJ , ion- . ba , sedgran unax for uudimns differ from et Myunt , yped systcn is in that they high--light tile notion of afi ! ature type  . Tyl)es C~L\[1t ) e3 , 1'-ranged hierarchically , where a subtype inherits mono-tonic Mly all the inlbrmation frolu its supertypes and unification plays l  ; he role of the primary in % rm~t tion-coml ) imng operation . AtN ) edefinitionelm be seen as ; mM ) breviation for ~(: Oml ~ lexexl ) ressi(m , (: ( msisl . ing of I . ypee on straiuts ( eoncerning the sub-/sup(~rl . yp(:rehLtionship ) ; rod feature constraints ( stat , ing the : ~1' propriate M , i;ribut . es and t ; he , ir values ) over the c(mue et . ives A,V , and -, . Types serve its abbrcvi~tfions Ibr lexicone , ntries , 11) rules (: helu ; d . ;'L , and mfiv(~rsa . I its well ask mguage-specilic principles as is l ' amil in rDolnIlPSG  . Ih ~ sides using Lyt ) cs as an abl ) revia . ion ~\ [ tllt(!~ltS~tStemlthd , es rare , I , lere areo , hel ; ~ t(lv~t tl liages as well which cmmot be a (:( ; Oml ) lished byte . nl)la . i . es : ? STRU(JTUIt . INGKNOWI , b;D(' , I ! ; Types together with the l ) ossibility to order then , hier ; u'e hieally allow for aluodul ; u " a Hdele ~ mwayt or , ~l)rcs(' . nl , linguls Lickuowle ( lgen de qu~d , ely . Moreow : r , generalizn tions can be put , a . t the apl ) l ' Ol ~ ri ; d , eh : vels of re . 13resenl;atioti . 
? I,~FFI('IENTI'I,OCI,'SSIN(I
Certain I , yl ) ee ons Lrainl , s (; all I ) e (: ompih ~ diltl , oel : ficient represenl , al ; ious like . bitvee Lors\[I\] , where a(l\[ , l/(grcgd ; esLh ) werbOUlld ) , L\[Jl  ~ , (leaM ; Ul ) p(~rI) , mnd ) , ora , ~( Lyl , es , d)SUml ) liot0eOmlml ; m , iot ~ reduces to low-h'vel bit In an ilmlatio , i ; see Seel , iou 3 . 2 . Moreover , types release mltyt)ed uniliei ~ tio . 
fi'omeXlmnSiveCOmlmI . M ; iouthrough lhei ) ossibility to decl are them in coml ) al ; ilde , luiuhligi(m , working with t . yf ) eu a . mesonly or with partiMly expanded l ; ypes minimizes the costs of copying sl , ruet ; ures during processing . ' Phis can only be a . ccomplishedi\['thesysLentm~ukes at Uleeh ; LILiSln for type exlmnsion available ; see Se(:l , ion ; L4 . 
? TYPE ( JIIECKIN ( I'Fype deliniti ( msallow ngramm ~ riml to ( leel ar ( ~which attributes a real ) l ) rOl ) riate lkq ' a given l . yl ) e and which types m : e a . l ) prol ) riate for a given at . .
tribute , the relb . ' ed is allow iug one to write il ~(: ( ms is tent , feat , m'e structures . Again , type expansiollis necess ; try to determine the glol ) Metmsist , eney of it given description . 
? RECIJltSIVI , \] TYI'ES lecursive l , ypes give it glml mnar writ . or the op-porl . unity to formuln l . ecerl . Mnfimel . ion . sorre--lations as recm'siv ctype specific . ; t tions . \ Yorking in the type deduel , ioli ) ~- tra(ligmel\]i ' or ecsa , grammar writer 1 , or el ) la (: ethee onl ; exl; . .fl'ee back . 
89, 3 bone through recursive types . Here , parameterized delayed type expansion is the ticket to the world of controlled linguistic deduction  \[13\]  ; see
Section 3.4.
3TD ?
TDZ : is a unificatiol , -based grammar development environment and run time systems npporting HPSG-like grammars  . Work on TD?has started within the DISCO project of the DFKI  \[14\]   ( this volume )  . The DISCO grammar currently consists of approx .   900 type specifications written in TD ? and is the largest HPSG grammar for German  \[9\]  . The core engine of DISCO consists of T/I ? and the feature constraint solver // D/A ~  \[3\]  . ND/~itself is a powerful untyped unification machinery which allows the use of distributed disjunctions  , general negation , and fllnction-aldependencies . The modules communicate through an interface , and this connection mirrors exactly the way an abstract typed unification algorithm works : two typed feature structures can only be unified if the attached types are definitely compatible  . This is accomplished by the unifier in that ~ handles over two typed feature structures to TD ? which gives back a simplified form  ( plus additional information ; see Fig .  1) . The motivation for separating type and featn re constraints and processing them in specialized modules  ( which again might consist of specialized components as is the case in  73  ) ? ) is twofold : ( i ) this strategy reduces the complexity of tile whole system  , thus making the architecture clear , and ( ii ) leads to a higher performance of the whole system because every module is designed to cover only a specialized task  . 
3 . 1 TD ? Language 7"D ? supports type definitions consisting of type constraints and feature constraints over the operators A  , V ,  -1 , and ?( xor ) . The operators are generalized in that they can connect feature descriptions  , coreference tags ( logical variables ) as well as types . 
77 ) ? distinguishes between arm types ( open-world semantics )  , sort types ( closed-world semantics ) , builtin types ( being made available by the underlying COM-MON LISP system  )  , and atoms . Recursive types are explicitly allowed and handled by a sophisticated lazy type expansion mechanism  . 
In asking for the greatest lower bound of two awn types a and b which share no common subtype  , TD ? always returns aAb ( open-world reasoning )  , and not 2_ . The reason for assuming this is manifold : ( i ) par-tiality of our linguistic knowledge ,   ( ii ) approach is in harmony with terminological ( KL-ONE-like ) languages which share a similar semantics ,   ( iii ) important during incremental grammar/lexicon construe-tion  ( which has been shown use fid in our project )  , and ( iv ) one must not write superfluous type definitions to guarantee successful type unifications during processing  . 
The opposite case holds for the C , LB of sort types ( closed-world approach ) . Furthermore , sort types differ in another point from a vm types in that they arc not fllrther structured  , as is the case for a to Ins . Moreover ,   779? oilers the possibility to declare partitions , a feature heavily used in If PSG . In addition , one can declare sets of types as incompatible , meaning that the conjunction of them yields ? , so that specific avm types can be closed . 
7"D ? allows a grammarian to define and use parameterized templates  ( macros )  . There exists a special instance definition facility to ease the writing of lexicon entries which differ from nor  , haltypes in that they are not entered into the type hierarchy  . Input given to TD ? is parsed by a Zebu-generated LALR  ( 1 ) parser\[8\] to allow for an intuitive ,   hi9h-level input syntax and to abstract fi'om uninteresting details imposed by the unifier and the underlying L is p systen r  . 
The kernel of TD ?- .   ( and of most other monoton-ic systems ) can be given a set-theoretical semantics Mong the lines of  \[12\]  . It is easy to translate TD ? . 
statements into denotation-preserving expressions of Smolka's feature logic  , thus viewing 7"D ? only as syntactic sugar for a restricted ( decidable ) subset of first-order logic . Take for instance the following feature description O written as an attribute-vMue matrix : np\[agr'eement\]?=A~\[\]NUMsO 
PERS 3rd
SUBJ\[\]
It is not hard to rewrite this two-dimension M description to a flat first-order formula  , where at-tributes/features ( e . g . ,  . ~GR ) are interpreted as binary relations and types ( e . g . , up ) as unary predicates : 3 ~ .   , ~ p (?) A , Ga(e , , ~) A , , a , ?~em~ , ,t (~) A RUM(x , sg ) APERS(x , o ? 7"(1) ASUBJ(? , x ) The corresponding VD ? type definition of ? looks as follows  ( actually & ; is used on the keyboard instead of A , \[ instead of V , ~ instead of ~ ) : ? := npA\[AGR#xA agreement A\[NU llst , PERS at ' d\] , 
SUBJ#~\].
3.2 Type Hierarchy
The type hierarchy is either called directly by the control machinery of TD ? during the detinition of a type  ( type classification ) or indirectly via the simpli-tier bo that definition and at runtime  ( type unification )  . 
3.2.1 Encoding Method
The implementation f the type hierarchy is based on A'/t-Kaci's encoding technique for partial orders  \[1\]  . Every type t is assigned a code 7 ( t )   ( represented via a bit vector ) such that 7 ( 0 reflects tile reflexive transitive closure of the subsumption relation with respect to t  . Decoding a codec is realized either by a lookup OFF  3t   .  7-1 ( c ) = t ) or by computing the " maximal restriction " of the set of types whose codes are less than c  . l ) e p e r , ding on the encoding method , the hierarchy occupies O ( n log n )   ( compact encoding ) resp . O(n2) ( transitive closure encoding ) bits . ltere , GLB/LUB operations directly correspond to bit-or /and instructions  . GI , B , I , UB and ~ computations 1-1ave the nice property that they can be carried out in this t Yame work in O  ( n )  , where n is the
Query ~1,\[ . . . 1 up / . Result ~\]\] A\[~< bl , N > ~ pehiera , rchy-<~--( , tAb)TZ ) ? < ~ ,   , , A ~ , _q , yo ~ , ~ o , ~ ai ~ ) > Figure 1: htterfa ( ' e between " FDE and ll / ) ' && Depet Miugon the type hierarchy and the type of ~ and \[~  , TD ? . either returns c(c is delinitely the ( ; LB of a and b ) or a Ab ( open-world reasoning ) resl )  . ~ L(clo . se < l-world reasoning 9 if there doesn't exist a single type which is ecplal to the GLB of a and b  . In addition ,   7"DL : determit ws whether tlDi32: must carry outlbature term unification ( yes ) or not ( no )  , i . e . , the return type contains all the information one needs to work on prol > erly  ( fail signals a global unification lhilure )  . 
number of (, ypes.1
Aitq ( a ci's nmthod has been extended in 7'D ? to cover the ol ) en-world nature of avm types in thai ; potential(\]I , I ~/ LU Bcm Midates ( calculated front their codes ) must be verified . Whyso ' . eTake the . lbllowing ex~mrple to see why this is ne . cessary : a : := J/A z x ' := y ' A z ' A\[ . 1\] l ) uring processing , one can definitely substitute yAz through % I ) ut rewriting ! I'Az'to a :' is not correct , because x ' difl'ersfi ' omfAz'-a/ismore speciiic as a coltseqt lell CX : of the l~e  ; ~ ture consl , r ~ t\[llt\[t t1\] . So We make ; ~distinction between the " internal " gre ; ~test lower bound GI , B4 , concerning only the type subsumptiot ~ relation i  ) y using Ait-Kaci's method alone ( which is however used for sort types ) and the : ' ex-t (  , rmq " one , GIAc , which takes the subsumption relation over f i ; ature structures into & (: CO tlllt . 
With Gl , l ) -< and GLIJc in mind , we (: m ~_ define , a generalized (~ , B operation in fbrmally by the following table . This GLI operation , is actually used during type mfitication(jr ( . ':: feature constraint ) :- di~g -, T is , , ~- . ~oT!,~fft,~i,u-F_f,;7-\[_f , '~_lLs,'-~ . \[? l-Is- . -- ;  . j ? lJh('A'c a,J mj <> Gl . llE( . vmi , a , , m ~) - . . vm ,:~ ( IUIIL 1 #,:--~? ( ll~?lt I ~ ( llHII . 2I .   . L ~ --> . C\[ , I \] ~( am nl , arm2)--J_ , via an explicit in comp ~ ttibility de clara ~ tion aural Aaline !  , otherwise ( open world ) ~ . . ,,,,,,,,~ <= . exp ~ md ( , , , , , . ~) ni ~: ~, , ? z_L , otherwises or ' t . ~?-=>(\]l,I5(sortt, . sort e ) = ~ or ta 3 . sort t4;: . _ ~ sort1==sort2 . L , otherwise ( closed worM ) at , oral , ~~--' . ~ type-of(a/oral , ~) ~ sort . & i , , 1 . where sort ~, lis ~ builtin
J . , otherwise 5 .   . a to Htt # , - - ~ ooHtI = : ( tlont2? , otherwise T4~>f , : lVIfc~?_l_6 .   . _L , otherwise The encoding algorithm is also exl , m , ded towards the rcd cJ iuition of types and the use of und cJ lmd types  , an essent i Mlmr to fat , im : remental gram-mar/lexicon dew . qopmet d , systen l , ll . edetining aI , ypemeans no toldy to m~kechanges local to this type  . 
h , stead , ( . , lie I : 4Store defil , eall dep cnd cul . s of this type-all subtypes in case of a conjunctive l  ; ypedefitd tion and all disjunction alternatives for at disjuuc-tive type speeilication plus  , in both cases , all types which use these types in their de\ [ inition  . The dependent types o\[al . ypet can be characterized gr~q ) h-theoretically vial , he strongly c ( mnected component of t with respec to the depe , Mency relation . 
3 . 2  . 2D ( moln I ) osing Type Definitions Conjm~ctivc , e . g . , x := J/Az ~ tnddisju , u ; tivct!lp(' . 
specificalio ) ~ s , e . g . , a / ::-= f V z / are entered difl'er-ently into the hier ~ u'chy::cinherits from itss  , ,per-l;ypes 9 and z , whereas x ' delines its efthrough its IActuMly , one can choose , in 7" DEI ) ctw ccn the two encoding I : cchniques and between bit vectors and bignumsill COMMON\[ASP for the representatiouf the codes  , h , our I , l . ql ' implelnent a Lion : operatimm on bignulns are . a magtfil ; u de faster than on bi ~ vectors . 
895 \ Jzlu AvAwly
Figure 2: The intermediate types luAH and NAvAwl are introduced by TD ? during the type delinitions  , = := uA ' ,   , A\[a0\] and Y := wAvA , * A\[a1\] . 
alternatives !/ and z ' . This distinction is represented throughtile use of different kinds of edges in the type graph  ( bold edges denote disjunction elements ; see Fig .  3) . But ; it is worth noting that both of tllem express subsumption  ( x ~ y and x '> -_ y ' ) and that the GLB/LUB operations must work properly over " conjunctive " as well as " disjunctive " subsumption links  . 
TD ? decomposes complex definitions consisting of A  , V , and ~ by introducing intermediate types , so that the resulting expression is either a pure covjunc-lion or " a disjunction of type symbols  . Intermediate type names are enclosed invertical bars  ( ef . the intermediate types \[ uAvI and luAvAw in Fig  .  2) . 
Tile same technique is applied when using ? ( see Fig .  3) . ( b will be decomposed into A , V and ~ , plus additional intermediates . For each negated tyt ) e~t ,  7"1 ) ? introduces a new intermediate type symbol I-'tl having the definition ~ t and dechu'es it incompatible with t  ( see Section 3 . 2 . a ) . I , ~ addition , if t is not already present , T / ) ? will add t as a new type to the hierarchy ( see types\[~b\[allcl\]-el in Fig .  3) . 
Let's consider the example a := b?c . The decomposition can be stated informally by the following rewrite steps  ( assuming that the user tu~s chosen
CNF ): a := bOc . := (~ A-~(-)v(-~Ac) . := ( bv-~b)A(bvc)A(-~V ~) A(- , eVe ) , , := (~ v e ) A (~ v ~) . := I~velAI ~ bWel3 . 2 . 3Incompatible Types and Bottom

Incompatible lypes lead to the introduction of specialized bottom symbols  ( see Fig . 3 and 4 ) which however are identified in the underlying logic in that they denote the empty set  . These bottom symbols must be propagate downwards by a mechanism called bottom propagation which takes place at definition time  ( see Fig .  4) . Note that it is important otake not only subtypes of incompatible types into account but also disjunction elements as the following example shows : 
T-k(b,~b \] J-e,~c
Figure 3: Decomposing a := b?c , such that a inherits from tile intermediates IbVc \[ and b/  , v ~ cl . 
.k -- a A b . _ ~ C + aAbi := J - and a Ab ~= J_b := bl Vb . ) . 
One might expect ; that incompatibility statements together with feature term unification ol onger lead to a monotonic  , set-theoretical semantics . But this is not the case . To preserve monotonicity , one must assume a 2-level interpretation of tgpcd feature structures , where feature constraints and t , ypeconstraints might denoted if lb . rent sets of objects and the glob ~ al interpretation is determined by the intersection of the two sets  . Take for instance the type definitions A :=\ [ a 1\] and 13 :=\[ b 1\]  , plus the user declaration J -= AAB , meaning that A and B are incompatible . 
Tl , enAAB will simplify to J_although the corresponding feature structures of A and\[t successfully unify to \[ a  1  , b1\] , thus the global interpretation is ? . 
3 . 3 Symbo l i c S impl i f ier \[ File simplifier operates on arbitrary TD~expressions  . 
Simplitication is done at definition time and at runtime when type d unification takes place  ( cf . \] rig .  1) . 
The main issue of symbolic simplitication is to avoid  ( i ) unnecessary feature constraint unification and ( it ) queries to the type hierarchy by simply applying " syntactic " reduction rules  . Consider all expression like x ~ A .   .   . Axi .   .   . A " ~ a:i , .   . Axn . The shnplilier will detect . k by simply applying reduction rules . 
The simplification schematare wellknown from the propositional calculus  . They are hardwired in the implementation to speed up computation  . For-really , types implitication in " FD ? can be characterized as a term rewriting system  . A set of reduction rnlesis applied until a normal form is reached  . Con-fluence and termination is guaranteed by imposing a total generalized lexicwraphic order on terms  ( see below )  . In addition , this order has the nice effects of neglecting eommutativity  ( which is expensiw . ' and might lead to termination problems ) : there is only one representative l bragiven formula  . Therefore , memoizatiouischeap and is employed in TD ? to reuse precomputed results of simplilied expressions  ( one must not cover all permutations of a formula )  . 
Additional reduction rules are applied at runtime using " semantic " inlbrmation of the type hierarchy  ( GLB , LUB , and ~) . 
896\[l-d ',:: bA\[pt'\].
<::: bA\[p--\].
. t , - - - + <, / /~ . c . l-a , b > , : I-a , b , cIqgured : I Jottom propagat , icmtrigg'eredthroltg ' h the:mbEglWS daud cof b  ,   , sof , ha . LaAdA cas well w;aA, . : A c will simI > lil ~ to_L during processing . 
a . a . 1 Nornial Forllihi order to reduce ; uim ; 1)il ; rary l , ylm expression to it simpler expression , Siml ) lifi (: al ; ion rules in usl;I ) ea\])-plied . So we have to deline wh;Ll , it , lfie0Al . q for & ll expressiol lt()t )( ; " SJlllllle ' . Ollo , Cil Jleil ; he , r (: boo , q(; the coujim cl , iv cor disjuimt , ivenol : maJtbrm . The ~ tdw tlr-
I , agcs of CNI "/ I ) NF are : iUNIQIIF , NES , q < l'y l ) e(' . XlJl : ossiollsilll lOl ' lll~t\[\[O1"111 ttl ; CI llliqllO , niodulo(; on unutal ; ivil , y . Sorl , ingl , yllcext J ressions according t , o~t ; oi , ;d lexi(Jographic order will lead i ; oai : ot Muiliqueness of l , yl ) eexlli:essions ( , <-;ee , 
Section 3.3.3).
? LINEAII'FY'\['ype expressions in liOi'lllal\[ ' or lll  ; ~ i : elinear . Arbil ; r ; tly llesl . ed expl:essi()iisc:itiilie1,ra . nsfort xiedinl , ollal(JXl)i'OS,'-;i OllS . This l\[l; , tyl'(' , dlil ; (? i , he COHIplexil , y of laters in iplilicatious , e , g ; . , ; d ; rllil time . 
?(Jt ) Ml'aItABII,1TY
This l ) roperi , y is a colls ( xlll ( ; lt(:(! of the two oi ; hel ; proli ( ; l : tie , <; . ( ~' ni ( lueaal ( I line , u : exl ) ressions l nake it ; easyi , oliild O1"1 , () cOUllm , ' e(sul )) expl:essions . 
This is it ll ) Ort , all t , \ [ or the liierlloiz ~ d ; iolix ; t : hliique described in Scctioii3 . 3 . 4 . 
3 . 3 . 2ll , eduction Rnl ( ~slu order to reach a normal for ui , it ; would suffice to at ) l ) ly only the s(:ll . etlt ; t ;; ~\ [' or ( lf ) ll)\[(~neg ~ l , ion , dis-I , ribul , ivity , and De Morgan'sh ~ ws . I lowever , in the worst case , t , hcscI , hr ('(; rtlleswouht blowiIt)i , heleugl ; hofth(~normallbrmtoeXl ) On Cnl , ial size ( (: omp ~ u'ed with \] , hemtull ) ero\[lit , erals iu the origina J expression ) . To~o , ' oi(lI , his ,  ()( ; her titles ; tr('use(I intermedi-ately : idempot cnce , idenl , ity , al ) sorpl , ioih etc . If they can l ) e applied , t , he . y alw ~ tysre ( tilt : l , helengl , h of I , hc expressions , l '\] specia . llyw\[;runl , ime , llu (; also al ; del L\]nil ; iontilne , i \ [ , is use\['ultoeXldOi\[ , inf brmM , i(m\['rt ) ln the , t , ypehi ( warchy . I " url , h(:rsiml ) lilit:al , ious arel ) ossi-hieby ~ csking lbrl , h(;(:ll , lt ,  \ ]  , till , alt d ~ . 
3.3.3 Lc'xlcogral)hic Order
To avoid the al)pli('ation of l ; ltc cotm nutativil , y rule , wc introduc ( ~; ~ to ( , all cxi cographic order on tyll ccx-lU'essious . Together with I ) NF/(TNI , ' , we ol ) taiila uniques or l ; ed normal for ntt bran arbitrary l ; y\[)e expression . This guarant , eesfast (: oin parabilil , y . 
We define I ; he order < NF on 7> ary normal forms : t ~ , lpe<N ~; neqaled type < NI ; conjunction < NI , ' dis , - , \ ]'?trtCti01~ < NI " symbol < NI " striu9 < NF ~ lltll21J  ( ~ F . l " ot ' the coinl ) arisoil of atoms , st ; rings , and type names , we use the lexic , ographical order on strings ; rodl brllitlllt )(! l:S\[ , h(~ordering < oun ; ttural IIII lH\[)OI'S . 
l" , x ; unple : a < NI ; b < NI ; bb < NI ; -m(t < NI ; c . zAb < NI , ' aA- , a < NI ; a Vb < NJ " ( tVb Vc < NI ; a Vi : 1 . 3 . 4 Memoizal fioit The memoization t , cchnique describe , din\[10\]hw- ; 1) een ad ; q ) ted in order to reuse precomlml , ed resull ; so \]' l . ypes in q ) li\[i <: at , ion . The lexicogral > hically sorted nor-lnMf ?) rniguar ; uitees fast ; ~ u : cess1 ; ol U:CCOlnlml ; e(ll , ypesinll ) lilications . Memoiza ; i on resull , s are also used by the recursive simplific ; d ; i on algorit ; hm ( ; o exploit , pre-conllmted results for subexln : cssions . 
Some enq firical results show I ; he usefulness of nteui-oization , The current DISCO grall ltlUtr\]'t)rQ' , 0r-lI~l , llco118i81 , 8o \]'88 F ) types ; uld 27 tentl ~ latx : s . AI : teralull ( , ylmex pausion of a toy lexicon of 244 in s ( , ; tltces/elll , ries , the lnemoiz ; tl , iontable t x mtaium approx . 3000 cnl ; ries ( literals m'c no Llneuloized) . 18000 results have been reused ~ t t ; lc ' as l ; once ( some upt ; (~ 600 ti ines ) of whMl 90% ~ repropers in lplilica (  , ions(i . e . , the siinpli l icd formulae m:e really shorter th ~ mt  , heuns implilied ones ) . 
3.4 Type Exlmnsion and Control
Wcnoted earlier I , hat types allow us to refer to c(m , --pIex constraints folirouglitim use o\[symbol nantes  . 
l/ , ecolml , rucl , ing , he consl , r ; tinl , s which determil maI , ype(rept:eseltted as a\['eatures l , rucl ; ure ) requires a complexol ) er ; -ttion called Qj pcc , 7 , Tmusz'om This is COml ) ; tr ; tbleto(Jat'lmnl ; er'slolal hjwcll-l~jpcdncss\[5\] . 
3.4.1 Motivation
In ~ J ' l ) l ~ , I , hemot , i w t t ioll for type expansion is m ; m-ii bl(l : ? CONSISTI , ; NCY AI , definition time , type expansion del , ermiues whc ; hertimst : l , of , ypedelinil ; ion , s(grammar and lexicon ) is consistent . At ; runtime , t , ypeexi ) ; m-sion is involved in checking the satis\[i ; d ) ility of l ; heunilical ; ion of two part , \] ally explm(h . ' dtypedfe;d , ures (; rucl , lures , e . g . , during parsing . 
897 ? ECONOMY
From the standpoint of efficiency , it ; does make sense to work only with small , partially expand-ed structures ( if possible ) to speed up feature term unification and to reduce the antount of copying  . At the end of processing however , one has to snake the result/constraints explicit . 
? It ECURSION lecursive types are inherently present in modern constraint-based granmlar theories like IIPSG which are not provided with a contextfree backbone  . Moreover , if the formalism does not allow fnnction M or relational constraints  , one tnust specify certain flmctions/relations like append through recurslve types  . Take for instance Ait-Kaci's version of the append type which  ( : ass be stated in "\]- DE as follows : append := append oV append l  . 
aN ) endo :=\[ FRONT <>,
BACK #1Alist,
WHOLE#1\].
append , :=\[ FRONT <  #first . #~ v.stl >,
BACK  #backAlist,
WHOLE <  #first .  #rest 2 > ,
PATCH append A\[FRONT  #rest l,
BACK  #back,
WHOLE  #rest2\]\].
oTY PEDEDUCTION
Parsing and generation can be seen in the light of type deduction as a unifor in process  , where ideal-ly only the phonology ( for parsing ) or the semantics ( for generation ) must begiw ' . n . Type expansion together with a sufficiently specified grammar then is responsible in both cases for cov-strncting a fully specified feature structure which is maximal informative and compatible with the input  . I to we ver , \[ la\]has shown that type expansion without sophistieated control strategies is in Illany cases inelficient and moreover does not guarantee termination  . 
3 . 4 . 2 Controlled Type . Exliansion Uszkoreit\[la \] introduced a new strategy t br linguistic processing called controlled linguistic deduc-lion  . Ills approaeh permits the . specitication of lit>gnistic performance models without giving up the declarative basis of linguistie competence  , especially monotonicity and eompleteness . The ewduation of both cm0nnctive and disjunctive constraints can be controlled in this framework  . For conjunctive constraints , the one with the highest faihtre probability should be evahtated first  . For disjunctive ones , a success measure is used instead : the alternative with the highest success probability is used until a unification fails  , in which case one has to backtrack to the next best alternative  . 
7'D ? and / . /D~desnpport this strategy in that every feature structnre can be associated with its sue-cess /faiht repotent iM such that type expansion can be sensitive to these settings  . Moreover , one can make other decisions as well during type expansion : ? only regard structures which art subsumed by a given type resp  . the opposite case ( e . g . , expand the type subcat-list always or never expand the type daughters  ) ? take into & c coutttonly structures under certain paths or again assume the oliposite case  ( e . g . , always expand the wtlue nailer path SYNSEMILOCICAT  ; in addition , it is possible to employ path pattenls in the sense of pattern matching  ) ? set the depth of type expansion for a given type Note that we are not restricted to apply only one of these settings -- they can be used in combination and can be changed dynamically during processing  . 
It does make sense , t br instance , to expand at certain well-defined points during parsing the  ( partial ) information obtained so far . If this will not resnlt in a failure , one can throw away ( resp . store ) this flflly expanded feature structure , working on with the older ( and smaller ) one . t lowever , if the information is inconsistent , we luust backtrack to older stages in computation  . Going this way which of course assumes / seuristic knowledge  ( language as well as grammar-specific knowledge ) results in faster processing and copying . Moreover , the inference nginelllnst be able to handle possibly ill consistenl  , knowledge , e . g . , in cast of a chart parser to allow for a third kind of edge  ( besides active and passive ones )  . 
3.4.3 Reem'siw ; Types , hnplenmntational
Issues , and Undee idabillty
The set of all recursive types of a given grammar /lexicon can be precompiled by employing the dependency graph of this type system  . This graph is updated every time a new type delhfition is added to the system  . Thus detecting whether a given type is recnrsive or not reduces to a simple table look--up  . 
l to we verl , he expansion of a recnrsive type itself is a little bith arder  . In T ' D ? , we are using a lazy expansion technique whMt only makes those constraints explicit which are really new  . Top slt it in a not h- . 
erway : if no ( global or local ) control information is specified to guide a specific expansion  , are cnrsive type will be be expanded under all its paths  ( local plus inherited paths ) until one reaches a point where the information is already given in a prcJi : r path  . We call such an expanded structure are solved type ilt ? ~  . a-ture structure . Of course , there are in linitely many resolved feature structures  , but this structure is the most general resolved one  . 
Takel brinstance the append example l ? om the 1 ) revions section , append is of course a recursive type because one of its alternatives  , viz . , append 1 uses append under the PATCH attrilm te . Exl ) and - ing append with no additional information supplied  ( especiMly no path leading inside appcndl , e . g . , PATCH I PATCH I PATCH ) yields a disjunctive feature structure where both appendo and append I are substituted by their definitior l  . The expansion then stops if no other informatiol l enforce a fisr the rexpansion  . 
In practice , one has to keep track of the visited paths and visited type il feature structures to avoid unnecessary expansion  . 3'0 make expansion more el Lficient , we mark structures whether they are fully expanded or not  . A feature strnetnre is then fully expanded iff all of its substructures are fully expanded  . 
This simple idea leads to a massive reduction of the search space when dealing will sincremental expansion  ( e . g . , during parsing ) . 

It is worth noting that the satstability of feature descriptions admitting recursive type equa-tions/detinitions is in general undecidable  . Rounds and Manaster-ll , aum r\[11\] were the tirst having shown that at ( as per-ll . ounds logic enriched with recnrsive types allows one to encode it Turing machine  , lie-cause our logic is much more richer , we imlne(liately get ; the sanle result tbrTD ? . 
i to wever , one can choose in 7" l ) ? between a complete expansion algorithm which may not terniinate and a non-comf  ) lete on (  . ' to guaranteet crmin~-ttion(see\[2\] and\[5 , Ch . 1, 5\] for similar prol , osals) . The latter ease heavily depends on the notion of resolvedness  ( see above )  . In both cases , the depth of the search space can be restricted by specifying a maximal path length  . 
4 Compar i son w i th o ther Sys tems 7'D /~ istmique in that itiml ) lemevts many novel features not found in other systems like ALE  \[4\]  , I , IFI ';\[2\] ,  (7 , : TIeS\[15\] . Of course , these systems l , rovide other l ~ atures whiclt are not present in our formal-s in  . What makes 7 , D ? unique in CO ml Taris onto them is the dist inction open vs  . closed world , the awd labil-ity of the full boolean connectives and distributed disjunctions  ( via UD / ~ )   , as well as an imphmte , lted lazy type expansion me chaifism for reeursive types  ( as compared with LIFE )  . AI , E , \[brinstance , neither allows dismintren or recursret yl ) es and enforces the l ; ypehier archy to be a I ? , CPO . I Iowever , il ; makes recursion available througl , detinite relations and incorporates special mechanisms\[breml  ) ty categories and lexical rules . TFS comes up with a closed worh l , the unawdlability of negative information ( only implicitly present ) and only a poor tbrm of disjunctive informat ion but performs parsing and generation entirely through type deduction  ( in fact , it was the tirst system ) . LIF'I'3 comes closest to us but l ) rovides a se-mantics for types that is similar to TFS  . Moreover the lack of negative information and distributed dis-junctions makes it again comparal  ) le with TFS . LIFF as a whole can be seen as an extension of PROI  , O ( ~  ( as was the case for its predecessor LO ( ' HN )  , where tirst-order terms are rel ) laced by . ~- terms . In this sense , I , IFF , is rMmr than on r fomalism in that it offers a fifll relational calculus  . 
5 Summary and Outlook
In this pal)er , we have presented 7 , D ? , a typed tha-ture for lnMism thg ~ t integrates a ) ower flfl feature con-strMnt solver and type system  .   13oth of t\]tem provide the boolean connectives A , V , and ~ , where a con > l ) lexexl ) ression is decomposed by emphTying intermediate types  . Moreover , recursive types are supported as well . lit 7 , D/2 , a grammar writer decides whether types liw . ~ in an open or a closed world . This ef-f e . cts(\]Ltl and LIJI\]computations . '' he type system i ~ , self consists of several inference components , each designed to cover etficiently a specific task :  ( i ) a tilt vector encoding o\[the hierarchy ,   ( ii ) a fast symbolics implilier for complex type expressions  , ( iii ) memoization t ; (7 cache preeomI ) uted results , and ( iv ) aso-phisticated type expansion nm chanism . The system as described in this paper has been implemented in COMMONIASP and integrated in tile I  ) ISC Oenviron-men\[14\] . 
The next ll ; kj or version of 7 , D ? will be integrated into a declaratives l ) ecilication langttage which allows linguists to define e outrol kuowledge that can bensed during proe ~  . ' ssing . In addition , certain forms of know edge , compilation will be made availa/flein future versions o\['TD/~  , e . g . , the auto lnat ic detection o \[' syntact ic in e o n q  ) atibilities between tyl ) es , so that a type e Omlmtation can subsl , it ute an extensive feature term unification . 
Re\['erences\[1\]llassanAi't-Kaci , Robertlloye . r,Pa(a'ickLincoln,~-tlldtogerNasr . I * ; flieient ; implementation of lattice operations . ACM Transactions oul ' rogramm in 9Lan- ( lUages aud Sgstcms ,  11 (1 . ):115-146, January 1989 . 
\[2\]II assan M'l , - Kaci , Andreas Podelski , and Seth Copen Goldstein . Ovder-sort , edR : a Luretimoryuni\[ica Lion . 
Teclm . Hcport 32,\]) ECP arisl/ . esem'ch , lb . , tg . ')a . 
\[3\]Rolf\]~a(:kofcll and Cln'ist ; oph Weyers . UDi/g'cafca- . lifet:onst , raint solver with distributed disiunction and classical negation  . Teclmical report . , D \[" K \[ , Sct\[tt'-brficken , (\] ermmty ,  1!/9-1 . Forth conting . 
\[4\] Bob Carpenter . ALE ; heal ; tribu (: elogic engine us-er's guide . Versionft . Technical report . , Labm'atoty for Computal ; iona\[l , inguisl ; ics . Carnegie Mellou University , Pit ( . sburgh , PA , 1992 . 
\[5\] Bob Carpenter . The Logic of ~ lilped Feature Struc-tm'cs . Cambridge University Press , Cmnbridge , 19!)2 . 
\[6\]  . lochenl ) Srre and Michael Dovna . CUF . a formalism for lhtguisi , cknowledge representation . In ?1'l ) ~ ~ lt ' ~, editor , Comp . utational Aspects cff Cou-straint-B , sed Linguistic Description . DYANA ,  1! ) 9: L\[7\]llans-UMch Krieger and Ulrich Sch'ffer .  "\['1)? . -a type description language for HPSG . Pm't2: user guide . Technical report , DFKI , Saarbrlleken , ( k't'-many ,  19!)-1 . Forthcoming . 
\[8\] Joachilnl ~ aul ) sch . Zebu : A tool for speeify il ~ gr cversible\] , ALR(I ) parsers . '\]' ethnical re . porl ;, I Iewle M ;-
Packard , 1993.
\[9\] Klaus Netter . Ar(:dteci;m'e and coverage of ; he1)\[,% . 
CO grammar . In S . Busemamtaim K . II arbusch , eds . , t'roc , of the DFKI Workshop on N , tural Lau-9tu , /e Systems : Modularity and ltc-Usability ~1993 . 
\[10\] Peter Norvig . Techniques fin'mt tomal:ic memoizai ; ion with applications t ; o (: oul ; ex ; -ft'eepro'sing . Computational Linguistics , 17(1):91--98, 1991 . 
\[11\]William C . \] O/llttls and Alexis Mg . tli . ~ tsl ; tw-l~-ttllel ' . A logical version of fimction algr ; unms u ' . In Procccdi , , qs of the AUL , pages 894) 6, 1987 . 
\[ t2\]GerLSmolka . A feature logic with subsorl ; s . I , II , O(',l/ . eporL33, IBM (; ermany , Sl ; ut . tgart , 1988 . 
\[13\]llans Uszkoreit . Strat ; cgies for adding control inf of lintion ( . o declarative gr ; munars , inl ' roccediuya of the ACL , l ) agcs 237 245 ,  1991 . 
\[14\]H . Uszkoreit . , R . Backofen , S . lhlsemann , A . K . l ) iagne , E . A . Ilinkehnan , W . Kasper , B . Kiefcr , t\[ . -/ j . KT " ieger , K . Netter , G . Neummm , S . Oel ) en , and S . \[ ) . Sl ) ackman . DISCO-an HPSC ;- bas (: dNI , Psys . -ternaimil ; sapph : al ; ion for a plmint lnentuched ulhlg . 
In Proceediuqs of COLING , 1994.
\[15\]HdmiZajac . Inheritance and constraint-bas (' . d grammar formals in s . Computational Linguistics,
J8(2):tat ) ~82,1,,),,)2.

