ATREATMENTOFNEGATIVE DESCRIPTIONS OF
TYPED FEATUREST RUCTURES
KIYOSHIKOGURE
NTT Basic P~esearch Laboratories
911 , Midori-cho 3-chome , Musashino-shi , Tokyo , 180 Japan
kogure@atom . ntt.jp
Abstract
A formal treatment of typed feature structures ( TFSs ) is developed to augment TFSs , so that negative descriptions of them can be treated  . Negative descriptions of TFSs can make linguistic descriptions compact and thus easy to understand  . Negative descriptions can be classified into three primitive negative descriptions :  ( 1 ) negations of type symbols , (2) negations of feature existences , and ( 3 ) negations of feature-address value agreements . The formalization proposed in this paper is based on A'it-Kaci's complex terms  . The first description is treated by extending type symbol attices to include complement type symbols  . The second and third are treated by aug-meriting term structures with structures representing these negations  . Algorithr rts for augmented-TFS unification have been developed using graph unification  , and programs using these algorithms have been written in Conma on Lisp  . 
1 Introduction
In unification-based or information : based linguistic frameworks  , the most important objects are structures called ' feature structures '  ( FSs )  , which are used to describe linguistic objects and phenomena  . A feature structure is either atomic or complex : an atomic FS is denoted by an atomic symbol  ; a complex FS consists of a set of feature-value pairs each of which describes an aspect of an object  . Partial information on a J~object is merged by applying the unification operation to FSs  . 
ILese are honunification-based linguistic theories has been accompanied by research on FSs themselves  . 
Several extensions on FSs or on feature descriptions and formal treatments of the extensions have been proposed  . 
Disjunctive and negative descriptions on FSs help make the linguistic descriptions simple  , compact , and thus easy to understand . For disjunctive feature de-acrq ) tions , Kay\[14\]introduces them into FUG ( lqlnc-tmnal Unification Grammar ) and gives the procedural semantics . Karttunen\[ll\]also proposes procedural treatments of disjunctions in conjunction with relatively simple negations  . ILounds and Ka . sper\[19 ,   13\] propose a logic-based formalism -- feature logic -which uses automata to model FSs and can treat dis-Junctive feature descriptions  , and they obtain important results . 
For negative descriptions of PSs , one of the most . 
fundamental properties of FSs , the partiality of information they carry , makes its insufficien to adopt relatively simple treatments  . Classical interpretation of negation , for example , does not , allow evaluation of negations to be freely interleaved with unification  . 
Moshier and Rounds\[17\] propose a formal framework which treats negative feature descriptions on the b ` a ~ is of intuitionistic logic  . I lowever , their bHnalism has trouble treating double negations  . Dawar\[5\]l ) rOl ) OSe Sa formal treatment b~ed on three-valued logic . 
In order to treat feature domains of complex FSs and to treat taxonomic hierarchies of symbolic timture values  , type ( or sort ) hierarchies have been introduced , allowing definition of typed ( or sorted ) feature-structures ( TFSs )  . A TFS consists of a type symbol from a lattice and a set of rearm : e-value pairs  . 
A TFS can be seen as a generalized concept of both atomic and cornplex FSs  . Pollard and Sag/18\] i att'o-duce sorts into IIPSG ( I lead-driv cnPhr ~ LseStrl lcttn'e Grammar ) and use sorted FSs to describe linguistic objects . 
A it-Kaci\[1\] proposes an Mgebraief ratne wot'k using the C -types and ~- types  , one of promising lbt'maliza-tions of TFSs , based on lattice theory . This lbrmal-ization was originally ainmd at formalizing and integrating various kinds of knowledge represent at  . ioiT frameworks mAI . In this approach , types are defined , as equivalence clms ses of complex term structures  . A subsumption relation is defined on these term struc-  . 
tures . The join and meet operations on then T correspond totile generalization and uniil cation Ol  ) era-tions on TFSs , respectively . This approach essentially a dopLs ' type-as-set ' seulantics  . Subtype relationships on type correspond to subsnmption relationships on denotations of types  . Based on this framework , an extension to Prolog , LOGIN\[2\] , has becn developed . 
S molka\[20\] proposes a feature logic with subsorts . 
In this approach , negative descript kms can be decom-poscd into three kinds of prinfitiv c negations  , namely , negations of sorts or complement sorts which denote tile complements of sets that positive counterlmrl  . slie-note , negations of feature existences , and negations of feature-address agreement or feature-address disagreement  . Slnolka extends t ~ a turc descriptions but a feature-structure interpretation of an extended e scription does not include negat  . iw ~ information and corresponds to a simple TI"S . 
Some TIeS based m ~ tural language processing systems have been  developed\[7  ,  24 ,  12 ,  15 ,  8 ,  22\] . Car-imnter and Pollard\[4\] propose an interlhce to buikl type lattices . 
Formalizations of extended FSs and of extet td ( ' d feature-descriptions , described above , arc classilicd into two classes : ( 1 ) extensions of FSs themselves , and ( 2 ) extensions not of FSs themselves hut of Dature -descriptions  . Previous attempts to introduce type hierarchies fall into the former clzLss while previous treatments of disjunctive and neg ~ diw ~&' scrip -tions mainly fall into the latter  . 
ACRESDECOIJNG , 92 , NAMES , 2328 AOt 33"1992380 Pl~oc . OFCOL1NG-92, NANTES , AUG .  2328 ,   1992 This paper proposes an extension to Ait-Kaci's ~/ , -type that incorporates three kinds of the primitive negative descriptions described below into the q :- type  . 
Ai't-Kaei'st-type formalization uses term structures  . 
In this paper , both these type structures and the tyl ) esym boll attice on which term strnctures are delined are e?tcuded to treat negative descril  ) tions . Negations of type symbols are treated by extending type symbol lattices  , aud negations of feature cxistmmes at td feature -address disagreements are treated by extending term structures  . This extension can be seen as intuition is tie . The extension is classified into class (1) a bow ' . .
Based on this paper's formalization , unilieation algorithms have been developed usiug graph unification  techniques\[23  ,  16\] . Programs based on these alger rithms have been implemented in Common Lisp  . 
2 Requirements of Negative
Descriptions of TFSs
In describing linguistic information using ( tyl ) ed ) feature structures , negative descriptions make the de- . 
scription compact , intuitive , and hence easy to understand . For example , we want to deserihe the gram-rnaI , ical agreement for an English verb , say " eat " , naturally a . s follows . 
.  .   .   .   .   .   .   .   . , I . r , , e, .   .   .   .   .   . :'" h\]sg ( 1 ) This description specifies compactly and directly that it is not the case that the person attribute is third and that the number attribute is singular  . If we could not use such complex negative descriptions  , we would write it using disjunctive descriptions with simple complement types as follows  . 
sy , ( ag , ' eeme , dag , l .   .   .   .   .   .   , , ~3rd \ ] \]'\[ syii(agreeme;' , lall , tinumbe ' rmsg\]IJ " (2) or sy , (  . g , ~, ae , , g~\[ve ~ . . .   . 1st\]\]1sy , ftag , ' eemen laglIp . . . . . . . 2nd \]\] (3) sy , ( a . qreeme , dag , f ,   , umberpl\]\]J In this case , (1) is e * L sier to understand than (2) or (3) . 
In the above ease . , we can describe the information because the complex negative descriptions C~tllbe transformed into the disjmlction of simple negative descriptions with mlal most same inteuded meaning  ) and because both person and number features take their values from lst  , 2nrl , 3rd and st , pl . 
However , it is not always the case that such transformations are possible and that feature takes its value from a finite set  . 
Let us consider more . complicated cases using dif-t 1 ference lists expressed using feat m'e structures . The empty list of categories ire presented as follows  . 
x  ~ H )
In the above example , the tag symbol ,   X1 shows that features in and out must take the same value  . 
t in HPSG and JPSG ( Japanese Ptlrase Structure Grammar )  , a difference list is very convenient \[' or expressing subcat and slash feature values  . 
llow can oniy no memptiness be expressed ? This is impossible using complement type symbols or dis junctions becmls c we can consider the set of MI finite length lists whose elements can bctaken frolt linlinit csets  . l ) iree to rindirect extension of features truetures is required  . 
So far , we have discussed the requirement of negative descriptions of type symbols and of l  ; eature-value agreeumnts from the viewpoint of capability of describing linguistic in R  ) rmation . There are other advantages of allowing negative descriptions  . Consider , for exannlde , debttgging processes of gram Jt , atical de-scriptlous by parsing sample sentences . We may obtaiu unexpected results Sllchll . ~ il ~ l'FS with ant ln expeeled type symbol , a TFS with an unexpected leat are value agreement and so on  . \[1/suchs it tlations , negatiw ~ descriptions can be use fld tools R ) r delecting their re~mons . 
Tot/l ; tkelinguistic descriptions compact and thuse a . uy to understand , to treat natural language fll-clently , and to detect error reasons rapidly , it is necessary to develo1 ) formalizations and nu ' . thods of treating negative descriptions . 
a Formal Treatment of Negative
Descriptions of TFSs
As stated earlier , a typed t ~: at , ure structure ( TI " S ) cousists Of ~ ttYl ) es yulbol all daset of feal , tlre-vs . ble pairs . Thus , descriptions of TFSs are chLssitied into descriptions of TFSs having :  ( 1 ) a certain type symbol ( or having a subtype syn , -hol of a certain type symbol ) , (2) a feature , and (3) two feature-address vahtes that agree . 
A TFS can be described by using conjunct , ions and disjunctions of such kinds of descriptions  . A eon jmle-tiw * and disjunctive TFS can be formalized as Nit-Kaei's t-type and ~- type  , respectively . That is , at-type , which has a complex term structure called ag , term a . sits syntax , represents a conjunction of such kinds of descript kms or at  col0unctiw ~typedfea Lltrl ! structure , and an etype is a maximal set of ? types representing the disjunction of them  . 
Negative counterparts of these descriptions are ebLs sified into deseriptions of TFSs :  ( 1' ) not having a certainty l ) csymbol ( or having a type symbol which is not subsunm d by a certain type symhol  )  , (2') not having a certain feature , and ( 3' ) having two that ure-addrcss values that do not agree  . 
Byine or poratiugs trllettlres represell l  , i l l g s t l c h l l l ! g-ative descriptions into a O term  , a'FFS with the netative descriptions can be formalized  . Such a lermis called an allglnented t-term and a type with an allg-mented ~/  , term ~ mits syntax is called an all gllu ! nted O - type  . From augmented g : - t . erms , an augmented te rule illl be COllStl'lletedill the S~LllleIllallll#!l"tlHltfill  ( -terluise on strlleted frolu?-t , errns . 
Next , augmented C-terms and C-types are defined.
Terln structures are first all glue uted with strtl ctll resrepresenting inhibited features and disagreement of feature address values  . Then , type symbol htt tiees are extended to inch , decomplement type symbols as suggested in \[1\] . 
AcrEsDECOLING-92, NAN'rgs . 2328 AO?~r19923811) l~oc . OFCOLING-92, NANTES , AUG .  2328, 1992 3 . 1 Typed Feature Structures as
Augmented C-Types
In order to define complex term structures , a signature is used to specify their vocabulary . It serves as the interface between their syntax and semantics  . A signature is formally defined as follows . 
Definition 1 A signature is a quadruple (7- , <_T , 2- , V ) consisting of : 1 . a set 7- of type symbols containing T and_L , 2 . a partial order _<7- on 7" such that ( a ) ? is the least and T is the greatest element , and ( b ) every pair of type symbols a , bE7-have a least upper bound or join , which is denoted by a VT " b and a greatest lower boundor meet  , which is denoted by a AT b ,  3 . a set . T " of feature symbols , and 4 . a set I \] of tag symbols where 7- , 2- and l ? are pairwise disjoint . 
A simple ' type-as-set'semantics is adopted for these objects  . That is , a type symbol in 7- denotes a set of objects in an interpretation . Here , 7- and . 1_denote the sets called the universe , written as U , and the empty set 0 , respectively . Another element a denotes a nonempty subset of U , written as \[ a\] . 
The partial order < ~- denotes the subsumption relation between these sets  ; for any type symbols a , b , and c ,  1 . a < ~ b if and only if Isclb\],2 . a Y : rb = cif and only if \[ a\]O\[b \] =\ [ el  , and 3 . aAT-b = cif and only if \[ a\]N\[b\]=\[ c \]  . 
A feature symbol denotes a function from a subset of U to U  . A feature path is a finite string of feature symbols and denotes the function obtained by tile composition of the functions that tile feature symbols denote  . 
A term is defined from a signature . First , a term domain is defined as a skeleton built from feature symbols  . 
Definition 2 A term domain A on 2- is a set of finite strings of feature symbols in 2"   ( in clnding the empty string ~ ) such that 1 . A is prefix-elosed : Yp , q(52-*, if p . q(sA , then p(5A ; and 2 . A is finitely branching : if p(5A , then f(52"1p . f(5A is finite where ' . ' is the string concatenation operator . 
An element of a term domain is called a feature address or a feature path  . By definition , the empty stringe must belong to all term domains and is called the root address  . A term domain is represented by a rooted directed graph within which each arc has a feature symbol as its label  . 
A suhdomain of a term domain , corresponding to a subgraph , is defined ms follows . 
Definition 3 Given a term domain A and a feature address p t5 A , the subdomain of A at p is defined to be the term domain Alp := p'IP'P *  ( 5A . The set of all subdomains of A is denoted by Subdom  ( A )   . 
Next , flesh is put on the term structure'skele-tonas defined as a term domain by assigning several kinds of objects to each feature address  . Ait-Kaci's term structure , the basis of the C-type , is defined by assigning a type symbol and a tag symbol to each feature address as follows  . 
Definition 4A term is a triple ( A , r , v ) where A is a term domain on . T , r is a type symbol function f i ' om 2-* to T such that r ( f*-A ) = T , and v is a tag symbol 5 ruction front A to Y . 
Given a tag symbol fimction v , Addr . denotes the function from a tag symboJ to tile set of addresses : 
Addro(X ): -- pGAIv(p ) = X . (5)
In order to treat negations of feature xistences attd feature-address value disagreement  , the term structure defined above is augmented by assigning additional objects  , a set of inhibited features and a set of disagreement tag symbols  , to each feature addrcs s . 
Definition 5 An augmented term is a quintuple ( A , r , o , ?  , X ) where A is a term domain on 5 v , r is a type symbol timer ( on from ~'* to T such that r ( 2-*-A ) = T , v is a tag symbol function front A to V , ? is an inhibited feature filnction front 5 r * to 2 ~ such that ? ( p ) is finite for any p ( 5 A and ~ ( ~'*- A )  = 0 , and X is a disagreement tag symbol function from J '* to  2 v such that X ( P ) is finite for any p ( 5A and X ( f '*- A )  _- 0 ,   2 The inhibited feature fimction ? specifies which features cannot exist at a given address  . There is thus inconsistency if there is an address p in A such that ?  ( p ) nfe2-lp . f(sA#O .   ( 6 ) The disagreement tag symbol fimction X specifies , for a given address , substructures with which its argument disagrees . There is thus inconsistency if there is an address p in A such that  , ( p ) ex(1 , ) . (7) The disagreement address function Disagr .   , xfrmnAto2~:' , based on v and X , takes an address as its argument , and gives the set of addresses with Milch the argument address must disagree  , called the disagreement addresset and defined as: 
D is a grv,x(P ) := UAddr.(X ), (8)

Augmented terms are hereafter referred to simply as terms unless stated otherwise  . 
Definition 6 Given a term ~: ( A , r , v , ?  , X ) and a feature address p in A , the subterm of/at the address p is the term tip =  ( A/p , r/p , v/p , ~b/p , x/p ) where rip:Jr*~T , v / p : Alp ~ V , ?/ p:2-"~2F , and
X/P : . T"~2v are defined by ( r/p ) ( q ) := 7-(p-q) , (9a ) ( v / p ) ( q ) := v(p . q ), (91) (?/ p ) ( q ) := ?( p . q ), (9 r ) ( X/P ) ( q ) := X(P'q) . (9(1) For a term t = ( A , r , v ,  ? , X ) , a type symbol a ( similarly , a tag symbol or a term t ' ) is said to occn r in t if there is a feature address p in  , X such that r(p ) = a ( similarly , v(p ) = X or X(5X ( P ) , or lip = t') . 
Atermt = ( Ar , v ,  ? , X ) is said to be regular if the set of all subterms of t  , Subterm(t ) := t/p\]p(5A , is finite , tlereafter , we will consider mdy regular terms . Illa regular term , only finite numbers of type symbols and tag symbols occur  . 
2 For any set S , 2s denotes the set of subsets of S . 
ACRESDE COLING-92 , NANTES , 2328 AOt3T1992382PRO (= . OFCOLING-92, NANTES , AUG . 2328, 1992 ~ e , apty
Xl ::: dlist:\['"o ,,, x2:j .., ~:: r\]x2
X a:::d list\[ X4  : :  X6: list\]=in\[first X5: : : T\]out X6  :  :   X4 : list Figure 1: Examples of Augmented Terms ill Matrix
Notation lem~tyt nonempty
Xl ::: dlistX3::):dlist, . ( ~ o . t . Clio , ,, x4:: x6 .  ( _  .   .   .   .  _% . 
X2:fi,'st:listIx6::x4ll . tli " ~ tIii . ,, xs::

Figure 2: Examples of Augmented'l ~ rmsill Directed
Graph Notation
In a term , any two feature addresses bearing tile same symbol are said to corefer  . Thus , tile corefer-enee relation g of a terln is a relation defined on A  , as the kernel of the tag flnlctiouv ; i . e,~:=Ker(v ) = v-Iov . IIer e , g is an equivalence relation and a ~- class is called a corefereuee class  . 
Definition 7 Aterlnt is referentially consistent if the same subtern * occurs at all feature addresses in a coreference class  . 
If a term is referentially consistent , then by definition , for any Php : ZEA , if v(pl ) = v(p2) then , for all p such that Pt ' PCA , it follows that P2'P ( 5 A and v ( pl " p ) = v ( p  ~ . p ) . Therefore , if a term is referentially consistent , g is a right-invariant eqnivalence or right -eongrue uee on A  . That is , for any Pl , P2EA , if P t *? P 2 then ( Pl'P ) ~: ( P2'P ) for any p such that
Pl . pEA.
Definition 8A wellformed term ( wf t ) is a referentially-consistent regnlar term . The set of all wellformed terms is denoted by 14 , ' . TtrT . 
A term can be represented in matrix notation . Examples of terms are show u in Figll re1 . In this figure , T , d list and list are type symbols , in , out and . first are feature symbols , and X1, X2, .   .   . are tag symbols . A matrix represents a set of feature-value pairs preceded by a tag symbol  , followed by a set of iuhib-ited features and followed by a set of disagreement tag symbols  . In the term te , ,vlv , its snbterms at in and at out corefer while t , ~o , , , , , vty is a termill which its subterms at in aud at out should not corefer  . The term te . m?1 y should not have the feature address in . . first
Williet nonempty II&S that address,
A term can also be represented by directed graphs ( DGs )  . t ~ , , ~, t ~ ant it . . . . . . . . ply in Figure 1 are shown as
DGs in Figure 2.
The set WY5 r of wellformed terms includes many terms that l lave tile same type syml  ) ol function , tile same coreferene erlations , the same inhibited feature function , and the same disagreelnent address fllll C-lion but different tag symbol fiUl C tions  . These terms have the same infornlation and can describe the same liugttistic object or tile same linguistic phenomena  . 
These ternls construct equivalence classes by reualll-lugtag symbols in a certain manner  . 
Delinltion 9T woterlnst l = ( Al , rl , Vl , ?q , ?(1 and t~=(A2 , r2 , V  ~ ,  ~2 , X - ~ ) are altlhabetical variants of each other if and only if  1  . Al = A2,2 . Ker(vl ) = Ker(v2), 3 . rl = r2,4 . ?1 = ?2, and 5 . Disagr ~, , x ` = Disagr ~, x, . 
This is written as 11~t ~.
According to ' type-as-set'semantics , tile symbols Taud ? denote , respectively , tilele&s t informative type tile whole universe U aud the over defined or incousistel  , cy type . -- the empty set 0 . Therefore , a term containing ? should be interpreted as inconsistent  . Such an inconsistency is called a type inconsistency  . ' Ibtreat such inconsistency , a relation 1~1 on
W.~'T isllefiued as follows.
Definition 10 For all y two terms t l , t = , G\]4 , ' . T'T , tlglt2 if and mdy if . ? occurs in both tl and i2 . 
There are other kinds of inconsistency as mentioned earlier  . If a term contains an address p such that ? ) P ) fqf ~ : J :' lp'f ( ~ Ai ? 0 , it is inconsistent because it means that there are features that should uotexist at  . the address . Such an inconsistency is called a feature inconsistency  . 
Ill addition , if a terln contains an address p such that v ( p ) EX ( P )  , it is inconsistent because it means that tile subterm at p does not agree with itself  . Such an inconsistency is called a tag ill consisteucy  . 
llence , the three kinds of inconsistency are treated integratedly by a relation  . ~ on ) 4, ' S'T delincd as follows . 
Definition 11 For any two terms it , Z2CW . T ' T , tlU 12 if and ouly if each of them contaius at legist one address p such that t  . r(p ) : ?, 2 . ?( p ) nfeJlp . feA?O , or 3 . .(p ) e x(v) . 
Clearly , if J ~ occurs in a terl n , it also occurs in a llternls in its ? ~- class . This is also trne for feature in consistency and tag in consistency  , lh . ' nce , the relations ( ~ and - U are such that their union ~ becomes an equivalence relation  . Thus , we call detincd the augnlented t-types as follows  . 
Definition 12 An augmented &- tyl ) e ( or ~ b-tyl ) e for short ) It \] is an element of tile quotient set , q ~:= Syutactic structures of augment edg , -tyl)es will I)e (: ailed augmented ~ p-ternls . An augmented typed-feature-structure Callt ) e formalized as an anglllented t-type . 
The set of type symbols 7- has the partial order ~7-which denotes a subsumption relation between the set denoted by type symbols  . The partial ordering on 7 can lie extended to augnmuted g~-terms and t- types  . Tilesul ) smnp tion orders on )& . T"T and on are ilefined t~s follows . 
Acrgs DECOLING-92 , NANTES , 2328 AO~'1992383 PROC . OFCOLING-92, NAm'ES , AUG .  2328 , 1992 Definition 13 Lettl = ( AI , rt , vl , ~ bl , X t ) and t2 = ( A2 , r~ , v2 , C~ , X2) be WFTs . il is said to be subsumed by t2 , written tt_<i2 , if and only if either tt ~ J_or 1 . A ~__ At , 2 . Ker(v ~) C_Ker(vl ), 3 . vpeY ', n(p)_<rr~(v ), 4 . VpE2-*,#:(p)_c~t(p ), ~ nd5 . Y p(55 r* , Disagr ~ , x , ( p)C_D is a gro ~ , x~(p ) . 
The subsumption order on ? are defined by \[/1\]  _< \[  t2\] if tl_ < t2 is well-defined . 
Lattice operations on ? can be defined to be compatible with the above subsumption order relation as follows  . 
Theorem 1 If (7";_<7") is a lattice , then so is ~ . 
Proof . This theorem can he proved in a very similar manner to the counterpart for A'/t-Kaci's  0-terms  . 
Therefore , instead of providing the proof in detail , only the definitions of the least upper bounds - -or joins -- and greatest lower bounds ~ rmeets -- are provided below  . Let tt : ( ml , 7" l , Pl , g \]) l , XI ) and t ~ = ( A  ~ , r~ , v2 , ck2 , X2) be WFTs . 
First , the join of t ~ and t2 , ta = tlVt2 = ( Aa , ra , V a , ~ ba , X a ) , is defined as follows:
Aa = Alna = (10a ) va : Aa - - - * ~1 such that
Ker(va ) = ~ xNtis , ( lOb ) and VpE . T*rs(p ) = rx(p)VzT~(p) , (10c)~ba(p ) =--( pl(p)N~b2(p) , and ( lOd)XS(P ) = us(q ) IqE(D is a gro ,   , xt(p )
ND is a gro ~, x ~( p )). (10e)
Next , the meet of t , and t2 , t4 = t , At ~= ( A4 , r4 , v4 , ~ b 4 , X4) , is defined as follows:
A4 = At*\],(lla ) v4:A~~I ; such that
Ker(v4) = r\[*l , (llb ) and VpG9r " r4(p ): VT 7" i(q)\]P ~ pq , i:1 , 2  , ( lie ) U ~ i(q ) lp np q , i = 1 , 2 , (lid)~(v ) = and x4p ) = where
A \['\] =
Al , , l = g\[.l =
Uv4(q ) lqaqr,rC(D is a grv ~, ?~( p ) o D is a gro ~ . ? ~( P )) ~1 le ) co
UAt " l , n = 0A1UA ~ for n = O , A\['-qUpE9 rIp tct'lq , qEAi "- q for n > I , x\["\] , n = 0 tempty Vt nonempty
X/:::dlist=\[inXS:: ( : llst\]out X9 list ~ et np\[yA ~ Tlollell lpl ~
X 10:::d list
IXll:first:Xll:list=it , \[ first X12: : : T\]outXll Figure 3: Examples of Join and Meet . of Augmented tb-Terms o/?2)' for n = 0 , i ?\[' d = ~\[ , -l\]O ( p ~ ? p , p  ~ . v)Ipl~t"-'lv2) , for n > 1 at tdr ~ , uA  ~ is the rellexive extension of ~ i from Ai to  A1UA2 for i = 1  ,  2 . 
The conditions ( lla-lle ) define a meet , that collapses to J-whenever conditions ( lie--lie ) l ) roducc some address p such that type inconsistency  , feature in consistency , or tag in consistency occurs at p . 
The V is a join operation and A is a meet operat i on which are compatible with the subsumptiou order defined in Definition  13  . \[\] Examples of join and meet operations on augmented e-terms are shown in Figure  3  . The join and meet operations on augmented ~- types correspond to the generalization and unif ication operations on 

A'it-Kaei defines an ~- type as a maximal set of ~ b-types  . It is also possible to defir , e an augmented ~- type as a maximal set of augmented ~ b-types in the same manner  , making disjunctive and negative descriptions possible  . 
3.2 Type Symbol Lattice Extension to
Include Complement Type Symbols q_?eating a negative desGil  ) tion of a given type syln-bol , say a , requires a type symbol I ) such that b has only information that unif ication of it with a yiekls inconsistency  , or such that a VTh =- V and a ATb = ? . 
Such a symbol is called a complementype symbol of a and written as a ~  . If a given type symbol lattice (7- ; _<7") is a Boolean lattice , that is , a comI ) lcmented 3 distributive lattice , we do not need to do anything . 
Otherwise , we nmst extend the lattice to include the cmn plements of the type symbols contained in the given lattice  . 
For a finite type symbol lattice T , for example , a Boolean lattice T ~ can he constructed a . s follows . 
Let . .4 :=  at .   .   .   .   . a N be the set of a tolns of 7- , that is , type symbols which cover j_ . 4 If there are , to n-atomic type symbols which cover only one symbol  , for each such symbol a , a new atom is added a A lattice is called complemented if its all elements have complements  . t 3\] ~a is said to cover b if b <7 a a t t d b <7 c <7- a implies e = b . 
Ac'IXS DECOLING-92 , NANTES , 2328 ^ otrr 1992384 Paoc . OFCOLING-92, NANTES . AUG .  2328 .   1992 t symbol : node structure a type symbol arcs : ~ a set of arc structures  ) __ ~ a set of feature symbols ) es : ~ a set of r to destructures ) anoaes : fo ~ a ~: ~ a . o do s . nc*n ro/IN ZL arc structure\[#atn , ~! I(afeat .   .   .   . ymbol\[vM . . . . I  a node structure
Figure 4: Data Structures
Fnnetion Unify ( node l , node ~) begin node 1: = De reference ( node l ) ; node ~:= Det , e\]erence(node2) ; if node 1 = node 2 then return ( node 1) ; qodel . forward := node ~; node 2 . tsymbol := node l . t symbol AT node 2 . tsymbol ; if node 2 . tsymbol = J_then return ( J_) node 2 . i features := node l . i \] eatures LI node ~ . J \] eatures ; if node 2 . i features r ' l arc . feature I arc ? node l . arcs LJ node 2 . arcs #0 then return ( . L ); aode e . d nodes := node 1 . dnodes O node 2 . dmMes ; if node 1, node 27 node 2 . d nodes #~ theai return ( . L ); arc pairs := Shared-Arc-Pairs ( node 1 , node ~); for ( arc1 , arc2) in arc pairs do begin value := Unify ( arcl . value , arce . value ); if vMu e = . 1 . then return ( l ) ; end ; arcs::Complement ~ Arcs(node1 , node'2); rlod cS2 . aFcs := arcs LJllode ~ . arcs ; return ( node *) ; end Figure 5: A Destrnctive Graph Unification Function so that a covers all additional type symbol  . The extended lattice " T ~ is tile set of subsets of A with set inclusion ordering  . An elementaliet E " T ' denotes Uie /\[ al\] . The join and mcct operations on T ' are the set -nniou and set-intersection perations  , respectively . The complement of an elementaiie/inT ' is the set-complement of it with respect o  . 4, that is , ~? . 4 la?ad , e ~ . 
4 Implementation of Augmented TFS

The unification operation for augmented 1/ , -terms or augmented TFSs has been implemented using graph unification techniques  . A term structure is represented as a directed graph by assigning a graph node to each x-class as in Figure  2  . The unification operation for such DGs corresponds to a graph merging operation  . This takes two DGs and merges ~- cla . sses of the same feature-aAdress into an-class . 
In a destructive graph unification method , which is very simple , suci ~ a graph is represented by tile data structures in Figure  4  . A node structure consists of live fields : l symbol for a type symbol  , arcs for a set of feature-vafile pairs , if eatures for a set of inhibited features , d nodes for a set of disagreement odes i . e . , disagreement K-classes , and forward . The field for'warY1 is used for the Union-Find algoritfim\[9\] to calculate unions of K-classes in tiles alne n lanner  , ' L qlluet's algorithm\[10 . By traversing two DGs ' nodes with the same feature-addresss in mltaneously  , calculating the union of their x-classes , and copying arcs , their unification can be calculated as in Figure 5  . 
The function Unify takes two input nodes and puts the minaK-class by letting one input betim forward field values  . The flmction then examines three kinds of inconsistency  ; namely , type in consist cncy , feature in consistency , and tag in consistency . Timfim c-tionfinally treats arcs in order to make tile result graph right-cougruent  . For treating arcs , tile function Unify assumes two fimctions , Shared_Arc_Pairs and Complement_Arcs . The function Shared_Arc_Pairs takes two nodes as its in pnts aud gives a set of arc pairs each consisting of both inputs ' arcs with a shared feature  . The flmctiou Complement_Arcs also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second  . 
An inhibited feature fimetion is implemented using tile t featn resfield of nodes  . When unification of two nodes results in a node witfian arc witfia feature in i features  , it yields J-because of feature in consistency . 
A disagreement tag symbol fnnetion is implemented using d nodes  . Unification of two nodes which have each other in their d nodes yields  3  . because of tag in consistency , q_'hese computations require negligible additional computation  . 
qb simplify the exphmation , the destructive version of graph unification is used above  . Other versions based ou more efficient graph unill cation methods such  ; ~s Wroblewski's and Kogure's method\[23 , 16\] have also been developed .  1 , ' urthermore , it is easy to modify other graph unification methods\[21  , 6\] to allow augmented TFSs . 
, 5 Conclusion \]' his paper has proposed an augmentatiotl of feature structures FSs  ) which introduces negative information into FSs illunification-based tbrmalisms  . 
Unification-based linguistic formalisn mnsel " . qs to describe linguistic objects and phenotneu a , l ~ e can selinguistic information ( : an ) e described compactly using disjunctive and uegatiw : descriptions  , FSs and feaoture descriptions are required to treat such  ( lescrip-trans , in this paper , FSs have been augnlent . ed , using a promising method of for nudizat . iou , Ait-l(a ci's$~type , to allow three kinds of negatiw ~ descriptions of them to be treated  . 
In a formalizalion of typed feature structures , negative descriptions can be decomposed rata three kinds of negations : negations of type sytnbols  , negations of feature existences , audllegations of feature-address value agreements  . It . is shown thai the second and third kinds Call be treated by ailglnc II tlllgtlrl ' nlst lill % Lures to include structures representing such kinds of descriptions  . Subsnmption relations on augmented terms are defined  . It . is also shown that the first kind call be treated by exteuditlg type symbol lattices t  ( ) include complement type synd ) ols . 
The proposed formalization cau provid efficiental -AcrEsDE  COLING-92  , NANTES , 2328 AOl3"r199238$PROC . OFCOLING-92, Nhr,n'Es . AUG .  2328 .   1992 gor ithms for generalization adunification operations as well as treat primitive negations  . The formalization can be integrated with logic -based frameworks such as  \[20\] which can treat wider ranges of descriptions but which do not have such efficient algorithms for these operations  . Logic-based frameworks can be used to obtain the data structures for this paper's formalization  . 
Unification algorithms for augmented terms or augmented TFSs have been developed using graph unification techniques  . Unification programs based on these algorithms have been developed in Common 

The augmentation of TFSs makes linguistic descriptions compact and easy to understand  . In an HPSG-based grammar , for example , non-emptiness of a subcator slash feature value can be easily described by nsing feature-address value disagreement  . 
Moreover , negative descriptions make debugging pro-eesss s of grammatical descriptions easier  . 

This research was performed in the VCAT project of the Takeuchi Research Group in NTT Basic Research Laboratories  . The author would like to thank Ikuo Takeuehi , Akira Shimazu , Shozo Naito , Masahito Kawamori , Mikio Nakano , and other colleagues of the group for their encouragement adthought-provoking discussions  . 
References\[1\] Hassan Ait-Kaei . An algebraic semantics approach to the effective resolution of type equations  . Journal of Theoretical Computer Science ,  45:293-351 ,  1986 . 
\[2\] Hassan Ait-Kaci and Roger Nasr . Latin : a logic programming language with built in inheritance  . Journal of Logic Programming , 3:185-215, 1986 . 
\[3\] Garrett Birkhoff , Lattice Theory . Americau Mathematical Society , Providence , Rhode Island , USA , 3rd edition ,  1967 . 
\[4\] Bob Carpenter and Carl Pollard . htclusion , disjoint-hess and choice : the logic of linguistic classification  . 
In Proceeding so \] the 29th Annual Meeting of the Association for Computational Linguistics  , pages 916 , ACL , University of California , Berkeley , California , 
USA , 1991.
\[5\] Annuj Dawar and K . Vijay-Shanker . A three-valued interpretation of negation in feature structure descriptions  . In Proceedings of the 271h Annual Meeting of Association for Computational Linguistics  , pages 1824 , ACL , Vancouver , British Columbia , 
Canada , 1989.
\[6\] Martin Emele . Unification with lazy non-rednndant copying . In Proceeding so \] the ~9th Annual Meeting of the Association \] or Computational Linguistics  , pages 325-330 , ACL , University of California , Berkeley , California , USA ,  1991 . 
\[7\] Martin Emele and Rdmi Zajac . RETIF : A Rewriting System \] or Typed Feature Structures  . Technical Report TR-I-0071 , ATR , Kyoto , Japan ,  1989 . 
\[8\] Martin Emele and Rdmi Zajac . Typed unification grammars . In Proceedings of the 13th International Conference on Computational Linguistics  , Vol . 3, pages 293-298, 1990 . 
\[9\] J . E . ltop croft and R . M . Karp . An Algorithm for Testing the Equivalence of Finite Automata  . Technical Report TR-71-114, Dept . of Computer Science , Cornell University , lthaca , New York , USA ,  1971 . 
\[10\]G ~ rardHuet . Rdsolution d ' Equations dans des Langages d ' Order 1  ,  2 ,   . . . , w . PhD thesis , Universit 6 de
Paris VH , France , 1976.
\[11\] Lauri Katttunen . Features and values . In Proceedings of the lOIh International Conference on Computational Linguistics  , pages 28-33 , Stanford , California , 
USA , 1984.
\[12\] Robert T . Kasper . Unification and classification : an experiment in information-hazed parsing  . In Proceedings of the International Workshop on Parsing Technologies  , pages 17 , Pittsbnrgh , Pennsylvania , USA ,  1989 . 
\[13\] Robert T . Kasper and William C . Rounds . A logical semantics for feature structure . In Proceedings of the 241h Annual Meetingo \] the Association for Computational Linguistics  , ACL , New York , New York , 
USA , 1986.
\[14\] Martin Kay . Parsiug in functional unitication grammar . In D . R . Dowty , editor , Natural Language Pars-in 9 , chapter 7 , pages 251-278 , Cambridge University
Press , 1985.
\[15\] Kiyoshi Kogure . Parsing Japanese spoken sentences based on HPSG . In Proceedings of the International Workshop on Parsing Technologies  , pages 132-141 , 
Pittsburgh , Pennsylvania , USA , 1989.
\[16\] Kiyoshi Kogure . Strategic lazy incremental copy graph unification  . In Proceedings of the 131h International Conference on Computational Linguistics  , 
Vol . 2, pages 223-228, 1990.
\[17\] M . Drew Moshier and William C . Rounds . A logic for partially specified at a structures . In Proceedings of the ldth ACM Symposium on Principles of Programming Language  , pages 156167 , Munich , West
Germany , 1987.
\[18\] Carl Pollard and Ivan Sag . An Information . Based Syntax and Semantics -- Volume 1:bhndamentals . 
CSLI Lecture Notes Number 13, CSLI , 1987.
\[19\]William C . Rounds and Robert T . Kasper . A complete logical culus for record structures representing linguistic information  . In Proceedings of Symposium on Logic in Computer Science  , IEEE Computer
Society , 1986.
\[20\] GertSmolka . A Feature Logic with Subsorts . Technical Report LILAC Report 33 , IBM Deutschland , 7000 Stuttgart 80 , West Germany ,  1988 . 
\[21\] Hide to Tomabechi . Quasi-destructive graph unification . In Proceedings of the 291h Annnal Meeting of the Association for Computational Linguistics  , pages 315-322 , ACL , University of California , Berkeley , California , USA ,  1991 . 
\[22\] Yoshihiro Ueda and Kiyoshi Kogure . Generation for dialogue translation using typed feature struc-tnre unification  . In Proceedings of the 13th h~ter . 
national Conference on Computational Linguistics,
Vol . 1, pages 64-66, 1990.
\[23\] David A . Wroblewski . Nondestructive graph unification . In Proceedings of the 6th National Conference on Artificial Intelligence , pages 582-587 , AAAI , 
Seattle , Washington , USA , 1987.
\[24\] R6miZajac . A transfer model using a typed feature structure rewriting system with inheritance  . In Proceedings of the PTth Annual Meeting of Association for Computational Linguistics  , pages 16 , ACL , Vancouver , British Columbia , Canada ,  1989 . 
Ac-rEs DECOLING-92 , NANTEs , 2328^o ~' r 1992386 Paoc . oF COLING-92, NANTES , AUG , 2328, 1992
