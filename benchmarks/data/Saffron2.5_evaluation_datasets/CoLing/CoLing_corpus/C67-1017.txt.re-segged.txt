The Application of FORTRAN to Automatic Translation 
Paul O . Samuels dor ff
I . Introduction
A multitude of problem-oriented programming languages are being 
created in order to facilitate programming in various fields  . Th~se languages have two advantages for non -programmers who need a computer for solving their problems : I  . they are not forced to spend much time on learning a complicated machine language  ;  2 . they do not necessarily have to alter their programs when they are obliged to use a different machine  . These advantages seem to justify the labour of writing a multitude of compilers that translate each problem-oriented language into the machine language of each machine  . 
The existence of various problem-oriented languages  , however , makes it difficult for the users of computers in various fields to exchange their experience  . In addition there is the danger that a certain machine possesses only a limited number of compilers  , and that therefore a program may have to be rewritten when for some reason or other a different machine has to be used  . The question therefore arises whether it is not possible to have the advantages of problem -orlented languages without multiplying their number  . 
This paper wants to show that one of the most widespread problem-oriented languages  , originally created for mathematicians , may efficiently be used for non-numerical data -processing  , if the necessary subroutines are available . 
Another object of this paper is to give a concrete picture of how linguistic problems may be handled by the computer to those readers who have only a theoretical knowledge of data-processing  . For the benefit of these readers a few definitions will be given  , so that the examples will be understood by everybody  . 
bit = the smalles unit of information that may be stored in the computer  , having one of two values symbolized by " I " or " O "  . 
character = a letter of the alphabet , a decimal digit , or one of 11 special signs including the blank . A character is represented in the computer used for our examples  ( IBM 709@ ) by a combination of 6 bits . 
machlne-word = a string of six characters ( represented in the computer by a combination of 36 bits )  . 
location = the place in the computer where a machine-word is stored  . 
array = a combination of locations treated as a unit  . 
subroutine = a program that may be called up by another program for performing a specific job  . 
function = a subroutine that in addition to handling a certain job leaves a definite result in a certain location  . 
IF-statement ~ an instruction of the program that enables a branch-ing to one of three different statements in the program  , depending on whether the value in the parentheses of this statement is negative  , zero or posit-ive . Its format is " IF ( x)1 , m , n " , where 1 , m and n are the numbers of the statements to which the program may branch  . 
The application of a mathematically oriented programming language to linguistic problems will be exemplified by a Hebrew-English translation project written in FORTRAN with the aid of subroutines programmed at the Deutsches Rechenzentrum in Darmstadt  . These subroutines handled at a smaller than the machine-word  ( single bits ,  . 
single characters and their concatenation ) , the non-numerical machine-word and data larger than the machine-word  . 
We shall now explain the subroutines used in our project and give examples of their application  . In order to avoid a repeated ex-planation of the variables used in the formats of the subroutines  , we introduce the following conventions . 
M = a positive integer not greater than 36 , referring to one of the 36 bits of a machine-word . 
WORD = the location of a machine-word to be handled by the subroutine  . If two machine-words are to be handled , we dis-tlnguish between WORD1 and WORD2 . 
BLOCK ~ the location of the first machine-word of an array containing the characters or the string to be handled by the subroutine  . If two arrays are involved , we distinguish between
BLOCKI and BLOCK 2.
NA = a positive integer indicating the position of the first character of a string in the array BLOCK to be handled by t ~ subroutine  . If two strings are to be handled , we dis-tinguish between NA1 and NA2 . 
N = an integer , usually positive , indicating the number of characters to be treated by the subroutine  . ~ will be negative if we count the characters from NA to the left  . 
TABLE = an array containing characters to be used by a subroutine  . 
This table is prepared before the subroutine is called  . 
The subroutines will be described in the order of the units they handle  , starting from the smallest units . 
2. Bits 2.1. PAKR
This routine facilitates the codinE of ~ rammatical information  . 
Each bit of a 36-bit machine-word represents a certain kindo ~ grammatical information  . Its value is " I " when this information applies to the Hebrew word it is coordinated to and  "0" when this information does not apply . The 36 bits of one machine-word , stored in the array CODE , represent the following information . 

I = definite noun 2 = indefinite noun 3 = construct state = pronoun 5 = prepositional phrase 6 = preposition 7 = adverb 8 = numeral 9 -- in definite adjective 10 = definite adjective 11 = in definite participle 12 = definite participle 13=ZH 
I ~= AT15 = AUTU , AUTH , AUTM , AUTN 16 = KI , AM , KAWR 17 = GM , RQ 18= LA 19= IW 20 = verb 21 = infinitive 22 = comma 23 = KL 2@ = present 25 = past 26 = future 27 = copula 28 = WL 29 = W 30=U   31 = masculine singular 32 = feminine singular 33 = masculine plural = feminine plural 35 = no indefinite article 36 = no definite article ( The words in capital letters are Hebrew words that need special treatment  . ) It would be very complicated to work out the figure to be stored in a certain location for each possible combination of grammatical information  . Let us take as an example a masculine singular verb in the past tense  . The machine-word coordinated to this verb will have a " I " in bit-positions  20  ,  25 , and 31 , and a " O " in all other blt-positions : 000000000000000000010000100000100000  . This is the binary equivalent of the decimal number  69   664  . Instead of working out this figure , we code a " I " into the 2Oth ,   25th and 31st column of a punched card and leave the other columns blank  . The first 36 columns of the card are then read into an array of  36 locations . 
The 36 machlne-words of this array are subsequently packed with the aid of the subroutine PAKR into one location  ( containing 36 bits )  , the ones and blanks of the 36 columns on the card resulting in ones and zeros in the respective bits of one machine-word  . 
2.2. KBIT
This subroutine is a function and identifies single bits  . If we want to find out whether a word possesses a certain grammatical feature  , we have to ask whether the value of the respective bit of the machine-word that contains the desired grammatical information is " I " or  "0"  . 
Format : J = KBIT(WORD , M)
The result stored in the location J will be " I " or  "0"  , depending on the value of the respective bit . 
The subroutine EBIT enables the control to cause a branching to the specific part of the program needed for the treatment of a member of a certain word class  . A computed GOTO after the dic-tionary Iooku ~ handles this process very efficiently  , as seen in the following example . 
379 DO90L~125999 , 90  , IF8O80GOTO(100 , 200 , 300 , 400 , 500 , 600 , 1000 , 75 , 920 , 910 , 1200 . 2000 ,  13000 , $000 , 5000 , 1000 , 75 , 1000 , 1000 , 2200 , 1000 , 1000 , 700~ , L 90 CONTINUE The valne of the variable L must be computed before the GOTO statement is reached  . It must be a positive integer not greater than the number of statement-numbers in the parentheses of the GOTO statement  , since it determines which statement of the program is to be executed next  . L is computed in statement 79 . It assumes the values from 1 to 23 as long as the program reaches statement 90  . The IF-statement between statement 79 and statement 80 causes the program to branch to statement 90 as long as the Lth bit of the machine-word containing the grammatical information of the Nth word of the sentence equals zero  . As soon as the Lth bit equals one , the program will branch to statement 80 . (999 is a dum~statement number , since the result of KBIT will never be negative . ) Since we are examining the machine-word found in the dictionary together with the Hebrew word we were ~ ooking up  , statement 80 will cause a branching to that part of the program that handles members of the word class this Hebrew word belongs to  . 
An IF-statement using the subroutine KBIT may also enable the program to branch conditionally during the syntactic analysis or the translation process and thus make the solution of ambiguities possible  . Specific parts of the program for the solution of ambiguities are reached by statements examining the bits of machine-words located in the array SCODE  . For instance for ambiguous verbs the statement will  be:"2200 IF ( KBIT ( SCODE ( N ) ~ I ) ) 999 , 2210 , 25OO " . The part of the program solving the ambiguity of the verb starts at statement  2500  . The other "1"-bits of SCODE , coded with a verb or a noun , indicate how a preposition is to be translated . 
2.3. LBIT
This subroutine permits the conversion of " O " -bits into  "1"-bits and vice versa . Its format is similar to that o--~IT , namely
J = LBIT(WORD , N ) ~ he result stored at J will be "1" when "0" has been replaced by "1" and "0" when "1" has been replaced by "0"  . 
LBIT is used for storing or deleting grammatical information during the analysis process  . 
An example is the indication of definite nouns or prepositional phrases during the dictionary lookup  . Since in Hebrew the definite article and some of the prepositions consist of one letter that is attached to the following noun  , this letter has to be stripped before the word can be found in the dictionary  . We use the subroutine LBIT during the dictionary lookup for storing  "1" In the first bit-position of CODE ( N ) and deleting the "1" in the second bit-posltion if the Nth word of the sentence is a noun preceded by the definite article  , or "1" is stored in the fifth bit-position , if the Nth ~ ord of the sentence is a noun preceded by a preposition  . 
4 ~ . Single characters 3 . 1 . IF PP ( find first position ) This subroutine makes the identification of s , in ~ le characters , possible . 
Format : J = IFFP(BLOCK , NA , N , TABLE , IND)
This function finds the first position of a character in the array BLOCK which is equal to a character of TABLE if IND = I or unequal to a my of the characters of TABLE if IND = O  . The search starts from the NAth character of the array  . It goes to the right if N is positive and to the left if N is negative  . 
One of the characters we frequently want to identify is the blank  , in order to find word boundaries . This subroutine is used , for instance , when we want to insert an adjective between a preposition and the following noun  . We have to look for the blank after the preposition in order to insert the adjective in the right place  . 
An example for a negative N will be given in section  6  . 3 . 
3.2. SEPO ( seek positions )
This subroutine traces the positions of occurrence of a character  ( or a member of a set of characters ) stored in a table . 
Format : CALLSEPO(BLOCK , NA , N , TABLE , NSP , NFIND ) The subroutine SEPO examines N characters in the array BLOCK  , starting from the NAth character . The number of characters found to be equal to the characters stored in TABLE is stored in the loc -ation NFIND  . The actual positions of these NFIND characters are stored in the array NSP  . 
If the only character stored in the table is the blank  , dictionary lookup will be very convenient , since the occurrence of word boundaries may be stored for a whole text  . NSP ( I ) will contain the position of the blank after the Ith word of the text  . The next word to be processed will therefore easily be found  . Its first character will y , be in the first position after the one indicated by the contents of NSP  ( I ) and its length will be NSP ( I+I ) -NSP ( 1 ) -I . 
3.3. ICPC ( compare character)
This subroutine compares a character with a set of characters stor-ed in a table  . 
Format : J = ICPC(BLOCK , NA , TABLE , NTAB)
NTAB is a positive integer stating with how many characters of TABLE we want to compare the NAth character of the array  . 
The result of this function , stored in J , is zero if the NAth character is unequal to any of the characters of the table  , otherwise it is a positive integer not greater than NTAB  , indicating that the NAth character of the array BLOCK is equal to the Jth character of TABLE  . 

In the following example we see how this subroutine is used for choosing between the English in definite articles " a "  ( WORD ( I ) ) and " an " ( WORD ( 5 ) ) . 
1476K = ICPC(EWD(1 , N) , I , VOC , 5) 1477 IF ( K-l ) 1905 . 19 10,191 51 905 ENG(1, I ) = WORD(1)
I = I+1
GOTO 1480 1910K = ICPC(EWD(1,N ), 5. VOC , 5)
IF ( K ) 1905, 1915, 1905
ENG(1, I ) ~ WORD(5)
I = I+I
GOTO 1480
EWD is the array where the English words were brought after the dIB ~ ionary lookup and ENG where they are brought d~ring the analysis  . The first five locations of the table VOC contain the vowels U  , O , I , EA . If the first letter of the noun in question , stored in EWD(1 , N  ~ , starts with a consonant , K in statement 1476 will be zero , and K1 in statement 1477 will be negative . If the first letter is U , K 1 = 0 , and if the first letter is any other vowelt K1 will be positive . That means , that for any first letter of the noun , except U , statement 1477 decides whether " a " or " an " will be chosen . In the case of U the choice depends on the third letter of the noun  , found in statement 1910 . " A " will be chosen if the third letter is a vowel  , and " an " will be chosen if it is a consonant . 
This routine will , of course , still have to be refined for the case when the prefix " un " is followed by a vowel  . 
4 . Machine-word parts 4 . 1 . CSW0 ( compose word ) This subroutine , composing a machine-word from two parts of two other machine-word's  , facilitates the insertion of short words like prepositions or the definite article  . 
Format : S = CSWO(WORI ~, WORD2,K)
As a result of this function the first K characters of the machine-word in location WORDI is composed with the last  6 -E characters of the machine-word in location WORD2  . The resulting machine-word is stored in location S  . S may be identical with WORI ~ or WORD2 . 
We see an example of the application of this subroutine in t ~ he part of the program that translates a date into English  . 
575 EWD(1, IL ) = CSW0(WORD(50), EWD(I , IL ), 2)
K = IL-I
CALL SHA2(EWD(1,K ), 1, 52, 4, 1)
EWD(1, K)--CSWO(WORD(40), EWD(1,K ), 5)
CALL SHA2(EWD(1,K ), 1, 55, 5, 1)
GOTO550
In statement 575 the preposition " of " ( WORD ( 50 ) ) , chosen in this case as the translation of the Hebrew p ~ epcsitional prefix B  , is composed with the first part of the name of the month which follows it  . The statements following statement 575 translate the Hebrew B before the day of the month by " on the "  ( WORD ( 52 ) and ~ ORD ( ~O ) ) . 
The shifting subroutine SHA2 will be explained in section 6  . 2 . 
5 - Machine-words 5 . 1 . CP WO ( compare words ) A special subroutine for comparing non-numerical machine-words is necessary for ignoring the sign - bit  . When we make a mathematical comparison between two machine-words  ( subtracting one word from the other ) the first bit is interpreted as a sign ( 0=+ and I = - )  . 
This will give a wrong result when we compare a word starting with a letter between A and I with a word starting with a letter between J and Z  , since the former have "0" in their first bit-position , while the latter have " I " In non-numerical data -processing we therefore have to regard the machine-word as an entity of six characters  , where the first bit of the first character is part of the binary number representing the whole machine-word  . 
Format : S = CPWO(WORDI , WORD2)
The machine-words at the two locations WORDI and WORD2 are compared . 
S = I if the contents of WORD1 is greater than the contents of WORD2  , S = 0 if the two machine-words are equal , and S = - I if the contents of WORDI is smaller than the contents of  WORD2  . 
6 . Units lar~er than the machine-word 6 . 1 . CPST ( compare strings ) This routine differs from CE~O in enabling us to define the number of characters  ( N ) that we regard as the entity to be compared . 
Format : CPST(BLOCKI , NAI , BLOCK2, NA2, N)
The result is similar to that of the comparison of two machine-words : S = I if the binary number representing the string in BLOCKI  ( starting from NA 1 ) is greater than the binary number representing the string in  BLOCK2   ( starting from NA 2 )  , S = 0 if the two strings are equal , and S = - I if the binary number representing the string in BLOCKI is smaller than the binary number representing the string in  BLOCK2  . 
We shall see an example of this subroutine in the dictionary lookup  , section 6 . 5 . , where the words from the text will be compared to the words in the dictionary  . 
6.2. SHA2 ( shift in array )
This subroutine enables us to shift strinEs of variable length  . 
Format : CALL SHA2 ( BLOCK , NA , N , NSHIFT , IND ) NSHIFT is the number of positions we want to shift a string of N characters  , starting from the NAth character in the array BLOCK  . 
NSHIFT may be a positive or a negative integer , depending on whether we want to shift to the right or to the left  . IND = I if we want to fill the vacant positions by blanks and IND =  0 if we want to fill them by zeros . We saw two examples of this subroutine in sec-t ion  4  . 1 . Since we reserved six machine-words for one English word  , 
N+NSHIFT = 36 (6x6 characters).
6.5.1 OSS ( compose strings )
With the aid of this subroutine we may brinK a string of variable  ( N ) from one arra ~ ( BLOCK 1 ) ~ o another ( BLOCK 2 )  , starting position in the two arrays ( NA1 and NA2 )  . 
Format : J = ICSS(BLOCK 1 , NA1 , N , BLOCK2 , NA2 ) : The result of this function will be J = NA2+N . 
This routine , combined with IFFP ( section 5 . 1 . ) , is very useful in bringing the processed English sentence  , word for word , into the output area . 
5060 NA2 = 1
DO 5075L = 1, I
N = IFFP(ENG(1,L ), 56,-36, TAB , O)+1
IF ( N-l ) 5075 , 5075 , 5070 5070 NA2 = ICSS(ENG(1 , L) , I , N , OUT , NA2) 5075 CONTINUEI is the number of arrays , each consisting of six locations , that contain the English words after the analysis process  . IFFP has to look for the first non-blank , since the English equivalent of a Hebrew word may be a word group  . For the same reason we have to start the search from the  56th character , going left . We add 1 to the result of the function , so that the English word ( or word group ) is stored ~ i than additional blank and the result  ( NA 2 ) of the function ICSS may serve as a parameter of the same function in the next round  . The IF-statement before 5070 is as a feguard against the English word being blank  . 
6 . 4 . A subroutine changing the word order was added to the existing subroutines  . Since in Hebrew the adjective always follows the noun it qualifies  , we have to change the word order in English . 
Format : OALLADT(N )
N is a positive integer indicating that the adjective is the Nth word in the sentence  . It changes position ( together with its grammar codes ) with the ( N-1 ) th word . This subroutine was entirely written in FORTRAN , without a ~ ing subroutines . 
6 . 5 . The following subroutine was written for the dictionar Flookup of the translation project  . The words in the dictionary are alphabetically ordered  , with the exception of the blank , that stands between R and S , because of the value of its binary equivalent . 
For this reason , the blank following the word in the text is added before the word is compared with the dictionary entries  ( HW )  . 
The following parameters are used by the subroutine : NA = The position of the first letter of the word in the text that is looked up in the dictionary  . 
NZ = The number of characters of the word.
IL = The ordinal number of the word in the sentence  . 
M = The number of entries in the dictionary.
85 " Machine-words 5 . 1 . CPW 0 ( compare words ) A special subroutine for comparing non-numerical machine-words is necessary for ignoring the sign - b~t  . When we make a mathematical comparison between two machine-words  ( subtracting one word from the other ) the first bit is interpreted as a sign ( 0=+ and 1=- )  . 
This will give a wrong result when we compare a word starting with a letter between A and I with a word starting with a letter between J and Z  , since the former have "0" in their first bit-position , while the latter have "1" In non-numerical data-processing we therefore have to regard the machine-word as an entity of six characters  , where the first bit of the first character is part of the binary number representing the whole machine-word  . 
Format : S = CPW0(WORD1 , WORD2 ) femachine-words at the two locations WORD1 and WORD2 are compared . 
-  1 if the contents of WORD1 is greater than the contents of WORD2  , S = 0 if the two machine-words are equal , and S = -1 if the contents of WORD1 is smaller than the contents of WORD2  . 
6 . Units larger than the machine-word 6 . 1 . CPST ( compare strings ) This routine differs from CPW0 in enabling us to define the number of characters  ( N ) that we regard as the entity to be compared . 
Format : CPST ( BLOCK1, NA1, BLOCK2, NA2, N)
The result is similar to that of the comparison of two machine-words : S =  1 if the binary number representing the string in BLOCK1   ( starting from NA 1 ) is greater than the binary number representing the string in  BLOCK2   ( starting from NA 2 )  , S = 0 if the two strings are equal , and S = -1 if the binary number representing the string in BLOCK1 is smaller than the binary number representing the string in  BLOCK2  . 
We shall see an example of this subroutine in the dictionary lookup  , section 6 . 5 . , where the words from the text will be compared to the words in the dictionary  . 
6.2. SHA2 ( shift in array )
This subroutine enables us to shift strings of variable length  . 
Format : CALL SHA2 ( BLOCK , NA , N , NSHIFT , IND ) NSHIFT is the number of positions we want to shift a string of N characters  , starting from the NAth character in the array BLOCK  . 
NSHIFT may be a positive or a negative integer , depending on whether we want to shift to the right or to the left  . IND = 1 if we want to fill the vacant positions by blanks and IND =  0 if we want to fill them by zeros . We saw two examples of this subroutine in sec-t ion  4  . 1 . Since we reserved six machine-words for one Engl ish word  , 
N+NSHIFT = 36 (6x6 characters).
76.3. ICSS ( compose strings )
With the aid of this subroutine we may bring a string of variable  ( N ) from one arra ~ ( BLOCKI ) ~ o another ( BLOCK 2 )  , starting from any position in the two arrays ( NAt and NA 2 )  . 
Format : J = ICSS(BLOCK 1 , NA1 , N , BLOCK2 , NA2 ) : The result of this function will be J = NA2+N . 
This routine , combined with IFFP ( section 5 . 1 . ) , is very useful in bringing the processed English sentence  , word for word , into the output area . 
5O6ONA2=1,,\]~x ) = 5075L = ~ i
IFFP ( ENG(1,L ~, 56, ~-? B , 0)+1
I ~( N-I ) 5075 , 507~ , 5070 5070 NA2 = ICSS(ENG(I , L) , I , N , OUT , NA2) 5075 CONTINUEI is the number of arrays , each consisting of six locations , that contain the English words after the analysis process  . IFFP has to look for the first non-blank , since the English equivalent of a Hebrew word may be a word group  . For the same reason we have to start the search from the  56th character , going left . We add 1 to the result of the function , so that the English word ( or word group ) is stored@I than additional blank and the result  ( NA 2 ) of the function ICSS may serve as a parameter of the same function in the next round  . The IF-statement before 5070 is as a feguard against the English word being blank  . 
6 . 4 . A subroutine chan ~ in ~ the word order was added to the existing subroutines  . Since in Hebrew the adjective always follows the noun it qualifies  , we have to change the word order in English . 
Format : CALLADT(N )
N is a positive integer indicating that the adjective is the Nth word in the sentence  . It changes position ( together with its grammar codes ) with the ( N-1 ) th word . This subroutine was entirely written in FORTRAN , without a ~? ng subroutines . 
6 . 5 . The following subroutine was written for the dictionar ~ lookup of the translation project  . The words in the dlctio ~ ary are alphabetically ordered  , with the exception of the blank , that stands between R and S , because of the value of its binary equivalent . 
For this reasen , the blank following the word in the text is added before the word is compared with the dictionary entries  ( HW )  . 
The following parameters are used by the subroutine : NA = The position of the first letter of the word in the text that is looked up in the dictionary  . 
NZ = The number of characters of the word.
IL = The ordinal number of the word in the sentence  . 
M = The number of entries in the dictionary.

The following two constants are set up in the subroutine : N = the first power of  2 greater than M ( in our case 1024 ) 
J = 2LogN ( in our case 10)
SUBROUTINE LOOKUP(NA , NZ , IL , N)
DIMENSION ~( # , 1024) , HC(lO2#) , HSC(102#) , EW~6 , 102#) , EC(1024) , I~EX ~ (200) , CODE (50) , SCODE (50) , EWD (6 , 5O ) , ECOD~(50) , ~ D(2) COMMONTEXT , HW , CODE , SCODE , EWD , ECODE , HC , HSC , EW , EC , TESTWD
TESTWD(1) = 6HO 0 0 0 0 0
J = lO
N=1024
NI=N/2555 N=N-NI 54 OJ = J-1.
i ~( J ) 59 o , 54a , 5 ~ 544 NI=NI/2545 IF(CPST(TEXT , NA , HW(1 , N) , NZ+I )) 535 , 575 , 555555N=N+NI560 IF(MN ) 565 , 540 , 540565N = N-NI
NZ = ~ Z/2
N = N + NI 3=3-1
IFI~~590 , 570 , 570570 IFN ) 565 , 544 , 544575 CODE(IL ) = HC(N)
SCODE(tL ) = HSC(N)
DO580K=1,6580 EWD(K,IL ) = EW(K,N)
ECODE(IL ) = EC(N ) j = LBI~(~ES ~ WD(1) , 1) 590 RETURN

The lookup is done by the logarithmic method . We jump into the middle of the array reserved for the dictionary and exclude the lower half of the dictionary from further search if t~e text word is greater than the word of the dictionary that it was compared with  , and exclude the upper half if the word was smaller than the word in the dictionary  . This process of halving the searched area is repeated till either the word is found or J  , which is decreased by one before each search , is equal to zero . That means , we meyer have to compare more than ten times to find a word in the dictionary or to know that it cannot be found  . Statements 560 and 570 prevent us from searching in the area between M and N  . When the word is found , the grammatical information from the dictionary and the English translation of the Hebrew word is delivered to  . the main program and the first bit-position of TEST WD  ( 1 ) is set "1" . 
If the word is not found in the dictionary , the program proceeds as follows . If the first letter is one of the possible Hebrew prefixes  ( found by ICPC )  , the word is looked ~ p again , with Ehefirst letter stripped and NZ diminished by one  . The result of the function ICPC is used by a computed GOTO for a branching to that part of the program that will prepare the insertion of the definite article or the solution of the ambiguity of the preposition  . 
If the first letter is none of the possible prefixes and the word is not found in the dictionary  , the program will use the Hebrew original in the t ranslation and print out a message that the word was not found  . 
7. Conclusion
Apart from the subroutines described above , there are additional subroutines that facilitate information retrieval and other lingu-istic data -processing  . Statistical linguistics may obviously be efficiently treated by a mathematically oriented programming language  . 
This paper is not supposed to be a plea for FORTRAN  , but for a universally applicable problem-oriented language  , which will make the progress achieved in programming in one field accessible to the users of computers in all fields  . A combination of subroutines written in this language may do the job that is done today by separate problem-oriented languages  . A programming language like PL/I , or a language still to be created , may do the job more efficiently than FORTRAN . The idea is that the programs written will have a maximal possibility of application and that programmming examples given in the literature describing computer problems will be understood by all the readers interested  . 
8. Reference
Dipl . -Nath . Gisela Schlotter , Verarbeitung nicht numerischer Daten
Tell I . Unterprogramme ( PI-17)
Deutsches Rechenzentrum , Darmstadt
