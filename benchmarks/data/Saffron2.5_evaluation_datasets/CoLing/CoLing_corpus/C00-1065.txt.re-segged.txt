
Alexandra KINYON
Talana/Lattice , Univ . Paris 7
UFRL case 7003
2 pl Jussieu 75005 Paris , France
Alexandra . Kinyon@linguist.jussieu.fr

Srinivas ( 97 ) enriches traditional morphosyntactic POS tagging with syntactic information by introducing 
Supertags . Unfortunately , words are assigned on average a much higher number of Supertags than traditional POS  . In this paper , we develop the notion of Hypertag , first introduced in Kinyon ( 00 a ) and in Kinyon ( 00 b )  , which allows to factor the information contained in ~ everal Supertags into a single structure and to encode flmctional information in a systematic lnanner  . We show why other possible solutions based on mathematical properties of trees are unsatisfactory and also discuss the practical usefulness of this approach  . 

As a first step prior to parsing , traditional Part of Speech ( POS ) tagging assigns limited morphosyntactic nformation to lexical items  . 
These labels can be more or less finegrained depending on the tagset  , but syntactic information is often absent or limited  . Also , most lexical items are assigned several POS . Although lexical ambiguities are dealt with by POS taggers  , either in a rule-based or in probabilistic manner  , it is useful to delay this decision at a further parsing step  ( e . g . Giguet ( 98 ) shows that knowing constituent boundaries is crucial for solving lexical ambiguity correctly  )  . In order to do so , it would help to be able to encode several POS into one compact representation  . 
In order to assign richer syntactic information to lexical items Joshi & Srinivas  ( 94 ) and Srinivas ( 97 ) introduce the notion of Supertags , developed within the fiamework of Tree Adjoining Grammars  ( TAG )  . The idea behind Supertags is to assign to each word in a sentence  , instead of a traditional POS , an " elementary tree " , which constitutes a primitive syntactic structure within the TAG frmnework  . A supertagged text can then be inputed to a parser or shallow parser  , thus alleviating the task of the parser . Several problems remain though : ? Even when no lexical ambiguity occurs  , each word can anchor several trees ( several hundreds for some verbs ) I . On average for English a word is associated with 1  . 5 POS and with 9 supertags ( Joshi (99)) . One common solution to the problem is to only retain the " best " supertag for each word  , or eventually the 3best supertags for each word , but the nearly decision has an adverse effect on the quality of parsing if the wrong supertag  ( s ) have been kept : one typically obtains between 75% and 92% accuracy when supertagging , depending on the type of text being supertagged and on the technique used  )   ( cf Srinivas ( 97 )  , Chen & al (99) , Srinivas & Joshi (99)) . This means that it may be the case that every word in  4 will be assigned the wrong supertag , whereas typical POS taggers usually achieve an accuracy above  95%  . 
? Supertagged texts rely heavily on the TAG framework and therefore may be difficult to exploit without being familiar with this for naal is m  . 
? Supertagged texts are difficult to read and thus difficult to annotate manually  . 
? Some structural information contained in
Supertags is redundant ? Some information is missing  , especially with respect to syntactic functions 2 . 
So our idea is to investigate how supertags can be underspecified so that instead of associating a set of supertags to each word  , one could associate one single structure , which we call hypertag , and which contains the same information as a set of supertags as well as functional information 
Our practical goal is four folds : a ) delaying decision for parsing b ) obtaining a compact and readable representation , which can be manually annotated 1 See Barrier & al . (00) for precise data for French , using the FFAG wide-coverage grammar developped at 
TALANA , University of I ' aris 7.
2 The usefulness offunctional information ill POS tagging has also been discussed within the reductionist paradigm  ( cf Voutilainen & Tapanainen ( 93 ) ) . 
4 46 as a step towards building a treebank for French ( cfA be ill 6& al . (00a ), Cl6ment & Kinyon (00)) . 
c ) extracting linguistic information on a large scale such as lcxical preferences for verb subcategorization frames  . ( cfKinyon(99a )) (1) Building an efficient , but nonetheless psycholinguistically motivated , processing model for TAGs ( cfKinyon ( 99 b ) ) Ttms , in addition of being well-defined computational objects  ( Pointa )  , hypertag should I ) e " readable " ( point b ) and also motivated from a linguistic point of view  ( Points c&d )  . 
In the first part of this paper , we briefly introduce the LTAG frmnework and give exmnples of supertags  . In a second part , we investigate several potential ways to underspecify supertags  , and show why these solutions are unsatisfactory . In a third part , we explain the solution we have adopted , building upon the notion of MetaGrammar introduced by Candito  ( 96 ) and Candito ( 99 )  . Finally , we discuss how this approach can be used in practice  , and why it is interesting for frameworks other than LTAGs  . 
1 Brief Overview of LTAGs
ALTAG consists of at ' inite set of elementary trees of finite depth  . Each elementary treenms t " anchor " one or more lcxical item  ( s )  . The principal anchor is called " head " , other anchors are called " co-heads " . All leaves in elementary trees are either " anchor "  , " footnode " ( noted * ) or " substitution node " ( noted $ )  . . These trees are of 2 types ? auxiliary or initial 3  . A tree has at most 1 foot node . A tree with a foot node is an auxiliary tree . Trees that are not auxiliary are initial . Elementary trees combine with 2 operations : substitution and adjunction , but we won't develop this point since it is orthogonal to our concern and refer to Joshi  ( 87 ) for more details . Morphosyntactic features are encoded in atomic feature structures associated to nodes in elementary trees  , in order to handle phenomena such as agreement . 
Moreover , linguistic constraints on the wellformedness of elementary trees have been formulated : ? Predicate Argulnent Cooccurence Principle : there must be a leaf node for each realized argument of the head of an elementary tree  . 
? Semantic consistency : No elementary tree is semantically void ? Semantic minimality : an elementary tree corresponds at most to one semantic unit Figure  1 shows a nonexhaustive set of Supertags ( i . e . elementary trees ) which can be assigned to " beats ''4 , which is a verb in trees ctl ( canonical tree ) , ~2 ( object extraction ) , 131 ( ob . iect relative ) and \[32 ( subject relative ) and a noun in tree oG . So an LTAG can be seen as a large dictionary , were in addition of traditional POS , lexical entries are associated with several structures encoding their nlor phological as well as some of their syntactic properties  , these structures being very similar to small constituent trees  . 
e?lc?2
SS~05v NI , I . s's'beats explVNI,I,Cl~mpNO,I-V
IIII(Vb : " J beats M . ") it is that beats ( rb : " It is Mary that J . beats ")
NN
NI*S'NO*S'

Comp NO$V Camp VNI$I
I\[II1 , eats that beats who beats ( Vb : " The man that ( Vb : " The manrho ( Noaa : "3 beats " ) 
M . beats ., .") beats 31...")
HGURE1: some supertags fi ) r " beats " 2 Underspecifying Supertags The idea of underspecifying constituentrees  ( and thus elementary trees ) is not new . Several solutions have been proposed in the past . We will now investigate how these solutions could potentially be used to encode a set of supertags in a compact manner  . 
2.1 Parse forest
Since elementary trees are constituent structures , one could represent a set of elementary trees with a graph instead of a tree  ( cf . Tomita (91)) . This approach is not particularly interesting though  . For example , if one considers the trees czl and 131 fi'om figure 1  , it is obvious that they hardly have any structural information in common  , not even the category of their root . 
Therefore , representing these 2 structures in a graph would not help . Moreover , packed 3 Traditionally initial trees arc called a , and auxiliary lines 4For sake of readability , morphological features arc not

4 47 structures are notoriously difficult to manipulate and yield unreadable output  . 
2.2 Logical formulae
With this approach , developped for instance in Kalhneyer (99) , a tree can be represented by a logical formula , where each pair of nodes is either in relation of dominance  , or in relation of precedance . This allows to resort to 1 ~' order logic to represent a set of trees by underspecifying dominance and/or precedence relations  . Unfortunately , this yields an output which is difficult to read . Also , the approach relies only on mathematical properties of trees  ( i . e . no linguistic motivations ) 2 . 3 Linear types of trees This approach , introduced in Srinivas (97) , used in other work ( e . g . Halber (99)) is more specific to TAGs . The idea is to relax constraints on the order of nodes in a tree as well as on internal nodes  . A linear type consists in a 7-tuple < A , B , C , D , E , F , G > where A is the root of the tree , B is the category of the anchor , C is the lexical anchor , D is a set of nodes which can receive an adjunction  , E is a set of co-anchors , Faset of nodes marked for substitution , and G a potential foot node ( or nilin case the tree is initial )  . In addition , elements of E and F are marked+if they are to the left of the anchor  , - if they are to the right . 
czlor 2
SS
NOP NO ,, LVPPNI ,, L
I/\I /", , donneaN2-1-donneil N2,,\[-
FIGURE 2 : two trees with the same linear type For example  , the tree NOdonneNl'~N2 for " Jean donne unepommegl Marie " ( J . gives an apple to M . ) and the tree N0donne~lN2Nl for " Jeandonne & Marieune pomme " ( J . gives M . an apple ) which are shown on Figure 2 , yield the unique linear type ( a ) ( a ) < S , V , do nnc , S , V , PP , h + , N0- , NI + , N2+ , nil > ( b ) < S , V , gives , S , V , PP , to + , N0- , N1+ , N2+ , nil > This approach is robust , but not really linguistic : it will allow to refer to trees that are not initially in the grammar  . For instance , the linear type ( b ) will correctly allow the sentence " John gives an apple to Mary "  , but also incorrectly allow "* John gives to Mary an apple "  . 
Moreover , linear types are not easily readables.
Finally , trees that have more structural differences than just the ordering of branches will yield different linear types  . So , the tree N0 give Nl to N2(J . gives an apple to M . ) yields the linear type ( b ) , whereas the tree N0 give N2N l(J . gives M . an apple ) yields a different linear type(c ) , and thus both linear types should label " gives " . Therefore , it is impossible to label " gives " with one unique linear type  . 
( c ) < S , V , gives , S , V ,    , N0- , N1+ , N2+ , nil > 2 . 4 . Partition approach This approach , which we have investigated , consists in building equivalence classes to partition the grammar  , each lexical item then anchors one class instead of a set of trees  . But building such a partition is prohibitively costly : a wide coverage grammar for French contains approx  . 5000 elementary trees ( cfA beilld & al . 
(99) , (00b )) , which means that we have 25~'~ possible subsets . Also , it does not work from a linguistic point of view :   ( a ) Qu and Jeanabris dlaglace ? ( When did J . break the ice ?) ( b ) Jean abris d laglace ( J . broke the ice )   ( c ) Quelle chaise Jeanabrisd cematin ? ( Which chair did J . break this morning ? ) In ( a ) brisd potentially anchors N0 brise NI ( canonical transitive )  , WhN0brise ( object extraction ) and NO Brise Glace ( tree for idiom )  . 
But in ( b) , we would like brim not to anchor WhN0brise since there is no Whelement in the sentence , therefore these three trees should not belong to the same equivallence class : We can have class  A=N0briseN1  , NO Brise Glace and Class B = Wh N0 brise . But then , in(c ) , brisd potentially anchors WhN0brise and N0briseNI but not NOB rise Glaces in ceglace does not appear in the sentence  . So NOVN1 and NOB rise Glace should not be in the same equivalence class  . This hints that the only realistic partition of the grammar would be the one were each class contains only one tree  , which is pretty useless . 
4. Exploiting a MetaGrammar
Candito (96) ,   ( 99 ) has developed a tool to generate semiautomatically elementary trees She use an addition a layer of linguistic description  , called the metagrammar ( MG ) , which imposes a general organization for syntactic information in a  3 dimensional hierarchy: 5 This type of format was considered as a step towards creating a trccbank for French  ( of Abcilld & al00a )  , but unfommatcly proved impossible to manually annotate  . 
4 48 ? Dimension 1: initial subcategorization ? Dimension 2: redistribution of functions and transitivity alternations ? Dimension  3: surface realization of arguments , clause type and word order Each terminal class in dimension  1 describes a possible initial subcategorization ( i . e . a tree family ) . Each terminal class it \] dimension 2 describes a list of ordered redistributions of functions  ( e . g . it allows to add an argument for causatives ) . Finally , each terminal class in dimension 3 represents the surface realization of a ( final ) flmction ( e . g . cliticized , extracted . . . ) . 
Each class in the hierarchy corresponds to the partial description of a tree  ( cf . Rogers & Vijay-Shanker (94)) . An elementary tree is generated by inheriting from one terminal class in dimension  1  , fi'om one terminal class in dimension 2 and fl ' olll Uterulinal classes illd in lension 3   ( were n is the number of arguments of the elementary tree  )  . 6 The hierarchy is partially handwritten . Then crossing of linguistic phenomena ( e . g . passive+extraction ) , terminal classes , and from the reelementary trees are generated automatically offline  . This allows to obtain a grammar which cat \] then be used to parse online  . When the grau\]mar is generated , it is straightforward to keep track of the terminal classes each elementary tree inherited from : Figure  3 shows seven elementary trees which can superiag " domw "  ( gives )  , as well as the inheritance patterns 7 associated to each of these supertags . All the exain ples below will refer to this figure . 
The key idea then is to represent a set of elementary trees by a disjunction for each dilnension of the hierarchy  . Therefore , a hypertag consists in 3 disjunctions ( one for dimension 1 , one for d in lension 2 and one for dimension 3) . 
The crossproduct of the disiunctions can then be perforined automatically and from there the set of elementary trees referred to by the hypertag will  6 The idea to use the MG to obtain a colnpact representation faset of SuperTags was briefly sketched in Candito  ( 99 ) and Abeill 6& al .  (99) , by resorting to MetaFeatures , but the approachere is slightly different since only inlbrmation about he classes in the hierarchy is used  . 
7 We call inheritance patterns Ihe structure used to store all the terminal classes a tree has inherited from  . 
) CA . . . . . . . . . .
oq , ~ V ~) i . . . .  .   .   . io II 1: It0'?lii (' Ill2) qN~'P ~ II , i . . . . . . . i , , , 2 .   .   .   .   .   .   . lislril , , , , ioi, . 1\[~)imension3:suhj:tlominai . canonlcal\[\[\[//~ . xoll j . . . . . . . in a , . . . . . . . .  cal II donne h N2-L ~ l'O ) j : II ( llt lIIn-can one fll \]\[ ( J donnelille pOlllMt ~ hM .  /
J gives an apple to M ) c~2
N~NI.L\[~)i.......ioi,1: n0vnl(hi12) q
I Dimc . sio . 2:. or edistril > ution t
Ilii . . . . . . . ion3:\]suhj . . . . . . . inal . . . . . . . . ieal II ~ / I obJ . . . . . . . i , , , , I . . . . . . . . i~ . lII(J,donlIc\[I  ~ . ~ . \[\]Dt3pOlllmO /
Jgi ',' esto Mana pll\]?)0' . ~ F)i . . . . . . . ion : I , OV lll ( ~ln2 ) " ~1 s ~ I Dimension 2: h Obj-cln ply/N ~ NI . L ~\] I)i . . . . . . . ion3:\[sulij . . . . . . . inal . . . . . . . . ical I\[
IL_I ebj:nominal-canonical I\] define(J . d Olitle Lil Lep Olliille /
J gives an apple )\[; 4~ li . . . . . . . ioi , I : nll~nl(hi , 2 ) ~ ~ II ) hllensi ( l l l 2 : no redistribution\[Conll~%'Nll$PP\[I obj:relall vizcd-object IIII/\Li  . o ,, J: . . . . . . ,,,,,,  .   .   .   .   .   .   .   .  ++ . ~ quedonnel'\[epN2 . \[-/ a (1 perun?que donne J . hM , I
The allph , w Dich gives J . to M . ) t\]5\[~)i . . . . . . . ioi,1: n0viil(hn2) qNNI*~S_'~IDime . d . n2: no redistrilutlon . 1 ~ ~ ll ) i . . . . . . . i01 13: lst lh j . . . . . . . . ilHll .   .   .   .   .   .   .   .   . i'lIICotnl > N0-L VPPl\]obj:rehttivized-ollj cctIIII~Ll , ,- . , , J . . . . . . . . i ,,,,: . . . . . . . . . . i , . , ~ quedonneP\[cpN2,~//l(l , a pomme que J . donne DM . I
The allph , whict lJ.gil'es to M . J
I 6N ~) i . . . . . . . ion I : n0vnl(',,,2) qIm . . . . . . . io ,, 2: ao hj-cmply tNI*--~~II)i . . . . . . . ion 3: lsu hj . . . . . . . . iual-i . verled\]l/ACompVNI ) ~ Liob . i : relali ; ized-object . ~ J
Ii qlte do tlttd(Lapomme que donneJ./
The apph ' which give . iJ . )\[:17 UIi . . . . . . . ion 11n(l ', nl(hn2) qy s'~II ) imc . sio . 2: Mll , j-elnpty . lNI*lm . . . . . . . io . 3: l + , , i , j . . . . . . . . inal . . . . . . . . . . it ,,: \] I c , , ~ v L I obj : relali+ized . ohject 11
Iiqttedonne(LapotlltJl#qtteJ.dotltte/
The all Ph'which J.gil.es )
FIGURE 3 : SuperTags and associated inheritance patterns be automatically retrieved We will no wilhlstrate this  , first by showing how hypertags are built , and then by explaining how a set of trees ( and thus of supertags ) is retrieved from the information contained in a hype mig  . 
4 . 1 Bui ld ing hypertags : a detailed example Let us start with a simple exemple were we want " donner " to be assigned the supertags  o~1   ( J . 
dmmetree pomme DM . IJ . gives an apple to M . ) and o~2 ( J donneh M . treel ) omme/J , gives M . an inherited exactly fi'om the same classes : the relative order of the two complements is left unspecified in the hierarchy  , thus one same description will yield both trees . In this case , the hypertag will thus simply be identical to the inheritance pattern of these  2 trees :
Dimension 1: n0 vnl(hn2)
Dimension 2: no redistribution
Dimension 3 subj:nominal-canonical\[obj:nominal -canonical\]\[a-~'bj:nominal-canonical\[Let ' snow add tree  o3   ( J . donne une pomme/J . gives an apple ) to this hypertag . This tree had its second object declared empty in dimension  2   ( thus it inherits only two terminal classes from dimension  3  , since it has only 2 arguments realized ) . The hypertag now becomes 8:
Dim . 1: n0 vnl(an2)
Dim . 2: no redistribution ORStObj-empty
I ) im .   3 lsubj:nonainal-canonical\[obj:nominal -canonical a-obj:nominal-canonicalLet's now add the tree  134 for the object relative to this hypertag . This tree has been generated by inheriting in dimension  3 fi'om the terminal class " nominal inverted " for its subject and from the class " relativized object " for its object  . This information is simply added in the hypertag , which now becomes :
I ) i , l ~ . : n0 wll(~ . 12) ira . 2: no redistribution 0P , il 0bj-empty lira .   3 subj : nominal-canonical OR nominal-inverled lI obj : nominal-canonical OR relativized-oblectI I 
Ia-0bj:n0 minal-canonicalii
Also note that for this last example the structural properties of  134 were quite different than those of ?~1  , 02 and cG ( for instance , it has a root of category N and not S ) . But this has little importance since a generalization is made in linguistic terms without explicitly relying on the shape of trees  . 
it is also clear that hypertags are built in a monotonic fashion : each supertag added to a hypertag just adds information  . Hypertags allow to label each word with a unique structure  9  . and 8 What has been added to a supertag is shown in bold characters  . 
9 We presented a simple example for sake of clarity  , but traditional POS ambiguity is handled in the same way  , excep that disjunctions are then added in dimension  1 as contain rich syntactic and ftmctional information about lexical items  ( For our example here the word donne ~ gives )  . They are linguistically motivated , but also yield a readable output . They can be enriched or modified by Imman annotators or easily fed to a parser or shallow parser  . 
4 . 2 Retrieving information from hypertags Retrieving inforlnation from hypertags is pretty straightforward  . For example , to recover the set of supertags contained in a hypertag  , one just needs to perform the crossproduct between tile  3 dimensions of the hypertag , as shown or l Figure 4 , in order to obtain all inheritance patterns . These inheritance patterns are then matched with tile inheritance patterns contained in the grammar  ( i . e . tile right colunm in Figure 3 ) to recover all the appropriate supertags . 
Inheritance patterns which are generated but don't match any existing trees in tile grammar are simply discarded  . 
We observe that the 4 supertags 01 ,   c~2 and 03 and \]34 which we had explicitly added to tile hypertag in  4  . 1 are correctly retrieved . But also , the supertags 135 , 136 and 137 arc retrieved , which we did not explicitly intend since we never added them to the hypertag  . But if a word can anchor the 4 first trees , then it will also necessarily anchortile three last ones : for instance we had added the canonical tree without a second object realized into the hypertag  ( tree or 2 )  , as well as the tree for tile object relative with a second object realized realized  ( tree 134 )  , so it is expected that tile tree for the object relative without a second object realized can be retrieved from the hypertag  ( tree 136 ) even though we never explicitly add edit . In fact , the automatic rossing of disjunctions in the hypertag insures consistency  . 
Also note that no particular " mechanism is needed for dimension  3 to handle arguments which are not realized : if hObj-empty is inherited from dilnension  2  , then only subject and object will inherit from dimeusiouthree  ( since only arguments that are realized inherit from that dimension when the grammar is generated  )  . 
Information can be modified at runtime in a hypertag  , depending on the context of lexical items . For example " relativized-object " can be suppressed in dimension  2 from the hypertag shown on Figure 4  , in case no Whelement is encountered in a sentence  . Then , the correct set of supertags will still be retrieved from the well  . 

Content of the llypertag
Dimension 2 Dimension 3
Subject Object a-obj1 iI l . -/\~~111 i1~10<2\[~5 No\[~cs3\[~6N .  \[7 , 7 ( Jorresllonding Corresl ) onl ( lhig I , ' ~'~'\[% qsertags c?r-resls ?' idi"glol'il -ierilancel Jatter'sltr ~  , e\[ ( el Figure 3 ) IFIGURE 4 : Retrieving Inheritance patterns and Supertags fronla Hypertag hypertag by automatic rossing  ( that is , treeso ~1 , (; ~2 and o ' . 3) , since the other inheritance l ) atterns generated won't refer to any treeill the grain mar  ( here , tie tree inherits in diillension 3 , vuhject : in , verted-nominal , without inheriting also objecl : I wlalivize U -oluect  )  4 . 3 Practical use We have seen that an LTAG can be seen as a dictionary  , in which each lexical entry is associated to a set of elementary trees  . With hypertags , each lexical entry is now paired with one unique structure  . Therefore , automatically hypertagging a text is easy and involves a simple dictionary lookup  . The equiwllent of finding the " right " supertag for each lexical item in a lext  ( i . e . 
reducing ambiguity ) then consists in dynamically removing information from hypertags  ( i . e . 
suppressing elements in disjunctions ) . This can be achieved by specific rules , which are currently being developed . The resulting output carl then easily be manually annotated in order to build a gold standard corpus : manually removing linguistically relevant pieces fronlinformation in a disjunction from a single structure is simpler than dealing with a set of trees  . In addition of obvious advantages in terms of display  ( tlee structures , especially when presented in a nongraphical way , are unreadable ) , the task itself becomes easier because topological problems are solved automatically : annotators need just answer question such as " does this verb have an extracted object ?"  , " is the subject of this verb inverted ?" to decide which terminal classe  ( s ) nlust be kepti ? . We believe that these questions are easier to iuls w cr than " Which of these trees have a node N I marked wh+at address  1  . 19" ( for an extracted object ) . 
Moreover , supertagged text are difficult to use outside of an LTAG framework  , contrary to hypertagged texts , which contain higher level generalinguistic information  . An example would be searching and extracting syntactic data oil a largescale : suppose one wants to extract all tile occurrences where a given verb V has a relativized object  . To do so on a hypertagged text simply involves performing a " grep " ell all lines coutain higa V whose hypertag contains dimension  . 7: objet : relalivized-object , without knowing anything about the LTAG framework . 
Performing the same task with a supertagged text involves knowing how LTAGs encode relativized objects in elementary trees and scanning potential trees associated with V  . Another examl ) le would be using a hypertagged text as an input to a parser based oil a framework other than LTAGs : for instance  , information in hypertags could be used by an LFG parser to constrain the construction of an IV -structure  , whereas it's uuclear how tills could be achieved with supertags  . 
1 0 This of course implies that one must be very careful in choosing evocative names for terminal classes  . 

The need to " featurize " Supertags , in order to pack ambiguity and add functional information has also been discussed for text generation ill Danlos  ( 98 ) and more recently in Srinivas & Rain bow ( 00 )  . It would be interesting to compare their approach with that of hypertags  . 

We have introduced the notion of Hypertags.
Hypertags allow to assign one unique structure to lexical items  . Moreover this structure is readable , linguistically and computationally motivated , and contains much richer syntactic information than traditional POS  , thus a hypertagger would be a good candidate as the frontend of a parser  . It allows in practice to build large annotated resources which are useful for extracting syntactic information on a large scale  , without being dependant on a ~ iven grammatical formalism  . 
We have shown how hypertags are built , how information can be retrieved from them . Further work will investigate how hypertags can be combine directly  . 

Abeilld A . , Candito M . H . , Kinyon A . (1999) FFAG : current status & parsing scheme . Prec . Vextal'99 . 

Abeilld A . , Cldment L . , Kinyon A . (2000a ) Building a Treebank for French . Prec . LREC'2000 . Athens . 
Abeilld A . , Candito M . H . , Kinyon A . (2000b ) Current status of FTAG . ProcTAG+5 . Paris . 
Barrier N . Barrier S . Kinyon A .  (2000) . Lcxik : a maintenance tool for FTAG . Prec . TAG+5 . Paris . 
Candito MH .   ( 1996 ) A principle-based hierarchical representation of LTAGs  , Prec . COLING'96

Candito M . -H ,   ( 1999 ) Reprd sentation modulair cct paramdtrable de grammaircs  61ectroniques lexicalis des . Application au frangais et al'italien . 
PhD dissertation . University Paris 7.
Chen J . , Srinivas B . , Vijay-Shanker K .   1999 New Models for Improving Supertag Disambiguation . 
Prec . EACL'99 pp . 188-195. Bergen.
Cldment L , Kinyon A . (2000) Chunking , marking and searching a morphosyntactically annotated corpus for French  . Prec . ACIDCA'2000 . Monastir . 
Danlos L ( 1998 ) GTAG : unformalisme lexicalis6 pour lagdnd ration automatiqued TAG . TAL 39:2 . 
Giguet E .   ( 1998 ) Mdthodes pour l ' analyse automatique destructures formelles surdocuments multilingues  . PhD thesis . Universit de Cacn . 
Halber A .   ( 1999 ) Stratdgied ' analyse pour la compr dhension de la parole : versune approche base de Grammaires d ' Arbres Adjoints Lexicalis des  . 
PhD thesis . ENST . Paris
Joshi A .   ( 1987 ) An introduction to Tree Adjoining Grammars . In Mathematics of Language . A . 
Manaster-Ramer ( eds ) . John Benjamins Publishing Company . Amsterdam . Philadelphia . pp .  87-114 . 
Joshi A . (1999) Explorations era domain of locality . 
CLIN'99. Utrecht.
Joshi A . Srinivas B .   ( 1994 ) Disambiguation of SuperParts of Speech ( or Supertags ) : Ahnost parsing . 
Proceeding COLING'94. Kyoto.
Kalhneyer L0999 ) Tree Description Grammars and Und cr specified Representations  . PhD thesis,
Universit ' At Ti . ibingen.
Kinyon A .   ( 1999a ) Parsing preferences with LTAGs : exploiting the derivation tree  . Prec . ACL'99 . College
Park , Md
Kinyon A .   ( 1999b ) Some remarks about the psycholinguistic relevance of LTAGs  . Prec . 
CLIN'99. Utrecht.
Srinivas B .   ( 1997 ) Complexity of lexical descriptions and its relevance t br partial parsing  , PhD thesis , 
Univ . of Pennsylvania.
Srinivas B . , Joshi A .   ( 1999 ) Supertagging : An approach to almost parsing . Computational
Linguistics 25:2.
Srinivas B . Rainbow O . (2000) Using TAGs , a Trce Model , and a Language Model for Generation . Prec . 
TAG+5. Paris.
Tomita M . (1991) Generalized LR Parsing . Masaru Tomita ( eds ) . Kluwer academic publishers . .
Rogers J . , Vijay-Shanker K .   ( 1994 ) Obtaining trees froln their descriptions : an application to TAGs  . 
Computational Intelligence , 10:4pp 401-421.
Voutilainen A . Tapanainen P .   ( 1993 ) Ambiguity resolution in a reductionistic parser . Prec . EACL'93 . 

