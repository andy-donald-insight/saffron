AUTOMATICTRANS LATION WITH ATTRIBUTEG RAMMARS
Werner Dilger
University of Kaisers lauter n
Computer Science Department
D-6750 Kaisers lauter n
Federal Republic of Germany

Starting from an ATN-grammar and translation rules assigning expressions of a predicate calculus language to the symbols of the grammar one can produce an attribute grammar for the translation of natural language sentences  ( here German ) into expressions of the predicate calculus language  . The paper illustrates that this can be done in a straightforward way and outlines further improvements of the resulting attribute grammar  . 

An important component of the natural language information system PLIDIS  , developped by my colleagues and myself at the Institut fuer deutsche Sprache in Mannheim  ( cf . \[ BW78\] , \[ KL79\]) , is the translation algorithm , which transduces na-tural language sentences into expressions of an augmented first order predicate calculus  , called KS(cf . \[ DZ78\],\[Zi77\]) . Special features of KS going beyond ordinary predicate calculus are many-sorted domain of objects  , l-abstraction , and complex term-building facilities . The examp-les contained in this paper will il lust rate these features  . Input for the translation algorithm are the parsed sentence and a set of translation rules  ( in the following : TR-rules )   ( cf . \[ Wu 79\]) , which are defined for labels of the parse tree nodes  , mainly for the labels of the terminal nodes , i . e . for the words of the input sentence . Working bottom up the parse tree the translation algorithm assigns a translation to each of the nodes of the tree by interpreting the TR-rules defined for the labels of the nodes  . If a translation has been successfully assigned to the root of the tree  , which is labelled by S , this translation is the translation of the whole sentence  . 
The advantage of the translation algorithm , the most important part of which is the interpretation of the TR-rules  , is its rather simple structure , which facilitated implementation . But it also has several disadvantages . First of all the algorithm is not very efficient since it runs separately from parsing  , i . e . it does not start before parsing has finished . The TR-rules must take care of the structure of the parse tree  , that means , during their interpretation we must check which steps were made in parsing some relevant part of the tree  . Next , the TR-rule for the label of a node must be completely evalua-ted  , though it depends on the position of the node in the tree  , which parts of the rule apply to the node or whether the rule applies as a whole  . Finally it is difficult to detect circu-larities in the translation process on the basis of the TR -rules  . 
To avoid these disadvantages we can use attribute grammars for the translation  . The content of the TR-rules must then be represented by attributes and semantic functions  . But for this purpose we need a contextfree grammar as a basis of the parsing  . In PLIDIS , however , we have no such grammar , parsing is done by means of an ATN-grammar ( cf . \[ Wo 70\] , \[ Wo 73\] , \[Ba78\] , \[ EL79\]) , adapted for German . Though the networks of the ATN-grammar are not contextfree productions  , we can produce such productions out of them . At first glance , by doing so , the context sensitivity of the networks-which is their main advantage-is lost  . But we can regain it by providing the productions with appropriate attributes and semantic functions  . If we take a simpler version of the ATN-grammar , namely the RTN-grammar ( " recursive transition networks " )   ( cf . \[ Wo 70\]) , then an ATN-grammar is nothing else but an attributed RTN-grammar  ; so we could read the letters " ATN " as " attributed transition networks " instead of " augmented transition networks "  . In the remainder of the paper we omit the attributes needed to express context conditions  , we only deal with those needed for translation . 
To summarize , we have to show how to obtain contextfree productions from the networks and attributes and semantic functions from the TR-rules  . We will demonstrate by examples that the method is straightforward  , and we will outline how the resulting attribute grammar can be improved  . 
ATN-grammars and TR-rules
We want to parse the following questions asking for facts of the PLIDIS mini-world  , i . e . the control of water pollution : Enthielteine Probeim Jahr  1979 in Stuttgart Arsen ? Dida sample in 1979 in Stuttgart contain arsenic ? Welche Betriebe in Stuttgar that Zimpelim 
Jahr 1979 geprOft ? which plants in Stuttgart Zimpel has inspected in  1979? Welche Betriebehat Zimpelim Jahr 1979 in
Stuttgart gepr ~ f t ? which plants Z impel has inspected in  1979 in Stuttgart ? --397-- 
Welche Betrie beder Firma Lauxmann in
Stuttgar that Zimpelge pr~f t ?
Which plants of the firm Lauxmann in
Stuttgart Zimpel has inspected ?
Welcher Probenehmer hat beider Firma Laux-mannim Jahr  1979 Probenge zogen ? Which sampler has taken a sample from the firm Lauxmann in  1979? We will give a small section of the ATN-grammar used within PLIDIS  , reduced to an RTN-gr~mnar , which allows the parsing of these questions . The networks and word classes of fig . i are needed for this purpose . 
NGP NGN GPNG_wo q_/2 Q/2
DET N
AUXH : hob have
DET = ( der , die , das , eine the , a
N = ( Probe , Probe nehmer , Jahr , Betrieb , Firma , Arsen sample , sampler , year , plant , firm , arsenic
NPR = Stuttgart , Zimpet , Lauxmann
PRAEP = in , beiin , at
VERB = enthalt , pr~f , ziehcontain , inspect , take
WDET = welch which
Figure 1
We obtain by means of this grammar for the question Welche Betriebe in Stuttgar that Zimpel im 
Jahr 1979 gepr0ft ?
Which plants in Stuttgart Zimpel has inspected in 1979? the parse tree of fig .  2 . 
We will now give TR-rules for the labels of some of the nodes occurring in fig  .  2 , using small 0~_ cgz_~-bf"N~Q : ? "~2 mo ~ zX ~ : ?* lEE-? , ,=  . _ ~-  . - cm2 = : u , ~  e4 u_diagrams which represent sections of possible parse trees  . The triangles in these diagrams denote arbitrary ( perhaps empty ) subtrees . Because the TR-rules are defined for single symbols of the grammar regardless of their occurrences in parse trees  , all possible natural language occurrences of the symbols must be described and dealt within the TR-rules  . Therefore in the following TR-rules not all conditions will be immediately clear  . But that doesn't matter since we are not interested in the details of the TR-rules  , rather we will show below how the TR-rules can be transformed into expressions containing attributes and semantic functions  . 

Betrieh ( plant ) : if ~ and sort ( translat ( Y ) ) = iBetrieb i i f ?# ont \ ] . ~  . a then i'w'~'~and sort ( trnslat /& Betrieb then translat ( Betrieb ) =\[ LAMBDAX . BETR\[BETRIEB translat(Y ) translat(PNG )
X . BETR\]\]else translat(Betrieb ) =\[ LAMBDAX . BETR~\[BETRIEB translat(Y ) X . ORTX . BETR\]\]else if ~ pNan~sort ( translat ( PNG ) ) = ORT ~ Betrieb then translat ( Betrieb ) =\[ LAMBDAX . BETR\[BETRIEBX . INDUSTRIE translat ( PNG )
X . BETR\]\]else translat(Betrieb ) =\[ LAMBDAX . BETR\[BETRIEBX . INDUSTRIEX . ORTX . BETR\]\]in:i . . . _, . f . . N~,pRNAGEp ? in and N ~ y N G an d
Y 6N , NPR and sort ( translat ( Y )   ) = ORT then translat ( in ) =\[ LAMBDAX . ORT\[IN translat(Y ) X . ORT\]\]else if N~p and NA yNO and insort ( translat ( Y ) ) _~ INT then translat ( in ) =\[ LAMBDAX . INT\[INTEMP translat(Y ) X . INT\]\]else if ~ and so rans lat ( NG ) ) ~ INT & in then translat ( in ) =\[ LAMBDAX . INT\[INTEMP translat(NG ) X . INT\]\]else translat(in ) = 0 o
Stuttgart : translat ( Stuttgart ) = STUTTGART
M : if ~ and Z'6NG , PNG and ~ Z~'~NG((z6 Monat , Jahr and cat ( translat ( Y ) ) = KONST and sort ( translat ( Y ) ) = INT ) or ( YEN , NPR and cat ( translat ( Y ) ) = TERM and cat ( translat ( Z ) ) = LTERM and sort ( translat ( Y ) ) = sort ( translat ( Z ) ) ) ) then translat ( N ) = The else-part here is assumed to be substituted by the general rule prescribing that whenever a TR-rule does not apply  , the translation of the node will be the translation of one of its daughter nodes  , e . g . here we could write : else translat ( N ) = translat ( Z ) From the TR-rule for PNG we will only give some part : 
PNG : i_~~NG and cat(translat(N))
KONST then if ~ PNG and Y6DET , QDET , WDET , NEG-
PET , ZAHL and cat ( translat ( Y ) ) = QUANT o ? then if cat ( translat ( PRAEP ) ) = LTERM then translat ( PNG ) =\[ translat ( Y ) translat ( PRAEP ) \] else translat ( PNG ) = --\[ translat ( Y ) translat ( N ) \] else if cat ( translat ( ? RAEP ) ) = LTERM then translat ( PNG ) =\[\[ QUANTEIN \] translat ( PRAEP ) \] else translat ( PNG ) = --\[\[ QUANTEIN \] translat ( N ) \] As with the rule for N the else-part is omitted here too  . 
Applying these TR-rules to the section of the parse tree of fig  . 2 represented in fig .  3 , we get as translation of this section :\[ LAMBDA X  . BETR\[BETRIEBX . INDUSTRIE\[~AMBDAX . ORT\[INSTUTTGARTX . ORT\]\]x . BETR\]\]--399--

Betriebem Stuttgart plants in Stuttgart
Figure 3
Transformation of the networks into contextfree _productiOns The first step is to produce sets of productions by means of the inscriptions of the nodes and edges  , the right hand sides of which consist of at most two symbols  . 
s ? VERBS/VKIS/VK
S/VK ? NGS/VKPNGS/VKAUXHS/~\]?S/S
S/AA+NGS/AAPNGS/AAHS VKS/VERB
S/VERB ?? S/S
S/S ?
PNG+PRAEPNG
NG ? DETNG/DET\[NDETNG/DET\[NG/DET
DATUM SZA HLNG/NG
NG/DET ? NNG/NG\[NPRNG/NG
NG/NG ?
HSVK?VERBHS VK/VK\]H SVK/VK
HSVK/VK ? ?
In the next step the sets of productions are combined for each network to a single production the right hand side of which consists of a regular expression  . The set for PNG is duplicated , omitting PRAEP , to get a separate production for

S ? ( VERB le )   ( NG\]PNG )  @ ( AUxH ( NG\[PNG ) eHSVK ?\[? ) PNG ? PRAEP ( (DET\]WDET \]? )   ( N\] NPR ) \] DATUM SZAHL ) NG ? ( DET\[WDET\[? )   ( NINPR ) IDATUM SZAHL
HSVK?VERBI ?
NOW these productions are transformed step by step into " disjunctive normal form "  , where sequencing ( represented by Juxtaposition ) corresponds to the logical " and " , \[ corresponds to the logical " or " . 
S ? ( VERB\[E )   ( NG ePNG e ) e ( AUXH ( NG ePNG e ) eHSVK ?\[? ) e e % m e S ? ( VER Be ) (NG PNGe ) eAUXH ( NGP NG ) HSVK ? I ( VERB ? ) ( NG PNG ) ? S?VERB ( NGePNG~ ) wAUXH ( NGePNGe ) eHSVK?I ( NG WPNG e ) ~AUXH ( NGePNGe ) eHSVK ?\]
VERB(NG ~ PNG ~)% ? I(NG ePNG e)e?
PNG?P~EP(DETIWDETI~)(NINPR)I
PRAEP DATUM SZAHL
PNG ? PRAEPDETNIPRAEPWDETNIPRAEPNI
PRAEPDETNPR\[Pm~EPWDETNPRI
PRAEPNPR\[PRAEPDATUMSZAHL
NG ? DETNIWDET NINIBET NPRIWDET NPRI
NPRIDATUM SZAHL
Finally those parts provided with e are removed introducing new symbols and productions  . 
S?VERBNG/PNG AUXHNG/PNGHSVK?I
NG/PNG AUX HNG/PNGHSVK ? I
VERBNG/PNG?ING/PNG ?
NG/PNG ? NGNG/PNG\[PNGNG/PNGINGIPNGIcIf we form sets of productions out of the word classes  , we get aloge ther :
S?VERBNG/PNG AUXHNG/PNGHSVK?I
NG/PNG AUX HNG/PNGHSVK ? I
VERBNG/PNG?\]NG/PNG ?
NG/PNG ? NGNG/PNG\[PNGNG/PNG\[NG\[PNG\[ PNG ? P ~ EP DET NIP ~ EP ~ ETNIP ~ EPN\] 
PRAEP DET NPR\[P ~ BP MET NP RI
PRAEP NPRIPRAEP DATUM SZAHL
NG ? DET NIW DET NINIDET NPRIWDET NPR 1
NPR\]DATUM SZAHL
HSVK+VERBI e
AUXH ? hab
DET ? der die I des\[sinIeine
N ? Probe Probenehmer I Jahr I Betrieb I
Firma Arsen
NPR ? Stuttgart \ [ Zimpel IL auxmann
PRAEP ? in Ibei
VERB + enthalt Iprfif Izieh
WDET+welch
The parsing of our question example by means of these productions yields the parse tree of fig  . 
4 . The section of this tree corresponding to that of fig  . 3 is represented in fig .  5 . 
Providing the productions with attributes We will now give a list of attributes and semantic functions for the productions and augment the productions by them such that the evaluation of the semantic functions yields the translation of the sentence  . We will do this only for those productions needed for the section of fig  .  5 . 
--400--welche Betrie be which plonts hat has



Stuttgart in d;s Jahr
Stuttgart in the year
Figure 4
NGT NG/PNG/in Stuttgart in Stuttgart
Figure 5
VERB'Ipr~f inspect , NG name+val+tree+tree % pos name cat sort symbnt hvalu ~ del class synthesized synthesized inherited inherited 
Attributes domain n-tuple of KS-expressions ( translations )  , in general n = 1 1 sets of triples , consisting of the position of a symbol in the parse tree  , the symbol itself , and the value of the symbol same as with + tree finite sequences of positive integers  , separated by dots mnemo-technbcate ~ gory sort symbol nth  ( = last elemen value delete
Semantic functions argument translation t translation t position 
P position
P position
P position
Puse yields the KS-syntactic category of t yields the sort of t yields from % tree the symbol of the node with position p yields the last integer of p yields from + tree the value of the node with position preplaces in + tree the value of the node with position p by + val is the most important attribute  , for it contains the translation of a node . The other attributes are auxiliary attributes . + tree contains in each node a relevant section of the parse tree with all necessary informations about the nodes of that section  , namely their labels and their values . Already Knuth ( \[ Kn68\] ) has given a technique for representing the attribute values of all other nodes at each node of the tree  . We adopt this technique herein a slightly modif ie dway since it offers an elegant way to rewrite the conditions of the TR-rules as expressions containing semantic functions and attributes for appropriate productions  . We will illustrate how this technique works , using the structure of fig .  5 . The only information we are interested in for this example are the labels of the nodes  . Let
X ? + X IX 2 . . . Xn(n ~ O ) be a production , where the X . ( i = l , . . . , n ) are terminal or nonterminal symbols . If n = O , X is terminal . Then : o--401--+pos ( Xi + tree ( X ) =- o + tree ( X )  , if X  #So + tree(X . ) , if X ? = S1 o\[(+pos(xo) , xo)n+tree(X ) = o
UU + tree(Xi ), if X ? #Si = ln
U+tree(X')'ifX = Sloi = l
We can easily obtain the + pos-value for each node of fig  .   5 beginning with the NG/PNG-node which is dominated by the S-node and for which we assume :+ pos  ( NG/PNG ) = k . The + pos-values are given in fig .  6 . Using these values , we obtain e . g . 
+ tree(PNG ) = ~ k . 2  . 1, PNG ), ( k . 2 . 1 . 1, PRAEP ), ( k . 2 . 1 . 1 . l , in ), ( k . 2 . 1 . 2, NPR ), ( k . 2 . 1 . 2 . l , Stuttgart ) The + tree-value for NG/PNG ( and thus for all other nodes ) is + tree ( NG/PNG )  =  ( k , NG/PNG ) , ( k . i , NG ), ( k . l . l , N ), ( k . l . l . l , Betriebe ), ( k . 2, NG/PNG ), ( k . 2 . 1, PNG ), ( k . 2 . 1 . 1, PRAEP ), ( k . 2 . 1 . 1 . l , in ), ( k . 2 . 1 . 2, NPR ), ( k-2 . 1 ? 2 . i , Stuttgart ) In order to obtain the values of attributes de -fined for the productions it is often necessary to determine a new position starting from a given one  . For this purpose some of the integers at the end of the position must be omitted or others must be appended  . If the last integer of the position belonging to symbol X shall be omitted we write = " NG ~ NG /PNG  , ! , pos = k . 1 ~ pos = k . 2 ~ pos=k41 ~ PNGk-2 . 1
Betriebe PR/AEP ~ NPR in ~5 tuttgart , I , pos = k . 2 . 1 . 1 . 1 Spos = k . 2 . 12'1
Figure 6+ pos(x)-i
If the last two integers shall be omitted , we write+pos(X\]-2 etc . If an integer , say k , shall be appended j times , we write + pos ( X ) ' kj Now we are ready to give the productions needed for the structure of fig  .  5 , provided with attributes and semantic functions . 
N ? Betrieb if symb(+pos(N)-l ) ENG , PNG Asymb((+pos(N)-2) . 2  . 1) = NG ^(( symb (% pos(N ) . l ) eMonat , Jahr ) A3j > O : cat(value((+pos(N)-2) . 2  . l . j ) = KONST ^ sort(value((+pos(N)-2) . 2  . 1  . j )) = INT ) v(3j > O : symb((+pos(N)-2) . 2  . l . j)EN,NPR^cat(value((+pos(N)-2) ? 2 . 1  . j )   ) = TERM^cat ( value ( + pos ( N ) ? i )   ) = LTERMA sort ( value ( + pos ( N )  ? 1  )   ) = sort ( value (   ( + pos ( N )  -2 )  ? 2 . 1 ? j ) ) )   ) then + val ( N ) = else if sort ( value (   ( + pos ( N ) - l )   . 2  . 1 )   ) = INDUSTRIE - - then if 39 >0: symb ( (+pos ( N ) - l )   . 2J . l ) = PNG sort(value((+pos(N)-l) . 2J . l )) = ORT then + val(N ) =\[ LAMBDAX . BETR\[BETRIEB value((+pos(N)-l) . 2 . 1) value ((+ pos(N)-l) . 2J . l ) ? . BETR\]\]del((+pos(N)-1) . 2 . 1) del((+pos(N)-l) . 2J . l ) else+val(N ) =\[ LAMBDAX . BETR\[BETRIEB value((+pos(N)-1) . 2 . 1) x . oRTX . B ~ TR\]\]del((+pos(N)-l ), 2 . 1) else if 3 j > O : symb((+pos(N)-l) , 2J , l ) = PNG sort(value((+pos(N)-l) , 2J , l )) = ORT then + val(N ) =\[ LAMBDAX . BETR\[BETRIEB
X . INDUSTRIE value ((+ pos(N)-l)o2J,l)
X . BETR\]Idel((+pos(N)-l) , 2\ ]  , l ) else+val(N ) =\[ LAMBDAX . BETR\[BETRIEB
X . INDUSTRIEX . ORT
X . BETR\]\]+tree(N ) = (+ pos(N) , N , + val(N )) , (+ pos ( Betrieb ) , Betrieb , ~) + pos(Betrieb ) = + pos(N ) . l The first part of the expression needed to determine the value of + val  ( N ) comes from the TR-rule for N , the second part from the TR-rule for
Betrieb ( plant).
For the symbol NG there is a TR-rule too . We omit it here , because it does not apply to our example . Therefore we deal with the production NG?N in such a way  , as if there were no TR-rule for NG . 

NG ? Ni_~value ( + poe ( N ) ) = ~0 then + val ( NG ) = else+val ( NG ) = + val ( N ) + tree ( NS )  =   ( + pos ( NG )  , NG , +vai ( NG ) )  U + tree ( N ) + tree ( N ) = + tree ( NG ) + poe ( N ) = + pos ( NG )   , i
PRAEP ? in if symb ( +pos ( PRAEP ) - l ) = PNG then if Hj  #nth ( 4-poe ( PRAEP ) ) : symb ( (+pos ( PRAEP ) - l )   . jeN , NPRAsott ( value (   ( + pos ( PRAEP )  - 1  ) ? j )   ) = ORT then + val ( PRAEP ) =\[ LAMBDAX . ORT\[IN value((+poe(PRAEP)-i ) ? j)
X . ORT\]\]dei (   ( + pos ( PRAEP ) - i ) ? j ) else if 3 j  #nth ( + pos ( PRAEP ) ) : sort ( value ( (+ pos ( PRAEP ) " i )   . j )) g_INT then + val(PRAEP ) =\[ LAMBDAX . INT\[INTEMP value (   ( + poe ( PRAEP ) - i ) ? j ) x . IN ~\]\] del((+poe(PRAEP)-i) . j ) else if ~ j > O : symb((+po . s(PRAEP ) -2) ?23 . 1) = NG sort ( value ((+ poe(PRAEP)-2) . 2J . i ))_~ INT then + val(PRAEP ) =\[ LAMBDAX , INT\[INTEMP value ((+ poe(PRAEP)-2) , 2J*l ) X . INT\]\]del((+pos(PRAEP)-2) . 23 . i ) else+val ( PRAEP ) = else+val ( PRAgP ) = 0 ~+ tree ( PRAEP )  =   ( + poe ( PRAEP )   , PRAEP , + val(PRAEP )) , (+ poe(in ) , in , 00) + poe(in ): + poe(PRAEP ) ' I
NPR ? Stuttgart + val ( NPR ) = STUTTGART + tree ( NPR )  =   ( + poe ( NPR )   , NPR , + val(NPR )) , (+ poe ( Stuttgart ) , Stuttgart , 0 ~) + poe(Stuttgart ) = + poe(NPR) . I
PNG ? PRAEP NPR if ~ j > o : symb(+pos(PNG) . j ) = N cat ( value (+ pos(PNG ) . j )   ) ~ KONST then if 3i > O : symb ( + poe ( PNG ) ? i ) EDET , QDET , WDET , 
NEG DET , ZAHL cat ( value ( + poe ( PNG ) ? i )   ) = QUANT then if cat ( +val ( PRAEP ) ) = LTERM then + val ( PNG ) =\[ value ( % poe ( PNG )   . i ) + val ( PRAEP ) \] del ( + poe ( PNG ) ? i ) del ( + poe ( PRAEP ) ) else + vai ( PNG ) =\[ value ( +pos ( PNG )  . i ) value (+ poe(PNG ) . j)\]del(+poe(PNG ) . i ) del(+poe(PNG ) . j ) else if cat ( + val ( PRAEP ) ) = LTERM then + val ( PNG ) =\[ EIN+val ( PRAEP ) \] del ( + poe ( PRAEP ) ) else + val ( PNG ) =\[ EIN value ( + poe ( PNG ) " j ) \] del ( + poe ( PNG )   . j ) else if + val ( PRAEP ) = ~0 then + val ( PNG ) = + val ( NPR ) else+val ( PNG ) = + val ( PRAEP ) + tree ( PNG )  =   ( + poe ( PNG )   , PNG , +val(PNG ))
U + tree ( PRAEP ) U + tree ( NPR ) + tree ( PRAEP ) = + tree ( PNG ) % tree ( NPR ) = + tree ( PNG ) % poe ( PRAEP ) = + poe ( PNG )   . i + poe(NPR ) = + poe(PNG ) . 2
NG/PNG ? PNG if value ( + poe ( PNG ) ) = ~0 then + val ( NG/PNG ) = 0 0 else + val ( NG/PNG ) = + val ( PNG ) + tree ( NG/PNO )  =  ( + pos ( NS/PNS )   , NG/PNG , + val ( NG/PNG ) )  U + tree ( PNG ) + tree ( PNG ) = + tree ( NG/PNG ) + poe ( PNG ) = + poe ( NG/PNG )  ? 1
NG/PNG1 ? NGNG/PNG ~ if value ( + poe ( NG ) ) = then + val ( NG/PNGi ) = + val ( NG/PNG2 ) else if value ( + poe ( NG/PNGs ) ) = 0~ then + val ( NG/PNG1 ) = + val ( NG ) else+val ( NG/PNG1 )  =  ( + val ( NG )   , + val ( NG/PNG ~ ) ) + tree ( NG/PNGI )  =  ( + poe ( NG/PNG1 )   , NG/PNG , +val(NG/PNG1)) U+tree(NG )
U + tree ( NG/PNG2 ) + tree ( NG ) = + tree ( NG/PNG1 ) + tree ( NG/PNG2 ) = + tree ( NG/PNGI ) + pos ( NG ) = + pos ( NG/PNG1 )  . I + poe(NG/PNG e ) = + poe(NG/PNG1) . 2 With these product ions we obta in immediately the value of the + tree-attribute for each node of the structure of fig  . 5 or 6 , when we postpone the evaluation of the + val -attribute  . The value is ( k , NG/PNG , + val(NG/PNG )) , ( k*l , NG , +val(NG )) , ( k . l*i,N,+val(N )), ( k . l . i . l , Betriebe , 00), ( k . 2, NG/PNG , + val(NG/PNG )), ( k . 2 . 1, PNG , + val(PNG )), ( k . 2 . 1 . 1, PRAEP , + Vai(PRAEP )), ( k . 2 . 1 . 1 . l , in , ~), ( k . 2 ? i?2,NPR,+vai(NPR )), ( k . 2 . l . 2 . l , Stuttgart , ~ ) The production NPR+Stuttgart yields+val ( NPR ) = STUTTGART We can substitute this value in % tree or regard "+ val  ( NPR ) " as a pointer to this value . Now we try to determine+val ( PRAEP ) from the production
PRAEP ? in . First we have symb(+pos(PRAEP)-l ) = symb(k . 2 . 1 ? l-i ~= svmb(k . 2 . 1) = PNGThat is , the first condition holds . Next nth (+ poe(PRAEP )) = i therefore j > l . Assume j = 2 . Then symb ((+ pos(PRAEP)-l ) . j ) = symb((k . 2 . 1 . 1-I ) . 2) = symb(k . 2 . 1 . 2) = NPR--403--
Further sort ( value ((+ pos(PRAEP)-l) . 2)) = sort(value(k . 2 . 1 . 2 ) ) = sort ( STUTTGART ) = ORT The second condition holds too , thus we get+vai(PRAEP ) =\[ LAMBDAX . ORT\[INSTUTTGARTX . ORT \]\] Within the production PNG ? PRAEPNPR the first condition needed to determine+vai  ( PNG ) does not hold , so we get % vai ( PNG ) = + val ( PRAEP ) If we assume these values to be substituted in + tree  , we now have the intermediate result ( k , NG/PNG , +vai(NG/PNG )) , ( k*l , NG , +val(NG )) , ( k . lol , N , + val(N )), ( kolol . l , Betriebe , ~), ( k . 2, NG/PNG , + vai(NG/PNG )), ( k . 2 . i,PNG,~LAMBDAX . ORT\[INSTUTTGARTX . ORT\]\]),(k . 2 ? l ? l , PRAEP , LLAMBDAX . ORT\[INSTUTTGARTX . ORT\]\]),(k*2 . 1 . 1-l , in , ~), ( k . 2 . 1?2, NPR , ~), ( k ? 2*1 . 2 . i,

It is left to the raeder to compute the final result applying the remainding productions  . 

We have illustrated how an attribute grammar can be produced from the networks and TR-rules used within PLIDIS  , which has the same expressive power as the underlying networks and rules  . The advantages of the ATN-grammars for the parsing of natural language sentences are well known  . 
Above all they are an elegant tool to write grammars especially suited for linguists  . The eTR-rules have advantages similar to these . Surely they are easier to write than the somewhat cumber some expressions for determining attribute values  , particularly those for the ? val-attri-bute . In the TR-rules , however , attempt is made to describe and deal with all possible occurren-ces of a symbol  . With the attributed productions tb is is not necessary  , since for a single production some of the cases which stem from the possible occurrences of one or more symbols can be omitted a priori  . For example , in the production PNG+PRAEPNPR the whole first part for determining + vai  ( PNG ) can be omitted , because the first condition does not hold for this production  . In a similar way we can omit some part in the production N ? Betrieb  . Further improvements can be made by changing the productions themselves  , e . g . by partly eliminating those symbols which denote word classes  . Performing all possible improvements certainly leads to an attribute grammar which yields translations of sentences in a rather efficient way  . On the basis of this grammar we can detect circulari-ties which can occur in the translation process by means of well defined algorithms  ( cf . \[Bo76\]) . 
\[Ba 78\] \[ BW 78\] \[ Bo 76\] \[ Dz 7s  \] \ [~  6s \]\[ m 71\] \[ KL 79 \]\[ Wo 70 \]\[ We 73  \] \ [~  79 \]\[ Zi 77  \]

M . Bates , The theory and practice of augmented transition network grammars in : L  . Bolc ( ed . ), Natural language communication with computers
Springer Lecture Notes in Computer
Science , 63, 191-259, Berlin 1978
G . L . Berry-Rogghe/H . Wulz , An overview of PLIDIS , a problem solving information system with German as query language in : L  . Bolc ( ed . ), Natural language communication with computers
Springer Lecture Notes in Computer
Science , 63, 87-132, Berlin 1978
G . V . Bochmann , Semantic evaluation from left to right in : CACM 19  ( 2 )  ,  1976 , 5562 W . Dilger/G . Zifonun , The predicate cal-culus-language KS as query language in : H  . Gallaire/J . Minker ( eds . ), Logic and databases
Plenum Press New York , 1978, 377-408
D . E . Knuth , Semantics of contextfree languages in : Math . Systems Th . 2, 1968, 127-145 and Math . Systems Th . 5, 1971, 95-96 D . E . Knuth , Examples of formal semantics in : E . Engeler ( ed . ) , Symposium on semantics of algorithmic languages Springer Lecture Notes in Mathematics  ,  188 ,  212-235 , Berlin 1971
M . Kolvenbach/A . L6tscher/H-D . Lutz ( eds . ) KOnstliche Intelligenz undnat ~ r-ficheSprache
Forschungsberichte desInstitute f0r deutsche Sprache ,  42 , 
G . Narr-Verlag T fibingen , 1979
W . A . Woods , Transition network grammars for natural language analysis in : CACM  13  ,  1970 , 59~-606 W . A . Woods , An experimental parsing sy-stem for transition network grammars in : R  . Rustin ( ed . ) , Natural language processing Algorithmic Press New York  ,  1973 , 112-grammatik
Forschungsberichte desInstituteffir deutsche Sprache  ,  46
G . Narr-Verlag T fibingen , 1979
G . Zifonun , Die Konstruktsprache KS in : K . Heger/J . PetSfi(eds . ), Kasus-theorie , Klassifikation , semantische

Papiere zur Text linguistikii , Hamburg
