ANINTER ACTIVE P ~0 NO IE GICAL
RULE TE3TING SYST ~4
Victoria A . Fromkin

D . Lloyd Rice
University of California , Los Angeles
September 1969
One of them anyways the high-speed computer is useful to linguistic researchers is for the evaluation of generative grammars  . Several pro~-s~ing systems for this purpose have been described in the literature  .  1  , 2  , 3  , ~A transformational generative grammar cons ists of a syntactic component  , a phonological component and a semantic component  . This paper is concerned solely with the phono logical component  . While this component is a dependent part of the entire grammar  , systems of phonological rules for specifi clan-guages  , i . e , the phonological components of the graEmars of th ~selanguages  , have been separately presented by Chomsk ~ and Halle  5  , Kuroda , Schaohter and Fromkin 7 and others . The Sound Pattern of English 5( hereafter , ~ PE ) includes the ' formalism used for presenting phonological rules and the schemata that represent them  , and the interpretation of this formaliam '? ( p ? 390 ) This formal description is taken as the basis for the rule structures d/a-cussed in this paper  . 
Cho~sk ~ and Halle state that ' The rules of the grammar operate in a mechanical fashion  ; one my think of them as in struc~ns that might be given to a mindless robot  , incapable of exercising any ~ udsment or imagiluation in their application  . An ~ ambiguity or in explicitness in the statement of rules must in principle be eliminated  , since the receiver of the instructions is asssmed to ~ he incapable of uain ~ intelligence to fill in gaps or to correct  . 
errors ' ? They find it ' a curious fact ' however that ' this condition of preciseness of formulation ?  . .has led man ~ lin6uists to conclude that thenctivation for such grammars must be  . ?  . some . ? use of computers '? We also believe that there are more b~sictheoretical motives in clar ity and completeness  ; we furthe . r believe that this very explicitness makes possible the use of the computer fortes ti ~ such rules  . 
Furthermore , the complexities of natural language are ref lected in the component sphonological ru les  . Anyone who has attempted to teach a group of g raduate students the phonology of English  , using the rules pre-sented in a PE canattes t to the fact that even a single rule schema presents endless problems for the brightest of students when he attempts to expand the sche  . ~- and to apply this set of rules to convert an abstract ~ urface structure of a sentence into its phonetic representation  . While the liDguist or the student m~ybe possessed with greater intelligence than the mindless robot  , he is also possessed with human fallibil ity  , and limited time and energy . For these reasons , the mindless robot can perform far more effec tively than a Linded human  . The conq ~ ater program which is described in ~ paper was written to aid human phonologis ts in the writi ~ of rules  , the testing-2-of rules , and the teaching of phonology . The importance of such a computerized phonological rule teeter becomes very apparent when one selects at r-n~om any twenty-five English words  , attempts to provide what one assumes to be the underlying phonological representation  , and then applies the rules of SPE as spec if ied  . One of the authore of this paper made euch an attempt  . After more hours than she wishest or emember , and using every possible underlying segment , she found that eleven of these randomly chosen words could not be correctly derived  . Nor were these strange foreign loan words , unless one believes the word ' America ' to be an exceptional item in the Englieh vocabulary ? This example is not offered as a criticism of Sound Pattern of English  , probably the most important published book on English phonology and phonological theory  . Nor are we concerned here with any theoretical weaknesses which may or may not be present in this work  . What is apparent is that had a phonologic ~- I rule tester been used  , prior to the publication of this set of rules , many of the problems in rule order in E~omitted contexts etc  . could have easily been corrected ~ and those rules which present problems and which cannot work would have at least been revealed  . Furthermore , because of the speed of the computer , one could have tested not only twentyfive words , but hundreds -- determining the correct underlying forms of formatives  , and thereby providing a lexlc ~@ B ~ h the Pnle  ,   , o ~ operate ? A ~ er ~ t , ebl~s  ~ . ~ ed~n~i ~ up ? prod-as ~ or roach a tester is ~ h  , J ~$ a$~ . om ~ . oospro~seot ~ enn~esury betveen the computer input format the rule deeriptiom seh~suused by linguiste to express their phono-logica l rules  , The Phonological Rule Teeter of Bobrow and Fraser  8 solves this problem by offer in6 a variety of logical combinatorial devices which may be used to group either segments wi thina rule or complete rules for dis- junctive or conjunctive application  . Such a system has very general descriptive capability  , but complex rules appear in the computer input form rather different from the linguist's format  . 
In consideration of the deecriptive powers of euch systems  , it appears that the input format should be made as specific as possible to the proposed theoretical structure since a more general deecriptive scheme require etherule write r to learn n more powerful metalanguage than is needed  . This parallels the general direction of development of computer languages  ; from the general machine-oriented coding to the specific problem-oriented languages  . 
This paper describes the translational core or compiler of a system which accepts phonological rules in a format very close to that formalized in The Sound Pattern of English and produces as output the coding similar to phone '--- tic segments necessary to evaluate the input rules in a phonological testing program  . The input format of this system is especial ly applicable to keyboard entry on a CRT graphic terminal such as the IBM  2260 and is planned for possible use in an online class room system for teaching the properties and operation of the phonological component  , as well as for the writing and testing of phonological rules by the linguist  . 
The rule testing program consists of an ' input block  , a sequence of phone-logical rules , and a print out block ( see Figure i ) . The input block will accept a string of characters from the operator's console representing the underlying form of a word or phrase or an ~ form assumed to occur in a derivati?n  -3-in the phonological component . This form is then tested against the environmental conditions specified by the stored rules and modified according to those rules whenever a match is found ? The string of phonological units  , i . e , segments and boundaries , and/or the binary matrix resulting from the application of any rule may be optionally displayed on the operator's console after the application of that rule  . 
Rule Specifications ICompiler input R1   R2 form --- ) 
EIPrint out
A Block ~3
Figure 1: The Phonological Rule Tester
The structure of the program is such that any rule or sequence of rules can be tested using the same input and output blocks  . The rules initially coded for testing and described in this paper are taken from Cholu ~ y and Halle  ( 1968 ) o The program however , is not limited to these particular rules , but can be used to test any set of rules comprising the phonological component of a generative grammar  . 
The Input Format for Rule Description The input to the phonological component consists of as t ructurally analyzed string consisting of syntactic brackets  ( e . g . Noun Phrase , Noun , Adjective , Verb etc ) , segments , and boundaries . The segments and boundaries are composite feature bundles  . 
The system used in our Phonological Rule Tester specifies these units in any of several ways : a  . As a combination of uppercase alphabetic characters representing the various phonological segments defined in the system  ; b . As a cluster of distinctive features pec ifications enclosed in angle brackets  . These may be spaced horizontally or vertically , i . e . I <+ voc-cons-round ) < ? voc > <- cons > <- round > , but are to be considered simultaneously an a cluster rather than con-Junctively as in the square bracketed series  ; c . As a sequence of segments of specific predetermined types  ; ' ~" indicates a ~ vowel segment , i . e .   , defined as + voc ' ~" indicates a ~ rnon Vowel: se Blent  , i ? e . a true consonant , a liquid or aglide , i . e .   , defined as either-vocor+cons , ' ~" ~ dicntesa ~ sequence of units not coat at ~ n ~ the boundary unit #  , i ' ~" indicates as t ~ of at least i consonants  , i , j ' ~" indicates a str in8 of at least i and not more than j consonants , d . As any of several boundary units # ,  + , or = , which Si ~ Dify themselves ? e . ass combination of brackets and upper-case a lphabetic characters representing the ~ tacti c brackets defined in the system  . 
Rules in the Phon ~ osical Component are of the form 
A--B/X--Y where ' A and B are single un its or the null element  ; the arrow stand ~ for ' is actuai Lized by ' ; the dia ~ 0n ~ line mean ~' ~ n the context ' ; and I and Y represent respectively , the left and r~hth and environments in ~ nickA appears  . These ~ ralsobenu ~ , or may con~at of units or str~s of units and include labeled syntactic brackets  . 
Our ~ ystel accepts rules written in th ~ format  , i . e . 
L~--I~3/context specif~ntion.
A rule is applicable if the IN3 latches some unit ' in the test str in8 and any context specified in the rule is found to exist at or adjacent to the matched unit ? The context specification ma ~ consist of an ~ sequence of one or more unit s  , and enmt include a marker--to indicate where the LHS fit ~ in-to the specified context  , or more exactly , how the enwironment must be con-figured around the matched unit in order for the ru ~ e to be applied ? In the l~hon ~ Logkal Coll~nent of a ~ ran~r  , two partial ~ identic ~ rules marbe coa lesced into a ~ erule ~ aeq ~_ ~ yenclos ~  . the cozTespo ~ ling non-identical parts in b races  , i ? e . A--B/--~\[ . Schema Ue Lt~m~h braces coales ceacon ~ unctive sex~es of r~esoTherg~e ~ areap ~ edimorder ? A conjunctive series of unit ~ is written in our program as a vertical list bounded left and r~ht by columns of left and right square brackets  . T~s corresponds to the braces ? For example , given the phonolo ~ cal rule ( 1 )   ( 1 ) V--V--\[+S~aX\] has the interpre ~ at lont hat the rule will be t~ed first with the contexts psc -ificationoo as ~ tin ~ of theae ~ mnt ~ rmbo \]  . ized as N(i . e . na ~ al ) , and then with the context coas~t ~ of these /paent V  . 
In our system a rule co~a ? on ~ u ~ tive series is matched against the test stri~taking each of the conjunctive item in the order they appear in these r~es  , app ~ in @ the rule ~ llediately a I ~ time the match ~ stri ~ in-cluding the current item matches the appropriate portion of the tests tr  i=8o In the phonolo Eica Itheory ~ derl ~ ing our 6ystem   , rules la ~ also be disjunctive \] ~ ordered  . Such rules are represe ~ edin schema by the use of parentheses and anted brackets  . 
A disjunction is written a sam ~ to r sequence of units enclosed in parenthes~s ? It differs from the conjunctives er~es in the sequence of ap-p\]-icability to a particular test stz ~ J  ~  . Ad~m ~ unction is matched ms ~ ins the -5-tes t string by considering first the conteXt including the disjunctive item  . 
If this match is successful the rule is applied and no further matchi ~ is at tempted  . If the first match is unsuccessful , then the aatch is attempted omitting the d is junctive item  , applying the rule if a match is found . 
Clearly , the conteXt must specify exactly one relat ive position of the LHS  , marked by the double dash ,  - -  . Thus , the LKS position marker m~y be in a conjunct iveseries if it appears once in each item of the series  , but it may not occur inside a disjunction . 
The items of a conjunctive series or of a di sjunction may in turn include either con junctive series or disjunctions  . Conjunctive series must be written with the bracket columns eXtending below and not above the line external to the conjunction  . Extra spaces m~7 be included either horizontally or verti cally for clarity and in some eases may be needed for disambiguation  . 
Rule ( 12 ) from SPE would be expressed as follows in this system :\[~-- Ere\]\]#~w/\[\[  ( Jr \] ) \]\]\[\[\[ Zm\]#\]\]\[\]\[ ( * round-VOC+cons > --\] A context specification may conoist of stacked contexts according to the convention that 
A--B/D--E/C--F is interpreted as
A--B/CD--EF .
System Structure
The rule testing program proper consists of 4 sections . They are : 1 . the system storage definitions which in c lude definition of the feature set used  ,  2 . the mechanics necessary to accept an input form and setup the test matrix with the features of the input form  ,  3 . a rule test loop which controls cyclico rdering  , and 4 . the routines to print out the results , either in segment string or in binary matrix form  , following the application of at ~ rule . The rules are then included as blocks of coding inserted andesired in the test loop  . 
Initially , four values are defined which determine the size of the various tables and matrices in the system  . 
DECLAREL (6O ) CHAR(2);
DECLAREF (60,20), M(50, 20) BIT(I);
DECLAREs (5o)F ~;
The amount of memory reserved may be easily changed by alter i ~ only the lines def in ing the size limits  . 
An array L of CHARACTERSTRING variables is declared to have length  60 and a logical matrix F is declared to have a length of  60 coluwns , each column having 20 elements or bits . Immediately after program execution has be Eun  , in-put of the feature set is requested . The feature specification consists of the  -6-character representation for each phonological unit fol~ded by at least  1 space followed by an ordered string of ?' s and -' s corresponding to the feature value assignment  . The ordering is a 6 in Table 2 below . The character representation of the nth unit entered is stored in the nth element of thes tring array L and the feature value a ares to red as l's and O's in the nth column of the feature refere ~ e matrix F  ( n 60 )   . If less than 20 binary values are specified for a ~ unit the remainder of the column is filled with O's  ( i . e . -' s ) . Table 1 is a listing of the units and feature va lues used for testing the rules of Engliah in the present study  ( from Cho~asky and Halle ,  1968) . 

Symbol bZ
II




OE %%


E &&&
W ?










UnitSymbol ++ -+ + .   .   .   . +( T ) TH ++ -+ .   .   .   .   . +( T ) DH ++-++---++(~)++ .   .   .   .   .   .   .  +  ( ~ ) S + + - - + - - - + 4 - - ( ~ ) z4-4---4----4- ( ~ ) C4-+--4-4---+ ( Z ) t i t ? 4----+--++ ( ~ ) a ++ --++--4-+ ( ~ ) SH++-4- .   .   .   .   .   . ( i ) ZH ++ -4-+---+-( u ) + + .   .   .   .   .   .   .   . ( e)C4-+--4- .   .   .   .   . ( A ) X ++ --+ .   .   .   . +(7) ~: C+4---+---+-(o)H+4----+ .   .   .   . ( ~) k'w ++ --++--+-(=) ~, . ~ 4---+  .   .   .   .   .   . ( y)~,~+--4-+---+-(~)++ .   .   .   .   .   .   .   .   .  (~) ++- -++  .   .   .   . ( o)#+4-+ .   .   .   .  4 - - -++- -  ( r )  \[ +++-- -++- -++- -  ( I )  \] +-+- - -+  .   .   .   .   .   .   .   ( ~ ) b+-+---4---+--- ( o ) \]A + -?---+ .   .   .   . ? -+( f)\]V + -+---+---++-+( v )!: ; + -+---+---+-+-('~) i ~'+-+---+4- .   .   .   .   .   . ( t ), :4--4---???-+---(~)+--+---- . ++------+----+--+------++----++----+--+-- . --++----+--?--+--+--- . ?+------+--+ +--?---- . ++----?+--+ +--+------++  .   .   .   .   .  + + -++------+  .   .   .   .   .  ? +-4-+------+----+----+ 4---4-4-------+------+-+ +--4-4-------+----4-+--+ +-+++  .   .   .   .   .   .   .   .   . 



Unit ( e )   ( 5 )   ( n )   ( s )   ( z )   ( c )   ( ~ )   ( 7 )   ( ~ )   ( k )   ( g )   ( x )   ( rj )   ( h )   ( kW )   ( x " ) 
T~DIei : Unit Feature Values-8-
In order to generate computer instructions as necessary to man-ipulate the values in the b in ary matrix  , the rules as specified above must be made compatible with the requirements of the in ternal logical structure of the computer  . This is accomplished through a compilation process on the above rules  . 
A logical matrix M is delcared to have a length of  50 columns , each column having 20 elements . The Jth feature in the Ith column is refer red to with the notation M  ( I , J ) . The value of each M(I , J ) may be either O or 1 , representing logical False or True ( the feature value - or + ) respect viely . 
The input string ( the form to be tested ) is then stored as a pattern of features in the test matrix M such that each unit occupies one column of the matrix  , allowing the entry of a~7 string of segments and boundaries up to length  50  . The features for each unit are stored in the corresponding column of M by transferring the values from the appropriate column of the previously defined feature matrix F  . 
Symbols were chosen to have mnemonic value rela ting to the features used  . These symbols are assigned values corresponding to the row in the matrix 
F having that feature value.
Value Symbol Feature Represented 1 SEG segment 2 VOC vocalic 3 CONS consonantal 4 ~ ~ GH high 5 ~ CK hack 6 LOW low 7 ANT anterior 8 COR coronal 9 ROUN Dround
I 0 TENSE tease ii VOICE voice 12 CONT continuant 13   N1 NASAL nasal 14 STRIDs trident Table 2: Feature Values in Matrix Rows Several more rows of the matrix M are delcard so that they area -vailable for specification of diacrit ic information about each unit  . The number of such spaces is determined by the declared size of  20  , the column height . Table 3 defines six add i ~ donal matrix rows . 
Value Symbol Diacritic Represented 15 FLAG 20 Rule 20   16 FLAG 30 Rule 30   17 FLAG 32 ' Rule 32   18 FLAG ~ ~ ule 19 DMSRD ( see Main Stress Rule ) 20 FVSRF ( see Vowel Shift Rule ) Table 3: Diacritic Feature Value in Matrix Rows -9 -A ~ additional row associated with M is delcared to have length  ~0 and elements which sa ~ have a e ~ integer va lue  ( up to the computer word size )   . 
This row has the ~ jmbolS and is used to store the stress value assigned to each unit  . The stress on the Ith unit is referenced by the notation S  ( I )   . 
The value O is initially stored in the array S for all units entered  , which represents f-stress \] for all uni ts  . This is very convenient from the point of view of the programming language as an integer value O is also logical  0 while any integer value greater than zero is read as logical  1  . It is plan-ned at a later date to be able to enter a nonzero stress value for any uni t in the input string  . 
A w~7 was needed to store the information in the matrix represent in  6 boundary units and the syntactic bracketing of the input string  . Because the previously described distinctive feature set has the common feature \[? segment \] it is clear thnt the positions in a column of the matrix representing this feature set need only be so defined when the first position has the value ~? seEment \]  . When the first element in a column has the value I-segment \] the next  13 spaces are in effect free to be defined so as to represent the boundary unit information  . Thus a duplicate set of values are defined on the matrix as in Table  4  . 
Value Symbol Feature Represented 1 SEG segment 2 FB formative boundary ( i  ~ ) 3 WB word boundary ( WB )   4 BRAC 10~e~ket   5 HBRAC right bracket 6 NBRAC noun bracket 7 ABRAC adjective bracket 8 VBRAC verb bracket 9 SBRAC stem bracket i0 PBRAC prefix bracket Table 4: Boundary Unit Feature Valuesi ~ Matrix Rows Positions  4 through IO representing bracket in ~ informatio ~ are de-fined only in case the feature set Fsegl occurs in  posi~on8   1 through 3-  -~ ~ -
L+WBJ
Presence of bracketing 4~(I , BRAo ) -l ) then implies occurrence of the word boundary # . At present ,   4 spaces remain in the matrix column for addition of syntactic  marker8 other than those defined here . 
When entry of the segmental form to be tested i scomplete and before the test cycle is begun  , the matrix positions correspond in E to the diacritics Rulen  ( FLAG20 through FLAG 34 ) are set to i . 
At a point within the test sequence when the adjustment rules have been applied  , the test string is scanned and the bracketing is located  . A pair of pointers , LEFT and RIGHT , are set to the left and right innermost brackets . If no brackets are specified in the input form , brackets are added-lO-to the left and right ends of the form as referents for these poin ters  . Corresponding to the cyclic order of applica tion ~ the phonological rules  , all rules begin with environmental scratch at I ~ and continue right to RIGHT  . This is accomplished in the progr ~ lance ~ thn DO-E~state-ment pair as follows: 
DOI = LE~TORIQRT ; ? ~ s block of cod ~ is executed repeatedly ? with I = LEFT  , LEFT ? l ,  ~ +2 ,   . . . . l~(~r ; AD ~ reference to I~th in the DO-loop range uses the current value of the variable ~ for that repetition of the loop  . 
Because several of the rules needed for the phonetic specifications in a ~ m Eunger equ i re~ertion or deletion of phonological un its in the atring  , it is desirable to be able to print out the results of the application of an ~ rule after that rule has been applied to the str ~  . Tl ~ aability has been provided in the present program with the character ~ tic that the result sma ~ be optionally printed after the application of o ~ rule in the test sequence  . 
Rule Codin ~
Wem~now conmider the codinK for one of the ru lest obe proK ro~ed ? In rule  32  , Glide Voca ~ izatio ~ we have the specific at ion  ; First ) the Ith unit must be checked to see if it has the feature \  [4~e~ent \]? If not , the scan is continued to the next tmit ? If it does  , also continue the scan . ~tL % s ~ represented by the fo~o ~ JJ ~ co ~?
DOI . LEFTTORI ~
IF7 M(I , Sg ) then go to end 32
IFM(I , C1 ) 7M ( IoB ~ ) then go to end 32 oe o end 32: end ;   (   PL/1 uses the synbol 7 for ' I~OT " and 1 for ' DR " ) Thene ~ step is to determ ~ the ~ currence of the environment 
Y-ll-vention that any rule be interpreted as applicable in the presence of the format ive boundary +  , which has the features F ~ gl in any case in wh ~ h the 
L rule is other ~8 eapp ~ able . That is , no rule should be blocked by the pre-sence of + in  an7 context where that + is unmarked in the envi ronmental con-ditions  . On the other hand , if the + is marked in the environmental spec if i cat in it must be present in the stri ~ before that rule is applicable  . 
From the preced ~ discussion we see that the environment for this rule must be in terpreted as To reference an ~ unit a fixed distance to the left or NOt of the current lyscanned unit I  , it would be possible to add or subtract a constant to the column pointer I  . That is , M(I-1 , J ) would reference the unit ilnnediately to the left of l  . In this case , however , the unit in question may be either 1 or 2 spaces to the left of I , depending on whether the unit at I -1 has the features ~- seg 1   . Actually , it is necessary to check only the first 2 features\[~~ , \]~-2t~eset ~ ,  \ ]  . is not defied i ~ the , t?o cabu ~ Lr 7I ~ Id , be assumed not to oc?ur . A act of pointers is available to indicate the d ~tanceOf the desired unit fron the current lyscanned unit  ,   L1   throughL9 for distance to the left and rethrough I ~ for distance to the right  . These pointers , when used in a rule , are initially set to 1 at the be Einning of the enviromlent ~ search in each ~ a trix position ? With this convention t  T-L1 initially refe~l to the unit immediate ly to the left of the Ith unit  . If the unit I -1 is found to have the features of the formative boundary + then  L1 is 8e ~ equal to 20 I-L now refers correctly to the segment o be checked for the environmental con-dition specified  . 
DOI . LEFT~O ~ TC~T
L1-1;
IF ~ M(I , SE ~) the Eoto end 32; 1FM(I , COL~~M(I , BACK ) then end32; IFM(I-1 , SEG ) and M(I-1 , FB ) the L1 . 2;-12-If M(I-LI , RODND)IZM(I-LI , HIGH ) the go to end 32 ; IV\] is defined to be the coincidence of the features \[+ vocalic  1 
L-conso as ntal J which may be checked simply in one statement  , while application of t ~ is rule specifies the value assignment M  ( I , voc ) = l . Following application of the rule the pr intout option flags are checked and if ei the r is set the corresponding print subrout in e is executed  . The coding for the rule may now be completed . 
DOI:LEFTTORIGNT ; De6cription
Units to hescanned start at left-most uni t  , I = LEFT and include successive units I = LEFT+I , I:LEFT+2 , to rightmost unit I = RIGHTLl-l ; Set the pointer equal to 1 , at unit to immediate left of I . 
IF'bM(I , SEG ) the go to end 32 ; If the currently scanned unit , I , is specified as \[- segment\]o to next I ( i . e . Ln+l ) . 
IFM(I , CONS)I~M(I , BACK ) then go to end 32;
If scanned unit , I , is either\[+coasonantal\]or\[-backs(i . e . does not match the rule condition ) , go to the next unit . 
IF~M(I-I , SEG ) and M(I-I , FB ) the LI~2 ; If the unit immediately to the left of I is specified as \[- segment \] and\[?FB\]  , then set the pointer to 2(i . e . I - L1 will refer to two units to the left of I  )   . 
IFNIM(I-LI , SEG ) the end 32 ; If I-L1 is a \[- segment \] go to next unit . 
IFM(I-LI , ROUND ) , = M(I-LI , HIGH ) then go to end 32;
If the unit in the left environment does not have the same feature values for roundness and highness  ( i . e . 
does not meet the rule condition , round , high ) , go to the next unit . 
IFIM(I-LI , VOC ~ M(I-LI , CO ~) then go to end 32;
M(l , VOC ) = I;
PUTLIST('RULE 32, A t ', I);
PRINT ' ~32, AT " : I
IFP (32, 1) THENCALLST ~ OUT;
IFP (32, 2) THE ~ CALL MATOUT;
E~D 32:~D ;-13 -
If the unit in the left-moat environment is either 
I-vocalic3 or\[?consonantalJ(i . e . not a true vowel ), go to the next unit . 
All the conditions have been satisfied ; change the value of the feature \[ vocalic ~ from-to +  ( i . e . apply Rule 32) . 
Instruction to print the rule number ( R32 ) and state the matrix feature column to which it has been applied  , i . e . I . 
If a display of the string , resulting from application of Rule 32 is desired , go to subroutine $ TROUT . 
If a diapls~7 of the matrix result in E from applicat ion of Rule  32 is desired , go to subroutine MATOUT . 
Scanunit Ln+l , where
Lu = previously scanned I.
Co~iler Code Generation
To illustrate , the output coding to evaluate a simple right- handed context of the form 
A-~B/--context will bee Xa~nedo It wil l be seen that this codi ~ can be general i zed to evaluate a left-handed context as we ll  . If the context matching process is considered to be anchored at the point between the LH ~ position marker and the context bo~y  , then conjunctive and disjunctive items fa rther to the right in the context m~y betr ied ~ thout rematch in E items to their left in the context str ~  . This would be true even after the rule has been applied to the carrent \]  , y matched unit provided that the matched uni t is again tested against the L ~ after application of the ~ to that unit and be forethe context match continues  . 
The run-time environment in the object machine requires a single pushdown stack and a few simple variables tor ~ elocations  . A test strin ~ is assumed to be stored in the object machine which ~ a ~ have been entered prior to execution of the rule match or may be the result of application of ap rior rule in the syste  . 
Th ~ semantic formatch ~ n ~ particula ~ uni ts in the test string  ~1  . l not be described ~ but will be abbrevia ted in the output cod ~ as ~ ATC ~  ; EL~SGOTO ; which is taken to mean that a Jump to the ELSE ~ OTO label occurs if the specified unit was not successfully matched  . Further abbreviations in the outpute od i ~ are in the application of the ~ of ar~e  , ~ d~cated by
DORULE ; and in the declaration of program block and procedure structures  . Other ~ se , the coding presented constitutes a valid PL /I program segment  . 
~" ~- ~ the codi ~ necessary to evaluate simple contextual expression siuclud ~ an un-nested is junction titm ~ y be seen that no loop-in ~ back to previously matched units is necessary  . When the left paren-thesis is encountered the current location of the match pointer  , stored in the variable P , is saved . If a ~ y subsequent item match fails before the r~ht parenthesis is encountered the poin terlocation is reset to the saved value and the matching process resunes with the next uni to utside the paren-thesis  . The saved pointer location is erased when the riEht parenthesis is encountered whether or not the disjunctive item was successful lymat-ched  . This ~ heme achieves the desired disjunct ivity quite simply in that only one match i s attempted  . If the match of units inside the disjunct ion succeeds  , the matching process continues normally . If it fails , the en-closed str ~ is effectively ignored and the  , match in E process continues as before . This processlmy be made recursive to any leve l by saving the pointer location in s pushdown stack  , freeing the top stack item when a -15-r iE ht parenthesis is encountered . Such a stack ~ easily he implemented in PL/I by using the CORTROLL ~ form of dyna ~? storage allocation for a variable-~A new level in the stack is secured with the statement ALLOCATE STK  ;  , savi ~ all previous values . The topleveliserased with the statement FR ~ STK  ; t bring in 6 the previous value into . accessibility . 
In the coding examples presented below , two variables , LEFT-nd RIGHt , are assumed to contain the currently appl icable left and right limit ~ for matching the test string  . These will heset by scanning the test str ing to locate the innermost syntactic brackets or other such test S~ri ~ delimiters  . 
The index variable N will be used to ind icate the left-most end of the matching process  ; in this case , the anchoring point following the LHS posit ionmarker  . The statement MATCHUNIT__ ; EI~EGOTO__ ; is assumed to increment the current match pointer P and fail at anytime the value of P eXceeds the right delimiter value  , stored in RIGHT ? The codil ~ to evaluate a context of the form RULEN : A-  , B/--CD ( E ( YG ) HJ ) K would have the following appearance . 
tulLE:DOI-.LEFTTOHIGHT ;

IF MATCHUNITA ; ELSEGOTONEXT;
IF MATCHUNITC ; EI~EGOTONEXT;
IF MATCHUNITD ; ELSEGOTONEXT;
ALLOCATESTK ;

IF MA~HUNITE ; ELSEGOTOPN 1;
AMECATESTK ; ~ K-;
IF MATCHUNITF ; ~ SEGOTOPN2;
IF MATCHUNITG ; ~ GOTOPN2;
GOTOSK2;
PN2:paSTE;
SK2: FREESTK;
IF MATCHUNITH ; ~ EGOTOPN 1;
IF MATCHUNITI ; ELSEGOTOPN 1;
GOTOSK 1;
PNI : P = STE;
SKI : FREESTE;
IF MATCHUNITJ~ELSEGOTOHEXT;
DORULE ; m~T : ~ D ~ LEN;
The attempt to formulate the coding to evaluate a contextia cludi ~ a conjunctive series bri ~ to liEht a different type of problem  . It is not possible & or etch units from le ft to right in an orderly fashion as fox simple or disjunctive contexts  . Once a match for the entirest ~ ing has been attempted ttsi ~ the first item of the conjunctive series  , it is necessary ,  5 , -16-whether the rule was applied or not , to reset the current match pointer to its va lue at the time the left bracket was encountered  , and then continue the matching process using the units of the second conjunctive item as the matching patterns  . In order to loop back in this manner , it is necessary to save three values during a matching pass over the st~ng  ; 1) The bracket-pair number ,  2 ) The pointer value at the time the left b racket is encountered  , and 3 ) The item number within the bracket pair . These three values are saved in the pushdowns tack in the order listed when the conjunct iveseries match is begun  . It is convenient in the PL/I~e to accompl is h the branching by using the stacked values as subscript values in an assiEned-label GDTO statement  . The labels ITS4(1, 1):, ITEM(I , 2):, IT~4(1, 3):, . . . .
are attached to the statements in the coding which perform the pointer reset following matching of the corresponding conjunctive items  . Branch in E is accomplished with the statement GO TOIT ~  ( I , J ) ; following the proper assignment of values to the variables I and JoAn initial value of zero is put in the stack prior to rule evaluation  . 
The stack is then checked for a nonzero top item before it is unstacked for label assignment and an empty stack indicates that all conjunctive items in the rule have been used in the matching process  . If the stack is not empty , the top two items are unstacked and stored as the variables J and P respectively  . The remaining top stack item is accessed and the value stored in the variable I~but it is not freed from the stack  . The value of P must then be restored to thes tack ~ oit will be handled properly by the end-of-item coding  . The details of this scheme may be seen in the followi ~ example  , coded to evaluate a context of the form ~ LEJ : A -  ) B/--c~j
RULEJ :
D ~ GLAREIT ~4(I , 3) LABEL;
ALLOCATES ~;

DON-_LEFT TOEIGEr;

IF MATCHUNITA ; ELSEGOTONEXT;
IF MAT CHUNIT C ; ELSEGOTONEXT ;
AIJ ~ OCATE ~ TK;~TK = I;
ALLOCATESTK ;

ALLOCATESTK ; 3TK:I;
IF MATCHUNITD ; ELSETOTOBll;
IF MATCHUNITE~ELSEGOTOBII
GOTOBRI;
BII : J-STK ;
FREESTK ;

ITEM(I,1):ALIECATESTK;
STK~J+i ;
IF MATCHUNITF ; ~ GOTOBI2;
IF MATCHUNIT@;ELSEGOTO\]@12;-17-
IF MATCHUNITH ; ELSEGOTOBI2;
GOTOBRI;
BI2: J = STK ;
FREESTK ;

ITEM(I,2): ALLOCATESTK ;
STK--J+i ;
IF MAT ~ UNITXl ~ GOTOB 1 . 31 a OTOBEI . i ~ 1 . ~1 ~ STKIi II Eil STK Ie OTONEXTI
BBI:IF ~ TCHUNITJ ; ELSEGOTONE ~ T ;
DORULE ; h~T:IFSTK . OTHENGOTOSCAN;

FREESTK ;

FREESTK ;

ALLOCATESTK ;

GOTOITE~(I,J);
SCAN : E~DRULEJ ;
A further complication arises when a conjunctive series is embedded inside of a disjunction  . Specifically , the pointer location should not be reset to the value stored in the stack for a ~ y failure to match the internal sequence of units  , but on l ~ if the match fails for all items in the embedded conjunctive series  . Because the last conjunctive item may fail to match  , while a previously tested item matched successfully  , it is necessary to use a ' ~ lle applied " f lag  , which is cleared ( reset ) wbe , -entering the match of a disjunction and set by any application of the rule  . The setting of this flag determines the act ion taken concerning the pointer setting on exit from the disjunction  , when all conjunctive items have been tr ied  . 
The Compilim ~ Process
It m~y be seen from the coding examples given that the output from the coeq ~ iler occurs essentially in ~ he same order as the symhols in the linear input form  , suggesting that a preliminary stage of syntactic analysis is unnecessary  . It is only necessary to save the ~ specification in the compiler from the time it is input u~til it is output in coded format the end of the context coding  . Observing the three different types of failure-to -match exit branches  , it appears that the most direct solution i sa three-state table driven translator used in conjunction with a number of indices defined during the compiling operation for the purpose of counting brackets and parenthes is  , 8 enerating sequential abels , etc . Entries in the table indicate for each of the three states what output coding should be generated and what compiler index operations should be carried out as a result of each possible input symbol  . 
The table and listing of compiler actions shown below specifies a compiler system capable of producing PL/lcoding such as shown in the examples  . Notations used in the compiler table and act ion specifications  -18-are explained briefly . 
1 . Uppercase letters in the output are output as shown  . 
2 . Lowercase letters in the output represent compiler variables ~ for which the currently assigned value is output  . 
3- Abbreviated output coding has the meaning d i scussed above  , for example , DORULE expressed the codin ~ necessary to incorporate into the marked unit in the test string the characteristics or features g iven as the ~ of the rule  . 
4 . The state transfer from state 2 on input of a right parenthesis is a cond it ional transfer  , depending on the value of the com-piler var iable moThe test is shown as a four thpseudo -state  . 
5-Compiler initialization , a hown as state O , mast be accomplished at the beginning of compilation for each rule  . 
6 . Three of the input actions are identical for all states  , in-dicating that it is unnecessary to sto rethose actions in the state table  . 
7 . No action is specified for error inputs  . It is assumed that the compiler would respond with some indication of the trouble  , for example , a comma input when in state 2 could cause the reply ' ~ ommaille galin side parenthesis "? The compiler uses seven variab les  , four of them , i , j , k and 1 , as pushdown stacks with the CONTHOLT . E  ~ attribute , and three , m , nando as simple variables . 
Compiler State Table

E ~ OF--uni__!___E_~~C_____~LU ~
O.Action : Allocatei ; i = I;n . O ; o ~0;
Next State : 1i . Action : 145679i0
Next State : 13312102 . Action : 24 error error 78 iO
Next State: 2   3   2   4   0   3- Action : 3   4   5   6   7 error i0 
Next State : 3331204. Action :
Next State:
Conditional transfer state , no input ; If m_-O then go to state 1 . , else go to state 2 . 

Compiler Actions
Action Compiler number Operations 1 . Output " 2 . Output "3 . Output "4 . n = n * l
Allocatei ; i = n;
Allocatej ; j=i ; l = l ? l;m = O;


Output 5-Output

Output j = j + l ; 6. l = l-1;



If I ) Othengo to 6a.
Output "
Output "6a . Output "
Output ' ~ Ri : "
FREEi;
FREEj ; 7. o = o , i;
Allocatek ; k = o;
Allocate 1; i = O ; m = m + l;
Output "
Output 8. Free I ; m-m-l;
Output "
Output ' ? Nk :
Output ' ~ Kk :
Freek ;
Output Code
IF MATCHUNIT__;ELSEGOTONE~T ; "
IF MATCHUNIT__;ELSEGOTOPN k ; "
IF MATCHUNIT__;ELSEGOTOBij ; "
ALLOCATESTK ~ STK = i ; "
ALLOCATESTK ; STK_-P ; "" ALLOCATESTK~STK = I ; "" GOTOBRi ; "' Bij : J = STK ; FREESTK~P : STK ; "' ~ TEM(i , J ): ALLOCATEST\]( ; STK = ~+ l ; "" GOTOBRi ; "' BiJ : FREESTK ; ' ~ TEM(i , j ): FREESTK ; FREESTK ; "
IFFLAG_-OTHENGOTOPN k ; "
FREESTK ; "
GDTONEXT ; "
ALLOCATESTK ; STK_-O ; '?
FLAG = o ; "
GOTOSK k ; "
P = STK ; "
FREESTK ; "-20-9.

Free 1;
Output " GOTOSK k ; "
Output ' ~ Nk : p-ST ~; FREESTK ; "
Output ' ~ k : "
Freek ;
Free 1;
Output " DORULE ; FLAG = l ; "
Output'REXT:TK_-OTHENGOTOSCAN ;"
Output " J = STK ; FREESTK ; " output " P = -~ TK ; FREESTK ; " output " I~STK ; ALLOCATESTK ; STK~P ;  "
Output " GOTOITEM(I,J);"
Output ' BCAN : ~ DRULE ; "
The Generalit ~ of the Process
The only references to left-right direct ionality in the matching scheme described are in the left to right scan of the current L ~ marker in attempting to fit the test str ing and in the assumption that the coding for matching particular units ~ ncluded an instruction to increment he matching locat ionpointer  , P . A left-handed context m~7 be evaluated by similar coding by letting the pattern match move from the L~outward  , i . e . , to the left . The same compiling system can be used by revers ing the symbols of the left-hand context dur ing the initial linearization  , substituting left for right and rightfo r left brackets and parenthesis  . 
Thus , a rule of the form
A-,B/EF(G)H--I ~
L~J would appear in the linear format as
A-,B/H(G)FE--I\[J,K\]+
An additional dimension would be added to the compiler state tablet providing for the product io = of unit match coding which would decrement instead of incrementing the current matching pointer  . The L~S marker would still scan the test st ring from left to right  . If the L~marker occurred within the items of a co  . unction , separate coding would have to be produced for the left and right parts of each item  . The details of the matching process for thi scase have not been worked out  , but do not appear to present any major diffi culties for the system presented here  . 
-21-? Bibliograpb , y1?2e3.
Blair , F .   , Programming of the Grsmsar Tester in Specif ication and Utilization of a Transfer a at ional G ~  , Sci . Rep?1, IBM Corp ?
Iorktown Hts . New York , 1966
Friedman , Joyce , A Co~uter System for Trans for National Grammar . 
Cos~uter Sci . Rep . CS-~AF-21, Stanford , Ca . , Jan . 1968 Gross , L . N . , OnLine Prograe~ng System User ' s Manual MTP -~ , The MITRE Corp . , Bedford , Mass . , March 19674 . Londe , D . and Schoene , We , TGT , Transformational Grammar Tester , ~4-3759/0 OO/00 , System Development Corpo . Santa N~nica , Ca . , 1967 5- Ch ~ , Noam , The Sound Pattern of English , Harper and Row , N . Y . , 1968 6 . Kurd , S . -Y . , Yawe l ~ Phonolo ~ , MIT Press , Cambridge , 19677 - Schachter , Paul and Fromkin , Victoria , A Phonolo ~ of Akan : A kuapem , Asante and Fante , Work in ~ Papers in Phonetics No . 9, UCLA , August 19688 . Bobrow , D . G . and Fraser , Brice , The Phonological Rule Tester , Cos ? ACM , 
Tel 11, no 11, November 19689 . Ri?e , D . Lloyd , and Hofshi , Reuben , An Interactive Phonological/bale Tester , Work in K Papers in Phonetics m No . 10, UC ~, Dec . 1968 I 0 . ~, Roam . Some General Properties of Phonological Rules , Lan Eu~e . oib3 no1, March 196711 . K ~ I , J . P .   , Conjunctive Stacks and Disjunctive Sequences in Ls ~ eCh ~  , ~mu ~ terly Prog . Rep . Research Lab ? of Electronics , No ?88,
Mmm.Im~t . of Technology . Jan . 1968
