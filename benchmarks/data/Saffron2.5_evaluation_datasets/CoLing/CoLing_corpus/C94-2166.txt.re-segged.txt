A Dutch to SQL database interface using
C4cnc , elized Quantifier Theory
\])irkSpcelmml\[I\](\]ccri ; Adria ens\[1'2\]
\[1\]U niversily of l , cuvcn(J cnl ; er\[or Comput ~ tional , inguisi ; ics , 
Blijdc-Inkomststra . ~ t21 , 3000 l , cuven , Belgium \[2\] Sicme : ns-Nix dorf Software Centre Lib . ge , Ruedesl J ' orics 2, 4020 Lib . ge , Belgium
Abstract
This paper presents the treatment , of quantitication as it was im I ) lemented in a prototy l ) c of a natural language relational database interface for l  ) utch1 . It is shown how the theoretical ' generalized ( tuantifier ' ap-l )   ; tratlts introduced in form M semantics by Barwise and  ( \] oot ) er can be I , uned to irrq ) lementational feasi -" ( bility .  ( , ompm~d to the t , raditional tl ' ( ~ atl'flellt of ( luan-tilication , tile alternative l ) rcs('nted here offers gre ; tl ; erext ) ressive l ) ower , great , re'similarity to natural language and , as ~ t consequoxmo . , the possibility o \[' a more straighl , forward tral , slation from natural language to tbrmal repres (' . ntation . 
1 INTRODUCTION
In the prototyl ) eath and , as in many database interfaces , the naturalanguag (' , input is translated go a conventional formal query language  , viz .   , qQL , the most widely used and supported of these languages  . The resulting SQL queries can then be 1 ) asscd to an already existing SQL interpreter . 
The translation i ) r occ dui : efi ' om Dutch to SQI , is spill , up in two (: OrlSC cutive trl ~ tiorsl , eps , using a logic-based it l lierrrlediate sel/la . nLic represellta?ion called Goner MSem~mtic lepresentation  ( GSH . ) 2 . The functionality of ' the whole database interface  , including the SQI , interpreter , was seen as a straight , forward implementation f the fornial semantic Montague-style  ( Montague , 197: l ) mechamsmof indirect interpret at ; ion of natural language ( see Fig .  1) . 
TI
NI,--b.-C~Sl--~1) 13
NLi .   .   .   .   . +(~ It .   .   .   .   . -q ~ SQI , ----~ I ) Bl ! ' igure 1: Major processing steps in the I ) Binterface ' Grafting't brmal semantic pro ( : essing steps upon ~ tnNI , data l ) as e interface architecture has 1 ) een\[ ) r ( >l ) ~-1\[uthisi > a per the actual i in l ) lelnentation is not in focus ( see
Sl ) eelman , 1992).
2 Wi Lhln a frmne worl ? of machine I , r ; msl ; tti(m , we c ; m say 1 llal , (- ISIt , is a kind of logic-based in t cr lingua . 
gated and ( succesfllly ) worked out betbre in a somewhal , comparable project carried out at the university of l  , ' , ssex ( see 1) eP meck , Fox , Lowden , Ttlrnergz Walls ,  1991) . The main concern in that project was to clearly separate domain  ( -- database ) dependent semantic in-tbrmation t?om domain independent semantic information  . In the project presented he . reasimilar but more general ol/jective was to maximize the separation of the NLI  ) data and filnctionality of the system fi : omits purely database oriented data and fimctionality  , GSR being the interface structure . 
13 nt ch queslion

I 1 . . . . . I 1 . 1 . NI , d&ta~1, ( If 4l generat , , rII .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . t .   .   .   .   .   .   .   .   .   .   .   .   . n
C~SR expre ~ aioniT ) rl-:*B~s~s2 gzK .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . t .   .   .   .   .   .   .   .   .   .   .   .   . 
I ) ll SII . query
SQL query
Figure 2: General architecture of the program ' Filema in topic of this paper  , treated in section 3 , is the application of ' generalized quantitier theory ' in GSR  . l laving become classical in mathematical and some theoretical linguistic studies on quantification  ( SeCresp . Mostowski , 1!)57 and Barwise , ~z Cooper ,  1981) , tile theory is now beginning to be appreciated in A\[  ( and NI , P ) for its richness and flexibility . Probably the best illustration of this upcoming interc'st is the incorporation of ' generalized quantifiers ' in the popular  ( kmccI ) tuat Graph knowledge represenl ; ation for -- realism ( see e . g . Sowa , 1991) . A somewhat differently tiers ' can be found in ( Kaan , Kas & Puhland ,  1990) . 
These applications concentrate on the expressive and inferential power of ' generalized quantifier theory ' respectively  . The program presented here additionally illustrates how the use of  ( a variant of ) the theory reduces the complexity of implementing  ; he translation from natural to formal and artificial language  . 
2 GSR:GENER ALOUTLINE
The question what GSR should look like was to al ~rge extent tackled in a very pragmatical way  . As far as the linguistic module of the program is concerned  , the following criteria were formulated . GSR had to be a formal representation ( i ) with sufficient expressive power so the ftevery possibly useful query can be formulated in it in a not too complex fashion  ,   ( ii ) that is relatively easy to reach computationally , starting off from natural language . 
A general observation is that , considering the kind of NL sentences one can expect as input to the system  , GSR , inevitably had to differ from logical formalisms such as the ones used in formal semantics  ( focussing on propositions )  . In view of the general decision to work with intermediate  , semantic expressions the denotation of which is the answer to the NL questions  , the basic types of complet expressions listed in Pig  . 3 were found useful . In this figure 9~ stands for an arbitrary proposition in some logical language L  . Thee . x tension of L created by introducing these new types will be called L '  . 
( i ) propositions ( format : ? p) , to be used when people ask yes-or-no questions ( ii ) set expressions ( format : a ~ , \[~ o ) , to be used when people ask non-numerical identity questions  ( iii ) mathematical expressions ( form F t t : # ( ~"\] go ) ) , to be used when people ask for nmnerieal information 
Figure 3: GSR : types of expressions 3 FROMDUTCHTOGSR 3  . 1 ~ and V : problems The traditional . way of coping with quantification in NL database interfaces is by using _~ and V  , the classical first order predicate logic ( PL ) in strmnents ( see e . g . Warren & Pereira , 1982) . This approach , however , does not meet the criteria set out above . To illustrate this , we basically rely on two observations Barwise & . 
Cooper ( 1981 ) made to show a fundamental difference in the natures of NL and PL  . Their observations will be ' transposed ' to the computational pplication at hand  . 
The first observation is illustrated in figure 4 , which contain some Dutch questions at td their most natural PL'counterparts  . Whereas the Dutch sentences have the same syntactic structure  , their PL'counterparts have different formats . These and many other examples suggests that there is no trivially composition M way of translating NL expressions to their nearest PL' equivalents  . The problem is thai ; the quantiticational information , which in NL has a fixed location , is spread over the PL'expression in a seemingly arbitrary way  . 
It may be concluded that criterium ( ii ) for a good GSR is violated . 
1 Zijn alle werknemers gehuwd ? ' Are all employees married ?'  2 Zijnb cid cwerk nemers gehuw d ? ' Are both employees married ?' ~  . ~- ff~(( , ~ ? ~2 ) AV y ( ert~plo~dec ( y )  ~  ( ( y = Xl ) V ( y:0 C2 ) ) ) Arnarried ( : q ) Amar , 'ied ( x2 ) )  3 Zijn precies driewer knemers gehuw d ? ' Are exactly three employees married ?'  ( :/"1 # '~2 ) A ( a31?" r:'3 ) A ( :' ; 2 ~ ; ~ gJ3) A .   .   .   . ployee ( xI ) a employee ( z " 2 ) A e r r z p l o y c e ( ~: 3  ) ^ Vy ( (  .   .   .   .   .   . " icd ( y ) A employe e ( y )   )   ( ( y : Xl ) V ( y : "2 ) V ( y = X g ) ) A .   .   .   .   . " ried(eo"l ) A . .  .   .   .   .   . ied(x2) A . . . . . . " ried ( a ;  3  )   )   )   )   4 Zijn rncerdan de helft van dewer krlerners gehuwd7 ' Are more than half of the employees married ?' Figure  4: Translation of quantification from Dutch to

A second , more serious reason f ' or the inadequacy of E and V is that some forms of N il  , quantification ( : art only be expressed in a very complex way ( e . g . Fig .  4 , examples 2 and 3 ) or simply cannot be expressed at all ( e . g . Fig . 4, example 4) . llere criterium(i ) is not satisfied . 
A third problem , mentioned in Kaan , Kas & Puh-land (1990) , is that in practice , e . g . in implementations , one is tempted to make rough translations , and to neglect nuances or strong conversational implica-lures in natural language  , when one is limited to 3 and V . So , for instance , in Warren & Pereira (1982)%' , ' some ' and ' the ' all are simply interpreted as ~  . 
3.2 L(GQ)':a solution
There are many ways to try at nlget around the shortcomings of the traditional approach  . To score better on criterium ( i ), i . e . to increase expressive power , one could consider the introduction of n nmbers in the logical formalism  . Only , one can imagine that , if made in an adhoc way , this extension could result in a hybrid formalism  ( with respect o quantification ) showing an even greater syntactical mismatch with NL  ( decreasing the score on criterium ii )  . 
A solution for these probleins was first explored by Montague  ( 1973 )  , and later thoroughly worked out by Barwise & Cooper  ( 1981 ) in a formalism called L ( GQ )  . 
In contrast ot radition MP fi , which only has 3 and V , the language of generalized qnantifiers L ( GQ ) specilies no limitation of the number of primitives to express quantification  . All kinds of del , erminers (' . an be used . 
The translation of the examples of Vig . 4 to L(GQ)'is given in Fig .  5 . Some special notational conventions Barwise & Cooper introduced  , are left on t . Fur-llsed . 
2:1, u(~I . . . . vlov ~,(,:)), * I ,,,, . , . i ~ d(x ))
Zijn be dewer knem crsge huwd ? th ~_~( , , I ~ , ,~ vtow4: , :) , ~ I . . .   .   .   .   ,   , i  ~ a ( x ) ) gijn precies drie werknemers gehuwd ? e:t : act lyZl  ( a : I emptoyee (  , :)) , a:Imar , 'ied( . v ) - ~ Zijn meet d and e helf twm de werk nemers gehnwd?rrzm'e_than_~  . 2 tit(:,:I . . . . .   . 1o .  , ,4  .  : ) ,  . , : I . . . . . .  ,  '~- , z(20) D_I ? igure 5: Tr ; mslationo\[ql~m21 ; ifical , ion from Dutcht . o
I , ((\] q ) '
The . denotation of I , ( GQ ) ' determiners is de . fined ~ l ; a meta--h ' , vel , Some ( , xamples are given in (1) Co(/1) .  12 , these examples I stands form ~ in l , er preA , al ; ionfuncl ; ionmNq ) ing~m expression on its de . notation . 
" r , .   .   . ( it(x(v)\*(x )) = ~) b ) ~( , 11(~ , x )) : : i , , , ,~ , ~ , ~( oth , , , ' wi ~; (0I(tl .   .   .   .   .   . ( q ~, X )) = UndefiTze . d(if#(l(V ~)) 7': , z ) ~( , m(v , , x )) ( , , th( , , . , , , i , ~)( P')*(~: . ,,(,~ . ttu_,,(~o , x )) = " r, . .~ ( if #( v n x ) = , *) ? False ( atherwise ) (3) t( . , o , .  ,~ . ~  .   .   .   .   .   .   .   .   .   .   . th(e , x )) : : " ~', . , , , ( it #(/( w ) r ~ X(x )) > #( t ( w ) ) / ,   , )( d ) l , ' alsc(ot , herwise ) In Fig . 5 thesl ; ructural similarity of the NI , expressions is ' eflected in that of the I , ( GQ)'expressions . 
l ; urthermore . , all Nl , e . xamples ( ; & II\[le expressed almost equally easily in \[ , ( QQ )' . By consequence , the formalism does not \[ brcepeol ) let el Ioe satisfied wil , hrough l ; r~msl~l , ions . In shorl; , 1; t1(; problems o\['l , radil , ional logical quant , if i ( ; a tion are overcome . 
3.3 L(GQ)':complications
Unfortnnately , there are two reasons for not , consider- . 
ingI , ( GQ ) ' an ideals ohll , ion . The first probhml actually is not typic ~ d of I , ( GQ ) , lml , of l ; he fact that B~rwise & COOl/er take over i ; he Mont ~ Govian way of coping with I ) ossible ambigui W due to phenomena of quantilier scope  . In these cases one reading is gener- ; * tedin ~ t straighl , forwa , rdwayby H~rwise & , COOlmr . 
To allow for altern ~ t tive red , dings , they introduce extra machinery ( called t , \]2 o'qumll , itie at ; i on rule ') . 
' l'hel~ttl , eri Fleella , lliSlil ~ howevel ; coiivelli(:ll ~ ; \[1!o211 itl , heoretic ? fl point of view , is rather imph ~ me ~ ntation - . 
unfriendly . It Ol ) eral ; esoucoml ) let esl , ructural de-scriptions (= non-t ; rivial trees ) , and generat , escomph'l , estrucl , urM descril / tions . Allowing for such ; ~ rule drastically changes the l ) rolih ~ of I , hcpm:ser thai ; is needed . 
The second problem is ( , h  ~ l , i l , is undesirable for GSIt , beingmt interface\[;mgm~ge with ; ~ nonNI , Pme(hilt , to court , in the set of ( NL instlircd ) det , erminers l ; hal , I , (GQ )' contains . It wo nld prol ) ~ d)ly be I ) el . terit ' GS thad fewer primil Jves , prererably of al , ypenotcom . 
plei ; elyuncust , oma , ryintraditiom dI ) IMSs.
3.4 GSR : an L(GQ)'derivative
As a soluti (/ n for these problems I , ( GQ)'gets two new neighbours in the 1 , ransh ~ tion process , as shown in
Fig . 6.
NI , ---- ik-StI . I--~ , -- b ( G-q ) ' ---- I ~ ( \] SItI"igure 6: Major processing steps in the , NI , P subsys . -\[ , ( Jill In order to avoid l , heN)pli(:~Ltion of the ' qu ~ mlJti-cation rule ' , th(; choice has been to first generate , an expression that is neul ; ral wil , hresl)ect , l ; ol , he Se Olle of its quantifie . rs(SR . 1) , and then solve the scope I ) rOt > lemin a second step , here by generating m2I , ( GQ)'ex~presson . The 1, rick of first ge . ne . rating a scope-neula ' M expression is not new . I , ' or instance , it , is used in the l , OQUl system ( see Gailly , l  ~ . ibb(' . ns&Binot , 1990) . 
The originality lies ral , her in the eflbrt to respect well--l'or medne . ssiut , he scope-neutral expre . ssions . 
hdbrn , ally speaking , SILlisallre . dieate-logic ; flor--realism in which the arguments of the l lredicates ~ L rein-te  . rnally structure . dasl ; hl ~ N\[, arguments of verbs . The mostimt ) or t ~ mt (: on sequence is that del ; erminers are lo-cal , ed within the predi (: ~ fl ; e-~rguments , q ' o give an example , 'Werk (' nalle werk nemers a ~ ml , wee projekten ?' ( l ) o all employees work on two projects ? ) wouhl be represent ; ed ; ts(5) . For idenl ; il ; y and cm:din Mil , yquest . ionsl , he formats in gig . 3; ~ rern~(leSUl ) ertluous by the pseudo . (M ; ermin (: rsWll and CARl) . For in sl , ance , ; he quest , e22' U elke werkt lem (' . rswerkellaant , wee projekten ?' ( Whiche . mphyees work on two projects ? ) is translated to ( 6 )  . 
. . . . . q:(all(a " I . . . . ploy, . ' e(x )), 2(~: I proj ~: ct(x ))) (5) . . . . . . k(W //(~: I .   .   .   . ployee ( , v )) , 2(: cIp , ' ojeet(x ))) ( Ci ) Thel , ranslation of NL l , oSI1 is as l , raightA ' or wardeoint ) osition M process , compar~t b h '~ t , ( ) the Iarwisc ( ) oopcr processing of readings for which no ' quantification rule ' is ne  . eded . The algorithm l brgoing fi'om
SRI1, oL(GQ)'is given in l?ig.7.
If an S11 expression contains a pseudo-determiner W\]Ior CAll  . l ), the schema in Fig . 7 is adapl ; ed as follows . In the first step the arguments with reM determiners are replaced by w~rb~bles vlup to v  ~  , , ~ md the cial w~riable v0 . l !' urther , ; he result ~ o of the norm ; flse colldsl , ( l/isIAil'led into ; tse , expression or ~ tnumer ~ i ~ l , : xt , ,: , ~ . ~ . io .  ( , , , , I & A ~ , l , : #(~ , ~ I , v , , A ~) ) ' rhe t , hird step , which is ~ o-inl , ernal , remains unchanged . 
The essent ; iM part in Fig . 7 isl ; he procedure that d('te . rminesth(;possi/)le SCOlle-configur ~ tions . Inl ; hepro-gl'a , lrl only one , I ; he most I ) robad ) lescope-conligurat , ion is genexai ; e(l . The algorithms t ~ d , esthat < , hee ~ rlier some quantifier occurs in I ; he Nl , e . x pression , the larger its s(:ol)e should be in the I , ( GQ)'expression . Int , het Every argument Di ( , ~ i ) is replaced by a new , unique variable vi(iE1 ,  .   .   .   .   . ) t .   .   . p(~,v2, .   .   . , v , O .   .   . 

An independent procedure is run to determine tim probable or possible scope of the determiners  . The determiners are wrapped around the initial proposition according to this scope  . Formally the scope-determining procedure generates for every probable or possible reading a permutation f of  1  ,   .   .   . , n . 
t01 (1) ( .   .   . Dj ( . 2 ) (  .   .   . Dj ( , )( .   . P ( Vl , V2, .   .   . , v , ~) .   .   .  )  .   .   .  )  .   .   .   ) t The remaining lacunes are filled up by adding , as shown , to every determiner 0 i its original domain-set S i , and the variable vi that was introduced before to replace l  ) i ( Si )   ( iC1 .   .   .   .   .   .   . ) tDt(1)(sj(t ), . vf(t)IDs(2)(sf(2) , vL (?) I ; q; , 01 ( n ) ( Sl(n ) , Vl(n ) l~tVl , ~2 ,  ' ' '  , v " ) 1  ) ''' l ) 1  ) Figure 7: Schema for translation fl : om SR . 1 to L ( GQ ) ' NL fragmen that was tested extensively with the program  , this procedure proved to be amazingly accurate ( see Specimen ,  1992 ,  85 98) . The fllture goal , however , is that instead of on ( . ' most probable reading a list of all possible readings  , tagged with a degree of probability , is generated . Since the procedure is a separate module , any extension or alteration of cat , be made without affecting the rest of the program . 
What remains to be overcome , is the fact that introducing a large set of determiners in GSH  . would burden the interpreters used it , the database subsystem with an extra , NLP-type recognition tank . This problem is solved by giving L ( GQ ) ' a right h and neig bonr ( see FiX .   6 in which the determiners are replaced by what was originally the recta-level definition of their semantics  ( see ( 1 ) - ( 4 ) ) . In the resulting I , ( GQ)'derivative , called GSR , the numl ) er of primitives ( set , set intersection , set difference , set cardmality ,   . . . ) is drastically reduced . Fnrthermore , the new primitives are much closer to , and even at the heart of , the procedural and semantic building blocks of traditional computer science in general  , and of relational DBMSs in partic nlar . 
An example of the complete procedure , going from SILl to L(GQ)'to(\]SP ~ , is given in (7) up to (9) . '\[' he question is ' Zijnal lewer knemers gehuwd  ?'   ( A real lemployees married ? )  . 
all (: qlemployee(:q ) , xll married(x , ))) (8) 4 FROMGSR TOS QLAs the NLP subsystem , the database subsystem is hilly implemented . However , we shall restrict ourselves to a very brief sketch of its functionality here  . As can be seen in Fig .  2 , aGSH , expression is first translated to a formalism called I  ) BSIL This was clone for reasons of modularity , primarily for facilitating the extension of the system to dill ? rent target languages  . 
DBSR , which stands for DataBase specitic Semantic Representation  , is a declarative relational database query language that is both close to GSR and easily translatable to any of the commercialized \]  . I ) BMS query languages . Apart from the treatment of quantification the formalism is very sf nilar to relation alea h:n - lt  , s . The major effort in the step fron ,   ( \]S\[toI ) BSR lies in adapting GSl-terminology to concrete names of tabels and columns of a database  . This is done using a Dl3-1exicon , which can be seer , as an augmented l ~ , t-mode \] of a data /) as e . 
The last step , from I ) BSR to SQL , is extremely straightforward . Sets and cardinality expressions are translated l , o(sub)qneries . Relations between sets or cardinality expressions are  . translated to conditions for ( sub ) queries . 
For completeness , an example of the database subsystem on tlmt is given  . For the last example of the foregoing section aI ) BSI expression and an SQI , query are giver , in (10) and (11) respectively . YES contains only ' Yes ' . 
: elI . . . . ployee (': l ) \ ':1 I a"l . rr'a ?' 7" i('d = w\],J = ~(10)
SFLEC q ?*
FtOMYES
WIIl';ll,l'3NOTEXISTS(SI'~I,I'~C'FXl.*
FII . OMt !' MPI , OYI'~EX 1
WI , I'~RENO'I'(X1 . MAII . I ( \[ I'~D='q " ) )  ( 11 )   5 IMPLEMENTATION The system is written in Common Lisp  ( according ; othe'de facto standard Steele , 90) and generate star>dard SQL queries ( ISO) . It has prow'd to be a perfectly portable product . Originally written on a Macinto siSE/30 , it has afterwards been tested on several Sym -belies  , Macintosh and PC platforms . 
The major modules of the linguistic component are a ' letter tree ' tool for efficient communication with the lexicon  , a transition etwork based morphological-ysis tool  , and an augmented chart parser for syntactic and semantic analysis  . 
6 CONCLUSION
In some subfields of formal semantics the traditional logical apparatus for quantification  , i . e . the use of and V . , is being abandoned in favor of ' generalized quantifiers '  , because the latter are both ch ) sert on a tural language and richer in expressive power  . In this text it has been shown how this theory can he put to use in an at nrallanguagc database interface  , another field ht which ~ and V had become traditional  . 
Some modifications had to be made in order tol'on -der the theoretical ' generalized quantifier ' approach I  ; ions were\[ , heinl ; roduction of a sepal : al ; e module to replace the ' quanl ; ilication rule ' , and the shift , from rnet ; a-lew'JI ; ological representation of some set theo-retical primit fives  . 
References\[1\]Ba,:wisc,J . & (; ooper , IL (1981) . '( ;<; neralizcdQuanl , ilicrs and Nal , nral Language ' . Linguistics and
Philosophy 4, 159-219.
\[2\](?odd , E . I ~ .  (1!)70) . ' A Data Sublanguagc Founded onl , heRdal ; ional Calculus ' . AUM5' IUI , 'IDI , 27' Workshop onl ) ala Description , Access and Control , 
November 1971.
\[3\]l)cII . o < ! ck , A . N . , Fox , ( L , 1 . , 1, owden , I/ . ( UI ' . , Tur--nor , II . . & Walls , I/ . H , .  (1991) . ' A Natural Language Sysl . ern Based on Formal Semantics ' . Proceedings of lheln lernalional CoT@fence on ( /urrcntl . s . rues in
Compulalional Linguistics . 268-281.
\[4\] Gailly , P . J . , l , ibbens , 1) . & Binot , , I . L .  (199(/) . ' l , a < tuanl , iieationen Trait cment du Language Naturel ' . 
\[5\]IS()'1'(797/8C21/W(;3 and ANSIX3H2(1987) . 
ISO9075 Dalabasc Language SQL.
\[ s \] K a ~, ~, E . , Kas , M . , ~: Puht ~, , d , ll . . ( l~J!t0) . ' f , ; , ' . n procedure veer l'ed ( ) llel ' ( Hll\[lel , k w ~ l , llt ( ) rell ' . TABUI\]ul-lelinveer T < tahvete~z . schap2(\](4) .  205 221 . 
\[7\] Montague , H, . ( I . 9TI ) . ' Thol'rop < ; r Treatment of quantiiication in Or < linaryl ! ; nglish ' , llintikka J . , Moravcsik J . & Suppes P . ( ot is . ) Approache . sloNat-ur'al Language . I ) or drcch\[;:H , eidel .  221- . 242 . 
\[8\] Mostowski , A .  (1957) . ' On a (\] eneralization of Qn antitiers ' . 1, '~ tnd . Math .  44, 12-36 . 
\[9\] Sowa , J . F .  (19!)1) . ' Towards the Expressive Powero\[Natm : al Language '  . JF . Sowa ( ed . ), I'ri ' nciples of ScmanlicNet ' work,~ . San Marco , ( laliibrnia : Morgan
Kaufinann . 157189.
\[10\] Spcelman , 1) .  (1992) . l , ; cn prototype voore cn da ? a base-interfacc in L is p . Vc'rtaling van Ncder'-landsew'agenna ar SQL -queries  , (? omlmtation a\[1 , inguisti <' s Thesis , University of \] , euven ( inl ) utch ) . 
\[11\]Steel <:', C; . L .  (1992) . Common Li , sl , : 7' he Lan-g'u < l<le . Second Edition . Digital Press : Be < t for dMA . 
\[12\]Warren , I) . ll . & P < ~ reira , F . C . N .  (1982) . ' An Efli-cicnl , Easily Adapl ; al>le System for Interpreting N~tl , -ural Language Qu <; ries ' . American Journal of Com-lrulalional Linguistics 8 .  110:\] 19 . 
\[13\]Zwarts , F .  (1983) . ' Determiners : a relational perspective ' . \[' erMeulen(ed . ), q'ludies in Modellheorelic Semantics . I , ' or is : I ) ord rechl; .  37-62 . 

