Contribution of a Category Hierarchy to the Robustness of 
Syntactic Parsing.
Damien GENTHIAI ~ , Jacques COURTIN , lr 6 ne KO WAR SKI
Laboratoire de g6nie informatique ? lmagCampus ? BP53X 
F-38041 GRENOBLE CEDEX-France
T 61:765 14878
E-Mail : courti.@imag.imag.fr


We describe how the use o1' at hierarchy of lexical categories instead of a simple set of categories leads to the definition of a flexible and precise language for the description of dependency structures  . After specifying the t'ormalism we use to decorate these structures  , we present an application aiming to detect and correct en ' ors in a written text  . We outline how tile use of the hierarchy irn proves the manii  ) ulation of unknown words . 
\] i . it-troduction
The work presented in this paper is part of an at ) regeneral project which aims towards a complete system for detection and corrcctio ~ of errors i ~a written text  . Our interes~hereistit ( : creation of asyrit actic--semantic module which builds depent tency structures decorated with attribute  . -pairs lits integrating a mechanism for the inheritance of properties  . We show the contribtltion of hierarchisation of lexical categories to the construct i  ( m of syntactical structures . 
2 . Construction of dependency structures Dependency structures are trees which give a description of the structure of a sentence by establishing direct links bew cen the words  ( or lexical items : the terminal symbols according lo constituent grammars  )  . The idea is that the structure of a phrase can be thought of as a particular word  ( the head or governor ) modified by ' the other words ( the modifiers or dependents )  . Dependents can themselves be modified to produce a tree strucure : the governor as root and dependents as his sons  . 
Complex intormation ( e . g . syntactic functions or semantic relationships ) can easily be added on the links of such trees and rules of agreement are conveniently expressed  . For example , in French , the agreement in gender and number between a noun and its determiner and adjectives implies the same gender and number for both the dependents  ( determiner and adjectives ) and their governor ( noun )  . On the other hand , it is difficult to express ptn ' ase properties on dependency structures  , because the properties of a phrase governed by a word at  ( : not necessarily limited to the properties of the word alone  . 
In order to describe such structures , we write bin my relations in " governor-dependent " form  . 
The formalism proposed by Tesni ~ . res\[120\] ( depender my grammars ) is very prec is E , but all possible arrangements of the dependents of a governor must be described  . In Courtin's work\[8\] , weighte dependency relations are defined , which are well suited to computation , but limited in power of expression . 
We have attempted to design a language for the description of dependency structures retaining the precision of grammars  , but more appropriate for automatic treatment . 
To build these structures , we must be able to determine , for any two words , caracterized by their lexical category : det , noun , verb .   .   .   .   . 
which one governstile other . More generally , given two dependency trees , we must know how to merge them into a unique tree . 
t !~, xample : 1 s , eL det adj
We have defined a language based on rewriting rules  ; each rule applies to a dependency forest and produces a dependency tree  . A set of such Examples given are simple English adaptations of tile 
French originals can be applied to a sentence by means of an interpreter  . This interpreter can be viewed as au'ee -transducer  . 
Example of a simple rule: ( the "--" begins comments ) 
NV\[--Name(~:N ,  (0 , SF:P ) 2: V ) -- Forest => (( i , SF )  2  ) -- Resulting tree \] This rule applies to any forest which includes a sequence of an N and aV  , whose left dependents are only preverbal particles P  . It builds a new tree where the N is added as a dependent of the v  . 
The advantage of these rules , compared to simple binary relations , is that it is possible to express the context of each category which appears  . It is thus possible to restrict a governor to one or two dependents only  , or to forbid more than one occurrence of a given category  . . . . One can also define linked pairs of binary relat ions  , as for coordination conjunctions :
Ncoon\[(T '"" ~: N , ~: ~ coco , ~: t_ , ~) :> (1) 23))\] On the other hand , they present he drawback of the primitive dependency grammars : therenms t be a rule for almost every pair of lexical categories  ( LC )  . To avoid this problem , we have chosen to use a hierarchy of LCs instead of the usual linear set of LCs  . This hierarchy is a set , partially ordered by the?s a relation ( Figure 1 )  . 

N\/A e noun x be x have verb past p adj
Figure 1? Example of hierarchy
We can , in this manner , express very general rules like the two given above  ( NV and
Ncoco ) or more specific ones like ' aux_ppas\[ ( l : x be ; x have , 2: past p ) => ((1) 2)\]Thanks to i . sa(cnoun , pnoun , N ) and is-a(xbe , x have , verb , past p , V ) relations , the N_V rule for instancer nay be applied to all the following pairs of categories :  ( cnoun , xbe ) ( pnoun , xbe ) ( cnoun , x have ) ( p noun , x have ) ( c noun , verb ) ( pnoun , verb ) ( cnoun , past p ) ( pnoun , past p ) We can thus define a set of basic categories which describe words in a very specific way  , and use these categories for lexical indexing . 
The categories can then be grouped in " meta -categories " according to the structures we want to build  . Finally , we can write the rules which effectively build these structures  . 
By using this method , we can avoid the usual compromise between a very fine set of LCs  ( which multiplies morphological ambiguities and syntactic rules  ) and a very general set ( which multiplies syntactic ambiguities )  . We also obtain a fairly robust syntactic parsing : all unknown words are given the most general category  ( CLS )  , to which any rule carlapply ( see ?4) . 
Similar type hierarchies have already been used in work on language semantics to represent the taxonomy of semantic types  . We shall therefore use the same formalism for the representation of syntactic and semm\]tic knowledge  . 
3. Type hierarchies and ' e-terms
We have chosen to represent knowledge about words and trees with a unique formalism ' q'-terms  \[2\]  . 
q'-terms are case frame structures which permit the description of types  ( in the sense of classical programming languages such as Pascal  )  , i . e . sets of values . ~- terrns are directed graphs ( Figure 2 ) in which nodes are symbols associated to fundamental types  ( simple types ) and arcs are labelled with attribute symbols . Each node of the graph includes a reference tag which can be used to designate it  , thus allowing information to be shared . 
Simple types are defined in the signature which is a set partially ordered by the is-a relation  . 
This order is extended to q'-terms by the unique operation used to manipulate them : unification  \[1  ,  2\] . The unification of two simple types is defined as the set of lower bounds of these two types  ; ( in the 2s-a relation ) . 
Ser\[i  #sere pat.ient
Linear R . ? m:"t JL(J . @ X - ->" e&tS " ; cdt7>vezl ~' ; subj ~:> Uh(sem':>S:ANIMATE ) ; obj , :> UL(so ; a :> O:Y . A ' 2 A B ' . I ; ;)  ; sere :=> ? NG ggT(agent : :> g ; pat:Jent>O ))
Figure 2? Example of % l : crm
U Hification allows implicitir wherit ancc of properties  , and can be ? i Ticiently implemented

Exmnple of unification ?
The two tlJo terms "
Uf , ( i_ex :> " dr)g ";
CaL :> cr ~ our %; nbr- . > sin;gnu :> re < is ; sere-,:>CA ~ i qiN : <)
UL(cat:>,L ; sere::>ANIMATP :) unify as "
UL(ieN:>"d<)g";
C~\]L-:>CrlOtID ; 9 ~ r > mas ; nbr > sin ; sere : > CANINE ) under the condition that the associated signature unifies CANINE and ANIMATE as 
CANINE.
We can del'in easel-senmntics on simple types\[1 ,  191\]  ; this semantics can be extended to ' t'-terms giving the following interpretation of unif ication : if Pl and  P2 are two T-terms describing respectively two setsel and  e2 of values , then unification of two q'-terms L\](pl , 
P2) describes these telne2.
To transduction rules we have added expressions which enable us to test and modify'v-terms attached to the trees we are manipulating  . We can thus simultaneously build a syntactic structure  ( dependency tree ) and a semantic structure ( f-term , which also contains morphological and syntact ical information  )  . 
Example of rules ~ md application '
We have two words ?
UL(?~e >:::'~-" cog ~";
C&t::7(;~l; , ~J ~ 5i ; sere=>CANINE ) rTT = :> It . ~ c .  11 ? , . :? ( \] ~ :<  . .~ ct , . ~- ; " . : at . :> v ~ . ~b;
UL(sem::>~,c':AN2MATI :); obI=>
ULs . em::=>O:\]~ATAJ~LL ) ; seiI'L=:>1~':f'\]'?~''~ , o . ',, . 0L(=~ge?/C . = :> S;\]:)~ . tient : :> O )   ) and lherule " s ' cbj ( - ct : .  \[ (\] . : N , 2:4V ) /', ; : ~: i . ~: I , 2sub )) ~' ~ ~ .   .   .   .  ?  .  " , . . O\[i( . _,_L . 1(9,~::2>((i2); . . . . . '" c ; bi .   .  "  .   .   .   .   . z  ~ o . : ~; (2sub\],i,Act:ions

The root of the resulting tree is decorated by ?
U \ [ , ( I(' , " , 1:>"C ' ~\[ L ~" ; <: t&L :> L'@E\]:) ; sui : ; \]::> UL(Iox . . . . > , , Hr ~, , . 
t ~ ll <; < x ** jse re -- :> , ~~': CANINE ;  )  ; ob::>UL(sem=>O:EATABLE ) ; sere=>\]:NGEST(agor zt => f_ ; ; oaLJeri ! ; : :> O )) 4 . Applticafio as : a robus parser of French and syamctica it vcril\[icao We have implemented on a microcomputer a prototype of the dependency-tree transducer  . 
This prototype is integrated in a system for detection and correction of errors in a written text as a syntactic filter  ( Figure 3 ) o The prototype uses an algorithm for the appl ication of rules adapted to syntactic  . -semantic parsing ? the text is pmsed from left to right  ; each time a word is recognized by the morphological parser  , it is transmitted to the syntactic module which includes it in the current state of the analysis  . This state is represented by a list of dependency forests to which the transducer tries to attach the new word  , according to the rules . 
Sentence ( Text)
Morphol.
Parsing I
Unknown words
E1
Hypothesis
Generator Correct words
Hypotheses ~ yn ~ actic
Fiiter
I  ~ J
Syntactico-semantic structures
Figure 3: Architecture
If part of the entry string is not recognized , it is passed onto the hypothesis-generator which attempts to correct it by means of three techniques  ( skeleton key\[1611 , phonetics\[9\] , and morphological generation \[7\]) . The hypotheses are then passed onto the syntactic module which handles them exactly in the same way as morphological mbiguities  . It must be noted that the three modules can function almost simultaneously  ( pipeline ) and that the hypothesis-generator always transmits something to the syntactic module  . 
If a word is so ill-formed as to render its correction impossible  , tile hierarchical structure of categories can be used to transmit hemost general possible word  , i . e . ? UL(cat:>CLS ) . 
Any rule can apply to CLS ( which is tile most general category )  , so the choice of the rule to be applied i , ; determined only by the context of the unknown word  , and this rule will in turn determine which category the word should have had  . 

With a forest such as ?( l : c noun , 2: coco , 3:CLS ) we shall obtain ? (   ( l : c noun ) 2: coco ( 3N )   ) after applying the rule N_coco . 
The syntactic filter works like a parser but does not take into account agreement in number and gender between words  . A specialized module in charge of verification of these agreements in ow being designed  . A prototype of such a module has been implemented in Prolog  ; it detects agreement mistakes and can propose corrections by means of a morphological generator  . We are now working on rewriting it in tile transducer language  . 
The main use of the syntactic filter is therefore to validate the lexical category of the hypotheses generated by the lexical correct or by building dependency trees which take into account the semantic information attached to the words  . 

With the phrase " sun and moun " we obtain the following hypotheses for moun : 
UL(Iex=>"morn";cat=>cnoun ; sem=>TIME)
UL(lex => " moon " ; cat :> c noun ; sem :> CELESTIAL-OBJECT )
UL(iex => " mount " ; cat => verb ; subj=>UL(sem=>S:ANIM , hTED ) ; obj=>UL(sem=>O:PLACE ; sem :> MOVE(agent => S ; where = > O )   ) Each of these hypotheses is considered an interpretation f the unknown word moun  . 
The rule of coordination is
Ncoco\[(I:N,2:coco,3:N)/Unif(l . sem , 3 . sem)/=>((i ) 2(3)); ASSiGN(2 . sem , Unif(l . sem , 3 . sere));
ASSIGN(2. nbr,plu)\]with for sun:
UL(lex => " sun " ; cat => c noun ; sem=>CELESTIAL-OBJECT ) . 
The rule cannot be applied to mount because a verb is not aN  . It can only be applied to the noun moon by unification of the seniantic features of moon and sun  . 
With a phrase such as " sun and miz rn " , the hypothesis generator gives formizrn :
UL(cat=>CLS )
The application of the rule N_coco will give the tree of the figure  4  . 
5. Conclusion
The use of a category hierarchy simplifies the writing of the rules and introduces a way of manipulating unknown words which is not part of the mechanisms of the system but which is  142   4 integrated in the objects it manipulates . We can then write rules without thinking about ill-formedness  ( i . e . it is not necessary to make the rules tolerant because the tolerance is implicit in the system  )  . 
UL(Ie :<=>" and ";
C~C=:>COCO ; nbr > plu ; sem=>
CELESTIAL-OBJECT )/ k
UL(lex -> " and " ; UL(cat :> N ) cat => coco ; sem :>
CELESTIAL-OBJECT )
Figure 4: Decorated tree
The throe modules have each been implemented on a microcomputer  , we are now working on integrating the three modules and adding the module for agreement verification  . We are also improving the performance of the transducer :- by integrating a factorization technique for the intermediate forests in the form of a graph-structured stack  \[21  \] , -by adding a finer control ( graph of rule application ) precomputed at compilation time . 
Refi . rences
I1\]:H.A'itKaci
An Algebrai'c Approach to the eJ'\['ective resolution of type equations  . 
Theoretical Computer Science 45 ,  1986 , pp 293--351\[2\]:H . Ait Kaci , P . Lincoln LIFE . " A natural language for natural language . 
MCC Technical Report , Number ACA-ST-074-88 , February 88\[3\]: H . A'it Kaci et al
Ejficient implementation o./'Lattice

ACM Transactions on Programming
Languages and System sll : l ,  1989 , pp 116-146\[4\]:C . Boitet Representation ad computation of units of translation for Machine Interpretation of spoken texts  . 
GETA & ATR Technical Report TR-I-0035,
August 88\[5\]: J.G . Carbonell & P.J . Hayes
Recovery Strategies for
Extragrammatical Language.
AJCL 9:3-4, 1983
Parsing\[6\]:E.ChaJ'niak
On the use of framed language comprehension.
AI 11,1978.
knowledge for\[7\]: B . Cohard
Logicielded ~ tection et decorrection deserreurs lexicales  . 
Mdmoire CNAM , Mars 1988\[8\]: J . Court in Algorithmes pour le traitement interact if deslanguest mturelles  . 
Th6sed'dtat,USMG , Octobre1977\[9\]:J . Courtin , D . Dujardin , I . Kowarski , D . 
Genthial , V . L . Strube de Lima
Correq dode erros de or to grafia atrav~s da fondtica emtex toses critosem franc~s  . 
XIV Conferencia Latino america nade
Inform~ . tica ,   17avas Jorna das Argentinas de Inform fitica e Investigacidn Operativa  , 
Buenos Aires , Sep . 1988. pp 873-891.
\[10\]: J . Courtin , D . Dujardin , I . Kowarski , D . 
Genthial , V . L . Strube de Lima
Interactive Multi-Level Systems for
Correction of Ill-Formed French Texts.
Proceedings of the 2nd Scandinavian
Conference on Artificial Intelligence,
Tampere , Finland , June 1989\[11\]:L . Emirkanianl L . Bouchard
Knowledge integration in a robust and efficient morphosyntactic analyser for 

12th CoLing , Budapest , August 1988, pp 166-171.
\[12\]: J.P . Fournier , J . V 6 ron is
Traitement deserreurs dans la communication homme -machine enlangage nature l  . 
A cresdes premi6resjourn6es nationales du
GRECO-PRC Communication Homme-
Machine , Paris , Novembre 885143\[13\]: R . H . Granger
The NOMAD System : Expectation-Based
Detection and Correction of Errors during
Understanding of Syntactically and
Sermmtically Ill-Formed Text.
AJCL 9:3-4 ,  1983 , pp 188-196 , \[14\]: Peter Hellwig
Dependency Unification Grammar 11th CoLing , Bonn , August 1986 ,  195-198 . 
\[15\]:G . Lapalme , D . Richard
UnsystOme decorrection automatique des accords desparticipes passes  . 
Technique set Sciences Informatiques ,   4 Automatic'spelling correction in scient ti\[i'c and scholarly text  . 
CACM 27: 4, 1984\[17\]:D . Scott
Data Types as Lattices.
SIAM Journal on Computing 5:3 ,  1976 , pp 522-587\[18\]: S . M . Shieber
An Introduction to Unification-Based
Approach to Grammar.
CSLILecture Notes 4, 1986\[19\]:G . Smolka and H . A'/t-Kaci inheritance IIierarchies : Semantics and 

Journal of Symbolic Computation 7 ,  1989 , pp 343-370\[20\]: Tesni6res
Eldments de syntaxe structurale.
Klincksiek , Paris , 1959\[21\]:M . Tomita
Graph-structured Stack and Natural
Language Parsing.
Proceedings of the 26 th Annual Meeting of the ACL , Buffalo , USA , June 88\[22\]: R . Zajac , M . Emele
Multiple Inheritance in RETIF.
Report of the ATR Interpreting Telephony
Research Laboratories.

