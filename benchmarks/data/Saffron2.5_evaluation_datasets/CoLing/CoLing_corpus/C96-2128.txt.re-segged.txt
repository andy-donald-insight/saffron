Reversible delayed lexical choice in a bid irectional framework 
Graham Wilcock *
Centre for Computational Linguistics
University of Manchester Institute
of Science and Technology
PO Box 88, Manchester M 601 QD
United Kingdom
graham Occl , umist , ac.uk
Yuji Matsumoto
Graduate School of In % rmation Science Nara Inst it ute of Science and %chnology  8916-5 Takayama , Ikoma , Nara 630-01 , Japan matsu ~ is , aist-nara , ac . jp
Abstract
We describe a bidirectional framework for natural anguage parsing and generation  , using a typed feature formalism and an HPSG-based grammar with a parser and generator derived from parallel processing algorithms  . We present an approach to delayed lexical choice in generation  , based on subsumption within the sort hierarchy , using a lexicon of nnder-instantiated signs which at '  (  ; derived fi ' om the normal lexicon by lexical rules  . We then show how delayed lexical choice can be used in parsing  , so that some types of ill-formed inputs can be parsed  , but wellformed outputs are generated , using the same shared linguistic information . 
1 A bidirectional framework
In our bidirectional framework for a natural language engine  , the linguistic descriptions in the grammar and lexicon are shared resources which are used  , inappropriately compiled forms , for both parsing and generation . Like the Core Language Engine ( CLE ) ( Alshawi ,  1992) , we use a unification-based phrase structure grammar  , a logical form representation , a bottom-up chart parser and a semantic head -driven generation algorithm  . However , we ( lifter from CLE by exploiting recent developments in processing algorithms and in linguistic representation formalisms  . We will clarify the similarities and differences at  ; the relevant points . 
1.1 Processing algorithms
The SAX parser is a concurrent SICStus Prolog implementation of the PAX parallel pro'sing algorithm  ( Matsutnoto and Sugimura , 1987; Matsumoto et al ,  1994) . Like the earlier BUP parser to which the CLE parser was closely related  , SAX uses partial execution to compile the gramlnar for efficient bottom-up arsing  . However , instead of * Visiting researcher of Information Systems Product Development Lalmratories  , Sharp Corporation . 
building the chart by asserting edges into the Prolog database  , SAX implements the chart by creating concurrent processes  . For compiled rather than interpreted Prolog systems  , this is a highly etficient form of chart , parsing , even on sequen-tim machines . The terminal and nonterminal symbols of the grammar are realized as processes which communicate via streams to build larger structures  . A meta-process monitor stile strealns and controls l  ; he whole parsing process . 
The SGX generator is a concurrent SICStus Prolog implementation of the BCG parallel bidirectional chart generation algorithm  ( Haruno et al . ,:1993; Den , 1 . 994) . SGX uses partial execution to compile the grammar lot'efficient generation  . Like the CLE generator , SGX follows the semantic head-driven ( SHD ) generation algoril ; hm ( Shieber et al ,  1990 ) to ensurefficient ordering of the geImration process  . However , SGX also implement stile suggestion of Shieber et . al , thal ; backtracking and recomputation of results should be avoided by using a chart  , as in chart parsing . Like SAX , SGX implements the chart by concurrent processes and coin in unication streants monitored by a meta -process  . 
SAX and SGX accept definite clause grammars , with specific requirements o eliminate nondeter -minism  . Prolog code can be added to DCG rules as extra conditions  , buttile extra conditions must be deterministic . Empty categories are not supported in normal processing  ,   1 and SGX does not allow non-chain rules with uninstantiated logica  . 1 forms . 
1.2 Grammar formalism
Large DCG-t ) ased grammars typically have many rules , many categories , and many arguments per category . Such grammars could be efficiently pro-tossed by SAX and SGX  , but are ditficult to de-l If empty categories are really imcessary  , they can be handled in the concurrent processing system via a recta-process  . This approach is described in ( hnaichi and Matsumoto , 1995) tbrill-tbrmcd inputs . However , we eliminate traces by lexical rule , and welcome tlte proposals of ( Sag ,  1 . 995 ) for eliminating all empty categories from ItPSG . 
758 veh ) p and debug . CLE addressed this t ) roblemt ) y adopting GPSG grammatical theory midext ) ress-ing linguistic descriptions as flmture structures  , but the CI , Egrmnmm'still had many arguments per category and many rules  . We adopt Itl ) SG grammatical theory ( Pollard and Sag , 1994) and express linguistic descriptions in al ; yI ) e(1 feature formalism , lint we still ilnt ) le , ii ~ len the grammar in 1) CG for ln . 
S in (: e HPSG colle(' . tsallfe , atures into a strut > tured sign , the many I ) CG a . rguments are repla(:ed by a single HPSG sign . As H1 ) SG generalizes fl ' om category-based rules ( for S , NP , el ; t : . ) to schenms for phrasal signs , the many 1) CG rules are rel ) lat ; ed1) y a few generalized rules . Wesl)ec-if yase pa . rate logi(:alform(LF)f()rgeneration , as in ( Shieber et al ,  \]990) . Our I ) CG'categories therefore have the fin'mat word ( Sign ) /LF and phrase ( Sign ) /LF . 2 phrase ( synsem ! loc ! ( cat ! ( head ! HF g subcat !@ list l ( SubjSynsem ) cont ! Cont ) ) / i f ( Cont )  #word ( synsem ! loc ! ( cat ! ( head ! HF & subcat !@ list l ( SubjSynsem ) ) & cont!Cont ) ) / I f ( Cont )   . 
Figure 1: Thesour ( : e form of a grammarule Figure 1 shows the source form of a simplified version of It PSG Scheina  2 with zeroeoint ) h' , nmnt daughters . ~list1 is al ; emplate which ext ) and s to a list ; wil ; honememl ) ei ' . The  #symbol is required by SGX to identify the semantic  , head of ~ chain rule for SlID generation . 
1.3 Grammar compilation
The ProFIT system ( Erbaeh , 1995) iv an extension of fq'o log whic , hSUl ) ports a typed feature for-malis in with multiple inheiital we  . CLE used as orthierarchy only for senlantie seleetional restrictions  . HPSG uses a sort hierarchy also for syntactic resl  ; rictions , aim exploits multiple inheritmme for lexicon organization  . 
2 In this pape , r we follow ( Shieber et al , 1990) and ( Pollard add Sag ,  1 . 994 ) in equating logical form with semmltic ontent . A separate logical form is therefore redundant , as the . content f e . a ture could/)e used to <: ontrol SHD generation . I to we ver , logical form may need to include other inforination  , suet , as unscot)ed quantifiers ( HPSG q store ) , i ) resul ) positions ( IIPSG context ) , pragmatic and discourse factors ( in fact Shieber et al include mood ot ) erators )  . An important consequence of this is that a semmt tichead in the sense of the IIPSG Content Princil  ) le is not necessarily a semantic head in the sense of the StID generation algorithm  . 
ProFIT compiles the , typed hm ture formalism into Prolog terlns , which can be used with any appropriate parser or generator  . We therefore use I ) roFIT in order to combine I\[PSG g~ra , lrllIl&r with the SAX l ) a , i'ser and the SGX generator , 1) y( ; ) tit-piling the grmn mar in two separate stages . 
In the tirst stage , the typed feature structures in the I ) CG rules are compiled by I'roFIT into efficient Prolog terms  . Like CI , E , ProFfl't : ompiles feature , structures into terms , so that relatively slow unification offe , atures trucl ; uresire t ) laced t ) y relatively fast m fitication ofter in s . Also like CLE , l'rol!Tl ' uses the technique of ( Mellish ,  1988 ) tbr compiling finite domains such as index agreement into booh  ; an vectors for fast unification . 
In the second stage , tlle resulting I ) C ( \] containing only Prolog terms is CO ml ) ih' , dsel ) a . rately by the SAXl , rmmlatort ' or pa , rsing mid1) y the SGX tralls l & tor for generation .   ( ~ rgtHin & rules Call 1 ) e labelled to be compiled only by SAX or only by SGX  , st ) thai , parsing could for e , xaml ) le use some rules with wider coverage l ; hanothers used in gen-ergttion , while sharing I\[IOSt of the gra , in nl & r . 
Like the earlier BUP parser , the SAX transla-t ; or uses t ) art ; ial execution to t ) rodue efficient code for bol ; 1 ; om-ut ) (: hart t ) arsing . The SGX transla , to reont l ) ilestal ) les of chain rules and also uses partial ex ( ~eutiontol ) rt ) dut : efliehmt code for Sill )   ( : ha , rtge , ncration . 
1.4 Lexicon compilation
We , do not compile tile lexicon off : line ill / ; () a static list of signs . Instead , the existence of a lexieal sign is proved online by lexical inlhrence rules  . We specify a morph , ological lexicon in l;erfiu:e morph_lex(Forn ,   , Cat , \[ LF , Sign \]) where N ) rm is ~ . ~specific morl ) hological form , and Sign is a typed li , ~ a tut'e structure . Alexieal inference ruh , is shown in simplified form in Figure 2 . 
In ProFIT , sorts axe writl ; en as < sort and features as feature ! value . 
morph_lex(Vbse , word , \[ if ( Cont) , synsem ! loc ! ( cat ! ( head! ( vform ! < bse&aux ! < n&inv!<n ) & subcat !@ list l ( loc ! ( cat ! ( head ! < noun subcat ! < elist cont ! ( Subjg index ! < ref ) ) )   ) cont ! ( Cont ~ < pso a & quants ! < elist & nucleus ! ( reln ! Reln
Role ! Subj )))\]) verb(Vbse , Rein , \[ np/Role\]) . 
Figure 2: A morph Jex rule for a verb baseform HPSG lexical signs from a database of simple Prolog clauses  . Such rules can partially reuse available non-HPSG lexical information  . The example assumes a lexical entry such as verb ( walk , walk 1 , \[ np/agent\] ) specifying a verb with baseform walJg and sense , walk 1 , which subcategorizes for a noun phrase subject assigned to a thematic role agent  . 
We also use rules like normal HPSG lexical rules , to derive new signs fl ' om other lexical signs for morphological derivations  , complement extraction and so on . We have no automatic defaults , so these rules must be written carefully . The simplified example in Figure 3 instantiates nominative and 3rd singular in the first subcat item , and copies the rest of subcat by unification . 
morph_lex(V3sg , word , \[ if ( Cont) , synsem ! loc ! ( cat ! ( head! ( vform ! < finaux ! < n&inv ! < n ) subcat ! ( first!loc ! ( cat ! ( head ! case ! < nom subcat ! < elist ) cont ! ( Subject index ! agr ! ( 3& sg ) ) ) rest ! Rest ) ) cont! ( Cont & nucleus ! rel n ! Reln ) )\] ) morph_lex ( Vbse , word , \[ if ( Cont) , synsem ! loc ! ( cat ! ( head! ( v for m ! < b seaux ! < n & inv ! < n ) subcat ! ( first!loc ! ( cat ! ( head ! < noun subcat ! < elist ) cont ! Subject ) grest ! Rest ) ) cont!Cont ) \] )  , morph_infl(verb_3sg , Vbse , Reln , V3sg ) . 
Figure 3: Lexical rule for 3rd singular verb form The typed feature structures in the lexical rules are compiled by ProFIT into Prolog terms  . The resulting rules arc then compiled by SICStus Prolog  , together with the database of simple lexical entries  . 
2 Delayed lexical choice
Delayed lexical choice is an established technique in natural language generation  . When a backtracking algorithm is combined with a lexicon of morphological forms  , there is considerable nondeterminism during syntactic generation  , because features required for a deterministic choice of morphological form are not yet instantiated  . With delayed lexical choice , a lexicon of stems is used during syntactic generation  , and the choice of morphological form is delayed to a postprocess  . Instead of producing a string of wordforms , syntactic generation produces a string of lexical items  . 
The morphological postprocess converts the lexical items to final lexical forms  , when all required syntactic features have become instantiated  . 
2.1 Monotonicity
Describing the implementation of delayed lexical choice in the  MiMo2 system , Shieber et al ( 1990 ) pointed out that only monotonic rules ( which tilt-ther instantiate the feature structure of alc xi-calitem but do not change it  ) can be delayed . 
For example , the choice of singular or plural verb i ' or m can be delayed until after the subject has been generated  , by perforIning syntactic generation with a lexical item based on the verb stem  , which does not specify singular or plural . By contrast , a lexical rule for passivization which changes the order of items on the subcat list is nonmonotonic  . Both the active and the passive variants must be made available as distinct lexical items during syntactic generation  , a In an inheritance-based typed feature formalism  , monotonicity is tmilt into the subsumption relation in the sort hierarchy  . As ort subsumes its subsorts , which may further instantiate its features , but cannot change them . We exploit tile monotonicity of subsumption i the sort hierarchy in our implementation of delayed lexical choice  . 
2.2 Syntactic-semantic lexicon
In place of the MiMo2 lexicon of stems , we specify a syntactic-semantic lezicon interface synsem Jex  ( Lex , Cat , \[ LF , Sign \] ) where Lex has no significance for generation . Entries in tile syntactic-seInantic lexicon are derived by a small number of lexical rules from entries in the morphological lexicon  . Like the morph Jex rules , the synsem_lex rules are compiled first , by
ProFIT and then by SICS tus Prolog.
To implement delayed lexical choice , we use the synsem_lex interface during syntactic generation  , and then use the morph_lex interface in the morphological postprocess  . We must thereforensure that the delayed morph_lex rules will be monotonic  . We do that by ensuring that tile synsem_tex entries subsume the morph Jex entries from which they are derived  . 
Figure 4 shows a simplified form of a synsem_lex rule for verbs  . The rule derives the synsemJex entry from tile morph Jexbase form entry  , in which v form has a vahm of s or t < bse . The subcat of the synsem_lex entry is unified with the subcat of the a we currently make such variants available via alternative forms of the lexicon access rule  ( Section 2 . 3) . 
This could be improved by using constraints to enable subcat-changing rules to be delayed  ( van Noord and Bouma , 1994; Meurers and Minnen ,  1995) . 
760 morph_lex entry , so that the synsem_lex entry subcategorizes for the appropriate synt  ; acticomple-inents . The morptl_lexbase form entry is used so that the agreement Datures of tile subject  , will not t ) c restricted . The content vahte , s are also unified , so that the synseni_lex entry in chldes the appro -I  ) riate semantic roles . However , the head Datures are not unified . Tile synsemJex v form has a value . 
of s or t < v form , wtfich is tim immediate supersort of the mort ) hJ exv form sort , < bse . Instead offlfll unification , the synselnJexhea(lfeat , ures ut ) sumc those of them or I ) hJex entry . 
synsem_lex(Lex , word , \[ If ( Contg < psoa ) , synsem ! loc ! ( cat ! ( head! ( v form ! < v form aux ! < n & inv ! < n ) subcat ! Subcat ) cont ! Cont ) \] ) morph_lex ( Lex , word , \[ if ( Cont) , synsem ! loc ! ( cat ! ( head! ( v for m ! < b seaux ! < n & inv ! < n ) subcat ! Subcat ) cont ! Cont ) \] )  . 
Figure . 4: A synsem_le . x rule for verbs 2 . 3 Grammar-lexicon interface In I ) CG-based systems , the interface between the grammar and the lexicon can often m speciiied by a DCG rule which accesses the lexicon by means of an extra condition  . In our fl'a mework , such a rule might , be:word(Sign)/LF-->\[Word\] , morph_lex(Word , word , \[ LF , Sign\]) . 
I lowev cr , since our concurrent t ) roeessing algorithms require extra conditions to be deterministic  , such a rule would find only one lexical entry ( the first unifiable one )  , which would depend on the order of lexical rules and lexical entries  . 
For parsing this is not a problem because , like CLE , wcuse a morphological preprocess which performs lexicon access  , building a morpheme lattice to be passed to the syntactic parsing pro-tess  . Lexicon access is therefore separated from the parsing algorithm  , and is not required to be deterministic . 
For generation with delayed lexical choice , we use a modified form of the nile : sgx word ( Sign ) /LF-->\[Sign\] , synsem_lex(Word , word , \[ LF , Sign\]) . 
The label'sgx ' shows that the rule is to be compiled only by SGX  , not by SAX . It differs from the previous rule not only by accessing the synt  , act , ic-semantic lexicon instead of dm morphological lexicon  , but also by speci\[ying that the lexical item is \[ Sign \] instead of \[ Word\]  . That is , the output of syntactic geueration is a string of HPSG signs  . 
2 . 4 Semant ic head-dr iven generat ion When syntactic generation begins  , the StlD algorithm uses chain rules ( like the rule ill Figure 1 ) to identify timpiw ) t , the semantic head of the scn-t , ence . The synsemlex entry for the pivot is then accessed by the  . extra condition in tile DCG rule above . .
Since the synsem_lex entry for verbs ( Figure 4 ) does not specify subject agreement or v form subtype  , but does specify subcategorization ad semantic roles  , it can be used equally well as the sc . -mantle head to drive syntactic generation of , say , a 3rd-singular finite clause or an infinitivale om-t ) lemt ; nt . Since a single entry (' . all be used in this way , the extra condition can be detcrt ninist , ic , as required . 
If the verb is the head of an infiniti wll con > p\ ] enlent  , its v for nll/e conlesil mtant , iat , ed to < bsefl ' om subcategorization by the auxiliary to  . If t , hcvert ) is the head of tl temain clause , its v form be-eonms instantiated to < f in ( finite ) by a rule R ) rgrammatical mfit , s in our grant mar . 4 After syntactic generation , the string of IPSG signs is conw~rted to a string of wordforms by a morphological t  ) ost process , which unifies the signs with entries in the . in or phological lexicon . As the signs are t\]llly instantiate during syntactic generation  , this postprocessial so deterministic . 
a Reversible delayed lexical choice
Most forms of robust parsing are based on coil -straint  , relaxation . Our approact l to delayed lexical choice is based on using less instantiated signs flom the syntactic-semantic lexicon  , rather than the more instant , iated signs from the morphological lexicon . Tiffs can be viewed as equivalent to constraint , re . laxation . It therefore seelns reasonable to consider eversing the approach  , using delayed lexical choice for parsing . 
Constraint , relaxer , ion in parsing typically has a two-pass approach . Strict parsing is attempted with normal gralm nar ules and the normal parsing algorithm  . If strict parsing fails to produce a parse , relaxed parsing is attempted , using a modified algorithm or modified grammar ules  . With a lexicalist grammar like HPSG it seems more appropriate to use modified lexical rules  , as in our syntactic-semantic lexicon . 
4In addition to the HPSG categories word and phrase  , we have a category gram_unit for grammatical units which can be uttered independently  . These include finite sentences , accusative NPs , and others . 
The rule for gram_unit thus instantiates certain tha-I  , ures which arc " required for wellformed generation  . 

However , in our approach to delayed lexieale hoice we do not start with strict constraints and then relax them  . On the contrary , we start with relaxed constraints from less instantiated signs and then further instantiate the signs as other constraints become available  . Our approach is therefore incremental description refinement  ( Mellish , 1988) rather than constraint relaxation . 
3.1 Parsing and generation with delay
When the syntactic-semantic lexicon is used for generation  , tile logical form is the retriew flkey , and the name of the lexeme is irrelew mt . In tile interface synse In_lex ( Lex , word , \[ LF , Sign\]) , the variable Lex does not need to be unified with the name of the morpheme in tile morph_lex entry  , and could be given another value , such as " verb " . 
However , if we use the syntactic-semantic lexicon for parsing  , tile value of this variable will be the retrieval key  . If the value is taken directly from the words of the input string  , it will not necessarily unify with the name of the morpheme in the morph_lex entry  . 
In the case of verbs ( Figure 4) , where the input word may be an inflected form but the synsem_lex entry uses the morph Jex entry for the baseform  , wenms t first use the morphological preprocess to obtaintile " root " form of the word  , which is the same as the baseform . We then use tile root form instead of the input form as the retrieval key  . In the ease of pronouns , which take different forms according to case and reflexivity but have no natural root form  , the input form is used directly as the retrieval key  ( Section 3 . 2) . 
Since the synsem_lex entry for verbs in Figure 4 does not restrict subject agreement , an ill-formed input withine or rect subject verb agreement is parsed in exactly the same way as a wellformed in tmt  . The ' subject agreement in the verb's sign remains uninstantiated until the subject and the verb phrase are combined by Schema  1  , when the agreement features are instantiated to those of the subject  . So " sheswim " is accepted , but only " sheswims " is generated illa finite clause  . 
Tile synsemAex entry in Figure 4 also does not , restrict v form , which remains uninstantiated until the verb phrase is combined into a larger phrase  . 
So " she can swimming " is accepted , but only " she can swim " is generated , since " can " subeatego-rizes for a VP with v form of sort  , < bse . 
3.2 Experimenting with delay
Of course , difl'erent specifications in tile rules for the syntactic-semantic lexicon produce different etfects  . Intile synsem_lex entry for pronouns in Figure 5 , instead of unifying tile head feature case with the morph Jex entry  , the head is specified only assort < noun , leaving the case unspecified . 
There are distinct morph Jex entries for nominative and accusative forms of personal pronouns  , but it is irrelevant which one happens to be found when the rule is executed  , because the rule does not unify the head features which include case  . 
So the synsem_lex entry can be used deterministi- ( : ally for syntactic generation , leaving tile case to be instantiated from subcategorization by a verb or preposition  . 
In parsing , tile effect of this form of the rule is that the case of an input  , pronoun is ignored . 
Whether this is good or bad depends oil both the language and tile level of relaxation desired  . This form of the rule would clearly be unsuitable tbrfree word order languages  , but seems useful for English , accepting " foryon and I " but generating ' ~ for you and nle ' ~  . 
synsem_lex(Lex , word , \[ if ( SynsemCont) , synsem ! loc ! ( cat ! ( head ! < noun subcat ! < elist ) cont ! ( SynsemCont & < pron index ! Ind exrestr ! < elist ) )\] ) :- morph_lex ( Lex , word , \[ if ( Morph Cont) , synsem ! loc ! ( cat ! ( head ! < noun subcat ! < elist ) cont ! ( Morph Cont ~< pron index ! Ind exrestr ! < elist ) )\] )  . 
Figure 5: A synsem_lex rule for pronouns In Figure 5  , the synsem_lex content value is not unified with the morph Jex content vahm  . Only the index values are unified , including tile gender , number and person features essential for pronouns  ( tile restrvahms are elnpty lists )  . The contant values are constrained only to be of sort < pron  ( pronominal )  . Ill the sort hierarchy , < pronhas subsorts < ana ( anaphoric ) and < ppro ( personal-pronominal )  , and < ana has its own subsorts < ref1 ( reflexive ) and < recp ( reciprocal )  . HPSG binding theory is based on these sortal distinctions  , which are part of the content value . 
Again , there are distinct morphJex entries for reflexive and personal-pronominal forms  , but , it is irrelevant which one happens to be found when the rule is executed  , because the rule does not unify the content values  . Therefore the synsemJex entry can be used deterministically for syntactic gemeration before the sort  , becomes instantiated to < an a or < p proby the binding principles  . 
Tile effect of this form of tile rule is to relax the binding constraints in parsing  , accepting " I sawme " but generating " I saw myself "  . Of coursetile distinction between " They saw themselves "  ( coindexed ) and " They saw them " ( e ontra-indexed ) is also lost in parsing with this version . The binding the content values in the rule , but the above version is not neee . ssarily bad , for example in parsing nonnative English . The rule could t ) eim-t ) roved by having alternative forms which distinguishard and non-ard person  . 
4 Conclusion
Our fralne work seeks to combille the elegance of a typed feature for nlalisln and IIPSG syntactic theory with efficient processing  . The ProFIT system gives an efticient encoding of typed feature structures  . The SAX and SGX systems use an efficient ( : hart implementation , and their concurrent processing algorithms give turther motivation for eliminating enlpty categories and reducing nondeterminism  . 
W c have addressed the issue of bidirectional use of shared linguistic descril  ) tions , rather than robust parsing . I to wev cr , the idea of using delwed lexical choice in reverse makes it possible  , widlout modifying the parsing and generation algorithms  , to parse certain types of ill-formed inputs and to generate corresponding wellformed outpul  , s , using the same shared linguistic descril)tions . 

The first author would like to thank Mr Ilitoshi Suzuki  ( Sharp Cort ) oration ) and Profaun-ichi Tsujii ( UMIST ) for making this work possible . We also thank DrKristi in a aokinen ( NAIST ) and the anonymous reviewers for valuable conlinetll  ; s . 

Hiyan Alshawi , editor . 1992. The Core Language
Engine . The MIT Press.
Yasuharul ) en .  1994 . Generalized chart algorithm : an efficient ) rocedure for cost-based abduction . In 32nd Annual Meeting of the Association for Computational Linguistics  , pages 218225 . Association for Computational Linguistics . 
Gregor Erbaeh .  1995 . ProFIT : Prolog with Features , Inheritance , and Templates . In Seve'nth Conference of the European Chapter of the Association fin " Computational Linguistics  . Association for Computational Linguistics . 
Masahiko Haruno , Yasuhm ' uDen , Yuji Matsu-mote , and Makoto Nagao .  1993 . Bidirectional chart gene . ratioil of natural language texts . In Proceedings of the Eleventh National Confer -ertcconArtifici allnt clligence  , pages 350356 . 
AAAI Press/The MIT Press.
Osamuhnaichi and Yuji Matsumoto .  1995 . Integration of syntactic , semantic and contextual information in processing rammatic Mlyill-fi  ) rmed inputs , in I ) ~vccedings of the Fourteenth International Joint Conference on Artificiallnt elligenes  , pages 143540 . 
Yuji Matsumoto and \] yoichi Suginmra . 1987.
A parsing system based on logic programming.
In Proceedings of the Tenth International Joint Conference on Arli Jieial Intelligence  , volmne2 , pages 6714 . 
Yuji Matsumoto , Yasuharul ) en , and Takehito Utsuro ,  199 , 1 . Koubunkaisekishisutem ' aSAX , shiyouset sumcisho ( Parsing system SAX Man-hal ) w ' . rsio'u2 . 1 . Nm'a Institute of Sci('nc(~and

Christoph (: rS . Mellish .  1988 . hnph'm cnting systemic classification ) ymfitication . Compv . ta-tional Linguistic , 14(1): 4051 . 
W . Detmar Meurersan (\[ Guido Minnen .  1995 . A ( : omputational treatment of IIPSG lexical rules as cow ~ riation i lexical entries  . In Proceedings of the I~fth International Workshop on Natural Language Understanding and Logicl ' rogram-ruing  , Lisbon , Portugal . 
Carl Pollard and Ivan Sag .  1994 . Head-driven Phrase Structure Grammar . University l'ress,

Ivan Sag .  1995 . English relativ (?(: laus cconstrue-dons . Unpublished in a nuscript . 
Stuart M . Shiet)er , Gertjanwm Noord , Fernando C . N . P (; reira , and lobert C . Moore . 
1990 . Semantic head-driven generation . Con > putational Linguistics , 16(1):3042 . 
Gertjan van Noord and Gosse Bouina . 1994.
Adjuncts and the 1) recessing of lexical rules.
In 15th International Conference on ComFu-rational Linguistics  . Association for Computational IAnguistics . 

