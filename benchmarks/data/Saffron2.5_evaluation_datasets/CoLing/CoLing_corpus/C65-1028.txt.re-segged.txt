

" International Conference on Computational Linguistics " 
MORPHISM : ASYMBOLICLIST PROCESSING LANGUAGE
Vandenburgh Harold R.
Laboratoire de Calcul Automatique
Faculte ~ des Sciences
2, Place Pasteur
RENNES-FRANCE


MORPHISM : ASYMBOLICLIST PROCESSING LANGUAGE


With the formal study of natural languages , we have obtained some residual results which greatly increase our power of logical manipulation  . Coupled with a computer , our language extends enormously the external logic of our computing device  . This paper is concerned with a well-defined symbolic list processing language and a set of operators for this language  . These operators , which we call morphisms , are themselves operators thereby giving us an indefinite nesting ability  . We have defined a schematic representation of ' our operators  ( called a comb-scheme ) and have then proceeded to describe a numbering technique which allows us to use these operators with a computer  . Since our operators and lists are defined at the time of execution  , our ability to change them is unlimited . 
The pattern of this paper is to build up from an alphabet to words  , then non-connected words , then lists and the operations on lists and finally operations on the operations  . We have taken , what we hope to be , descriptive examples in linguistics and non -linguistical applications in the hope of being representative of our language and easily understandable  . 
VANDENBURGH 1.
MOP , . PHISM : ASYMBOLICLIST PROCESSING LANGUAGE
Introduction
We at the Facult ~ des Sciences of the Umverslte de Rennes are interested in the mathematical study of languages  . Since we have a computer (1620) , it is only natural that we attempt to combine the two  . With languages being our major interest , we find that an extensive study of lists and symbolic list processing techniques will yield a most powerful and broad spectrum of results when applied to a computer  . 
It appears that problems involving natural languages and certain types of mathematical p roblems are computer solvable when list processing techniques are applied to them  . There are also linguistical problems which yield beneficial results when they are approached in this manner  . 
We are therefore going to define : lists , operations on lists ( which we call morphisms ) , and a comb-scheme which allows us to manipulate the lists and morphisms  ; this scheme gives us the ability to manipulate a lmost any pattern that can be handled in a logical manner  ( in linguistic usage , the term logical will refer to letters , words , sentences , phonemes ; in a predetermined or random occurrence ) . 
We have defined our operators in such a manner that we allow for an indefinite nesting  ; adding to a computing machine an external logical system  . Also , our operators , in the computer , are defined at proces ~ ing time soourability to change them at execution time is unlimited  . 
This paper can be considered to be divided into four sections  . 
Part one defines our terms and gives definitions for such things as an alphabet  , lists , words , non-connected words , etc . Part two defines a morphism and our operators on lists  . Part three shows our comb-scheme . Part four consists of examples : in linguistics ; an example in the logical generation of a flowd i a gram into a computer program  ; and finally , an example of the solution of a mathematical p roblem  ( the arithmetic operations on polynominials of n variables  )  . 
VANDENBURGH 2.
I . Definitions
I.1 Words and Symbols
Since we are using a computer , composed of : let us define our alphabet to be the Latin capital letters the blank  ( # ) for notational purposes but on printed page a blank  . 
the punctuation marks . and , -the digits excluding := -$/+@ (   ) and 0 which is also acceptable to the computer . 
I.Z Non-connected words
Let us put in parallel the Latin phrase : nec adulatoribus latus praebes and its French equivalent : ettune pretes pasle flan caux flat teurs  ; The Latin wordneccor responds , in French , to the three nonconsecutive words e_t . . . n . e . . . pa_ . ~s and the Latin word praebes corresponds to tu . . . prates Thus it appears that for the words of a language  , on the same level as words , there is a series of words not necessarily consecutive : the non-connected words  . For a non-connected word , the components will be separated by the symbol : -   . For example:
ATA-BP,_IQUE
RI-DO-are non-connected words . The first has two components and the second has three components  . 
1.3 Comb-scheme
In the formulas , as in algebra , we designate a variable by x ( and , eventually intervening variables by Xl , x2''") ; a non-connected word of N components will be schematized by a combor comb-scheme 
VANDENBURGH 3.
(eventually t rans formed into a number ) of N teeth ordered from left to right ( eventually numbered from 1 to N ) such that the first tooth represents the first component  , the second to oth the second component , etc . 
1Z 3456 i . 4 Lists of non-connected words ; We will separate the lists of non-connected words by a /  . 


RA/TA-PLAN/PLAN-PLAN is a list of three non-connected words : the first of one component  ; the other two , two . We will schematize the list by :- ior if need be by:  1 Z 3 or again by : iZ 3 
IZi Zi .   5 Designation of lists and their types We will designate a list by a symbol  ( name , a set of letters and digits ) . We will enclose the symbol by the sign@ . This avoids
VANDENBURGH 4.
confusing the name of a list with elements of the list e  . g . 
@ ABS@=A-B/C/D-E-F where AB5 is an element ( or word of our alphabet )  ; but @ AB5@designates a list . The list is:
A-B/C/DE-F .
It should be mentioned that a list can be recursive : it may contain a list  ( i . e . the name of the list enclosed in@signs wh ich  , of course , refers to another list ) . 
A type of list will be indicated , not by a series of combs which are not part of a keyboard  ; but by the particular list of the type where all of its components are empty  ; enclosed by two@signs . 
For instance , @-//--@ designates a lists chernatized by : i 2  . Morphisms , List operators , and comb construction 2 .   1 Morphisms or operations on lists Let@L IST  1  @ , and @ LISTZ@betwolists . We will define the operation juxtapos it ion  ( putting them side by side ) which we will designate by the sign / . For example : @ LIST1@/@LISTZ@ . 
In a like manner , we will use the notation-to show the insert ion of a word  ( or list ) into another list . For instance the expression :
A-/B-C-@X@/@Y@UT
VANDENBUP ~ GH5.
if we define :@ X@:D-E/F/GH@Y@=T and becomes A-/B-C-D-E/F/G-H-TUTZ  . Z List ordering and comb scheme construction Let us consider the following French sentence  . 
jeneve uxpa_._~s.
It is written in our alphabet as:

and this constitutes a word in our alphabet . It perhaps may be constructed with the aid of the following non-connected words :  ( i ) JE-VEUX ( 2 ) NE-PAS ( 3 )  #  ( non-connected word of one component )   ( 4  )   . 
these words , thus ordered , constitutes all stschematized by : 1Z 34

Shuffled according to the following scheme : the non-connected words of the list  , each one take nonce or many times ( the @ is taken three times )  , is shuffled into the components of one against the other : thus a juxtaposition of the various components in the order where the preceding shuffling places them  . 
VANDENBUKGH 6.
Z3334-Jwestarted . We will call it the source of the morphism . 
The second line represents how we have shuffled the various teeth of the source  . We will call it the graph of the morphism . 
The third line represents the non-connected word  ( here of a single component )   . We will call it the target of the rnorphism . 
The three line schematic represents the morph is m  . 
It should be clear that since the first l in e of the schematic represents a list  , the morphism can operate on any list of this type  . 
Thus , the list :
A-B/C-D/E/F
AECEBEDF will become
The morphism conserves in each non-connected word the order of its components  ( JE preceeds VEUX , etc .  ) . This is a condition we may or may not impose on a morphism  . If we impose it , we are saying that it is forbidden to cross the teeth of the combs  . 
Let us note that we could also have const ructed the sentence : jene veuxpas  . 
by starting with the list :
JE#-VEUX/NE#-#PAS/.
VANDENBURGH 7.
which yields the following morphism :
I . Z .3
E , Ii ~ II
Let us briefly consider the following German sentence : 
Dura ~ nst diesesein.
We could define it with the following li st:DU-ST/EIN-R  . AUlVi/DIESES/#/ . 
from which we obtain the following morphism.
<#9-i.I ~.3 LIi
Here the morphism commutes the teeth of the second comb of the source  . 

VANDENBURGH 8.
2.3 Numerotizing the morphisr r ~
It is more convenient to use numbers instead of teeth and combs for the input to a computing machine  . We have therefore designed the following type of numbering system for our morphisrns  . 
We will define a morphism by a symbol ( set of letters and digits )  . 
We shall p1"ecede this symbol by the sign $ . For example : $ PSI will designate a morphism . 
Let @ A@bealist of the source type of $ PSI ; the resultant list of @ A@transformed by the morphism will have the following notation : $ PSI  ( @ A @ )  . 
The morphism itself will be notated by the following type of its source list between two $ written as a series of integer triplets representing the series of teeth of the graph : the combs of the graph being ranked in the order of the encounter of their first teethgoing frorn left to right  .   . % 11 of the teeth of the graph will be represented by three integers each one being separated by a comma:i  ) the rank of the comb of the graph to which it belongs  ; Z ) the rank of the corresponding comb of the graph ;  3 ) the rank in the comb of the source of the tooth , corresponding to the given tooth of the graph . 
The target and the correspondence between the graph will be indicated by the symbols - and / placed between the triplets : two triplets separated by the sign  . , correspond to a similar to oth of the target ;
VANDENBUKGH 9.
two triplets separated by the sign-correspond to two different teeth of the target belonging to a single comb  ; two triplets separated by the sign/correspond to two different teet h belonging to two different combs  ; two triplets separated by the sign . will correspond to the same tooth of the target . 
For example , let us describe the rnorphisrn for the previously mentioned German sentence : dura\[h~nst dieses ein  . We shall call it $ PHI and schernatize it as follows : i  2_   3 W
I ~ . . I L I 1 ~ Z ~ ~ J $ PHI =@ - / - /// @ $ I , i , i . Z , 4, 1 . 3, Z , Z . I , I , Z .  4,4, 1 . 5,3, 1 . 6,4, 1 . 3, Z , 1 . 7 , 5 , i $ For a second example , let $ PSI bether norphisrnschernatized by:
I ~-3%
II 1 II

I 1I
Il$PSI=@-/-//@$I,1,3 . Z , 3, 1 . 3, Z , 1 . 4, 3, ii , I , Z .  5,3, 1 . 3, Z , Z .  6,4, 1--/7,4;15
VANDENBUKGHi 0.
In this example , the third tooth of the first comb of the ta rget does not correspond to any tooth of the graph  ; this is indicated in the series of integer t riplets by the empty components having thes ign /  . 
When we forbid the crossing of the teeth in the comb  , the third number of the triplet represent ing a tooth of the graph is ambiguous for our notational purposes  . We may , therefore , reduce our notation from triplets to coup lets  . 
Thus $ PSI would be come : $ PSI = @-/-//@$ i , i .  2,3 . 3,2 . 4, 3-i , 1 . 5,3 . 3, 2  . 6,4- /7,4 5  . 
Z .   4 Operations on the lists by morphisms In a precise manner  , we can show that the scheme of a morphism $ 1AO is determined by the input of the lists . The first having the notation : @ x@ composed of word signs differing from each other and such that $ RO can operate on itsel f  ; the second , transformed from@X@by$RO and having the notation : @ Y@=$Ro  ( @x@ )  . 
The source and the target of the scheme is none o ther than the schemes of @ X @ and @ Y@r espect ively  . This is due to the graph that is given by the comb-bindings of @ Y@as each one can be ident ified  , tooth by tooth , from a comb of the source . 
In effect , the comb schemes of @ X@coincide with the comb-bindings  ; by series , if two letters of the substance@Y@of@Y@ have the same path  . The combs of a graph of $ 1%O are none other than the comb-bindings of @ Y@ in position  . Moreover , since all the word signs of @ X @ are dist inct between  , we have the ability to distinguish the combs from each other  . Thus , we know which comb of the source corresponds to which comb of the graph  ; and in this comb of the source which to oth cor responds 
VANDENBURGHII.
to which toothunder consideration ; equally , we know , thanks to the - and / , the group of teeth of the graph which has joined the above bracketing of the teeth of the target  . 
We can , therefore , reconstitute the complete scheme of the morphism $ I % O  . 
Here is an example.
@ x @=@ Y@-!

U\[-/I1!
AB 1....+
The morphism $ RO which transforms@X@into@ Y @ for its scheme:  2  .  2 4-
III 11I ~2.32 - has % -
I@Y @=$ Ro(@x@)
VANDENBUR . GH 12.
For a second example let@M@be:
L !:\[" III"1
NI~l . 2.
and the word is transformed by the morphism $ IZO of the following scheme :  9  . . "~
I ~..\]2.

I 1-~ . j from the list : i i i i i i i / L ' J , , g iv ing : .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
@ x @=@ Y @=!:7 . X ~_____ is the word@M@is none other than :
SRO ( A /@ X@/@Y @ ) where A/@X@/@Y@designates the product of a juxtaposition : 
VANDENBURGH 13.
A/'/"?Xz "-" Az--JL!:
The above is simply to say that the real ways exists a form of this comb-scheme and list type structure  . Our canonical form ( going from left to right ) for :
Iill ! ! canonical is as follows : $ RO ( A /@ X@/@Y @ )  . 
2.5 Operators defined from morphisms
We are going to define from the rnorphisms some operators on sets of lists  . We will show later that the operators are themselves morphisms : therefore they are recursive and this then gives us the ability to have an extended logic for our computing language  . 
There are three operators for our morphisms : the /product  , the // product and the ~ product ( or composition )  . 
I . The/product of two morphisms
Let $ RO and $ MU be two morphisms.
following notation :
The/product has the ($ R . O/SMU ) and is defined for any list @ X@:
VANDENBURGH 14.
($1%0/$MU ) (@X @ = $ RO ( @ X @ ) /$ MU ( @ X @ )   ( i . e . the l is transformed by $1%O/$MU of @ X@ is the product of the juxtaposition of lists transformed from@X@by$I%O and $ MU  )  . 
II . The // product of two morphisms
Let $ RO and $ KHI be two morphisms.
/notation.
We shall use the following ($ RO//$KHD.
For any lists @ X@/@Z@ ( $ ROIISKHI ) (@X @ I@Z@ ) =$RO ( @ X @ ) I $ KHI ( @ Z @ ) It should be mentioned that the // product of two morphisms is defined only when they are from the same source  . 
III . The * product ( or composition of two morphisms . 
Let $1%O and SPI be two morphisms such that the source of $ RO is identical to the target of $ PI  . The * product has the following notation : ( $ Ro ? SpI ) 
For any list @ V@ ( $ RO*$PI ( @ V @ ) =$ RO ( $ PI ( @ V @ ) ) It should be mentioned that since the * product of two morphisms is defined only if the source of $ RO is identical to the target of SP l  , it thus transforms any list of source type of $ PI into a list of target type $ ao  . 
VANDENBURGH 15.
Z .   6 _Product of morphisrns are themselves morph is ms The operators defined in Z  . 5/product , // product , and ':'- product of morphisms are morphisms . 
In effect , they can be represented by schemes which are schemes of morphisms  . 

The scheme ( $ RO/$MU ) is constructed as follows : The first l in e is the source common to the schemes of  $1%O and SMU . 
The second and are those of SILO and $ MU placed side by side  ; those of $ MU to the right of those of $1% O . 
For instance , given : $1% O:$MU:
I , Il , I\[IkI
The scheme of ($ RO/$MU ) is as follows : t
VANDENBURGH 16.
The schemes of ( $ RO //$ KHI ) are constructed as follows : We modify the number of the combs of the scheme of $ KHI while adding to each of them the number of combs of the source of $ RO  ; thus , we can place the schemes of $1ZO and $ KHI side by side ; those of $ KHI to the right to those of $ RO . 
For instance , given : $1% O : $ KHI:
I 1

Iqil
The scheme for ($ RO//$KHI ) is as follows : 2 .   . X1ILLI il 9 .   . 



VANDENBURGH 17.
The scheme of ($ RO ~' , '$ PI ) is constructed as follows:
The source is that of $ PI.
The graph is that of $ RO where we replace each comb  ( which is also a comb of the target of $ PI ) by the system of combs to which it corresponds in the graph of $ PI  . 
The target is that of SRO.
For instance , given : $ R.O:$PI:
Ii III lt-It
The scheme of ($ R.O'~

IIIII $ PI ) is as follows:

Il ~ A
VANDENBURGH 18.
To construct the scheme of the ~ product of $ RO and SPI  , we can also characterize it by its action on a list@X@of source type of $ PI : un iquely composed of word-signs different f rom each other  . For that , we will make $ PI act on @ X@ , then SRO on $ PI(@X@) . 
Retaking the previous example ; given :@ x@=
SPI(@x@)---%"fI
A ' ~ A ~ A3A~7.
from which is defined the scheme for ( $ RO?$pl )  . 
The different products / ,  // , and * defined between the rnorphisms are not associative between themselves  . They are associative when there intervenes only the product of a single sort  ( / ,  // , or ~ ) which permits in this case the suppression of parenthesis  . Thus: ( ($ RO ':' $ PI ) * $ XI )  =  ( $ RO * ( $ PI*$KHI ) ) may also be written as : $ RO * $ PI * XI . 
VANDENBURGH 19.
3 . Practical application of symbolic list p . roces . sing'3 . i Introduction The actual programming of a symbolic list processing system presents many interesting and varied problems and possibilities  . 
The power of this type of list manipulation opens the way to many hither to unsolvable  ( computer-wise ) problems . 
Now that we have defined our language , it naturally be hooves us to ask how , and to what , we can apply it . We are going to illustrate three different types of problems to show that we have a general purpose language  . The first will be a simple example of list processing manipula-ting variables in algebra  . The second will be an application of morphisms to generate FOP ~ TRAN  ( or any symbolic programming system ) in the same general manner of SHADOW but with the added difference that our input is a list instead of a single variable  . The third example will be an application to the natural languages  . 
3 .   2 Operating on polynominials using symbolic list processing We have written a program for the  1620 computer in FORTRAN which allows us to operate on sets of polymminials of N variables varied to a power p  . The only limitation being that of memory size i . e . 
Np size of memory . If we consider an external memory source such as tapes or discs this does not become much of a limitation  . 
The operations we are treating at present are addition  , subtraction , multiplication and raising to a power . We are considering the differenciation but that we will leave to a later date  . Mathematically expressed , we are doing the following : Let PI(Xl , X Z . . . . . XN ) and Pz(XI , XZ, . . . . . X N ) be polynominials when the variables can be raised to the jpower and all combinations  . An example will clarify this section . Let :

PZ 3   2   3 = X + 5X   6X + i + Y-CY + 4XY  =  -3Y   2   6X2y + X
VANDENBURGHZ 0.

We are able to compute Pl~:=PZ' P1  +  P2 ' and any combination of these pcly nominials . It turns out that this can be handled ve ~ . y easily as a function of lists . Our limitations , at Rennes , being simply memory size as we need to setup tables for the coefficients a nuthe  16Z0 is rather limited in memory capacity and lists are very heavy users of tables  . This limitation would be relatively nil , if we had an external memory device such as discs or tapes  . 
3 . 3 Generating computes . programs from flow charts . 
A practical application of the n norphisms is the translation of flow charts into programs  . This section is therefore concerned with that problem  . 
A typical flow charting or programming problem . Let us consider that we wish to solve the following general type problem : x =  0  . ( . i ) z0 . 0 and Y = -4 . O(I .  0)8 .  0
IREAm " ~ I~o " %/ oT ' the flow chart would appear to be of the following form  ( since there are no fixed rules for the logical flow or organization of a computer solvable problem  , this flow chart is as good as any ) . 
I ~- x => ~+ o . 1F"1-"f,-where:X0 = Z0 . 1 = 0  , X hdAXY0=-4 , Yl ViAX = 9 for our original problem . 
VANDENBURGHZi.
3.4 The ccmb-schematic
Let us number each box from left to right . Now let us draw 9 teeth and number then as follows ( we need the ninet has there are two possible flows for the lost to oth  )  . 
ll II 111 iZ 345 6789
It follows that the 9th toothmeets the first , illL1
Z3 456789 soletus jointhem:
Also , them , i , 123 the 8th meets the 3rd , and the 4th meets the 6th . 
we will have : ill kk 456 78
If we join
Now , for the sake of clarity , and to take advantage of our comb-scheme , we will re-number them as follows: 4   6   4   5   1 Z 3   3 
VANDENBURGHZZ.
3.5 The list of our flow chart
For t ~ elist of our flow chart , it is necessary to write only the imperati-~ e instructions  . We will generate the IF and the right parant heu ! s with the correct flow from our morphism  . Therefore , the list is as follows:
READI00, X0,
X : X0

Z = SQP ~ TF(X )
Y = Y + I . 0
Y-YIV lAX

X-XMAX

XIVIAX , YO , YMAX*Y ** 3 the program will also generate an END statement . 
The type of list is:

Using the definition of a list as in section two , we have : @ MU@=~EADi00 , XO , Xl VIAX , YO , YMAX/X=x0/Y=Y0/Z=SQRTF(X )* Y**3/Y=Y+I . 0/Y-Y MAX/X=X+0 . I/X-XMAX //0 ( the notation 0 is to signify the end of a list since a list may be of variable length  . For descriptive purposes , we will continue to use the/to delimit ane lement of a list and a-  ( dash ) to denote an inse~t . In practice , ( for this particular problem ) , we cannot use these symbols as they are used by FORTRAN and we cannot distinguish whether they are for FORTRAN or for our list processing language  . 
VANDENBU l ~ GHZ 3.
3.6 The Morphism
As mentioned $ PI(@MU@)=$i , I . 2, I .  3, 1 . 4, 1 . 5, i . 4, Z .  6, 1 . 3, Z . I , Z . $ or SPI(@MU@)=@/////--//--//@=$i,I . Z , 1 . 3, 1 . 4, 1 . 5, I . 4, Z .  6, 1 . 3, Z .  1 , 25 ( Since a morphism may be of any length , we must also define its length ) 3 . 7 Decomposing the morphism For convenience , let us reorder the morphism into tabular form . 
iBC 111
ZZ 1   3   3   1   4   4   1   5   5   1   6   4 Z 7   6   1   8   3 Z 9   1   1 We can scan the list Cuntil we come to an entry Z  . This will cause an IF ( to be generated . We follow this by the entry in the list ( in our case Y-YMAX )   . This is followed by a right paranthesis . The FORTRAN statement numbers are respectively the corresponding entry for  \]5 taken twice ( separated by commas ) and the value of i + l . 
This is true because all orders following an IF must have a path so they must be numbered i  . e . carry a statement number . 
3 .   8 Advantages and power of symbolic list processing with morphisms With the example shown here  , the real power does not come to light . 
However , there are somethings we can do here . We can take advantage of inserts . We can insert elements into our list by add ing an element to the end of the list and fo r putting a dash in the list  ; or we can even insert
VANDENBURGHZ 4.
a list/s within our original list by inserting the name of a new list/senclosed in two @ signs  . 
It should also be mentioned here that it is not necessary to punch redundant coding in the above example  . It suffices simply to add the number of the e lement to the morph is rnlist  . For instance in our example if we wanted to do another series of calculations over the same range  , we need only punch a new entry for Z ( or some other variable with another symbolic name  ) and repeat the tables . 
With a little imagination , it is easy to see that if we can generate an IF statement  , we can search to find out if our variable starts with the letters i  , j , k , i , m , or n and generate a DO statement . 
Unfortunately , this , despite IBM's claim of FORTRAN's compatibility between machines  , creates the problem of being machine oriented e . g . the 704/7090 etc . permit a DO loop to have a maximum value of 3Z ,   767 while the decimal machines will easily accept 99  , 999 . 
We could also attack the logical schematic of a flow chart with IF statements but this poses to the problem of ordinary usage and becomes completely computer oriented  . For example , we can generate a statement of the following type  :   ( i ) IF (   )  ~< ,  ~ , ( Z ) IF () ~ ,  ~  , 0 < (3) IF ( ) o ~ ,  ~  , " ~ Which pattern shall we select ? We can't accept the third one for a binary machine as floating point equality is a rather elusive an imal due to binary round off  . 
This example was chosen to demonstrate that with list processing we can generate FORTRAN programs  . 
VANDENBURGHZ 5.
3.9 Linguistic Transformations
Let us state the following rules ( not quite foreign to Ingwes ) :@SEN@----->$LA " , ~$ RO ( @SUB@/@VER @ ) @ vEK@----->@VER@ ( i = 0 , l , Z ,  3)
I@VER .@------~$ RO(@MOD .@/@ VER.@)
J 3   1 @ SUB@-----~#THEY-#HE-S #THE-LINGUISTS -@ VERO@----~#INSERT-#  ( or  #CLIMB-UP # . . .   ) @ MODI@~#BE-EN @ MOD2 @-->-#BE-ING @ MOD3  @ ------'~ .  #HAVE-EN $ RO is aschuffling which out of two intercepted words makes a third one  , according to the following scheme :
I : e . g . $ RO ( A-B-/C-D ) = A-CBD$LA is a " junction " of the two components in one : e  . g . SLA(A-B ) = AB . 
VANDENBURGH 26.
Now we can derive a sentence ( morpho-phonenaic rules are omitted in our sketch , they happen to be useless for this example . . . ) . 
@SEN@~$LA , : ~$1% O (  #THE  #LINGUISTS/$1%O ( @ MOD3@/$1% O ( @ MODZ@/#INSE1%T ) ) ) @ SEN@------~$ LA ~$1% O ( @SUB@/$t % O ( @ MOD3@/$1% O ( @ MODZ@/@VEt % 0@ ) ) ) that is e . g . 
 #THE  #LINGUISTS  #HAVE  #BEEN # INSE1%TING  #or in the shape of a tree . 
@SEN @
SLA ~'$ RO@SUB@I@VEt %@ #THE  #LINGUISTS @   VE1%3 @$ ao #HAVE-ENI@ Vm1%z  @  , $1% o#BE-ING/@VER0@#INSERT-#
VANDENBURGH 27.

J . P . Benz ~ cri , 3? lecons ( course and publication de la Faculte des Sciences del ' Universite de Rennes  , France ) . 
~', p .
F . Benzecri ; Linguistique MatHem at lque ( publication de la Faculte des Sciences del ' Universit ~ de Rennes  , France ) . 
See also paper being presented at the 1965 International Federation of Information Societes Congress  ( IFIPS ) in New York ? . by Professor J . P . Benzecrl ~ articularment for linguistical applications  . 
