An Integrated Architecture for Example-Based Machine Translation 
Alexander Franz , Keiko Horiguchi , Lei Duan,
Doris Ecker , Eugene Koontz , and Kazami Uchida
Spoken Language Technology , Sony US Research Labs
3300 Zanker P , oad
San Jose , CA 95134, USA
amf , keiko , lei , doris , ekontz , kuchida@sit . sel . sony . com

This paper describes a machine translation architecture that integrates the use el ' examples for flexible  , idiomatic translations with the use o1' linguistic rules for broad coverage and grammatical acctu'acy  . We have implemented a prototype for English-to -Japanese translation  , and our ewfluation shows lhattile system has good translation quality  , and only requires reasonable computational resources  . 
1 Introduction
Machine translation by analogy lo pairs of corresponding expressions in the source and target languages  , or " example-based transhtlion " , was firs ! proposed by ( Nagao 1984) . Recent work in the example-based I'rame work in chl des memory-based translation  ( Sate & Nagao 1990 )  , similarity-driven translation ( Watanabe 1992) , transl'cr-driven lachine translation ( Furusc &
Iida 1996) , and patten > based machine translation ( Watanabe & Takeda 1998 )  . 
The example-based approach promises easy translation knowledge acquisition  , more flexible transfer than brittle rule-based approaches  , and idiomatic translations . At the same time , the use o1' linguistic rules offers a number of important benel'its  . Detailed linguistic analysis can allow an example -based machine translation system to handle a wide variety of input  , since rules can be used to factor out all linguistic wMations that do not influence tile exampled  ) ased transfer . 
Rulebased language generation from detailed linguistic representations can lead to higher grammatical output quality  . Finally , a modular system architecture that uses domain -independent linguistic regularities in separate linguistic modules allows extending the system to much broader domains  . The HARMONY architecture for lkybrid Analogical aud rule-based njachine translation of naturally _ occurring colloquial hmguagccombines the adwm tages of both these approaches  . 
2 The Travel Domain
Our prototype implementation o1' the HARMONY architecture was designed to cover the " travel domain "  . This is composed of words , phrases , expressions , and sentences related to international travel , similar to what is covered by typical travel phrasebooks  . 
Two principles guided our detailed definition of the translation domain  . FirsL the translation domain should not be limited to a narrow subdomain  , such as appointment scheduling or hotel rcs cr wt tions  . Second , the expressions considered in the domain should reflect the fact that people quickly adapt to limitations in human-machiue or machine-mediated communication by simplifying the input  . For example ,   ( Sugaya et al 1999 ) found that the average lengthel ' actual human utterances in a hotel resmwation task using speech translation was only  6  . 1 words , much shorter than some o1' the data that has been used in previous work on speech translation  . 
' File current vocabulary o1'7 , 5 00 woMs is divided into a group o1' general words , a number of extensibl c word groups ( such as names el ' food items or diseases )  , and a number of a rea-specific wo M groups ( such as names of cities or tourist destinations )  . The travel domain is divided into eight " situations ": A general situation  ( including everyday conversation )  ; transportation ; accommodation ; sight seeing ; and postal ; and doctor and pharmacy . 
We created a corpus for this dolna in , and divided it into a development set o1'7 , 000 expressions , and a separate , unseen test set of 5 , 000 expressions . The development set is used for creation and refine lnent of the translation knowledge sources  , and the test set is only used for evaluations . ( Each evaluation uses a new , random 500-word sample from the 5 , 000 word test set . ) The corpus was balanced to illustrate the widest possible variety of types  o1' words , phrases , syntactic structures , semantic patterns , and pragmatic functions . The average lengthel'the expressions in the corpus is  6  . 5 words . Some examples from the development corpus are shown below  . Even though this dolnain might seem rather limited  , it still contains in any challenges for machine translation  . 
? Can I have your last name , please ?? Is this the bus for Shinagawastation ? ?   1 would like to make a reservation for two people for eight nights  . 
? Can you tell us where we can see some
Buddhis temples ? ? Most supermarkets sell liquor.
? Can you recommend a good Chinese restaurant in this area ? ? I'd like to change  500 Dollars ' in traveller's checks into Yen . 
? Are there any English . .speaking doctolw at the hospital ? 3 NLP Infrastructure The prototype implementation is coustructed out of components that are based on a powerful infrastructure for natural language processing and language engineering  . The three in a in aspects of this infrastructure are the Grammar 
Programming Language ( GPL) , the GPL compiler , and the GPL runtime environment . 
3.1 The Grammar Programming Language
The Gralnmar Programming Language ( GPL ) is an imperative programming language for feature -structure-based rewrite grammars  . GPL is al'ormalism that allows the direct expression of linguistic algorithms l ' or parsing  , transfer , and generation . Some ideas in GPL can be traced back to Tolnita's pseudo-unification for nmlisln  ( Tomita 1988 )  , and to Lexical-Functional
Grammar ( Dalrymple et al 1995) . GPL includes variables , simple and complex tests , and various manipulation operators . GPL also includes control flow statements including if-then-else  , switch , iteration over sub-feature-structures , and other features . An example of a silnplified GPL rule for English generation is shown in Figure  1  . 
WllSENT-- ) NPYN_SENT ! exist\[S in VPSUBJWH\] ; local-variable WIt_VP=\[$mVP\] ; local-wlriable WHPHP , ASE ; $ WHPHRASE = find-subfstruct in $ WHVP where ( ? exist\[$xWH\] )  ; $ dI=\[$WH_PHRASESLOT-VALUE\] ; \[$ WHPHRASESLOT-VALUETRACE \]='+' ; $ d2 = $ m ; /Figure IExample of a GPL Generation P , ule 3 . 2 The GPL Compiler GPL grammars are compiled into C code by the GPL compiler  . The GPL compiler was created using the Unix tools lex and y acc  ( Levine et al 1990 )  . For each rewrite rule , the GPL compiler creates a main action function , which carries out most of the tests and manipulatious specified by the GPL statements  . 
The GPL compiler handles disiunctive feature structures in an efficient manner by keeping track of sub-feature-structure references within each GPL rule  , and by generating an expansion function that is called once before the action function  . The coinpiler also tracks variable references , and generates and tracks separate test functions for nested test expressions  . 
3.3 The GPL Runtime Environment
The result of compiling a GPL grainmar is an encapsulated object that can be accessed via a public interface function  . This interface fnnction serves as the link between the compiled GPL grammars  , and the various language-independent addomain -independent softwar engines for parsing  , transfer , generation , and others . This is illustrated in Figure 2 . 

GI ) I + Grammar J Feature Slructure \] l ) cf initions . , . . . ----
GI)L Compiler \]
A clion leunctions l ? x pansionFunclions
Test Ftmctions
Compiled GI ) L Grammar
Software Engine ( parsers , Iransfers , gellcrators ,   . . . )

Feature Structt lre Library
P , el ) resentaiion
Testing code
Manipulalion code
Memory Management ) Figure 2 GILR untime Environmenl The compiled GPI . grammars use the feature structure library , which provides services for efficiently representing  , testing , manipulating , and managing memory for feature structures . A special-purpose in emory manager maintains separate stacks of memory pages for each object size  . This scheme allows garbage colleclion that is so fast that it can be performed after every a U empted GPL rule execution  . In our experiments with Japanese and English parsing  , we found that l ) el'-rule garbage collection reduced the overall read/write memory requirements by as much as a factor of four to six  . 
4 Source Language Analysis
Translation is divided into the steps ot ' analysis  , transfer , and generation . Sourcc-hm guage analysis is illustrated in Figure 3  . 
English analysis begins with tokenization and morphological analysis  , which creates a lattice that contains lexical feature structures  . I ) uring multiword matching , expressions from tile multiword lexicon ( such as White House or take on ) are detected in the word lattice , and new arcs with the appropriate lxical feature structures are added  . 
English lnpul
Morphological Analysis
Ilmt lice with Single-word gexicall : cature , qlructures ~ , 
Mulli-word Matching ~. ~ La Hice with Single and
Multiword texical t " eature

I gexical P , educlion Anlbiguity
P . educed l . exical Feature
N\[I'UCI . LII'e Lattice
VI'm'sing
Senleilial Fealure Slruclure

I Compiled
English l ' arsing

Figure 3 Architecture el ' the Analysis Module Lexical ambiguity reduction reduces then uln be rel ' arcs in the word lattice  . This module carries out part-of-speech tagging over the lattice  , and reduces the lattice to those lexical feature structures that arc part of the number of best paths that represent stile best speed/accuracy tradeoff  ( currently two )  . This calculation is based on the usual lexical and contextual bigram probabilities that were estimated from a training corpus  , but it also takes into account manual costs that can be added to lexicon entries  , or to individual part-of-speech bigrams . 
The resulting reduced lattice with lcxical single -word and multiword feature structures iparsed using tilt GLR parsing algorithm extended to lattice input  ( Tomita 1986 )  . The English parsing grammar consists of 540 GPL rules . The output is a sentential feature structure that represents the input to the transfer component  . 
10335 Transfer
Transfer I?om the source-language sential feature structure to the target-languages ntential feature structure is accomplished with a hybrid rule-based and example-based method  . This is illustrated in Figure 4 . 
IEnglish Scntcntial )
Feature Structure \[ Compiled l\[Tra , ,srer / I \[ Database I ! I Tra , , . <er~Matching\[;iiiiiiiiiiiiiiiiii . . . . . . . . . . . . . . . . . . .   . . . . . .
Figure 4 Architecture of the Transfer Module The input feature structure is passed to the linguistic transfer procedure  . This consists of a rule-rewriting softwar engine that executes the compiled English-to-Japanese transfer grammar  . 
The transfer grammar consists of 140GPL rules , and its job is to specify linguistic constraints on examples  , combine multiple examples , transfer informatiou that is beyond the scope of the example database  , and perl ' or m various other transformations . The overall effect is to broaden the linguistic coverage  , and to raise the grammatical accuracy far beyond the level of a traditional example-based transfer procedure  . 
The linguistic transfer procedure operates on the input feature structure in a recursive manner  , and it invokes the example matching procedure to find the best translation example for various parts of the input  . The example matching procedure retrieves the best translation examples from the example database  , which contains 14 , 0 00 example pairs ranging from individual words to entire sentences  . In an of l'-line step , the example pairs are parsed , disambiguated , and indexed for corresponding constituents using a 
Treebanking tool.
At each invocation of the example matching procedure  , linguistic constraints fl ' om the transfer grammar are used to limit the search space to appropriate xamples  . In a nol'l'-line step , these constraints are precompiled into a complex index that allows a preliminary fast match  . Examples that survive the fast match are matched and aligned with the input feature structure  ( or sub-feature-structure , during recursive invocations ) using the thesaurus to calculate word similarity , and using various other constraints and costs for inserting  , deleting , or altering slots and features . Rather than rely on the exact distance in the thesaurus to calculate lexical similarity  , we use a scheme that is based on the information content of thesaurus nodes  , similar to ( Resnik 1995) . 
6 Target language Generation
The Japanese target-language fature structure l ' orms the input to the generation module  , which is summarized in Figure 5 below . This module also consists o1' a rule-rewriting softwar engine , executing the compiled GPL Japanese generation grammar  , which consists ol'200 GPL rules . The generator uses the Japanese lexicon to create the Japanese target-language expression  . 
Feature Slrtl clure Compiled





Figure 5 Architecture of ~ . he Generation Module 7 Evaluation and Conclusions We evaluated the trauslation system using a random  500-expression sample from the unseen test set ( see Section 2 above )  . The translatious were manually assigned to one of the following categories  o1' translatiou quality : Failure . Complete translation failure , due to lack of coverage of a rule-based component . 

Wrong . A translation that is COlnpletely wrong , or that has major errors in an important part , such as in the main clause . 
Major Problem . A translation that has a missing , extra , or incorrect constituent , such as a subject , object , or adjectival/prepositional predicate . 
Minor Problem . A translation that l-ms a missing , extra , or incorrect minor part , such as an intensifier , tense , aspect , temporal or locative adjunct , adverb , adjective or other prenominal modifier , prepositional phrase , verb conjugation form , adjective form , or required word or constituent order . 
Stylistic Problem . Slylistic problems include awkward but tolerable word order  , incorrect Japanese particles , incorrect idioms , and silnilar . 
Flawless . A translation that does not exhibit any of the above problems is considered flawless  . 
The results of the ewtluation are shown in Table 1 below . Overall ,   84% of the translations convey the meaning in an acceptable manner  . 
We also ewtluated the computational resource requirements of the system  . On a Pentium II 1 running at 500 MH z , the average translation speed was 0 . 44 seconds . The memory requirements are summarized in Table 2 below . 
Flawless 60%
Stylistic Problem 9%
Minor F ' robl cm 14%
Acceptable with OOV 1%
Major ProMem 9%
Wrong Translation 5%
Translation IV ailure 3%
Table 1 Translalion Quality 6MB Read-only Memorylbr Code and Data
Read-only Melnory for l ) iclionary,
Examples , Fast Match Index , etc.
Read/Write Memory for Feature Slructures Read /Write Memoryfo  , " Software Engines
Table 2 Memoryl , I equirements 23MB   14MB   4MB Our plans for further work include extending the size of the input w  ) cabulary , and developing mechanisms for closer integration with speech recognition and speech synthesis components for speech-to-speech translation  . We are also working on the Japanese-to-English translation direction  , and we plan to report results on this in the future  . 

Our thanks go to Robert Bowen , Benjamin
Hartwell , Chigusa Inaba , Kaori Shibatani , Hirono Stone lake , and Kazue Watanabe for their language ngineering el Torts  , and to Edwardt to for user interface and application development  . 

Dalryml)le , M . , R . M . Kaplan , J . T . Maxwelll , and A . 
Zacncn , cds . (1995) l ; ormal Issues in
Lexical-Functional Grammar . CSLI Lecture Notes 47, Stanford , CA . 
Furuse , O . and H . Iida ( 1996 ) " incremental Iranslation utilizing constituent-I ~ oundary patl cr ns "  , in Proceedings of COL1NG-96 , pages 412-417 . 
Lcvine , J . R . , T . Mason , and D . Brown (1990) , lex & y acc(SecondE ditio , ) , O'R cillcy and Associates , 
Sebastopol , CA.
Nagao , M .   ( 1984 ) "A framework of a Machine Translation between Japanese and English by analogy principle "  , in Artificial and tlumatt Intelligence , A . 17 Jithorn and R . Baneiji ( eds . ),
North Holland , pages 173--180.
Resnik , P .   ( 1995 ) "Using information content to evalual csemantic similarity in a taxonomy "  , in
Proceedings of LICAI-95.
Sale , S . and M . Nagao (1990) " Toward memo , y-based lratls lalioD " , ill Proceedings of COLING90 , vol . 3, Helsinki , Finhmd , pages 247--252 . 
Sugaya , F ., T . Takczawam A . Yokoo , and S.
Yamamolo (1999)'% rid-to-endewtlualion in ATP , -Matrix " , in Proceedings of Fmrospeech-99 , B t , dapest , Hungary , pages 2431--2434 . 
Tomita , M . (1988) The Generalized LR
I'ars'eMCompiler(Version 8.1): User's Guide.
Technical Memor and umCMU-CMT-88-Memo,
Cenler for Machine Translation , Carnegie Mellon

Tonlila , M . , " All efficient word lattice parsing algoritlun for conlinuou speech recognition "  , illl ' roceedings of ICASSP-86 , Tokyo , Japan , pages 1569-1572 . 
Walanabe , H . (1992) " A similarily-driven transfer system " , in Proceedings of COLING-92 , Nantes , 
France , pages 770-776.
Walanabe , H . and K . Takeda ( 1998 ) "A pattern-based Machine Translation syslem extended by exanll~le-based processing "  , in
Proceedings of ACL-COLING-98, pages 1369-1373.

