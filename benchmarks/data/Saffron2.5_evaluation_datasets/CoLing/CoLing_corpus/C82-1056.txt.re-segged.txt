COLING82, J . Horeclc )) ( ed.)
North-Holland Publishing Company
? Academia , 1982
NATNRALL ANGUAGEUPDATES *
Sharon C . Salveter
David Maier
Computer Science Department
State University of New York at Stony Brook
Stony Brook , New York 11794

A great deal of research effort has been expended in support of natural language  ( NL ) database querying . English and English-like query systems already exist  , such as ROBOT\[Ha77\] , TQA\[Da78\] ,   LUNAREWo76\] and those described by Kaplan\[Ka79\]  , Walker\[Wa 78\] and Waltz\[Wa 75\] . Little effort has gone to NL database update\[ KD81  , Br 81 , Sk 80 , CHSI\] . We want to extend l ~ interaction to include data modification  ( insert , delete , modify ) rather than simply data extraction . The desirability and unavailability of NL database modification has been noted by Wieder hold  , et al [ WiSl\] . Database systems currently do not contain structures for explicit modelling of realworld changes  . 
N~querying of a database requires that the correspondence between the semantic description of the realworld and the database definition be explicitly stated  . 
The NL query system must translate a question phrased in terms of the semantic description into a question phrased in terms of the database definition  , that is , into a data retrieval command in the language of the database system  . For NL database modification , a stative correspondence between database states and realworld states is not adequate  . To suo Dort NL undate we need to renre sent an active correspondence  , the connection between realworld changes and database updates  . 
We have a means to describe the actions that change the state of the realworld : active verbs  . We also have a means to describe a change in the database state : a data manipulation language  ( DML ) command . We must capture the notion that an action in the realworld causes changes in the real world that must be reflected in the database  , as shown in Fig . i . But given a realworld action , how do we find a DML sequence that will accomplish the corresponding changes in the database ? We need to connect verbs like " schedule  , "" hire " and " reserve " with some structures that dictate appropriate D~sequences that perform the corresponding updates to the database  . In addition , a verb may denote various actions , that is , it may have different senses . 
There is no explicit database object that re ~ resents all the changes in the database that correspond to the changes in the real world brought about by actions such as " schedule  . " The desired situation is shown in Fig . 2, where RWS i statively corresponds to DBS i . We have an active correspondence between " schedule " and a parameterized database transaction PT  . Different instances of the schedule action , S1 and $2 , cause different changes in the realworld state , from RWSI to RWS2 or RWS3 . From the active correspondence of " schedule " and PT we want to select the proper transaction  , T1 or T2 , to effect the correct change in the database . 
We propose a structure , a  ~ , to represent action verbs on the database side . One verb graph is associated with each sense of a verb  ; its structure will represent all variants of that sense  . A verb graph exploits commonalities among the variants of a verb sense and also distinguishes the variants  . A verb graph is used to select DML sequences appropriate to reflect the actions of each variant of a verb sense  . The primitives in the structures are relations , attributes and values from the database , employed in DML-like expressions . 
345346 S.C.SAL VETER and D.MAIER
Verb graphs are extensions of frame structures used to represent verb meaning in  Moran\[Sa78  , Sa79\] . A verb graph is directed acyclieg raph with five kinds of nodes : header ~ footer  , information ~ AND and OR . An example of a verb graph is shown in Fig .  3 . The header is the source of the graph , the footer is the sink . 
Every information node ( represented by a rectangle ) has one incoming and outgoing edge . An AND or OR node ( represented by , and O , respectively ) can have any number of incoming and outgoing edges  . A variant corresponds to a complete directed path in the graph  . We define a complete path to be a connected subgraph such that  ( i ) the header is included ; (2) the footer is included ; (3) if it contains an information node , it contains the incoming and outgoing edge ; (4) if it contains an AND node , it contains all lncoming and outgoing edges ; and (5) if it contains an OR node , it contains exactly one incoming and outgoing edge  . An example of a complete path in Fig . 3 is the header , the footer , information nodes A , B , D , J , and connector nodes a , b , c , d , g , k~l~n . 
Expressions in information nodes can be of two basic types : as slgnment and restriction  . An example of the assignment type ( node D in Fig . 3) is RES . date ? APFT . date . An example of the restriction type ( node B in Fig . 3) is APPT . who i__n_nRI , where , in this case , R1 is the result of a query against the database . 
A verb graph supports NL update in the following manner  . As sume we have only a single sense for each verb . When a user update command is entered , information is first extracted from the command , classified by domain and used to instantiate elements of the information nodes  . We then examine the graph to see if a unique path has been determined  . If not , we generate from the graph a question whose response further constrains the possibilities  . Once a unique complete path is determined ~ the information in that path is used to instantiate the parameterized 
DML in the footer.
The verb graph SCHEDULE-APPOINT MENT in Fig .   3 is based on the following database schema : ~ MP ( name , office , phone , supervisor ) APPOINT MENT ( name , date , time , duration , who , topic , location ) MAILBOX ( name , date , time , from , message ) ROOMRESERVE(room , date , time , duration , reserver ) with domains ( permissible sets of values ) :
DOMAINATTRIBUTES WITH THATDOMAIN person name name  , who , from , reserver , suDervls or room numroom , location , office phone numph one calendardate date clock time time elapsed time duration text message  , topic The basic variations for this verb graph are whether the person being scheduled is in the company  , whether a room should be reserved and whether ones supervisor should be notified  . 
Suppose we have the update command " Schedule an appointment With James Parker on April  13  , " where James Parker is a company employe e . Interaction with the verb-graph proceeds as follows  . First , information is extracted from the command and classified by domain  . For example , James Parker is indomain person name , which can only be used to instant late APPT . name , AFFT . who , ApPT 2 . name and APPT2 . who . 
However , since USER is a system variable , the only slots left are APPT . who and ApPT 2 . name , which are necessarily the same . Thus we can instantiate APPT . who and APPT2 . name with " James Parker . " We classify " April 13" as a calendar date and
NATURALL ANGUAGE UPDATES 347
Instantiate APPT . date , APPT 2 . date and RES . date with it , because all these must be the same . No more useful information is in the update request  . 
Second , we examine the graph to see if a unique path has been determined  . In this case it has not . However , other possibilities are constrained because we know the path must go through node B  . This is because the path must go through either node B or node C and by analyzing the response to retrieval RI  , we can determine it must be node B(i . e . , James Parker is a company employee ) . 
Now we must determine the rest of the path . One determination yet to be made is whether or not node D is in the bath  . Because no room was mentioned in the query , we generate from the graph a question such as " Where will the appointment take place ? " Suppose the answer is " my office  . " Presume we can translate ' ~ y office " into the scheduler's office number  . This response has two effects . First , we know that no room has to be reserved , so node D is not in the path . Second , we can fill APPT . where in node F . 
Finally , all that remains to be decided is if node Hison the path  . A question like " Should we notify your supervisor ?" is generated  . Supposing the answer is " no . " Now the path is completely determined : it contains nodes A  , B and F . 
Now that we have determined a unique path in the graph  , we discover that not all the information has been filled-in in every node on the path  . We no wask questions to complete these nodes , such as What time ? , For how long ? and What is the topic ? At this point we have a unique complete path  , so the appropriate calls to INFORM can be made and the parameterized DML in the footer can be filled-in  . 
Note that the above interaction was quite rigidly structured  . In particular , i ) After the user issues the original command , the verb graph instantiation program chooses the order of the subsequent data entry  . 
2) There is no provision for default , or optional values . 
3) Even if optional values were allowed , the program would have to ask questions for them anyway  , since the user has no opportunity to specify them subsequent to the original command  . 
We want the interaction to be more user-directed . Our general principle is to allow the user to volunteer additional information during the course of the interaction  , as long as the path has not been determined and values remain unspecified  . 
We could use the following interaction protocol . The user enters the initial command and hits return  . The program will accept additional lines of input . 
However , if the user Just hits return , and the program needs more information the program will generate a question  . The user then answers that question , followed by a return . As before , additional information may be entered on subsequent lines  . 
If the user hits return on an emptyllne , another question is generated , if necessary . 
The following advantages accrue from letting the user volunteer information  . The user may choose the order of data entry . We can now have optional values , but not have to ask questions about them . Since the user has an opportunity to volunteer any values  , if he or she does not volunteer the value , a default value will be used . 
From our previous example , suppose topic is optional , with default null string . 
Consider the following interaction under our new paradigm  . 
i > Schedule an appointment with James Parker , on April 13348 S . C . SALVETER and D . MAIER 2 > At 3:00pm for 15 minutes 3  >  4 > Where will the appointment take place ? 5 > My office 6 > Notify my supervisor 7 > The user enters the initial command onll nei . In line 2 she volunteers supplemental information . Since llne 3 is empty , the program generates the question in line 4 . The user responds to the question in llne 5 and volunteers information at line 6  . At line 7 , a value for topic still has not been snecified , but the user has the option . Since an empty line is entered , and all non-obligatory slots are filled in , the command interaction terminates , and the program uses the default for the optional slot  . DML can now be executed . 
Verb graphs are also a means for specifying non -database operations  , such as sending a confirmation letter when an appointment is made  . The verb graph can also be used to express integrity constraints on the uDdate operation  , just as functional dependencies represent constraints on states of the database  . We can also easily express integrity constraints on successive states of the database  . Finally , there is the opportunity for computer aided design of the verb graDhs  . 
We are currently considering hierarchically structured transactions  , as used in the TAXIS semantic model \[ MBW80\] , as an alternative to verb graphs . Verb graphs can be ambiguous , and do not lend themselves to topdown design . Hierarchical transactions would seem to overcome both problems  . Hierarchical transactions in TAXIS are not quite as versatile as verb graphs in representing variants  . The hierarchy is induced by hierarchies on the entity classes involved  . Variants based on the relationship among particular entities  , as recorded in the database , cannot be represented . Also all variants in the hierarchy must involve the same entity classes  , where we may want to involve some classes only in certain variants  . 
However , these shortcomings do not seem in surmountable . 
Real World Database
Rwsl~)DBSl~action\[DNL
RWS2() DBS2
FIGUREi induced connections
I_RWS2~DBS2"Schedule " 4 ~ Parameterized
Transaction PT
Figure 2
NATURALL ANGUAGE UPDATES 349
APPT.whoi__nnRl
APPT 2. name ? APPT . who
APPT 2. who ? APPT . name
APPT2 . time ? APPT . timeiAPPT2 . date ? APPT . date : APPT 2 . topie ? APPT . tople ~ SCHEDULE-APPOINT MENT >
APPT . name + USER
APPT.time+In_n~ut from elock time
APPT . duration + in np ~ from elapsed time
APPT.date ? input from calendar date
APPT . who ~ input fro ____ mmperson name iAPPT . topie+input from text %, ,, %\ [ PT . who not in I1
IRES . room+APPT . where
APPT2 . where + APPT . where . IRES . date ? APPT . date call INFORM ( APPT . who , ~ RES . reserver ? APPT . name
IRES . time ? APPT . time ~-~, name , ' Meeting ~ RES . duration ? APPT . duration \] with meon % APPT . date ~ at % APPT . time ') IAPPT ' where ? in np_ut , from roe == ? inut from R3APPT . where J~PT . where ot R2 ? Jk %
IAPPT . where not in R3\]G1m')
L ~ , APPT . name , Meeting i ~_ . --l with % APPT . who on % APPT . date in P , I=i__nn ~ retrieve name Iroom % APPT . where ') EMP retrieve office where ~ , R2i_~n name ~ ame - - ~ . 
inDiP retrieve office where %~-- name ~ e or name =APPT  . name/\]i-APPOINT MENT insert APPT ,   APPT2~ in EMP retrieve supervisor where ~ ttROOMRESERVE ~ RES ~  ) -- name=APPT , name k ~ In~y
Figure 3  \[  CH81\]  \[  Da78\]  \[  Ha77\]  \[  I~79\]  \[  D~8I  \] \[  MAW80\]  \[  Sa78\]  \[  Sa79\] 
Esk8o\]\[Wa78\]\[wisl\]\[Wo76\]
S.C.SAL VETER and D . MAIER
Brodie , M . L . , On modelling behavioral semantics of database . VLDBVII,
Cannes , Prance , 1981.
Carbonell , J . and Hayes , P . , Multistrategy construction-specific parsing for flexible database query and update  . CMU Internal Report,
July 1981.
Damereau , F . J . , The derivation of answers from logical forms in a question answering system  . American Journal of Computational Linguistics , Microfiche 75 ,  1978 , pp .  3-42 . 
Harris , L . R . , Using the database itself as a semantic component to aid the parsing of natural language database queries  . Dartmouth College
Mathematics Dept . TR 77-2, 1977.
Kaplan , 8 . J . , Cooperative responses from a natural language database query system  . Stanford Univ . Heuristic Progra ~ ning Project paper

Kaplan , S . J . , and Davidson , J . , Interpreting natural language updates . 
Proceedings of the 19th Annual Meeting of the Association for
Computational Linguistics , June 1981.
Mylopoulos , J . , Bernstein , P . , and Wong , K . , A language facility for designing database - intensive applications  . ACM TODS , 5, 2, 1980, pp .  185-207 . 
Salveter , S . C . , Inferring conceptual structures from pictorial input data  . University of Wisconsin , Computer Science Dept . , TR 328,1978 . 
Salveter , S . C . , Inferring conceptual graphs . Co~nitlve Science , 3, pp .  141-166 . 
Skuce , D . R . , Bridging the gap between natural and computer language  , Proc . of Int'l Congress on Applied Systems , and Cybernetics , Acapulco , 
December 1980.
Walker , D . E . , Understanding Spoken Language . American Elsevier , 1978 . 
Wiederhold , G . , Ka Dlan , S . J . . and Sagalowicz , D . , Research in knowledge base management systems . S~GMOD Record , VII , #3, April 1981, pp .  26-54 . 
Woods , W . , et al , Speech understanding systems : final technical report  . 
BBN No . 3438, Cambridge , MA , 1976.
