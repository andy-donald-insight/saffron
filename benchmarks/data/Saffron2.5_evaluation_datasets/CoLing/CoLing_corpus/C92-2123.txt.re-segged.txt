TOWARDSCOMPUTER-AIDEDLINGUISTICENGINEERING
Versunem~thodologie et de sout ilspout " ieg ~ nielinguistique 
RI~MIZAJAC

Universit 6 Blaise Pa~al , 34 avenue Carno !
F-63037 Clermont-Ferr and cedex

Danscet article , nous proposon sune
m6thodologie deg6nie logiciel pour le
traitement automatique des langues
fond 6esurlag 6n 6 ration ( semi -) automa-
tique de programmes de TALN it partir
desp6cifications for melies.
Cettem 6thodologieest concue pour
favoriser la r6utilisation de sp6cifications linguistiques dans la g6n6ration de dif-f6rentes applications de TALN , ainsiquele d6veloppement i cr6mental deces sp6cifications linguistiques . 
Lelangage desp dcification fomlelleest fond6 surles structures detraits typ6s   . La r6utilisation desp dcifications linguistiques est favoris6e parl ' organisation deces sp6cifications darts unstyle parobjets , enplusieurs niveaux desp6cificit 6 croissante . Celangagest suffisement puissant pour pouvoir d6crire to ut typed ' objet linguistique , tal'avantaged'uti-lise rune notation largement  r6pandue n

L'acquisition deconnaissances linguistiques formalis6es aumoyen decelangage peut 6tre   automatis6e enutilisant des out ils d'exploration de corpus et de s  6diteurs   p6cialis6s   fond6s urcelangage et directement com~ect6s ? alabase deconnaissances linguistiques . 
ACRESDE COLING-92 , Nnt , rrE~s ,   2328 ao ~ r 1992   8   2   7 La g6n6ration deprogrml maes sp6cifiques d ' aualyseoude g6n6ration peut ~ tre automatis6e dans lame sure oules lan-gages de programmation cibles sont des langages de programmation logique ~ t contraintes dontles structures de donn des sont des structures detraits  typ6s  . 
I . es diff drents 616merits constituant cette approches on tactuellement dartsun  6tat d ' avancement vari6  , q but e fo is , cette approehest d6ja partiellement u ilis6e par diff6rents groupes clans plusieurs pro-jets nation aux et europ6ens   , en particulier dans le domaine des dictio Imai ~ Tes  61ec-troniques  . 
Pltc ~ c . o1: COLING-92, NAbrIES , AUTO , 2328 .   1992 TOWARDSCOMPUTER-AIDEDLINGUISTICENGINEERING
RI~MIZAJAC

Universit ~ Blaise Pascal , 34 avenue Carnot
F-63037 Clermont-Ferr and cedex remi@ucfsl . uuep We outline a framework for computer-aided linguistic engineering based on the automatic generation of NLP programs from specifications  , midan automated construction of reusable linguistic specifications  . The specification language is based on Typed Feature Structures  , and the target programming language is a constraint logic programming language which data structures are typed feature structures  . Reusability of linguistic specification is enhanced by the organization of the specifications in an object-oriented style in several Myers of increasing specificity  , supporting for example the incremental development of grammar specification for sublanguages  . 
1A framework for NLP Software

The development of reliable high-quality linguistic software is a time-consuming  , error-prone , and costly process . A parser used in an industrial NLP system is typically developed by one person over several years  . The development of a linguistic engioneering methodology is one of the major in the development of a language induslry  . The process of developing an NLP application is an application and an adaptation of the classical software engineering development methodology and follows three major steps : the initial requirements and specifications expressed in natural anguage  , the formal specification of the system , and finally the implementation f the system\[ Bigger staff/Perl is  89\]  . 
The requirements specific to a linguistic engineering methodology are :  1  . The initial requirements are complemented by a corpus giving typical examples of the texts and linguistic phenomena contained in these texts to be treated by the system  ;  2 . The set of formal specifications constitutes a standardized repository of formalized linguistic knowledge reusable across different NLP applications - a crucial property given the sheer size of granrmars and dictionaries  ; executable-to be able to test the specifications against corpora  . 
3 . NLP programs are generated ( semi- ) automatically from formal specifications . 
These particularities have the following implications :  1  . The availability of a corpus allows to develop a methodology based on sublanguages and corpus analysis  , automating the knowledge acquisition process . 
2 . The linguistic specification does not include any information specific to some application  ( especially , it does not contain any control information ) , thus the same specification can be reused for different applications  ( genericity )  . 
A specification language for describing linguistic knowledge could be based on a feature logic and has an object-oriented inheritance style that makes it possible to distinguish formally between generic knowledge and specific  ( e . g . , sublanguage ) knowledge , thus enabling the reuse of specifications in the development of the specification stllemselves  . 
The expressive power of the specification language  ( a non-decidable subset of first order logic ) allows to remove the conventional distinction between dictionaries and grammars  , providing a single homogeneous framework for an integrated development of linguistic knowledge bases  . 
The use of a feature-based language also favors standardization  , as feature structures become a " lingua franca " for computational linguists  . 
Several modem specialized linguistic programming languages can be the targets of the automated generation process  . Since the specification language is based on typed feature structures  , natural candidates are ~ unification-based grammar formalisms  . .

Ac~lzs DECOLING-92 , NANTEs , 2328 AO~r 1992828 Prtoc . OVCOLING-92, NANTES , AUG .  2328 ,   1992 A Computer-Aided Linguistic Engineeringine thod -ology should also address the  1011owing poinls : ? strict separation between pure linguistic knowledge and knowledge about strategies to rits use in a particular application  , a conditions in equan on for reusability ; , concepts of modularity for lingnistic description  , e . g . , formal separation of knowledge pertaining to different levels of linguistic description  , organization of linguistic knowledge in hierarchies  ( from generic to specific )  ; ? team organization of linguistic development projects  . 
1 Reusab le l ingu is t i c descr ip t ions In softwar engineering  , the use of the ten n < < reusability >> covers two main trends : the composition-based approach and the generation-based approach  . 
In the first approach , software components can be plugged together with noors maU modifications in order to build software systems : programming lan-gnage such as ADA or object-oriented languages are designed to support his type of reuse  . This approach is successful when the components are small and perform very precise functions  , as li3r numerical analysis \ [ Biggerst , ' fff/l'erl is 891 . In NLP , this approach is exemplified by there u ~ of various  , < engines >> such as parsers . 
In the second approach , software components are generated ( semiautomatically ) from a ~ t of formal specifications , instantiating these specifications in a programming language by choosing appropriate data representations and control structures : the knowledge expressed in the specification is reused in various contexts to generate different applications  . This approach is successful when a fair alnount of domain knowledge is built into the specilication and the generation environment  , e . g . , business knowledge in 4GL ( Fourth Generation Languages ) environments . 
T iffs is the approach ween v is age for producing NLP programs  . 
To support reusability and incremenlal development of specifications  , we organize and describe linguistic knowledge using partial specifications and controlled degrees of abstraction i the overall design  . 
Tiffs approach should of course be supported by a specification language which will be based on the concept of partial information and provides the means of stmcturing a specification ia hierarchy of subspecifications of increasing specificity  . 
We envisage three basic levels of abstraction . The i~titial design of the linguistic domain is rather abstract and largely free of details  . It establishes the basic buildings blocks , the basic structures and the foundations of the linguistic domait ~  . At that level , we could aim at providing a eonsensual formal deft onition of t bese basic building blocks as a first step towards the definition of standards for representiug linguistic knowledge  . For example , the initial level of abstraction could start from basic descriptive clas-siticalions  , e . g . at the categorial level nouns , verbs , etc . , and li'om the basic syntactic dependencies between these categories  , and give them afnrmal delinition . 
A second level of specialization makes choices as for the distribution of linguistic properties into more linegrained categories  . At that level , we observe the emergence of linguistic theories , where choices are triggered by tlleoretical assumptions  . Given the relative freedom of structuration , the choice between competing representations should be guided by the concern for modularity and reusability  ( internal con-sla'aints ) and by the external constraints on the coverage and the adequacy of the linguistic representation to the needs of NLP of applications  . Linguistic specification should be developed as a set of independently defined nm dules with well -defined interconnections : modularity is essential in supporting reusability audteam work in the development of specilications  . 
At the third level of specialization , the lingnistic organization principles are instantiated in the fully detaile description of specilic linguistic phenomena  . This level is sufficiently detailed to test the specification against actual sentences  ( trings of word t bnns )  . Previous levels can ' also be tested but only against abstract descriptions representing sets of sentences  . Tius is also tile level at which we have several diflerenti ~ tstances corresponding to diflerent sublanguages  , ach sublanguaged scription reusing the same first mid second levels of specification  , freeing the linguistic of redoing the same design decisions for each instance  . There could also be a smlcturation among sublanguages which could introduce finer levels of abstraction  , thus achieving a higher degree of reusability . 
This overall framework in winch each level sets partial cxm straints on the most specific instance siable to support the incremental develop nrent of linguistic knowledge by successiver finements and thus  , far-tiler reusability . 
ACTf!St ) ' ~ COLING-92, N^N-I ~ . s , 2328 ^ ot Jr 1992829I'v:o ~: . oI:COLING-92, N^l'rrgs,AUG .  2328 ,   1992   2 A linguistic description language The crucial issue in the generation-based approach to reusability is the nature and the definition of the specification language  . A specification language has to be defined and implemented as pure logic to fully support reusability  . It should be suitable to describe the knowledge of a particular domain and should build on well -accepted notions and notations for that domain : here  , natural language processing . In NLP , the emergence of unification-based grammar formalisms promoted the use of feature structures as a  , din-guafranca > , for representing linguistic information . 
Although some work on unification-based grammar formalisms imotivated by reusability of linguistic specifications  ( e . g . , < reversible grammars , ,) , such work does usually not address the problem of specifications in engineering terms  . Furthermore , these formalisms make strong assumptions about he nature of linguistic representation  1 thereby limiting severely the expressive power of these languages  . 
The linguistic specification language is based on a typed version of a logic for feature structures which allows to define specifications at different levels of abstraction  . Using this language , it will be possible to eliminate the conventional division between lexical and grammatical knowledge  , and also the division between generic and specific  ( e . g . , 8ublanguage ) knowledge . 
Such a specification language is executable ( although it is potentially infinitely inefficient  )  , and it should be executable for two reasons . First , since the formal specification is the first level of formality in the conception of a software system  , correcmess cannot be proved by formal means . However , an executable specification language allows at leasto test the specifications against examples  . Second , it should be possible to derive an actual program  ( e . g . , a parser ) from a specification . An executable specification language nsures the basic feasibility of an automated generation of NLP programs  . 
The specification language is formally based on a subset of first-order logic  . In order to make it manageable and intuitive , it employ syntactic constructs called Typed Feature Structures  ( TFSs )  . The , ~ vocabulary ~ of the language , its signature , consists of unary predicates ( or ts ) and binary predicates ( features )  . Moreover , there is an ordering on the sorts ( yielding a lower semilattice )  . The structures over which the language is interpreted are determined in that they have to satisfy certain axioms : the features give partial functions  , and the ordering on the sorts is 1 . Which are sometimes only motivated by processing considerations  . 
reflected as subset inclusion ( unary predicates give sets )  . They are not fully specific , however , which reflects the situation in knowledge representation where the domain of discourse is not completely specified  . By adding new axioms , this domain is made more and more specific ; in the extreme case , one structure is singled out . 
The sort signature is extendable through ( recursive ) definitions of new sorts ; these are done by defining explicit constraints which come from the language itself  ( the TFS constraint language )  . The sorts are organized into an inheritance hierarchy  , with a clean ( logical , algebraic and type-theoretic ) semantics of inheritance in the object-oriented programming style  . The subset of first-order logic can be made more complex by adding logical connectives  , uchas negation and quantification . 
Given the signature , which defines the constraints available to the user  , the user has the option to extend the language by specifying new predicates  . 
These are interpreted as relations between the elements of the domain of the respective interpretation structure  . The language is still a subset of first-order logic  ; thus , its syntax can be chosen like the one of definite clauses  , but with TFS's instead of first-order terms . 
The specification language thus obtained allows the user to create partial specifications that can be incrementally extended  , and to express controlled egrees of abstraction and precision  . Although of considerable expressive power , this specification language is executable , but the control information is be abstracted ; that is , formally the execution is nondeterministic , and there will be no explicit programming feature to express control  . This has a good reason : control information coded in programs is pecific to particular applicatiorts  . For grammars for example , for the same underlying logical specification the control will be different in parsing or in generation  , or even in different parsers ( e . g . , for indexing or for granunar checking ) . Thus , abstracting from control is important forgaining enericity : logical specifications apply to more problems than programs  . The knowledge specification language is used in a first step in the generation of correct programs  . 
3 Automating the acquisition of linguistic descriptions We assume that the acquisition of linguistic information will build upon the definition of broad linguistic AcrF  . s DECOLING-92 , NANTES , 2328 AOt ~ T1992830 PROC . OFCOLING-92, NA brrES , AUG .  2328 ,   1992 categories formalized as the initial and secondary level of linguistic abstraction described above  . In a Computer-Aided Linguistic Engineering fnune work  , the acquisition of linguistic inibrmation is targeted towards the needs of specific applications : we also assume that the linguist uses for testing purposes a set of examples of the kind of text Ire describes  ( test case )  . These exanlples ( fire < ~ corpus > ~ ) can be con-stmcted ( as a way for example to specify file kind of dialoguenvisagedfox " a natural language man  . , machine interface ) or can come from existing texts , for example , existing teclmical documentation , The acquisition of linguistic iulonuation coltsists in describing in lull detail the set of linguistic phenomena occurring in the corpus as a specialization of linguistic axioms and principles  . The acquisition is performed in two steps . First , the linguist uses corpus analysis tools to characterize the particularities of the sublanguage phenomena occurring in the corpus and to define the coverage  ( selot ' linguisticate-gories ) that should be reached , q ~ en , the linguist describes formally ( i . e . , using the specification language ) in all details phenomena occun'ing in the col pus  , using corpus analysis tools to lind examples and to refine the categorization \[ Ananiadou  90  , Tsujii et al .  901 . 
This approach to tim acquisition of linguistic knowledge leads to the delinition of a precise methodology  ( basic concepts and working procedures ) upported by a specific set of sollware tools : . Concepts . The basic concepts underlying this methodology are the notions of sublanguage and coverage \[ Grishman/Kittredge  86  , Kittredge/Lehrberger 82 , Gristmlm ~ lirsclnnan/Ngo86\] . 
Given a corpus , a linguist should be able to give a high level description of it in terms of its linguistic particularities which are not lkmndm other kinds of texts  , and in terms of the set of lingttistic phenomena which are occurring in it : these concept should be defined operationally to allow the linguist o apply them to actual texts  . 
. Working procedure . A working procedure delines the steps to be taken in the acquisition of linguistic knowledge  , both in larger steps ( characterization of the corpus , then acquisition ) and in details such as how to document the phenomena described  , to link a formal description to exam-pies of the corpus  , to check the consistency o1' the description with other parts of the specification  , etc . It also gives examples of , e . g . , how to detine new lexical semantic classes using a cluster analysis tool  ( see below )  . 
o Software tools , qhe concepts and working procedures are suppo ~ted by a set of specialized linguistic software tools integrated in a Computer ~ Aided Linguistic Engineering workstation  . 
These ~ ltw are tools supl x ) rling the acquisition of linguistic knowledge should have tire tollowiug functio ~ mlities :  . Taggh ~ g . A first set offmiction a fities is to tag a corpus using linguistic markel such as the category of wordforms  , their inflection , etc . Several levels of sophistication will be distinguished depending on the availal ~ ility of the appropriate set of pat ~ uneters : sels of closed categories  , ets of word fonns , sets of nlor phemes , definition of phrase boundaries , etc . 
Text DBMS . A tagged coq ) us is beloaded into a text DBMS for further exploitation  , and accessed through a specialized linguistic interlace  ( using a specialized query language )  . 
. Statistics and cluster analysis . Two kinds of inl2mnation can be extracted linma tagged cornpus : statistical inlbnnation and concordance and clustering ild bnnation  . Statistical and clustering aualysis algorithms will be implemented and in corlx n'ated  , as l ~ unctionalities of the linguistic interlace of the text database  . 
Semantic editor The essential operation in linguistic acquisition is the creation of specializa-finns of existing categories  . A semantic editor takes into account the delinition of existing classes and interactively guides the user in the creation of instances  . 
4 Automat ing the generat ion o f NLP programs In the development process ketched above  ( Section I ) the last step is the implementation f the system . 
Automatic gencratinn of NI . Psoltware Ires been locused to the ( crucial ) domain of lexical resources ( how to build generic rcsom ~ ; es and compilers that can extract electronic dictionaries from a lexical knowledge baselbr NLP systems  ) and to the domain of , ~reversible grammars , , 1 . 
The process of transfomfing a specilication i to an elficient program is very similar to compilation  . If the structure of a set of specilication is stable  , a compiler can be built to gene late a program . This is the approach envisaged for lexical infnnnation  2  . Lexical \] . See for exmnple file I ) taw . eedings of the ACL Workshop on Reversible Grammars  , Berkeley , June 1991 . 
Acq3/s DECOLING-92 , NANTES , 2328 An(n199283 Il'r ~ oc . O1: (5OLINGO2,NANTES,AU?; .  2328 , 1992 information is here considered as < < static , information : once the structure of the lexicon is defined  , adding or removing an entry will not modify the compilation process  . This is less tree for grammatical information which defines how the basic linguistic buildings blocks  , i . e . , lexical entries , are combined into larger structures . Here , the needs may vary depending on the processing requirements of different NLP applications  . For example , a grammar checker and an indexing system will most probably not use the same parsing scheme : they will treat differently errors and ambiguities  . Thus , a general approach is needed . 
Since the knowledge specification language is exe -cutable  , this means that , to generate a program , there are two basic choices to be made : the selection of data structures and the selection of control structures  . The nature and the complexity of these choices depend on the distance between the specification language and the targeted programming language  . 
As a programming language into which the specifications are derived  , we envisage to use the Con-stralnt Logic Programming  ( CLP ) language LIFE developed at DEC-PRL\[Ai't-Kaci / Meyer  90  , Ai't-Kaci/Podelski91\] . The reason is that its formal foundation has parts in common with the Knowledge Specification Language  ; in particular , its basic data structures are also Typed Feature Structures  , thus ensuring a basic level of compatibility between the two  . A no the reason is its descriptive power , its efficiency and its flexibility in execution ( ~ datadriven . ): LIFE subsumes the two main programming paradigms  ( logic programming , as in PRO-LOG , and functional programming , as in LISP or ML ) . That is , a . logic .   ( or ~ functional > > ) programmer may stick to his favorite programming style and still write code in LIFE  . 
Since the data model is the same , to generate an efficient program form a specification  , the user will only have to select appropriate control structures  , For example , to generate dictionaries for a parsing program , the only refinement the user will have to develop is to define an efficient indexing mechanism that allows a parser direct access to a lexical entry  . In generating NLP parsers or NLP generators , the user will have to choose between a functional control structure  ( as in ML ) or a relational control structure . 
as in PROLOG . For the latter , additional choices have to be made , such as the ordering of clauses , the introduction of cuts , etc . \[Deville 90\] . Research in computational linguistics has identified a few central  2  . This is also the approach envisaged in the ESPRIT project 
Multilex and in the Eurotra-7 study.
computational concepts appropriate for NLP , among them regular grammars and regular transducers  , augmented contextfree grammars and tree transducers  . 
In particular , augmented contextfree grammars are the framework of the research in socalled ~< revers-ible grammars >  ,  . This research can be used in the development of NLP processing schemes defined as annotations to the specification \[ Deville  90  , Uszkoreit 91\] . 
Assuming that a set of specifications is stable , it is possible to write a specialized compiler to generate a LIFE program for  , e . g . , parsing or generation . This compiler will embed the control choices that a designer of a parser makes when developing a parsing algorithm  . This kind of generation has been shown practically feasible for lexieal information  , and research on , < reversible grammars ~> has demonstrated the feasibility for grammatical information as well  ( see for exanlple\[Dymetman/Isabelle 88\]who present a prototype of a machine translation system capable of translating in both directions using the same grammars and dictionaries  )  . 
However , we have also a long term more ambitious goal , which is to develop methods and tools for fi . dly automating the generation of a program . Using these tools , the user will interactively guide the system in the generation of a program  , experimenting with various choices and recording the design decisions for control to be used in a fully automatic step once the design is completed \[ Bigger staff/Perl is  89\]  . 
5 Towards Computer-Aided
Linguistic Engineering we have outlined a frmnework for Computer-Aided Linguistic Engineering based on the concepts of reusability and automatic programming\[Bigger staff / Peflis  89\]  , and showed that we have already all the basic ingredients  ( although at various degree of elaboration ) : ? a TFS based specification language \[ Emele /Zajac  90a   , Emele/Zajac90b\] ; ? a TFS based constraint logic programming language\[Ai't-Kaci/Meyer  90  , Ai't-Kaci/Podelski91\] ; ? a methodology for the generation of NLP programs\[Devine  90  , Uszkoreit 91\] ; ? a methodology for linguistic acquisition \[ Ananiao dou  90  , Tsujii et al 90\] . 
A caxs DECOLING-92 , NAMES , 2328 AOt ~ T1992832 PROC . OFCOLING-92, NANTES , AUG .  2328 ,   1992 To arrive a a fully detailed framework tlmt could be implemented in a Computer-Aided Linguistic Engineering workstation  , the major parts that need to be researched and developed are the elaboration of an annotation system to bridge the gap between the specification language and the programming language  , and the development of adequate ools for the automated acquisition of linguistic knowledge  . Of course , this approach as to be tested on a larger scale than what have been possible using the partial implementations available at present  . 
Part of the framework described in this paper is presently used in several ongoing projects or proposed in several projects proposals  . In the current projects , the primary domain of application of this framework is in the area of lexical representations  ( e . g . , the
MULTILEXES PRIT project , the EUROLANG
EUREKA project , the DELL SLRE proposal ) , Acknowledgments . This paper was written while I was working in the Polygloss project at the IMS  ( University of Stuttgart )  . Many of the ideas presented in this paper have been discussed during the preparation of an ESPRIT project proposal on Com-puter-Aided Linguistic Engineering  . I would espe-cia Uylike to thank Hassan Ai1-Kaci , Gabriel B~s , Ulrich Heir , Andreas Pedelski , and Harts Uszkoreit . 
References\[All-Kaci84 Hassan Al't-Kaci . A Lattice Theoretic Approach to Computation based on a Calculus of Partially Ordered Types Structures  . Ph . DD is ~ r-tation , University of Pennsylvania . 
\[Ail-Kaci86\] Hassan Al't-Kaci . ~ < An Algebraic Semantics Approach to the Effective Resolution of Type Equations > >  . Theoretical Computer Science 45, 293-351 . 
\[Ai~-Kaci/Meyer 90\] Hassan Al't-Kaci and Richard Meyer . , ~ WiidLIFE , a user manual > > . DEC-PRL Technical Note PRL-TN-l , Rueil-Malmaison , 
France , 1990.
\[ AiV Kaci/Podelski 91 \] Hassan Alt-Kaci and Andreas Podelski . < < Towards a meaning of LIFE ~ . DEC-PRL Research Report PRL-RR-11,
Ruei I-Malmaison , France , June 1991.
\[Ananiadou90\]S . Ananiadou .   , < The use of statistical techniques in identifying sublanguage patterns  ,  . 
Eurotra Research Report , 1990.
\[ Bigger staff/Perl is 89\] Ted J . Biggerstaff and Alan J . 
Perlis ( eds ). Software Reusability , 2 volumes.
ACM Press-Addison-Wesley , 1989.
\[ Carpenter 90\] Bob Carpenter . ~' I~yped feature structures : inheritance , ( in ) equality and extensional-ity ) > . Proc . of the Workshop on Inheritance in Natural Language Processing  , Institute for Language Technology and AI , Tilhnrg University , 
Netherlands , August 1990.
\ [ Deville 90\] Yves Deville . Logic programming . Systematic Program Development . Addison-Wesley , 1990 . 
\[ Dymetman/lsabelle 88\] Marc Dymetman and Pierre Isabelle .   , ~ Reversible logic grammars for machine translation > >  . Proc . of the 2nd International Conference on Theoretical attd Methodological Issues in Machine  7  ) ' anslation of Natural Language , June 1988 , Pittsburgh . 
\[ Dymetumn et al90\] Marc Dymetman , Pierre Isabelle and Franqois Perrault .  ~ ( Asymmetrical approach to parsing and generation ,  . Prec . of the 13th International Conference on Computational Linguistics -  COLING'90  , Helsinki , August 1990 . 
\[Emele1988\] Martin Emele . << A typed feature stmc?t are unification-based approach to generation >  ,  . 
Proc . of the WGNLC of the IECE , Oiso University , Japan ,  1988 . 
\[Emele1991\] Martin Emele . < < Unification with lazy nonredundant copying >> . 29th Annual Meeting of the ACL , Berkeley , June 1991 . 
\[ Emele/Zajac90a \] Martin Emele and RdmiZajac.
a A fixed-point semantics for feature type systems ,  . Proc . of the 2nd Workshop on Conditional and : l ) ~ pedRewriting Systems-CTRS'90 , Moll-trdal , June 1990 . 
\[ Emele/Zajac90b \] Martin Emele and RdmiZajac.
<< Typed Unification Grammars >> . Proc . of the 13th International Conference on Computational Linguistics -  COLING'90  , Helsinki , August 1990 . 
\[ Emel et al . 90\] Martin Emele , Ulrich Heir , Stefan Momma and R~mi Zajac .   , < Organizing linguistic knowledge for multilingual generation > >  . Proc . of the 13th International Conference on Computational Linguistics-COLING "  90  , Helsinki , 
August 1990.
\[Franz90\]AlexFranz . , ~ A parser for HPSG, . CMU report CMU-LCL-90-3 , Laboratory for Computational Linguistics , Carnegie Mellon University , 
July 1990.
\[Grishman/Kittredge86\]R . Grishman and R . Kittredge . Analyzing Language in Restricted
Domains . Laurence Edbaum , 1986.
\[Grishrnan/Hirschman/Ngo861 Hirschman L . Grishman , R . and T . N . Ngo .   , , Discovery procedures for Ac'r ~ DE COLING-92 , NAturES , 2328 AO~"1992833 PROC . OFCOLING-92, NANTES , Autl .  2328 .   1992 sublanguages lecfional patterns : initial experiments ~  . Computational Linguistics , 12(3):205-215, 1886 . 
\[ Kittredge/Lehrberger82\]R . Kittredge and J . Lehr-berger . Sublanguage : Studies of Language in Restricted Semantic Domains  . DeGruyter , 1982 . 
\[ Pollard 90\] Carl Pollard . ~ Sorts in unification-based grammar and what they mean ~  . In M . Pinkal and B . Gregor ( eds . ) , Unification in Natural Language Analysis , MIT Press .   ( in press ) \[ Pollard/Moshier 90\] Carl Pollard and Drew Mosh-ier . ~Unifying partial descriptions of sets , > . In P . 
Hanson ( ed . ) Information , Language and Cognition , Vancouver Studies in Cognitive Science 1 , University of British Columbia Press , Vancouver . 
( in press ) \[ Pollard/Sag87\] Carl Pollard and Ivan A . Sag . Infor-mation-Based Syntax and Semantics . CSL1 Lecture Notes 13 , Chicago University Press ,  1987 . 
\[ Pollard/Sag91\]Carl Pollard and Ivan A . Sag.
Agreement , Binding and Control . Information-Based Syntax and Semantics . Volume 2 . To appear . 
\[Smolka88\]GertSmolka . ~ A Feature Logic with Subsorts . . LILOG Report 33, IBM Deutschland
GmbH , Stuttgart.
\[Smolka89\] GertSmolka . ~ Feature Constraint Log-ics for Unification Grammars > ~  . IWBS Report 93,
IBM Deutschl and GmbH , Stuttgart.
\[Smolka/A'ft-Kaci 88\] Gert Smolka and Hassan Ai't-Kaci .   , dn heritance Hierarchies : Semantics and Unificatiom ~  . J . Symbolic Computation 7, 343-370 . 
\[Strzalkowski90\] Tomek Strzalkowski . ~ How to invert a natural language parser into an efficient generator : an algorithm for logic grammars > >  . 
Proc . of the 13th International Conference on Computational Linguistics -  COLING'90  , 
August 1990, Helsinki.
\[Tsujii et al90\]Tsujii , J . , Ananiadou S . , Carroll J . , and Phillips J . D .   , ~ Methodologies for the development of sublanguage MT systems ~  . CCL Research Report CCL/90-10 , UMIST , Manchester ,  1990 . 
\[Uszkoreit91\]HansUszkoreit .   , ~ Strategies for adding control information to declarative gram-marsh  . In Proceedings of the 1991 Annual Meeting of the Association of Computational Linguistics  , Berkeley ,  1991 . 
\[Zajac89\]R6miZajac . ~ A transfer model using a typed feature structure rewriting system with inheritance ~  . Proc . of the 27th Annual Meeting of the ACL , 26--27 June 1989 , Vancouver . 
\[ Zajac90a \] R6miZajac . , ~ A relational approach to translatiom, . Proc . of the 3rd International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Language  , 1113 June 1990 , Austin . 
\[Zajac90b\]R ~ miZajac . , ~ Semantics of typed feature structures ~ . Presented at the International Workshop on Constraint Based Formalisms for Natural Language Generation  , Bad Teinach , 
Germany , November 1990.
ACTESDECOLING-92 , NANTES , 2328 AOC'r1992834 PROC . OFCOLING-92, NANTES . AUG .  2328, 1992
