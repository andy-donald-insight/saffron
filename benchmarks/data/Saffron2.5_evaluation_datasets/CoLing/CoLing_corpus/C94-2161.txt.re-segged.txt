Anytime Algorithms fl ) r Speech Parsing ?*
Gfinl ; her(\]6rz Marcus Kesscler
Univorsit ; yofl,'zlange > Niirnberg , IMMDVIII
goerz@informatik.uni-erlangen , de
TOPICAI , PAI'\]~I/
Keywords : anytime Mgorithms , p ; ~ rsing , speech analysis

This paper discusses to which extent the concept of " anytime algorithms " can be applied to parsing algorithms with feature unification  . We first try to give a more precise definition of what an any tinm algorithm is  . We arque that parsing algorithms have to be classified as contract algorithms as opposed to  ( truly ) it > terruptible algorithms . With the restriction that the transaction being active at the time an in l  , errupt , is issued has to be COml ) leted before the interrupt cart be executed , it is possible to provide a parser with l in ritcd anytime t  ) ehavior , which is in fact t ) dng realized in our re . search l ) roto type . 
1 Introduction
The idea of '% nylime algorithms " , which has been around in the tieht of plmming for sometime  1  , has recently been suggested for application in natural language and speech l  ) rocessing ( NL/SP )  2 . An anytime algorithm is an algorit . hm " whose quality of results ( legrades graceflfly a~s computation time decreases "  ( \ [ Russellattd Zilt ) erstein 1991\] , p .  212) . In the following we will first give a more specilic definition of which properties allow an algorithm to be implemented and used as an anytime algorithm  . We then apply this knowledge to a specitic aspect of NL/SP  , namely parsing algorithms in a speech understanding system  . In the Appendix we present he AI ) C protocol which supports anytime computations . 
We will discuss these matters in the framework of the Verb mobil joint research project a  , where we are working on the implementation fan incremental chart parser  4  . The conception of this I ) arser has been derived from earlier work by the llrstauthor  5  . 
lef . e . g . \[ llussellm M Zilberstein 1991\] P'so\[Wahlster 1992\] in his invited talk at CO1  , \[N ( I -92 a ~ l The Verb mn biljoint research project has been defined in the document \[ Verbmobilt  . eport 1991\]4 the Verl ) mol , il/15 parser , of . \[ Weber1 !)!)'2\] S the GuLP parser , of . \[Gi ~ rz 1988\] . 
2 Ai , y time Algorithms\[1 ) etm and Boddy 1988\] give the fi ) llowing characteri ~ zation of anytime algorithms :   1  . 


they lend themselves to preemptive scheduling techniques  ( i . e . , they cart bc suspended and resumed with negligible overhead  )  , they can be terminated at any time and will return 
SOl\[leans wer ~ and the atts wers reI , urnediml ) rove in some welt-behaved maturer as a function of time  . 
Unforl , unately this characterization does not make a clear distinction between the intplementation of an algorithm and tile algorithm as such  . 
Point ( 1 ) is true of a great many Mgorithms implemented on preen q  ) tive operatir Lg systems . 
Poin ~ ( 2 ) can be made true for any algorithm by adding all explicit Result slot  , that is I ) reset by aw due . 
denoting aw ) id result . I , et us call the implementation of an any l ; in m algorithm an anytime producer . Accordingly wettanle the entity interested in the result of such an anytime computation the anytime consumer  . Fig-urc 1 shows two such processes in a tightly coupled synchronization loop  . Figure 2 shows the same communicating processes decoupled by the introduction of the Result slot  . Note that synrhronisation is much cheaper in terms of perceived complexity R  ) r the pro-gram rne . r and runtime synehronisation overhead ( just the time to cheek and eventually traverse the mutual exclusion barrier  )  . In such an architecture producer and consumer work under a regime that allows the consmner to interrupt the producer at any lime and dent and a result  . The risk that the consumer incurs by such flexibility is a eert Mnnonzero probability that this result is void ~ or mt changed since the last result retrievah  6The faihn ' e to provide an answer within a given an munt of time n layill itself I  ) e an interesting and meaning flal result for the ally Linle consume t '  . 


Anytime Anytime
Consumer Producer
Figure 1: Tightly coupled processes with complex synchronization internals  . 
Result Slot Mutex ( preset with Barrier " VOID " )  ~' ,  / \ ' \  ,  / & ~  . ~ . . . . . ~?" X/+-ft/M . /'7,; 7d,- .   .   .   .  ,  . _-/M .  /
Anytime Anytime
Consumer Producer
Figure 2: Processes decoupled by using a result slot protected by a simple mutual exclusion barrier  . 
Point (3) is surely a much too strong restriction , since it is not always possible to define what exactly an improvement is for any given algorithm  . In NL/SP , where we are often dealing with scored hypotheses  , it is difficult , if not impossible , to devise algorithms that supply answers that improve monotonically as a flmc-tion of invested computational resources  ( time or processing units in a parallel architecture  )  . 
We propose the following characterization of anytime algorithms : An algorithm is fit to be used as an anytime producer if its implementation yields a program that has a Result Production Granular-ity  ( RPG ) that is cmnpatible with the time constraints of the consumer  . 
The notion of RPG is based on the following observation : Computations being performed on fnite state machines do not proceed directly from goal state to goal state  . Instead they go through arbitrarily large sequences of states that yield no extractable or intelligible data to an outside observer  . To interrupt a producer on any of these intermediate states is fruitless  , since the result obtained could at best , according to the observation made on point ( 2 ) above , be the result that was available in the last goal state of the producer  . 
From the point of view of the consumer the transitions from goal state to goal state in the produce rare atomic transactions  . 
The average length of these transactions in the algorithm correspond to average time intervals in the implementation  , so that we can speak of a granularity with which results are produced  . 
The time constraints under which thee on sumer is operating then give the final verdict if the implemeuta-tion of an algorithm is usable as an anytime producer  . 
Let us illustrate this by an example : In a realtime NL/SP-system timup per bound for the RPG will I  , yp-ie ally be in the range of 10 lOOms . That is , a producer implemented with such an RPG of l > rs the consumer the chance to trade a  500ms delay for 5 to 50 fllrther potential solutions . 
Note that goal states can also be associated with intermediate results in the producer algorithm  . Conceptually there really is not much of a difference between a result and an intermediater sult  , , but in highly optimized implementations there might be the need to explicitly export such intermediater sults  , due to data representation i compatibilities or simply because the data might be overwritten by other  ( non-result ) data . 
Section 4 gives an example of how the RPG of an implementation can be reduced by identifying intermediate goal states that yield information which is of interest to the consumer  . 
3 Breadth and Depth of Analysis
In the following we will ask whether and how the idea of anytime producers can be applied within the active chart parsing algorithm scheme with feature unification  . Although the analogy to decision making in planning where the idea of anytime algorithms has been developed seems to be rather shallow  , we can , for the operation of the parser , distinguish between depth and breadth of analysis  7  . 
We define depth of analysis as the concept refering to the growing size of information content in a feature structure over a given set of non-competing word hypotheses in a certain time segment during its computation  . Larger depth corresponds to a more detailed linguistic description of the same objects  . 
In contrast , we understand by breadth of analysis the consideration of linguistic descriptions resulting from the analysis of growing sets of word hypotheses  , either from growing segments of the utterance to be parsed or from a larger number of competing word hypotheses in a given time segment  . 
q ' or egard breadth of analysis as a measure in the context of the anytime algorithm concept is in a senser not to  ) e confused with depth-first or breadth-fi rst search  . 
998 trivial : Considering only one l ) arse , the more processing time the parser is given the larger the analyzed segment of the input utterance will be  . In general , larger breadth corresponds to more information about competing word hypotheses in an  ( half- ) open time interval as opposed to more information about a given word sequence  . So , obviously , breadth of analysis does not correspond to what is intended by the concel  ) t of anytime algorithms , whereas depth of analysis meets the inliention . 
If an utterance is syntactically ambiguous , we ( : an compute more parses the more processing time the parser is given  . Therefore , to his case is a part , icular instance of depth of analysis , beea ase the same word sequence is considered , and not of breadth of analysis given the definition above  . In this case one would like to get the best analysis in terms of the quality scores of its constituents first  , and other reading slate , ' , ordered by score . If the parser works incrementally , what happens to be the case for the Verbmobil/15 parsers , the intended effect car , be achieved by the adjustment of a strategy parameter namely to report the analysis of a grammatical fragment of the input utterance as so on as it is found  . 
At least one distinction might be useful for the Verbmobil/\  [5 parser . In our parser a category check is performed on two chart edges for eIficiency reasons  , and only if this check is successflfi , the unificatkm of the associated feature structures is performed  , llence , an interrupt would be admissible after , , he category check . 
In this case we emphasize a factorization of the set  ; of constraints in two distinct subsets : phrasal constraints which are processed by the act  . iw ~ chart parsing algo-rithm schema ( with l ) olynomial complexity )  , and functional constraints which are solved by the unification algorithm  ( with exponential complexity )  . ' rheinterface between both types of constraints ia crucial place for the introduction of control in the parsing process in general  9 Since we use a constraint-hased grammar formalism  , whose central operation is the unification of feature structures  , it does not make sense to admit interrupts at any time  . Instead , the operation of the parser consists of a sequence of transactions  . At the most coarse grained level , a transaction would be an application of the flm damental rule of active chart t  ) arsing , i . e . a series of operations which ends when a new edge is introduced into the chart  , including the computation of the feature structure associated with it  . Of course this argument holds when an application of the fundamental rule results in another application of it on subunits due to the reeursive structure of the grammar rule Q ?  . Certainly one might ask whether a smaller grain size makes sense  , i . e . the construclion of a feature structure should itself he interruptible  . In this case one could think of the possibility of au interrupt  . 
S and for Gul , t ' as well 9cf . \[ Maxwell and Kaplan 1994\]l ? Thish , ' ts been implemented in the interrupt system of ( lul , l)\[Ggrz1988\] . 
after one feature in one of the two feature structures to be unified has been l  ) roees sed . We think that this possibility shou hlbe rejected  , since feature structures usually contain eoreli ' . rences . If we consider a partial feature structure -- as in an intermediate step in the unitication of two feature structures in the situation where just one feature has been processed  , this structure might not be a realistic partial description of the part of speech under consideration  , but simply inadequate as long as not all embedded eo references have been established  . It seems obvious that the grain size cannot be meaningfully decreased below the processing of one feature  . Therefore we decided that transactions must be defined in terms of computations of whole feature structures  . 
Nevertheless , a possibility for interrupting the computation of a feature structure could be considered in case the set of featn re  , s is divided in ~ wo classes : features which are obligatory and features which are optional  . Members of the last group are candidates for constraint relaxation which seems to be relevant with respect to robustness at least in the case of speech parsing  . We have just started to work on the constraint relaxation problem  , but there is no doubt that this is an important issue for further research  . Nevertheless , at the time being we doubt whether the abovemen -tione  . d problem with coreferences couht be avoided in this case  . 
A further opportunity for interrupts comes up in cases where the processing of alternatives in unifying disjm  ) ctiw ~' feature structures is delayed . In this case , unilication with one of the disjuncts can be considered as a transaction  . 
Another chance R ) r the implementation f anytime behavior in parsing arises if we consider the grammar from a linguistic perspective ~ oppose  . d to the purely formal view taken above . Since semantic on-struction is done by our grammar as well  , the functional constraints contain a distinct subset for the purpose of semantic construction  . In a separate b , vesti-gation\[Fischer 1994\] implemented a version of A-I ) t ; I~\[l ) al1993\] within the . same feature unification fo > realism which buihts semantic structures within the framework of Discourse Representation Theory  . It has been shown that the process of DRS construction can be split in two types of transactions  , one which can be performed incrementally basically the construction of event representations without temporal information -- and another one which cannot be concluded before the end of an utterance has been reached -- supplying temporal information  . Since the first kind of transactions represents meaning fnl partial semantic analyses those can be supplied immediately on demand under a uany time regime  . 
The possibility to process interrupts with the restriction that the currently active transaction has to be complete  . d in advance has been built into the Verhmo-bil/15 parser , using the APC protocol ( of . Appendix ) . 
It thereforexhibits a limited anytime behavior.
9994 Feature Unification as an
Anytime Algorithm ?
Up to now , in our discussion of an appropriate grain size for the unification of feature structures we consid:ered two cases : the unification of two whole feature structures or the unification of parts of two feature structures on the level of disjuncts or individual fea-tures  . .In all of these cases unitication is considered as a single step  , neglecting its real cost , i . e . time constraints would only affect the number of unification steps  , but not the execution of a particular unification operation  . 
Alternatively , one might consider the unification algorithm itself as an anytime algorithm with a property which one might call " shallow unification "  . A shallow unification process would quickly come up with a first  , incomplete and only partially correct solution which then  , given more computation time , would have to be refined and possibly revised . It seems that this property cannot be achieved by a modification of existing unification algorithms  , but would require a radically different approach . A prerequisite for that would be a sort of quality measure  11 tbr different partial feature structures describing a given linguistic object which is distinct from the subsumption relation  . To our knowledge , the definition of such a measure is an open re : search question  . 
5 Conclusion
According to \[ Russell and Zilberst , ein 1991\] parsing algorithms with feature unification have to be classified as contract algorithms as opposed to  ( truly ) interrupt-ible algorithms : They must be given a particular time allocation in advance  , because interrupted at anytime shorter than the contractime they will not yield usefll results  . At least the transaction which is active at the time an interrupt occurs has to be completed before the interrupt can be executed  . With this restriction , it is possible to provide a parser with l inqited anytime behavior  , which is in fact being realized in the current version of the  Verbmobil/15 parser . 
Acknowledgements . The authors would like to thank Gerhard Kraetzschmar  , Herbert Stoyan , and Hans Weberforw ~ luable comments on a previous ver  . -sion of this paper . 
References\[Dean and Boddy 1988\]
Thomas Dean and Mark Boddy : An Analysis of ' I\ ] me-Dependent Planning  . AAAI 1988 , 49--54\[Dongarra , Geist , Manchek and Sundaram 1993\] Jack Dongarra , G . A . Geist , Robert Manchek and V . S . 
Sundaram : Integrated PVM Framework Supports 11c . f . \[Russell and Wefald 1989\] Heterogeneous Network Computing . Comlmters in
Physics , Vol . 7, No . 2,1993, 166-175\[Fischer1994\] Fischer , I . : Diekom position elle Bildungyon . Diskurs repriisentations strtzkturen fibe reiner Chart  . Submitted to KONVENS 94, Vienna . 
\[Gfrz1988\]G5rz , G . : Struktm ' analysen at firli & er
Spra & e . Bonn : Addison-Wesley , 1988\[Maxwell and Kaplan1 . 994\] Maxwell , J . T , Kaplan , R . : The Interface between Pbr < ~ sal and F ~ metional Constraints  . Computationall , inguistics , Vol . 19,1994, 571-590\[Pinkal1993\]PinkM,M . : Semantik . In : Gfrz , G . 
( Ed . ): Einffihr , ngin die Kfinstliehe Intelligenz . 
Bonn : Addison-Wesley ,  1993 , 425-498\[Russell and Wefald 1989\] Rnssell , S . J . and Wefald , E : Principles of Metareasoning . Proc . KR-89,198 9,400 411 . 
\[Russell and Zilberstein1991\] Russell , S . a . , Zilber-stein , S . : Composing Real-Time Systems . Proc . 
I3CAI-91 , Sydney ,  1991 ,   212-217 \ [ Verbmobil Report 1991\] Verbmobil Konsor-titan ( 13?1 . ): Verbmobil-Mobiles Dohnets & ge-rat . BMFT Report , Miinchen , 1991\[Wahlster1992\]Wahlster , W . : Complltational Models of Face-to-Face Dialogs : Multimodality  , Negotia-tion and Translation . Invited talk at COLING-92, Nantes , 1992 . Not contained in the proceedings ; copies of slides are available from the author . 
\ [ Weber1992\]Weber,1I . : Chart Parsing mASI , ASL Tecbnical Report ASL-TR-28-92/UER , University of 1; rlaugen-Niirnberg , IMMD VIII , Erlangen , time Producer/Consumer Processes In the following we introduce the APC  ( Anytime Pro-ducer Consumer ) protocol which allows for easy establishment of anytime producer/consume rrlationships on parallel architectures  . 
Let Producer be the flmction that implements he producer algorithm  . In a purely sequential procedural call/return implementation this function would have a control structure similar to:  ( defml Producer (  . . . )  ( Initialize )   ( let ( ( Result nil ) )  ( ~ hile ( not ( Good Enough ? Result ) )  ( Improve Result ) )
Result )) tion Improve Result . It is finer if Improve Result is itself made of loops that produce intermediater sults that are ext  ) or table to consumers . 
q'he consumer is ilnplemented as the function Consumer  , that at some point calls the l ) roducer : ( defun Consumer (   .   .   . ) ( Producer .   .   .   ) We now translate Producer and Consumer into parallel processes  , sing the APC protocol , which is directly implemented by functions that act as interfaces to the underlying communication /synchro-nization system  . All functions implementing the protocol have the prefix APC:  ( In our imphunent a-i on all of them are in the Conmlon ~ l  , is package anytme-producer-consumer ) . 
( defunAny time Producer ( . . . )  ( Initialize )   ( let ( ( Result nil ) )  ( while ( not ( Good Enough ? Result ) )  ( Improve Result )   ; ; Make Result available to consumers ( APC : Set Result ! Result )   ; ; Check for messages/instructions ; ; from Consumer ( APC:CheckStatus)

In a paral M implements or , it is not sullicient for the consumer to simt ) ly call the producer . The pro?ducer has to be spaw T~ed or forked as a separate process :  ( defun Anytime Consumer (   .   .   .   ) ? Create a new process ( let ( ( P-AnytimeProducer-1 ( AI'g : Start Process ( Anytime Producer .   .   .   )   )   )   )   ( let (   ( Result ( h PC : GetResult P-hnytime Producer-1 )   )   )   ( while ( not ( Consumer Good Enough ? Result ) )  ; I ) o something else , like going to sleep ; to give tile producer some more time ( set f Result ,   ( A Pe:Get Resnlt P-Anytime Producer-1 )   )   )   )   ( A Pe:hbort Process P-Any time Producer-:l )   ) 
The APCPr()/;()('()l
APC : Start Process F starts a new process in which the procedure F is executed  . This function is also responsib h ; for tile creation of the protected Result slot . APe : Start Process returns the id of the new process  . 
No ~ e that an arbitrm : y number of producers may be started by a consnlner  . A prodtlcer mayo\['course also start other producers  . 
APC : Abort Process Procaborts the process Prec.
APC : Set Result ! Rsets the value of the Result slot to R  . 
APC : Get Result P ? retrieves the current value of the Result slot from process P  . Remember that APC : Set Result ! and APC : Get Result avoid read/write conflicts by a locking mechanism that implements mutual exclusion  . 
APC:geset Process Proc I-restarts the process Proc with new input I  . 
APC:CheckStatus\[Proc\]checkifanyinessages or instructions have arrived from Proc  . Often parallels of t ; war environments offer only very crude process scheduling and control primitives  . The user may have to implements or tie of them by himself  . APC : Reset Proeess , for example , is ( lit " ticult to formulate in a general way . Reset can also involve , ltla . intenance or elean np work , which is clearly beyond any process-oriented im -ph'  . mentation of Reset . ' l ' he idea is that these user implemented control procedures are hooked into h PC : Check Status\[Proc\]  . ' lk ) a , tain a line-grained control relationship between consunter and t  ) roducer , the user simply inserts APC : Check Status at key -positions in the code  . 
The AP ( ; protocol has been implemented aud tested under a coarse grained paral MCommonl  , ist ) System running on a four processor SUN-
SPARCMP-670 . UNIXIPC 1~ shared memory and senspheres are used to implement the h  ) w-level communica . tion and synchronisation facilities . We are currently porting the system to Solar is 2 . 3 , with PVM ( Parallel Virtual Machine , see\[l ) on garra , Geist , Manchek and Snndaram 1993\] ) as the basic communic at km facility . IWM would allow us to mow ~ our parallel system h ' omtile current high communication and low memory b and width implementation on a shared memory machine  , to a low communication/high memory bandwidth implementation tutoring on a cluster of workstations  . 
12\[lit , el-pl'og(!]ommunlcationFacilitie , s
