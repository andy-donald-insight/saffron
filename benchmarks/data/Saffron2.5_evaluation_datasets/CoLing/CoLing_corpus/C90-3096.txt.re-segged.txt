SIMPLE PARSER FOR AN HPSG-STY LEGR AMMAR IMPLEMENTED INPROLOG 
Kareloliva *
Lingustic Modelling Laboratory,
Coordination Centre
for Computer Science and Computer Technology,
Bulgarian Academy of Sciences,
a cad . G . Bonchevst . bl . 25A,
BG-1113 Sofia,


This paper describes basic ideas of a parser for HPSG style grammars without LP component  . The parser works bottom-up using the left corner method and a chart for improving efficiency  . Attention is paid to the format of grammar ru~es as required by the parser  , to the possibilities of direct implement at ion of principles of the grammar as well as to solutions of problems connected with storing partly specified categories in the chart  . 
i . Kapremmntation of Grammar Rulam for the Parser The Head-driven Phrase Structure Grammar  ( HPSG ) blurrs the distinction between rules of the grammar and the structures they generate  . Put shortly , the matter is that " structures " and " rules " in HPSG differ solely in the level of abstraction over the llnguist Jc material they describe  . A " structure " describes some very concrete piece of this material  ( e . g . , a sentence ) and , hence , embodies no abstraction ; a " rule " , on the other hand , presents by itself a prototype of a set of structures  . Since in HPSG categories are understood as bundles of features  ( " attribute "= " value " pairs )   , the " structure " / " rule " dichotomy is reflected by the fact that the rules can contain variables as values of attributes of some features while the structures must be always fully specified or that the rules can miss some  ( otherwise possibly obligatory ) features altogether . Constraints restricting or binding together permitted values of the attributes can be associated with the rules  . Naturally , different levels of abstraction can be introduced among the rules as well  , which allows for capturing different levels of genera-lization over the linguistic data described  . 
On the highest level of abstraction , the parser can deal with two types of rules : in the first type  , the values of variables occurring in the rules are bound by constraints  , in the second type no constraints occur . In order to support simultaneously an easily legible notation and a reasonable computer implementation of these two types of rules  , two Prolog operators are defined , each describing one rule type . 
:- op(1200, xfx , is a rule if ).
:- op(1200, xf , is a rule )
The first of the two is an infix operator descr ibing the rules containing additional constraints  ; the rule itself should stand in front of the operator  , the constraints should follow it , separated from each other by commas " , " . The second one is a postfix operator describing the rules without any constraints  . 
The inventory of types of rules may be arbitra -rily broadened  . All that is necessary for this purpose is just adding operator declarations and  , possibly , also implementing feature inheritance principles corresponding to the newly introduced rule type  ( s )  . This is important because it provides for bounding the application of the principles to the whole rule types and makes thus obsolete the explicit stipulation of feature sharing among respective categories in each rule  , which is still the case in many current parsers . 
TWO examples of the rule format for the parser are shown in the following : it is to be remembered that in HPSG  , as well as in all other theories accepting the X bar convention  , a central role among the daughters in a rule is played by the head daughter-because of this  , the head daughter is specially marked , which provides , e . g . , for application of the Head
Feature Principle.
Ex . l : - the standard " S - - - > NP VP " rule can appear in the following form  ( with obvious meanings of the predicates " concatenation " and " agreement "  ) :\ [ phonology = SPhonology , dtrs =\[ dtr =\[ cat = n , bar = two , phonology = NP_Phenology , morphology = NP_Morphology\] , head_d_tr =\[ cat = v , bar = two ~ phonology = VP Phcnology , morphology=VP Morphology\]i \] is a rule if coneatenation  ( NP Phonology , VP Phonology , SP honology ) , agreement ( NP Morphology , VP Morphology ) Ex . 2: - the rule " NP ---> Dot NP ": note the fact that the phonology of the mother can be expressed without invocation of the " concatenation " predicate  ( since determiners e on sist of one word only ) and the agreement is expressed directly in the rule by coinde?ing the features " number " in both daughters\[bar=two  , phonology =\ [ Det_Phonology ! NP_Phonology\] , dtrs=\[dtr=\[cat=det , bar=zero , phonology =\[ DetPhono!ogy\] , morphology=\[number=Number\]i , he add_tr =\[ cat : n , bar=one , phonology = NP Phonoloqy , morphology=\[humbar=NumberI\]\] is a rule . 
2 . Repreeantation of Categories in the Parser AS follows from the examples  , the notation adopt Zed for categories in rules is the one describing them as  ( Prolog ) lists of features . Keeping such kind of representation also in the underlying mechanism of the parser would be  , however , quite unfelicitous a decision . The main problem consists in the fact that the parser working bottom-up may discover certain features of already parsed  ( sub ) structures only later in the parsing process ( so to say , only when it gets " higher in the tree " , with regard to the way the parsing proceeds ) . These features are to be , then , incorporated into the already parsed structures . An elegant solu-tion of this problem was proposed in  ( Eisele and D~rre , 1986) and adopted in the parser described . 
Syntactic categories are represented in the parser internally in a way slightly different from their representation in the grammar : all categories  ( including 434   1 those used as values of features of other categories  ) are represented as " open-ended lists ": each internal representation of a category is a list having a certain number of instantiated elements at its beginning  . 
and an uninstantiated " tail " . The main ideastanding behind this kind of representation is that any feature to be dlscovered  ( and added to the category ) only la-ter in the parsing process can be now added as the " first member " of the uninstant iated " tail "  , which task is easy to perform provided that the " tail " is still accessible  ( e . g . , if the free " tails " of categories subject to feature inheritance principles are shared logical variables  )  . Converting categories from one kind of representation to the other one is performed by a two-argument predicate " per estroika "  ( used below )  . 
The representation described also supports a simple implementation of unification of categories  ( see Eisele and D~rre , op . cit . for more detail ); in the folowing , unification of two categories is presupposed to be performed by a two-argument predicate " unify "  . 
3. The Pars Qr
The main idea of the parsing method used in the BUP par~er  ( Matsumoto et ai , 1983 ) being the starting point of the system described is that a rule is to be triggered only after its left corner has been found  ( i . e . it has been supplied by lexicals can , in the case of iexical categories , or it has been properly parsed ) . The left corner of a rewriting rule is the leftmost symbol on its rlght-hand side-the name stems from depicting the rule as a local tree it generates  . After a category is parsed or supplied by lexical scan  , one of the grammar rules having this category as its left-corner is s@lected  , the sisters of the left corner in this rule are tried  , and if all of them are succesfuly parsed , the mother category of the rule is declared to be parsed and the whole process  , using the mother as a left corner , is repeated " on a higher level " . If any failure occurs , backtracking is invoked . Thus , the parsing process is data-driven-the rules of the grammar are selected in accordance with the symbols scanned in the input  . From the viewpoint of efficiency , this is important mainly for the so-called " free-word-order " languages  . Mentioning this , it should be further recalled that the performance of BUP is further improved by storing all the information about all subtasks that have been already tried  ( successfully or unsuccessfully )  , which avofds repetitive computations of the parses that have been performed or that have been proved impossible to perform in the preceding steps of the analysis  . 
For the purposes of the implementation of the parsing process  , it is necessary to extend the notion of the " left corner " to its reflexive and transitive closure  . The transitive closure inductively states that for all triples of categories X  , Y , Z such that X is a left corner of Y and Y is a left corner of Z  , X is also a left corner of Zo The reflexive closure finishes the picture by saying that any category is a left corner of itself  . 
Given the previously described basic philosophy of parsing  , the process can be implemented in Prolog by means of two predicates performing the two tasks informally mentioned in the preceding paragraphs : - the predicate " parse "  , parsing a given ( expected ) category from ( a prefix of ) the input string-the predicate " is a left _corner "  , linking the left corner category with the goal ( expected ) category in the parsing process . 
However , before these predicates can be explained in more detail  , it is necessary to make several remarks explaining the way the processing of complex categories has been built into the system  . 
First , the usual equality ( "=" ) of two categories was replaced by their unif ication  , i . e . on all spots where equality of two categories - expressed either directly  , in the form of an equation , or indirectly , by variable sharing or otherwise-occured in the original BUP  , it had to be replaced by a call of the predicate " unify "  . 
Second , in the predicates storing or retrieving the information about the  ( un ) successfully performed parsing subtasks , the categories must be " frozen " exactly in the state when this subtask was started : problems would occur if the " stored " categories include free variables  ( "\] n\[ormation holes " ) as values of some features , which variables might be matched by any real values in the moment of search for the infor-mat i on about previously performed parsing tasks - such a matching  , however , would be incorrect , since what is required is a real identity of the subtasks  . ( The same holds also the other way round , i . e . problems of exactly the same nature would occur also if the stored value were instant ! ated and the current one were a free variable  . ) The aforementioned identity of subtasks , however , requires the identity of ( some of ) the stored categories only , not the identity of the lists representing them , i . e . what really matters is the identity of features , but not of their order . This identity of " frozen " categories ( represented as " usual " Prolog lists ) is checked by the predicate " identical_catego -ries"  . 
Now at last , the definitions of the predicates " parse " and " is a left corner " caobe given  ; the sup- .   .   .   .   .   . 
porting predicates are either elucidated in ti~e preceding text or are given  ( hepefully ) self-expla!ni:Ig names , which should hold also for the arguments . The difference between the " frozen " categories represented as usual Prologlists and those represented as " open-ended " lists is ref lected in the variable names standing for the respective types : the " open-ended " categories are always marked as " ReaL " categories  , the other ones never bear such marking . 
% PARSE (% " Frozen "_Goal_Cat , %\[ Real_GoalCat , Structure \] , % Input_String , Rest String ) /* Checking whether parsing the current Real Goal Ca-tegory from some prefix of the Input String has been tried  ( either successfully or not ) in the preceding steps of the parsing process . */ parse(Goal Category , \[RealGoal_Category , Structtlre\] , 
Input_String , Rest_String )   ( already_parsed ( Asserted_Goal Category ,   , 
Input Str\]ng ,  ) , identical_ categories ( Goai Category , 
Asserted Goai Category) ; cannot_be parsed ( Asserted Geai Category , 
Input String ) , identical_ categories GoaICategory , 
Asserted_Goal_Category )!, fail),
I , i already_parsed ( Asserted Goal_Category , \ [ Real_Goal Category , Structure \] , 
Input Strlng , Rest_String identical categorles ( Goal Category , 
Asserted_Goal Category).
) ,   2   435 /* The following clause describes parsing of a category with no daughters  ( category immediately dominating an empty string ) */ parse ( Goal_Category , \[Real_Goal_Category , dtrs=\[\]\] , 
String , String ) /* rule having no daughters is to be found in the grammar*/find_rule to be used  ( Realgoal_Category , 
ConstraintsOfRule ) , call ( Constralnts Of Rule ) , assert z(already_parsed (
Goal_Category , \ [ Real_Goal_Category , d_trs=\[\]\] , 
String , String)).
/* The following clause describes parsing of a category dominating a nonempty terminal string */ parse  ( Goal_Category , \[Real_GoalCategory , Structure \] , \[ Word_FormIRestInput_Strlng\] , Rest_String ) lexicon ( Word Form , Word Form Category ) , per estroika ( Word_Form_Category , 
Real Word_Form_Category) , is a left corner (\ [ Real_Word Form Category , dtrs =\[\]\] , \ [ Real_Goal Category , Structure , 
Rest_Input_String , Rest_String ) , assert z(already_parsed (
Goal Category , \ [ Real_Goal Category , Structure \] , \[ Word_FormlRest_Input_String\] , 
Rest_String)).
/* Asserting information about the impossibility of parsing certain categories from certain strings */ parse  ( Goal_Category ,   , Input Strlng , ) ( already_parsed ( Goal Category ,   , Input_String , _); assert z ( cannot_be_parsed (
Goal Category , Input String )), !, fail.
IS_A_LEFT_CORNER (\ [ Real_Left Corner Cat , Structure \] , \[ Real Goal Cat , Structurel , 
Input String , RestString /* reflexive closure of the relation " being a left corner "*/ is_a_left corner  ( \ [ ReaiLeft Corner Category , RealLeftCornerCategory_Structure\] , \ [ Real Goal Category , Real Goal_Category_Structure\] , 
String , String ) unify ( RealLeft Corner_Category,
Real_Goal_Category).
/* transitive closure of the relation " being a left corner "*/ is_a_left_corner  ( \ [ RealLef ~_ Corner_Category , RealLeft_Corner Category_Structure\] , \ [ Real Goal_Category , RealGoal_Category_Structure\] , 
Input String , Rest String ) : -/* a rule having the current left corner category as its left corner is to be found */ f ind rule to be used  ( 



Mother_Category_From_CurrentRule,
Constraints Of Rule,
TypeOfRule ) , /* all the right sisters have to be parsed */ parse_right_sisters  ( Right Sisters_List From Current Rule , 

Input String , Intermediary String,
TypeOfRule ) , call ( ConstraintsOfRule ) , /* the mother category from the rule must comply with the feature inheritance principles relevant for the TypeOfRule */ feature inheritance pr in clples concerning_mother  ( \ [ RealLeft Corner Category
I Real_Right Sisters List \],
Mother Category_From_CurrentRule,
Real Mother_Category,
TypeOfRule ) , /* the mother itself ( ? herself ? ) is used as a left corner , which repeats the process on a higher level */ is alert corner  ( \ [ Real Mother_Category , dtrs=LeftDaughter__Marking=\[RealLeftCorner Category  , 
RealLeftCorner_Category_Structure\],
IReal_Right_SlstersList\]\] , \ [ Real Goal Category , Real Goal Category_Structure , 
Intermediary String , Rest Strlng).
The whole parsing process is started by asking the conjunction of goals ?- parse  ( TOP MOST CATEGORY , Intermediary Result , 
INPUT , \[\] ) , perestroik a(RESULT , Intermediary Result) . 
where the " RESULT " is the only output argument , na-mely , the resulting structure of the parse , the TOP MOST CATEGORYIs a skeleton category ( represented as a " usual " Prologllst ) of the expected result ( most often , something like "\[ cat=sentence \]" or "\[ cat =v  , bar = two \]" etc . ), i . e . a category which is expected to unify with any result of the parse  , the INPUTSTRING is the input string represented as a Prolog list of word forms and the empty string "\[\]" is the expected rest of the input string after the parsing process finished  . 
Eilele A . and J .   D6rre : A Lexical Functional Grammar System in Prolog , in : Proceedings of Coling ~86 , Bonn M ~ tlum Qto ? . et al:BUP-A Bottom-Up Parser Embedded in Prolog  , in : New Generation Computing vol . l , 1983 Pollard C . and I . Sag : Information Based Syntax and Semantics , vol . l : Fundamentals , CSLI Lecture Notes No . 
13, CSLI , Stanford , California 1987
W since IstApril 1990:
Lehrstuhl fur Computerlinguistlk
Universit ~ tdes Saarlandes
ImStadt wald
D-6600 Saarbr ~ cken ( West ) Germany 4363
