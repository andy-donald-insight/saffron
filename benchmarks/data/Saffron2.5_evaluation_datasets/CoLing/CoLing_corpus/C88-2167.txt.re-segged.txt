An Efficient Execution Method
for Rule-Based Machine Translation
Hiroyuki KAJI
Systems Development Laboratory ~ Hitachi Lt do
1099 Ohzenji , Asao , Kawasaki , 215~Japan

A rule based system is an effective way to impl ~nent a machine translation syste/~because of its extensibility and maintainability ? However  , it is disadvantageous in processing effici ~\] Cyo In a rule based machine translation system b the gran~ik ~ r consists of a lot of rewriting rules ? While - the translation is carried out by repeating pattern matching and ~ ansformation of graph structures  , nD strifles fail in pattenl matching . It is to be desired that pattern matching of the unfruitful rules should be avoided  . This paper proposes a method to restrict the rule application by activating rules dynamically  . ? The logical relationship among rules are pre -mmlyzed and a set of antecede/ltactions  , which are prerequisite for the condition of 9/\]e rule being satisfied ~ is determined for each rule o In execution time  , a rule is activated only when one of the antecedent actions are carried out  . The probability of a rule being activated is reduced to near the occurrence probability of its relevant linguistic phenc ~ no noAs most rules relate to linguistic phenc ~ msa that rarely occur  , the processing efficiency is drastically in r proved  . 
I . Introduction
A practical machine translation system needs to deal with a wide variety of linguistic phencm ~ J % a  . A large and sophisticated grammar will be developed over a long period ~ Accordingly  , it is necessary to adopt an implementation method which  ir~0r~  ; es the extensibility and maintainability of the system ?  . The rule based approach \[ i \] is a prc*nising one from this viewpoint  . 
However , a rule based systes ~ is generally disadvantageous in processing efficiency  . In rule based machine translation , agr ~ , mar is comprised with a lot of rewriting rules \[ 2  \] \[  3  \] \[  4  \] . 
Translation is carried out by repeating pattern matching and transformation of tree or graph structures that represent the syntax or s~mtics of a sentence  . A great part of the processing time is spent in pattern n ~% t ching ~ which mostly results in failure  . The key to improve the processing efficiency is how to avoid the pattern matching that results in failure ? A number of methods such  . as the Retep attern match algorithm \[5\] have been devel ~ ped to ini0rove the processing efficiency of rule based systems . 
However , peculiarities in machine ' translation systems make it difficult to apply the whole of an existing method ? The general idea of existing methods is to restructure the set of rules in a network such as a cause-effect graph ~ or a descriminant network  , and maintain the state of the object in the network  . The following are distinguishing features of a machine translation system ? First  , the object data is a graph handle ~\] as a collection of slates of respective  sub4\]raphs ~ which are created dynamically by applying rules o Therefore  , maintaining the state of the object in a network causes a large amount of overhead  . Seoondly ~ ~ ules area ~ plied in a c~ntrolled m ~mer~sotI~t a linguistically insignificant result J  . spreventedo\[\[%~e computational control of rules to ~ rove the processing efficiency must ~ x ~ super\[nkoosed on the ling~dstic control of ~ mles  . 
' l %, jspaper proposes a nu~1 ~ . .thod to ~? fove iJ~e processing efficiency of rule based syst~t ~ having t/le above mentioned featumes oS ~ tion  2 describes a gran~ardescription language which was develops d  fo~7 a JapaneseEnglish machine translation systex no ' l ~ ough the proposed method is described on tJ~e basis of this grars ~ ar description  16mguage ~ it is general enough to apply to other systems ~ Section  3 exp\]ains the probl ~ of processing efficienoy . 
Then , Section 4 outlines the proposed metb0d by which essence is in dynastic rule activation ~ based on the logical relationship ar ~  ) ngrules ? A method to pre-analyze the logic ~ l relationship anong zllles is described ? The Jmproved grar ~ executor is also described  . Lastly , the effectiveness of %/ le proposed ~ tho dis discussed in Section  5~   2  . Grammar Descr ~ for Rule Based Machine Translation  2 oi~ect data structure A machine translation syst~ndeals with the syntax and semantics of a naturall ~ guage sentenc ~ which is represented by tree or graph structures ~ The object data in our machine translation syst~n is a directed graph  . A directed graph consists of a set of nodes and arcs connecting a pair of nodes  . ~ch node has a number of attributes and each arc has a label  . ~e label of an arc can be regarded as a kind of attribute in the tail node of the arc ~ The attributes are divided into sca~peattxibntes and set-type attribetes  . A scalar-type attribute is e ~ lein which only ~ nevalue is given to a node ? A set-type attribute is one Jm whic~h ~ than ~ valuen my be given to a node ~ In Japanese-~glish machine translations a ~ e corresponds to a bumm~tsu in a Japanese ~ t ~ OeoA  . b~n sets uiso ~ rised witk taco ~ itent ~ rd and % k ~ succeeding fnnction word so The follo ~ r'?ng a ~etreated as attributes of nodes  ; parts of speech ,  . 
s ~ m m % tie features , function words ~ dependent , types ~ governor types esurface case markers ~ se ~mmtic roles  ( case )  , and others . 
2.2 Gramn~tical rules
A granm~tical rule is written in the form of a graph-to-g  , raph rewriting rule oT\]~t is8 axu \] e consists of a condition part and an action parto The condition part  . specifies the pattern of a condition *@ X ~ T : ~\[ t  , t'\](a:@Y ) ; @Y ~ U = u ! u ' ( a : @ z) ; @Z ~ V ~@ X . V ; action@X (+ a:@z\] ; @Y (-- a:@Z ) ; ( a ) Coding form
Eli ) ( b ) Illustrative form
F:i . golAn _exf?~J3\]e of a ~ ranm\]atical rule subgrapb , and tile action part does a transformation to I ~ performed on subgraphs that ** retch the patLeml s\[~  . oified . in the condition part : . Fig .  1 . shows an emtmple of rule . In Fig?i ~( a ) is the c ~ Dd J . ng for in t and ( b ) J . san illustrative form ~ As nodes are represents3 by variables ( character strings headed by @ )  , rules should be applicable to any subgraph in the object data ? A rule has a key node variable  , which is indicated by * o The key node plays a role in specifying exactly the \] ocmtion where the rule is applied in the object ? at a ~ The  ( ~ nd ~ tion part of a rule is a logical cx\ ]mbination of primitive conditions ? A prlndtive cx\]ndition  is related to either a node co ~mection or an attribute  . ~lality Js specified fox " as ( mlar-ty ~ . ~attribute ~ and an inclusion relat . ~ onship is specified for a set-ty\[~attribute o '\[ heprimitive conditions are also divided into intra-node conditions and inter-node conditions  . 
-An intra-node condition is one relating to only one node ? e  . g . ~@ X : T : ~\[ t ~ t '\] ; ' l ~ leset-type attribute ? of node @ X includes the values t and t '  . 
?-~ inten---no decondition is one relating to a pair of nodes  . 
eogo , @ X:T=@Yo ~' ; ?\[' he attribute T of node @ X hast/he same ~ alueas % trotoln cx~e@Yo The action pa~t of a rule is a sequ ~ ce of  . -primitive actions . A prJ~d tive action is related to eithe\[a node e on nection or an attribute ? Cx  ) n neetion and disconnection are s~eeifi6~ for a pair of nodes . 
Substitution of a value is specific ~ for a scalar -type attribute ~ and addition and deletion of a value ar_especified for a set-type attribute ? Y % ~ eactions are ' also divided into intra-node actions and inter-node actions  . 
-  2~% intra--nedeaction is one relating to only one nodeeogo  ; @ X : T = T +\[ t\] ; Add a value t to the set-type attribute q'of nede@X  . 
- ~ n inter- . node action is one relating to a\[~ir of nc~\]es . 
eogo ~@ X : T = @ YoT ;
Substitute the value of attribute T of node@Y for tile attribute T of node @  X0 Agra\[m ~ ar ~ . ~msists of a lot of ru\]es , which play their own roles in-t~e translation process ?'\] hey must be applie ~\] in a controlled  , intoner , so that linguistically insignificant results are prevented ? The  c3~'atl~sr description language provides a facility to n ~ x\ ]u\]  . ar:i . zeagral rwmu ~ and specify sop hJstJ . cat c~d control in ru\]e applicat JOnoA gra~t ~ , ~ risdeo~m ~ posed into a lot of subgr~m ~ mrs ~ ~ hich are applied J  . na prescribed order ? ~ brex ~ m~ple , ' the analysis gra~ar for Japanese sentences J . s deo ~ nposed into suchs n bgramtmrs as 6J s~lnbiguation of multiple ~ r'ts of s~eeh , detel ~ niuation of governor types , detezminat ~ on of dependent types , dependency structure analysis , deep case analysis , tense/aspect analysis , and ol . hers . As ' ttb 9 ran . m~ramy 1"~9 dec~m % oosed into further subgr6m~ars  . 
A number of control ? mrameters for ru\]e application are speeific ~ d for each subgra ~ nar ? The following are examples ?  7 -Mutual relationship ~ m~ong rules ( Exc\]usiw ~ , Conctrcrent , Dependent or Unrelated ): For instance , when ~ clusive is selected , rule application is cmntrolled so that successfu \] application of a ru\]  . e should prevent the ren mining rules fr d~l being applied  . 
- ~\ [ ~ averse mode in the object data ( Pre-order or Postorder ) : '\] . ~ e object data is travers e ~\] in the specified mode  , and rules are appl J ( ~\] at each Icxzation : in the object data structure  . 
-Priority between ru\]e selection n~d\]o cation selection : When rule selection is select e  ( I~Yule application is ( x\]ntro\]led so that the next rule should be selected after applying a rule at every location ?   3  . Probl ~ n of Processing Efficienc Z A naive Jmplersantation of grar ~ narexecutor for such a gra~r description language as describe <\] in Section  2 is illustrated in Fig .  2 . q ~ e translation is carried out by applying granmmtica \] rules to the object data in the working memory  . The granmar executor consists of the in J tializer  , the controller , t / ~ e pattern nnt cher and t ~ e transformer . 
' l ~ e initializer creates all initial state of the object data ill the working nm_r  , ~) ry , based on the result of morphological analysis ? It defines a node for each bunsetsu and assigns it some attribute values o ' fhe attribute values c ~ me from the dictionary and ' the result of morphological \] analysis o'l~ne controller ' is initiated after the initial objec ~ data is created  . The controller determines both the rule to be app \]  . ie fl and the current node at which the rule is to be applied  , according to rule app\]ic ~ tion c ~ ontrol parameters and the application result of the previous rule o The pattern nmtd ~ erjudges whether the condition part of a rule is satisfied or not  . % ~ e rule and the current node is designated by the controller ? 
IController-\]~~-------'--~I " Matcher Pattern "\] ~ 
IJI
Fig . 2Grammar executor

Controll Parameter

I Condition
Action !
The pattern marcher first binds the key node variable in the rule with the current node  . Then , it binds the other node variables with nodes in the object data one after another  , searching for a node which satisfies the conditions relevant to each node variable  . If all the node Variables in the rule are bound with nodes  , the pattern matcher judges that the condition part of the rule is satisfied at %/ ~ e current node  . If there exists a node variable that caD/lot be bound with a node  , the pattern marcher judgest/\]at the condition is not satisfied at the current node  . 
The transformer performs the action part of a rule . 
It is called only when the pattern matcher judges that the condition part of the rule is satisfied  . 
As the pattern matcher has bound each node variable with a node in the object data  , the appropriate portion of the object data structure undergoes the transformation  . 
The grammar executor described above leaves room for improven ~ nt in efficiency  . The behavior of rules in the naive grammar executor shows the following characteristics  . 
-The proportion of rules that succeed in pattern matching is very small  . It is less than one percent in the case of our Japanese sentence analysis grammar which is ecmprised of several thousand rules  . 
- The probability that a rule succeeds in pattern matching varies widely with rules  . While some rules succeed fairly frequently , most other rules rarely succeed . 
In the naive implementation of grammar executor , all the rules are treated equally . As a result , a great part of ~ the processing time is spent in pattern matching of unfruitful rules  . If application of '? unfruitful rules can be avoided  , the processing efficiency will be drastically improved  . Same rules can be directly linked to specific words  . 
Application of such word specific rules can be easily restricted by linking them with the dictionary  . Our concern here is how to restrict application of general rules that cannot be linked directly to specific words  . 
4 . Dynamic Rule Activation 4 . 1 Basic idea ~ ether the condition part of a rule is satisfied or rules  , q ~ e logical relationship an~0ng rules can be extracted by static analysis of the grammar ? A considerable application of unfruitful rules will be prevented by using the logical relationship among rules  . 
First , we define an ~ tecedent set for a condition . 
The anteoedent set for a condition is such a set of actions as:  ( i ) carrying Out a member action causes the possibility that the condition is satisfied  , and ( ii ) the condition is never satisfied if nomen~xe . raction is carried out . 
Then , we define the inverse action for a/lantecedent set  . The inverse action for an antecedent set is an action that cancels the effect of any me~ber action of the antecedent set ? An antecedent set and its inverse action can be used to dynamically change the status of a rule as follows  . A rule is activated when a member action of the antecedent set for the condition of the rule is carried out  . A rule is deactivated when the inverse action is carried out ? It is obviously assured that a rule is active whenever its condition may ~ e satisfied  . Thus ~ the application of inactive rt116s can be skipped . 
More than one antecede at set can usually be obtained for a oon dition  . The optimal antecedent set is one that minimizes the probability of activating a rule ~ The optimal antecedent set is one of min~nal antecedent  , sets . The minimal anteoedent set is such an antecede/It set as any subset is not an anteoedent set for the same condition  . In order to choose the optimal antecedent set among  , ~inimal anteoedent sets , occurrence statistics of actions should be gathered using a corpus of texT  . 
4 . 2~s of ~ ammar 4 . 2 . 1 Amtecedent set for 10rimitive oondition We are not interested in all the antecedent sets but the optimal one for the condition of each rule oq ~ erefore  , we turn our attention to intra-no decenditions . Intra-node conditions usually give us an effective anteoedent set  , while inter--node conditions do not . 
% ~ leminimal antecedent sets for an intra-node condition are as follow  . Here , antecedent sets are defined separately for each node  ( indicated by i below )  , as the truth value of a oon dition varies with nodes  . It is necessary to consider two cases . 
One is that the attribute in the condition is not related to any inter-node action  . ~ neother is that the attribute in the condition is related to sQme/nter-node actions  . 
( I ) When the attribute is not related to any inter -node action  , the truth value of a condition at a node i is effected only by actions at the same node i  . " therefore , only the actions at the same node i are included in the antecedent set  . 
e . g . , The minimal antecedent sets for a condition Ti p \[ t  , t'\]are\[Ti = Ti+It\]\] and Ti = Ti+\ [ t '\]\]  . 
A comment should be given on cfm~posite actions . For instance , Ti = Ti +\[ t , t ' , t "\] is also an antecedent action . However , it is decomposed into %' i = Ti+\[t\] , Ti = Ti +\[ t'\] and Ti = Ti +\[ t"\] . Therefore , we exclude it from antecedent sets . 
e.g ., The minimal antecedent set for a condition
Tin\[t , t'\]%~is\[Ti = Ti+\[t\] , Ti = Ti +\[ t'\]\] . 
(2 ) When the attribute is related to same inter-node actions  , the truth value of a condition at a node i may be effected by actions at another node via an inter -node action  ( See Fig .  3) . Therefore , ' the antecedent sets need to include the actions at all the nodes  . 
e.g ., The minimal antecedent sets for a condition
TiP\[t , t'\]are\[Tj = ~ i +\[ t\] , j = l ,  . .,N \] and \[ Tj = T ~ + It '\] I j=l,",N \] . 
e . g ? , -The ~ tinimal antecedent set for a condition
T in \[ L , t'\]?@is\[Tj = Tj+\[t\] , Tj--Tj+It'\]!j = I ,  . .,N \] . 
In this case , obviously the antecedent sets for a rule are cam Dn to all the nodes  . 
On the other , hand , we cannot obtain effective antecedent sets from an inter-no decondition  . For instance , the minimal antecedent set for an Jmter-node condition Ti = Tj must include actions Tj = Ti +\[ t\]  ( for any t )  , as Ti = Ti +\[ t "\] make true the condition together with Tj = Tj+\[t\]  . Accordingly , the minimal antecedent set includes a large number of actions and has a rather large occurrence probability  . 
4.2.2 Antecedent set for rule
A minimal antecedent set for a condition or a rule is synthesized by those for the constituent primitive conditions  . For this purpose , 1"/~ecendition ) ~rt of a rule is transforme ~ into conjtu~ctive canonical form  . The conjunctive ' canonical form is a logical AkD of terms  , each term being a logical OR of one or more primitives  . In Fig . 4 r the condition part of the rule in Fig . 1 is shown in conjunctive canonical form . 
In the oon j\[mctive canonical form , a term is true if anyone of t / ~ primitives is trHe  , and it is false if all the pr~nitives are false . Therefore , the union of the minimal antecedent sets of the primitives is that for the term  . Here , the detailed procedure is separated J~to two cases  . In the case of the term being relat ~ to the key node variable in the rule  , t / ~ e minimal antecedent sets for the node concerned should bet~ited  . On the contrary , in case the term is related to a node variable other than the key node variable  , the minimal antecedent sets for all the nodes should be united  , because any node may , as a result of structural change , occupy the location that oor resix gnds to the node variable the term is related to  ( See Fig .  5) . 
The condition , a logical A ~) of terms , is totally true if and only if all the terms are true  . 
Accordingly , each minimal antecedent set for one of
Fig . 3 il intra-node I , Jaction a ~ jJT j = tj +\[ t\] .   .   .   . ~ JD\[t\]~~ter'nod~actionI
Ti = Tj ) conditionatiil ~ TiD\[t\]----~TiD\[ t  , t'\]k , \]? Antecedent action via inter-node act i on Fig  . 4 ~ osition of a condition l\[?
Action at\[Uj=u , Uj = u'\]---~\[
Fig . 5 ~ Change J ~> condition at ii * X .   .   .   . 9 ~ x =\[ t,t"T\]I
YT a ", . . . . . ~ Uy = u or Uy = u'\]
Iv ,= vx\]
Antecedent set via structural chan~e condition part of a rule usually includes one or more terms comprised of intra-node conditions  , it does not mattertlmt effective antecedent sets cannot be obtained from inter-no decond J tions ~ As an example of the nlinJ/~al  antec6~\]ent set for a rule ~ those for the rule . in Fig . 1 are given below . 
\[ Ti = Ti +\[ t\]\] , \[ Ti = Ti +\[ t'\]\]\[Lj = a'j=I ,  -  . , N\]\[UjU , Uj = u!j = I , " ~ N\] . 
4.2.3 Inverse action
The inverse of an action can be easily defined ? e . g . , The inverse action of Tj = T i + \[ t \] is T i = T i - \[ t \]  . 
The inverse action for an antecedent set is obtained by connecting all the inverse actions in the set ? The following are the inverse actions corresponding to the antecedent sets shown in  4  . 2 . 2 . 
Ti = Ti-\[t\],
Ti = Ti-\[t'\],(L\]n---a)&- . &( LN~=a ), ( Ul ~= u ) & ( Ul ~= u ') & . ?&( I,N~=u') . 
4.3 Modification of . granmmr
Among tilem in Jlnal antecedent sets for each rule , the optimal one is selected statistically using a corpus of text  . Then , t/hegrammatical rules are modified as follow . When the action part of a rule R ' includes a member action of the antecedent set for a rule R  , the action to activate R is added to the action part of R '  . Likewise , when the action part ' of a ~ uleR " includes the inverse action of the antecedent set for a rule R  , the action to deactivate R is added to the action part of R "  . 
We should add a comment on the s?atus of a rule o In principle  , a status is defined for ead \] node . 
However , when the antecedent set is related to ancde variable other than the key node variable  , or an attribute relating to scme inter-node actions  , a status cfmm~n to all the nodes is defined . 
4.4 Improved 9 rammar executor
A n . improved grm~m ~- executor whid ~ exec\[~tes the l  ~ od if J  . edgran ~ k ~ risil\] . ustrate <\] in Fig ? 6 . A statustable indicating the status of rules is introduced ? It is updated by both the initializer and the trensformer  , and looked up by the contro\]ler ~' l~ne initialize rac  . ~ivates the rules in whJch the antecedent set includes an action in the process to create the initial object data ? The transformer performs rule activating/deactivating actions include ~\] in them < x\]ified grammar  . The controller looks up the status table whea it selec ~  . s the rule to apply . While the control is transferred to the pattern matcher if the rule is act Jve ~ the controller irm ~ diately selects the next rule to al~ply if the rule is in active ?  5o Effectiveness The ~0roveanent of processing efficiency by ~ le proposed ~ th cx \] is disc~assed frc~t two points of vi ? ~: ~ he probability that rnles are active and the overhead cm used by dynamic ru\]e activation ?  ( iProbability that rules are active ? The probability t\]mt a rule succeeds in patter ~\] matching is a lower lJn/t for the probability that the rule is activated ~ However  , the \]? ~ erlimit ( ~ n not be realized ~ because a rule is activated with prerequisite actions for its c ~ ondition being satisfied ~ q~estate ~ active ' implies just the possibility t/\]at the rule will be applied successfully  . The gap between the probabilities of ' active ' and ' success'varies with rules  . Fig ~7 illustrates two extreme cases . Fig .  7 ( a ) is a case in which there is a minimal en~tecedent set for which occurrence probability is near the probability of t / ~ e condition being satisfied  . Fig .  7 ( b ) is a case in w~dch there is no such ndnimal antecedent set  . 
As a matter of fact ~ ( a ) is a usual case and ( b ) iss rare case . A rule usually has a key condition featuring its relevant \] ing\[d  . stic phenomenon , from which an effective antecedent set can be obtained ? ~ herefore ~ the probability of ' active ' is reduced to the same order as the probability of ' success '  . 
(2) Overhead of dynamic rule activation.
No additional condit X ons are introduced to the condition parts of rules to judge if an acTX onto activate/deactivate a mile should be performed ? 
O(%(%1C--tter ..... t <==
R . lestotu Y q l
Table \] < ~= = = = = = ~ ~ Status U ~ ~- ~%
Fig . 6 Im~ed J__q_rammar executor

Control

Modified Rule
Condition
Action
Rule Activation
Rule Deactivation success success active ve ( a ) Usual case ( b ) Rare case
A , BFC : minimal antecedent set
Flu . 7Probabilit ~ of ' active ~ vs.
Probabilit ~ of ' success '
Although rather a large number of actions to activate/deactivate a rule are added to action parts of rule ~' ~  , the action parts are infrequently performed . Moreover , although looking up the status of rules occurs frequently  , its load is far smaller t/~1 that of pattern matching , which would be repeated if the dynamic rule activation were not used  . ~ erefore , the overhead caused by dynamic rule activation can be neglected  . 
Another effect of the proposed method is that it can be applied to on-d~d loading of rules when the  1~anory a ~ pacity for a grammar is limited . That is , while rules with a large probability of ' active ' are made resident on the main memory  , the other rules are loaded when they are to ~ applied  . Thus the frequency of loading rules is minimized . 
6. Conclusion
An efficient execution method for rule based machine translation systems has been developed  . ~ees sence of the met 21 od is as follows . First , a grammar is pre-analyzed to determine an antecedent set for each rule  . The ~ tecedent set for a rule is a set of actions such that perfo~r?ing an action in it causes the possibility of the condition of the rule being satisfied  , and the condition of the rule is unsatisfied if any action in it is not performed  . 
At execution time , a rule is activated only when an action in Ule antecedent set for the rule is perfol ~= d ? qhe rule application is restricted to active rules  . The probability of a rule being active is reduced to near the occurrence probability of its relevant linguistic phenomenon  . Thus most pattern l , ~ tching of unfruitful rules is avoided . 
Acknowledgement : I would like to acknowledge Dr.
Jun Kawasaki , Mr . Nobuyoshi Dc~en , Mr . Koichiro Ishihara and Dr . ~n Watanabe for their valuable advice and constant encouragement  . 

Newell A .  (1973) . Production Syst~ns : Models of Control Structures  , in Visual Information Processing ( ed . W . C~ase ; Academic Press) . 
\[2\] BoitetC . , et al (1982) . Impl ~ tation and Conversational ~ vironment of ARIANE  78  . 4, Proc . 

\[3\] Nakamura J . , et al (1984) . Grars nar Writing Systesl ( GRADE ) of Mu-Machine Translation Project and its Characteristics  , Proc . OOLING 84 . 
\[4\]EajiH . (1987). HICATS/JE : A
Japanese-to-English Machine Translation System Based on Se~ntics  , Mac/line Translation SLmmdt . 
\[5\] Forgy C . L .  (1982) . Rete : A Fast Algoritl ~ n for the Many Pattern / Many Object Pattern Match Problems Artificial  Intelligence0 Vol .  19 . 

