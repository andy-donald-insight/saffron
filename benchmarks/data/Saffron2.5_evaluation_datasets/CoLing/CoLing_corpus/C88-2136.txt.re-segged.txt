16a~\] . gG_&\]~?? . Na ; i ; ttra . iLa . , . /gi~ . ; . ~ . geAnalysisc , ~, ystem
TOK(\]N . AGA '/) ake ~ obu , IWAYAMAM ~ d~o ~% TANAKki : fozu~tfi
\]) ep~trtmento1!Computer,?qelence
'\] bkyoh~sgit~e<K'\]2hcm dogy
I(AMIWAKI3% dashi
\[ iif,~whl\]h'sem:chI,M > or ~. tm:y
tlit~mhi I,M .

' . Fhi . q p ~ p m p r e s m d s ~ s \] ~ a . tu~a . llatg ~ atge ~ ma\]ys is system ~', ~ . .:~ gL . A ? / ~ base do ~ t_~:~0'~ . - X(: . ~ which parses with at I , r ~ i . t,om-~p ~ d delr ', h- . - fi~s  ~ , trategy a : t t d hms at bili ~ , y t , oh ~ nd\]elgext_~;\] . positio: , to We halve at l\]xm+dy deloped agtammatr for- . 
malls in ') ', X ~; :; , which ix a . snpeJcset of I ) CGoWi ~ . hX . K . ~, legex\]:atposii;io:~phenome . , ta , is nattrt\]:~/lyexpressedi,~g\]:a . mmat ~: F , les=Weh . : tveat b ; optim . ized . \]: ~ tl~X < cl . ~, ~, se , ; . l , ', : ~ p e > merits aho ' a . ed that th:i:ompatr\]so ~ to the el : itrod ~ U * . . . 
XG system ~ the an Mysisapedup 10 times in the interp ~: eter ~ node ~ , td 4 times in the compiled mode ? The ' . PNX\]!~s~;r~c . .
ttlred dictio a atry ixl . La , tgLAJC ~ req ~ fires less rnentory , p\]:o-ridesIkstm:dictim-~ary):eD . renee ~ nd also hat ~ td\[escma . p\]i-c ~ tedidioms with versa~t Jlity . Conseq~e\]dly ~ the itti\]iz~4hmel ~, a_~ . tg\]; . Ag for pra , : tical purposes ha . s become feasf ble . 
Sot'a , r , seve ~ at ! gratmmar form a . /imn based < m logic prograt m . -mi \] tgpar ; ~ d: , g\]n~i IlChatSMet ~ nno ~: phosisGramm ~ ,  . r\[~\]aatd\])CC . \[9\] ha . ~ . ebeen p ~ : eseatedo In Meta . : , ~: mr phosisGr ~ llt~ta , r , each graan max rule is tratns latted i ,  . t~o at I\[or ~ tClatuse , and the Pro/oghd , er preterpa ~: ses the inp * tt sentmte e with these llo  , : rtClauseuai ~ tl ; attop- , dew , a , xtdep ~ h . d'aa ~ ~ strattegy . O \] tlilm in the past where pa , sers had to be eo \]\] strlmted for synt~mt\]e analysis  , i ~ t ; ; h is method , we do not Mwetoi ) ecrt use the Prologiute ~ preter itself works a_ . ~ o , m . Metat morplhosis Gratmma : catlso provides ~' ~ t atturatl bnguage processing method which intede at vest  ; y~tta . etie ~ aatlysls and sere . antic attalysis . ' i ' his is at deal , able feattu ~ e from . the pot , 4 of view of cognitive science ?1 . , " ollowing Met~u ~ torphusis Gra . mlaar ~ Yerekae ~ ~1o devel ~ oped agra , mmar formalism called lJe . ih fiie Cla . ase Gratm-ma . \]:( D ,, ~ . :0 at , ~ dlgxt ): at posii , imt (, ratmma ~ . r0 = G)\[8\] . The gratmra at * r ~! eswrittmti~tI ) CG at ~: e also tr~n slatte di rate a ~ Pro log progratm  , a . nd the Prolog in . ter preter works as at top ? ( iow x ~ a ) ~ d dopth-4i~st pa~seri ~ tterleatving syntax axtrdysis . ~ nd sex ** a ~ tie aaalysis . XG is the exte ~ tdedver . qioa of DCG ca ,- pa . bleofhaa, . dli , tgleftext ~ a ~ poaition , ) o weve . ~: ~ top--( low ~ patrs e ~ have ; a . ta'oblemtMt thep:m-gra . m : 5~llsi ~ to the infinite loop whe_* . tatleg~ec , rsive rule a ~ pzpea\]~rsi?t the gra . mma . ~: rtfles . Thls problem (: a ~ . \] t be solved by either t\]:~mlatti~tg gra . mmarr ~ tles with left rem ~ rsive rule di ~ 4 . omet ; wiZholltle*t ~: eeursiver ~ ales or by'ashlgat botto~n  . -app ~ . ~: singst ~ tegy . Si ~ teethelbnner solallen ~ aty give ~ m ~ , ~ , g ~ tral ?2 s . ~: shtg ~: esults ; the latter is prefe ~: atb\]e . 
Ma . tsn~ao ~ oofl , ~leetrotee/ndeal :! ~ , t ~ bora ; or y developed ~ . 
sys*emin widththeg ~: at nlnla ~** lesw*itteai ~ t:I  ) CG at ret , a~t slated it t to \]\[ o ~: xt clauses c ; dled BOP cb~uses ~ atd Prologh ~ erpre ~ ; e*wo: , : ksa ~: abo ~ om-up and depth d lrstp ~ . , sm : " il , 4, , , i , G . . . . . .
2qI7i ? ZZZZZ , ZL~21:2_2.
Smllm ~ o ~ IT fllF . ~ I ruetuto d\]I ? ? t~dlot lonar I\[JUP- , ~3 ( littlsO ~;
Prolo ~ System
I .   .   .   .   .   .   .   .   .   .   .   .   .   .   . l .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Vli Ot AJli
Figm:e 1: Stun:lute of LangLkltfin : these rules \[1@ Ma , tsun ~ loto h ; system is called the BUP system . ' i ! ? he BUP system ca , nha , ndleIv:Itrecn\] , siver de s~n(i , t ~ : eat ~ gl : ammatrrule ~; a , nd~hedictio ~ a try sepat : rattely , Komtoof ' . lbkyo Institute of Technology extended the B0P system LoBUP-X ( 4 system\[5\]w Mchca , nh ~: nd le the leftex ? , \]: at positio ~ tphen on m\]tate legantly . BUP-X ( : I system in tn : oduced the g~atmmatr description for mea  , lled XGS(F , x-tr: , ,~posit . io~t Grammatr with Slash Category ) . 
This paper presents amttnral \] at nguage a . m dysisysge:mLa , ngf , AB base do ~ Ko It no's BUP--XG system .  \] , ' igul : e 1 shows the structure of the LatngLAB system , Users should p~ep ~ regr ~ mma rules written in XGS and a dietion a try written in I  ) CG . Both gramma . r rules at nd~t diction atrya \]: et , atltal attedi~t to BUP-XG clauses and 3 . 'lf . IE stratetltred die-ti?mary respectively by tra . nslatm's .  3 ) ranslated results are c0nsMted by the Prolog system and the Prolog interp ~: eter works as ~ parset  . 
In chapter 2 , we briet \[ y explat in the filn datmentals of the BUP system and the gra  , mmar description tbrmXGS adopted itt LangLAB . We will a . l so describe BUP . XG treats-is . to . , : which translates the g ~: atmma . r witten i ~ l 7XG S into BUP . -- XG cl ~ tllse alt dits optimizatimts , l * t chatpter 3 , we will to 4 ch on the ' . FRIEst\]mctn*ed dictionary adoptedi ~ iLatngLAB . ' i?\] , IEstruetrl redietio\]tary ~ eqnires less memory at nd provides'faster dicfio\]n ~ ryeference a  , n . d provides ~ texible idiomlta ~ tdlil ~ g . In chapter : 4 , we shall p\]:esentre-suits of experiments re : drying the effect of the optimiza  . *, io~des, . : ~: J bed in the . pier 2 . Experiments showed theft the a . md--ys is spedap 10 times in the interpretive modeu at d 4 times in the compiled mode . The authol:s believel , ha . tL~\]lg\] , A\]lpe~fi>rms well cnoug\]t to be of pratctiea , luse . 
65 ! is --> rip , vp . ( dl ) np ~ - . > pron . (d~2) pron-o->\[you\] . ( d-3) vp-->\[walk\] .   ( d ~ 4 ) Figure 2: Sample grammar written in DCG np ( G ) --> link ( np , G ) , ( b--l ) goal ( vp ) , s(G ) . 
pron(G)-->np(G ) . (b--2) diet(pron)--->\[you\] . (b3) diet(vp)-->\[walk\] .   ( b - - 4 ) Figure 3: BUP clauses translated fzom figure 2   2 XGS and BUP-XG hit his chapter , we shall explain the grammar description form XGS adopted in LangLAB and the BUP-XG translator which translates gramma rules written in XGS into the BUP-XG clauses  . Before explaining BUP--XG , we will briefly explain the mechanism of the BUP system  , the predecessor of BUP-XG . Basic parsing mechanism of BUP is left-corner parsing with topdown prediction  . 
2 . 1 BUP system \] in BUP system , grammar if les written in DCG ( Figure 2 ) are translated into the rules called BUP clauses which are also of DCG format and some Prolog program  ( link clauses and termination clauses : explained . later ) . 
Figure 3 shows results of the translation . These BUP clauses are then translated into a Prolog program  ( Figure 4 ) by the DCG translator wl , ich is embedded in the Prolog system . Two more arguments are added to each predicate which denotes nontenninal symbol in figure  4  . These arguments constitutes a difference list which represents he input string  . With the special predicate goal which is necessary for bottom up parsing  , this Prolog program can parse the input string with a bottom-up and depth-first strategy  . Figure 5 shows the definition of the predicate goal . 
Now , we shall give a step by step explanation of the parsing algorithm of the BUP system  . We will use the grammar shown in figure 4 and input sentence " you walk " as an example . Calling the predicate goal activates the parsing process : ?- goal  ( s , \[ you , walk\] ,  [ \ ] )  . 
np(G , X , Z ) : ~' link(rip , G ) , ( p--l ) goal ( vp , X , Y ) , s(G , Y , Z) . 
pron(~,X,Y ) :- np(G,X,Y) . ( p2) diet(pron,\[youlX\],X ) . ( pS ) dict(vp,\[wa\] . kIX\],X ) o(p-4) Figure ~: Prolog progn ~ . ms translated from figure 3 goal ( G , X , Y ) :-~( g-l ) ( wf_goal(G , X , _) fail_goal(G , X ) ,  !  , fail ) ,  !  , wf_goal(G , X , Y) . 
goal(G , X , Y ) :-( g-2) diet(C , X , Y ) , link(C , G ) , 
P = . . \[ c , G , Y , Z \] , call ( P ) , assertz(wf_goal(P )) . 
goal(G , X , Y ) :-( g-3) assert z ( fail_goal(G , X )) ,  ! , fail . 
Figure 5: Definition of the goal clause
This calling checks to see if :
A parse tree the root of which is the category %' , can be constructed from the input string denoted by the difference between the list \[ you  , walk \] and the list\[\](\[ you , walk \] in this example ) . 
The first call of goal invokes the clause ( g-l ) in the figure 5 . 
The clause ( g-l ) checks to see if the same analysis have been made before  , to avoid recomputation using the information previously asserted as wf_goal and fail_goal  . 
As the execution of the clause ( g-l ) fails in this case , the system chooses the next clause ( g-2) . In the body of the clause ( g-2) , the system consults the dictionary by calling " d i e t  ( C , \[ you , walk\] , Y ) " . This predicate call picks ( p3 ) in figure 4 and the system matches " pron " with variable C and "\[ walk \]" with variable Y  . 
In the second line of ( g-2) , the system calls the predicate link to see if the category which is obtained by the previous dictionary consultation  ( " pron " in this example ) can be left-corner of the current goal ( '%" in this example )  . The llnk clauses are calculated by the BUP translator  . Suppose this test succeeds , the system calls the predicate " pron ":
P = ..\[ pron , s,\[walk\],\[\]\], call(P).
Calling " pron(s , \[ walk\] , \[\]) " invokes(p2) . Then , the system executes its body that is , " up(s , \[ walk\] ,  \[\] )'~ . 
Calling " np(s , \[ walk\] , \[\]) " invokes the clause ( p-l) . After calling the predicate llnk to check a teach ability from " np " to " s "  , the system invokes " goal ( vp , \[ walk\] ,  \[\] ) " . At this point , the system has analyzed the string " you " as " up " and is predicting that the trailing string " walk " should be bundled up to the category " vp "  . 
In the same manner , a bottomoup analysis with a topdown prediction proceeds until the execution of goal with the termination clause succeeds  . See \[14\] for the detail of the termination clauses . 
R , esults once succeeded or failed in an analysis are asserted as wf_goal in the end of  ( g-2 ) and fail_goal in the clause ( g -' S ) respectively . This information is used in ( g-l ) as described . 
np = . -> pron?(x-2)~tp--=>del;~~tomt,s_x'el . ?/ np . ( x-3) vp . . . . > vt ~ x~p . ( x-4) ~ . ~: el?'o > : cel~p:coa , ~ o ( x-5 ) Figure 6: Sample graramar written in XGS 2 . 2 ~ IO ' I~=XG systen l The embedded sentence which appears in relative clauses in English can be viewed as a strncture ilt which a noun phrase is missing f\[om declarative sentence  . A gap is formed as a result of moving the antecedent from within the declarative sentence to the left of the relative clause  . Linguists call such phenomena " Left extraposition '  . By considering the gap left by then loved constituents aa " trace "  , and incorporating a mechanism tha:t looks h ) ~ such a " trace " automatically , the number of gxamma rules can be decreased and the grammar ~ ules become a sie ~ to read  . Moreover incorporating such mechanism contributes to making analysis peed faster  . 
~* bp = down parsers hke ATNG\[131 ,   \[12\] and XG \[8\] inc of porate such ? mechanism ? The topdown parser can predict what catego : ey the trailing input string may be bundled up ~ o  . Efficient trace searching is possible as the system assumes the e:dstence of traces only when a particular cate-go  , y is predicted as a goal . 
Apu~eboa ; tom-up parser is not capable of such predictions and inefficiency results because of the necessity to assume the existence  ; of a trace between every two words . However , since the BI\[P system incorporates topdown prediction in the bottom-u parsing strategy described in  2  . 1 , it is possible to implement the mechanism to look for the traces efficiently  . Konno developed a BUP--XG system which incorporated such a mechanism  \[5\]  . 
The XGS adopted in LangLABp ~ ovides grammar writers the facility ~? ith which left extraposition tanbenaturMly expressed in grammar rules  . Figure 6 shows a small English grammar w\]d chis written in XGS  . 
The notation " . o /" ( called " slash " ) in the rule ( x = 3 ) is introduced in XGS . This rule means that there exists the syntactic category " up " which dominates the " trace " under the sypt actica ~ egory " s = xel "  ( % . xel " means relative sentence ) . 
This idea is influenced by the % lash category " in GPSG  \[3\]  . 
We call the category after " .   . /" ~ cslash category " . Rule ( x-3 ) also shows that the category ' ~ np ' ~ consists of the categories " det "  , ~' noun " and % . xel " and that the trace left behind by the left extraposition of the norm phrase consisting of " det"a~td " norm " is dominated by " s ~ rel "  . During an ~ naly si % when the system finds the trace under " s_~el "  , assl ~ own tit figure 7 , its associates the trace in the enlbedded sentence with the moved phrase  ( " the man " )  . 
XGS also provides a notation to represent " Ross's Comoplex NP constraint "  \[10\]  . Following is an example of this notation . This notation is called " open ( < ) " and ~' close ( :> ) " following Pex'ei ~ a\[8\] . 
a ~- o > b9 c ~< d > .
'\[ . ' his rule ~ Yu ! a . : as that category " a " consists of categories C~b  '  , " C ~ and ~' d ~ . Open-close notation defines the scope of extra-np npsrel detneuntheman rel_jorensnpvp who\ [ trace\]lovesher Figure  7: Matching between slash category and its trace position  . This example says that the movement fi : om under " b " or " c " to the outside of " a " is permissible  , but the move = ment from under " d " to the outside of " a " is not  . Sentences violating " Ross~s Complex Np constraint " are rejected by modifying  ( x-3 ) to become ( x-3' ) np --> do t , noun , < s_rel .   . /np > . ( x- . 3') With ( x-3') , the trace which is dominated by slash category " up " under " s_rel " can only correspond to the noun phrase which consists of " det " and " noun "  . 
In addition , XGS also provides a double arrow notation ( ==> ) and the notation to describe X lists ( explained later ) explicitly . With these notation , " coordinate structure " can be represented in a natural way  ( see\[5\] )  . 
2.3 BUP-XG translator
Just like the BUP system , the gramma rules written in XGS are translated into BUP-XG clauses  , link clauses at Ld termination clauses by the BUP -XG translator  . The BUP-XG translator in the LangLAB system has been improved so as to generate BUP--XG clauses more optimized than that in the original BUP-XG system  . Furthermore , it is also equipped with a new function which inserts parse tree in  . -formation automatically . The translator takes about three seconds to translate a grammar of about  200 rules . The following subsection explains these inl provements  . 
2 . 3 . 1 Representat ion o f l lnk clauses As the number of grammar rules increases  , more link clauses are generated by the translator  . For example , from about 200 gramma rules of English which we have developed , the BUP-XG translator generates about 700 llnk clauses . 
Shortening the search time of llnk clauses wo nld contribute to an efficient analysis  . 
Link clauses are called in the body of BUP-XG clauses and in the predicate goal  . Since both the alguments of link are atoms in the both cases  , all nklink(a , b ) . 
which denotes th . ereach ablity from the category % t " b " can be change to the form a  ( b )  : - ! . 
This form of representation reduces the search space of the reachablity test  . The BUP-XG translator in LangLAB geuoerates link information of this form  . 
557 2.3.2 Indexes for dit Ferenee\]:~st
As described in subsection 2 . 1 input string are represented by ~ , difference list and intermediate analysis results are as--served with the predicate wf goal a:ud fidl  . goal . Since dmh~s two arguments of " the wf_goal constitutes a diff brence list of the input string  , the longer the input string becomes , ~ he more memory wKgoe ! consumes . By indexing differ . .
once lisfs , the amonnt of memory ~: eqnired is reduced , amtfasterre\[create o intermediater sults is possible  . 
' or example , when the system gets the input string '! you walk  "  , the predicates text arc a . sse~ted as follows : tex~(sO,\[\]) . 
text ( r ~: l :,\[ ~ alk\]).
te:~:t(s2,\[ you,~al . k\] ) ?' l'he dictionary reference program gets a difference list by calling text with indexes  ( s \] , s2 ,  . . . ) as the key , before con-suiting the dietiom ~ ry . 
2 . : L3 Representation of intermediater sults Generally  , along input string gives rise to more wft goals and faiL goals which results in longer search time for intermediate analysis results  . Wf_goals and fail_goals have as their arguments , the index to the difference list denoting the partial input string  , and its an Mysis . As described in 2 . 1 ; goal first consults wf goads and fail_geMs with the indexes of input string as the key  . In LangLAB system , the predi- ( : atenames of intenned late analysis result are the indexes to the ditference list instea A of " wL  goa  . \]" or " fail_goal ' . This modification reduces the search space oil the intermedi~t t canalysis results and speeds up the analysis processo  2  . 3 ?4 Insertion of parse tree information Users sometimes reqaire the results of syntactic analysis to be expressed as pa  . rse trees , and in both the BUP system and the origin MB ( Y\] ) -- XG system , users are required to insert an argument in each category to accommodate parse treelure > marion  . I to weve ~ , it is not a difficult task to make the translator insert this information automatically  , ht the BUP-XG translator of LangLAB , this information is inserted auto-maritally unless instructed otherwise  . This Nnction is similar to ~ he one in the McCord 's MLG  ( Modular Logic Grammar )  \[7\] . However , unlike MLG , all the nonterminal symbols can be a node of parse trees  . 
2.3.5 Example of translation
Figure 8 shows the BUP--XG clauses translated t ~ om the grammar in figure  6  . The wriables beginning with " X " in the figme . 8 axe introduced to handle left extrapos mon . T in s variable is called X list ( extraposition list ) which were introduced in XG\[8\] . Information pertaining to slash categories is pushed into the Xllst and is then transfe:rred from eate  . ~gory to category during the analysis process . The predicate goal_x is an extended version of the predicate gord in the BUP system  , which pops up the slash category from the X\] is ~ when the t  ,  . ' ace is\[bun & Note that variables for parse tree in ~ brmation  , the names of which begin with " T " , are automatically inserted and that the representation flink information  ( in braces ) is also modified . 
np(Goal,\[TJ\],Xnfo,XO~Xl,XR ) . . . . > geal_x ( vp ~ \[ T2\] , Xl , X2) , s((~oal , \[\[ s , ' fl , ' r2\]\] , Info , X 0 , X2 , XR ) opron ( Goal , \[ TI\] , Info , X 0 , Xl , XR ) . . . . . > up(Goal ) , np(Goal~\[\[np , 'fl\]\] , Info ~ X0~)\[I , XR) . 
dot(Goal,\[T1\]~In're,X0,Xi~XI~) . . . . . . >  up(Goal ) , goa\] . ~ x(noml,\[T2\],Xl~X2), goal . . . x(~ . rel , \[ Y3\] , x(np , \[ np(t)\]~X2) , X3) , ~ np(Goal , \[ tap , T1 , T2 , T3\]\] , Info ~ X0 , X3 , Xlt ) , ?et ( Goal , \[ TI\] , -tato , XO , Xi , XR ) ~- . > vp(Goa\] . )  , goal_x(nil , \[ T2\] , X ! , X2) vp ( Goal , \[\[ vp , T~ . , T2\]\], lure,XO,X2,Xlt ) ~' el_p:~o:~, . ( Goal , \[ T1\], Info , X0, Xl , XR . ) " ~'> s_rel(Goal)\]', goal . .x ( s ~ IT2\] , Xi , X2) s_rel(Goal , \[\[ s_rel , T :\[ , T2j\]~Info ~ XO~X2~X ~) . 
Figure 8: BUP-XG clo~nsest ) : ~ mslated from figm'e6v ( info ( get )   ) ~->\[ get\] . 
v(ref(get,\[\[vfIed\]\])) . . . . > \[ got \] ? v ( re f ( get , \[\[v~len\]\]))-->\[gotten\] . 
v(in:ro(get_up )) - ~->\[ get , Up\]ov(info(gct_on )) -- >\[ get , on \] . 
Figure 9: Sample dictionary including idioms 3TR , IEst , ructured dictionary This chapter explMns the TRIE stnletn redictionary  , a > other extension to the BUP-XG system and the BUP sys-  . 
tern . The TR\]IEsh'nctured dictionary requires less memory  , provides Nster dictionary ~ eference ait d flexible idiom handling  . 
3?1 Title structure
The name " T/~ll ? , " is takenfl'om " reTllllJval " \[1\] and it means a kind of tree structure . A dictionary written in I ) CG is translated into a TRIE structure dictionary by the Tll  . IE dictionary translator . The TPJE structure is utupple which has three elements  , that is " word " , " information for word ( s ) " and ' ~ its child TRIE strncture ' . 
' or example , the dictionary written in DCG shown in fig- . 
are 9 would be translated to the TP~IE structured ictionary shown in figm : e  \]0  . 
To lookup a TRIE . ,~ t~uctuzed dictionary , the diclion a ~ y reference program searches through the tree matching the i~t put string with the first element of the TKIE structure and  , information for the string of input is retrieved only after the last word of the input string is matched  . Actnally ~ the translatm : blmdlesup ~ he dictional : y entries which has the s~Lmeill'st word into ? clause  ( sue how the entries ' ~ gct ' , " get on " , % nd " getup " are translated in tlgn re10) . By md~g this struchlre for the dictionary , the system can avoid the \[\[ v , \[ i : i ~+ : ~ o(gei;) , Ii ! J\[t ~( ,  . It,i \] D ,, l_t:u:to(l :> ri; . mO\]7!7i ,
I11 . 1t,\[r+<~)-,i::\[l\[~0(~j <!~: . fl : ~ . ~)) 71\[l . " t , diCi:i ~( re ~; ~ i7Iv , E+:La:~I(g , ; i ; . ,\[\[:v:~:!~ . d\]~i)J\]\],
H )..
(12t : i ; ~+(\[-; oi ; geL*!i " J , b_'e : , :( ge ~ , i ~\ [ v : ~ ie~d\])\]11! , 
J \]) o\]'~i\[;, . -' i:eI0:'J)\]l)';s ~; i:~c ~,, + ret~:a ~,', tsls . ted from fig . x:e9ba , ckt:ca , cki . ! ~ a , +, (: lwl ~ . a ~ level h ~ dJ . cimia ~ yreJhJ : eace , a , ,d ~+ , i , I , titare ) , ~ he ~ r!~n:u)cn~ofi:he head is the intb ): m~ic . t of bk ' , <; ~ t t , ~: y +' t'hc > , q~nmen ~ , ": i , ' , + , ~ o(+:+)":'utean<~the hth)rma , iAo . 
el ; heelitr F % , '-'~' , ' J ' lC ~ argll ntevtt of tile entry + eI ~ Otna , ! td(\[~ , Ot()\]++)\];a ! , ~ , rl . lCttLree\]i Je;iDWIIJ cl!dem>e,: . : a ~ ,  !> ( ) Jilter to the entry denoted by the iir <?~ argmne-nt of %'  , + , i 7" ( hthi ~ case , a , \]) oinl , e ~ totlmentry ~< get ~) . \]) iction a ) yet ) trie , ~ i ; h ( ~ilttb::'+aa:ho~l of whict only differs Dora each other l :  ) ~+ rt\]aJly~e+g+the\]:oo:ibrnt ~ utd the col@gated Nrm of a + ni  , : regld ; < c "/ e)b , ca , u1 + ~: wri ~ , i ; tmi , , . ~ hJsma . nne : , :+ + JP \]) esecoli_dgi:gtD . ), en\[or the s\[rlletltrec:~: . ~;; 12~) is \] to dil: . 
J ~ erential it . ti > ima . tion bet , >e( ; e~his entry ( :+ f4 ot ~ ( Jr "! ~ ( > ~ t ( )*i > ) and the enhypoht ted to by the tit ' . s +, arg / ! il teltte-J '";/ el " . \]( ti ; hi < < ie/a ' . , ~ q p \] e , . i ! attlre << ~, J7 ~ lrl . (;it . \] lts : % erb ! iron " a . nditsv ~ Jae ~< od . " a . nd % . m " men , Its " pa . s " act td <<\] . ; its tpuxticip\] , ? ~  , : e , ~ , p e , (> l , ive ! y , " V\"i ~ h . .; tlch ~' , +(/ emvxipgi()tl , users dolto thave tOW \]' ite ~ M di ~ . iomd:diemm ) LJ . es whle hi~mlude theeo , ~sgated lbYulofi > : eguh ~ a verbs . In the cas :; of reg~darvet : b % since co , f, . \] ug , a\[cd\[brmsacrepr :) ee , < iqed b2 the : utoq diologie alaliMys is p: , :ograJ . ml ) a_i \[ ~ . ; ai , he dieionaa : yreihren (: epc'oBram , i die , mc < nt ~ : ies wtii , : lti: . q clade the conjugated Jbrmau : enot ~ tecessary + gote xam  . ) ~ t % t ~ sers do : ~) ot , hamstow ~: i tegte idion lmit * y < < kicked the blt deet ' ~ i \[ life  (  ; ntry'<k\[c\]el ~ ebucket " is writ:tea . 
f io ~ , ary ' il , '\]) e'\]/R\['\]strnctl~eedic ~ io . a ~ ryea . : uhteht de P~:o log pro . 
g~a . ms to check , ,; ome cons , a , httsa , it dsy\]~ta , eticea : lego ; iesi , tits + + wo:ed"po . , dtimt(tb:stelementelim . pl)ie ) .  ' . flit , < . ; > atiu'e makes Jtp3ssible ~; ot ~ , : ( td~e~;l')eidio '_ , rtai , iclming , ion- . fmze3, . 
c\]e,umt % aae has %! . (:, tt ); aly . . . . but a,ls . )  , ?) J~+; , he BUi'~+ystem:mad!;l ) eBU\]?--XC:a . system , the sys~<;m regards so . chi <\] io ~! < ~ as ~: , two-:el , eme ~ , wo : rd , tl ta ~ is g prefix i , ermia ~) lpart and a ~ bll . owing ?, to ; ~ te ~: ~ F\] . na , l \] > ar ~; .  3 . ' he Ib , : n ~ e , : partiS\]It = ch , dedh , i ; hedic fimtary and the I . ate . tpa:rgL <; included in the gx:~mt\] , at , ~! es . l:aLang\],AilJ , the'J . 'l . .i\]g sv~c*Yt~' . .~d dic = i , io~u~,ry is abk ; to h~ . ndle all snchidle:msw . ; the dicth )_a a , ryceAries . 
' ? heidi(~teni ~: ies which i ~ t ch ; de ,), ( nt . d ' toze : t ~ eleme ) . )g', . i such ~ u ; show ~+ . ~ ao + , only , , , bu*~+l'do , , , " caube writ ( hiasilg , are 71 , +>_dj(\[\] ,  \[~1 )  . . . . . . > I1 . o ~; ~ oltil ~ y\], adj ( .   .   .   .   . ), llt ) ~') . ~, a:t:m\], adj ( .   .   .   .   .  )  . 
: up(lSp , i \]) "++ ;> Lx , - og~m(l_y\] , , tp ( i~p * ,   . )+1)mi;~also\]~np(i~lI)2 ,  ~+)  , -\[jo:ht(l~pi , ~ p :> , ~l  ~ p ) . 
.i!'igt~ . ~ o1; i ; Sample dictios ~ ryWith ~ o , iterminal symbol aar , d\['~\]x)/~):a , : , ~ tsi ! ltlt+~r ! debodyd:i , ct > aOurl; , \[\] +!; i ; t > 0-: i .   .   .   .   .   .   . ; I , , il ~ E\[bt ~, t,\[\],E
I ; al::o,\[;\], f\[\[vdj . . . . . . . . 1, 12 i . dj , \[ I ;; l + I ; 71; t\]\] , Ei \] 71\]\]1\]\] , ,
Li.?,tq > J.~.:,\]~1?71,\[
Ehrri ; ~ l;\]o if aJ_ . '  . ),\[\], i\[\[:~tp,gp2,, . J,\[\],,\[i l(jo:i . n0~lp ; t , gp2 , ~' ~ p )) , 1:\[np , \[;l~p ~ H71;1\] , \[\]\]\]\]: l;I\]\]\]\]\]~1\]) , , \]'~ igare i2:' . L'IMI \]; 3, <; tr~lc%~l,:e ~ ansla+ted from fig . : ce ! ; 1 And figm:e 12 is the resnlt of the translation . 
IN tim case of DCG , as the idioment ~_: y such as figure 1 \] is csnaliy handled as a g ~ amma rule , the number of gramma ~ rules blcrea ~) os a , ~ . tinefl\]cieney ollanalysis process results . 1 ~ i , < . ~ preDralAeto ha , ,tdle g~aanmar cnles and dict ionary entries sepa~ :a  . tely . 
.A :; sttowll Jxt f ignre 12 , the txansla3 , or converts the Prolog progra , msi~t the dietion a . ryentry ejoin(gpl , l~fp2 , fgp ) " h , to he:thrill(~(oo:hl(igpJ . + t~p2,~p ))' . The dictionary ~ e : ~ e , mtcel ) mg * am callstim prog ~: antenclosed by pa , renthesis whel titen co/inters <(~ nc . hi ~ refil L . Ill the same way , the syn-ht ciieca ? , egoryi~t Ore dictionar yen Lries such as " rip ( ~/ pi ,  = ) " au : ec ( mverted into the \] is the titseleme : at of which is a  , category rot , mea ~ , d ? \] terest of which a , rearguments of ? he categoi'y(\[np , ~ ap ; t ,  : \ ] )  . The dictionary reference l > rog ~: amcalls the predicatte goal  ( goal ( np+I ) ~ p1 ,  . _\], X ~ Y )) to tsnch . 
a , \] bfItt,' . riteT\]tl ; Est , uctu ~ ed dictionary enables the \] , ang LAB , (; ys~em to ttail d . leidioms with . versatility\[4\] . 
We condrtcted experiments to verify the eflec ~ of optimiza--ion of \]  Y0P-  , XC claaises . We mea , sa ~ ed the time fo ~ syntau:tica : a a \] ys is of ten sample sentences  . The experimen ~ envJ - . 
~: on raeitt Jsa , s follows : ~ , J  ~ a , chine : SIDa / 260 Worksta + tion ~ P , : olog:@fint ~ tsPm logRelease 1 . 6 o(', . raommar : 1($3l : nles in XGSInlie , expezim . elit , we me as m : edf , he time leq0i~ed too h = ta , h  ~ aipa , setreebe\[ore and a Jiertile optimiz ~ tio~tIbm : each 
No . I'Number Numler of Words of Trees 11   14   9   21   4   \]2   31   3   7   41   1   10   5J   3   11   61   4   18   71   9   21 i 81   2   19   91   4   17   10 I 1   25   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . I .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
time using interpretive code
Analysis Time\[msec\]l % ~ tioI ( 1 ) DUB-X ( \]  ( 2 ) LangLAB_ ( 1 ) / ( 2_~ )  ! 80 , 415 8 , 552 18 , 868 2 , 700 46 , 700 4 , 983 30 , 900 3 , 600 39 , 634 4 , 050 95 , 933 9 , 550 323 , 167 26 , 183 87 , 550 9 , 349 180 , 300 15 , 816 116 , 284 12 , 083 average 9 . 401 6 . 99I 9 . 37 I 8 . 58I 9 . 791 10 . 05I 12 . 34I 9 . 36I 11 . 40I 9 . 62 I 9 . 691  .   .   .   . '_\]?-~!,! e_ . 2: An aJ_ys is time using compiled code
No . Number Number I of Words of Trees I 1   14   91   2   4   121   3   3   71   4 l 101   5   3   11 I 6   4   181   7   9   211   8   2   191   9   4   171   10   1   251 
Analysis Time\[m~ee\]B . atio(1) BUP--XG(2) LangLAB 20 , 485 4 , 134 2 , 467 1 , 299 4 , 783 2 , 284 2 , 884 1 , 566 4 , 383 1 , 917 18 , 768 4 , 500 127 , 400 14 , 000 13 , 450 4 , 450 59 , 468 8 , 216 23 , 650 5 , 801 average (1)/(~) 4 . 96 1 . 90 2 . 09 1 . 84 2 . 29 4 . 17 9 . 10 3 . 02 7 . 24 4 . 08 4 . 07 sample sentence . '\[' his analysis does not include morphc ~ logical a ~ tulysis  . Table \] is the result of the experiment in the interpretive mode and table  2 is ' the one in the compiled mode . The fourth and the fifth column of the table is the time to analyze the sentence in the original BUP-XG system and in the LangLAB system respectively  . Time is shown in millisecond . 
Results showed that in comparison to the original BUP-XG system  , the analysis pedup 10 times in the interpretive mode and 4 times in the compiled mode . The optimization is less effective in the compiled mode than in the interpretive mode  . I\[o wever , this optimization is practical because debugging is usually done in the interpretive mode  . We believe that LangLAB has the capacity for practical use  . 
'\]' here is a related workSAX\[6\] by Matsumoto . SAX is also a parsing system based on logic programming  , but its parsing strategy is bottom-up and breadth -first  . Okunishi of ICOT reports that LangLAB is 6  ~  d0 times faster than SAX in the intm'pretive mode . However , in the compiled mode , SAX is 6~-16 times faster than LangLAB\[11\] . SAX has still yet to be modified to handle idioms  . If this modification is introduced , debugging can be done on LangLAB in the interpretive mode and the debugged grammar can be executed on SAX in the compiled mode  . 
5C " oonchlmon
We have made the following modification to the original 
BUI ) -XG : ? AdoptedTItIE structure dictionary With these modifications  , the analysis pedup in comparison to the original BUP-XG system and fiexible idiom handling became possible  . We believe that LangLAB has become a more powerful and practical tool for naturalan-guage processing  . We plan to develop a natural anguage processing system which include semantic analysis  , based on LangLAB . 
References\[1\]A . V . Aho , J . E . Hopcroft , and J . D . Ulhnan . Data Structures and Algorithms . Addison-Wesley , i983 . 
\[2\]A . Colmerauer Metamor phosis grammar , in Natural Language Communication with Computers , pages 133-190 , Springer-Veflag ,  1978 . 
\[3\]G . Gazdar and A . F . Pullum . Generalized Phrase Structure Grammar : A Theoretical Synopsis  . Indiana
University Linguistics Club , 1982.
\[4\] M . Gross . Lexicon-grammar : the representation of compound words  . In COLING'86, pages 16, 1986 . 
\[5\]S . Konno and H . Tanaka . Processing left-extraposition in bottom up parsing system  . Computer Software , 3(2):115-125, 1986 . ( in Japanese) . 
\[6\]Y . Matsumoto and It . Sugimura . A parsing system based on logic programming . In IJCA\['87, pages 671-674, 1987 . 
\[7\] M . McCord . Naturalanguage processing mprolog . In Adrian Walker , editor , Knowledge Systems and Prolog , chapter 5 , pages 291-402 , Addison-Wesley ,  1987 . 
\[8\]F . Pereira . Extraposition grammar . American Journalo \] Computational Linguistics ,  7(4):243-256 ,  1981 . 
\[9\]F . Pereira and D . Warren . Definite clause grammar for language analysis - a survey of the formalism and a comparison with augmented transition et works  . Artificial
Intelligence , 13(3):231-278, 1980.
\[10\]J . it . Ross . Constraints on variables in syntax . In On Noam Chomsky : Critical Essays , Anchor Books ,  1974 . 
\[11\]T . Oknuishi , et . al . Comparison of logic programming based natural anguage parsing systems  . In ~ nd Inter . 
national Workshop on Natural Language  nderstanding and Logic Programming  , pages 90-102 ,  1987 . 
\[!2\]T . Winograd . Language as a Cognitive Process . Vo Lume 1: Syntax , Addison-Wesley , 1983 . 
\[13\]W . A . Woods . Experimental parsing system for transl . 
tion network grammar . In Natural Language Process?ing , Algorithmic Press ,  1971 . 
\[14\]Y . Matsumoto , et . al . Bup : a bottom-up arser embedded in I~o log . New Generation Computing , 1(2):145-158, 1983 . 
