Modularizing Contexted Constraints
John Griffith *
Seminar fiir Sprachwissenschaft
Universitgt ' Fiibingen
K 1. Wilhehn str . 113,
D-72074 Tiibingen , Germany


This paper describes an lethod for compiling a constraint-based grammar into a potentially in or e efficient form for processing  . This method takes dependent disjunctions within a constraint formula and factors them into non -interacting groups whenever possibh  ; by determining their independence . When a group of dependent disjunctions is split into slnaller groups  , an exponential amount of redundant information is reduced  . At runtime , this ineans that all exponential alnount of processing can be saved as well  . Since the performance of an algorithm ibr processing constraints with dependent dis -jmmtions is highly deterxnined by its input  , the transformatioll presented in this paper should prove beneficial for all such algorithms  . 
1 Introduction
There are two facts that conspire to make tile treatment of disjunction an important consideration when building a natural language processing  ( NLP ) system . The first fact is that natural languages are full of ambiguities  , and in a grammar many of these ambiguities are described by disjunctions  . The second fact is that the introduction of disjmmtion into a grammar causes processing tilne to increase exponentially in the number of disjunets  . This means that a nearly linear-time operation , such a suififieation of Imrely conjunctive feature structures  , becomes an exponential-time problem as soon as disjunctions are included  , tSince disjunction is unlikely to dis-*This work was sponsored by Teil projekt  B4 " t ~? om Constraints to Rules : Compilation of lipS  (  ; " of the Sonder for se hungs be reie h 340 of the Deutsche Forsehungsgemeinschaft . I would also like to thank Dale Gerdemann and Guido Minnen for help fltl comments on the ideas presented here  . All remaining errors are of course my own . 
t Assuming P#NIL appear from natur ~ fl language graln lnars  , controlling its form ( : all save exponential amounts of time . 
This paper introduces all etficient normal tbrm for processing dependent disjunctive constraints and an operation for compilation into this normal form  . This ot ) eration , modularization , can reduce exponential alnounts of redtmdant information in a grain mar and can consequently save corresponding alnounts of processing time  . While this operation is general enough to be applied to a wide variety of constraint systems  , it ; was originally designed to optimize processing of dependent disjunctions in featm'e structure-based grammars  . In particular , modular fea . tuie structures are more eflicient R ) runification than non-I nodulm ' ones . 
Since ill many current NLP systems , a signiti-cant amount of tilne is spent performing unification  , optimizing feature structures for unill catiol l shouhlincrease the tmrt brmance of these  , syst ; ems . 
Many algorithms foretticient mfitication of lea t are structures with dependent disjunctions have been propose  . d ( Maxwell and Kaplan , 1989; F , isele and DSrre , 1990; Gerdemann , 1991; Str SmbSek , 1992; Griflith ,  1 . 996) . However , all of these algorithms sutfer from a common problem : thc  . ir performance is highly deternfined by their inputs  . 
All of these algorithms will perform at their best when their dependent disjunctions interact as little as possible  , but if all of the disjunctions interact , then these algorithms may perform redundant computations  . The need for ef\[icient inputs has been noted in the literature  2 but there have been few attempts to automatically optilnize gr  ; mnnarstor disjunetiw ; unification algorithms . 
The modularization algorithm presented in this paper takes existing dependent disjunctions and splits them into independent groups by deterln in -ing which disjunctions really interact  . In delen-dent groups of disjunctions can be processed sepa-rat  ; ely during unification rathe , r than having to try every combination of one group with every combination of every other group  . 
This pat ) er is organized as follows : Section 2 gives an informal introduction to dependent dis- ~ Cf  . ( Maxwell and Kaplan , \]991) fl ) rinstance . 
448 juncl ; ions and shows how r ( , ctundani ; int (; racl li(lnslml , w( ; engroups of ( tisju:n(:l ; ions (: mibcr ( ; du(:ed . 
S( ; c:i ; ion 3 shows how normal disjunctions c ; mt ) ( ; r ( ; l)lac( ; d t ) y (: on t , cxtx ; d constrainl:s . S ( , (: tion4t ; hcn , <d  ~ ow showt , hcs (' ~ cont(;xl ; (' , d (' , on straints can en-cod( , del ) (' , nd(;ni , disjunctions . S(!(:l;i on 51) r(!s(' , nts themo ( hllm ' ization a , lgorii ; hmforconlx ~ xi;ed(' , on- . 
si;ra . ini ; s . I h ) we ver , e , ven though this algorl ; hmist ~(; omt ) ih > t , im (' , ot ) (; ralJ(m , it itself has (; xt ) on ( nitial comt ) lexity , solilil , l(ing it IllOl(' , ( ~ tli (' , i(mi ; should ~ Jso1)(;a(:onc : ( , rn . Ai ; h(~or (; m will l , hc , Ii \])( ; i ) r(~s(mix ; dillS('x'J ; iOll(it\]mLt ) ( ! rllli ( ; s ; I , li (' , xt ) olt (! tll ; i alt ) & rt ; ()\[ i , tl(;nm(hllarizal;ionalgo\]'il , hmI ; ( ) I ) crct ) l ; t(:(' , ( l1W combinatorial aam . lysis . 
2Dependent disjunctions l ) (: l ) enchull ; disjuncl ; ions are lik ('\] u )\] maid is . iun(:--donscxc ', c ; 1) tdial ; (; very(l is . iun(:l ; ion has an an L(' , midl ; h ( ; disjuncts of disjuimti(mswii ; htim sam (: Illl Ill ( ~ I llltSt ;  )( ; ch()s(~llillSyllC . FoF ( ~ xmnt ) l(' .   ,  (< , g , , d / , (//') A(<t ' , ? ,  ~/)' , ~//') is a(: , , ni . n , : i:io , ~  , ) ri:wodcl)cn(hmtdisjml(:donswithtims . ~/ lil(;lt~l \ [ l(, . , (/ . 
Wtl ; l , l ; thism (' . ; msixllha . l ; if l , h(' , s(;('oml(lisjun(:l:in1;ho , til'sl ; ( t is . iul ~ (: tion ,  (// , ix (: hoscn , lJicnl ; h(~s (!(> ond dis . jun(:t , ofth(;()th(;rdisjun(:llion ,  '~// , In llsl ; t )(; chos(mas well . ( Not ( ; thai ; wilful ; kind ( if con-sLrainl ; sthe?/)sa . n(I'l/~s are ix not iml ) or tmfl ; here . )' Fh (' ,  (' , o Illl ) lll ; &/; iOll & ll'e;/ , soll\[()1llSill , ; ( h~t )( , ,u(hml ; ( lis . iun(' . i ; ionsovc , rnorma,\](tisjunc ' . tion sixt ; hal ; ( h > l )( ; n(lc nl ; disjun(:donsMlow for more (: Oral ) a ( ; 1 , a . nd(dlici(;nl ; tllCi;/ll(~ . s . ' Fhisisl ) mdcularly lain ( ; wh cli(h ; 1)cn(l( ; nl ; ( lisjunc:l ; ious arc (' , lnl ) (! d(hxtiusi(h ; of\[ea , l , urcsl ; rutJl ; llr(;s . This is\[let ', raise inl ; li ; tl , c . as o(lisjlln(:l;i(insCl , lllickepthi (' a , lillit dirc ; (: l ; (' dgl'ltlihSl , \]' llCI ; lll'(1t ; hllSs:4 Villlrl : ( xhut(la . nl;\['(;; tl;ureI);~l ; lis . 
Wcslty I ; tia A ; disjuncl ; ions with l ; \] i ( ; sani ( ; name ' , arc inl ; h(;s a , mcg'ro'u , p . Oltc(lisl ; inguishing fea-1;ll r(~of a , group of ( lisj un('donsixi ; tl&l ;  ( ; ~( ; 1 dis-jun ( ; t ; ionlnusi ; ha , v(~timstun(' , numl ) (' , r of dis-junclis . This is ( ; sscntially who ! re!r(xlun(lalitint , cr-a(' , l ; ions origina , l ; (' , , l " or inslia , lL(m ~ in(<l(l ) > ( lJ , ( I/ , qi ) ') A ( , 1 '~1~ ,  '~// ,  '~/~ , ' ~//)(; ac:hdisjun(:ti()n hasfour(tisjun(' , ts , \[)111;r (; allyOll\]yl;WO values . Bul ; 11 ( ) I'(~, iml ) O\]'-l ; ; ~ . nl ; ly , nonla . l ; l ; (; r whal ; wahl ( , , of l , h0 lirsl ; (lisjun(>lionix (: hos(m ( (/) or ell ) t ; hc ; sallle v ~- I , lll(~Sa , l(;t ) (3 s - . 
sibh ; fori ; h(*, s(;(', on (1(9 or ' l //) . hiol ; hcr words , thos('disjunctions at ( ; a (: tually in d ( ; p(mdcnt from one ; anol ; hcr , and Cant ) 0 , put into ( lifl'er (' , nl ; groups : ( d '+ , ?') A(d ""/2 ,  +') . This is th (: In OC(;Ss , ) t , nod-ulmiz ~ tl ; i on which will b ( ; for in a , lized in s(;c ; l;i on 5 . 
Onemi < ghl ; t ) cl ; ( mll ) tc(ltol ; hink thal ; ul ( ) ( lulm '- izg-t , ; i o n i x l l l n C C C S S ~ l , l ' ysiIl(;(~~I'3 , Il IIl ILI wril ; (; rs ~-/ , 1"( ~ unlikely to writ (' . ( h ; t ) end c ; nt ; disjunctions which (' , ontain i i l d ( ~ , l)cm(tcn(;parts . I h :) w (' v(~r , gramma , r writer sm ; ~ y not b ( ;  ( ; hi ; only sotlr ( ; (! o\[(\[( ; \[)( ; n(l ( ; if l , disjunc : tions . Mmiygrajmnarl ) ro(:( ; ssing sysi ; ( ; ms use high-level dose:tit)lions whic:harc I ; hcn trans-form ( ; d into ltt Or ( ; cxt ) lic : il ; \[ ow(~l'-hw ( ; 1grmmnars . 
This trims Jbrmatio Il proc : c ; ssmay very w(' . llin-l ; rodu(;(; large ': tlllly )(; l' , <-; of dc ; t)en(h ; nl ; disjunctions with (; ? a(:l , ly this t ) rol )(; r l , y . 
() IIC ('? alnt ) l(~of who ; r ( ; this can ha , l)l )(; n is in the ; (' x mipilm ; iono1'h;xi(:a , 1 ruh ' , sin(Mcmr('rs and Mimmn ,  1995) . In thist ) apc ! r , M(mr(nsmMMinn(;n(t('s(:rib(~a(:omt)ih , whic : hf , rmml~m ; sa . s( , t of LIPS(;h;xi (: alruh ; saimth(;i rint(;ra , l : d ( ) n into(h ; l-init ; er(Jationsusc , d1 , o constrainh'xical(~niai(~s . 
In ( Mem(us and Mimmn , 199 ( i ) , th('y show hownnoil'-lin(;COml ) ila , tionte(:hniqu(;(:a , lh ~ d constraint l ) roi ) a , gation can I ) eus ( ; d to inll ) rov ( ; tim(leNnit(~c:la , us ('( ; nc : ( ) cting produ ( : ( ; d1) yl ; heir (: Oml ) ih , t ( ) a , 1-h)wform()r(~(dti(:i(~nl ; t)ro(:('ssing . Tim use o\[ ( h'i ron ( hint disjunctions t ) rovid (  ,  . smla . l;tr;~(:dv(~dLer-\]mlJv(~1; oI ; tm (: olisl , rainl , t)\]op ; ~ gal;ion ~ q ) l ) roa(:h1)3 , s t )(; (' . if ying all t ; h ( ; information associ ; ~lxxl with ah'xi (: al ( ; nl , rydir (; c : dy as a singh ' , ( h't )( ; nd( ; nl ; f(!ml ; llresI ; r/I (: LIII'( ; r&l ; h( ; rth ; tn hidd(mina set ; of ( h~ti-nii ; e(:la . us ( ; s . : ~ C'onsid c . r the AheMlmh ) w : PIt()N ~ ll , d . . . . . . lielnu ,, lleht , li,d,I  i . d
VI , '( ) I(MI)se , hse , finIlilt  d . % Ull . I\[-/I~vn , '() aM ~ , . , , , ' lichen
Lau(~I ' " II\[VI , '() ILM hsE(\[11\[VI , '() IMI!he\]i ,  . \]J>)'(\[(X)N'r ) '() This comph' . x lexicMentry rels rcs ( ; nl ; s the ha . so lexical enlayfl ) rt ; ll (' . Gcrnmn verb lichen , " to love " , mMtimt ; hreelcxical c ! ntricsl ; haA ; (: all 1) 0 . derived from il ; giventh(!lcxi (: ~ druh ; sprc sc ; nl ; c , xlin ( Me . ur-ers and Mimmn , \]99(i ) . Tho difl '(; renc : estml , wc'x;ni ; hese h~xi (: M(miaic ; sarc ( , nc:oded1) yth(;(h~pc' , nch ; nl ; disjunctions all o1"which a , rcinth(~ . ~mncgr(ml ), d . The first (\[ i ~ llll(;l ; illc & ch(tisjun(;l , ioll ( : () rr(~-Sill ) nitstol ; tmb ; ts ( ; t ' Oll n ~( ; hi ; S ( ; ( ; () II(I (: or r('st)c)n(lstotheal)pli(:~l ; ion of l ; lmCompl('mc ; ntF , xtracl ; ic ) ul , exic Mlhtl (; , the third corrc'sl ) onds to the al ) pli-cation of the Finitivization L (  ; xicall tuh ;  , mid I ; he last COrlTo , s1) oIl(lsl;oL heapt ) lication of t ) ol ; hrltles . '1 Modulariz ~ tion can l ) eilSc . ( lt ; oil clak ( ; this t'('~tur(~sl ; ructur ( ; ( wen more ( dlichuit byst ) litl ; ing all ( ; gro/ipd into two new gt ' ( ) llpSdla , nd(12 as show ulmlow . 
aln I ; he case of infinite h;xica , detinit c clauses arc . 
still necc . ss ; try to encode recursive informal ; ion . 
4q'ht' , selexical rules air ( ! simplitied versions of those presented in ( Polb ~ rd~md Sag ,  \]994) . 

PIION ~ lleben , liebt/\[dl
VFORM ~ bse , fill
I , el
SUBJ\[\]frVFORMbse\]\] ) \[ lieben-\]\[AaG~2t!\]\]rv , ,'OaMbsol  s ,   ,   ,   , s ,   ,   d2 Another example of where modularization might prove useful is in the treatment of typed feature structures presented in  ( Gerdemann and King ,  1994) . Their approach produces a set of feature structures from a satisfiability algorithm such that all of the feature structures have the same shape but the nodes may be labeled by different types  . They then collapse this set down to a single feature structure where nodes are labeled with dependent disjunctions of types  . Many of the groups of disjunctions in their feature structures can be made more efficient via modularization  . 
A final example is in the compaction algorithm for feature structures  , presented in ( Grigith ,  1995) . Compaction is another operation designed to optimize feature structures for unification  . It takes a disjunction of feature structures , transforms them into a single feature structure with dependent disjunctions  , and then pushes the disjunctions down in the structure as far as possible  . 
The result is a large number of dependent disjunctions in the same group  . Many of these can probably be split into new independent groups  . 
3 Contexted constraints
Maxwell and Kaplan ( 1989 ) showed how a disjunction of constraints could be replaced by an equi-satisfiable conjunction of contexted constraints as in lemma  1 below .  5
Lemma 1 ( Contexted Constraints ) ?1V?2 is satisfialtle if \] ( t )  -+ ?1 ) A ( ~ --4 ?2 ) is satisfiable , where p is a new propositional variable . 
Disjunctions are replaced by conjunctions of implications from contexts  ( propositional formulae ) to the base constraints fie . ?: t and ?2 ) -The nature of the base constraints is irrelevant as long as there is a satisfaction algorithm for them  . The key insight is that solving disjunctions of the base constraints is no longer necessary since they are purely conjunctive  . 
S For a proof see ( Maxwell and Kaplan , 1989).
Maxwell and Kaplan's goal in doing this was to have an efficient method for solving disjunctive constraints  . The goal in this paper is compil in . q disjunctive constraints into more efficient ones for fllture solution  . To this end a somewhat different notion of contexted constraint will be used as show in lemma  2  . 
Lemma 2 ( Alternative-Case Form )   ( / ) 1 V?2 is satisfiable iff ( al-4-?\] ) A ( a2~-?:~ ) A ( alVa2 ) is satisfiable , where al and a 2arc new propositional variables . 
We ( : an see that this formulation is nearly equivalent to Maxwell and Kaplan's by substituting p for at and p for  a2  . To make the formulation completely equivalent; , we would need to enforce the uniqueness of a solution by conjoining al V  g2  . 
However , this is unnecessary since we want to permit both solutions to be simultaneously true  . The reason for using the modified version of contexted constraints in lemma  2 is that we can separate the representation of disjunctions into a conjunction of the values that the disjuncts can have  , called the alternatives , and the way in which the we can choose the values  , called the cases . The alternatives are the conjunction ( al-~?1 ) A ( a2-+ ( /52 ) and the cases are the disjunction ( alVa2 )  . 
While we could use repeated applications of lemma 2 to turn a disjunction of n disjuncts into an alternative-case form  , it will simplify the expo-sition to have a more general way of doing this  , as shown in lemma 3 . 
v----I~l~ ) ma3 ( N-ary Aiternative-Case A ( ai-~?i ) AvFarm ) aiie Nissatisfiable ifficNicNiS satisfiable , where each ai is a new propositional variablA ? ( ai--~?i ) VaItereiGN are the alternatives and icN are the cases  . So for example , ?1V?2 VC a V?4 is satisfiable just in case ( at-~?1 ) A ( a2-+?2 ) A ( a3~+ q~3 ) A ( a4-~ ( ~4 ) A ( a: , Va2Va3Va4) is satisfiable . 
4 Dependent disjunctions as contexted constraints The usefulness of the alternative-case form only becomes apparent when considering dependent disjunctions  . Dependent disjunctions can be represented by alternative-cast forms as shown in definition  1 below . 
Definition 1 ( Dependency Group)
A dependency group is a conjunction of dependent disjunctions with the same name  , d , where each
V * A* ,   6ieN and ie N are disjunctions and conjunctions of formulae ? i  , respectively , where each i is a member of the set of indices , N . 
4 50 disjunction is an alternative-case form such that there is one alternative for every disjunct of every disjunction in the group  , and there is one case for each disjunct in the group which is a co * one-tion of the alternative variables for that disjunct <  . MAA ( a -~? ) VA a: i6Mj6N   AJ6NiC-M where each a is a new propositional variable and
N = L < ..., n .
Sol ; he dependent disjunction ( , l ? , 0  , ?') A(d ? , '~// ,   0' is the alternative-case form with alternatives ( aI-+0 ) A ( a ~- ~0 ) A ( a:~-+4/ ) A (  , 4 -" ? ) A ?' ) A "/" ) and eases ( ( a I Aa ~ ) V ( a ~ A a ~ ) V ( a ~ A < ) )  . The cases enforce that the corresponding disjuncts of every disjunet in the group in ust be simultaneously satisfiable  . 
We , can now start to see where redundancy in dependent disjmmtions originates  . Because , every disjunction in a group of ( lepen(le , nt disjunctions nms t have the , same n und ) er of disjuncts , some , of those disjunets may appear more , than once . In the above exmnplet : brinstance ,   5 occurs twice in the first disjunction and ~// occurs twi  ( : e in the second disjunction . To resolve this problem we impose the following condition  , called alternative compactness : if a base constraint ? equals another base constraint from the same disjunction  ,  ?\[ , , then the alternatives variables associated with those base constraints  , ( ji and a ~ , are also equal .   7 Doing this allows us to express the alternatives t  ; ' om the example above as ( d-~? ) A ( 4 -~ ?' ) A ( ~ --~ ? ) a ( a ~~?' )  , an (1 the case , ~ as (( at : Aa~t)V ( allA(t2) V (8 , 12 Aa2)) . 8 One advall-tage of this is that the number of base constraints that must be checked during satisfaction  ( : an potentially be exponentially reduced . 
' Filenexl ; section will show how an alt ; ernative-case form for a , group of det ) tn dent disjuncl ; ions can be split into a conjunction of two ( or more ) equivalent forms , thereby ( potentially ) exponentially reducing them unbtr of alternative varial  ) le interactions that must be checke during satisfac-l  ; ion ,   5 Modularization Consider againtile example from section  2:   ( d ( /5 , ( I ) ,  ?' , (/)') A(d0 , " ~ t / ,  ~1~ ,  %/)') . ie presented as a compact alternative-case form , the alternatives becomes : ( al0)A((4?')A(d' , //) , with cases : (( aIAa ~) V(alAa ~) V(a . ~ Aa ~) V(a1Aa ~)) . The key to determining that the two disjunctions ( : all be split into different rNote that this requires being able to determine equality of the base constraints  . 
S in this example , equivalent alternative variables have been replaced by representatives of their equiva-lence chess  . Soa ~ has been replaced by alanda ? a has been replaced by a  . ~ . 
groups then involves determining that cases can be split into a conjunction of two smaller cases  ( a ' , V a ~) A(a ~ V a ~) . If the cases can be split in this manner , we say the cases ( and by extension tilt group of dependent disjunctions  ) are independent . 
Definition 2 ( Independence )
A case \] or rn is independent iff it is equivalent to " j ~ N  i6M ~ j ( iN ' i6M ' Ajc N " i6M " where M ' and M " partition M . 
So in the above examph ' , , M = 1 , 2 where 1 rep-r(!sents l ; he first disjunel ; ion and 2 represents l ; he second . That makes M'=1 and M"=2 . 
While M ' and M " are derived Dora M , the ele-aleuts of the Ns are arbitrary . But a consequence of definil ; ion2 is that \[ N\[=-IN'\[x\[N"\[ . This will be proved in section 6 . The size of the N s , however , represent henmn ber of cases . So for instance in the above example , N might equal 1 , 2 , 3 , 4 since there are four disjuncts in the original ease form  , while N ' might equal 1 , 2 and N " ,  1 , 2 , since the smaller case forms each contain two disjuncts  . 
The process of splitting a group of dependent disjunctions into smallel " groups is called modularization  . Modularizing a group of dependent disjunctions amounts to finding a conjunction of ease forms that in equivalent  ; to the original ease form . The modularization algorithm consists of two main steps  . Tile first is to take the original case form and to construct a pair of possibly in-dep  ( m dentease forms from it : . The second step is to check if these (: as (' , forms are actually indepen- ( lent from each other with respect othe original one  . The modularizatioil algorithm performs both of these steps repeatedly until either apmrof in -depe  , ndentease R ) rms is found or until all possible pMrs have been checked  . If tile later , then we know that ; the original dependent disjunction in already nn ) (lulai ' . If on the ottmrh and we can split the case forms into a pair of smaller  , independent (; as (; for lns , then we can again try to modularize each of those  , until all groups are modular . 
'\[ b const ; ruct a pair of potentially independent (: as ( ; forms , we first need to partition the set of alternative vm ' i ablts from the original ca  , qe form into two sets . The first , subset contains all of and only the , variables corresponding to some subset of the original disjunctions and tile second subset of variables is the complement of the first  , corresponding to all of and only the other disjunctions  . 
lh ' om these subsets of variables , we construct two new cast forms D or a the original using the opera-tion of confinement  , defined below . 
Definitjop , A3 ( Confine Inent)
V/\ a ~
COII , f(jc  NiEM , J ~/ I t ) is the confinement of JCNiGM with respectoa 4 Vka ; iff co~tf(JCN i < M , M ') =- dnf(JCNi~M ') , where . M ' CM . 
Constructing the e ontinement of a (: as ( ; form is essentially just throwing out all of the alternative variables that are not in M '  . However , only doing this might leave us with duplicate disjuncts  , so converting the result to DNF removes any such duplicates  . 
To make the definition of confinement clearer , consider tile following conjunction of dependent disjunctions :  ( d ? ,  0 ,  ? ,  (/) ,  ?' , ~//) A(d ~/% ~// , t / , ,  , // , ~/ o , t //) A((~x , x , x ' , x ' , x ' , x ' . 
This is equivalent totile compact alternative fo rIn :  9   ( a ~-' , ?') A(a ~--~ x)A(d+x') , and tile following case for nl : ease . = (( elAa ~/ ,,*9 v(alA~4A a'0, V(4A . ,2 A d ) v ( 4 Aa ~ Ad ) v ( 4 A ( qAai ~ ) V ( (4 A a ~ A d ) ) ' Now we can compute the confinements . For instance 1eon f(case ,  1 , 2) = dnf((aIAa ~) V(aIAa , ~) V(alA(q)v(o'Aa , 9 v ( (4 Ad ) v (4 Ad)) , \]
After removing duplicates we get : . , , ?(( , as e ,  ~ , 2)-((4AabV(o*A"9V(4Aa ~) V(4A a , 9)'1 Likewise , for the c()mtflement of M ' with respect to M , we get : conf(case , 3): (( aa)V ( ai ~)) . 
Now we just need to test whether two confined case ibrms are independent with respect to the original  . This is done with the free combination operation , shown in definition 4 . 
Definition 4 ( \] ~ ? ee Combination ? ) The free combination of two ease forms is the disjunctive ' normal form of their conjunction : case ' ? case "-- dnf  ( case ' A case " ) The two ease forms , case ' and case " , are I ) NF for-mulct . ~ ib compute the free combination , we conjoin them and convert there . suit back into DNF . 
They are independence if their free combination is equal to the originale a set brm  , case . 
For example , the flee combination of the two confinements from above  , (( aIAa , 2) V(a * , aa , ~) V(a ~ Aa ~) V(a ~ Aa ~)) and (( d ) v0 , 9 ) is ( ra'Aa ~ A4 ) V ( el A4 A4 ) V ( aI / , a ~ Ad)V\\](4A a . ~ A4*) v(4A , qAd ) v(4A a ~/ , d ) V ( a ~ AdAd ) v ( a ~ A a ~ A d )   ) 9 in this examl ) le , equivalent alternative variables have a gain been replaced by represent at  , ives of their equivalence class . Sotbrinstance . , a ~, c * ~ and a ~ are all represented by al . 
which is not equMt ; othe original (: as ( . ' form : (( el Aa ~ Aa ~) V(a ' , A , ~ , ~ A4') V(4AdA , , i\] ) v ( alAa ~ A all ) v ( dAa ~ Ad ) v04 Ad Aaq ) ) , sotim first two disjunctions are not in det ) en-dent from the third . However , the second dis-jmmtion is independe . nt front the first and the third since , conf(case , 2)-((a ~) V(a . ~)), antico , ?( ca . ~ e ,  1 , 3) ( q , ''~'~'": t , A a , ) V (% A ai , ) V(asAa!i )) , and their free combination is equal to the oi'igi -nal case form  . Therefore , the original formula is equivalent o(d ' ~/ a , * //) A(d , , ? ,  ? , ?') A(d , , X , X ' , Z ') . 
6 Free combination elimination
The last section showed all efl'ective algoritln n for modularizing groups of dependent disjunet  ; iolls . 
However , even d lough this is a compile time algorithm we should be con  ( : erned about its efliociency since it has ext ) onential comph ; xity . The main source of complexity is that weinight have to check  (  ; very pair of sul ) sets of disjun ( : tions fl ' o in the group . Ill the worst case this is tnmvoidable ( elothough we do not expect natural language grain-mars to exhibit such behavior  )  . Other sources of comi ) lexity are computing the fl'ee coin binadon and testing the result against the original  ( : as (  ; form . l , uckily it is possible to avoid both of these operations  . This Ceilt ) ed one by noting that both the original ( : a seform a im each of the ( : on fine t ( : as (  ; forms are in DNF . Therefore it ; is a nee- . 
essary (: ondition ttatifl ; hefl ' ee combination of the confinements is the same as the original case form then the I  ) roduet of tile number of disjun ( ' tsi , , ea(:h conflneme . t , lease'lx lease " l , re , steq , lalthe number of disjun ( : ts in the original case form , lease I . Moreover , since both confinements at ( ; derived fl ' om the original ease form , it is also a sufficient , condition . This is shown more for lnally in theorem 1 . 
Theorem 1 ( l ~ Yee combination elimination ) ~ . ' , ~se = ~: as , /Oease "?=>\] case\]=ba~e'l?I case " lProof = :> We assulne that case ' ? case "=- case  . 
Since hoth case '? e as #' and ease are in DNF and DNI  ; is unique , we know that \](: as (' . '? case "\] =: lease\] . We also know that case ' and case " have no disjunets in common because they have no alternative variables in coln mon  , so I casc'?case " l = I case'lxI casc . " l . Therefore . le~s4 = I casc'lxkase "\] . UP roof < -- Again since case ' arm case " have no disjuncts in corm non  , we know that leas#@case "\] =\] case'\]x I case "\] and therefore  , that lease I--lease ' ? co , s t "\] . Every disjunct in case can be represented as A ' AA " where A ' is a disjnnet in case ' and A " is a disjun  ( : till case " . So the dis- . iunetsinease'@case " must be every conjunction of possible A's and A"s  . So case'?case " must contain ev < mm <) re ,  ) , itf , h<m+>case ~ ~ case " must (: ontain cxacl ; ly the disjuncl ; sill cas (: a Ildl ; hcrcfor c(:as(t::(:o , ,~('J (29 (:( ts (:' . E \] We can see that this would have hell > edus inth  ( ' . 
p,'cvi <, us <`- x~t ~,, p > t ; <) k ~, <, w m~t .  <:<,,,/(,,<,, . ~( , , 1 , 2) (: ( lll(l110;)('~il , (( , t)(!II(l(!llJ;\['1'()1\[1C()ILf(c(t , '~C , 3) wit ; h respect to c < , , , sc , t > eca . use ):,, ( f(ca , sc , 1, 2) ! 8 . () on vcrscly , sin(:(`-Ico'/~f(ca . s ' c ,  \[ , 3) I3 and\[conf(casc ,  2)1 : 2 , we , knowimm ( , Jia . l ; elyl ; hatl ; hcs('~(:as(' , forms are in ( h`-t)c'nd(mt . 
This the , or em also allows us to trot form other comt ) in at , orial shortcuts , su <' has noting that if t ; hen unltmr of disjuncl ; s in the origim tl case to rm is prime \[ ; henit ; is already modular . 
7 Conclusion '\[' his paper has\[ ) r ( '~s<!nt ( xlan ( fllici ( mt form for r ( ' , l)r(;s(ml;ing(lc , p(!ll(h ; nl , dis , jun(:t;i(>nsm ~ ( ian algo-rithmford(`-I ; ( x ; l , ingaim (; liminal ; ingr ( , ,dmt ( tmitn : teractions within a group of <\[ ( ~ l ) (m ( hmtdisjmm-l ; i < ms . This mc , l ; h <) < l shoul < l be useful for a . ,y sys-( ; era which ( mq ) l< ) ys < let ) endent < lisjun ( : tions in <: e , it , can(`-liminai ; e exponen l ; i alam(mnt ; sofi ) ro < : (~ ssh~g during (: onstra . inl ; sadsi\]mtion . 
In Conslraint I ' ropagatio'n , Linguistic Dcsc ~ ip-tion , a ' nd Computation , \[ stitutol ) alh ' , Molle II ) -
SIA , Lugano , Switzerlan<t.
Meurers , i ) . and G . Minnen .  1995 . A@olni)u-t ; al ; ional Trcat ; nmnt ; of\[ll'S(lI , exi <: allules as Covm ' ial ; ion in Lexi (: all , ; ntries . Inl)r'oc , of I , h,<:5th , Int . Workshop o'n Nal , ' wrrd Lang'uo , 9< ~ U'nd cr-standing a , ndLogicl ~ r'og'ra'mming . 
M < mr(!rs , 1) . ml(IG . Mimmn . 199 ( i . () It'-liue Con-sl , ra . in l;I ) r <) l ) agat ; ion for l , ;\[ li('i(`-zzI , III'S(II)I'O(;(~SS-ing . h\[l'roc,ofIII'S(I/TAI,N-06 . 
I > ollm'd , C . midi\[ . Sag .  :1994 . H cad-driv c . n Phra , scStruct'u , rcG ' rummar . U . (> t ! Chi (: ago Press . 
StrSml ) ~ i(:k,L .  1992 . Uni\[~gingDisjun(:l ; ivel " eal ; ur ( ; Sl ; ru<:i ; ures . \[ nCOl,IN (',\[992, 1) a . ges1:167 11171 . 

Eiseh `-, A . and J . D 6 r r e .  1990 . Unification of Disjunctiv <`- Feature De , s(:ril)tionsIBM Wis-sens<:haft li<:hcsZcntrnm , \[ nstitul ; (' , fiirWiss(`-ns:basi(;rt <: , qysl ; t ' . In <`- l;(`-(;h,l'Cl ) <> r\[;]2+l . 
(; (; r < lemann , I) .  1991 . Parsing and Genc'ration of Unification Cramma'rs , PM ) thesis , U . (> f

( ~ el'<lemaml , D . and 1) . King 1 . (t94 . The () or-re <:/ ; an < lEilh:ient ; hnt ) lemealt : ation of Apl > ri-a . teness Specifications for Typed Feature Structures In COLING  1994  , pages 956960 . 
Griflith , J .  1995 . Optimizing F cat ; nreSt ; ru <: turc Uniticat , ion widt l ) ependent l ) is juncl ; ions , in l ' apcrs presented al , th . cW ( rrkshop on ( h'am-ma , ' rli'ormaliwm , fl ) rNLP at E , qAT , LI:-9/I . U . 
Tiibinge . n , S('minm'fiirStn'achwisse,nscha . fl ; tech . 
rel ) or t04415.
Gritlith , J .  1996 . Disjur ~ , ction and EJ\]icic'n , tP ' lv-tossing of Feature Struct'u , ' rcs . 1) hi)th(!sis,Uni-versitStT/ibingen . Tentative tide . 
Maxwell , J . and I . . Kat)lan .  1 . (t89 . An Overview of l ) i % iuncl ; iw ' . C < m straintSadsfact ; ion . In \]" me . of lnl . Workshop on 1) a'rsi'n , g Technologies , pages 1827 . 
Ma . xw <`- ll , 3 . and 1 . Kaplan .  1991 . Th(!lnt('xfa(:(!1)(!l;w(' , (mPhrasalmt < lFunct ; ional Consl ; ra , ints . 

