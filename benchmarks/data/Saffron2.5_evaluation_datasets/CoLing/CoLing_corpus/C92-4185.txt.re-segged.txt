UNIFYING DISJUNCTIVE FEATUREST RUCTURES
LENAS'F ROMBACK
Deparlment of Coinputer , and htforntatiol ~ Science
Link 0 ping University
S-58183 Link Oping , Sweden
Telephone + 461 328 2676
elnail : lcsti(Wida , liu.se
Abstract
This paper describes an algorithm for unifying disjunctive feature structnres  . Unlike previous algorithms , except Eisele & l ) 6n'e (1990) , this algorithm is as fast as an algorithm with ont disjunction when disjunctions do not participate in the unification  , it is also as fast as an algorithm handling only local disjunctions when there are only local disjunctions  , and expensive only in tile case of unifying fnll disjunction  . The description is given in the fiame work of graph unification algoritbnls which ulakes it easy to implement as an extension of such an algorithm  . 
1 Introduction
Disjunction is all important extension to feature structure languages since it increases the compact-uess of the descriptions  . Themmn problem with including disjunction in tile structures is that the unification operation becomes NP-complete  . The re-lore there have been many proposals on how to uni-fy disjunctive feature structures  , the most important being Karttunen's ( 1984 ) unification with constraints , Kasper's ( 1987 ) unification by successive approximation , Eisele & D 0 rru's ( 1988 ) value unification and lately Eisele & D0 rre's ( 1990a , b ) unification with named disjunctions . Since Kasper's and Eisele & D0rre's algorithm seem to be more general and efficient han Kart tunen's algorithm I will restrict my discussion to them  . 
hi Kasper's algorithin the structures to be unified are divided into two parts  , one that does not contain any disjunctions and one that is a conjunction of all disjunctions in the structure  . Tile idea is to unify the non-disjunctive parts first and then unify the result with the disjunctions  , thus trying to exclude as many alternatives as possible  . The last step is to compare all disjunctions with each other  , making it possible to discard further alternatives  . At is this comparison that is expensive . The algorithm is always expensive for disjunctions  , regardless of whether they coutain path equivalences or not and independent of whether they are affected by the unification or not  . This is due to the representation , where all disjunctions are moved to the toplevel of the strncture  , which means that larger parts of the structures are moved into the disjunctions and must be compared by the algorithm  . Carter ( 1990 ) has made a development of this algorithm which improves the efficiency when nsed together with bottom-uparsing  . 
Eisele & D01 Te'S ( 1988 ) approach is based on the fact that unification of path equivalences should return uot only a local value  , but also a global value that affects some other part of the struetm'e  . Their solution is to compute t be local value and save tile global value a ~ sa global Jesu it  . The global results will be unified with the result of the first unification  . 
This new unification can also generate a new global disjunction so that the unification with global results will be repeated until no new global result is generated  . This solution generates at least one , but otten more than one , exU annification for each path equivalence . Thus , tile algorithm is always expensive for path equivalences  , regardless of whether they are contained inside disjunct to us or not  . 
T be approach taken by Eisele & D 0 rre ( 1990 ) is similar to file approach taken in tills paper . They use'nmned disjunction ' ( Kaplan & Maxwell 1989 ) and one of their central ideas i . e . to use a disjunction as the value of a variable to decide when the value is dependent on the choice in some disjunction is simi-itu " to the way of unifying variables in the present paper  , l to wev cr , they use feature terms for repre-set mug the structures and their algorithm is described by a set of rewrite rule slot feature terms  . 
This makes the algorithm different from algorittuns described for graph unification  . 
What is special with the algorithm in the present paper is filatitis  1  . As efficient as au algorithm not handling disjunction wlleu the participating structures do not contain any disjuuclions  . 
2 . As efficient as an algorithm allowing only local disjunctions when the participating structures only contain such disjunction  . 
3 . Expensive only when nonlocal disjunction is involved  . 
The description is given in a way that makes the algorithin easy to implement as an extensron of a graph unification algorithm  . 
2 The Formulas
Feature structures are represented by for nlul as . The syntax of the formulas , especially the way of constructing complex graphs  , is chosen so as to get a close relation to features t ~ uctmes  . This also makes it easy to construct a unification procedures ~ milar to ACTESDE  COLING-92  , NANTES . 2328 AOt '; r19921167 PROC . O1: COLING-92 . NANTES , AUG .  2328 ,   1992 graph unification and give the formulas a semantics based on graph models  . For disjunction a generalization of Kaplan & Maxwell's  ( 1989 ) ' named dis-junction ' is used . Their idea is to give the disjunctions names so that it is possible to restrict the choices in them  . Kaplan and Max well use only binary disjunctions , and if the left alternative in one disjunction is chosen the left alternative in all disjunctions with the same name has to be chosen  . In this paper I do not restric the algorithm to binary disjunctions  . Instead of giving the disjunction a name I give each alternative a name  . Alternatives with the same name are then connected so that if one of them is chosen we also have to choose all the others  . 
We assume four basic sets A , F , X and E of atoms , feature attributes , variables and disjunction switches respectively . These sets contain symbols denoted by strings . They are all assumed to be enumerable and pmrwise disjoint  . From these basic sets we define the set S of feature structures  . S contains the following structures : ? T : no information ?  . L : failure ? a for all a EA : atoms ? x for all xEX : variables ?\[ ft:sl  . . . . . f n : s n \] for any f iEF , siES , n > 0 such that fr-~fori~j : complex feature slructure ? ot : Sl  ,   .   .   .   , On : SnfOranyoiE)2 , siES , n20 such that of , -~ crj for i ~ j : disjunction A formula is defined to be a pair  ( s , v ) where s is a feature structure and v : X- ) S avaluation function that assign structures to variables  . We demand that the formulas are acyclic . 
An example of a formula is given in figure 1 . Var-iables are denoted by using the symbol  #and a number  . The same formula is also given in matrix format which will be used to make the examples easier to read  . 
(\[ a:\[e:#1\] , b : 3 , c:#l\] ,  (#1 , \[ d:4\])
Figure 1
We can observe that according to this definflion formulas are not unambiguously determined  . The same formula can for example be expressed with different variables  . There is also nothing said about the value of the valuation function v for variables not occurring in the formulas  . 
3 Semantics
The semantics given for these formulas is similar to the one given by Kasper & Rounds  ( 1986 ) for their logic of feature structures . This logic is modified in the same way as in Reape  ( 1991 ) to allow for the use of variables instead of equational coustraints as used by Kasper and Rounds  . As Kasper and Rounds I will use a graph model for the formulas where each formula is satisfied by a set of graphs  . I will use b to denote the transition function between nodes in the graph  . We also need to define avaluation to describe the semantics of variables  . Given a graph a valuation is a function V : X-->N . By this fnnction every variable is assigned a node in the graph as its value  . 
Satisfaction is defined by the following rules . The model M = ( G , V , L ) where G is a graph , V avaluation and La subset of the switches occurring in the formula  . satisfies a formula at node i iff it fulfils any of these cases  . 1 will use the notions at ( i ) if node i in the graph satisfies a formula . 
? Msat(i ) T , v ) for all v ? Ms at ( i ) ( t , v ) for no v ? M sat(i ) ( a , v ) iff node i in G is the leaf a EA ? Ms at ( i )   ( x , v ) iff V(x ) = i and Msat(i ) ( v(x ) , v)?Ms at ( i ) (\[ fl:Sl . . . . . fn : Sn \], v ) iff for all k = 1 . . . n ~ ( if ~ z ) = jk and Msat(jr : )( sk , v)?Ms at ( i ) ( ol:sI . . . . . On : Sn , v ) iff precisely one of ot . . . on is in L and Msat(i ) ( sk , v ) for k such that
OkEL
These rules correspond to the usual sansfaction definitions for feature structures  . The snbset of switches L forces us to choose exactly one alternative in each disjunction and the model should satisfy this alternative  . 
4 Un i f i ca t ion in this section I will define a set of rewrite rules for computing the unification of two formulas  .   1 will start by in u ' oducing the operator ^ into our formulas  . The syntax and semantics is given by the following rules : ? Ms at  ( i ) fst/ , fs ; ~ ifffsI and fs2 are formulas and Ms at ( i ) fsI and Msat ( i ) fs2 ? Ms at ( i )   ( SlAS2 , v ) iff Msat(i ) ( s1 , v and M sat(i ) < s2 , v ) The operator ^ can be viewed as the unification operator  . By the definition we can see that it is inter+ preted as a conjunction or intersection of the two participating formulas  , which is the normal interpretation of unification  . The task of unifying two formulas is then the task of rewriting two tormulas containing ^ into a formula not containing A  . Here we can note that since a formula is not unambiguously determined the unified formula is not unique  . 
Actually there is a set of formulas that all have the Aer E  . s DECOLING-92, NANTES . 2328 AOt ~' r1992l168 PROC . OFCOLING-92, NANTES , AUG .  2328 ,   1992 same model as the unification of the l " ormulas . The aim here is to compute one of these formulas as a representative for this set  , and thus are presentative for the unification of fst and fs  2  . The rewrite rules given below correspond to the unification algorithm for formulas not containing disjunction  . 
1 , ( st , vl ) A(s2 , v , ~) ~( slAs2 , v ) if vI and v2 are disjoint and v ( x ) =vl ( x ) for all x in v1 , v(x ) = vHx ) for all x in v) ,  . 
2 . ( ~/ ~2,v)~(s2~1,v)3 . ( T,~,v)~(s,v ) 4 . ( aAa , v)r . ( a , v ) where a EA 5 . ( a / 49, v ) r . (?, v ) where ae : banda , bEA 6 . ( a ^ lfl:Sl . .~,:sn \], v ) ~ ( . 1_, v ) where a 6A7 . <_t ~,, v > ~<?, v > 8 . < xm , v > -< x , v ~> where ( v(x ) ^ s , v ) ~( st , Vl ) and xeX , v;~(x ) = sI and v2 = vI for all other variables 9 . (\[fll:Sll"fln:Sln\]m\[f21:s21"f2m:SemI , v)~(s , ve ) where sistim complex feature structure contam - ing : fl  , : suj for any j such that fLr ~ fek for all k-~-~f ) ):s ) i for any j such that /2 f , -eflt__for all kflj . ' S3 if or any j , k such that fu = f , ~t where ( sljAs2t , 
V(F1)) ~( S3i , V i ) and i describe some enumerau on of the resulting formulas vo = v and <  x3p   , vp ) is the last of tim formulas . 
The first rule is a kind of entry rule and can be interpreted as saying that it is possible to unify two formulas if the variables occumng within them are disjoint  . " l ~ le second rule says that unification is commutative  , and are used to avoid duplicating the other rules  . The next rule says that T unifies with everything  . Rules four to six says that anatom only unifies with itself and becomes failure when unified with some other a tomora complex structnre  . The seventh rule says that unifying failure always yields failure  . The eighth rule deals with unification of var -iables  . Here we have to start with unifying the value of the variable with the others aucmre  . This unification gives a new pair of feature structure and valuation function as result where the new valuation function contains the changes of variables that have been made during this unification  . The result of the unification of a variable is the pair of the variable and the new valuation function where the value of the variable is replaced with the unified one  . Rule nine deals with the umfication of two complex feature structures and says that the result is the structure obtained by unifying the values of the common attributes of the two structures and then adding all atmbutes that occurs in either of the structures to the result  . 
Figure 2 gives an example that illustrates what modifications that must be made to the rewrite rules to be able to handle unification of disjunction  . Unifying a disjunction is basically unifying each of its alternatives  . But the exmnple also shows what mns tool . 2:  #libel^I ? :\[) ' lb . . #1
I (/:
Iib : o1:02:#1#1
C.'I\[et\[a.31
Figme 2 happen if a variable occurs within the disjunc U on . 
The value of the variable is global sitice it can affect parts of the structure outside the disjunction  . Therefore this value must be dependent on what alternative that is chosen m the disjunction  . This is done by representing the value of the variable as a new disjunction where we only choose the unified value if the alternative o  7 is chosen , q b express this in the rewrite rule we index all rules by the list of switches that are U aversed in the formula  . This is expressed by replacing them with __x in all rules where X is a list of the switches passed to reach this point of the unification  . We also need to split rule 8 into two rules depending on if any disjunctions have been passed to reach the variable  . The new rules are given below and we assume that the switches occurring in each formula are unique  . 
8 . a(xm , v ) ~0(x , v ~_:' . s t )) where ( v(x ) ^ s , v ) ~( st , v1) x~X , vHx ) = sI and v2 = vI for all other variables 8 . b(x , ~', v ) ~ lot . . . . ' O(x , v ~) , where ( v(x)^s , v ) ~ ol . . . om(si , Vl ), xCX , vJx ) = ol:lo2:I . . . \[ o ~: slo .   .   .   .   . : v(x ) . . . IO now 2: v(x ) cr new I : v(x) , v ~= vI for all other vari-ables and Onewis a switch name not used before  . 
10 . (Ol:Sll . . . On : SlnAS , v) . - - -- X,~(Ol:S 21 . . . Crn : S2n , V n ) where ( S l i ^ S , v(i1)) i ~? lu ' ~( s2i , vi ) and vo = vIn Str Omblick (1991 ,  1992 ) these rewrite rules are proved to compute the unification of two foimulas  . 
5 Discussion
The syntax and semantics of the formulas are very similar to what is given in Reape  ( 1991 pp 35 ) which is a development of the semantics given in Kasper & Rounds  ( 1986 ) that allows the use of vari-ACrEs DECOLING-92 , NAN a ~2 S , 2328 X Ot ; r1992l169 PROC . OFCOLING-92, NANTES , AUO .  2328 , 1992 ables to express equational constraints . The difference is that I use formulas of the form \[/ l:sl  . . . f , : sn\] instead of an ordinary conjunction and that we use name disjunction  . This restricts the syntax of the formula somewhat and makes them closer to ordinary feature structures  . The restricted syntax is also the reason why we need to include a valuation function in the formulas  . 
It is easy to represent the formulas as ordinary directed acyclic graphs where variables are represented as references to the same substructure in the graphs  . If we think of the formulas as graphs it is also easy to compare the rewrite rules  19 above with an ordinary graph unification algorithm  . Doing this we can conclude that each of the rewrite roles three to nine corresponds to a case in the unification algorithm  . The only difference is that when variables are represented as reentrant subgraphs we never have to look up the variable to find its value  . The main advantage with defining unification by a set of rewrite rules is that the procedure can be proved to be correct  . 
6 Detection of failure and improvements
The problem with the rewrite rules is that they sometimes produces formulas which have no model  . 
Such formulas must be detected in order to know when the unification fails  . As long as the formulas only contain local disjunction this is not a problem and it is easy to change the rewrite rules in order to propagate a failure to the top level in the formula  . 
Then in th rule is , for example , changed to return ( . ? , vp ) whenever any of the values of the attributes in the resulting formula is fail  . 
When nonlocal disjunction is included we must find some of keeping track of which choices of switches in the disjunctions that represent a failure  . 
This can be done by building a tree where the paths represents possible choices of switches and the leaf nodes in the tree contains a value that is false if this choice represents a subset of switches for which the formula has no model and true otherwise  . Figure 3 shows an example of a formula and its corresponding choice tree  . To reach the leaf b in the tree the switches 0 . 1,03, and crn have been chosen and or 2, 0 . 4, and 03 have not . So 0 . 3 is both chosen and not chosen and the value of this leaf must be false  . Continuing this reasoning for the other paths in the tree we could see that the leafs b  , e , and fmust have the value false and the other leafs must have the value true  . If some value of an alternative is . 1_ the corresponding leafs in the choice tree must be false  . If we , for example assume that the value of or4 is fail we must assign false to the leafs c , f , and g . 
Choice trees can be built ones for each formula and merged during the unification of formulas  . A better solution is to only build the choice trees when they are needed  , i . e . when a disjunction alternatave
O2:#1O3: ...
On . ' O3:~l04:03f:?,"truea03 . " ~ n "", ~- false Ool ~- . 
/" o4"~-true e/~\03 ~" trlted , ,2 " C ~" '~-* - I alse ,   .   .  03  . _ ~- falsef on " J ' ~ true g
Figure 3 where the disjunction share some switch name with another disjunction fails  . If this is done we only have to do the expensive work when really needed which is when we have failure in a nonlocal disjunction and achieves a better performance of the algorithm for all other cases  . 
Str6mhiick (1991 , 1992) discusses how the choice tree is best used . The papers also discuss how the choice tree can be used to remove failed alternatives from a formula without destroying the interpretation of the formula  . The main idea here is to see what switches that must be chosen to reach each disjunction alternative in the formula  . For this set of switches we find all leafs in the choice nee that can be reached if these switches are chosen  . If all these leafs are false the alternative should be removed  . 
For example , if we assume that the value of 0 . 4 in figure 3 is fail and that we have assigned false to the corresponding leafs in the choice tree  , we can also see that there is no way of reaching a leaf with the value true if we have to choose t i n  . In this case we can as well remove both 04 and on from the feature

The two papers mentioned above also discuss vmious improvements that can be made in order to get a more efficient algorithm  . Most important here is that we can build only parts of the choice tree and that the notion of switches for a disjunction can be extended to allow sets of switches in order to avoid creating too many new disjunctions  . 
7 Implementation
The algorithm has been implemented in Xerox Common Lispand is running on the SunSparc sta-tions  . 
ACTESDECOLING-92 . NANTES , 2328 AOt ~' r19921l70 PROC . OFCOLING-92, NANTES , AUG .  2328 ,   1992   8 Complexity To analyze the complexity of this algorithm  1 will look at threccases . If we assume that there are no disjunctions in the formulas the procedure can be implemented almost linearly  . If we have local disjunction in the formulas , i . e . disjunctions which do not contain variables and which not are connected by switch nantes  , the total complexity becomes exponential on the maximum depth of disjunctions occurring within each other  . For the third case we have to add the complexity for the removal strategies when alternatives have failed  . The complexity for this procedure is also exponential in the size of a "  , where a is the total n nmb cr of alternatives Occut Ting in the formulas  . For a more complete discussion of the complexity see StrOmhack  ( 1991 ,  1992 ) When considering complexity one must remember that the second case will only be pcr for n~ed when there are disjunctions in the formul and when these disjunctions are actually affec WA by the unification  . Disjunctions in some subpart of the formula not affected by the unification never affect the complexity  . It is also reasonable to assume that m most case . q when a disjunction really participates in the unification  , some of its alternatives will be removed due to failure  . The same thing holds for the last case ; it will only be performed when some global alternative has failed  . This means that this procedure can at most be performed once for each ordinary alternative in the initial formulas  . 
Comparing this to the other proposed alternatives we can see that K as per's  ( 1987 ) algorithm has a better worst case complexity ( 2a/2 )  . On the other hand this complexity holds for all disjunctions in the structure regardless of whetlmr they arc '  , fffected by the unification or not . The algorithm by Eisele & D 0 rre ( 1988 ) has a similar worst case complexity . 
The disadvantage hreis that this ' algorithm is expensive ven if the structures do not contain any disjunctions at all  . The third algorithm ( Eisele & D~3 rre 1990 a , b ) will also be NP-complete in rite worst case and will probably have a stinilar perform artce compared to the algorithm descrit xxl in this paper  . 
9 Conclusion
This paper describes an algot ~ ithm for unifying disjunctions which calls for as little computation as possible for each ease  . Disjunctions only affect the complexity when they directly parucipate ~ are affected by the unification  , which is the only case when we expand to disjunctive normal form  . The most expensive work is done only when there is a failure in a disjunction which affect some other part of the structure  . The only algorithm that show sim-ilar complexity is the algorithm proposed by Eisele &  D0rre   ( 1990 )  . However the description given by Eisele and DOne is harder to relate and implement as a graph unification algorithm  . This paper shows that it is possible to use Snililar ideas together with graph unification  . The de , , ; cription given here is fair ? ly easy to implement as mi extension of a graph uni ~ ficatiou algorithm  . 

This work is part of the project I ) ynamic ! , an guaget lnd cr standing suppmted by the Swedish Council for Research in the Itumauities and the Swedish Bored for Industrial and " l ~ echnical Development  .   1 would also like to thank Lars Ahrcnberg and " lhre Laugholln for valuable comments on this work  . 
References
Crater , David (1990) . Efficient Disjunctive Unification for Bottom-Upl ' msm g  . Proe .   13th International Conference on Computational Linguistics  , vol . 3, pp 7075 . 
Eisele , Andreas and Jochen D 0 rre (1988) . Unification of Disjunctive Feattne Descriptions . Proc .   26th Annual Meeting of the Association fi~r Computational Linguistics  , pp 286-294 . 
Eisele , Andreas and Jochen D Otre (1990a) . Disjt/r + ctive Unification . IWBSRep()rt124, IWtIS , IBM Deutsehlat~d,
W . Gemmny , May 1990.
Eisele , Andrease ald Jochen DOne (19tX)b) . Feature Logic with Disjtmctive Unification . Proe .   13th International Conference on Compntatiomll Linguistics  , vol . 2, pp100o105 . 
Kalttnnen , Lauri (1984) . Featttres and Values . l Oth International Conference on Computation all dnguistics122nd Annual Meeting of the Association for Computational Linguistics  , Stanford , California , pp 28-33 . 
Karttenen , Lauri (1986) . D-PATR : A Develop nlent Ea Wl-ronment for Unification Based Grammars  . Proc . llth International Conference on Computational Linguistics  , Bonn , Federal Republic of Gemmny , pp 74~80 . 
Kaplall , Ronald M . mid John T . Maxwellit (1989) . An Overview of Disjunctive Constraint Satisfaction  . Proc . 
International Workshop on I ' arsing Technologies , Pitts-bulgh , Pennsylvania , pp 18-27 . 
Kasper , Robert T .  (1987) . Aihtih catien Method for Disjunctive Feature Descriptions  .   25th Annual Meeting & the Association for Computational Linguistics  . pp 235-242 . 
Reape , Mike (199 l) . An Introduction to file Semantics of Unification -Based Grmn mar Formalisms  . Deliverable R3 . 2 . ADYANA-E SPRITB~ic Research Action BR 31 75 . 
Rotmds , Willianl C . and Robert Kasper (1986) . A Complete Logical Calculus for Record Stmctt Hes Representing Linguistic Information  . Proe . Symposium on Logic in Computer Science , Cambridge Massachusetts , pp 39-43 Str0mback , Lena (1991) . Unifying Disjuuctive Feature Structures . Teclmical Report LiTH-1 DA-R-91-34 , l~e-part meslt of Computer and ln fommtion Science , Link Oping Univelsity , Link0pixlg , Sweden . 
Str ~, mbitck , Lena (1992) . Studies in Extended Uni \] ication Formalisms for Linguistic Description  . Licentiate thesis . 
Depmtment of Compute ; and hfformation Scie ~: e , Link 6 ping University , LinktJping , Sweden . 
A CRES Ul ! COLING-92 , NANTES , 2328 AO(7l'1992l171 PROC . OFCOLING-92, NANTES , AUG .  2328, 1992
