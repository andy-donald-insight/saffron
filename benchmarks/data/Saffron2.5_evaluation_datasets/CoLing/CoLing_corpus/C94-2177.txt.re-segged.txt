Reverse Queries in DATR *
Hagen Langer
( ~ niversity of () stall ) flick , Germany
hlai ~ ger((~)jupite , r . rz . mfi-osnal ) rue(:k . de
Abstract
I ) ATI is a declarative re . presentation language ti ) r lex- . 
icaliifformation and as such , fitprin (: iple , neul ; ral with resl )( ; ct ;  1 ; oi ) arl ; icul & rl ) rocessing st , rat , egies . Previous DATR(:l ) mt)iler/inl;erI)ret(!rsy , q t ( ! m support only one al : l : e . 4s , % rat , egy~hnt , closely resembles the set , of inti ~ r- . 
otlcerllleS of the procedm:sds(mumti(:s of \]) A . Tli ( Evmls & C,~tz ( lar 1989a) . In this i/al ) erw (! present , an alt , ern ; > 1; ivc accesss t , r ~ tl ; egy('ri:'uc'l' . s(' . q'ucr !/ . stral , cgy ) ~ brahim-trivial subsel ; of I ) A'F \]/ . 
1 The Reverse Query Problem
DATR ( Evans & Gazdm "1989@ hasl ) ecome . Olte of the iiiosl ; widely used for nlatl languages t in ' the I ' ( ~l ) t'ese . tll ;; t-t , ion of lexicad in for nlat , ion . !) N\['ll ~ q ) plil : ations ha . rebeen ( h ~ velol ) ed for a wide variety of lml guages ( including English ,   . lat/mmse , Kikuyu , Arabi (: , l , at , in , and others ) ; rodmmly different ; subdonudns of le , xic alrel ) resen-tat , ion , including inilect , ional morphology , und t ~ r speci-fication l ) honlt logy , nlm-(:onca . t , enative morphophonology , lexica Isenlanti(:s , and tone systems I . 
We presutl I ) O Se that the reader of the llresenl ; paper is \[ ) mlilia . r with the basic Datur(!s of \]) AT\[/ . asspe(:ilie(1 in Ewms & Gazda . r\[1989@7' he ; all ; (tu ; tcy of st lexi (: on repr(~se . nt , ;~t ; ion frnm lisln depends basically on two major fact  , ors : ? it , s declarative c : c pres . sivenes . s : is the ff ) rmalism , inprin(:iple , i : al ) al ) le of rel ) resent , ingl ; he phenomena in ? This research was partly SUpl ) orted by the ( ~ ermaul , 'e ( h ! ral Ministry of Heseareh and Technology ( BMfI' , project VEI ~ P , -MOBIl , ) at the University of l~ielelk ~ ld . I would like telthank 1 ) afy ( Id Gibbon for velyttseful COllltHeltL8   o11 aliearlier draft of
I ; his paper.
1See Cahill \[\[9 . 93\] , Gibbon\[\[9!)2\] , (lazdm"\[I9921 ,   ; rod Kilbm'y\[1992\] for reeelll ; I ) ATR applicatious in L hese areas . An informal introducl , ionI , oI ) ATR is given in ( lazdar\[19!10\] . ' l ' hesl . and at d syntax and semantics of I ) ATI is defined in I , iwm sgz(~az(lar\[198!)a ,  19891)\] . hul ) lementation issues are discussed iu ( : libbon & Almua\[1991\] , Jenkins\[1990\] , aud in Gibbon\[19931 . M , ) ser\[I992 a , 1992b ,  1992(: ,   1992d \] provides interesting insights into the fl~rmal properties of I  ) N\['I/ ( see also the I ) A'\['I/represen/ations of finil , estate all Lomal . a , dilI'e~ent kiiMs of logics , regisl , er operations ere . in Evans & ( l ~ z(la , ' \[1990\] , and l , ; ml ; er\[1993\]) . Andry et al . \[19931 describe how I ) ATR canlmused in speech-oriented ~ tl ) l ) lieal . ion . ~; . 
qll (*, st,ion ~& lid does it allow lbra . n explicit t , re;~t , -lll onl ; of general is at , ions , subgene , ralisations , ; rodex --
Cel ) tions ' . ~? itsl ' ailg ~ e of acct ', ssing . strategies : are th(w0, & cc0s . qill t , ~ strategies for all apl ) lical ; ions which 1) rt ' . suppose a lexicon ( e . g . parsing , general ; ion, . . . ), a . nd tlot , hey supporl ; t ; he development , Ill ; : till t , t ! ll ~ tllt:( , ;- I , II(\]evahm Lion of lexi (: aina na(h~(ltlat , l ~ manner ? Most ; of t , h(!previous work oili)A~I'l/has focussed out , hc for lnc'rset , of (: rigeria , i . e . t , he det ; larative features of l ; he language , its exl ) ressive i : ~ L palfili ; ies , miditsa(t-equ ; ti : yl()rL her (> for in ul ~ l ; ion of l ) r(>l ; h(~oret , i(;nt()rln~tl linguistic concepts . This paper is mainly con(:er Imd with f ; he latter set of criteria of adequacy . However , in the (: ase of I ) ATI , the limited accessiu only one di-re ( : tionlms led to a somewhat l ) ro ( : edural view of \[ ; he language whi (: h , in 1) artil : ular cases , has also had a . nimpact on the declarative rel ) resenl ; al ; ion , qI ; hem , qelves . 
I ) AT\]/ . has of l ; en been (: h ~ r ; u : I ; erised as a fiim . ctional ttild d(ttg ' . l'glti'lti . s't(:1LllglHtglLThese feLl ; llt'(hq31'o , () fCOllt'SO , not prolmrl ; ies of the bmgm~geit , self , but rather of I ; hela . uguage l ; ogether with a particulm : proceduralild ; erpre . t , ation . Actually , l ; het , erm deterministic is ill ) i ; l , l)-t ) lic~fl ) le to a declarative l~mguage , but only makes s ( ! ltseif applied to a procedural laalgua . geor a particut a . r procedural intert ) retal ; ion of a langnage . The I ) ATR interpreter/couq/iler systems develol ) Cdst ) t ~ l'2 have in CO ml nont hat (  , heysupt ) or Litaly one way of accessing the in li ) rmat , ionrelIres(mt(~'(1in & I ) ATR theory . ' Fhis accesss t ; ral ; eg y , whi (: h we will refer to as the sl , and a ' rdpT " ocedur ' alint crprctatio'n of \]) ATR , closely resembh~s the inference rules defined in Evans & Gaz  ( lar\[11989 a\] . 
Even if one considers DATR neither a . satool for i ) a . rs-ing nor for generatiol l tasks , \[) lit , rather as a purely ret/resent , ational device , the one-way-only access to DATR t , heories turns ollt , to 1) eOllO () f the major drawbacks of t ; he model . 
One(If (; tiei:bdins stated for DATR in F , wms & . Gaz-(l&r\[\]989\]ist , haA ; it isi : on qn ttationally ; ra(:l ; able , lhlt ~ for many practical purpl/Ses , including lexicon iI evel o1) tnt ! llLsl , l l d e w ~ , lual ; ion , it isllOt , sufficient , t , hal;t , her ( ~ . is , : ~ lly21) ATI ; i/impl-et ; mn~ati . . . . . i , ave I .   .   .   .   .   .   .   . leveloped by iCEvans(I)A'\['I(90), I) . ( lit ) bon(I)I)ATI , ODE ), A . Sikorski ( TPI)A-'I'll , q), . l . Kilbury ( QI)ATII ), ( I . I ) rexel(YAI )\]"), M . I ) uda(IIUI ~
I ) ATII ), mid other.s.
1089 arbitrary accessing strategy at all , bnt there should be an appropriate way for accessing whatever information that is necessary for the purpose in question  . This is a strong motivation for investigating alternative strategies for processing DATR representations  . This paper is concerned with the reverse query problem  , i . e . the problem how a given DATR value can be mapped onto the queries that evaluate to it  . A standard query consists of a node and a path , e . g . Sheep : < or thplur > , an < levaluates to a sequence , of atoms ( value ) , e . g . sheep . A reverse query , on the other hand , starts with the value , e . g . sheep , and queries the set of node-path pairs which evaluate to it  , for instance , Sheep : < orthsing > and Sheep : < or thplur > . Our solution can be be regarded as an inversion of the parsing-as-deductional  ) proach of the logic programming tradition , since we treat reverse-query theorem proving as a parsing problem  . We adopt a wellknown strategy fror a parsing technology : we isolate the context-fi'ee " backbone " of DATR and use a modified chart -parsing algorithm for CF-PSG as a theorem prover for reverse queries  . 
I , br the purposes of the present paper we will introduce a DATR notation that slightly differs fi ' om the standard notation given in Evans & Gazdar  \[1989\] in the following respects : ? the usual DATR abbreviation conventions are spelled out * the global environment of a DATR descriptor is explicitly represented  ( even if it is uninstantiated ) ? each node-path pair N : P is associated with the set of extensional suffixes of N : P that are defined within the DATR theory In standard DATR notation  , what one might call a nonterminal symbol , is a node-path pair ( or an abbreviation for a node-path pair )  . In our notation a DATR nonterminal symbol is an ordered set\[N  , P ,  (7 , N ' , P '\] . 
N and N ~ are nodes or variables ranging over nodes  . 
P and P ' are paths or variables ranging over paths  . C is the set of path suffixes of N : P . 
A DATR terminal symbol of a theory 0 is an atom that has at least one occurence in a sentence in  0 where it is not an attribute , i . e . where it does not occur in a path . 
The suffix-set w . r . t , at ) refix p and a set of sequences S ( written as alp , S ) ) is the set of the remaining suifixes of strings in S which contain th c prefix p : alp  , S ) - slp^s~S . 
Let N : P be the left hand side of a DATR sentence of some DATR theory  0  . Let be II the set of pat , hs occurring under node N in 0 . The path extension constraint of Pw . r . t . N and 0 ( written as C(P , N , O ) , or simply c ) is defined as : C(P , N , O ) = G(I " , n ) . 
Thus , the constraint of a path P is the set of path suffixes extending P of those paths that have P as a prefix  . 
Example : Consider the DATR theory 0:
N : <>==0 < a >==1<ab >==2.
The constraint of <>( w . r . t . N and 0) is < a > , < ab > , the constraint of < a > is < b > , and the constraint of < ab > is ~ . 
We sW that a sequence S-st .   . . s , ~(1_<n ) satisfies a constraint Cilla:6cl . ax = s-~(i . e . a sequence S satisfies a constraint C iff there is no pretix of S in 

Now having defined some basic notions , we can give the rules that map standard DATR notation on t  ; oour representation :
Mapping rules
N : P = --0
N : P == at onl : : ~
N : P = = N 2:1'2::>
N : P == N2 =>
N : P = = P2:::>
N:P=--"N2:P2"
N : P = --" N2"
N : P == " P2":=>\[N , P , C , N' , P'\]-~e\[N , P , C , N' , P'\]-+atom\[N , P , C , N' , P'\]--+\[N2 , P2 , C , N' , P'\]\[N , P , C , N' , P'\]-+\[N2 , P , C , N' , P'\]\[N , P , C , N' , P'\]--; . \[ N , P2 , C , N' , P'\]\[N , P , C , N' , P'\]-~\[N2 , P2 , C , N % P2\]\[N , P , C , N' , P'\]-~\[N2 , P' , C , N2 , P'\]\[N , P , C , N' , P'\]--+\[N' , I'2 , C , N' , I'2\] llow these in at ) ping principles work can 1 ) erhaps bes the claritied by a larger example . Consider the small DAq'R theory , below , wifich we will usems an example case throughout this paper : 
House : <>== Noutl < root >== house.
Sheep : <> :: Noun < root . > == sheep < affixplur > :--- . 
Foot : <>== Sheep < root >== foot < root plur > = = feet  . 
Noun : < orth > --="< root > "" < affix > " < affix sing >==< affix singgen >== s<affixplur > = = s  . 
The application of the mapping rules to the DATR theory above yield stile following result  ;   ( unstantiated variables are indicated by bold letters  ) :\[ Ifouse , <> , <root> , N' , P'\]~\[Noun , <> , <root> , N' , P'\]\[House , <root> , ,N' , P'\]~houso\[Sheep , <> , <root> , < at flxplur > , N ' , P'\]-\[Noun , < > , < root > , < affixplur > , N ' , P'\]\[Sheep , <root> , ~ , N' , P'\]--+sheep\[Sheep , < affixplur > , ql , N' , P'\]--~e\[Foot , <> , <root> , < root plur > , N ' , P'\]--\[Sheep , <> , <root> , < root plur > , N' , P'\]\[Foot , <root> , <plur> , N' , P'\]- , foot\[Noun , <orth> , ~ , N' , P'\]--*\[N' , < root > , ~ , N' , < root>\]\[N' , <aflix> , (t , N' , < aflix >\]\[ Noun , < allixsing > , <gen> , N' , P'\]-+e\[Nmm , < a\[\[ixsinggen > , ~ , N' , P'\]~s\[Noun , < aI\[ixplur > , 0 , N ' , l "\] --~ s The general aim of this ( somewhat redundant ; ) notation is 1 ; ol intevery l ; hing that is needed for drawing infm-trices from a sentence  ( especially its global enviromnent mM possibly compel  ; ing clauses al ; the same node ) into t , herc presenl ; ation of the . sent xmc (; itself . Similar inter-hal representations are used in several I  ) ATII . imple-lnentations . 
2 Inference in DATR
Bol ; hsl ; mM md inference a . nd reverse query inference can be regarded as COmlflexsul  ) stil ; ul ; i on Ol ) eral , ions defined for sequences of DATR terminal and iiolt-l  ; Crtllinal symbols which apply if particulareal ; thing crit(wia ~ rr(:sal ; is tk!d . In case of DATI . standa . rd procedural Selnan-tics , a step of inference is tim substitution of a I ) ATtIlonternfinM by a sequcnt : e of \] ) A'FR torminal and non-tern final symbols . The matching criterion applies to a givon DAT\] query and the lefthmld sides of the sen-tenets of the  1  ) A'HI , theory , if the LfIS of aI ) ATII sentence satisfies the matching criterion , a modified vcrsio Il of the right ha . IMside is sttl ) sl . il . lll ; edl br the LItS . Since the maL (: hing criterion is such l ; hat there is at most one sent 0 . ncein at ) A: . HI theory with a matching I , HS , DATR standard in Drence is determil fisticm M functional  . The starting point of DA'FR staiMm : dinference is single nonterminal a  . ndtim derivation process terminates if a Se ( lUenc ( ' . of I . ernfinals is obl ; ailmd ( or if there is no IAIS in the theory that sa . l ; is fics the matching criterion , in which case the process of inference term i -tortes with a failure  )  . 
In terms of DAq'\]I . roverse query t ) roce dural semmt-tics , a step of inti ; ren ( ; e is the . substitution of a sub-sc ; qllm(:(~ of a given sequence of I ) ATR . terminal and nonterminal symt ) ols by a . I ) A Tlt non-tern final . Tim matching criterion applies l , othe subsequence and the . 
right hand sides of the sentences o\[the DATR theory  . 
If the matching criterion is satisfied , a modifie . dversion of the LHS of the I ) A Tlt sentence is substituted for them ~ t ching subsequenc c  . In contrast to I ) A'FI/ , standard in li!rmm (! , the matching c : riterion is sut : h that there might be several I  ) AT\]/ . senl ; encos in a given t ; hc-ory which satisfy il ; . DA\[I'II reverse queryiM ' erence is hence neither flmctional  , nor deterministic . Starting poin I ; of a reverse query is a sequence of l ; ( n : lninals(avalll(!) . Ath ' , rivati(m ( , ermin aI ; cs , if the substitutions finally yield a singh ; nonter\]uinal with identical \] oc , al and global cnvi rolmmnt ( or if there are no matching sentences in the theory  , in which case the dcrivatioil fails ) . 
We now define the in a A ; (: hing criteria for I ) ATR terminal symbols , I ) ATI nonterminM symbols and sequences of DATft symbols  . These matching criteria relate extra > sional lemlnal  ; a(i . e . already derived tmrtial analyses ) to I ) ATR definil ; ional sentences ( i . e . " rules " that may yield afm ' tho , rroduction ) w . r . t , a given DATR theory 0 . 
A term . thai symbol t,'matches another tc . r'minalsy'm-bolt2 if l't,-t2 . We also say that t , rrtatt ' Jte . s t . 2 with art arbit~nry suJfi:c and art empty constTn in th  , of der to provide compatibility with the definitions t br nontermimfls  , below . 
1 . A nontcrmi'nalIN ,  1'1 , C1 , N ' , P '\] matches another nonto . rminal\[N , 12 . 2, C2, N ', Pq with as ~ tf . JirrEa'nda constraint C2 if (@ H'2 = P ~ E , & n(l(l )) Es ; ~; is fies C1 . 
2 . A nonterminal IN , P ~, C1, N ', i "\] match . canotlmrnont , o . rminal\[N , P . e,C2, N ', I"\] with an e . rnpt~/s'uf/i:ca'ttda constrainta ( . \[~, Cu ) if ( a)P , = I ~ AI , : , and ( b)
E satisfies C~.
Example : The nonterminal symbol \[ Node , < ab > , < cde > , Nf , P\[I matches\[Node , < ~ bcd > ,  ~ , N  ~ , l ~\] with suffix , 5'= < cd > and constraint ~ . 
l ? rom the definitions , giwmabovo . , we can derive the matching criterion for sequences :  1  . The ernpt!/sequence matches the empty sequence with a  . nempty suffix and constraint V ) . 
2 . A nonempty sequence of ( terminal and non-tcrmilml ) symbols s ' ~ .   .   . s ' , ~  ( 1 < n ) matches another se-quen ( : e of ( terminal and nonterminal ) symbols sj .   .   . s , , with suttix E mM constraint C if ( a ) for ca . all symbols l(1<i<n ): sm~l ; cho,ss, . with suffix / 3 and constradnt Ci , and ( b)C = C~u (& .   .   . oC .   . 
To put it roughly , this definition requires thai : the symbols of the sequences match one another with the sarrte  ( possibly eml > ty ) suffix . Tho . re'suiting constraint of thes (' . quence is t , heration of the constraints of the sylnbols . 
Example : The string of nontcrminal symbols \[ N1 , <a> , C~ , N'I , P'I\]\[N2 , <x> , C>N'2 , P'2\]matches\[Nl , < ab > , <c> , <d> , N ' l , P'l\]\[N2 , < xb > , < e > , N ' 2 , P ' 2\] with suffix < b > ~ md constraint < c > , < d > , < e > . : ~ a The matching criteria , defined above , do not ; cover non-t , erminals with evaluable paths , i . e . paths that include ( an arbitrary nutuber of possibly recursively e . mbcd ded ) nonter-mimds . The matching cril , erion for nonterminals has to be extended in order to account f l  ) rsLatem cnts with evaluabh ~ paths : l , et , lit ! eval(tt , e , 0) a func Lion I ; hat maps as l ; ring of I ) ATR t , erminal attdnonl , erHlinal symbols(~=At . . . A , , on ; oa string of I ) NH/ . terminals ~' such that ( a ) each terminal synfl ) olAi ( I < i < rt ) in ( ~ is mapped onl , oil , self in : ~ , and ( b ) each nonU '* minalAj\[Nj , l ,  (5'~ , Nj , \[j\](l<j < rl , ) in ~ is mapped on to ell (; se , quence , a  ~ . .  . aj ' inc ~' sucht ; hat,N'j:l'^je=aj ' .   . , aj ' in 0 .   , A , refers to ( recur-Metaphorically , DATR can be regarded as a formalism that exhibits a contextfree backbone  4  . In an al--ogytoae on text-flee phrase structure rule  , a DATR sentence has a lefthand side that consists of exactly one nonterminal symbol  ( i . e . a node-path pair ) and a right hand side that consists of an arbitrary number of nonterminal and terminal symbols  ( i . e . DATR atoms ) . IIl contrast to contextfree phrase structure grmmnar  , DATR nonterminals are not atomic sym-hols , but highly structured complex objects . Additionally , DATR difli?rs from CF-PSG in that there is not a unique start symbol but a possibly in finite set of them  ( i . e . the set of node-path pairs that , taken as the . starting point of a query , yMd a value ) . 
Despite these differences , the basic similarity of DATR sentences and CF-PSG rules suggests that  , in principle , any parsing algorithm for CF-PSGs couhl be a suitable starting point for constructing a reverse query algorithm for DATR  . The algorithm adopted here is a bottom-up chart parser  . 
A chart parser is an abstract machine that performs exactly one action  . This action is monotonically adding items to an abstract data structure called ehart  , which might be thought of as a graph with annotated arcs  ( which are also often referred to as edges ) or a matrix . 
There are basically two diff'erent kinds of items : ? in active items  ( which represent completed amdyses of substrings of the input string  ) ? active items ( which represent incomplete analyses of substrings of the input string  ) if one thinks of a chm't in terms of a graph structure consisting of vertices connected by arcs  , then an item can be defined as a triple ( START , END , LABEL ) , where START and END are vertices connected by an arc labeled with LABEL  . Active and in active items ditfer with respect to the structure of the label  , in active items are labeled with a category representing the analysis of the substringiven by the START and END position  . An active item is labeled with a category representing the analysis for a substring starting at  ; START and ending ats or neyet unknown position X ( END < X ) and a list of categories that still have to sire ) DATR path extension ( of . Evans & (' azdar 1989a) . 
Notice that e has no index and thus has to be the same t brall nonterminals Aj  . Let X1IN ,  15 , Ct , N ' , P'\] be a nonterminal symbol including an evaluable path PI  . Xt matches\[N , P ' 2 , C2 , N ' , P'\] with a suffix / 3 . and a constraint ( L , if ( at eval(Pt ,  1 , / , 0) = 7 r , and ( b)\[N , real ' .  ' , C  ~ , N ' , P'\]matches\[N , P ' 2 , C  ~ , N  ~ , /) q with suffix15' and constraint C . , ( according to the matching criteria , defined above ) . 
4 The similarity of certain I ) ATR sentences and contextfree phrase structure rules has first been mmltioned in Gilt-bon  \[1992\]  . 
l ) ei ) roven to he proper analyses of a sequence of connected substring starting at END and ending at X  . 
For the purpose of processing DATR rather than CI , '-PSGs , each active item is additionally associated with a path sutfix  . Thus an active item has the structure : ( START , END , CAT0 , CATj . . . CAT ,   , SUFFIX ) Consider the following examples : the inactive item  ( 0 ,  1 , \[ House , < orthsing > , <gen> , House , P '\] ) represents the intbrmation that the substring of the input string consisting of the first symbol is the vahm of the query House : < orthsing >  ( with arty extensional path suffix , but not gcn ) in the global environment hat consists of the node House and some still uninstantiated path P '   . The active item (() , l , \[ Noun , < orth > , 0 , House , P '\] , \ [ I to use , <affix> , O , House , P'\] , e ) represents the information that there is at ) artial analysis for a substring of the input string that starts with the first symbol and ends somewhere to the right  . This substring is the value of the query Noun : < orth > within the global environment consisting of the node House and some uninstantiated glohal path P '  , if there is a substring starting from vertex 1 that turns out to he the value of the query I to use : < a ~ ix > in the same global environment  . IIousc:P' . 
The general aim is to get al in active item sla-.
heled with a start symbol ( i . e . a DATR nonterminal with identical local and global environment  ) for the whole string which a derivable from the given grammar  . There are different strategies to achieve this . The one we have adopted here is hased on a chart -parsing algorithm proposed in Kay  \[1980\]  . 
Here is a brief description of the . procedures : ? parse is the main proeedm : e that scans the in l  ) ut , increments the pointer to the current chart position  , and invokes the other procedures ? reduce searchest  ; he DATR theory for appropriate rules in order to achieve fllrther reductions of inac-tiw'~items ? add-epsilon applies epsik  ) n productions ? complete combines in active and active items ? add-item adds items to the chart We will now giw ' ~ a more detailed description of the procedures in a pseudocode notation  ( the input arguments of a procedure are given in parentheses after the procedure nain c  )  . Since the only chart-modif ) ing ot > (' . ration is carried out as a side effcc . t of the procedure add-item , the , ' e are no output w dues , at all . 
The procedure parse takes as input arguments a vertex that indicates the current chart position  ( in the initial state this 1 ) osition is 0 ) and the suffix of there . intoning suItix of tlminlmt string is n(m-( ; mpty , parse calls the procedures add-cpsil on , red'ace , and complete , il ICI'~IIR!II ; SI , h ! pointer to l ; he currell t , ch ; 41: l ; position , and si ; m'i , s again with t . he new currelg ; vcrLex . 
procedm ' epars c(VEl~Fl'3X , SI . . ? ,% ) variables:
VER3PEX , NEXT-.VER3 ~ EX ( integer)
SI .   .   . Sn ( string of t ) A'I'\]:L symbols ) data : A DATR theory 0
I ) eg in if n > 0 then
NEX'\[':VIBIIlI'I+ , X :-- VI , ;I/I\['EX + 1 ca l l - p roe ad<l:epsilon ( VEI ; I'EX ) call-procreduce(VEllSl'EX ,  $1 , NI , ' XT-VFI/TI , ; X ) call-proecomplete ( VEI(Pl , ; X ,  $1 , NEX'I'-VEII lFI , ; N ) e all-proeparse . (NEXT-VEIIS\['F,X,S2 .   .   . S , , ) else add-e . psilon ( VEI/flT ; X)en(i The 17 r<>ce < hn'e add-cpsilo'nill , '- ; (!l't ; sar<:s For the epsihmpr(lu:tins in Lol ; he charL : procedure add-c . p , + il < m(VE\]SITBX ) variables : VI , ; R/IT ; X(integer ) data : AI ) ATR , the , Try 0iegin for-each rule CAT ~ e : in 0 ca . ll-procredu:e(VEll'EX , CAT , V \] , ; II3T;X ) call-proc(:omplete(Vl , ; R'l?EX , CAT , VER\[PIBX)end The , llO ( :< ~ durc'reduce Lakes all inactive item as timin -l  ) tll ; a , rgumcn L and s ~; ~ l ; h!sl , lOI ) A Tll , Llmory for tulcs thai ; have a mat (: hin p ; le , fl;-c > ruer < : at < ~ g(ry . t , ' orea , (: h such rulefmn1,'rc . d ' acc in vkestiml TrTc ~ < htr ~ add . .itcm . 
procedm'e"red'ucc(Vi , CATI , V2 ) data : AI ) ATR theory 0 begin if is-tx ~ rminal ( CA'l't ) then fir-e . aehrll e\[No,Po,Co,N'o,P'o\]>CNI'j .   .   . CAT ,   , in 0 call-troca < ld-it cn ~ ( Vl , V2 , \[ No , 1o , C , N ' o , t''o \] , 
CATI .   .   . CAT , , , X ) else for-each rule\[No , lo ,   , 0 , N 0 , I0\]>CATt . . . ( A'I',, in 0 sucht ; ha . t(JAfl'matches(JATI with snlIixS ; rod constraint Cealt-procaddil ; ! in(Vt , V2 , \[ N , ,I' , ,C u o(S , C0) , N' , ,P '( , \] , :: A % . . . CA% , S ) elld The procedure complete takes ; minat:tiv(~il ; ;nl as a . ninpuL ~ o ' , gllllelll ; ittK\[s(;/ , 7' clos ; h(! ; h&l' ; for active il ; elnSwhi(:h('antTe , c(TmI ) leted wiL hit ,  . 
procedure complete ( V1 , CAT , V2 ) data : A < : hart CII begin if is-terminal ( CAT )    ; henfor-each a . cl ; ive item ( Vo , V ,, CA To , CAT , CAT 2 .   .   . CAT , ~ , S ) in CIIe all-proc add-item ( Vo , V2 , M , CAT 2 . .  . CA'\]? , ,  , S ) else for-each act ; iv (' , il ; em(V0 , V  ~ , \[No , I'o , (-Jo , N'o , I"o\] , CAT ,   .   .   . CAT , ,, S ) in CII such l ; hat(JA'FI lna . t(:hes CAT with consl ; rainL (' , and su\[lix , Seall-proc add-iten , (V , ,V2 , \[No , Po , o(S , G , ) UC , 
N ', P'\], CAT2 . . . Cat , ~, S ) end
The procedure add . item is t;\[1( . ' chart-modifying ope . r-al ; iTn . \[Lt , akesana % ive item its an inlm targtt nw . tit . 
\[ fL his acLivei ; em has no 1) ending categories , it L '; regarded as a . ninactiw'item . In this case add-item in s(!rl , sa new (: harlen Lry for t ; heilxm ~ , providedil ; is not al-r (' . ady includ ; dinl ; he chart , and calls the procedures reduce ; rod corn plcl . < If tit (: item is an active item , then it ; is inserted hfl ; othe(:hart; , provided it , is not a h'eady inside . 
) i ~ I procedm ' e add-i l . cm(V ~, V : ,\[ No , (, o , No , to \], (~ A'l ' ~ . .  . CAT ,   , S ) data : A charl , CII begin if CAT ,   .   .   . CA '\[', ~-: e the . n if ' ~ A- ,   ,   ,  ) , ( V  ~ , V~ , \[ No , IoS , Co , No , 1o \]) ECIt then end , ' , Is , , (3 \ [ ::: CII tO ( Vt , V2 , \[No , I'~S , Co , N' , , , P'o \]) else if(V ,   , V  ~ , \[No , Po , Co , N'o , I"o\] , CAT ~ . . . (; AT ,, S ) (- CII then e . ndelse CH:-CIItO(VI , V2 , \[ NI'C , v ,   ,   , lCv ~ ,   .   .   . CAT ,   ,   , S ) end4 Cycles A hard problemior I ) ATR interpr ( ~tersarec:vclc , % i . e . 
I ) ATI (, statements and sets of I ) N . \[' I statement swlfic , hinvolver ( ; (: ursive detiifitions such thai ; standard inference (71 reverse-query illf(!r (' , Iic(~(\[o ( ; si1(7 ; necess : u'ilyIx'r-ininate afLeralin itemlmber of steps of iMi  , rence . Here & l'(:SOIlIO(!X~l , I ilple SO\['cycles : ? simple cg clc . s : N : < a > - :-< a > . 
? pathlc'n.gthcning cycle.s:N : < a >=--< aa>.
? paUt . sh . orte'ain . 9C ? lclc . s:N:<a a >=-=< a > . 

While simple cycles have to be considered as semantically ill-formed and thus typically occur as typing errors only  , both path lengthening and path shortening cycles occur quite frequently in many DATR representations  . Note that path lengthening cycles turn out to be path shortening cycles in the reverse query direction  , and vice versa . The DATR inference ngine can be prevented from going lost in path-lengthening and path -shortening cycles by a limit on path length  . This finite bound on path length can be integrated into our algorithm by modifying the add-item procedure such that only items with a path shorter than the permitted maximum path length are added to the chart  . 
5 Complexity
CF-PSG parsing is known to have a cubic complexity w  . r . t , the length of the input string . Though it is crucial for our approach that we exploit he CF-backbone of DATR for computing reverse queries  , this result is of no significance , here . I ) ATR is % 1 ring-equivalent ( Moser 1992d) , and ~ ISM ng-equivalence has also been shown for a proper subset of DATR  ( Langer 1993 )  . 
These theoretical results may a priori outrule DATR as an implementation laguage for large scale realtime applications  , but not as a develot ) ment environment for prototypelxica which can be transformed into efficient task-specific online lexica  ( Andry et al 1992 )  . With a finite bound on path length our algorithm works  , in practice 5 , fast enough to be regarded as a usefifl tool for the development of small and medium scale lexica in DATR  . 
6 Conclusions
We have proposed an algorithm for the evaluation of reverse queries in DATR  . This algorithmakes DATR-based representations applicable for various parsing tasks  ( e . g . morphological parsing , lexicalist syntactic parsing ) , and provides an important tool for lexicon development and evaluation iDATR  . 
References\[Andry et al1992\]F~'an(;oisAndry , Norman M . lh ' aser , Scott McGlashan , Sira on Thorn-ton&Nick J . Youd \[1992\]: Making DATR Work for Speech : Lexicon Compilation in SUNDIAL  . In : Cornp . Ling . Vol . 18, No . 3, pages 245-267 . 
5A prolog implementation f the algorithm described in this paper is freely available as a DOS executable program  . Please , contact he author for fllrther information . 
\[Cahill 1993\] Lynne J . Cahill : Morphonology in the Lexicon . in Sixth Co@fence of the E . uropean Chapter of the Association for Computational Linguistics  , pages 87-96 ,  1993 . 
\[Evans & Gazdar 1989a \] Roger Evans & Gerald Gazdar : Inference in DATR  . In li'o~tr'th Conference of the European Chapter of th  , e Association for " Computational Linguistics , pages 66-71 ,  1989 . 
\[Evans & Gazdar 1989b \] Roger Ewms & Gerald Gazdar : The Semantics of DATR  . In : Anthony G . 
Cohnled . \]: P~vcecdings of th , eSeventh Conference of the Society for " the Study of Artificial Intelligence and Simulation of Behaviour  , pages 79-87 , London 1989 , Pitman/Morgan Kaufinann . 
\[Evansk Gazdar ( eds . ) 1990\]Evans , Roger & Gerald Gazdar \ [ eds . \]: The DATR Papers . Brighton : University of Susse ? Cognitive Science Research Paper 
CSRP 139, 1990.
\[Gazdar 1992\] Gerald Gazdar : Paradigm I~mction Morphology in DATR  . In : L . J . Cahill & ll , ie hard Coates \[ eds . \]: Sussex Papers in General and Computational Linguistics : Presented to the Linguistic Association of Great Britain Conference at Bright on Polytechnic  , 6 th-8th April 1992 . Cognitive Science Research Paper ( CSRP ) No .  239 . University of Sussex , 1992, pages 43-54 . 
\[Gibbon 1992\] Dafydd Gibbon : ILEX : A linguistic approach to computational lexiea  . In : Ursula Klenkled . \]: Computatio Linguae . Au Niitze zur algorith-mischen nnd quantitative n Analyse der Sprache  , pages 32-53 . 
\[Gibbon 1993\] Dafydd Gibbon : Generalised DATR for flexible access : Prolog specification  . En-glish/Linguistics Occasional Papers 8 . University of

\[Gibbon & Ahona 1991\] Dafydd Gibbon & Firmin Ahoua : DDATR : un logieiel detraitement d'hdritage parddfaut pour lamod dlisation lexical  . Chiers Ivoriens de Recherche Linguistique ( ivl )  27 . Universitd Nationale de C6ted'Ivoire . Abidjan , 1991, pages 5-59 . 
\[Jenkins1990\]ElizabethA . Jenkins : Enhancements to t be Sussex Prolog DATR hnplemeution  . I : Evans & Gazdar \ [ eds . \]\[1990\], pp .  41-61 . 
\[Kay 1980\] Martin Kay : Algorithm Schemat and Data Structures in Syntactic Processing  . XEROX ,
Palo Alto.
\ [ Kiltmry 1993\] James Kilbury : Para < ligm-Based Derivational Morphology  . In : Giint her GSrzled . I:KONVENS 92 . Springer , Berlin etc . 1992, pages 159-168 . 
1094\[Langer 1993\]lt ; ~gen Langer : DATR without nodes mM global inheritance  . In : Proc . of 4 . F ; ~chtagung Dckla Tntiv cund proze durab ~ As pcktcd~r @ Tnchvcr-arb citung der\]  ) GfS/CI ~ , University of Iiamburg , pages 7\]-76 . 
\[Moser1992 a\]I , ionel Moser : DATR Paths as Arguments . Cognitive Science Research l'al)e . rCSR , P216, University of Sussex , Brighton . 
\[ Moser1992b \] Lionel Moser : Lexical Consl ; r ~ thlts in /) AT1L Cognitive Science Resea . rchPaper CSRP 215 , University of Susse , x , Brighton . 
\ [ Moser 1992 ( :\] Lionel Moser : Evaluation in DATR is co-NP -Itard  . Cognitive St : ience\[1 . ese ; ~ rchP ; tper CSRP 240 , University of Sussex , Brighton . 
\[ Moser 1992d \] Lionel Moser : Simulating Turing M~L-chines in DATR  . Cognitive Scien (: (~ Research Paper CSRP 2411 , Univ ( , rsity of Sussex , Brighton . 

