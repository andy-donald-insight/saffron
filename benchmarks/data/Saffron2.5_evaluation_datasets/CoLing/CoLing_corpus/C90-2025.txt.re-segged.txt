Funetor-Driven Natural Language Generation w ith 
Categorial-Unification Grammars
Dale G , er demann
Beckman Institute for Advanced
Science and Technology
University of Illinois
at Urbana-Champaign
405N . Mathews
Urbana , IL 61801

Erhard W . Hinrichs
Beckman Institute for Advanced
Science and Technology
University of Illinois
at Urbana-Champaign
405N . Mathews
Urbana ~ IL 61801

1. Introduction
In this paper we develop a functor-driven approach to natural language generation which pairs logical forms  , expressed in first-order predicate logic , with syntactically wellformed English sentences . Grammatical knowledge is expressed in the fi ' a mework of categorial unifieation-qrammars developed by Karttunen  ( 1986 )  , Wittenburg (1986) , Uszkoreit (1986) , and Zeevatet . al .  (1987) . The semantic omponent of the grammar makes crucial use of the principle of minimal type assignment whose importance has been independently motivated in recent work in natural language semantics  ( see Partee and Rooth 1983 )  . 
The principle of typeraising as necessary which follows fi ' omminimal type assignment has been implemented using Wittenburg's  ( 1987 , 1989) idea of su-pereom binators . This use of supercombinators to achieve semantic compatibility of types generalizes Wittenburg's trictly syntactic use of such combinators  . 
The use of categorial unification grammars makes it possible to develop an efficient topdown control regime for natural anguage generation  . Rather than generating the syntactic output string in a left oto-right fashion  , our algorithm always generates that part of the output string first that belongs to the funet or category in a given phrase  , before it generates any of the arguments of the functor category  . 
This fnnctor-driven strategy is similar to the head-driven approach to natural language generation developed by Shieber el  . al .  (1989) . However , unlike the head-driven approach , which uses a mixed regime of topdown and bottom -upprocessing  , our algo-rithmal ways has sufficient op-down information to guide the generation process  . Moreover , due to the principle of minimal type assigmnent in the semantics  , our approach avoids problems of efficiency that arise for the head-driven approach for those classes of grammars that do not satisfy this principle  . The work reported here is implemented in the natural language system UNICORN  , which can be used for natural language parsing ( see Gerdemann and Hinrichs 1989 ) and na . tural anguage generation . 
2 . The Grammar Formalism : Catego-rim Unifica tion Grammar The grammatical formalism that we adopt for categorial unification grammar is similar to that proposed in Uszkoreit  ( 1986 )  . Following the schema for syntactic rules developed for PATR-style grammars  , we formulate the categorial gramma rule of functional application by the rule schema in fig  .  1 . The
Figure 1: Function Application zl node ( i . e . the node at the end of the path ( zl ) represents a functor category that combines with an argument at  x2 to yield as a result the category at x0  . The rule also specifies that the semantic translation  ( trans ) of the result category x0 is inherited from the functor x l . As is characteristic of categorial grammars , our syntactic rules are highly schematic , with most of the grammatical information encoded in the categorial lexicon  . For example , constraints on word order are encoded in lexical representations of functor categories  , rather than in the syntactic rules themselves . To this end we adopt an attribute phon ( for : phonology ) which is used to encode linear order for syntactic strings  . The values for p~taon are structured as difference lists  . The use of this data structure , inherited from PROLOG , allows us to concatenate functor categories with their arguments either to the left or to the right  . It also allows us to state syntactic rules without having to make reference to constituent order  . * The graphs in fig .   2 display partial lexical entries for the intransitive verb smiles  , 1 In this respect , our representation is more compact than other categorial-unitlcation grammar formalisms which state order constraints in the categorial lexicon and in each syntactic rule  . In particular , we don't need to distinguish between forward application and backward application i  145 l ,  . c . /- , % j . 
%@//' N@~o_'~(v 4/#/~ from essmiles ~
Figure 2: Phonology Rules for the proper name Tom and for the sentence Tom smiles  . The phonattribute for argument categories such as proper names is encoded as a singleton list which contains the argument string in question  , e . g . 
Tom . The phonattribute for functor categories is designed to combine the string for the functor category with the phon feature structure of its argument categories  . In the case of the intransitive verbs miles , the morphemes miles appears as the first element in a list that is appended to the difference list for its subject argument  . When the phonology attributes for Ibm and smiles are combined by function application  , the resulting sentence xhibits the correct word order  , as fig . 2c shows . For the sake of con > pleteness , we also include the representation of the preposition from as an example of a forward functor in fig  . 2d . 
For the remainder of this paper we will concentrate on the interplay between syntax and semantics for the purposes of language generation  . We will assume that information about word order propagates from the lexicon in the manner we just outlined by example  . 
3. Natural Language Generation with
Categorial-Unification Grammars
In this section we describe our functor-driven approach to natural language generation which pairs logical forms  ( represented in first-order predicate logic ) with syntactically wellformed expressions of English  . For example , given a first-order for nmla such as ( 1 ) gx\[person ' ( x ) - - ~ smile ' ( x ) \] we want to generate a sentence such as Everyone smiles  . 
Ill order to produce the appropriate sentence , the generator is supplied with a start Dagas in fig  .  3 . 
s ~ ., ~ iksmile & every ) ersoll
Figure 3: Start Dag for Everyone smiles
The first order formula (1) is represented in fig . 3 under the attribute trans ( for : logical form translation )  . The value for the attribute cat specifies that the translation corresponds to a syntactic expression of category s  ( for : sentence )  . Unlike functional categories which take other syntactic categories as arguments  , s is a basic category , i . e . a category which does not take an argument . 
The task of the generator is to further instantiate start Dags such as that in fig  .   3 so that appropriate syntactic expressions are generated in the most efficient manner possible  . 
3 . 1 A Functor-Dr iven Generat ion A lgor i thm One advantage of the use of categorial grammars is that efficient generation can be effected by a completely general principle : at each step in the derivation of a syntactic expression  , constituents tha . t correspond to functor categories are to be generated before the generation of constituents that correspond to the functor's argument categories  . The strategy underlying this principle is that in any grammatical construction  , functor categories always provide more syntactic and semantic information than any of the argument categories  . By generating the fnnctor cat-1462 a . o@ . ~ i , ' b .  / ' / ~ ? ~ 4 "  .   . oc . rans
I ?' V " ; ~//"~' O'~~b person persons np smile Figure 5: Generating ?' verg . ones raile . ~

Ir\+sl ~ :"- . ~' e , \ smile person it , ' igure 4: Start Dagu ~ Jifies with function application ; i ' llle . :: gory first , the choice of argnmen I~categories will be : ~ e . verely con~-trained , which sigJ : ificantly prunes the ; ; earch space in whieh the algorithm has t . ooperate . 
We will illustrate our approach by discussing the funetor-driven order of processing for the generation of the sentence Ever ' gone < <- rsz'i  , les . First the generator will make a topdown predict i on by unifying the e  . ', bart Dagin fig . .3 with the m0 node of the functional ; xpplication rule shown in fig .  1 . The resulting Dag is shown in fig .  4 . 
The predicted Dagin fig . 4 then becomes sub- . eel ; to the principle of generating functor categories !' h-st  . Identification of a functor eategory in a rule of categoriab  . unitication grammar is straightforward : I he functor category is represented by the subdag whose w flue for the attribute c ~ t t is a Dag with atoi  ;  , 'ibut . esart and reszUta . nd whose ' c e . ~ zltare is reen -! rant with the value of the subdagrooted in  ) :0 . 
Thus , in the case of fig . 4, the functor category is zl .   2 At this point there is enough information on the zl node to uniquely det  , ermine the choice of a functor category , whereas the choice of an argument category would beeomplet ciyun const  . raired . When the ! exical entry for eve , "; t/cne(fig . 5a . ) unifies with the a:l node , the result is the Dagin fig . oh . ~ Then , at this point , the z2 node is fully enough instantiated to uniquely determine the choice of  . ~ miles ( fig . 5 e ) hom the lexicon . 
3 . 2 Non-min imal ly Type Ra ised Functors Now consider w\]'  , at , happens when non-quantified NPs like To ~ Tz are type-raised as in ~'\ [ on tague  ( 1974 )  . 
That is , suppose that the lexical entry for T or n is the Dagillfig  . 6 a rather than the lower type in fig . 6b . 
It turns out that if the typeraised NP is used , it will not be possible to constrain the choice of func-for in generation  . For example , fig . 7 a shows the rule of flmction application ( fig .  1 ) in which the z0 node has been unified with a start \] ) agappropriate . 
to generate Tom ~ miles . In fig . 7b , the zl node has unified with a type-raised entry for Hatred  , show- . 
ing that the start Dagh as done nothing to constrain the choice of functor  . Thus , a part fl-om introducing spurious ambiguity into the grammar  ( see Wittenburg 1987 for detailed discussion )  , the operation of typeraising , when used unconstrained , can also lead to considerable inefficiency in generation  . In order 2Alternatively , one could could simply take ?1 . to always be the functor since , given our use of the phon attribute , the order of xl and x2 no longer corresponds to linear order . 
aA problem that arises here is that the ~1 node in fig .   4 will also unify with the lexieal entry for s~r ~ iles  ( fig . 5c ) giving a nonsensical translation . Clearly , what needs to be done is to modify the semantic representations so that quantified expressions will not unify with non-quantified expressions  . One line that could be investigated would be to have a type system which distinguishes quantified and non-quantified signs as in 
Pollard and Sag (1987).
3  14   "7 ~ ~ pfOS " ~" ~~ lt 0 ' StmP smile ~ Ep/- , 4 harry
C .-~ oo
Psi
Figure 7: Generating Tornsmiles < , 2)  #tom ~ np ~ ~ ptom
Figure 6: Lexical entries for Totv , to constrain rite use of typeraising , we adopt the principle of minimal type a . ,sigament suggesl ; ed on independent grounds by Partee and Rooth (1( . )83) . 
Part:ee and Rooth argued for t , he principle of mini-real type assigament , to account fox " seop al properties of NPs in a variety of coordinate structures  . Among the examples they discussist the contrast between sentences sud ~ as  ( 2 ) a , ,d (3) . 
(2) Every student failed or got'aD.
(3) Every student failed or every student got a D.
(2 ) and ( 3 ) have different truth true if some students failed and while others got a D and did not would be false in that situat  , ion . 
point out that appropriate truth conditions . (2) is did not get aD , fail . (3), however,
Partee and Rooth conditions for ( 2 ) can only obtained if intransitive verbs are given a non-Wpe-raised in tter pretation and if their conjunction is represented by the k-abstract in  ( 4 )  . When ( 4 ) is combined with the translation for every student  , the desired reduced formula in (5) is obtained . 
(4: ) Aa\[fail ' ( a: ) VgoLa_D' ( z ) \]  ( 5 ) Vm\[student' ( z )   . . . . \[ failed'(ac ) v got , _~LD'(~ ; )\]l The use of conjoined type-raised predicates as in  ( 6 )  , however , would incorrectly yield the formula in (7) , which is appropriate for (3) but not for (2) . 
(6) v p(A z . go La_D'(z )) (7) V\[studnt , '()-, V
V0-\[student'()--+got,_a_D'(z)\]
On the other hand , Partee and Roothpoint ' out that for the interprc't  , a tion of sent tence such as ( 8 ) : intransitive verbs do ha . veto be Wpe-raised , since (9) is a paraphrase of (8) . 
(8) A tropical storm was expected to form offt . llecoast of Florida and did form there within a few days of the forecast  . 
(9 ) A tropicals t'orm was expected to form off the cc  , ast of Florida and Atropical storm did form there within a few day's of the forecast '  . 
In order to reconcile this conflict , Partee and Rooth propose that extension M intransitive verbs such as formed should be assigned t  , othelowest possible type and be type-raised only when t  , hey are conjoined with an intensional verb such as beez pected  . 
Given the principle of minimal type assignment , the entry for smile 3 fig .   5c will now be the main functor in generating the sentence To~ns ~  . .iles . It . can be seen that smiles ( and no other non-type-raised cat . -egory ) will unify with the zl node of fig . 7a . The resulting prediction is shown in fig . 7c . At this point the x2 node is constrained to unify with the minimal , non-type-raised entry fox:Torn(fig . 6 by . Thus , the principle of minimal type assignment urns out to be crucial tor constructing efficient generation algorithms for categorial-unification grammars  . 
3 . , 3 Allowing Type-Raising as Needed As seen in the previous section  , efficient generation requires the use of basic ( non-type-raised ) NPs , whenever possible . However , this is not't , osuggest'1484 a . .~~xC~x b . ~~ ~ ~ ~ np ~ c ~ ~
Figure 8: Type-Raising that the operation of type-rais ing can be eliminated from the grammar altogether  . For example , t , ype-raising needs to apply in the case of conjoined NP's such as Tom and every boy  . If we assume , as in Wit-tenburg (1986) , that and is assigned the category in (10) ,   4 then to parse or generate a conjoined NP like Tom and every boy the category for Torn will have to be raised so that its type will match that of every boy  . 
(10) ( XIX ) iX
What is needed then is sonle operation that will convert the non-type-raised entry for\[/bmin fig  . 6b to its raised counterpart in fig . 6a . One way of in-corporating the necessary operat ion into the grammar would be via the type-rais ing rule in fig  . 8a , in which the non-type-raised entry unifies with the xl node to yield the type-raised result at  z0   '5 t to wever , the problem with the rule in fig .   8a is that it will allow type-raising not just as needed but also anywhere else  . So the problem of spurious predictions like that  . in fig . 7 bree merges . 
Clearly , what is needed is some way of allowing type-rais ing only in those cases where it is needed  . 
Partee and Rooth suggest that typeraising should be constrained by some kind of processing strategy  ,   6 with ou ~ indicating how such a processing strategy  4We use a nondirectional calculus here , since word order is encoded into lexical items . The domain is to the right of tt~ebar and the range is to the left  . The capital X s represent a variable over categories  . This is just a schematic representation of a considerably more complicated category  . 
SNote again thai . , since phonology is encoded into lexical items , we can get by with a single rule of typeraising whereas most formalisms would require two  . The phonological counterpart of typeraising would be : ?  4 / ~ Partee and Rooth were actually more interested in psy-eholinguis?ic processing strategies  . Still their ideas carry over straightforwardly to computational linguistics  . 
can be implemented . It turns out that the processing strategy that Partee and Rooth suggest can be stated declar at iv cly as part of the grammar  , if the operation of type-raising is incorporated into a supercombinator  ( in the sense of Wittenburg 1987 , 89 ) that combines type-raising and function alappl ication into a single operation  . 
Wittenburg himself was interested in constraining type-raising in order to eliminate the spurious ambiguity problem of eombinatory categorial grammars  . 
He noted that in some of Steedman's (1985 , 1988 ) grammars typeraising was needed just in those cases where an NP needed to compose with an adjacent functor  , tie , therefore , proposed that the typeraising rule be included into the function composition rule  . The use of type-raising in coordinate structures that we have considered in this paper  , is quite similar : We want typeraising to be licensed  , just in case an NP is adjacent to a funet or that is locking for a type-raised argument  . We , therefore , incorporate type-raising into the function appl ication rule as seen in fig  . 8b . Now , the old type-raising rule in fig . 8 a is no longer needed , and spurious typeraising will no longer be a problem  . 
The type-raising supereom binator schema in fig . 8 b is , for example , used in the generation of cooldinate structure such as Tom and every boy  . Space will not allow us to fully present an analysis of such an NP here  , but . the important point is that a non-type-raised lexical entry such as that in fig  . 6b will be able to unify with the x2 node , and when it . does so , the subdag at the end of the path ( zl catart ) will become identical to the type-raised entry for Tom in fig  . 6a . 
4. Conclusion
In this paper we have argued t , hat a functor-driven generation algorithnl for categorial unification grammars leads to efficient natural language generation  , if the algorithm incorporates Part , ee and Rooth's ( 1983 ) principle of minimal type assignment . In order to have minimal type assignment and still allow typeraising in rest  . ricted contexts , we have adopted Wittenburg's ( 1986 ) idea of supercombina-5149 tors . Type-rMsing has been incorporated into the function application rule so that typeraising can only apply when some functor is looking for a type-raised argument  . This use of supercombinators to achieve semantic compatibility generalizes Wittm > burg's strictly syntactic application of these combi-nators  . 

Gerdemann , D . and Hinrichs , E .  1988 . UNI-CORN : a unification parser for attribute -value grammars  . Studies in the Linguistic Sciences , 18(2): 41-86 Karttunen , L .  1986 . D-patr : a development environment for unification-based grammars  . In

Montague , R .  1974 . The Proper treatment of quantification in ordinary English  . In R . Thorns-son(Ed . ) ,   \]7ormal Philosophy : Selected Papers of Richard A . ~ontague , Yale University Press,
Newtaven.
Partee , B . and Rooth , M .  1983 . Generalized conjunction and type ambiguity . In R . Bauerle , C . 
Schwarze , and A . y on Stechow ( Eds . ) , Meaning , Use and Interpretation o/Language ,  361-383 , Walter de Gruyter . 
Pollard , C . and Sag , I .  1987 . An Information-Based Approach to Syntax and Semantics : Volume iF undamentals  . CSL\[Lecture Notes No .  13,
Chicago University Press , Chicago.
Shieher , S .  1988 . A uniform architecture for parsing and generation  . In COLING-88, 614-9 . 
Shieber , S . , van Noord , G . , Moore , R . C . , and Pereira , F . C . N .  1989 . A semantic-head-driven generation algorit , hm for unification-based formalisms . In ACL Proceedings , 27th
An . nual Meeting , 717.
Steedman , M .  1985 . Dependency and coordination i the grammar of dutch and english  . Language , 61:523-568 . 
Steedman , M .  1988 . Combinat . or s and grammar . In R . Oehrle , E . Bach , and D . Wheeler ( Eds . ) , Categorfal Grammarar , ,d Natural Language Structures ,  417-442 , Reidel , Dordrecht . 
Uszkoreit , H .  1986 . Categoria tunification grammar . 
In COLING-86.
Wall , R . and Wittenburg , K .  1989 . Predictive normal forms for composition in categorial grammars  . 
In Proceedings of International Workshop on
Parsing Technologies , 152-161.
Wittenburg , K .  1986 . Natural Language Parsing with Cornbinatory Categorial Grammar in a Graph-Unification-Based For rnalism  . PhD thesis , The University of Texas at Austin . 
Wittenburg , K .  1987 . Predictive combinators : a method for efficient parsing of combinatory c~t tegorial grammars  . In Proceedings of the 25th Annual Meeting of the Association for
Computational Linguistics , 73-80.
Zeevat , H , Klein , E , and Calder , J .  1987 . Unification categoriM grammar . In N . Haddock , E . Klein , and G . Morrill ( Eds . ) , Edinburgh Working Papers in Cognitive Science ,  195-222 , Centre for Cognitive Science , University of Edinburgh . 

