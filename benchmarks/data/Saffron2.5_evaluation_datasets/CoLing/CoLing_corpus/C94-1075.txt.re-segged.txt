A MODUL ARARCHITECTURE
FOR CONSTRAINT-BASED PARSING
Franco is Barthdlemy ~" Fran ( ; o is Rouaix 0
0 INRIA Roequene our t , BP 105 , 78153 Le Chesnay cedex , France
& Universidade Nova de Lisboa , 2825 Monte de Caparica , Portugal

This paper presents a framework and a system for implementing  , comparing and analyzing parsers for some classes of Constraint-Based Grammars  . 
The framework consists in a uniform theoretic description of parsing algorithms  , and provides the structure for decomposing the system into logical components  , with possibly several interchangeable implementations  . Many parsing algorithms can be obtained by compositi  ( m of the modules of our system . Modularity is also , ~ way of achieving codesharing for the common parts of these various algorithms  . Furthermore , tile design lielpi ~ reusing the existing modules when implementing other algorithms  . The system uses the flexible modularity provided by the program-mifig languages  hleool-90  ,  1 ) ased on a type system that ensures the safety of module composition  . 
1 INTRODUCTION
We designed a system to study parsing . Our aim was not to implement only one parsing algorithm  , but as many as possible , in such a way that we could compare their performances  . We wanted to study parsers ' behavio rather than using them to exploit their parses  . Furthermore , we wanted a system opened to new developments , impossibh ~ to predict at the time we began our project  . 
We achieved the seaims by detining a mo ( lular architecture that gives us in addition code sharing between alternative implementations  . 
On r system , called APOC-II , implements more than 60 ditferent parsing algorithms for ContextFree Grammars  , Tree-Adjoining Grammars , and Definite-Clause Grammars . The different generated parsers are comparable , because they are implemented in the same way , with common data structures . Experimental comparison can involve more than 20 parsers for a given grammar and give results independent from the implementation  . 
Fnrthermore , adding new modules multiplies them Hnber of parsing Mgorithm  . A POC-II is open to new parsing techniques to such an extent that it can be seen as a library of tools for parsing  , including constraint solvers , lookahead , parsing strategies and control strategies . These tools make prototyping of parshlg algorithms easier an  ( lqui ( :ker . 
The system is I ) ase ( 1 on a general framework that divides parsing matters in three different tasks  . First , tl , e compili ~ tion that translates a grammar into a pushdown automaton  ( tescrib-ing how a parse tree is built . The automaton can be non-determinlstic if several trees have to bee on sider e  ( l when parsing a string . Second , the interl ) retation of the pushdown ~ m tomaton that has to deal with nondeterminism  . Third , the constraint solving , used by 1 ) otheom i ) ilation and interpretation to perform operations related to constraints  . 
Several algorithms can perform each of these three tasks : the compiler can generate it her topdown or bottom-up automata  , the interl ) reter can make use of backtracldngor of tal ) ulation and the solver has to deal with different kinds of constraints  ( first-order terms , features ,   . . .  ) . 
Our architecture allows different combinations of three components  ( one for each basic task ) resulting into a specific parsing system . We use the Alcoo\[-90 progranmfing language to implement our mo ( hlles . This language's type system allows the definition of alternative implementations of a conlponent and enmlrest he safety of module cond  ) ination , i . e . each module provides what is need e ( 1 by other mo ( lules and re ( : eives what it requires . 
The same kind of modularity is used to split the main components  ( conll ) iler , interpreter , solver ) into independents nb-modnles . Some of these submodules can bcs hared by several different implementations  . For instance the coml ) utation of lookahead is the same for LL ( k ) and LR ( k ) techniques . 
The next section defines the class of grammar we consider  . Then , ~t general framework for parsing and the sort of modularity it requires are presented  . Section 4 is devoted to the AIcool-90 language that provides a convenient module system . 
Section 5 is the detailed description of tile APOC-using Alcool-90  . 
2 CONSTII . AINT-BASEDC ~ RAMMARS
The notion of Constraint-Based Gramm~traii-ile ~tredill computational linglfistic  . It is rt useful all straction of several classes of grammars  , in elud-hlg the most commonly used to describe Natunt IL anguage in view of CO mlmter processing  . 
Wo give our own definition of constraint-lmsed grammars that may slightly differ from other definitions  . 
Definition 1   ConstTnint-11ased Grammar A constraint-based grammar is a 7-tuple Nt , T ,  (~ , V , Am , CL , R where ? N t is a set of symbols called nonterminals ?  7' is a set of symbols called terminals ? a is af lmetion fromNtO  7' to then at m ' a lintegers called the arity of the symbol  , s ? V  is an infinite set of variables ? Aa : is an element of Nt called the a:dom ? CL is a constraint language  ( see definition be-loin ) having V as variable set and being closed it ~ ' t dere naming a ~ td conjunction ? R is a finite set of rules of the form :-  ,  (2 '  ,  )  .   .   .   .   ,  <2; , ) such that so EN t , sl~NtU 7' for 0 < i_ < . n , ceCL , X i are tuples of ( t(sl ) distinct va , ' i-ables , and the same wwi abIe cannot appear in two different tupIes  . 
in this definitio , t , we use the notion ( if con-straint language to define the syntax and the semantics of the constraints usod  1  ) y the grammars . 
Wo refer to the definition given IiyH/Sfcld and Smollmin\[  ITS88\]  . This detinition is especially suitable for constraints used in NLP  ( unrestricted synt*tx , multiplicity ( if interpretation donmins ) . 
The closure under renaming property has ~ tl so 1lees detined by IIS feld and Snlolka . It ensure stlt~tt constraints are independent from the variable names  . This grmt nds the systematic renaming of grammar ules to avoid w triallle conflicts  . 
Definition 2 Constrnint Language
A constraint Language is a 4-tuple ( V , C , u , I ) such that : ? V is an infinite set of variables ? C is a decidable set whose elements are called constraints ? u is fanction that associates a finite set of variables to eaeh constraint ? I is a nonempty set of interpretations Ii ' or bt <: k of Slm<:e we < lo not recall in detail what itll in terpret & tiollJill  ( the "<' losurolll del " I' ( !IlH . III~ing " pr <) perty are , and refer to \[ IIS88\] . 
The semantics of Constra . int-Based Gnmmlars is defined by the . '-; (? lllalltics of the constra . int language ~ tll(ll , honotion of syntax tree . A synta . xtrce is a tree which \]ms at grammt tr rule ( remt med with fi'es hv ~ triables ) a slatmlofe a . chnodo . A constraint is associatted to at parse tree : it is the conjunction of all the constr~dnts of the labels and the oqualities between the tUllle of w triables from the non-termilm l  , if the loft-hand side of a label and the tlq ) le of there lew mt symbol of tim right > h and side of timl ~ dml of its p~trent  . 
An hn portantlloint ~ dmut p ; trse trees is tlt*tt the ordor of terminal symbols of tll  ( ~ ini ) ut string and the order of the symhols in riglt-h ; md sides of rules are signitica . nt . 
A Context Free Gramma , r is obtained just by , ' omoving tutiles and constr~dntsfl ' om tho grammar rules  . Mosti ) m'sing techniques for Constraint-Bas ( ~d Grain mars use the underly illg context-fro ( ! structure , to guido parsing . This allows the , ' euse of cont . ext-fl ' eelntrsing tccl , niques . 
TIog ~ r ; tllllll ; H's wo hltve just definod OIICOIII-pass several classes if i  ; r & lllll ; tr sllSO dill N\] ,  \ ] ) , including log ; it p ; l ' amlttlal ' S ( Definite Clause Cram-mars and variants )  , UIlifica ~ tionCramlmtrs , Tree Adjoining ( h'ammars I and , at least p~tr tially , i , exical-I ; ' unctioval C~l ' ~ tllllHli's ; ilia I/oralPhras(~~ . I ' IIC ~/ . III '(~( . * fl'~lllllllLl'S . ()1"(' OllI'S(~1t , h(!r ( ~ ; tl ' ( ~ syn-tactical differ ( mces 1 ) (~twe ( m these ( : lassosaltd Constraint-Based ( ll ' amlmU'S . A simplet : rans la . -t . ion\['r () lllon(?syntaxt,/) . he ( ) th(,risn(~(:essary . 
3AGENF.RAI,\]?RAME WOIKFOIl.

This section is devoted to it general fralnew or k for iiar singill which most of the i  ) arsing in ethods , in chlding ~ all the l nost CO tllll Otl OliOS , ar(\]express-ible . It is ; in extension of ~ contoxt-freoframo-work\[ Lan74\]  . it is based on an explicit separation lletween thoparsing strategy that descrilies how ITAGs have an underlying context-free structure  , although this is not ol ) vi ( ms in their form M definition . See for instance \[ I , angl\] . 
455 syntax trees are built ( e . g . top-<lown , bottom-Ill )) , and the control strategy that < l cals with the nondeterminism of the parsing  ( e . g . backtracking , tabulation ) . 
3.1 EPDAs
This separation is based on an intermediater presentation that describes how a grammar is used following a given parsing strategy  . This intermediate representation is a Push-Down Automaton  . It is known that most contextfree parsers can be encoded with such a stack machine  . Of course , the usual formalism has to be extended to take constraints into account  , and possibly use them to disambiguate the parsing  . We . call Extended Push-Down Automaton ( EPDA ) the extended formalism . 
For lack of space , we do not give here the formal definition of EPDA  . hf formally , it is a machine using three data structures : a stack containing at each level a stack symbol and its tuple of variables  ; a representation f the terminal string that distinguishes those that have already been used and those that are still to be read  ; finally a constraint . A configuration of an automaton is a triple of these three data  . Transitions are partial fimctions from configurations to configurations  . We add some restrictions to these transitions : the only clmngeal lowed for the string is that at most one more terminal is read  ; only the top of the stack is accessible and at most one symbol can be added or removed from it at once  . 
These restrictions are needed to employ directly the generic tabular techniques for automata execution described in \[  BVdlC92\]  . EPDAs may be nondeterministic, . e . several transitions are applicable on a given configuration  . 
Parsing for Constraint-Based Grammars blen ( ls two tasks : ? The structural part , that consists in buihling the skeleton of parse trees  . Thisl ) art is similar to a contextfree parsing with the underlying contextfree projection of the grammar  . 
? Solving the constraints of this skeleton.
The two tasks are related in the following way : constraints appear at the nodes of the tree  ; the structure is not a valid syntax tree if the constraint set is unsatisfiable  . Each task can be performed in several ways : there are several contextfree parsing methods  ( e . g . LL , LR ) and constraints sets can be solved globally or incrementally  , using various orders , and several ways of mixing the two tasks are valid  . Tree construction involves a stack mechanism , and constraint solving results in a constraint . The different parsing teel miques can be described as computations on these two data structures  . EPDAs are thus able to enco<le various l ) arsers for Constraint C~ram-nlars . 
Automatic translation of grammars into EP-DAs is possible using extensions of usual contextfree teel miques\[  Bar93\]  . 
3.2 ARCIII'r ECTUP = E
Thanks to the intermediate representation ( EPDA ) , parsing can be divi<led into two independent passes : tile compilation that translates a gran lnlar into an extended autonlaton  ; timexecution that takes an EPDA and a string and pro-due es a forest of syntax trees  . To achieve the independence , the compihw is not allowed to make any assumptions about the way the automata it produces will lie executed  , and the interpreter in charge of the execution is not allowed to make assumptions about the automata it executes  . 
We add to this scheme reused from contextfree parsing a thir<l component : the solver  ( in an extensive meaning ) in charge of all the oi > erations related to constraints and wu'iables  . We will try to make it as in < lel ) en < teilt from the other two modules ( compiler and interpreter ) as possible . 
There is not a fidlin < lependenee , since both the compiler and the interpreter involve constraints and related operations  , that are : l ) er for n md by the solver . We just want to define a ( : lear interface between the solver and the other modules  , an interface independent from the kind of the constraints and from the solving algorithms being used  . rl ' be same coml ) iler ( resp . interl ) reter ) used with different solvers will work on ditl ' erent classes of grammars  . For instance , the same compiler can compih ~ Unilh : ation Grammars an<l Definite Clause Grammars  , using two solvers , one implenmnting feature unilieation , the second one iml ) lementing tirst-order unilieation . 
We can see a complete parsing system as the eoml ) ination of three modules , compiler , inter-prefer , solver . Whenea (: h module has several implementations , we wouhllike to take any combination of three modules  . This schematic abstraction captures l ) arsing algorithms we are interested in . However , actually defining interfaces for a practical system without restricting open-endedness or the abstraction  ( interehangeability of components ) was the most difficult technical task of this work  . 
456 3.3 SOLVERS
The main problem lies in the dclinition of the solver's interface  . Some of the required ol ) era-lions areol ) vious : renaming of constraints and tul ) les , constraint l milding , extraction of the vari-al ) les from a constraint , etc . 
By the way , remark that constraint solving can be hidden within the solver  , and thus not appear in the interface . There is an equivalence relation between constraints given by their interpretations  . This relation can lie used to replace a constraint by another eqniwdent one  , l ) ossibly siml ) ler . The solving call also be explicitly used to enR ) ree the simplification of constraints at some points of tile parsing  . 
Unfortunately some special techniques require more specific operations on constraints  . For instance , a family of parsing strategies related to Earley 's algorithmm ~ tke use of the restrictio ~ operator defined by Shieber in \[  Shi85\]  . Another ex-aml ) le : some tabular techn i ( luestake Benetit from a projectioil operator that restricts constraints with respecto a subset of their variat  ) les . 
We . could define the solver's inte . rf ace as the cartesian product of all the operations used by  ; tt least one technique . There are two reasons to recot such an apI ) roaeh . The first one is that some seldom used operations aredit li  ( : ult to de-line on some constraints domains , it is the case , among others , of tile projection . The second reason is that it woul ( \[ restrict to the techniques a I : ready existing and known by us at the moment when we design tile interface  . This contradicts the open-endedness requirement . A new ollera-tion can appear , useful for a new parsing method or for optimizing the old ones  . 
We prefer a flexible detlnition of the interface.
Instead of defining one single interface , we will allow each alternative in iF , lenlentation of the solver to define exactly what itol\['ers and eachiml  ) h~-nmntation of the compiler or of the interpreter to detine what it demands  . The conll ) ination of modules will involve the checking that the@r <'  . rencompasses the demand , that all tile needed operations are implemented . This imposes restrictions on the combination of niodules : it is the overhead to obtain an open -ended system  , opened to new developments . 
We found it language providing the . kind of l lex-il ) le modularity we needed : Al cool --90 . We now present his language . 
4'\]' IIEL ANGUAGE ALCOOL 90
A lcool-90 is an experimental extension of the functional anguage ML with runtime overload-ing\[  Iou90\]  . Overloading is used as a tool for seamless integration of abstract data types ill the ML type system  , retaining strong typing , and type inference proller ties . Abstract data types ( encapsulating a data structure representation and its constructors ~ uld interpretive flmc-tiol  , s ) i ) rovidew dues for overloaded symbols , as classes provide methods for messages ill object-o  , ' ient cd terminology , iowever , strong typing means that the compiler guarantees that errors  ( ) f kind " method not found " never hal ) pen . 
Abstract programs axe programs referring to overloaded syml  ) ols , which vahles will be deter-nfined at runtime , consistently with the calling environment . By grouping Mlstract l ) rograms , we obtain parameterized abstra . ct data types ( or fllnctors ) , the calling environment being here a ~ particular instantiation of the I  ) arameterized adt . 
Thus , we obtain Jut environment equivalen to a module system  , each module being an adt , eventually llarameterized . 
D ) r instance , illAPOC-II ,   ( : ompilers h~tve an abstract data type parameterized by a solver  . 
A lcool-90 also proposes an innow ~ tiven viron-ment where we exploit anlbiguities due to overloading for semiautomated  1  ) rogram configuration : the type iuf in ' elice e oullnltes interfaces of % llissing " COIll pollents to colnplete a progralll  , ae-cording to the use of overloaded synlbols in the program  . A search algo , ' it hm finds components satisfying those interfaces  , eventually by tind-ing suitable parameters for parameterized components  . Naturally , instantiatiot , of parameterized coml ) onentsi also type-safe : actual parameters must have interfaces matching formal parameters  ( schematically : the actual parameter must provide at least the functions required by the interface of the formal parameter  )  . 
For instance , only the solvers provi(lil , gShieber's restriction can ) e used as the . aetlial pa . -ramcter of Earley with restriction compiler . But these solvers can also be ' . lse(ll ) ya . ll the eoml ) ilers that do not use the restriction . 
Simple module systems have severe limitations when several implementations of components with simil ~tr interfaces  ( : ( ) exist in a system , or when some component Inay be employed in different contexts  . Ada generics provided a first step to l nodule parameterization  , th(m ghat the cost of heavy declar ~ tions a . nd difficulties with type equiw dence . SML pral ) oses a very powerful module system with paranleterization  , but lacks separate comllilation and still requires a large amount of user decl ~ u ' ations to detine and use functors  . 
Object-oriented languages lack the type security that  Alcoo\[-90 guarantees . 

The Alcool-90 approach benefits from the simplification ot modules as abstract data types by adding inference facilities : the compiler is able to infer the interfaces of parameters required by a module  . Moreover , the instantiation of a functor is simply seen as a type application  , thus no efforts are required from the programmer , while its consistency is checked by the compiler . 
This approacl , is mostly useful when multiple implementations with similar interfaces are available  , whether they will coexist in the program or they will be used to generate several configurations  . Components may have similar interfaces but different semantics  , although they are interchangeable . Choosing a configuration is simply choosing fl'om a set of solutions to missing emn-ponents  , computed by the compiler . 
Several other features of Alcool-90 have not linen used in this experiment , namely the inheritance operator on abstract data types  , and an extension of tile type system with dynamics  ( where some type checking occurs at runtime )  . 
5 APOC-II
A POC-II is a system written in Alcool-90 , implementing numerous parsing techniques within the framework described in section  3  . The user can choose between these techniques to buihla parser  . 
By adding new modules written in Alcool-90 to the library , new techniques can freely be added to the system . 
A POC-II has two levels of modularity : the first one is that of the three main components distinguished above  , compiler , interpreter and solver . 
Each of these component si implemented by several alternative modules  , that are combinable using Alcool-90 discipline . 
Tile second level of modularity consist in split -ring each of the three main components i  , l to sev-er a . 1 modules . This makes the sharing of common parts of different hnplementations possible  . 
We give now examples of splitting APOC-qluses at the moment  , in order to give an idea of this second level of modularity  . This splitting has proved convenient so far , but it is not fixed and imposed to fllrther developments : ~ tnew implementation can be added even if it uses a completely different internal structure  . 
A solver is made of : ? a module for w triables , variabh : generation and renaming , ? a parser for constraints , ? a pretty-printer for constraints , ? a constraint builder ( creation of abstract syntax trees for constraints  , e . g . building constraints expressing equality of variables  )  , ? a solver ill the restrictive meaning , in charge of constraint reduction , ? an interface that encapsulate all the other modules  . 
A compiler includes : ? a grammar parser ( that uses tile constrMnt parser given by the solver  )  , ? a module for lookahead ( for computation of lookahead sets by static an Mysis of the gram- 
I\[lar ) , ? a module for EPDA representation and handling , ? ~ t transition generator which translates grammar rules into EPDA tra  . nsitions therefore de-tern fining the p~trsing strategy  ( cf . figure 1) , ? Control code , using previous modules , defining the " compih ?' function , tile only one exported . 
The two interpreters implemented so far have very different structures  . The tlrstone uses backtracking and the second one uses tabulation  . 
They share some modules however , such as a module handling transitions and a lexer of inlmt strings  . 
Tile interest of the modular architecture is in tileeomt fin~t to rhtl effect of module composition  . 
It leads to many diiferent parsing algorithms.
The tigure 1 summarizes the different ~ spects of the parsing algorithms that can vary more or less independently  . 
For example , the builtin parsing method of Prolog for DCGs is ol~t  . ained by combining tim solver for \]) CGs , the topdown strategy , 0 symbol of lookaheada . nd a backtracking interpreter ( and other modules not mentioned in Iigure 1 because they do not change the algorithm , but a . t most its implenm ntation ) . 
Some remarks about : figure 1: ? we call Earle ?\] parsing strategy the way Earley deduction \ [  PW8a \] builds a tree , * tot the control method it uses . It difl'e . rs from topdown by the way constrMnts are taken into account  . 
? the difference between garley-like tabulation and graph-structure stacks is the data structure used for item storage  . Several variants are possible , that actually change the parser's behavior . 

Solver Context-t Yee Grammars -1 ) etinite Clause Grammars ( grammar class ) Tree Adjoining Grammars-Uni \] ication Grammars  .   .   . 
parsing strategy top-down-pure bottom-up- Earley-Earley with restriction  ( transition generator ) left-corner-LR-precedence-PLR .   .   . 
lookaheade on text-lYee look-ahead of 0 or 1 symbol context-free lookahead of k symbols - contca't-scnsitiv clookahead interpreter backt racking-Earley-like tabulation-Graph -str ' actur cdStacks  .   .   . 
Agenda management Synchronization-lifo-fi fo -wL rio ' as weights  .   .   . 
( for tabulation only )
Figure 1: modules of APOC-II
Modules written iii . bold fontare ah'eadyiml ) lemented , where . as modules written in italicm'e possible extensions to the system  . 
? we call synchronizations L kind of breadth-first se ~ trch where sc~tnnlnga terminal is performed only whe  . n it is needed by all the paths of the search -tree  . The search is synchronized with the . input string . It is the order used by l , ; str-h . ' y's algorithin . 
? at the moment , only generic lookahead , that is look-a hest d based on the first and fol low sets  , has been considered . Some more a CCll-rate lookahead technique such as the ones involved in SLR  ( k ) pa , ' singare probal > ly not indepen < lentfi ' om the parsing strategy and <: armor be an independent mo < lule  . 
Building a parsing system with APOC-II consists roughly in choosing one module of each row of figure  1 and combining them . Some of the combinations are not possible . Thanks to type checking ,   Alcool-90 will detect the incompatibility and provide at yl ) e-based explanation of the probh ; m . 
At the moment , APOC-II ot Drs more than 60 ditDrent parsing algorithms . Givenag , ral rHn . % r , there is a choice of more than 20 different parsers . 
Adding one module does not add only one more algorithm  , but sewn ' Mnew vstri ; tltts . 
The techniques i inplemented by APOC-II are not original  . For instance , the LR conq ) ilation strategy comes from a paper I ) yNilss on , \[Nil 86\] , left-corner parsing has been used 1 ) y Matsumoto and Tanaka in \[ MT83\] . As far as we know , however , LR and left-era'herp ~ trsers have not been prolmsed for Tree-Adjoining C  , rammars before . 
Notice that the modularity is also useful to vary implementation of algorithms  . D ) r instance , a first prototype can be quickly written by implementing constraints reduction in a naive way  . A refined version can be written later , if needed . 
6 CONCLUSION
A POC-II has several advantages . First of all , it provides comparable implementations of the most comnmn parsing Mgorithms  . Their efficiency can be abstractly measured , for instance by counting the number of eomlmtation step  ( EPDA transition applicatiol 0 performed to eomlm tea tree or a complete forest of parse trees  . We call this kind of measm'ements abstract \] ) e call se it does not rely neither on the implementlt tionnor on the machine that runs the parser  . Other comparisons could be done statically , on the automaton or on the pstrse forest ( e . .g . number of transitions , all lOllllt , ) f determi ~ l is nl , size of the forest , all lOll llt of structures lurring ) . 
()therwise , APOC-II cstnbe . used as a to ( ~ lkit that provides : t library of modules usefld to imple-lllent quickly ll  ( !W parse . r generators . For instance , one has only to write a solver to obtain up to 22 parsing a . lg or ithms ( perhaps less if t it (' , solw ! r provides only basic operations ) . The library contains tools to deal with some constraints  , lookahead , lexing , tabulation , etc . Reusing these tools whenever it is possible saves a lot of work  . 
The limitations of APOC-II are that it is mainly convenient for parsing strategies that stre somehow static  , i . e . statically determined at com-pih ! time . Also , al ) stract loll ( full independence between coral > tiers and i , ~terpreters ) cannot Im achieved for some optimized algorithms . For in-Sl , & ll Ce , Nederhof presents in \[ Ned93\] a parsing strategy called ELI for which tsdmlar execution can be optimized  . To implement h is a . lg or ithm ti to llr system , one would have to write a I low interpreter dedicated to ELR-EPDAs  . 
\? e think that our experiment shows the in-t ( ~ rest of at lexible modul ; trity for studies a bollt parsing . We believe that the same technique can fiuit fully apply on other domains of Ns ~ tural Language Processing  . 
4, 597 ACKNOWLED GEMENTS
The authors are grateflfl to Gabriel Pereira Lopes for his hell  )  . 
REFERENCES\[Bar93\]FranqoisBarthdlemy . Out ils pour l'3-nalyse syntaxique contextuelle . Thb~-sededoetorat , Universitd ' Orldans , 1993 . 
\[BVdlC921F . Barthdlemy and E . Villemonte de 13 Clergerie . Subsnmption--oriented pushdown autom 3 t3, hi
Proe . of PLILP'92, pages 100114, june 1992.
\[II 8881 M . It Shfeld and G . Smolk 3. Definite
Relations over Constraint Languages.
Technical Report 53, LILOG , IWBS,
IBM Deutschl and , october 1988.
\[Lan74\] Bernard Lang . Deterministic techniques for efficient non-dc ' terministic parsers  , hiProe . of the 2' ~' l Colloquium on automata , languages and
Prv gramrning , pages 255-269 , Saar-brlieken ( Germany ) ,  1974 . Springer-
Verlag ( LNCS 14).
\[Lan91\] Bernard Lang . The systematic construction of earley parsers : Application to the production of o  ( na ) earley parsers for tree adjoin in grammars . 
In First International Workshop on
Tree Adjoining Grammars , 1991.
\[ MTSal Y . Matsumoto and H . Tanaka . Bup:
A bottom-up3rser embedded in In'O-log . New Generation Computing , 1:145-158, 1983 . 
\[Ned93\] Mark-Jan Nederhof . A multidisei-plin3ry approach to 3 parsing algorithm . In Proceedings of the Tvmntc
Workshop on Language Technology-
TWLT6, december 1993.
\[Ni 1861 Ulf Nilsson . Aid : An Mternative implementation fDCGs . New Generation Computing , 4:383-399, 1986 . 
\[ pwsa\]F . C . N . Pereir 3 and D . II . D . Warren . Parsing as deduction . In Proc . of the 21st Annual Meeting of the Association for Computationnal Linguistic  , pages 137-144 , Cambridge ( Mas-sae hus setts) ,  1983 . 
\[ Rou90\]\[Shi85\]
Franqois Rouaix .   ALCOOL-90: Ty-page de 13 surcharged on sunlangave fonetionnel . ThSsededoctorat , Uni-versitd Paris 7, 1990 . 
Stu3rt M . Shieber . Using restriction to extend parsing algori-thms for complex--feature--based formalisms  . In Proceedings of the 23 r'~
Annual Meetin 9 of the Association for Computational Linguistics , pages 145-152 , Chic3go ( Illinois ) ,  1985 . 

