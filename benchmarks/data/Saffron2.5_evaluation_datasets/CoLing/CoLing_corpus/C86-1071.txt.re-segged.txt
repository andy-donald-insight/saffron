\]' HE < C , A> , TFRAME WORKINEUROTRA : ATHEORETICALLY COMMITTED NOTATION FORMT 
n . J . Arnold:

fl . Rosner :
L.des Tombe:
G . B . Varile:
University of Essex , Colchester , Essex , CO43S ~ , UK . 
University of Utrecht , Trans 14 , 3512 OK Utrecht , NL . 
ISSCO ,  54 , Routedes Acacias , 1227 Geneva , Switzerland . 
University of Utrecht , Trans 14 , 3512 3K Utrecht , NL . 
Commission of the European Communities , L-292 ~ Luxembourg . 
A~s ~ tr_acL.
This paper " describes a model fur MT , developed within the Eurotra M\[project , based on the idea of r . o_omj \] osi-tional translation , by describing a basic , experimental notation which embodies the idea . The introduction provides background , section 1 introduces the basic ideas and the notation , and section 2 discusses some of the theoretical and practical implications of the model  , including some concrete extensions , and some more speculative discussion . 
As Kay (1985) has emphasised , machine translation today is always experimental in nature  . We think a number " of things follow from this , among them the need for clear and rather strong theoretical princip-les which can be treated as hypotheses for testing  . 
The idea is , nf course , that such testing is revea-lingir respective of the confirmation or disconfirma-tion of the hypotheses  . Furthermore , especially where projects of considerable size are concerned  , clear and explicitely stated theoretical principles are necessary for the ~  ommoi2 understanding of the problem . 
We assume that it is possible to distinguish a number of different levels of description for MT theories  ( programmes , systems , etc ) , where in general , the relation between levels is that lower levels are motivated  , or evaluated with respect to higher levels . The aim of this stratification is to introduce a kind of modularity  , so that it is possible to preserve stability while responding to changing perceptions of ' the MT problem '  . We distinguish the fol-lowing levels of description : MuB : A set of executable programs  , and descriptions of a set of languages and the relations between them  . 
Mul : A set of substantive theories of representation  , and a set of languages in which linguistic descriptions are expressed  . 
Me2: The basic theory of translation , general theory of ( linguistic ) representation & computational apparatus . 
Mu 3: The basic principles , aims , goals , characteristic assumptions , the ' spirit ' of the enterprise . 
The purpose o ~ the paper is to discuss the Mu2 level , concentrating on the basic theory or model of translation  . T be approach will be to describe a family of abstract  , special purpose ' MT machines ' by describing the syntax and semantics of a very basic notation for MT  . We will make some assumptions about representation and user languages for concreteness  , but they will be simplified , and unrealistic in the main . Next we examine the model of translation by making explicit some of the theoretical commitments implicit in the notation  , discussing some its attractions , and weaknesses , and sketching some possible remedies for the lat ter  . Section 1 will present the notation , with some relevant background , section 2 will discuss the commitment he notation makes . 
L ~_\[EE_EELEE\[_!, odel of translation.
The ideas described in this section were firs t presented at the the Colgate Conference on Methodological Issues in MT  ( Arnold et al DesTombe et al 1985 )  . A key idea in what follows is an interpretation of the idea that translation is a ' compositio -nal'process  . To our knowledge , the first application of this idea in MT is in the work of Jan Lands-bergen in the Rosetta project  ( of L and s bergen 19 B 4 )  . 
The fundamental problem of MT is to find a notation  , with an associated interpreter , for describing the translation relations between texts in different languages in a ' natural ' way  . Since it seems impossible to provide such a notation for relating texts to texts directly  , the standard response is to decompose the problem ' horizontally ' into a sequence of steps  , as in: ( I ) TLG---RLI ~ ~- RL2---RL3 .   .   . RLn . . . . TL T where TLs and TLT are source and target text languages  , and the RLi are representation languages ( or levels of representation , as they are often called ) of some sort .   ( Notice that in what follows me will systematically use the term ' language ' ambiguously for both natural languages and representation languages  )  . Giw ! n such a picture one naturally thinks of the languages that are input and output of transfer  , but far the purpose of this discussion they could be any pair of representation languages at all  . What is crucial to this discussion is the assumption that MT characteristically involves more than one representation language  . This point is worth stressing . The following discussion will be couched in terms of a representational theory  ( Mull that involves several specific levels of representation  . 
We believe that this is motivated , but the interest of the general model in no way depends on the existence of these levels  . 
Given this , one is obviously lead to consider ( a ) the nature of the representation languages , and ( b ) the nature of the relations between the representation languages themselves  , and between the representation languages and the text languages  . 
We will not discuss the nature of the representation languages here in any detail  ( see Arnold et al  #anuary 1985 , for detailed discussion ) , hut it seems important that they should he : is to preserve whatever properties are preserved under "' correct translation '  . If two ( unambiguous ) texts are not translation equivalents i . e . if they differ ~ ith respect to these properties , then the representation languages must be rich enough to provide different representations for them  . 
( ii ) Learnable ( specific and indepmndently defi-nable ) : By ' learnable ' we means imply that it must be possible fat " linguists  ( who eust state the relations between a language and its neighbeurs  , ultimately in the farm of an executable description  ) to be able to understand that relation : for any given text they should be able to determine the appropriate representation  , and vice versa : the intuitive semantics of the representation language should be accessible to them  . This normally means that the representational theory should be rather specific and constrained  . It also means that an independent specification of the language should be available  . To take the most pro-blematic case , consider the writer of the generation component in a multilingual MT system  , where the only definition of the input representation language is that provided by the transfer components themselves  . 
The task seems clearly impossible.
( iii ) ~ E_EELE ~ E ~_E ; Tb is is the most straightforward , and the most commonly appealed to requirement for the adequacy of representation languages  . It must at least be easier to relate the representation languages than it is to relate the text languages  . 
It is this requirement that usually rules out naturallenguages  ( e . g . Latin ) as representation languages , and motivates representation languages which are highly structured  . 
We will not be concerned oith particular representation languages that have been proposed in Eorotra but  , for the purposes o exposition , it is worth a brief description of the ~ ind of representation languages  ( levels ) we will assume in what . follows . We will assume there are three such languages ( apart from levels such as actual , and normalized text ) :  ( a ) A surface constituent/morphological structure level of a rather standard kind  , allowing more than one x-bar projection of the major lexical categories  ( see Arnold et al ~ anuary 1985 )   . This level is usually called ECS ( Eurotra Constituent Structure )  . 
( b ) filevel which represents syntactic relations or dependency  , and information about syntactic category . 
This level involves structures where each ( non-co-ordinate ) construction contains a primitive item which is the head  , or governor ( ' gov ' ) of the other elements of the construction ( this amounts to a sti-pulation that there can be no more than one projection of lexical categories : XI syntax  , in effect ) . 
This level is usually called ERS ( Eurotra Relational
Structure).
( c ) A level which represents semantic relations/de -pendency  , and thus contains an indication of semantic relations  ( case or : beta roles )  . Like the syntactic relational level , we will take this to be a nXI level , it is intended to abstract away from surface syntactic phenomena that are net relevant to translation  , and to reinterpret some syntactic characteristics semantically  ( egg . replacing tense marking by an indication of time reference  )  . This level is normally interface between analysis and transfer  , and transfer and generatinn components ? Turning now to the relations between ttlese languages  , as regards the text <-> representation language rola-tion  , there is very little to say in an HT context that does not arise elsewhere in computational linguistics  , where parsing and generation are two of the major areas of research  . It is the relation between the representation languages that concerns MT speci-fically  . We think the falloeiog three conditions are important :  ( i ) compositimnality ( ii ) directness ( primitiveness , ' one-shut-ness ' )   ( iii ) simplicity ( statable in a ~ imple way ) Idioms apart , the translation of complex expressions is normally based in some systematic may on the translations of their parts--normal translation is in some sense ' co  , n ~ osition a\[' . Of course , it is only because of this that the translation relation is productive at all  , and if one is looking for " princip-les , it seems reasonable to require something like this of the relation between the representational languages also  . \]' he following gives a slightly more precise sense to this idea : Translation is compositional when the translation of a complex expression is some  ( reasonably straightforward ) function of the translation o-I the basic expressions it contains  , plus the translation of their mode of combination . 
Condition ( ii ) ' directness'of-'primitiw~ness'is simply intended to exclude illicit representational levels between those officially sanctioned : what it says is that the RLi-RLj relation must he direct  , or primitive , and can no the mediated by other undeclared representational levels  . Such a conditimn helps to maintain clarity ( and learnability )  , and giw-~s content to the other conditions . 
A more ferea \] reconstruction of these ideas ( along the lines suggested in Hontague ( 1974 ) ) eight be as follows . 
We begin by defining compositional translation as a relation between ' grammars '  ( generative devices ) specifying languages , rather than languages directly , thus making the RLi-RLJ relationship parasitic on the relation between t be corresponding ' grammars '  . Instead of ( I ) , we are thinking of a picture like (2) , where a ' vertical ' dimension has been added ( 2 ) B 1 .   .   .   . G2 .   .   .   .   .   .   . __G nl IL s---RL lRL2 RL n .   .   .   . TLf Compositional translation of two representation lan-guages RLi and RLj is then defined by a pair of relations T and T-i  ( ' translators ' ) between the 6 i and 8 j ( generative devices , grammars ) specifying ( generating , enumerating ) RLi and RLj . 
We take a generative device 8 to be a pair , < C , I \]> where C is a finite set of constructors ( ' rules ' defining the class of complex expressions  )  , and A is a finite set of atoms ( basic expressions )  . 
We say that translation from LitoLj is ELE_LEt ~Y  . 
? om L 0 ositional if tilere is mapping T from 6 i = < C i , Ai > to 8j = < Cj , Aj > such that : ( i ) Tleaps Ai into Aj , and ( ii ) there is a mapping t from Ci into Cj such that if u = < c :  u1  ,  . . . , Un >, then T ( u ) = < tcT(Ul), .  ,  .   , T ( Un )) As will become apparent , these definition simply a very restric Jve theory of translation  , one which is much too strt log to be usable . However ' , before discussing its inadequacy , we mill make the ideas invol-ved more concrete by describing a notation for Gs and Tsmhich is strongly committed to these ideas  , and by discussing a very simple example of the use of the notation  , fhe description is rough and not precisely formalised  , bmt should give an idea of the issues involved . 
Notation for constructors and atoms : atom : := ( name , feature description ) constructor : := ( name , feature description ) \[ argspec*\]arg spec : := ( name , feature description ) ( In fact , atoms are simply constructors with arity ~ , but we will preserve the intuitive distinction here  )  . 
The feature theory we assume here is extremely simple : a feature description is a set of attribute-value pairs  . fhe'name'is . just a distinguished fea-ture represent ing the intuitive linguistic basis of the language being described  ( thus , it might be a syntactic category , a syntactic relation , or a semantic relation as appropriate ) . Notice that this name need not be unique . Each constructor has in addition a unique abbreviatory constructor name which is used by the T-rules  . 
The language I_generated by a G is a set of wellformed object  ( wfo's ) such that : Every atom is amfo ; and if cn is a constructor of arity n , and each of el ,   .   .   . , Unisawfo , then cn : Ul, . . . , unisawfo . 
This very simple syntax for Gs will lead to over ' -" generation  . . . . for + example , it mill allown p construc-tors with two arguments a saw fo  , even if the first argument is a verb , and the second is a preposition . 
For this reason we supplement the purely syntactic description uith a semantics based on applying constructors to arguments  . We will thus normally be concerned only with the subsetmfos that are also constructs ~ in the following sense : Every atomi ~ ia construct ~ a constructor applied k ~ some argumellt ~ i yields a construct providing the argu'-ments EEL ~_ ~ with the appropriate argspecs of th ~ constructor  . 
Examples ( for ' a constituent structure language ) : atom ~: a example = ( example , cat = n , oum = sing ) at hi ~ ~ , ~: ( this , cat = det , oum=sing ) constructor:Cop = ( no , num = X , per=3)\[( , cat = det , num = X )( , cat = n , num = X ) \] construct Cnp : a this a example = ( np , num=siog , per=5)\[(this , cat = dmt , num=sing ) , ( e?ample , cat = o , num=sing ) l The syntax and semantics of fs is roughly as folloms  . 
Syntactically vaT-rule is of the form : lhs == > rhs  , where ihs and rhs are atoms or constructors of source and target language Gs respectively  . For example , the following might be T-rules relating a level based on syntactic relations with one based on semantic relations for the atoms corresponding to the verbs like and ! kit  .   ( They are both assumed to assign subject and object relations to their dependents syntactically  . 
They are assumed to assign respectively , experiencer and patient , and agent and patient to their semantic dependents ? Since the loading linguistic idea at both levels is relational  , and the nature of the relation cannot be determined for constructs in isolation  , the name feature of atoms and constructors is ' blank ' at these levels  )  . 
(3) ( ,( word = like , cat = wvframe=subj-ubj ) = =>( . _v word = like , cat = v , frame = exp-pat ) (4) ( , word , : hit , cat = v , frame=subj-obj ) ==>( . . , word = hit , cat = v , frame=agent-pat ) The semantics of this is that all source language atoms wit  ( oh unify with the lhs are translated to all target Language atoms whie hunify with the rhs  . 
he following might be a constructor to constructor
T-rule for the same two levels : ( 51 C~ubj-ohj=:~>Cexp- . pat meaning that any source language construction built by applying Csubj  . .ob j to some arguments ul , . . . unis translated by applying C exp_pat to the translations of el  ,   ,   .   . iOn This syntax and semantics for T~rules implements the idea of strict compositiooality defined above  . 
This modelise legant , but inadequate , givml the way natural languages appear to be . What strict compositionality requires is at least a rather strong homomorphism between the languages related by a T  . It is easy to find examples where this looks implausible  . 
For example , consider the common need to reorder members of a construction in translation ~ or the need to ~ liminate ' formal ' items which are a part of constructions in one language  ( one level ) but not in another ( perhaps re-expressing some information they carry as part of a feature  )  , as in (6) ; or the kind of simples troctmral change i nwHve dingoing from a level which has both  5 and VP constructions to one mhich has verb , subject , and object as members of a single construction ( 7 )  ; or ' the need to re-analyse an item which is part of nee constraction in one language  , as part of another construction in translation ( 8 )  . 
(& ) \[S for jules to understand it \] = ~>\[ S\[ -finite\]jules understandit\]  ( 7 ) \[ Sjules\[vphits and y\]\] ==2 \ [ Shitjuless and y\] ( 8 ) \[ rely\[ppons and y\]\]==>\[rely-on \[ nps and y\]\]Of cuurse  , one could easily vary assumptions about representations so that these examples disappear ~ but other examples conflicting with the new assumptions will be just as easy to find  . Notice that though , close to the surface of one language ( English ) , there are many examples of this kind between languages :  ( 9 ) \[ julesz wemt graag \] ==>\[ jule silkes\[e ito swim \]\] " jules swims likingly '  ( 10\[give\[ah and to X\]\]==>\[ ( helpen )  , X \] ( 11 ) \ [ nappleseller \] ==>\[ npvendeur\[pp depommes \]\]' Lexical holes " such as English exhibits with respect to Dutch  ( English has no adverb ' likingly " to translaterag_raacL  )   , and idioms such as qive . a hand will normally give rise to the need for non-strictly compositional translations  , for obvious reasons . As a more general example , it is often the case that what is expressed Iex ically or syntactically in one language is expressed morphologically in another  . 
Thus , modality is often expressed by inflection in Romance languages  , and by combinations of separate lexi ~ alitems in Germanic languages  , and correspondences between compounds in Germanic languages  , and syntactic constructions in Romance languages ( as in ( 11 ) are very common . Treating this kind of thing will certainly lead to non-strictly compositional translations somewhere  . 
The solution to this problem adopted by Landsbergen  ( 1984 ) in Rosetta is to ' tune ' the Gs to each other , thereby ensuring that they are homomorphic , and that something close to strict compositionality can be preserved  . ( In fact , L and sbergen requires the translation relation to besymmetric  , so the grammars turn out to be isomorphic ) . This preserves the elegance of the model , but at the expense of the elegance of the lingu is tictheories and descriptions  ( the Mul and MUD )  , which become extremely complex , and potentially unusable . For example , it requires give a handtE and ~ , and ~ , and like to to be treated alike . Providing a systematic and general characterisation of a theory of representation which allows this seems highly problematic  . What one expects is that the representational theory will become unlearn-able in the sense described above  . A second objection to this approach is the obvious one that it eliminates the modularity that is potentially available with this model  ( each G can be thought of as a module , e . g .  )  . This reduces its attractiveness from a deve lopmental point of view  , particularly where multi-lingual MT involving large numbers of languages  , or wide coverage ( hence collaboration of large numbers of indiv iduals  ) is envisaged . 
For these reasons , we have preferred to explore an alternative approach  , which involves allowing some relaxations of str ict compositionality  . The fol-lowing three relaxations have been proposed :  ( i ) To allow variables on either side of T rules : ( 12 ) e . g . c27\[I ,  2 , 3\]==>c38\[2 ,   3 \] with the meaning : translate any expression formed by applying  c27 to three arguments by an expression formed by applying  c38 to the translation of the second and third arguments  . This relaxation allows for reorderings , deletions , and reduplications by T-rules , and seems an entirely natural extension of str ict compositienality  . 
( ii ) To allow functions made up of constructors , atoms , and variables of the appropriate Gs on either ( 13 e . g . cS\[I , Cvp\[2 , 3\]\]==>Csubj/obj\[2 , I ,   3\] Notice that since the output of such a translation rule is still an expression in the target language  ( i . e . an expression built by applying target G constructors to target constructs  )  , this relaxation still yields ' one shot ' translation  . 
( iii ) To all mw the choice of the target constructor ( function ) to be dependent on properties of the arguments involved  . For example , one does not want all \[ vppl constructions to be treated like rel__el_y ~_  . gn_in (8) , and the exceptional translation behaviour of idioms  , and constructions involving lexical holes is clearly dependent on the presence of particular properties within constructions  ( e . g . the presence of particular lexical items ) :  ( 14 ) e . g . c35\[1 , 21 fl = vt , 3\]==>c46\[i ,  2 ,   31f2=v2\] with the meaning : translate constructions formed by applying  c35 to three arguments by constructions formed by applying  c46 to their translations , provi-ding the second argument of c35 unifies with a feature description where the attribute fl has the value v l  , and the translation of the third argument unifies with a feature description where the attr ibute  f2 has the value v2  . 
Though there is no provision for wild notational devices such as path variables  , these relaxations greatly increase the power of the notation  , to an extent which is problematic , given our methodology . 
We would naturally like to impose restrictions , so that we can preserve the idea that in compositional translation the translation of a whole is some ' reasonably straightforward ' function of the translation of its parts  . One possibility is to impose special restr ictions  ( or alternatively restrict some relaxa - tions  ) to certain translators ( e . g . one would like the transfer translators to be as near as possible restricted to some kind of atom -atom translator  )   . 
More generally , one might require that at most one side of a T -rule be a function  ( in the sense of relaxation ( bl )   , or to require that context sensitive T-rules may only refer to attributes of particular arguments  ( e . g . attributes of the heads of construcutions , perhaps , or to only allow them to test for the presence of particular lexical items among their arguments  )  . There are interesting methodological and empirical problems involved in trying to find approp-riate restrictions  , but we will not pursue them here , since ( as will appear in the following section ) , the notation is still restrictive enough for there to be a theoretical commitment which d~serves discussion  . 
2. The theoretical commitments of the model.
The attractiveness of our model as a framework for practical and theoretical MT derives from its modula-rity and its order liness in the main  . Practically , it ensures that translation proceeds via a series of representations which are described exp licitly  , and which therefore have to be capable of systematic description  , and it ensures that the language generated by app lying a sequence of translators is always a subset of a language that has been explicit ly described  . It thus comes as close as possible to excluding ' hybrid ' representations  , and ensuring that representations languages will be ' learnable '  . Moreover , the separation of Gs and Ts ~ and the use of a semantics based on unification provides a high degree of declarativeness  , and the homogeneity and uniformi-ty of the model may be of practical benefit  . The separation of Gs and Ts also provides a high degree of modularity  , so , e . g . different Gs can in principle be developed in parallel  , and the effects of modifications may often be localised to one G and the adjacent Ts  . This is developmentally attractive . 
Methodologically and theoretically the model is at-tractive in a number of ways  . The complexity of T-rules provides a very simple and effective evaluation metric against which to judge competing proposals about representational levels  ( so it is relatively easy to find arguments why there should or should not be intermediate representations of a certain sort  )  . 
And it provides a level of abstraction at w bich linguists and implementers can communicate easily  . 
However , perhaps the most important advantage of the model is that it decomposes the ' problem of MT '  , and provides a framework for investigating some interesting and apparently manageable subproblems  . Some of these are discussed in a preliminary way here  . 
This notation , and hence the model that it instantiates , in effect provides a contextfree grammar notation augmented by a simple feature theory based on unification  , and ( via the T rules ) t be capacity for certain transformations . We have no demonstration of the weak gene nerative capacity of the nota-tion  , but one suspects it Js at least as powerful as the notations of  LF6   ( Kaplan & Bresnan 1982 )  , or rUG ( Kay 19857 . Taking full advantage of relaxations ( a ) - ( c ) below may well yield Turing machine capacity . 
While this makes it likely that the notation provides some treat meot of all translational ly relevant phenomena  , it i ! is till rather restricted as regards des -criptive or expressive capacity  , and there is no guarantee that the treatment will be ' natural '  , appropriate , or even practically usable . 
One approach to the issue of usability is the provision of user " friendly abbreviations  ( e . g . )~ and it is fairly easy to imagine some conventions which would take this hasic  ( Mu 2 ) notation and make it more usable as a programming language for linguists  ( i . e . 
a Mul ' user language').
Some of the major modifications to the model which have been proposed include :  ( a ) The introduction of special versions of construct or application in place of unification  , for example , in the treatment of coordinate constructions . The properties of coordinate constructions are partly determined by the fact that they inherit the common features of their elements  , so the feature descrip-tion of the ~: on struction should be the generalisation  ( roughly self consistent intersection of the feature descriptions  ) of the elements , rather than their unification . 
( b ) The introduction of Kleene starto avoid deeply recursive structures in the treatment of construc ~ times which allow arbitrary numbers of arguments  ( e . g . most constructions can include an indefinite ly large number of PP modifiers  )  . Since the syntax of 6s requires specific reference to the arity of con -strutters  , the obvious may of dealing with this phe ~ no mena in the basic notation is to have recursive constructors  ( e . g . a constructor that combines an np and app to forman np  ) ~ yielding structures such as: ( iS ) n p np p p n p p p n p p p This treatment is not obviously incorrect  , but it is not necessarily the most intuitive ly satisfactory treatment either  , and it can have the undesriable effect of burying the lexical heads of constructions arbi trarily far down inside them  . 
( c ) A closely related point is that the model described is committed to representation languages where members of constructions ares trictly ordered  ( \[c 32: a , b \] is a different object from \[ c32: b , a \] -- e . g . 
the latter may fail to unify to give a construct  , while the former succeeds ) . This may not always be very natural , especially where relational languages are concerned : since the elements of constructions are distinguished by their roles  , they do not also need to be distinguished positionally  . 
A number of modifications along these lines are heing discussed in the project  . They are not on problematic ( or even obviously correct )  , for example ,   ( b ) and ( c ) above both suggest that constructors be treated as operations on sets  , rather than lists of arguments . 
Apart from changing the formal nature of constructors  , a problem will arise in going from unordered representation languages to ones which are ordered  , motivating an extension to the T-rule notation . Ne-vertheless , they seem to within a reasonable distance of ( and hence compatible with ) the essentials of the basic model . 
A consequence of the CFG basis of the model is that constructs are always hierarchical objects similar to tree structures  ( each application of a constructor yields a new l evel of structure  , intuitively ) . The model is most naturally applied in the description of linguistic phenomena that can be thought of hierarchically  , and in translating between languages that capture such phenomena  . Thus , it is naturally applied in the description of phrase and relational structures  ( though cf above )  , and given the unifica-tion based semantics , in dealing with phenomena such as agreement between members of constructions  . 
Moreover , though the ' naturalness ' of the treatment is perhaps more questionable  , it provides interesting , and apparently workable accounts of a number of phenomena that are not obviously hierarchical  . For example : it is reasonably easy to see hem the relaxa-tions of strict colapositionality allow a treatment of functional control and unbounded syntactic dependencies  ( Arnold et al 1985 sketches a crude ~ but straightforward treatment exploiting the possibility of having functions composed of target  6 constructors and variables in T~rules )   . 

One cart also envisage a treatment of pronominal reference  ( which is naturally thought of in terms of cn -indexation across trees  , rather than in hierarchical terms ) within this model along the following lines . 
Suppose every construct is assigned a unique index  , and every non-atomic construct is augmented by two lists  ( which we will refer to jointly as the ala lists  ) :  ( i ) an antecedent list , of the indices of the paten-tial antecedents the construct contains  ; ( it ) a nan_o ~ phorlist , of the indices nf the potentially anaphoric items the construct contains  . 
We will say that a member of the antecedent list and a member of the anaphor list are ' compatible ' provi-ding they do not differ with respect to the relevant inherent linguistic properties  ( such as number and gender )  . Every time a constructor is applied to some arguments  , the a/a lists of the arguments are inspec-ted : ( i ) if two arguments have compatible items on their lists  , then art indication that these two items are bound to each other is added to the construct that results  ; ( it ) the indices of the arguments , and members of the arguments ' alalists a reused to form the relevant alalists of the construct  . 
Apart from testing for inherent properties of antecedents and an apbors  , structural conditions can be imposed , e . g . the c-command condition can be imposed by allowing members of antecedent lists to be trams- -lured'upwards'tn only one construct  . This seems to provide a basic method for expressing all the antecedent-anaphor relations  , insofar as they are grammatically determined , at least . 
It is a natural consequence of the CFG basis of the notation that  , under " this treatment of antecedemt-anaphor relations  , objects do not themselves contain an indication of their antecedents  ( or anaphors )  . 
Instead , this information is present in the construct that contains them  . For the same reasons , the notation involves an interesting commitment in some kinds of context senstive translation  . 
Consider , for example , the translation of the verb know into French , which ( for simplicity ) we will take to be ~ avoir if there is a semtential complement  , and connaitre if there is a nominal complement , i . e . in standard rewrite notation : (16) a . know->cunnaitreI_np-objb . know->savoir I__s-obj Our notation has no direct analogue to this sort of statement : ti recontex~sensitivity has to be taken care of in the translation of the construction containing the verb  . Suppose c32 is the English constructor which builds the IS representation of Oules knows Sv and suppose that English-French transfer contains the following T-rules :  ( 17 ) a . know ==> connaitreb . know ==> savoirc . c32 ==> of 36 Then c32: know , Jules , S will produce both of: ( 18 )   ( 4 )   Cf~6: connaitre Oules S ' and what one expects is that unification in  ( i )   ( or some later translation of ( i )   ) will fail to produce a conetruct ( e . g , because of 36 checks the Syntactic category of its third argument  )  . This seems a very natural account for cases such as these  , where the target G contains the information for making the right choice  , But one cannot expect this always to be so ( e . g . where the information required is only part of the source language  )  , and in such cases context sensitive T-rules will be required  ( of relaxation ( c ) above )   . It is clear that this notation is committed to such cases being less common  , at least . 
As already noted , this model provides for a high degree of modularity in principle  . In fact , the degree of modularity is rather extreme : not only are individual Gs modules  , but individual constructors and atoms are modules also  . Though the use of a feature theory allows some general  ) motions to be captured , the degree of modularity means that many generalisations that hold ' horizontally '  ( across languages )  , and ' vertically ' ( within languages l are missed . 
The most obvious case of horizontal generalisations are ' invariances ' and default translations across languages  . For example , one does not expect the value of the attribute which identifies individual lexical items to change normally during analysis and generation  , and the simplest and most restrictive view of transfer would be that nnly this attribute changes  . Similarly , one knows that syntactic subjects normally correspond to semantic agents  , and vice versa . 
Within individual languages some capacity to capture generalisations across constructors is a prerequisite of some of the modifications mentioned above  ( in particular , CF type treatments of unbounded dependencies depend on some such mechanism if massive redundancy is to be avoided  )  . More generally , one would like to be able to state conventions ( about e . g . the percolation of attributes from heads of cnnstructions to constructions  ) once and for all , rather than ha . -ring to state them separately in each constructor  , and there are various defaults which could make construction of Gs easier  ( e . g . the default case is that verbs have regular morphology  )   . 
Here we will briefly describe a fairly simple extension of the basic notation which is capable of dea-ling with these phenomena : ~ E~ect ~_EE__EuleEI which describe  ( relations between l classes of constructs by stating partial descriptions of  ( pairs of ) constructs . The following are examples : (19>(20) (21) (_ , cat = v , morph-form = regulat ) ( , cat = X ,   . . . ) l(gov , cat = X , o . .) (_ , cat=s , tense=vl)\[3==>(_ , time = v2 ) \[\] The idea being that such rules can be used to ' in-ject " generalisations into existing constructors  , atoms , or \[- rules . The normal problem with such'meta"devices as these is controlling their interaction  . A very simple way of avoiding this would be to adopt the following semantics : applying an injection rule l to a rule  ( atom , constructor , or T-rule ) R succeeds if I unifies with R , in which case the unification EgEl(;c~sR . This semantics means that injection rules cannot affect the cardimality t ~ f the role set  , but it greatly simplifies the form andumntent nf the rules that must be written  , and provides a perspic nous way of otatiug cer tain general J  . --sations . 
As stated , injection rule ( 19 ) is intended to unify miL hall at mms that haw ~ , cat = v , and to add in the information that they have regular morphology  . No . -lice that this injection rul ~ . , w i l l fail to app ly tu any atom that a l ready has it d i f fe rent spec i f i ca t ion fo r morph-forla  , so there is a ~ . ; traightformard way of trnatiug exceptions ouch as irregular verb morphology  ,   ( 20 ) is avpry simple example of a percolation injection  . When applied to the coustructors of a relational level f  ;  , it will ensure that the category of the head ( gov ) of a construct , is percolated to tllo construction ? hgain ~ exceptions t:auhe  . ~; tipolated in iudividual coestru ~ tors .   ( 21 ) is intended to state a cerrespoude neebetween tense = vl  , and time = v2 , arid will inject this relation ! ~ hip into al lT-Pules that translates eotences ~ It is appropriate to end by mentioning the mest obvious open questions  , since they suggest the direc-
T : i on which future work should take.
( i ) We have not yet investigated tlm implications of the model for robustness  , arid while the model has been setupuo that T -rules should here versible to a large extent ~ we have insufficient practical experience witllit to know how far this potential can he exploited  .   . 
( it ) Perhaps the most obviuos theoretical commitment is that the notation is linguistic \] unature  , He-signed for representing linguistic knowledge ( it would not be a very natural method for representing more general ' real world ' knowledge  )  . We think this is appropriate in HT , which is fundamentally about relating l . i_t t t ~ lEi_stic objects . However , as many examples indicate , there is an important role for gener ~ il knowledge in HT  , and this must be accommodated somewhere . ? No doubt various compromises are possihle ~ antl there is certainly room in the model furs ~ch quasi-linguistic entities as semaotic features  , but taking the model serioosly involves rejecting knowledge representation languages as levels per so  . The role of general knowledge representatiens cannot therefore be a step in translation  , and can only be to provide a method of chmosing between alternative representations at linguistic levels  . 
( iii ) \] h is leads directly to another point : the framework provides a number n fmay o of coping with nun-determinism  ( filtering hy target Gs , context sensitive T--rules , e . g . ) , but there is no method furthe explicit coml Jarisun of competing representations  ( e . g . as in ' preference semantics ' Milks ( tP " lB ) )  , and to provide such a method seet as heyond the scope of the model we have described  . Practically ~ it is not clear whether thi, . i is a problem or not , however ~ an appruach which is censistent mith the general spirito ~ the model mighthe to define a cumber of ' choice ' levels  , at which ~: bmices between alternatives would be made  ( tS is the obvious candidate )  , fie would require G and T rulestube setups e that all alternative representations at these levels would he translatimn ~ lly equivalent ~ uo that choice could be arbitrary  . 
( iv ) We have assumed an extremely simple feature theory  ( e . g . ~' ae have not allowed attribute ~ to take features as values  )  . It is clear that a more sophisticated theory is desirable ~ and ~ ome work has been dmee in this direction witll in the model ? llomever ~ what is not clear is how the extra descriptive paper of an extended feature theory affects the ' pragma-t ics ' of l  . he model . . . . the way the model should be used fo r l i ngu is tic description  . 
Investigation mf this model is still at an : arty stage ~ and much of the abowe is speculative mr schematic  . However , despite its preliminary !; ta Lus , we feel the approach described here i5 pr ( Imisiug , alto we hmpe we have said enuughto show why ~ e feel it is worthy of attention  . 
More information on the Eurotra project can be found in e  . g . King & Perschke (1982) and King et al (198 U)o
Wet___._erences
D . J . t/rnnld , L . aa Bpaert & L . desfombe " ELS-3: Eurotra Linguistic , qpecifications ( January 1985) " l : urel : to
Report ETL-5, DGXIII ) CgCLux embourg.
D . d . Arnold , L . Jaspaert , R . amhnsun , S . Krauwer ~ H . Ros-her , L . des Tembe , G . B . Varile , & S . Warwick " ~ l . ltll Viewef the ( C~8>,1f framewmrl . " in Euretra " in .  _ . .Prouee-~i . ng>_> . ( tl!e~_qd . DrEg !: ~ 9fi   fl>-~TetiE~L1  & !'  lgttLmO~llogi7 Eat ~ s > ges .   . _ in ~! . a EII uIE . l\[ . ~vsl<~t_i~k . pf_N~j?eEaJ,~ . ~U ~: ega . tLgS ~ Colgate Ilniv . , Hamiltun ~ N . Y , 1985, ppo114 . 
R . Kaplan & J . Bresmau " Lexical Functional Grammar : a Formal System for Grammatical Representation " in The ! ~ e  , ~ t&lIZ . Epz~>En . ~ti . m . L!~k . _  ~ Eam(,Lati&_,,kl!h:zl:~t . , ~, >, a . 
Bresoanled ), HIT Press , 19112.
H . Kay " Functional Unification Grammar = a Formalism for MT " in  Erpc~LeEi0fjs g f j ; 0_L ! N . ~gEStanford , Cali-fornia ~1984 , pp , 75-7 II . 
H . King , R . L . aohns on & L . desTombe " Eurotra : a Multilingual system under Development " in ! ~ gmp !_ Ltatio A ! al  . 
L.ing Ei . ~ Lt * E >, 11:2-3, 1985, pp . 15.5-169.
H . King & SoPerschke " Eurotra & its Objectives " in Mo  . !__ti\[ . iE qg . ?, 1:1,19~2, pp .  27-32 . 
~ l . Landsbergen " Isomorphic Grammars and their Use in tim Rosette Translation System " to appear in H~u : hig  (  . ' ! . r_~J ! ~ . La_t . t_g\[L!_! . l\]E_~L~t ~ A t :__t ~)__~__~~1%,~ll . Kiligted ), Kdin--burgh Univ . Press . 
R . l . lontague Eo . rlEalP bjj ~ _ osgl / ! Ly_ , Yale University Press ,  1974 . 
L?desTmmbe , b . J . Arnold , L . Jaspaert , R . John, . mr ~, S , Krauwer ~ M . Rmsner , I \] , Bo Varilev &!\] , Warwick " t\]Preliminary Linguistic Framework for Eorotra  ( dune !985 ) " in\[rp_~ . ! . tE0j_ntkE_?2_t_bEg on2 erenE~_p . n_T!L gp cgt , 7 cal & Methodological Issues in Machine Translation of Nat_~E  , !!___L~ . P_Ru_iLEE ~ L . , Cmlgate Univ . , Hami Itch , N , Y . 
1985 ~ PP . 283-288.
Y . Wilks " Making Preferences Mere Active " in AI ____ dour - 
E ~ ! I , II : 3, 1978, pp . 197723.

