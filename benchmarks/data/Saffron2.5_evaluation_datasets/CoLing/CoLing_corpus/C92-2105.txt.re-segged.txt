Self-Monitoring with Reversible Grammars 
Giinter Neumann * and Gertjan van Noord\]
*Deutsches Forschungszentrumt Rijksuniversiteit Groningen 
f ~ rK finst liche Intelligenz Postbus 716
Stuhls at zenhaus weg 3NL 9700 AS Groning en
D-6600 Saarbr/icken11 vannoord@let.rug.nl


We describe a method and its implementation for self-monitoring during natural anguage generation  . In situations of communication where the generation of ambiguous utterances should be avoided our method is able to compute an unambiguous utterance for a given semantic input  . 
The proposed method is based on a very strict integration of parsing and generation  . During the monitored generation step , a previously generated ( possibly ) ambiguous utterance is parsed and the obtained alternative derivation trees are used as a ' guide ' for regenerating the utterance  . 
To achieve such an integrated approach the underlying grammar must be reversible  . 
1 Introduction
In many situations of communication a speaker need not to worry about the possible ambiguity of what she is saying because she can assume that the \] tearer will be able to disambiguate ileutter anceby means of contextual information or would otherwise ask for clarification  . But in some situations it is necessary to avoid the risk of generating ambiguous utterances that could lead to misunderstanding by the hearer  , e . g . , during the proecss of writing text , where no interaction is possible , or when utterances refer to actions that have to bcperforme directly or in some specific dialog situations  ( e . g . having an interview with a company ) . 
The need to generate unambiguous tterances is also relevant for the development of natural language generation systems  . For example in the case of an intelligent help -system that supports the use of an operating system  ( Wilensky et al ,  1984) , asking an inexperienced user to'f~e-move the folder with the system tools ' could \] lave tremendous effects on the system itself  . 
If one assumes a modular division of the natural language generation task between two stages of the language production process -- deciding what to say  ( conec plua level ) and deciding how to say it ( grammatical level ) -- it is not realistic to expect hat the conceptual component will be able to specify the input for the grammatical component such that ambiguous utterances can be avoided  . 
If it were possible to specify the input in such a way  , then this would mean that the conceptual component has to provide all information eeded by the grammatical component to make decisions about lexieal and syntactic hoices  . Hence , the conceptual component would need detailed information about the language to use  . But this would blur the distinction between the grammatical and the conceptual level  , because this would imply that both components share the grammar  ( see also Appelt ( 1989 )  , Meteer (1990) , Neumann (1991)) .   1 In order to maintain a modular design additional mechanisms are necessary to perform some monitoring of the generator's output  . Several authors argue for such additional mechanisms  ( Jameson and Wahlster , 1982; DeSmedt and Kempen , 1987; Joshi , 1987; Levelt ,  1989) . For example , Levelt ( 1989 ) pointed out tbat " speakers monitor what they are saying and how they are saying it "  . In particular he shows that a speaker is also able to note that what she is saying involves a potential ambiguity for the hearer and can handle this problem by means of self-monitoring  . 
In this paper we describe an approach for self -monitoring which allows to generate unambiguous utterances in such situations where possible misunderstandings by tire user have to be avoided  . The proposed method is based on a very strict integration of parsing and generation  . During self-monitoring a generated ambigu 1As pointed out in Fodor ( 1983 ) one of timch taxacter-istic properties of a module is that it is computationally autonomous  . But a relevant coimideration of cornputa-tionally autonomy is that nmdules do not shares our ccs  ( in our case the grarm nar )  . 
AcrEsDECOLING-92, NANTES . 2328 AOL'r 1992700 PROC . OFCOLING-92 . NANTES , AUG .  2328 .   1992 ous utterance is parsed and the obtained alternative derivation trees are use  . dmsa'guide ' for the ' monitored ' generation step  . We will show that such an integrated approach makes only sense with reversible grammars  . To our knowledge , there is at present no algorithm that solves the problem of generating unambiguous utterances by nmans of self-monitoring  . 
2 Overview of the Monitoring Algorithm
Our approach is based on a strict integration of parsing and generation in that parsing is used to detect whether a produced utterance is ambiguous or not  . The advantages of using comprehension mechanisms to facilitate moint or iug arc for example mentioned in Levelt  ( 1989 )  . \[ nhis model parsing and generation are performed in an isolated way by means of two different granunars  . 
' Phe problem with this view is that generation of unambiguous paraphrases can be very inefficient  , because the source of the ambignons utterance is not used to guide the generation process  . 
To overcome this problem the basic idea of our approach is to operate with derivation tl~es obtained during the generation and parsing step  . 
In short , the algorithm works as follows . Firstly , it is checked whether a produced utterance S of an input for mLF is ambiguous  , by parsing S~If during parsing e . g . two readings LF and LF ~ are deduced LF is generated again along the parse trees obtained for S  . Now an utterance S'can be generated that has the same meaning but differs with respect othe ambiguity source of S  . 
In this way the derivation trees obtained during parsing of a previously generated utterances are used as a guide during monitored generation  . 
Grammatical structures obtained during parsing arc used directly to restric the search space during generation  . At this point its houhl be clear that the only way in order to be able to generate ' along parsed structures ' is to use reversible gram mars  . This ensures that every sentence produced by the generator can be parsed  . Similarly , for every semantic structure computed by the parser  , the generator delivers an utterance . 
3 Amonitoring strategy
A naive strategy . The tirst and most straightforward solution to obtain Olflynn-ambiguoust-terances during generation could hc described as a ' brute force ' solution  . The generator derives possible utterances for a given logical form  . 
For each of these utterances it is easy to check whether it is ambiguous or not  , by counting the results the parser delivers for that utterance  . 
In a Prolog implementation this simple solution can be det in cd as follows  . Note that we assume for simplicity ttlat linguistic signs are represented with terms s ign  ( LF , Str , Syn , Der ) where LF represent stile semantic information , Str represents the string and Syn represents syntactic information  . The fourtil argument position will be used later in this paper to represent derivation trees  . 
monitor(sign(LF , Str , Syn , Der)):-geuerate(sign(LF , Str , Syn , Der )) , unambiguous ( Sir ) . 
tmambiguous(Str ) :- set of ( LF , D'S^parse(sign(LF , Str , S , D ) , \[ El \]) . 
The predicates paxse/1 and generate /1 call respectively the underlying parser and generator  . 
These to ~ predicate is used to obtain the set of solutions of the parse predicate  , where " indicates that D and S are existentially quantified  . 
By instantiating the resulting set as a set with exactly one element  , we implement the idea that the utterance should be unambiguous  ( in that case there is only one parse result )  . Given Pro-log's search strategy this definition implies that the generator generate solutions until an unambiguous utterance is generated  . 
The prol ) lem with this ' generate and test ' approach is that the search of the generator is not directed by the goal to produce an unambiguous result  . We will now present a more involved monitoring strategy which is oriented toward stile goal of producing an unambiguous utterance  . 
Ambiguities are often ' local ' . Aflm dameu-tal assumption is that it is often possible to obtain an unambiguous utterance by slightly changing an ambiguous one  . ' fhus , after generating an ambiguous utterance , it may bcpossible to change that utterance locally  , to obtain an unambiguous utterance with the same meaning  . In the ease of a simple lexieal ambiguity this idea is easily illustrated  . Given the two meanings of the word ' bank ' ( ' river bank'vs . ' money institution ') a generator may produce , as a first possibility , the following sentence in the e o . se of the first reading of ' bauk ' . 
ACRESDE COLING-92 , NANTES , 2328 hOt'n1992701 PROC . OFCOLING-92, NANTES , AUG . 2328,199 2elmiaux3/\infll8vp4
I/\ be 2 in fll2 ppt
I/\ stand3 near l rip2  / \  the2   bank4 sl/\jolml aux3  / \  infll8   vp4 
I/\ be 2 in ~112 ppl
I/\ stand3 near1 rip2/\ the2bemk7
Figure 1: Derivation trees ( I ) John was standing near the bank while Mary tried to make a picture of him  . 
To'repair'this utterance we simply alter the word ' bank ' into the word ' river bank ' and we obtain an unambiguous result  . Similar examples can be constructed for structural ambiguities  . Consider the German sentence : ( 2 ) Heuteist durchalas Au~nministerium be kannt gegeben women  , daft Minister van den Broek den jugos lawischen Delegations leiter aufgef order that  , die
Armeeaus Kroatienzuriickzuziehen.
Today it was announced by the ministry of foreign affairs that minister van den Brock has requested the Yugoslav delegation leaders to with draw the army from Croatia  , which is ambiguous ( in German ) between ' withdraw\[the army of Croatia \]' and '\[ withdraw\[thearmy\]away from Croatia \ ]'  . In German this ambiguity can be repaired locally simply by changing the order of ' aus K roatien ' and ' die Armee '  , which forces the second reading . Thus again we only need to change only a small part of the utterance in order for it to be unambiguous  . 
Locating ambiguity with derivation trees.
We hypothesise that a good way to e haracterise the location of the ambiguity of an utterance is by referring to the notion of ' derl vation tree '  . We are assuming that the underly in grammar formalism comes with a notion ' derivation tree ' which represents how a certain derivation is licenced by the rules and lexical entries of the grammar  . Note that such a derivation tree does not necessarily reflect how the parser or generator goes about finding such a derivation tree for a given string or logical form  . For example , the derivation trees of the two readings of ' john is standing near the bank'may look as in figure  1  . The intuition that the ambiguity of this sentence is local is reflected in these derivation trees : the trees are identical up to the difference between  bamk4 and bank7  . 
In our examples each sign sign(LF , Str , Syn , D ) is specified for its corresponding derivation tree D  . In Prolog such a tree is represented with terms of the form t  ; (Label , Ds , M ) where Label is the node name ( the unique name of a rule ) and Ds is a list of Daughter trees . The third argument position will be explained below  . 
Given a derivation treet of a generated sentence s  , we mark the places where the ambiguity occurs as follows  . If s is ambiguous it can be parsed in several ways  , giving rise to a set of derivation trees T = t l .   .   . tn . We now compare t with the set of trees T in a topdown fashion  . 
If for a given node label in t there are several possible labels at the corresponding nodes in T then we have found an ambiguous spot  , and the corresponding node in tismarked . Thus , in the previous example of structural ambiguity we may first generate sentence  ( 2 ) above . After checking w betfier this sentence is ambiguous we obtain  , as a result , the marked derivation tree of that sentence . A marked node in such a tree relates to an ambiguity  . The relevant part of the resulting derivation tree of the example above may be the tree in figure  2  . 
Markhlg a derivation tree . The predicate mark ( Tree , Set ) marks the generated tree Tree given the trees Set found by the parser  . Tile third argument M of tile terms t(Labsl , Ds , M ) repre-ACRES DECOLING-92 , Nxlcr ~ ,  23 . 28^Or ~ T1992702 PRec . OFCOLING-92, NANTES , AUG .  2328 ,   1992   vp5  / \ ~  ragen3   vp2 MARKED npl vp4  / \ /  die2 arme elppl/\ aus2 Krl \ infl4 t zieh3 
Figure 2: Marked derivation tree senting derivation trees indicates whether the current node is marked  ( in that case the value is y ) or not ( using the value n )  . Subtrees of marked nodes have no instantiated value for this variable  . 
mark(t(L , Ds , n) , Set):-root_same(L , Set ) , ! , get_ds ( Set , DsSet ) , markds(Ds , DsSet) . 

root_same(L,\[\]).
root_same(L,\[t(L .   .   .   . ) IT\]):-root_same(L,T ) . 
markds(\[\],\[\]).
markds(\[HlT\] , \[Hs\]Ts\]):-mark(H , Hs ) , mark_ds(T , Ts) . 

get ds(Set , \[~ IT\]):-getf(Set , Sst2 , H ) , get_ds ( Set2 , T) . 
getf(\[\],\[\],\[\]).
get f(\[t(_ , \[ H3IB\] , _) IT\] , \[ t(_ , B , _) IT 2J , \[ H3IT3J ):-get_f(T , T2 , T3) . 
Changing the ambiguous parts . Summaris-in K , the generator first generates a possible utterance  . This utterance is then given as input to the monitor  . The monitor calls the parser to find which parts of that utterance are ambiguous  . 
These parts are marked in the derivation tree associated with the utterance  . Finally the monitor tries to generate an utterance whict luses alternative derivation trees for the marked  , i . e . ambiguous , parts . 
Generating an utterance given a marked criva-tion tree proceeds as follows  . The generator simply ' repeats ' the previous generation in a topdown fashion  , as long as it encounters unmarked nodes . This part of the generation algorithm thus simply copies previous results  . If a marked node is encountered the embedded generation algorithm is called for this partial structure  . The result should be a different derivation tree than the given one  . Now clearly , this may or may no the possible depending on the grammar  . The next paragraph discusses what happens if it is not possible  . 
The following definition ~ sumes that grammar rules are represented simply as rule  ( Name , No ' thor , Ds ) where Name is the rule name , Mother is the mother sign and Ds is a list of daughter signs  . The predicate mgen is used to generate an utterance  , using a marked derivation tree as an extraguide . 
mgen(sign(Lf , Str , S , D ) , * ( Name , Ds , y )) :- genera * e(sign(Lf , Sir , S , D )) , \+ D = t(Name , Ds , _) . 
mgen ( sign(Lf , Str , S , Dr , t(Name , Ds , n )) :- rule(Name , sign(Lf , Sir , S , D ) , Kids ) , mgends ( Kids , Ds) . 
mgen_de(\[\],_).
mgen_ds(\[SIT\] , \[Stree , Ttree\]):-mgen(S , Stree ) , mgends(T , Tire ~) . 
II . e defining locality . Often it will not be possible to generate an alternative x pression by a local change as w c suggested  . Wcpropose that the monitor first tries to change things ~- qlocal mq possible  . If all possibilities are tried , the notion ' locality ' is redefined by going up one level  . This process repeats itself until no more alternative solutions are possible  . Thus , given a marke deriva-tion tree the monitored generation first tries to find alternatives for the marked parts of the tree  . 
\] fno further possibilities exist , all markers in the trees are inherited by their mother nodes  . Again the monitored generation tries to find alternatives  , after which the markers are pushed upwards yet another level  , etc . 
The following definition of the predicate laawkA . .g(Treo , Set , Guido ) will ( procedurally speaking ) first construct the ' guide ' Guide given a derivation tree Tree and a set of derivation trees Set  ; upon backtracld ngit will push the markers in the tree one level upward at the time  . 
mark_l_g(Tree , Set , Guide ) :-
Ama~s DECOLING-92 , NANTES , 2328 ao ~"1992703 PROC . OVCOLING-92, NANTES , Auo .  2328 , 1992 mark ( Tree , Set ) , l_g(Tree , Guide ) . 
1g(Tree , Tree).
l_g(Tree , Guide ) :- one_up(Tree , Tree 2) , l_g(Tree2 , Guide ) . 
one_up(t(L , Ds , n ) , t(L , Ds , y )) :- member(t ( .   .   .   . y ), Ds ), ! . 
one_up(t(L , Ds , n ) , t(L , Ds2 , n )) :- one_up_ds(Ds , D s2) . 
one up_ds(\[\],\[\]).
one_up_ds(\[HIT\] , \[ H2IT2\]):-one_up(It , It2) , one_up_ds(T , T2) . 
The algorithm can be completed as follows . ~monitored_genoration(LF , Sign ) :- generate ( sign(LF , Str , Syn , D )) ,  ! ,  ~ . stick to one . .
monitor ( sign(LF , Str , Syn , D ), Sign).
monitor(sign(LF , StrI , Synl , Dl ) , sign(LF , Str , Syn , D )) :-
Find_all_parse(Strl , TreeSet ) , ( TreeSet=\[_\]->Strl = Str , Synl = Syn , DI=D ; mark_l_g(D1 , TreeSet , Guide ) , mgen ( sign(LF , Str , Syn , D ) , Guide ) , unambiguous(Sir )) . 
Zindall_parse(Strl , TreeSet ) :- seto ~( D , LF ~ S ' parse(sign(LF , Strl , S . D),

Simple attac/nnent example . In order to clarify the monitoring strategy we will now consider how an attachment ambiguity may be avoided  . The following German sentence constitutes a simplified example of the sort of attachment ambiguity shown in  ( 2 )  . 
(3) Die M~inner habenheute die Fraumit dem
Fernglasges ehen.
Themen have today the woman with the telescope seen  . 
To day the mensaw the woman with the telescope.
2 In the actual implementation thepredicate ~ ind_all_-parse is complicated in order to remember which parses were already tried  . If a parse has been tried before , then the predicate fails because then that reslflt is either already shown to be ambiguous  , or otherwise the colTs-sponding solution he . s already been found . 
Suppose indeed that the generator , as a first possibility , constructs this sentence in order to realize the ( simplified ) semantic representation : heute ( mit ( fernglas , sehen(pl(mann ) , frau )   ) Let us assume that the corresponding derivation tree is the tree in figure  3  . To find out whether topic/\mann verb ~ see/\ habenvp_compl/\frauvp_modmit demfernglass gesehen Figure  3: Derivation tree of German example this sentence is ambiguous the parser is called  . 
The parser will find two results , indicating that the sentence is ambiguous . For the alternative reading tile derivation tree shown in figure  4 is found . 
topic/\mann verb_see/\habenvp_compl/\pp -modges ehen/\fraumit demfern glass Figure  4: Derivation tree of alternative reading The derivation tree of the result of generation is then compared with the trees assigned to the alternative readings  ( in this ease only one )  , given rise to the marked derivation tree shown in figure  5  . 
The monitored generation will then try to find alternative possibilities at these marked nodes  , However , no such alternatives exist . Therefore , the markers are pushed upone level , obtaining the derivation tree given in figure 6 . 
ACRESDE COLING-92 . NANTES . 2328 Aou'r1992704 PREC . OFCOLING-92, NANTES , AUO .  2328 ,   1992 topic/\nlann verb~sec/\habenvp_complfrau MARKED vpanod MARKED/\tnit demfern glass gesehen Figure  5: Marked tree of German example topic/\
Yila Iln verb ~ see haben vp_eompl MARKED/\frau vp_mod/\mit demferngt assges e hen Figure  6: Markers are pushed one level upward At this point the monitored generator again tries to find alternatives fortile marked nodes  , this timesue eess flfl ly yielding: ( 4 ) Die Mgnner haben mit dem Fernglass die
Prauges e hen .
At this point we may stop . However , note that if we ask for further possibilities we will eventually obtain all possible results  . For example , if the markers are pushed to the root node of the derivation tree we will also obtain  ( 5 ) Mitdcm Ferngt as shaben ( lie Mgnner ( liel ' ? augesehen . 
4 Discussion
Properties . Some of the important properties of our approach can be dmraeterised as follows  . 
The strategy is sound and complete in the sense that no ambiguous utterances will be produced  , and all unambiguous tterances are produced . If for a given semantic structure nonn-ambiguous utterance is possible  , the current strategy will not deliver a solution ( it is fore seen that in such cases the planner decides what should happen  )  . 
The strategy is completely independent on the grammars that are bcing used  ( except for the re-lilac6 on derivation trees )  . Even more interestingly , the nature of the underlying parsing and generalion strategy is not important either  . The strategy can thus he used with any parsing - or generation strategy  . 
1 ) uri ~ gth cmonitored generation previously generated structures are reused  , because only the ambiguous partial structures have to be regenerated  . 
Finally , for the proposed strategy to i ) e meaningful , it nmst b c the case that r * ; versible grammars are being used . If this were not the case then it would not makc sense to compare the derivation tree of a generation result with the derivation trees which the parser produces  . 
Generation of Paraphrases . In Neumann and van Noord ( to appear ) we discuss the implementation of a variant of the monitoring strategy  , to solve tile problem of the generation of paraphrases  . 
If parsing an utterance has lead to several readings  , one way in order to detcrmme the intended meaning is to start a claritication dialog  , in which the multiple interpretations of the parsed utter-anccare contr~tcd by restating them in different form  . The dialog partner is then requested to almos the approllriate paraphr ~ qc  , bye~sking her ' Do youn rean X or Y ?' . 
The advantage of our approach is , that it will be ensured that the source of the ambiguity is used dircctly during the production of such paraphrases  . Therefore , the generation of irrelevant paraphrases is avoided  . 
Limitations . It should be clear that monitoring involves nlore than the  . avoidance of aln higu--ities , l , evelt ( 1989 ) discusses also monitorirlg on the conceptual lew d and in onitoring with respect to social standards  , lexical errors , loudness , precision and others . Obviously , our approach is restricted in the sense that no changes to the inlmt 
LF are made.
Meteer ( 1990 ) makes a strict distinction between processes that can change decisions that operate on intermediate lvels of represent a timl  ( optimisations ) and others that operate on produced text ( revisions )  . Our strategy is an exam-pie of revision . Optimisations are useful when changes have to be done during the initial generation process  . For example , in Neumann and AcrEs DECOLING-92 , NANTES , 2328 AO't3T 1992705 F"aoc . Ol : COLING-92, NANTES , AUO .  2328 , 1992 Finkler ( 1990 ) an increment alnd parallel grammatical component is described that is able to handle underspecified input such that it detects and requests missing but necessary grammatical information  . 
Implementation . In Levelt ( 1989 ) and Meteer ( 1990 ) the need for revision respectively monitoring is discussed in detail although they describe no implementations  . As far as we know our approach is the first implementation of revising a produced utterance in order to find an unambiguous alternative  . The underlying parser and generator are described in Shieber et al  ( 1990 ) and van Noord ( 1991 )  . We are using lexicalized unification-based grammars for German and Dutch  . 

This research work has been partially supported by the German Science Foundation in its Special Collaborative Research Programme on Artificial Intelligence and Knowledge Based Systems  ( SFB 314 , Project N3BiLD ) , and by the DFKI in the project DISCO , funded by the German Ministry for Research and Technology under Grant-No  . :
ITW 9002.

Douglas E . Appelt . Bidirectional grammars and the design of natural anguage generation systems  . In Y . Wilks , editor , Theoretical Issues in Natural Language Processing  , pages 206-212 . 
Hillsdale , N.J.:Erlbaum , 1989.
K . DeSmedt and G . Kempen . Incremental sentence production , self-correction and coordination . In G . Kempen , editor , Natural Language Generation , pages 365-376 . Martinus Nijhoff,
Dordrecht , 1987.
Jerry A . Fodor . The Modularity of Mind : An . Es . 
say on Faculty Psychology . A Bradford Book , MIT Press , Cambridge , Massachusetts ,  1983 . 
Anthony Jameson and Wolfgang Wahlster . User modelling in anaphora generation : Ellipsis and definite description  . In ECAI , pages 222-227,
Orsay , 1982.
Aravind K . Joshi . Generation-a new frontier of natural anguage processing ? In Theoretical Issues in Natural Language Processing  3  , New
Mexico State University , 1987.
Willem J . M . Levelt . Speaking : From Intention to Articulation . MIT Press , Cambridge , Massachusetts , 1989 . 
Marie M . Meteer . The Generation Gap-the problem of ez pressibility in test planning  . PhD thesis , University of Massachusetts , 1990 . 
Giinter Neumann and Wolfgang Finkler . A bead-driven approach to incremental and parallel generation of syntactic structures  . In Proceed-tugs of the 13th International Conference on Computational Linguistics  ( COL1 NG )  , pages 288-293 , Helsinki ,  1990 . 
Giinter Neumann and Gertjan van Noord . Reversible grammars for self-monitoring and generation of paraphrases  . In Tomek Strzalkowski , editor , Reversible Grammar in Natural Language Processing  . Kluwer , to appear . 
Giinter Neumann . Reversibility and modularity in natural anguage generation  . In Proceedings of the ACL Workshop on Reversible Grammar in Natural Language Processing  , pages 31-39 , 
Berkeley , 1991.
Stuart M . Shieber , Gertjan van Noord , Robert C.
Moore , and Fernando C . N . Pereira . Semantic-head-driven generation . Computational Linguistics , 16(1), 1990 . 
Gertjan van Noord . Head corner parsing for discontinuous constituency  . In 29th Annual Meeting of the Association for Computational Linguistics  , Berkeley ,  1991 . 
R . Wilensky , Y . Arens , and D . Chin . Talking to unix in english : An overview of uc . Communications of the ACM , pages 574593, 1984 . 
ACRESDE COLING-92 , NANTES , 2328 AOUT 1992706 PROC . OFCOLING-92, NANTES , AUG .  2328, 1992
