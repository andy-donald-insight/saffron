A User Friendly ATN Programming Envi ronment  ( APE ) 
tIansHau geneder , Manfred Gehrke
Siemens AG , ZTZTIINF
W . Germany
APE is a work bench to develop ATN grammars based on an active chart parser  . 
It represent she networks graphically and supports the grammar writer by w in -  ( to w-and menu-based debugging techniques . 
1. ATNs-Attractive , but ....
Augmented Transition Network Grammars are one of the frameworks for developing natural anguage par -sers that has been used sueess fully in a large number of natural anguage systems for many languages since its introduction i the early seventies by Woods\[WOO  701  . 
Three aspects of ATNs , namely applicability in various types of natural anguage systems  , suitability for different languages and the availability of efficient processing methods make ATNs an adequate framework for practically oriented development of natural language parsers  . 
Since the time of its introduction the core of the ATN formalism has proved to be astonishingly stable and the exposition and specification of ATNs given in \[ BAT  78\] turned out to become a quasi-standard . 
One of the five claims stated there , namely perspicuity , deserve some comments , because to us it doesn't seem justified strongly . On the contrary we feel that concerning perspicuity and descriptiveness ATN grammars do have some shortcomings  . These come into playify ouuse the ATN formalism to develop a grammar for a nontrivial subset of a natural language  . 
The main reason for this insufficient perspicuity clearly lies in the possiblities ATNs offer with respectolocal and global register setting and testing  . These facilities , though practically very useful , give an ATN grammar a somewhat procedural character  , the grammar writer has to cope with . In this sense ATNs can be seen as a programming language for writing nondeterministic programs  ( grammars )  . Thus for the development of any larger grammars ( programs ) some sort of programming environment for ATNs not only is necessary but also compensates the lack of perspicuity and it makes the development of ATN grammars a practicable task  . 
2 . Design Considerations for an ATN Environment Examining various ATN environments a\[KEH  80\]  , \[GNE 82\] and \[ CHR 831 for example we developed our ATN programming environment  ( APE ) along following design principles . 
1 ) The various tools the environment offers must be integrated allowing simultaneous grammar editing and testing  . 
2 ) The grarm n are ditor has to represent the network structures graphically allowing the user to access the grammar via the contextfree skeleton of the various networks  . 
3 ) The desigu of the system should make use of techni-ques like multi-windowing  , menue-and mouse-based interaction facilities , in order to make the system usable in an easy manner  . 
With this desiderata concerning the design of such a system  , certain requirements concerning the hardware and software fi  ) r such an implementation are necessary . 
We have chosen Interlisp-D ( Trademark of XEROX ) as basis of APE , which due to its comprehensive display-and interaction facilitie : i ~ proved to be an adequate starting point for the realisation of our ideas  . 
3. Active Chart Parsing as a Framework for an
ATNEn vironment
Active Chart parsing ( \[KAP73\] ) is a highly general framework to implement parsers  . The two main ideas of this approach are to represent the parser's control structure explicitly allowing high flexibility in scheduling the various paths to be followed and to preven the parser from doing the same thing twice using a comprehensive bookkeeping mechanism  . The interaction of these components is shown schematically in figure  1  . 

Figure 1
The possibilities of a flexible scheduling is achieved by means of an agenda  , which at any state of the parser contains all the tasks that are induced by the grammar and not processed so far  . The ordering of the agenda thereby determines the way  , the search space is traversed . With this agenda-based scheduling facility the parser can apply various control structures like depth-first  , breadth-first or heuristic scheduling , even changing it during one parse . 
Such facilities are of interest for " tuning " the parser's behaviour in an intended way  . Agenda-based tasks che-duling also offers the operational facilities for pruning parts of the search space which amounts to switching off certain parts of a grammar during a parse  . 
The second central concept in active chart parsing  , the chart , is a graph structure , which does not only do the bookkeeping of the parsed constituents  ( the inactive edges )  . It also records each of the partial intermediate steps  ( the active edges )  , thus logically representing all the paths in work and all constituents parsed so far offering the possibility to in spectheup to then parsing process  . 
But more important , e . g . for perspicuity , the chart ( i . e . 
its graphical representation ) also can be seen as a des-criptive representation f the parser ' state from a naive simple representation  , whose atomic constructs , the graph's nodes , the active and in activedges , have clear counterpart so the conceptual entities a grammar wri-ter has a naive understanding of  , namely the positions in the sentence to parse ( i . e . the nodes ) , the partial parses spawning between two nodes ( i . e . the active edges ) and already analysed constituents ( i . e . the inactive edges spawning the sequence of words between two nodes  )  . 
Thus a graphical representation f the chart growing as the parser proceeds makes the parsing process easily per spicuable for the user  . 
4 . Description of the Environment 4 . 1 . The Grammar-Editor The user interface to the ATN grammar is built on top of an active graph-like representation f the single networks  , which is initiated by the user in a menu-based manner  . This bird's eyeview gives the user an overall first impression of the global structure of the whole grammar with the type of the  , arc ( PUSH , POP , CAT , JUMP ) and the specification of categorial " information with CAT-and PUSH-arcs  . 
Thus the user is not be a ten with an unnatural , artificial-ly linearized ( for example lispish ) way to represent the basic graph-like concepts of ATNs  . The benefits of such network-based grammar specification facilities have been pointed out by Grimes\[  GR175\]  . 
The networks , displayed in the way described above , additionally offers the user a number of operational facilities  , such as getting : more specific information on a certain arc as for example its actions or additional tests  . 
The user can activate the displayed network's arc and nodes respectively by clicking the mouse  . 
Activating an archere by pops a menu with the following possibilities :- info : Gives a detailed print out of the arc  , including its status ( broken vs . unbroken ) . 
-delete : Deletes the arc from the network , causing a new graphical layout of the network . 
-edit : Edits the complete arc in a mouse-and menu-oriented editor with all necessary facilities to modify various parts of the arc  , such as tests , actions and forms as well as its weight . Lea-ving the editor several checks are performed , putting the user back into the edit mode , if the modified arc structure is incorrect ( e . g . if it contains too many items or items of an incorrect type at the wrong place  )  . 
-break : Puts a break on the arc taking the user into the break mode with interactive facilities  ( as described below ) after the broken arc's actions are performed . 
-unbreak : Removes a break from the arc.
Activating a node in the network offers the following facilities :- info:-insert : Gives a detailed print out of all the arcs star-ting at that node  . 
Allows the user to insert an arc starting at the node activated  , the arc's ending node ( except POP-arcs ) being determined via the mouse . To introduce additional new nodes the user is prompted by the system for subsequent arcs until he specifies a POP-arc or an already existing node a sending node of the last prompted arc  . 
4 00 -merge : A new node N1 is inserted after node N with the leaving arcs of Nnow beginning at  N1 and a new arc between N and N1  . 
4.2. Grammar-Debugger
The user can specify in advance certain construction she wants to be parsed  , thus having the possiblitiy to test certain NP -constructions for example without he overhead of parsing a whole sentence  . 
These debugging facilities can be involved in three ways : primarily while the parser is working in a step per-modeoy means of a user interaction  , secondly during the parser's run by means of a break put on an grammar arc and thirdly system -initiated at the end of the parse giving the user the possibility to restart  . 
In the step per-mode the user can cause a break while watching the chart growing as the parser processes one task after another in the following way  . During the single steps of creating of the chart graphically the system is interruptable to give the user the opportunity to put APE's step per into the break-mode ~ oymouse-clicking the relevant menu's item  )  . 
In the break-mode the user is offered a number of operational facilities which can be accessed activating the chart nodes and edges with the mouse  . When selec-ting an edge the user can get more detailled info ~ ana-tionas for example its weight  , its register environment and its history , consisting of the path through the grammar each arc being augmented with additional information as its current input word  , its register environment and the number of the task being responsible for processing that arc  , which directly reflects the way the scheduling is performed  . But more importantly the ~ . ammartester can also modify the edges in various dimensions  , including the following options : - registers : - weight : - ending edge : The user can change registers by emplo-ying the same language he is used to as a grammar writer  , i . e . in terms of actions defined in the ATN formalism as for example SETRs  , ADDRs or form to be evaluated such as BUILDQs . 
Allows to change of the weight of an edge , affecting the order of further processing . 
With this option an edge can be modified with respect o the part of the input being spanned by it  . 
This last option together with the possibilities of regi-ster modifying renders for example the simple simulation of the parser's behaviour under the assumption of a  ( effectively missing or due to not matching tests blocked  ) grammar arc by enlarging the span of an edge . 
Another more powerful possibility in testing a grammar is the introduction of additional  ( in ) activedges , connecting two arbitrary nodes , which can be achieved via an activation of the starting arc  . This allows the specification of partial parses or parsed constituents  , which-though missing due to some defect in the grammar-the user wants the to make use of in further parsing process  . 
Parallel to all the options presented so far the user can edit the grammar on the fly  , thus being able to modify the grammar just when here cognises certain bugs  . 
Additionally APE gives the user the possibilitiy to manipulate the agenda offering him various actions to be performed on the single tasks l!ke freezing and killing a task  , or changing its weight , this facility provides an advanced grammar writer with very effective means to focus the parser on things that are interesting for him in a certain situation  , abondoning with irrelev cnt paths or postponing them  . 
Finally , when the user has done all the things that seemed useful to himat this break point he can continue the parsing process leaving the step per options as they are or changing them appropriately  . 
At the end of the parsing process the user again gets in a break modegiving him the opportunuity of inserting new edges with the facility to restar the parsing process with this new information  . Thus adding a new in active edge and restarting for example amounts to asking the parser " what would yours results have been with an additional constituent ci from word wj to word Wk ?"  . 
With the facilities described above the user also can easily analyse a configuration when the parser did not succeed in parsing a certain construction ? This description  , though sketchy , should give an impression of the ~ acilitities of APE and the ideas behind it  . An illustration of APE's environment is shown in the appendix  . 
5. Outlook
The described ATN programming environment gives substantial support othe user in building up a working grammar  , but some of APE's aspects aren't completely satts fymg  . ~o a lot of polishing the user interface as well as improving the functionality is still to be done  . 

Snapshot of the system in the break mode.
Primarily we are currently working on an user friendly lexicon handling  . Another augmentation will be the easier global specification of very flne-grained breaks  . 
We ' d like to thank U . Hochges and , C . Maienborn and L . 
Simon for implementing parts of the environment and the colleagues of our labf br many fruitful discussions  . 
7. Literature \[ BAT78\]
Bates , M . , " The Theory and Practice of Augmented Transition Network Gramnmrs '  , in : Bole , L . ( ed ) , " Natural Language Communication with Computers " , Berlin Christaller , T . , " An ATN Prgramming Environment " , in : Bolc , L . ( ed ) , ' ~ Phe Design of Interpreters , Compilers , and Editors for Augmented Transition Networks " , 
Berlin 1983\[GNE82\]
Gnefkow , W . , " Studien zu einer Programmierumgebung ffir Augmented Transition Networks "  , MemoANS-3 , 
Universitatf Iamburg , 1982\[Gill 75\]
Grimes , J . ( ed ) " Network Grammars " , Summer Institute of Linguistics , University of Oklahoma , 1975\[KAP73\]Kaplan , R . M . , " A General Syntactic Processor " , in : Rust in , R . ( ed ), " Natural Language Processing ", New
York 1973\[KEH80\]
Kehler , T . P . , Woods , R . C . , " ATN Grammar Modelling in Applied Linguistics " , Proc . 19th ACL Meeting , 1980\[WOO 701 Woods , W . A . , '~ rransition Network Grammars for Natural Language Analysis "  , Comm . of the ACM 13(10), 1970
I paper submitted for
COLING 86
Bonnby
Yves LEPAGE
GETA , BP 68 dnt versit ~ Sclentirt que et M6d icale de Grenoble 38402 Salnt-Martln-d'H ~ res , FRANCE(Final draft , April 1986)

To deal with specific alphabets is a necessity tn natural language processing  . In Grenoble , thls problem is solved with held of t ranscriptions  . Here we present a language ( LT ) designed to the rapid writing of passage f romone transcription to another  ( transducers ) and give some examples of its use . 

Transcriptions , transducers , multi-alphabet text processing , logical and physical processing of texts . 

In the general framework or natural language processing  , the possibilities of interfaces provtded by the current devices are rather poor  , when censt derng ~ for example , the number of alphabets to be used . The problem of uppercase/lower case lette rs  , that of non-latinal phabets , not mention in gideograms , is UsUally solved by the use of transcript ions in computer science circle dealing w lth natural languages <  BOITET83>  . 
Our idea is to provide a rather simple dev ice allow in grapid writing of programs performing the passage from one transcript i onto another  ( transducers , < KAIN 72>) , with help of a language ( LT or Language for Transcriptions ) based on an abstract automaton . The definition and the implementation of this language were initiated during an eng in eering school project <  MENGAB4>  . The work on this Speclalls ed Language for Linguistic Programming  ( SLLP ) has led to a First version < LT85> in the context o ? a GETA/USMG project . 
It has then been extended in the frame of EUROTRA contract  ETS-5  <  ETS5>  . 
This paper presents : the semantics of LT in automata theory  ; the syntax of LT briefly described ; Indications on the Implementation ; some appll catlons . 
I . SEMANTICS OFI_TINAU TO MATA THEORY input tape .   .   . a < strx > .   .   . a < strx > READINGHEAD .   .   .   .   .   .   .  ~  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . l .   .   .   .   .   .   .   . 
. . . . . I .   .   .   .   .   .   . I state EqI-->!q'I---t .   .   .   .   .   . I---writing head ~ output tape < strz > < strz > b  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Given a state and a character read , the transducer goes Into another state and determines which character to write onto the output tape  ( transition )   . 
Tile most simple transducer is deterministi c and r~la~r  . : it has only one input tape and only one output tape  ; there is only one way for reading and writ ing  ( rlg htwards )   ; It reads only one symbol at a time ; it writes only one symbol for one symbol read  ; there are no other objects such as stacks or balloons  . 
2, THEABSTRACT AUTOMATONOFLT
Tile " basic " automaton is extended in LT into three directions  1  . availability of the right context by means of two reading heads  . The transition is function of the head ( " forward " or " current " ) used in the reading of the input tape . A special transition performs the return of the " forward " head onto the position o f the " current " one  . This permits to simulates the readlng of the empty string and places the abstract automaton or LT in the class of tile " sequential transducers " as defined in <  KAIN72>  ;  2 . use of the notions of attributes in thes tates  . 
A state Isanetique tte with attr ibutes  . The values of some attributes are tested before a transition  ( condition ) and the values of some attributes are changed after  ( actions )   . This theoretically increases the non -determinism of the automaton  ;  3 . work on strings and not only on characters , which sets defl nitlve iy the automaton In the class of " sequential transducers "  . 
1." BASIC"TRAN~JCER
Transductlon may be regarded as a simultaneous operation of reading and writing  , writing being a function of reading < AHO , UL?2> , < CHAUCHE 74 > . A transducer Isa machine with an input tape and an output tape  . 
?  .   . < strx > < stry > .   .   . < strx '> < stry '> .   .   .   .   .   . T .   .   .   .   .   .   . I .   .   .   .   .   .   .   .   .   .   .   .   .    .   .   .   .   .   .   .   . f .   .   .   .   .   .   .   . 
I ~! I
II
Iqt-->Iq'I
IAl = ai IIAI = ai'1 .   .   .   . I .   .   .   .   .   .   . I---<sir z > .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
< strz '> .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 

The bower of the LT automaton 1! ; restrained to a transducer wlth the fol lowing characteristics : one input tape and one output tape  ; determinism ; states defined byetique ttes and attr ibutes  ; two reading heads . 
The abstract LT transducer may b ( ~ under-used as a deterministic ftnlte- state machine  . So the class of languages which carl be an a lysed by LT comprises tl ~ e class of regular languages  . 
On the contrary to what we wrote in < ETS 5> , LF can be used to define an accepter of til efamous context-dependent language anbncn  . It Is the semi-regularity which per lnl tstoslmul ~ Ltestacks  . This means that \[ tie class of languages analysed by the abstract LT transducer compr is es some of the centext-dependent languages  . 
Using the Chomsly hierarchy we say that I_T can analyse all the languages of class  L3   ; some of the languages of class L ~ ; to know If all laeguagl . ~ sIn 1_2 can be analysed by LTIs an open prob 1 em ; some of the languages of class I_1 ; 
II . SYNTAXOF . LT

After " a presentation of the synta ; ~ of the strlngs , we introduce the definition of cond it ions and actions based on the attributes  . 
With these three objects ( strings , conditions and actions ) we define the rules which serve to write the bundles  . 
Finally , we sketch the general structure of a I . T program . Incidentally , the concrete syntax of LT has taken its Inspi ration from tllat of Artane-  -78 < DSEI > . 
J-.ZHB__S_!R_ING$_
A string Isa concatenation of simples tr ings  . A simple strlng may be a stringel characters or hexa decimal codes or special symbols for the end of the line and tile end of the file  . 
Any strlng of a certain length may be read wtth help of a speclal designator  . 
There exist three other conventions for the output tape to desI~nate the same string as read in input  , or wlth letters only in UD Der-case or l ll lower-case  . 
2._THEOON\[!\[TIONSAND~IO~S
Acgndl__t_lonIs a first order predicate on the attributes  , expressed in the usual syntax ( logical connectors : no , and , or ; parentheses allowed ) . The attributes belong to one of the three c lasses : scalar  , set or arithmetic ( inferior to an upper bound )   . 
An acU_oP_can be an assignment of a value to a variable  , al~st of actions carried out condition a lly  , or , a block containing alls to factions . 
Thls notion is extended to three predeflned actions  . 
The first has no impact at all oil the semantics of the transduct to n  ( displaying a message on an auxiliary fi le  )   ; the two others , on the contrary , are significant for the transduction ( displaying a return code on the error fil e and stopping the transductlon  ; moving the " forward " head back to the posit ion of the " current " head  ( seml-regularlty )   )   . 
A rule describes a ( ; lass of transitions of the shape : inputs tring/condition == output string/act ions  . 
the symbol ? at the head of the rule sign if ies that the inpqt string is to be read under the " forward ' the ad  . 
The philosophy of LTs to put together the possible passages from one et l quetto to another into a bundle of tile shape : de < et lquettel > a < etiquet  te2> viarllle lru le2   .   .   . rule N4 . GENERAL STRUC . TU , RE_OFA_TPROGRAMALT progral nIs divided into sections  . 
OnemLIS t give the lnit lalstair of the automaton  . 
Others give the definition of attr ! butes and their lelt talls at lon  . 
Other optional sections define c~n~l ~ lons , a ? t . JQDs and LUleA which can be referred to by their names in the bundles  . 
The other sectlons glve the bundles explt cl tely  . 
III~_IM@LEMENTAjION
In order-t of a cl 11 late prograrr lYHng in LT , an environment for this language was writ tent n 
Prolog-CrIss < PROLOG 85>:
The manager allows the manipulation of LT programs  . The usua ~ functions of an interactive envi ronment  ( PROI_OG , APL ) are defined : loading , saving , editing , ltsttng .   .   .   . 
The compiler was Implemented with use of a generator Of a oaly sers inspired from METAL <   METAL82>  , but less powerful . 
The Interpreter Is a mock-up in Prolog which works on the abstract trees resulting from com  #tlation  . 
The user must specify the files wbtch will be the input and output tapes  , and the LT program to be interpreted . Interactive traces are possible . 
The design of a Pascal version of the In terp reter in order to increase the rate of execution is currently in work  . 
IV . APPLICATIONS ! ~ EX~MPL#OF . EBO ~ BA ~
To Illustrate the syntax of LT , we glveable ce of the program for the ana lysisOfAnBnCn on the next page  . 

I let at initial < read_AB > .
Ilvariables ! last char:(A,B,C,EOL ) . --last character read ! I ** Reading An Bn , reading alternatively A and B undert the current and the forward heads respectively  . 
Ide < readAB > a<readAB > via 1 ' A'/last char=B==/\]astchar := A . 
f?'B'/last char=A ==/ last char := B.
l d e < r e a d A B > a < r e a d B C > v l a
I?'C'/last char=A==/last char:=C.
lde<readAB>a<fail>via!/~astchar = B == '*** Rejected string  . ' eel . 
I--If not A 1? /last char=A=='*** Rejected string . ' eol . 
I--If neither Bn or C
I 1 , * Readlng of BnCn:same prlnclple as for An Bn  . 

!!~* Final section for the analysis.
Ide < read C > a < success > via
I'C'/last char=EOL =='*** V all dstr ing  . ' eol . 
Ide < read C > a < fail > via
I =='*** Character Cmissing . ' eol.

2 . TRA~SCRIPTIONS_FORDIACRITICS LET TERS There ex is ts in French a lot of diacritics and accents  . In the frame of Eurotra , a transcrlptlon for the diacritics was proposed  .   14ere tsatext in the Eurotra Short Transcript ion and its responding form In the actual F rench orthograph  . The passage between the two forms was perfo rmed by a LT program  . 

! Uncertain Mopt flory (1533) , puts l ' Imprlmeur IE tienne O Gler ( out Pubilaen 1540 Dela Punctuation ! de la Langue Francl Soyse , blus des accents d'y celie ! ) l'employe l2rent notarament pour marouerlachuteId'une&l' Intellrteur d ' unmot : vral  l3ment   , 
Ipatl 3na , etc.
I(Grellvsse , Le Ben Usage ) + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + Uncertain Montflory (1533) , pulsl'lm primeur IE tienne Dolet ( qul Publlaen 1540 Dela Punctuation ! de la Langue Franooys e , plus desaeoents d'y celle ) ! l'employ~rent not amment pour marquer la chute d ' un Ie & l'lnt ~ rieur d ' unmot : vra ~ment  , basra , etc . I(Gr~vtsse , Le8on Usage)I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +  3~ PHYSICAL AN_~_GICAL PROCESSING OF TEXTS_The use o  #the LT language is not limited to the t rans crlbt lons  ; one of Its interesting features , and not the least one , is that physical and logical processing o f texts coutd be  . carried out with Its help . 
+  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + l . sp2fl . usonf IAvant-dernter exemple : I + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + In the previous text , the first twollnes correspond to format t ing commands of SCRIBERE  ( a text formatting software developped at GETA and based on SCRIPT  , an IBM text formatting software , < SCRIBERE 85 > ) Transducers have been written which reflec ttables o?lnformations about punctuat ion  , formatting commands and structural separators  . Here Is the result of the application o f the sequence of those transducers written In LT on the fallow lng text  . 
404 l . Sp 2: type = format , format = paragraph , level = l , start = nol 1 . US on : tY be = format , format=beg_underlt , level = 7 , t
I start = yes , ovi = end under lll

I-: level = 9 , start = no , content = hyphen ! fdernter ! f exemple II :: teve l=3  , start = no , conteot=colon !

The language LI defined and implemented as above was tested on various examples : passages from transcriptions to others  ( Russian , 
Thai , Greek, .   .   .  )  ; -logical and physlcal processing of texts  ; analysis of the context dependent language

Though we Intentionally limited the syntax of LT and forced non-determinism In the ln terp retatlon to fit our purpose  , the power of thls language seems to be rather sufficient for the applications it is sbeciallsedIn  . 
REFERENCE ~< AHO , UL 72> AHQ Alfred V . , ULLL ANJ effrey D . 
The Theor ~ of Parsln ~ L , Translat lqn aod_C ~ Ul ~ q Prentice Hallser ies in Automatic Computation  ,  1972 . 
< BOITET 83 > BOITET Christian
C onve0_L!pEIs de_$& ansc?j#~toD~puEA~sais ! Aet pour ' \] Lar ~ vlslon de textes ~ LL ~ Ar  i#De-78 Docu ~ eet att pn ~_ ~ s t ~ m@russe ~ fran ~ alsver ~! ~

R apport DRET n ? 41 , GETA , Grenoble , d ~ cembre 1983 . 
< CHAUCHE 74> CHAUCHEJ acques
Tr ~ Es ~ uct ~ M  ~ & ~ or esc ~ e ~
E~dese ~ r6a ll & at londeSys ~ es~ltqu ~ saux gr_Ammaire & t rADs for ma$~onnel\]~s  Th6se d ' Et at , Grenoble , d ~ cembre 1974 . 
< DSEI > BOITET Christian , editor Le o1~&q_~DJ~s&r Arlaoe-~d 6  ~  9   8   2   ( Volume 1 , Partle 1: lelogt clel ) avrl l 1982
Convention ADIn ?81/423
Cab Sogetl Logiclel-GETA-Champollion < ETS5> LEPAGEY ves , VAUQUOIS PhtllppeLO ~ L!#J~I a~d ~ . ! c~Q & essir ~ of texts
Eurotra contract ETS 5, Part B
Intermediate report number 2 , September 1985 < KAIN 72 > KAIN Richard Y . 
~oma ~ L ~_Theorj ~: MA cllioe ~ and L ~
MacGnaw-Hill Computer science-series 1972  <  LT85> LEPAGEYvesL~nlan~gAgA_~D~c\[Nc~on~a~e\] u ~ sale Nr Internal document  , GEFA , September 1985  <  METAL82> MELESEBertr and METALnlanaed~p ~ at to n Dourle syst~mA 
M  #N_Z O_R
T . S . I . vol . 1  , n ? 4 ,  1982 , pp 275-285  <  MENGA84> MENGA Daniel@g_ag&~E a Dsduct_jID ~ LTR apport detrols l ~ meannie ENSIMAG  , Juin 1984  <  PROLOG85> CRISS-Untverst t6 IIPRL~ES & ~& ex ~ LeDslonCLqLlan#a ~ e Prolo_~qCRISS-UnlversIt ~ IIG renoble  , Julllet 1985 < SCRIBERE85>8ACHLITDaniel , VERASTEGUINels on

Internal document , GETA , Aprll 1985
