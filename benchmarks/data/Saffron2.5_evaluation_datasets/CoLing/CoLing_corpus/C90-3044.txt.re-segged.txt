Toward Memory--based Translation
Satoshi SATO and Ma.koto NAG AO
Dept . of Electrical Engineering , Kyoto University
Yoshida-honmachi , Sa.kyo , K.yoto , 606, Ja . pan

Abstract
An essential problem of example-based translation is how to utilize more than one translation example for translating one source sentence  . 
This 1 ) a per proposes a method to solve this problem . We introduce tile representation , called . matching e , ,z:pressio~z , which tel ) resents the combination of fragments of translation examples  . The translation process consists of three steps :   (  . 1 ) Make the source matching expression from lhe source sentence  .   ( 2 ) Trans Dr the source matching expression into the target matching expression  .   ( 3 ) Construct the target sentence from the target matching expression  . 
This mechanism generates some candidates of translation  . To select , the best translation out of them , we define the score of a translation . 
1 Introduction
Use of extracted information fiom examples or example-based translation is becoming the new wave of machine translation  . The ba . -sic idea . of example ~ based translation is very simple : translate a source sentence by imitating the translation example of a similar sentence in the database  . The idea first appeared in \[ Nagao84\] , and some research has followed it \[ Sumita 88\]\[Sato   89\]\[Sadler   89a  . \]\[ Sadler 89 b \] . 
But a great deal of effort is still needed to im -plemenl the idea  . 
In our previous work , we show how to select.
the best target word in case frame translation based on examples \[ Sato  89\]  . In this paper , we concentrate on two problems : 1 . l to w to combine some fragments of translation examph ~ s in order to translate one sentence ?  2  . tlow to select tile best tra . nslation out of in any candidates ? We show partial solutions for them in  MBT2  . 
M BT2 is the second prototype system in our Memory -based Translation Project  . . MBT2 ca . n do bidirectional m~nslation between an English word-dependency tree and a Japanese word -dependency tree  . It is implemented in Sicstus

2 Need to Combine Frag-ments
The basic idea of example-based translation is very simple : translate a source sentence by im -itating the translation example of similar sen -tence in the database  . But in many cases , it is necessary to imitate more than one translation example and combine some fragments of them  . 
Let's consider the translation of the following sentence  . 
(1) He buys a book on international politics.
If we know the following translation examt ) le ( 2 ) and ( 3 )  , we can translate sentence ( 1 ) into sentence ( 4 ) by imitating examples and coln bin-ing fragments of them  . 
(2) He buy sanote book .
Kate hanou to woka ~.
(3) I read a boo\]~on international polilics.
Watt , hihakokusaiseij init , suitel : akareta honwoyomu . 
(4) Kate hakokus Mseij in its uitek M~retahon
WOka~ll.
It is easy for a human to do this , but not so for a machine . The ability to combine some fragments of translation examples is essential to example -based translation  . A lack of this ability restricts the power of example-based translation  . In this paper , we concentrate on the implementation of this ability on machine  . 
i 2473 Matching Expression
To implenrent the ability to combine some fragments of t  . ra . nslation example in order to translate one sentence  , we must determine the following : ? how to represent translation examples ? what is a fragment ? how to represe  . the combination of flag-lnent . s3 . 1 Trans la t ion Database The translation database is the collection of translation examples  . At ~ anslation example consists of three parts : ? an English word-dependency tree  ( EWD ) ? a Japanese word-dependency tree ( JWD ) ? correspondence links
For example , in Prolog , ew de (\[ el , \[ buy , v\] , \[ e2 , \[he , pron\]\] , \[ e3 , \ [ notebook , n \] , \[ e4 , \[ a , det\]\]\]\]) . 
%% He buy sanote book .
j w d_e(\[jI , \[kau , v\] , \[ j2 , \[ ha , p\] , \[ j3 , \[kare , pron\]\]\] , \[ j4 , \[ wo , p\] , \[ j5 , \[ nouto , n\]\]\]\]) . 
% % Karehanou to wo kau.
clinks(\[\[el , jl \] , \[ e2 , j3\] , \[ e3 , j5\]\]) . 
% % el <-> jl , e2<->j3,e3<->j 5
Each number with prefix'e'or'j'in word -dependency trees represents the ID of the subtree  . Each node in a tree contains a word ( in root form ) and its syntactic ategory . A correspondence link is represented as a pair of iDs  . 
3.2 Translation Unit
A word-dependency ( sub ) tree which has a correspondence link is transhttable  ;   . g . el , e2, e3, jl,j3, j5 . A translatable tree in which some translatable subtrees are removed is also trans-lata  . ble ; e . g . el-e2 , el-e3 , el-e2-e3 , jl-j3 , jl-j5 , jl-ja-jS . Both of them are tra . nslat-M ) le fragments . Sadler calls them translation w , ,its\[Sadler 89a , \] . 
3.3 Matching Expression
Next we will introduce the concept'matching expression  . ' Matching expression ( ME ) is defined as the following : < HE > :=\[< ID > I<ME-Commands >\] < ME-Commands > : :=\ [\] or\ [< ME-Command > I < ME-Commands >\] < ME-Command > : :=\[ d  , < ID >\] or\[r , < ID > , < ME>\]or\[a , <ID> , < ME>\]%% delete<ID > %% replace < ID > %% with < ME > %% add < ME > as a %% child of root %% node of < ID > Every ID in an ME should be translatable  . 
We assume the example in Section 3 . 1 and the following example . 
ewd_e(fell , freud , v\] , \[ el2 , \[' I) , prOn \]\] , \[ el3 , \ [ book , n \] , \[ el 4 , \[ a , det\]\] , \[ elb , Ion , p\] , \[ el 6 , \[ politics , n \] , felT , \[ international , adj \]\]\]\]\]1) . 
Y , Y , I read a book on international %% politics.
jwd_e(\[jll , \ [ yomu , v\] , \[ j12 , \[ ha , p\] , \[ j13 , \[ watashi , pron\]\]\] , \[ j14 , \[ wo , p\] , \[ j15 , \[ hon , n \] , \[ j16 , \[ ta , aux \] , \[ j17 , \[ reru , aux \] , \[ j18 , \[kaku , v\] , \[ j19 , \ [ nitsuite , p\] , \[ j20 , \ [ kokusaiseiji , n\]1\]\]11\]\]\]) . 
% % Watashi hakokusaiseij initsui . te %% kakare tahonwoyomu . 
clinks(\[ell , \] ll \] , \[ e12 , j13\] , \[ e13 , j15\] , \[ e16 , j20\]\]) . 
Under this assumption , the word-dependency tree ( a ) can be represented by the matching expression ( b )  . 
(a)\[\[buy , v1 , \[\[ he , pron\]\] , \[\[ book , hi , \[\[ a , det\]\] , \[Ion , p\] , \[\[ politics , n \] , \[\[ international , adj \]\]\]\]\]\]% % He buys a book on international 
Y , Y , politics.
( b)\[el , \[ r , e3 , \[ el3\]\]\]2482
Source WD(SWD ) #
Source ME ( SME)
Target ME ( TME ) g ~., ompo ~ itiol ~\]
Target WD(TWD )
Figure 1: Flow of Translaton
The matching expression ( b ) consists of two transla , tion units : el-e3 , e13 . And it has the information to combine them . 
4 Tl'anslation via Matching

Figure 1 shows the flow of the translation pro- . cess . The translation process consists of three steps : decomposition  , transfer , and composition . This process generates all candidates of translation using Prolog's backtrack mechanism  . 
4.1 Decomposition
In decomposition , the system decomposes a source word-dependency tree  ( SWD ) into translation units , and makes a source matching ex-pression ( SME ) . For example,
SWD =\[\[ buy , v\] , \[\[ he , pron\]\] , \[\[ book , n \] , \[\[ a , det\]\] , \[\[ on , p\] , \[\[ politics , n \] , \[\[ international , adj \]\]\]\]\]\] SME =\[ el , \[ r , e a , \[ e l3 \]\]\] The main tasks in this step are to retrieve translation units and compare the source WD with retrieved translation units  . To retrieve translation units quickly , we use some hashing techniques . There are two program to do the comparison task ; one for English WDs and one for Japanese WDs . In comparison of Japanese WDs , the order of subtrees is not inlportant . 
To reduce the search space and the number of candidates  , we define replace ablity between syntactic categories  . If two nodes are replaceable , system makes only ~ replace-command . As a result , the the system does not make some matching expressions  ; e . g . 
\[ el,\[d,e3\],\[a , el,\[e13\]\]\]4 . 2 Transfer in the transfer step , the system replaces every ID in the source matching expression with its corresponding ID  . For example,
SME=\[el,\[r,eS,\[el3\]\]\]
TME =\[ j1,\[r,jS,\[j15\]\]\]4 . 3 Composition in the composition step , the system composes the target word-dependency tree according to the target matching expression  . For example . 
TME =\[ jl,\[r,j5,\[jlS\]\]\]
TWD=\[\[kau , v\] , \[\[ ha , p\] , \[\[ k are , pron\]\]\] , \[\[ wo , p\] , \[\[ hon , n \] , \[\[ ta , aux \] , \[\[tern , aux \] , \[\[kaku , v\] , \[\ [ nitsuite , p\] , \[\[ kokusaiseiji , n \]\]\]\]\]\]\]\]\] ~ , ~ . Kate hakoku saiseij init suite ~ , ~ , kakaretahonwokau . 
This step divides into two substeps ; the main composing step and validity checking . In the main composing step , there is no ambiguity with one exception . Because an add-command\[a , <ID> , < ME >\] specifies only the parent node ( < ID > ) to add the tree ( < ME > )  , there are some choices in composing English word -dependency trees  . In this step , all possibilities are generated . 
Validity of the composed word-dependency trees are checked using syntactic categories  . 
Validity is checked in every parent-children unit . For example , in the above target word-dependency tree , \[ v , \[ p , p\]\] , \[ p , \[prom\] , \[ p , \[ n\]\] , 
In , \[ aux \]] . . . .
are checked . A unit is valid if there is a unit which has the same category pattern in the database  . A word-dependency tree is valid if all parent -children units are valid  . 
3249 z "/7 t2L1"/~lII,\7/571,7 . 2  .   .  ~  . _ . ___--restricted enviornment ~/"'~"\' nll /  m2   ( = n2 )  " , mlo/m , 8 2 /  , -d Translation Gx ~ mple Source ( or Target ) WD Figure 2: Restricted Environments of TU 5 Score of Translation To select the best translation out of all candidates generated by system  , we introduce the score of atra . nslM . ion . We define it based on the score of the matching expression  , because the matching expression determines the translation out i  ) ut . The scores of . the source matching expression and the target matching expression are calculated separately  . 
5.1 Score of Translation Unit
First , we will define the score of a translation unit . The score of a translation unit should reflect the correctness of the translation unit  . 
Which translation unit is better ? Two main fac-t . or s are : 1 . A larger translation unit is better . 
2 . A translation unit in a matching expression is a fragment of a source  ( or target ) word-dependency tree , and also a fragment of a translation example . There are two environments of a translation unit ; in a source ( or target ) tree and in a translation example . The more similar these two environ-meuts are , the better . 
To calculate 1 , we define the size of a translation unit ( TU ) . 
size(TU ) = the number of nodes in TU
To calculate 2 , we need a measure of similarity between two environments  , i . e . external similarity . To estimate x ternal similarity , we introduce a unit called restricted environment . 
A restricted environment consists of the nodes one link outside of a TU normally  . If corresponding nodes are same in two environments  , those environments are extended one more link outside  . Figure 2 illustrates restricted environments of a TU . We estimate x ternal similarity as the best matching of two restricted environments  . To find the best matching , we first determine the correspondences between odes in two restricted environments  . Some nodes have several candidates of correspondence  . For example , n7 corresponds with rn6 or m7 . In this case , we select the most similar node . To do this , we assume that similarity values betwee nodes ( words ) are defined as numeric values between 0 and 1 in a thesaurus . When the best matching is found , we can calculate the matching point between two environments  , mpoint ( TU , WD ) . 
mpoint ( TU , WD ) = summation of similarity values between corresponding nodes in two restricted environments ~ t the best matching We use this value as a measure of similarity between two environments  . 
Finally , we define the score of a translation unit , seore ( TU , WD ) . 
score(TU , WD ) = size(TU)x(size(Tg ) + mpoiut(TU , WD )) For example , we assume that the following similarity vMues are defined in a thesaurus  . 
2504 sim(\[book,n\],\[notebook,n\],O.8).
sire(\[buy , v\],\[read , v\],0.5).
sire(\[hon,n\],\[nouto,n\],0.8).
sim(\[kau , v\],\[yomu , v\],O.5).
Then i . he scores of translation units in the previous section are the followings  . 
jl-j5 I\['!\[0. S
IJs___2_JLL 5 . 2 Score o f Match ing Express ion \]? he score of a nlatching expression is defined as the following  . 
score . (  . ' tiE : . It'D)F ~ YUCME score(TU , WD ) sizc(WD ) 2
FOl ; exaulple , \[ jl , \[ r , jS , \[ j15\]5 . 3 Score of Translation Finally , we define the score of a translation as the following  . 
scur ~: ( SWD . SME , TME , TWD ) = ~, ni ~ ( seo , ' ~( SME . SWD ) , score(T~IE , TWD )) For example , the score of the translation in ? the previous section is  0  . 6 . I2 . 
6 Examples
The English verb eat corresponds to two
Japanese verbs , tabcrvandokasu . For exam-pie.
(4) Themal leats w.:ge tabtes.
Hitohay as alwotaberu.
(5) Acid eats metal.
Sanhakinzoku wooka.qu.
Figure 3 shows translation out l ) uts based on example (  , t ) and (5) by MBT2 . MBT2 choose sht beru for he cat . st  ~ ot a , to esandokasu for sulfuric acid calsir on . 
*** Tr & nslationSource ***\[\[ eat , v\] , \[ the , pron\]\] , \[\[ potato , n \]\]\]
Y , Y , Heeatspotatoes.
*** Translation Results ***
No . I(Score = 0 . 5889)\[\ [ taberu , v\] , \[\[ ha , p\] , \[\[ k are , pron\]\]\] , \[\[ wo , p\] , \[\[ jagaimo , n \]\]\]\]
No . 2 ( Score = 0 . 4 S 56)\[\[ ok as u , v\] , \[\[ ha , p\] , \[\[ k are , pron\]\]\] , \[\[~ o , p\] , \[\[ jagaimo , n\]\]\]\]*** TranslationSource***\[\[eat , v\] , \[\[ acid , n \] , \[\[ sulfuric , adj \]\]\] , \[\[ iron , n\]\]\]%% Sulfuricacideatsir on . 
*** Translation Results ***
No . I(Score = 0 . 5500)\[\[okasu , v\] , \[\[ ha , p\] , \[\[ ryuusan , n \]\]\] , \[\[ wo , p\] , \[\[tetsu , n \]\]\]\]
No . 2 ( Score = 0 . 4688)\[\ [ taberu , v\] , \[\[ ha , p\] , \[\[ ryuusan , n \]\]\] , \[\[ wo , p\] , \[\[tetsu , n\]\]
Figure 3: Translation Outputs by MBT2   5   251   7 Discussion Although MBT2 is not a full realization of Na-gao's idea . , it contain some merits from the original idea . 
1. It is easy to modify the system.
The knowledge of the system is in the form of translation examl  ) les and thesauri . We can modify the system with addition of translation examples  . 
. It can do high quality translation.
The system sees as wide a scope as possible in a sentence and uses the largest translation units  . It produces high quality translations . 
. It can translate some metaphorical sentences.
In the system , semantic information is not used as constraints . As a result , the system can translate some metaphorical sentences  . 
Demerits or problems of the system are : 1 . A great deal of computation is needed . 
2. Can we make good thesauri ?
The first l ) roblem is not serious . Parallel computation or some heuristics will overcome it  . But the second problem is serious . We have to study how to construct large thesauri . 

The authors would like to thank Mort Webster for his proofreading  . 
References\[Nagao84\] Makoto Nagao , A Framework of a Mechanical Translation between Japanese and English by Analogy Principle  , in ARTI-
FICIAL ANDtIUMAN INTELMGENCE(A . Elithorn and R . Banerji , editors ) , Elsevier Science Publishers , B . V , 198 . t . 
\[ Sadler89a \] Victor Sadler , The Bilingual
Knowledge Bank ( BKB ), BSO/Research , 1989.
\[ Sadler89b\]Victor Sadler , Translating with a simulated Bilingual Knowledge BankBKB  )  , 
BSO/Research , 1989.
\[Sato89\] Satoshi Sa . to and Makoto Nagao , Memory-based Translation , IPSJ-WG , NL-70-9 ,  1989 . ( in Japanese )\ [ Sumita88\]E . Sumita and Y . Tsutsumi , A Translation Aid System Using Flexible Text Retrieval Based on Syntax-Matching  , TRL Research Report , TR-87-1019 , Tokyo Research Laboratory , IBM ,  1988 . 
8 Conclusion
This paper describes how to combine some translation units in order to translate one sentence and how to select tile best translation out of some candidates generated by system  . To represent he combination of fragments , we introduce the representation called matching expression  . To select the best translation , we define the score of translation based on the score of the matching expression  . 
This framework can be applied to not only the translation between word-dependency trees but also the translation between other data structures  . We hope that generation can be implemented in same framework as the translation from a word -dependency tree to a list or string  . 

