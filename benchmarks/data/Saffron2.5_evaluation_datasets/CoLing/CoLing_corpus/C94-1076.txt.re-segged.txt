Minimal Change and Bounded Incremental Parsing
Mats Wirdn
Fachrichttmg 8.7, Comput cr linguistik
Universit , ~ tdes Saarlandes
Postfach 11 50
D-66041 Saarbr/icken , Germany

Abstract
Ideally , the time that an incremental algorithm uses to process a change should be a fimction of the size of the change rather than  , say , the size of the entire current input . Based on a formalization of " the set of things changed " by an increInental modification  , this paper investigates how and to what extit is possibh ~' to give such a guarantee for a chart-ba  . se ( l parsing frmne-work and discusses the general utility of at ninlmality notion in incremental processing  ) 1 Introduction 1 . 1 Background Natural-language computing has traditionally been understood as a " batch-mode " or " once-only " process  , in which a problem instance P ( shy , a text ) is mapped as a whole to a solution S ( such as air analysis of the text )  . I Iowever , in highly interactive and realtime applications - -for example  , grammar checking , structure editing and online translation -- what is required is efficient processing of a sequence of small changes of a text  . Exhaustive recomlmtation is tber , not a feasible alternative . Rather , to avoidms much recomputation as possible , each update cycle must reuse those parts of the previou solution that are still wdid  . We say that an algorithm is incremental if it rises information from an old solution in computing the new solution  . 
The problem of incremental processing can be stal . edits follows , using a notation similar to that of All ) ern et al . \[1\]: Assume given a problen r instance P ( a representation of the current input )  , a solution S ( the current output ) , and a modification Aptop . 2 The modification resu l ts in a new problem instance P ' = P ? At  ,   , where ? is a composition operator . The task of an in-1I would like to thank Ralph RS nn qulst as well as Greg or Erbach and other colleagues in Snarbrfieken for discussions on the material presented here  , Peter Fritzson for originally alerting my attention to Ramaling am and tleps'paper  , and the anonymous referees . This research as been flmded by the Cerman Science Foundation  ( DFG ) through the Sonder for schnngsl ) erelch3 14 , project N3 ( BiLD ) . 
~ A terminological note : we use " input change " and " modification " as well as " output cllange " and " update " synonymously  . 
z ~ p ~ P ' = P ( DA p

S . ~- S'--S(I ) Asl ; ' igure 1: Batch-mode versus incremental cornlmtation . 
cremental algorithm is then to produce an upd~te As in the old solution such that  . 5' ? As is a solution to P ( DA p ( see figure 1) . At this point , nothing is stipula-ted about timamount , of information it , Stlmt should be reused in S ' . 
To show propertie such imcorrectness and complexity of incremental algorithms  , it is necessary to esta-blish a formal measure of " the set of things changed "  . 
This me , in ures llouhl capture timminimal changer e -suiting from a modification and  , moreover , should be independent of any particular algorithms R  ) r incremental update . One way of achieving this is to compare the results obtained by batch-mode processing of the inputs before and after the change  , respectively ( Wirfin and l ~ . Snnquist\[15 , 17\]): By forming tile " difference " l ) el . ween the lmtch-modes oh , tions S and ? , 1 obtained before ; tlt(\]after a modill cationAt , to P , we obtain a parameter As , m ' which captures t in . ' minimal change in a way which is indeed imlependent of the incrementalul  ) date . Given that A . s , , , i " corre . sl ) onds precisely to what any sound and complete incremental algorithm must do  , it , can be used as a blmisl brcorrectness proofs for suclt algorithms  ( given tl , at the batch-rhode algorithm is correct ) . 
Fnrthermore , As mi " can be used ms a basis of complexity analyses : Ideally  , each update cycle of an incremental algorithm slmuld expend an amount of work which is a polynomial fimction of the size of the change  , rather than , say , tile size of tl , eentire current input . 
However , making this notion precise in a way which is independent of particular incrementallg or ithms i not these lines are Goodwin  \[3  ,  4\]  ( reason maintenance ) and Reps\[11\] ( language-basediting )  . More recently , Alpern et al\[1\] and Ramaling am and R . eps\[9 ,   10\] have provided a framework for analysing incremental algorithms  , in which the basic measure used is the snm of the sizes of the changes in the input and output  . This framework assumes that the modification of the input can be carried out in o  ( IAPI ) time , where the generic notation IXI is used for the size of X  . Furthermore , it assumes that \] As , m , \] denotes the minimal IAsl such that S ( 9As solves P ( 9 Ap . Alpern et al then define = lapl+IzXs , ~ . I as the intrinsic size of a change . 
The choice of 6 is motivated as follows : IAph the size of the modification  , is in itself too crude a measure , since a small change in problem instance may cause a large change in solution or vice versa  . IAs . . , ,I iv then chosen as a measure of the size of the chauge in the solution  , since the time for updating the solution can be no less than this  . The 5 measure thus makes it possible to capture how well a particular algorithm performs relative to the amount of work that must be performed in response to a change  . 
An incremental algorithm is said to be bounded if it can process any change in time O  ( f ( 5 ) ) , that is , in time depending only or ,  5 . Intuitively , this means that it only processes the " region " where the input or output changes  . Algorithms of this kind can then be classified according to their respective degrees of boundedness  ( see Ftamaling am and Reps\[10 , section 5\]) . For exam-pie , an algorithm which is linear in 5 is asymptotically optimal . Furthermore , an incrementallg or ithm is said to be unbounded if the time it takes to update the solution can be arbitrarily large for a given  5  . 
It might seem that what has been discussed so far has little relevance to natural language processing  , where incrementality is typically understood , as the pieceme M assembly of an analysis during a single left-to-right a pass through a text or a spoken utterance  . In particular , incrementality is often used as a synonym for interleaved approaches  , in which syntax and semantics work in parallel such that each word or phr ~ me is given an interpretation immediately upon being reco -gnized  ( see , for example , Mellish\[7\] and lladdock\[5\]) . 
l lowever , the two views are closely related : The " left-to -right view " is an idealized  , psycholinguistically motivated special case , in which the only kind of change allowed is addition of new material at the end of the current input  , resulting in piecemeal expansion of the analysis . Moreover , the interleaving is just a consequence of the fact that every piece of new input must  , in some sense , be fully analysed in order to be integra-ted with the old analysis  . 
To distinguish this special case from the general case  , in wt fich arbitrary changes are allowed , Wird n\[15\] refers to them as left-to-right ( Lll ) incrementality and 3Strictly speaking front-to-back or begin Mng-to-end . 
full incremenlalily , respectively . The former case corresponds to online analysis - -that each prefix of a string is parsed  ( interpreted ) before any of the input beyond that prefix is read  ( llarrison\[6 , page 433\]) . 
The latter case has long been studied in interactive language-based programming environments  ( for example , Ghezzi and Mandrioli\[2\]) , whereas the only previous such work that we are aware of in the context of natural language processing is Wirdn and R  . gmlqnist\[14, 15, 16, 17\] . 
1.2 The Problem
The aim of this paper is to begin to adapt and apply the notion of bounded incremental computation to natural language parsing  , using a method for establis-hing minimal change previously introduced by  Wir6n and RSnnquist \[15  ,  17\] . To this end , the paper shows how the 6 parameter can be defined in a fully incremental , chart-based parsing framework , briefly describes a previous , unbomMed algorithm , and then shows how a polynomially bounded algorithm can be obtained  . 
2 Batch-Mode Chart Parsing
An incremental problem can be defined by specifying its batch-mode version and the set of allowable modifications  . We thus begin by specifying batch-rhode chart parsing  , restricting ourselves to a standard contextfree grammar without cyclic or empty productions  . 
Definition 1 ( Chart ) A chart is a directed graph C = ( V , E ) such that V is a linite , nonempty set of vertices and ECV xV x is a finite set of edges  , where Riv the set of dotted contextfree rules obtained from the grammar  . 4 The vertices v l , .   .   .   , vn + lGV correspond to the linear positions between the tokens r = t l  . . . t , of an n-token text . 5 Alledgee GI ' ; hetween vertices vl and vj carries informational > out a  ( partially ) analysed constituent between the corresponding positions  . 
The algorithm makes use of an agenda ( see Thompson\[12\] )  . Agendat ; ~sks are created in response to tokens being read and edges being added to the chart  , and may be ordered according to their priorities . To define the agenda , we make use of the set of possible tokens 7'kns and the set of possible edges Edgs . 
Definition 2 ( Agenda ) We define the agenda as AgdaCTknsUEdgsU ( EdgsxEdgs )  . We refer to the three types of tasks that it contains as scanning  , prediction and combination tasks , respectively . 
4For brevity , we omit a fourth edge component corresponding to tile set of  ( partial ) parse trees according to the grammar and lexicon ( assuming that only the topmost portion of a tree corresponding to the  ( lotted rule needs to be stored in an edge )  . 
5We shall use ~" interchangeably to denote a sequence a~td a set of tokens  . 

Each agenda task is executed by a ste1 ) of the algorithln below . We specify two versions of batch-nm de chart parsing -- the basic bottom-up  ( strictly speaking , left-corner ) and topdown ( Earlcy-stylc ) strategies - . a SSll ~ ruing that the one or the other is chosen . 
Algorithm 1 ( Batch-mode chart parsing ) Input : A seqnence of tokens r = t1 . . ? t , . 
Output : A chart.
Initialization : If tiletOll-down strategy is used  , then add an agenda task corresponding to ail initial topdown prediction  ( Vl , Vl , S - - ~ . c ~) for each rule S - - + ~ v , where Sisttle start category of tile grammar . 
Method : For each token , create a scanning tm~k.
While tile agenda is not empty , remove the next task and execute tile corresponding step below : Scan : Given a token I at position j  , l breach lexical entry of the form X->t , add all edge ( v j , Vj + l , X - - + l .  )  . dAd drestllting newt~sks to the agenda . 
Predict 1 ( Bottom-up ) : If tile edge is of the form ( vj , vk , X - -* c ? . ) , then , for each rule of the form Y--+XT , add an edge ( vjivj , Y ~-+ . XT ) unless it already exists . Add resulting new tasks to tile agenda . 
Predict 2 ( Top-down ) : If the edge is of tile form ( vl , vj , X - - + o e . gfl ) , tlien , for each rule of the form Y "-*3' , add an edge ( vj , vj , Y -+-7) unless it already exists . Add resulting new tasks to the agenda . 
Combine : If tile first edge is of tim form ( vi , vj , X - -* ~ . Y fl and the second is of the form ( vj , vk , Y - ,  7 . ), then add an edge ( vi , vk , X-+a Y . fl ) . Add resulting new tasks to the agenda . 
3 Incremental Chart Parsing a . 1 The Prob lem \]' lie overall incremental process can be thought of ~ Lsa cliange-update loop  , where each chalige of the input is immediately followed by a corresponding update of the output  . To completely specify the state of this process , we shall make use of a conliguration consisting of  ( are I ) resentation of ) an input text r , a cliart C and an edge-dependency relation 79 ( to be & dined in section 4 )  . 
The problem of incremental chart parsing can then be specilied abstractly as a mapping f  (   ( r , C ,  79) , Ar ) ~( r ' , C' , 79' ) from an old configuration and a modill cation Ar to a new configuration  . We shall allow two kinds of change , namely , insertion and deletion of w > 1 contiguons ~ We refer to the new edge as a lezical ' edge  . 
tokens . We assume that a modification A ~ is given as a vertex pair vj  , Vj+mGV defining the update interval and , in the cILs c of an insertion , a seqnence of tokens T ~ lj ? ? ? titm . We fiir the rn lore ; ussume that either the bottom-up or topdown strategy is chosen throughout a change-ul  ) dates ssion , and , in tile latter case , that tile toll-down initialization is made before the session is started  . 
3 . 2 AC , eneral Vertex Mapping flow cantile miniln al change ASh  , in be defined il , a chart-b~sed framework ? One way of doing this is to colnp are the charts C =  ( V , E and C '= ( V' , I ' , " ) that are obtained by batch-mode parsing of tile texts before and after a change  , respectively . We thereby obtain a measure which is independent of particular increniental update algoril  , hms . hltnitively , only those edges that are in E but not in lqre , stI ) erelnoved , and only those elites that are in 1' ; ~ I lut not in E must lie generated a new . If the change is snlall , then a large fraction of the edges are in/qgl I ' Y  ( I . hatis , are unchanged ) . 
l lowever , to be able to colnpare the edge sets in the two ( ' harts , wenms t first establish a one-to-one mapping between their vertices  , l , etus consider the case in wl fich a single token ti is  ( Meted from an n-token text . 
The probleln is that , be can se of tile remove ( l token , the two vertices v l and v i + l would seem to correspond to a single w ~ r tex in V ~  . l lowever , we can regard this single vertex as consisting of a " left half " and a " right half "  , which we assign diffe . rent indices . In other words , after having increase ( leach index of v ~_ l . 1, . . .   , v ~ , GV'by one , we " split " vertex v ~ and assign the index i+1 to its " right half " . The incoming non-predicted edges ms well as ( looping ) topdown predictions attile split vertex are then associated with its left half  , and tile on tgoing non-predicted edges as well ~ us  ( looping ) bottom-up re-dictions are associated with its right half  . 7 q'he reason for dividing the pre ( licted edges in this way is that at Oll-down prediction is made at  (  , tie ending vertex of the i , riggcril , g edge ( that is , frolntimleft ) , wlle reasa /) ol . to ln-uppre(liction is lnade attim starting veri , ex of the triggering edge ( that is , from the right ) . 
The lnapping Call I ) ege I ieralized totile cruse ill whil:\]l Ill COlitiguoii Stokel is are deleted  . T t l is is done by i il-c . reasilig the index of eax : hw ~ rtex froint he " right half " of tile split wn ' texan  ( Ioilwards by m ( instead of one )  . 
Fnrtherinore , by nsing the salile lnlq ) ping but in the opposite direction , we canills ( ) cover insertion of m contiguous toke\[is . To express this generalized in al)-ping , m'-IS lliln ~ that ! ) is the set of vertices of the larger chart and V is that of the smaller chart  . A deletion of m contiguous tokens then involves a mapping fronato V and an insertion of rn tokens involves a real/ping from V to V  . In terms of tile indexing that holds before the vertices in V are renumbered  , and assuniing that l ) 7A , ulllent loiled above , we aSsulne that only the one or the others t , i ' a tegy is ilsed , so that ii , is kllow lille fOl ' ehllnd which kind of predi < : tlons the cltal't COlttliillS  , '" r . __~2 wls .   .   .   .   .   .   .   .   .   .   .  =17  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
-"'. IIt , '.....
.  .   .   .   .   .   .   .   .   .   .   .   .   . ~/ r . . . . -', l l i t .   .   .   .   .   .   .   .   .   .   .   .   .   . , r .   .   .   .   . 
.  .   .   .   .  '  .   .   .   .   .   . ::: zc-:-_ .  : -1? :  . 
~awx ~ ~ alveal .,\] wx~~aavP 0
Figure 2: Chart of the sentence " The old man the tall ships " under bottom-up parsing  . In active edges are drawn using continuous lines , active edges using dashed lines , and predicted ( looping ) edges are depicted below the vertices . 
, S36~';,;i~-..................
l . . . . . . . . . . . . . . . . . . , Ii . . . .
.r """ . . . . . . . . . . . . . . . . . . . ~ f -"~'--\/ , --'~'~'- ~ awla Ne2a   ve2~   slooP3   Vel4 N ~\] V~2B Figure 3: Chart of the sentence " The old mantileships " under bottom-uparsing  . 
has n+1 vertices , we obtain the following bidirectional mapping : ? Vertices vl  ,   .   .   . , vi-1CV correspond to vl , ?? . , vi-1GV , respectively . 
? Vert exvic or responds to the " left half " of vertex 

? Vertices vi+l , .   .   .   , Vi+m-tE ~" do not correspond to any vertices in V  . 
? Vertex ~ i + m corresponds to the " right half " of vertex v l  . 
? Vertices 91 + re+x , ?? . , ~ . +1 correspond to vi + l , ?? . , vn + l-m , respectively . 
The mapping is thus established with respect o in set-tion or deletion of an arbitrary number of contiguous tokens  ,  3  . 3 M in ima l Change Assume that E and E ' are the sets of edges of the charts C and C'obtained by batch-mode parsing of a text before and after a modification Ar  , respectively . 
8 Presumably , it is possible to generalize the mapping to more complex  ( non-contiguous ) operations such as replacements or re-versa ls  . However , we do not pursue that here . 
S - - ~ NP VP the * -- Det
NP - - -* Det Nold , --- N , A
NP ~ DelANman , --- N,V
VP--*Vships+--N,V 171) -- ~ VNP
Figure 4: Example grammar and lexicon.
We can then define the minimal on tput change on the b~is of two edge sets as follows : Def in it ion  3   ( Minimal output change ) We define the set of missing edges a stile set difference M = E\Ej and the set of new edges as tile set difference N = E'\E  . We then define the minimal output change as
Ac , , i , = MUN.
Next , we can define the size of tile minimal change as follows : Definition  4   ( Size of minimal change ) We define the size of the minimal change as /~= \[ A~I+\]Ac  ,   ,   ,   , I , the sum of the number of inserted or deleted tokens and the number of edges in Ac  , ,  , i ,   . 
3.4 An Example
As an illustration , tile chart in tigure 2 is obtained under ( batch-mode ) bottom-uparsing , given the grammar in figure 4 and the sentence'q'heoldman the tallships " . If the token " tall " is removed , the chart in figure 3 is obtained . Vertex v ~ in figure 2 then colresponds to the left half of vertex v ~ in figure  3  , and vertex v6 corresponds to the right half of vertex v ~ . 
Furthermore , v7 corresponds to v ~ . Clearly , tile input change A ~ consists of the token " tall "  . The output change A ? ,   , i , consists of the missing set M , which contains the three edges A26 , NP27 and NP a4 infi-gure2 , and the new set N , which contains the singh . 
edge NP au in figure 3 . '\]' he size of the change is then 6= I~X rl+IZ XC , , ,  . , I := t+a+l = 5 . 
If instead " tall " is inserted before the last word in the sentence in figure  3  , then the input change stilleon slsts of the token " tall "  . \] lowever , the two sets ma-king up the output change are reversed : the missing set contains the single edge  NPa2 in figure 3 and the new set contains the three edges A26  , NP2 r and NP34 in figure 2 . Thus , the size of the change is again 5 . 
4 An Unbounded Algorithm
A key idea of the incremental chart-parsing algorithm put forward by Wir &  ,  \[14 ,   15\] is to use edge dependencies for keeping track of edges that \] lave to be removed in response to a change  . An edge e ' is said to depend upon another edge or token e if it is formed  ( derived ) directly on the b ~ us is of e . Furthermore , if e ' is redundantly proposed by an edge f , then d can be said to 01" ,   1 l * Figure 5: Edge-dependency graph induced by 1  )  . q ' he nodes of tlegral ) h correspond to the chart edges in figure 3 . A dummy root node 0 is shown instead of nodes corresponding to the tokens  . 
depend ( also ) on f . Bye'being " redundantly propo-se(l " , we mean that the parser attempts to add an edge that is equivalent to  #to the chart  , but thai , that edge is rejected by the standard redundancy test in chart parsing  . In effect , f provides an additional " justification " for # . 
Given a chart C = ( V , E ) and a set of tokens r , these conditions correspond to the following dependency relation on E and r : Definition  5   ( Edge dependency ) We define 79 as a binary relation on the set of chart edges and the set of tokens EUr such that  79  ( s , d ) hohts if and only if dGE is formed , or is redun(lantly proposed , directly using sCEUr according to a chart-l ) arsing algorithm . 
We say that d is a dependent ( or derivative ) edge of s , and tlats is a source edge ( token ) of d . 
7) can be ilh strated by a graph . The dependency graph corresponding to the chart in figure  3 is shown in \[ i-gure 5  . 
On the basis of the dependency relation , WirSn and RS nnq nist\[15 , 17\] define different disturbance sets , given as fimctions t'rom tokens to sets of edges , and containing edges that need to be removed from the chart in response to a token-level change  . The simplest such set is 7)* ( tj ) , the transitive closure of 79(tj ) . Wirdn and Rfnnquist\[15 ,   17\] discuss this and other alternatives and show completeness of  79* with respect o the missing set . 
The algorithm performs an update essentially by removing the entire disturbance set an  ( \[ then generating all possible edges . The latter set includes not only the new edges , but also disturbed , non-missing edges , which have to be generated a new . q'hecoml ) lexity analysis of the algorithm yields that it is unbounded incremental in both its botton-up and topdown version  ( see Wir6n\[16\] )  . The source of this is that the algorithm removes the entire disturbance set  , whose size depends on n , the size of the entire input . 
5 A Bounded Algorithm 5 . 1 Intuitive Idea Intuitively , a bounded incremental algorii . hm only processes the region where the input or output changes during an update cycle  . In our c~se , the problem in achieving this is that the missing and new edges are not a priori known -- when the incremental update begins  , only a set of potentially missing edges ( the di-sturbance set ) is known . I lowever , the ul ) date can be limited by using a change-prol ) agation algorithm ( compare Itamaling am and l . eps\[10 , page 21\] ) : By initially retaining the disturl ) anceset , new and old edges can be coml ) are during reparsing . If a new edge e ' is different from the corresponding old edge e  ( if this exists )  , then the dependants of care regarded ms disturbed  ( potentially missing )  . If  #is equivalent to e in the sense of giving rise to the slt mederivative dges  , then the dependants of care known not to be missing  , and hence timre parsing process does not have to proceed beyond this point in the search sl  ) ace , in order to avoid extra computation , the disturbed edges should be visited in the order given by the dependency graph  . 
llow can the points a L which a change " ( lies out " be characterized ? Since we are interested in characte-rizing the conditions under which two edges give rise to the same derivt Ltiv edges  , the contents part of an edge ( that is , the rigltt-hand side before the dot of the dotted rule  ) is irrelevant . For example , we want to say that the new edge N l ) : ~2 in figre 3 to be reparsing-equivalent with edge NP:~4 in figure 2 although their dotted rules and parse trees are different : the dotte  ( I rule of the former is NP-~D clN . and that of the latter is NI"~l)cIAN .   . We can summarize this in tile following delinition : Definition  6   ( Reparsing-equivalent edges ) As sume given a proposed edge e and a disturbed edge e ' C-C  . We say that e = ( v i , v j , X- . * o ~ . fl ) and #= ( v , , vt,Y-*tt . v ) are equivalent from the point of view of repars ing if i = s  , j = t , X = Y and f l = v . 
In active ( combined or lexical ) edges and predicted ed-ges are special cases under this definition  . Ill the former case , fl and u are empty , and thus two inactive edges are reparsing -equivalent if i = s  , j = t and X = Y . In the latter case , ( v and it are empty , and thus two predicted edges e and c ' are reparsing-equivalent if e = d  . 
465 5.2 The Algorithm
We now specify a bounded incremental chart-parsing algorithm that handles one update cycle  . 9In comparison with the unbounded algorithm , the differences are in the reparse and remove steps  . 
Algorithm 2 ( Incremental Chart Parsing ) Input : A configuration ( r , C , : D ) and a modification Ar corresponding to insertion ord cletlon of m tokens ti  ,   .   . ?, ti+m . 
Output : An updated configuration ( r ', C~,D').
Method : Do the following steps :
Modify the problem instance:
Insert or delete the modified tokens given by A ~ into or from r  . 
Prepare the chart : Do one of the following steps in the case of insertion or deletion  , respectively : Insertion : Renumber edges as follows : First  , replace each edge ( v j , v~ , r where j _> i and k i with an edge ( v j + m , vk , r . Secondly , replace each edge ( v j , v~ , r ) where k > i with an edge ( v j , vk+m , r ) . Looping edges at the " modification vertex " , which have the form ( vi , vi , r ) , are dealt with differently depending on where their sources are located  , which in turn depends on the prediction strategy : ? Bottom-up case : If the looping edge depends on an outgoing  , non-looping edge (( vi , vj , r ) such that j > i ) , then the looping edge is replaced with an edge ( vi + , n , V i + m , r ) ( in effect , it is moved ) . 
? Top-downcase : If the looping edge depends on an incoming  , possibly looping edge (( vi , v ~ , r ) such that k < i ) , then do nothing . 
Finally , update the depemlency relation 79 so that any edge ( vj , vk , r ) such that j < i and k > i is made dependent on ti . 
Deletion : Renumber edges ms follows : First , replace each edge ( v j , vie , r ) where j > i with an edge ( V j-m , vk , r ) . Then replace each edge ( vj , vk , r ) where k > i with an edge ( v j , vk . . . . . r ) . 
Reparse : Do the following steps :
In the ease of insertion : create a scanning task for each new token  ; create a combination tmsk for each active -in active edge pair meeting at vl and vi+m  . 
In the case of deletion : create a combination task for each active-in active edge pair meeting at v i  . 
Reparse while visiting the disturbed edges in the order given by the dependency graph and treating the disturbed edges as " sleeping "  ( that is , they do not play any role in the parsing process ms such  )  . 
9The algorithm is currently being implenlented.
Whenever a new edge is proposed , check if an equivalent edge exists in the disturbance set according to definition  6  . If so , install the new edge , update 2 ) by letting the new edge inherit the dependencies from the old edge  . Do not add any agenda items for the new edge ( thereby discontinuing reparsing along this path )  . Mark the new edge as recreated ( with respect o are parsing-equivalento e )  . 
Remove edges : Remove each edge that is in the di -sturbance set but not in the dependency set of any recreated edge  . 
5.3 Incremental Complexity
For the purpose of analysing the incremental complexity of algorithm  2  , we assume that adding or removing an edge takes unit time  . We also assume that no edge h , ' ~ more than a constant munber of sources or dependants and  , hence , that the time required to install or examine the depemlencies of k edges is O  ( k )  . t ? We first focus on the reparsing step . 11 Consider the case of a deletion within a text . The set of new edges N are generated ; ks a result of joining two subcharts , which we assume have length i and j and contain O ( i2 ) and O ( j2 ) edges , respectively ( disregarding the grammar constant \] GD . The joined chart thus has lengthi+j and consists of O  ( (i + j ) '-' ) edges . The number of uew edges resulting from joining the subcharts i then INI--O  ( (i + j ) 2 )  _  ( O ( i2 ) + O ( j2 ) ) = O ( i . j ) cages . Since the algorithm generates these edges by invoking a O  ( n3 ) reparsing algorithm , the new edges require O ( (i+j ) a )  - ( O ( i a ) + O ( jJ ) ) = O ( i . j . ( i + j )) = O(i ~ . j2) = O(IN2\[)time . The insertion case can be obtained in a similar way and gives the same result  . In the remove step , the missing edges are found by following dependency chains originating from tokens until a reparsing-equi-valent edge is found or the chain ends  . This step can therefore be executed in O ( IM\] ) time . The algorithm as a whole then requires 0 ( /~ 2 ) time . 
6 Conclusions
The boundedness criterion used here provides a gua -rantee that tile next update state is never more than an amount of computation away from the current state that is limited by the size of the change  . This criterion is very strong . It can be thought of as constituting one l ? Thls assmnption is considered too strong in reason maintenance  , where , in the worst case , all formulas can be directly connected ( see Good wln\[4 , page 110f . \]) . However , it seems ap-proprlate here , sincenmler a contextfree grammar of the kind ' ased here only predicted edges may have mutlple sources  . Mo-reover , the number of these sources is limited because of the llnearlty of the problem instance  ( the text )  . 
ll Since we take addition and removal of edges to be the pl'i-mary tasks of incremental update  , we disregard the chart-prepa-ration step . Although a more thorough analysis might take this step into & c cotlnt both in the definition of g and in the complexity analysis  , we do not believe that anything fundamental would be altered by this  . 
4 66 extreme point of a continuum of ways in which to measure tile complexity of increment algorithms  . At . the other extreme , we have the option of using 11"1+I , ~"1 , the cost of discarding the ohl solution and invoking a hatch-mode algorithm on the moditied problem instance  . This measure might be used for showing that an algorithm with poor worst < as e incremental behavi -our is still practical : Poor incremental behaviour means that the algorithm does not respond quickly to  ( some ) small changes , t lowever , it may still perform better than discarding the old solution and invoking a hatch-mode algorithm  . In other words , even if the algorithm is unbounded in ~ , it may have a lower time bound in IP'\[+1 , 9'1 than the batch-mode algorithm , q ' heun-bonn ( led algorithm describe dilk section 4 is an example of this : it is clearly more ellicient hant he batch-mode algorithm for the lm rpose of incremental update  . 
Several interesting topics for furthere search present themselves : One is to generalize the notions of minimal change and hounded incrementality to other processing frameworks that make use of a table or a chart  , for example , pseudo-parallel LR . parsing ( Tomita\[13\] ) or ta Mlar generation ( Neuman n\[8\] )  . Another interesting topic is to translate the slm renotions to a unification-based grammar formalism  . Defining minimal change then requires a definition of the dill'erence between two feature structures  . An immediate observation is that this is itself hardly a feature structure  , but rather the set of ( suh ) structnres that are not present in both feature structures  ( in analogy with our delinition of the difference between two charts  )  . 
References\[1\]llowen Alpern , Roger\[loow ' . r , Barry K . Rosen , Peter F . Sweeney , and 1" . Kenneth Zadeck . Incremental Evaluation of Computational Circuits . 
In Proc . First Annual ACM-SIAM Symposium on Discrete Algorithms  , l ) ages 3242 , Sanl " rancisco , 
California , USA , 1990.
\[2\] Carlo Ghezzi and Dino Mandrioli . Increment all ' arsing . ACM7 ) ' ansaclions on Prv qramming Languages and Systems ,  1(1):58-70 ,  1979 . 
\[3\] James W . Goodwin . An hn proved Algorithm for Non Monotonicl ) ependency Net , Update . Research Report LiTII-MNI'-R-82-23 , Department of Computer and lnfornaation Science , Link 6 ping
University , Link/3ping , Sweden , 1982.
\[4\] James W . Goodwin . A'l'heory and Systom for NonMonotonic Reasoning  . LinkSping Studies in Science and q'eehnology , l ) issertation 165 , l ) epart-ment of Computer and Information Science , Lin-kgping University , Link Sping , Sweden ,  1987 . 
\[5\] Nicholasa . Iladdock . Comlmtational Models of Incremental Semantic Interpretation  . l , angnage and Cognitive Processes , 4(3--4): aar-a 68 ,  1989 . 
\[6\] Michael A . Ilarrison . introduction to l " ormal Language Theory . Addison-Wesley , Reading , M~ssa-chuset , ts , USA ,  1978 . 
\[7\] Christopher S . Melllsh . Computerlnlerp relalion of Natural Language Descriptions  . Ellisllorwood,
Chiehester , England , 1985.
\[8\] G/inter Neumann . A Tabular Uniform Algorithm for Parsing and Generation  . Chapter of forthcoming Ph . l ) . thesis , Universit ~\[ tdes Saarlandes,
Sitarbriicken , Gerrnany , 1994.
\[9\] O . lamaling am . Bounded Incremental Computation . Technical l ~ . eport ( Ph . D . Thesis ) 1172 , Computer Sciences l ) epartment , U'niversity of Wisconsin , Madison , Wisconsin , USA ,  1993 . 
\[10\] (\] . l  ~ . amaling am and ' l'hom ~ . W . l/ . el ) s . Onl , he . 
Comlmtational Complexity of Incremental Algorithms  . Technicali . eport10a ' . l , Computer Sciences I ) epartmeut , University of Wisconsin , Ma-dison , Wisconsin , USA ,  1991 . 
\[1 I \] Thomas W . Reps . Optimal-Time Incremental Se--mantle Analysis lbr Syntax-Directed Editors  . ILk Proc . Ninth ACM Symposium on Principles of Programming Languages  , pages 169-176 , Alhu-querque , New Mexico , USA ,  1982 . 
\[12\]II enry S . Thompson . MClIAItT : A Flexible , Mo-(htlar Chartl ' arsing System . In Proc . Third National ( ; on feT vn ce on Artificial Intelligence , pages 408--410 , W ~ k shington , I ) . C . , USA , 1983 . 
\[I3\]M as a ruq bnfita . An EIficient Context-l , 'ree Parsing Algorithm for Natural Languages . In Proc . Ninth International Joint Conference on Artificial Intelligence  , pages 756-764 , Los Angeles , California , 
USA , 1985.
\[14\]MittsWirdn . lnteractiw ' ~ Incremental Chart Par-sing . In Proc . Fourth Co , fere nee of the European Chapter of the Association for Compnlalio-nol Linguistics  , pages 241-248 , Manchester , ling-land ,  1989 . 
\[15\] Mats Wir6n . Stutlies in lncrenmntal Natural Language M , alys is . l , ink 6 pingStn die silkScience and q~chnology , Dissertation 292 , l ) epart-ment of Computer and Information Science , Lin-kSping University , Liuk Sping , Sweden ,  1992 . 
\[16\] Mats Wirdn . l/ounded Incremental Parsing . In PTvc . 6th7'wenteWorkshop on Language 7' echno-logy , pages 145--156 , I'm schede , the Nether hmds ,  1993 . 
\[17\] Mats Wir(n and Rall ) hR gnnquist . l " ully Incremental Pro'sing . In Proc . Third International Workshop o11 Parsing 7~chnologies   , Tilburg , the
Netherlands and Durlmy , IMgium , 1993.

