DCKR -- Knowledge Representation in Pro l0g and Its Application
to Natural Language Processing
Hozumi Tanaka
Tokyo Institute of Technology
Dept . of Computer Science
Ookayama , 2-12-1, Megro-ku
Tokyo , Japan
ABSTRACT : Semantic processing is one of the important tasks for natural language processing  . 
Basic to semantic processing is descriptions of lexical items  . The most frequently used form of description of lexical items is probably Frames or Ob jects  . Therefore in what form Frames or Objects are expressed is a key issue for natural language processing  . A method of the Object representation in Pro log called DCKR will be introduced  . It will be seen that if part of general knowledge and a dictionary are described in DCKR  , part of context-processing and the greater part of semantic processing can be left to the functions built in Prolog  . 
1. Introduction
Relationships between knowledge represented in predicate logic formulas and knowledge represented in Frames or ~ Kt ~ i ~ K ~ fihi ~ i ~ are clarified by \[ Hayes  80\]  , \[Nilsson80\] , \[Goebel85\] , \[Bowen85\] , et al , but their methods requires separately an interpreter for their representation  . 
The authors have developed a knowledge representation form called DCKR  ( Definite Clause Knowledge Representation ) \[Koyama85\] . In DCKR , each of the ~ i ~% ~ composing of a Structured Object  ( hereinafter simply called an ~ hJ ~ Gi ) is represented by a Horn clause ( a Prolog statement ) with the " sem " predicate ( to be explained in Section 2 ) as its head . 
Therefore , an Object can here garded as a set of Horn clauses  ( slots ) headed by the sempredicate with the same fir stargument  . From the foregoing it follows that almost a ll of a program for performing semantic in tep retations relative to lexical items described in DCKR can be replaced by functions builtin Prolog  . 
That is , most of programming efforts of semantic p rocessing can be left to the functions buil t i n 
Prolog.
DCKR will be described in detail in Section 2  . 
Section 3 will discuss applications of DCKR to semantic processing of natural languages  . 
2. Knowledge Representation in DCKR
The following examples of knowledge represent at ion in DCKR will be used in Section  3 and later . 
:- op(lO0 , yfx ,  '~' )  , op (100 , yfx ,  ' : ' )  , op (90 , xf  y ,  '#' )  . 
01) sem(clyde#t,age:6,_).
02) sem(clyde#1 , P , S ) :- is a ( elephant , P , \[ clyde#11S\]) . 
03) sem(elephant#1, birthYear:lg80,).
04) sem(elephant#1 , P , S ) :- is a ( elephant , P , \[ elephant#1:S\]) . 
05) sem(elephant , P , S ) :- isa(mammal , P , \[ elephant lS\]) . 
06) sem(mammal,bloodTemp:warm ,).
07) sem(mammal , P , S ) :- is a ( animal , P , \[ mammall S\]) . 
08) sem(animal , P , S ) :- is a ( or eature , P , \[ animall S\]); has a ( faee , P , \[ animall S\]); has a ( body , P , \[ animal lS\]) . 
09) sem(animal , age : X , ) :- bottom of ( S , B ) , sem(B , birth Year : Y ,  _ )  , 
X is 1986-Y .
i0) sem(face , P , S ) :- has a(eye , P , \[facelS\]); has a(nose , P , \[ facel S\]); has a ( mouth , P , \[facelS\]) . 
Now the meanings of the sem , i ~ and h ~ a predicates , which are important to descriptions in DCKR , are explained later using the DCKR examples given above  . 
The first argument in the sempredicate is the Qhl~!ngm ~  . Objects are broadly divided into two types , in ~ iEi ~ i ~ and RE ~ ! Q % X ~ . Psychologists often refer to prototypes as stereotypes  . An Object name with  #represents an in ~% ~ i ~ in ~ and the one without #  , a ~ K ~ ! ~ ! Z ~ n ~ . For example , clyde#1 and elephant , which appears in 01 l and 05) , represent an individual name and a prototype name  , respectively . A set of Horn clauses , headed by the sempredicate with the same individual name or prototype name represents an  /  . ~ i ~ i ~ IA ~ ! object or a PK ~ iXP ~ object , respectively . 
The second argument in the sempredicate is a pair composed of a ~! ~ infi ~ and a sift ! X g ! B  ~  . The pair is hereinafter called @ ~ ~ iE . 
The description in 02 ) is to be read as showing that clyde#l is an instance of the prototype elephant  . 
Here , note that 02 ) is a direct description of inheritance of knowledge from prototypes at higher level  .  02 ) means that if a prs to type called elephant has a property P  , the individual c lyde#1 also has the same property P .  05 ) arid07 ) describe the fact that an elephant is a mammal and that a mammal is an ~ nimai  .  08 ) describes the fact that an animal is a creature and has a face  , body .   .   .   .   . From the foregoing it can be seen that the is a predicate used for the inheritance of knowledge is a predicate for traversing the h ierarchy of prototype Objects  . 
The predicates , is a and has a are defined below.
Ii ) is a ( Upper , P , S ) :-
P = isa : Upper ; sem(Upper , P , S).
12) hasa ( Part , X:Y , S ): -
X == has a , ( Y = Part ; sem(Part , has a:Y , S )) . 
The i~predicate and the ha~a predicates are used for the inheritance of knowledge through subordinate-superordinate and part-whole relations  , respectively . 
DCKR is provided with the bottom of pred icate  , which is used in the body of 09) . By using the predicate , it is possible to know what the calling individual  ( the individual that called the world of p rototypes  ) is and extract the knowledge held by that in d ividual  . This is accomplished by using the third a rgument in the sempredicate  , since in the third argument of the sempred icate is stacked the route followed intrac ing the hierarchy  . 
For example , 09) identifies the individual . ( caller ) B by means of the bottom of predicate and if ? -sem  ( elephant #1 , age : X ,  _ )  . 
is executed , 09) is reached by the is a predicate in 0 , t ) , 05) and 07) . As a result . 
X = 6 is derived by the Prolog interpreter.
Also , if ? - sem(elephant#1,P ,).
is exeellted , all properties about elephant  #l call be obtained as follows: 
P = birthYear : 1980;
P = is a : elephant;
P = isa : mamnlal;
P = bloodTelnp:warnti
P = isa : animal;
P = isa : creature;
P = age : 6
Nste that all knowledge ( SV pairs ; prop cF tie ! ;   ) at higher level prototypes than e lephant#1 is obtained ttlr ' oughtire unificat i on mechanism of Prolog  . \[ aother ' words , in ilerilance of knowledge is carried out automatically by tile functions buil t in Prolog  . 
As yell may notice ' . , if ? - sem(K,Y , ) . 
is executcd , the system begins calculating all knewled F  , eithat ; ( as XY pairs ) . 
If 9.... sem(~, is a : lll all ufla1.).
is exee ut cd , it . i5 . r ) lssi . bletoaq ~' . es . 5 an illc ~ . ividuao EI ~ EP ~ Yt ~ ~ t-k % he loy ! eL " l(~yet .   . f Jiqma Iqt ~ DIJ ! tAj attile high ~ EI r/v ~ .  \ [ :
X : ~ cly de#l;
X :: elephant#l;
X = elephant
Finally , if ?- sem(animal , hasa : X ,_t . 
is executed , you may have tile following results :
X = face;
X = eye;
X = nose;
X = mollth;
X = body
From the foregoing explanation , yen will understand that i ! o_nlg . k_l/p_~?!edge . ! ~4e_s . e_,Eib(2_diraD_CIjR . _ inf_eEfu!ce! . ~ tal~!_oma . t ! c , a . \[ iYLJeE foE_m . _ed_byt . f ~ ei ~ nierp3x~t_r_b ~ li!tkn,E~_'o_j_og . 
3 . Semall tteP Pocessing of Natural Language 3 . 1 Dsecr ip f ions o f Lex ica l I tems in DCKR Semantic processing is one of tile important tasks for natural language processing  . Basle to semantic processing are descript ions of lexieal items  . The most frequently used form of descript ion of lexical items is probably Frames or ' Objects  , A method of the Object representation in Pro log called DCKR is introduced in section  2   . In this section , it will be shown that DCKII represeutation o flexical items enables to alleviate alo t of programming efforts of semantic p rocessing  . 
\[ nI ) CKI1 , all Object consists of a set of slots each of which is represented by a Horn clal lse headed by these repredicate  . I lowever , tile first a F/funlellt intiles ere predicate is tile Object name  . Tile values of slots used in semantic p rocessing are initially undecided but a redeterntined as semantic processing progresses  . This is referred to as slots be in K sati sfied by fi\]  . ! e_rs . To betire value of a slot , a filler must st t t is fyt il epp . nsty'_a , ir ! lswritten in tile slot . 
If the fillet " satisfies the constra ints written in a slot  , action is started to extract a semantic structure or to make a more prof on a dinfe rence  . 
Constraints written in slots are broadly divided into two  , syntactic constraints and semantic constra ints  . 
The former represents the syntactic roles to be played by fillers ill sentences  . Tile letter are constraints on tile meaning to be carried by fillers  . Typical semantic proness in K proceeds rOl lghly as follows : i  ) If a fille . r satisfiestire syntactic and semantic constraints on a siot selected  , start action and end with success . Else , got nii ) it ) If there is so other slot to select , seleclit and I ~0 to it . Else , Kotoiii ) iii ) If there is a higher-level prototype , get its slot and go to it . Else , and oe the assumption that the semantic p rocessing is a failure  . 
1 4'FOIII tile semantic processing procedll rnsil li  ) through i ii ) above , tile following call be seen : at ' rile semantic constraints in i  ) are often expressed illlogical formulas . This call be easily done witll
DCKR as explained later.
b ) The slot selection in it ) can use the backtrack in/~mechanism built ini ~ rolog  , leer in I ) CK a slot is repre . sented as a II or n clause . 
el iii ) can be . easily implemented by the knowledge in her i tance mechanism of DCKR expiaioed ill  2   . 1  . 
Thus , if lexica\[items are described in I ) CKR , programs central to senlaatie processing call be replaced by the  . basice ompllt & tionmcn hanism builtin P rolog  . Tills will be demonstrated by examples below  . 
Cited first is a DCKR description of the lexlcal item " open "\[ Tanaka  85a  \ ]  . 
13) sem(open , subj:Filler " ~ in ~ Out, . ):-sem(Fi1let , isa : htllllan ,  _)  , extroe?s e . ul(agellt : Fi 11 e . r ~ In " Out ); ( sem(Filler , is a: event Open , ); sem(Fi1ler , is a : tillng Open ,   .  ) )  , extraetsem ( object : Filler ~ In ~ Out ) ; sem(ti'ilet ' , is a : instrument ,  )  , extract sem ( instrument : FiI 1er *? ln ~ Out ) sem ( Filler , isu : wind ,   .  )  , extrant sem(reasoa : Fi11er ~\[ n ~ Out) . 
14) sem(open , obj : Filler ~ ln ~ Out , ) :-( semtFi1Ier , is a: event Open , _); sem(FiI1 or , is a:thing Open ,  ) )  , extraetsem ( objuet : Fi1let ~ In ~ Out) . 
15) sem(open , with : Filler ' ~ In ~ Out , __):-sere(Fi11er , iso:instrument ,  )  , extract sem(instrument : l . ' i1lel " ~ In ~ Outt 16) sem(open , P , S ) :- is a ( aetion , P , \[ openlS\]); is a ( event , P , \[ ol ) en lS\]) . 
13) , i , i ) and 15) are slots named sttbj , obj and with , which constitute open . Variable Filleristile filler fo r these slots  . The slot names represent tile syntactic constraints to be satisfied by tile Fi ller  . 
Subj , obj and with show that the l , ' iller must playtile roles of the sub ject  , object , and with-headed prepositional phrase , respectively , in sentences . The body of each of the Horn clauses cor responding to tile slots describes a pai rconlposed of semantic constraint and act ion  ( hereinafter called an . CA pair ') . For example , tile body of 13 ) describes four CA pairs e ocb of the nl joined by or  (  "  ;  ' )  . 
The first CA pair : extract sem ( agent : Filler ~ In ~ Out )   ; shows that if the Filler is a human ( a semantic constraint )   , the action extract sem ( agent : Flller ~ In ~ Out ) starts making the deep case of the Fille r the agent case that is added to Insent to Out  . 
As described above , checking semantic constraints can be rep laced by direct Prolog program execution  . 
Therefore , relatively complex semantic constraints , e . g .   , person of blood type A or AB , can be easily described as shown below : sem ( Filler , isa:human , _ )  , ( sem(Filler , boodType : a , ); sem(Filler , boodType:ab , _ )) The meaning of the second , third and forth SA pair in 13 ) is obvious now . 
Form the foregoing explanation , the meaning of the slots in 14 ) and 15 ) will be evident . In addition to " with " , there are many slots corresponding to prepos itional phrases  , but they are omitted to simplify the exp lanation  . 
16 ) shows that if the Filler cannot satisfy the slots in  30  )  , 31) and 32) , the slots in the prototype action or event is accessed automatically by backtracking  . This was explained in detail as inheritance of knowledge in  2  , and provides an example of multiple inheri tance of knowledge as well  . 
The descriptions of 13 ) through 16 ) can be completely compiled , thus ensuring higher speed of processing . This makes a good contrast with most convent ional systems which cannot compile a descript ion of lexical items because it is represented as a large data structure  . 
3.2 Description of grammar rules
The DCG notation\[Pereira 80\] is used to describe grammar rules . Semantic processing is performed by rein forcement terms in DCG  . An example of a simple grammar rule to analyze a declarative sentence is given below  . 
sdec(SynVp , SemS dec ) --> np(SynSubj , SemSubj ) , vp(SynVp , SemVp ) , ( eoncord(SynSubj , SynVp ) , seminter p(SemVp , subj:SemSubj , SemS dec ) . 
The part encircled by ( is a reinforcement term . The predicate concord is to check concord between subject and verb  . The predicate seminter p , intended to call semformally , is a small program of about five lines . In this example the grammar rule checks if the head noun in SemSubj can satisfy the sub j slot of the main verb frame  ( e . g .   , open in 13 )  -16 )   ) in SemVp and returns the results of semantic processing to SemSdec  . Therefore , we can see that there is little need to prepare a Program for semantic processing  . 
As semantic processing is performed by rein forcement terms added to DCG  , syntactic processing and semantic process ing are amalgamated  . This has been held to be a psychologically reasonable language-processing model  . 
3.3 Test result
Some comments will be made on the results of semantic processing based on the concept exp lained in  3   . 1 and 3 . 2  . The sentence used in the semantic processing i s " He opens the door with a key  . " input senlences:
He opens the door with a key.
Semantic structure is : sem(open #5 , P , S ) :- is a(open , P , \[ open  #SIS\]) . 
sem(open#5, agent:he#4,).
sem(open#5, instrument : key#7,).
sem(open#5, object : door #6,).
sem(he#4 , P , S/:-isa(he , P , \[ he #41 S\]) . 
sem(door#6 , P , S ) :- is a(door , P , \[ door #61 S\]) . 
sem(door #6, det:the ,).
sem(key#7 , P , S ) :- is a ( key , P , \[key#71S\]) . 
sem(key#7, det:a,_).
Besides , results of semantic processing of " the door with a key " are obtained but their explan at ion is omitted  . 
Here it is to be noted that results of semantic p rocessing are also in DCKR form  . By obtaining semantic processing results in DCKR form  , it is possible to get , for example , sem(open#J , instrument : X ,   ) from the interrogative sentence " With what does he open the door ?" and get the answer  .   .   .   .   .   .   .   .   .   .   .   .   .   .   . I Semantic Structure l .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
lI(DCKR)I
I .................\[
I .   .   .   .   .   .   .   .   .   .   . t .   .   .   .   .   .   .   .   .   . IInferencett I Context,, .   .   .   .   . I Engine I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . II Analysis II .   .   .   .   .   .   .   .   . II
IIII .   .   .   .   .   .   .   .   .   . I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  \[   .   .   .   .   . I Knowledge Base ( DCKR +?) I .   .   .   .   .   .   .   .   .   . II .   .   .   .   .   .   .   .   .   . 
Semantic l .   .   .   .   .   .   .   .   . I .   .   .   .   . l Sentence I Analysls lI .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . lI Genera-I : lIDictionary ( DCKR ) IItion I .   .   .   .   .   .   .   .   .   . ILI .   .   .   .   .   .   .   . Ii , II .   .   .   .   .   .   .   .   .   .   . I\[Syntacticl .   .   .   .   .   .   .   . I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . I
IAnalysis II Grammart
Input Sentence ( Source )
Fig . 1
Answer ( Target)
DCKR and Natural-Language-Understanding System by merely executing that  . 
4. Conclusion
Now the relationship between DCKR and a natural language understanding system will be touched on  . 
From what has no far been discussed , we can envision a natural-language-unders tanding system architecture as illustra ted in Fig  .  1 . 
The shaded parts in Fig .   1 are those will be achieved by the in ter preter builtInProlog  . From the foregoing explanation , it will be seen that if part of general knowledge and a dictionary are described in DCKR  , part of context-processing and the greater part of semantic processing can be left to the functions builtin Prolog  . As for syntactic processing , the grammar rules described in DCG\[Perei ra  802 automatically converted into a Prolog program  , and parsing can be replaced by Prolog program execution  . 
Given the foregoing facts and assuming the in ference engine to be the Prolog interpreter  , it may be concluded that a Prolog machine p lus something else will be a natural- language-processing machine  . If asked what that something will be , we might say that it will be a knowledge base machine  . Anyway , this concept is in line with what the Japanese fifth-generation computer systems project is aimede L  . 
\[ Acknowledgment \]
Authors wish to express their greatgrati tude to Mr  . Kazuhiro Fuchi , the director of the Research Center of ICOT , and Dr . Koichi Furukawa , the chief of the Research Center of ICOT , for their encouragements and valuable comments  . Mr . ltaruogoyama , Mr . Manabu Okumura , Mr . Teruo Ikeda , Mr . Tadashi Kamiwaki , who are students of Tanaka Lab . of Tokyo Institute of Technology , helped us to implement some application programs based on DCKR  . Mrs . Saehie Salts helped us for preparing thi smanuscript  . 
5 . References\[Bobrow77\] Bobrow,D . G . et . al . : An Overview of KRL-O,
Cognitive Science , i , i , 3-46(1977).
\[Bowen85\]Bowen , K . A . : Mete-Level Programming and Knowledge Representation  , Syracuse Univ . ,(1985) . 
\[Colmeraure 78\] Colmeraure , A . : Metamorphosis Grammer , in Bole ( edl : Natural Language Communication with Computers  , Springer-Vcrlag 133-190 (1978) . 
\[Goebel85\] Goei Jel , R . : Interpreting Descriptions in a Prolog-Based knowledge Representation System  , Proc . of IJCAI '85, 711-716(1985) . 
\[ Hayes 80\] Hayes , P . J . : The Logic of Frame Conceptions an Text Understanding  , Walter de Gruyer , Berlin ,   , 16-61(1980) . 
\[Koyama85\]Koyama , H . and Tanaka , H . : Definite Clause Knowledge Representation , Proc . of LPC'85, ICOT95-106 (1986), in Japanese . 
\[ Matsumoto 83 J Matsumoto , Y . et . al , : BUP-~A Bottom-UP Parser Embedded in Prolog , NEW Generation
Computing , I , 2, 145-158 (1983).
\[ Mukai85\] Mukai , K . : Unification over Complex Indeterminates in Prolog  , Free . of LPC'85, ICOT 271-278 (1985) . 
\[Nilsson 80 Nilsson , N . J . : Principles of Artificial
Intelligence , Tioga , (1980).
\ [ Pereira 803 Pereira , F . et . al : Definite Clause Grammar for Language Analysis - - A Survey of the Formalism and a Comparison with Augmented Transition Networks  , Artificial Intelligence ,  13 ,  231-278 (1980) . 
\[ Tanaka84\] Tanaka , H . and Matsumoto , Y . : Natural Language Processing in Prolog , Information Processing , Society of Japan ,  25  ,  12 ,  1396-1403 (198  , t ) , in Japanese . 
\[ Tanaka85a \] Tanaka , H . et , al : Definite Clause Dictionary and its Application to Semantic Analysis of Natural Language  , Prec . of LPC'85, ICOT , 317-328 (1985), in Japanese . 
\[ Tanaka86\] Tanaka , H . : Definite Clause Knowledge Representation and its Applications  , ICOT-TR ( in press ) . 

