1.0 INTRODUCTION
Automatic text generation is the generation of natural language texts 
by computer . It has applications in automatic documentation
systems , automatic letter writing , automatic report generation and
HELP subsystems for tlme-sharlng systems . This section introduces the subject and describes the contents of this paper  . 
The second section describes a basic approach to automatic text generation which makes it possible to generate a relevant ext in response to a compact text specification  . The structure of the database ( overlapping tree structures , roughly ) from which the text is constructed makes it possible to do this in a non-ad-hoc way because the relationships between the elements of the database imply sentences and relationships between sentences and groups of sentences  . 
In the third section , a number of extensions to the basic approach are discussed  . These include among others : ( a ) paragraphing , ( b ) natural language queries , (c ) " flattening " of structures , and ( d ) elimination of redundancy . 
The fourth section of this paper discusses the application of this approach to HELP subsystems for tlme-sharing systems and on-llne documentation systems  . 

ABASICAPPROACH
This section describes a basic approach to the generation of natural language texts  . Three subjects are discussed : text specifications  , i . e . , a means for specifying the structure of a text that is to be generated  , -the structure of the database , i . e . , the way in which the data base is organized to facilitate the generation of natural language texts  , and the text generation algorithm which generates a text given a text specification and a data base  . 
This approach represents the basic insight presented in this paper  . It is simple and generatively very powerful , but a number of improvements are possible . Some of these possible improvements are discussed in 
Section 3.
Text Specification
A text specification is a compact description of the outline of a text  . 
The form of a text specification is as follows : .   .   .   .   .   .   .   .   . O0~te?t specl fl cat lon ~: := ~ subspecl fl cat lon~t ; ~ subspecl flcahor ~ o ~ ub specificatior ~ . - := ~ object name ~( ~ R~t , < R~~)
I <: object name ~: := one or more contiguous characters ~ relation ame ~:-= one to three contiguous alphabetic characters  . 

The metalinguist l c symbols have the following significance : ' may be rewritten as I encloses a class name ?  .   . occurs between a & b times Object names are key words or phrases  . They represent objects of interest within a data base  , for example , names of commands in a programming language , people on a project or pieces of equipment in a system configuration  . 
A relation is a connection or association between one object and a fragment of text  ( i . e . , a part of a sentence or one or more closely related sentences  ) and zero or more other objects . The following are typl cal relation names : NT ( narrower term )  ; PT(part ) ; FUN ( function ) ; 
SYN(syntax ); EG ( example).
The significance of text specifications and of object names and relation names in text specifications is developed further in the examples that follow  . The significance of objects and relations in the database is described in section  2  . 2 . The algorithm for generating a text~given a database and a text specification  , is described in section 2 . 3 . 
First Example
Consider the following request :
Please create a text that explains the function and the syntax of the narrower terms of command  . Examples of each command should be included . Each command should be discussed separately -- function  , first , then syntax , and last an example . 

This request can be stated briefly by the following text specification : 
COMMAND(NT(FUN , SYN , EG))
The corresponding text that would be generated would have an outline in the following form : 
First Command
Function of First Command
Syntax of First Command
Example of First Command
Second Cammand
Function of Second Command
Syntax of Second Command
Example of Second Command etc.
The output for one command in the outline might be : The function of the SetCommand is to set a specified control parameter to a specified integer value  . The format of the SetCommand is : < name >= < integer > 
An example of the SetCommand is:
SL:OU=100
In the example , the maximum number of online users ( SL:OU ) is set to 100 . 

Second Example
Suppose that in addition to the text of the first example  , an into duction is desired in which a list of all the commands is given  . The appropriate text specification would be : COMMAND  ( NT )  ; COMMAND(NT(FUN , SYN , EG ))
Third Example
Suppose that instead of grouping information by cammand  , it is desired that all the functions should be grouped together  , etc . Then , the appropriate text specification would be :
COMMAND(NT(FUN ), NT(SYN ), NT ( EG))
Data Base
A database for a particular subject consists of two parts :  ( a ) a thesaurus that relates objects to each other and to frac~nents of text  , and ( b ) fragments of text . 

A thesaurus contains an entry for each object.
An entry for a single object consists of any number of relationships  . Each relationship relates the object to a fragment of text and  , in same cases , to one or more other objects in addition . 

An object that is being focused on ( i . e .   , as the object in a text specification or as the obiect that an entry is for  ) is referred to as a ~ . 
An object should be included under a relation in a particular entry if it occurs in the fragment for that relation and its meaning is not self-evident in that context  . 
The following is an example of an entry in a thesaurus for SET 
COMMAND :
SETCOMMAND
FUN:10
CONTROL PARAME TER
SYN : 11

I:I

EG : 12
FUN , SYN and EG are relations . The function of the SETCOMMAND is stated in fragment  \]0  , the syntax in fragment 11 and an example of the SETCOMMAND is given in fragment  12  . The object CONTROL PARAME TER occurs in fragment 10 and its significance is not self-evident in that context  . 
TextFragments

The database includes a text fragment for each relationship in each entry  . These fragments can be arranged ( in the database ) into one or more unified texts , perhaps with some fragments left over . 

Fragments 10 ,   11 and 12 referred to above might read as follows: 10: The function of the SetCommand is to se to specified control parameter to a specified integer value  . 
1 1: The format of the SetCommand is : < name > : < integer >  12: An example of the SetCommand is:
SL:OU=100
In the example , the maximum number of online users ( SL:OU ) is set to 100 . 
Text Generation Algorithm
A flow chart of the text generation algorithm for handling subspeci-fications is given in Figure  2  . 3a . The algorithm as described does not include any error checking  . 

This section suggests c~ne of the ways that the basic approach could be modified to advantage  . Like the previous section , it is divided into three subsections which discuss text specifications  , the structure of the database and the text generation algorithm  . But instead of discussing one basic approach , it discusses many possible extensions of that basic approach  . The extensions discussed often effect more than one of these three areas  . They will be discussed wherever they can be presented in the most illuminating way  . 
-7-l Put Symbols into SYMBOL
JPush(SYMBOL(1), 3) into SUBLIST
J Pull(CSUBJECT , IS ) from SUBLIST
Figure 2.3 a


Pull all of TEMPLISTj ~ and push into SUBLISTJ-
No More/f-~'~I
Print fragment pointed to by CSUB . IECT
PAREN=0j = PAREN-1~~~_~~ , , PAREN - V -~ r -" .   .   .   .   .   . L . _ ~ i ~ under this re-l/SYMBOLI ~ ~- ~_ vy ! lation for L a relation name \]~- append-  ~ / 
N~(OBJECT , is + 2 ) iP'e"a'nt no 0> Ie for this relation name for CSUBJECT to TEMPLIST  -8  -
FIGURE 2.3b
Notes for Flow Chart





TEMPLIST a list containing the symbols of the text specification in the order of their occurrence  . 
a list of items each of which is either ( a ) a fragment number or ( b ) a pair that consists of a subject and an index to the first symbol in SYMBOL to be processed for that subject  . 
the current subject being processed.
an index to the symbol in SYMBOL that is being processed  . 
a counter for keeping track of parentheses.
temporary list for collecting items to be pushed into SUBLIST for one CSUBJECT  . 

Text Specification ~ od D wol ~ ~ oI ~ etokl
Paragraph Boundaries
With texts of any size paragraphing is desirable . A new symbol ( PARG ) sider the follow lr ~ oe ~ msl:d~Qfi ~ lwtdhgtighbi ~ er , ~ sed:3 . 1 . 2bnr~tog dueoto et ei ~ noot o:it ~ io qo ( d ) to ~ edm , ~n Paroglra ~ lf ~ gJ ~ c ~ i ~ I e ~ i ~ rel~ef ~ re ,  . ~b ~ ic ~ cussion of each of the narrower terms of COMMAi ~  . .toH ~ ~, o/bg,~ . eg3olc ~ Section numb?b ~ a nodo headi . nasco~l ~ be handled in a similar manner . 
. ez q ~/"11:5"~  ogicU ~ . " lngllb~o9rjt\]' . ~ . . fl l . SU ~ . ;)~b,qr,b ~; ~ R!F ~ l:qg~eEtsLn , the Outp . vt .   .   .   .   .   .   .   .   .  ~ . ": ~' ~ n ~ ~, : . _tx~bn~no Consider the text specifl cat lon : , bee~goo~q . T33 LSU~D~no~o ~ TSIJSU ? ot ni


FUNSYNEG i
In the basic approach only the fragments of the lowest level relations are printed  . The fragmen that lists the NTs of COMMAND is not printed  . 
It would probably be more reasonable to interpret text specifications ~ X rbl ~ eir ~ e ~ l  4  . to rh qeb er hs zo qqu ~ tu d , btuow(((TVI ) Tkt)T/ , 4 ) A If it was desired that fragments at a level be suppress  . e~erX~ld be marked by a special symbol , say a minussign ? ioi ~ ) ~leoe ~ uoied bluow mel dolq ai ( t t s l b n a d a t X o w t n e l n s v n o o A , ~ et ~ , ~i ~ bni ? ~ e~i ~ nio ~ ~ monnoitolo ~ D ~ eflo ( ' l'a qod ~ q ) Iodn~?z . , ~ n 0 erorcmes ot a ~ em non . belia ~ beino ~ tolel 9~tt ognit ~ n There are many relations that naturally form hierorchies ~ e  . g .   , narrower term of , part of , works for and subroutine of . Consider z~i ~ nebn . 9 qeCI . gn ~: hito8a database with a hierarchy of NTs . The uner , nee ~" ~ oi uoif ~, . ~ a  ~ . ~ o ~( ~ oI ~ ~ , - ~ lu ~ it ~ qorit ~ , , b~loi~o~o tnemgmt A represent SUDlects or enrr ~ es  .  "  . ~o Hois ~ i . ~ r ' ~ , caloe\[dogritto ~ , no Honolqx ~ not nebneqg baitoej dua ~ oitn ~ . ~c ,, ~ ri ! ~ o ~ . air ~ emgo ~' ~ , riT ~ , oat ~ , ~ anoa ~: , ~idoonoitono ~ qx~nA ? Ioi'~ns ~ . e~it . ~) rkv~ui ~ . ' ~ ej do . ed~:~o ~ noitoie ~
NT : Ibi ~ ow ~ i . ~i  ~ o ~ (' PlU ~) ~ e , o i i o n u ~ B i O r i t ~ n : ~ r ~ e ~ z m . ~ s . ~ i ; ~ oh q , ~ ~ . mseai ~ i ~ nea ~ " onb noJni-~nee ~ e ~ ~ ot ~ 10   r:oil0o~i~zoto iotg g tluoi~5 ~ evori~t ~ e'Hg de d~H~n~l . bi ~ i ~ xti ~ o ~ ea en ~ b
NT : 2NT ~ . -3ebivo ~ qo ~ ! obnoi'1 , U  ~ ( at b~im~i ~ o ) ~ ibu ~ onianoltole ~ Joilneaa . ,~ :? n ~ ou ~ tngmo?otz o X~le ; -tiuo \] ebcirJ tebhlevoFoj xtili do qoooo ~ o1 \] eilneeae be ~ ebiznoo el ~ l ~ Odlanoitole ~ ~ boeten i ~ onoltibbon  . ezo do tob~flt nlrlou ~ ~ obs ~ homed bluoo to ej du ~ ~ oJuoit ~ c ~ q 
NT : 4e~t ~ iI . tU : I to ~~ be but onie ~ o ~ ne~gm level ~ erlgifl to rlt gnl mu ~  . ~ , , zeione~bnecleb refit etooibq ; zte ~ lomdtodtb nonoitolm Ioitnez ~ eXI~O : noitooilio ~ q~txetB ~ i wolJo~le ~ li~eblznoo ~  bei1~ito ~ e  ~ loie ~ o ~ ( ~ JY  ~ ) TIt ) a HAMM03\]-?\[-3 . 1 . 4 What text specification would cause all four fragments to be printed ? A  ( NT ( NT ( NT ) ) ) would , but suppose the depth of the hierarchy is not known  . 
A convenient way to handle this problem would be to use a special symbol  ( pethaps '!' ) after a relation name to indicate that indefinite nesting of the relation is desired  . 
! L  ~
Satisfying Dependencies
A fragment as ~ , ociated with a particular relation for a particular subject is dependent on explanations of the objects of that relation  . 
An explanation of objects consists of the fragments for the essential relatiom of the object  . But what is essential ? A_A prior it seams reasonable that functions  ( FUN ) of objects would be essential and examples ( EG ) not . But to insist on a particular classification of relations as essential and nonessential seems unnecessarily rigid  . It might be better to hove a defauit set of essential mlotlons including  ( or limited to ) FUN and also provide a capability to override this default set by a statament such as: 
ESSENTIAL = FUN , NT1 ~ addition or instead , relations that are considered essential for a I ~rticulm subject could be marked as such in the database  . 
Assuming that higher level fmgmnnts are included , that FUN is the only essential relation and that bracketsi/ldicote that dependencies ~ om to be satisfied  , consider the following text specification :-12-3 . 1 . 5 The fragments giving the narroweL " terms of COMMAND and those giving the syntax of all the narrower terms of COMMAND would be included in the resulting text  . In additlon ~ the functions of COMMAND ~ of the narrower terms of COMMAND  , and of any objects of the SYN relations would be included  . Further ~ the functions of any objects of these FUN relations would be included ~ etc  . 
Natural Language Queries
The approach in dealing with natural language queries is to convert them into text specifications  . In order to make the conversion , the following types of words would have to be isolated in the query : relations  ( e . g . , function , syntax , example ) ~ objects ( e . g . , ADD COMMAND ) and connectors of objects with relations or relations with relations  ( e . g . , of ) . 
In the following example , the words that would need to be isolated are underlined : Please create a text that explains the function and the syntax of all of the commands in the database  . 
Next it would have to be determined which objects and relations were connected in the query and how  . What we have is FUN and SYN of
NT of COMMAND.
This must finally be translated into :
COMMAND(NT(FUN , SYN )) -13 -3.2 3.2.1
Data Base
References across Subject Areas
The approach described here depends on a text specification being processed for a particular database  . The database should be highly controlled and relatively free from ambiguities  . 
Although each specification must be directed at a particular database  , not all ( or even any ) of the fragments in the resuJtlng text would necessarily be from that database  . 
Consider the following databases :
A slash indicates that the name of the database for that object follows: 
OVERVIE WDATABASE
ASSEMBLER-NT : IO
METASYMBOL/METASYMBOL
MATHE MATICAL COMPILERS
NT:20/BASIC/BASIC
FOR TrAN/FORTRAN~x % ~ . FORTRANDATABASE__~BASICDATABASE
I :
BAsicFORTRAN
FUN:17jj FUN:30' 11-14-3.2.2
The text specification MATHE MATICAL COMPILERS ( NT ( FUN ) ) would result in a text consisting of fragfi~ent 10 from the BASIC database and fragment 30 of the FORTRAN database . 
Higher-Level Connectives
A higher-level connective is a connective that connects a sentence or a group of sentences with a sentence or a group of sentences  . 
This is in contrast to the relations discussed so far which relate a subject to an object or to s ~nething else  . 
The following are examples of such connectives : similarly  ( SIM )  , in contrast , thus , otherwise and for example ( EG ) . 
These connectives can be incorporated into the database by expanding the reference to fragments  . Consider the following reference to a fragment :
FUN:I0, EG:20, SIM:X(FUN)
This reference says that the function of the subject of the entry in which it occurs is stated in fragment  10  . It says further that an example of the function is given in fragment  20 and that the subject X has a similar function . 

Text Generation Algorithm
Generation of Fragments
The implementation of the text generation algorithm is simpler if fragment numbers and corresponding fragments are included in the data bases for all relationships  ; but for some relations ( e . g . , PT and NT ) the fragment can be generated from the thesaurus entry itself  . In other cases ( e . g . , FUN ) part of the fragment can be generated . 
For example , a relationship with the following format : < su bject 
PT:<Object < Object ~ implies a fragment of the form : < subject > has the following parts : < object >  , < object > . . . 
Lexical information for the subjects and objects would be necessary to include the correct articles and endings  . 
Eliminating Redundancies
In the context of a reference manual for a programming language  , syntax would probably be considered an essential relation  . The relations between syntactic objects is ( roughly ) hierarchical , but the overall structure of syntactic objects is generally not quite a  -16-tree structure because of the fact that more than one object is often dependent on a single object  . 
Consider a database that contains the following objects and relations : 
ASSIGNMENT STATEMENT
SYN : 1 s

ARITH METICEX PRESSION

SYN : 2
SUBSCRIPTED VARIABLE
SSIMPLE VARIABLE
SUBSCRIPTED VARIABLE
SYN : 3
ARRAYIDENTIFIER
SUBSCRIPTEDLIST/
SUBSCRIPTEDLIST
SYN : 4
ARITH METICEX PRESSION\
ARITH METICEX PRESSION
SYN : 5
TERM . ee ..o-17 -3.3.3
The text specification :
ASSIGNMENT STATEMENT ( SYN ! ) would result in the syntax of ARITH METIC EXPRESSION being described twice in exactly the same words  . Probably this is not desirable , and it would be even less desirable if TERM and /or OPERATOR required further objects to explain them  . 
How can such redundancy be identified and how is it to be handled ? Oneway would be to construct a graph for the relationships to be included in a text plus references to all the occurrences of each object in the graph  . For any object that occurred more than once a check would be made to determine if the subgraph going down from it in one occurrence was the same as in some other occurrence  . All but one such subgraph would be deleted . The one that was to generate text earliest would be retained  . 
Flattening of Structures
Structures that go beyond a certain depth are often confusing if they are not broken up or flattened  . Thus , in describing a programming language the basic symbols  ( such as arithmetic expressions ) are often discussed before the discussion of individual commands  . This means that in discussing an individual command  ( such as an assignment statement )  , it is not necessary to explain arithmetic expressions  ( or variables ) in all their complexity . 
Given the capacity for eliminating redundancies , it is possible to flatten structures . As an example , consider the f?llowing text specification . 
ARITH METICEX PRESSION(SYNI) ; ASSIGNMENTSTATEMENT(SYNI)-18-4 . 0 4 . 1 First , the fragment for the syntax of arithmetic expressions would be printed along with the fragments for the objects it depends on  , etc . 
Second , the fragment for the syntax of the assignment statement would be printed along with the fragments for the objects it depends  on0 etc . , except that the fragments for arithmetic expressions and the fragments for objects it depends on  , etc . would not be printed because they are redundant . 

The approaches to text generation described in the previous two sections have applications in many are as including the following : HELP subsystems for time-sharing systems  , 
Automatic Documentation Systems,
Vocabulary Control,
Automatic Letter Writing and
Automatic Report Generation.
The first two of these applications are discussed below  . 

A HELP subsystem is a part of a time-sharing system that helps the user to understand the system and the various parts of the system  . Two main types of help may be provided :-- abil ity to answer questions about the system  ( without reference to the current state of the system  ) and -- abillty to answer questions about the current  -19-state of the user's job . 
The techniques described in this paper are oriented more towards the former capability  . 
The user of a HELP subsystem is typically in the middle of a task when he needs help  . He wants what he has done so far to be intact when he returns to his original task  . Moreover , he does not want to have to make a special effort to achieve this because  ( a ) he might forget and ( b ) it takes time and he is in a hurry . Often these goals can be achieved by incorporating the HELP capab ! lity into the terminal executive of the system  . 
It is especially important hata HELP subsystem help the user to understand how it should be used  . For example , if the user types in an illegal text specification  , the HELP subsystem might offer to display some material concerning the proper format of a text specifl cation  . 
Ability to handle simple natural language queries is very desirable  , at least the first time a user uses a HELP capability  . It means that he can use it without having already learned to use text specifications  . 

A user of a time-sharing system is entering the statements of a BASIC program on-line when a syntax error occurs on an assignment statement  . 
But the error message does not make clear to him how he can correct the error  . So , he exits to the terminal executive . Then heasks aiseries of questions about the syntax of an assignment statement in BASIC  , finds the information that makes clear how to correct the error  , and returns control to the on-line BASIC compiler with the same environment  -20-t  ~  4  . 2  ( including the partly entered program ) as when heleft . Then , he can reenter the statement hat was in error and continue as if nothing had happened  . 
On Line Documentation Systems
An automate documentation system consists of capabilities for maintaining a database and for producing formal document such as reports or documents for individual use  . The approach discussed in this paper has primarily to do with the generative capabilities  . The documents generated would be natural language texts  . 
Some of the advantages of a non-llne system are : ( a ) the system can be accessed when the information is needed  ;   ( b ) the information that is received may suggest further queries and  ( c ) syntactic or semantic errors in the text specification can be corrected at once  . 
A system using the approach described has the advantage of suggesting gaps in the documentation  . For example , one might discover that a particular object never occurs as a subject or that a relevant relation is missing from an entry  . 
As a fall out of the approach , one has a thesaurus ( or glossary ) for vocabulary control . 
A couple of examples of the use of such a system may be helpful in communicating its significance  . 
First Example
A new person has been assigned to an implementation project  . He Would like up-to-date documentation of parts of the system relevant to  -21-the work he will be doing . In different areas he wants different types of information  . The structure of the texts generated for him can be tailored to his needs by use of appropriate text specifications  . 
If he needs more information in some areas , he can use the system interactively . 
Second Example
The information in a particular area changes frequently and a number of people need to receive up to date information periodically  . A text specification can be created to generate the appropriate information  , and ( assuming the structure of the database doesn't change significantly  ) the same specification can be used to generate a text with the same structure  ( 10 ut different information ) as after 1 as is desired . 

BIBLIOGRAPHY 1.


Lauriault ( Loriot ), James
Shipibo Paragraph Structure unpublished paper , Summer Institute of Linguistics , August ,  1957 . 
Jacobson , S.N.
" A Modifiable Routine for Connecting Related Sentences of 
English Text . " in Computation in Linguistics ( edited by Paul L . Garvin and Bernard Spolsky) , Indiana University Press , Bloomlngton ~ indiana ,  1966 . 
Woolley , George H.
Syntax Analysis beyond the Sentence ( presented at the Fourth Annual Meeting of the Association for Machine Translation and Computational Linguistics  )  , Computer Associates Inc . document no . CA-6607-2121, July ~1966 . 

