Feature Logic with Disjunctive Unification
do chen Dgrre , Andreas Eisele
Institut fiir maschinelle Spraehvera . rb citung
Universit ~ tt Stuttgart
Abstract
\ Veintroducelea . t are terms containing sorts , vz triables , negation and named disjunction for the specification of feature structures  . We show that the possibility to label di@mc-tions with names has m~tj or advantages both for the ' use of feature logic in computation a Jlinguistics and its implementation  . We give an open world semantics for feature terms  , where the denotation of a term is determined in dependence on the disjunctive conte : rt  , i . e . the choices taken for the disjunctions . We define conte : ct-unique fature description . % a relational , constraint-based rcpresentation language and give a norm Mization procedure that allows to test consistency of feature terms  . This procedure does not only avoid expansion 1o disjunctive normal fbrm but maintains also structure sharing between information contained indii:-ferent disjuncts as much as possible  . Context-unique fature descriptions can be easily implemented in environments that support ordinary unification  ( such as I ? UOLOG )  . 
1 Introduction 1 . t . Ambiguity in Nat ; ural \]\[ , anguage Our use of language mirrors our intellectual capacities  , which are as yet my no mea . ns understood . As long as we cannot formally de . scribe the processes involved in thinking and understanding  , k ) rnlM descriptions of human language have to b < : rough approximations  . Onepa . rticular instance of this general fact is ; the problem of disambiguation of human utterances  . Since our use of words fits our capabilities of it nderstanding l  . heir meaning , contex : t and intent , systems that doilot have such capabilities can , at best , produce sets of possible analyses . It is wellknown that such sets can be very la . rgein practice . 
Ambiguity in a at nral language is fed by a couple of source  . ~; , including lexicat ambiguity , where differing analyses are possible for a given word concerning its part of speech  , subcat . -cgorization for complements , morphological features , or anyo ! her information assigned to it , and structural ambiguity introduced by different possible groupings or interpretations of phrases or different interrela Iious between them with respect to subcategorizatioil  , meaning , pragm Mics etc . On each le . vel , a . bunch of possibilities exist , which could po--tentially multiply to an enormous space of combinations  . 
l lowever , these possibilities interact and restrict each other in such a way  , that taking it all together-only a few ( hopcful Jy exactly one ) interpretations remain . 
1 . 2 Uni f i ca t ion - Based Formal i sms For about a decade  , many for nral theories of natur Mlan- . 
guage haw : tried to describe their subject in terms of socalled feature structures  , i . e . potentially nested bundels of features that are assigned to words and phrases  . These structures are sometimes seen as M ) stract linguistic objects , which are described using a suitable description language  , sometimes they are given ~ concrete shape in form of finite automatons and regarded themselves as descriptions of the linguistic objects \[ Kasper /Ronnds  86\]  . Despite such differences in interpretation , there is a consensus among the theories that linguistic description should provide constraints concerning feature structures and that a set  . of such constraints gives a partial description of the features t  , rnctures associated with a phrase . A set of constraints defines a millireal model , i . e . arninimM structure satisfying all constrainls in the set  . The union of two sets of constraints ot ( ontra . .
dieting each other leads to a minimal model which is the least common extension of the models of both sets  . Sn ( -hminimal common extensions can be constructed by unification of the given models  , hence the term unification-based formalisrns . 
There is also a consensus among feature-based ti ~eories that ambiguity should be described with disjunctive formulas  , and most formalisms offer ways to spe (: it them . If disiunct lonis present , there is usila . lya . tiniteltumberel minimal models instead of only one  . I lowever , until now , the way such disjunctive specifications have been processed computaiionally was not quite satisfactory  . An enumeration of the possibilities using a backtracking scheme or a chart  , which c . or responds to an expansion to disjunctive nornlal form in the underlying logic  , often leads to computational ineflMency . 
Approaches to improve the situa . ii on both ill terms of the logic and the inlplementation  ( see e . g . \[ l(arttuncn81, Ka . ' q~er 87 , Eisele/Dgrre 88 , Maxwell/Kaplan $ 9\] ) can be subdivided in those assuming di : , junctive value . stor fealures and lhose allowing \[ or more general terms of disjunction  . 
Roughly , we can state that for nia . lisms and implementatio ; is that provide wilue disjunction can be implelnented more easily a  . nd more efiicienilg ' , since they can exploit the facit hat disjunclive information for a certain feature ha ~  ; no et\[ect(~liother features ( as long ; is disjunctive iui \ 3 rnlation . ' loe ~ not interact with path equivalences , ee\[Eisele/1) grreg8\]) . t 3 t l t . 
the restriction tow due disjunction decreases the expressive power of the formalism  , since disjunctions concerning di\[l\?rent features must be stated on a higher level  , Schemes providing for general disjunction allow for a more compact representation of such cases  . But if disjunctive information is not local to single features  , the interaction between different parts of tile descripi  . ion is more dilfl cuh to handle ( see e . g . \[Kasper87\]) . 
The method we propose combines advantages of both appreaches  . It can be seen as a generalization of value disjunction  , which allows for a concise description of di~Lju ~ c-Lion concerning more than one feature  , or pat ; h . It can also bese . en as an efficient implementation of general disjunctiol ~ which a  . llows to exploit the locality of disjunctive information whenever this is possible  . 
2 Feature Terms 2.1 Disjunction Names
The background of our approach is the simple observation that general disjunction affecting more than one feature can be reduced to value disjunction for those k ' at nres  , provided that tile correspondence between such disjunctions can be expressed within the formalism  . In order to state such correspondences , we will label disjunctions with a disjunctiot ~ name  . Take , tbrinstance , th . e formula ( l ) that could be used 100 is , tAxf:s sFlts Lldt as or ta variables imple complements selection conjunction  ( intersection ) named disjunction ( union ) := A : r := ( ~ ( ~ ) := u-IM .   .   .   . 
:= a EU If z(a ) E\[s ~ . . . .  := D\]I ,,,,~ n \ [ tL ,~ ~ J '~ \ [ s ly , . if . ( d ) :/: gt\]~ , ~ if ~ ( d ) = r Figure 1: Syntax and Semantics of Feature Terms to express that the directional reading of the german prepo -sition " in "  ( = into ) corresponds to the accusative case of the following noun phrase  , whereas the static reading ( = in ) corresponds to the dative case . This can also be expressed by (2) , where the index dl at the disjunction sign indicates the mutual dependence of both disjunctions  . Throughout this paper , we will assume that each disjunction is labelled with ~ name  . Even in cases where a disjunction appears only once in the initial description  , naming it will help us to treat the : interaction between disjunction and path equivalence correctly  . 
(1 )   ( syn:arg:case:datAsem:rel:statdn ) V ( syn:arg:case:aceAsere:rel:dirdn )   ( 2 ) syn:arg:case: ( dat Va , ace )
A sem:tel:(statdnVd,dir_in)rs2 . 2 Syntax and Semantics of Feature term . '\ Veincorporate named disjunction into ~ t language of socalled feature terms  ( similar to those in\[Smolka88\] )  , where each feature term describes a set of possible feature structures  . The language allows for the use of sort symbols A , B , C . .  . (:_S , on which some partial order ~ induces a lower semilattice  ( i . e . VA , BES:CLB(A,B)eS) . T and ? are the greatest and least element of S . We also dis-tinguish a set of singleton sorts ( a , b , c .   .   . ESgCS ), which include the special sort NONE . J_ is the only sort smaller than a singleton sort  . The language provides a set F of feature symbols ( written f , g , h ,   .   .   . ), aniMinite set . V of variables ( written x , y , z , xa , Yl ,  ? ?  . ) to express path equivalence , and an infinite set D of disjunction names ( written d , dl , d2 ,   .   .   .  )  . 
S , F , V and D are pMrwise disjoint . Sort symbols and variables can be negated to express negative values and path equivalence  ( simple negation )  . The restriction of negation to sort symbols and variables is not essential  , since the negation of any feature term can always be reduced to these forms in linear time\[ Smolka  88\]  . 
Definition 1 ( Feature Terms ) We define the set FT of feature terms with wwiables  , simple negation and named dis-junction by the contextfree production rules given in Fig  .  1 . 
Letterss , t , tl, .   .   . will always denote feature terms . 
The semantics of our terms is defined with respect to an interpretation  , which is a pair ( H ,   . z ) of a universe of the interpretation and an interpretation function snch that : ? T z := // and - kz =\ [ ~? for all sorts A  , 11:GLB(A , B ) " z = A ~ rlBz ? singleton sorts are mapped onto singleton sets ? for  (  ; very feature f : f z is a function b /- + l t . 
? if a is a singleton sort and f is a featn re symbol  , then fz maps az into NONE "/ When interpreting a feature term with variables and named disjunctions  , we have to make sure that the same value is assigned to each occurrence of a variable and that the same branch is chosen for each occurrence of a named disjunction  . 
To achieve this , we introduce variable assignments that map variables to elements of tile universe and disjunctive contexts that assign to each dis junction name the branch that has to be taken for this dis  . innction and hence specify a possible interpret at ion of a formula with named disjnnction  . Since we limit ourselves to binary disjunctions , a branch of a dis-junction can be specified by one of the symbols lorr  . 
Definition 2 ( //- Assignment ) Alt-assign me~ta . is an element of l . tV , i . e . a Junction from V to li . 
Definition 3 ( Context ) A context is an element of ( 1 , r)D , i . e . a function from D to the set l , r . 7' he . , ' gmbols ~, ~', etc . will a hvags denote contexts . 
For a given interpretation , we define the denotation of a feature term in a context ~ E  1  , r D under an assignment a EN v as shown in Fig .  1 . The denotation of a feature term as such is defined by : :_- UUst  ,  . 
nEl , rDc~E~/v 3 Context-Unique Feature Descriptions To describe the computational mechanisms needed for an implementation  , we will introduce a relation a language Io express constraints over variables  . Unlike similar approaches ( e . g . \[Smolka88\]) , our constraint language will also bensed to express disjunctive information  . For this language , we will define a normal form that exhibits inconsistencies  , and simplification rules that allow to normalize a given specification  . 
Our language will provide only two kinds of constraints  , one that relates a variable to some feature term ( written zIt ) att done that expresses that certain contexts are excluded from consideration because the inforn -tal  . ion known for them is inconsistent ( written ?\[ k\] )  . 
In order to refer to sets of contexts , we define Definition 4 ( Context Desc . riptions ) A context description is a propositioned . form , law here the constant TRUE , variables written d , : l and d , : r with d , ED , and the operators A , V and ~ may be empl ~ we cl . 
CD will deplete the set of context descriptio ~ ts . The symbols k , kl .   .   .   . will alwags denote members of CD . 
The set of purely co~junctiv context descriptiol ~ s  (   , oteoa-taining the operators V and ~ ) is denoted by CD ? . 
Each context x satisfies the context description " rRu\[  , ; ( written n ~ , : TUUF ) , where a , , n  ~ . d : b forbEl , r only if t ~( d ) = b . 7' he meaning of context descriptions in voh . ,i , gA , V and -~ is defined a sirt propositional logic . 
If n~k , we will also say that k describes or covers ~ r or that ~ lies in k  . 
A context description is called contradictory , if ~ meold ~: rt satisfies it . 
Two context deseripti < msk , k ' which are satisfied b!\]e:ractlg the same contexts are called equivalent  ( written \] , '=-k ') . 
2 i0 1
An important form of constraints for our approach are constraints like xIzlk in  ,   x2 which expresses that x and x l have to be equal in contexts where ~  ( dl ) = 1 and so dox and x2 in contexts where ~ ( dl ) = r . Such constraints are called bifurcations and Xl , x2 are called ( the dl : l - and dl : r- ) variants ' of x . Assume an additional constraint xl\[xakid2 x4 , then x3 will be called the dl : lA d2:l-variant of x and so on . 
Now , instead of accumulating constraints on the variable x which might be effective in different contexts and could interact in complicated ways  , we ( : an introduce new variables as variants of ~ and attach the information to them  . 
We will sometimes reffer to a . variant of a variable x without having a variable name for this variant  . To this end , we will use a special notation x/k to denote the k-variant of x  . Such expressions will be called context cd variables  . 
Definition 5 ( Contexted Variables ) A contexted variable is a pair x/k where xGV and k ~ CI  ) ~ . 
V , : wilt denote the union of V with the set of e on texted varioables  . Elernents of V~will be written with capital letters X  ,  ?' , Z , X 1 , Y ' I .   .   . libmark the distinction , we will some . .
time . ~ call the members of V pure variables.
During t . he normalization of feature descriptions we will sometimes need variable substitution  . If a descriptione on-taiz)se . g . x\[y , where other constraints might express conflicting information about x and y  , we want to concentrate this information on one variable  ( saya : ) by m~bstituting alloceurences of y in other constraints by x  . This could lea ( \] to problems when constraints attached to x and y are relevant in different contexts  . One way to treat this situation cor-rec' . ly would be the introduction of conditional substitution  ( seei Eisele/DS rre90\] for details )  . The way we choose here is to rest . ric ~ the use of variables in such a way that it is always safe to use conventional substitution  . 
Our trick **' ill be to require thud . essentially all occurences of a variable x are relevan to the same set of contexts  . We call this condition ( defined more precisely below ) the context ? uniqaer ~ ess of variables . ~ V e . will setup the normal for nl and the rewrite system in such a way  , that context-nniquel , ess of a description is maintaine during the simplilication pro-tess  .   ( See\[Eisele/i ) Srre 90\] for a more detailed motivation of context -uniqueness  )  . ' The set of relevant contexts will be regarded as an inherent and invariant property of varial  ) les , and we will introduce a context assignment , i . e .   , ~ partial function Con : V~--~CD ~: that maps each variable in use to a purely conjunctive description of the contexts it is relevant to  . \\ reext end (' onto context . ed varial ) les by defining
C'ou(:,./~:)::::co,,(:~)A~.
in order Io obtain context-uniqued scriptions , we generalize our feature terms so that they may also contain contexted variables  . 
Definition 6 ( Gontexted Feature Terms ) A contexted feature term is buih ' according go definition l  , but where both p~tre and contexted variables may occur  . The set of context cd feature terms will be denoted by FT ~  . The symbols s , t,t ~ .   . .
may henc@~rth also denote contexted feature germs.
The dc**otation of a contcx ted feature term in a context nI  , r D under an assignment e e ~ l/\[V is defined as for usual feature terms by adding : \[ x/k\ ]~  , ,~ := ~ otherwise We can now define the context compatibility of a feature term  . This definition is somewhat echnical and the reader can skip it  , since our algorithm will produce only context -unique descriptions  , anyway . 
Definition 7 ( Context compatibility ) Given a partial assignment Con : V~-~CD e , a contexted feature term t is context-compatible to a context description k with respect to Con  , written t , ' o conk , according to the following conditions . A ~ Conk
X " conk-~t "- co , ; kf:t ~ Co , , k s N t " con k s Ud t " Con k for arbitrary k E CD ~ iff Con  ( X ) = klift ~ Co . klift ~ Co . kiffs ~ Co , k and t*~Co , * k if Js ~ Co ~ kAd : l and t ~ co , ~ kAd : r Definition 8 ( Context-unique feature descriptions ) A context-uniquc feature description ( m0 , CUC , Con ) is a triple such that : * xo CV , called the root variable eCUC' is a set of context-unique constraints which either have the form &\[ k\]  , where kECD or Xlt , where XCV ~ , tEF '? ~ and t " co , ~ Con ( X ) o Con is a context assignment which is defined for all variables in CUC The semantics of context ounique feature descriptions is given by the satisfaction relation t-::Co~between variable as  . ~ ignment f l , contexts and constraints , which is parametrized with a context assignment . 
~, ' ~ t := ~: . . . . . XltiJJ " ~ V : ~ Co, . ( X)o , "< X)c~t\] . . . . . 
~ , ,~ V<'o , , ?\[ k \] ifl ~ >~ k 7'he denotation of a context . unique f-description is :\[( x0 , c ~ c , Co , ,)lj :--= ~ O'0) I ~ < zcv , ~ cl , r : ? s . t . 
Ve~CUC : r_t,~t::Co-c
Given a feature term t not containing the variable  x0  , we ( : an find an equivalent context-unique fature description  ( x0 , ~0 IF , Con ) as follows . We initialize the context assignment Conso that x0 and all variables e on t , dnedint are mapped to TRUE ( they are regarded as relevant o all contexts )  . Then we obt Mn the contexted feature term t'by replacing all occurences of variables in t which are embed?ded in disjunctions by their appropriate variants  , such that ~ J " ~ C : on TItUE 2 . 
Proposition : if t does not contain the variable  x0  , and if Con and t ' are obtained fi'om tas described above  , then \[ t ~ ~ . = ~( x0,:coIt ', C0n ) ~ . For a proof see\[l'; is ele/l ) grre90\] . 
4 Normal Feature Descriptions
One way to elimina : tea contexted wn : iable ( take e . g . x/dl : l ) from a description is to introduce a bifurcation ( xJ xlkl ~ x2 ) and replace the variable by an appropriate variant  ( in this case xl )  . An Mogously , contexted variables with rnore coin-plex context descriptions can be replaced by introducing several bifurcations  . However , it turns out that our representation can be more compact if we allow for the use of contexted variables  . But we have to prevent conflicting in-lbrmation from being attached to variants of a variable  . Our normal form will therefore allow the use of contexted variables in certain places  , but in some cases , a pure variable has to be used . 
lc ~ is extended to e on texted variables by : a ( x/k ) : : : : : c ~ ( x )   2 \] in the sequel we will also assmne that in accessible disjuncts resulting fi'om nested disjunctions with identical names  ( e . g . t2 in tltad(t2Mdt3)) are removed . 

A context-unique fature description ( x0 , CUC , Con ) is nor ? tool if it satisfies the following conditions : A  ) All constraints in CUC have one of the forms : ? Z\[k\]?xIxlUd  z2 ? xl-~y , where x 7~ y?xlAorxl ~ A ? xlf:Y where kCCD , x  ~ , x2 , x , yCV , YCV ~ , dED and AE
S\T ,_L
B ) ' l The following restrictions apply : t . \]f?\[k\]audxI ~ aroincuc , then Co . (~') A- , k is not contradictory 2 , if xIX aud XIl \] are in CUC , then A = 1\]3 . if : el a and xlt are in CUC , then t = a 4 . if x\]A and xI-~I3 are in CUC , then A ~ . B and 5 . if xI ~ A and a ' I ~ B are in C ' UC , then A ~ B 6 . if x lf:Y and mlf:Z are in CUC , then Y =  Z7 . if _L\[k\]and . L\[k'\]areit,CUC , then k = k'8 . if x12:1lad~;2 and xIt are ill C\[r (? , then t = , ';'21 UdX24 . ? Simplification Rules for Normalizat ionFo ~: normalization  , we have to consider all ways a context-unique feature description could fail to be normal  , and we have to find an equivalent description that is in  ( or closer t . o ) normal form . To this end , we give simp\]ification rules for each possible case  . Since there are many different ways to violate normal form  , we get a lot of different rules , but each of them is very simple and their correctnes should be easy to see  . The rules are parametrized with the root variable  ( which should not be substituted away ) aml with th < context assignment , which will be extended to new vari-abh : . s durings ~ implification . To facilit ~ tenotation , we use c . ~ . ; CUC to denote  c  u CUC where CUC is supposed no ~lo contain the constraint c  , and C/fCx ~ , a denotes CUC with all oecurences of x replaced by y  . Also , if we writed : bAk ' , then k ' is supposed not to contain d : b . The eases we have to handle are grouped in those that treMsingle nonnormal constraints  ( S ) and those that treat interactious between different constraints  ( M )  . 
There are S-Rules for all forms of constraints which conflict wilh condition A  )  , i . e . which are of our of the forms
J . */ kl~e . ~l-,vlk:LxlY 4 . xl to rxl-~t , where t has the form T , 2_ or z 5 . x \] f : ~ l , where tl ~ V c 6 . xlt lFlt2r .  : , : It ~ uat 2 , where h ,   t2 ?_g Among the situations in which a contexted variable x/k con-fliers with normal form  , we have to distinguish sever M cases . 
If \] . : ~' I'RUF , , then the context description is irrelevant and we can replace x/k by x  ( Rule S ~ , ,lb ) . Otherwise , if there exi : qtsah : eady a bifurcation x lxtLlaxr  , such that k_~d:bAk ' for some bC1 , r and k ' C C D ~ , where k ' does not contain d : b , then we can replace x/k by the shorter term : cb /k '  ( Rule S ~ , ,lc ) . \] f there is a biflu:cation x\]:tt LJ dz , -where d does not appear in k , the constraint attached to x/k is dist . ributed over the wtriablc . s : ct and x , . ( Rule S ~ , , ld) . In order to maintain context-uniqueness , the variables appearing in the constraint luLve to be replaced by their respective el :/  . and d:r-w ~ riants . We use il k as a shorthand for a e on-texted feature term  , where each variable has been replaced by its k -variant  , i . e . z has been replaced by z/k and z'/k'by z'/ ( k ' Ak )   ( see also rule ( M ~8 c )   , below ) . Only if nobi-furcation exists for x we have to introduce a new bift trcation  ( Rule S ~ , ,le ) . We select a disjunction named flom k such that k-d:bAk ' for some bEl  , ratt dk ' ECD ? , where k ' does not contain d : b , we add a bifurcation xlxtLid :/: , , to CUC , where act and x ,  . are new variables , and we extend C on by mapping x ~ to Con ( x ) Ad : l and x , -toCon(x ) Ad : r . 
Now we can replace x/k by xb/k'.
The other rules handle equalities by substitut ing a variable by some other variable  , eliminate redundant constraints , handle inconsistencies , or decompose constraints with complex feature terms into a set of simple constraints  . 
' l ' he cases where a pair of constraints violates some of the conditions Ill  -7 can be treated as for similar non-disjunctive rewrite systems  ( see\[Smolka88\] or\[Eiscle/DS rre 9 ( /\] )  . 
Rules M~,\]-7 handle those . When a bifurcation xIx : tJdx2 occurs together with some other constraiut on z , this could lead to a contradiction with informat ion known about xlandace  . ilere , we disting nish three cases , if the other constraint happens to be a bifurcat i on reIylLid Ye with the same disjuoction name d  , we get equalities between both d:i-variants and both d:r-variants  ( Rule A/?~8a )  . If the other constraint is a bifurcation xI ylIdol  , y2 with a different disjunction name , then the . two disjunctions interact and have to be multipl ied out for the w triable x  ( lhlle3/ ~ , 8b) . 
To this cud , four new variables are introduced as variants of xatt dnew bifurcations are installed that link the new variables to those already in use  . Con is extended for the new variables . In any other case , the constraint attached tox is distributed over both variants  , and context descriptions for variables on the r ight-hand side of the constraint are introduced or adapted as required by context-uniqueness  ( tlule M~Sc )   . 
4 . 2 Soundness ; Completeness and Ternfinatlon We can show that our simplification rules constitute an al -gorithn a for the consistency  ( or unification ) problem , which is sound and complet c and guaranteed to terminate  . For detailed proofs the reader is referred to \[ Eisele/I  ) Srre90\] . Below , we give the key intuitions or strategies for the proofs  . 
Soundness can be seen by inspecting the rules . ?ach rule rewrites a clause to one with an equivalent denotatlom To show that the algor ithm M ways finds an answer  , we first observe that to evcry context-unique feature description that is produced during translation or normalization aud that is not normal at le  , ' Lst one of the rules applies . When the result of simplification is the single constraint ?\[ kI where k ~ " rRuI  . :, this means that the description failed to unify . 
in any other case we cart construct models from the normal form result  . The basic idea is to choose a context i ~ which is not covered by the context description of a constraint Z\[k\]in our formula and ' project ' the formula into this context by regarding  0nly those constrail , ts which are relevant to this context ; , thereby degenerating bifurcations to nondisjunctive bindings a " IY  . This nondisjunctive set of constraints can be made into a modeh In order to prove termination we construct  , a complexity measure for descriptions ( a natural number ) which is decreased in eve , ') , rewrite step ( see\[Eisele/DSrre90\]) . tIere we take advautage of the fact that al though there are rules which increase the uumber of constraints and hence seem to add to complexity  , these rules also can be seen as part . of an inherently irreversible process , since they distribute information M . tached to a variable over variables in more specific contexts  . But since the number of dis , junctionuames 4103 ( Scula ) ( s ~ . .~) ( s ~,~) ( s~3a ) ( s~3~) ( s~3c ) ( s~4 . )( S ? , ~4 b )   ( s ~ 8 )   ( s~6 )   ( s ~ 7 ) ?/ ~ lx/~'x ~ cucxl~lts ? cucx / kltX~x lx~dX  ,   . & CUCx/klt&xlx ~ uax~hCUCx/~lts~cucxl- ~ylk & CUC xlYlk & CUCxly & CUC xol Ygz CUC zlt&CUCxlt&CUC ~  , ~ lf:t~tzCUCx lhrnt2 & CUCxl hUdt ~& CUC---*xo , Co , ~ CUC(k--k ' due to context-uniqueness ) -* xo , Co . xlt&CUC , if k ~ TRUE - '* ~ . o , co~xb/k'lt&xlxtLAdX , "& CUC , if k ==- d:b Ak'--*zo , Co~x , / klt/d:lt ~ x ,  . / klt/d:rSz~l ~ , ~ xT , ~: cuc , if ( S : ~ , lc ) does not match---~o , co , ~ x~lk'lt&xlx ~ Udx ~& CUC if ( S~la , b , c , d ) do not match , k =_ d:bAk ' , x  ~ , x , , are new , and Con(xb ) := Con(x ) Ad : b - - + ~ o , co , ~ y/kl " . x8z CUC---*~o , Co~y/klx~CUC--+xo , ConCUCx ~ , if x?x0-*~o , Co~CUC ~_ ~ , o--~o , co , ?\[ Con(z)\]&CUC , if t = ? , t = -~ V or t = -~ x-~o , co ~ , CUC , if t = T , t = ~_k or t = x~xo . Co~xlf:y&y\[t&CUC , if tCV ~ where y is new and Con ( y ) := Con ( x ) --" ~ o , Co . xl&&xlt2&CUC--*xo,Co~xlxtUdX . & xtltt&x , - lt , XcCUC where & , t2?V , Xbarenew and Con ( xb ) := Con ( x ) Ad : b ( ~4 cul )   ( M  ~2 )   ( i ~3 ~ )   ( M ~4 ~ )   ( M  ~ , ,4~) ( M~5) ( M~6) ( M~ . 8a )   ( M ~ s8 )   ( M : ~8 ~ ) ?\[k\]~xlt&CUCzlA&ztB&CUCxla&xl- ~y & CUCxla & xlf:Y&CUCxlAS zxl-~BS ? CUCxlA ~ zl-  , B&CUCxI- , A ~ xl- . B&CUCxlf:Y & zlf:Z&cue ?\[ ~\] s~?\[ ~'\] ~ cuexIx ~ LAd  x2 & : xlY ~ LJd y2   ~5 CUC xlx ~ LA a ~ x ~ ~ xly LJ d ~ z ~ CUC x l x x u ~ z ~ ~= ~ lt&cue"-+X  0   , Con~-'~xo , Co~-~x0 , CorL "- ~ xo , Con "-* xo , Con "-'-~ x0 , Con--'~Xo , COrt ""+ xo , Co~--+xo , Con--+xo , Con "-+ xo , Con_l_\[k\]&CUC , if Con(x)A- , k is contradictory xIGLB(A , B ) & CUCxla & yl-~a&CUCxlag?YINONE & cu e?\[Con  ( x ) \]~5 CUC , if a_<Bx\[A&CUC , if GLB(A , B ) = ? x\[~B&CUC , if A < Bxlf:Y&ZIY&CUC_l_\[kvk'\]& CUC xlx ~ uax~s ~  ( cucw-x ~ ) u :- x ~_ xlxlLJ dxx ~ ~ xll!/a LAd2 zl  ~ xzly2 Lla ~ z'2 ylylk la ~ y ~ & zlzl t2at   z2 ~ CUC , where dl:/:d2 and yl , y2 , zl , z2 are new--*~o , Co , xlxaudz2&zalt/d:l$ . ~ z21 t/d:r ~ C rfC where t is not a bifurcation
Figure 2: Simplification Rules is limited , the contexts associated to variables cannot be arbitrarily specific and hence  , this process must terminate . 
4.3 An Example
Due to lack of space , our example cannot demonstrate all capabilities of the formal is rn  , but will concentrate on the treatment of disjunction and the support of structure sharing between different disjuncts  . Assume as initial feature term f : ( xNg:ta ) V3h : ( ( x Ud y ) yli:tI ) where ta and t1 might be themselves complex . Translation to context-unique tbrm will produce the description  ( x0 , xolf : ( xNg : t'c ; ) Nh : (( x/d:lLAdy/d:r)Ni:t'D , Conl ) where t ' ~ and t might contain contexted variables if necessary  . Partial normalization then produces x0  \[  x01h zlx/d:lUay/d:x ~ It ) ' where the further decomposition of the constraints Xt " alta  , x ~ lt ~ need not interest us . Since the bifurcation for z contains e on texted variables  , it is replaced by zlz , Udz ~ , zzlx/d:l , zrly/d:r , but the latter two constraints lead to the introduction of bifurcations also for x and y  . Furthermore , the feature constraints on x and z are distributed over their respective variants  . We eventually get : xo , ~ x\[ . ludz , . , 6' o ~3 ~ , . 1i : xz/d:r , % ~ l~tUdzr , Although the resulting description contains contexted variables which refer to variants of zc and : r ~  , we do not have to introduce bifurcations for these variables  . It cnce the information contained in constraints on the variables x a and x i is not duplicated  , although both variables are used within a disjunction  . However , if there would be more information on the values of the g-or/--features of z ~  , x  ~ , or z ~ , for instance a constraint of the form z ~ lg : x ' , this would lead to the introduction of a bifurcation for x a  , and some parts of the structure embedded under x a would have to be dis-tributed over the variants of za  . But the unfolding of the structure below xc . would be limited to the minimal necessary amount  , since those parts of the structure that do not interact with information known about ~' could make use of contexted variables  . 
Informally speaking , if we unify a structure with a disjunction , only those parts of the structure have to be copied that  104   5 interact with the information contained in the disjunction  . 
4, 4 Algorithmic Considerations
One major advant ~ geofour treatment is its similarity with conventional rewrite systems for feature logic  . Since we per-lorm only convention M substitution of variables  ( opposed to conditional substitution as in \[ Maxwell/Kaplan  89\]  , see\[Eisele/Dgrre90\] for a discussion ) , our system can be easily implemented in environments providing term unification  ( PnoLoc , ) , or the ahnost linear solution of the union/find problem could be exploited  ( see e . g . \[ Aft-Kaci84\]) . The only essential extension we need concerns tire treatment of context descriptions  . A context description contained in a contexted variable is always purely conjunctive  , tIence the necessary operations ( comparison with TRUe ;  , locating , adding or deleting a simple conjunct ) can each be implemented by one simple list operation  . In the constraint expressing in consistent contexts  ( A_\[k\] )  , k is a disjunction of the inconsistencies found so far  ( which themselves are purely conjunctive )  . This could be also represented in a list of ( purely conjunctive . ) contexts . However , the exclusion of irrelevant constraints ~: It , where Con(x ) is covered by k in ?\[ k\] , and the ( final ) test if k ~ TRU e involves a bit more propositional calculation  . Since these tests might occur more often than the detection of a new inconsistency  , it might be worthwile to use a representation that facilitates the test for entailment  . In any case , the implementation can make use of fast bit vector operations  . 
<!: . 5 Maxwel l and Kap lan ' s Approach An approach which ours is especially interesting to con > p are with is the disjunctive constraint satisfaction procedure given in \[ Max well / Kaplan  89\]  , because of the similar representations involved in the two approaches  . They use also disjunction names and contexts to represent disjunctive constraints and propose  , ~ general transformation procedure which turns a rewrite system for non-disjunctive constraints into one which handles disjunction of constraints with the use of corttexted constraints  , having the impli . -cational form ( k-~d ) , where ? is some non-disjanct lw . ' constraint . This is done by replacing every rewrite rule by its " contexted versim F '  , e . g . , ?1 A ?2 ~ ? a is replaced by ( k : t - ~ ( / ) 1 ) A ( k2-~~2 )  - - '+  ( klA"~k2 ~ ( / ) 1 ) A ( k ~ A ~ k ~ -- , O ~) A(<A k ~-- ,  0~) , where k ~ and k ~ are variables for context descriptions  . There are two severe efficiency-critical problems if we want to use the outcome of this translation without further optimization  . First , any rule of the generated form should only apply to a pair of contexted constraints whose contexts are compatible  , i . e . klA/c2 is not contradictory . But now , since context descriptions taay include conjunction and negation at any level  , this test itself is an A/P-complete problem , which has to be solved before every application of a rule  . The second problem concerns substitution . Consider a rule like z-yA~~~,a- . ~ . 
The translation produces a rule in which ( P is rewritten to both ~ and ( I ) v_x , indexed with different context descriptions . Thu , ~ , we cannot simply perform a replacement , but instead , have to make a copy of 45 ( or at least those parts of 45 containing y )  . Unfortunately , this prevents also the efficient union/find method to be employed for bnilding equivalence classes for variables instead of actual substitution  . All of I , hese problems arc avoided if we let the context description  , : ) facontexted constraint depend implicitly on the variables in it through the introduction of context-unique variables  . 
From this point of view , our method can be seen as an op-tirnized implementation of the translated rewrite system for unification in feature logic wittt sorts and negation  . 
5 Conclusion
To summarize , we have presented a new unification method for tilefull la  . nguage of feature logic including variables , sorts and negation which avoids expansion to disjunctiw ~ normal form  , if possible . The basic principle is to minimize unnecessary interaction of dilt'erent disjunctions by keep h~g then llocal to those attributes which they specify different values for through the introduction of disjunction names  . With this treatment we avoid expoimntial explosion in many practical cases  . A precursor of this algorithm\[DSrre/Eisele 89\] has been implenlenled and is successfully used in a grammar development environment  . Besides the obvious advantage of increased et liciency  , our compact representation of disjunctive information also facilitates the comparison of a hernativ c solulions with common parts  , which has been proved to be a very valuable property in our application  . Our algorithm is specified in a completely formalised way as a rewrite system for which a model-  . theoretic semantics is given . It may seem that there are a lot of rules , but this can be explained by the following facts : we include a complete reduction from feature terms  ( like in t ( asper/I/ounds logic ) to feature descriptions ( as used in Lt . "G ) ; we handle all different types of constraints , in chlding sorts ~ md negation in one framework ; and our rules only involve few primitive operations for which s in rple and fast implementations exist  . 
Refererlces\[Ai't-I , : aci84\]Ai't-Kaci,lI .  (1984) . A Latlice-Theoretic Approadl to Computation Based on a Calculus of Partially-Ordered Type Structures  . Ph . D . Thesis . University of \[~ ennsylvania . 
\[ DSrre/Eisele89\]DSrre,J . and A . I : ; isele (1989) . Determining consistency of feature terms with distribute disjunctions  . In : D . Mctzing red . ) GWAI-89 , 13th German Workshop on Ar-lificial Intelliyence , pp .  270 279 . Informatik\[;'ach be richte2I6,

\[F , isele/1)Srre88\]Eisele , A . and J . DSrre (1988) . Unification of disjunctive feature descriptions . In : Proc . o/the'2 . 6rd Ann . 
Meeting of the ACL , Buffalo , NY.
\[ l'; is ele/D&'re90\]t';isele , A . and J . 13 Srre (1990) . Dis . junc ~ ive Unification . IWBS-l~eport , IWBS , IBM Germany , Postfach 8008 80 , 7000 Stuttgart 80 , W . Germany . To app . in : f " , ' oc , of t\]~c Workshop on Unification Fo'r'm . alisms . . . . Syntax .   , q'eman ~ i , :s and Implementation , Titise e , MIT Press . 
\[Karttunen84\]Karttunen , L .  (1984) . Features and Values . In : P~'oceedings of COLINGI98~, Stanford , CA . 
\[ l(asper87\]I(asper , tt . T .  (1987) . A Unification Melhod for Disjunctive Feature Descriptions  . In : PT " oc . o . f the 25 ~ helnn . Meet-in . qo / the ACL . Stanford , CA . 
\[ t(asper/lounds86\]Kasper,H . .T . and \ V . flounds (1986) . A Logical Semantics for I ;' eature Structures . In : Proc . of ~ he2 . ill , Ann . ~ l qeeling o / the ACL . Columbia University , New York,

\[ Maxwell/Kaplan89\] Maxwell , J . and It . \[( a plan(i989) . Disjunctive Constraint Satisfaction . Ill : Proc . \[ nLIVS 0 n Parsing Technologies , Carnegie Mellon , Pittsburgh , PA . 
\[Smolka88\]S molka , G .  (1988) . A Feat ~ Lre Lo . qictcizh5'~tbsorla . 
LILOG-F ~ eport 33 . IBM Germany . To app . in : J . of Automatodlt . easoning . 
\[Smol'!~,89\]S molka,G .  (1989) . I " ea ~' reConst . , ' ai'at Logic . s . f , ~ J Unification Grammars . IWl-~S-teport 93 . D,\'BS , IBM Germany . To app . in Proc . o / thel'g . 5' on UTzifica . tiorz Formalis ', ls---Syn . ?ax , Semantics and Implementalion , Titisee , MIT
Press , 6105
