Emergent Parsing and Generation with Generalized
HASIDAKSiti
Electrotechnical Laboratory
1-1-4 Umezono , Tukuba , Ibaraki 305, J ~, pan
Email : hasida@etl.go.jp


A new , flexible inference method for Horn logic program is proposed  . It is also a drasticgencn dization of chart I ) aming , partial instaatiation of clauses in a program ronghly corresponding to arcs in a chart  . Chart-like i ) al~ing and semantic-head-drivenge ration emerge from this method  . With a parsimonious instantiation scheme for ambiguity packing  , the parsing eoml ) lexity reduces to that of standard chart-based algorithms  . 
1 Introduction
Language use involves very complex interactions an mng very divm  . 'se types of information , not only syntactic one but also semantic , pragmatic , and so forth . It is hence inappropriate to assmne any specific algorithm for syntactic parsing or generation  , which prescril ) es particular processing directions ( such as left-to-right , topdown antibottom-uI )   ) and is I ) i as c d f l ) r specific types of domain knowledge ( such , ' ~ sae on text-fl'ee grammar) . To accmmt for the whole language use , we will lmve to put many such algorithms together  , ending up with an intractably complicated model . 
A better strategy is to i ) ostulate no specific algorithms for parsing or generation or any particular t ~ k  , but instead a single uniform computational method from which emerge various types of computation in -eluding parsing and generation dei  ) ending ui ) on various computational contexts . 
For example , Earley de ductiml ( Pereir : t&Warren ,  1983 ) is a general procedure for dealing with Horn clauses which gives rise to Earlcy-like parsing when given a contextfree grammar and a word string as the inlmt  . Shieber ( 1988 ) has generalized this method so as to adapt to sentence generation as well  . Thosen mthods fail to give rise to cllicieut conq ) ution for a wide variety of contexts , however , because they prescribe processing directions such  , ~left-to-rightf ( Jr parsing and bottom-up for generation . They also hu:ka general way of efficient an fl ) iguity l ) acking unlimited to contextfree grammars . Hasida ( 1994a ) i ) rol ) oses a more general inference method for clausal form logic l  ) rograms wtfich accounts for efficient parsing and generation ~ memergent l  ) hmm mena . This mctho ( l prescribes no fixed processing directions , and the way it packs ambiguity is not specific to contextfree gnun-mare  . However , it is rather complicated an ( l has greater computational complexity than standard algorithms do  . 
In this i ) ai ) er we propose another inference method for tlorn logic programs based on I iasid a  ( 1994a )  , and show that efficient parsing and generation mnerge from it  . Like that of Ilasida (1994a ) , this metlm d is totally e on straint-1 ) : med in the sense that it prcs upl ) oSCS not axed directions of information llow , but it is more ellicic ntowing to ap : trsimonious nmthod of instantiation  . In Section 2 we deline this inference method , which is a generalization of chart parsing , and may be also thought of : maconnection method or a sort of l  ) rogram transformation . Section 3 illustrates how et fi-cient parsing and gencratiml emerge from this method witl mutany procedural stipulation specific to the t:mk and the domain knowledge  ( syntactic on straints )  . Section , 1 introduces a parsimmfious instantiation mthod for ambiguity packing  . We will show that owing to this nmthod the ciliciency reaches that of the standard algorithms with regard to contextfreel  ) arsing . Section 5 < : on ( ' huh ~' s the paper by touching upon further research directions  . 
2 Partial Instantiation
A constraint is represented in terms of a Horn clause progral n such ambelow  . 
(a ) - p(A,B)-A = a(C).
(b)p(X,Y)-X = a(Y).
(c ) p(U , W ) - p(u , v ) - p(v , w).
Nanmsl ) cg in nl ng with eaplt al letter src prese at variables , ; md the other names l ) rc(li(:ates . ' unl funetors . 
The atomic formulae following them aim sign are negative  ( bo ( \[ y ) laterals , an ( l the others are positive ( head ) laterals . Acl . ' mse without a positive literal is called a top clause  , whose negation represents a go M ( top level hYl ) othesis )  , which corrcs pomls to a query in Prolog . For instance , top clause ( a ) in the above l ) rogram is regarded as goal ~_IA , B , C p(A , B ) AA = a(C ) . In general , there may be several top clauses . The purpose of computation is to tell whether any goal is satisfiable  , and if so obtain an answer substitution for the terms  ( variat ) les ) in a satisfiabh ~' goal . We consider the minimal Herbrand models as usual . So the set of answer sul ) stitutions t brA in the above i ) rogram is a ( B )  , a(a(B )) , a(a(a(B ))) , - . . . 
A graphical representation f this program is shown in Figure  1  . Here each clause is the set of the litends enclosed in a dimclosed curve  . A link connecting ar-gmllnents in a clause is the term  ( varial ) le ) filling in those arguments .   ( It is a hyperlink when there arc more than two arguments  . ) A transclausal link represents the unifiability between two corresponding arguments of two unifial lcIt  ) orals . ( Neglect the arrows for a while . ) A hypothes is is a conjunction of atomic formulas and I  ) indings . The premise of a clause ( i . e . , the conjunction of the atomic formuhts and bindings which appear ~ negative literals  ) is a hypothesis . An ex-pansion for a hypothesis is a way of conll ) ining ( ill-stances of ) clauses by resolutions so ~ m to transl : tte the hylothcs is to another hypothesis involving bindings only  . We will refi , ~ r to an expausion by the sequence of clauses i u the order of lcftnlostapl fiication of res -elution using their instances  . 1 In the above lrogram , for examile , expansion ( e , b , Ii ) translaLes the tol)-level hylm thesis ( A , B ) AA = a(C ) to a hypothesis A = a(C ) AC = a(B) . An expansion of a clause is a nexl ) ansiou of its premise . We will simply say ' an exiansion ' to mean all expansion of the top level hylothesis  . Al ) rogranl represents a set of expansions , and the COmlut ~ tion~m discussed later is to transform it so a  . stoligure out colrect hypotheses while discarding the wrong expansions  ( those entailing wrong hypotheses )  . 
We say that there is a dependency between twote rms whetl those ternls are unified in some exl  )  ; tllSiOll , and the sequence of terms ( including them ) ntcdiating this unification is called the del ) endency l ) at hofi , his dependency . In Figure 1 , for instance , the depend cacy 1 ) etween A and X is mediated by dependency path A . X , A . U . X , A . U . U . X , and so on . There is a dependency Ie-tween C and B , among others , be , cause of the unilia-bility of the two-o = a(o)s , though ~ his unifiability is not explicitly shown in Figure  1  . We say a dependency between two terms is consis tent when they at '  ( : not bound 1 ) 3' inconsistent bindings . All tile dependencies in Figure 1 are consistent . 
A solution of the program is an expansion ill which every dependency is consistent  . St ) the : Oml ) utation we propose in this paper is to transform the given program in such a way that every delendeney be consistent  . ~lb figure out dependencies , we use a symt ) olico I ) eration called subsumption , and delete the parts of the lrogram which contrilmtes to wrong exlansim stllere we meution the order anlong the literals in a clause just for explanatory convenience  . This order is l to t . sigaificanl , in the computation discussed later . 
only . For example , suppose there is an inconsistent dependency between terms < ~ and ft  . We create an instance fl ' off l1 ) y substunption operations to be discussed shortly , so that every expansion containing an instance of  \[31 contains an instance of a delcn deney path between ? x and f t  . We can then delete t it , " clause containing flJ and probably sonte more parts of the progranl without affecting the declarative semantics of the program  . Below wc will dc iine a computation alir occ dure in such a way that the  , set of the possil ) le expansion seventually represent the set of all the solu-ti  ( ms . 
Subsmuption operation is to create subsumption re lationship  . We regard each part ( clause , atomic for nmla , term , etc . ) of a program as the seg of its instances , and say that a part ~ of the program subsumes another Itart't I to mean that we explicit ly know that  ( D ~/ . We consider that a link is subsumed by 5 if and only if one of the terms it links is sulsmncd by  5  . We say term 5 is an origin of , q when ~/ issul ) sumed by 5 . In this ) taper we consider that every origin is a bound term  ( the term filling in the Iirst argmnent of a I ) inding )  . Let us say that two clauses ( or two literals ) are equivalent whentltey are of the same form and for each pair of correslmnding terms the  , two terms have the same sel ; of origins . 
,qubsuntption relation restricts the possibility of expansions so that if term ~ l is subsumed by auother to  , r l ) l ( ~ ,   ) hellevel ' y expansion containing an instance  . 
of 7\]1)ll ) St also contain an instance of 5 . SttbsUlnl ) tion relation is usefld to encode structure sharing among CXIt&IlSiOIIS  . \[ llSl ) bSlll ) ll\[ ; ioll-) ; tse\[~tp pro:tehes~ater ) ltn ) ay subsume several non-unilial ) le terms and thus the first term is shared among the latters  . I Iowever , thai ; is int possibh ; in unification-I ) ased approaches , where difl'er cnt expansions ( : ltl ) llOf5 share the same instance of it ~ erll ) Ol "\[ tC\[allse . 
A partially instantiated clause is a el , ' utsesome ol7 whose terms is subsumed by another terln in possibly another clause  . For instance,
O)a(A ~, Z)-b(~,~)-c(~, Z).
is a Iarti ; tlinstant ) at ) on of L he follow in ~ clause: ( 2 ) a ( X , Z)-b(X , Y)-c(Y , Z) . 
represents a term sul ) sumed I , yt!l . 1\]t)A,2IIer cafter wcsay just'clause'l . o refer to 1 ) oth uninstantiated clauses al ) (l partially instantiatcd clauses . 
A program consisting of such clauses is a gener -alizatiou of a chart  ( Kay ,  1980) . A chart is a graph whose node , s denote positions between word sill as ell-tenee and whose ares are regarded as contextfree rules each instant  ) a real partially with respect o at most two such positions  . For instance , an active a refront node i to node j labelled with\[A-**H?C \] is an instance of rule A - ~ l ~' C with Ioth sides of B instantiatel by positions i and j  . This arc approx in tatcly corresponds to ( 1 ) 22 This notation is i ) ro\]i I elllati ( : I ) e : it ll , ~(! iti8i lllch ! ~ ll ' whether ~ , wOC ?; III'I'I ~ IICtL~of Aillil , CI all S(!(IellOt(the . q ; ill ! t ! l ' lll . Ill this paper they alway , '; do . 
311 ow evcr , an arc in a chart does not 1 reclsely : or l'e , qlolld to a part lany in . stant lated au : ~ c derived fi'om a programenc , dlnglion relation by possibly creating a partially instantiated clause  . A subsumptiml operation is characterized by the origin  , the source , antithe target . The origin ( let it be 5) is a bound term . T i t ( . ' source ( a ) and the target ( r ) are arguments , a should already be subsumed by the origin , but rshmfld not be so . 
They should be connected through a transclausal link ~  . Let the literal containing a bep . Also let the literal containing r be 7 r , and the clause containing thmn be ( ILT here are two cases for subsumption , and in both cases a comes to be linked through ~ with an argument which is an instance of r subsmned by  5  . 
In the first case of subsumption operation , which we cdlun folding , a partial iustantiation , I ) ' of iI ~ is created . They are cquiwdent excep that the instance r'of rin  ( I ) ' is subsumed by & After the unfolding , a is linked through ~ totile iustance of r in ( D ' instead of the origin Mr , and accordingly p is linked to the instance of 7r in 4  ) ' . Let r " be ~- after the unfolding . 
Then rIUr "=%"#N"1""=~ , and rI = " r ~ a hohl . 
This implies r'Ca and r'VIo = ~ . Sot " at n do are not unifial ) le . 
For instance , the two suhsumption operations indicated by tim two arrows in Figure  1 are unfohlings . In either case , the origin and the source are both A . The target in the left is X and that in the right is U  . We obtain the program in Figure 2 by these operations , /Figure 2: After subsumi ) tions to X and U by A . 
where partial instantiation ( bl ) and ( el ) of ( b ) at nd ( c ) have been created , respectively . 
In Figure 1 , the subsumption opm ' atiml through the ( invisible ) link connecting C and Y is not executable now , because the unification represented by this link presupposes the unification of A and X through the dependency paths A  . X , A . U . X , A . U . U . X , and so on . 
That is , it is only when C subsumes an instance ( let it be Y ' ) of Y that subsumption from C to Y ' is Imssible . 
( This subsmnption is an unfohling without any e . opy , a context-fl'ee grammar in a standard w~ty . See Section 4 for further discussion . 
?$ because then C automatic Mly subsumes Y q ) Same for the . subsumptionill the opposite direction . 
Tile second ease of subsmnption operation is called folding  . It takes place when there is already a literati 7d equivalent oqrex cept that its argument r'col responding to r is subsumed by  5  . In this case , no new instance of clause is created , but instead link his switched so that it links a with ~" anti accordingly p is linked with ~'  . Let r " he T after the unfohling . Then rn~J = 0 both I ) efore and after the f i ) lding , and on r is subtracted from r and added to r~1 ) ytile folding . 
Fohling is triggered when there exists literal ~' as de-seribed a bow ~'  , and unfolding is executed otherwise . If the . reexisted several such ~ ds , folding takes place , creating as nlally iltstauees of ~ and eot llteet itlg to those  , ' KIS . 
The two subsumption operations indicated in Fig - are  2 are fohlings . Actually , in the . left , the p ( . , . ) in ( bl ) att ( ltluttin ( b ) are equivMent excep that the tirst argument of the former is subsunm d by A  . So tile link with the arrow arm the paralle . lace oml ) any iuglink are switched up to p(o , . ) in ( bl ) . Similarly for tile right subsuml ) tion . Shownill Figure . 3 is the result . 

(bU/"Pt,t,~)",,",,~//x"Pg ', ',) . \ , ,( A - ~/ ~ ~ A ~ f / f A2/'---'\"1
Figure 3: After R fl diugs.
Note that the original program encodes aim ) lf lem of partial parsing of a string beginning with " at " under the contextfree granunar consisting of the following rllles  . 
1 ~ ~ a
P ~ PP
There . suit in Figure 3 encodes the iutinitely many pos-stifle parses of this incompletes e  , lteuee . Note also that here the subsuml ) tiou from C to t it ( ' , instance , of Y in (1) 1) would bc possible if C were bound . '\] ~ he next section contains relevant examl ) lcs . 
When a link is subsumed by two terms bound by two hm on sistent bindings  ( such am ? = a and o = b )  , then that link is deleted , surrounding clauses possibly being deleted if some of their attomie for mubm are linked with no atomic for nmlaany more  . 
For the sake of simplicity , we mainly consider input-bound programs in this paper  . We say it program is in lmt-bound when every dependency path between boundterlnse Olluects a tertuilla top clause and olte in a non-top clause  . ' l ~ he program in Figure 1 and tile ones for parsing ; and geue . ration in the billowing section are all in lmt -lmund programs  . For input-bound terms in top clauses : in l ) ut-driven conqmtation . Also , in inlmt-driven computation for inpnt-bound l ) rogr ~ unswe do not have to worry about duplications of origins by subsmnl  ) timm . 
Both subsmnl ) tion and deletion preserve the declarative semamtics of tlm program  ( the set of the solutions )  , tl mugh we skip at detailed proof due to the sl /ace limitation  . 8 o when they arc , rot ; q ) plicablcrely more , every expansion is a solutim latndvice versa . For input-l ) ound programs , the inlmt-driven CO mlmt attional w ; tysterminates within time polynomiM as to the size of the program  . This is 1) e canse there are at nmstn ' , ~liar-tially instantiated clauses deriv ( : d front a claus c with m terms , where n is the size of the inlmt ( the trundler of bound terms in the top clause ( s ) ) , and accordingly there are polynomially many tr ; umclausal links . Obviously , partially instantiated clauses at nd new tran-sel , ' msallinks are each created in constantime . . It is also clear that each fohling ternfinates in polynomial time  . 
3 Parsing and Generation tlere we show that chart -likel  ) arsing and s ( muultic-\]le , % d-driven generation emerge fronlthe ; t ) ove ( : ( ) lll\[)ll-rational method . We discuss examph ! s of parsing ~ tndgenent tionl ) oth on the basis of the Mlowing gratnm~tr . 
(3) s(Sem , X , Z)-np(SbjSem , X , Y)-vp ( Sem , SbjSem , Y , Z) . 
(4) v p(Sem , SbjSem , X , Z)-v(Sem , SbjSem , ObjSem , X , Y-np(ObjSem , Y , Z) . 
(5) np(Sem,X,Y)-Sem--tom-X="Tom"(Y).
(6), p(Sem,X,Y)-Sere=mary-X="Mary"(Y).
(7) v(Sem , Agt . Pat,X,Y)-Sem=love(Agt,Pat)-X="loves"(Y) . 
Since we h&veah'e&(lynle . ntione daunl ) iguity lta ( : king ' in the previous section , below we do not explMtly deal with ambiguity but instead discuss jusl  ;   ( t i t ( : senten ( : estrneture in both parsing and gener ; ttion . 
Let us first consider parsing of sentence ' rl ? oln lov  ( : sMary ' . Thei ) roblmn is encoded I ) y the wogram in Figure 4 . Tit ( : inl ) ut-driv ( : nCOmlmtation l ) ro ( : eeds as shown by the arrows , which represent subsuml ) tio , top- ( : rations taking l ) la ( : ( : intlmordering it Mic~ttedI ) y t i t ( : labclling numbers . A thick del ) endency l ) at thisllro-cessed by successive subsmnptions with the sam  (  ; origin . Tile only subsuml ) tion operations exeeul : abh ~ intire initial situation is the one mmfl  ) ered1 and , ' tfter that the onen mnbered 2 , along the thick I ) at hl ) et ween A0 and X in (5) . As the result of these unfoldings , we obtain the following clauses . 
(8) s(Sem,~o,Z)- . p(SbjSem,~0 . Y)-vp(Sem,SbjSem,Y,Z ) . 
(9) np(Sem,~0,~ll)-Sem=tom-Aoo="To.,"(~).
Of course other partially instanti~Lted ( : l~t uses nmyb ( : created lmre from definition clauses nfs other than  ( 3 ) and those of np other tlum ( 5 )  , but we omit them here iul ( l(ZOtl (!( , ~lltril . te Oll just one solution , Now the copy of link with the arrow numbered 3 connected to ( 9 )   ( : t in mediate subsumption operations . 
So the subsuml ) tion oper ~ tion indicated tlu ~ tarrow is triggered , though that does not duplicate ( 9 ) because A1 a h'eady subsumes the target . The result is already refieete . d in (9) . The subsequent subsumption Oln : r-ationsmmt be red , 1 ,  5 , aud 6 will yield the . following cla Atses . 
(I(I)s(Sem,Ao0,Z)-np(SbjSem,A0,A,)-vp(Sem . SbjSem . Al , Z) . 
(11) v p(Sem , SbjSem , ~ , Z)-v(Sem , SbjSem , ObjSem , A 1 , Y ) - np(ObjSem , Y , Z) . 
(12) v(Sem , Agt , Pat , A1 , A2)-Sem=love(Agt , Pat)-AI=''loves"(A22) . 
Now the subsmnl ) tion operations by A2 ~ L , ' e commenced , due . to the creM ; ion of (12) . Accordingly , tit ( . " following dauses are m'eated , and the parsing is finisl w . d . 
(13) s(Sem , A0 , Aa)-np(SbjSem , A0 , A , )-vp(Sem , SbjSem , A 1 , A a ) . 
(14) v p(Sem , SbjSem , A1 , Aa)-v(Sem , SbjSem , ObjSem , Al , A2) - - np(ObjSem , A2 , Aa) . 
(15) np(Sem,~,Aa)-Sere=mary-A-~2="Mary"(AT).
From tit ( ; earlier discussion in the cam ' . of contextfree parsing tit (' , tt(ttl lber of ttl\[~uses created tl , ereis O(nm ) , where n is the number of the input words and M the lnaxilnt tlttltlll ltbw of the occurrences of nou-termimd symbols in a eontext-fi'ee rule  . This isl~trger than tit ( . " space complexity of the st ~ tn dal'dl ) ars-tug Mgorithms , but latter we will show how to improve i ; he ellicien (: y so as to be equiw dentotlt ( ; standltrd algorithnts . 
Nol ) ~wti ( mbtrorder ~ tntollg the subsmnptioa operations is ltrescril  ) ed in the M ) ove COml ) utation , ~ tnd so it is not inherently limited to toll -down or bottom-up  . Note also that tlt ( ' left-to-right l ) rocessiug or ( ler among the input words is derived fi'om the dellnitiou strong link  , rather than stilm lated a ~ s in Earley de due-\[i ( )ll , lt lll Ollg others . We can m : (: on nt\[or islat n(-dl'iV ( . ql parsing ; Lswell , by Mlowing links between bindings to trigger sul ) smnl ) tions more earlier . 
Let ( tsll ( . ' x t take . it look at sell telleegenel'atioli . 
Consider the program shown in 1, ' igure 5 . IIer e . the inlmt is semantic structure love ( tom , mary ) . Again the comltutation Mpro ( : ess is indicated by the numl ) ere . datrrows . ( i ) (; M~esl ) ht(:(', atfter 5, but the . order ~ tm()ng 6 ,  7 , and 6t is ~ u ' l ) it ratry ~ m long as 6 should be before 7 . So the only 1 ) ossible sultsmnption < ) Iteration in the b ( : ginning is the ones I ) yLove , wl fiehgo through the thick curv ( : connecting Love ; rod the X in (4) . This createst lt (: following cl~ume , ~ unong othm's . 
(16) v ( Love , Tom , Mary , X , Y)-Love = love(Tom , Mary ) - X = " loves "( Y) . 

Fig ~ ure 4: P ~ u ' sing
Love . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   . . . . . . . .
= tom . . . . . . . . . . .
n ~ Mary " i ~ e ~, ~ mary .   . . .  '' \ . ,-rl , J/L'\\=t Olll . ." /  . 
/ i %. ?.
..... vp ../ ji"'.., .....
Z .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -  .   . . . . . 


= mary . . . . .  " / \  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Y
Fi# ; ui'eS:Cener ~ d ; ion of the other two thick curves . So wear c creating the . 
following clauses , among others.
(17) ~( VO ~, X,Z ) -, p(Y--o-om ~, X,V)-vp(~Y ~ m,V.Z).
(18) v p(L-o ~ , \]-om , X , Z)-v(Love , Tom , Mary , X , Y ) - np(~ , ?  , Z ) . 
(19) np(To-m,X,Y)-Tom=tom-X="Tom"(Y).
(20). p(M---~,X,Y)-Mary:mary-X="Mary"(Y).
Not ( : tlmt this generation processiun ounts to a gem eralization of semantic-head-drivengeration  ( Shieber , van Noord , & Moore ,  1989) . The order among the retriewds of semantic heads is theor  ( h ; r of sul ) sumI)-tion operations by dilf i ; rentermsiutile input semantic structure , just as with the iiroccssing order i unt ) ng words ill the case of parsing . 4 Also its ill the case of i ) , ' trsing , the computational comillexity of such a generation is polynonfial with respect to the siz  ( : of the in Imt semantics tru (  . ture , provided that the I ) rogr ~ tnl is inlmt-bound and tile c ( unputation is input-driven . 
Although the above cxami ) lc deals with only a single sentence structure , ill general cases ambiguity packing mtturally take slllace just as with parsing of ambiguous sentences  . 
Under the restriction that the program be input -bound  , tile grammar caunot employ features tru ( : turcs l ) rew d cn till the current linguistic theories , and also nmst be semantically monotonic ( Shiebe , retal ,  1989 ) ~ The proposed nlcthod can be generalized so as to remove this restriction  , though the details do not litill the allowed space  . This gcner aliz ; t tion makes it possible to deal with fc , ' tturc structures and scnumtieally non-nm not onic grammars  . Of coursetile cOnll/utlttion is not anynmre generally guantntced to terminate  . ( because Horn programs can encode ' . t ~ uring machines ) , but our method still has at ) ettert cxmination prol ) cr ty than more simI ) listic ones such im Pro\[og interl ) retcror Earley deduction . For instanre , endless cxpansiou of leftrceursion or SUBCNF list  , which wouhlhal ) penill simple top- ( Iowaconr Ilutations , is avoid rxlowing to folding . 
4 Incremental Copy
The parsing process ( lise ussed above is conllmtatiou-ally more eompl cx than chart parsing  , ilerew cim-l ) rove our method by introducing a more clfi<:ient st : heine for ambiguity I  ) a ( : king and thus reduce the plu'sing complexity to that of chart l  ) ~trsing , which is O(n :) for space aud O(n3) for time . 
Tile present in el fi ( : icncy is due to excessive umlti-plieation of clauses : much more I  ) artially instantiate . d(: l~uses arc created than arcs illa chart . So let us snppos c that a subsumption Ol ) eratiml does not dul ) li- ( : a tea whole clause I ) ut only s ( )me part of it , so tlu~ta clause is coiffed in crcnlentally , as shown in Figure 6 . 
We , ' Lssum c that a subsumption to an argument of a a So the semantic-head-driven g\[~nt tiou parallels bett ~ n ' with left-to-rlg  , ht parsing than with syntactic-heard-driven l ) arslng ;  . 
5The sem~uttlc monotonicity is practically same as the iuput-boun  ( lness with regard to sem~mt lc structures . 
literal copies the term filling in tlutt argulnent  , the lit-I ; ra\[ , ll , llds on i coth P , r literals which lllelltioll that tel'Il l  , unless there have a h'eady been the terms and literals to be thus created  . Subscrii)ti of ~ tliter ; dindic ~ test hat it is created by the ith subsumption operation  . 
Wc must ensure that this partial copying be semantically equiw dento the copying of whole chumes  . 
That is a trivial business when the re~tre just one or two litcrals in the original clause  . The case where there arc more than throelit crals reduces to time  , ~se where there are exactly three literals , l > y grouping several iteralse < ) nne < : ted directly ( through terms ) and treltt then li~-'~if they were one literal . So below letus consider the cruse where there are three ' litcrals illa clause  . 
A non-trivild chet:k must be ( loll ( ! illStlch~L ( tas . ~ as ill the lower right of I " igurc 6 . Here you must copy-r ( . , . ) ~ a , . l-q ( . , . ) ~ t ) ut . ot-q ( . , . ), I , ~ ause-~( . . . ) ~ is compatible with-q(-, . ) l but not with-q ( .  ,  .  )  . W csl ty that a set of liter . ' ds ; trccoml ) a tible when there is an instance of the obtuse , which involves all instance , of each of those literals . Also , two literals arc said to b cheterogeneous when thc  , y haw ' different originals in the original uninstanti ~ tted clltuse  . ( The original of an origimd literal is itself . ) Ill general , when a subsumption Ol ) erldfion copies two heterogeneous , directly connected litcrals anticreates two directly connected literals  , then ct : r . ssary and sullicient c ( m ditionfl ) r this partiM copy to 1 ) esemantie : dly equivalent to the full-clause Col ) y is obviously that the fin ' nmr two literals be conlpatibh :  . 
When two of the original litcrals , ' tre not (: on nccte ( l directly with each other , two heterogeneous literals whic . h have ~ directly conne (' . tcd originals are compatible iff they arc also directly emmected  ; wr . need note on si ( ler two literals whose originals are not directly ( : onnccted , I ) ccaus ( ~ one sul ) sull q ) tionollerlttion ( lt ) (~s not copy such literals at a time . . When MI of the three original literals arc . connect t : directly with each other , two hetcro , e;e . neous literals are compatible if \[' they are ctmnected not only  ( lirectly but ~ d so through another literal heterogeneous to both  . Illflu:t,-r ( . ,  . ) ~ and - q(* ,  '  ) lare ( : mme ( : ted both throught crnl ~ and through P ( ? , o)2 , but-r (? , ?)2 an ( l-q (? ,   . ) are not con-m~(:ted through any inst , ; ume of the original p ( . ,?) . 
In the case , of contextfree parsing , O(n ' ~) litr . nd . ~a recrt ~ at e(1, where, . is tilemnnl ) er of words ill the , input string ,  1 ) rovided that the origins o1'sul ) suml ) tions are the posit . ions I ) ct ween tilt : inllut words only , (lue to the input-driven CO ml ) utation . Since then ; ~ u'c jusl ; i ~ constantimes more links than literals , the space ( : om-1 ) I exity of contextfreellarsing hencel ) econles O ( n ' 2 ) ill our method . The time conq/h . ' xity is O(n3) , I ) e clulse there are O ( n ) different ways of making each literal . 
Now the correspon ( len ( : c  with v hart plt rsing is more exact . Allart : ill the c . h;u't : or resl ) onds to an instantiated lit , or al . For instance , arc\[A---**H?C\]fi'om nolleito node j corrc~sl  ) onds to iustanti ~ tte . dliteral-b ( A // ,   , ~j ) , an ( l\[A-+?BC*\]fi'om n < ) (le ~ i to node j corresponds to a ( ~ , i , Aj . ), l,'t)r . ' tcont c . xt-free rule with more than two symbols illtile right hand side  , we can group several literals to oar , ~ uuin(!lltiolll2dabove&l ) drP . dt lce it to It rule with j , st two symbols ill the right h and si(h ~ . 
473 subsumption
Z ' <--_q ( , ~ . ._~ , ~) subsumption_q(~'~')0( ~ , \])2--P0' , ~)2~subsumption_q( , , ,  ) ~ . /~< . . . ~_~-_q(~)) Figure 6: Sul ) sumptions with I , mrem cnt MCopy 5 Concluding Remarks We have proposed a flexible iufi ~' renee method for I h  ) rn logic programs . The computation l > ; mc donitis its or t (> f program transformation , and chart l > arsing an < l semantic-head-driven g eration are epil  ) he nomena emergent thereof . The proposed method hasuothing Sl ) C-cific to parsing , generation , contextfree gramm~tr , or the like . This indicates that there is no need for any si ) ecial algorithms of parsing or generation , or perhaps any other a Sl ) CC t of natural language l ) rocessing . 
The i(lelt reported al ) ove ha . s already been partially implemented and applied to spoken language understanding  ( Nagao , tbusi(ht , & Miyat ; t ,  1993) , and an it CCOlllltOf how the roh:s of speaker ltll  ( lh catrer II Hly switch in the midst of it sentence  ( tlas ida , Nagao , & Miy , ' tta ,  1993) . Although this line of work It ; us into > porated a notion of dyn , ' unics ( Ilmsi(la , 1994b ) , ' us the declarative semantics to control coutext -sensitive computation  , we ; u : e planning to rel ) laeedynamics with probability . For inlmt-bound programs together with input -driven  ( : omputation , it is quite straightforward to deline probabilistie  , semantics auq ~ tnatm ' M extension of stochastic on text-free grammars  , aunong others , because all the body literals are prol ) a bilistieally independent in that case . We wmfld like to report soon on , 't gener M treatment of probabilistic Mly depend mlt liter Ms whih  . , preserving the cflieim~t struetm'c sharing , which will gm tranteet lieient computation and learning  . 
Referencet Imsida , K . , Nagao , K . , & Miyatat , T .  (19!)3) . 
Joint Utterance : Intrm sentential Sl ) eakcr/II earcrS witch as an Emergent I ) he nonm non . In Ba-jcsy , R . ( Ed . ) , PT veeedinfls of the lgth InteT ~ za-tional Joint Conference on Artificial h~telligence 

llausida , K . (1994a ) . Common Ihmristies for P~trsiug , Generation , ~ md Whateww . . . . In Strzalkowski , T . (\[, ~ d . ) , l ~ eversible Grammar in Natural Language lb ' oe essing  . Kluwer Ae ~ ulemie Publisher,

tlasida , K .  (19941)) . l ) y namies of Symbol Systems . 
New Generation Com Fitling , 12(3). to ~ tppear in
May 1994.
Kay , M .  (1980) . Algorithm Schenmt ; t and Datt ; ~ Structures in Syntactic Processing . Tceh . rep . , XE-I/ . OXP alo Alto II . escarch Center , PMoAll : (), California . 
N~tgao , K . , Ibusida , K . , & Miyata , T .  (1993) . Understanding SpokenNatm ' ML auguage with Omni -Direction al hfformation Flow  . In Proceedings of the 13th International Joint Conference on Ar-tiJicial Intelligence  . 
Pereirat , I , ' . C . N . , & Warren , D . H .  \]) .  (198:/) . Parsing as Deduction . In Proceedings of the 21st Awnual
Meeting of ACL , I ) 1).13714, 1.
Shieber , S . M .  (1988) . A Uniform Architecture . for Parsing and Generation . In Proceedings of the 12th International Conferenee . on Computational
Linguistics , pp . 614-619.
Shieber , S . M . , v;m Noord , G . , & Moore , R . C .  (1989) . 
A Semantic . -th:ad-Driven Generation Algorithm for Unilication -B ~ sed Forn  , Misms . In Proceedings of the 27th Annual Meeting of the Assoeia-tion for Computational Linguistics  , 1) i ) .  7 17 . 

