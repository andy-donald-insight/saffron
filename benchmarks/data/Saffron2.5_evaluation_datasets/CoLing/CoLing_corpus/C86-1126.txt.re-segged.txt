AGRAM MARUSED FOR PARSING AND GENERATION
Jean-Marie LANCEL ( ~) , Frango is ROUSSELOT (**) , Nathalie SIMONIN(~)
CAPSOGETIINNOVATION ,  \]29 , ruedel ' Universit 6 , 75007 - PARIS
w , University of STRASBOURG If ,  22 , rue Descartes , 67084-STRASBOURG
i . INTRODUCTION
This text presents the outline of a system us ing the same grammar for parsing and generating sentences in a given language  . 
This system has been devised for a " multili ngual document generation " project  . 
Martin KAY has shown that parsing and gener at ion could be done using Functional Grammars  . APPEL TlAPP85\] and McKEOWN\[McK82\] , among others , have used Functional Grammars for generation . Usually the grammar formalism is mores ui ted to parsing than to generation  . The way a grammar is processed for parsing is rather clear  , while the generating process needs strong assumptions on the interpreter to be easily readable  . 
The Functional Grammar notation described here allows a full symmetry between parsing and generating  . Such a grammar may be read easily from the po int of view of the parsing and from the point of view of the generation  . This allows to write only one grammar of a language  , which minimizes the linguistic costs in a multilingual scheme  . 
Description of the Functional Grammar not at ion  , in chapter 2 , will thoroughly refer to Functional Descr iptions and Functional Unification  . For a detailed presentation , the reader may refer to \[ KAY79\]  \ [  ROU84\]  \ [  SIM85\]   . 
2. THEGRAM MAR FOR MALISM
The formalism we have defined allows us to write a single grammar of a language which is used both for analysis and generation by means of two specialized interpreters  . 
Sentence analysis is viewed as the transit ion from a surface structure to a semantic representation which is a Functional Descrip tion  . Sentence generation is the transformation of a semantic representation into a syntactic form  . This symmetry between the two processes has to be clearly expressed if we want a clear not at ion  , easy to read and to understand from the point of view of parsing and of generating  . 
A grammar rule is itself represented as a Functional Description  . This FD has three main " identifiers ": PATTERN  , MEANING and


Example of a simple grammar rule : simple_gn = \[ pattern =  ( det substadj ) meaning=\[obj=<subst meaning>defini tude=<dettype>qualif=<adj meaning > number=<substnumber >\] constraints =  ( \[ equal = ( < det gender > < substgender > < adj gender > ) equal = ( < detnumber > < substnumber > < adj number > )  \ ]  ) det=\[cat=det\]subst=\[cat=subst\] adj=\[cat=adj\]\] The ~ part describes the syntactical structure  . Each item of the list associated to pattern refers to a rule or to a terminal  . In the above example the three terms refer to terminals  . Omissions and repetitions are allowed . 
The mean in q part describes the semantic representation associated to the syntactic a l structure  . Bracketed lists represent " paths " refering to Functional Descriptions inside the rule or in another rule  . During parsing , these paths are used to build the semantic representation while in generation they are used for splitting a semantic structure into different sub-structures  . The two processes , parsing and generation , are detailed in chapters 3 and 4 . 
The constraints part is a list of " set of constraints " expressed by Functional Descr iptions  . At \] east one " set of constraints " must be fulfilled  . In the above example this allows us to express agreement rules used for both parsing and generating  . 
As in Mart in Kay definitions a rule may have different derivations  . These are represented by enclosed braces . Example : simple_phrase = pattern = ( gnlv transgn 2 ) meaning =\[ action = < v transmeaning > sub jsem=<gnl meaning > objsem=<  gn2 meaning >\] constraints = ( \[ equal = ( < gnl number > , <v transnumber >\] ) pattern = ( gnlv in trans ) meaning =\[ action = < v in transmeaning > subjsem=<gni meaning>\]constraints =  ( \[ equal = ( < gnl number > , <vintrans number > ~) 3 . THE PARSING PROCESS 3 . 1 . Us___e of the ~ rammar for In order to anaiyze a sentence  , the words and compounds words are converted in Functional Descriptions  , using a morphological analyzer and a dict ionary  . The result is a list of FD's which will be processed by-the parser  . 
Example ( semantic va\]ues are expressed here by Engl ish terms but they are usually expressed as FD  ) : "\] eschaussures vertes " ( " the green shoes " ) 
Input list of parser is: ( \[ cat=det\[cat=subst\[cat=adjtype= defined gender=fem gender=fem number : p lural number : plural number = plurallex :\] e\]lex = ehaussure lex = vert meaning = shoe\] meaning : green \] This sentence matches wi th the rule simple_gn described in chapter  2  , as the first FD of the list is funchionnaly unifiab\]e with\[cat=det\]  , the second FD with\[cat=subst\]and the thirdFD with\[cat=adj\]  . 
The parsing process builds a structure which is a copy of the rule simple_gn and enlarges it with the actual  , word analyzed . 
The path descriptions are replaced by their actual values  . 
3 . 2 . Structure builts Jmple_gn=\[pattern = meaning = det = subst = adj =  ( det substadj ) \[ obj = shoede finitude = defined qualif = green number = plural\]\[cat=dettype = defined number = plurailex ~ le\]\[cat = substgender = femnumber = plurallex = chaussure meaning = shoe\]\[cat=adj gender = femnumber = plurallex = vert meaning = green \] This structure is built if the constraints are met : for this rule it impl ies agreement of gender and number  , which is the case for " leschaussures vertes "   . 
4 . THEGENERATING PROCESS 4 . 1o Use of the ~ rammar : for ~ enerat ion The generation-takes as input a semantics t ructure and produces a sentence  . 
As an example the rule simple_gn ( cf chapter 2) , is activated with the semantic structure \ [ obj = box definitude=undefined qualif = white number = plural \] A copy of the rule is built  . The paths in ? the Functional Description associated to the identifier " meaning " are used to convey the semantic information to " the items referred to by the identifie r " pattern "  ( These items are named " constituents " ) \] ~ n this example Jt gives : identifier path obj < substmeaning > definitude < det type>qualif < adj meaning > number < subst number > pointed value box undefined white p \] ura \] The interpretation process of the grammar " builds " the path  , which means that the needed identifiers are included in the copy of-the rule  . 
FD for DET becomes : det=\[cat = de htype = undefined \] ~ ere " type " has been added  . 
FD : for SUBST becomes : subst =\[ cat = subst meaning ~ box number = plural\]where " meaning " and " number " have been added  . 
FD for ADJ becomes : adj =\[ cat : adj meaning = white \] where " meaning " has been added  . 
Then the constraints are applied . In the parsing process they are used to el iminate wrong constructions  , while in the generating process they are used to transmit information  . 
Use of the constraints of the rules implegn equal =  ( < det gender > < substgender > < adj gender > ) information because identifier " gender " is not present in at least one Functional 
Description equal = ( < detnumber > < substnumber > < adj number > ) This rule transmits number of substantive ( number = plural )   , in the two other Functional descriptions of the output list After constraints are appl ied  , the output list is: ( \[ cat = dettype=undefined number=plural\ ]\[ cat = substmeaning = box number = plural \]\[ cat = adj meaning = white number = p lural \]  ) The next step is word selection : for each terminal  , the semantic structure associated with it is used to choose a lexical item  . 
This is done by using Functional
Unification . For each word or compound word selected , " constraints " are processed again , in order to transmit informations to Funct ional Descriptions of the list  . 
For a given structure there may be more than one adequate word  . In that case the appropriate word is chosen by the user interactively  . 
The list of terminals is enlarged by these lected lexical items  , as shown in the following example :
For the first item : ( \[ cat=det\[cat=subst\[cat=adj type = undefined meaning = box meaning = white number = plural number=plural\]number=plural\]l ex = un\]  ) 
For the second item : ( \[ cat=dettype=undefined number=plurallex=un gender=fem\]  ) \[ cat=subst\[cat=adj meaning=box meaning = white number = plural number = plurallex = boite gender=fem\]gender=fem\] 
For the third item : ( \[ cat=det\[cat=substtype=undefined mean ing = box number=plurallex=ungender=fem\]  ) \[ cat = adj meaning = white number = plural number = plurallex = boitegender=fem gender=fem\]lex = blanc\]completely defined  . The morphological generation processes each Functional Description using fields LEX  , GENDER , NUMBER , MODE , TENSE and PERSON . The appropriate form of the lexieal item is constructed using Functional Unificat ion  . 
For this example the list constructed by the morphological generation is:  ( " des " , " boites " , " blanches " ) which gives : " desboites blanches " This example is a simple case where items of a " pattern " do not refer to other rules  . 
Presence of a rule name in a pattern leads to a c tivation of this rule with a subset of the in itial meaning  ( transmitted by a path , as for a terminal ) . 
4.2. Generation models
The generation of the sentence associated to a semantic structure may lead to various syntactical constructs  . In order to reduce the number of constructs , and to allow control of text style , a specific feature has been introduced , named " generation model " . A generation model associates a semantic pat tern to a precise grammar rule  . 
Example:
Semantic structure associated to the advice " Do not expose to rain " in a user's manual : \[ advice advice-type=directive adv ice-giver=constructor content=\[link = negation argl =\[ action action-type = expose subjsem = user objsem=machine  obj2 = rain \]\]\] Among the " generation models " of the system  , the following is Functionnaly Unifiable to the above structure :\[ advice advice- type=directive gen-model=\[\[cat = prop-infinitive pattern =  ( gvinf * comp ) meaning=<content>\]\[cat=prop-must pat ter n =  ( gvdir * comp ) meaning = < content >\]\]\] Remark : the symbol * means that the rule may be repeated  . 
This generation model is selected by a restr icted version of Functional Unification : identifiers " advice " and " advice-type " must be present in the semantic structure  . 
In this example two grammar rules are candidate once the generation model is selected  . A simple implementation is to choose a rule at random  , another is to have an evaluation module which choose the most appropriate rule according to stylistic knowledge  ( technical style , telegraphic style , etc ) . 
5. DEVELOPMENTS
Previous version of the multilingual generat ion system uses a grammar for parsing  , and production rules for generation . 
Present work is the adaptation of the parser to the new formalism  , and the implementation of the generation interpreter  . It includes the adaptation of the multil in gual dictionary retrieval process  . 
6. REFERENCES

" Planning English Sentences . " Cambridge
University Press . 1985.
KAPLAN , R.M . and BRESNAN , J.
" Lexical-Functional Grammar : A Formal System for Grammatical Representation  . "In : Bresnan , J .   ( ed ) The Mental Representation of Grammatical Relations  . MIT Press .  1982 . 

" Functional Grammar . " Proceedings of Firth Annual Meeting of the Berkeley Iinguistics 
Society , 1979.

" Unification Grammars . " Xerox publication . 


" Genera Ling Natural Language TexL in Response to Questions about Database Structure  . " Ph . D . dissertation . University of Pennsylvania .  1982 . 
RIT CIIIE , G.
" Simulating n-ruring machine using funct ional unification grammar  . " ECAI 84 . 
Piss . 1984.

" R4a lisa LJ ond ' un program mee omprenant des textes ~ enu LJ lisan Lunformalisme un ique pour reprdsen Le ? routes les connaissances nd cessaiees  . " Thbsed ' Eta L . University of
Paris VI .\]986.
ROUSSEI_OT , Ir . and GROSCOT , H.
" Unlangsge d6c \]eratif uniformee Lunanalyseur syntaxico-s~mant:ique  . " COGN\[TIVA 85 . Paris .  \ ]985  . 
SIM fl NZN , N.
" Ukilisation d'uneEx pertise pout " engendrer destex tesstPuettJF~senfranga is  . " Th~se . 
Univet'sity of Paris VI . 1985.

