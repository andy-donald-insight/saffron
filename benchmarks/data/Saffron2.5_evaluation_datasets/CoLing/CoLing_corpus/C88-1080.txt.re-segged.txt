APROCE ss-AcTIVATION\]8~SF , DPARS ~ gl~kL , GOR ~' I-la ~

TIlEDEVELOPMENTOF\]NATURALLANGIIAGIgGk ~
Massimo MARINO
Department of lAnguisties -, University of \]~51 sa
Via S . Maria 36-56100 Plsa--ITALY
Electronic Mall : MASSIMOM@ICNUCEVM . BITNET

A running system , named SAIL , for the development of Natural Language Grammars is described  . Stress Isput on the particular gramma rule model adopted  , named Complex Grammar Units , and on the parsing algorithm that runs rules written In according to this model  . 
Moreover , the parser is like a processor and sees grammar rules as processes which cart be activated or In activated  , and eaxi handle exchange of information , structured as : messages , among rules for long distance analysis . A brief description of the frmnework of SAILa user can interact with  , neaned SiS , is also given . Finally , an example shows that different greanmar formalisms can be implemented into the frame of SAIL  . 
Xo INTRODUCTION
Most recent research in the field of grammar Ibrmalisms and parsers for natural language has seen the flourishing of various theoretical as well as coralm tational accounts  , which , however , bring into consideration the same lacts . The most relevant ones ~ , mem the following : -~ whatever representation is adopted for the structure of the parsed sentence  ( basically fstructures or trees )  , it is agreed that complex ) sets of features must describe the linguistic units  . It is , therefore , necessary to provide feature handling mechanisms ; long distance dependency , or , more gener Mly , dependency , requires a specific treatment , which Is to be naturally embedded in the theoretical or computational model of syntax  , and must be subject to language dependent constraints  . In aaly case , the treatment of dependencies takes the form of a differently constrained search Ibra referent  ; -a certal n amount of context-sensitiveness is to be allowed in natural anguage parsing  . 
As an additional feature of recent research , the l~mlinatlon towards the one-to-one correspondence between semantic and syntactic rules has to be mentioned  . 
SAILIs the parsing algorithm of a development environment  , called SAIL Interfacing System , where different grammars corresponding to different grammatical theories can be hnplemented  ( /Marlno1988/I . Its basic features , which allow full implementation fgrmn mars and their debugging are as l bllows : a  , tehlml guage for the handling of features ; gramma rules are seen as processes which can be activated or In activated  , and can exchange messages ; this mechanism allows a natural treatment of dependencies and the running of context-sensitive rules  ; the format of the rules Is such as to allow semantic processing in parallel with syntactic processing  ; the traditional structure of the parser , a bottomoup all-paths algorithm , allows relative efficiency mid the the development envirot Jrnent is based on dllterent layers of rules  , which are processed by the same parser and can handle the external interface  , the particular application , and the debugger . This enables the user to modify also the frontend of SAIL  , by modifying tile corresponding grammar . 
2. TItNG ~ ARRI\[1 LNFONISN
The grammar rules are expres , ~mdix- , at brmall sm called Complex Grammm Unitsg ' , ' . G . Uos ) having the tbllowing BNF :
CGD "::=< Syntactic-Rule >::::< ProducUo ~:: =< LHS >  ; ;= < I~-IS > ::= < Synerests > ::= < S~\]n-ActIo ~ > ::= < Syn-Recovery-Actiorr ~> ::= < Semantie ~Rule > ::= < Sere:rests > ::= < Sem-Recov  (  , , y Actions > :: A < Syntactic-Rule > < Semantic -Rule > < Prrnluetlon >  <8yn-  . Tests > < Syn-Actlons > <8yn-Recovery-Actions > < LHS > < RHS >
A non-tern maal symbol of the g~mrim ~'
A pat * erast ~ lng of terminal arid/or non . .termUral uymbols Borne teats on the appl icabi l i ty of ttte syntactic aetimm 
Arbitrary syntactic actions
Syntactic actions for the recovery
In case of r match-ihflor test-f- . dl < Sere-Tests > < Sere . Actions > < Semo Recovery-Actions >
Some te~t . ~ on the applicability of the semantic rule/U ' blhary semantic actiorLs " Semantica et lo Ilg for the recovery in case of  match4all or test-fall In . each grmimlar rule the syntactic intexpretation is directly connected with the corresponding semantic interpretation : hL this way the pea'ser processes in parallel both interpretations  . 
Inside the augmentations we can do several things :- the tests arc evaluated before the application of a rule and through * her a we can check its applicability  ; -every node of the parsing structure contains tructural infbrmation about the part of sentence it covers  ; this information is local to each node and is stored as a feature structure tree  . " l ~ e features are classically stored as attribute-value pairs  , with the possibili . ty that a value laitseff an attribute-value pair  ; several feature handling functions are defined inside the system  , so we cea~use them with the augmentations to create  , delete . 
test , get , copy and raise features ; the semantic rule acts on the semantic part of the system  , which can be , for example , at ~ handled by a knowledge representation language  ; tk flsside is dependent on the system application  ; -the semantic actions are a sequence of semantic operations  , includkng the possibility of assigning : , tsemmatic value to the new node built by the ~: ule  ; The semant ; evalue assigned to a node represents , In general , the meaning of tb . c " t ) mt of the sentence the node covers , accord h~gi ( ~ the chosen fonrmlism ; ? the eye , tactic and se_manti . erecovery aetimm allow tdte~rm tive actions ff the rule fails during themate hi~g phase or the test checking  , so the rules need not bem-udely rejected Mten they fail  ; -- soiriebLdlt . 4n system funct ions are available : these tools handle  , for example , the particular execution of a rule , o ,   ,  . nodly tile parsing processing , etc . ; these ~ ilecha : ~ iJ . sllks are discrtssed below . 
The production in each nile Is classically represented as a Cmfi  ; c ~_ rt-lq:ee product tm , : A-~w , w = _ . w , , where A1, . ; a no ~ ~4: ~: ~_ut Jn~dsyt ~ llool alid w ~ wa . . . w , , i s a si~:lng of terminal a tu l / o r : ta~m . te ~ miual symbols . 
The ~ ole , ' ~ of the grammmare applied by the parser hia bottoln-lti  ) ' w ~ ly : it , '; tint , ' ~ fiom the sentence and build , ~ over it the parsing shtlct nreas a graph . 
In our system weMso have adh ; ttonmy D . Each item in the dictionary is (::: filed a . ~ . ' ox ', t . < WedlsLing ~ fish betweeuah ~ gle?ox ~ tal~d ~ aut ? itAei'ox ~ as  . The first mate hest hege , mral concept of ~ , word ; the second defines an mltl-word expxession of the language  , typically an idiom . 
One or more interpretations are associated with each tb ~ at and they consist of the syntactic categmy  , these . mantievalue and a\[(~ature structure . 
A sentence is a conlpoLllld of fonus . For every set ~ temmf , fa . . . ~ SUChttrate very tbrmi ~ D , and a grammar G defined in our model we say that f ~ f  ,  . . . f , is palaable If we car ~ build as U'uc . tu , elhrough a finite sequence of rule applle atirms , where at least one no decovers the entire a entenee and its  ; category Is the root synibol of the gl~mnlna , ~ Rule appll cation , ~3 are performed by tt . epro ' set in a bottom-hi ) , '; tratep ~ whez ~ eve ~: : a . at leae ; i : one sequence of nodes exists in the sh-ucture the l  ) a >' scr has been building , matching the < RtIS > part of the rule ; b . if ' the above condition holdstile parser verifies the tests of the rule  ; if they ateveiified the nile is applied ; c . if the match fails , or the tests are not verified , then the parser eKe . cures recovex y actions ? ~ lt ~ e core application of tCGU consists in : d  . bnllding a new node cot . responding to the < I , I-IS > part of the ~ ule ; e . assigning l cature , ~ . ; to the new trade by execut ing the ~'~ y~ffacl :ic action '  . ; of the rule ; f . exeent ; h~g the semantic actions of rile nile , and possibl ~ , assigning the semantle value to the new nude . 
In the ibllowing we always rep~et ; ent the production In tile standard way as above  ; the feature structures associated wl ~: ha no0e of category w ~ are represented as \[\[~ , 1 and tilesemmt tlcvahmas\[Iw , \] i , We . ' carlSl ) , ~ cii ) tile complete process of a rule application by means of a PASCAL-lith estatement as follows  . 
Ne~4~eeover3ro . Aetlonst ~ dhq ~ J ~ ~ y ~ x-Itecove ty-Aet lo ~ ; ~ ~ e , ' ~- llee ovea-~-A cllom ~" llm rules are grouped in such a way that the parser accesses to a restr icted number of them  , i . e . only the currently applicable ones , when itt ~ test o apply S Olne . 
This is accomplished by partitioning the ru les into ~- meket ~ discriminated by the last : category in fire right-band side  . If a grammar is partitioned as t ' ~ . . . . . Pk then for every ld : , l . . . . . k , i : ~ l , we must have tlmi . I . , r~P~::: . So when the parser ace e . s . ~; esa packet through the category of a node , th crr des In that packet are the tufty ones al~l ) lleable at that momeut . 
Now let us introduce the coneepl of Not Operat ive / ~: of lttet  , ti Onu . 
In gene , ral such productions do not build a new node If one of the three special categories < NOP >  , < NOP-ASE > , < NOP- . SE > is the left-hand side . A Not Operative
Production is one of the following : < NOP > I < NOP--ASE > I < NOP-SE > -> v %%  . . . wRules ? with such productions are ealled NOt- Rules  . 
l ) epending on the NOP-eategoly used , tile rule applieal to n is performed i , ~ a special was . 
ANOP rule with < NOP > as let t- . hand side Is applied as follows Jf lhesy rltaette tests succeed :  1  ) no new node is l ) uJlt ;  2 ) only ihe syntactic rule is iakci ~ into accomlt by the parser  ; 3) the semantic rule is never considered . 
Therefore the application of such a rule iy . pciape ~ lbnned as in the following PASCAL-like statem c ~  . l:iJ_'i ~ tch(w ~ . . . . . wu , graph ) IbenLfNyn-Test , a(\[it ~ l .   .   .   .   . I ! ~, J ) gloat Sy~t ,, Recovery-Aetton ~' . ?! f ~ JtSy ~141 ecore ~- y . ,Ae , tIons ; This kind of NOP rule is useful when we are interestedir ~ performing modlfleatlons or particular consh-uctions or analyses on features Inside a eetia in contexi without bui lding a new node  . Such a kind of NOr ' rule is purely syntactic . 
in a producl ~ on with < NOP-ASE > as left-hand side  , ff both syutaetle and semantic tests succeed : 1  ) no new node is built ;  2 ) the rule application is preformed in thes t and m ' dway ? irmln diug feature hmadllng if it does notiovolve the non--existent parent node  . 
In a production with < NOP- . SE > as left-hand side , if o Myitic semantic tests succeed : 1 ) no new node is t ) uilt ' ,  2 ) only the semantic rule is taken Into account by the parser  ; 3) file syntaclle rule is never considered . From there on application is the dual of that defined for tim < NOP > category  . 
.!( lVlal;ch ( v , l . . . . . w . graph)/*~;c: . ~: ~' ~ q ~ one o ~ mo ~ c , ~ clt ; ~1"~mdcsmatching the < I:tIIS >*/ ~ ; em . -' r~ata(\[1% 11 . . . . . \[\[ wJl , SEM)/*:~;E Mie , presetllt ; hes ; elnain'l citlode\]*/~'~a~td(A , , . %  . . . . .  % , J ; /* build a ** evenode Aovm the matched nodes */ f ~ ls ~ q  . i ) egh L&R ' ( JLE~ASPROCESSES The rtfles defill ours ys iem ~ reviewed as proeesses to be executed by the prose t which has the roie of i ~ e processor ? Aaacon sequence  , a state is assigned to each rifle which is determined at the moment of grammar dell ni ion  . Rules can assume two different ~ tates : aettve or i ~ xae five state  . A rule is a ettw . ~ when the parser normally takes it into account for application  ; rules are acLiv c when their names are in the i rcol responding packets  . A rule is in a e , ttve when the parser does not normally take it into consideration for application  ; rules are in active when their names are not in any packet  . 
It is possible to modify the state of a rule by memmof two  39\] tunetions within the augmentations dining a rule application  . 
A rule R , changes its state from active to In active if some rule Rj calls within its augmentations the functionile-dtsable for R  , , performing a disabling operation ; on the termination of the disabling rule Rj , the disabled nile name R , is removed from the corresponding packet , and the parser does not take into account R , , Conversely , a rulel ~ ehaazges its state from In active to active If some rule calls the function rule -enable for Ph within its augmentations  , perl brming an enabling operation . On the termination of tlmenabling rule Rr the enabled rule name R  , becomes present into the corresponding packet . 
It Is possible to change the state of one or more rules at a time through these functions and the rules can perform self-enabling and self : disabling operations  . Changes of state effecte during the parsing are not penuanent  . At the end of each parse the rules are reconfigured as indicated in their original definition  . 
In addition we cruz invoke an inactive rule for just one application from anothe rule  . We say that an inactive rule R~is activated to be applied Just once  , when a call to the function rifle-activation is in some augmentation of anotherule Rr The activation of an inactive rule R  , allows just one application of it by the parser , immediately after the termination of the activating rule Rr The state of the activated rule Is not modified  . The activation of more than one rule at a time Is possible  , and once a rulels activated it can activate other rules  ,   4o CONTEXTUAL RULES Rule activation by means of the rule-actlvation function  , together with NOP rules can be used to handle context sensitive languages  , However , rials is entirely done by means of CF product ions and the augmentations  . 
A typical CS production is : ~ hAp ~--~ p , 1 ~ ~ h where p , , p ~ , 13 are stringsOf symbols , and A is a nonterminal symbol . A bottom-up applieation of such a production is possible l fit happens in two steps :  1  ) indlviduation of the context p~I~P ~ ; the right hand side must match a sequence of subtrees that covers  1~13   1~  ;   2 Inside this context we can perform the api ~lleaflon of the CF production A  . - ~\ [ ~ building the node A over the sequence of nodes characterized by ~ l  . So the complete application for a CS production is made in two steps : the tlrstone concerns context determination  , the context being represented by the righthand side of the CS production  ; the second step is just the application of a CF production if and only if the first step has determined the context where the CF production is applicable  . These considerations allow us to say that : step 1 can be performed by the application of a NOP rule using the NOP-special categories  ; in fact this kind of rule Is useful in detet ~ ining the context by defining a NOP rule with production : < NOP > I < NOP  . -SE>I < NOP-ASE > --> ~ t ,  ~  bt2 Step 2 can be performed by the application of an activated rule  ; in fact , wizen the rule at step 1 determines the context it cartactivate an in active rule with a production  A--~13  , indicating in the cMI to rule-activation the last node In the sequence ~  . 
Now we can give the definition of contextual nile.
We say that a rule is contextual if it is a NOP rule with production : < NOP > I < NOP-SE >\[ < NOP-ASE>-~wz  . . . w and inside the augmentations there is a rule activation of  , gJ~g_~t one in active rule which has a production :
A-->wkwk.~...w ~, 1<_k.<_m~n
AeVNu<NOI~>,<NOP-SE>,<NOP-/LSE>grammar.
This definition allows a nesting of contextual x nules : Inthct an activated rule can be a contextual rule itself  , In addition , we can activate more than one rule at a time ; in this way we can access several contexts Inside a main context  . 
We suggest a method to make possible a synchronous operations  , i . e . , how two independent rules can interact with each other in order to perform long distance operations  . All this is based on the fact that we must be sure that a certain rule will be applied after mlother and the earlie rule wants to communicate some information to the other one  , To this end we have adopted a communication meeharflsm  , that we call message pa ~ alug , which Is not based on nmtehing as all the previously explained opexations  , but on executing two basic tasks : sending and receiving  , The sending task is firstly performed by the sending rule that sends a message to a receiving rule  ; afterwards the receiving rule must perl brm the receiving task to receive the message  , These two tasks are executed by the two rules at two independent thnes  , i . e . , when the rules are applied , In the following we denote the sending rule as Rs and the receiving rule as Rr  , and we assume they are standard rules : so we denote with SN the node built by Rsmad with 
RN the node built by Pa?.
We state two different approaches for what a ~ is  :   1  ) the rules access a global feature structure where they store global features  . Each role can access this structure and whatever feature value In It  ;  2 ) a Message-Box exists where a rule can send a message to another specified rule  . 
" l~e Message-Box is accessible from every rule but the messages are accessible only by receiving rules  . A message is composed as follows : a reference to the teature structure of SN : Rs makes avafiable its feature structure to Rr  ; a sequence of operations , possibly empty , that Rr~-o . ustexecute . 
It Is not necessm3r that both these Items m'e present in a message , In the case of the global feature structure all the rules have access to It  . We recall that all the feature structures Included Ill the nodes of the graph are local to their own node  , Each rule earl store in or get from the global structure features that are global for the sentence : then the messages are feature structures and the same type of oIJerations allowed on the feature structures of the nodes of the graph Is possible on this sta ~ aeture o The Message-Box Isa structure referred to by all rules that want to send or receive messages  . A rule Rs , building the node 8N . sends a message which is automatically inserted In the Message-Box specifying : Its name Rs  , the receiving rule Rr , a reference to the feature structure of SN which is made available to Rr  , a list of operations , possibly empty , to be perlbrmed by Rr . Until the messages are sent , they are the exclusive property of Rs . Wizen they are sentRs loses Its property , rights , and only the rule R rspecified In the messages i authorized to get them  . In addition , Rrfinds In the message a reference to a feature structure ~ md this structure is available only to It and always local to its own node  . 
Message passing , In either of the two realizations , is a way to facilitate the tndl viduation and treatment of existing relations among phrases or parts of them  . It is certainly flexible and not expensive because It avoids searches  , i e . , matches , Inside the graph , and it can be a valid alternative to NOP rules that require a certain number of matches to find particular nodes In the graph  . 
In fact , if there was not overlapping of the sub--trees rooted In SN and RN  , then we can solve relations between SN and RN by applying a proper NOP rule  , but , more efficiently , message passing allows us to avoid a certain computational overhead peribnning proper operations directly in Iks and Rx  . 
When NOP rules are applied they act upon as t ructure already built  . It Is also possible to activate i ~ ales that pertbl-m further building  ( contextual rules ) and/or teaturing operations within a context . This process of activation can be nested many t imes inside a certain structure  , This analysis per/orms a kind of operation that is virtually directed toward the bottom  , in depth . If there was a partial or total overlapping between the sub-trees rooted In SN and RN  , then - In this case . -when iLs sends a message ; , assuraes that Rr will be applied above its node SN  ; in thk lway it Is possible to evaluate the consequences of certain operations on a struc ture which Is not yet but It could be butt  . In this case we act toward the top of the pars ing slxueture  , through as many levels as we want , In contrast , using NOP rules , we only act on an existing structure represent ing deeper levels  . 
So we can distinguish two ways of operation for long distance analysis araong phrases or parts of them : breadth  ; malysls , using both NOP rules or message passing ; depth analysis which can be topdown with NOP ru les or bottom-up with message passing  . 
The mechanism of the messages so described is performed through functions that can be used within the augmentations  . 
6 ? TI-~P ,, ~ RSER
Our parser is a CF-based one , derived from the ICA ( in mledia ~: e Constituent Analysis ) algorithm described in/Gxishman 1976/ , designed to run CGU rules , carrying out the syntactic and semantic an a lysisIn parallel  . It is a bottom-up algorithm , a ~ n dit performs left-to orlght scanning and reduction in an Immediate constituent analysis  . The data structure It works on is a graph where all possible parse trees are connected  . The complete parse h'ee ( s ) is ( are ) extracted from the graph in a subsequent step , Therefore , the parser Is also able to create structure fragment  , ~ for ill-formed sentences , thus returning , even in tills ca ; ~ e , partial analyses . This Is particularly useful for diagnosis and debugghlg  . 
Parsingte . rmination occurs In a natural way , when no more rule can be applied and the input string is completely scanned  , Before entering the parser a preprocessor scans the sentence fi'om left to ~ ght  , performs the dictionary lookup t breach form in the Input string  , and returns a structure , tile preprocessed sentence , with the syntactic and semantic Information taken from the dictionary  . 
The graph Is composed of nodes : the nodes can be either terminals or non-term ln~s  . Terminal nodes are built in co : a'espondence to a scanned form  , whereas non-terminal ones arc built whenever a rule is applied  , obviously the rule must not be a NOP rule . 
As stated above the parser is seen as a processor arid It sees the rules as processes  , It handles a queue of w ~ ting processes/rules to be executed  . When the parser takes a packet , for every rule it builds a process descriptor and In sexts it in the queue  . We call such a process descriptor an applica tion specification  ( AS )  , while the queue is c~dlcd the application specificationsHst  ( ASL )  , 
ASs are composed of : a node identifier , through this node the parser starts fl'ie ntatching  ; then mne of the rule that the parser will apply ; -only in the case of an AS of an activated rule this Item is the context where then mnedact ivated rule will be applied  , l . e . the nodes that matched the right-hand side of the activating rule  , otherwise this item is left empty . 
ASs in ASL are ordered depending upon the rule involved in an AS  . In general , ffstm~dard active rules have to be executed , ASL is handled with a LIFO policy . If we consider the case of NOP rules ? then these rules must be ordered before the others  , since feat m'e modifications they may produce can ser ~ eas input to other rules of the same packet  , which are applied after them . .4 . n In active rule can be activated Justibrone application by means of rule-activation t raction : the activated rules must be applied immediately alter the end of the activating rule  . So this kind of rules has the highest prior ity of execution with respect oNOP rules and s " tandard active rules  . Then x alle-activation inserts an activat ion ~ pect/tea ~ lo ~ on the top of/KSL for the activated rule  . Sunamarlzlng , the roles have the tbllowing decreasing prior ity order of execution :  1  ) activated rules ; 2) active NOP rules ; 3) standard active rules , Once a node is created , be it terminal ( in correspondence to ascarined tbrm ) or non~terminal ( in e on ' espondence to a reduction )  , the parser inserts In the ASL an AS for every rule in the packet corresponding to the categoxy of the new created node : i  . e . the new node Istile one specified In every inserted AS  , The parser performs all possible reductions building more than one node if possible  , extracting one AS at a time before analyzing the next one  . After mlASls extracted tom the ASL , the parser gets file specified rule : the first step is to match the right-hand side on the graph  . The nodes matching a right-hand side are searched by the matcher : It returns one or more sets of these nodes  , called reduction sets . For every reduction set , the application of the current rule is h-led . In this way we can connect together all possib le parses for a sentence in a uniquest ructure  . Termination occurs when the ASL is e ~ . np ty and the preprocessed string is completely scanned  . 
Afterwards the parser returns the graph , kom which ~1 parse trees satisi ~ ing the tbllowing condit ions are extracted : a node covers the entire sentence and Its category Is the root symbol of the grmn mar  . Here is the complete algorithm of the parser : * Until the end of tile sentence ts not reached :   , Scanatorm : * Ill , lid a newtern m mlxm de for the scanned tbxm ; ~ interpretation f the node : og . ~ the packet corresponding to Its categoiT and for every rule In the packet ~ tile ASIn the ASL  ; 
F_Qr ~ AS in the ASL :* gt ? the first AS from the top of the ASL  ; * g gi the specified rule kltile AS , it Is the current rule , and access to the node specified in the AS , it is time mxent node ; * starting from the cun~nt node perform tile match on the graph using tile production of the current rule  ; i_f at least one reduction set is found hlh . c_r_l : ? F r_~K . _C~YC , ~ t reduction set : - Apply the current rule ; o If a new nonterminal node is butt ~ gtk the corresponding packet to its category and for every rule in it ~ the AS in the ASL  ;   . ? g . ~: oApply recovery actions of the current rule ; In this algorithm by match we mean the operat ion of searching the reduction sets and by ' apply the current rule ' we mean the standard rule application starting from tile test checking as stated for the CGU model  ; particular ways of application , e , g , NOP rules , depend on the particular ule definition . 
7. ANEXAMPLE
The example concerns a simple fragment of a LFG written in SAIL according to the CGU model  , Our example is taken from/Kaplan 1982/and/Winograd   1983/  . 
The lexical entries for this grammar in SAIL are the following : a  ( Determiner NIL ( Definiteness )   ( In definite ) Number )   ( singular ) ) ) baby ( ( Noun NIL ( Number )   ( Singular )   ( Predicate ) Baby ) girl ( Noun NIL Number ( Singular ( Predicate ) Girl ) lhanded ( ( Verb NIL ( Tense )   ( Past )   ( Predicate )   ( H and ) ) ) the ( ( Determiner NIL ( Definiteness ) Definite ) ) ) toys ( ( Noun NIL ( Number )   ( Plural ( Predicate )   ( Toys ) ) ) Rules in SAIL are written using a def~ttle format where all the fields appearing in the CGUs can be defined  ; in addition two fields are devoted to the state definition  ( STATUS field ) and the rule type definition , that is ff the rule is a standard rule or a contextual or a NOP rule  ( CNTXTLORNOPR field )  . The rules are the following : ( defrule NP Rule ; NP --> Determiner Noun ( STATUS active )   ( CNTXTLORNOPRNIL )   ( PRODUCTION ( NP ( Determiner Noun ) ) )   ( SYN-TESTST )   ( SEM-TESTST )   ( SYN-ACTIONS ( ralsef " ( * Definitene SS Determiner )   ; raise the values of the specified features from the  ; sonnode into the parent node " (** Noun ) l ; second * means all features of the son node ; first * means the storing of the features as they are  ; in the sonnode into the parent node ( defrule VP Rule ; VP - -> Verb NP NP ( STATUS active )   ( CNTXTLORNOPRNIL )   ( PRODUCTION ( Via ( Verb NP NP ) ) )   ( SYN-TESTST )   ( SEM-TESTST )   ( SYN-ACTIONS raiser " ( ** Verb )   ; all features of the Verb node are ; copied in the parent node ( ( Object Definiteness ) Definiteness NP )   ; lstNP " ( ( Object Number ) Number NP )  " ( ( Object Predicate  Predicate NP )  " ( ( Object-2 Definiteness ) Definiteness NP 2 ; 2nd NP " ( ( Object-2 Number  Number NP 2 )  " ( ( Object-2 Predicate ) Predicate NP 2 ) ) )   ( defrule TOP Rule ; S - - > NP VP ( STATUS active ( CNTXTLORNOPRNIL )   ( PRODUCTION ( S ( NP VP ) ) )   ( SYN-TESTST )   ( SEM-TESTST )   ( SYN-ACTION Sralaef " ( Subject Definiteness ) Definiteness NP )  " ( Subject Number ) Number NP )  " ( Subject Predicate Predicate NP ) "** vP ) \[ SEM-ACTIONS put-sem-val ; stores the EVA Luation of the following ; expression as the semantic value of the ; parent node S39 g ( append ( getf-pn " Predicate ) getf-pn " Subject Predicatel ( get l-pn " ( Object Predicate ) )  ( getf-pn " ( Object-2 Predicate ) ) ) ) ) )  ; get f-pn gets feature values from the parent node The graph built by the parser applying these rules to the sentence ' a girl handed the baby the toys ' is equivalent to the e-structure buil t by the corresponding LFG as shown in / Wlnograd  1983/   . The top node S contains the following feature structure : "- Definiteness : In definite q- 
Subject : Nmnber Singular
Predicate Girl ._!
Object : \[ Definitene SS predicate NUmber ::: Baby Slngular Deftnite \]  Object-2 : F Number Definiteness : Plural Definite \]
LP ~ edicate Toys
Terme : Past
Predicate : H and with the semantic value : ( H and Girl Baby Toys )  , Comparing the solution of the LFG version with the feature structure and the semantic value of the SAIL version we have that the LFG solution is equivalent to the above feature structure plus the semantic value  . 
8. THESAILINTERFACING SYSTEM
The SAIL Interfacing System ( S . I . S . ) is the f ramework where a user can interact with SAIL in developing NL applications  . In fact SIS is organized in Interface Levels ( I . L . s ) : in SIS we commonly speak of Interface Level Applications  ( I . L . A . s ) which are the association of an IL with a grammar  . 
If IL-Name is the name of an IL , and G-Name is the name of a grammar which defines a particular language through a dict ionary and a set of CGU rules  , then the pair < IL-Name , G-Name > defines an 1LA inside the SIS : this application is a task performed by that particular IL  . 
In this way the development environment is based on different layers of rules  , which are processed by the same parser and can handle the external Interface  , the particular application , and any request issued by the user . In fact , the grammar of an ILA defines a language which can be used by the user for sending to the system his request so that are caught by the parsing system and immediately satisfied  . 
SIS is structured in 2 main ILs : the Kenael Interface Level ( K . I . L . ) and the Natural Language IL(N . L . I . L) . 
When the system runs only two ILAs are active and available to the user : the KIL  , associated to the Kernel Grammar ( K . G . ) and the Current Running Interface Level ( C . R . I . L . ) . The KIL is always aetive because it is the core ILA of SIS and Its purpose Is to handle the overall system  , so when the system Is started the user is introduced to the Kernel Interface Level  . The Kernel Grammar is a semantic grammar associated with the KIL and defines a kernel language of commands and through them the user can use all the functionality of the system such as grammar building  , parse checking , running other lI . As . 
When SAIL starts up , the KIL is also the CRIL , but when the user wants to load as CRIL another ILA defined In the system  , for example a NLIL application , then a KIL command allows this and NLIL becomes the CRIL by loading a grammar associated to the NLIL : in this way the CRIL is updated to the new application and the loaded grammal becomes the current rumllng grammar  . 
A subset of KIL commands defines a language through which the user cane ~ e the parsing structures generated by the parser for all the sentences input until that moment  . This tool , named ANAPAR ( ANAlysis of PARsing ) , is useful for the grammar and parse checking in deveh  ) ping NL applications , Finally , we want to point out that the particular structure given to ~ IS enables the user to modify the frontend to SAIL by nmdifying the corresponding grammar of the KIL  ; in fact , all the files involved in their definition are accessible to the user who can modify those files as he wishes  , or extend the language by introducing new gramma ~ rules  . 

The example has shown the possibility of implementing different grammar formalisms into the frame of SAIL and also the searching of standard procedures for building grammars in the CGU model starting feom Categorial Grammars is planned  , An experimental component has also been implemented  , which performs some diagnosis of ill-formed input  , and confirmed that the chosen parsing algorithm easily support such a component  . 
Afu U evaluation of some of the described mechanisms  ( such as message passing ) has not been carried yet , as application to real linguisticases has not been designed  , but theoretically . 
However , a whole view of the system , and the described example show that SAIL is a valuable tool for the development of concrete grammars  , even of large coverage . 
The whole system described in this paper is currently implemented in Common Lisp and runs on Sun and 
Orion wock stations.
" IT ils work has been carried out within the framework of the ESPRIT Project  P527 CFID ( Conmmnlcation Failure in Dialogue : Techniques for Detection and 


The author is thankful to Giaeomo Ferrari and Irl na Prodano for their helpful support  . The author is also grateful to Ronan Reilly who read the draft of the paper  . 
~FERENCES/Aho1972/Aho , A . E . and UIlman , J . D .  (1972) . The theory of parsing , translation and compiling . VolI : Parsing . Prentice-Hall

/Grishman 1976/Grishman , R .  (1976) . A survey of syntactic analysis procedures for natural language  . AJCL , Microfiches 47, pp .  2-96 . 
/Kaplan1982/Kaplan , R . and Bresnan , J .  (1982) . 
Lexical-Functional Grannnar : A Formal
System for Grammatical Representation . In
The Mental Representation of
Grammatical Relations , Bresnan , J , Ed.
Cambridge , MA : MIT Press , pp . 173-281.
/Marino 1987a/Marino , M . , Spiezio , A . , Ferrari , G . and Prodanof , I . SAIL : a natural language interface for the building of and interacting with knowledge bases  . In Proceedings of the 2nd International Conference on
Artificial Intelligence : Methodology,
Systems and Application 9 ( AIMSA '86) ?
Varna , Bulgaria , 1986, Jon ' and , P . told
Sgurev , V ., Eds . North-Holland , 1987, pp.

/Marlno1987b/Marino , M . , Splezlo , A . , Ferrari , G . and Prodanof , I . An efficient contextfree parser for augmented phrase-structure grammars  . 
In Proceedings of 1987 ACL Europe
Conference , Copenhagen , Denmark , 1987.
/Marino 1988/Marino , M .  1988) . The SAIL Interfacing System : a Framework for the
Development of Natural Language
Grannnars and Applications . Technical
Report DL-NLP-1988-1, Department of
Linguistics , University of Pisa , Italy.
/Robinson 1980/Robinson , J . , J , (1980) . Interpreting natural-language utterances in dialogues about tasks  . Teehn . Note 210, SRI
International , Menlo Park , CA , /Robinson 1982/Robinson , J . , J .  (1982) . DIAGRAIVI : A grammar for dialogues . CACM , 25, 1, pp .  2747 . 
/Winograd 1983/Winograd , T .  (1983) . Lauguage as a
Cognitive Process . Vol.l : Syx~tax.


