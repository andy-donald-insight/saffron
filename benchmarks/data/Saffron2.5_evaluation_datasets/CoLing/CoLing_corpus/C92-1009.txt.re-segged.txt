Feature Structure Based
Semantic Head Driven Generation
Gendchiro KIKUI
ATR Interpreting \] ~ elephony Research Laborator i es 
22 I Iikaridai , Seikacho , Sorakugun , Kyoto (; 1902JAPAN
kikui@atr-la.atr.co.jp
Abstract
This paper proposes a generation method for feature-structured  ) ased unification grammars . 
As comlx ~ red with fixed ~ rity term notation , feature structure notation is more tlexible for representing knowledge needed to generate idiom ~ttic structures as well as gene m ~ l constructions  . The method enables feature strncture retrieval vianmltiple indices  . The indexing mechanism , when used with a semantic head driven generation algorithm  , attains efficient generation even when a large amount of generation knowledge must be considered  . Our method can produce all possible structures in parNlet  , using structure sharing among ambiguous ubstructures  . 
1 Introduction
Practic M generation systems must ln we linguistic knowledge of both specilic expressions like idioms and gener Mgrammatical constructions  ,   ; rodttmy should efgtciently produces m ' face strings applying that knowledge  \[\[\]\[2\]  . 
In order to satisfy the first requirement , our system employs a set of trees annotated with f  e  , ~ture structures to represent generation knowledge  . l : ; ach tree represents at ? agment of a syntactic strncture  , and is paired with a semantic feature structure . We can describe idiomatice on structions , by making a tree which cont~t in s lexical specifications and is paired with a specilie rather than general semautic structure  . Because feature structures allow partial speeii icatiom we can encode generation knowledger  ; mgiug over multiple levels of generality in a . uniform way . 
l lowever , notice that this property will be restricted if we use DCG or  ( tixed arity ) term notation 1 Suppose there is a generation knowledge structure whose syntactic part is " go on foot "  . ' rimfeat , tu'e structure notation of its semantic part will be sonm thing like : ~ The flexibility of structure notation colnpated Lotetln notation is also discussed il ~  \[4\]  . 
\[\[ReinGO\]\[Agent?agent\[\]\]\[ Instrument FOOT\]\]  . 
while the term notation is: ( 1 ) instrument ( go ( Agent )   , foot )   ( 2 ) These two notations seem to be equivalent , but there is a cruciN diflerence . A generation knowledge structure containing the fe~tture-based se-lnantics will still be unifiable even if the semantic input to be unified contains additional material  . Thus the knowledge structure will be discovered and its syntactic information can he used for generation  . By contrast , a term-based input with addition a . 1 elements would not unify with the term-based semantic structure shown above  . It would thus be necessary to create ad-ditional generation structures containing distinct  ( though partly over lN ) ping ) term-based semantic structures . Such additional structures are redundant ~ tn ( lcause superfluous output . 
For example , consider the a , ugmented feature structure (3) . 
\[\[ Rein~o\]\[AgentKen\]\[Instrument FOOT\]\[Time  I0 : OOmn\]\] ( 3 ) it will indeed nnify with ( 1 ) above . But term-based input semantic structure ( 4 ) will not unify with term-based semantic structure  ( 2 )  . 
instrument(time(go(ken ), 10:00 am ), foot ) . 

Toun if v(2), semantic , structure (5) would a . l so be required . 
time(instzument(go(ken ), foot ), 10:00 ma) . 

AcrEsDECOLING-92 . NANTES . 2328 AOt ~ q "199232 PROC . OI ; COLING92 . NANTES . AUG .  23 28 . 1992 For this reason , our generation knowledge consists of trees represented as feature structures  . 
A tree can be substituted for a leaf node of as -other tree to form a larger structure  . Thus , tile tree can be regarded as a rule in a contextfree feature-structure-based unification grammar  . 
The second requirement for a generation system is efficient creation of syntactic structures  . 
This is the main topic of this paper . Our system is based upon Semantic lead Driven Generation  \[6\]  , which is an efficient algorithm for unilication based formalisms  . However , this algorithm requires some additional mechanisms to efficiently retrieve relevant generation knowledge  , because feature structures cannot be easily indexed  . 
The algorithm presented here uses an mltiple index network of feature structures to efficiently choose relevant generation knowledge from the knowledge base  . The algorithm " also uses an hypothetical nodes o as to efficiently maintain ambiguou structures during generation  . 
2 Phrase Description ( PD)
Generation knowledge is represented as a set of trees a unotated with feature structures  , l , ' , ach tree is called a Phrase Description ( PD ) . 
ALl example of al ) D is shown in Figure . 1.
Structure : ( SAUX(NPPRON)VP)
Annotation : ( S\[\[syn\[\[catS\]\[inv +\]\]1 \[sem\[\[relnREQUEST\]\[agon*SP*\]\[ recp*HR*\]\[obje?ACTION\]\]\]\]  )   ( AUX\[\[syn\[\[catAUX\]\[lex " would"\]\ [ v-morph PAST\]\]\]\]  )   ( NP\[\[syn\[\[catNP\]\[case NOM\]\]\]\] )   ( PRON\[\[syn\[\[catPRON\]\[caseNOM\]\[ lex " you "\]\]\]\]  )   ( VP\[\[syn\[\[catVP\]\[v-morphBSE\]\]\]\[ sem?ACTION \] J  ) 
Figure 1: an example of a PD
APD consists of two parts : a structure definition and feature structure annotation  ( Structure a . nd Annotation i Figure 1) . 
The structure definition define stile structure of a tree by using a list in which the first element corresl  ) onds to the mother node and tile rest of the elements correspond to daughters  . 
l' ; a ch daughter may t ) eatree rather than as in > pie node . 
Acres DECOLING-92 , NANT es ,   2328   AO6-r   1992   3   3 The annotation part specifies the feature structure of each symhol appearing in the structure definition  . A feature structure description can contain tags or variables  ( symbols with "?" as a prefix in the figure )  , The scope of a tag in a PD is the entire PD . 
Each node should have a semmltic and syntactic feature structure  . The semantic feature on the root node of a PD represent shesemaattics of the PD  ; thus we call it the semantic structure of the PD . 
Although the description represents a tree , it is the same ms for a ( partial ) derivation structure of a unification-l ) ased CFG , because tile current system does not allow adjoining operations  . If the structure definition of every PD is restricted to mother-daughter rlations only  , the PD set is strictly equivalent to a unification-based CFG  . 
3 Generation Algorithm
Our algorithm is a alefficient extension of Sema at -ticHead Driven Generation  . 3 ? he major extensions are : 1 ) it handles feature structures directly , and 2 ) it creates all possible phrase structures in parallel  . These extensions are embodied mainly in the t'l ) activation and ambiguity handling mechanisms discussed in this section  . 
3.1 Overview of the algorithm
The main part of the generation process is expansion process  , which iterates through expanding node selection , activation , prc combination , and application , using ane ~ Tmnding odeagenda . 
Input to the process is a feature structure con -raining syntactic  , semantic and pragmatic features as an initial constraint on the root node  . 
q'heCxl ) auding node agenda contain stim unlexicalized leaf nodes of the tree under creation  . 
At the beginning of the process , it conta . ins only one node , which has the feature structure give u as an initial constraint  . 
The expanding node selection step picks up one node  , say expanding node , from the agenda . 
If no node is picked ill ) , the expaa ~ sinn process stops . 
The PD activation step activates all PD's whose senlantic strl Letures s~tlJs~tmethe semantic structure of the expanding node  . 
The precombination step makes PD sequences from activated PD's to satisfy some constraints  . 
The application step instantiates the PD se-quence ( s ) and applies it totile expanding node . 
Paoc . oe COLING-92, NAm'ES , AU ~.2328, 1992
PD1 PD2 v3 v4v2
Figure 2: an example of dags
It also pushes unlexic Mized leaf nodes into the expanding node agenda  . 
i //#...':.-"'"> e4 a
PDIPD2 l0 path node ~ feature arc . . . . value arc pd node -~ tag arc 3 . 2 Expand ing Node Select ion The expanding node selection step is for fetching one node from the expanding node agenda  . From among the nodes whose semantic feature has been instamtiated  , one is chosen . In this step , if tile fetched node satisfie some termination conditions  ( if ~ for instance , it satisfiestile conditions for slash terminatim0  , the node is discarded ( i . e . , not expanded anymore ) . If the agenda is empty or contains no node with an instantiated semantic feature  , the expansion process tops . 
3.3 Activation
This step is responsible for selecting all PD's whose semantic structures subsume the semantic structure of an expanding node  . The selection is done by traversing a multiple index network of 
PD's called the PD net.
3.3.1 Compiling PD's
A set of PD's are pl'e-compiled into a PI ) net.
Suppose there are two PD's whose sema~ntic structures  2 are defined as the dags ( i . e . directed acyelic graphs ) in Figure 2 . in the figure , f a , f l ), fc , . ., and vl,v2, . , represent arc babels ( feature names ) and atomic values respectively . 
These PD's are coinpiled to the PD net shown in
Figure 3.
The uet has two kinds of nodes : path nodes@i ) , and PI ) nodes ( PDj ) . These nodes are linked by three kinds of labeled directed arcs :  2The semantic feature of a PD . is a semantic feature on the root node of the PD
Figure 3: an example of PD net feature arcs ( bold lines )  , vMue arcs ( dashed ) , and tag arcs ( with arrows ) . 
A path node is used to represent a particular feature path in one or more feature structure  . 
As shown in Figure 3 , path nodes are linked by bold feature arcs to form a tree  . The sequence of arc labels from the root path node to a path node Pl is the path of Pi  . \[It Figure 3 , p3 and p5 show paths ( PoN ) and ( refd ) respectively . 
Each PD node ( rectangle ) corresponds to a particular PD , which may have value ares and tag arcs . 
? Value Arcs : Which PD's contain which atomic vN ues along certain paths ? APD node may be linked to path nodes with value ares  . 
If a ( rectangular ) PD node is linked to a.
(round ) path node pn with a dashed value are labeled v , then following the path leading topn yields atomic value v in that PD  . 
Consider the dashed value are vl in Figure 3.
It indicates that following pathfain PDI yiehls an atomic value v l  . This is just tim situation depicted in Figure 2 . 
? Tag Arcs : In a given PD , which paths share a.
cel't ~ in feature structure as a vaJue ?
APD node may also be linked to path nodes with tagarcs  . 
If lowot a garcs have the same label and they cdnnect  ; ~PD node to two path nodes , say pnl and pn2 , then tim feature structure of that PI ) has a substrm ; ture which is the value of both paths , that of phi and pn2 . 
Am~s DECOLING-92 , N^N TES , 2328 ao ~ r199234 Proc . OFCOL/NG-92, NANTES , AU6 .  2328 , 1992 t , brexample , the two tag arcs from rectangular PDI node labeled " tl " in Figure  3 show that the semantic structure of PD1 has a substructure serving as the vMue of ( ~ ) and ( fc )  . 
3.3.2 Traversing the PDnet
The data structure of nodes and arcs are shown ill  . Figure 4 . 
+  .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .   .   .   . + IPDII label I + .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .   .   .   .  +
I values Iltag arcs II destination l + .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .   .   .   .  +
I features II value Numl ( c ) arc + .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   . + ( feature arc , Idags to rel\[status\]value arc ,  +  .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   . + ( a)P node ( b ) PD node path arc)
Figure 4: Node and Arc structures
A path node has three slots : values , features , o a t d d a g s t o r e . The values slot and the arcs slot contain value arcs and feature arcs respectively  . 
The dag stores to t is initially empty ; later it holds a pointer to a dag which passed the path node  . 
Each PD node has a PD slot , at a gares slot , a value Num slot , and a status slot . The PD slot contains a pointer to the represented PD itself  . 
The tag arcs slot contains the data structure of the tag arcs  ( see below )  . The value Num slot has the number of value arcs to the PD node  . For example , the value of the number slot of PD1 node in Figure3 is 3  , because the node has one value a . r c labeled v l and two value arcs labeled v l . The status slot holds integer and is initially set to  0  . 
Every type of arc has two slots , ' label ' and ' destination ' . Label ' is an atomic symbol which labels the arc , and ' destination ' is a pointer to the node which is the destination of the arc  . 
We use the PDnet as a datal townet . The entry point of the net is the root path node amd the token which flows is a dag of a semantic feature structure  . 
The action of a path node is shown in Figure 5 . " faihn'e " means there is no PD whose semantic structure subsumes the given dag  . Thus the entire retrieval process fails . 
The action of a 1) D node is shown in Figure 6 . The status is incremented each time the node receives a tokeu  . As a result , if all atomic values in t l , e semantic structure of the PI ) are satisfied , the status becomes equM to the value Num ( that is then uln ber of atomic values )  . Once this is detected , the nuuifiability of shared structure is checked by cMling the tag tcst procedure  . 
Tagtes tests unifiability of the dags in the dag -stores of p  ( ath ) nodes connected by tag arcs with the same label . Iu Figure 3 , if the status of PD1 becomes 3 and if the dag in p2 and the dag in 114 are identical , then the PD becomes active . That is , the PD has been found to subsume the generation input  . It may or may not actually be applied , depending on later events . 
PROCEDUREPD node Action(pdNode , value)pdNode . stat , us ~ pdNod c . status+1;
IF pdNode . status = pdNode . value Num and tag test ( pdNode . tagarcs ) = TTHEN activate(pdNode . PD );
Figure 6: Procedure of a PD node
If there is a PI ) node whose wdue Nums is 0(i . e . Noa , to mic value is specified iu the semantic structure  )  , node action of the PD node is invoked after ? la . taflow is terminated . 
PROCEDUREPathNodeAction(pathnode,dag ) path node . dagstore , -- tile pointer of dag ;
IF dag is atomic value type THEN valid Value Arcs+- -arc\[arcEpath node  . values , arc . label = ( lag . value ;
IF valid Value Ares : ~? THEN
FOREACH arc IN valid Value Arcs DO
PD node Action ( are . pdnode , dag);
ELSE failure;
ELSEIF dag is complex value type THEN
FOREACH arc IN dag.va : ue DO
IF Searcharc ( arc . label , path node . feature Arcs ) : ~ NilTHEN Path Node Action ( Searcharc ( arc . label , pathuo(le . feature Aras ), rc . destin ; ttion );
ELSE failure
Figure 5: Procedure of a path node
Acres DECOLING-92 , NAI'/TES , 2328 Aour 199235 PROC . OFCOLING-92, NANTES , AUG .  2328, 1992 3 . 4 P recombinat ion The precombiuation step is responsible for making sequences of PD's from activated PD's under certain constraints  . APD sequence is a rough plan for a potential structure which can realize a semantic specification of the node being expanded a  . If no sequence is obtained , the ambiguity resolution process , discussed later , is invoked . 
We divide PD's into two groups : propagation type and non-propagation type  . A propagation type PD has has one propagation ode  . A propagation node of a PD is a leaf node whose semantic structure is identical with the semantic structure of the root node of the PD  4  . The rest of the PD's , which have no propagation odes , are classified as non-propagation type PD's . This distinction is an extension of Shieber's chain rule and non-chain rule distinction  . 
APD sequence PD 1 . . . . . PD , ~ must satisfy the following constraints . 
1 . semantic structure sharing constraints ( a ) PDi ( 1 <_i < n ) is a propagation PD , ( b ) PD ~ is a non-propagation PD , Under these constraints , the system can make a partial phrase structure by unifying the propagation ode of PDI with the root uode of PDi + l  . Tile root node of the created structure contains the unified semantic structure of all semantic structures of PD's in the sequence  . 
2 . local unifiability constraints ( a ) the root node of PDI is unifiable with tile expanding node  ( b ) t > Di and t ) Di + l are connectable where PDI is connectable to PD  5 if PDI is a propagation P\] )  , and t impropagation ode of PD i is unitiable with the root node of 

These constraints are necessary conditions for unifiability throughout the entire PD sequence  , which is called the global nnifiability of a PD sequence  . In contras to such global uni/iability constraints  , the local vnifiability can be precomputed , or compiled , before generation process . 
a APD sequence is roughly corresponds to a bottom -upchumin  \[6 ~ Our current system does not allow PD's with multiple semantic head  4  . 
covering constraint
Let fs l be the unified semantic structure of all semantic structures of PD's in tile sequence  . Fsl must contain every top feature of the semantic structure of the expanding node  , where a top feature of a feature structure is defined as a toplevel feature name  . 
The covering constraint ensures complete generation  \[6\]  . If the constraint is nots aris-fled , a given semantic structure may not be completely realized in the generation result  . 
For example , if all input semantic strucure is ( 3 )   ( in Section 1 ) and the unified semantic structure of a PD sequence is  ( 1 )  , then the resulting PD sequence lacks the locative phrase for the " time " feature  , which will not appear in the generation result . 
disjointness constraints
For each PD(PD i ) , there is no other PD(PDj(i#j )) , such that PDI has a topar c whose label is included in the set of to parcs of PDj  . The definition of top arc is given above . 
If this constraint is not satisfied , the generation result may contain duplicated or invalid expressions  . For example , if a PD sequence contains two distinct PD's each of which is for a locative adjunct and hasa " time " feature on the top level  , the generation result will have two locative adjuncts for one semantic feature  ( i . e . tile " time " feature) . 
The disjointness constraint also ensures compaet generation  . Suppose a coherent and complete generator produces a string w  , and the grammar assigns a semantic structure fso to w using a set of rules R  . String w is minimal if every substructure offs o is supplied from one rule in R  . The generator is compact if any string w is minimal  . 
Ill general , completeness , & lid conlpactness cannot actually be judged until the entire generation fiulshes  . Thus the last two constraints ( 3 and 4 ) do not reaiiy guarantee completeness and compactness  ; rather , they help to limit search space in a practical way  . 
3.5 PD Application
The PD application step is responsible for creating phrase structure  ( s ) fl ' om PD sequence ( s ) and attaching them to the expanding node . In this section , we restrict ourselves to the simple case ACRES DE  COLING-92  , NAN ' YES , 2328 AOt ~ T199236 PROC . OFCOLING-92, NANTES , AUG .  2328 ,   1992 such that there is only one PD sequence obtained during the previous step  . The case of multiple PI ) sequences , ( i . e . , generation ambiguity ) , will be discussed in the next section . 
First , the module connects all PD's in the PD sequence PDI  . . . PD , , by unifying the propagation node of PDi with the root node of  PDI+1  . All unification operations are quasi-destructive , or temporal\[7\] . The result of the unification is valid until the module copies it  ( see below )  . 
If this entire unification processucceeds ( i . e . , if every PI ) in the sequence can indeed be unified , and the sequence thus proves to be globally unifiable  ; see 3 . 7) , then the module makes a copy of the unified PD sequence  . Otherw is expansion failure ( see next section ) is signified . The copy , which is a phrase structure tree , is called an instance of the PD sequence . 
Then the module attaches ( unifies ) the instan-tiatted PD sequence to the expanding node  . 
Finally , the system stores in the exl ) and iug node agenda leaf nodes of expanded structures which have no lexieal feature values  . .
3 . 6 Ambiguity Handling 3 . 6  . 1 Ambigu i ty pack ing If multiple PD sequences are applicable to an expanding node  , the substructure of the expanding node cannot be uniquely determined  , because each PD sequence indicates only an hypothesis for ' the potential substructure  . 
The system maintain these hyl ) otheses in a special hypotheses slot on the undetermined expanding node  . 
For each PD sequence , a copy of the expanding node ( : ailed an hypothesis node is created . These copies are stored into the hypotheses slot of the original expanding node  . Then the system applies each PD sequence to the corresponding hypothesis node  , as described in the previous section , and continues expansion . 
In Figure 7, three suh trees in the " hypo"s lol.
on the undetermined node have been created for ' the hypothetical Pl  ) sequences . 
The hyl ) othetical PI ) sequences are not unblied with the original expanding node  , but unbtied with copies of the expanding node . This prevents tire original feature structure of the undetermined node from being modilied by further expansion of the hypothetical structures  ( TIT3 in Figure 7 )  . 
q'he further expansion sometimes makes an hypothesis node inconsistent with the original vl  , \[ inqt0 ~" p0------------_~0p : hypothesis T ~ , ,~'" -'"  . , . -" -  .   . jnodes ~ VP1 ~" ~ VP2 VP3 P'
Figure 7: generation ambiguity node . This is detected in the ambiguity reso-hltion process described in the next section  . 
3.6.2 Expansion Failure and Ambiguity
ILe solution
Expansion failure occurs when : 1 . \] to PD is activated in the PD activation , or 2 . no PD sequences are obtained in the pre combination  , or 3 . no PI ) sequences satisfy global connectabil-ity in the application  . 
The failure signifies that the features trncture of the current exl  ) and ing node is inconsistent with a set of Pl ) 's given as generation knowledge . 
The module searchest br then e ; ~ rest(i . e . , lowest ) hypothesis node ( Nh ) dominating the failed expanding node and deletes Nhfi ' om the hypothese slot containing it  . 
If the number of hyl ) othetical structures in the hyl > otheses slot of a . nun determined re > de(N , ,) hecomes one , then N , ~ and the root node . of the remaining structnre in the hypothese slot are unified  . If the unilication f~tils , amlriguity resoh > tion continues recursively upw ~rd  . 
An examt ) leof ambiguity resolution is illustrated in Figure  8  . The values of tire hyt ) othe-ses slot of node VI ' are the hypothetical nodes VP l  , VP 2 , and vt'3 , corresponding to hypothetical trees TI , T2 , ' I'3 respectively . If expansion failure occur in TI and '1'2 , VP 1 ; ~ ndVI'2 are removed from the hypothesis slot . Then , Vl'3 is unitied with VP , because there is only one hypothesis node left in the slot VP node  . 
If there is no hypothesis node dominating the failed expansion ode  , the entire generation l ) r ~) - cess fails . 
AcrEsDECOLING-92, NAI~'a T . .S , 2328 AOI\]'r 1992 3 7 I'ROC . OFCOLING-92, NANTF . S , AUr3 .  2328, 1992
Nhunify .......
VP1 VP2 VP3 perform adjunct operation \[9\].
The algorithm is implemented in SL-Trans , a spoken language translation system\[8\] . 

The author would like to thank M0zk Seligma~t for helpful comments on this paper and also would like to thank Akira Kurematsu  , Tsuyoshi Morimoto and other members of ATR for their constant help and fruitful discussions  . 
Figure 8: an illustration of generation ambiguity resolution  3  . 7 Pos tprocess Expansion halts when no node is selected in the expanding node selection step  . This does not necessarily mean the agenda is empty  , because the rem~y be some nodes without instantiated smnantic structure  . 
l to w do such semantically empty nodes arise ? The problem is that feature structnres within hy -pothetic M nodes are not allowed to unify with the feature structure on the " real " dominating node  . 
The solution is : for each hypothetical node , we create a complete tree using copies of the " real " dominating structure  , Feature structures can then be permitted to unify with dominating structures  . Then , the system collects all unlexicalized leafre ) des as initial values of the expanding node agenda nd starts the normal expansion loop again  . 
4 Concluding Remarks
A semantic headdriven generation method based on feature structures is proposed in this paper  . This method efliciently generates all possible phrase structures fl'om a given semantic feature structure  . The method involves multiple indexing of feature structures and a precombi-nationnle chanisn\]  . The selnechanisnls constrain applicable gralnmatical knowledge beR  ) reinstantiation ; thus the method eliminates the copying of fegture structures  , which consunles conlputillg resources . 
The proposed grammar notation is appropriate for describing idiomatic phrase structures easily  . To make the best use of the notation , we are extending the Mgorithm so that it can AcrEs De  COLING-92  , NA mes , 2328 AO13"r199238
References\[11 Hovy , E . H . , " Generating Natur M Language
Under Pragmatic Con-stralnts ", Ph . D . Dissertation , Yale Univ . , 1987\[2\] Jacobs , P . S . , " A generator for natural language interfaces " , In D . l) . McDonald et al , editors , Natur M Language Generation Systems , 
Chapter 7, Springer-Verlag , 1988\[3\] Shieber , S . M , " An introduction to Unification-Based Approaches to Graznmar '  , 
CSLI , 1986\[4\]Knight , K . , " Unification : A Multidisci-plinaxy Survey " , ACM Computing Surveys , 
VoL21, No . i , 1989\[5\] Pollard , C . et ah , " Information-ba . sed Syntax and Semantics Volume 1Fundamentals ",
CSLI , 1987\[6\]Shieber , S . M . et al , " A Semantic-Head-Driven Generation Algorithm " , In Proceedings of 27th ACL , t989\[7\]Tomabechi , H . , " Quasi-Destructive (\] raph Unification " , In Proceedings of 29th ACL ,  1991 . 
\[8\] Morimoto , "17 . , et a . l . "A Spoken Language Translation System : SL-TRANS2"  . In Proceedings of COLING '92, 1!) 92 . 
\[9\] Vijay-Shanker , K . et al , " Feature Structure Based Tree Adjoining Grammars  "  , in Proceedings of COLING'88 , 1988 PROC . OFCOLING-92, NANTES , AUG .  2328, 1992
