Construction of a modular and portable translation system 
Fujio NISIIIDA , Yone haru FUJITA and Shi . nobu'FAKAMATS\[I
Department of Electrical Engineering,
Faculty of Engineering,
University of Osaka Prefecture,
Saka \], Osaka , Japan 59\]
i . Introduction
In recent years the study of nlach Jne
trans\] . ation has made great advances and the transla tion system has been larger and complicated wJ thaugmenting faei \]\] ties  . Furthermore , most recently , many power fu\[workstations have been developed and wtrious MT systems for special purposes are ready to be mounted on these workstations  . 
\] in snch a state of affairs Jt will be needed that many MT systems are reorganized or reconstructed on a program module basis for easy modification llla Jntainance and transplantation  . 
'\]' h : is paper has two purposes . One of th ~ i ~ l : s to show a method of constructing an MT system  ~'3" on a library module basis by the aids ~ a progralnming construction system called L-MAPS  .  ~ ) The M\]' system can be written in any progranm ~ Jng language designated by a user if an appropriate database and the appropriate processing functions are imp\]  . emented in advance . For example , it call be written in a coml ) i \] . er language like C \] aeguage , which Js preferable for a workstation with a relatives low running machine speed  .  4)
The other purpose is to give a brief : introduction of a program generating system called Library-Modul  . eAided Program Synthesiz Jng system ( abbreviated to \[ , -MAPS ) running on a library module basis . L-MAPS permits us to write program specifications in a restricted natural \] anguage like Japanese and converts them to formal specifications  . It refines the formal specifications using the library modules and geeerates a readable comment of tile refiined specification written in tlre above natural language every refinement in option  . 
Tim conversion between formal expressions and natural language expressions is performed ef ficient \] y on a case grammar basis  . 
? 2 ) :~) 2 . Overview of the MT system organizat \] . on Our machine translation system is constructed on the intermediate expressions based on universal subframes of predicates and predicative nouns  . It aims at a multiliugual transfer system . \[\] p to now , however ~ no universal precise semant Jc category system over various languages has been constructed yet  , and our MT system is compelled to work rather on a bilingual basis in the selection of equiva lent  . s , The first versio ~ of the par~q ~ was writ ten in an extended version " of LINGOL-'~'  . It has an advice part and a semantic part in each rewriting rule  . Both parts of them pernlit users to describe any Lisp program for designating details of the reduction procedures  . These techniques used JnLINGOL and ATN seem apparently convenient  . However , they often make the data part inseparable from the program part and bring an MT system to much complexity  , and accordingly , prevents applicability of tire programs o f the MT system Lo another translation between other languages  . 
Recently , a revised version of our MT system has been constructed  , rf he main program or procedural part cons : is ts of unif : i cat \] on a rKl substJtut:ion  , while the data part consists of frame knowledge rewriting ruins and word dictionaries  . 
Rewriting ru\]es with arguments describe the details of the syntactic and semantic structure of the language explicitly  . For example , the predicate part : of the Horn by's verb l latter n  VP\]3A of Eagl : is his written as follows : PREDP ( PRED-co:to , MOI ): m , kl-C\]:t\] , k2-c2:t2)--> VP(PRED-co:to , MOD : m ) NP(k\]-Cl:t\])
PP(k2-c2:TO-t2) where PREDP , VP , NP and PP denote a PR\]'\]DJ cage Phrase , a Verb Phrase , a Noun Phrase and a Prepositional Phrase respecively  , k-c : t denotes a triple of a case label , a semantic category and a term and in denotes var : ious modal values such as tense an  ( \] aspect . These rewriting rules are tabnlated in several tab\]es :\[ or an effJ  ( lent process Jug . 
The parsing system first applies the syntactic par to fare writing rule to that of a handle in a reduction sequence of a given source sentence  , fftile system finds a unJf:iable rewriting rule , : it checks whether the semantic part is unifiable  . \]' he category check of a term in a handle for the case frame condition is processed by a special kind of unification under an interpretation that the term category in a rule : is a restricted variable  . 
The intermediate expression of tile handle part is constructed by substituting the unified terms for the arguments in the lefthand side of the rewriting rule  . 
3. The L-MAPS system aud language conversion
The L-MAPS system is costructed on a fundamental \]  . ibrary module basis . When a user gives a specification by referrkng to the libraly module  , L-MAPS searches appl J ( . : able library modules and refines the spa ( if J cation by linking several modules or replacing : it by the detailed procedure called the Operation Part of an applicable library module  . 
The formal specifications of programs as well as tile library modules are generally difficult for users to read and write correctly though they are efficient and rigorous for inachine operation  . Hence , it is desirab\] . e to rewrite the formal specification Jnanatural l  . anguage . I . -MAPS performs a conversion between a restricted natural language expression and a for nlal language expression through the intermediate  ( or the internal ) expression of the natural language expression with the aids of case \]  . abels . 
The conversion between a restricted natural language expression and the intermediate expression can be done Jn a similar manner to the conversion carried out in machine translation  . 
Formal specifications genera J . ly have different forms from those of the intermediate expressions  . 

The intermediate expression of a sentence takes the following form:  ( PRED : tp , Kl : tl . . . . . . . Kn : tn )   ( I ) where PREDK1 and Knare case labe\] . s and tptl and tn are terms corresponding to their cases ? On the other hand  , a procedure expression appearing in formal specifications as well as in a heading of each library module hastile following form : proc- label  ( Kl ': tl ' , K2':t2' ,   .   .   .   .   . Kri':tn ' )   ( 2 ) where the procedure name plays a role of the key word and it is constructed from the predicate term the object term and others of the intermediate expression ? It is used for retrieving library modules applicable to a given specification  . 
\] . -MAPS performs the conversion between the in termediate expression  ( I ) and the procedural expression ( 2 ) by a method similar to the case structure conversion between different languages  . 
The conversion : ks applied not on Jy to the const ruction of a formal specJ fJeation from an informal specific at Jonwritten Jn restricted Japanese or English but also to the generation of Japanese or English comments on the refJned specifications generated by L-MAPS itself  . 
4. Modularization of programs
The revised MT system is reconstructed based on library modules by the aids of L-MAPS  . Each library module has a structure as shown in Tablei  . 
Table 1Apart of library modules
PROC:HANDLE_REDUCE(SO : reduced_sequence , OBJ : handle , 
INSTR : reduction rule,

IN:GIVEN(OBJ : reduced_sequence , handle , reduction_rule ) OUT : REDUCED_FORM ( OBJ:new_reduced_sequence ) ENTITY TYPE : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OP:RULE_APPLY(OBJ : reduction_rule , PARTIC : handle , 



FOR(COUNT:n , FROM:l , TO :-( stack_pointer , symbol_number of handle ) , 





The heading of each module has both the procedural expression and the input-output predicate expression  ( abbreviated to the IO expression )  . 
Program specifications given by a user can call a module by using one of these headings  . 
The IO expression consists of a pair of an input and an output predicate and asserts that the output predicate holds under the given input predicate  . 
The IO expressions are used to automatically link some modules for a specification and to check linking of modules specified by their procedural expressions  . 
The type part describes the types of regions structures and roles of input output or local variables  . 

Tile OP part describes the procedures for the ~ nnction assured in the heading part  . \]' he procedures are described in a little more detail by using tile headings of more fundainental modules ? Control statements are represented by using a prefixed-form of Pascal called the General Control Expression  ( abbrew kated to GCE , ) here ? The control statements are expanded into a programming language such as L:isp and C designated by users  . Some conversion rules are shown in Table 2 . 
Table 2 Conversion rules to objective lauguages IFTIIEN ( CONI ) : p . OP : s . . . . . . . . . . . . . . . . . . . . ( GCE ) ( CORD ( p s ) ) .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ( Lisp ) IF ( p)s; .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ( C ) IFTIIEN_I ~ , LSE(COND : p , OPI : sl , OP2: s2 .   .   .   . ( GCE ) ( CON:\[)(ps\])(ts2)) .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ( Lisp ) IF ( p)s\]ELSEs2; .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ( C ) FOR ( COUNT : i , FROM:m , TO:n , OP : s) .   .   .   .   .   . ( GCE ) ( SETQJm)(\] , OOP ( ) ( CORD ( ( EQUAL i n )   ( EXIT-LOOP ) )  ( T  ~ ( SET Qi ( ADmi )   )   )   ) )  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ( map)FOR(J = m;J <= n;J ++) s .   .   .   .   .   .   .   .   .   . ( C ) ?, o . 0, oo ? .  0  . o ? .   .   .   .   .  ~ ,  .  0  . o . ooo .   .   .   .   . oo ~ oooo , oo , , .  0  . o ~ , , , . o ~ 0 . ? o .   .  ,  . oo , .  0 ? ?  . GC or responding to tlle genera \] control \] anguage ~ general data structures are also introduced  . If refined specifications are designated to be expanded to a programming language which do not have the corresponding data structures inherently  , the equivalent data structures and the access function must be imp\]  . emented in advance by combining the fundamental data structures in the language  . For example , if L is p is designated as the programming language  , a struct which appears in a general data structure of a specification is expanded to the correspondig associative list structure and the lists can be accessed by associative functions  . 
5 . Refinement and Expansion by the L-MAPS system Figure  1 shows an outline of the processing by

\[ specificati?n s'I?J ~ l library modules ( i ) I procedurall ~ input-output\]~--'\[ expressions J~expressions I "  , \] specification by
I ~ input-output I
J , . 11" ~ expressions I(2) I detection of ~ II/ . . . .
\[ insufficiency \] ~$/~--~ subproblems I ,  /  , /~- q~requests of I "/ I ""\] additional modules I //  . . . .
(3) ~ ~  . . . . . . ~ ad'ditional modules I ~ - ~ intermediate I - jpr?gra  . msIj ~ ~ object language , l(4) ~ efinement , expansion ~--- J expansion mode I-~~-~ object programs\[ 
Fig . l The processing by L-MAPS
In refinement , L-MAPS tries to un : i . fy the heading el an expression in a given spee if J cation and the corresponding heading of a l : ibrary module  . 
If L-MAPS succeeds in the unification , it constructs a more detaJ\]ed descript ion of the specific at fion by using the uni fied Operation Part of the module  . 
The refined part with a more detailed description can be substituted directly for the original part in the specification or can be called in a form of a subprogram as a procedure or a dosed subroutine from the specification part  . One of them is selected by the user . 
The principal part of the above refinement is unification of a specification and the heading of a library module  . When the arguments of a module are confined to the individual variables and the number of arguments of a function is confined to a constant the unification caa be carried out  ; by an ordinary unification of the firs torder logic  . 0 the rwJ se , the unification procedure for the second orderilogic is needed  . 
L-MAPS has a unification procedure for the second order logic  . I Iowever , the un~fJ catJon procedure is confined to a unilateral unification from a module to a specification in which each symbol is J nterpreted as a constant under the condition that any substitution for the symbol Jn the specifications is forbidden  . Accord dagly , the unification procedure can be muchs implified for practical purpose  . 
Fig . 2 shows par ts of a given spec i f i ca t ion wr i tten in the restricted English for a pars ing program of EngIish sentences and Fig  . 3 shows a part of the generated formal spec i f i cation  . 
.  .   .  ,  .  , ,  .   .   .   .   .   .   .   .   .   .   .  ,  .   .   .   .   .   , ? o for i from i to m j s := j search handles from reduced sequences  ( i ) by using reduction rules , and store it in handle ( l . .k ) and rule(\[ . .k ) if k is greater than 0 for n from 1 to k reduce handle ( n ) Jn reduced_sequences ( i ) by using rule ( n )  , and store the result in new_reduced_sequences ( j )   .   .   .  , ,  .   .   . o .  ,  .   .   .   .   .   .   .   .   .   .  ,  .   .  *  .   .   .   . 
Fig . 2 The informal specification for a parsing program

OP := ( JS , J)





OP:HANDLEREDUCE(SO:REDUCEDSEQUENCES(I),


GOAL:NEW_REDUCED_SEQUENCES(J))))
Fig . 3 A part of formal specifications\[ , -MAPS refines the formal specification by referrdng to library modules such as shown in Table \] and generates are f : ined specific at ion and the comment : shown in Fig  . 4 . 
RULE APPI , Y(OBJ:REDUCTION_RULE , PARTIC : HANDLE , 
GOAL:REDUCED SYMBOL)
BRANCH1 ( COND : EQUAL ( REDUCED_SYMBOL , NULL),
OP:RETURN(FAIL))
FOR(COUNT:N , FROM : 1 , TO:-(STACK_POINTER , 
SYMBOL NUMBER OFH ANDI,E),
OP:COPY(OBJ:REDUCED_SEQUENCE(N),--
GOAL:NEW_REDUCED_SEQUENCE(N)), .   .   .   .   .   .   .   .  ~  .   .   .   .   . o .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig . 4 ( a ) A part of tile refined specification apply t : her nl  . e to the handle , and store t ; he result ; in a reduced symbol . 
Jf the reduced_symbol Js null return ( fail )   . 
for n from t . t:o stack_po:inter-synlbol_number of hand\]e copy reduced sequence  ( n ) : into new reduced sequence ( n )   . 
. o .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  ,  .   .   .  ,  .   .   .   . 
Fig . 4 ( b ) The comments of the refined specification in Fig  . 4  ( a ) In the refinement process global optimizations are tried to be done at the user's option  . Some of them are rearrangement of conditional control statements and fusion of several iteration loops : i  . n to one loop . 
6. Conclusion
The translation system : is constructed on a modular basis consisting of  24 application modules and 30 bas :\[ c modules by refining and expanding specifications by the aids of the L-MAPS system consisting of about  1000 lines of L is p statements . 
The generated translation-system programs is about  i000 lines in both C language and Franz Lisp . 
Besides various advantages due to the modular : \[ -zation  , the translation speed is almost the same as that of the old version in LISP  . Furthermore , the translation speed in C language is about three times faster than that of Franz Lispata compiler mode in 
English-Japanese translation.
References l ) Pratt , V . R . : LINGOL-A Progress Report , IJCAI4 ,  422-428 (1975) . 
2) Nishida , F ., Takamatsu , S . and Kuroki , B.:
English-Japanese Translation through
Case-Structure Conversion , COLING-80, pp . 447 -454 (1980) . 
3) Nishida , F . and Takamatsu , S . : JapaneseEnglish Translation through Internal Expressions  , 
COLING-82, pp . 271-276 (1982).
4) Nishida , F . and Fujita , Y . : SemiAutomatic Program Refinement from Specification Using Library Modules  , Trans ? of IPS of Japan , Voi . 25,
No . 5, pp . 785-793, (1984), ( Written in

5) Tanaka , ll . , Sato , T and Motoyoshi , F . : Predictive Control Parser : Extended LING OL , 6th IJCAI , 
Vol . 2, pp . 868-870, (1979).

