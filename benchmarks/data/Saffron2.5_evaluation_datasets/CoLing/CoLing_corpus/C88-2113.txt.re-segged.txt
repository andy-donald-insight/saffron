Parallel Intersection and Serial Composition of FiniteState Transducers 
Mike REAPE13 and Henry THOMPSONt 23
Centre for Cognitive Sciencel
University of Edinburgh
2 Buccleuch Place
Edinbm'gh EH8 9LW

Department of Artificial Intelligence 2 and
Centre for Speech Tectmology Research 3
University of Edinburgh
80 South Bridge
Edinburgh EH 11 HN


We describe a linguistically expressive and easy to implement parallel semantics for quasi -deterministic fnite state transducers  ( FSTS ) used as acceptors . Algorithms are given for detemain-ing acceptance of pairs of phoneme strings given a parallel suite of such transducers and for constructing the equivalent single transducer by parallel intersection  . An algorithm for constructing the serial composition of a sequence of such transducers is also given  . This algorithm can produce generally non -detemlinislic FSTS and an algorithm is presented for eliminating the unacceptable nondeterminism  . Finally , the work is discussed in the context of other work on finite state transducers  . 
1. Introduction
Finite state transducers ( FSTS ) have been shown to be useful for modelling morphophonemic processes in an efficient way in  ( Karttunen 1983 )  , ( Kay 1983) , ( Kaplan and Kay 1985) , ( Karttunen , Koskenniemi and Kaplan 1987 ) and ( Koskenniemi 1983 )   ( but cf . ( Barton 1986b ), ( Barton 1986a )) . This paper presents a linguistically expressive parallel semantics for quasi-deterministic FSTS used as receptors and algorithms for taking the parallel intersection and serial composition of such FSTS  . 
The intersection and composition algorithms generate composite FSTS from sets of FSTS with the same semantics as the parallel semantics of the set  . ?2 presents the parallel semantics ; ?3 discusses the parallel intersection algorithm . ?4 discusses the serial composition algorithm .   ?5 discusses the elimination of unacceptable general nondete ~ rninism which can arise fi'om the composition algorithm  .   ?6 discusses the implementation of the interpreter which is based on the semantics presented here and the three algorithms  .   ?7 discusses this research in the context of other work in this area and draws some conclusions  . 
2 . A Paraflel Semantics for FiniteState Transducers In the discussion that follows  , we assume that the reader is familiar with the work of Karttunen and Koskenniemi on FSTS and with finite state automata  ( FSA ) generally . The notation used is slightly different than that usually used to describe FSA but is more convenient for our purposes  . Also , rather than discuss the algorithms directly , we give their semantics . In contrast to Karttuuen and Koskenniemi's work , no higher level rule formalism is used . FSTS are stated directly . 
An FST , M , is a pair < NC ~ , Z > where N ~ is a set of start stateurines and Z is a set of states  . A state Zi ~ Z is a triple < N , T , A > where N is the name of the state , T is an ordered sequence of transitions T i , l < i < n , n = ITI and A is the truth value T if the state is au accepting state and the troth value F if it is a nonaceepting state  . ( The notion of final state is not relevant here . Only the accepting/nonaccepting distinction is important  . ) A transition Ti~T is a pair < ~ i , Ni > where q5 i is a transition pair < ~ x , ~0~> . An element of a transition pair is either a phoneme  , a phoneme class name , the symbol = or the empty string e . A phoneme is a character and is a member of the alphabet set  . A phoneme class is a set of phonemes . We will refer to phoneme classes and their names interchangeably  . 
Ni is the new state , cI ) i=<O ~ , ~0P ~> subsumes ~ t = <~ xt , t ) of > if o ~ i subsumes Ox , and ~0 is ubsumes ~ I ~ 0 ,  . q bisubsutnes ( P t if ~ i = ~ to r ( ~i == or ( ~ i is a phoneme class and ~ t~q~i ' The transition type or type a :  ( ~ ) of a transition pair fi5 = <@ , ~P > is(x . x ) ' if both ~ ; ~ and 0 o are phoneme classes and is x (@) . ,~ ( ~ o ) otherwise where x ( ~ ) is the phoneme type of q ~ .   ( x is not a variable in this and the following definitions  . )
I ! if ~="~(~) = if ~== otherwise
The set of types , TYP , and tile set of final types , TYP0~ , arc defined below . 
TYP == . = x . = = . xx . EE . xx . x = . e e . =( x . e )' ( e . x )'( x . x ) ' TYP ~=( x . x )' x . x .   .   .   .   . xx . = x . ec . x e . e Some examples should clarify the definitions . < s , s > is of type x . x . <s , z > is of type x . x . < sih , sih > is of type(x . x )' if sib is a phoneme class name . <=, => is of type = . = . <=, e . > is of typenO'ff ? , ~ ) where nx is a partial function from pairs of u ' ansition i = I types to transition types as defined below  . 
" qn'"t2 if x~n , ' x2 eTYP " ~ an " ~= undefined otherwise n , ~' is defined as follows . 
(1) oc-nx ' = : 13 = ( a . \[3)' (2) ~ . = n .  / (& . ~) ' = ( a . ~)' (3) = . f ~%'( cc\[~)'=(a . D ' (4) tx . Dn , ~'( a . \[3)' = a . ~(5) a . \[~%' c ~ . l~=a . ~ (6) = . = nx ' a . L3 = ot . 13(7) c ~ . = n . ~' a . l~=a . I 3(8) = . 1 ~ % ' c ~ . ~= a . l ~ (9) a . ~c ~' ~ i . ~, = 5 . ~/ c ~" a . \[~ An unprimed type " c indicates that the transition type is supported  . A primed type q :' indicates that the transition type is unsupported  . That is , there have been no e . x , x . e or x . x types in timset of intersected types that produced the primed type  . (1) is the origin of unsupported types . (2) and (3) state that neither ct . = nor = . ct can support a transition .   ( 4 ) states that an unprimed type supports the corresponding primed type  .   ( 5 ) states that the intm'section of two identical . types is the same type . (6) States that the intersection of = . = and any type is that type .   ( 7 ) and ( 8 ) state that the intersection of either = . o ~ or co . = and a supported type is a supported type . (9) states that n , c'is commutative and that the commutative closure of  ( 1 ) - ( 8 ) also holds . 
A set of transition pairs cI ) i which subsmne ( 1"5 t is licensed w . r . t . (I ) t if LICENSED(Oi , Ot ) holds . 
LICENSED(Oi , O t ) if n , t'ffOi)eTYP and ( nx'c(O i )  x . xx . e e . xorn,~x(O i ) e(x . x )', = . =, = . xx . = and
Ot=<?'?>)
This definition implements the " daisy wheel " . That is , although a set of transition pairs Oi is excluded in the general case if the type intersection of Oi ~  ( x . x )', = . =, = . xx . = we make an exception if qbt is a pair of identical phonemes  . So , for example , if the type intersection of Oi is = . x and ~ t = < s , s > then ~ i is licensed . In practical terms , this means that the user does not need to encode a large set of " default " transition pairs of the foma  <0  , ?> for each state . This effect is usually achieved , in other FST fomaalisms in the rule compiler . However , such a compilation depends on the existence of an alphabet declaration  . As we do not use a rule compiler , we have found it more convenien to build the effect into the parallel semantics  . 
A machine , Min state N accepts a phoneme pair ? t with accepting transition pair ? and new state N'if 
ACCEPTS(M,N,~t , ~, N ') holds.
ACCEPTS(M,N,Ot,O,N') if
M = < Net , Z > and
Zi = < N , T , A > eZ and 3T k=<Ok , Nk > e~P ( T ))
Ok subsumes Ot and = < , I , j , Nj > P ( r ) 1Sj < k and ~ j subsumes ? r ( ACCEPTS replaces the more usual state transition function f t  . ) P ( T ) is a total function that takes the transition sequence T as argument and returns a transition sequence T ' containing the same set of elements as T with the following ordering of the elements of T '  . All = . = transitions follow all non -= . = transitions . All = . ~ or f ~ . = transitions precede all = . = transitions and follow all other transitions . Relative ordering of transitions in
T ' is as in T otherwise.
The definition above implies that transition precedence is by citation order with two exceptions  . All transition pairs which have non -= first and second elements take precedence over any pairs of the form < o ~  , => and <= , a > and all non -< = , => transition pairs take precedence over a transition pair of the form < =  , => . 
A set of machines Mi in states Ni accept a phoneme pair t ~ t with accepting transitions pairs Oi and new states Ni'if  . ( tS-ACCEPTS(Mi,NiLI)t,Ni ) holds . 
S-ACCEPTS(Mi , Ni , Ot , Ni ') if
Vi 30 i
ACCEPTS(Mi , Ni , Ot , Oi , Ni') and

A string is a sequence of phoneme pair elements . A string pair < It , v > is a pair of strings g and v . < oql3> is a prefix of the string pair < g , v > and the string pair <~ t' , v '> is the corresponding suffix of < It , v > if CONCAT(<oq ~> , <It' , v'> , <g , v >) holds . 
CONCAT(<0~,~>,<g',v'>,<I . t , v > ) if = ~ g ' and v = 13v ' and ~ ( a = eAf~=e )  . 
In particular , this means that prefixes can be of the schematic types x  . x , x . e and e . x but note . e . 
A set of machines/Vii in states Ni accept a string pair < It  , v > with new states Ni ' if STR~ACCEPTS(Mi , N i , < ll , v > , Ni ') holds . 
STR-ACCEPTS(Mi , Nil , < e , e >, Nil).
STR-ACCE PTS(Mi , N i , <II , v > , Ni ') if ~< OC , \[~> <\[ x' , V '> 3Ni "
CONCAT(<~,I3>,<~', V '>,< g,V >) and
S-ACCE PTS ( Mi , N i , <a , 13> , Ni ') and STR-ACCEPTS(Mi , Ni " , <l . t ', v '>, Ni') . 
The following definition is the toplevel relation of our semantics  . A set of machines Mi accepts a string pair < it , v > if
ACCEPTS(Mi,<It,v >) holds.

ACCEPTS(Mi,<l.t,v >) if
VM i=<NC ~ , E > eMi ~ NiaENa ~ Zi = < Ni , T , T > ~ ESTR-ACCEPTS(Mi , N ~" , < bt , V > , N i ) , The reader may have noticed that there is no explicit declaration of the set of phonemes which define the alphabet of the FSTS  . This is the reason that no mention was made of the alphabet in the definition of an FST above as is usually done for finite state machines  . This complicates the algorithms to be discussed below a groat deal  . In particular , phoneme classes cannot in geaeral be replaced by their definitions  , the = notation cannot be compiled away nor can transition sequences be replaced by transition sequences in which  d0 ~ and ~ P are both phonemes fi ) revery transition pair ? = < d?k , ~) P > . However , explicitly declaring the alphabet is unnecessm'y and a certain flexibility ill the semantics of the FSTS is gained by not doing 

3. The Parallel Intersection Algorithm
As ( Karttnnen and Wittenburg 1983) points out , it is possible to merge a set of pm'allelFSTS into one large FST  . In the worst case , the number of states of tile intersected FST is the product of the numl ~ er of states of the intersected FSTS  . In theory , this number can be very large . Ill practice , it is usually much smaller becaase the intersection of most state pairs is undefined  . 
Parallel intersection is associative and commutative  . Thus , tile t bllowing detinition of the intersection of a sequence of FSTS is adequaten 
N <\[ VI 1''' Mn >= (" hMi'i = 1
The intersection M1c~M2, of two FSTS
M t := < N ~ , Y - . ,I > and M 2 = < N~ , Y_ , 2> is their crossproduct < N*xN ~' , E 1 x Z2> The crossproduct of two state name sets Ni'\ [ l_<i_<n and ptt  ,  . ~Nj"\]l<i_<_mistileset<Ni,Nj ~ . \] l_<i_<n and l <_j_<m , The intersection Y '< I , a >= E1~22 of two states
E1:=<NpT1 , AI > and E2 = < Na , Ta , A2> is ) 2 < 1 , 2> = << NI , N2> , T1?"1"2 , A1 AA2 > , I , e . , the nanm of the intersection is the pair of the names of the two intersected states  . The intersection is an accepting state if both of the intersected states are accepting states and is a nonaccepting state otherwise  . 
The crossproduct of two transition seqnences T 1 and T 2 is a sequence Ttx'I'~=<T' , _ <> where T ' is tile set defined below and -<- is a total ordering  . 
T ' = Tk\[TieT1 and TjeT2 and
Tk = T in Tj is defined.
< can be any total ordering which satisfies the following partial ordering on T': 
VTm~T '9
Vm = Tin ~ Ii and ri Erl and Tje Te
V TeT'-9
Tn = Toc3Tp and TOcT1 and Tp~T2 ( Ill<ngo- )  ,  -7  ( o < i and p_<j ) and -1 ( o-<i and p < j ) ) In particular , the ordering of tile following sequence satisfies the partial order : < T < III > ''" T < l  , n > .   .   . T < m , l > T < m , n >> where T < i , j > namestile intersection of the transitions Ti ~ Tl and TjeT  2  , m = IWl\[andn = IT2\] , The intersection Ti c5 Tj of two transitions T i = < t ~ i , Ni > and Tj = <( bj , 5> is < tl ) i(5q ) ' . l'<Ni'Nj > >' If (1) i = . <( zi , \[~ i > and ( l ) j = < ~ , \[3j > then ? i ( -i~j is defined as follows < a incry , ~ in\[3i > if ~ ( d ) i ) c ~' x ( Oj ) a7'YP4~incI ~ ) = undefined otherwise The intersection of two phoneme pair elements x and y is defined as follows xny = x if x = y x if y == y if x == x if y is a phoneme class and x c : y y if x is a phoneme class and y~xx ?~ y if both x and y are phoneme classes undefined otherwise The composite FST is nondeterministic with respect to  ~  ; and the set of start states and is deterministic otherwise  . All phoneme class and = notation is preserved in the intersected transitions  . This is actually quite useful for debugging purposes  . In general , it will often be the case that elements of all intersected transition sequence are subsumed by preceding elements in the same sequence  . It is a simple matter to remove such transitions ( although this is not necessary as they are unreachable  )  . Furthermore , it is often the case that transitions with phoneme classes are partially subsumed by preceding elements in the same transition sequence  . It is straightforward to split the phoneme class transitions into disjoint phoneme class transitions which are not subsumed by preceding transitions in the same sequence  . Our implementation uses both of these optimisations  . 
Notice that the intersection algorithm does not " compile in " the effect of the daisy wheel  . This is because the semantics of a set of parallel FSTS includes the daisy wheel and so the composite FST need not have its effect " compiled in "  . Furthermore , the intersection algorithm must not build in the daisy wheel because the composite FST would have the wrong parallel semantics algorithm  . ( I . e . , we cannot eliminate = or phoneme classes from any transition pairs  . ) The cross product of two transition sequences T 1 and T 2 is a sequence T 1 xT 2 = < T ' , <> where T ' is defined below and < is a total ordering  . 
4. Tile Serial Composition Algorithm
Just as parallel FSTS can be intersected , a cascade of FSTS may be composed into one FST . Such a cascade is most useful for representing ordered sequences of rules  . For example , a theory which orders assimilation processes before morphophonemic processes could be modelled by a cascade of two parallel sequences of transducers where the first parallel sequence models the assimilation processes and the second models the morphophonemic processes  . As is the case with parallel intersection , the number of states of a composed FST is the product of the number of states of the composed FSTS in the worst case  . Again , the number of states in the composed FST is usually much smaller in practice  . 
Serial composition is different in several ways from the parallel intersection problem  . Fit'st , each FST in the composition must have the parallel semantics of  ?2 " compiled in " before it is composed . This means that type intersection as defined for parallel intersection is irrelevant for composition  . On the other hand , we must include the effect of the daisy wheel before composition on any transition pair < Op  ; ~ , OpP > where both gpX and ?0 are phoneme classes . As a result , we can replace all such transitions with one or more transitions < ? x  , , CO , >? where ?~' and ~' are both phonemes . This simplifies the composition algorithm considerably  . However , we must still check that the type of each transition pair in each FST to be composed is an element of TYP e  . ( In particular , users may encode illegal transitions . ) Also , although serial composition is associative , unlike parallel intersection , it is not commutative . So , a cascade of FSTS must be composed in the same order as they appear in the cascade  . 
The composition of a sequence of FSTS*<M1 .   .   . Mn > is defined by fM if n = l *<211/t '" M > :*< Ml .   .   . M . t >* M if n > lk
T ' = TklTi ~ TI and TjeT 2 and Tk = Ti*Tj is defined . 
< must satisfy the same partial ordering as that given for parallel intersection  ( modulo the substitution of * for n )  . Again , we use the ordering given in ?3 . 
If Zi = < Ni ' , TI , Ai > and Ej = < Nj ' , T2 , Aj > and TiET 1 and TjT 2 then the composition Ti * Tj of two transitions Ti = < Oi  , Ni > and Tj = <~ j , Nj > is defined by r ,  *~= <<= , => , < NvNj > > < < ~ , I3> , ~/ vF > << a , ~> . < v ~ ~ v /> > < < ~ , ~> , ~ , ': v ~>> << a , ~> , ~v , Svj >> undefined if ~/=<= , => and Oj = <= , => if Oi = <= , => and ~=<~ , 13> and << a ; 0t > , Nk > flT1 ~ k<i if ? i=<a , 13> and Oj = <= , => and <<13 , 13> , Nk > ? T2~k < j if Ot=<a , e > if Oj = < e , \[~> if Oi = < a . 13> and O/=<13 , $> otherwise ( The fourth and fifth clauses are due to Martin Kay  ( Kay 1983 )  . ) Note that if ? i = < a , e > and Oj = < e , 13> then both <<( z , e> , <Ni , N ' j >> and << a , ~> , <N'i , Nj > > are defined . Their ? order relative to each other is irrelevant since the semantics in on detemainistic with respectoe transitions  . Also , note that the second and third clauses dealing with < =  , => transitions are further constrained to eliminate any " instantiation " of <=  , => which has lower precedence than a transition with the "  instan-tiati0n " in the transition sequence which contains <= , => . E . g . , if <<= , => , Nj > eT1 and <<= , => , Nil * < < b , c> , Nk >= << b , c> , <Nj , Nk >> and there is a transition < < b , b> , Ni > eT1 and i < j then < < b , b> , Ni > takes precedence over < <= , => , Nj > and so the composition is undefined . 
The composition M1*M2 of two FSTS
M 1=<N ~, Y . I > and/Vl2=<N ~ , E2> is their crossproduct < v~xte ~ , X1 x X2 > The composition Z < l , 2> = Z1*Z2 of two states Finally , note that nondetemainistic ransition sequences may be defined  . That is , two or more transitions with the same transition pair may be specified which have different new states  . E . g . , the composition of the transitions << a , b> , sl > and < < b , c> , tl > is < < a , c> , <sl , tl > > but the composition of the transitions < < a , d> , s2> and << d , c> , t2> is << a , c> , <s2 , t2>> . Both compositions have the transition pair < a , c > but the new state is the < sl , tl > for the first transition and < s2 , t2> for the second transition . This form of nondeterminism is genuine and must be eliminated if the quasi-deterministic semanties that we have outlined is to be maintained  . 
X1=<NI,T1,AI>andZz=<N2,T2,A2> 5 . The Determinisation Algorithm is Z < l , 2> = << Ni , N2> , T1 xT 2 , A1AA2>I . e . , the name of the composition is the pair of the names of the two composed states  . The composition is an accepting state if both of the composed states are accepting states and is a nonae-cepting state otherwise  . 
As ( Barton 1986b ) points out , FSTS used as aeceptors are finite-state machines ( FSM ) with an alphabet of pairs of characters . As such , an equivalent deterministic FST can be con -strutted  . for any nondeterministic FST used as an acceptor since a deterministic FSM can always be constructed that accepts exactly the same language as a nondeterministic FSM  ( Hoperoft and Ullman 1979 )  . Because the serial composition algorithm may produce nondeterministic FSTS  , a determinisa-tion algorithm is required to produce equivalent deterministic 


The algorithm collapses all transitions in a transition : ~ equence with common transition pairs but different new states into one transition with a complex new state name  . This new state name is the name of a state which is the parallel intersection of all the new states " of the transitions with the common transition pairs  . The only fundamental difference between this type of parallel inteisection and the definition presented in ?  3 is that a state in the intersected FST is an accepting state if any of the intersected states is an accepting state  . 
Although it may not be obvious , the determinisation algorithm is guaranteed to terminate  . The following argument shows why . The new states of simple states are always simple states so complex states are the intersection of only simple states  . 
The number of simple states is finite . The number of transitions within a simple state is finite  . It follows that the number of transitions in a transition sequence with common transition pairs is bounded  , the number of possible complex states is bounded and the size of a complex state is bounded  . Therefore , there is an upper bound on the size of the equivalent deterministic machine and so the determinisation algorithm is guaranteed to terminate  . 
6. Implementation
The second author designed the parallel semantics and implemented an interpreter for it in Interlisp-Dona Xerox  1186  . The first author designed and implemented the parallel intersection  , serial composition and determinisation algorithms in Lucid Common Lispona Masscomp  MC5700  . The programs exhibit reasonable performance ( about enminutes using compiled Lisp for composite FSTS with approximately  160 states )  . 
7. Conclusions and Related Work
Although it has been reported in the literature that the algorithms described here have been implemented  , we are unaware of the publication of any such algorithms to date  . The algorithms themselves are of interest because they formalise the semantics of finite state transducers  . Also , these algorithms are similar to graph unification algorithms  . Specifically , the parallel intersection and determinisation algorithms can be viewed as cyclic graph unification and graph disjunction elimination algorithms respectively  . 
As Barton points out , a determinisation algorithm like the one presented here will not work on transducers used for generation and recognition  ( as opposed to simple acceptance )  . He claims that many FSTS are not determinisable at all  . The current work provides a formal basis on which to investigate the class of detemlinisable transducers used for generation and recognition  . 
9. References
Barton , G . E . (1986) Constraint Propagation in Kimmo Systems . In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics  , Columbia University , New York , N . Y . , June , 1986, pp 45-52 . 
Barton , G . E .   ( 1986 ) Computational Complexity in Two-Level Morphology . In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics  , Columbia University , New York , N . Y . ,
June , 1986, pp 53-59.
Hopcmft , J . and Ulhnan , J . D . (1979) Introduction to Automata Theory , Languages and Computation . Reading , Mass . :

Kaplan , R . and Kay , M . (1985) Phonological rules and finite . -state transducers . 
Karttunen , L . (1983) KIMMO : A general morphological processor . Texas Linguistic Forum , 22, 165-186 . 
Karttunen , L . and Wittenburg , K . (1983) A two- . level morphological analysis of English . Texas Linguistic
Forum , 22, 217-228.
Karttunen , L . , Koskenniemi , K . and Kaplan , R .   ( 1987 ) A Compiler for Two-level Phonological Rules . Technical Report , Center for the Study of Language and Information , Stanford University ,  1987 . 
Kay , M . (1982) When metarules are not recta-rules , in SparckJones , K . and Wilks , Y . ( cds . ) Automatic Nat , ra ! Language Parsing , pp74-97 . Chichester : Ell is Horwood . Also in MBadow , DF lickinger and IAS a ! , ( eds . ) Developments in Generalized Phrase Structure Grammar : Stanford Working Papers in Grammatical Theory  , Volume 2 , pp 69-91 . Bloomington : \[ ndi at m
University Linguistics Club.
Koskenniemi , K .   ( 1983 ) Two-level morphology : A general computational model for wordform recognition and production  . Publication 11 , Department of General Linguistics , University of Helsinki , Helsinki ,  1983 . 
8. Acknowledgments
This research was supported by the Alvey Speech Input Word Processor and Workstation Large Scale Demonstrator project  , ESRC Grants D/29611 , D / 29628 and 1)/29604 . The first author has been supporte during the writing of this paper by the EECEs prit Project  393 ACORD : the Construction and Interrogation of Knowledge Bases using Natural Language Text and Graphics  . 

