A Simple Reconstruction of GPSG
Stuart M . Shieber
Artificial Intelligence Center
SRI International

Center for the Study of Language and Information
Stanford University
Abstract
Like most linguistic theories , the theory of generalized phrase structure grammar  ( GPSG ) has described language axiomati-cally , that is , as a set of universal and language-specific con -attaints on the well-formed ncss of linguistic elements of some sort  . 
The coverage at ttl detailed analysis of English grammar in the ambitious recent volume by Gazdar  , Klein , Pullum , and Sagentitled Generalized Phrase Structure Grammar  \[2\] are impressive , in part because of the complexity of the axiomatic system developed by the authors  . In this paper , we examine the possibility that simpler descriptions of the same theory can be achieved through a slightly different  , albeit still axiomatic , method . Rather than characterize the wellformed trees directly  , we progress in two stages by procedurally characterizing the wellformedness axioms themselves  , which in turn characterize the trees . 
1 Introduction I
Like most llngafistic theories , the theory of generalized phrase structure grammar  ( GPSG ) has described language axiomati-cally , that is , as a set of universal and language-specific constraints on the we\[l-formed ncss of linguistic elements of some sort  . In the case of GPSG , these elements are trees whose nodes are themselves structure dentltics from a domain of categories  ( a type of feature ~ trueture \[6\] )  . The proposed axioms have become quite complex , culminating in the ambitious recent volume by Gazdar  , Klein , Pullum , and Sagentitled Generalized Phrase Structure Grammar  \[2\]  . The coverage and detailed analysis of English grammar in this work are impressive  , in part because of the complexity of the axiomatic system developed by the author  . 
In this paper , we examine the possibility that simpler descriptions of the same theory can be achieved through a slightly different  , albeit still axiomatic , method . Rather than characterize the wellformed trees driectly  , we progress in two stages by procedurally characterizing timwell-formed aess axioms themselves  , which in turn charaetei ' ize the trees . In particular , we give a procedure which converts GPSG gramma ~ into gramma ~ written lThls research wasm ~ de possible by a gift  . from the System Development

I am indebted to Lauri K~rttuncn and Ray Perrault for their eomrael ~ te on earlier drafts  , and to Roger Evans , Gerald Gszdsr ~ Ivan S ~ . $t lenry Thompson , and members of the Foundations of Grammar project at the Center for the Study of Language and Information for their helpful discussions during the development of this work  . 
in a unification-b~qed formalism , the PATR-II formalism developed at SRI International  ( henceforth PATR )  \[5\] , which h~s its own declaratives emmltics , and which can therefore be viewed & san axiomatization of string wellformedness constraints  .   2 The characterization of GPSG thus obtained is simpler and better defined than the version described by Gazdar et al The semantics of the formalism is given directly through the reduction to PATR  . Also , the PATR axiomatization has a clear construe-tire interpretation  , unlike that used in Gazdar et al , thus making the system more amenable to computational implementation  . 
Finally , the characteristics of the coml ~ ilation -- the difficulty or ease with which the various devices can be encoded in PATR--can provide a measure of the expressiveness and indispensability of these devices in GPSG  . 
2 The GPSG Axioms 2 . 1 A Summary o f the P r inc ip les GPSG describes natural languages in terms of various types of constraints on local sets of nodes in trees  . Pcrtlncn to the ensuing discussion are the following : ? ID  ( immediate dominance ) rules , which state constraints of immediate dominance among categories  ; ? metarules , which state generalizations coI ~ ccraing classes of 
ID rules ; ? LP ( linear precedence ) rules , which constrain the Ihwar order of sibling categories  ; ? feature cooccurrencc restrictions ( FCR ) , which constrain the feature structures as to which arc permissiHe categories  ; a feature specification defaults ( FS1)) , which provide values for features that are otherwise unspecified  ; and , most importantly , 21 to wever , a caveat is \] n order th : ~ t the detailed ~ u ~ alys is from this perspective of the full range of GPSG devices  ( especially immediate dominance ( ID ) rules , and feature cooccurrence rstrictions ) is not discussed fillly here , nor do I completely understand them . ( See Section 3 . 4 . And while in a confessional mood , I should add that the Ms or lthm given here has not actually been implemented  . 
211 ? universal feature instantiation principles , which constrain the allowable local sets of nodes in trees  ; these feature instantiation principles include the head feature convention  ( HFC )  , the foot feature principle ( FFP ) , and the control agreement principle ( CAP ) . 
In GPSG all of these constraints are applied simultaneously  . 
A local set of nodes in a tree is admissible under the constraints if mad only if there is some base or derived ID rule  ( which we will call tile licensing rule ) for which the parent node's category is an extension of the left-hand-side category in the rule  , and the children arc respective extensions of right-hand-side categories in the rule  , and , in addition , the set of nodes simultaneously satisfies all of the separate feature instantiation principles  , ordering constraints , etc . Byeztension , we mean that the constituent has all the feature values of the corresponding category in the licensing rule  , and possibly some additional feature values . The former type of values are called inherited , the latter instantiated . 
The feature instantiation principles are typically of the following form : if a certain feature configuration holds of a local set of nodes  , then some other configuration must also be present  . 
For instance , the antecedent of the control agreement principle is stated in terms of the existence of a controller and e ontrollee which notions are themselves defined in terms of feature configurations  . The consequent concerns identity of agreement features  . 
2.2 Interaction of Principles
Much care is taken in the definitions of the feature instantiation principles  ( and their ancillary notions such as controller , e ontrolle e , fl'ce features , privileged features , etc . ) to control the complex interaction of the various constraints  . For instance , the FFP admits local sets of nodes with 8la~h feature values on parent and child where no such values occur in the licensing ID rule  , i . e . , it allows instantiation of slash features . But the CAP's above mentione definition of control is sensitive to the value of the slash feature associated with the various constituents  . A simple definition of the CAP would ignore the source of the slash value  , whether inherited , instantiat cd by the FFP , or instantlated in some other manner , l lowev cr , the appropriate definition of control needed for the CAP must ignore instantiated slash features  , but not inherited ones . Say Gazdar et al : We must modify the definition of control in such a way that it ignores perturbations of semantic type occa-sioned by the presence of instantiated FOOT features  . 
12, p . 87\]
Thus , the CAP is in some sense blind to the work of the PFP  . 
As Gazdarctal . note , this requirement makes stating the CAP a much more complex task  . 
The increased complexity of the principles resulting from this need for tracking the origins of feature values is evident not only in the CAP  , but in the other principles as well . The head feature convention requires identity of the head features of parent and !  , , ad child . The features ayr and slash--features that can be it fimrited from an ID rule or instantiated by the CAP or FFP  , respectively -- are had features and therefore potentially subject to this identity condition  . However , great care is taken to remove such instantiated head features from obligatory manipulation by the tIFC  . This is accomplished by limiting the scope of the It FC to the socalled free head features  . 
Intuitively , the free feature specifications on a category \[ the ones the HFC is to apply to \] is the set of feature specifications which can legitimately appear on extensions of that category : feature specifications which conflict with what is already part of the category  , either directly , or in virtue of the FCRs , FFP , or CAP , are not free on that category . \[2, p . 95\]That is , the FFP and CAP take precedence ( intuitively viewed ) over the ItFC . 
Finally , all three principles are seen to take precedence over feature specification defaults in the following quotation  . 
In general , a feature is exempt from assuming its default specification if it has been assigned a different value in virtue of some ID rule or some principle of feature instantiation  . \[2, p .   1001 Qazdar et al accomplish this by defining a class of privileged features and excluding such features from tile requirement that they take on their default value  . Of course , instantiated head features , slash features , and so forth are all considered privileged . 
However , a modification of these exemption sine cessary in the case of lexical defaults  , i . e . , default values instantiated on lexical constituents  . We will not discuss here the rather idiosyncratic motivation for this distinction  , bnt merely note that Icxical constituent defaults are to be insensitive to changes engendered by the HFC  , as revealed in ' this excerpt : f to wever , this simpler formulation is inadequate since it entails that lexical heads will always be exempt from defaults that relate to their ttEAD features  . . . . Accordingly , tile final clause needs to distinguish lexical categories  , which become x empt from a default only if they covary with a sister  , and nonlexieal categories , which become exempt from a default if they covary  ( in relevant respects ) with any other category in the tree . \[2, p .   103\] Thus the interaction of these principles is controlled through complex definitions of the various classes of features they are applicable to  . These definitions conspire to engender the following implicit precedence ordering ontire principles  , principles earlier in the ordering being blind to the instantiatlons from later principles  , which are themselves sensitive to ( and exempt from applying to ) features instantlated by the earlier principles ) CAP ~ . 4 FFP~'-FSDuz~tlFC>-FSD no , a ~ Of course , all ID rules , both base and derived arc subject to all these principles  ; yet met , rule application is not contingent on instantiations of the base ID rules  . Conversely , LP constraints are sensitive to the full range of instantiat cd features  . The precedence ordering can thus be extended as follows : S Current efforts by at least certain GPSG practitioners are placing the GPSG type of analysis directly in a PATR-like formalism  . This formalism , Pollard's head-drlven phrase structure grammar ( ltPSG ) variant of GPSG , uses a runtime algorithm similar to the one described in this paper  \[4\]  . Highly suggestive is the fact that the \] IPSG runtime algorithm also happens to order the principles in substantially the same way  . 
4We use the symbol ~- to denote one principle " taking precedence over " another  . 

META~-CAP~-FFP>-FS Dttx~-It FC>-FSD no , u ~ ~" LP The existence of such an ordering on the priority of axioms is  , of course , not a necessary condition for the coherence of such an aximaatic theory  . Undoubtedly , this inherent ordering was not apparent othe developers of the theory  , and may even be the source of some surprise to them  . Yet , the fact that this ordering exists and is strict leads us to a substantial simplification of the system  . Instead of applying all the constraints imultaneously  , we might do so sequentially , so that the precedence ordering--tile blindness of earlier principles in the ordering to the effects of later ones emerge simply because the later principles have not yet applied  . 
This solution harkens back to earlier versions of GPSG in which the semantics of the formalism was given in terms of compilation of the various principles and constraints in to pure contextfree I~lles  . This compilation process can be combinato-rially explosive  , yielding vast numbers of contextfree rules . Indeed , the whole point of the GI'SG decomposition is to succinctly express generalizations about tile possible phrasal combinations of natural languages  , l to wever , by carefully choosing a system for stating constraints on local sets of nodes -- a formalism more compact in its representation than contextfree grammars -- we call compile out the various principles and constraints without risking this explosion in practice  . 
The GPSG principles are stated in terms of identities of features  . What we need to avoid the combinatorial problems of pure CF rules is a formalism in which such equalities can be stated directly  , without generating all the ground instances that satisfy the equalities  . What is needed , in fact , is a unification-based grammar formalism\[6\] . We will use a variant of PATR\[5\] as the fi ) rmalism into which ( H ) SG grammars are compiled . In par-tieular , we assume a version of PATR that has been extended by the familiar decomposition i to an immediate-dominance and linear-precedence omponent  . T tf is will allow us to ignore the
LP portion of GPSG for the nonce.
PATR is ideal for two reasons . First , it is the simplest of the unification-based grammar formalisms  , possessing only the apparatus that is needed for this exercise  . Second , a semantics for the formalism has been provided , so that , by displaying this compilation , we implicitly provide a semantics for GPSG grammars as well  . In the remainder of the paper , we will assume the reader's familiarity with the rudiments of the PATR formalism  . 
3 The Compilation Algorithm
We postpone for the time being discussion of the metarules  , LP constraints , and feature e o occurrence restrictions , concentrating instead on the central principles of GPSG  , those relating to feature instantiation . The following nondeterministic algorithm generates wellformed PATR rules from GPSGID rules  . A GPSG grammar is compiled into the set of PATR rules generated by this algorithm  . 
is written in unordered PATR as
Xo ~ Xt , X2 ( X on )  =- ( X o ~ )  =+  ( Xobar )  = 2  ( R  ~ )   ( Xos , ,O ) = + ( X l bar ) = 2 ( x2 s . O ) =-Note that abbreviations ( like 5' for l-n , + v , bar 2 , -t . subj \]) have been mad ( ; explicit . 
In fact , we will make one change in tile structure of categories  ( to simplify our restatement of the HFC ) by placing all head features under the single feature head in tile corresponding PATR rule  . We do not , however , add an analogous f cature foot . sTiros the preceding rule becomes
Xo --* Xi , Xz ( Xoheadn ) = . - ( Xoheadv ) = - t - ( xo head bar ) = e ( ~ )   ( Xo head subj )  = +  ( Xtheadbar )  = 2  ( X2 heads ubl ) =- We use an operation add c ( read " add conservatively ' ) which adds an equation to a PATI~rule conservatively  , in Ihc sense that the equation is added only if thc equations arc not thereby rendered unsolvable  . If addition would yield uosolvability , thcn a weaker set of unifications arc added ( conserw ~ tively ) instead , one for each feature in the domain of tile value being equated  . For instance , suppose that the operation add ~ ( (Xo head )  =  ( Xthead ) ) is called for , where the domain of the head feature w dues ( i . e . , the various head features ) arc a , b , and c . If the equations in the rule already Sl ) ccify that ( X0 head a )  #  ( X1hc ~ , da ) then this operation would add only the two equations  ( X0 head b )  =  ( Xlheadb ) and ( Xo head c )  =  ( X the adc )  , sincc the addition of the given equation itself would cause rule failure  . Thus the earlier constraint of values for the a feature is given precedence over the constrain to be added  . 
In the description of the algorithm , a nonempty path p is said to be defined for a feature structure X if and only if p is a unit path  ( \] ) and f ~ dora ( X ) or p = ( h ? ) and p ' is defined for X ( f )   . Our notion of a feature's being defined for a constituent corresponds to the GPSG concepts of being instantiated or of covarying with some other feature  . 
As in the previous definition , we will be quite lax with respcct to our notation for paths  , using ( ( ab ) c ) and ( a ( be )   ) as synonymous with ( abc )   . Also , we will e on sist cntly blur the distinction betw cen a set of equations and the f catur c structure it determines  .   ( SceShleber \[7\] for details of the mapping that makes this possible  . ) 3 . 2 The A lgor i thm I t se l f Now our algorithm for compiling a G PSG grammar into a PATR grammar follows:  3  . 1 Pre l iminar ies We first observe that a GPSG ID rule is only notationally distinct from an unordered PAI ' R rule  . Thus , the first step in the algorithm is trivial . For example , the ID rule , ' ~- + x ~ , II\[- , ubj\] ( RI )   5But recall that dawh is a head feature and titus would fall t in der the p~th  ( head slash )   . 

For each ID rule of GPSG ( basic or derived by metarule ) X0"--'
X 1 , ..., X , ,:
CAP If Xi controls X y ( determined by Type ( Xi ) and Type ( Xj ) ) , then add e ( (Xl con )  =  ( Xjcon ) ) where ( head slash ) if ( head slash ) is defined for Xicon = ( head acr ) otherwise FFP For each foot feature path p ( e . g . , ( head slash  ) , if p is not defined for Xo , then add e ( (Xi p )  =  ( Xop )   ) for zero or more i such that 0 < i <_n and such that p is not defined for X , ' . 6 FSD tez For all paths p with a default value , say , d , and for all i such that 0 < i < n , if ( Xibar ) = 0 and p is not defined for
X i , then add , (( X ? 1) = d).
HFCF or X/the head of X0 , add ~(( Xihead ) = ( Xohead )) . 
FSD nont ~ zFor all paths p with a default value , say , d , and for all i such that 0 < i_<n , if ( Xibar ) #0 and p is not defined for X ? , then add ?(( X?J ) = d) . 
3.3 An Example
Let us apply this algorithm to the prcceding rule RI  . 7 We start with the PArR equivalent Rs . By checking the existing control relationships in this rule as currently instantiated  , we conclude t bat the subject X1 controls the bead ) (2 . We conservatively add the unification ( X2 head a gr )  =  ( XI )  . This can be safely added , and therefore is . 
Next , the FFP step in the algorithm can instantiate the rule further  . Suppose we choose to instantiate a slash feature on  X2  . 
Then we add the equation ( Xo head . dash ) = ( X2 head slash ) . 
Lexical default values rcqulre no new equations , since no con-stituents in the rule are given as 0 bar at this point . 
The tlFC conservatively adds the equation ( X0 head )  =  ( X2 head )  , as ) (2 is the head of X o . But this equation , as it stands , would lead to the entire set of equations being unsolvable  , since we already have conflicting values for the head feature subj  . Thus the following set of unifications is added instead : s  X0 head n )  =  ( X2 headn )   ( Xoheadv )  =  ( X2 headv )   ( Xoheadbar )  =  ( X2 head bar ) X 0 head a gr )  =  ( X2 head a gr )   ( Xohead ; nv ) = ( x2 head in , )  6Several comments are pertinent to this portion of the algorithm  . First , it is the FFP portion that is responsible for its nondeterminism  . Second , the operation add ? is actually superfluous here . The equation can simply be added directly , since we have already guaranteed that the pertinent features are not yet instantiated  . By a similar argument , we can conclude that only the add coperations in the CAP and HFG are actually necessary  . 
We will use adds , however , for uniformity . Finally ~ we assume that an FSD will place the value ~ on any remaining constituents unmarked for foot features  . 
7We do not include here the effect of the rule on every feature postulated by Gazdar et al  . but only a representative sample . 
8A more efficient representation f such sets could be achieved by the introduction of nonmonotonic operations such as overwriting or priority union  . 
But such consideration seed not concernushere.

Finally , nonlexieal defmdts are introduced for features not in the domains of consti  tuents2 Since the path ( head in v ) is defined for the constituents X0 and X2 , l ? the defanlt value ( i . e . , ' - ' according to FSD 1 of Gazdar et al ) is not instantiated on either constituent . Similarly , the case default value ( ace , FSD10) is not instantiated on tile subject NP . But the conj feature default t (  '~ '  ) will be instantiated on all three constituents with the equations  ( Xoeo . ~ ,   )  = ~  ( xl conj )  = ~  ( xzeonj ) = ~ The ( partial ) generated rule is the following :
X s -* X ~ , X z ( Xoheadn )  = - ( Xoheadv )  = +  ( Xo head bar=2 ( Xo head subl )  = +  ( X1 head bar )  = 2  ( X2 heads ubl )  = - ( X2 head a gr )  =  ( X 1 )   ( Xo head slash )  =  ( Xz head slash )   ( xo head . ) = ( xz head . )  ( Xoheadv )  =  ( X2 headv )   ( Xohead ~ ar )  =  ( xz head bar )   ( Xoheadaor )  =  ( X ~ heada ~ r )   ( Xoheadinv )  =  ( - ) (2 head inv )   ( x0co@=~ ( X , co@=~(X2 so . j ) = ~3 . 4 Problems and Extens ions Several problems have been glossed over in tile previous discns-sion  . First , we have not mentioned the role of LP rules . Two possibilities are available for their interpretation : a " rtm-time " and a " eompile -tlme " interpretation  . We can augmentile PATR formalism with I , Prules in t be same way as Gazdar et al , providing for local sets of nodes to satisfy an unordered PATR rule if and only if the nodes are extensions of elements in the ID rule such that the LP rules are all satisfied  . Alteruatively , we can generate at compile time all possible orderlngs of tile unordered rules compatible with ttle LP statements  , but this leads us into the problem of interpreting LP statements relative to partially instantiated categories  , an issue beyond the scope of tiffspaper . 
Second , feature eooe eurreneer strictions were ignored in the previous discussion  . Again , we will limit ourselves to a brief dis-eussion of the possibilities  . One alternative is to modify the lat-OWe have made the simplifying assumption that feature specification defaults are stated in terms of simple default values for features  , rather than the more complex boolean conditions used in the Gazdar et al text  . 
The modifications to allow the more complex FSDs may or may net be straightforward  . 
t ? The value of the feature head on the constituent Xo has the feature inv in its domain because the unification  ( Xo headiuv = ( X2 head in v ) gives as value to ( Xo head inva variable , the same variable as the value for ( X2 headins )   . Thus the path ( headlay is defined for Xo and , similarly , for X : . 
II We assume here , contra Gazdar et al , that ' ~' is af nll-fl edged value in its own right  , at least as interpreted in this compilation . Since this value fails to unify with any other value  , e . g . , '+' or ' - ' , it has exactly the behavior desired , namely , that the feature is prohibited from taking any of its standard values  . 
tice of categories relative to which unification is defined tz in such a way that all categories violating the FCILs are simply removed  . 
Then unification over this revised lattice will be used instead of the simpler w ! rsion and FCRs will automatically always be obeyed  . Unfortunately , tire possibility exists that unification over tile revised lattice may not bear the same ord cr -in  ( lependence properties that characterize unification over the freely-generated lattice  . . Of course , if this turns out to be the ease , it c ~ , ~ts doubton the well-fom Medness of the original Gazdar et al interpre:tation of FCRs as well  , apdtlms is an interesting question to pursue . 
Another alternative involves checking the FCRs at every point in the algorithm  , throwing out any rules which violate them at any point  . In addition , FCRs would be required to be checked during rau -time as well  . This alternative , though more direct , violates the spMt of the enterprise of giving a compilation from the eoml > lexGazdar et al formulation to n simpler system  . 
A final problen l concerns the ordering of the III " C and the  ( JAIL The definitions of e ontroller and controllee necessary for stating ttwCAP depend on the assigmnent of semantic types tr  ) constitn cnts , which in turn deltend on the configuration of features in  ; he categorical . We have a h'eady noted that the features pertinent ot it  ( ! definition of sen ( antictype ( and hence control ) do not include instantia tcdfi ) otfeat ttrcs . Indeed , Gazdar et al claim that " it is just Il EAl ) feature specifications ( other than those which are also I?OOT feature specifications  ) and inherited FOOT fl , a turc specifications that determit rethesemantic types relevan to the definition of control  . "\[2, p . 87\] Unfortunately , the orderiug we have giveulu'e cludes instantiated head features from participating in the definition of semantic type and hence the CAI  ) ) "~ It seems that the III"C nmst apply before che CAP lot the  ( Mini \ [ ion of semantic type , but after the CAP so that the CAI' instantiatlons of head features takeln  , eeedence . Tbus , our earlier claim of strict ordering may be falsified by this case  . 
Of com-se , the : ~ et of features neeess at T for type determination and the : act  ; instantiated by tile CAP may be disjoint . In this case , we can merely split the application of the IIFC in two  , in-start\[taring the flu'met'class beibre the CAP and tile latter class after the FFP ms originally described  . Alternatively , it might be possible to notate head features on the head constituent rather than timl  ) arent as is convent lally dtate . In this case , tile information needed by tile CAP is inherited , ( to t instantiated , head feature w dues , at nltitus not subject to the ordering problem . 
On the other hand , if the sets are nondisjoint , this presents a problem not only for our algorithmic analysis  , but for the deti-nltion of GI'SG given by Gazdar et al Suppose that the IlFC determines types in such a way that the CAP is required to apply and instantiates head features thereby overriding the original values  ( since the CAP takes preeedence ) attd changing the type determination so that the CAP does not apply  . We wouhl thus require the CAP to apply if and only if it does not apply  . This paradox : qt pears as a nord cring cych:in our algorithm  ; in the declarative detinition of Gazdar et al , it would be manifested in the inadmissability of all local set  . ~ of nodes 11\], at ( equally unattractive effect . We leave the resolution of this problem open for the time being  , merely noting that it is a difieulty for GPSGiu general  , and not only for our characterization . 
l ~ For the technic M background of st\[d\[a move , see the discussion of PATR semantics\[3\] . 
~u I am ind t : bted to Roger Evens and William Keller for pointing this problem out  , to me and for helpful discussion of solution alternatives  . 
4 Conclusion
The axiomatic formulation of generalized phrase structure gram?marby Gazdar et al is a quite subtle and complex system  . Yet , as we have qhown , GPSG grammars cm~be substantially converted to grammars in a simpler  , attd constructive , axiomatic system through a straightforward ( albeit procedural ) mapping . 
Intrinsic iuthis conversion is the use of a unification-based grammar formalism  , so that axioms can be stated schematically , without enumerating all nf their possible instantiations  . In fact , we wouhl contend that defining the semantics of a GI  ) SG grammar in this way yields a much simpler for nmlation  . The need for such are construetinn is evident o anyone who has studied tit\[:C  ; azd are tal text . 
Of course , even if certain parts of the GPSG for ' realism not discussed fully here  , i . e . , FCRs att(I l , l ) constraints , arc found not to be reducible to PATR , this in itself wouhl be an interest i , g fact . It wouhlslmw that exactly those porticos of the formalism were truly essential for stating certain analyses  , i . e . , that analyses using those formal devices do so necessarily  . 
We find a hope fid sign in the recent work in ( \] PSG that is pro- . 
ceeding iu the direction of using unilication directly in the rules  , in addition to its implicit m ~ eiu featuce instantiation principles  . 
W chope that this paper has provided evidence that such a system may be able to more simply state the kiuds of generalizations that linguists claim  , and has pointed out I ) oth the possibilities and difll cultics inherent in these tcehniques  . 
i\[t ~ ei ~ re ~ ces\[1\] Gerahl Cazdac . l'ecs on al communication , 1986 . 
\[2\] Gerald Cazdar , Ewan Klein , Geoffrey K , I ' ullum , att(lIvanA . Sag . Generalized Phrase Structure Grammar . Blaekwell Pnblishing , Oxford , l ( , ngl and , at nll\]arvard University Press , 
Candwidge , Massachusetts , 1985.
\[3\]l , ' ernando C . N . l'ercira and Stuart M . Shieber . The semaaotics of granmar form a I is m seen as CO mlmter languages  , In Proeecding , ~ of the Tenthlnt crnational Conference on Com . .
putation . lLinguistics , Stanford University , Stauh)r(l , California , 27 July 1984 . 
\[4\] Carl Pollard . l , ecture notes ouh cad-driven phrase-structure grammar  . Fcbruary 1985 . Center for thc Study of l , anguagcand Information , unpublished . 
\[5\]StuartM . Shieber . The design of a computer language for linguistic information  . In Proeecding ~ of the " l~nth International Conference on Computational Lt'ngui  , ~ tic ~ , Stanford University , Stanford , California . , 27 July 1984 . 
\[6\] Stuart M . Shiel ) er . Art Introduction to Unification-Ba . ~ cdAp . 
proache ~ to Grammar . CSLILectu ) v Note Series , Center for the Study of Language aud Information , Stanford , California , 

\[7\] Stnart M . Shieber . Usiug restriction to extend parsing algorithms for complex-feature-based formalisms  . In Proceedings of the 22nd Annual Meeting of the Association for Computational Linguistic  . ~, Univel ~ ity of Chicago , Chicago , lllinoi %
July 1985.

