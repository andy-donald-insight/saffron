COMPUTING FIRSTAND FOLLOWFUNCTIONSFOR,
FEA'rURE-THEoRE'rR?GRAMMARS
Arturo Trujillo
Computer Labora , tory
University of Cambridge
Cambridge CB 23 QG , gngh md

ABSTRA(3T 1.1 FIRSTANI ) FOLLOW
This paper des (: ribes an algorithm ff)r ( ; he com-lm tation of FIIST and F ( ) I~LOW sets for use with f (  ; atur(!-thcor('~( ; ic grammars , in which the value of the sets t : on sist ; s of pairs of feature-l ; he orctic cat ; o , gorit ; s . The Mgori (; hmtn '( ; sezve , sasmu (: hinformed ; ion from th(;gratn nmrsa , s1) ossibh ' , , using negative restriction to ( h;fin (~ (' , quivah ; nc ( , , classes . Addition of a simple ( I a ( ; aS ( ; I ; IIt : tIII'e leads to ; morder of ilta , glli ; lld ( , ; iln-\[)rov('Jll( ; ii ( ; iltexet : tl ( ; ionl ; ilneov ( ~ ranaivo , i Hl-ph ; mo , ntation . 
1 INTRODUCTION
The , need for (; flicien (; parsing is a (: onsta , n (; one in Natural Langmtge , Pro('cssing . With the ad-vo , n ; ( ) ffea (; ur (> l ; he , ore (; i (: gratmn ; ti's , In ; my of (; he optimization te (: hniqu(' , s that w (; rea , pi)li(:a-bh ; to ContextFree(CI")grammnrshaver ( ; - ( tuir cdmo(titi(:ation . For insl ; an (:( ~ , ~mlml ) ( ~ r of algorithms used (; oex(;ra , (: Lp ; ~ rsing l ; a ~ bl ( ~ , q f l ' om CF grammars have involved ( list : at ( ling in form ~ t (  ; i on which ol ; h(' , r w is c , would have con-strain (' dtim parsing pro('ess , ( Brisco (; and Carroll ,  19!)3) . Thist ) ap(' , rdes ( :rib ( ~s an extension to an algorithm that ( ) pe , r ~ L(;('~s over CF gram-nmr to make , it at ) pli(:M ) h;t of (' , atur(' , -th(;oretic () lieS . One advantage of th ('~( ; x ( ; en(h ~ dMgo-rithmis ( ; ha ? it , i)r ( ; serves ~ ts much of l ; hcin-fOrlnalAon in ( ; h(!graininarasI ) ossibh ;  . 
\ [ norder to make more t , ,\[\[icient parsers , it ; is SO ln (; gimt ' , snecessary(;opr(; process((:Olnl)ih ;) agra , i l l l B a , r1; oext ; ra , c ( ; \]' romit ;  ( ; o\[)-down in for lrm-~ion ( ; oguide ( ; h ( ; s( ; mr : h during analysi . q . Tim\[irs(;sl;(;pinI ; ho , prel ) ro (: essing stage of several ( ; omi / ilal ; i on algorithms requires ( ; h ( ; so hl-tion of ( ; wo\['un(' , tions normally (: al\]e(lFII , ST and F()\]AA)W . Intui (; iv (~ ly , lrIILS'T ( X ) gives us(; h(;(;(' , rmin a , lsymbols(; may app(;n rinhfil , i alposi ( ; i ou in substrings de , riv(;(I froiD , c;L ; (~- gory X . FOLLOW ( X ) gives us ( ; Ira ( ; c'rminals whi (: hmayimm ( ; dia , t(;ly follow as u ) string o1'(:~(; e , gory X . For ( , ~ xami ) lc , inl ; h(;gra , mmar S > NI'VP ; NP->(lel ; II(tltlI ; VP--vtraNP , wcgo(;:l~'H~sr(s')-v'lies'-r(N/ , )-: ( J , c  ~ , , v~llc , s ' ~ r(yl ,  ) -  , , , ~ , , ,  . .,,
FOI . I . 0W ( A  ~ , ') : ,, ~ , , . ,,,, ml , mw(s')-t,~01~l~(~p ~,,( V ~,) .  (  , ($ markstrod of input , ) Th(;so , (; worunc (; bmLs a , t : (~ hnpc , rtan ; in a \] a , rgo , l ' il , II ~( ~ .   ( ) f a lgor i thms used for construct ing el'-licit ; n ( ; l ) arse x s . For ex ; m q ) let h(; l , I-tmrse , rconst , rll(stion algorithm given in ( A hoc'tal . , 1986 ) : 232 uses FIRST to ( ' omt ) ute item do-SllI' (  ~ , va , hles . AIm ( ; h(~r examph ; is ( ; h ' ~ t:ompu-( ; a tion of the /* rela , tion whit : his used in timc(mstru('(;ion of go , nt ; ralize , (1left-(:orn(~r parsers , ( N(;d crhof ,  \] !)9:) ;  ( ; his relation is et l ' ct : tiv cly ~ mex ( ; ensi(moft ; h ( ; funt : ( ; i on FIRST . 
8752 COMPUTING FIRSTAND

We propose an algorithm : \[ or the computation of FIRST values which handles feature-theoretic grammars without having to extract a CF backbone from the ln  ; the approach is easily adapted to compute F ( )LLOW values too . 
An improvement to the algorithln in presented towards the end of ' the pat  ) er . Betbre describing the algorithm , we give a wellknown procedure for coinputing F IRST for CF grammars  ( taken from ( Aho et al ,  1986):1189 , where e is the empty string ) : " rioconlpute FIRST ( X ) for all grammar symbols X , apply the following rules until no more terminals ore can be added to ally FIRST set :  . 
1. If Xisterufinal , then FIRST(X ) is X.
2 . If X-+e is a production , then addetom ~ ST(X ) . 
3 . If X is nonterminal and X--~Y1Y , 2 . . . Y  ~ isa . production , then place a in FI . I? , ST(X ) if \[' or some i , a is in FIR , ST(Yi ) , and e is in all of F1RST ( YI ) . . . FIRST(Yi_:I ); that is , Yt . . . Y/I ~ e . If e is in F\[12, ST(Yj ) for all j = 1, 2, . . . , k , then addeto FIRST(X ) . 
Now , we can compui ; eFIRSTt : brany string XIX . e . . . Xuast bllows . Add to FIRST ( XIX2 . . . X ~ z ) all of the non-esym bols of I , ' II ? . ST ( X , ) . Also add the non-esym bols of 1,'I . BST '( X , 2) ire is in . FI . RST(X t ) , the non-esym bols of P ' llST ( X a ) if e is in both t , 'IH . ST(X ,) and F1RS fl'(X2), and so on . Finally , add ~ to FIH . ST(XIX . e . . . X , ~) if , tbralli , FIH , ST(Xi ) contains e . " This algorithln will fbrm the basis of our proposal  . 
3 COMPILING FEATURE-
THEORETICC ~ RAMMARS 3 . 1EQUIVAI , ENCECLASSES The inain reason why the al ) ove algorithm can-uol : be used with li ~ al , ure-theoi'etic grammars is that in general the number of possibh  ; nonterminals allowed by the gralnmar is intinit ~ e  . One of the simplest ways of showing this is where a grammar accumulates the orthographic representation of its terminals as one of its feature values  , it is not difficult to see how one can have an infinitemml ber of NPs in such a granl In ar : 
NP\[orth:the(log1
NP\[orth : the fatclog\]
NP\[orth : the big Nt dog\], etc.
This means that l ~' Ii ~ ST ( NP\[orth : the ( to g\] ) would have a different value to FllLgT ( NP\[orth : the fat dog\] ) even though they share the same left ; mosterminal . That is , : tieilia-ture structure for the substring " det adj noun " will be different to that for " det noun " ewm though they have tile same starting symbol  . 
This point is important since similar situations arise with the subcategorization frame of verbs and the selnan  (  ; ic value of categories in contemporary theories of grammar  , ( Pollard and Sag ,  1992) . Without modification , the algo-rithm above would not terminate . 
The so hltion to this problem is to define a finite number of equivalence classes into which the in finite uumber of n nnterminals in ay be sorted  . ' Fhese (' , lasses may be established in a number of ways ; the one we have adopted in that presented by ( Harrison and Ellison , \]992) which builds onl ; he work of ( Shieber , 1985): it introduces the nol ; ion of a negative restrictor to define equivalence classes  . In this solution a predefined portion of a category  ( a specific set of paths ) is discarded when determining whether a category belongs to an equivalence  ( : lass or not . For instance , in the above example we could define the negative restrictor to be orth  . Applying this negative restriet or to each of the three NPs abow ~' would discard the infbrmation in the % rth ' feature t  , ogive us three cquiwflen I ; nonterminals . It , is clear that the restrictor must be such that it discards features which in one way or another giverise I  ; o an infinil ; emunl ) erofnOlfl ; erminals . Unl ' ortu-nately , terlnination in not guaranteed for all restrict ; or s , and \[' llrl ; her more , the , best restric-tOl'CalUIOt ; l ) e chosen automatically since it depends on the amount of grammatical information I  ; hatist ; obe preserved . Thus , selection parti (: ub ~ r grammar or system used . 
3.2 VA\]A)ESIIAR . ING
A no (; her prol ) lelnwil ; h the Mgo , : il ; hm Moove isl ; ha . t , ree . ntranci(:sbel;w(:ena . category a )\[( titsIqll . ST a . ndF ( ) I , I , ( ) W values are n ( )( . t ) reserved in the so hition to ( ; heset ' unct ; iollS ; this is because ( healgoril ; hlu assume sal ; omic syml ) ols and / ; heseca , m ~ oten code ( ~ xI ) licil Jy , ~ ha , redin-f()rmation l ) et we(;l~c~t(;t:gories , l ' brexample , cousid (: r the\[o I lowing ha , iregra , mnm , r :
S ::> Ne\[a.gr:X\]V Pa.gr:X\]
VP\[agr:X\]~>Vint\[a , gr:X\]
NP\[~,gr:X\]-5Det N\[a.gr:X\]
We would like l , h(:solul;i(m of I , 'OLLOW(N ) t()in(:h\]del ; h(:l ) in(lingo\[the'ag\]"f(:a , tureSllcht ; ha(;(;heva . hl(:ofF ( ) IA , () W , '( ~ s( , ml ) h:d::x\])::x\] . 
(: hea . lgoril ; hmabove , evenwi(;ha . r(:s(;ri(:t;or , would nol , prese ) ' ve such at l ) in diug siuce the a , dditi(m of a new ca , t('~go)'y to I , ' OLLOW(N ) is don(' , indel ) e . nd(' , utly of the bindings\[)(; l:w (' , (' , n (; he new (: a , i : egory ~ tlutN . 
4 Tile BASICAI , QOI . ITHM
Wel ) rOpose an algorithm which , rather than cousl ; ru (: ; a set ; of categories as ( ; \[ t(~vah\]e of l , 'II1 . S " l'a . ndF()M,()W,<:onstru(:(;sa . set of pairs each of which represeuts a (: M ; egory and its FIRSTovF ( ) I , LOW category , with all the (: or-rect biudings exp\]i (: it ; ly encoded . For instant (:, for l ; hea . hove(:xa . iill ) l(L ( , he pair ( Vl >\[ agr:X\] , Vint\[agr:X\])wouldt)einl ; ho . set r ( , pres(:nting the vMue()f (; heflll(:I ; Joll FII . ST . Inth(~uext section the a . lgorithm for (: Ol Uf ) ul ; ilu LFIll . ST is d(:s (: ril)(, . ( l ; (: ompul ; a . l;io:t)oi'F () I~\] , () Wt > ro(:(~e(ls in a similar l'a shion . 
4.1 SO \], VIN(;FI . IZSq ?
When modifying the a . lg or it ; hm of Section 2 w (' not e1; ha . l ; (: a . cho(:(:mren(:(:o\['a . (: al ; eg () ryiu (; he grammar is pol ; e . n(>ia . lly < list ; in (' . (;\[' rome v-(:1'3, o(; her(:a . Le . gory . \])1 add it ; iou , l () reach cat , c-gory we nee ( I ; or (: memb(u ' a , ll there entrmt cies between it aud the da , ughterswi (; hin the rule ill which i ( ; oc . (: ltrs . Finally , we assmne that any ca , tegory hia , rule which c~munify with a lexica . 1 category is marked in some way , say by using the t'e~ture-wth lepair'l ; er :+' , and I ; ha . l . llOtl-(;(!rttlilla . lcaJx;gori ( , sIIIllS ; ll ni \ [ y with the tool ; hero\['~ome rule in the grammar ; the latter con(lit ; ionisne ( : essaxy he ( : ause the Mgo ~ rithmonly c ( mllmLes the solutiou of FIll . ST\[or h:xi(:a,l(:a . lx : gories in ' for (: a?egoriest Jml ; occur as mot , hers . 
\] ncorn\]rot ; in ~ I ql . g ' rw('i ( , era . l ; e over ~1\[; he rulesillt ; h(!gF;LIHHI&I' , (; re . al;ingt , hei\[loi;h(' . l ' O\[each rule as the category fl ) r which wem'e (  ; ry-ing ( , olinda FIll . STw due . Throughout each i(x ~ ral:ion , unific ~ l;ion of a , ( la . ugh( ; er with timlhs of a neh : Inento\[lqlST resul ( ; sina . modified rule and ~ modified pnir in which bindings be-  (  ; ween the mot ; her category mM the ) ' hso\[the pair are(~si ; a , lf lisl md . The modi\[iedmot ; her aim rhs are\[; h(' . tll , q(:(l ( , o(:o , lH (; rtl(:l;I , ho1air which is added to F\[\]ST . l ) ' or iusta . nce , giwm rule X -> ~" ~ u , dpair ( L , l ~) , w ( ! unifyY and Ltot<iw:X'-7 , and ( I7 , 1); DO ln these the pair ( X' , l~t ) is COllSl , t'llc:l ; cd~tll(added1 , o \] I ~ , S\[ . 
The algorith\]na.ssumes a nop('ra?ion-I-~.
which (: ons L rll (: l; . qa . sel;H'-- , 5' - <7 / ) ill the lbl-lowing w~Lv:i \[ pair psul ) smues an element ; a of 5 then S ' = , ff-o , fl-p ; if p is subsulned I ) y an ( Qement of , % ~( ; hen3 ; ' ~= , %'; else S'- , S ) p . 1(; should b(' . uol ; ed ( ; trot the pairs col > stitul ; h ~ g the w flue of li ' II . ST can themselw ~ sl ) (: comlm . red using the subsumption relation in whid ~ reeIll  ; ran ( ; wdu ( ; sa . resu\[),'-; ulIcled by non-r (: (: lll ; ra . ti1 ; o Ilcs ~3AI ( \[ combined using the uni\[i-cationolm ration . Thus in the pl ' in (: ipal step of the a . l ~; or ithm , a . new \] miris constructed ; is described above , ~ restrictov is applied to i ( ; , a . nd the resulting , resl ; ricted pair is +<- added to FIRST . ' Phea . lgorithm is a . s follows : \] . \[ nitia , iiset " i'r , sl, .  ~  . 
2 . l  ~ , unthrough aJ1 the da , ughgers in Lhegramma , r . If X is pre-t ; erlninal : then fci , ~ . , ~ t:-Fi , ~ . , ~ tI <( X,X ) N , ( whore(X , X )! q > meaus a . pply the nega . tiw : re . -, % ri (: tor(P ( x ) l~he . ira , it(X , X)) . 
3. For each rule in the grammar with mother

VP\[agr:X , slash:Y\]
NP\[agr:X , slash:NULL\]
NP\[slash:NP\]=>NP\[agr:X , slash:NULI , \] VP\[agr:X , slash:NULL\]NP\[slash:NULL\]NP\[agr:X , slash:NULL\]VP\[agr:X , slash:NP\]=>Vtra\[agr:X , ter:+\]Ne\[slash:Y\]-~Det\[ter:+\]N\ [ ag  , ': X , ter : ? . \]=>- e Figure 1: Example grammar with value sharing . 
X , apply steps 4 and 5 until no more changes are made to First . 
4. If the rule is X-+e , then First =
First+<(X , e ) ! e ~ .
5 . if the rule is X-+V , . .Y~ . .Yk , then F i rs t = F i r s t +~ ( X ', a)l(I ) . if ' ~( Y'i , a ) has success-fl fly unified with an eleinent of F irst  , and (~ , , e ,  ) . . .  (~% , ei_~ ) have all successfully and simultaneously unified with members of First  . Also , First = First+<(X' , e)\[(l~if(Y ( , e ~) . . . ( Y\[,e ~) haw ~ . all suc ( : essfully and simultaneously unified with elements of lvir '  , vt . 
6 . Now , for any string of categories Xl . . X~ . .X ,~, F i r s t = F i rs t +< ( X', . . . X\[ , , , a ) !( I ) if ( X ~ , a ) has sueeess flfly unified with an element of Fi rst  , and a fe . Also , for i--2 .   .   . n , Fir . s t = t " i r's t+<(X ~ .   .   . X n , a ) ! q ) if ( X' , a ) has suce ess fiflly unified with an eMnent of Fi rst  , a ~ e , and ( X  ~ , e ,  ) . . . ( X ~_ l , ci1 ) have all sue eess fidly and simultaneously unified with members of First  . Finally , First = First + <( Xf . . . X , ' ~ , ?)!( I ' if(X ', , e,) .   .   . ( X  ~ ,  % ) have all suecessflfly and simultaneously unified with members of First  . ( This step may be eomtmted on demand ) . 
() no observation on this algorithm is in order.
Tim last ; action of steps 5 and 6 add seasal ) ossible w fiue of FIIST for a mother category or a . string of categories ; such a w flue results when all daughters or categories have e as their  FII2  . ST value . Since most grammatical descriptions assign a category to e  ( e . g . to bind on to it information ecessary for correct gap threading  )  , the . pairs ( X ',-) or ( X\[ . . . X . \[~ ,  ? ) should have bindings between their two elements ; this creates the problem of deciding which of the cs in the FIRST pairs to use  , since it ; is possi-t ) lein principle that each of these will have a difl : erent value for  (  . In our irnplement a-tion , the pair added to First in these situations consists of ' the mother category or the string of categories and the most general category for e as defined by the grammar  , thus et-fectively ignoring any bindings that e may have within the constructed pair  . A more accurate solution would have been to compute multiple pairs with c  , construct their least upper bound , and then add this to First . However , in our implementation this solution has not t ) roven necessary . 
4.2 EXAMPLE
Assuming the grammm : in Fig . 1 and the negative restriet or (\]) = slash , the following is a simplified run through the algorithm : ?~'  , : r . ~ t = ? After processing a . ll in ' e-terminal categories Fir , st-(Dot , Dct ) , ( N , N ) , ( Vt'ra , Vtra ) ( obvious bindings not shown ) . 
* After I ; he first iteration First = ( Det , De . t ) , ( N , N ) , ( W , ra , Vt , ' , *) , (VP , , , r , ": X\] , W ' , '~+ , ,: , ": xJ ) , ( NIP . . Wt ), ( NI5 ~) * Since ~ slash ' is in ( . 1 , any of the NPs in the grammar will unit ) with the lhs of ( NP , e ) and hence S will have V tra as part of its FIRSTw ~lue  . .rir,t = . . , ( Vl'\[o , , , ': X\] , Wra\[a , ," : X \]) , ( NP , Det ) , ( NP , e ) , ( S , De , t ) , ( S , Vtra ) ? The next iteration adds nothing and the first stage of the algorithm tern tinates  . 
The second stage ( step 6) is done on demand , for example to eomtm te state transitions for a parsing table  , in order to avoid the expense of colntmting FIRST for all possible substrings of categories  . For instance , to compute FIlq , ST for the string\[NPNP VP\] the algorithm wo , 'ks as follows: ( N ? After considering the firsl , NP : t , ' i ' rsl ,  -:  . ., ( f ro ' NIP Vr \], D~:t) . 
?(3onsi(l('a:~fl ; ionf1;11(, . sc(:ondNI ) in I ; h('~inputs l , ringrcsul(;sinno(:ha . uges to t,'iv . , d . , given the s (> manl;i(:s of - < , s in (: et impair l ; lutl ; il ; wouhl have , , Sin (-(; Nf's can rcwri (;(~ as < ( i . (' , ( NI ' , ( ) is in\[;"i' , '>; l , ) , l ' " i'v , ' ~ l ,  : :  . ., (\[ N \[' . N\]'V\["\],I)e . f ) , (\[ Nrm'vr\] , ? Finally , (\[ NI'NP VI'\] , c)ma , ynott ) eadded since(VI' , () does nol ; unif ~ y wil ; h ; my clemett ( , of Fir'sl ,  . 
5 IMPROVING THE SEARCH
THI/,OUCdtFiTst1\[(;hea . lgoril ; hmisr,ma,st)r(;s(;nt(~(l , ea . (: hil:-erationI ; hrough l ; hagram unar rules lm(:() messlow ( ; ra , ndsl(-)w(;I ' . The r (' . a , sonis(;\]l ~: tl ;> iHsl ; e\[)5 , when s t ! a , r (: hingl " i ' rst to cr (: a t ( , a new Imir(X' , o , ) , every 1) a , irinl , ' i ' rsl , ix cousi(h ; red and unilical , ion of its lhs with the relevan L daughter of , V ~( ; teml ) l , (' xl . Sin(:(;en(:lLi ( , ( ~ raLionn()rmMlyaddspah's to Fi' , ' stca . oh i ( ; ( , r~t ; ion involves as ( mr ' (: hI ; hrough a larger ~ t\[l(l largers (' . (;; fm-(;hertm)re , (; his search involves ut filic ~ rt ; ion , a . nd in the case of a . su(:(:(;ssful match , t i t ( ; subsequent ;   ( : ( instruction and a ( l ( tition to Fi ' rstalsor ( 'quir ( : ssul ) sumption che ( : ks . All ( ) f t ; heseOl ) - erations (: olnbine ( ; omakeea . t : ha(hlit it ) nalele-m ( ; nl ; in 1/i ' rsl , lu ~ ve ~ v strong effect , on the per--\[brma , nceo\[(; he Mgorithm . \ Ve(;h(~rel'orene(, . d ( ; ommil nize (; he number of pairs searched . 
C(msi(h , ring thed (: t ) (' nd ( , nci(!s that exist t )(> L wee , u pairs in Fivsl , one nol ; iccs ( ; lust ; once a pair has been consi(ter ( Minrela (: ion wit ; ha , llI ; hcrlllcs in the graln nlaa ' , I ; heef l'(~cl ; of thai , l ); rir has ) eeu COml ) h;l ; ( ; lyd cterm in (' . (\[ . Thai ; is , a . ft(;ra , pair is added to Fi'r>d,i(n (> . donly I >( ,(: on sidcr(:duI )( ; o a . ndint ; luding ( he rule frOIll which it was d(wivo . d , aft ; ev which time it ; maylm excluded from fl ~ r tho . rse ; trches . For exa . m~t > le , ta . keth (: previous gra . Ill Iiii-lr , a . ll dilt pa . rtic-ul;n'(:h('~va . hw of l /' irsl , a\['l ; o . r1 ; \]l (' ~ firstil ; ei'~t ; i on throughth (: algorithl n . '\[' helmir(NI ) , l)c , t ) , a , ddedIwca , use of l ; hcrifle NP\[~gr:X , slash:NUI3~\]-~DeL\[tm:+\]N\[a . gr : . X , Ix : r :+\], ha . sI ; ( ) Im(:onsi(lered only once by every ruh ' , in the gram-max ; M't , erthai; , this I ) a . ircmmothc involved in l ; he (' . on sl , ru (: tion of new values . 
Asiml)le data . stru (' . ture which keel ) sI ; rack of thos(!pairs ( ; hat ; n ( ; ed to be sear (: hcda . ( , anyone tim(; was added 1; othe Mg or il , hm ; the ( la . taS(;I't lC(;III'(~l , ookl ; hcl'()l'l\[lo\['~list of l ) oin( ; ersI ; o a . cl : ivep a . irsit)l,"i'rst,whel:(~m , a . (' . l ; ivc pair is one which hast ~ o(:linen (: ( ) nsid ( , redl ) y the rule from which il ; was c . ( mst ; ru(:t(M . For exa . ml > l(h the pair ( NP , I ) ( t ) would 1) (' . a . (' . l ; ive for a com-l)le(x ~ it ( , ral ; ionl ' vom the moment tim ( > the cot--responding rule in (  , roduc . edi L until that rule is visited again ( hiring ( ; he second it ( u ' ~ ti(m . The effe(:t of this policy is ( ; o allow eaclt pair in l ; ' i ' rsl , to be ( ; este ( l against each ) ' ul ( ~ exa ( : l:lyOlI ( : ( : a , ll(\[( ; hell \] ) eex ( : lu ( led\['rolilslll ) st~ ( lllell (  ; s(:ar('h(:s ; this g ) ' ea . ( ; lyr ( ~ ( lu ( : ( ! sth ( : mtml ) er ( > I'pairs considered for ca , dril ; era ( , ion . 
Usin/~;th(''t'y t>e<ll "(, a . l;ureSt ; ru < : l;m'es ysl:(!m(tit <, . LKI \]) of ( lh . is <:< mel , al . , 1993) , we wrole two gr~mmmrs and ( ; esl ; ( ; dl ; h(:algoril ; hm onl ; h(~t t l . ' l " a . ble1 shows the average llll Ill CI'Of'pairsc ( mside ) ' ( ~ dforcad1i (  ; (:rat ; ion(-ompa . r ( : ( lI;o(;h(~a . vera . gemtmber of pairs in l,'i'rst . 
\[13Ihfl ! Grammar I21 Rule( , rmnmar \]( , ' on ~\] d , ~ , \]~d % (: ~ , 1 ( , , ,  . 's ,) h,~,(~,\]\[:coL~L1\]) 271-i) . 7\[u : 7-\]2E) . o\]_A;qLupoTabl(;f : Averagemmflmr of 1) a . irs per iteral ; ion . 
As we ca . nsee . , ah;er the first iteral;ion Lhe mmflw , r of l mirsI ; h ~ r t needs to be considered is lnss ( lnltch h . ' , sst()iLhcfinal iteration ) thaut , hel;o Lalml ) ero\[pfirsinI <' i'rsl ,  . Similar im-I ) rOV(mW nl ; sinper\['ormance were obga . ined for the (: Oml ) Ul ; ation of F()I , IX ) W . 
6\[~iEI , ATEDR , ESEARCH ~ l'heexl , eusion to the 1 , 1al~gorit , hn ~ presenlx ~ d by ( Na , ka , za , wa , 1991) uses a , similar a 4) proa , cht ; oLhaL dea ' , rilm dhere ; the\['undsions in w ) lwMhOWCV tW , ~ LI'(!I ; h()s(~\[l(~CCSS/ , / , l'y\['()1'\[ ; h ( ;  / ; OllSLI ' llC-( ; ion of an/Jpa . rsing t ; al)le(i . e . the GOTO and A(YI'I()N funcl;i(ms ) . One technica . l(litt uses positive restrictors , ( Shieber ,  1985) , instead of negative ones . In addition , both of his algorithms also differ in another way from the algorithm described here  . The difference is that they add items to a set using simple set addition whereas in the algorithm of Section  4  . 1 we add elements using the operator + < . Furthermore , when computing the closure of a set of items , both of the algorithms there ignore the effect that unification has on the categories in the rules  . 
For example , the states of an LR parser are computed using the closure operation on a set I of dotted rules or items  . In Nakazawa's algorithms computation of this closure proceeds as follows : if dotted rule < A ~" w  . Bz > is in I , then add a dotted rule < C -+ . y > to the closure of I , where C and B unify . This ignores the fact that both dotted rules may be modified after unif cation  , and therefore , his algorithm leads to less restricted \[ values than those implicit in the grammar  . To adapt our algorithm to the computation of the closure of I for a feature-theoretic grammar would involve using a set of pairs of dotted rules as the value of I  . 
7 CONCLUSION
We have extended an algorithm that manipulates CF grammars to allow it to handle feature-theoretic ones  . It was shown how most of the information contained in the grammar rules may be preserved by using a set of pairs as the value of a function and by using the notion of subsumption to update this set  . Although the algorithm has in fact been used to adapt the constraint propagation algorithm of  ( Brew , 1992) to phrase structure grammars , the basic idea should be applicable to the rest of the flmctions needed for constructing LR tables  . 
However , such adaptations are left ; as a topic for future research . 
Finally , improvements in speed obtained with the active pairs mechanism of Section  5 are of an order of magnitude in an implementation using Common Lisp  . 

This work was funded by the UKSERC . I am very grate flfl to Ted Briscoe , John Carroll , Mark-Jan Nederhof , Ann Copestake and two anonymous reviewers . All remaining errors are mine . 

Aho , A . V . , R . Sethi , and J . D . Ullman , (1986) . 
Compilers-Principles , Techniques , and Tools.
Addison-Wesley Publishing Company , Reading , MA.
Brew , C . , (1992) . Letting the cat ; out of the bag : Generation for Shake-and-Bake MT  . In COLING-92, pages 610-616, Nantes , l~-ance . 
Briscoe , E . and J . Carroll , (1993) . Generalised Probabilistic LR Parsing of Natural Language  ( Corpora ) with Unification-Based Grammars . 
Computational Linguistics , 19(1):2560.
Briscoe , E . , A . Copestake and V . de Paiva ( eds ) . 
(1993). Inheritance , D@ults and the Lexicon.
Cambridge University Press , Cambridge , UK.
Harrison , S . P . and T . M . Ellison , (1992) . Restriction and \[\[ L'rmination in Parsing with Feature-Theoretic Grmmnars  . Computational
Linguistics , 18(4):519-530.
Nakazawa , T . , (1 . 991) . An Extended LR Parsing Algorithm for Grammars using Feature-Based Syntactic Categories  . In Proceedings European ACL 91 , pages 69--74 , Berlin , Germany . 
Nederhof , M . , (1993) . Generalized Left-Corner Parsing . In Proceedinos European ACL93 , pages 305-314 , Utrecht , The Netherlands . 
Pollard , C . and I . Sag , (1992).
Phrase Structure Grammar.
sity Press , IL.
Head Driven
Chicago Univer-
Shieber , S . M . , (1985) . Using Restriction to Ex-tend Parsing Algorithms for Complex-Feature-Based Formalisms  . In Proceedings ACL85 , pages 145-152 , Chicago , IL . 

