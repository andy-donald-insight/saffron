A Karaka Based Approach to Parsing of Indian Languages 
Akshar Bharati Rajeev Sangal
Department of Computer Science and Engineering
indian Institute of Technology Kanpur
Kanpur 208016 India

A karakabased & i ) pro , ' ~ cl ' ~ for't ) , xYsng of\[nc/ian languages is described . I ~ has been used for , building a parse L ' of t tindi for a prototype Machine Translation system  . 
Alex . \[ ca\] . \[ sodgt ' & mlnaF formalism has been deve loped that a \]  . lov as constraints to be specified between ' demand ' ~ and ' source ' ~  ; or ' ds(e . g . , between verb and its karaka roles ) . The parser has two important novel features : ( . \[ ) It has a local word grouping phase in uhich wot"dgr ' oups are formed using ' local'in -for-marion on l ~ ~  . They are formed based on finite state mach in especifications thu ~ resulting in a fas~t grouper  . ( ii ) The parser . 
is a general constraint : ~ o \] ver . It first transforms the con-str ' aints to ~ n integer programming pr  . ob\]em and then solves it . 
i . Introduction
Languages belonging % othe Indian linguist icareasha Feseveral common features  . They are relatively wor . dorder free , nominals are inflected or-have postpo::it ion case markers  ( collectively called as having vibhakti )   , have verb complexes consisting of sequences of verbs  ( possibly joined together into a single word  )   , etc . There ar'e also com-monal \] ties in vocabu lory  , in senses spanned by a ~4ord in one language to those of its counterpart in another Indian language  , etc . 
We base our grammar on the karaka ( pronounced kaarak ) structure . It is necessary to mention that although ka Fakas are thought of as similar to c ! ~  , ' os , ~~ y ? , r ' of uDd ; ) mer~t : . a \]\] y , 7! ffei'e ~\] + . : : " The pivotal categories of " the ~ bstL' act syntactic Fepresentation are the karakas  , the grammarica \] functions as ~ signed to nominals in relation to the ? verbal root  . Theyar'ene\]ther'se-manticnol . " morphological categories in themselves but cor'r'espond to semant cs according to r'u \]  . es specified in the grammar ' and tomor . phology according to other rules specified in the grammar  . "\[ Kip & rsky , 82\] . 
Before describing our grammar formal-ism , let us look at % he parser struc . - t t l P e "+ .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +
Ikaraka chart & I . . . .
Ilakshancharts\] . )  . . . . . . . . . . . . . . . . . . . . . . . . . . + sentence
V + . . . . . . . . . . . . . . . . . . . . + +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . +lactive lexiconl -> I morphological I
I\]I analyzer I . . . . . . . . . . . . . . . . . . . . . . + +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +
I lexical I entries .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  ~ +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + I verb form chart l --> l local word grouper l  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . r + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +
I word I groups
I+................'
I core par , set I + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . +lv intermediate representation Function of the mor'phological analyzer is to take each word in the input sentence and extract its root and other associated grammatical info rmation  . This information for , ms the input to the local word grouper ( LWG ) . 
1252. Local Word Grouper ( LWG)
The function of this block is to form the word groups on the basis of the ' local info rmation '  ( i . e .   , information based on adjacent words ) which will need no revision later on . This implies that wheneve ~ there is a possib ility of more than one grouping for some word  , they will not be grouped together by the LWG . 
This block has been introduced to reduce the load on the core parser resulting in inc reased efficiency and simplicity of the overall system  . 
The following example illustrates the job done by the LWG  . In the fol-lowing sentence in Hindi : l a dake adhya pakko haarpaha nara hehein boys teacher to garl and garland-ing  ( Boys are garlanding the teacher .   ) the output corresponding to the word ' ladake ' for-msone unit  , wo~ds'adhyapak'and'ko'form the next uni t  , similarly ' pahana ' , ' ~ ahe ' and ' hein'will fo~m the last uni t  . 
3. Come Parser
The function of the core parser is to accept the input from LUG and produce an ' intermediate language ' representation  ( i . eparsed structure along with the ident if ied karaka role  , ~;) of the given source language sentence . 
The core parser has to perfo~-messential-ly two kinds of tasks l  ) karaka ~ ole assignment tom verbs2 ) sense disambiguation for verbs and nouns ~ espectively  . 
For translating ~ monglhdian languages , assignment of karaka roles \[ s suffic i ent  . 
One need not do the semantic r , ole assign-ment after the ka Fakaass ignment  . 
Let us now look at the grammar.
3.1 Grammar Formalism
The notion of karaka * rel ~ tion is .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
* Here , we use the word ' kar , aka ' in an extended sense which includes ' hetu '  , ' ta-darthya'etc . in addition to actual kara-kas . 
central to the model . These are semantico-syntactic relations between the ve ~' b  ( s ) and the nominals in a sentence . The computational gTammar specifies a mapp ing from the nominals and the verb  ( s ) in a sentence to kara-kar ' elations between them  . Similarly , other rules of grammar provide a mapping f rom karaka ~ elations to  ( deep ) seman-tic relations between the verb ( s ) and the nominals . Thus , the karaka rela--tions by themselves do not g ive the se-mantics  . They specify relations which mediate between vibhaktiof nominals and verb form on one hand and semantic\['elations on the o the r\[Bharati  , 
Chaitanya , Sangal , 90\].
For each verb , for one of its forms called as basic , there is ~ a default karaka chart . The default karak chart specifies a mapp ing from vibhakf is to karakas when that verb -form is used in a sentence  .   ( Karaka chart has additional information besides vibhaktipertaining to ' yogyata ' of the nominals  . This serves to reduce the possible parses . Yogy at a gives the semantic type that must be sa -tisfied by the word group that serves in the kamaka role  .   ) When a verb-form other than the basic occurs in a sentence  , the applicable karaka chart is obtained by taking the default karaka chart and trans forming it using the verb type and its form  . 
The new karaka chart defines the mapping from vibhaktito kanaka relations for the sentence  . Thus , for example , ' jotata hat ' ( ploughs ) in A . I has the default karaka chart which says that karts takes no pars arg  ( Ram )  . However , for ' jots ' ( ploughed ) in A . 2, or A . 4 , the karaka chart is transformed so that the karts takes the vibhakti'ne''ko' s e ~  , 
A . I Ramkhetko jotatahai.
Ramfarm ko-pars arg plough-s.
( Ramp lough shis farm .)
A.2 Ramnekhetkojots.
Ramne-farm ko-ploughed.
( Ramp loughed the farm .)
A.3 Ramkokhetjotanapada.
Ramko-farm plough had-to.
( Ram had to plough the farmo ) 262 ? ~4~ ~ , ~ , , "- ~ ( /
G-->L c ~ lv___q .
S ~ % /' . ' ~" e .   .   .   . /C <" c4, . ~_=""' e .  , ' - / , ;  .  ,
Chart Fig . 3: Lakshan for Jota
Finally , besides the merged kay-aka charts associa ted with individual verbs  , there is also a global table of common k & rakas  . It pertains to ad hi karana karaka(i ; imear id place ) , hetu ( cause ) , etc . and is applicable to all the verbs . It can be u ; \] ed to account for . source ~ ord groups that remain aftersa-t is f ~/  . ing them and a to--ry karakas . In this sense , it only con-i&ins optional karakas . 
3.3 Parsing
For the task of karaka assignment , the core parser uses the fundamental princip leof'a kanksha '  ( demand unit ) and ' yogyata ' ( qualification of the sou ~: ce unit )   . 
The \] inguiatic units which playt hero le of demand and source word groups can vary depending on the parse cycle  . 
In the case of simple sentences , only or lecycle is needed in which verb groups and some special noun groups  ( e . g . 
' i > a as ' ( near ), ' door ' ( far ) etc . ) pllly the role of demand ~ or ( l groups , and noun groups and predicative adjectives p lay the role of source word groups  , During the parsing process , each of the source word groups may be tested a ~9 . a inst each of the karakar . estrictions in each of the k~x raka charts of the demand word groups  . An appropriate data structure ma~becl . eated storing the sour-reword groups and the kar  . ak restric-tions ( in karats charts of demand groups ) they satisfy , l~ecall each such entr'y as a candidate var iable  . 
Typ\[('el\] . g , a number of source word groups will qualify for a par-t : iculil r-<lem ~ nd  . The job of the core parse F is to make an appropr iate assign-merit of the candidates  , subject to cer-tain constraints such as the following : I  ) one c and . dates our ' reword group cannot satisfy more than or le demand of the same demand word  . 
2 ) every obligatory demand must be satis-fied in some karaka chart of every demand word group  . 
3) every source word must have an assign-ment.
4 ) if more than one interpretation of a source word is available  , then exactly one has to be selected . 
Tile above problem is transformed to an in teger programming problem  . Assigning 1 to a candidate variable means that the part i cular karaka relation between the source word group and the demand word group holds  ; 0 stands for otherwise . All the various types of constraints men-t ioned above can be specified in a very natura l manner using algebraic in equali-ties in integer programming  . Having a set of candidate variables assigned to I not only identifies the karakarelat ions which can be used to get the deep cases  , but also identifies the karaka chart which serves to identify the sense of the verb group  , etc . 
Moreover Integer ' programming also permits a lingust to express prefer-ences among var ious candidates for a particular demand  . A typical example of such a preference can be given  . For . example , for most of the verbs an animate thing is more likely to be the karts than inanimate th ings  , and among an i-mate ~ human beings are more l ikely c and l-date : ~  ; to b : , karts than nonhuman candi-dates . These preferences would simply order the mul tiple parses if an ~ in the absence of other information  . 
The parsing strategy actually adopted in the system makes use of the merged kar'aka chart and corresponds to Anvit-Abhidhan vad  , a theory of mimams a school of the Indian grammatical it-edition  . In this approach , we first determine the karaka relations h ips among the demand and source ~ ord groups  . ( These are determined 327
A.4 Ramsekhet nahiiota gaya.
Ramse-farm not plough could.
( Ram could not plough the farm .)
The above principle allows us to deal with active passives  . The verb forms for active and passive are just two special cases of the forms a verb can take  . 
For example , the verb ' iota ' in Hindi has four different meanings listed in the dictionary : I  ) harness ( e . g . , Ram ne bail ko ko lhu me iota , or Ramharnessed the bullock for ( turning ) the crusher . ) 2) hitching the cart ( e . g . , Ram ne gaadi i ko iota , or R am hitched the art . )3) plough(e . g . , Ram ne jamindar ka khet iota , or Ramp loughed the landlord's farm . ')4) exploit ( e . g . , Ram ne naukar ko kaam me iota diya , or Ram exploited his servant by putting him to  ( hard ) work . ) For each of the four senses , a karaka chart can be created . A karaka chart specifies the mandatory karakas  ( i . e . , wh ich must be f i l led for the sentence to be grammatical  )   , optional karakas , and desirable karakas . For each of the kara--kas , it specifies the vibhakti(i . e . , in-f lec t ion or post pos i t ion marker ) , and the semantic specification ( typically in the form of semantic type ) to be satis-fied by the source word ( group )  . Such a specification for a karaka in a karaka chart is called a karaka restrict ion  . 
Thus , the karaka chart for the ' hitching ' sense of ' iota ' has two mandatory karaka restrict ions : one for karta karaka  ( p\[ . o-nounced kartaaka rak ) and the other for karma karaka ( pronounced ka Fmkaaz . ak) . 
The former karaka relation maps to agent and the latter to patient semantic relation  . As shown in Fig . i , the restriction for karta karaka says that a source word group satisfying it must be present in the sentence  , its vibhakti must be 0 , and its semantic type should be human . 
restriction on karta karaka : karaka : kar taman datory : yesvib hakti:  0 semantic expression : human restriction on karma karaka : karaka : karma mandatory : yes vibhakti:  0 -or-ko semantic expression : cartFig . I : Karaka Chart for Jota ( Sense2)3 . 2 Ref in ing the Grammar Model The actual g rammar we use in the system is based on the model di scussed above  . However , it differs from it slightly so as to have a faster parser  . 
Instead of a sepal'atekar ~ kachart for each sense of a verb  , we have a single merged karaka chart . It consists of a set of karaka restrict ions where a res-triction for a particu larkaraka relation is obtained by taking the logical-or of the necessary vibhakti and semantic types for the same karakarelat ion in the dif-ferent karaka charts  . For example , semantic type in restriction for karma kanaka for the merged karaka chart is obtained by taking logical-or of semantic types in karmakaraka restrictions in the dif- ferent karaka charts  . Fig . 2 shows the merged karaka chart for iot a . 
Karaka Necessity Vibhakti Semantic Type .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
kartam 0 animate karmam 0-ko ~animate or instrument or l and karanad se- dvaraanimateOr ' instrument Fig  .   2: ~erged Karaka Chart for Jota As ' the separate karaka charts are no longer available for di stinguishing among the senses of the main verb  , separate in-formation is needed . This information is available in the form of laks hancharts or discrimination nets  . These nots can be obtained by looking at the separate karaka charts and identifying features that help us in distinguishing among the different senses  . An example laks hanchart for jot a is given in Fig  .  3 . 
284 byl ; eskin ? thesour . rewor'd ~ A Foup sag < tinsl ; kar , aka\[`est;p\]cl;ioriairlI;1l ~ , iue ~? ed\] . ' . ~ xFal < ct char ` t , and then : \] o\]v JI'Igl ; h , > inl . e &?, ~ pl'o-g\[`&Iuming problem . ) The\4 Ol-dItl " . ' O . ll\[Ilg\[ . S(lete, . mined on \] ffisher using I ; he\]~k shanchat ` k ~ on the karakaa ~ signment . 
d.Conc\].usJonE1
The major , features oo ar-app . -oath can be summarized as fo\]Iow ~ , : ; : 1 ) a paz'singel:tel:egg based on ' akanksha '  ( demand ) and ' yogyata ' ( qualification of the ~ ou\[-ceuni . t ) . Note that the k&t'aka charts exp\[`essingres tFict  . ions as above are similar to subcategor . iz ~ tion and selection alr'es-t ; f . tc tiop_s , but are no 1: identical to 1 hem . Sub--cat ; egor " ization F ~ t : ~ r's to deep cases , and select Jonal rest Fic ~ 1 ionsuaual \] . yspecify semantic types . 
fief " e we use karaka relations , and ~ peci . fy not just semantic type ~ . ~ but also post -, . position mar . kers ~ , it should , of course , be noted that : these ideasl ) la ~ a central ~- oleinourg\['ammat " and l > , % rse\[` . 
2) a , parsing ; strategy that uses lae~-gectEar`eke chart to doka\[`aka assignment  , and only later does the senses u \] ec:-tion for ' nouns and verbs us\]  . rlg\]aksh&nchat`ts . 
3 ) formulation of the core parsing pt-ob-ier a as integer " pr  . ogr . amming pr . eblem ? It ~ hould be noted that integer ` p t  . ogram-tiling is a general purpose technique mak ing a lat-ge amount of power and flexibi \]  . ity available to the parser ` . 
This is at the cost of efficiency if JlJ % e number of var  . iab\]es to be haqdled , qimultaneously is la\[`ge ( though our cut ` rent par . set-,funsfai\[`ly ~& sk) . IJe & reengaged in building a special con --: it rain l  ; solve\[-that will use this I ;  , ' owe Fonl ~ wh , ~ lll , ,~ct;s;5 , : ~ r -'~/\[ Ramesh , PU\] . 
Acknowl ~; d-~ement tJezJ . aid\]ike to acknowledge the pr'ill ?: ip a  . \]," 3 ou F ce of ide as . i . nt : his paper : l)r' . Vineet ( . ' haitan ~ r ~ . 
~ ef et ? ence ? J\[l % ha\[ . ati , Chai\[:a . nya & Sangal , 90\]A Com-- . 
put at : \]. on al Grammar for . Indian.
Language P : cocessing , A . Bharati , Vo
Chai . tanya , & rid R . Sangal , Technical Report TRCS-90-96, Dept . of Computer So . & Engg . , I . I . T . Kanpu\[`, 1990 . 
\[KJ par . sky , 32\] Some Theor'etical Problems in Pi , nini's Grammar , P . giparsky , Bhandarkar . Oriental Research Insti-tute , Pane , 1982 . 
\[ Ramesh , 9 ? I\]Constraints in Logic Pro-tramming , P . V . Ramesh , H . Tech . 
thesis , Dept . of Computer Sc.&
Engg ., I.I.T . Kanpur , Fiat '. 1990.
\[ Sangal & Chaitanya , 87\]An Inter-mediate Langu ~ . .ge for Fiachine T \ [` ans lat ion : An Approach based on Sanskrit using Conceptual Graph Notation  , Computer Science & InfoFmatics , J , of Comput-er Society of India , I7 , I , pp .  9-21 , 1987 . 
\[ Sangal , Chaitanga & Karnick ,   88\] An Ap-proach to Fi & chine Tt-anslation in Indian Languages  , Proc . of Indo-USL Jorkshop on Systems and Signal Processing  , Indian Institute of Sci-ence , Bangalore , Jan .  1988 . 
\[SenGupta , 89\] Some Aspects of Language Generation , Rimli SenGupta , H . Tech . 
thesis , Dept . of Electrical Engg,
I.I.T . Kanpur , 1989.
The gr ' ammar and the parser ' described above are part of a machine t\[`anslation sysl  ; em for , Indian languages based on an inter\]ingua\ [ Sangal & Chaitnya  ,  87\] . Gen-er , at or in the system uses the same grammar . In principle , each of the stages of the parser . isr . eve Fsed\[SenGupta , 89\] . 

