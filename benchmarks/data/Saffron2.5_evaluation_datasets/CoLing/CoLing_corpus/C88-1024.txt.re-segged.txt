ANEWDESIGNOF PROLOG-BASED
BOT TOM-UPPARSING SYSTEM
WITHGOVER NMENT . BINDING THEORY
Hsin-Hsi Chen * , ** , I-Peng Lin * and Chien-Ping Wu **
*Department of Computer Science and Information Engineering National Taiwan University  , Taipei , Taiwan , R . O . C . 
** Graduate Institute of Electrical Engineering National Taiwan University  , Taipei , Taiwan , R . O . C . 

This paper addresses the problems of movement transformation iProlog-based bottom-uparsing system  . 
Three principles of Government-Binding theory are employed to deal with these problems  . They are Empty Category Principle , C-command Principle , and Subjacency Principle . A formalism based upon them is proposed . Translation algorithms are given to add these linguistic principles to the general grammar rules  , the leftward movement grammar rules , and the rightward movement grammar rules respectively  . This approach as the following specific features : the uniform treatments of leftward and rightward movements  , the arbitrary number of movement nonterminals in the rule body  , and automatic detection of grammar errors before parsirlg  . An example in Chinese demonstrates all the concepts  . 
1. Introduction
The movement transformation is one of the major problems encountered in natural language processing  . It has relation to the empty constituents ( traces ) that exist at various levels of representation i natural language statements  . 
Consider the following example in Chinese : ~\]\  [~   , ~ ~ NTo(Thatbook , Iread . ) The word " N "( read ) is a transitive verb , which should take a direct object . However , the object " JJ l ~" ( that book ) is topicalized to the first position of the sentence  . For the treatment of this phenomenon , we cannot just write down the rules : sentence -- > noun-phrase  , verb-phrase . 
verb phrase --> transitive-verb , noun-phrase.
verb phrase --> transitive-verb.
verb phrase --> intransitive-verb.
This is because many ungrammatical sentences will be accepted  . Thus , we must provide some mechanisms in the grammars in order to capture them  . It is still a hard work to do . 
Several difficulties are listed as follows : ( 1 ) The determination f movement is difficult . That is , an element may be in a topicalization position , but it is not moved from some other place in the sentence  . For example , ( Fruit , I like . ) zk~,~~gt~o(As for fruit , I like banana . ) the first can be considered to be a movement phenomenon  , but the second cannot . 
(2 ) The empty constituent may exist at many possible positiof is  . For example , given an n word sentence such as ClW le2w2e3 . . . e ( n_l ) W ( n-1 ) e ( n ) W ( n ) e ( n + l ) where wi is the ith word and ei is an empty constituent  , the ream ( n + l ) possible positions from which the moved constituent may originate  . That is , for a moved constituent ( if there is any ) , there are so many possible mpty constituents to coindex  . 
(3 ) Since the gap in between the moved constituent and its corresponding trace is arbitrary  , it is implausible to list all the possible movements exhaustively  , and specify each movement constraint explicitly in the grammars  . 

The Government-Binding ( GB ) theory \[1\] provides universal principles to explain the movements  . Some of them are shown as follows: ( 1 ) Empty Category Principle\[7\]-
A trace must be properly governed.
(2 ) C-command Principle \[7\]-a c-commands B iff every branching node dominating a  dominates/3  . 
(3) Subjacency Principle\[7\]-
Any application of move-a may not cross more than one bounding node  . 
Summing up the above principles , we have to find a move zl constituent to c-command a trace  . The constituent can neither relate to au'ace out of its c-command domain  , normatch a trace when more than one bounding node is crossed  . Such principles nan ' ow down the searching space to some extent  . 
For example ,   ( El ) ~\]l~tNJ ~~ ti~t ' ~- ~ To ( The student that heman sawticame . )  ( E2 ) * tm~-Ntn~N ~ ~ T~9~\[~ff ~ J~o ( * The man that he student whotm sawtn came . ) There is a trace ti in the example ( El ) . Two NPs , i . e . " N ~" ( the student ) and " ~\] g ~ lA . " ( the man ) , may coindex with it , but only the former is acceptable . The reason is specified as below : ( ZI')In , , \[ s \]~ .   ( the man ) ~  ( saw ) q  ~ J ( de ) ~- ~ i ( the student )  1~  ( cane ) ?  ( as p ) 
L . ~ o ~(\ [ ~ i '') ~ , ~theman)\[n ,   , \[ st ~ ( saw ) tl  ~ ( de ~- i ( the student ) \]~  ( came ) \]'  ( as p ) x  ~ JL . - o . -I The ( E l " ) interpretation violates the subjacency principle ( assuming that s and n " are two bounding nodes )  . Two traces exist in the example ( E2) . The tracestm and tn may coindex with the two NPs " ~ J ~="  ( the student ) and " ~\] I~NA . " ( the man ), and vice versa . However , both are wrong because of the snbjacency principle :  i-7- ? -- a ( E2' )   . \[ sIn ' latm ~ ( saw ) tn\]~J ( de ~ nl the student ) 15  ( came ) ~  ( as p ) \]~  ( de\]~\[~ ) ~ . m(theman)\]L?-~o . -=--~( F , 2' ' ) Is\[n'~tm ~ ( saw ) tn\]/@ ( de ) ~m ( the student ) \]~  ( came ) T ( as p ) \]IfJ de ) ~\[ l ~ Ln ( the man ) 
IX ~_ _ . _I2 . A Government-Bindlng based Logic Grammar
Formalism 2 . 1 The specifications of grammar formalism The Government-Binding based Logic Grammar  ( GBLG ) formalism is specified informally as follows : ( I ) the general grammar rules - ( a ) c ( Arg ) - -> Cl ( Argl )  , C2(Arg2) ,  . . . ,cn(Argn) . 
where c(Arg ) is a phrasal non-telrninal , and may be also a bounding nonterminal , c . ( Arg . )( l < j < n ) is , a lexical terminal or
JJ -_ .
a phrasal non-terrmnal.
(b)c(Arg)-->Cl(Argl ), C2(Arg2), . . . ,ei(Argi ) , trace ( Trace Arg ) , c(i+I ) ( Argo+1)) , '" , cn ( Argn ) " where the definitions of c ( Arg ) and cj ( Argj )   ( l < j < n ) are the same as above , trace('rraceArg ) is a virtual nonterminal . 
The special case i = O is common . For example , a noun phrase is topicalized from a subject position  . It is represented as s --> trace , np . 
(2 ) the leftward movement grammar rules-c ( Arg ) --> c1 ( ArgI )  , c2(Arg2) , -" , ei ( Argi ) , m(Argm ) < < < trae e(TraeeArg) , c(i+1) ( Arg(i+1)) ,  . . . ,cn(Argn) . 
where the . definitions of c ( Arg ) and cj ( Argj )   ( l < j < n ) arc the same as l ( a )  , m ( Argm ) <<<trace ( Trace Arg ) is a movement nonterminal . 
When i = 0 , the movement nonterminal is the first element in ~ he rule body  . 
(3 ) the rightward movement grammar rules - ( : ( Arg ) --> ci ( Arg1 )  , e2(Arg2) , '" , ei ( Argi ) , trace(TraceArg ) > >> m(Argm) , e(i+1) ( Argo+1)) , '" , en(Argn)-Except that the operator '>>>' is used , the other definitions are the same as those in the leftward movement rules  . It is apparent because of the uniform treatments of the leftward and the rightward movements  . 
2.2 A sample grammar
A sample grammar GBLG1 for Chinese shown below introduces lheuses of the formalism :  ( rl ) slbm ' ( slbar ( Topie , S )) --> topic(Topic ) <<< traeeT(Topic) , s(S) . 
( r2) slb~t,-(slbar(S )) --> s(S).
( r3) s(s(N2 bar , V2bar , Par0)--> z~2 bar(N2 bar) , v2 bar(V2 bar) , * part ( Part ) . 
( r4) s(s(N2 bar , V2bar )) --> n2 bar0N2 bar) , v2bar(V2bar) . 
( r5) s(s(ttaceR ( Trace) , V2bar )) --> traceR(Traee) , v2bar(V2bar) . 
( r6) topic ( topic(N2bar )) --> n2 bar(N2 bar).
( r7) n2 bar(n2 bar(Det , CL , Nlbar )) -->* det(Det) , * cl(CL ) , nlbar0Nlbar) . 
(r8) n2 bar(n2 bar(Nlbar )) --> nlbar(Nlbar).
(19) nlbac(nlbar(Rel , N2 bar )) --> tel(Rel) , trace R(N2 bar ) > >> n2 bar(N2 bar) . 
( riO ) nl bar(nlbar(N )) -->* n(N).
( rl1) rel(rcl(S , De )) --> s(S ),* de(De).
( r12) v2 bar(v2 bar(Adv , Vlbar )) -->* adv(Adv) , vlbar(Vlbar) . 
(r13) v2 bac(v2bar(Vlbar )) --> vlbar(V1bar).
( r14) vl bar(vlbar(TV , N2bar )) ->* tv(TV ) , n2bar(N2bar) . 
( r15) vl bat ' ( vl bar(TV , traceT(Trace ))) -->* tvOW ) , traeeT(Trace) . 
( r16) vlbac(vl barfrV , traeeR(Traee ))) -->* tv(TV ) , traeeR(Trace) . 
( r17) vlbac(vlbar(iv )) -->* iv(IV).
Among tlu ; segramma rules ,   ( rl ) deals with the leftward movement ( opiealization )  ,   ( r9 ) treats the rightward movemen ~ ( relafivization )  , and the others amnormal grammar rules . The heads of the grammar rules ( r3) , ( r4) , ( r5) , ( r7) , and ( r8) are bounding nodes . The virtual nonterminals trace T ( Trace ) and trace R ( Trace ) appear in the rules ( r5 )  , ( r15) , and (1"16) . 
2 . 3 Tramtsitive . relation of c . command theory For a phrasal nonterminal X , a virtual nonterminal Y and a transitive relation TR  , XTRY if ( 1 ) X is the rule head of a grammar rule , and Y is an element in its rule body , or (2) X is the rule head of a gramma rule , a phrasal nonterminal I in its rule body , and ITRY , or ( 3 ) there exists a sequence of phrasal nonterminals I  1  ,  12  . . . . . In , such that XTRIITR 12TR . . . TRIn . 
The transitive relation TR is also a dominate relation  . 
The c-command theory is embedded implicitly in the GBLGs if ~ very grammar rules satisfy the following property : for a rule X  0  -->  X1  , X2 ,  . . . ,X m where X i is a terminal or a nonterminal , lai~m , if X i = ( A <<< B ) then there must exist some Xj ( i < j < m )  ; such that Xj dominates the virtual nonterminal B in other grammar rule  . That is , XjTRB . The phrasal nonterminal X 0 is the first branching node that dominates A and Xj  , and thus also dominates B . Therefore , Ac-commands B . X i = ( B > > > A ) has the similar behavior . Rules ( rl ) and ( r9 ) in grammar GBLGI show these <<< and >>> relations respectively  . 
2 . 4 Comparison with other logic programming approaches Compared with other logic programming approaches  , especially the RLGs\[8 , 9\] , the GBLGs have the following features : ( 1 ) the uniform treatments of leftward movement and the rightward movement-The direction of movement is expressed in terms of movement operators <<< or >>>  . The interpretation of movement on-terminals A < < < Bor B >> > A is IfA is a left moved constituent  ( or a fight moved constituent )  , hen the corresponding trace denoted by B should be found after  ( or before ) A <<< B ( or B >>> A )  . It is illustrated in the Fig .  1 . The two trees are symmetric and the corresponding rules are similar  . However , the rules are not similar in RLGs . That is , the two types of movements are not treated in the same way  . For the rightward movement , a concept of adjunct node is introduced . It says that the right moved constituent is found if the rule hung on the adjunct node is satisfied  . The operation semanticsien forced on the writing of the logic grammars  . It destroys the declarative semantics of logic grammars to some extent  . 
(2 ) the arbitrary number of movement on-terminals in the rule body-In our logic grammars  , the number of movement nonterminals in a rule is not restrictive if the rule satisfies the property specified in the last section  . The RLGs allow at most one movement nonterminal in their rules  . The position of movement nonterminal is declared in the rule head  . It is difficult for a translator to tell out the position if different types ~ he move dionst it uont ~/ ~ ~ iAA ? AAAk  . . . . . .
trace\[the empty constituent )
XO the moved constltucn t
Xl . . . X JnzxAA?el . . . . . . c).
AAtrace ( the empty constituent )
Fio . ISymmetric tree for leftward and riohtward movement of elements are interleaved in the rule body  . Thus , our formalism is more clear and flexible than RLG s '  . 
(3 ) automatic detection of grammar errors before parsing For significant grammar rules  , a transitive relation TR must be satisfied . The violation of the transitive relation can be found before handuring rule translation  . Thus , this feature can help grammar writers detecthe grammar errors before parsing  . 
I 133 . A Bottom-up Parser in Prolog 3 . 1 Problem specifications The Bottom-Up Parsing system  ( BUP )  \[2 , 3 , 4\] uses the left-coruer bottom-up algorithm to implement Definite Clause Grammars  ( DCGs )  \[5\] . It overcomes the problems of topdown parsing , e . g . the left-recursive invocation , and provides an efficient way as Earley's and Pratt's algorithms  \[3\]  . However , it does not deal with the important syntactic problem-movement transformation  . Extraposition Grarmnars ( XGs ) \[6\] propose extraposition lists ( x-lists ) to attack the movement problem , but when to extract races from x-lists becomes a new obstacle  \[8  , 9\] . Restricted Logic Grammars ( RLGs)\[8 , 9\] based upon GB try to tackle the unrestricted extraction from the x-list  . They emphasize the importance of the c-command and the subjacency principles during parsing  . 
The extraction must obey these two principles . The parsing strategies of XGs and RLGs are all depth-first and left-to-right  , thus they have the same drawbacks as DCGs do \[4\]  . If the parsing strategy is left-coruer bottom-up , the following issues have to be considered in the translation of GBLGs :  ( 1 ) the empty constituent problem-The first element in the rule body  , which acts as a left-corner , should not be empty in left-corner bottom-up algorithm  . However , the type 1(b ) of rules is common . 
(2) the transfer of trace information -
From Fig .  1 , we know that the positions of empty constituents are usually lower than those of moved constituents  . Because the parsing style is bottom-up , the trace information must be transferred up from the bottom  . The conventional different list cannot be applied here  . Fig . 2 and Fig .   3 illustrates the differences of data flow between topdown parsing and bottom-uparsing  . 
e:Cl91 c(i41) cnk
HO1'HIH(i-l ) Hi Hi+IH(n-l ) ~ H,' . . . . . . ";, A ,': . . . . . . . . A A \ , : ,, : , . , , " cllc12 ~ toilel2 . , ~: c(I+I)I , . . . % ~ nlon2 FiG .   2 the data flow in tile topdown parsing ~ qro ~ ( \[ HI , H2 . . . . . Hn)HI""H(i-I)---Hi . . . . . . . . . . . . H(i?l)-,H(n-l)---Hn . . . . . . . . . . ~ -~
A , , A \ , , , , ,
Fig . 3 tho data flow in the bottom ~ uo pars lnQ3 . 2 Data structure The transfer of trace information is through a list called extraposition list  ( x-list ) and denoted by a symbol H . The transformation of x-list is bottom-up . Fig . 3 sketches the concept . A special data structure shown below is proposed to carry the information : \[ In sequence of trace information/X\]  , X\]No teamii variable X is introduced . Based upon this notation , an empty list is represented as \[ Z , Z \] . An algorithm that merges arbitrary number of lists in linear time is designed : merge  ( X , Y ) :- merge(X , Y , \[Z , Z\]) . 
merge(\[\],L,L):-!.
merge(\[\[B , X\]JT\[ , Y , \[A , B \]) :- merge(T , Y , \[A , XD . 
In the conventional list structure such as \[ a sequence of trace information \] even though the difference list concept is adopted  , the computation time is still in proportion to ml+m2+  . . . + mn , where mi ( 1 < i < n ) is the number of elements in the ith list . 

Although our merge algorithm is the fastest , it is still a burden on the parsing . In most cases , the predicate merges empty lists . That is nonsense . To enhance the parsing speed , the merge predicate is added in which place it is needed  . 
Observing the merge operation , we can find that it is needed only when the number of lists to be merged is greater than one  . 
The following method can decrease the number of x -lists during rule translation  , and thus delete most of the unnecessary merges : Partition the basic elements in the logic grammars into two mutually exclusive sets : carry -Hset and non-earry-Hset  . 
The elements in the carry-Hset may contribute trace information during parsing  , and those in the non-carry-H set do not introduce trace information absolutely  . The transitive relation TR defined in the section  2  . 3 tells us which phrasal nonterminals constitute the carry-H set  . 
3.3 The translation of grammar rules
The translation of basic elements in the GBLGs are similar to BUPs  . Only one difference is that an extra argument that carries trace information may be added to phrasal nonterminal if it belongs to carry-H set  . Appendix lists the translated results of the grammar GBLG  1  . 
3.3.1 The general gramma rules
The general grammar rules are divided into two types according as a virtual nonterminal disappears or appears in the rule body :  ( a ) c ( Arg ) - -> Cl ( Argl )  , C2(Arg2) ,  . . . , cn(Argn)"Whenc is not a bounding node , e . g . rule(r2) , the translation is the same as that in BUP\[2 , 3 , 4\] , excep that an extra argument H ( if necessary ) for x-list and a builtin predicate merge are added in the new translation algorithm  . 
This predicate is used to merge all the x-lists on the same level  . 
The transformation fx-lists is bottom-up ( only one direction ) as shown in Fig .  3 , Thus , the rule(a ) is translated into cl(G , Argl , H1 , X1 , X ) :- goal(c2 , Arg2 , H2 , X1 , X2) , goal ( cn , Argn , Hn , X(n-l ) , Xn ) , merge(\[H1 , H2 . . . . . Hn \], H ), c(G , Arg , H,Xn,X) . 
When c is a bounding node , e . g . rule(r4) , the information is used to check the x-list transferred up  . Thus , an extra predicate bound is tagged to this type of rules : cl  ( G , Argl , H1 , X1 , X ) :- goal(c2 , Arg2 , H2 , X1 , X2) , goal ( cn , Argn , Hn , X(n-1) , Xn ) , merge(\[HI , H2 . . . . . Hn \], H ), bound(c,H ), c(G,Arg,H,Xn,X) . 
The predicate bound implements he subjacency principle  . Its definition is : bound(C , \[X , Y \]) :-( var(X ) , !;boundaux(C , X)) . 
boundaux(C,X):-var(X ), l.
boundaux(C , \[x(Trace , Bound , Direction ) lXs\]):-(var(Bound) , !  , Bound = C , boundaux(C , Xs);
Bound = s,C = s,!,boundaux(C,Xs ); fail).
A variable Bound which records the cross information is reserved for each element in the x -list  . When a bounding node is crossed , this variable is checked tO avoid the illegal operation  . 
(b)c(Arg ) --> e1(Arg1), e2(Arg2), . . . , ci(Argi ), trace(TraceArg ), c(i+1)(Arg0+1)),' . .,cn(Argn) . 
where i >= O . The rules ( r5) and ( r15) are two examples . 
If the left-coruer bottom-u parsing algorithm is used  , the grammar rules should free of empty constituents  . When i = 0 , the grammar rule considers a trace ( an empty constituent ) to be the first element in the rule body . It overrides the principle of the algorithm , but we can always selec the first element c ( i+1 ) that satisfies the following criterion : ( i ) a lexieal terminal , or (2) a phrasal nonterminal , or ( 3 ) a phrasal nonterminal in a movement on-terminal , to be the left-comer and put the trace inforumtion i to an x-list before this nonterminal  . Thus , the translation is generalized as follows ( assume that cl is a left-comer )  . 
ci(G , ArgI , H1, X1, X):..
goal(c2 , Arg2 , H2 , X 1 , X2) , goal(ci , Argi , Hi , X(i-1) , Xi ) , goal ( c(i + l) , Arg0+l) , H(i+l) , Xi , X(i + l)) , goal ( cn , Argn , Hn , X(n-l) , Xn ) , merge(\[H1 , H2 . . . . . Hi,\[\[x(trace(TraceArg ), Bound,D)lZ\],Z\],
H(i+I ), ..., Hn \], H ), c(G , Arg , H,Xn,X).
Here , the trace information is placed between Hi and H ( i+l )  . 
Summing up , the virtual nonterminal is represented as a fixed fommt : x  ( trace ( l'raceArg )  , Bound , Direction ) and placed in tox-list via merge operation . The position in x-list is reflected from the original rule  . 
3?3 . 2 The leftward movement grammar rules The leftward movement grammar rnles can be generalized as below : c  ( Arg ) o->c1 ( Arg1 )  , c2(Arg2) . . . . . 
ci(Argi ) << < trace(TraceArg ), c(i+1)(Arg(i+1)) . . . . . 

The rule ( r l ) is an example . Its translation is shown as follows : cl(G , Argl , H1 , X1 , X ) :- goal(c2 , Arg2 , H2 , X1 , X2) , goal(ci , Argi , Hi , X(i-1) , Xi ) , goal ( c0+l ) , Arg(i+l) , H(i+l) , Xi , X(i + l)) , goal ( cn , Argn , Hn , X(n-1) , Xn ) , merge(\[H(i + l) . . . . . Hn \], T1), cuLtrace(x(trace(TraceArg ), Bound , left),
T1, T2), merge(\[H1, H2, . . . Hi , T2\], H ), c(G , Arg , H,Xn,X) . 
Comparing this translation with that of general grammar rules  , we can find a new predicate cut_ . trace is added . The cut trace implement silec-command principle , and its definition i ~ . 
cnLtrace(Trace , \[Y , X\] , \[ Y1X\]):-(var(Y ) , ! , ( l'race=x(TraceInfo , Bound , left ) , !; fail ); cut trace aux ( Trace , Y , Y1)) . 
cnLtraceaux(Trace,\[TracelXs\],X s):-!.
cut traceaux ( Trace , \[HIX\] , \[ HIY\]):-(vat(X ) , ! , ( Trace = x ( Trace Info , Bound , left) , !; fail ); cut_traceaux(Tracc , X , Y)) . 
The cut trace tries to retract a trace from x-list if a movement exists  . ~ landarin Chinese has many specific features that oilier languages do not have  . For example , topic comment structure does not always involve movement transformation  . The first cuttraeeau zchmse matches the trace information with the x-list ~ rans ferred f  , ' om the bottom on its right part . The second cut trace a trctells us that if the expected leftward trace can not ma ~ hone of the elements in the x-list  , then it will be drop out . 
The x-list is not changed and transferred up . The concept is demonstrated in Fig .  4 . It also explains why we can detect grammar errors before parsing  . In summary , each movement nonterminal is decomposed into a phrasal nonterminal ndavimml non-  . tet~ninal . The phrasal nonterminal is translated the ' same as before  . The vktual nonterminal is represented as x ( trace ( l Yace Arg )  , Bound , left ) in this case , however , cut_trace is involved instead of merge . 
3 . 3 . 3 The r ightward movement grammar rules Because we treat the leftward and the rightward movement grammar rules in a uniform way  , the translation algorithm of both are similar . The rightward movement gr~n~narruks are wifll the following format : c  ( Arg ) --> cl ( Argl )  , C2(Arg2) . . . . . 
lxace(TraceArg ) > > > ci(Argi) , c(i + l ) ( Arg(i + l)) , '" , cn(Argn)"The rule(r9) is an example . " Itle corrsponding translated result cl(G , \[Argl\] , HI , X1 , X ) :- goal(c2 , \[Arg2\] , H2X1 , X2) , e
Hk .   . H(i-l ) Illint hls range , left-moved the corresDond lnQconstltuent moved elems nt is on the uDDer level e  ( l + l ) 
AA
I a trace should be found in this range if the oxpoct at I on succeeds 
Flg .   4 the sketch o ~ the translation of the leftward production rules goal  ( c ( i-1 )  , \[Arg0-1)\] , H(i-1) , X(i-2) , X(i_l )) , merge(\[H1 , H2 . . . . . H(i-1)\] , T1) , cut_trace(x(trace(TraceArg , Bound , right)) , 
TI , T2) , goal(ci , \[Argi\] , Hi , X(i-1) , Xi ) , goal ( cn , \[Argn\] , Hn , X(n-1) , Xn ) , merge(\[T2 , Hi . . . . . Hn \], H ), c(G,\[Arg\],I-t,Xn,X) . 
The translation is very apparent for the symmetric property of the leftward and the rightward grammar rules illustrated in Fig  . 
4 and Fig .  5 . A slight difference appears in the definition of the cc  ( i-l ) iA < p found in this range enconstituent in this range  , the corraspondlng moved element is sn the upper level Fio of  .   5 the sketch of the translation the rightward production rules predicate cut trace  . It shows an important linguistic phenomenoni- Mandarin Chinese : ' Relativization is always a movemen transformation  . ' Thus , if we expect a trace and cannot find a corresponding one  , failure is issued . The direction information in x ( trace ( Trace Arg) , Bound , right ) , i . e . 
fight , tells out the difference between the leftward and the rightward movements  . \] ( n general , we allow both leftward movement and rightward movement to appear in the same rule  . 
A new predicate intersection is introduced to couple these two translations  . 
3 . 4 Invocat ion of the pars ing sys tem The parsing system is triggered in the following way : goal  ( a start non-terminal , \[ a sequence of arguments \] , an empty : ~- list , \[ a sequence of input string \] , \[\]) . 
In GBLG1 , the invocation is shown as follows : goal ( slbar , \[ParseTree\] , \[Z~I , \[ input sentence \] , \[\]) , 

Because an emptyx-list is represented as \[ Z , Z \] ( Z : a variable ) in our special data structure shown in Section 3 . 2, var(Z ) verifies its correctness . For example , to parse the Chinese sentence " ~ Jl ~ A . ~t ~\[ t . ~3K ?" ( the student that that man saw came) , we trigger tile parser by calling : ?- goal ( slbar , \[ Slbar \] , \[ Z , Z \] , \[' JJ ~' ,  '~' , ' J ~' ' , ' ~ tE ' ,  '~ '  ,  '~ '  ,  '~ '  , 'Y '\] , \[\]) , vat(Z ) . 
/*7-goal(s1 bar , \[ S1 bar \] , \[Z , Z\] , \['that' , 'man' , ' saw ' , ' dc ' , 'student' , ' came ' , ' aspect '\] , \[\] ) , var(Z ) .   , /This paper addresses the problems of movement transformation iProlog-based bottom-u parser  . Three principles of Government-Binding theory are considered to deal with these problems  . They are Empty Category Principle , C-comr 0 and Principle and Subjacency Principle . A sequence of translation rules is given to add these linguistic principles to the general grammar rules  , the leftward movement grammar rules , and the rightward movements grammar rules respectively  . The empty constituent problem is solved in this paper to allow the trace to be the first element in the grammar rule body  . A special data structure for extraposition list is proposed to transfer the movement information from the bottom to the top  . Based upon this structure , the fastest merge algorithm is designed . Those unnecessary merge predicates can be eliminated with the help of transitive relation  . Thus , the new design not only extends the original bottom-u parsing system with the movement facility  , but also preserves the parsing efficiency . 
References\[1\]N . Chomsky , Lectures on Government and Binding . 
Foris Publication , Dordrecht , Holland , 1981.
\[2\] Yuji Matsumoto , Hozumi Tanaka , et al , " BUP : A Bottom-Up Parser Embedded in Prolog , " New Generation Computing , Vol . 1, No . 2,1983, pp . 

\[3\] Yuji Matsumoto , Masaki Kiyono , and Hozumi Tanaka , " Facilities of the BUP Parsing System , " in Dahl , V . and P . Saint-Dizier , Natural Language Understanding and
Logic Programming , 1985, pp . 97-106.
\[4\] Yuji Matsumoto , Hozurni Tanaka , and Masaki Kiyono , " BUP : A Bottom-Up Parsing System for Natural Languages  , " in Warren , D . H . D . and M . Canegham ( eds . ) , Logic Programming and Its Applications ,  1986 , pp .  262-275 . 
\[5\]F . Pereira and D . H . D . Warren , "Definite Clause Grammars for Language Analysis -A Survey of the Formalism and a Comparison with Augmented ~ Transition Networks  , " Artificial Intelligence , Vol . 13,1980, pp .  ~!-278 . ,,\[6\]F . Pereira ~ , Extraposition Grammars , American Journal of Comp U~?tion Linguistics , ~ Vol . 7, No . 4, 1981, pp . 

\[7\]P . Sells , Lectures On Contemporary Sntactic Theories , Center for the Study of Language and Information ,  1985 . 
\[8\]E . P . Stabler , Jr , , " Restricting Logic Grammars , " Proc . 
of the AAAI Conference , 1986, pp . 1048-1052.
\[9\]E . P . Stabler , Jr . , " Restricting Logic Grammars with Government -Binding Theory  , " Computational Linguistics , Vol . 13, No . 12, January-June , 1987, pp . 


Based upon the translation algorithm specified in Section  3  , the logic grammar GBLG1 is translated as below . 
The clause ( ti ) is the relevant translated result of the grammar rule  ( ri )  . Note the codes have been optimized . Those unnecessary merge operations are deleted from the translated results  . 
( tl ) topic(G , \[Topic\] , H1 , X1 , X ) :- goal(s , \[S\] , H2 , X 1 ,  2) , cut_trace(x(traceT ( Topie ) , Bound , left) , H2 , T1) , merge(\[H1 , T1\] , H ) , slbar(G , \[slbar(Topic , S)\] , H , X2 , X) . 
( t2) s(G , \[S\] , H , X1 , X ) :- slbar(G , \[slbar(S)\] , H , X1 , X) . 
( t3) n2 bar(G , \[N2bar\] , H1 , X1 , X ) :- goal(v2 bar , \[V2bar\] , H2 , X1 , X2) , lookup(part , \[Part\] , X2 , X3) , merge(\[H1 , H2\] , H ) , bound(s , H ) , s(G , \[s(N2bar , V2bar , Part )\] , H , X3 , X) . 
( t4) n2 bar(G , \[N2bar\] , H1 , X1 , X ) :- goal(v2 bar , \[V2bar\] , H2 , X 1 , X2) , merge(\[H1 , H2\] , H ) , bound(s , H ) , s(G , \[s(lq2bar , V2bar)\] , H , X2 , X) . 
116 ( t5) v2 bar(G , \[V2bar\] , H1 , X1 , X ):-merge(\[\[\[x(traceR(Trace) , Bound , righ01Z\] , Z\] , 
HI\] , H ) , bound(s , H ) , s(G , \[s(traceR(Trace) , V2bar)\] , H , XI , X ) . 
( t6) n2 bar(G , \[N2bar\] , H , XLX):-topic(G , \[topic(N2bar)\] , H , XIX ) . 
( t7) det(G , \[Det\] , X1 , X ) :- lookup(cl , \[CL\] , X1 , X2) , goal(nlbar , \[Nlbar \] , H , X2 , X3) , bound(n2 bar , H ) , n2bar(G , \[n2bar(Det , CL , N1bar)\] , H , X3 , X) . 
( t8) nlbar(G , \[Nlbar\] , H , Xl , X ) :- bound(n2 bar , H ) , n2bar(G , \[n2bar(Nlbar)\] , H , X1 , X) . 
( t9) reI(G , \[Rel\] , H1 , X1 , X ):-eut_trace(x(tmeeR(N2 bar) , Bound , right) , H1 , T1) , goal(n2 bar , \[N2bar\] , H2 , X 1 , X2) , merge(\[T1 , H2\] , h0 , nlbar(G , \[nlbar(Rel , N2bar)\] , H , X2 , X) . 
( tl0)n(G , \[N\] , X1 , X ) :- nlbar(G , \[nlbar(N)\] , \[Z , Z\] , X1 , X) . 
( tll ) s(G , \[S\] , H , X1 , X ) :- lookup(de , \[De\] , X1 , X2) , rel(G , \[reI(S , De)\] , H , X2~X) . 
( t12) adv(G , \[Adv\] , X1 , X ) :- goal(vlbar , \[ V1 bar \] , H , X 1 , X2) , v2 bar(G , \[v2bar(Adv , V1 bar)\] , H , X2 , X) . 
( t13) vl bar(G , \[Vlbar\] , H , X1 , X ) :- v2 bar(G , \[ v2 bar(V1 bar)\] , H , X 1 , X) . 
( t14) tv(G , \[TV\] , X1 , X ) :- goal(n2 bar , \[N2bar\] , H , XI , X2) , vlbar(G , \[vlbar(TV , N2bar)\] , H , X2 , X) . 
( t15) tv(G , \[TV\] , X! , X ) :- v1 bar(G , \[ v1 bar(TV , traceT ( Traee ))\] , \[\[x ( traeeT ( Traee) , Bound , left)lZ\] , Z\] , H , XI , X) . 
( t16) w(G , \[TV\] , X1 , X ) :- v1 bar(G , \[ v1 bar(TV , tr ; aceR(Traee ))\] , \[\[x ( traceR ( Trace) , Bound , right)lZ\] , Z\] , H , X 1 X ) . 
( t17) iv(G , \[IV\] , X1 , X ) :- vlbar(G , \[vlbar(IV)\] , \[Z , Z\] , X1 , X) . 
