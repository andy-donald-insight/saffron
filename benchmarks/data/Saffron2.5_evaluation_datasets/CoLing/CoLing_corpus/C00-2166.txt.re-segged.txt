Robust Semantic Construction
Michael Schiehlen *
Institute tbr Comlmtational Linguistics , University of Stuttgart , 
Azenbergstr . 12, 70174 Stuttgart
mike@adler,ims.uni-stuttgart , de
1 Introduction
Recent years have seen a surgeill interest f ~ r robust fi at analysis  , i . e . NLP systems with fairly limited supl ) ly of linguistic knowledge but with vast coverage . The paper describes a module that serves as a backend to such fiat analysis methods and transforms their output into full semantic representations a constructed by deep analysis methods  . In particular , the module has been designed so as to process input fl'om ? treebanks ? a statistic contextfree parser trained on these treebanks ? a finite-state parser ? a traditional feature -structure parser The semantic representations which the module constructs m'eso called Verbmobil Inter-~&ce\[\[~Ol'lllS  ( \\[Irl~s )   ( BOS et al ,  1998) , ( l ) uilding on Reyle's Underspecified Discourse R , epresen-tation Structures (1993) , see an example , in Figure 1) . Although in principle o the , r representations could be constructed as well , VITs seem to be a particularly good choice : They Call  1oe implemented as sets of coustraint so that semantic construction  ( SC ) reduces to collecting the constraints and unifying some variables in these constraints  . Furthermore VITs are supported by mlabstract data type  ( Dorlla ,  2000) . 
Several daunting prol ) lems had to be t'aced intile design of the module . 
* This work was fimded by the German Federal Ministry of Education  , Science , Research and Technology ( BMBF ) in the ti'amework of the Verbmobil Project under Grant  01 IV 1  ( 1 U . Many thanks are ducto M . Emele and the colleagues in Verbmobil . 
week ( y ) next ( y ) decl ( ~7\]  ) \~1 ~ may be ( \[~  ) /// should ( el , ~\])1 into ( e , y ) move ( e , x ) pron(x ) Figure 1: VIT for So may be , u ~' e should move , into idle next u , e , e k . 
Context-Free Input . The treebanks providing tile input structures ( which have been built in the Verbmobil project ) only encode contextfree trees to facilitate the training of a statistical parser  . This means that nonlocal dependencies are either left out  ( e . g . topicalization in English ) or treated by flattening out subtrees into rules ( e . g . head-moven mntill German ) . The latter strategy can create a vast amount of rules : S in  ( : eGelunan head-nmvement connects a clause-initial and a clause-final position  , every clause frame gives rise to a new rule . 
To thee this challenge some adjustments had to be made :  ( 1 ) Predicate-argument structure is indispensable for SC but presupposes reconstruction of long distance dependencies  ( " movement " )  . If syntaxcmmotsupl ) lyit , SC has to retrieve it ; on its own ( see Section 5 . 2) . 
(2 ) The sheer bulk of rules prohibits manual tag : ging of syntactic rules with semantic rules  . In-tion in its rules so that SC can determi im the semantic operations required  . 
Robustness . Since the treebanks have been constructed by hand  , errors are prone to cropUl ) . Likewise , flat analysis methods cannot be expected to deliver input of the same quality as deep traditional parsers  . Finally , grammars and semantic formalism will often difl ' er in their subcategorization assmnptions : The verb move e  . g . subcategorizes for hit o in the treebank ( see Figure 2 ) but not in tile VITt bnnalism ( see Figure 3 )  . 
To handle this problem , the syntax-semantics-interface should be dismantled as far as possible : Only the most indispensable information should be taken over fl ' om syntax  . By neglecting all tile rest the system stands a good chance of skipping syntax errors  . Furthermore in many cases decisions made ill syntax need to be overturned in semantics  ( e . g . the complement/adjunct specifications ) , hnportant semantic information is often deterlnined only in SC or in subsequent disambiguation lnodules that have access to larger stores of context  . This approach eases the burden on syntactic analysis and potentiall yields more reliable results  . 
Diverse Input . ASC module should be able to handle input from a variety of grammars and convert it into an independelltt brmat of semantic representation  . Thus , a common syntax-semantics-interface ( or inore precisely an interface between syntax and SC  ) must be defined onto which every type of ' input is mapped  . 
2 Design Principles
To cope with tile problems mentioned , traditional SC techniques ( Montague , 1973) ( Pereira and Shieber , 1987) ( Bosel ; al . , 1996) cannot be used . Instead , the f bllowing ideas were exploited . 
Modularity and Underspeeification . A major problem in SC is the treatment of mn -biguity  . Often the local rule context available in SC does not give enoughilf fonnation to resolve such ambiguities  . In these cases , underspecification should be used to defer the resolution of choices  . Thus , the described module builds a lexically and scopally underspecified representation  . Subsequently the lexical ambiguities are resolved by disambiguation modules  . 
COMIZ_....~ItD
AIkJ/~D-/ADJ/~"JtD/---~~Bj/~HD~.
/ /  ~7  ?  D2""C ~ OMP /// '7 Ime'---<OMP\//// -7 m ) ~C-OMI_'__\
SPI ,,/ ~ D
RB RB PP MD VB IN DT JJ NN
So may be we should move into the next week Figure 2: Example for an application tree . 
Modularity and Syntax-Semantics -
Interface . To facilitate modularity a syntax-semantics -interface is explicitly defined  . The input of every parser is mapped onto an interface structure called application twe  , see Figure 2 . In this way input Dora various sources can be processed with a minimum of effort  . 
Semantic Database . Great emphasis is laid on an external database of semantic predicates  ( Heinecke and Worm ,  1996) . This database associates lemmas with predicate nmnes  , semantic classes and subcategorization frames ( see the entry in Figure 3 )  . 
3 System Overview
The process of SC can be split into two phases ( see Figure 4 )  . In the first , phase an application I ; ree is traversed and simultaneously an underspecified semantic represent t ~ tion is lmilt  ( compositional semantic onstruction , see section 5) . 
In the second phase the semantic representation is partially  ( lisambiguated ( see section 6 )  . The two phases are preceded by a step which me . -diates between the actual output of the syntax and the syntax-semantics-interface  . 
4 Syntax-Semantics-Interface
Traditionally , the content of the syntax-semantics-interface is somewhat contentious  . 
While syntax-oriented approaches try to integrate a good part of SC already into the parsing process  ( cf . the construction of f-structure in LFG ) , other al ) proaches puttile main focus on semantics ( e . g . Montague Grammar) . To achieve a high degree of flexibility , a modular SC system has to settle for the lowest , common denonfinator of all input sources . The following information seems to be minimally required from the syntax  . 

Lemma Pred Name move move
SemClass SyntFrameSor tvi3 argl:subj , a rg3:obj moves it Figure 3: Entry in the semantic database . 
ArgSorts agentive , entity contezt-frectrec ; \[ preprocessing step\] ; application tree semantic construction <- semant ic lexicon semantic represcv  , tation ; noncoln positional \] semantic COll struction <-- i diom lexicon 
Figure 4: System overview.
( l ) The parser should d ( ~liv cratree tbr the parsed string whi ( : h the SC system then ( ' an convert into a hierarchical stmmian'e of senmnti  ( : o\] ) - (  ; rations ( an applicatim l , tree ) . 
(2 ) Every word in the input string should 1 ) e syntactically classified , i . e . assigned a . ~! lntac-tic cateflo'r !/ or \]) art of Sl ) (; e . (: htag . \? ewill as-Sllllle that the parser assigns every word exactly one category  .   ( Lexical underslmcification could conceiv at fyb (  ; used to deal with multiple categories . ) Then morphological analysis ( either in synt ; ax or SC ) mapsl ; he word cate ~ rory pair to a morphological lemma and a set of morphologi-e::fl features  . SC records the feal ; llres in the VIT while it uses l ; he lemma as a key to the semantic lexicon . In ( : ase the lemma is unknown in the semantic lexicon  , the , syst , eln uses the syn~tacti ( : category to automati ( : ally as so ( : iate ~ new 1 ) redicate and semantic ( : lass with the lemma . 
(3 ) Every rule used in the trees hou hlspeci~y for each of the categories on its right hand side exactly one grammatical role  ( GR )  . It 7 the grmmnar does not do this , ORs must be deternfined in the prel ) roees sing step ( e . g . determiners in NPs are specifiers ) . Gll . sarellsed to COlttro\] . the choice of s, . ; nmntice l ) orations . The set of CHseml floyed is ; inspired by HPSG ( Pollard and Sag , 1994:): Head , Complement , Adjunct , Om~:j'anct , Spcci--Z--_ZZ-_ZZ--_ZS--Z-- _7_Z - - - - _ Z - - - - _ - -
Y ___/ff'-\[houk,(o ,) 7"i !
Figure 5: () peration of a (1. immtion.
tier , Part of a MultiWord Lezcme . The corm-spending semm~tic operations are Complem cn-ration  , Adjunction , Coordination , Spec ~ i / ication , and Predicate Form , ation . Except for Coordination and Predicate Formation all operations are l  ) ilmry . A nile without a head is considere del-lil ) ti ( ' al and an abstract 1 ) redicate for the missing head is inserted in semantics  . 
5 Compositional Semantic
Construction Process
Conll ) ositional SC follows the at ) plieation tree ( the contextfree backbone ) and detc , : nfincs the in'edicate-argunmnt structure(th(' , subcategorization paths ) . 
5.1 Senmntic Construction on the
ConsGtuent Structure
Figure 5 shows two adjun ( : tion operations : In the firs/: one , the inl : er seetive a ( kiunct into the next week is adjoined to move . In the second one , may be is adjoined to the clause . The picture makes clem ' what the data structure for a partial result should look like : a set of constraints and some pointers to variables in these constraints  ( e . g . the partial result for may be would be may be ( l ~ , lq) , 12 < hl , llC-la ~ and (12 , la )) . Since only finitely many pointers Jlna VIT , every predicate is referenced over a base label ( e . g . lj for may be ) . The constraint 12 < hasays that ; the box 12 is subordinated to boxlq , while l : Clasl ; a ; est , hat ; predicate l : is in boxla . 
1103 are involved , they can be collected in a record . 
All partial results are classified into six semantic types according to the pointers they allow for : n head  ( nominal head , ibr nouns ) , vhead ( verbal head , for verbs ) , adj ( adjuncts ~ , for adverbs , adjectives , subclanses , PPs , also prepositions and subordinating co ~ \junctions  )  , ncomp ( nonfinal complements , for pronouns , NPs , also determiners ) , vcomp ( verbal complements , for sentences and complement clauses , also sentence moods and complementizers ) , cnj ( tbr coordinating conjunctions ) . 
Semantic operations expect arguments of specific semantic types : Complementation combines heads with complements  , Adjunction combines heads with adjuncts . Specification converts an incoml ) let encomp(i . e . a detern finer ) and an head into a complete n comp . Coordination combines a cnj with a series of partial results of equal type  . 
If a type clash occurs , a " typeraising " operation is invoked . Such operations usually insert specific abstract predicates that represent phonetically empty words or elided mater iM still to be retrieved by ellipsis resolution in a later step  . 
Figure 6 gives a concise description of these operations a  . Consider some typeraising exmnples : ( 1 ) I will be here Monday . 
udefuns pccrood ( n head-+n comp )   ( ncomp-~adj )   ( 2 ) I will come if necessary . 
star ( adj--+v head )   ( 3 ) After no on might work or early morn iT ~ , g . 
abstr_tel(ncomp -+ v head ) 5 . 2 Semantic Construction on the
Predicate-Argument Structure
While the application tree ( Figure 2 ) states that the pronoun we is the subject of should  , in the 2VITs provide a lexical underspecification class for intersective  (   . g . into the vext week and scopal adjuncts ( e . g . may be ) . Thus , SC has to handle intersecLive and seop al adjunction iparallel  . 
3In Figure 6 the following names are used for newly inserted predicates : udef  ( mill determiner )  , unspcc_rood(mill preposition ) , stat ( auxiliary verb be ) , abstr_nom(nominal ellipsis ) , abstr_tel ( verbal ellipsis ) , dccl(declarative sentence mood ) , poss ( relation expressed by ge . ni-tive ), de . f(definite quantifier ) . 
comp(abstrrcl ,) a , ..-?@
I1~\\%-.oo %. ~'%,,;_ //, o.,,~.._
Figure 6: Typeraising operations.
semantic representation ( Figure 1 ) we is the subject of move . So in this case head and semantic subject m : e not in the same local rule  . To retrace such nonlocal dependencies , a slash device is used to store the pertinent information  ( the argument variable and the box label of the head  ) and propagate it through the application tree in search for a licenser  . If a subcategorized element occurs without a subcategorizing head  ( as occurs often in fl'agmentary input )  , an elliptical element is assumed : ( 4 ) I meanif you--~absh'_'tel with subject you 6 Noncompositional Semantic
Construction
In noncompositional SC idioms are recognized m~da higher level of abstraction is achieved  . 
Technically , noncompositional SC is about transforming VITs . Thus , for implementation the VIT transfer package of Dorna and Emele  ( (1996 ) ) is used . Linguistically , the component performs the following tasks : ? recognition of multiword lexemes that arc not designated as such by syntax  ( e . g . greeting expressions good night , comparatives more comfortable ) ? recognition and comput ~ tion of clock times ( e . g . a qm~rterto ten ) and ( late expressions ? recognition of titles ( e . g . Frau Miiller ) ? partial dismnbiguation of sentence mood ( e . g . who did it ; is recognized as a question ) ? distribution of conjoined material , if required by the level of abstraction aimed for half l  ) aSt to , n ,   ( late expressions Monday the third and tenth ) ? eoml ) ositional morphology for German ( e . g . Sl ; it'tmuseum-:museum with the ualneStilt )   7 Summary The paper has presented a moduled capable o:\['tl and linginlmt from tlat  , analysis lnetho ( ls and transforming them into fullfledged semantic representations  . The module works rolmstly and currently has a through put of about  98% on Verbmobil treebank input ( i . e . it gener-al:es 21 , 222 English and 26 , 789 German VITx . ) The remaining 2% are due to errors in the SC module , errors in the treebank , or coordination 1 ) tel ) ictus1 ) etween SC and tree 1 ) ank . 
Evaluation of the module is COnll ) lieated 1) 3 , the effort involved in mmmally constructing a sizable set of input structures and correspondillg semantic rel  ) resentations , l ? urther more , t ; t1 ( : VIT formalism has been in constant flux over the last  ; years with the correct outlmt representations changing almost monthly  . It is , however , envisaged to perform an evaluation on ( ' edust has settled . 
The approach described adds in two respects to the rot  ) ustnexs of the overall system . First , l ; he flat analysis lmrxerx used are very rolms tas con-terns low-level inconsistencies such as agreement failures or missing function words  ( prepositions , determiners , CO mlflementizers , etc . ) . Second , the data analysed in the Verb mobil treebanksm : e exclusively xpoken language  . Hence , the treebanks encode analyxest brphenomena such as fl'agmentary in lmt  , truncate do relliptical sell-tence x , etc . The described module , gives semantic analyses for all of these constructions  .   ( Usually an abstract predicate is in corl ) orated which given a hint to subsequent modules that aim to piece together partial utterances  . ) Another perspective of this work is that it provides a first step towards a real corlms semantics by converting large sets of data into semantic representations  . Due to the abstraction they embody , semantic representations are a valuable too \] for content queries to the  . processed corpora . 
More immediately , the semmltic representations 4More inibrmation can be found in Schiehlen ( 1999 )  . 
generated by the described module have been used as text and training data tbrapplications requiring abstract input  , such as transfer in machine translation and generation  . 
References 3o han Bos , BjgrnG ambit(k , Cln'istiml Lieske , Yoshiki Mori , Manii'ed Pinkal , and Km'sten L . 
Worm .  1996 . Coml ) ositional Semantics in Verbmobil . In Proceedings of the 16th , International Cm~:ferencc . on ComFutational Linguistics ( COLING'96') , Copenhagen , l)emnark . 
Johan Box , Bianka Buschbeck-Wolf , Michael Dorna , and C . 3 . I upp .  1998 . Managing in tbr-ination at linguistic interfaces . In Proceedings of th , eIT ( h , Intcrnatio'nalCoT~ference on Com , - p'u , tational Linguistics ( COLING'98) , Montreal , 

Michaell ) or na and Martin C . Einele . 1996.
Senmntic-Based Transfer . In Proceedings of the . 16th,I'lder'nationaICo'n:fi ' . rence on Computational Linguistic , ~( COLING'96) , Cot ) enhagen , 

Michael Dorna .  2000 . A Library Package for the Verbmobil Interface Term  . Verbmobil E , e-port 238 , Institut fiir maschinelle Sprachverar-l)eit m~g . 
. \] ohannes Heinecke and Karsten Worm . 1996.
A Lexical Semantic Database for Verbmol ) il . \[51 Proceedings d the/tth , internatio'na , lCov:fere ' , ,ce on Comp'u , tational Linguistics ( COMPLEX'96) , 
Bud ~ l ) est , Iungary.
Eichard Montague .  1973 . The , Proper Treatment ; of Quantification . In Jaako Hintikka , Julius Moravcsik , and Patrick Suppes , editors , Approaches to Natural Lang , uage , pages 221242 . Reidel , l ) or dree ht . 
Ferlmndo C . N . Pereira and Stuart M . Shieber.
1987. Prolog and Natural Language Analysis.
CSLI Lecture Notes . Center for the Study of Language and hfformation , Stanford , Calitbr-nia . 
Carl Pollard and Ivan Sag . 1994. I tead-
Driven Phrase Structure Grammar . University of Chicago Press , Chicago . 
Uwe Reyle .  1993 . Dealing with Ambiguities by Underspeeification : Construction  , Ie presen-tation and Deduction . Journal of Semantics , 10(2):123-179 . 
Michael Sdfiehlen . 1999. Semantikkonstruktion.
Ph.D . thesis , Universitgt Stuttgart.

