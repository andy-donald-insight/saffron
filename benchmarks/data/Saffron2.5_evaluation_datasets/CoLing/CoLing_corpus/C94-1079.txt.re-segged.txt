PRINCIPAR--An Efficient , Broad-coverage , Principle-based

Dekang Lin
Department of Computer Science , University of Manitoba
Winnipeg , Manitoba , Cana da Ra T2N2, lindek@cs . umanitoba . ca

We present an efI\]cient , broadcoverage , principle-based parser for English . The parser has been implemented in C++and runs on SUNS parc stations with X-windows  . It con-rains a lexicon with over 90 , 000 entries , constructed automatically bapplying a set of extraction and conversion rules to entries from machine readable dictionaries  . 
1. Introduction
Principle-based grammars , such as Govern-ment-Binding ( GB ) theory ( Chomsky , 1981; Haegeman ,  1991) , offer many advantages over rule-based and unification-based grammars  , such as the universality of principles and modularity of components in the grammar  . Principles are constraints over Xbar structures . 
Most previous principle-based parsers , e . g . , ( Dorr , 1991; Font , 1991; Johnson ,  1991) , essentially generate all possible Xbar structures of a sentence and then use the principles to filter out the illicit ones  . The drawback of this approach is the inefficiency due  1  ; o the large number of candidate structures to be . filtered out . The problem persists even when w ~ rions techniques such as optimal ordering of principles  ( Fong ,  1991) , and corontining ( Dorr , 1991; Johnson , 1991) are used . This problem may also account for the fact that these parsers are experimentalnd have limited coverage  . 
This paper describes an efficient , broadcoverage , principle-based parser , called PRIN-CIPAR . The main innovation in PRINCIPAR is that it applies principles to descriptions  o17 Xbar structures rather than the structures themselves  . Xbar structures of a sentence are only built when their descriptions have satisfied all the pri ncil  ) les . 
O dynamic data \ [~ static dalal ) rocegsing module data flow Figure 1: ' . Pile architecture of PRINCIPAR Figure I shows the architecture of PRIN-CIPAR  . Sentence analysis is divided into three steps . The lexical analyser first converts the input sentence into a set of texical items  . Then , a message passing algorithm for OB-parsing is used to construct a shared parse forest  . Finally , a parse tree retriever is used to enumerate the parse trees  . 
The key idea of the parsing algorithm was presented in  ( t i n ,  199:1) . This paper presents some implementation details and experimental results  . 
2. Parsing by Message Passing
The parser in PIHNCIPAR is based on a message -passing framework proposed by \]  , in (1993) and l , in and Ooebel (1993) , which uses a network to encode the grammar . The nodes in tile grammar network represent grammatical categories  ( e . g . , NP , Nbar , N ) or subcategories , such as V : NP ( transitive verbs that take NPs as complements )  . The links in the network re . present relationships bel ; ween the categories . GB-principles are implemented as local constraints attached to the nodes and the network  . Figure ' 2 depicts ~ port:ionC " tilegr ; unmar network for Dnglish . 
'2\It "" IP cpspe ~.., -/~/\~ i
AAI~I'P"NIiVI : 1 t .   .  " . , . . . . " . . . " . .  . . . ." "" . . . .
Aul , P , , , .  '  .   .   .   .   .   .   .   .   .   .  ': ' . . . ." . v . v . v . v . v . v . v ; .   . . . . . . . . . . . . . . '"' "" ,~
V : N~V : ( , ~ x ' adjull ct dominance conlplement domln:lnce specialization specifier do in in ailce head donlina neebarrier 
Figure 2: A Grtunma . r Network
Th(; re~u'e two types of links in 1 , he network : subsumption lnks and dominance l inks  . 
?\[ l . ' here is a SlXi ) sttln\[)tiOlXlink\['rotn(vl ; of l if a subsume . sf t . For exa , in i ) le , since V subsumes V : NP and V : CP , l ; here is a , sul ) smnp tion link from V to ca . oh ()11 o , of them . 
? There . is a donxhia . ncelink frolil node(vi . o / 7 if / 7 cfl , ll ) eimme . dia . tely do in inal ~ ed by O&l . ' ~ Ol'CXi/dllplc , Sill CCa . IXN l ) a . rlii & yiltl-media ? cly dominate a . PP adjim ct , , t;here is a dominance link from Nbar to pp . 
A dominance link fi:omatof lisa . ssoci~ted with an integer id that determiiles tile linear order between fl and other cat  ; egories do lni-m~t(xlt ) ya , and a , binary att ; ril ) ute to specify whether fl is optional or oblig ~ l ; or y . It ln order to simplify the diagrain , we did nol . label tile links with their ids in l " igure 2 . \[ nstead , the precedence between dominance links is ilMie~t > edl  ) y their Input sentences a . rcp;u'sed by passing me . s-sa . gesiut , hegramm ; u ' network . ' l . ' he nodes ill the nel , wor\](are compul , ing agent st ; lxi~t com-nulnica . t . ew il ; he ; ~ choilier 1) ysending messa , ges in tilercv ( HJ so direcl , ion of the links ilx the . network . I'\]a cll node ha . sa . local n lemory t l x a . t , sDol'es a . set of it ; ellx . ~ . Ailil ; em is a triplet thai ; represe . ntsa . ( possibly internplei , e)X-ba , rstrltc-i > llI'(?\[t : < str , art , src > , where ~ tr is an int x_'ger interva . l\[i , j \] denoi , ingt:ixei'i ~ hLoj'l , tl word ill I , heill\[)llt ; still ; el \] eelart is the al ; trilml , cv Mues of the . reel ; node o\[the X barst ; rtlCtAll : (': ; ~Uidsrcisi'~seto\[St ) Ill'CO mess ~ . ~gesProm which this item is combined . The source i ~ less a , ges represent in line di~te constituct lLso\[the reel  ; node . li ', a . ch node in l , hegran nillu : network has a . conll ) letion I ) redicate tllal , deter-tllill CS whether a . nilielna . tl ; lie node . is " coin-plete , " ilx wil Mica . setheit ; elXlissenta . sa , in es-slt ge1 ; oel ; tierll ( )dOS i l l 1~110 \] XVOI'SC direct ion of the links . 
~ Vilena , node receives miit cnl > il ; a diLel31 ptso(:onll ) ine the iten l with il ; ems\['reinother nodes 1 , of or ln He wil ; en is . ' l ~ woit ; or es <\[ i ,, jl \], A ,, S , > a . nd<\[i2 , j2\] , A , 2 , S  ~ , > canI)e combilxed if ?'" a , ( I jacent o each \] l , heirSlll'\[a . cesl , riilgsArcel , her:i7-:jl-I-1 . 
2 . tiieira . tl , ribute vMuesAt midA ~ a . retlHif li~ble . .
. t i l e SOtlrc (~ lTxessa , ~ esCOTHeVii/~diffe . rentIi , ,ks : li , ,ks( , g , ) r ~ li , ,ks(S , ~) = --( k , where links ( , q ) is a . I'illl C~iOlXhal,>giveni ~ seto\[nlessa . ges , returl is these l ; of links via which the iiics sa . gesa , rrived . 
l'he resulto\[I ~ ixe coln binM ; ion is a . \[ le Wil;Oll ; l:<\[il , . i ~\],, mil'y(A ,, A2), S , US . ~> . 
The new il ; em represel xt : sa , la , rger N-ba , rsl ; ruc-t , ure result ; ing from t , hc combination of the two snla . ller cues . 1111; lienewit ; eras <% is flesthelo-ca . l constraint , o\[I ; he node it is considered valid a . ndsa . vedinl ; othelocal lnOIxlory . ( ) l : herwise , ig is disca . rded . Avalidito . nlsi~t ; is fying i ; he com-sLarting poinl,s , e . g ,   ( J precedes IP under Char since the link leading to  ( Jisto I ; heleft , of t . he link leading 1, o1P . 
48 . 7 pletion predicate of the node is sent further as messages to other nodes  . 
The input sentence is parsed in the following steps  . 
Step 1: Lexieal Lookup : Retrieve the lexical entries for all the words in the sentence and create a lexical item for each word sense  . 
A lexical item is a triple : <\[ i , j \] , av ~ lf , av . . . . . p > , where \[ i , j \] is an interval denoting the position of the word in the sentence  ; av~lf is the attribute values of the word sense ; and av , : o , , , , is the attr ibute values of the complements of the word sense  . 
Step 2: Message Passing : For each lexi-eelitem <\[ i , j \] , av ~ lf , av . . . . . p > , create an initiM message <\[ i , j \] , a v ~ r ,   0> and send this message to the grammar network node that represents the category or subcategory of the word sense  . 
When the node receives the initial message , it may forward the message to other nodes or it ma  , y combine the message with other messages and send the resulting combination to other nodes  . This initiates a message passing process which stops when there are no more messages to be passed around  . At that point , the initial message for the next lexical item is fed into the network  . 
Step 3: Build a Shared Parse Forest
When all lexieal items have been processed , a shared parse forest for the input sentence can be built by tracing the origins of the messages at the highest node  ( CP or IP )  , whose str component is the whole sentence . The parse forest consists of the links of the grammar network that are traverse during the tracing process  . 
The structure of the parse forest is similar to ( Billot and Long , 1989) and ( Tomita ,  1986) , but extended to include attribute values . 
The parse trees of the input sentence can be retrieved h'om the parse forest one by one  . 
The next section explains how tile constraints attached to the nodes and links in the network ensure that the parse trees satisfy all the principles  . 
3. Implementation of Principles
GB principles are implemented as local and percolation constraints on the items  . Local constraints are attached to nodes in the network  . All items at a node must satisfy the node's local constraint  , l?ercolation constraints are attached to the links in the network  . A message can be sent across a link only if the item satisfies the percolation constraint of the link  . 
We will only use two examples to give the reader a general idea about how GB principles are interpreted as loc  , al and percolation constraints . Interested reader is referred to Lin ( 1993 ) for more details . 
3.1. Bounding rpheory
The Bounding Theory ( Subjaneency ) states that a movement can cross at most one barrier without leaving an intermedia ~ te trace  . An attribute named ~ hbarr?0r is used to implement this l ) rinciple . A message containing the attribute value - wh barrier iS used to represent an Xbar structure cont Mnlng a position out  ol7 which a wh-constituent has moved , but without yet crossing a barrier . The wdue+wh barrier means that the movement has M-ready crossed one barrier  . Certain dominance links in the network are designated as barrier links  . Bounding condition is implemented by tile percolation constraints attached to the barrier links  , which block any message with + wh barrier and change-wh barrior to + whb arrier before the message is allowed to pass through  . 
3.2. Case Theory
Case . Theory reql fires tha . tevery lexic MNP be assigned anal ) stl'act case . '\]' he implementation of case theory in PI , INCII~AII , is based on the following attribute va Jues : ca , govern , cm . 
+cathe head is , ~ c~se assigner-ca the head is not a case assigner + govern the head is a governor-govern the head is not a governor-cr ~ an NP m -commanded by the head needs case marking The case filter is implemented as follows:  1  . LocM constraints attached to the nodes assign + cato items that represent X bar structures whose heads are case assigners  ( P , actiw . ' V , and tensed I ) . 



- No & ~ . Local C < m straint--l ) \] assign+ca to every item\[assign+cato items with-pass zve assign+ca to items with tense attril  ) nte\]' ; very item at NI ' node is assigned an a . ttribute value-cm , which means that l ; he NI ' represented by l , he item needs 1 , obe case-marked . The-cmal ; tril ) ute then propagates with tile item as it is sent to el  ; her nodes . '\]' his item is said t < ) be the origin of the-cm attribute . 
Barrier links do not Mlow any item with-cml ; opass through , \]) ceause , once the item goes beyond the 1) arri < : r , the origin Of-era will not be governed , let alne case-marked . 
Since each node in X-1 ) arstrncture has at most one governor , if the governor is not a case assigner , the node will not l ) e case-marked . Therei ' or e , a case-filter violation is detected if + govern- cm-ca cooccur in an item  . On the other han<l , if + govern + ca-cm co-ocetl all item ,  + , ; lienthe head daughter of th <; it < , m gov-erns and case : marks the origin of-cm . 
' l'hecase-filter condition on the origin of-cm is met  . '\]' he-cmattril ) ute is cleared . 
The local constraints attached to all the nodes check for the  ( ' . o-occurrences lca , cm , and govern to ensure <: ase-filter is not violated by any item  . 
4. Lexicon
The lexicon in PRINCIPAl consists of two hash tables : a primary one in memory and a secondary one on disk  . Tile secondary hashta . = ble contains over 90 , 000 entries , most of which are constructed automatically by applying a set of extraction and conw : rsion rules to etP tries in OxfordAdwmced\]  , eaner'sl ) ictionary and Collins English I ) ictionary . 
When a word is looked up , t ; he F , rimary hash table is searched first . If a , n entry for the word is found , the lexical search is done . Otherwise , the secondary hash table is searched . 
The entry retrieved from the secondary LaI ) Ie is inserted into the primary one , so , tha , t when the word is encouutered again only in -memory search will be necessary  . 
The primary hash table is lc , aded from a file a . Ll ; he system start up . The file also serves as a buffer for changes to the secondary hashtM  ) le . 
When a lexical entry is a d(led or \] nc , dified , it is saved in the file for the prhnary hash table  . 
The entry in these <: ( m dary hashtal ) le remains unchanged . Since the i ) rimary hasht M ) leisal w ~ ws consulted first , its entrios over ride the ( ; or responditlg entries in these co\[ldary La)\]C . 
The reason why the buffer in needed is that the secondary hash table is designed ill such a way that update speed is sacrificed for the sake of ef\[icie  . tretriew d . Therefore , updates to the secondary hashtal ) le should I > ed one in batch and relatively infrequently  . 
The tw ( > tier organization of the lexicon is transparent to the l  ) arser . That is , as far as the . parser is concerned , the lexic < misano1>jec , that , given a word or a phrase , returns its lexical entry or nil if the entry ( lees not exist in the lexicon . I , cxical rctrievM is very el\[icient , with over 90 , 000 entries , the average l ; ime to retrieve an entry is 0 . 002 secon<l . 
4.1. Lexical Entries
All , hot@l the lexicon currently ttsed in I ) IIN-C'II>AI , contains only syl ~ . tactic information , it ; may also be used to ho Mother types of ilff of mation  . Each lexical entry consists of ai1 e Iltry word or phrase and a , list of functions with a , r - ~ tlllClltS : (< en ~ ; ry-~ord-or-phrase >(< tune-name > < arg > .   .   . < arg >) (< gunc-name > < arg > .   .   . < art >) (<- June-name > < arg > .   .   . < art >))
For exanq ) le ,   ( acknowledge ( subcat ( ( cat v ) )  ( ( ( cat i ) -bare inf ) ) )   ( subcat (   ( cat v )   )   (   (   ( cat n )   ( case acc )   )   )   )   ( subcat (   ( cat v )   )   (   (   ( cat c )   )   )   ) q'\]lef'/ltlctioII subcatt'eturt/sastll ) c& , egoriz & - Lion frame of the word . The first argtlt ne Il ( ; of tte function is the attrHmteva , lues of the word a list of attribute value vector for the complements of the word  . For example , the above entry means that acknowledge is a verb that takes an IP  , NP or CP as the complement . The lexicon is extensible in that users can define new functions to suit their own needs  . Current implementation of the lexicon also includes functions ref and phrase  , which are explained in the next two subsections . 
4.2. Reference Entries
The lexicon does not contain separatentries for regular variations of words  . When a word is not found in the lexicon , the lexleal retriever strips the endings of the word to recow ~' r possible base forms of the word and look them up in the lexicon  . For example , when the lc'xieal retriever fails to find an entry for " studies  , " it searches the lexicon for " studie , "" studi " and " study . " Only the last one of these has an entry in the lexicon and its entry is returned  . 
Irregular variations of words are explicitly listed in the lexicon  . For example , there is an entry for the word " began . "I Iowever , the snb-catgorization frames of " begin " are not listed again under " began  . " Instead , the entry contains a reffimction which returns a reference to the entry for " begin  . "  ( began ( ref ( ( cat v )   ( v formed ) -prog-perf-passive ( tense past ) ) )   ( begin ( cat ) ) ) ) The first argument of ref is the attribute values of " began  . " The second argument contains the base form of the word and a set of attribute names  . The lexical items for the word " began " is obtained by unifying its attribute values with the attribute w dues in the lexiea \] entry for " begin  . " The advantage of making references to the base form is that when the baseform is modified  , one does not have to make changes to the entries for its variations  . 
4 . a . Phrasal Entries \]' he lexicon also allows for phrases that consist of multiple words  . One of the words in a phrase is designated as the head word  . The head word should be a word in the phrase that can undergo morphological changes and is the most infrequent  . For example , in the phrase , " downpayment , " the head word is " payment . " Ind ~ elexicon , a phrase " wl .   .   . wj .   .   .   . w ,, /' is stored as a string "' Wh .   .   . ' tOn , 101 .   .   . ' U , ~ h_l . " That is , the first word in the string is always head word and the words Mter "  , " should appear before the head word in texts . The rune-donphrases convert sil , s arguments into a list of phrases where tile entry word is the head  . 
l , ' or example , the lexical entry for " paymen C'is as follows :   ( payment ( subcat ( ( cat n )   ( n form norm ) ) )   ( phrases ( payment , down ) ( payment , stop ) ( payment , token ) ( payment , transfer ) ) ) After retrieving the entry for a word , each phrase in the phrase list is compared with the surrounding words in the sentence  . If the phrase is found in the sentence , the entry for the phrase is retrieved frointhe lexicon  . 
5. Reducing Ambiguities
One of the problems with many parsers is that they typically generate far more parses than humans normally do  . I " or example , the average number of parses pet ' word is 1 . 35 in ( l\]lack et al , 1992) . That means that their parser produces , on average , 8 parses for a 7-word sentence , 3 d parses for a , l % word sentence , and ld4 l ) a . rses for a 17-words eiRe . nce , rphela . rge number of parse trees make timl ~ roe ( , ssing at later stages more dillicult and error l ) ruTte . 
PIINCII ) AI defines a weight for every parse tree . A weight is associated with every word sense and every link in the parse tree  . 
\[ Pile weight of the parse tree is the total weight of the links and the word senses ~ t t the leaf nodes of the tree  . 
The packed shared parse forest in PtUN-
CIPAI . is organized in such a way that the parse tree with minimum weight is retrieved first  . I~IUNCIPAII , then uses the minimum weight and a predetermined number called BIGWEIGHT  , which is currently arbitraryly defined to be 20 , to prune the parse forest . Only ( minimum weiglit-FBIG WEIGHT/2 ) are spared and output . 
The weights of the links and word senses are determined as follows : e'I'he links fi'omXbar to an ad  , imlctYP have weight = nlGWEIglIW and all the ~ other links have weight = l  . 0 . 
? The words in the lexicon ma , y have an attributerar % which takes w drom very  , very-very . If a word sense has the attribute value ( rare very )  , its weight is BIGWEIGIIT . If a word sense has the attribute value ( rare very-very )  , its weight is 2? BIGWEIGIIT . Otherwise , the weight is 0 , Note that the att ; ributer are is used to indicate the relative frequency among different stmses of the same word  . 
/II ~/ IL big we ! ght
L ',
John John V/~;NP ' ~/ Np/~N ~ , about Kim reada/~b ~ rread/NP . 
a /) N bar
NI~P story/XN story about Kim ( a )   ( b ) Figure 3: Adjunct links ha , rehigher weights Example 5 . 1 . Comparing the two parses of the sentence " John read the story a  , boutKim " in Figure 3: in ( a ) , lee about Kim \] is the co , n-plement of " story "; in ( b ) , it is the a . djunct of " read " . Since the adjunct dominance link from Vbarto PP has much higher weight than the complement dominance link from Nba  . r to PP , the total weight of ( a ) is much smaller them the weight of ( b )  . Therefore , only ( a ) is output as the parse tree of the sentence . 
Example 5 . 2 . The lexical entry for tlm word " do " is as follows:  7%   7%  "  . pv /, . Who Z_~/barWho(traCe)V
Kim \ ~ , big weight\/v % did NPNP love ( trace ) AA ( a )   ( b ) Kim love Figure 4: l , exical items have diff c , ' entweights ( do ( subcat ( ( cat i ) -passive-per ~ ( aux form do ) -prog ( cgorm f in )   ( tense present ) ) )   ( subcat ( ( cat v )   ( rare very ) )  ( ( ( cat n )   ( case acc )   ( n form norm ) ) ) )  ( subcat ( ( cat v )   ( rare very-very ) )  ( ( ( cat n )   ( case ace )   ( n form norm ) )  ( ( cat n )   ( case acc )   ( n form norm ) ) ) ) '\]' ha . t is " do "(: a . nb can auxiliary verb , a transitive verb or a ( li-trmlsitive verb .  \[ , ' i gurel shows two parse trees for the sentence " Who did Kim love ? " The parsel  ; ree(a ) corrcs I ) onds to the correct ; understanding of the sentence . 
hi(b ) , " did " is analyzed as a bi-tra , nsitive w , ' basin " Who did Kima fawn '? " llow-eww , since the latter sense of the word has an attribute value  ( rare very-very )  , tree (17) has much higher weight tha , ntt'ee(a ) and only ( a , ) is otd . lmt , by the i ) ai's(~l . .
6. Irnplementation and Experimental

PRINCII~ARlms been implemented in C-I--I~.
The graphica , 1 user interface is developed with a toolkit called interViews  . The program runs on SUNSpa . rcstatlons with X-windows . A version without ; gral ) hica , luser interface can also be run on most Unix machines with GNUg-f-t-compiler  . 
l , ium ~ d Coebel (1993) showed that the
COml ) lexlty of the message passing algorithm is O ( ICl ' , , . :') ro , . co . l;( . xt-f , : eegra ,, ~, nars , wl . ',',' ~ . is the length of inputs c'utenco , \[ C\[issize
Example sentences
Who do you think Bills a MM ary expected to see I asked which book she told me that I should read The petition listed the mayor's occup ~ t tion as attorney and his agea  , s 71 lie said evidence was obtained in violation o\[' the legal rights of citizens Mr  . Nixon , for his part , wouhloppose interventionill Cllba without specific provocation The ~ Lssembly la  . ngu ~ tgeprovides a means for w,'iting a progra . m and you are , not concerned with actual memory addresses " Labels can be assigned to a particular instruction step in a source program that identify that step as an entry point for use in subsequent instructions * time  ( in seconds ) taken on a Sparc station \] ; ~ LC . 
- -  . , I words\[tmte*p ~ trses:10-110 . 76 i3 0 . 60 t4 13 0 . 55 4 \]3 0 . 51619 O . 80 2 26 4 . 1332 of the grammar ( measure by the number of the total length of the phrase structure rules  )  . 
When attribute values are used in messages , the complexity of the Mgorithm is not yet known . Our experiments have shown that the parser is very fast  . Table 1 lists the parsing time and the number of parses for several example sentences  . The correct parses for all the sentences in TM ) le1 are returned by the parser . 
Even though the lexicon is derived from machine readable dictionaries and contains a \] a  . rge number of senses for many words , the ratio between the number of parse trees and the sentence length here is well bell ow the ratio reported in  ( Black et al ,  1992) . 

The author wishes to than l ? Bonnie Dorr for comments about Sections  1  ,  2 , and 3 . This re'-search was supported by NaturM Sciences and Engineering Research Council of Canadagrant 


Berwick , I1 . . C . , Abney , S . P . , and Tenny , C . , editors (1991) . Principle-Based Parsing : Computation and Psyeholinguislics  . Kluwer Academic Publishers . 
Billot , S . and Lang , B .  (1989) . The structure of shared forests in ambiguous parsing  . In Proceedings of ACL-80 , pages 143-151 , Vancouver . 
Black , E . , L~d Drty , J . , and Roukos , S .  (:1992) . 
l ) evelopment andew duation of a broadcoverage probM ) ilistic grammar of english-language computer manua . ls . In Proceed-in : is of ACL-92 , pages 1185-1192 , Newark , l ) a law are . 
Chomsky , N .  (:1981) . Lectures on Governmentanti Binding . Foris Publications , Cinnaminson,

Dorr , B . J .  (1991 ) . Principle-based pa . rsing for nla , - chhm translation . In ( Herwick et al , 1991), p~ges15 a < 18, 1 . 
Fong , S . ( i991) . The computation M implementation of principle -based parsers  . In ( Berwiekel , al . , 1991), pages 05-82 . 
lla . egeman , L . (11997 l ) . lnl , roductio'n to Government m , f Binding Theory . Basil \] ~ I a . ck well Ltd . 
, \] ohnson , M . (199 l ) . 1) educt i w ~ l > a . rsing : The use of knowledge o\['la . ngua . ge . In ( l~erwiekel , al . ,
Ig . Ol ), pages 3964.
l , in , 1) .  (199") . Prhlciple-based parsing without ow ' . r generation . In Proceedings of A6'13-93 , pages : 112--120 , Columbus , Ohio . 
Lin , I) . and Coebel , R .  (1993) . Context-freegram-m ~ r parsing by message passing . In Proceedings of l , he Fi'lwZCm@renee of the Pacific Association for Comw  . tational Linguistics , pages 203-211 , V ~ mcouver , British Columbia . 
Tomit ', ~, M .  (1986) . l ' Jffieient Parsing for Nal , u-ral Language . Kluwer Ac~u\[emic Publishers,
Norwell , Massachusetts.

