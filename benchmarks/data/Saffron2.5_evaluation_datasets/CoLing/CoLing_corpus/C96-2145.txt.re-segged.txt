Error-tolerant Tree Matching
Kemal Oflazer
Department of Computer Engineering and Info rmation Science  , 
Bilkent University , Ankara , TR-06533 , ~1urkey
ko@cs , bilkent , edu.tr
Abstract
This paper presents an efficient algo-
rithm for retrieving from a database of trees , all trees that match a given query tree appro , imately , that is , within a certain error tolerance . It has natural language processing applications in searching for matches in example-based translation systems  , and retrieval from lexical databases containing entries of complex feature structures  . The algorithm has been implemented on Sparc Stations  , and for large randomly generated synthetic tree databases  ( some having tens of thousands of trees ) it can associatively search \ [ or trees with a small error  , in a matter of tenths of a second to few seconds . 
1 Introduction
Recent approaches in machine translation known as example-based translation rely on searching a database of previous translations of sentences or fragments of sentences  , and composing a translation from the translations of any matching examples  ( Sato and Nagao , 1!)90; Nirenburg , Beale and l ) omas n hev ,  1994) . The example database may consist , of paired text fragments , or trees as in Sat () and Nagao (1990) . Most often , exact matches for new sentences or fragments will not be in the database  , and one has to consider exam-pies that are " similar " to the sentence or fragment in question  . This involves associatively searching through the database  , tbr trees that are " close " to the query tree . This paper addresses the computational problemo \[ retrieving trees that are close to a given query tree in terms of a certain distance metric  . 
The paper first presents the approximate tree matching problem in an abstract setting and presents an algorithm for approximate associative tree matching  . The Mgorithm relies on linearizing the trees and then representing the complete database of trees as a trie structure which can be efficiently searched  . The problem then reduces to sequence correction problem akin to standard spelling correction problem  . The trie is then used with an approximate finite state recognition algorithm close to a query tree  . Following some experimental results from a number of synthetic tree databases  , the paper ends with conclusions . 
2 Approximate Tree Matching
In this paper we consider the problem of searching in a database of trees  , all trees that are " close " to a given query tree  , where closeness is defined in terms of an error metric  . The trees that we consider have labeled terminal and nonterminal nodes  . We assume that all immediate children of a given node have unique labels  , and that a total ordering on these labels is defined  . We consider two trees close if we can ? add /delete a small number of leaves to / from one of the trees  , and/or ? change the label of a small number of leaves in one of the trees to get the second tree  . A pair of such " close " trees is depicted in Fignre  1  . 
2.1 Linearization of trees
Before proceeding any fllrther we would like to define the terminology we will be using in the foblowing sections : We identify each leaf node in a tree with an ordered vertex list  ( re , vl , v2 ,   .   .   .   , vd ) where each vi is the label of a vertex from the root  v0 to the leaf Vd at depth d , and : ' or i > 0 , vi is the parent of vi + L . A tree with n leaves is represented by a vertex list sequence  . VLS = . Vi , V'e, .   .   . , ?, where each V ~ . = v3o , v ~, v ~, .  ? . , va , ; , corresponds to a vertex list for a leaf at level dj  . This sequence is constructed by taking into account the total order on the labels at every level  , that is , 17 i is lexico . qraphically less than Vi + l , based on the total ordering of the vertex labels . For instance , the first tree in Fignre 1 would be represented by the vertex list sequence  : 

I ) ctNPV
I ~ I
AA(I.jN chased
II black cat


Det NP the A < I.jN
II little mouse j ~-..
N\]) VP\])ctNI)
I\]V NP
AINIJ ~ l; , t ; <:/ l)ctNP cat I//~-the Adj-N
IIbrown\]IIO/ISC
I , ' igure 1: Trees tha . t;I . Fecl > S <; to eac . hother . 
((S , NP , Det , a ) , ( S , NP , NP , Adj , black ) , ( S , NP , NP , N , cat ) , ( S , VP , NP , Det , the ) , ( S , VP , NP , NP , Adj , little ) , ( S , VP , NP , NP , N , mouse ) , ( S , VP , V , chased ) assuming the normal lexicogra . phieordering on i,o ( lcna ~ lles . 
2.2 Distance between two trees
We deline the distan <' e1 ) etween two trees aee or ( 1-ing to the struchrral di Jl ~ , , , ' cncesor differences in leaf labels . We consider an extra or a missing leaf a . sa structural change . If , however , both trees It avea leaw ~ s whose vertex lists match in all but the last  ( leaf vertex ) lat > e\] , we . <: on si<ler this as a dil\[erence in leaf lal > cls  . For instance , in I , ' igm'e2 , ( i here is extra , leaf in tree(I )) in < , Oml ) a . r is onto the tree in ( a ) , while tree ( c ) has a leaf label diff c , ,-ence . Wea . sso<:iate the f'ollowing costs associated with these < lifl'erences : ? If I > oth trees have a  . lea\['whoseverl ; exlist matches in all but the last ( leaf w . ' l:tex ) ta--bel , we assign a label < lill ~ renc error of C . 
?\[\[' a certa , in leaf is missing in one of " the trees but exists in the other one  , then we assign a < : ost S for this a structural dilI'erence  . 
We < ' urrently treat all structural or leaf label <\] if :- fere  , <: es as in curring a . cost that is indel > endent of the treelevel at whi <'  h\]  ; he difference takes i ) l acc . 
; t be ;-~ ck


O0 h(1 e?~Ck

X(h ) & \]) C j q - - . . . .
afk

X 0)
Figure 2: Structural and lea\[label < lifl'erences he = tween trees  . 
If , however , ditl ~ rences that ar 0 . closer to the root of the tree are considered to b  ( ' more serious than differences further away\[\]: on ~ the root  , it is \] > os--sible to mo < lify the formulation to take this into ~ tCCO tlnt  . 
2, 3 Conw'xting a set of trees into a the.
Ah'ee databasel ) <: on sists of a set o\['trees '/ ~ ,  "1~ ,  ?  .   .  , 5/~ . , ea . ch "1) being a vertex lists e qu < m ce for a tree . Once we convert all the trees to a linear form , we haw : a set ; o\["vertex list sequences . We can conver this set into a tried at a structure  . This trie will compress ; -'~ l\]yl > ossible redundancies in the prefixes of the vertex list  ; sequences to achieve a . 
certain ( ' ompa <' tion which hell > s during searching . \] For insta . nce , the three trees in F\[gttre 2 can I > e re4>resente<l as a trie as shown in Figm'e ,  3 . 
The edge labels along the t > ath to a h ' af when concat <'  . nate < l in order gives the vertex list sequence for a tree  , e . g . , ( ( a , b , a , x ) , ( a , b , c ) , ( a , b , k ) , ( a , e )) repr <; sent she tree ( a ) il ) Figure ~ . 
tNote that i ~ is possible to obtain mores pa < : c reduction by a Jso sharing any common postflxes of Lhever texlabe \] sequences using a directed acy <: licgraph representation adnot a  . trie , but this does notira-prow : ' the execution time . 
861 la , I ), &, x ) b 24 . b , '1'1 eeaITreec
I'l'reeb
Figure 3: ' l'rie representation of the 3 trees in Figure .  2 2 . 4 Error-tolerant , matching in the trie Our concern in this work is not the exact match of trees but rather approximate match  . Given the vertex list sequence for a query tree , exact match over the trie can be performed using the standard t  ; echniques by fbllowing the edge labeled with next vertex list until a loft in the trie is reached  , ~-md the query vertex label sequence is exhausted  . 
For approximate tree matching , we use the error-tolerant approximate tinite -state recognitional-gorithm  ( Oflazer ,  1996) , which tinds all strings within a giwm error threshold of some string in the regular set accepted by the underlying finite-state acceptor  . An adaptation of this algorithm will be briefly summarized here  . 
hh : ror-tolerant matching of vertex list sequences requires a nerrol : inetric for measuring how r nuch two such sequences deviate from each other  . The distance between two sequences measures the minimum number of insertions  , deletions and leaf label changes that are necessary to convert one tree into another  . It should be noted that this is different fl : om the error metric defined by  ( Wangel
M ., 1994).
Let Z =  Z1, Z . ~, . . . , Zp , denote a generic vertex list sequence of pvertex lists  . Z\[j\] denotes the ini-tim subsequence of Zup to and including the ju~leaf label  . We will use X ( of length rn ) to denote the query vertex list sequence , and Y ( of length n ) to denote the sequence that is a ( possibly pattie . I ) candidate vertex list sequence ( from ( ; he database of trees ) . 
Given two vertex list sequences X and Y , the distance , disffX\[m\] , Y\[n\]) , computed according to the recurrence below , gives the minimum number of leaf insertions , deletions or lea\['label ( : hai~ges necessary to change one tree to the other  . 
dist(X\[m\] , Y\[n \]) = dist(X\[m-1\] , Y\[n-1\]) if x , ~ , = y , , . 
( last vertex lists a . resa . me ) : , ti . < x\[ . ~-l\],z\[,~-,\])+c'ifx . , a , ndy , ~ differ only ~ t t the lea . fl~tbel=dist(X\[rn-11 , Y\[n \]) + , '- , ' if y , , < x , ,(lexicographica . lly)
X is missing leaf#,,.
=  , ti , ~t(X\[ , ,4 , Zb-I \]) + , S ' if x m < y ~ ( lexicogra . phica . lly)
X has~nextral c~ffa : ....
Boundary Conditions dist(X\[O\], Z\[n \]) =, ~ . S dist(X\[m\],Y\[O\]):m . , 5' For a tree database D and at distance threshold t > O  , we consider a query tree represented by a wertex list sequence X\[m\]  ( not in the database ) to match the database with an error of t , if the set C : r\[" , \] lY\[" , \] < 10 and distX\[ , ,~\] , Yb\])-<t is not empty . 
2 . 5 An a lgor i thm for approx imate t ree mat eh ing Standard searching with a trie corresponds to traversing a path starting tom the start node  ( o\[' the trie )  , to one of tllelea\['nodes(of the trie ) , so that the concatenation of the labels on the arcs along this path matches the input vertex list sequence  . For error-tolerant matching , one needs to lind all paths from the start node lo one of the final nodes  , solhat wh . enlhelabels on the edges along a path are concatenated  , lhc resulting " verlea ; list sequence is within a given dislance lh , rcs hold t , of the query vertex list sequence . 
This search has to be very fast if a pl ) roximate matching is to be of any practical use . This means that paths in the trie that can lead to no solutions have to be pruned so that the search can be limited to a very small percentage of the search space  . 
We need to make sure that any candidate ( 1 ) re-fix ) vertex list sequence that is generated as the search is being p'erf brmed  , does not deviate from certain initial subsequences of " the query sequence by more than the allowed threshold  . To detect such cases , we use the notionol'a cnl-off distance . 
The cutoff distance measures the minimum dis -lance between an initial subsequence of the query  ( lidates oqtlOll ( - ( LI , et Y he ; ~ l ) a . rtial candi(latose-< , llleric ( ~ whose l mag this n , and le , tX betl/c query so qll ('\ [ lC(~O\[hmgthm . . I , c'tl = lnin(l , n , -LZ/M\])a , ,(i , , =  , ~ , ~?( , , , ,  , ++\[ Z/i V/i ) wl , e , : oa 4 is ti , ( ,  (( , so of itts ol : tions nnd deloi ; ions . ' l'h(~cut+ol+f distance c,,:d/ . s + t(X\[r , ,\],+7\[,,\]) is defino(la . s .   . : d / . ~( X\[,, . \], r\[,,\]):m  h,d . i . v,(x\[:\],<\[,,\]) . 

Notel ; hat ; ex('ept ; at the boulldarios , the iuitial subscquonces of the query soquence X considor exl  , , . , ; or , (; , , gt ,, EW e41 i , o , o . gt,,,+\[:/A4\] . A , , y initial sul ) scquonce of X short or tha . tlI , loods .   , or oIJ mnLI/M\]l , ~afnodoi ( isertions , ; rodnnyitiitial stll ) string of Xloilger tha . n " uro(ltfiresn loret\[ta . nI-\[I/M\]h ', a . fno(h:(\[cletions , to a . t bast equal Y in I ougth , violating the dist ; mee constrMnt . 
Givcua . vcrl . exlists e , qlw , n (: oX ( corresponding to a , ( tuery l ; reo) , alm . rtial ca . ndidate seqllenco Yisgeu or at ( xlI ) ysu ( :c ( ~ssively ( : oll caten ; ~ting labels a . lougtire ~ u'csastt:+msitions a , rotn~t(le , sta . rting with l ; ho start state . Wl tolm vorwo extcn(tYgoing a , long the trio , we chock if the cutoff distmwo of X and the i ~artial Y is within the botu  , Islu'c-ifiod by the threshold / . If the c , t-olf distnll cogoes l ) o youd I , hothroshol(l , the lasl ; edgo is Imcl ( o < loff ' totim source no do ( in p+u'a , lM  with the short-(' , hint0\['Y ) ~ , i ( l some other o(Igeist ; ried , l \] a . cl ? - tr:-tcMngist : e ( : ursively apl ) lie ( l when t i t ( '\] semr ( : h can . c . 1; l ) e contimled from tlmt no do . If , during tho (' c . l ) ~ sl , ruetion of Y , a , torm in ; q node ( which ma . yorllmy . otl ) o a , leaf of the trie ) is reached without viol a . tittgl,hc(:utoff(listan(:eco . stmail , t,a,n(Id ',: . ~t(X\[ , ,4 , Y \ [ , \]) < tatt , i ~ t poll , , , tti , ; , iV is ++ tr(+cint . h("(l + ~ ta . l > asct . hattt , aJ . chosth('iNl ) Ut(It , or y
S(XlUOnCC .2
I ) (! no L higtile nodes of the trio > ysubs('rilfl ; e(l(l'S(qo being the inil ; i aluode(e . g . , top node in Figure 3)) a , n ( the la . bols of tl : lo edges l)y V , a , nd denoting by 8(qi , 17) the tao do in IJ to t , rie that oiie Ca , llreach\[\[rOllllo(l('qi with edgo la , bolV ( ( ellotillg: , tvortex list , ) , wol)rcsettt , in I , ' igurc/I , the a , lgorithut \ [ Lrgonera , thlga . llY's by a ( slightly tnodifiod ) dopll h-first probing or l , hetrio . '\[' he cru (: ia . \] point illl ; hisa , lgoril , hlnist ha , ttile cut-eli ( list aucoconil ) ut ; t , l ; i onc ; i , obeper\['ortncd very ofticiontly by ui ~tintain hig  ; 1 ilia , trixII whh this ; i , alill , \]) y Itilla . i , rix with el -, . , , , o , , t //( i , j ) = d /, ~: . ( x\[,:\],Y\[ . /\]) ( , ), t + . t < i (: i , at . g , 1992) . We (: ~ ttt-tote that the (' , Ol Ut ) Ul ; ~ tion or l , heolettic ; ntII(i+1 , jq-1) recurs Jvely de . ponds on only //( i , j ), II(i , . 7-i-i ), 11(i+1, j)f , . o , u the earlier d of initiou of tlic edit disl , anco ( seel , ' iguro 5 . )\]) uring the dop l , h first , so ~ u'c , i()t ' the t('i % ont ; rios in cohn nn'n , o1' the lna , trix11\]ia , voI ; oI ) o(ro)contl :) ut ; ed , ottiy when the (' an ( li(hd ; esl ; riligiso\[Ioligthn . \]) urhlgImx'kt , rax:king , I , ho entries for the last coit it lill are 2Nol , et l , ; Ltwcha , vc to do this chock since we may coinc to other irreleva  . nt , tcrmin at nodes during I . he,q(aYch . 
/* push empty candidate , and start node to start search */
P,t . ~ h . (( '  , q0)) while stack not empgy begin l , op((Y' , qi ) ) /* pop par t ia l sequence Y ' and the node */ fo r a l l qj and V such that  6  ( qi , ' l / ) : qabegin /* extend the candidate sequence */
Y = conc:~tt(Y' , V ) /* u is the current length o:17 Y *//* checkifg has deviated too much , if not push */ i * . ', a . ,Zi . ~l(X\[' . , . \], Yb\])-<t then p ', t . ~ h((<q , )) /* also see if we are at a filial state */ i * , Z/s  ~ . ( X\[,,,,\], Y\[,, . \]) < : and q , i is a terminal node then output V end end Figure  4: Algoridmi for error-tolerant recognition o\[' vertex lis~sequences : ii " i  , : i ) , ( ' /  ,   . i + l ) . .  . (/+ J , j ) ,  : ( /+~ , /+: l ) Figure 5: ( k ) uqmt ; M ; iou of the elo . nionts of t , hoIImaJ , rix . 
disca . r do d , but the entries in prior cohumls m : o still valid  . Thus all enl ; ries required by It(i+1 ,   , 7"-I-1) , except I\[(i , j +\]) , axenlre ~ dyawLiht blein the matrix in cohlmnsi -\] a  . n d i . The conaputation of c'uldisl , (X\[ , t , \] , Y\[n\] ) invovcs ~ loop in whioh them in hntun is colul ) uted . ' l'h is loop(hldexing along coh,m , , . 7'+1) co , np , ,tos l l ( i , j + 1) b c fo , ' e it is needed for the computai Aonol 7 ll ( i + l , j + 1) . 
3 Experiniental Results
W ( ; hamocx per in l ( ; nLed with 3 synthcticly goner a . to d sots of trees with the propeJ'tios given in ' l '+> I  ) lc1 . lit this l ; Mqe, . tie third cohllill l ( label AL l ' ) gives the ~ tvera . g c r a t , to of the vertices at each level which a . rora . n domly soie(;te das lea\[vortices in ; ttree . '\[' hc'\['ourth column gives the trl ~ xinmirl nltni-bet of children that au on-lea?no delna  . yh~tvo . 
Tile\[a . st column gives the max in n n n depth of the trees in rite  , t , d ~ ttal ) ~ LSO . 
From I , heso synthetic, . I , nb'-dm , ses , wera . n do \] nl yoxtra . ctod100 trees arid the , perturbed th cnl with ramlom leaf deletions , insertions and la . bolchange so that l ; \] ioy were o\['some(list ml cel'ron ~~ t
Number ALP MaxI Maxof ~ Children Depth
Treesl , ooo ! 1/38I510 , 000\[1/216 I5 a 0 , 0 00/1/2 s__L__A Tablel : Properties of the synthetic databases of reestree in the origina Jtree  . We used thresholds t = 2 and t = 4 , allowing an error of C = 1 for each le~ff label change and an error of S = 2 for each insertion or deletion ( see Section 2 . 2) . We then ranore ' algoridn nonthese datasets and obtained perf of mance information  . All runs were performed on a SunSpare Station 20/61 with 128M real memory . 
The results are presented in '\] . ' able 2 . It can be
Data-\] Thres-base hold 12
I , eaves/\]Search'I ~' ees
Query Time Found /'\[' ree(Msec ) Query 12 . 00 65 1 . 96 12 . 42 81 16 . 65 24 . 65 990 3 . 32 25 . 62 1,659 31 . 59 10 . 45 2,550 13 . 63 10/15 3,492 68 . 6 2 ' Fable 2: Performance results for the approximate tree matching algorithm  . 
seen that the approximates arch algorithm is very fast for the set  ; of synthetic treed ; ~tabases that we have experimented with . It certainly is also possible that additional space savings can be achieved if directed acyclic graphs can be used to represent the tree database taking into account both com-lnon prefixes and common suffixes of vertex list  ; sequences . 
5 Acknowledgments
This research was in part funded by a NATO Science for Stability Phase III Project Grant-TU- 


M . W . Du and S . C . Chang .  \]992 . A model and a fast Mgorithm for multiple errors spelling correction  . Actalnformatica , 29:281-302 . 
Sergei Nirenbm:g , Stephen Beale , and Constantine Domashnev .  1994 . A Full-text l , \] xperiment in Example-based'lanslation . In Proceedings of lhe International Conference on New Methods in Language Processing  , Manchester , UK , Pages 7887 . 
Kemal Oflazer .  1996 . Error-tolerant Finite state Recognition with Applications to Morphological Analysis and Spelling Correction  , Computational Linguistics , Vo 1:22 , No : l . 
Satoshi Sat () and Makoto Nagao .  1990 . rIbwards Memory-based Translation . In Proceedings of
COLING'90 Vol.3, Pages 247252.
Jason Tsong 4 , i Wang , Kaizhong Zhang , Karpjoo Jeong , and Dennis Shasha .  1994 . A System\['or Approximate ' Dee Matching . In IEEI ' ;   7'ansac-tions of Knowledge and Data Engineering Vol . 
6, No . 4, August , Pages 559570.
4 Conc lus ions ' l'his paper has presented an algorithmibrap proximate associative tree matching that can be used in example-based machine translation applications  . The algorithmet \[ iciently searches in a database of trees  , all trees that are " ( : lose " to a given query tree . The algorithm has been ilnple-mented on Sun Sparc stations  , and experiments on rather large synthetic tree database indicate that it  ( ' an perform N ) proximate nmtehes with intenths of a second to few seconds depending on the size ot ' the  . database and the error that the search is allowed to consider  . 

