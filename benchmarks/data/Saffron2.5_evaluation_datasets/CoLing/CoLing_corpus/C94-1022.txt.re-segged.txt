Morphology with a Null-Interface
Harald Trost and Johannes Matiasek
Austrian Research Institute for Artifici M Intelligence  . *
Scllottengasse 3, A-IO IO Vienna , Austria
harald,john0ai.univie,ac.at

We present an integrated architecture for word -level and sentence-level processing in a unification-based paradigm  . The core of the system is a CLP implementation of annilication engine for feature structures uplmrting relational values  . In this framework an IiPSC , -style granl-mar is implemented . Word-level processing uses X2 Molt F , a morphological component I ) a sed on an extended version of two-level morphology  . This component is tightly integrated with the grammar as a relation  . The advantage of this a pl ) roach is that morphology and syntax are kept logically autonomous while at the same time minimizing interface problems  . 
1 Introduction
Over the last few years there has 1 ) eeu a growing interest in computational morphology and phonology  . A number of systems have been developed that deal with word-level processing  . A widely used approach is finite-state morphology  , most notably two-level morphology ( for an introduction , see Sproat 92) . Morphological components are sue eess flfly used for a wide range of standalone applications like sl  ) elling correction a Mhyphenation . One obvious application is the use in NI , P systems geared to the analysis/generation f text . 
Surprisingly , they have not been widely al ) l ) lied in this domain up to now . 
A major reason for this is the llrolllem of interfacing morphology with syntax  . Reflecting tile current trend in syntax towards lexicalism  , unification-1 ) ased systems use highly structured feature structures as in I  ) ut . Translating tile output of morphologie M components into such it rel  ) -resentation has proved to be diiticult . Reducing interface problems is therefore crucial to success  . 
* Financial support for the Austrian Research Institute for Artificial Intelligence is provk led by the Austrian Ministryo \] Science and Research  . We wouhllike to thank Wolfganglleinz for vMuable comments and suggestimls A tight integration between word and sentence level processing also has linguistic advantages  . The boundary between morphology and syntax is fuzzy  . When processing written text the units nmrl > hology has to deal with are  , illittech-nicM sense , not words Mt character strings separated by delimiters  . While these strings roughly correspond to the words of a sentence there are problematicases  . In German , e . g . , zu-infinitive or w'rbs with separMfie prefixes ; L rewritten as a single unit in some instances and separately illothers  . 
The prol ) lem has boon recognized and seine possihle remedies have been prol  ) osed . They all try to minimize or to elhn in Methe intel 'r : tcebe-tweellword and sontoiic  ( : low4 processing . One stop is the descriptiml of word fl ) rmationill terms of a unification-based gl ' all /lnai ' to make the result  ( ~1' morphologicall ) rocessing dir (  , ctly ~ wMhd ) le to syntax and vice w ~ rsa , an : g)l ) roa(-hah'e adyti~ken in X2 Moltl , ' ( Trost 90 , '\[' rost 91) , an extension of two-hweln mrphohlgy . 
The harder probhml is the integration of mor-phol ) honology which is traditionally formalized in it way not easily t  , ': mshmdlle into the fei ~ ture for-malisnx . We will show how this can he achieved by merging the word-level grammar of  X2MolI  . I,'into an lll'S(;-st yl0 graln nla . r , alld by adopting a relational view of its two -level rules  . 
1 l , this llal ) or weass/lille basi cflmfilhu'ity with unification-ha  . seal NI , P techniques and two-low ~ ll nor phology . 
2 Integrating Morphology into
IIPS Gllead-driwm Phrase Smwture Grammar ( IIPSG , Polhu'd , ~ S ; tg 87 , l ' ollard & . Sagin press ) can be viewed as a mono-level Mt multistratal theoryOfgl ' anlnlitl '  , where different stratit relate to different aspects  ( d " linguistic informlttion , but are ropres onted uniformly in feature logics . As such it is well suited as a linguistic theory for our en-It PSG differentiates between three strata---PIION  , SYNSEM and DTItS . Though morphology is not considered in the standard approach  , it suggests itself to be included as a fourth stratumby introducing a feature MORPH into the type sign  . 
Morphotactics are easily described in terms of a feature based grammar  . The problem is how to deal with morphophonology . Two proposals have been made to overcome this problem  . 
Krieger et al 93 encode finite state automata directly in the feature formalism  . Since two-level rules can be compiled into such automata  , roof phophonology can be straightforwardly integrate < l into the grammar  . While this is formally elegant it seems to be no good solution for practical considerations  . First , it is not entirely clear frmn their paper how the problem of null characters can be handled  . Second , encoding large automata will result in a very large and unwieldy type hierarchy  . In general , introducing automata into feature structures and encoding morphophonology directly at that level seems to be too low-level  . 
Bird & Klein 93 argue against the use of two-level morphology because of linguistic considerations  . The linguistic background of two-level rules - -mainstream segmental phonology -- has widely been rejected as a valid linguistic model  . Instead , they base their implementation on autosegmental phonology  ( of . Goldsmith 90) . 
This is certainly linguistically appealing . But there are reasons for sticking to a more conservative approach  . Finite state morphology as a formalism is not necessarily tied to segmental phonology  . There are various approaches to cope with nonconconcatenative phenomena--one of tlmm  X2MoltF   ( Trost 90 )  . Also , for an mnber of languages complete sets of two -level rules do exist and can immediately be brought to bear  . Finally , finite-state morphology has proven to be eflicient while the method proposed by Bird ~: Klein  93 seems to be computationally costly . 
Like the other apl > roaches ours is also based on IIPSG  . I to we ver , we employ a different approach to integration . Our grammar is encoded using a unification engine based on constraint logic programming  ( CLP )  . Besides conventional ttril ) ute-value descriptions this system allows for the direct representation of more general relations  , as they are required by IIPSG . This extension of the formalism is used for the integration of morl > hology  . 
Thus X2MoI~F is treated as one special relation of tile grammar  . As a result , our approach is more modular than the others . While being fully integrated morphology can still be viewed as an autonomous component leading to a morellexible design  . 
We will now give an overview of X2Mol IF he-fore describing the integrated system and its implementation i detail  . 
Word Level Processing

X 2MoRF differs fi'mn standard two-level mor-l > hology hi two hnportant respects  . Continuation classes are replaced by a feature -based word grammar  . This allows for a more line-grained description of morphs  . It is also a prerequisite for a tight integration with a unification-based grammar  .   X2MoRF uses a morph lexicon where each morl > h has one or more feature structures assigned  . The word grammar itself is shnple . 
Morphs have a functor-argument structure along the lines of di Sciullo  , ~: Williams 87 . Affixes are unary functors while stems are arguments without ally further structure  , resulting in a hinary tree structure . 
Tileothe , ' extension concerns the two-level rules , which are supplemented with a morphological filter consisti  , g of a feature structure . This is hnportant because in morl~hol>honology nly some rules are purely l  ) honologically nmtivated . Others are triggered by a mixture of phonologic M and morphological facts  . Such rules cannot be properly represented in tile standardal > proach  . 
TAD , , e . g . , umlaut an<l schwa epenthesis in ( lerman : The third I > erson singular presentense suffix for  (  ; er , nanw ~ rbsis4 , e . g . , sag-t--+sagt . 
For stem sending in a dental , schwa is inserted befi ) retheending , e . g . , bad-t-,badct . This rule does not hold across the whole vocabulary though  . 
Stems of the stroTIg paradign l <1o exhibitumlaut in 3  , ' dPersSgPres which blocks schwaepenthesis . 
The / in aldental of tile stem must be omitted instead  , e . g . , rat-t--+riil . 
Theth , ' eemiles I shown in Fig . lI together with the a . pl ) ropriatentries in the morl > h lexicon ( el . Fig . 7 below)--produce the re<luired behavior . In particular , these rules relate surface N it to lexical $ rAt?t  $   2  .   X2Mold ' ~ can be seen as are -* These rules as well as other data presented in the e ? : amples are simplified for the purl  ) ose of denmnstration 2The lexical character A may have the surface realiza- ( ii ) t : O ? = : : V_4 . :0 t ( iii ) + : e ? = e, . dental_+:0\[sIt\];\[MORPHIMtII . ;ADIEPl . ; NT II ESI . ; -\[-\] Figure \[: Three extended two-level Rules lation between a surface string  ( the wordi ~ or m )  , a lexical string , and a feature structure ( tim interpretation of the word form )  . Relevant for sentence level processing is the morl  ) hosyntactic information and the stem , found as the values of paths MOltPl I\[MIIEAI ) and MOR , Pll\[STE Mres l ) ectively ( of . 
Fig . 9 below ) . This is supplemented by lexeme specific information in the value of SYNSF : M  ( for a detailed description see Trost 93 )  . 
4 Implementing HPSG in a CLP

IIPSG employs strongly typed feature structures together with principles constraining them further  . Well-typcdness requirements restrict the space of valid feature structures  ( cf . Carl ) enter 92 ) : Every feature structure must I ) e associated with a type , and every type restricts its associated feature structure in that only certain features are allowed and the values of these features must be of a certain type  . Appropriateness and value restrictions are inherited along the type hierarchy  . 
The second source of constraints , in order to admit only linguistically valid feature structures  , are the principles of grammar . Pollard , ~ Sag 87 allow general implicative and negative constraints in the form of conditional feature structures  . In Pollardh Sagin press principles are given only in verbal form  . Recent work on formalizing the basis of IIPSG models them as constraints attached to types  ( e . g . , Carpenter et al 91) . I iowever , these distinctions affect only how the applicability of a principle is specified  . Moreiml ) ortant for our present purpose is the form which the constraints expressed by a principle may take  . Besides constraints enforcing simple structure sharing  ( e . g . , the Head Featnre Principle given in Fig . 2 ) there are also complex relational dependencies ( e . g . , in the Subcategorization Principlea ) . Constraints tions a and d . The rule ha . s an empty phonological context but a morphological fiter  . This is an example for the treat-meat of nonconcatenative phenomena in  X2MonF  . 
3, in a headed phrase ( i . e . , a phrmsal sign whose DTRS value is of sort head -struc  )  , the suncAT value of the head like these go beyond the exl  ) ressivity of l ) ure Da-ture formalisms alone and need to be defined in a recursive manner  . 
In order to integrate such complex constraints in the feature unification framework we interpret unitication of typed feature structures under the restrictions of princil  ) led constra . in ts as constraint solving in the CLI'paradigm ( Jafl ' ar , ~ Lassezg 7) . 
In CI , P the notion of unification is replaced by the more general notion of constraint solving  . 
Constraint solvers may be embedded into a logicl ) rogram ufing language it her by writing antet a -itlterl  ) reter or by urn . kinguse of a system which allows \ [ or the implet n  ( mtationel+unificationON-tollS\]OilS . 
The s ~ , cond approacls is taken by I ) MCAI(:l , l ) 4 ( l\[olzbaur92) , itl ) rolog system whose uni-tication mechanls nlis extended in such a way that the user may introduce interl  ) reted terms and specify their meaning with regard to uni\[ica-tion through l'ro log predicates  . The basic mechanism to a chiow , this behavior is the use of attributed variables , which may l ) equalified by ar-1 ) it rary user-defined attributes . Attributed variables behave like ordinary l ) rolog variables with two not al ) le exceptions : when an attributed variable is to be unified with a non-wu'iable term or another attril  ) uted variable the unif i ( ' . at k ) n extensions come into play . For either case the user has to supply a predicate which explicitly specifies how the attril  ) utes interact and how they should 1 ) e interpreted with respect to the semantics of the al  ) l ) lication domain . Unilication succeeds only if these constraint solving clauses managing the cond  ) inati , m-el'vm ' ification -- af the involved at-tril ) utes are successfid . 
The iml ) hm~entati ( m of typed feature structures in our system makes use of the CLP facilities provided by this enhanced Prolog system  . Feature structures are imlflemented by the attri l  ) uted aughter is the concatenation of the phrase's SUBCA Tllst with tile list  ( in order of incre ~ L slng obliqueness ) of SYNSEM values of the COml ) hmlent daughters . "( Pollard & . gag in
I ) ress ) 4I ) MC , AICLP is au enhanced version of SICStus Prolog , awd lahle by anonymous ftp from ftp . ai . univie , ac . at value pairs ( which is empty in case of atomic types ) or a marker indicating uninstantiatedness of the substructure  ( feature structures are instantiated lazily )  . Goals is a list of delayed constraints ( see below )  . Well-type dunification of two feature structures is implemented via the constraint solving clauses mentioned above  , taking into account type hierarchy and feature appropriateness  ( for a detailed description cf . Matiasek & Ileinz 93) . 
Constraints imposed onto feature structures by the principles of grammar are stated in a conditional form where the antecedent is restricted to contain only typing requirements  .   5 In order to account for these conditional constraints we adopt a licensing view : Every node of a feature structure has to be licensed by all principles of grammar  . 
A node is licensed by a principle if either ( i ) the feature structure F rooted in that node satisfies the applicability conditions of the l  ) rinciple and the constraints expressed by the l ) rinciple successfully unify with F , or ( ii ) the feature structure F rooted in that node is incompatible with the applicability conditions of the principle  . The interesting case arises when a feature structure does not satisfy the applicability conditions of the l  ) rin-ciple but is compatible with them . Thus applicability of tile principle can be decided only later  , after further instantiation or unification steps have restricted the  ( sub ) structure rooted at that node . 
In precisely this case the application ( or the al ) an-doning ) of the constraint has to be delayed . The delay mechanism utilize stim Goals slot in the fs  /3   6 attribute , which is dedicated to hold the delayed constraints  . As an example take the wellknown I lead Feature Principle of IIPSG  ( Fig . 2) r . 
The conditional operator == => is translated at read time via  terra_expansion/2 and implements the delay mechanism by coml ) iling l > recon<lition checks into the principle . These antecedent checks trigger either the application of the princiltle  , its abandomnent , or its delay ( by annotating the variables wl fich are not sufficiently constrained to decide on the antecedent with the delayed goals  )  . 
Two advantages of this approach to implement SThis is only a syntactic variant of attaching constraints solely to types  ( Carpenter et al 91 ) and does not permit general conditional structnresms used in Pollard & Sag  87  . 
6pred/n is the usual notation for a nary Prolog predicate  . 
V The operators : : , , ,  : : ,  : , === are defined for typing of a node , path restriction , path concatenation aim value restriction ( type or coreference ) respectively . 
AVM:\[SYNSEMILOCICATII'ED\[\] headed-LD'I ' ItS\[I\[I'  ; AD-DTIIISYNSEMILO <': ICATII 1EAI)\[~\] phrase
Proloq : head_feature_principle(X ) :-
X : := headed_phrase ===>


Figure 2: Head Feature Princil ) le principled constraints are especially important for our present purpose : First  , stating redundant typing re<luirements for embedded structures  ( i . e . 
type restrictions that would follow automatically from well-typing  ) forces delay of the conditional constraint until these sul  ) structures are instantiated . This device can , e . g . , be used to block in : finite recursion in recursively detlned constraints  . 
Second , the right hand part of the conditional is not restricted to feature logical expressions  , but instead can contain arbitrary Prolog goals . In this way constraints involving relational dependencies  ( such as the Subcategorization Principle and the morl > hological relation between a lexical and a surface string  ) can be expressed within the feature for nmlism and there is no need for external devices controll h~g this interaction  . Furthermore , the conditional constraint syntax is not restricted to unary licensing principles but can also be used to express relations  , such as * s_append/3--needed for implementing the Subcatl ~ rinciple--which ap -l > ends two feature structure lists  ( Fig .  3) . Note fs_append(X , Y , Z ) :- fs_empty appond(X , Y , Z ) , fs nonempty append(X , Y , Z) . 
fs_empty append(X,Y,Z ) :-
X : := elist == > Y = Z .
fs_nonempty_append(X,Y,Z ) :-
X::=nelist==>X::first===F,Z::first===F,
X : : rest === X Rest , Z :: rest === ZRest , fs_append(XRest , Y , ZRest ) . 
Figure 3: A1 ) pend for feature structure lists that disjunctiw ~ relations such as append call now l  ) e written a stile conjunction of two specialized cases applying conditionally  . Furthermore , in-morph rule(\[llG , 43  , 116 ILS\] , \[ Sc , dS , 1161 SS0\] , SS , LC on , SCon , F ) : ~! , Sc = 48 , morphology(\[43 , 116 II , S\] ,  \ [48  , 1161 SS0\] , SS , \[ l16ILC on \] , \[ HISC on \] , F ) . 

Figure 4: Sample Two-l , evel R . lemorphology ( LexStream , SurfStream 0 , Surf Plain ln , LexContext , Surf Context , F ) :- instantiate(LexStream , SurfStroam0 , Surf Plain ln , Surf Plain Out , F ) , morph rule ( LexStrearn , Surf Sirearn , Surf Plain Out , LexContext , Surf Context , F ) . 
instantiate (\[ LCILCs\] , \[ SCISCs\] , Surf Plain In , SurfPlainOut , F ) :- valid alphabet_pair ( LC , SC\] , synchronize (\[ SCISCs\] , S1trfPlainIn , S~irfPlain0ut ) , lookahead(LC , LCs , SCs , Surf PlainOut) . 
~ynchronize (\[481_\] , Stream , Stream ) : ~-! . 
synchronize (\[ Char I_\] , \[Char IStream \] , Stream ) . 
Figure 5: The morphology rela . t , iml finite loops due to uninstantiated vari M ) lescan never occur , a cruciM requirement when integr ; tt-ing relational dependencies into stlazy instantiating feature formalism  . 
5 Embedding X2 MouF into the
Feature System
Originally X2MoI tF was realized ~ tsst separate morphological component interfaced to the sentence analyzer /generator only via seq  . ential ( lat ~ transfer . In the case . of analysis , the feature strm > ture representing the word form was transmitted to the parser  . For generation ,   X2MoRF ' expected a feature structure as in lmt reproducing one or more word forms  . Thisl ) urely sequential architecture was not satisfactory lm causo  , of the l ) roblems mentioned in the introduction . 
In order to achieve tight integration , we a(hl ) ta relational view of X2 MoM ; ' and encode the relation between surfiLce string and lexical string < li-reetly without using finite state automata  ( for arguments suI ) porting this ai ) pro~Lch of . A1) rams on 92) . I lowever , our al ) l ) roach extends A1 ) rams on 92 in that it ( i ) explicitly accounts for the insertion of null characters and  ( ii ) introduces the filter concept of X2Mol tF into the relational approach . 
The general format of a two-h wel rules l ) eciIi-cation in our system is LC on <=> Trans it ion <=> RCon\[:-Filter \] in the case of equiwdence rules  , option : d rules are written using only single arrows  ( => and <= )  . 
These rules arocmnpiled into Prologc\]a , uses 8 re-buting the \] oxical and surfaco character streams appropriately  ( see Fig . ,1 for an example of the l-elision rtlle f'or ( \] erlllatl )   . 
q'-obtain ac . rroct relathmship between sur-fa , c ( , and h~xi ( ' alstringe wwy transition has to be licensed I ) yst morphological rule . Transitions not mentioned by rules are handled by a defitult rule  . 
Instantiation of contexts may not be done by the rules themselw  , s , since this would make it impos ~ sible to obt~dn negation via the cut-operator  . Instead , it is handled Sel ) a . rately in a backtrackable f~shion . 
The central relation is the morphology predicate , ( soel " iI '; . 5) nledia . tiug between lexical string , surf : we string ( with inserted n . ll elements ) , the puro ( dellullifiod ) surl ~ w ( ~string and the feature structure of them or l ) hologica . lsign . lnstantiation of pairs is done del ) onding on the possible lexical con in , rations ( the lexicon bei , g represented by a trie-structure ) . The amount of lookahead is detormil md by the current pair which is to be licensed by morph rule  . ' ~ Synchronization of s , r face and lexical string by insertion of mill characters i also ha  . lMlmla . t the insta . ntiatlonh wel . 
Timintogra . tion(fftim two-hwelroh U , ion into KN(II ~! l . hat\]e\[tCollie?Is are encoded reversed to account for the lelt to rlg  , httraw ~ rsa \] af the pair of characters\[ . r ( ! it ll  lS ; . \[ J(' . \[ tCOIItCX tsC~tllberelleHIbered3 . 1ldc\]lecked most efficiently this way . 
9 This interactio , and the lexicon look , p of the feature structure corresponding to the current morph  , which takes pl ; ~ . (: ew hell (: llCOllllt(~l'illg ; kIIIOl'phbOlll/dAryiSnot . '4 hOWl I for the sake of simplMty . 
1 45 the general framework of the feature based sentence-level and word-level grammars is now performed by adding this relation as a principled constraint at the appropriate level  . 
In a definite clause style AVM notation this could be written as follows  ( given that morpho:l . ogy/a is a wrapper around the morphology relation given above  , starting with empty left context and hiding the nullified surface stream  ) : rPnON ~\] strlng/msign LMm~AO mheodjlEAD heod word LSY NSEM synsem The actual imi  ) lementation as a princil ) led constraint in our formalism additionally takes care of delaying the actual enforcement of this relation in case the strings are not sufficiently instantiated  . 
A second provision has to be made in the word level grammar to assn reprol  ) er concatenation of the lexical strings of the morl  ) hological signs being combined . Given the subtyping of resign into marg and m functor  , which in turn has the suhtypes left functor and right functor  , the principled constraints ensuring concatenation of a left functor with its argument are shown in Fig  .  6 . Concatenation is delayed until the ar -concat_right_gunctor  ( X )  :-

X : : arg:m string === subtype_of(string ) == >


X :: m string === M string , concat(hrg , Suffix , M string).
Figure 6: Concatenation of lexical strings gument's MSTRING is instantiated  . Thus , in finite loops when concatenating are avoided . 
As an example we demonstrate how these constraints interact informing the third person singular presentense form of the German verb raten  ( to guess )  . The lexical string is composed of the stem rat and the suffix + t  . The lexical entries of these two morphs are given in Fig  .  7 . 
The two-level rules applicable for this examl ) leare the t-elision rule ( Fig . 4 ) and two rules with filters licensing a-um lavt and epen thesis  , given in right functor

MSTRING " rAt " 1
STEM " rot "
LUMLAUT aou_umlaut JJ verb_stemmarg'STEM\[~ string 
AH"IX"4"t"
M , , , .: A , ) PERSON 3/
LIIMI , AUT\[~\]umlautJverb_form
I-s'r , .: M\[\]l
ARG/\[EPEN q'HESI'1//MI~ , , , D/1-71//IIl ~/ #/ IILtJt?I'b_st ?; TII " UMLAU Tua . 1
Fignre 7: Lexical entries the input notation for our system  ( Fig . 8) . 
lnteract km between syntactic and morphological processes takes place at the word level  . The apl ) lieation of the two-lew ' J rules relating the surface string  ( i . e the pll ON-value of the word ) and the lexic:d-string ( i . e . MORP , IMsTRINC ) is also triggered here . This interaction is completely neutral with respec to the direction of l  ) rocessing due to its relational nature . Parsing is performed by simply instantiating the PIION value  . Generation can be achieved when MORPIII MSTRING is present  , which in turn is obtained by concatenating the lexical strings of the resigns instantiated by the morph grammar  . 
As a result of this constraint interaction the structure shown in Fig  . 9 is obtahm d . Features relevant at the syntactic level ( such as PERSON and TENSE ) are percolated fi'om MORPIII MI1EAD to SYNSI , : MILoc\[CAT\[ll ~ , : al ) via structure sharing constraints attached to the type word  ( this interaction is not shown in Fig .  9) . Information on sul)c ; d , egorization ad semantic ontent for the word is obtained fi-om the lexeme lexicon using MORPIIIsTN MaSakey  . These constraints con > plete the interaction between syntactic and morphological processing at the word-level  . 
6 Conclusion
We have presented afl'amework for " tile tight integration of word level and sentence lew  . q processing in a unification-1) ased paradigm . Tile system is built upon a unification engine hnl  ) lemented in a CLP language supporting types and delhfite relations as l  ) art of feature descriptions . Using this ex-Epen thesis dental <=>'+': e <=> s_or_t:-filtor  ( X , \ [ X::m head:open those ==='+'\])
Figure 8: F'ilterlhiles " PIlON " rift " " MSTRING " rAt +t" 
STEM\[~'l " at "
AFFIX " 4-t "
FEPENT nESE ~"\]
MIIE ADPERSON 3 /\[TI'~NSE tense_pre ~\ [ verb-LUMLAUT\[~ft Oll_tlll  ( lItt_\]
SOFIII MORPII
FMS ' rItIN < I ",' At "\]
All.(;/MI1EAI)\]i > ERsON3I\]
L stem J margright -' word functor
Figure 9: Result of constraint in i ; eri ~ (: tiontended feature formalism , which is in del > en < h , ntly motivated by reqnh'enlents of standard Ill ' St  ;   , iL reiml ) lementation fX2 MoRF was integr , ~ted into the grammar as a specialized relation . 
This architecture has computational as well as l inguistic advantages  , integrating morphology and morphophonology directly into the gralnmar is in the spirit of I IPSG  , which views gramm : crasa relation between the I ) honological ( orgr ~ qllielnic ) form of an utterance and its syntactic/seniantic rel  ) resentation . This way the treatnmnt of phenomena transcending tile boundary between in  ( )r-phology and syntax is also nlade l ) ossil ) h~ . 
On the implementations i(h ~ , the pract i ( ' alproblems of interfacing two inherently difl ' erent modules are eliminated  . For applh : ations this means that using a morl ) hological component is made easy . Nevertheless , this tight integration still leaves morphology and syntaz/somantics a autonomous comI  ) onents , enal ) \] ing direct use , )1' existing data sets descril ) ing morphopholm h ) gy in terms of the two-level p , ~ra(ligm . 

Abramson If . : A Logic Programmiilg View of l ( . e-lational Morl ) hology , in Proceedings of the 15th COIANG , August 2? , -28 ,  1992 , Vol . lII , pp . 850-854, 1992 . 
Bird S . , Klein E . : l '\] nriehing IIPSG Phonology , University of l'\]dildmrgh , UK , Research Paper
I ' ~ UCP/I~1'-56, 1993.
Carpenter B . , Pollard C . , Franz A . :' the ~ pecification and Implementation f Constraint-Based Unification C  , rammars , Proceedings of 2'*' II WPT , Can-curt , Mexico ,  143-153 ,  1991 . 
C , arl > enter B . : The Logic of " l~pedI"calure , S'h'u clures , ( ~ amhridg , , \[ hfiversity Press , Caml ) ritlgeTracts in Theoretical ( ~ Omlmter Science 32 ,  1992 . 
(ilolclsmh . hJ . A . : Anloseym cnhd and Metric all ' hovol-ogy , Basil Blacl ( well , Oxford ,  1990 . 
llolz baur C . : Metastructures vs . Attrilmted Vari-ames in the ( ~ on text of Extensible Unification , inlh ' uynooghe M . and Wirsing M . ( eds . ) , l ) rogram-ruing Language hnplementation and Logic Programming  , Springer , LN(JS6:/1 , pp . 260-268, 19!12 . 
Jatl ' arJ . , lms sez . I . L . : CoI isl . raint Logic Programming , in I'ro (' eodings 14 t . tlACMIK)PI , Conf . , Muifich , 1987 . 
Kriegor II . - U . , Pirkerl I . , Nerbolme J . : Fe~ture-bmsed Allom or ldly , Ih ' oceedings of the : l 1st Ammal Meeting of the At'L , ( k)hmll ) us , Ohio , Pl ) .  140-147, 1993 . 
Matiasek J . , . llein zW . : ACLI~Based Approach to l IPS(; ,   ( ) sterrei ( : hisches Forschungs institut fiir Artificial h , telligen (: e , Wien , TI(-93-26 ,  19!): . 
l > ollard C . J . , Sag I . A . : hiformation-Based5'ynlazond5'emmdics , Uuiw ' rsity of C\]licago Press , Chicago ,  1987 . 
l ' ollard , (2 . I , . % gI . A . : Ih'ad-l ) rivcn PhraseSh'vchtre(;ra , mlar , I/niw'i'sil . y of (: hicago Iq'oss and (~ Sl , Il > uhlicat . ions , in press . 
di , q('iulloA . -M . , ViliialnsI'\] . : Oillhr\[)ef initioli of Word , MIT l'ross , Caulbridge , MA ,  1!)87 . 
Sproal . R . : Morphologyalid Coniputalion , MIT Press , ( Janibridge , MA , ACI , -MIT Series in NLI' ,  1!)92 . 
' l'rost 11 . : The Appli ( mtion of Two-Level Morphology to Non- ( ik ) ncatenal . ive(i ~ el ' lilall Morphology , hiI ( arl-gren II . ( ed . ) , liroce(-dings of the 13th COLIN(\] , lh ' lsinkl , F ' inland , 1q ) . '371-376, 1990 . 
Trost II . : X2MORF : A Morphological ( JoDlpoli011~13 as i , dOllAugniei/l>ed'l'wo-Lew~l Morphology , ill Proceedings of the 12th IJCAI , Morgal/Ka/ifilianil ,   , ~ ttll~/llti , eo)C , i11) 1) . 1()24-1030, 1991 . 
Trost\]l . : ( k ) ii hlg with l ) eriv at . ionina . Morphological Conlpl ) lienl . , ill 61, 11 ( Jollference of the Eilropea il Chal)l . er of the ACI , , Ul . recht , pp . 368-376, 199,1 . 

