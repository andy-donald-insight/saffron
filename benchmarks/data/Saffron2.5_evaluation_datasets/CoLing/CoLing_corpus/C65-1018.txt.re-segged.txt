
"1965 International Conference on Computational

A Heuristic Approach to Natural
Language Processing
Denis M . Manelski and
Shell Oil Company
50 West 50th Street
New York 20, New York
Gilbert K . I ~ l.ee
Northwestern University
Technological Institute
Evanston , Illinois
Manelskl & Krulee


This paper is concerned with the design of a processor capable of formalizing English language descriptions of problems in the sentent lal calculus  . The emphasis is on the design of a system with natural language processing capabilities  , but the formal languages specified are oriented to the problem context  . 
A series of automata are specified to carry out the necessary functions  . The automata identify the premises in the problem strings ~ specify the appropriate logical connectives among the premises and determine which premises are meaning-equivalent  . The syntax of each automaton is defined and examples are used to illustrate their functioning  . 
The automata accept statements in the language L1 , the set of English statements of problems in the sentent lalcal culus  . The individual premises p@ L1 are recognized by the syntax ~ , where ~ is chosen so that the language L2 recognized by it is a subset of L1  . Furthermore , the strings in L2 are restricted to the declarative sentences . Once the premises and their logical connectives have been identified  , those that are meaning-equivalent are located in two additional steps  . First the L2 description of the string is mapped into a string in  L3  . The L3 language consists of a limited set of canonical forms that ease the problem of establishing meaning equivalence of premises  . Finally , the automaton applies heuristically a sequence of problem-or lented and meaning-preserving transformations in order to establish meaning -equivalence  . Two premises are taken to be meaning-equivalent if one can be deduced from the other  . 
Otherwise ~ they are taken to be not meaning -equlvalent  . 
Manelskl & Krulee
LANGUAGE PROCESSING 1

The recent evolution of programming languages has tended to improve communication between man and computer  . The use of mnemonics ~ automatic storage allocation ~ English-like operators  ( such as in COBOL ) and problem-oriented languages has greatly facilitated the task of the programmer  . Thus , the solution algorithm for a large class of computational problems can be defined with relative ease in languages such as FORTRAN and ALGOL  , specifically designed for these classes of problems  . 
This paper describes an attempt to further simplify the communication between programmer and computer by defining a system which can produce a formal description from its natural  ( verbal ) input .   2 In order to study this approach a specific problem area was chosen  , the propositional or statement calculus . It will be evident that the problem area chosen has influenced the design of the system  ; nonetheless it should be clear that the linguistic capabilities of the system are general rather than specific to the problem context  . 
In designing this processor , two major abilities are required . 
First , the processor must be able to identify each elementary premise and all logical connectives  . It must also determine which premises are to be taken as equivalent  . 
i This research was supported by Grant G-17951 of the National Science Foundation . A majority of the system has been programmed in the list processing language IPL-V  ( Newell ,  1961) . 
2 For a more complete description and some program listings see Manelski  ,  196~ . 
Manelski & K rule e ( see Fig .  1) . The first automaton , A 1 , accepts as its inputs the language L1 , where L1 is the set of all English language statements of problems in the propositional calculus  . This automaton is concerned with the identification of the premises and logical connectives of a problem  . This is achieved by using a syntax~capable of recognizing strings in  L2  . where L2 is a subset of L1 . The syntax ~ consists of a hierarchy of syntaxes ; a phrase structure syntax~idesigned to recognize a subset of English composed of simple declarative sentences and the set of ' transformations specified by ~ T  . I The equivalent premises are identified by the automata  A2 and A3  . The automaton A2 maps a premise , identified by AI ~ into a canonical form specified by the syntaxC that defines the language  L3  . This step is designed to facilitate the distinction of equivalent premises  . Finally A3 applies a sequence of meaning preserving transformations from the set TO = ~ TI  , T2 ,  . . . ~ Tm  ~ on the string ( ~ r,~'s ~ L3 such that if:
TiTj ''' T % ( ~ r ) : ~ s with TkCTO the two strings are considered meaning equivalent  . Should the system be unable to find a deduction satisfying these conditions or under certain other heuristically chosen criteria the  strin6~s are asslnned to represent different premises . 
In order to test the system described in this paper  , problems were drawn from Stoll (1961) . Some will be used later to illustrate the capabilities and inadequacies of the present system  . 
1 Chomsky's discussion of transformations and the inadequacies of various models for natural languages can be found in the monograph " Syntactic 
Structures ".
96 ~' r ~ u ~ ~ JN , k /
I1F-~U ~ , , , 4U
P , I , 1~0~t~4

I 1(~?
Q . < or ~ u ), GJ ?) u , IJ r , n.<.
Manelski & K rule e terms of its syntax . Finally the information flow for its implementation as a computer program will be outlined  . 
Characteristics of the Natural Language Processor ( AI ) The automaton A1 , as mentioned in the previous section , consists of two completely different syntactic mechanisms  . The system includes a phrase structure syntax designed to recognize an extremely restricted subset of the English language  , simple declarative sentences . The syntax of the processor also includes a limited set of transformations chosen to enhance the power of the language generated  , but also specifically chosen for the problem context  . 
If we consider the syntax of A1 ,  ~  , as consisting of ~ l and T we have defined a hierarchy of languages : 
L1~L2~I~l
Here L1 consists of all the legal problem statements ;   L2 consists of the set of strings recognized by ~ ; and L~l consists of all the strings recognized by the syutax ~  . Thus , the syntax ~ of the automaton A1 is really composed of two disjoint sets of rewriting rules  , ~l and ~ T . 
The syntax~lisa phrase structure crammar designed to generate or recognize a subset of English Composed of simple declarative sentences  . 
The syntax ~ T contains a set of transformations designed for the purposes of isolating premises and specifying logical connectives  . This hierarchy can be visualized in Figure 2 . 
IIII 1?6,
F : l.~ure2
Manelski & Kruleeby 91~ and then characterize the strings recognized by P  . From the following discussion it will be made clear that we are building a recognizer rather than a generator  . The automaton A1 will not perform syntactic analysis below the level of the alphabet  ( i . e . , words ) of the language . Thus ~ the processor w ? uld recognize :
The bridge was high
The bridges was high as the same sentence since the differences are at a level below that specified by its syntax  . 
The processor consists of an alphabet A , where : A = Nu DuP Nu ADJu VEQ uVTR uVIN u VFACUVAUX oPREP uAD VuTHAN uADJC with the sets representing : 
N : noun
D : determiner
PN:pronoun
ADJ:adjective
VEQ : verb equational
VTR : verb transitive
VIN : verb intransitive
VFAC : verb factitive
VAUX : verb auxiliary
PREP : preposition
ADV : adverb
ADJC : comparative adjective
THAN : Than
Manelski & K rule e the linguist , in general , if X i and X j are sets comprising A we expect x i xj for iJ where ~ represents the empty set  . The occurrence of an element of the alphabet in more than one word class is known as homography and is common to the natural languages  . 
For purposes of derivation , we distinguish between the elements of the alphabet  , to be known as the " terminal " elements , and the symbols the nonterminals . 
from the syntax such as S , NP , ADJ , etc . , which will be referred to as The word assignments might be as shown in Table  1  . 
N ..
D =
PN =
ADJ =
VMEQ =
V ~ R =
VMINTR =
VMFAC-

PRP =
ADV =
AI~C = man , boy , house , ...
a , the , ...
he , they , ...
blue , large , ...
is , are , ...
hit , hits , ...
rained , went , ...
appoint , call , ...
will , should , ...
in , to , ...
quickly , slowly , ...
larger , better , ...
Table 1
Although the processor is limited in the size of the available dictionary  , for purposes of discussion no limitations will be assumed  . 
In addition it is necessary to specify the syntax of the recognizer  , which uses the rewriting rules of the axiomatic ~ system ~ l in Table  2  . Examining the syntax ~ l , we see that it meets all the requirements of a phrase structure grammar  . Also , ~l generates several classes of strings characterized by the verb type  . Since this classification will be fundamental to the design of  A2  , we shall give some examples in L2 and laters how the mapping of A2  . 
Manelski & Kru . leei ) S-~NP+VP2) NP-,D+N

PN3 ) NP-~NP+PRP 4 ) PRP-~PREP+NP 5 ) N-~ADJ+N 6 ) AOJ-~AOJ+ADJ7 ) PA DJC-~ADJC+than+8 ) NP ~ NP + NP 9 ) VP-~VEQ+PREDEQ
VTR+PREDTR
VITR+PADV
VF AC+PRED FAC 10 ) VEQ-~VMEQll ) VMEQ-~VAUX+VMEQ 12 ) PREDEQ ~ NP


PADJC 13 ) VITR-~VMITR 14 ) VMITR-~VAUX+VMITR 15 ) PADV ~


PRP 16 ) PADV ~ PADV+PADV 17 ) VTR-~VMrR 18 ) VM~R-~VAUX+VM ~ R19 ) PREDTR~NP
NP+PADV
NP+PRP
NP+NP 20 ) VFAC~-VMFAC 21 ) VMF AC-~VAUX+VMFAC 22 ) PREDFAC-~NP

NP+PADV
NP sentence , noun phrase , verb phrase determiner , noun pronoun prepositional phrase preposition adjective comparative adjectival phrase  , comparative adjective verb equational , equational predicate verb transitive , transitive predicate verb intransitive , adverbial phrase verb factitive , factitive predicate main verb , equational verb auxiliary main verb , intransitive empty main verb , transitive main verb ~ factitive
Table 2
Manelski & Kruleel O
The syntax~lidentifies four verb types , equational verbs , intransitive verbs , transitive verbs , and factitive verbs with their corresponding predicates  . The following examples show some of the possible sentences : 
Equational verb : ( i ) John is home.
( ii ) Johnistall.
( iii ) John is by the house.
( iv ) Johnistaller than Peter.
A derivation of ( ii ) in the syntax ~ lis ( S ( NP ( N John ) )  ( VP ( VEQ ( VMEQ is ) )  ( PREDEQ ( ADJtall )   ) )  ) 
Intransitive verb : ( i ) The Dodgers win.
( ii ) The Dodgers winsel dom.
( iii ) The Dodgers win money.
( iv ) The Dodgers w in at home.
The derivation of ( i ) is ( S ( NP ( D The ) (N Dodgers ) ) ( VP ( VITR win ) (PADV? ) ) ) 
Transitive verb : ( i ) John loves Mary.
( ii ) John loves the winnings from the track.
The derivation for ( it is
John ) loves ) Mary S ) 555
Factitire verb : ( i ) John called home.
( il ) John called his friend a fool.
F~nelski & Kruleeii
The derivation of ( i ) is ( S ( ~P ( N John )   )   ( VP ( VFAC ( V~FAC called )   )   ( PREDFAC ( ~P ( NMary )   )   )   )   ) Several types of sentences will not be recognized by ~ l  . Some of these could be included by additional productions  . Some additional types of sentences will be recognized when ~ T is added to the syntax  . Other sentence forms are not considered necessary within the original problem conte ~  . Let us list some of the sentences in LI that are outside of the capabilities of recognition with ~ i  . 
Imperative sentences :
Gohome.
Interrogative sentences :
Is Johncoming home ?
Passive sentences:
Home is where John should be.
Conditional sentences :
If John should come home ...
Compound sentences :
John will go home and Mary will stay.
Complex sentences:
John , should he so desire , will go home.
In order to make the processor A1 useful in the problem context , it is necessary to increase the class of strings in  L2  . In contrast to the syntax ~ i , which uses the rewriting rules on the nonterminals in the deduction string  , the transformation set rT is designed to operate on the derivations in ~ i  . Generally , transformations have
Manelski & K rule e increasing the class of strings that a formal language can generate  ( 39 )  . 
However , our problem is to use ~ T in order to simplify the class of strings that ~ l will have to recognize  . Thus , our transformation set rT should decompose the string 
John will go home and Mary will stay.
into the following simpler strings : ( 1 ) John will go home . 
( il ) will stay.
Since we are interested in formalizing the natural language inputs as statements in the sentent lal calculus  , the transformations will also give us information as to the appropriate logical connectives for the premise  . Thus , in the previous example our processor could be expected to define a statement of the form : 
P ; k g
In order to explore the powerful linguistic possibilities of transformations  , a limited number were chosen . We shall now define the transformations and show how the linguistic capabilities of  A1 have been increased . 
The transformation set ~ T presently contains as its axioms : 
T = ~ TNOT , TCOM , TCOND ~
In order to specify a transformation , we must not only define the structural changes it produces but also the class of strings to which it is applicable  . The transformations ~ as defined in ~ T were adapted for  A1  . Since we are not interested in generating grammatically 
Manelski & K rulee form recognizable to ~ l , it is possible to omit the transformations for tenses because they operate at a level lower than that of the terminals  . By implication ~ 1 will process strings that are not grammatically correct  . Thus , if A1 were presented with the sentence :
If it were cold tomorrow ~....
the transformation TCOND will give as its output :
It were cold tomorrow.
This premise would still be processed althouch it is grammatically incorrect  . 
Another difference between the transformations as specified by Chomsky ~ and those used by  A1 is in the direction of the mapping . 
The ~ T transformations have L2 as their domain and the kernel strings generated by ~ last heir range  . This is the inverse of the mappings considered by Chomsky  ( 1957 )  . 
TNOT : is defined on strings of the form ( i ) . .+ NP + VAUX + not+VMTR+ . . . 
( ii )..+ NP+VAUX+never+VM ~ R + ...
( iii ).. + NP + V ~ EQ + not + ...
( iv ) .. + NP + VMEQ ~ never + ...

(vi )..+ NP+VAUX+never+VMEQ * ...

(viii )..+ NP+VAUX+never*VITR+.?.
( ix ) .. + NP + never + VITR + ...
Manelskl & K rulee(xi ).. + NP+VAUX+never+VTR . .
( x?i ).. + NP + never + VTR + ...
( xill )..+ NP+VAUX+not+VFAC+...
( xiv )..+ NP+VAUX+never+VFAC+...
( xv ) .. + NP + never + VFAC + ...
Should a string ~ 1 correspond to one of the above patterns TNOT ( 0-1 ) becomes : ( i )  . .+NP+VAUX+VMrR+ . . . 
. ( ii ).. + NP+VAUX + ~...



(vi )..+ NP+VAUX+VMEQ+...
(vii )..+ NP+VAUX+VITB+...
(viii )..+ NP+VAUX+VITR+...
( ix ).. + ~ P+v I ~+ ...

( xi ) .. + NP + VAUX + VTR + ...
( xll ) .. + ~+ VTR + ...

( xiv ).. + NP + VAUX + VFAC + ...

Examples of some of the cases follow:
Manelski & Krulee
TNOT (~): John will hit Mary.
( ~2: Today is not cold.
TNOT~--2): Today is cold.
~3: Tomor row will not be cold.
TNOT~3): Tomorrow will be cold.
~-4: John never suffers.
TNOT(q-4): John suffers.
TCOM : operates on strings in the following domain only:  ( i )  ?  . + Sl + and + S2 + ? ? ?( ii) . .+Sl + ,+ s2+ . . . 
( iii ).. + SI + ore S2 + ...
( iv ).. + Sl + then + S2 + ...
(vi ) Either+Sl+Or+S2+ ...
(vii ) Therefore +, + Either+Sl+or+S2+?.;
The range of the function is any string with the following format : 
SI
S2
Here the information between " SI " and "$2" is used by the processor only to establish the Boolean connectives for the statements  . Some examples will show the effect of TCOMOn strings ~' in the domain of the transform at ion  . 
~' i : Either Sally and Bob are the same age or Sally is older than Bob  . 
TCOM~I ): Sally and Bob are the same age.
Sally is older than Bob.
Manelski & Krulee
TCOM(~): The races are fixed.
The gambling houses are crooked.
TCOND : is defined over strings wlth the following configuration :  ( i )  . .+ If + Sl + . . . +, then +$2+ . . . .
(li ).. + If + Sl + ... +, +$2 + ...
and has as its range the following forms : ? . + Sl + .   .   . 
?.+ S2+...
As in the other transformations its application defines the logical connectives for  A1  . 
We can see the effect of TCOND on the following strings : ~ i : If the Dodgers win ~ then Los Angeles will celebrate ? 
TCOND(~I ): The Dodgers win.
Los Angeles will celebrate ?
The definitions of the syntactic elements used in establishing the domain of ~ T are given by the phrase-structure grammar ~ i  . Another convention used in the discussion is to allow a series of dots  (   . . . . ) to refer to any syntactic structure . It is also implied that the transformations may be concatenated as necessary  . 
To illustrate their use , we utilize the following examples : ~ i : If the then Los Angeles will celebrate  , and Dodgers wln ~ if the White Boxwin , Chicago will celebrate . 
TCOND(~I ): The Dodgers win.
Los Angeles will celebrate and if the White Sox win  , 
Chicago wllce lebrate.
Manelski & Krulee
Los Angeles will celebrate.
If the White Soxwin , Chicago will celebrate.
Dodgers will win.
Los Angeles will celebrate.
The ~ nite Sox win.
Chicago will celebrate.
~ '2: If I miss my appointment and start to feel downcast  , then
I should not go home.
TCOND ( ~2 ) : I miss my appointment and start to feel downcast . 
I should not go home.
TCOM(TCOND(~):I miss my appointment.
Start to feel downcast.
I should not go home.
TNOT(TCOM(TCOND(~2)): I miss my appointment.
Start to feel downcast.
I should go home.
In this example the resultant strings are not recognizable by ~ i  . Thus ~" start to feel do ~ n cast " has its subject implied by the preceding string  , and could be thought of as " I start to feel downcast "  . 
Some of the difficulties caused by the transformations can be overcome by AI  . 
Manelski & K_rulee
In order to design a processor of the type described in the previous section it is necessary to specify the relationship between the recognition rules ~ l of the phrase structure grammar and the rewriting rules ~ T of the set of transformations  . Clearly ~ l and ~ T are interdependent since the input cannot always be analyzed in terms of the syntax ~\]  . and because the rewriting rules of ~ T are defined in terms of  1  . Perhaps an example illustrates this point more effectively  . Consider the inp ~ string : If John went to the store then Mary went home  . 
This is clearly a case in which we sho~dapply TCOND ~ T in order to obtain : 
S1-John went to the store.
$2-Mary went home.
However , the processor cannot find S1 and S2 because they are defined in terms of ~ 1 which cannot determine S1 and $2 since it cannot analyze strings such as " If John went to the store  . . . " . This vicious circle has been resolved by determining heuristically when the transformations should be applied  . If the strings resulting from the application of the transformations cannot be analyzed by ~ i ~ the system attempts to apply the transformations again  . 
The general hierarchy of the programs can be found in Figure \] ~-  . 
The program DO embodies the essential features of the automaton AI  . A brief description of the various subroutines involved will serve to illustrate the workings of the processor and the difficulties that it might encounter  . 
Manelski & K rulee functions . Initially , certain keywords are marked in the problem input  ( giving rise to the hypothesized input string ) and later the set of transformations are used in conjunction with the marked words to generate possible premises  ( to be called " input strings " )  . 
The necessary information can be more fully explained by considering a program DO designed to implement  A1   ( see Figure 3 )  . The program DO initially calls the subroutine D15 which performs a left-to-rights can on the problem string  . All elements of the set MTO(where MTO = ~ if , then , and ~ or , not , never , either , therefore . 
then , ~ the last two elements are the symbols " , then " and " , ") are marked . 
After marking , the problem string becomes both the input string ( i . s . ) and the hypothesized input string ( h . i . s . ) . The syntactic analysis of an h . i . s , is attempted by EO . Failing to find a satisfactory parsing ~ control is transferred by  D2 to DI ; otherwise control goes to DI3 . The subroutine D13 searches for an additional h . i . s . ; on finding one , it deletes the successfully parsed string from thei  . s . and the list of h . i . s . Should no other h . i . s , be found , the executive calls D14 which halts the program . After performing the necessary output functions , D1 scans the h . i . s , currently being processed . If any marked words are found , control is passed to D3 ; otherwise the transfer is to Dll . Dllerases the previous h . i . s , and replaces them ( i . e . , all of them ) with the i . s . Should D1 find that some of the words are marked , the processor 20 . 
DOz Start
DISz marka~l words in MTO .   . ~ '  .  ~'~  . / t'D2 . Wasa satisfactory parsing / . '  . found for scrlng ?/!/ ~\ Dl6: stop ~ ~ D13Z are . y additional ( ~/ pu ~ . tring . ? S ~ o\'~/No . DI ~ are there any marked
DI0z Try Cofill In ~ ~ . ~sized input : string ?
Yes / D9: Does stringii ~ Copy Input string as ~ . begin with hypothesizeds Cr lns ?
D31 For TNOT ?.......~>


D4z For TCOND ?....

DSzF or TCOM ? xes ) ' N or ?
D6z Apply TNOT
D7: Apply TCOND ~ D8: Apply TCOM

Scop
Figure 3
Manelski & K rule etestroutines D3 , D4 or D5 in transferring control to D 6 , D7 or DS~respectively .   D3 transfers control to D6 when " no __~ t " or " never " ( the underlining is used in this section to indicate the symbols as marked  . ) are in the h . i . s . ; D 6 deletes the marked symbol from the h . i . s . The subroutine D5 is only applied when the h . i . s , begins with " if "" it in turn transfers control to  D7 which deletes the first of the marked "" .   .   .   . then " that it finds in the h . i . s . symbols " then " , " therefore , ? or ~_While removing the marking from the corresponding symbol in the i  . s . 
two new h . i . s , are created by dividing the list at the location of the marked symbol  . D5 and D8 are similar to D4 and D7; however , division of the h . i . s , is done on " and " , " or " or with the symbol " either " be ingerased from the beginning of the h  . i . s , if it is present . The routines D6 ,   D7 and D8 transfer control to D9 which is called to test whether the h . i . s .   , being processed , begins with a verb : if this condition exists HO attempts to precede it with the f irst noun or pronoun of the previous h  . i . s . Should it not be possible for the processor to carry out this operation  , the program prints out the syntactic analys is it has accomplished and halts  . Both DIO and D9 transfer to EO . 
Some examples will clarify the logic of DO . Let the input string ~1 be: ( ~' l : John and went home . Mary
Manelski & Krulee




DI4: transfers control to DI5.
marks the word ' and "; the h . i . s , is " John and Mary went home ( the underlining indicates the marked word )  . 
parses " John and Mary " went home.
there are no additional h.i.s.












John went home and Mary went to the store.
transfers to DI5.
thei . s . and h . i . s , become John went home and Mary went to the store . 
fails to parse the sentence.
transfers to D1.
transfers control to D3.
control parses to D4.
transfers control to D5.
transfers control to D8.
thei.s . becomes
John went home and Mary went to the store.
while the h.i.s , become
John went home.
Mary went to the store.
after testing the h . i . s , at the top of the pushdown list ( John went home ) transfers control to EO . 
Manelski & Krulee












D7:09: successfully parses the current h.l.s.
transfers control to DI3.
locates the next h.i.s.
successfully parses the h . i . s , at the top of the pushdown list ( Mary went to the store )  . 
transfers the processor to D13.
cannot locate any additional h.i.s.
prints the results of the parsing.
If John , Peter and Paulwere at the game , ...
calls D15.
marhs the problem string as " If John ~ Peteran__ ~ dPaul were at the gs~ne ~  ,   . . . . ' which is copied as the h . i . s . 
fails to find a deduction for the h.i.s.
transfers control to DI.
transfers control to D3.
transfers control to D4.
transfers control to D7.
the marked words have the structure required for TCOND and changes the i  . s . to " l_~f John , Peteran __~d Paul were at the game ~ . . . . " and the h . i . s , become " John " " Peter and Paul were at the game  . . . ." the h . i . s , does not begin with a verb . 
Manelskl & Krulee
















D4: fails to find a parsing.
transfers control to D1.
the h.i.s."John"has no marked words.
the " previous i.s . becomes the h.l.s.
" If John , Peteran __~d Paul were at the game, . . . " fails to find a parsing . 
transfers control to D3.
calls subroutine D4.
Ir finds the marked " If " and "? calling for TCOND  . 
the h . l . s , become " John , Peter " " Paul were at the gam 2A . . . " and thei . s . is marked as " If John , Peter and Paul were at the game & . . . " the h . l . s , does not begin with a verb . 
a satisfactory parsing cannot be found.
transfers the processor to D1.
there are no marked words in the h.i.s.
the h . i . s , becomes " If John , Peter and Paulwere at the game z . . . " fails to flnd a parsing . 
transfers control to D3.
calls D4.
finds the " If " and "2" for TCOND.
Manelski & K rulee " John , Peter and Paul were at the game " ( the remainder of the sentence is a separate h . i . s . ) . 
thei . s . is changed to " If John , Peter and Paulwere at the game ,  . . . "
D9: transfers the processor to EO.
E0: analyzes the first h . i . s . The program would then analyze the remainder of the sentence  . 
As indicated in the above examples the parsing of thei  . s . is attempted by subroutine E0 , using the syntax specified in Table 2 . The presently implemented version of EO uses a bottom-to-top search in the sense that the parsing tree always begins by analyzing the input string  1 rather than the set of productions . In addition , the subroutine is " predictive " in utilizing the productions to and establishing the next syntactic element  . 
Syntax of the Predicate Forms ( A2)
The automaton A2 has as its domain the strings of L2  . However , its syntax is based on Reichenbach's methods of linguistic analysis  . In this section we will define a convenient formalism ~ the predicate form  , and discuss its syntax . Later we will discuss how the processor discovers the  L3   ( predicate function ) mapping of an L2 string . In defining the syntax C of A2 , it will be shown that U1 was designed in order to simplifyi For a review of current parsing algorithms see Bobrow  . 
M~nelski & Kav Ale especified by a predicate form depend on the verb  . Thus , the forms fall into four basic categories ; equational , intransitive , transitive and factitive forms . 
Equational Forms-
PRED(ARG ) Examples:
PRED(~))
PRED(ARG , ARG)
Intransitive Forms

John is home . Johnistall.
There is a man .
Johnistaller than Peter.
The Dodgers win.
The Dodgers winsel dom.
Transitive For nm-
PRED ( ARG , ARG ) Tall John loves Mary.
PRED(ARG , ARG , ARG ) John saw Peter at the track . 
F a c t i t i v e F o r m s -
PRED(ARG , ARG , ARG ) John elected Peter the chairman . 
With one exception the verb types used in the above classification follow conventional definitions  . However , following Sledd , factitive verbs are also included . F actitive verbs are transitive verbs that take an object complement  . 
The following predicate functions show the L3 mappings of the examples . In order to avoid using Church's Lambda notation to bind the variables  , the convention of using uppercase letters for the nonterminal elements and following them by the variables in lowercase letters  , is utilized to fully define the predicate function  . 
Manelski & Krulee . . . . . . .   ( ii )   ( iii )   ( iv )   ( v )   ( vi )   ( vii )   ( viii )   ( i  ~ ) 
PRED is home ( ARG John)
PRED is tall ( ARG John)
FRED is a man ( ARG ~
PRE Distaller than ( ARG John , ARG Peter)
PREDw in ( ARG The Dodgers)
PRED winseldom ( ARG The Dodgers)
PRED loves ( ARG Tall Johns ARG Mary)
PREDs a wat the track ( ARG John , ARG Peter ) PRE Delected ( ARG John , ARG Peter , ~ LRG the chairman ) One special characteristic of the mapping should be noted  . It is not necessary that elements be contiguous for them to be bound to the same variable  . Thus , the verb " saw " and the preposition " at the track " are not contiguous in the string yet appear so in the function  . This characteristic of the syntax has influenced the design of the processor  , as will be made explicit in a later section . 
Using the syntax C shown in Table 3 , and the same conventions for
Syntax C for Predicate Forms
I ) PRED-~PRED ( PREDMOD )  2 ) PREDMOD-~PREDMOD , PREDMOD 3 ) ARG - - ~ ARG ( ARGMOD )  4 ) ARG MOD-~ARG MOD , ARGMOD
Table 3 binding the variables , results in the following predicate functions for the previous examples : 
Manelski & Krulee ( v ) PRED win ( ARG Dodgers ( ARGMOD the )   ( vi ) FRED win ( PREDMOD seldom )   ( ARG Dodgers ( ARG MOD The )   ( vii ) FRED loves ( AReJohn ( ARGMODT all )  , Mary )   ( viii ) FRED saw ( PREDMOD at the track ) (ARG John , ARG Peter ) ( ix ) PRE Delected ( ARG John , ARG Peter , ARG chairman ( ARaMODte ) ) The mapping from L2 to L3 has not been formalized by the syntax C . 
However , this syntax is implicit in the processor and will be described in the same section  . 
Description of the Canonical Form Processor ( A ? ) The predicate forms have been designed to mechanize efficiently the problems of pattern recognition and of equivalence of strings by providing a limited number of canonical forms or patterns to describe a large number of natural language strings  . The syntax implicit in the processor for canonical reduction is quite simple as is shown in Table  4  . 
It should be noted that the mapping presupposes a description in  L2  . 
Another implication is the necessity to order the arguments  . The ordering of arguments is not made explicit by the rewriting rules given  ; however , the ordering is implicit in the processor . The rule followed in ordering arguments is simply defining each one as it is found in a left to right scan of the  L2 description . 
Manelski & Krulee

PRED(AR % ARG)
PRED(ARG , ARG , ARG )  2 ) NP--~ARO3 ) VMEQ-~PRED 4 ) VMITR-~PRED 5 ) VH rR-~PRED6 ) VMEQ+ADJC ~ PRED 7 ) VFAC-~PRED8 ) ADJ-~ARGMOD 9 ) THAN ( deleted )  10 ) PREDEQ-~ARGii ) PADV--~PREDMOD 12 ) PRP--@PREDMOD
Table 4
The flow diagram of FO , designed to behave like the automaton ~ , is described in Figure 4 . Although the syntax does not give a complete description of how the  L2 to L3 mapping should be carried out , it will become clear in the descriptions of the subroutines  . F1 is essentially a hypothesis generator . It examines the L2 input and decides on an appropriate canonical form  . Should it find the string L2 to have an equational verb , the possible canonical forms are :


PRED(ARG , ARG ) ?
Manelski & K rule e3 o
Intransitive verbs restrict us to the form : ' ~ hen the string has a transitive verb  , we choose between the canonical forms :
PRED(ARG , ARG)
PRED(ARG , ARG , ARG).
Finally problem strings with factitive verbs must follow the form: 
PRED(ARG , ARG , ARG)
Sub-routine F1 searches the string and locates the main verb . 
The verb class is noted in order to establish the appropriate forms  . 
When n overb is located , control is transferred to FlO , which notifies the programmer of the difficulty and stops  . Once a verb has been located Fll generates a predicate form  . F12 copies the form as the current prediction . The next subroutine is F2 ; it binds the words of the problem string to the form  . Thus , the words of each NP are bound to an ARG in accordance with a left-to-right scan of the problem string  . 
~ . 2nen a one-to-one correspondence is established between the NPs and the ARGs the processor transfers to  F14  .   F14 leaves all the names of the ARGs on a pushdown list  . The next subroutine is F13 which tests whether the pushdown list string named by the ARG is empty  . Should the llst be empty F6 is the next subroutine ; otherwise it is F ~ .   F4 tests whether there are any variables beside an N or PN in the ARG named on the pushdown list  . If there are not the processor returns to F13 . When additional words are found F5 rewrites the predicate form as ~ a ~ ~ G ( A~MOD ) 




FO : ? Star ~
F1: locate main verb8 ~ wme .31.
~~-'---> F~o . ~ r ~ ~ Ow "
Yll : generate a prediction ~..
Y I2: copy prediction as -~ current predicate form ~ no 
I.~~F2: Bind the ARGs . Does the number of
F I4: place names of variables for a locate verb and bind  ?5: modify form and b : Lu ~/ are there variables for , > Yg : modii ~ canonical form a PRE~0D ? Yes and bind variable nO ~
Prln ~ and stop
YlG .4"
Manelski & Krulee
ARGMOD . Following the execution of F5 the processor returns to F13  . 
F6 locates the verb . For transitive , intransitive , and factitive verbs all the words in VTR , VITR and VFAC are bound to the PRED of the form . 
For equational verbs , the processor searches to see if it is followed by an ADJC or a PRP  ; if it is , the ADJC or a PRP becomes part of the PRED . 
F 7 searches for a PADV or a PRP on the tree of a PREDTR  . The words named by the PADV or PRP are bound to the PREDMOD  . Sub-routine F8 then prints the L3 mapping of the problem string and halts the processor  . 
The following example illustrates the flow of the program : Input S " l ~  L2  =  ( S ( NP ( ADJ Big ) (N John ) )  ( VP ( VEQ ( VMEQ is )   ) ( PREDEQ ( PADJC ( ADJC smarter )   ( THAN than l ( NP ( NP aul ) ) ) ) ) ) Fl : locates the main verb " is " . The available predicate forms are :


PRED(ARG , ARG)
FII : The form PRED(~) is generated.
FI2:PRED(~) is the current form.
F 2: Since NP " Big John " is localized this predicate form is not appropriate  . The executive returns to FII . 
FII : The form PRED(ARG ) is generated.
FI2:PRED(ARG ) is the current form.
F 2: Since the NPs ~' Big John " and " Paul " are localized this form is inappropriate  . Control returns to FII . 
Manelski & Krulee











The form PRED(AR % ARG ) is generated.
PRED(AR % ARG ) is the current form.
The NPs are in one-to-one correspondence with the ARGs  . 
The variables are bound as
PRED ( ARG Big John , ARGPaul ) and the executive transfers to F14 . 
The names of the ARGs are placed in a pushdown list  . 
Since the pushdown list is not empty control passes to  F4  . 
The first ARG in the pushdown list names ' Maul " . There is no ARGMOD so control passes to F15 . 
Pops up the ARG naming " Paul " .
There is still an ARG name on the pushdown list.
The ARG names " BigJohn "; so the output becomes
PRED(~CB ig John ( ARG Mod)) , ~ a Paul ) and then the variables are rearranged as PRED ( ARG John ( t LRG MOD Big )   )  , ARGP aul ) . 
Pops up the last ARG name.
Since the pushdown list is empty the executive program calls  F6  . 
Since L2 has a VEQ the PRED is bound as
PRED is ( ARG John ( ARG MOD Big) , ARGP aul ) and then a further search is made for an ADJC or PRP  . 
The f ~ ) JC naming " larger " is found so the predicate function becomes PRED is larger  ( ARG John ( ARGMOD Big )  , 
ARGP aul).
Manelskl & K rule et ransitive ( so there can be no PREDTR ) the processor calls sub-routlne F8 . 
F 8: The predicate function is printed and the processor halts  . 
Recognition of Equivalent Strings ( A3)
Meaning equivalence is determined by A3 which attempts to apply a set of heuristically determined transformations in order to eliminate the differences between the strings ~- i and ~' j  . The set of transformations TO was chosen on the basis that it is found useful in a large class of problems taken from Stoll  . The set TO does not correctly solve all premise equivalence problems  . Some examples will be given where it is inadequate  . 
The recognition of meaning equivalence is postponed until the mapping to  L3 is complete .   L3 was chosen to determine the pattern classes because the language not only orders the structure of  L2~ but also shows the dependencies between the elements of the language  , and permits us to manipulate easily the L3 representations of G"i and O"j . 
The actual recognition of equivalence is determined by the set of transformations TO  . 
Definition : The strings ~' l and~-2~ ~ L 3 are said to be " meaning equivalent " when we can find :  ( Ti ( Tj '"" ( Tm~l )  1 ) = 6"2 where the Ti ~ Tj ~ . . . Tm  belong to the set TO . Where:
TO = ~ TPRN , TIMP , TTIME , TSYN ~
Manelski & Krulee
The transformation replaces the current ARG with the corresponding one of the preceding premise  . A necessary condition for the application of TPRN is that the first ARG be a pronoun in its  L2 representation . For example , let : i : John loves music . 
~'2: He dressed quickly.
Their representation is
PRED loves ( ARG John , ARG music)
PRED dressed ( PREMOD quickly ) ( ARG He)
The transformation TPRN~'-2) results in
PRED dressed ( PREDMOD quicl ~ ly ) (ARG John ) The implied transformation , TIMP , has a domain of the predicate functions with a null argument  . The transformation replaces the missing argument with that of the preceding premise  . For : ~ l : Dodgers won pennant . The the : lost the series with a representation of PRED won  ( ARG Dodgers ( ARGMOD the )  , ARG Pennant ( ARGMOD the )) PRED lost ( ARGO , ARG series ( ARGMOD the)) . 
TIMP ( ~-2 ) results in " the predicate function PRED lost ( ARG Dodgers , ARG series ( ARGMOD the)) . 
The time transformation , TTIME ~ has as its domain the predicates . 
The range is also the predicates . This transformation eliminates auxiliary verbs and replaces the main verb with its root  . The main verb is determined by the L2 representation of the string . An example would be:
Manelski & K rulee with ~, nL3 representation
PRED should go ( ARG John , ARG home)
Thus TTIME~l ) becomes
PRED go(ARG John , ARG home)
The synonym transformation , TSYN , has a domain of the words Wi ~ L2 . Its range is also the words Wi ~ L2 . The transformation is defined by replacing any W i by its synonym as defined in the dictionary of the processor  . The effect of TSY ~ can be seen on ~- leL1 . 
~--l : John is happy.
which has an L3 representation
PRED is happy ( ARG John ) after TSYN ( ~' I ) the predicate function might appear as
PRED is glad(ARG John)
This approach can certainly lead to difficulties.
Some problems in semantics have been avoided . A word can take on various meanings depending on the context  , as in:
The bug crawled along the leaf.
~ neb_~in the program was found.
He likes to bug me.
The word bug takes on a different meaning in each sentence  . The mistakes that transformations can lead to should be evident  . In some contexts the TSYN might be appropriate while in others it is not  . 
Another type of difficulty that has not been considered in the derivation of meaning equivalent strings is the following : One 
Manelski & K rule e representation of a string . Thus ~ l,0"2~L2 . 
~l : John hits the ball with the bat.
~'2: John bats the ball.
would have their respective representations as follows in  L3: PRED hits ( ARG John ) ARG ball ( ARGMOD the )  , ARG bat ( ARGMOD the )) PREO bats ( ARG John , ARG ball ( ARGMOD the ) )l By changing the predicate , a 3 ARG function becomes a 2 ARG function with the same meaning . By working with the set TO , the great majority of problems in Stoll are amenable to solution  . However , the processor is not capable of doing justice to the human abilities of linguistic resolution  . One noticeable characteristic of utilizing TO as a recognition device is its tendency to err by not recognizing equivalent strings rather than by un~iustified recognition  . 
Although this section defines the scope and effect of TO  , it is also necessary to specify under what conditions the automaton attempts to apply one of the transformations  , and under what conditions the processor will stop trying to match the strings  . The criteria for applying a member of TO , and the decision to halt , will . be made explicit in the next section . 
iExample thanks to D . Kuck.
Manelski & Krulee
The flow chart ( see Figure 5 ) of GO was intended to implement A3 . Clearly , meaning equivalence , as defined by GO , can only be understood in light of the problem context  . Thus , in the formalization of the sentential calculus , we shall consider 1 and 2i : John will go home . 
2: John went home.
as meaning equivalent , because in this problem context meaning is time invariant  . Obviously this is not true in conversational English  . The program GO initially calls GI whose function is to test the number of ~ RGs in the problem strings  . Failing to find the number of ARGs to be the same  , control is passed to G3 . G3 is one of a set of subroutines , including G13 , G 17 , GI4 and GI5 , designed to notify the programmer that the strings were not found to be meaning equivalent and briefly indicate the reason  . Should the problem strings have the same number of ARGs control is passed to  G4 which tests for equality of PREDs . When this requirement is not met G5 is executed by dropping any VAUX and attempting to find the root of the main verb  . If the existing differences are not eliminated by  G5 the executive transfers control to G6  . This subroutine , like G22 , G21 and G20 , attempts to eliminate the differences between strings by using a dictionary search  . Sub-routine G7 tests the PREDMODs for equality . Uhen any differences in the PRt VDMODs are reconciled the executive program calls  G8  . It also tests for identity in the substrings . 
In this case the matching is of the first ARG of each string  , the second
ARG of each string ~ etc ... until a
GI7:prints " PREDMODDIFF "
G22:, renothe PREI ~ OD 6 synonyms ? <
L . HI




GT : start initialize storage
Doa ~ ana ~2 have the same no . uf ARGs ?
Yes are the FRED's of " oI and sathesame ?
In o are the PREDMODs of al and 02 the same ? ~ Yes
GS : are the ARGs of al and a 2
G3: Print " DIFFNO
ARGs "39@"~ no GS : eliminate roots . .@ G ~: are -~ ) and auxiliary I the FREDs I verbs J of a ~ . and I/a2 the//same ? Nd
Yes J//'~G6: are the ~'




Yes ~. ~ strings synonyms the same ?
G21: are there e?no
GI3: Point " PREDIDI ~7

Print " ARGs DIFF".
are the ARGMODS of ? I and " am the same ? ? GIO : are there any \ print " PREMHEQUIV  , "' wor ~ permutations ? transformations used , and the strings on which GI6: Have G6 and GIO reduced they are used the differences between/same differences 
GIS : , : pm ? nt ' ~ GDSDIYF " .
FIG . S ",
Manelski & Krulee 4o difference is found in the strings . A difference in the strings leads the processor to execute  G20  , GlO ~ and G16 . As previously mentioned ~ G20 searches for synonyms .   G10 attempts to reduce differences by finding permutations of the differing ARGMODs  . Finally ,   G16 keeps track of the number of differences in the strings  ( based on the order and symbols on each ARGMOD list  )  . ~When all differences are eliminated control is passed to a print routine  , G12 . Should the number of differences remain constant on successive executions of the  G20  ,   G10 and G16 loop ~ the processor calls subroutine G15  . If the number of differences is decreasing the loop is repeated  . 
The following example illustrates the logic of the system : ~ J~l:PRED is  ( ARG John ( ARGMOD Bigtall )  , ARG home ) ~'2: PRED is ( ARG John ( ARGMODT all large )  , ARG home )
GO : Calls GI.
GI : Initializes storage.
G 2: Both ~" 1 and S- 2 have two ARGs so the executive calls G4  . 
G 4: Since both the ARGs have the PRED " is " control is transferred to GT  . 
GT : There are no PREDMODs so the processor continues to  G8  . 
GS : ARGs are checked in order , first Q- 1 and S- 2 are shown to have the same ARG " John " ~ then the second ARGs are both identified as " home "  . Since no difference exists the processor calls G9 . 
G 9: In the first ARG ~ DD the difference count is 2 since " Bigtall " and " Tall large " are both different symbols  . No second ARC ~ MOD is located for either ~ 1 or ~" 2  . The executive program calls G20 . 
Manelski & Kru . lee






Attempts to locate " Tall'as a synonym for f'big " and " large " as a synonym for " tall "  , and fails in both cases . 
Notes that the difference count can be decreased by rearranging the ARGMODs as " Bigtall " and " Larg et all "  . 
Since the number of differences has decreased from  2 to i the executive returns to G20  . 
This time the synonym " Large ' is located for " Big "  ( assuming that the synonym is stored in the dictionary 

Since no differences are located by GI0 it cannot perform any permutations . 
The differences between the ARGMODs of G-I and ~   2 have been eliminated so a transfer is made to GI2  . 
The print out " PR~4S EQUIV " is followed by the fact that the transformation TGYN was necessary on " Big " and TPERM on " T all large "  . 
Manelski & Kruleeh2

This completes our description of a processing system for problems in the statement calculus  . The system accepts problems as they are normally written in English and attempts to produce a formalized equivalent as its output  . It makes uses of a series of automata , the first of which attempts to identify the elementary premises and the logical connectives  . Two additional automata are used in order to compare premises and to determine whether or not they should be identified as equivalent  . As a first step , each premise is mapped into a canonical form which simplifies the identification of equivalent premises  . In the second step ~ pairs of premises are compared  . 
This automata makes use of a number of meaning -preserving transformations  . 
In a sense , two premises are equivalent if one can be derived from the other with the aid of these transformations  . Otherwise , the premises are evaluated as not equivalent . Although this processor is limited to a particular class of problems ~ it was designed with two purposes in mind : as an attempt to simplify the problems of communications between programmer and computer and to clarify those processes by means of which meaning is extracted from natural language  . 
Manelski & ~ eeh.i.s.





hypothesized input string input string lefthand side not a wellformed string part of speech right hand side 
Manelski & Krulee
Bobrow , D . , " Syntactic Analysis of English by Computer - A Survey "  , 
Proceedings of the FJCC , 1963.
Carnap , R . , Introduction to Symbolic Logic and its Applications  . 
New York : Dover , 1958.
Chomsky , N . , Syntactic Structures . ' s-Gravenhage : Mouton , 1957 . 
Green , B . F . , Jr . , Wolf , A . K . , Chomsky , C . , and Laughery , K . , " Baseball : an Automatic Question-Answerer ' . Proceedings , Western Joint Computer
Conference . May , 1961, pp . 219-224.
Krulee , G . K . , Kuck , D . J . , Landi , D . M . , and Manelski , D . M . , " Natural Language Inputs for a Problem-Solving System "  . Behavioral Science ?
July , 1964, pp . 281-288.
?" A Proolem Solver with Formal Descriptive Kuck , D . J , and Krulee , G . K . , Inputs " . Computers and Information Science . Baltimore : Spartan , 1964, pp .  344-374 . 
Manelski , D . M . , " A Heuristic Approach to Natural Language Processing "  , Unpublished Ph . D . thesis , Northwestern University , 1964 . 
Newell , A . ( Ed . ), Information Processing Language-VManual . Englewood
Cliffs : Prentice-Hall , 1961.
Newell , A . , and Shaw , J . C . , '! Programming the Logic Theory Machine " . 
Proceedings ~ Western Joint Computer Conference . February , 1957, pp . 23O-24 O . 
Reichenbach , H . , Elements of Symbolic Logic . New York : MacMillan , 1938 . 
Manelski & Krulee
Foresmart , 1959.
Stoll , R . R . , Sets Logic and Axiomatic Theories . San Francisco : W . H . 
Freeman , 1961.
Walker , D . E . , and Bartlett , J . M . , " The Structure of Language for Man and Computer : Problems in Formalization " ~ Informati  . on System Science and Engineering . New York : McGraw Hill , 1963 . 
