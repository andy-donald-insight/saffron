A Compilation-Chart Method for
Linear Categorial Deduction
Mark Hepple
l)epl ;, of Compul ; or Sole . He0.
Universit ; y of Sheffield
Regent , Court ;, 211 l % rl ; obelloSt ; reel;
Shell Md $714 DP , UK
hepple@dcs , shef.ac.uk
Abstract
Recent , work in ca . t;eg(Mjgr;mmt ; ~ r has seen proposals for a wide . r;Lltg(~O\[sys- . 
t ; (; i \[ IS , differing in their ' resomx : esensi-tivil ; y ' and hence , implicitly , ; heir under . .
lying nol ; ion of qinguisl ; ie SLlllet ; ure ' . a common frm new or k for t ) arsing such sys-t ; elnsiselll ( ; l'ging ;  , whereby some in el ; hod of linear logi(:l ; hcorent \]) roving is used in COlnbinal ; i on with ; ~ sysl , em of l ; t-1)elling l ; hat ; ensures l ; hat ; only (\[ edtl (> Lionsa , pl ) rot ) ritt ; cLol ; her(~le . van L(:at ; ego-rM formalism are allowed . This l ) al ) ( n ' presenl , sa deduction reel ; hod for impli-(-a . t , ionalline ~ r logic I ; ha ; brings with il , I ; he benelil ; thai ; (: harl ; parsing provides for CI , 'G parsing , namely avoiding ( ; he need ( ; ore compu ( ; eintenne . dial ; eresull ; swheal , qcarching exhausi ; ively for ; ~ll possiblemmlyses . Themel ; ho ( \[ involves ( : ore-piling possibly higher - or ( l (  ; r linear formula e1 ; o indexed firsl ; -or ( ler formulae , over whi (: h(tcdu (: l;ion is in a(le using jusLa , sin- . 
gle inference rule.
1 Introduction
This t ) al ) er present ; sa method applicalle to parsing a . range of cal ; egorial gramm ~ u ' formalisms , in pa . rl ; ieul mones L hal ; l ' ; tll wil ; hinl ; he % yt > e-logieal't ; ra . dition , of which Lhe ( associa . l ; ive ) l , mn be k calculus Lisl ; he most ; familiar rcl ) re . qen Lal ; iw ; ( l , am-bek , 1988) . l , e(;enl ; workhaosse . en proposal stier a range of such sysl ; el\[l . q , differing in their resource sensitivity ( and hence , imt ) licil ; ly , (; heir underlyingllo ; ion of ' linguis Li (: sl . rllei ; llre ') , in some eases combining differing resource sensi Civil  ; ieswi ( ; hina , single sysl ; e\]n . ISomeo17 l ; hese propos ; dsem-l)\]o ya ' labelledde(luei ; ion'me . l ; hodology(G ; d)b;~y,\]994), where ) y1; he . I ; yi)es in a pr()of are asso (: ial ; (! d w i l ; h labels under a Sl ) e . eiti (; d disei I ) litte , l ; hela . belsiS(x ;, for cxanLlile , the\['orma . lisnls dev cqopedill Moortg~t & Morrill (1991) , Moortgat & () ehrle(1 . 994), Morrill 11994), Ilct , 1)le (1995) . 
re . cording proof ' in form ; ~ l ; i on a . sabasis for ensming ; correcl ; int ' c relming . 
Alongside such developmen Ls , vmiotts work ha . saddressed I ; he ; ts soeial ; e(t parsing 1) rol ) lem . 2()\[" l ) ~ Lrt ; iculmin l ; eresl , here ~ tre . qysl ; emst ; ha , l ; employ a 1 ; heorem proving reel ; hodl ; hatis ( perhaps implicitly ) appropriat ; e for use with linear h)gi (: , and combine it wiLh ~ labelling system I ; hat ; restrict , s ; uhnil ; t ; cddeducl ; ions1; obel , hose of some weaker logic . Moorl ; gal ; (\]!) 92) shows how a linear proofnel , mel ; hodmay 1) e combined wit ; har ; mge of la . -belling disciplines t ; o provide de du ( :\[ ; ion for a ran , g(!o1ca , l ; egori ~ lsys ; ems . Morrill (199, 5) shows how 71, t ; ypesnmy bet ; ra . nsl ; tl ; ed Lo labelled in q ) li (: ational line m ' l ; yl > es , wil ; hdeduct ; ion implement ; edvia . a version of SI , D resolution . The crucial ol ) serva . I ; ionist ; hat , linem ' logics l ; ;m(ls ~ bove all of @ e l ; yl ) (> log i ( ; a , lsyst ; emsprot ) osed a , s(:at ; cgorial formalisms in Lhe hierarchy of sul)st ; ruel ; m'a \] logics , and he ~ tcelinem ' logi(:deduct , ion methods (: m\]i ) rovide ; t common basis for parsing all of these systems . 
The prescnl , work contrilml ; esto this pro . \]ect by providing a met ; hod of deduction for the impli-c ; ~l ; ional fragment ; of linear logic l ; hal ;  , like charl ; parsing for I'SG , avoids reeonipul ; agion of result , , q , i . e . where any combination o\['1 ; ypesc(mt ; ril)ut ; es ; o more t ; hanone over all a Imlysis , it , need only t > e (: omt > ut ; edonce . . In whal ; follows , i will first ; ini ; rodu (: e(tcdue( ; i on totiml ) lical ; i on a linear logic , and discuss it ; sineom pal ; ibitil ; y with a . eharl > like(\[e(tu(:l;ionapt)r (); wh , before pre . senl ; ing ~ t(;omi)i-la . l , ionmet ; hod ; hat ; converl ; s form ( thin Loaform for which a chart > like deduction me ; hodist ) o ~ qsi-ble . Finally , 1 will in l ; roduce , l ; he Morrill(\]995) method for t ; rans lat , ing l~mnl ) ekt , yi ) est ; olal > elled lincm'types , as ab~ts is for illus\[ ; ra ; in ghowt ; he (' harl ; -compilat , ionreel ; hod c&n be used as a gen-era . 1fl'mneworkfin'(:al;egorialdedu(:Lion , vial ; he use of such 1; ra . nslal;ions . 
2Al>l)roa(:hc . b include sequent proof n(n ' , mt lisacion methods for I , ( K6nig , 1)89; Flel ) ple , \]990;llemlriks ,  1992) , charl ; pro'sing mc . l ; hods for L(t (6 nig , 1990; Hep- . 
pie ,  1992) , midprooftiC ; l ; methods for a range of sys-t ; ems ( Roorda ,  11991 . ; Moortgat , 1992) . 
537 2 Implicational Linear Logic
Linear logic is an example of a " resource -sensitive " logic  , requiring that in any deduction , every assumption ( ' resource ' ) is used precisely once . We consider only the implicational fragment of ( in-tuitionistic ) linear logic . 3 The set of formulae arises by closing a ( nonempty ) set of atomic types . 4 under the linear implication operator o-(i . e . 
~-: := AI5%--Y ) . Various alternative formulations are possible . We here use a natural deduction formulation , requiring the following rules ( o-elimination and introduction respectively ) :
Ao-B:aB:b\[B:v\]o-EA : a
A : ( ab)o--I
Ao--B :) ~ v.a
Eliminations and introductions correspond to steps of functional application and abstraction  , respectively , as the lambda term labelling reveals . 
The introduction rule discharges precisely one assumption  ( B ) within the proof to which it applies ( ensuring linear use of resources , i . e . that each resource is used precisely once ) . Consider the following proof that Xo-Y , Yo-Z=~Xo-Z
Xo-Y:xYo--Z:y\[Z:z\]
Y : ( yz)x:(x(w )) xo-z:
Following Prawitz (1965) , a normal form for proofs can be defined using just tilef bllowing  ( meaning preserving ) contraction rule ( analogous to /4-conversion )  . This observation is of note in that it restricts the form of proofs that we must consider in seeking to prove some possible theorem  . 



A:D

B A
The normal form proofs of this system have a straightforward structural characterisation  , that their main branch ( the unique path fi'om an assumption to the proof ' send-type that includes no  3It follows that tile parsing method to be developed applies only to categorial systems having only implicational connectives  . It is standard in categorial calculito include also a ' product ' operator  , enabliug matterlike addition of substructures , e . g . L has a product ( commonly notated as ) .   , with the Lambek implicationals/and\being its left and right residuals  . 
Although it is appealing from a logical point of view to include such operators  , their use is not motivated in grammar . 
minor premise of an elimination inference ) consists of a sequence of ( >_ 0 ) eliminations followed by a sequence of ( > 0 ) introductions . 
The differential status of the left and righthand side formulae in a sequent may be addressed in terms of polarity  , with left formulae being deemed to have positive polarity  , and the right formula to have negative polarity . Polarity applies also to subformulae , i . e . in a formula Xo-Y with a given polarity p , the subformula X has the same polarity p , and Y has the opposite polarity . For example , a positively occuring higher-oi'der type might have the following pattern of positive and negative subformulae :  ( X + o- ( Y-o-Z ~ ) -  ) + Consider the following proof involving this type: 
Xo-(yo-z ) Yo-WWo-Z\[Z\]




Observe that the involvement of ' hypothetical reasoning ' in this proof  ( i . e . the use of an additional assumption that is later discharged  ) is driven by the presence of the higher-order formula  , and that the additional assumption in fact corresponds to the positive subformula occurrence Z within that higher-order formula  . Intile following proof that Xo- ( yo- ( Yo--Z ) ) ~ Xo-Z , hypothetical reasoning again arises in relation to positive subformu-lae  , i . e . the subformula Yo-Z of the higher-order formula ( X + o- ( y-o- ( Y + o-Z- ) 4  )  -  ) +  , as well a stile subtbrmula Z of the ( over all negative ) goal formula ( X-o-Z + ) -  . 
Xo-(Yo-XYo-Z ))\[ Yo-Z\]\[Z\]




More specifically , additional assumptions link to maximal positive subformulae  , i . e . a subformula Y + in a context ; of the form ( X-o-Y+)- , but not in ( Y + o-Z -) ~ . 
For an even more complex formula , e.g.
(v + o- ( w-o- ( x + o- ( Yo-z + ) -  ) +  ) -  ) + we might find that a proof would involve not only an additional assumption corresponding to the positive subformula Xo-  ( Yo-Z ) )  , but that reasoning with that assumption would in turn involve a further additional assumption corresponding to its positive subformula Z  . 
538 3 A Compilation-Chart Method
Standard chart parsing for PSG has the adwmtage that a simple organising principle governs the storage of results and underpin search  , namely span within a linear dimension , specified by limiting left , and right points . A fllrther crucial feature is that what we derive as all item for any span is purely a function of the results derived for substretches of that span  , and ultimately of the lexical categories that it dominates  ( assuming a given grammar )  . 
l ) eduction in implicational linear logic lacks both of these features  , although , as we shall see shortly , some notion of ' span ' can be specified . The crucial problem for developing a chart-like method is the fact that  , in combining any two elements A , B  ~ C , there is an infinite number of possible results C we could derive  , and that what we in fact should derive depends not just on the formulae themselves  , but upon other formulae that might combine with thai  ; result . More particularly , the reasoning needed to derive C is liable to involve hypothetical elements whose involvement is driven by the presence of some higher-order type elsewhere  . 
First-Order Linear Deduction
Letust ) eg in by avoiding this latter l ) roblem by considering the fl'agment involving only first-order fbrmulae  , i . e . those defined by S : := fl . tYo--A , and furthermore allow only atomic goals ( i . e . so A is atomic in any F ~ A ) . Consequently , tile\[o-I \] rule is not required , and hypothetical reasoning excluded . In combining types using just the remaining elimination rule  , we must still ensure linear use of resources , i . e . that no resource may be used in ore than once in any deduction  , and that in any overall deduction , every resource has been used . These requirements carl been forced using an indexation method  , whereby each initial for inula in our dat , at ) as e is marked with a unique index ( or strictly a single ( eraset containing that index )  , and where a formula that results ti'om a combination is in arked with the union of the index sets of the two formulae combined  . 4 We . 
can ensure that no initial assumption contributes more than once to any deduction by requiring that wherever two tbrmulae are combined  , their index sets must be disjoint . Thus , we require the following modified \[ o-El rule ( where ? ,  '~/~ , vrarc ' . index sets , and t0 denotes union of sets that are required to be disjoint  ) : 4 ) : Ao-B : a ' ~/ ~ : B : b ? - ( bao ' , /~7 r : A : ( all ) In proving I '=> A , as nccessflf low ' , rall analysis is recognised by the prescmee of a database formula  4See Llord & Morrill ( 1995 ) fbrare lated use of indexing in ensuring linear use of resources  . 
A whose index set is the flfll set of indices assigned to the initial formulae in P  . For ' example , to prove Xo-X , Xo-X , Xo--Y , Y => X , we might start with a database containing entries as f bllows  ( the tmmbering of entries is purely for exposition ) :
I . i:Xo--X : v2 . j : Xo-X : w3 . k:Xo-Y : z4 . l : Y : y Use of the modified elimination rule gives additional for nmlae as follows:  5  . k,/:X:zy\[3+4\]6 . i,k,1:X:v(a:y)\[1-t-5\]7 . j , k , l:X : w(zy)\[2-1-5\]8 . i,j,k,1:X:v(w(xy ))\[1+7\]9 . i , j , k , l:X : w ( v ( a : y ) ) \[2+6\] There are two successful analyses , numbered 8 and 9 , which we recognise by the fact that they have the intended goal type  ( X )  , and are indexed with the full set of the indices assigned to the initial lefthand side for nmlae  . Note that the formulam nnbered 5 contributes to both oftile sucessflfl overall mtalyses  , without needing to be recom-tinted . Hence we can see that we have already gained the key benefit of a chart approach for PSG parsing  , nanmly avoiding the need to recompute partial results  . It can be seen that indexing in the above method plays a roles in filar to that of ' spans ' within standard  ( : hart parsing . 
An adequate algorithm for use with the above approach is easily stated  . Given a possible theorem Br, .   .   .   , Bn => A , tireleft hand side formulae are each assigned unique indices and semantic variables  , and t ) ul ; onailagenda . Then , a loop is followed in which a formula is . taken from the agenda and added to the database , and then the next formula is taken from the agenda and so on until the agenda is empty  . Whenever a formula is added to the data hase , a check is made to see if it can combine with formulae ah'eady there  , in which (: as (; new formulae are generated , which are added to tile agenda . When the agenda is empty , a check is made for any successful overall analsy -ses  , identified as described above . Note that since the result of a combination always bears an index set larger than either of its parent formulae  , and since the maximal index set that any for nmla c~n carry includes all and only the indices assigned to the original lefthand side formulae  , the above process nmst terminate . 
Higher-Order Linear Deduction
I , et us turn now to the general case , where higher-order formulae are allowed . The method to be described involves compiling tile initial formulae  ( which may be higher-order ) to give a new , possibly larger , set ; of formulae which arc ; all tirst order . 
We observed above how hypothetical reasoning in a proof is driven by the presence within higher -order for nuflae of positively occurring subforinu -ing and excising such subformulae  ( thereby simplifying the containing formulae ) and including them as additional assumptions . For example , this method will simplify the higher-order formula Xo-  ( Yo-Z ) to become Xo--Y , generating an additional assumption of Z . The two key challenges for such an approach are firstly ensuring that the additional assumptions are appropriately used  ( otherwise invalid reasoning will follow )  , and secondly ensuring that a proof term appropriate to the original type combination is returned  . 
Consider an attempto prove the ( invalid ) type combination : Xo-Zo- ( Yo-Z )   , Y => X . Compila-tion of the tbrmula Xo-Zo- ( yo-Z ) yiehls two formulae Xo--Zo-Y and Z , so tile initial query becomes Xo-Zo-Y , Z , Y => X , which is provable . 
The problem arises due to inappropriate use of the additional formula Z  , which should only be used to prove the argument Y  ( just as Z's role wouhl be to contribute to proving the argument Yo-Z in a standard proof involving the original formula Xo-Zo-  ( Yo--Z ) ) . The solution to this problem relies upon the indexing method adopted above  . 
The additional assumption generated in compiling a higher-order formula such as Xo--  ( yo-Z ) will itself be marked with a unique index . By recording this index on tile argument position from which the additional assumption was generated  , we can enforce the requirement that the assumption contributes to the derivation of that argument  . Note that a single argument position in ay give rise to in ored m none add il  ; ional assumption , and so in fact all index set that should be recorded  . For example , The ( indexed ) formulai : Xo- ( yo-Zo-W ) will compile to give three indexed formulae : i : Xo-  ( Y : j , k)j:Zk:WW e , require a inodified elimination rule that will enforce appropriate usage :  5 ? : Ao- ( B : rt ) : a '~ ~ / + b~r = eU ~ / ~7 r:A : ( ab ) Note that the compilation process must also gen -crate additional assumptions corresponding to the positive subformulae of the righthand side of a query  , e . g . compilal ; ion of Xo-Y , Yo-Z ~ , Xo-Z simplifies the right hand side formula to atomic X  , giving and additional assumption Z . 
The second challenge we noted for such an approach is ensuring that a proof term  ( loosely , the SNore the requirement that ( t is a proper subset of , /~ , which will have the consequence that other assumptions must also contrihute to deriving the argun wntB  . This will block a derivation of the linear logically valid Xo-  ( yo-Y ) => X . However , this move accords with general categorial practice  , where it is standm'd to require that each deduction restsm  , at least one assumption . The alternative regime is easily achieved , by making the condition c~C ~/) . 
' serum:ticrecipe ' of the combination ) ai ) propriate to the original type , combination is returned . Let us illustrate how this can be achieved with a simple example  . Consider the following proof : Xo- ( Yo-Z ) : zro-W : yWc-Z: , w\[Z:z\]

Y : y(wz )
Yo-Z : Az.y(wz)
Deriving the argument Yc-Z of the higher-order for nmlain volves a final introduction ste I  )  , whk : h , semanl ; ically , corresponds l ; o an abstraction step that binds the variable semantics of l  ; he additional assuinption Z . The possibility arises that , compilation inight insert tile absl ; rael ~ ioni to the semantics of the compiled tbrmula  , so that it late x ' binds the variable of the additional formula  . For example , coinpilation of Xo- ( Yo-Z ) lnight yield Xo-Y with term Ay . z(Az . y ) and Z with variable term z , so that combining the former with some formula derived from the latter  ( i . e . whose tern \] included z ) would cause the free occurrence of z to become bound  , giving a result such as x(iz . f(z )) . In that case , we can see that all ; hough C , olnpilation has eliminated the needt bran explicit introduction step in the proof  , the , sl ; ep still occurs imt flicitly ill the semantics . 
Of course , anyone familiar with lambda calculus will immediately spot the flaw in the preceding proposal  , namely that the substitution process that is used in ~- conversion is carefllll llystated to avoid such ' accidental binding ' of w ~ riables  ( by re-naIning bound variables , whereve required ) . We will instead use a special variant of substition which specifically does not act to avoid accidental binding  , notated__\[_//~\](e . g . t , \[ s //' v \] to indicate substitution of sR ) rvint )  . Not ( ; that tim assignment of term variables in the apt ) roach in general is such that other eases of ' accidental binding '  ( i . e . 
beyond those that we want ) wilt not occur , incorporating this idea , we arrive at the fbllowing ( final ) version of tile elimination rule ?: Ao-- ( B : ( ~ ) : kv . a ' ~ ~/ J : B : b c , C~--~'~/ ~ re:A:a\[b//v\]Note that the form of the rule requires the  , implicational formula 1; hat ; it , operates 111) Oll ; ot ) e of a certain for in , i . e . involving an at ) strael ; ion(Av . a) . 
This requirement is met by all implieationals , ( as a side effect of the (: ompilation process . 
A precise statement of the compilation procedure ( r ) is given in Figure .  1 . This takes a sequent F ~ A : x as input , where every left amlright hand side formula is labelled wil  ; ha Ulfique variable , and returns a strucl ; ure(A , (?: G:u )) , where A is a set , of indexed tirst order formulae , ? is the flfll where , i0 ,   .   .   . , i ~\ [ reshi , t(li(:(' . sneg(i0:X0: x0) = ( i0:G:u)WI'
A:FU pos(il:X1:x , )
U .,.
Upos(i,~:X,~:'a:,,.)(/,:-indices(A).
, , o ~( , : x : t ) :--( i:x :/ ,) whe ~ eX a , ; omi(:.
post , : : X~o-y ,  :/ , ) ( , i:x~(r ,   ,   ,  : (/ , ) : ~ , , . .~)
LJFtJA whe , ' eneg('i:\]q:' . ) = ( i'~:' . ) ~ Ul ~ ( vahes h variabh0 pos(i:Xl : ( t ' , ))): ( i:X2: , ';) l ~ Jz ~(/ ~-- indices ( l') . 
, eg(i:X:v ) = : ( i:X:v ) where X a.tomic.
neg ( i : Xlo-q : u ) __  ( i : X2:w ) Ol ' UA where v . :- : Av . : r(v , : cf resh variables ) neg(i:X , : z ) = ( i:X2:w ) Ul~pos(j:r , : v ) := A(j afr(;shin , lex ) . 
Figure \]: The COml ) ilad on pro(:edure set ; of indices , (\ ] is a nat x ) mi (: Goal I ; yp (' , , and u a variable , l , et A * denote the result ; of (: losiugA under ( , he elimination rule . The , sequent ix proven iJ ) "  ( ( ) : G : u )   ( ~ A*fi ) r some assigmnent of a vahle 1 ; o ' a . Undert ; hat assignment , the original right hand side va . riablex will return a ( : omplete proof term for the imi ) lMtI ) roof of the originals (  ; qll (: IIILNot , c ; hall , het ) i'ot ) fLerll hqsot ) ro ( hlce ( l have a form whi ( : h ( : or rest ) onds , (m(h ; rl ; he Curry-llowar disomorphism , to itormal form dedu (: l ; ions(as defin(xlear lier) . 
A simt ) le example . Compilation of the sequent : Xo- ( Yo-Z ) : x , Yo--W:y , Wo-Z : w ~ X : v yields the goal Sl ) ecification ( i , j , k , 1: X : v ) and fl ) rmula e1 14 , with t'ormulae57m'ising under com-binat;ion . Formula 7 meet ; st ; he , goals p e (: ith:ation , soth (; inil ; ial sequent ix proven , with l ) ro of term m ( ) ~ Z . y(Wz )) rel ; urned . 
I . i:Xo~(y:j ) : Au . z(Az . , , , ) 2 . j:Z : z3 . k:Yo-W : A'u . y'u4 . 1: Wo-Z :) v u . ' w ',, 5 . j , l:W:wz\[2+4\]6 . j , k,~:v::q(~,,~)\[a + ~\]7 . , : , j , k , l:x::,;(A ~ . ,( , , , ,~)) \[7l+6\] The indexed firsl ; -ord( ; r formulae generate ( 1 by the comI ) ilation procedure cant ) e processe , d using t ) recisely the same algoril ; hm as that des ( : ribed above for handling formulae of the iirs l > order fl'ag~men % with precisely the same benct it  , i . e . avoiding re(:ompul:ation of I ) artiM results . 
Some efti (: iency question stMse . Imagine a Prolog implementation of the method , with indexed for nmlae being stored as facts ( ' edges ' ) in the Pro-h ) g database . Animt ) or l ; ant , overhead will arise wh ( ; n adding an agenda item to the dal ; al ) asefl'omlo(:~dng those , lbrmub ~ Mrea ( lythere that the cur-reid ; t ' or illtlla (: all combine with , i . e . if welt lllSI ; separat ( Jy access every formula Mready stored to ewduate if in  ( l (  , xation require melltSares at is ii(d , a . d (: oml ) iIlad on possil ) le . Note first lydmt , , since (: omt)ih'd formulae are all tirst-order , if we area < tding analomi (: f (> rmula we nee , (t(>nlyh)ok to storediml)li (: atiomfl formula . e for possible (: or al ) i- . 
nations , and vice versa . ' Fhis is easily a <: hiev(xl . 
' l ' heprol > h'm(>f (' , valuating in < lexation require , -ments can be ( ~ ase (11) y using at bit vector e , n (: o(ling of in(h ' , x sets . The ,   ( : Oml ) iladont ) rocess will return a full set 1 of l : hemfi ( l U eiudices assigm xl to any \[ brnntlae . If we impose an arbitrary or d ( n ( ) vet dm elements of this sol ;  , we (: & n then ( m (: o(h~l ; heexl ; eltsioltOfally ill(lexset ; Weedl ( ; Ollill ; erttsillgaii'n-1) la (: ebitove(:tor , where n is the cudinality of l , i . e . if some , index set (: ontains the it ; h('\]e , m('m , of ( ordered ) 1 , then theii ; heh'ment of its bil > v(w , l ; ( ) r is 1 , other w is (~0 . \[ t is uscl ' ul to store fiflly sp (' , c-ilie(lbit vectors with al ; omi (: formula(; , specifying l ; heirim h'x set . For iml ) li (: a donal for nmla , how- . 
ever , it is use hfl to store a . 1) it-ve , (: tor(m (: oding its ' requireme , nt . s for an appropriately indexed argumenl ; , i . e . with 0 s instantiate ( l for tim ( ; \] em(!nts of the impli(:ational's own index sel ; ( to enfor(:(! dis-join(hess of index s ( ; ts ) , and with \] s a , pl ) ea . ring ; for those indi(:e , s that it requires hay (! l)e(minv ( ) lved in de , riving the argument . Other 1 ) ositi ( )ns will 1 ) et illed with anonymous vari M ) les . The bil:-vet:tors for an imt ) li ( : ational and an at ( )mi ( ' , formula will m ; ~t(:hjustin case I:hcy ~ r (' ~ permil ; t c d t x ) (: oml ) in c , a (: (: or ( ting to in ( lexal ; ion requir (; ments . ( Timone short fM1 here is thai ; tim the ( hod allows the impli-(:al , ioiml (; ospe(:ifyt ; ha . t(:crtain indices are a sub-sel ; of those of l ; he argumell t , but not that tlmy are a proper subset l ; here of . ) lly storing su (: hvet ; tots with formulae in the datalm . s e , indexation requirements caml)e , (: he(:ked by the process of mat(:hing ;  1 ; othed ~ tabase , so dial ; only at ) prot ) riate , entries ; ~ rebrought out for further examination , 4 Labelling and Lambek Calculus As dis ( : usscd in the introduction , tim above method is proposed as a gener M method for parsing  ( : a tegorial systems , via a trant'ormation of formulae\['tom the relevat f l  ; system to linemt br-mulae . Such translations houhlinduce lal ) ellittg ( halimi ) or ts the cons ( fronts of ttlc ~ origin M weaker logic . \[ n that case , , although we employ a general method for iml ) lieation M line , ard eduction , the re-suits we derive will I ) e all and only those that ; retie(:( , validity of the weaker system . I will illustrate this idea by considering one of two such translation methods described by Morrill  ( 1995 )  . This method is based on a . relational algebraic model for L(van len them ,  1991) , which in l ; erprets types as relent , ions on some set V ( intuitively , point al VxV ( intuitively , strings identified by delimiting points ) : D ( A\B )  =  ( vz , v3)\[Vvl , v2) CD(A) , ( vl , v3) eD(B)D(B/A ) = ( vl , v2) IV(v2 , v3) CD(A) , ( Vl , V3 ) eD ( B ) Morrill specifies polar translation functions , which convert Lambek types that are marked for position  ( ' span ' ) to labelled linear formulae . 
The translation functions are identity functions on atomic formulae  , and for complex formulae are defined mutually as follows  ( where each superscript p stands for one of the functions  , with i0 indicating the complementary function top ) : i-k:Bpo-i-j:A ~ where i is a new variable/constant j-k:A\B pasp is +/- i - k : Bpo--j-k : Ap where k is a new variable/constant as p is +/- i-j:B/AVA sequent  B1  ,  ? . ?,/3n = ~ A is translated as : O-l : Bl +, .   .   .   , ( n-1)-n:B+~O-n:A-For example , X/(Y/Z ) , Y/W , W/Z ::> X translates to give the following linear formulae  ( where i , j , 1 are variables , and k a constant ) : Database: ( 0-i : X ) o- ( (2 - k:Y ) o- ( i-k:Z ) )  ( 1-j : Y ) o- ( 2-j : W )   ( 2-l : W ) o- ( 3-I : Z ) 
Goal : (0-3: X)
Such linear formulae can be used with any linear deduction method  , given the ( trivial ) additional task of unifying variables and constants in the string position labels  . Note that for cases that are not L valid , but where the translation is linear logically valid  , deduction will fail due to unification failure for string position labels  . A minor complication arises for using this approach with the compilation-chart method described above  . For example , the higher-order formula would compile to two indexed formulae : a:  ( 0-i : X ) o- ( 2-k : Y ) :Ay . x(Az . y ) b : ( i-k:Z ) : z Note that the string position variable i appears in both resulting formulae  . For an overall deduction employing these two formulae to be correct  , the binding of the two instances of i must be consistent  . However , we cannot simply employ a global binding context since the chart method should be able to return alternative proofs of the same theorem  , and such alternative proofs will typically induce distinct  ( but internally consistent ) bindings over string position variables . Variable bindings must instead be handled locally  , i . e . each formula in the database will carry with it a context indicating bindings that have been made in its derivation  . 
Where two formula are combined , their contexts are merged ( and must be consistent )  . 
References van Benthem , J .  1991 . Languag cin Action : Categories , Lamdas and Dynamic Logic . Studies in Logic and the Foundations of Mathematics  , vol 130 , North-Holland , Amsterdam . 
Gabbay , D.M . 1994. Labelled deductive systems.
Part I : Foundations . Oxford University Press ( to appear) . First draft1 . 989, current draft , May 1994 . 
ttendriks , It .  1992 . ' Lambek Semantics : normalisation , spurious ambiguity , partial deduction and proofnets ' , Proc . of Eighth Amsterdam Colloquium , ILLI , University of Amsterdam . 
Hepple , M .  1990 . ' Normal form theorem proving for the Lambek calculus '  , Proc . of COLING90 . 
Hepple , M .  1992 . ' Chart Parsing Lambek Grammars : Modal Extensions and Incrementality '  , 
Proc . of COL1NG92.
Hepple , M .  1995 . ' Mixing Modes of Linguistic Description in Categorial Grammar '  , Proceedings EACL-7 , Dublin . 
KS nig , E .1989, ' Parsing as natural deduction ',
Pwc . of ACL-25.
KSnig , E .  1990 , ' The complexity of parsing with extended categorial grammars '  , Proc . of
COLING90.
Lambek , J .  1958 . The mathematics of sentence structure . American Mathematical Monthly 65 . 
Llor 6, F . X . & Morrill , G .  1995 . ' Difference Lists and Difference Bags for Logic Programming of Categorial Deduction '  , Pwc . of SEPLNXI,

Moortgat , M .  1992 . ' Labelled deductive systems for categorial theorem proving '  , Proc . of Eighth Amsterdam Colloquium , ILLI , Univo 4"-sity of Amsterdam . 
Moortgat , M . & Oehrle , R .  1994 . ' Adjacency , dependency and order ' . Proc . of N in th Amsterdam Colloquium . 
Moortgat , M . & Morrill , G .  1991 . ' Heads and Phrases : Type Calculus for Dependency and Constituency  . ' To appear : Journal of Language , Logic and Information . 
Morrill , G .  1994 . ~ljpe Logical Grammar : Categorial Logic of Signs  . Kluwer Academic Publishers , Dordrecht . 
Morrill , G .  1995 . ' Higher-order Linear Logic Programming of Categorial Dedution '  , Proc . of
EACL-7, Dublin.
Prawitz , D .  1965 . Natural Deduction : a Proof Theoretical Study , Almqvist and Wiksell , Uppsala . 
Roorda , D .  1991 . Resource Logics : Proof Theoretical Investigations  . Ph . D . Dissertation , Amsterdam . 

