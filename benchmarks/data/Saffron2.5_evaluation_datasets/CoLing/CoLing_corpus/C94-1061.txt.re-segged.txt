CONCURRENTIJ ~ XICAIJZEI)I)ENI ) ENCYPARSING :
THE Parse Talk MODEL
Norbert Br 6keh Udo Hahn & Susanne Schacht
Abstract . A grammar , nodel for concurrent , object-ori-
ented natural language l ) arsing is introduced . Complete lexical distribution of grmnmatical knowledge is achieved huilding upon the head -oriented notions of valency and dependency  , while inheritance mechanisms tire us cd to capture lexic  ; tl generalizations . The underlying concurrent computation m ( xlel relies upon the actor l ) aradigm . We consider message passing protocols for establishing de-l  ) cn dency relations and amhiguity handling . 
1 INTRODUCTION
In this pal)er , we propose a grammar model that combines lexical organization of grammatical knowledge with lexicalized conlrol of the corresponding parser in an object-oriented specification framework  . Recent developments in the lield of linguistic grammar theory have alread yielded arigid lexical modularization  . This finegraine decomlx ) -siton of linguistic knowledge can he taken as a starting Ix  ) in t for lexic , ' tlized control . Current lexicalized grammars ( for instance , Il PSG : Pollard & Sag , 1987; CG : tlcpple , 1992; Lexicalized TAG : Sehabes , Abelie & Josh ,  1988) , however , still consider lexical items as passive data con -tain crs who sc content is uniformly inteq  ) reled by global control mechanisms ( e . g . , unification , functional composition , tree adjunction ) . Divmging front these l ) remises , we assign full procedural autonomy to lexical units and treat then ~ as active lexical processes communicating with each other by message passing  . Thus , they dynamically estal ) -lish heterog cncous communication lines in order to determine each lexical item's funclional role  . While the issue of lcxicalized control has early I  ) ecn investigated in the paua-diem of conceptual parsing  ( Ricsbeck & Schank ,  1978) , and word expert parsing in particular ( Sinall & Ricger ,  1982) , these prol ) os als amlimited in several ways . First , they do not provide any general mechanism f ( )r the systematic incorporation of grammatical knowledge  . Second , they do not supply any organizing facility to R ) rmuhte generalizations over sets of lexical items . Third , lexical communication is based on an entirely inform : l\[l  ) rotocol that lacks any grounding in principles of distributed computing  . 
We intend to remedy these metho ( Iological short conl-ings by designing a radically texicalized grammar on lhebasis of valency and dependency  ( these head-oriented notions aheady tigure in different shal  ) eS in many modem linguistic theories , e . g . , kSsuhc . 'ltegorizations , case frames , the laroles ) , by introducing inheritance kSa major organizational mechanism  ( for a survey of at ) plying inheritance ( ' LI'J -- Comtmtational Linguistics Research Group
Vreiburg University
D-79085 Frciburg , German yemail : nobi , hahn , sue@coling . uni-frciburg . dcinin(xtem grammar theory , of . Daelemans , DeSmedt & Gazdar ,  1992) , and by specifying a message passing protocol that is grounded in the actor computation model  ( Agha & Ilewilt ,  1987) . As this protocol allows for a synchronous message passing  , concurrency enters as a theoretical notion : it the level of grammar specification  , ot only as an implementatiol ml feature . The Parse Thlkm ( ? lelout lined in this paper cantllerefore be considered as an attempt to replace the static  , global-control paradigm of naturalan-guage processing hyadynamic  , local-controlm c ? lel . 
The design of such a grammar and its associated parser responds to the demands of complex language performance problems  . By this , we meant mderstanding tasks , such as largescale text o , speech understanding , which not only require considerable portions of grammatical knowledge but also a vast amount of socalled non-lineguistic  , e . g . , domain and discourse knowledge . A major problem then relates to the interaction of the different knowledge sources involved  , an issue that is not so press-tug when monolithic grammar knowledgessentially boils down to syntactic regularities  . Instead of subscribing to any serial model of control  , we Imild Ul ) On evidences flom CO ml ) utational text understanding studies ( Granger , Eiselt & llolbrook , 1986; Yu & Simmons , 1990) as well as psycholinguistic experiments , in particular those worked out for the class of inter : lctive language processing m  ( xlels ( Marslen-Wilson & Tyler , 1980; Thibadeau , Just & . Car-t)enter , 1982) . They reveal that various knowledge sources are accessed in an a priori unpredictable order and that a signilicant amoullt of parallel processing occurst it various slat '  , es of I he ( htlll ~ all ) I . : nguagel ) fOCCSS or . Therefore , computationally and cognitively plausil ) le models of nalural language tm de , slandin , e , should account for parallelism at the lheoretical evel of language description  . Currenlly , I'arse'lalk provides a specificalion platform fo , ' computational language performance modeling . IIn the future , this vehicl c can be used as a test bed for the configuration of cognitively adequate parsers  . Moving performance on sid-erations to I he level of grammar design is thus in strong  1 We ( ) lily nlellti ( llll hatl ) cIfoIll  all  Ceissueshi , COlliee VCllillOl't ~ pl'essillgwht:nilatl . lral \] ang tlage ill ld ( : rsl and \[ llg tasks are placed ill realworld environments and Ihtls add illonal complexity is added by utt grammati-cal natural language in l :  , Ul , noisy dala , as well as lexical , grammatical , and coflee plual specification gaps . hithese cases , not only multiple knowledge sources have Io Im balanced but additional processing Sll'RI-egles must be supplied to cope wilh these phenomena in a robust way  . 
This places extra requirements on Ihein ( (elation of procedural linguistic knowledl ; cwidf in a per R ) (mance-orientcd language analysis framework , viz . slratt ; glc knowledge how to handle in complele or faulty hnguagcdata and grammar Sl ?: Ci fie at lons  . 
3 79 contrasto any competence-based account which assigns structural wellformedness conditions to the granmar level and leaves their computation to  ( general-puq ) ose ) parsing algorithms , often at the cost of vast amounts of ambiguous structural descriptions  . 
2 earse Talk's CONCE PTUAL FRAME WORK
The Parse'lhlk model is based on a fully lexicalized grammar  . Grammatical specifications are given in the format of valency constraints attached to each lexical trait  , on which the computation of concrete dependency relations is based  . By way of inheritance the entire collection of lexical items is organized in lexie at hierarchies  ( these constitute the lexical grammar )  , the lexical items forming their leaves antilhe intermediary nodes representing grammatical generalizations in terms of word classes  . This speciIi-cation is similar to various proposals currently investigated within the unification grammar community  ( Evans & Gazdar ,  1990) . The concurrent computation m ( ? lel builds upon and extends the formal foundations of the actor model  , a theory of object-oriented computation I hat is based on a synchronous message passing  . 
2.1 The Grammar M~xlel
The grammar model underlying the Parse Talk approach considers dependency relations between words as the ftm-damental notion of linguistic analysis  . A modifier is said lode pend on its head if the modifier's occurrence is permitted by the head but not vice versa  2  . Dependencies are thus asymmetric binary relations that can be established by local computations involving only two lexical items  ; they are tagged by delx zndency relation names from the set ? =  3 spee , subj , ppatt .   .   .   .    . Cooccurrence restrictions between lexical items are specified as sets of valencies that express various constraints a head places on permitted modifiers  . These constraints in coqx ) rate the Rllowing descriptive units : 1 . eategorial : C = Word Aet or , Noun , Substantive , Preposition . . . .  denotes the set of word classes , and is a c = ( Noun , Word Aet or ) , ( Substantive , Noun ) , ( Preposition , Word Actor ) . . . .  c C ? C denolcs the st , b class relation yielding a hierarchical o , dering in C(of . also Fig . I ) . 
2 . morl ) hosyntaetle : A unification formalism ( similar in spirit to Shicber , 1986) is t , sed to represent morphosyn-U~ctic regularities . It includes atomic tinms I ' romlh cset ' T =\ [ nor a  , acc . . . . . sg , pl . . . .  , complextertns associating labels from the set ? = case  , num , agr . . . .  vo O with embedded terms , wthte disjunction ( in curly braces ) , and coreferences ( nnmbers in angle brackets ) . 
? gl denotes the set of allowed features tructt , res , V the ; ~ Ahhong h phrases are not explicitly represented ( e . g . , by nonlexical categories ) , we consider each complete subtee of I he dependency tree a phrase  ( this convention allows disconthmous phrases as welt  )  . A dependency is not treated as a relation between words  ( as ~ n Word Grammar ( lluds on ,  1990 , p . 117) , but bcl ween a word and a dependent phnts e ( as in Dependency Unification Grammar ( l lell w i l ,   ,  1988)) . The mot of a phrase is laken I o be the representative of I he whole phrase  . 
3 Additionally , O contains the symbol self which denotes I he currently considered lexical item  . This symlml occurs in features mmtures ( ee2 . 
lyelow ) and ill the ordering relations on fer and occma ( 4 . lxflow ) . 
unification operation, . Ltile inconsistent element . 
Givenue U and I~_L , tile expansion \[ I : u \] denote stile complex term containing only one label  , I , with value u . If u is a complex term containing I at toplevel , the extraction u\l is detined to be the value of Iinu  . By definition , u \ l yields J_in all other cases . 
3 . c ( m cept n -' d : The concept hierarchy consists of a set of concept names  9-= Hardware , Computer , Notebook , Harddisk . . . .  anti a subclass relation isas = ( Computer , Hardware ) , ( Notebook , Computer ) . . . .  c Fx The set of conceptual role names ~ . = HesPer , Has Price . . .   . contains labels of l ) ossibl cconc cptual relations ( a frame-style , classification-based knowledge representation model in the spirit of MacGregor  ( 1991 ) is assumed )  . The relation tic ~ . q-x . ~ ?  . 9 imple-menls conceptual integrity conslraints : ( f , , r , , q ) ctic iff any concept subsumed by f e 5/ may be modified by any concept subsumed by , q < 5 V in relation reR , e . g , ( Computer , hasPad , Harddisk ) ede . From tic the relation per , tit-~(, V , r , y ) <' . fxR x51~f , 2/<5 r:(f ,, r, . ,7 ) eticA-C/saF*fAy " ~ aj ~' 21 ( * denotes themmsitive closure ) can be derived which explicitly states the range of concepts that can actually be related  . For brev-ity , we restric this exposition to the attribution of concepts and do nol conskler quantification  , etc . ( cf . 
Creary & Pollard , 19g5).
4 . ordering : The ( word class pecilic ) set on ferc q~'contains n-tuples which express ordering constraints onlhewdencies of each word class  . Legal orders of modifiers must correslx ) ud to an element of order Tile ( word specific ) functio , ~ occurs : ?-->9 , ~ ) associates dependency names with the modific r's ( and self's ) text tx ) sition ( 0 for valencies not yet occupied )  . Both speci-lications appear attile lexical head only  , since they refer to the head and all of its modifiers  . 
With these definitions , a valency can be characterized as an clement of the set  , /2 cq ) ? C x g l ? ~ , Focusing on one dependency relation from the example " Compaqent wik-keheinen Note bookmit einer  120-MByte-Ilarddisk "\[' Compaq devek ) psanote book with a 120-MB ytehard disk "\] , the at ? we crileria are illustrated in Table 1 . The fee-It restructure of the two heads , " rail " and " Note book " , is given prior to and after the establishment of rite dependency relation  . The concepts of each of the phrases , 120 MP , -IIARDDISK-00004 and NOTEBOOK-00003 , are stated . The order constraint of " Notebook " says that it may be preceded by a specifier  ( spec ) and attributive adjectives (  , ' tttr ) , and that it may be folk ) wed by prepositional phrases ( ppatt )  . The valency for prepositional phrases described in the last row states which class  , feature , and domain constraints must be fulfilled by candidate modifiers  . 
The predicate SATISFIES ( of . Table 2 ) holds when a candidate modifier fullills the constraints stated in a specified valency of a candidate head  . If SATISFIES evahm test otrue , a dependency valency . name is established ( objec-t . attribute denotes the value of the property attribute at object  )  . As can easily be veriIic d , SATISFIES is fldlilled for the combination of " mit "  , the prepositional valency , and " Notebook " from Table 1 . 




I lead
Valencies ( only one of the set is consklered )
Attributes class ~ ( 2 feature seq'l concepte Fimsition e 9 ~ . 
features e'\[lconcept6 . q7 or rferc9' occurs : q ) --> 9~ ) nanm ~ rD class < C
I feature secH domain C~.
lmxical items ( head underlined ) tnjteiner 120-MB yte-
Ilard diskein cn
Notebook prior Io dependency establishment
Preposition selfEi ' or mt , , i ~
I cased at pobj agr genfer nt nn '~ tsg_ i~20M B-I IAR1  ) I ) ISK-000 ( ) dependency establishment i l>rC . lX ) sition-\]selfE~brn ,   , nit ~ cased at lx ) bj agr genfer n ii 1 . 1111 sj . \]_(20 MII~IAI ~ , DDISK-00k) , Iselfag r < 1>=genmas
IItllIIsg_spe\[;+<l;j
Cilge IIC Csell " agr <1>= genmaslltlll llsgsl U-~c ~ tgr < l > -\ [ l'l'aLl ~ formllXi ~ 
NOT\[:I~ , OOK-00003 < spee , attr , sell ' , ppatt > ( spec ,  3) , ( altr ,  0) . ( sell ', 4), ( ppatt , 0) l > patt
I ~ relmsition ~ , pattEfor , , , mi ~ llasl\[arddisk , 1 lasPrice ,   . . . TAIll . EI . Antlluslrali . nor grammatical specilicalions in the Parse'lhlk modal 
NOTI'~FR ) OK4R ) 003 < spec , at lr , self , ppan > I(spec ,  3) , ( mtr ,  0) , ( self ,  4) , ( IWW . , 5) not applical)le SATISFIES ( modilier , valency , head ): <-~ modifier . classist l ~ valency . class_((\[valency . name:(modifier . features k self)\]V valency . features)
V head . features ) ~ . L ^3 role < wdency . domain : ( head . concept , role , modifier . concept ) cpermit^3 < d, . . . . dn > ehead . on\[er:3k c1, . . n  : ( valency . name = dR , ', ( V1-<i<k : ( head . occurs(di ) < modilier . positi(m )) ^( Vk < i <_ n : ( head . occt * rs(di ) = 0 v head . occurs(di ) > modifier . position))
TAII , E2. The SNI'ISFII , : Spredicale
Note that unlike most l ) revious dependency grammar formalisms ( Starosla & Nomu , a , 1986; I lell wig , 1988; Jiip-pinch , Lassila & Lehtola , 1988; Fraser & lludson ,  1992 ) this criterion assigns equal opportunities to synlactic as well as conceptual conditions for computing valid del  ) eU-dency relations , lnfommtion on word classes , morphosyn-lactic features , and order constraints is tmrely syntactic , while conceptual compatibility introduces an additional description layer to I  ) esatisfied before a grammatical relation may be established  ( of . Muraki , lehiyama & lVukumo-chi , 1985; Lesmo & Lombardo ,  1992) . Note that we restric the scope of tile unilicatiou module in our framework  , as only morphosyntactic features are described using this sul  ) formalism . This contrast sharply with standard unification grammars  ( and with designs \[ or dependency parsing as advocated byllell wig  ( 1988 ) and Lombardo ( 1992 ) ) , where virtually all information is encoded in tenns of the unification formalism  4  . 
2 . 1 . 1 A Look at (; rammalic . ' lllierarchies The grammatical styeci fieation of a loxical entry consists of structural criteria  ( valencies ) ~ behavioral descriptions ( protocols )  . In order IO cal ) ture , elcwmt generalizatkms and to supl ? ) rt ea symaintenance of grammar specilica-lions , both are represented in hierarchies ( cf . Genthial , Courtin & Kowarski ( 1990 ) and Fraser & Hudson ( 1992 ) for inheritance thai ix restricted to slruct tlrgl criteria  )  . The valem : ytfieran : hy assigns valencies to lexemes  . We will not consider it indepth here , since it captures only traditional grammatical notions  , like transitivity or rellexivity . 
The organizing principle is the subset relation on valency sets  . The word dass tfferarchy conlains word class specili-cations lhat cover distributional : rod behavior all  ) rOlx' . rties . 
Fit , . 1 ilh , stratcs tile be havk ) ral criterion by defining for each class different messages  ( the messages for Word-Actor are discussed in Sections  3 and 4  )  . Within the Nounl ) art of the word class hierarchy , the ream different meth- ( ) ( Is for an al ) her a resolution rellecting different structural constraints on possible antecedents for \[ R  ) minal anaphora , retlexives and personal pronouns . The word class hierarchy cannotly e generate ( lautomatically , since el assilication of program specifications ( commtmication protocols , in our ease ) falls out of the scope of slate-of-the-art classilier ' ~ Typed unificalion formalisms  ( limele & Zajac ,  1990 ) would easily allow for Ihei\[it ( :gration of word classiTll'oml at loll . Ordering con-strahlls and conceptual re , frictions ( sttchasValue range reslrict hm ~ ; or claboraled intet , rily(:(: , llslr ; lilltS ) , however , ; ire not SO easily\[ral~sfer-able , because , e . g . , the conceptual C ( )liSIlaillls go Far Imyond the levd of aIOIlliC SCI Ilal IIC features still prevail hlgh ~ unilicalior Lf  ( mnalisms . 

WordAct . r ~ tart Up make Adjacentle . f t Context search l lead head l ? e , und head Accepied dtlpll cate Slmcture copyStn lettlre_epl~silionmitI?IGURE  1  . Fragment of the word class hierarchy algorithms . On the other hand , the concept hierarchy is based on the subsumption relation holding between concepts  , which is computed by a terminological cassifier . 
Most lexicon entries refer to a corresponding domain concept and thus allow concept tml restrictions to be checked  . 
2.2 The Actor Computation Model
The actor model of computation combines object -oriented features with concurrency and distribution in a methodologically cleanway  . It assmnes a collection of independent objccLs , the actors , communicating via a synchronous message passing . An actor can send messages only to other actors it knows about  , its acquaintances . The arrival of a message at an actor is called an event  ; it triggers the execution of a method that is composed of atomic actions  , viz . creation of new actors c ~ aet or Typo ( acquaintan-ces ) ) , sending of messages to acquainted or a newly created actors  ( send actor message )  , or specification of new acquaintances ( become ( acquaintances ) ) . An actor system is dynamic , since new actors can be created and the communication topology is reconligurable  . We assume actors that process a single message at a time  , step by step ( l\[e witt&Atkinson ,  1979) . For convenience , we establish a synchronous request-reply protocol  ( Licberman ,  1987 ) to compute function such as uniIication of feature structures and queries to a  ( conceptual ) knowledge hase . In contrast to simple messages which unconditionally trigger the execution of a method at the receiving actor  , we lollne complex word actor messages as fntl -lledged actors with independent computatiom d abilities  . Departure and : nrival of complex messages are actions which arc perfornted by the message itself  , taking the sender and the target actors as parameters  . Upon arrival , a complex message determines whether a copy is forwarded to selected acquaintan-ces of its receiver and whether the receiver may process the message on its own  ( of . Schacht , \[Iahn & Br~3ker ( 1994 ) for a treatment of the parser's behavioral aspects  )  . 
The following syntax elements will he used subsequently : a program contains actor definitions  ( declaring the acquaintances and defining the methods of actors instantiated from this definition  ) and actor messaged c~ni-tions ( stating distribution and computation conditions )  . 
Method definitions contain the message key , the fonnal parameters and a composite action : actor Def ::= def Actoractor Type  ( acquaintance ) method Def * method Def : := . m~message Key ( param )   ( action ) messDet : := def Msg message-type ( acquaintance )   ( ( ( if condition distribute To tag ) )* if condition com_~ ( ( if condition distribuleTo tag ) )* ) action : := action ; action I if condition ( action ) \[ else ( action )  \]
Isendactor message Key ( param *)
I become ( acquaintance *)
I create actor Type '* ( acquaintance)
I for varinset : ( action ) condition is a locally computable l ) rcdicate , written as PREDICATE(actor ') ; actor stands for acquaintances , parameters , newly created actors , the performing actor itself ( se_~or the ml delined value ( nil )  ; actor . acquaintance yields the correst x ) nding acquaintance of actor ; fo__zr varin_ . 
set : ( action ) evaluates action for each element of set . 
3 ASIMPLIFIED PROTOCOLFORESTAB-
LISIIING DEPENDENCY RELATIONS
The protocol described below allows to establish dependency relations  . It integrates structural restrictions on dependency trees lind provides for domesticated concurrency  3  . 1 Synchronizing Actor Activities : Reception Protocol A reception protocol allows tinactor to determine when all events  ( transitively ) caused by a message have terminated . 
This is done by sending replies hack to the initial or of the message  . Since complex messages can be quasi-recur-sively for warded  , the tmmber of replies cannot be determined in advance  . In addition , each actor receiving such a message may need an arhitrary amount of processing time to terminate the actions caused by the message  ( e . g . , the establishment of a dependency relation requires communication via messages that takes indeterminate time  )  . The re-\['() re , each actor receiving the message must reply to the initiator once it has terminated processing  , informing the initiator to which actors the message has been forwarded  . 
A message is a reception message if ( I ) the receiver is required to ( asynchronously ) reply to the initiator with a receipt message , and (2) the initiator queues a reception task . A n ( explicit ) receipt message is a direct message containing a set of actor identities as a parameter  . This set indicates to which actors the receptior ! message has been forwarded or delcg  , 'tled . The enclosed set enahles the receiver ( which is the initiator of the reception message ) to wait until all receipt messages have arrived 5 . In addition to explicit receipts , which are messages solely used for termination detection  , there are regular messages that serve a similar purpose besides their primary ftmction within the parsing process  . They are called implicit receipt messages ( one example is the head Accopted message described in Section  3  . 3) . A reception task consists of a set of partial descriptions of the messages that must be received  ( implicit as well as explicit )  , and an action to be executed after all receipts have arrived  ( usually , sending a message ) . 
5 This , of course , only happens if the distribmion is limited : The search-Head message discussed Ix : low is only distributed to the head of each receiver  , which llllSl(~etlrillIhegallicst ~ rltellCe . This ellsures a finite RCIOF collection to distribute the IT ~ eRS ~ I ~\[~ t ~  . ) , a Tldgtlaranlees that tle reception task is actually triggered  . 
382 word Actor ( head depsvals feats . . . ) #head , dependencies , valencies , and features acquaintance ~ - - - - - - " search Head  ( sender target in it )  #processed at candidate heads ( ~ from the message definition )   ( for valinvals :  #check all valencies of the possible head  ( if SATISFIES ( in it valse lf )  #valency check adapted from 7-able 2 ( & giLd_ ( gLe . & t ~ haad Found ( . , ~ eJ . \[ initval , name feats\val . name )) p . ~ LeJ ; z ~<;  #reply to initiator , hnposing restrictions ( head depsvals ( feats V in it . leats ) . . . )  #expand grammatical description of head#J&g . ( e . s . g . .~d ( create receipt ( self in it head ) ) ~ )   )   )  #send are ceipt with the head the message was for warded to  #dep  , a G realizes the departure of a complex message head Found  ( sender target name head Feats )  #processed at the initiator of a search Head message  ( s e_g_r ~ d ( create head Accepted ( selfs ender name ) ) ~ )   ;  #reply to head , ( sender depsvals ( feats V head Feats ) ,  . .)) # store sender as head of s~ . ~ e  ~ . , restrict so ~ tz ~ . 's features head Accepted ( modifier target name )  #processed at the head only ( fo . #? dep indeps :  #checkaft . dependencies i(j\[(name=clap . name )  #relafion , name is identical ( send depstore ( modifier ) ) ) ) # send the dependency the message store to store tilen lodifiers end  ( create receipt ( self modifier head ) ) ~  )  #send a receipt with the tread the message was for warded to " I'A III  , E3 . Method del in itiluis for sear (' hllead , headl . ' ountl ~ heatlAccelltetl 3 . 2 Encoding Structural Restrictions Word actors conduct a bottom-up search for l  ) ossil ) leheads ; the principle of noncrossing arcs ( projectivity of the dependency tree ) is guaranteed by the following forwarding mechanism  . Consider the case of a newly illst : . lnli-ated word actor w . searching \ [ IS head to the left ( tile opposite direction is handled in a similar way  )  . In order to guar-aatee projectivity one has to ensure that only word actors occupying the outer fringe of the detyendency structure  ( tyetween the current absolute head wj antithe right lnOSt element w  . _i ) receive the search message of w . ( these are circled in Fig .  2) 6 . This forwarding schenic is reflected in the following simplified message definition : defMsg search Head  ( sender target initiator )   ( ( if GOVERNED ( target ) Oistributelbhead )  #forward a copy to head , identified by head c9) if . true g . g . l  ~ )  #the message is always processed at the target ;  #the computation event is concretized in the word  #actor specification in Table  3 Thus , a message searching for a head of its initiator is locally processed at each actor receiving it  , and is forwarded to tile head of each receiver , if one already exists . 
l . . . . . . . .
? ," " " - _~ .   . 7"N . / td , k, . : text l ) ositio . sl ? "( WkWkZ- . - - - - - - FIGURE2 . Forwardill gaseart'h message Additionally , direct messages are used to establish a dependency relation  . They involven of orwarding and nlayly especified as follows : def Mscj < direot Message >  ( sender target . . . )( if true comq . @m_p ~ )  #a direct message is always processed at the # target  , no distribution condition can apply Below , a number of messages of this type arctised for negotiating dependencies  , e . g . , headFound , head Ac-eepted , receipt ( each with difrerent imrameters , as represented by " . . . " above ) . 
~' Additionally , w . may be governed by lilly word actor govem in I , wj , bu ! due to the synchronization mplemented by I he receipt protocol  , each head of w j must belt x : a ted to the right of w  . .
3 . 3 All Excerpt fr ( llll the Word Actor Script The protocol for tx ) ttom-up establishment of det ) endencies consists elthree steps : The search for a head  ( search-Head )  , the reply of a suitable head to the initiator of tile search  ( head Found )  , and tile acceplanc c by the initiator ( head Accepted )  , thereby Ix ' coming a modifier of the head , The corrcs lxmding method dc\[initions are given in Table  3   ( notel halIhesem cth ( xls are ( lefincd for one actor type here , buttire executed by different actors during parsing  )  . The protocol allows alternative attachment so be checked concurrently  , since each a clorrace\[vies search-Head may process it locally  , while the message is simultaneously distributed to its head  . 
The specification of methods as above gives a local view of Jilltic\[or system  , stgting howeach actor behaves when it ~ vceives a message  . For a global view taking the actors ' interaction patterns into account  , cf . Schacht , ilahn & Br6ker (1994) . 
4 AMBIGUITYIIANI)I . ING
There are two alternative processing strategies for ambiguities  , viz . serial vs . p , ' mdlelpr(xzessing . We here f(ycus on a parallel mode , specifying only necessary serializal kms . 
Whenever an ambiguity is detected , additional actors are created to represent dilTerent readings  . The standard three-step negotiation scheme for dependencies can easily be accommodated letills duplication process  . When a word actor receives the second ( or n-Ill ) head Foundinessai ( e it does not immediately reply with a head Accepted message  , but initiates the copying of itself , its modifiers , and the prospective head ( which , in turn , initiates copying its m(x lifier saed head , if any ) . Copying modifiers proceeds by seeding a copyStructure message R  ) each actor ill-votved , wllichevokes a ( standard ) head Acceptedines-sage returned by tile actor copy  . Copying the head is done via a duplicate Structure message  , which will result in another head Found message to lye returned  . Since this head Found message is addressed to lhe ungoverned CO l  ) y , the CO l ) y m , ' lyreply ; is il Stl\[lItry sending a head Accepted message .  1 ) uplication of actors allow stile concurrent pro -tossing of alternatives  , and requires only limited ove , head for the disiribntion of messages all long duplicated actors  , Usually , a packed representation fambiguous structures is preferred in the parsing literature  ( Tamnra et al ,  1991) . 
This is feasible when syntactic analysis is the only determining factor for the distribution of partial structures  . But if conceptual knowledge is taken into account  , the distribution of a phrase is not fully determined by its syntactic structure  . Possible conceptual relations equally influence the distribution of the phrase  . Additionally , the inclusion of an ambiguous phrase in a larger syntactic on text requires the modification of the conceptual counterparts  . 
In a packed representation , there would have to be several conceptual counterparts  , i . e . , only the syntactic representation can be packed ( and it might even be necessary to unpack it on -the-fly  )  . Consequently , whenever conceptual analysis is integrated into the parsing process  ( as opposed to its interpretationia later stage , thereby producing numerous ambiguities in the syntactic analysis  )  , structure sharing is impossible , since different syntactic attachments result in different conceptual analyses  , and no common structure is accessible that can be shared  ( cf . Akasaka (1991) for a similar argument ) . We expect hat the overhead of duplication is compensated for by the ambiguity-reducing effects of integrating several knowledge sources  . 
4 . 2 Relation to Psycholinguistic Perfnrnmnce Models It has been claimed that human language understanding proceeds in a more sequential mode  , choosing one alternative and backtracking if that path fails  ( e . g . , Ilemforth , Konieczny & Strube , 1993) . This model requires the ranking of all alternatives according to criteria referring to syntactic or conceptual knowledge  . The protocol outlined so far could easily be accommodated to this processing strategy : All head Found messages must be collected  , and the corresponding attachments ranked . The best attachment is selected , aml only one head Accepled message sent . In case the analysis fails , the next-best attachment would be tried , until an analysis is found or no alternatives are left  . 
Additionally , the dependencie stablished during a failetl path would have to be released  . 75 COMPARISONTORELNI'EI ) WORK The issue of object-oriented parsing and concurrency  ( for a survey , cf . Hahn & Adriaens ,  1994 ) has long heen considered from a purely implementational perspective  . Message passing as an explicit control mechanism is inherent to various object-oriented inaplementations of standard rule-based parsers  ( cf . Yonezawa & Ohsawa ( 1988 ) for contextfree and Phillips ( 1984 ) for augmented PSGs )  . 
Actor-based implementations are provkted by Uehara et al  . (1985) for LFGs and Abney & Cole (1986) for GP , grammars . Similarly , a parallel implementation fa rule-7 Note that all psycholinguistic studies we know of are rel ~: rring to a con-slituency-based grammar model Since our grammar is based on dependency relations  , principles such as Minimal Attachment cannot be transferred without profound modification  , since in a dependency tree the number of nodes is identical for all readings  . Therefore , principles adapted to the structural properties of dependency Irees mustix : formulated for preferenlial ranking  . 
based , syntax-oriente dependency parser has been described by Akasaka  ( 1991 )  . The consideration of concurrency attile grammar specification level has recently been investigated by Milward  ( 1992 ) who properly relates notions fro , n categorial and dependency grammar with a state logicapl  ) roach , a formal alternative to the event-alge-braic formalization underlying the Parse Talk model  . 
Almost any of these proposal slack serious accotmts of the integration of syntactic knowledge with concept tml knowledge  ( cf . the end of Section 2 . 1 lot similar considerations related to dependency gram  , nars ) . The develop , nent of conceptual parsers ( Riesbeck & Schank ,  1978) , however , was entirely dominated by conceptual expectations driving the parsing process and specifically provided no mechanisms to integrate linguistic knowledge into such a lexical parser in a systematic way  . The pscudo-pandle lisminherent to these early proix  ) sals , word expert parsing in particular ( Small & Rieger ,  1982) , has in them can time been replaced by true parallelism  , either using parallel logic programming envkomnents  ( Devos , Adriaens & Willems ,  1988) ,   . actor spccilicatious ( Hahn ,  1989 ) or a connectionist methodology ( Riesbeck & Martin ,  1986) , while the lack of linguistic sophistication has remained  . 
A word of caution should be expressed regarding the superficial similarity between object -oriented and connectionist models  . Cn nnectionist methodology ( cf . a survey by Selman ( 1989 ) of some now classical connectionist natural language parsing systems  ) is restricted in two ways compared with object -oriented comlmting  . First , its com-mtmication patterns are determined by tile hard wired to I ?  ) logy of colmectiouist networks , whereas in object-ori-ented systems the tOl ) Ology isllexible and reconfignrable . 
Second , the type and amount of ( lata that can he exchanged in a connectionist network is rcslricted to marker antivalue passing together with severely limited computation logic  ( and - ing , or-ing of Boolean hit markers , determining maximum/miniln umvalues , etc . ) , while none of these restrictions apl ) ly to message passing models . These consideration seqtmlly extend to spreading aclivation models of nalural language parsing  ( Chamiak , 1986; llirst ,  1987 ) which are not as conslrain cd as connectionist , nodels but less expressive than t , cneral message passing models underlying the object-oriented paratligm  . As shot ddIx : evident from the preceding exposition of the Parse Talkm  ( xlel , the complexity of tile data exchtmged and compu-t : ltions perfommd  , in our case , require a full-llcdged mes-sage-l ) assiug model . 
6 CONCLUSIONS
The Parse Talk model of natural anguage underslanding aims at the integration of a lexically distrit  ) uted , depen-dency-based grannnar spc cilication with a solid fonnal foundation for concurrent  , object-oriented parsing ( of . 
Ilahn , Schacht & Br Oker ( forthcoming ) \[' or a more elaborated presentation )  . It conceives communication among and within different kuowledg csources  ( grammar , domain and discourse km ) wlcdge ) as the backbone for complex language understanding tasks  . The main specification elements of the grammar m ( ? lel consist of categorial , roof of valency specificatious attached to s ingle lexical items  . 
The associated concurrent computation m~xlelis based on the actor paradigm of objcct-orieuted programmiug  . The l'arse Talk model has been experimentally validated by a prototype system  , a parser for German ( for its implemenla-tional statns , cf . Schacht , Ilalm & Brt~ker , 1994) . 

The work reported in this paper is funded by grams from I  ) FG ( grants no . 
Ia 209711-1 , tla 2097/1-21 within a special research programme on cot , -nitive linguistics , We like to thank our colleagues , ENeuhatls , K . Sclmat-linger , M . Klenner , anti " Fit . llanne forth , for valnable onlrllents arid stlp-

REFIe ~ RENC le ~ S
AlINE'Y , S . & CO l . l : . . J .  (19861 . A govemment-bindlng parser . Proc . I 6th
NELS . pp . l-17.
AGIIA , G . & IIEW\['I~I ; C .  (1987) . Concurrent programming usiug actors . In A , Yone Tawa & M . ' l'okoro , 17 . ds . Oblect-Oriented Concurrent Programming . pp . 37-53, MIT Press . 
AKASAKA , K .  (19911 . Parallel parsing system based m dependency grammar  . In C . Brown & G . Koch , Eds . Nutural Language Untler-standing and Logic Progratmning  , Ill . pp .  147-157 . Norlh-Iloll and . 
CIIARNIAK , li , (1986) . An eat theory of marker passing . AAAI-86: Proc . 5th National Conf , on Artificial Intelh'gence , Vol . l . pp . 584-588, CI ~, EARY , L . G . & I~OLI , ARI ), C . J .  (19851 . A compulatlonal semantics fl ~ r natural language . Proe .   23rd Annual Meeting of the Association for Comlmtational Lingu & tics  . pp .  172-179 . 
DAI:A . EMANS , W . ; l)eSMFA)T , K . & GAZI ) AP ,, G .  (1992) . Inheritance in natural hmguage processing . Computational Lingu Lrtics , 18(2), 205-218 . 
DI~ . VOS , M , ; AI ) RIAENS , G . & WILI . EMS , Y .  (1988\] . The parallel expert parser ( I ) FA  ~ ) : a thoroughly revised descendent of tile wool expert F  , arser ( WEP ) . COLING'gs:Proc . 12th Intl . Conf . on Computational Linguistics . Vol . l . pp .  142-147 . 
EMEL F . , M . & ZAJAC , R .  (1990) . " l ~, pedunific at k m grammars . COL-ING'90: Proc . 131 h Intl . Conf . on Cotn putatiot ml Linguistics , Vol . 3, pp . 293-298 . 
EVANS , R . & GAZDAR , G .  (1990) . The DATR Papers , Vol .  1 . Univ . of Sussex , Brighton . ( Cognitive Science Research Paper , CSRP 139) . 
FI~-ASEI ~ . , N . M . & IIUI)SON , R . A .   ( 1992 ) Inheritance in word grammar Computational Lingu L ~ ' tics  , lg(2) ,  133-158 . 
GF . N'I'IIIAL , 1) . ; COURTIN , J . & KOWARSK 1, 1 .  (1990) , Contribution of a category hierarchy to the robus messol syntactic parsing  . COL-ING'90: Proc . 131 h Intl . Conf . on Computation tHLinguL ~' tlcs . Vol . 2 . 

GRANGER , R . ; FASEIT , K . & IIOIAH ~, O()K , J .  (19861 . Parsing with parallelism : a spreading-activation model of inference lnOCeSsing dnrittg text understanding  . In J , L . Kolodner & C . K . I ~, ies beck , Eds . 
I~perience , Memory , antt Reasoning . pp , 22% 246, i . F . rlbamn , tlAIIN , U .  (19891 . Making tm derstanders out of parsers : semantically driven parsing as a key concept for realistic text understanding applications  , lnternation aIJ . of Intelligent Systet rLv ,  4 (3) ,  345-393 , I1AIIN , U . & AI)R\[AINS , G .  (1994) . Paralleln atllralanguage F , rC , cess-ing : backgr(mnd and overview , In G . Adriaens & U , Ilalm , F . ds . 
Parallel Natural Longuage Processing . pp .  1 - 134  . Ablex . 
IIAIIN , U . ; SCIIACI rI ', S . & I\]I ~ . OKER , N . (ftmh coming ) . Concurrent , object-oriented natnral language parsing : thel ' arse Talk model  . 
International Journal of Iluman-Computer Stt Mies , Special Issue on Object . oriented Approaches in Artiftcial Intelligence and
Ihonan-Computer Interaction.
I1ELI . WI(\],P , (19881 . Chart parsing according to the slot and filler principle  . COLING'88: Pro&\]2th Intl . Conf , on Computational Linguistics , Vol . 1, pp . 242-244 . 
IIEMFOI , tTII , B . ; KONIF/ . .TZNY , L . & STRUIH :, G .  (1993) . In crcmemal syntax processing attd parsing strategies  . Pro&151h Annual Conf . 
of the Cognitive Science Society , pp , 539-545.
I/EI)PIJ ~, M .  (1992) . Chart parsing \[ mmbek grammars : modal extensions and incrementality  . COIJNG'92: Proc . 151 h Intl . Conf , on Computational Linguistics . I/o1 . 1 . pp .  134-140 . 
IIEW1TI ; C , & KI'KINSON , P, .  (19791 . Slmcification and proofted > niques for serializers  . IEEIe . Transactions on Software lengineering,
SE-5(11, 10-23.
IIIRS'I ', G , (1987) . Sertumti?Inter pretation antithe Resolution of Ambiguity  . Cand)ridge University Press . 
\]IUI)SON , R .  (19901 . Fmgl Lrh Word Gratmnar . Rasil Blackwell , Jfi , PI'INEN , ll . ; I , ASSII . A , E . & I . EIl TOLA , A .  (1988) . I . ocally governed trees and dependency parsing . COLING'88: Proc . 721 11 Intl . 
Conf . on Computational Linguistics . Vol . l . pp . 275-277, LES MO , L . & I ?) MBARDO , V .  (1992) . ' l\]m assignment of grammatical relations in natural anguage pr ~ x : essing  . COIJNG'92: Proc . 151 h Intl . Conf . on Computation td Linguistics . Vol , 4 . pp . 10911-1(Y ) 4 . 
LIFIIF , RMAN , II .  (1987) . Concurrent object-oriented pmg nn nnting in Act 1 . In A . Yonezawa & M . ' lbkoro , Eds . Object-Oriented Concurrent PrograJmning . pp . 9-36 . MIT Press , I . OMIIARDO , V .  (1992) . Incremental dependency parsing . Proc .   30th Annta : l Meeting of the Association for Comlmtational Linguistics  . 

Mac(;Itl:GOl't,R .  (1991) . The evolving technology of classification-based knowledget prcs enlall on systems  . In J . Sown , lid . Principles of Semantic Network . r , pp , 385-400 . Morgan Kaufmann . 
MARSI . IiN-WII ~"; ON , W . & TYIA ~ R , 1 . . (1980) . " llm temporal structure of spoken language understand hlg:Ihel  ) ercept lon of sentences at u ( words in sentences . Cognition , 8, 1-71 . 
MII ~ WARI ), I) .  (1992) . Dynamics , dependency grmn mar and incremental inteq ~ retation  . COLIN(;'92: Brae . 151 hlnt LConf on Computational Linguistics . Vol . 4 . pp . 1 f F15-1099 . 
MURAKI , K . ; ICIIlYAMA , Sh . & FUKUMOCIlt , Y .  (1985) . Aug-inelltetl tlelx211dency grallntlar : a slmple interface between the grant -marnile and the knowledge  . Proc . 2nd Conf . F ~ urope an Chapter of the Association for ComI ) utation td Linguistics . pp . 198-204 . 
PlIIII . IPS , B .  (198,11 . An object-oriented parser . In B . G . Flara & ( . 
Guido , lids . Computation td Models of Natural \[ ~ mgu2:ge Processing . pp . 297-321 . Nonh-IIoll and . 
P()I . I . AI~I ), C . & SAG , 1 .  (1987) . It J formation-Based Syntax and Seman-tics . Vol . l : Fundament a Lr . Chicago University Press . 
RIF . SIH ~ CK , C . & MARTIN , C .  (1986) . I ) irect memory access parsing . 
In J . 1 . . Kolodner & C,K . Riesbeck , I' . ' ds . Experience , Memory and Reasoning . pp . 2('~)-226, I . . F , dbat,n . 
RIF . SIIECK , C . & SCIIANK , R .  (1978) .   ( ~ mt prehension IW computer : ex\[xmtation-based analysis of sentences in context  . In W . J . M . l . ev-ch&G . B . I : lnresd ' Arcais , Fals . Studies in the Perception of Lan-gla:ge , pp2-'17-293 . J . Wiley . 
SCI/ABIiS , Y . ; AIH : IlA . F , , A . & JOSIII , A .  (1988) , Parsing strategies witt l ' lexicalized'grammars : application to tree adjoining grammars  . COLING "88: Proc . 12th Intl . Conf . on Computational Linguistics . Vol .  2 . pp . 578483 . 
SCI\[ACIIT , S . ; IIAIIN , U . & IH ~, OKFJ ~ , , N .  (19941 . Concurrent lexicalized dependency parsing : a Imhavioral view on Parse Talk events  . 
COLING'94: Proc . 15th Intl . Conf . on Computational Lingulsties . 
( this volume )
SIIFBER , S .  (1986) . An Introduetion to Unitarian-based Approaches to Grumtm : r  . Chicago University Press SEI , MAN , II .  (19891 .   ( 3omu~cfionist systems for natural anguage understanding  . Arh~licial Intelligence Review , 3, 2331 . 
SMAIA . , S . & R1 EGFA ~,, C .  (19821 , Parsing and comprehending with s ; ' onlexperts ( a theory and its realization ) , htW . Lchuert & M . Rin-gle , Eds . Strategies for Natural Language P ~ ocessing , pp . 89-147 . 
L . Erlbaum.
STAROSTA , St . & NOMURA , II , (1986) . l . exicase parsing : a lexicon-driven approaeh to syntactic analysis  , CO l , IN(;'86: Proe . IIth Intl . 
Conf . on Computational Linguistlcs , pp .  12"/-132 . 
TAMURA , N . ; IIOS , M ,;/vl UR AK AMI , II . ; NISIIII)A , O . ; YOSIIIMI , T . & JELIN liK , J .  (19911 . l . azy evaluation of preference on a packed shared forest without unpacking  . In C,G , l ~ rown & G . Koch , Eds . Natural I , anguage Understancling antiLogic Programming , 
II 1.pp . 13-26. North-lloll and.
TIIIBAI ) FAU , R . ; JUST , M . & CARPENTI~I ~ ,, P , (1982) . A model of the time cotlrsened content of reading  . Cognilive Science , 6, 157-203 . 
UFAIARA , K . ; OCIIITANI , R . ; MIKAMI , O , & TOY ODA , J .  (19851 . An integraled parser for text understanding : viewing parsing as passing messages among a clors  . 111 V . I ) ahl , P . Salnt-l ) izier , F . ds . Natural Langta~ge I Jnderstanding and Logic Progratmning  . Proc . of the ? stIntl . Wor Lrholr . pp . 79-95 . Norlh-lloll all d . 
YONEZAWA , A . & OIISAWA , I .  (19881 . Object-orienled parallel parsing for cc , nlext4ree grammars . COLING "88: l'roe . 12th Intl . Conf . 
on Computational Linguistics . Vol . 2, pp . 773078.
YU , Y . & SIMMONS , R , (1990) . Truly parallel underslanding of text , AAAI-90: Proe . 8th National Conf . on Ar@cial Inlelligence . Vol . 2 . 
pp . 996-I(XII.

