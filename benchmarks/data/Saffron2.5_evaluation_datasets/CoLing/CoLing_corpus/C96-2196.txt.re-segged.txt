Parsing Plans Situation-Dependently in Dialogues
Kiyoshi Kogure , Akira Shimazu and Mikio Nakano
NTT Basic Research Laboratories
31 Morinosato-Wakamiya , Atsugi , Kanagawa ,  243-01 . Japan
kogure , shimazu , nakano@atom , brl . ntt . jp

This paper describes a plan parsing method that can handle the effects and preconditions of actions and that parses plans in a manner dependent on dialogue state changes  , especially on the mental state changes of dialogue participants caused by utterances  . This method is based on active chart parsing and uses augmented edge structures to keep state information locally and time map management o deal with state changes  . It has been implemented in Prolog and is used for plan recognition in dialogues  . 
1 Introduction
Dialogue understanding requires plan recognition.
Many plan inference models have thus been proposed  . As an approach to the computation of plan recognition from observed actions  , plan parsing hms been proposed by Sidner ( 1985 ) and formalized by Vilain ( 1990 )  . A typical plan recipe for an action includes a sequence of subactions as its decomposition  , so interpreting an action sequence in terms of plans can be seen as parsing in which observed actions correspond to lexieal tokens and plan recipes correspond to grammatical rules  . 
Previous plan parsing methods , however , are insufficient for dialogue understanding since they do not handle the effects and preconditions of actions  . These effects and preconditions are of crucial importance in reasoning about what the agent intends to do and what she presupposes  . More concretely , without treating them , it is impossible ( a ) to describe actions in terms of their effects ,   ( b ) to capture the relationship between an action and another action that satisfies the former's preconditions to enable it  , and ( c ) to interpret actions in a manner dependent on the dialogue state  . 
To solve these problems , we have developed a plan parsing method that can handle the effects and preconditions of actions and that parses plans in a manner dependent on dialogue state changes  , especially on the mental state changes of dialogue participants caused by dialogue utterances  . 
This method , in particular , makes ( a ) ( c ) possible . The method is based on active chart parsing and uses augmented edge structures to keep state information locally and time map management  ( Dean and McDermott , 1987) to deal with state changes . The method is implemented in Sic-stus Prolog and is applied to a dialogue understanding system  ( Shimazu et al ,  1994) . 
2 Requirements for Treating
Effects and Preconditions
Let usex a mine typical situations where the effects and preconditions of actions must be treated  . 
2.1 Effect-Based Action Descriptions
In describing plan recipes , it is convenient to specify an action in terms of its effects ms follows: 
Recipe 1
Action : in form ref(S,H , Term , Prop)
Decomposition : achieve(bel(H,P ))
Effects : belref(H , Term , Prop)
Constraints : parameter ( Term , Prop)
A description of the form ' achieve ( P ) ' specifies the action for achieving the state where the proposition P holds  . This recipe thus says that an inform refaction can be performed by an action that has ' bel  ( H , P ) ' as its effect . There may be many such actions . Furthermore , the action specified by ' achieve ( P ) ' depends on the situation where P is about to be achieved  . In the extreme case , if P already holds , the agent need not do anything . For example , a speaker may not perform any action to make a hearer believe a proposition if the speaker believes the hearer already believes it  . If we are not permitted to use this form , we must enumerate all the actions that achieve P together with the conditions under which they do  . 
Treating this form requires calculating the effects of actions  . 
2.2 Action-Enabling
Given a goal , a planning procedure searches for an action to achieve the goal  ( a main action )  . If the procedure identifie such an action with preconditions  , it calls itself recursively to search for actions  ~01   . ~: contradicts(~,~,q</)~oj :
Figure h Effects of Complex Action.
that satisfy them ( enabling actions of tile main action )  , and then provides the action sequence consisting of the main action preceded by its enabling actions  . Given an action sequence of this form , a plan recognition procedure must thus regard it as I  ) erforming a main action to achieve itsettb . ct(s) . 
There are many kinds of dialogue phenomena that can be captured by such action-enabling relationships  . Understandings nch dialogue phenomena reqnires handling effects and preconditions  . 
2 . 3 State-Dependent Interi ) retation There are cases where state-dependent ier preta-tionisiml  ) ossible unless the effects and preconditions of actions are treated  . Consider , for example , the folh ) wing dialogue fragment : A : Please tell In e how to go to the Laboratories  . 
B : Take the busto Tokyo.
Whereas an imperative sentence ( with surface speech act type surface_request ) is generally interpreted as a request , the second utterance actually describes a step in tile plan to go to the Laboratories because the first utterance convinces B that A wants to have that plan  . This latter interpretation can be captured by using the heuristic rule for seh  ; cting an interpretation with fewer unsatisfied preconditions and the following recipe : 
Recipe 2
Action : describe_step(S,H Action , Plan)
Preconditions : bel(S , want(H,Plan))
Decomposition : surface_request(S,It,Action )
Constraints : stei ) ( Aetion , Plan )
This interpretation would be possible instead by using a recipe whose decomposition Mso contains the action of making B believe A ' s want  . However , such a recipe can handle only cases where the belief has been established by the action just before surface_request  . 
3 Effects and Preconditions 3 . 1 Effects of Ac t ions The efl>cts of a linguistic action in a dialogue mainly I  ) roduccun observable mental state changes of the di Mogne participants  . For a computer to participate in a dialogue like people do  , it must simulate such mental state changes . 
The clthcts of an action are the propositions tlmt hold after the action's successflt lexecution  . 
The effects are taken to be cah : nlated recursively c  ~ 
Case(a ) ( tgj = ~/) kII *
C~e ( b ) ~ Pk : ~ j = ~ P k ) . . . .
~i , , , contradicts(~i , bk)
C:~s0(~)'~bk:contradi('ts((pl , ~bk)qoi )) . 
Case(d ) contradicts(q~i , Pk ) ' t/,'i
Figure 2: Preconditions of Complex Action.
fl ' omtile action's recipe and component actions if any : the effects are essentially those specified by the action's recipe  , plus those of component actions . Since an action is modeled to have a certainten q ) or a lextent , an action's effect is in odeled to hohl at the point in time where the action has just finished and to continue  , to persist infinitely or until the first instance that a contradictory fact holds  . An effect of an a ( : tion's component action also holds in the same way  . Therefore , an action ~ with (71,- .   .   , % ) as its component actions has component action 7's effect ~ oi as its ownef-R'~ct if there is no component action  3'3 after 3'/ with an e\[fect 99j contradictory to ~ oi written as contradicts ( ~ , i , ~ j ) - and does not if such " ~ i exists as in Figure 1 . 
a . 2Preconditions of Actions
Tile preconditions of an action are tile proi ) osi- ( ions that must hold before the action ' successful execution  . Recognizing an action thus requires that its preconditions can be ~ msure doratle tust hypothesized to be believed by the agent  . 
The preconditions of an action are essentiMly taken to consists of those specified by the ac ~ tion's recipe and those of its component actions if atty  . A component action's precondition , however , can be satisfied by another component action's effect  . Consider action a with its component actions (%, . . . , %~), as shown in Fignre 2 . Let us focus on precondition ' ~ b / ~ of action % . When the . re is an action 7j before % such that its ef~fect q0j is identical to ' ~ bkas in Case ( a ) in the figure , " ~ bk is satisfied by ~ oj , so * Pk need not hoht at (~' s starting time . That is , ~ does not have ~/ J / ~ as its precondition . On the contrary , when there is an action ~ i before % such that its effect  q0i contradicts ~/ ; k , ~bk'shohtingata's starting time cannot contribute to the satisfaction of %' s precondition */  ; k-If there exists an action 7j between 7i and % with its effect qoj identical to ~ bk , ~/ Jk can be satistied\[Case(b)\] . Otherwise , * Pkemmot be satisfied\[Case(c)\] , so a cannot be successflfl lyex--ecuted and shonht not be recognized  . This kind of ( EP ) conflict . ' There is another kind of interference called ' precondition-precondition  ( PP ) conflict : ' if a precondition specified by ~' s recipe  , or a precondition ? i of any other component action  7i contradicts Ck , they cannot hold simultaneously at c ~' starting time\[Case  ( d ) \] . In such a case , should not be recognized . 
4 Active Chart Plan Parsing 4 . 1 Decompos i t ion Grammar The relationship between an action and its decomposition specified by a recipe can be viewed as a phrase structure rule  . The decomposition relationship specified by Recipe  2  , for example , can be view as describe o step ( S , H , Action , Plan ) surface_request(S , H , Action ) . 
This interpretation of the decomposition relationships specified by recipes in a plan library gives usa decomt  ) osition grammar and allows us to apply syntactic parsing techniques to plan recognition  . 
Based on this idea , we constructed a plan parsing method that handles the effects and precondi=tions of actions  . Hereafter , we focus on bottom-up active chart parsing , although the core of the discussion below can be applied to other parsing methods  . 
4.2 Calculating Effects and Preconditions
TimeMap Management
Time map management is used to capture the temporal state changes caused by the effects of actions  . A time map consists of a set of ( potential ) fact tokens ) A fact token is a triple ( tl , t2 , ~ o ) , where tl and t2 are time points and ~ is a time-less fact description  ( a term )  , that represents the proposition that ~ holds at tl and continues to persist through  t2 or until a contradictory fact holds . As a time point , we use a vertex in a chart , which is an integer . As a special case , timepoint T is used to represent unbounded persistence  . An effect ~ of action finishing att is represented by a fact token  ( t , T , ~ o . 
A time map with a set ~" of fact tokens supports queries about whether it guarantees that a fact ~ holds over an interval \[ t ~  , t2\] ( written as tm_holds((h , t2 ,  ~) , ~-)) . if act ~ is guaranteed to hold over an interval \ [ tl  ,   t2\] exactly if there is an intervalrt ' gl such that ( t ~ < tl < t2 < t ~ ) AL1 , 21------(t ~ , t~ , q o ) e ~" and if there is no ( ta , t4 , v ') 6~" such that contradicts ( ~0 , ~0') A(t ~< ta_<t2) . 
A precondition ? of an action can be represented by a triple similar to a fact token  . Since it must be satisfied at the action's tarting time t  , it is represented by ( t , t ,  ?) . 
1 This paper uses Shoham's terminology (1994).
start end action rsubactions constraints effects preconditions a cnd  ( an ! nteger )   ( gnihteger )   ( a term )   ( a sequence of terms )   ( a set of constraints ( a set of triples )   ( a set of triples )   ( a variable ) 
Figure 3: Edge structure
Data Structures
In our chart parsing , an action is represented by an edge . Since information on the effects and preconditions of the action represented by an edge must be kept locally  , we use the edge structure shown in Figure 3 . An edge'start and end values are vertices that are the respective integers representing the starting and ending time points of  ( the part of ) the action represented by the edge . The action and rsubactions ( remaining subaetions ) values are respectively an action description and a sequence of descriptions of actions to find in order to recognize the action  . An edge is called active if its rsubae tions vahm is a nonempty sequence and is in active otherwise  . The constraints value is a set of constraints on variable instantiation  . 
The effects and preconditions values respectively are sets of triples representing the action's effects and preconditions  . Thea end ( action end ) value is a variable used as the placeholder of the action's ending time point  . The ending time of the action represented by an active edge is not determined yet  , and neither is the starting point of the effects specified by the action's recipe  . To keep information on those effects in the edge , fact tokens with the a end value as their starting time points are used  . An unbound time point variable is taken to be greater than any integer and to be less than T  . 
An edge'saend value is bound to its end value if it is inactive  . Given an edge e and its field field , field(e ) denotes the value of field in e . 
Chart Procedures
Given an observed action , chart parsing applies the following procedure : P rocedure  1 Let ~ j be the description of the j-th observed action  . For each recipe with action ~ r , and for each most general unifier 0 of ~ j and C~r satisfying the constraints Cr specified by the recipe  , create an inactive edge from j- 1 to j such that its action , constraints , effects , and preconditions values respectively areaj 0 , CrO , ( j , T , ~ T0) I~T eE ~ , and ( j-1 , j-1 , ? ~0I ? , " EPr , where Er and Pr are the effects and preconditions specified by the recipe  . 
Chart parsing proceeds using the following two procedures  . 
1096l ' rocedure 2 Let ei be an inactive edge . For each recipe with its a . ctiona, . , decomposition (71, .  -  .   , %)  , effects Er , and preconditions P , , and for each most general unifier 0 , satisfying constraints ( ei ) and recipe's constrains C ,  . , of action@i ) and 71 such that g = ( cff ccts ( ci ) )O
U(v,T,9::,, . O ) I~," CZC, . and 7) = ( t , t , '?') rd(prc conditions(ci )) OI~tm_holds((t ,  ?) , g ) U(start(ei ) , start ( ed , GO ) lGc /' ,  . , without EP or P - I ' contlict , where v is a new variable , create an edge from start ( ci ) to cnd ( ci ) such that its action , rsubactions , constraints , effects , prceonditions , and a end values respectively are < Y ,  . O , (%, . . . , 7, ~)0, ( C, . Oe on straints(ci )) O , g , 7), and V . 
Procedure 3 Let c ~ and ei be adjacent active and in active edges such that rsubactions  ( e  ~ ) is ( 71 ,   .  -  .  , 7~) . For each most gener Munifier 0 , satisfying C =  constraints ( e  ~ ) O constraints ( ci )  , of 71 and action ( el ) such that = ( e F e c t s ( e a ) ueJy~cts ( ed ) O and 7 )  =  ( t , t , ' ~ b ) E(prc conditions ( e . )
Upree on ditions(ei )) OIt . ,_holds (( t , t ,  ?) , C ) , without F , -Por PP conflict , create an edge fr < ) m start ( e < , ) to end ( el ) such that its action , rsubaetions , constraints , effects , preconditions , and a cnd values respectively are ( action ( e , )) O , ( Tu , - . . ,7~)0, CO , g , ~ P , and acnd(c,~) . 
Now that we have the basic means to eah : ulate the effects and preconditions of the action represented by an edge  , we can augment plan parsing to handle the situations described in Section  2  . 
Effect-based action descriptions The fact that the description of the form achieve  ( P ) can specify an action with P as its effect is captured by augmenting Procedures  2 and 3  . The set of effects of the action represented by an inactive edge e i that hold at the  . action's ending time is/?7/=qoItm_holds(qo , end(ei ) , cnd(ei )) , effects@i )) . 
The fact is thus captured in these procedures by checking that Ei contains P  , instead of unifying 71 with action ( ei ) , if 71 is of that form . 
The fact that achieve ( P ) can specify the null action if P already holds is captured by a new procedure that  , given an active edge e ~ with as its rsubactions value  ( achieve ( P )  ,  72  ,   .  -  .   ,  % , creates a new edge whoser subactions value is (% ,   .   .   .   , % and whose preconditions value is preconditions ( e , ~) if e ~ , hasPaa its effect and preconditions ( ca ) plus end ( e . ), end(c ~), P otherwise . 
Action-enabling An action-enabling relationship can be captured by a new procedure that  , given two adjacent in active edges el and e2 such that el's effects satisfy some of eu's preconditions  , treaties a new in active edge with action ( c2) , as its action value . + State-dependent interpretation A dialogue state is determined by the initial state and the effects of the I  ) receding actions . The initial state is treated by using a special ' initialize ' in active edge from  0 to 0 with the effects value representing it . The influence of the qnitialize ' edge is propagated by the procedure for treating action -enabling relationships and preference rules referring to precon  ( litions , a 5 Conclusion Aplanl ) arsing method has been prol ) osed that handles the effe <: ts and l ) ree on ditions of actions and that parses i ) lanshia manner del ) endent ( m < tialogue state changes ( ' ause<t by utterances . The method has been implemented in Prolog . The . 
imt ) lemented progl'am uses an agendaine chanism that uses priority scores on edges to obtain i  ) re-fi ' . rred plans first . The method has been applied to understanding route-explanation dialogues by using the dialogue plan model that takes each action of uttering a word  ; ~s a primitive and that treats intra - and inter -utterance plans uniformly to treat fragmentary utterances  ( Kogure et al ,  1994) . 

Tllomas I~.l ) ean and Drew V . McDermott .: 1987.
Tmnporal database management . ArtiJicial Intelligence , 32(1):1-55 . 
Kiyoshi Kogure , Akira Shimazu , and Mikio Nakano.
1994 . Recognizing plans in more natural dialogue utterances  , in Proceedings of IGWLP . 94, pages 935-938 . 
Akira Shimazu , Kiyoshi Kogure , and Mikio Nakano.
1994 . Cooperative distributed processing for understanding dialogue utterances  . In Proceedings of
IUSLP94, pages 99:102.
Yoav Shoham .  1994 . Artificial Intelligence Techniques in Prolo 9 . Morgan Kanfmann Publishers . 
Candace L . Sidner .  1985 . Plan parsing for intended response recognition in discourse  . Computational
Inte Uigence , 1(1):1-10.
Mark Vil Mn .  1990 . Getting serious about parsing plans : a grammatical analysis of plan recoguition  . 
In Proceedings of AAAI-90, pages 190-197.
2As an extention to control the applicability of this procedure  , the effects and preconditions fields respectively are divided into main_effects and side_effect  . s fields amt into preconditions and prerequisites fields  . 
The procedure checks enabling relationships only between main_effects and preconditions  . 
a The use of the initial state also contributes to the efficiency of plan parsing : an input action sequence  ( : an be shortened by cMculating the current state in the middle of a dialogue and by restarting plan parsing with the current state as a new initial state  . 

