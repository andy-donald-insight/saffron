DATABASESYSTEMBASEDONINTENSION ALLOGIC
Naoki Yonezaki , Hajime Enomoto
DEPART MENTO FCOMPUTERSCIENCE
TOKYO INSTITUTE OFTECHNOLOGY
2-12-1, OO KAY AMA , ME GURO-KU
TOKYO152, JAPAN
Model theoretic semantics of database
systems is studied . As Rechard Montague has done in his work ,   5 we translate statements of DDL and DML into intensional logic and the latter is interpreted with reference to a suitable model  . Major advantages of its approach include ( i ) it leads itself to the design of database systems which can handle historical data  ,   ( ii ) it provides with a formal description of database semantics  . 
1. INTRODUCTION
There have been developed several knowledge base systems which utilize mathematical logic  , however they can Great facts or rules at the current world only  . ~ ~ In the medical fields or the area of art ificial intelligence there are many applications in which the database systems with h is torical data handling capability are required  . For example , in a query to a medical database tHasasterum treatment been applied to 
John ?' historical data is essential.
One of the reasons why existing database systems provide poor support for such historical info rmation is probably because very few theoretical study has been done yet  . 
Intensional logic ( IL ) which Rechard Montague developed to describe semantics of natural language formally seems to be useful to the theory of such database  . The first application of modal logic to the logic of database was done by Lipski  , though he treated incompleteness of database only . 
In the Montague's approach , concepts of intension and extension are used .   5'6 The same concepts can be applied in the theory of database  . Correspondence between IL and semantics of database is shown in Fig  . l . 
\[ Intensional Logic \]: possible worlds extension intension meaning postulates : \[ Database \] states of database data at some state historical data integrity constraints Figol Correspondence between Intensionals 
Logic and Database system
The extension of a constant predicate P in IL which corresponds to a relation in database corresponds to the contents in the current database state  . 
The main purpose of this paper is to describe in a implementation-independent way aspects of those database semantics  , which are characterized by interpretation of update operations and queries  . And we show the feasibility of using intensional logic for description of the semantics  . 
The treatment of update of database is closely related to that of assignment in programming language with data type specification facility  . 
Firstly we use Montaguets intensional logic and later we will introduce two-sorted type theory to treat queries which refer state indirectly  . 
In section 2 , we define a data model treated in this article . This data model is considered as hierachical relational model  . In section 3 , syntax of intensional logic is defined and its semantics is stated in section  4  . In section 5 ,  6 , syntax of query statements and their Montague semantics are given  . In section 7 ,  8 , data manipulation statements are introduced and their semantics is also defined  . 
In section 9 , semantics of two kinds of null value is stated as meaning postulates  . In section i 0 , we introduce two-sorted type theory and give semantics of statements referring states  . Section II is a concluding section . 
2. DATAMODEL
In this section we define a data model which corresponds to relational model exploiting hierarchical structure of relations  , that is , each component of relation may be also a relation or set of relations recursively  . In the Relational Model which Codd 7 introduced ,   3rd-normal form or 4th-normal form is exploited to avoid the update anomalies , though we regard it as an implementational matter  . Hierachical structure of relation is quite natural for representing information in the real world  . 
As a part of a data definition language ( DDL ) , schema declaration is formally defined as follows  . This DDL describes hierachical schema of database  , name of each relation and attribute names or selector names of a relation  . When we consider schema of relation , we do not concern the name of relation . 
Let SO be the set of all elementary data types e . g . integer , real or string of characters and so on , and F be the set of selector names . 
Schemas of database are constructed from SO recursively as strings on Ct = SOu\[  , \] , ' , :

Def . The set S of schemes is the smallest set S 2 satisfying ( i )  , (2) . 
220 ( i ) SimS0US2, (2) tI . . . . . tneSI , sI . . . . . SnEF(si~sj for imj ) =>\[ sl:tI . . . . , Sn:tn\]ES2 ( l~n) . 
Schema declaration in our DDL is of the form
Relation name=t ? where tES.
Now we can define the hierarchical relational database  ( HRDB ) as follows . 
Def . The set HD of HRDB is defined as
HD = UDt.

Fort ES , Dt is the set of database whose schema is tdef ined recursively with the following rules  ( I )  ,  (2) . 
( i ) tES0=>D t = E ~ , where E ~ is the set of data -- 5 L havlng elementary type t , (2) tES and t =\[ Sl:tI . . . . . Sn : tn\]=>
D t=2 Dt ~? Dt ~ ? . . . ? DL'Ln , where Dt ~ Dti UNULL1, NIJLL2 . 
An examp I e of a database is shown as follows.
Example i
Now , we consider an employee relation comprising of tuples which have hierarchical structure  . Each such tuple consists of employee number , name , education relation , age , a set of skills and children relation . 
Corresponding schema declaration is as follows . 
EMP i =\[$ E : int , NAME : string,
EDUCATION:\[SCHOOL:string,DEG:string,YR:int\],

KIDS :\[ KNAME : string , AGE : int , SEX : string\],

Fig . 2 is an instance of database with this schema at some state or world  . 

EDUCATION SKILL
SENAMES CHOOLDEG YRSNAME iCARYJ 2 JONES 3 SMITH
ANULL 258 SA
BiB 64 SE

CA 72
DC74 NULL1
ANULL 280
C ! A50 SB



KNAME AGESEX'SAL
JACK8 Mi
JILL5 F15K
JOHNi 0M
NULLI !14K
MARY 17F 20K
Fig . 2Instance of the Employee Relation
The value ' NULL 1' means nothing , however in some state there may be some values . The value ' NULL2' means absolutely no value exists in any state . The order of selector in each tuple is insign i ficant and order of raw is also insignificant  . This hierarchical schema can be visualized by tree graph  . Fig . 2 is a two-dimensional representation of hierarchical data which reflects the images of data instances  . 
EMP ii $ EINA MEIs ALI

Il
EDUCATION SKILL
Fig . 3A tree graph of hierarchical data
Note that the data declaration in our DDL and this graphs how the data structure only while the graph provides a convenient means to visualize the instances  . 


KNAME AGEJSEX ~3 . SYNTAXOFINTENSION ALLOGIC Intensional logic used in the Montaguets approach is based on the theory of types  . In this section we describe the extended version of IL according to Gallin  .   8 The set of all possible types is recursively defined as follows ? Def  . Let e , t , s be any three objects . The set of types of IL is the smallest set T satisfying  ( 1 ) ~ ( 3 )  . 
( I)e , t?T , (2) a , b ~ T => < a , b > ET , (3) a ET => < s , a > ET . 
Objects of type e correspond to entities.
Type of IL corresponds schema of our DDL or DML.
Our schema support snary relations , and it is considered a snary function whose range is truth values  . For any function of two ( or more ) arguments there exists an equivalent one which takes one argument at a time  , 9 i . e . ( Di ? D2? . . . 
? Dn ) -> Dn+1 corresponds to ( D1-> ( D2-> (  . . . ->( Dn->Dn+l )))) . . . ) . In this way we can make the types in IL correspond to schemas of our DDL  . D type which is a subset of type T in IL is now introduced as follows  . 
Def . D type is the smallest set of TA satisfying ( 1 ) ~ ( 4 )  . 
( i ) eETB , (2) a ETA => < s , a > ~ TB , (3) a ETB => < a , t > eTA , (4) be TB , a eTA => < b , a > ~ TA . 
Constants of type < s , a > ( aED type ) correspond to relations with schema corresponding to type a  . Such translation will be defined formally in section  6  . Intuitively speaking , constants of type < s , < e , t > > --221 corresponds to relations with schema\[s:int  \]  , \[ s:real \] or Is:string\] , i . e . single flat domain relation . Constants of type < s , <<s , a> , t >> correspond to relations with schema\[s  : \[  . . . \]\] i . e . hierarchical relations of single domain whose value is not flat but a relation with schema corresponding to type a  . By rule (4) , we can define the type of IL corresponding to nary relation schemas  . 
Example 2
The type of constant in IL corresponds to relation in Example  1 is which < s , <e , <e , <<s , <e , <e , <e , t>>>> , <<s , <e , t > > , < < s , <e , <e , <e , t>>>> , <e , t>>>>>>> . 
We take CON a ( VAR a ) to be the set of constants ( variables ) of type a . Now , we define the set Tma of terms of IL of type a as follows  . 

( i ) CON acTma , (2) VAR acTma , (3) A , BET me => A+B , A B , A , B , A ? B ~ T m e , (4) Ae Tm < a , b > , B?Tma => A\[B\]~Tmb , (5) A ? Tmb , xEVARa => ~ . x(A)~T m < a , b > , (6) A , BETma =>( AB ) ET mt , (7) AETma => hAET m < s , a > , (8) Ae Tm < s , a >=> VAET ma'(9) A , BETma , PET mt => ( P+A , B)eTma , ( i0) A?T ma , cECON < s , b > , BeTmb => B/V cA?T ma , ( Ii ) Ae Tmt => PA eTmt , FAeTmt . 
The additional construct ( i0 ) is introduced by Janssen . I0 Following Henk in , II we define sentential connectives , quantifiers and modal operators as follows . 

(I)T=\[kxtxt-~.xtxt\].
(2) F =\[ ~ , xtxt-AxtT\] , (3) ~= X xt\[F'xt\] , (4) A = AxtkYt\[If < t , t>\[fx . y\] . ~f<t , t >\[ fT\]\] , (5) ?= kxtkYt\[\[xAy\]'x\] , (6) V = ~ xtAYt\[ , - . x + y\] , (7) YxaA=\[AxaA'AxaT\] , (8) ~ X a A = ~? x a ~ A , (9)\[Aa ~ Ba\]=\[AAa'ABa\] , ( I0)\[\]A =\[ A~T\] . 
( ii ) OA = ~\[\] ~ A.
We write\[AAB\]instead of\[\[hA\]B\] where A and B are formulas  , similarly for the other binary connectives . 
4. SEMANTICSOFIL
The terms of intensional logic are interpreted in an intensional model  . Such a model is a system M = ( Ma ,  < , m ) a ? T , where Ma is a frame based on nonempty sets D and I  , and < is a linear ordering on S . To simplify following arguments , we make no distinction among ' in t ' , ' real ' and ' string ' , and they are represented by D . 
Def . Frame is defined as the indexed family ( Ma ) a ET of sets , where ( i ) Me = Du NU LL 1 , NULL2 , (2) Mt = 2 = 0 , 1 , (3) M < a , b >= MbMa=FIF:Ma->Mb , (4) M < s , a >= MaI=FIF:I->MaUNULL 1 , NULL2 . 
Function m must be such that if c is a a constant of type a  , then m ( Ca ) eM < s , a > . 
Tile assignment g is a function from variable to value such that if x eVAR at heng  ( xa ) eMa . If x a is a variable of type a , and xe Matheng ( x/X ) denotes the value assignment exactly like g except that it assigns the value 
X to the variable x.
Now we define the interpretation of a term Aa in a model M with respect to the states and the assignment g  . It is denoted by VM , s , g(Aa ) and defined inductively as follows . ( We dropped the subscript ' Mr . )

( i ) Vs , g(X a ) = g(Xa ) , XaEVARa , (2) Vs , g(C a ) = m(C a ) ( S ) , Cae CONa , (3) Vs , g(Ae+Be)=Vs , g(Ae)+Vs , g ( Be ) and similar for the other arithmetical operations  , (4) Vs , g(A<a , b >\[ Ba \]) = Vs , g(A < a , b>)\[Vs , g(Ba)\] , (5) Vs , g(XX aAb ) = the function f with domain M a , such that whenever X e Mathen f(x ) = V s , g , ( Ab ) , where g ' = g(x/X ) . By using meta-operator \ [ , we express the above as \[ X\[Vs , g , ( Ab)\] , (6) Vs , g(Aa-Ba ) = lifVs , g(Aa)=Vs , g(Ba ) , and 0 otherwise , (7) Vs , g(AA a ) = \[ j\[V j , g(A a)\] , (8) Vs , g(VA<s , a>)=Vs , ~~(A<s , a >) ( s) , (9) Vs , g((P t + A a , Ba )) = Vs , g(A a ) if V s , g(P t ) = l , and Vs , g(Ba ) otherwise , (10) Vs , g(Bb/VC<s , b>Aa)=Vt , g(Aa ) , where t = < c+Vs , g(Bb ) > s , ( II)Vs , g ( PAt ) = I if there is some s ' in S such that s ' < s and V s , ,g(A)=1 , 0 otherwise , (12) Vs , g ( FAt ) = l if there is some s ' in S such that s < s ' and Vs  , g(A ) = l , 0 otherwise . 

In the rule ( 10 ) t denotes the state in which all constants have values exactly like insexcept that the value of Vc is the value of the expression B b in the states  . 
We must clarify the notion of state in our model to define the meaning of database  . State is understood to present the internal situation of a database  . A state is altered by update operations . A new states I preceeds an old states 2, i . e . ( s2 < sl) . Clearly a states El determines the value of all relations  . The effect of update operation is that it modi fies the value of single relation  , and in order to model this update operation , it should be assumed that the resulting state always exists and is unique  . 
So we restrict our model for IL which satisfies the following postulates  . 
I ) Update postulate
For every tI~I , every c ? CON < s , a > ( aED type ) and everyie Ma , there exists a unlquet2ES such that
IVs , g(C ) ( tI ) = i ,
Vs , g(C')(tI ) = Vs , g(C')(t2) , for all constants c'm c . 
2) Uniqueness postulate
For every ti , t2eI(tI~t $) , there exists c ~ CON < s , a > ( ae D type ) such t ~ at
Vs , g(C ) ( tI)~Vs , g(C)(t2) , that is , the result of update operation should be distinct from all of the other states  . 
Therefore , we can identify a state with contents of database  . The database is translated into constant in IL . So the set I of states is defined by-N-T
I = aeD type c ~ CON < s , a > Ma 5 . QUERY STATEMENTS Now we introduce a syntax of queries in our data manipulation language  ( DML )  . The set Q of queries is defined as QiuQ2 recursively . 

( i ) O , IcQi ' ( 2 ) dE descriptor => dEQI' ( 3 ) ql'q2~Qi =>- ql' ( ql+q2 )  '  ( ql ? q2 )  '  ( ql ? q2 )  , always ql'past q1'future q2~QI' ( 4 ) f ~ Q2' q~Q1 => q when f , q whenever fcQI ' (5) T , F ~ Q2' ( 6 ) ql'q2EQ1=> ql=q2eQ2' ( 7 ) fl'f2EQ2=>'If1' ( flVf2 )  '  ( flAf2 )  '  ( fl => f2 )  , always f , past f , future f ,   f2 when fl ' f2 whenever flE Q2" Qi is the set of queries for which an answer is a set of objects  . For a query in Q2 an answer is yes or no . 
Every descriptor is of the form < R , sI , s2 , A > , where R is a relation name , s \] , s2 are sequences of selectors , and A is the ~ ubset of
Dt which is accessed by s2.
< R , sI , a2 , A > is used to denote the set of ~ element of tuples in the relation R whoses  2 ement is in A . In the above rule ( 3 ) all descriptors in ( ql+q2 )  ,   ( qloq 2 ) or ( q1 ? q2 ) must have the same selector sequences I as their second component  . 
We assume certain auxiliary language for describing A which is a subset of the domain Dt  . 
Example 3
Let us consider a query , tWase very employee who has a child named Jack educated at school B or C ?' on the database g iven in the previous example  . We have a expression < EMP , NAME , KIDS . KNAME , Jack > o-<EMP , NAME , EDUCATION . SCHOOL , B,C >= 0 . 
Let us consider another example as follows.
'G et al names of employees who always earn more than  I0000 or less than 500  . I The corresponding expression is always (< EMP , NAME , SAL , xlx > 10000>+<EMP , NAME , SAL , xT x < 500>) . 
6. SEMANTICS OF QUERIES
We have already defined a model theoretic mean ing of IL  . Thus the remaining part of Montague semantics is defining a translation which gives for each syntactic structure of the language some meaningful expression of IL  . For a part of statement E , its translation into IL is denoted Et . Relation name R is translated into a constant R'of IL whose type is determined by its schema declared at DDL  . More precisely this type is determined with next rules  . If there is a statement VR name : t ' in a data definition part  , then type of the constant Rname'isG(t ) , where G is a function satisfying , 
Def . G : S-~D type(i)t=\[Sl:tI,s2:t2 .   .   .   .   . Sn : tn\]=>G(t ) = F ( t ) = < s,<F ( tI ), < F ( t2) . . . . . < F(tn ), t > > . . . >, (2) tESO => F ( t ) = e . 
Each descriptor < R , sI , s2 , A > is translated according to the schema of R and sequences of selectors sI and  82  . Let so denote the common maximal prefix of sI , s2 and Is0i'~=n , IsI\[=n+k , Is 21 = n + q , i . e . sI , s2 are represented as Sl = S01 . s02 . . . S0n . Sll . Sl2 . . . Slk , s2 = s01 . s02 . . . S0 n . S21 . s22 . . . S2q . 
tFor strings , Isl denotes length of s.
223\[<R , sI , s2 , A >\]' = ~ iSlk ( ~ iSon ( \[R ( s01"'S0n ) \]'\[ R'\]\[is0n\]^~ . ? (3 il . . . ~imiSll31S21 ( VlS0n'\[il\] . . . \[ iSll . \]"'\[ is 21\]'"\[im\])
A\[R ( Sl2""Slk ) \]' ( iSll ) ( islk ) ^ ~ iS2q ( \[R ( s22 . . . S2q )\]'(' is 21)(is2)^VA'\[is\]))) ~ , where the sequence 3 ii . . . 3 im2 ~ oes ~ not contain ~ iSllor ~' is 2I . The number m and positions of \[ i \] , \[ i \] in the sequence of
Slls21\[il\] . . . \[ im\]are determined self evidently by the DDL statement about R  . If n = 0 then the first component\[R(So1 . . . S0n ) \]'\[ R'\]\[i \] of the above conjunctive form is replaced by R'-i  . If k=0 or q=0 then an appropriate but obvious modification is also needed  . It is possible to construct this IL expression systematically according to a microsyntax of a descriptor  , however it is somewhat tedious so we do not concern it  . When a is a type of subschema corresponding to the selector  s9\]  , A ' is a predicate of type < a , t > in which Aqi ) has the value i when an object corresponding to i is an element of A  . 
Each is is a bounded variable whose type is the one determined by G and subschema corresponding to a selectors used in a relation 

Translation of R(Sl . . . Sn ) is defined as follows.
\[R(Sl . . . Sn )\]' = ~ i ~ is (3il . . . ~ im(Vi\[il\]...\[im\]
A\[R(s2 . . . Sn)\]'(i )( is )))\[ R(Sn)\]'=~i ~ is (3il . . . ~im(Vi\[il\] . . . \[is\] . . . \[ im \])), where , each bounded variable il , . .0 , i_has the same type determined by G and su ~ -schema corresponding each selector which appears in the same level of relation R as the selectors n appears  . Moreover the sequence 3 ii , . . . , 3 in does not contain ~ i_ . 
According to the syntax of Q , translation into IL expression is defined as follows  . 

(1)\[O\]'=A~xEF\]\[x\] , (2)\[l\]'=^~x\[T\]\[x\] , (3)\[-q\]'=AXx(~(V\[q\]'\[x\])) , (4)\[ql+q2\]'=Axx(vEql\]'\[x\]vV\[q2\]'\[x\]) , (5)\[qloq2\]'=A~x(V\[ql\]'\[x\]AV\[q2\]'\[x\]) ,   ( 6 ) \[ q1*q2\]'=A~x ( ~ V\[ql\]'\[x\]vV\[q2\]'\[x\] )  , (7)\[alwaysq\]'=A~x(~V\[q\]'\[x\]) , (8)\[pastq\]'=A % x(eV\[q\]'\[x\]) , (9)\[future q\]'=A~x(FV\[q\]'\[x\]) , ( I0)\[q whenf\]' , \[ q whenever f \]': these will be defined in section  I0  , (11)\[T \]' = AT , \[F\]'=AF , (12)\[ql = q2\]'=A(V\[ql\]'mV\[q2\]') , (13)\[~ f\] , = A(V\[f\] , ) , (14)\[flVf2\]'=A(V\[fl\]'vV\[f2\]') , (15)\[flAf2\]'=A(V\[fl\]'AV\[f2\]') , (16)\[fl=>f2\]'=^(~V\[fl\]'VV\[f2\]') , (17)\[ alwaysf\] , = ~ v\[f\] , , (18) \[ past f\] , = pV\[f\] , (19)\[futuref\]'=FV\[f\]' , (20)\[ f2 when fl\]' ,  \[  f2 whenever fl \]': these will also be defined in section  i0  . 
In case of \[0\]' . \[ I\]' , type of x is determined by the context of its usage in a query  . 
7. DATAMANIPULATION STATEMENTS
Insertion , deletion and update of tuples in database are now considered  . We concern the case where we can manipulate either one tuple at a time or a set of tuples with a single command  . 
Syntax of update statements is defined as follows . Update statements are built up from certain descriptor and operation  . More exactly , the set M of data manipulation statements is defined with the following four cases : 
I ~ ( set oriented update ) d : descriptor , < f , d > ~ M , where fmeans arbitrary operation on the object in the answer of d  , (2) ( individual insertion ) (2-i ) < R , t > EM , where , R is a relation name and t is a tuple which is intended to be inserted into R  , (22) d : descriptor , < d , t > ? M , (3) ( individual deletion ) (31) ~< R , t > eM , (32) d : descriptor , ~< d , t > ? M , (4) ( set oriented deletion ) ~< R , S , A > ~ M , where , R is a relation name , s 2 is a sequence of selectors and A is the subset of Dt which is accessed by s  2  . 
A set oriented update statement ( i ) changes all elements in a relation R that are elements of answer for query q by values which is a result of operation f on them  . An individual insertion ( 21 ) means insertion of a tuplet into a relation R as usual  , and an individual insertion ( 22 ) means insertion of a tuplet into the all relations which are elements of answer for query d  . We can define the meaning of individual deletions  ( 31 )  ,   ( 32 ) in the same manner as in the case of insertion by changing the word ' insert w by ' delete v  . Set oriented deletion statement ( 4 ) deletes all tuples whose values accessed by B 2 are in A from relation R . 
~2248. SEMANTICS OF DAT AMANIPULATION
In the Montague semantics , a data manipulation statement is translated into forward predicate transformer  , which is a function from a state predicate to a state predicate whose type is < s  , t > , and which has the format of an intension of an assertion  . So the predicate transformer has a type << s , t > , < s , t >> and has the format kP (~) , where P~VAR < o +> and ~ is a term of type < s , t > . For set or lented update statement , we define the translation into IL as follows . In this definition symbol , + t is used to designate the ? . , +, inverse of the translatlon , i . e . \[\[ E\]\]=E for a term E of IL . 
\[<f , d>\]'=\[R :=\[~ il . . . ~ is01 . .,~ im(~J s01(VR'\[il \] . . . \[Js01\] . . . \[ im\]A\[%R(s02 . . . S0n)\]'\[js01\]\[ is01\]+\]',\[%R(s02 . . . S0n)\]'=lj~i(i-A(~il . . . ),is02 . . . ~im(~js02(vJ\[iI\] . . . \[js02\]"'\[im\]^\[%R(s03 . . . S0n)\]'\[Js02\]\[is02\])))) , \[%R(S0n)\]'=ljNi(i " A (% il . . . Xis0 . . . ~im(~-js0n(vj\[il\] . . . \[Js0n\] . . . \[ im\]AiS0n " A (% ii . . . 
)~iSll . . . l is 2I . . . % im(3jS l1(VjSOn\[il\] . . . 
\[Js11\]""\[is21\]'"\[im\]^(\[$R(s22 . . . S2q)\]'\[is2I\]?\[*R(Sl2 . . . Slk)\]'\[js\]\[is\],?1 . 1 11
Z s11"JS ll )))),\[$ R(s22 . . . S2q)\]'=li(~il . . . ~is22 . . . ~im ( Vi\[i I\]""\['Zs22\]"'\[im\]^\[$R ( s23"'S2q ) \]'\[is22\] ) )' \[ SR ( s2q ) \]' = ~ i ( ~ il . . . \] i2q . . . ~im(Vi\[il\] . . . 
\[ is 2\] . . . \[ im\]^VA'\[is\])), ?2 q\[*R(Sl2 . . . Slk)\]'=xjTki ~ i'A ( ), il . . . ~ zSl2 . . . Aim(~Jsl2(vj\[il\] . . . \[ jSl2\] . . . \[ im\]^\]\[?)))) , \[* R ( s 13 " " Slk ) \]'\[ Jsl2zSl2\]\[*R ( Slk ) \]' = AjNi ( i " ( ^ki I . . . ~ iSlk . . , % im ( ~ jSlk ( Vj\[il\]'"\[Jslk\]'''\[im\]^iSlk=f' ( 3 Slk ' ) ) ) ) ) " For individual insertion or deletion their translations are as follows  . 
\[<R,t>\]'=\[R:=\[lil . . . lim(il = tlA . . . Aim = tm -+
T,R'\[il\] . . . \[ im\])\]+\]',\[~<R,t>\]'=\[R :=\[ X i l . . . ~im(il = tI ^ . . . ^ im = tm -+
F,R'\[il\] . . . \[ im\])\]+\]'? where we assumed t = < tI,t2, . . .  , . t ~ > . . If n=0 ,   k=0 or q=0 then appropriate modlfl cat lons are needed as in the case of query statements  . 
For insertion operation < d , t > and deletion operations ~< d , t >; ~< R , S , A > , we can define their corresponding IL expressions in the same manner as shown in the case of set oriented update  . 
By using an intensional version of Floyd's semantics of assignment  12 \[ A := B\]'=IP^~z\[z/VA'VpAVA'-z/VA'\]B'\] , and semantics of composition \[ A ; B\]'=%P\[B'(A'(P ))\] , we complete the definition of the semantics of the update statements  , 
Now , we consider the following simple example for comprehension of the above definition  . 
Example 4
Suppose relation EMP2 is declared at data definition part as EMP2=\[ KIDS:\[NAME : string , AGE : in , I , SAL : int\] , and that before the update ,  <*2 , <EMP2 , SAL , KIDS . NAME , Jack >> holds that A(\[<EMP2, SAL , KIDS . NAME?Jack>\]'-AXx(x-20')) . 
We denote this precondition by PC . The translation of the update statement is \[<*2 , < EMP2 , SAL , KIDS . NAME , Jack >>\]'=\[ EMP2:=\[XiKX is ( ~js ( VEMP2' ( iK ) (Js ) 
A(~iN~iA(ViK(iN)(iA)^iA'Jack')is-Js*2 , is = Js ) ) ) \]+\]'=% pA~z ( z/vEMP2'vpAvEMP2'-z/vEMP2' ( % iK ~ is ( ~js ( VE~2' ( iK ) (Js ) 
A(~iN~iA(ViK(iN)(iA)AiA'Jack')is-Js*2 , is = is ))))) . 
PC=A ( A~is ( ~iK ( VEMP2' ( iK ) (is ) A ~ iN ~ iA ( ViK ( iN ) (iA ) AiN ' Jack ' ) ) ) -^~ x ( x-20' ) ) . 
Then after the update,
A~z ( A~is ( ~iK ( z ( iK ) (is ) A~iN~iA ( ViK ( iN ) (iA ) ^ iN-Jack ' ) ) ) -A%x ( x-20' ) ) ^ VEMP2'' ( %iK~is ( ~Js ( Z ( iK ) (Js )  ^ ( ~ iN ~ iA ( ViK ( iN ) (iA ) AiA ' Jack ' ) ? is-Js * 2 , is ' Js ))))) ?
From this we derive that , ^% is (~ iK(VEMP2'(iK)(is)A~iN~iA(ViK(iN)(iA)

Example 5
As another example , we consider the relation as follows . 
EMP3=\[NAME:string,MGR:string\].
For this relation we perform an update such as the manager of manager of John is Smith  , i . e . 

The translation of this update statement is\[<= Smith  , < EMP3 , MGR , NAME , < EMP3 , MGR , NAME , John >>>\]'--225 =\[ EMP3:=\[~iN%iM ( ~ jM ( VEMP3 , ( iN)(jM )
A(V\[<EMP3 , MGR , NAME , John>\]'(iN)+JM-Smith , , JMmiM ) ) ) \]+\]'=\[EMP3:=\[%iNAiM ( ~JM ( vEMP 3' ( iN )   ( jM ) 
A ( VA~iM2 ( ~iN2 ( VEMP3' ( iN2 ) (iM2 ) ^ iN2-John ' ) )  ( iN ) -+ JM-Smith , , JM-iM ) ) ) \]+\]'=~P^~z ( z/VEMP3'VpAVEMP3'- ( ~iN%iM ( ~ OM ( z ( iN )   ( jM )  ^  ( ~ iN2 ( z ( iN2 )   ( iN ) ^ iN2-John ' ) -+ JM-Smith ' , JM'iN )))) . 
Assume that before the update holds that ^ ( (\[< EMP3 , MGR , NAME , John > \]'-^ Xx(x-John '))
A(\[<EMP3, MGR , NAME , Smith >\]'-

Then we obtain that afterwards ^ ~ z ( z ( John ' )   ( John ' ) ^z ( Smith ' )   ( Jack ' ) ^ VEMP 3 " ( % iN % iM ( ~ jM ( z ( iN )   ( jM ) 
A(~iN2(z(iN2)(iN)AiN2mJohn')?JM-Smith' , JM-iM ))))) . 
This implies
VEMP 3' ( John ' )   ( Smith ' ) ^ VEMP 3' ( Smith ' )   ( Jack ' )  . 
9. SEMANTICS OF NULL VALUES
We can define various kinds of null values , indeed ANSI/SPARC interim report 13 cites 14 possible manifestations of null . However , the two important kinds of null value have the meanings ' value at present unknown ' and ' property inapplicable '  . 
Formal treatment of the first kind of null value has been resolved by the ideas of null substitu tion principle and non-truth functionality principie  .   4'14 In this article we study the second kind of null value more precisely  . We introduced two null values NULL 1 , NULL2 of the second kind of null values .   NULL1 is intended to mean that nothing exists at current state but there may be some states in which the value exists  .   NULL2 is intended to mean that there exists absolutely no value in any state  . 
Those semantics are formally defined by auxiliary update postulates  . 
( i ) Update postulate for NULL 1
For everytl El and every A ~ Tm < s , a > ( a = < al , < . . . < an , t > > . . . > eD type ), if Vs , g(A)(tl ) ( fal) . . . ( fak ) . . . (fan ) = l and fak=NULL 1 , then V s'g ( A ) (tl ) (fal ) ''' ( hak ) ''' ( fan ) = 0 hakE MaCNULL1\] for all and there exists t2?I such that Vs , g(A ) ( t2) ( fal) . . . ( rak ) .   .   . (fan ) = l forrake Ma~NULLI,NULL2 . 
!2) Update postulate for NULL 2
For every t1?I and everyA~Tm<s,a>(a=<al , < . . . < an , t > > . . . > ED type ), if Vs , g(A)(tl ) ( fal) . . . (fak) . . . (fan ) = l and fak=NULL 2 , then for every t 2 eI and every hcM- NULL2 akakVs , g(A ) ( t2) ( fal) . . . ( hak ) . . . ( fan ) = 0 ? i0 . SEMANTICS OF STATEREFERENCE To define the semantics of queries with ' when ' or ' whenever '  , it is necessary to consider the case that s is a type  . We define such a logic called Two-Sorted Type Theory  , and denote it by Ty2 . 
Def . The set T ' of types of Ty 2 is the smallest set such that ( i ) e , t , sET ' , (2) a , be T ' => < a , b > ET ' . 
Note that TcT'(T : the set of types of IL).
Def ____ ~ The sets Tm ~ of terms of Ty 2 of type a are defined with the following rules recursively  . 
(I ) CONscTm ~ , (2) VAR acTm ~ , (3) A , BET m ~=> A+B , A B , A ' B , A ? B e T m ~ , T ''=> A\[B\]Emb , (4) AETm Sa , b > , BeTma (5) AET m ~=>% X aA ? ' T m < a , b > , (6) A , B ~ Tm ~=>( AB ) ? Tm ~ , (7) A , BeTmta , PET m ~=>( P?A , B ) ~ Tm  ~ , (8) Ae Tm ~ , cECON < s , b > , xeVARs , BET m ~=> B/c\[x\]A ~ Tm ~ , (9) A ~ Tm ~=> PA eTm ~ , FAeTm ~ . 
To define the semantics of Ty2 the model M ' = ( Ma ,  <  , m ) ae T , is introduced , where Ma is a frame based on nonempty sets D , I , and < is a linear ordering on I . 
We define the frame as the indexed family ( Ma ) aET , of sets , where

(I)Me=DUNULL 1 , NULL2 , (2) Mt = 2 = 0 ,  1 , (3) Ms = I , (4) M < a , b >= MbMa=FIF:Ma->Mb(fora~s) , (5) M < s , a >= MaI=FIF:I->Ms UNULLi , NULL2 . 
For each constant Cs , m(Ca ) EMa , and for each variable x a , g(Xa)cMa . Interpretation of term Aa which is denoted VM , g ( A a ) is defined in such a way that the following conditions hold  . 
( We dropped the subscript'M' . )( i)V g(x a ) = g(Xa) , xaE"VARa , (2) Vg(Ca ) = m(Ca) , ca~CONa , (3) ~ (7) similar to the case of IL , (8) Vg ( Bb/C < s , b >\[ Xs\]Aa ) = Vg ' ( Aa) ,   , where g ' = g(xs/X ) , xs ~ VARs , XcI , such that for all constant C~s , b > except c , 
Vg(ci\[Xs\])=V g , ( Ci\[Xs\]) and Vg , ( C\[Xs\])=Vg(B ) ,   ( 9 ) V g ( PAt ) =  1 if there is some g '= g ( xs/X ) such that g ' ( xs ) < g ( xs ) and Vg , ( A ) = i , 0 otherwise ,   ( i0 ) V g ( FAt ) = I if there is some g '= g ( ~ s/X ) such that g ( xs ) < g ' ( xs ) and Vg , ( A ) = I , 0 otherwise . 
For each term A a of IL we can define the translation of Aain Ty  2  . Such translation is defined with next rules , and denoted A: . 

( i)\[Xa\]*=xa , (2)\[Ca\]*=C < s , a >\[ Xs\] , (3)\[A < a , b >\[ Bb\]\]*=A*\[B*\] , (4)\[hXaAb\]*=kxA * , (5)\[Aa-Ba\]*=\[A*-B*\] , (6)\[^Aa \]*= ~ XsA* , (7) \[ VA < s , a >\]* = A*\[xs\] . 
Now we can define the semantics of query'q when f ' as a term of T y  2  . 
\[ q when f \]' = ~ x ~ x ( ~x~ ( \[\[f\]'\]*\[x~\]A\[\[q\]'\]*\[x~\]\[x\] ) )  , which means intuitively the set of objects which satisfy q in each states where f has a value I  . Similarly we define the following . 
\[ q whenever f \]' = X x~x ( Vx~ ( \[\[f\]'\]*\[x~\]A\[\[q\]'\]*\[x~\]\[x\] ) ) , Ef2 when fl\]':Xx~Xx ( ~x~ ( EEfl\]'\]*\[x~\]^\[\[f2\]'\]*\[x~\] ) ) , \[f2 whenever fl \]' = ~ X ~% X ( VX~ ( \[\[fl\]'\]*\[x~\]A\[\[f2\]'\]*\[x~\] ) ) . 
Ii . CONCLUDING REMARKS
We believe we have demonstrated feasibility of the Montague's approach to the semantics of hierarchical database systems with historical data  . 
As for future reasearch directions , we would like to point out the importance of ( i ) finding normal forms which allows efficient evaluation of terms  , and ( ii ) finding a set of axioms for equivalence transformations which derive normal forms from given terms  . 

Our thanks are due to Mr . Kenichi Murata for fruitful discussions and encouragement and to Prof  . Takuya Katayama and many other people whose ideas we have unwittingly absorbed over the years  . 
REFERENCESi . Gallaire , H . , Minker , J . , (1978) ' Logic and
Databases ', Plenum Press.
2 . Reiter , R . ,  ( 1977 ) ' An Approach to Deductive Question-Answering ' , BBN Report No . 3649,
Bolt , Beranek and Newman , Inc.
3 . Wong , H . K . T . , and Mylopoulos , J . ,  ( 1977 ) ' Two Views of Data Semantics : A survey of Data Models in Artificial Intelligence and Database Management '  , INFOR ,  15 ,  3 ,  344-383 . 
4 . Lipski , W . , Jr . ,  ( 1977 ) ' On Semantic Issues Connected with Incomplete Databases '  , 3rd

5 . Montague , R . ,  ( 1973 ) ' The Proper Treatment of Quantification in Ordinary English ' Approaches to Natural Language  , Reidel

6 . Montague , R . , (1977) ' Universal grammar ' , Formal philosophy-selected paper of R . 
Montague , edited by R ~. Tomason , Yale Univ.

7 . Codd , E . F . ,  ( 1974 ) ' Recent investigations in relational database systems '  , Information Processing 74 , North-Holl and Pub . Co . ,
Amsterdam , 1017-1021.
8 . Gallin , D . ,  ( 1975 ) ' Intensional and Higher-order Modal logic ' , North-Holland Publishing
Company , Amsterdam.
9 . Curry , H . B . , and Feys , R . , (1968) ' Combinatory Logic ', Vol . l , North-Holland,

i0 . Yanssen , T . M . V . ,  ( 1977 ) ' The expressive power of intensional logic in the semantics of programming language '  , Lecture Notes in Comp . Sci .  53 . Springer-Verlag , Berlin . 
II . Henkin , L . , (1963)' A theory of propositonal types ', Fund . Math . , 52 . 
12 . Floyd , R . W . , (1967) ' Assingning meanings to programs ' , Proc . Amer . Math . Soc . Symposia in Applied Mathematics , Vol .  19 . 
13 .   ANSI/X3/SPARC Study Group on Data Base Management Systems , (1975) ' Interim Report ' , 

14 . Yannis Vassiliou ,   ( 1979 ) ' Null Values in Data Base Management : A Denotat ional Semantics Approach '  , Internal Conference on Management of Data , ACM-SIGMOD ,  162-169 . 

