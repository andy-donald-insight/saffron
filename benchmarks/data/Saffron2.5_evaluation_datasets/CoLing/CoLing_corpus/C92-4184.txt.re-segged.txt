JAUNT : A Constraint Solver
for Disjunctive Feature Structures
Hiroshi Maruyama
IBM Research , Tokyo Research Laboratory
maruyama@trl.vnet.ibm.conl
Abstract
To represent a conlbl natorial nuln bernfambigu ous interpretatio as of a naturala ' nguage sentence f-ficiently  , a " packed " or " factorized " represeutath ) n is necessary . We propose a represent a titm hat comprises a set of explicit value disjunct ltms and constraints hn -posed on them  . New constraints are successively added for disambiguation  , dn rhtg which local consistencies are maintained by an underlying mechanism  . We have developed a constraint solver called JAUNT that embodies this idea  . The latest techniques , including constraint propagation and for wa , vl checking , are employed ms constraint satisfaction mechauisms  . JAUNT also allows an external recta-inference program tn intervene in the constraint satisfaction process in order to control the application of the constraints  . 
1. Introduction
Certain natural language constructs , such as PP : attachnmnt in English , are known to have a combinatorial number of syntactic parses  ( Church & Patil 1988 )  . 
For example , sentence ( 1 ) has 14 ( = Catalan ( 4 ) ) dif = ferent parses because of the three consecutiw ~ PPs : Put the block on tmfloor on the table in the room  .   ( 1 ) Representing the set of parses in a compact way and extracting a correct parse by using such knowledge as A block cannot be on athm rand on a table at the same time are keys to a practical natural anguage system  . 
The parsing method of Constraint Dependency Grammar  ( Maruyama 1990 ) axldressed exactly these issues . The essential ideas were ? to represent the set of parses by a constraint network  , which is emnposed of a set of explicit , vahm disjunctions and constraints imposed on them  , ? to apply constraint propagation i order to kee I  ) the constraint network locally consistent , and ? to dynamically add new constraints for disambiguation  . 
In this paper , we describe a programming tool named JAUNT that embodies the above ideas  . 
JAUNT is a constraint solver for disjmmtive feature structure % whose constraint satisfaction mechanisms are constraint propagation and for war ~ l checking  . In the next secthm , we show \] to w various ambiguities are represented in our explicit vahm disjunction + constraint scheme  . The constraint satisfaction algorithnls
S : ~\[ id = O , cat=v , head=put , gr=root , mod = nilJ , \[ id = i , cat=np , hoad=block , gr=obj , mod ~ O\] , \[ id = 2 , cat=pp , prep=on , head = floor , gr = ~ loc , postmod~ , mod=~O , l ~\] , \[ id = S , cat=pp , prep=on , head = table , gr = ~ io c , postmod~ , mod=~O , l , 2~ \] , \[ id = 4 , cat=pp , prep=in , head = room , gr = ~ loc , postmodZ , mod=~O , l , 2 , 3 ~ J ; Figure 1: JAUNT representation fsentence ( l ) adapted in JAUNT are explained in Section 3 . Section 4 describes the rise/ ) fJAUNT's recta-inference apa-bility . Section 5 concludes the paper . 
2 . Explicit disjunction + constraints Let use mml der sentence  ( 1 )  . In order to simplify the following dlscussimt , we iL~st lnle that the sentence is prepmcessedms in Figure  1  . This preprocessing can be done\[Wa simple contextfree grammar that does not determ hm PP -attachments  . In the figur %\ [ .   .   . \] is a featn restructure, .   .   . is alls t , and ~ . . . Y , is a disjunction . " Phus ~ the variable S represents the ( packed ) structure of sentence ( 1 ) as a list of five e om-\[mmnts 1 each of whldl corresl ) onds to a V : an NP , or a PP . The grammatical relation ( gr = ) and the modi-flee ( meal = ) of the three PPs are disjunctions , meaning that one of the w duess hou hl be selected , but that the correct candidate has not yet beat determined  . For example , the first PP " on the floor " has ~0 , 1~ ,   . ' ~ sits and = vahm , which means it can modify either phrase 0 ( the verb " put " ) or phrase 1 ( the NP " the block " )  . 
Not all the value combhtations of the disjunctions are allowed  . In the above example , if a PP modifies the main verb , the grammatical relation should be loc . 
In JAUNT , constraints are introduced by add c state-meats . The program fragment ( 2 ) applies constraints between the moditle e and the grammatical relation of app  . 
for W in S begin add cW . cat == p p&S . (W?mod) . cat in pp , np = >
W?gr == postmod ; add cW . cat == p p~S . ( W?mod ) . cat == v = >
W?gr == loc ; end ;   ( 2 ) \[\] ere ~ dots and question marks are operators forme : cessing components of bsts or feltture structures t  .  '\] . ' he ? The difference between a ( lot and a question mark is that a Ac ~ . s DECOLING-92 , NAI VI~S , 2328 Ao(rr 19921162 P Rec . OFCOLING-92, NANIES , AUG .  2328 , 1992 symbols t ~( logical and ) an , I => ( iml , ly ) h~ve their ordinary logical meanings . In geuernl ,   ; tny first-order logical formula without qnantifieation is allowed as actmstraint  . ' Fhe variable W is bonndtoea ~ zh V~NP ~ and PP while the add c state lnen  , slm tweee begin and end are executed . Timlir stadd c statement reaxls ~ sft ) ll ( , ws : If tile category of W is PP aud the category of the modifiee of W is either PP or NP  , then the grammatict d relation of W should be postmod  . 
The applied constraints are represented implicitly by an internal data structure called a conslt vdnt oeln  , o'rk(describedt ; tter) . 
in axlrlitit lu ~ tamp , ' ojeclivity constrzdut , that modifi ~ cation liuks dount cross over , can be progran mmd~sh ) llows : for Y , X in S begin add c(Y . id < Lid ~ X ? mod < Y . Jd ) => l?mod <= Y ? mod ; end ;   ( 3 ) We have now obtained a packed representation that consists of explicit disjunctions  , as in Figure 1 , and constraints attached behind them . Each value conl--bination of the disjunctions that globally sat  , is fiest im constraints exactly corresponds to one of the  14 parses of sentence ( 1 )  . 
Every contextfree parsing , ~ lg or it . hnltimth a . sa polynomial time bound prodnees a pu~cketl representation of the parsing results  ( for example , ? chart ill chart parsing ( Kaplan 1973) , apa , 'si . gmat , ' ix in the CKY nmthod ( Yonnger 1967) , and a . sha , ~ d-packed-forest in qbmita's algoritlun ( Tomita 1987 ) ) . These representations take advantage of tile regularities of syntactic ambiguities in contextfree pars log  . For example , sillce it is known that 1~ consecutive P\]'si lave Cutalan ( n ) different p ~ zrses , it is possible to encode all PP-attachment ambiguities by renlemberiug only n and the position of tile PPs  ( Church ~ Patil 1982 )  . 
However , once we try to extract ~ single illterpretation item these representations  , we face a prubhml , because such regularities may be vn id when new cun  . -straints ~ reintroduced for disnmbiguati , nl . Consider the application of constraint ( 4 ) : Averll cannot have two h ) eatives .   ( 4 ) Tiffs constraint viohttes the regularity of the PI'att  ; miunent ambiguity and tl , ereh ) r , ~ , the Cb'G be-led packed representations lentioned ailove cannot hall--tile this new int ~ rmation properly without modifyiug the grammar significantly  . IllJAUNT~this constraint is ~ pplied by a simple add c statement  ( 5 )  . 
for X , ? in Sbegin addenot(X ? mod == Y ? mod ~ S . ( X ? mod ) . cat == ~&
X ? gr == i ? c&Y ? gr == l?c) ; (5) end ; lebrrnaliy ~ itha . sbeea proven that Constraint De-peudency Grammars : whose rules Ca~b  ( ! written a ~ sq . estionmr trk allows ~ disjunction as its value , w\]m re~a(lot does not . The cllretlt in lllelllentatiOll generates more efl clent code for dots than for question m~rks  . 
S :=\[ id = O , cat = v , head = put , gr = root , and = nil\] , lid = i , cat = rip , head=block , gr = obj , mod = O\] , lid=2 , cat = pp , prep = on , head=fleer , gr = % loc , postmod~ , ,mod=%0 , I %)\] , \[ id = 3 , cat = pp , prop = on , head = table , gr = % in c , postmod~ , mod=%0 , 2~ \]  , lid = 4 , cat = pp , prep =  in , huad=room , gr = ~ Ioc , postmod % , mod = % 0 , I ,  2 , 3 ~\]; Figure 2: JAUNT rel , resent ~ tionf sentence ( 1 ) restricted f ( irms of JAUNT program : have ~ weak generativr power strictly greater than that of CI"G  ( Maruy ~ ma 1991 )  , This implies that certain types of pa~rsing results can be represenu  . .d by constraint networks but not by CFG based represmt tatioos  . 
Sen and Simmons ( 1988 ) proposed syntactic 9~phs and discussed the axl vantagos of having explicit , disjunctions in a packed data structure . Their represeutation is similar to ours in tile seuseth  ; tt they have con~trahlts attached to the explicit disjnnctive data structure  . However , they d . uotdise us a how to ~ r p . 
ply disam\[liguation kowledge in order tn reduce the ambiguity effectiw qy  , luJAUNT , the underlying constraints aris\[action algorithm removes im : on sistmdlval-IteS ~ cnd keepstim constrai/ituet work locally consistent  . 
Consider , lot example ~ the application of the new con straint  ( 6 ) : An object : an not In ! on two distinct objects a , t the same t in , e .   ( 6 ) This constraint is written a ~ s follows : for X , Y in S begin add cX . prap ~= on ~ Y . prep == on & X ? mod in pp , np = > X ? mod != Y ? mod ; 17) end ; After this coustraint \[ ta . sbeet , evahl~ted ~ tile and attribute of the t'P " on the t~ble " becomes  ~0  , 2Z , n ~ strewnit , Figure 2 , because the vMue1 is locally in consisteut ; m cn rt ling to the coost raints applied su far , and central , pneti(il , ateillany of the remaining seveure ; tdings . 
There , ave been several ~ Lttenlpts to incorporated is junctions in uniii catinu-ba  . sed grammars re . g . Karltuoen 1984) . Constr . ' tints ; ere introduced by ~ tunification between two disjuuctiw  . ' feature structures . Annificatio , succeeds only if there are combinations ( ffw ducs of the disjunctions that s~t is fytile equality constraints implied by the u  , lificatio . . It , order to clarify the exl , ressiw ~ power offe ~ ture structures with general disjunctions  , Kasper ~ Rounds ( 1986 ) defined a logic-be-led notation called FM1 , A for nlula in FMI , can be rewritteu as an add c statement in JAUNT , and hence , constraints expre~ed hyaunification can also be expr~ssed in JAUNT  . In ~ dition , in unification-based grammars , then nly basic predicate is equality , aud other useful predicates , suchemine qualities and set inclusion /membership  , are diflicuh to represent . In ~ If these cottd PP " ontile table " modifies the NP " the block  , " the first PP " ontimriot , r " ha . sno legal modifiee ~ . 
ACRESDE COLING-92 , Nam'l~s , 2328 AOUX'19921163 I'koc . OVCOLING-92 , NANTES , AU(L2328 , 1992 JAUNT , inequalities and set operations are built in , and user-defined predicates are also allowed . 
3 . Constraint-satisfaction algorithm Since every disjunction in a JAUNT program has a finite number of choices  , its satisfiability problem can be formulated as a constraint satisfaction problem over a finite do nlain  ( sometimes called a consi . ~tenl-ht beling problem ( Men\[snarl 1974)) . Much effort has been devoted to developing efficient algorithms for this proble a  . 
Two such algorithms are employed in JAUNT . Ore , is the constrainl propagation algorithm ( Mackworth 1977 )  , which is activated when a new constraint is added by add c statements  . The constraint propagation algorithm runs in polynomial time  , and eliminates locally inconsistent vMues from the choice points and propagates the results to the neighboring constraints  . 
The constraint propagation algorithm usually reduces the size of the search space significantly  . 
The other algorithm used in JAUNT is the forward -checking Mgorithm  ( Haralick & Elliott 1980 )  , which is triggered by the execution of a special find stat~meat  . It is essentially a backtracking algorithm , but it prunes unpromising branches whenever temporal choices are made  , thus significantly reducing the size of the remaining search space  . 
This section describes in detail the constraint propagation Mgorithm used in JAUNT  . Re ' 0 ders are referred to Hentenry ck ( 1989 ) for the forward-checking algo-rlthm . 
3 . 1 Internal representation of constraints Bob ) redescribing the Mgorithm in detail , let us explain the internal representation of the constraints  , hiacompiled\[nodule of a JAUNT program , a disjunction is represented by a data structure called a Choice Point  ( CP )  . ACP maintains a list of pt Jssible values ( called a domain ) at the time of program execution . 
When a new constraint is added by a add c statement  , the constraint is represented internally msa conslrrint ms\[l is a For example ~ assume that W is bound to \ [ gr = ~ loc  , posttaod ~ , mod--Y , 0 , lY , \] . 
W?gr and W?mod are represented internMlya . ~ CPs whose domain size is two . Then , when the constraints (2) are evaluated , a new two-dlmensional constraint matrix is created between the two CPs  , as shown in
Figure 3.
Each dimension of the constraint matrix corresponds to a CP  . The elements indicate whether the particn-lar combination of the CP v Mues is legal  ( 1 ) or illegal ( 0 )  . For example , W?gr = loc and W?mod=O satisfies the constraint and hence the corresponding element in the matrix is  1  . 
If another adds statement is then executed declaring that ttm value combination of W?gr = pontraod and W?mod=lisillegal  , the corresponding element in the matrix is changed to  0  , yielding the matrix shown in
Figure 4.
W?g(W?r nod
Figure 3: Constraint matrix
W ? ~ lrW ? rnod\[~IoCpOS
Figure 4: Updated constraint matrix
Suppose that the executiol lo fart addestatement referring to  7t different CPs XhX2  ,  . . . , Xn reveals that the value combhtation < xl , x ~, . . . : x , ~> is illegal . JAUNT first locates an n dimensional constraint matrix connected to  X1  , X2 ,  . . . ,X = , and set its element corresponding to the value combination < xi  , x2 ,   . . . , x , ~> to 0 . If there is no such constraint matrix , JAUNT creates a new one whose elements are all 1 except for the element of < xl , x~ ,  . . . ~ x ,,> that is set to 0 . 
8.2 Constraint propagation
The ba . sie idea of constraint propagation is to remow ~' locally inconsistent values from the  , choice points and to reduce their domain size before a backtracking search is performed  . 
\ [ n the example ~ d ) ove , let us consider the row afW?gr = postraod in the constrah\[t matrix  . When i ~? gr = postmod ~ the elements of the matrix are zero  , whatew ~ r value W?mod Lakes . This means that there are noglnbal solutions with W ? gr = postmod  , and therefore this value can be safely removed fronltim domain of the CPW ? gr  . Similarly , Id?rnod=lca . n be removed from the domain of the CPW?raod . 
In general , when a particular row or column ( or plane or hyperplaue , if the dimension is greater th ~ n two ) contains all zero elements , the corresponding vM nezl of CPX can never participate in ~ solutimt  ( see Figure 5 )  . Therefore , a'i can be eliminated frmn the domait t of X . Whenever a constraint matrix is updated ~ JAUNT searches for a  . hyperplane whose ele ~ ale/Its are all zero aud relnoves the corresponding v~thle from its domain  . This may updrrte other constraint matrices conllected to lheC  . P ~ and may causerabies in other CPs to be elhninated  . Thus , updates are propagate dow ~ r the network of constraints until the entire network reaches a stable state  . 
For every hyperplane in a constraint matrix , JAUNT ACT US DE COLING-92 . NAbrrES , 2328 AO(Yr 19921 l64 PROC . OFCOLING-92, NANIES , AUG .  2328, 1992
X\Y ...
xi0(I0...0
Figure 5: Locally in nonsistent value a : is uppo . \[~3\[\]
Numtmr of I ' sill the plal ~\[ ~ 3/~ ~ suppo ~\ [ Xl\[l
Figurt + 6: Support keeps the current number of t's on that plane  , called the support ( see Figure 6) . When a certain element of a constraint matrix a pl ) ears to be inconsistent a , s a result of the evaluation of add c statement , he curresponding support in each dimensiun is decremented  . 
When a value in a CP is removed by constraint prop station  , the car respondlng hyperplaue of every constraint matrix connected to the  ( 11' is removed , attd the result is reflected i ~ ( all tt ~ e support values in the matrix . This algorithm is a uatnral extension of Mohr and Henderson's arc-c  ( ms is tency algorithm ( Mohr & Henderson 1986 ) for allowing n : ary constraints . 
The cmn put athmal complexity of our constralut propagation algorithm is hounded by O  ( eIMD , where IMI is the siz , ~ of the constraint matrices and e is the number of the cunstraint matrices  , be catts eat lems toue element inst ) me matrix is changed to 0 from I for every iteration of constraint propagatiom If the constr ~ ints are Iocal ~ that is  , if the arity of each ennstraint is bounded by a small integer  , this time bound is a polynomial of the number of disjunctions  . 
Our algorlthnrtries to maintain h , cal consistency ix ( the sense that it runs ( tiers only one e on str + dnt matrix at . + t time . This is a generalization of the notion called am consistency  ( Mackworth 1977 ) or pairwise cousisteucy , and is equlva \] enttn the flrst two steps of Ka . sper's ( 1987 ) successive apt nvximatim L Algorithms for achieving more global consistency by look : in s at mnltlple constraint matrices are possibh +  , but as Carter ( 1990 ) argues in his paper on the experimen . 
tal Propane parser , once pairwise consistencies have been achieved , peffurnling a backtrack search is usually more efficient than using higher-level consistency algorithms  . In JAUNT , a forward : checking algorithm , which is far better than the traditional backtracking algorithms  ( Haraliek & Elliot 1980 )  , is provided for generating global solutions , if necessary , althoughth\[~intended use of JAUNT is to combine constraint propagation with the recta -inferenced scribed in the uexl section ~ rather than t  ( ) perfornl a search . 
Therehay , ' t ~ en attl ! nlpts to formulate naturalan-guage pro  , : essing as a cunstraiut satisfaction prob-lenl with broader don~ains  ( fl ~ r example , the Herbraud domain ) . CIL ( Mukai 1988) and cu = Pmh)g(Tsuda , ltasida & Sirai1( . 189) are examples of such atteuipts . 
There is a tradeoff between the expressive power and the CO mlmtatiunal complexity  , aml we argue that linited onlaius have sutticient expressive power while retain : ing the couqmtational eflicieucy implied by the algu + rithms described above  . 
4. Meta:inference
Acunsi M , (~nt - \ ] at ) elli Lgpr (   ) bl ( ! nlu Layorn lay not have a solution . If it ha_s role , it is most probable that there are multiple solutions  . In fax : l , it + the glven constraints are lint ' tight ' enought unarrow down the uumber ufso hltitl liSto  ( Hit ? or a few ! the prohhml Ill ~ l , y have an eXponential number of solntions . This situatlon is common hL naturalanguage processing  . Strict grammars can seanalysis failures for grammatical sentelt  ; ( ~ s ~ i ) n the other hand , lnose graulmars pruduce a combinatorially explosive number oF parse trees fin ' certain types of sentence  . ' l bavoid this situation , cnnstrahits shou hlbe dynamically added audremuw ~d according to the size of the stdul  . iut ( space + hiuther words , a constraint solvers hun hltm provided with a means of watching its own in fl~rence process and changing its strategy a c = cord  ( us to tim observati < m . 
To set > purl the metaAnference apability ~ JAUNT provides the following builtin functions :  1  . incousistent p() . . . Non-NULl , wile nJAUNT detects in cD ltslstencies bf ~ tweell coltstraints  2  . save S(ate () . . . Save the current status of constraints at ( slant ( usg . loadState () . . . lLestore the saved status of con- . 
straint satisfactiuu.
luJAUN'I'~ti restate of the constraint : satisfaction process is deJined ms the set of all choice points and all cosstraint nlatrices  . Oth , ~rstatuses bUlC\]ImS global audlocal variables , the progral n couuter + ; utd the coutrol stack are lint saved Isn applications  ( If cml straints nanbeu an beuadone without distilrbing the c < ut trull  . w . 
Metain h ~ renc , ~ is nonletlntes per h~rmed in an exterhal nlodule  . JAUNT has interqm ) cesscrassus ( ca-tion primitiw ~ shmm~donUNIX so < : kets . With these met ; u inference a palfilities , an independent inference process timing ext . ernalk nuwh~dgecantilt ) ill ( or and iIi-tervenelna JAUNT progra . nt . If it detects an inconsistency , it instructs the JAUNTi > rogram to gob . ' u : k tu the previous inferenc\[~state and try another set of constraints  ; if it finds thai the solution spa ~: e is not small enough+it may giw ~ new constraints from its own knowledge source  . By separating the rneta-inference module from tile object-level JAUNT program  , modularity \[) f knowledge is ; whieved . 
As an application <> f the meta:inference apability  , let us describe the interactive Japanesp parser of the Japanese t < F English m  ; u : hine translation system JETS ( Maruyama , Watanabe , & Oginn 1990) . The systmn structure is shown in Figure 7 . Timmor phological A(:rl~sBECOL1NG+92 , NANTES , 2328^O ( JT 1992116 SPron . oi:COLING-92, Nm,n'zs,AUG .  2328, 1992
Fignre 7: Analysis p~rt of JETS\[~ord_id=O , string = " ANATh " , modifiee ffi~1 , 2 , 3 , 4~ , lex = ~ , \[ part_of_speech = pronoun , sf = hum\] , \[ part_of_speech = noun , sf = loc\]%) , 
Figure 8: Input feature structure analyzer analyzes an input sentence using a  type3 grarl'lln&r and creates a feature structure that COll-talus disjunctions for lexieal and attachment ambiguities  ( Figure 8 )  . The syntactic analysis program written in JAUNT applies grammatical constraints based on Constraint Dependency Grammar to these choice points and sends the result to a user-interlace running on a separate machine  . The amblguons choice points ( those with domain size > 1 ) are highlighted on the screen , and the end user can select an appropriate value for some of them  . This information is sent back to the JAUNT program through the interprocess communication channel and applied in the form of new constraints  . This iteration is written in JAUNT as fed-lows;
U if := op on ( Client ~ ame , " socket "); while true begins end(U/f , S );
X := read(U if ) ; if X == goA head then break ; save Stato () ; add cS . ( X . id)?mod==X . mod ; if/n consistent p () then begins end(U if , " inconsistency detected ") ; loadState O ; end ; end ; Thus , h*JETS , the endnser acts as an external know\[edge source to guide the inference process of the program  . 
SHALT2 , an experimental English-to-Japanese machine translation system currently being developed at IBM's Tokyo Research Laboratory  , has a similar system structure ( Nagao 1990) . Instead of user interaction , an external example ba . ~ebuilt from an existing corpus is used for resolving attachment amblgui-ties in  SHAUF2  . Thus , clear modularization of general syntactic/semantic knowledge from domain-dependent example-based knowledge is achieved  . 
5. Conclusion
We have described a constraint solver for efficiently processing ambi ~ nlties in natural anguage sentences  . 
Disambignation is dntm by dynamically adding new constraints while the constraint satisfaction algorithm mainteoius local consistency  . The system is actually bnl demented and used in two  macl6ue translatiun systems . 
References 1 . Carter , I . , 1990 . " Efficient Disjunctive Unification for
Bottom-Up Parsing , " COLING'90.
2 . Church , K . and Patti , R . , 1982 " Coping with Syntactic Ambiguity , orllow to Put the Blockm the Box on the Table . " Arne*-tc and . of Compulattonal Linguistics 8 . 
3 . llaralick , M . and Elliott , G .  1, . , 1980 , " lnerea ~ sing Tree Search Efficiency for Constraint Sittisfaction Problems  , " Arhficial Intelligence 1 ~ . 
4 . llentenry ck ~ P . V . , 1989, Constraint Satisfaction In
Logic Programming , MIT Press.
5 . Karttunen , L . , 1984, " Fca Utres and Values ~" COL1NG'8q . 
6 . Ka . sper , R . T . , 1987, " A Unification Method for Dis . In active Feature Iescriptions , "25 lh ACL Annual

7 . Kasper , ILT . , and Rounds , W . C . , 1986 , " A Logical Semantics for Feature Structures , "2 Jth ACL Annual

8 . Mackworth ~ A . K . , 1977, " Consistencym Networks of ll . elation , " Artificial lntelhgence 8 . 
9 . Maruyama , 11 . , 1990 , " Stmlc Utral ) is ambiguation with Constraint Propagation , "28th ACL Annual
Meel in 9.
10 . Maruyama , H . , 1991 , " Constraint I ) ependency Grammar and Its Weak Generative Capacity  , " Advances in
Software Science and Technology 3.
11 . Maruyama , H . , Watanabe , 11 . , and Ogino , S . , 1990 , " An Interactive Japanese Parser for Machine ' lYansla-tion  , " COLING'90 . 
12 . Montanari , U . , 1974 , " Networks of Constraints : Fundamental Properties and Applications to Picture Pro cessing  , " Information Science 7 . 
13 . Mohr , R . and llen derson , T . , 1986 , " Arc and Path Consistency Revisited , " Artificial Intelligence 28 . 
14 . Mukai , K .  1988 , " Partially Specified Termin Logic Programming for IAnguistic Analysis  , " International Conference on Fifth Generation Computer Systems  , 

15 . Nagao , K ,   1990~ " Constraints and Preferences : Integrating Grammatic alnd Semantic Kimwledge for Structural  ) is ambiguation , " Pacific Rim International Conference on Al , Nagoya . 
16 . Se , , J . and Simmons , R .  1988 , " Syntactic Graphs : a Representation for the Union of All Ambiguous Parse 
Trees , " Computational Linguistics 1517 . Tsuda , 11 . , llasida , K . , and Sirai , I1 . , 1989 , "JPSG Parser on Constraint Logic Programming , "4th ACL
European Chapter.
18 . Younger , D . H . , 1967 , " Recognition and Parsing of ContextFree Languages in time nO  , '' Information and
Control 10.
ACRESDE COLING-92 , NANTEs , 2328 Ao~r 1992I166 P Rec . OFCOLING-92 . NANTES , AUG .  2328, 1992
