An EN cientParser Gener ; ttorfl ) rN at ; rea , 1 Language
Masayuki ISItl I * l ( azuh is a OHTAIliro ~ ddSAITO
Fujitsu Inc . Apple Technology , Inc . Keio University
masayuki ~ . nak . math . keio . ac . jpk-ohta@kol)o . apple . coln hxs~nak . math . keio . ac . jp
Abstract
We . have developed a parser generator for natural language i  ) rocessing . The generator named " NLyace " accepts grammar ules written in the Y acc format  . NLy acc , unlike Y acc , can handle arbitrary contextfree grammars using the generalized Lll  . parsing Mgorithm . The parser produced by NLy accelliciently parses given sentences and execute semantic actions  . NLy acc , which is a free and sharable software , runs on UNIX workstations and personal computers . 
1 Parser Generator for NLP
Y acc\[4\] was designed for unambiguous progl'anl-ming languages  . Thus , Yacccat ) notelegantly handle a script language with a natural language flavor  , i . e . Y acc forces a grammar writer to use tricks for handling ambiguities  . To remedy this situation we have developed N l , yacc which can handle arbitrary context-fi'e egr ; tnl-marst and allows a grammar writer to write natural rules and semantic actions  . Although there are several parsing algorithms for a general context-fi'e e language  , such as ATN , CYI ( , and garley , " the generalized Eli . parsing algorithm \[2\]" would be the best in terms of its compatibility with Y acc and its efficiency  . 
An ambiguous grammar causes a conflict in the parsing table  , a state which has more than one action in an entry  . The . generalized LR parsing proceeds exactly tit ( . ' same way as the stm~dard one except when it encounters a conflict  . The standard deterministic LR parser chooses only one action in this situation  . The generalized I , R parser , on the other hand , performs all the actions in the multiple entry by * This work was done while ls hilstayed at l  ) ept , of Computer Science , Keio University , Japan . 
1 To be exact , NLyaccca , tnoth and le ; t circular rule like " A - - + A " . 
splitting the parses tack f in ' each action . The parser merges the divided sta . ckbr ; tnches , only when they have the same top state . This merger operation is important for efficiency  . As a re-suit , the stacl ( becomes a . gra . plt instead of a simph , , linear state sequence . 
There is already a generalized LR parser for natural language processing developed at Carnegie Mellon University  \[3\]  . Nl , yacc difl hrsfi'om CMU's system in the following points  . 
? NLy acc is written in C , while CMU's in

? CMU's cannot handh ' , crules , while NI , y-ace does . crules are handful for writing natural rules . 
The way to execute semantic actions differs . CMU's evaluates an Ll? ( \]-like semantic action attached to each rule when reduce action is performed on that rule  . 
NLy accexecutes a semantic action in two levels ; one is perfin'med during parsing for syntactic control and the  . other is performed onto each success fifl final p ; ~ rse . We will desc . ribe the details of NLy acc's approach in the next section  . 
NLy accis , , pper-compatible to Y acc . NLy-acc consists of three modules ; a reader , a parsing table constructor , and a driver outine for the gene . ralized LR parsing . The reader accepts grammar ruh ; s in the Y acc format . The table constructor produces a generalized LR . parsing t ; t ble instead of the standard I,R . parsing table . 
We describe the de . tails of the parser in the next sectiou . 
4 17   2 Execution of Semantic Ac-tions NLy acc differs from Y accmainly in the execution process of semantic actions attached to each grammar ule  . Namely , Yacc evaluates a semantic action a . qit parses the input . We examine if this evaluation mechanism is suitable for the generalized LR  . parsing here . If we can assume that there is only one final parse  , the parser canewtluate semantic actions when only one branch exists on top of the stack  . Although having only one final parse is often the cruse in practical applications  , the constraint of being unambiguous i too strong in gener M  . 
2.1 Handling Side Effects
Next , we examine what would happen if semantic actions are execute during parsing  . When a reduce action is performed , the parser evaluates the action attached to the current rule  . 
As described in the previous section , the parses tack grows in a graph form . Thus , when the action contains side effects like an assignment operation to a variable shared by different actions  , that side effect must not propagate to tile other paths in the graph  . 
If an environment , which is a set of v , z due of variables , is prepared to each path of the parse branches , such side effect can been capsulated . 
When a stack splits , a copy of the environment should be created for each branch  . When the parse branches are merged , however , each environment cannot be merged . Instead , the merged state must have all the environments . 
Thus , the number of environments grows exponentially as parsing proceeds  . Therefore this approach decreases the parsing e\ [Iiciency drastically  . Also this high cost operation would be vain when the parse fails in the middle  . To sumit up , although this approach retains compatibility with Yacc  , it sacrifices efficiency too much . 
2 . 2 Two Kinds of Semantic Actions We , therefore , take another approach to handling semantic actions in NLy acc  . Namely , the parser just keeps a list of actions to be executed  , and performs all the actions after parsing is done  . This method can avoid the problem the semantic actionev Muator performs the task as it traces all the history paths one by one  . 
This approach retains parsing efficiency and can avoid the execution of useless semantic actions  . 
A drawback of this approach is that semantic actions cannot control the syntactic parsing  , because actions are not evaluated until tile parsing is clone  . To compensate the cons above , we have introduced a new semantic action enclosed with \[\] to enable a user to discard semantically incorrect parses in the middle of parsing  . 
Namely , there are two types of semantic actions : An action enclosed with \[\] is executed during parsing  . just as done in Y acc . If ' return 0; ' is execute < t in the action , the partial parse having invoked this action fails and is disca  . rded . 
* An action enclosed with ) is executed alter the syntactic parsing . 
In the example below , the bracketed action checks if the subtraction result is negative  , and , if true , discar<ts its partial parse . 
number : number '-' number\[$$=$133 ; if (35<0) return 0 ;  \]  $$ = 31-33 ; print ( . . . . .  , 31, $3, $$);  2 . 3 Keeping Parse History Our generalized Lll . parsing algorithm is different from tile original one  \[2\] in that or e ' algorithm keeps a history of parse actions to execute semantic actions after the syntactle parsing  . The original algorithm uses a packe < l forest representation for the stack  , whereas our algorithm uses a list representation . 
The algorithm of keeping the parse history is shown as follows  . 
1) If the next action is " shifts " , then make < s > as the history , where < s > is a list of only one elements . 
2 ) If the next action is " reducer : A-+BIB2"" . 11 ~", then make append ( lh , lI2, . . . , I In , l-r \]) as the history , where Hi is a history of Bi , r is the rule number of production " A -+ 1~1132  ?  "1\  ]  ,  / '  , an < l the function ' append ' concatenates multiple lists and returns the result  . 
Now we describe how to execute semantic actions using the parse history  . First , before starting to parse , the parser ca . lls " yyinit " function to initialize w triables in the semantic actions  . 
Our system requires the . user to define " yyinit " to set initial values to the variables  . Next , the parser starts parsing and l ) erforms a shift action or a reduce action according to the parse history and evaluates the apl  ) ropriate semantic actions . 
2.4 Efficient Memory Management
We use a list structure to implement he . parses tack , because the stack becomes a complex grN ) h structure as described l ) reviously . Because the parser discards fa . iled branches of the stack , the system rechfims the memory allocated for the discarded parses using the " mark and sweep garhage collection algorithm  \[1\]" to use memory efficiently . ' Phisgarl ) age collection is triggered only when the memory is exhausted in our current implementation  . 
3 Distribution
Portability
Currently , NLy accruns on UNIX worksta . -tions and DOS personal computers . 
Debugging Grammars
For grammar debugging , NLy acc provides l ) arse trace information such as a history of shift /reduce actions  , execution information of '\[\] actions . ' When NLya . c cencounters an error state , " yyerror " function is called just a . s in Y acc . 
Distribution
NLy acc is distributed through email ( ple : tse contact nly acc ~ nak . math . keio . ac . jp ) . I ) is-tribution package includes all the source codes  , a manual , and some sample grammars . 
References\[1\]J . McCarthy . Recursive flmctions of symbolic expressions and their computation by machine  , part 1 . Communications of the ACM , 3(4), April 1960 . 
\[2\] M . Tomita . EJficieut Parsing for Nalural Language . Kluwer Academic P . blishers , l~oston,
MA , 1985.
\[3\] M . Tomita and J . G . Carbonell . The universal parser architecture for knowledge -based machine translation  . In Proceedings , l Olh hd cvaational Joint Um ~ ference on Arlificial IMelligence  ( IJ-
CAI ), Milan , A , gust 1987.
\[ J\]y acc-yet another compiler-compiler : l ) arsing l ) rogram generator , in UNLV manual . 
Appendix-SampleRuns-
As a , mple grammar helow covers as m~fll set of l ' ~nglish sentences  . The . parser I ) ro(h : , ees syntactic trees of a given sentence . Agreement check is done by the semantic actions . 
/* grml ~ ar . y */%  #include < stdio . h >  #include < stdlib . h >  #include " gran ~ ar , h "  #include " proto . h "% % token NOUN VERBDETPREP % %
SS : S
S:NPVP pr_tree($1);\[return checkl($1 , $2);\]$$ = mk_tree2("S " ,  $1 ,  $2); 
S : SPP $5
NP:NOUN\[$$$$
NP:DETNOUN\[$$55
NP:NPPP\[55$$
PP:PREP NP $$
VP:VERBNP\[$5$$%%
FILE * yyin ; extern in tyy debug ; int main ( arg c , arg v ) in targ c ; char * argv\[\] ; int result ; = mk_tree2("S " ,  $1 , $2);:$1;\]:mktreel("NP " , $ I );=$2; return check2($1 , $2);\] = mktree2("NP " , $ I , $2);=$1;\]=mk_tree2("NP " ,  $1 , 52); = mk_tree2("PP " ,  $1 , 52);=$1;\]=mk_%ree2("VP " ,  $1 ,  $2) ; yydebug = I ; read_dictionary("dict ") ; yy initialize_heap ( ) ; result = yyparse () ; printf (" Result = Zd\n " , result ) ; yyfree_heap ( ) ; return O ; voidyy in it ( )  int yyerror ( message ) char * message ; fprintf(stderr , " % s\n " , message ); exit(l ); in t checkl ( seml , sem2)
SEMPTR seml , sem2 ; return ( seml->seigen & sem2->seigen ) ; in t check2 ( seml , sem2)
SEMPTR seml , sem2 ; return ( seml->seigen & sem2->seigen ) ; /* grammar . h*/ #define SPELLING_SIZE 32  #define HINSBI_SIZE 32  #define BUFFER_SIZE 64 type defstruct word struct word * next ; char * spelling ; in thinshi ; /* parts of speech */ intseigen ; /* constraints*/WORD ; type defenum tag
TLEAF , TND DETAG ; type defstruct node
TAG tag ; union
WORD*_lea ~ ; struct char *_ pos ; struct node *_ left ; struct node * right ; contents ; NODE , * NODEPTR ;  #define leaf contents . _leaf#define pos contents . _pair . _pos  #define left contents . _pair , left#define right contents , pair . _right type def WORDSEM , * SEMPTR ;  #define YYSTYPENODEPTR  #define Y Y SEMTYPE SEMPTR /* dict*/ 

You:NOUN:22 you:NOUN:22
He:NOUN:04 he:NOUN:04
She:NOUN:04 she:NOUN:04
It : NOUN : 04 it : NOUN : 04
We:NOUN:IO we:NOUN:IO
T hey:NOUN:40   they:NOUN:40   see:VERB:73   sees:VERB:04   a:DET:07   the:DET:77   with:PREP:O0   telescope:NOUN:07   man:NOUN:07 
Sample Runs  #sentence no . l\[e see saman with a telescope " D#parse1


NP:(DET:aNOUN:man)))
PP:(PREP:with NP:(DET : a
NOUN : telescope )))  #parse 2


NP:(NP:(DET:aNOUN:man)

NP:(DET : a NOUN : telescope ))))) #sentence no.2
He see a man " D  #The semantic actions prune syntactically-#sound but semantically-incorrect parses  . 
