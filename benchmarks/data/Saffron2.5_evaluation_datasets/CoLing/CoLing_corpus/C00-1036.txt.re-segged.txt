XML and Multilingual Document Authoring : Convergent Trends 
Marcl ) ymctman Veronika Lux
Xerox Research Centre Europe
6, chemin de Maupertuis
38240 Meylan , France
dymetman , lux@xrce.xerox.com
Aarne Ranta
Department of Computing Science
Chahners University of Technology
and G Oteborg University
S-41296 G Oteborg , Sweden
aarne@cs.chahners , e

Typical al ) proaches to XML authoring view a XML doc-urnent as a mixture of structure  ( the tags ) and surl hce ( texl between the tags )  . We advoeale a radical approach where the surface disappears from lheXML documenlal together to be handled exclusively by rendering mechanisms  . This move is based on the view that the author's choices when authoring XML docutnciHs are best seen as language-i ~ eutral semantic decisions  , that lheSlft lC-lure can then be viewed as inlerlingual content  , and that the textual oul pul should be derived from this co  ) lien\[by language-sl~ecific realization mechanisms  , lhus assimi-lating XML aufllol'inglo Mullilingual Document Amhofing  . However , slandard XMI , tools have imporlant lhni-tations when used for such aptu ' pose:  ( 1 ) they are weak at propagating semanlic dependencies belween dil'ferenl parts of the st  , ' ucture , and , (2) current XMI . rendering tools are ill-suited for handling the grammatical combination of lextual units  . We present two relalcd proposals for overcoming these limitalions : one  ( GI: ) origitmting in the Iradilion of malhemalical proofedilors and con-slructiv ctypelh cery  , the other ( IG ) , a speciali?ation of l ) elinite Clause ( _\] ranllllars strongly inspired by ( iF . 
1 Introduction
The typical al3pl'oacll to XML authoring views an XML doctml cnt as a mixture of wee-like strttct ttre  , expressed througll balanced labelled parentheses ( timlags )  , and of sul : face , expressed llu ' ough freelexi interspersed between lhetags  ( PCI ) ATA )  . Al ) octunent Typel ) elini-lion ( DTD ) is roughly similar to a coiitext-free grammar j with exactly one predelined terminal  . It delines a set o1'wellformed structures , ( hatis , ala , guage over trees , where each nonterminal node can dominate it her the empty string  , or a sequence of occurrences of nonterminal nodes and of  111o terminal node pc data . The terminal pc data has aspecM status : it can in turn dominate any characler string  ( subjecl to certain reslrictions on the characters allowed  )  . Authoring is typically seen as a topdown interactive process of stepwise refinement of the root nonterminal  ( corresponding to the whole document ) where the aulh orileratively chooses a rule for expanding IBu  ( see ( l ' rescod ,  1998 ) l braninleresfing discussion of lhediffer-enccs . 
a nonlerminal aheady present in the tree ,   2 and where in addition the author can choose an arbitrary sequence of characters  ( roughly ) for expanding lhep c data node . 
One can observe the following trends in the XML world : A move towards more typing of the surface : Schemas  ( W3C , 1999a ) , which are an inlluemial proposal for the ie placenlent of I  ) TD's , provide for types such as float , boolean , uri , etc . , instead o \[" the single type pcdata ; A move , a heady constitulive of the mainlml pose of XM l , its opposed l(1HTML for instance , towards clearer separation between content and form  , where the original XML document is responsible for con-lent  , and powerful styling lnechanisms ( e . g . XSI . T ( W3C , 1999b ) ) are available for rendering 111o doc-tlll/en\[\[olheend-user . 
We advocate an approach in which these two moves are radicali?cd in tilefolk  ) wingways : Strongly typed , surface-free XML documents . The whole content of the document is at rcc whore each node is labelled and typed  . For inlernal nodes , lhelype is just the usual nonierminal name ( or category )  , and Ille label is a name for the expansion chosen for this nonlern final  , lhat is , an identifier of which rule was chosen to expand ib is nonterminal  . For leaves , lhetype is a semanlically specilic category such as Integer  , Animal , etc . , and lhe label is a specilic concept of this type  , such as three or dog ) Styling responsible for producing timtext itself . 
The styling mechanisnlis not only responsible for rendering the layout of the lext  ( typography , order and presentation of lheelements ) , but also for producing the text its e!f from 111o document content . 
What are ( hemotiw ~ tions behind this proposal ? Autlmring choices carry language-independent meaning  . First , let us note that lhe expansion choices 2We arc ignoring here tl ~ e aspecls of lhis process relating to lhere gular  , mlure of Iherigh (- halld sides of rules , but I hese parliculars are uncs senlial loth e nlaillg : lfgtlllOnl  . 
3 Note I hatlnlcg crisof " logical type " e , whereas Animal is of logically pe(c , t ): lhe , ' c is no reslriction on lhede not alionals alus of leaves  . 
243 <! ELEMENT Risk ( Caution I Warning ) > risk-rulel:Risk-->Caution risk- ru  le2 : Risk-->Warning<!ELEMENTCaution (   .   .   . I .   .   . I .   .   .   ) > caution-rulel:caution-ru le2 : caution-ru le3  :
Caution --> ..,
Caution --> ...
Caution --> ...
Figure 1: Context-flee rules ( shown on the right ) corresponding to the aircraft DTD ( shown on the left )  ; for illustration purposes , we have assumed that there are in turn three semantic varieties of cautious  . The rule identitier on the left can be seen as a semantic label for each expansion choice  ( in practice , the rule identifiers are given mnemonic names directly related to their meauing  )  . 
made during the authoring of an XML document generally carry language-independent meaning  . For instance , the DTD for an aircraft maintenance manual might be legally required to distinguish between risk instructions of two kinds : caution  ( risk related to material damages ) and warning ( risk to the operator )  . Ora D ~' I ) describing a personal list of contacts might provide a choice of gender  ( male , female ) , title(dr , prof , default ) , country ( ger , fra ,  . . . ), etc . Each such authoring choice , which formally consists in selecting among different rules for expanding the same nonterminal  ( see Figure 1 )  , corresponds to a semantic decision which is independent of the language chosen for expressing the document  . A given DTD has an associated expressive space of tree structures which fall under its explicit control  , and the author is situating herself in this space through topdown expansion choices  . There is then a tension between on the one hand these cxplicitely controlled choices  , which should be rendered differently in different languages  ( thus geras Germany , Allemagne , Deutschland . . . . and Warning by a paragraph starting with Warnillg !  . . . ; Attention , Danger ! . . . ; Achtung , Lebensge fahr ! . . . ) , and on the other hand the uncontrolled inclusion in the XML document of free PCDATA strings  , which are written in a specific language . 
Surface-fi'ce XML documents . We propose to completely remove these surface strings from the XML document  , and replace them with explicit meaning labels .   4 The tree structure of the document then becomes the sole repository of content  , and can be viewed as a kind of interlingua for describing a point in the expressive space of tile DTD  ( a strongly domain-dependent space )  ; it is then the responsability of the language -specific rendering mechanisms to " display " such content in each individual language where the document is needed  . 
XML and Multilingual Document Authoring . In this conception , XML authoring has a strong connection to the enterprise of Multilingual Document Authoring in which the author is guided in the specilication of the document content  , and where the system is responsible 4There are autlmring situations in which it may be necessary for the user to introduce new selllalllic label seorle Sl  ) onding lo expressive needs not for eseen by lhe creator of the original I  ) TD . To handle such situations , it is usefl fl to view the l ) TI ) 's as open-ended objecls 1o which new semantic labels and types can be added at authoring time  . 
for generating from this content extual output in several language simultaneously  ( see ( Power and Scott , 1998; Hartley and Paris , 1997; Coch ,  1996)) . 
Now there are some obvious problems with this view  , due to the current limitations of XML tools . 
Limitations of XML for multilingual document authoring  . The first , possibly most serious , limitation originates in the fact that a standard DTD is severely restricted in the semantic dependencies it can express between two subtrces in the document structure  . Thus , if in the description of a contact , a city of residence is included , one may want to constrain such an information depending on the country of residence  ; or , in the aircraft maintenance manual example , one might want to automatically include some warning in case a dangerous chemical is mentioned somewherels e in the document  . 
Because DTD's are essentially of contcxt-fi'ce expressive power  , the only communication between a subtree and its environment has to be mediated through the name of the nonterminal rooting this subtree  ( for instance the nonterminal Country )   , which presents a bottleneck to information i low . 
The second limitation comes fi'om the fact that the current styling tools for rendering an XML document  , such as CSS ( Cascading Style Sheets ) , which arc a strictly layout-oriented language , or XSLT ( XSL transformation language) , which is a more generic tool for transforming an XML document into another one  ( such as a display-oriented HTML file ) are poorly adapted to linguistic processing . In particulm , it seems difficult in such formalisms to express uch basic grammatical facts as n tun-ber or gender agreement  . But such problems become central as soon as semantic elements corresponding to textual units below the sentence level have to be combined and rendered linguistically  . 
We will present two related proposals for overcoming these limitations  . The first , the Grammatical Framework ( GF ) ( Ranta ,  2000) , originates in constructive type-theory ( Martin-L6f , 1984; Ranta ,  1994 ) and in mathematical proof editors ( Magnusson and Nordstr6m ,  1994) . 
The second , h~teraction Grammars ( IG ) , is a specialization of Definite Clause Grammars trongly inspired by GF  . The two approaches present certain lk ) rmal differences that will not be examined in detail in this papeh ? The semantic representations are strrm glyO'ped trees  , and rich dependencies between subtrees can be specilied  ; ? The abstract tree is independe , lt of tile different ex-tual realization hm guages ; ? Tim surface realization in each language is obtained by a semalltics-driven compositional process  ; that is , the surface realizations are constructed by a bottom-up recursive process which associates ur -face realizations to abstract reenodes by recursively combining the realizations of daugth cr nodes to obtain the realization of the mother node  . 
? The grammars are revelwible , that is , can be used both for generation and for parsing ; ? The authoring process is an interactive process of repeatedly asking the author to further specify nodes in the absmlct ree of which only the type is known at the  1  ) oint of interact i ( m ( tyFere/itlemeHt )  . 
This process is mediated througll text in the language of the author  , showing the types t ( 5 be relined as specially highlighted textual units  . 
2 GF ~ the Grammatical Framework
The Grammatical Framework ( GF ; ( Ranta ,  2000 ) ) is a special-purpose programming hmguage combining co~z-strttctive type thee O  , with an annotation hmguage for concrete syntax . A grammar , in the sense of GF , delines , on one hand , an abstracts 3 , 1ttax ( a system of types and typed syntax trees ) , and on the other hand , a mapping 51 tile abstract syntax into a co , icicles y , tta . v . The abstract syntax has cotC tlot3 , declarations , uchascat Country ; cat City ; and combinator ( orfttnctiol O dechuations , uchasfun Get : Country ; fun Fra : Country ; fun Ham : City ; funPar : City ; funcap : Country -> City ; The type of a combinator can be either a basic type  , such as the type City of the combinator Ham , or a function type , such as the type of the combinator cap . Syntax trees formed by combinators of functiol l types are con > plex function alterlns  , such as cap Fra of type City . 
" file concrete syntax part of a GF grammar gives lit~-earization rules  , which assign strings ( or , in general , more complex linguistic objects ) to syntax trees . For the abstract syntax above , we may lmvef in Ger="Germany" ; finFra="France " ; linHam="Hamburg " ; linPar:"Paris " ; lincapCo = " the capital of "+ + Co ; 
Thustile linearization of capFra is the capital of France  2  . 1GF in XMI , Functional terms have a straightforward encoding in XML  , l ' el ~ resenting a term of tile for n a . \[ (11  .   .   . (I,~by the XML object < J '> ct ', .   .   . a ' , , < / f > where each e ~ is tile encoding of a i . In this encoding , capFrais < cap > < Fra > </ Fra > </ cap > Tile simple encoding does not pay attention to the types  ( 51' the objects , and has no interesting DTI ) . To express type distinctions , we will hence use a slightly more complicated representation  , i which the category and combinator declarations of GF are represented as DTDs in XML  , so that GF typed lecking becomes equivalent , a , it ll XML validatiom The represelm ~ tionf the GF grall l l l l a f  o1' tile previou section is tile DTI ) < ! ELEMENT Country ( Ger\[Fra ) > <! ELEMENTGetEMPTY > <! ELEMENT FraEMPTY > < ! ELEMENT City  ( HamIParI ( cap , Country ) )> <! ELEMENT Ham EMPTY > <! ELEMENT Par EMPTY > < ! ELEMENT cap EMPTY > In this DTD  , each category is represented as an EI , E-MENT dclinition , listing all combinators producing trees of that category  . The combinators themselves are represented as EMPTY elements  . The XML representation f the capital ( 5 1' France is < City > < cap/><Country > < Fra/> </Country > </ City > which is awdid XML object w  . r . t , tile given DTD . 
The latter encoding of GF in XML enjoys two important properties : ? All well-typed GF trees are represented by valid 
XML objects.
? An XML represents a unique GF tree.
The tirst property guarantees that type checking in the sense of GF  ( and type theory ) can be used for validation of XML objects . The second property guarantees that GF objects can be stored in timXML format  . ( The second property is already gt , a ranteed by tile simpler encoding , which ignores types . ) ( ) ther prope , ' ties one would desire are the followillg : trees . 
? ADTD represents a unique GF abstract grammar.
These properties cannot be satislied , in general . The reason is that GF grammars may contain dependent types  , i . e . types depending on objects . We will retnrn to this notion shortly . But let us first consider the use of GF for nmltilingual generation  . 
2.2 Multilingual generation iGF
Multilingual generation iGF is based on parallel grammars ': two  ( or more ) GF grammars are parallel , if they have the same abstract syntax . They may differ in concrete syntax . A grammar parallel to the one above is defined by the concrete syntax paramCase=hem\[gen  ; opernoml:Str->Case=>Str=ks->tbl nom => s  , gen->s + " n " ; oper nom2 :Str->Case=>Strks->tblnom=>s+"ki " , gen->s + " gin " ; lincatCountry=Case => Str ; lincatCity=Case => Str ; linGer = noml " Saksa " ; linFra = noml " Ranska " ; lin Ham=noml " Hampuri " ; linPar=noml " Pariisi " ; lincapCo = tblc => Co!gen++ nora2 " p ~ ii kaupun "! c ; This grammar renders GF objects in Finnish . In addition to linearization rules , it has rules introducing parameters and operations  , and rules detining the linearization O , pes " corresponding to basic types : the linearization type el ' Country  , for instance is not just string ( Str ) , but a function fl ' om cases to strings . 
Not only the linearization rules proper , but also parameters and linearization types wwy a lot fl ' om one hm guage to another  . In our example , we have the paralnetre of ease with two values ( in larger granunars for Finnish , as many as 16 may be required !) , and two patterns for inflecting Finnish nouns . The syntax tree cap Fra produces the strings
Ranskanp ~ fikaupunki
Ranskanp ~ kaupung in which are the nominative and the genitive form  , respectively . 
2.3 Del ) endent types
DTDs in XML are capable of representing simple types  , i . e . types without dependencies . Even a simple type system can contribute a lot to the semantic ontrol of documents  . For instance , the above grammar permits the formation of the English noun phrase the capital of France but not of the capital of Paris Both of these expressions would be wellformed w  . r . t . 
an " ordinary " granunar , in which both France and Paris would be classitied simply as noun phrases  . 
Dependent types are types depending on objects of other types  . An example is the following alternative declaration of Country and City : cat Country  ; cat City ( Co : Country ) ; Undertiffs definition , there are no objects of type City ( which is no longer a wellformed type )  , but of types City Ger and CityFra . Tlms we define e . g . 
fun Ham : City Ger ; funPar : CityFra ; funcap : ( Co : Country ) -> City Co ; Observe the use of the variable Coin the type of the com-binator capital : the variable is bound to the argument type and then used in the value type  . The capital of a country is by definition a city of the same country  . This involves a generalization o1' function types with dependent types . 
Now consider a simplified format ( ) f postal addresses : an address is a pair of a country and a city  . The GF rule is either fun addr:Country->Ci ty -> Address  ; i in add rCoC = C + +" , "+ + Co ; using simple types or fun addr : ( Co : Country ) -> C ? tyCo -> Address ; & in add rCoC = C + +" , "++ Co ; using dependent types . The invalid address
Hamburg , France is well-typed by the former definition but not by the latter  . Using the la Uer delinition gives a simple mechanism of semantic ontrolot'addresses  . The same idea can obviously be exlended to full addresses with street names and numbers  . Such dependencies cannot , however , be expressed in DTDs : both of the address rules above correspond to one and the same ELEMENT definition  , <! ELEMENT Address ( addr , Country , City ) >
This example enoughlbrGF < Address > < addr/>< Country > < Fra/></Country > < City > < Ham /> </City > </ Address > also shows Illat XML validity is not wellformedness : the object addr Frattam is not well-typed  . 
2.4 Computation rules
In addition to categories and cornbinators , GF grammars may contain definitions , uchas def cap Fra = Par ; Definitions belong to the abstract syntax . They define a normal form for syntax trees ( recursively replace de-fiendaby definientes )  , as well as a paraphrase relation ( sameness of normal tbrm )  . These notions are , of course reflected in the concrete syntax : the addresses the capital of France  , France
Paris , France are paraphrases , and the latter is the normal form of the former . 
=  .   .   .   .  - -  ,  -  ,  - - -  1 \[ U"emIE'~iml~wml?pu?i's ~ lum=~JIIN ll
I\["''~~~~ I/ll
II~h~1-~ul~f ~ //11
IIlt ' ~ eore ~ . Fc?a Hnumbers ? , there e ? is tsart lOceru ' such I/ /11 II~hat ~ . L ~ ~, ~ n ~ U ~ , , ' . ~- o~f . C ~ - . id ~ . ~, ~' bitr , a ~ u I//11 nuli Jerx . ' ? z3 re <~? . Ik . nce , " for ' all riJ ~2 rs ~ , there exists a Ill II li~- , 4 , c , r ' e ~ . Pot to us lorer Bc ~ hoes ; 4 . i le ~ i ~ t e ~ . ~ mbre~:' . ~\[/ I1j\[x,~r ~ .  , ~ . 111 ~\](~ t ~ . : n ~' , -~ , ~-~~ - ooqlII//1/I\[m  ~ o on L ~ , u : ~ o Uill " " t ~-(~- n ~ , u = (~ . ' qlII jill II et ~ o Hlukux ~ ik 4 l .   .   .   .   .   . I .   .   .   .   .   .   .   .   . v . IIIll/ItI\[<Text>crh,ua~w,-o411~,~ .  ( ,   , :- \[~ , r , , q I I I l l / I / I I < Pr *~> < E--:ist /> <0c~ll E ~ t , / i ' .  ~ -_ ~  ,   ,  ~-_  ( ~ = 11IIIMII </ Prop > < ~ r'o o > </@ tEll_ .   . 
I .   .   .   . ta~~_l~mH , . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Ill . , , , 411 Lt ? ~ a ~ Proof(Exist!lat(',' . .'>:' q l l?l . l0:~s~r , , s : ~" ~ ' , ~tlIii-\]1t--~iI1_:_' .  ~  , _t % : t ~ : F ? ? ~ ) \] lll ~ Figure 2: GF session for editing a mathematical proof text . 
2.5 GF editing tools
An editing tool has been implemented for GF , using metavariables to represent yet undefined parts of expressions  . The user can work on any metavariable , in various different ways , e . g . 
? by choosing a combinator fomamenu , ? by entering a string that is parsed , ? by reading a previously defined object from a file  , ? by using an automatic search of suitable instantiations  . 
These functionalities and their metatheory have been used for about a decade in a number of syntax editors for constructive type theory  , usually known as proof editors ( Magnusson and Nordstr Om ,  1994) . From this point of view , the GF editor is essentially a proof editor together with supplementary views  , provided by the concrete syntax . The current implementation of GF is a plugin module of the proof editor Alfa  ( Hallgren ,  2000) . The window dump in Figure 2 shows a GF session editing a mathematical proof . Five views are provided : abstract syntax in type -theoretical notation  , English , French , Finnish , and XML . One metavariable is seen , expecting the user to find a Proof of the proposition that there exists a number  . r ' such that a ' , is smaller than x ' , where x is an arbitrary number given in the context  ( for the sake of Universal Introduction )  . 
3 IG : Interaction Grammars
We have just described an approach to solving the limitations of usual XML tools for multilingual document authoring which originates in the tradition of constructive type-theory and mathematical proof editors  . We will now sketch an approach strongly inspired by GF but which formally is more in the tradition of logic-programming based unification grammars  , and which is currently un- . 
der development at Xerox Research Centre Europe ( see ( Brun et al ,  2000 ) for a more extende description of this project )  . 
Definite Clause Grammars , or DCG's , ( Pereira and Warren ,  1980) , are possibly the simplest unification-based extension of contextfree grammars  , and have good reversibility properties which make them adapted both to parsing and to generation  . A typical view of what a DCG rule looks like is the following :  5 a ( al ( B , C .   .   .   . )) ---> < text l > , b(B ) , < text2 > , e(c ) , < text 3> , constraints ( B , C ,  . . . ) . 
This rule expresses the fact that ( 1 ) some abstract structure al ( B , C .   .   .   .   ) is in category a if the structure B is in category b  , the structure C in category c . . . . . and furthermore a certain number of constraints are satisfied by the structures B  , C . . . . ; (2) if the structures B , C . . . . can be " rendered " by character strings St r ingB  , String C ,   . . . . then the structure a l ( B , C .   .   .   .   ) can be rendered by the string obtained by concatenating the text < text : t >  ( that is , a certain constant sequence of terminals ) , then String B , then < text2 > , then String C , etc . 
In this formalism , a grammar for generating English addresses ( see preceding section ) might look like : SReminder : according to the usualogic programming conventions  , lowercase letters denote predicates and functors , whereas uppercase letters denote metavariables that will be instantiated with terms  . 
247 address ( addr ( Co , C )) --> city(C ) ,  " , " , country ( Co ) . 
country ( fra)-->"France".
country(get)-->"Germany".
city ( par ) --> " Paris " city ( cap ( Co ) ) --> " the capital of " , country ( Co ) . 
The analogies with the GF grammars of the previous section arc clear  . What is traditionally called a category ( or nonterminal , or predicate ) in the logic program-ruing terminology , can also be seen as a type ( address , country , city ) and functor such as get , par , add r , cap can be seen as combinators . 
If , in this DCG , we " forget " all the constant strings by replacing them with the empty string  , we obtain the following " abstract grammar ": address  ( addr ( Co , C )) --> city(C ) , country ( Co ) . 
country ( fra)-->\[\].
country(ger)-->\[\].
city(par)-->\[\].
city(cap(Co )) --> country(Co).
which is in fact equivalent to the definite clause program :  6 address ( add r ( Co , C )) :- city(C ) , country ( Co ) . 
country ( fra).
country ( ger).
city(par).
city(cap(Co )) :- country(Co).
This program is language-independent and recursively dclines a set el ' wellformed trees to which it assigns types  ( thus cap ( fra ) is a wellformed tree o1'type city )  . 
As they stand , such definite clause grammars and programs , although suitable Ibr simple generation tasks , are not directly adapted for the process of interactive multilingual document authoring  . In order to make them more appropriate for that task  , we need to specialize and adapt
DCGs in the way that we now describe.
Parallel grammars . The tirst move is to allow for parallel English , French . . . . . grammars , which all have the same underlying abstract graln mar  ( program )  . So in addition to the Englisb grammar given above  , we have tim French grammar : address ( addr ( Co , C )) --> city(C ) ,  " , " , country ( Co ) . 
country ( fra ) --> " la France ".
country(get)-->"l'Allemagne".
city(par)-->"Paris".
city(cap(Co )) --> " la capitale de " , country ( Co ) . 
6hl the sense that rewriling the llOntCI'nlilull goal address  ( add r ( Co , C )   ) to the empty siring in lheI ) CG is equivalent oproving the goal address ( add r ( Co , C )   ) in the program ( l ) cransart and Maluszynski ,  1993) . 
Dependent Categories . The grammars we have given arc delicient in one import aut respect : there is no dependency between the city and the country in the salne address  . In order to remedy this problem , a standard logic programming move would he to reformulate the abstract grammar  ( and similarly for the language-dependent ones ) as : address ( add r ( Co , C )) --> city(C , Co ) , country ( Co ) . 
country ( fra)-->\[\].
country(ger)-->\[\].
city(par , fra)-->\[\].
city(cap(Co ), Co ) --> country ( Co).
The expression city(C , Co ) is usually read as the relation " C is a city of Co "  , which is line for computational purposes , but this reading obscures the notion that the object C is being typed as a city  ; more precisely , it is being typed as a city of Co . In order to make this reading more apparent , we will write the grammar as : address ( addr ( Co , C )) --> city c0(C ) , country ( Co ) . 
country ( fra)-->\[\].
country(ger)-->\[\].
cityf~(par)-->\[\].
cityco(cap(Co )) --> country(Co).
That is , we allow the categories to be indexed by terms ( a move which is a kind of " currying " ot'a relation into a type for its first argument  )  . Dependent categories are similar to the dependent types of constructive type theory  . 
Heterogeneous trees . Natural language authoring is different from natural language generation in one crucial respect  . Whenever the abstract ree to be generated is incomplete  ( for instance the tree cap ( Co ) ) , that is , has some leaves which are yet uninstantiated variables  , the generation process should not proceed with noude-terministically enumerating texts for all the possible instantiations of the initial incomplete structure  . Instead it should display to the author as much of the text as it can in its present " knowledge state "  , and enter into an interaction with the author to allow her to further refine the incomplete structure  , that is , to further instantiate some of the uninstantiated leaves  . To this purpose , it is useful to introduce along with the usual combinators  ( add r , fra , cap , etc . ) new combinator so farity 0 called type-names , which are notated type , and are of type type . 
These combiuators are allowed to stand as leaves ( e . g . in the tree cap ( country )   ) and the trees thus obtained are said to be heterogeneous  . The type names are treated by the text generation process as if they were standard semantic units  , that is , they are associated with text trails which arc generated " at their proper place " in the generated output  . These text units are specially phrased and highlighted to indicate to the author that some choice has to be made to reline the underlying type  ( e . g . obtaining of further instantiating the incomplete tree with " true " combinators  , and the gmm ration process is iterated . 
Extended senmntics-driveneom positionality . The simple DCG view presented at the beginning of this section sees the process of generating text from an abstract structure as basically a compositional process on strings  , that is , a process where strings are recursively associated with subtrees and concatenated to l ~ roduce strings at the next subtree level  . But such a direct process of constructing strings Ires wellknown limitations when the semantic and syntactic levels do not have such a direct correspondence  ( simple example : ordering a list of modifiers around a noun  )  . We are currently experimenting with a powerful extension of string compositionality where the objects compositionally associated with abstract subtrees are not strings  , but syntactic representations with rich internal structure  . The text itself is obtained fiom the syntactic representation associated with the total tree by Siln-plyenumerating its leaves  . 
The picture we get of an IG grammaristinally the following : aD  ,  .   . ( al(B , C .   .   .   . ))-Syn-->bE, . . . (B)-SynB,
CF, . . . (C ) - SynC , constraints(B,C , .   .   . , D , E , F, .   .   . ), compose_english(SynB,SynC,Syn) . 
The rule shown is a rule for English : the syntactic representations are hmguage dependent  ; Parallel rules for timother hm guages are obtained by replacing the compose engl'ish constraint  ( which ist mique to this rule ) by constraints appropriate to the other hm guages under consideration  . 
4 Conclusion
XML-based authoring tools are more and more widely used in the business community for supporting the production of technical documentation  , controlling their quality and improving their reusability  . In this paper , we have stressed the connections between these practices and current research in natural anguage genent tion and authoring  . We have described two related for nmlisms which are proposals for removing some of the limitations of XMLDTD's when used for tim production of multilingual texts  . 
From a compt , tation a linguist's point of view , there might be little which seems novel or exciting in XML representations  . Still XML has a great potential as a lin-gua . franca and in driving a large community of users towards authoring practices where content is becoming more and more explicit  . There may be a great opportunity here for researchers in natural hmguage generation to connecto a growing sot  , rce of applications . 

Thanks for contributions , discussions and comments to Ken Beesley , Caroline Brtm , Jean-Pierre Chanod , Marie-Hdl8ne Corrdard , Pierre Isabelle , BengtNordstr6m , Sylvain Pogodall and Annie Zaenen . 

C . Brun , M . l ) ymetman , and V . Lux .  2000 . l ) ocument structure and multilinguatauthoring . In Proceedings of Firsth~telwatiomd Natural lzm guage Generation Conference  ( INLG'2000 )  , Mitzpe P , amon , Israel , June . 
J . Coch .  1996 . Evahmting and comparing three text production tech  , fiqucs . In Proceedhtgs of the 16th huernational Confe . r-ett ce on Conqmtational Linguistics . 
1: l ) eransart and J . Maluszynski .  1993 . A Gramntatical View of Logic Programming . MIT Press . 
Thonmsllall gren .  2000 . Alfa Home Page . Aw filable fi ' om http://wm ~ . cs . chalmers , se/~hall gren/Alfa/A . ltartley and C . Paris .  1997 . Multilingual document production : fiom support for translating to support for authoring  . 
In Machine Translation , Special Issue on New 7 bols . for Htt-man7)' anslators , pages 109-128 . 
L . Magnusson and B . Nords lr Om .  1994 . The ALF proof editor and its proof engine . In Lecture Notes in Conqmler Science 806 . Springe LP . Martin-L6f .  1984 . hmdlionistic7\]ype7heoo , . Bibliopolis,

W.Pardi . 1999. XML in Action . Microsoft Press.
Femando C . N . Pereira and David II . D . Warren .  1980 . Deft-nite clause grammars for language analysis . Artificial huel-ligence , 13:231-278 . 
P , . Power and D . Scott .  1998 . Multilingual authoring using feedback texts . In Proceed h T gs of the 17th h ~ ternational Confelwnce on Comlmtatiom ~ l linguistics and  36th Annual Meeting of the Association for Computational Lhlguislics  , pages 1053-1059 . 
P . Prescod .  1998 . For nmlizing SGMI , and XML Instances and Schemata with Forest Automata Theory  . 
http://m~w.prescod,net/forest/shorttut/.
A . Ranta .  1994 . 7 ~ vpe-Theorelical Grammar . Oxford University Press . 
Aarne Ranm .  2000 . GF Work Page . Awfi labl cfi ' om h'ct ; p://m,m,cs . chalmers , se/~aarne/(IF/pub/work-index/W3C ,  1998 . Exlensible Marktq ~ Language ( XML ) 1 . 0, February . W3C recommendation . 
W3C , 1999a . XML Schema-l ' arth Strltct ttres , Part 2: Data types - , l ) e cembe ,  . W3C Working draft . 
W3C , 1999b . XSL Transformations ( XSLT ) , Nov cm be , ; W3C recommendation . 

