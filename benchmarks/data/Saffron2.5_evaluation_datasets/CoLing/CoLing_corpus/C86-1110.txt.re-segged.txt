CONTROLLED ACTIVE PROCE DURES AS A TO OLFORL INGUISTICENGINEERING 
Heinz-Dirk Luckhardt
Manfred Thiel
Sonderforschungsbereichi00
" Elektronische Spraoh forschung "
Universitat des Saarlandes
D-6600 Saarbr ~ ckenii
Bundesrepublik Deutschland
Abstract
Controlled active procedures are productions that are grouped under and activated by units called's couts '  . Scouts are controlled by units called'missions  '  , which also select relevant sections from the data structure for rule application  . Following the problem reduction method , the parsing problem is subdivided into ever smaller subproblems  , each one of which is represented by a mission . The elementary problems are represented by scouts  . The CAP grammar formalism is based on experience gained with natural language  ( NL ) analysis and translation by computer in the Sonderforschungsbereich  I00 at the University of Saarbrdcken over the past twelve years and dictated by the wish to develop an efficient parser for random NL texts on a sound theoretical basis  . The idea has ripened in discussions with colleagues from the EUROTRA-project and is based on what Heinz-Die-ter Maas has developed in the framework of the SUSY- 
II system.
In the present paper , CAP is introduced as a means of linguistic engineering  ( cf . Simmons 1985) , which covers aspects like rule writing , parsing strategies , syntactic and semantic representation of meaning , representation of lexical knowledge etc . 
Survey of some ideas behind CAP
The data structure used in CAP is a type of chart called S-graph  ( see Maas 1985 )  . Charts are used in parsing quite frequently ( cf . Kay 1977, Varile 1983) . The S-graph is an acyclic directed graph with exactly one start node and one end node  . Each arc carries nonstructural information and may carry structural information that is also represented as an S-graph  . The nonstructural information is a set of property/value-pairs called ' decoration '  . It includes a ) amor Dhosvntactict_vpe(MS ), i . e . the terminal or nonterminal category b ) a surface-syntactic function ( SF ) c ) a ~\] 9_e~nt ~ ctic function ( DSF ) d ) a semantic relation ( SR ) e ) aW~i . C ~ f ) information specific to an MS The structure of the complex NP'trouble with Max'isvisible to the user as Fig  . i . 
trouble NP with Max
Fig . 1
NP n lo . . . . . . . . . . . . . . on 2\[!NNP
O . . . . . . . O . . .   .   .   . O trouble!\[PRP No . . . . . o . . . . . . o
Fig . 2 with Max
If we interpret the nodes as arcs , we receive the S-graph representation ( Fig .  2) . Hence , we shall use ' node ' and ' arc ' as synonyms . The ambiguity of ' trouble with Max ' is represented by a sequence of two NP-arcs that also goes from nl to  n2  . 
Much like most modern grammar theories ( LFG , GPSG etc . ), the CAP-concept is based on contextfree rules . CAP differs from these theories in the way wellknown problems of cf-grammars are dealt with  . 
Where GPSG employs metarules , derived categories , and the ID/LP-formalism , LFG uses different structural concepts ( C - and F-structures ) and - above all-lexical knowledge . LFG and GPSG are augmented PS-grammars . With CAPPS-grammar has been abandoned . 
This is due to the fact that PS-grammar simply strict word order  , and nonstandard word order can only be handled by means of transformations  ( TG ) or derived categories/new formalisms ( GPSG )  . 
In principle , in CAP constituents are accepted where they are found in natural language utterances  . 
It is assumed more natural to accept and represent the constituents '  #  ( whom ) and ' du ' ( you ) in ' Wenliebstdu ?' ( Who ( m ) do you love ? ) in their respective positions as accusative and nominative object than to mark the gaps in the representation where those constituents ' ought ' to appear or to move them to their standard position and to leave a trace in the original \[  . , lace . 
LFG and GPSG do not use transformations . In CAP transformations are possible , but they serve other purposes than in TG . They are not employed to account for structures that are not covered by standard PS-rules  ( the ID/LP-formalism was invented for that reason )  . On the one hand , transformations serve to ' normalise'certain surface structures  , in order to make rule writing easier ( cf . Luckhardt 1986) . On the other hand , they produce the deep structure necessary for the disambiguation of lexemes and for other purposes of machine translation  , e . g . by reintroducing deleted complements . 
Unlike the government-and-binding theory , CAP moves constituents only in those cases , where this movement can be achieved without damage to representation without leaving a trace  . E . g . in ' . . . lastet demAngek lagten das Verbreohenan . ' ( . . . charges the defendant with the crime . ) the verbal prefix ' an ' is moved to the left of ' lastet '  , so that the correct frame ( i . e . the frame of ' an lasten ' which requires a new dictionary lookup  ) can be used for assigning syntactic functions to the complements  . TG-typical transformations like passive transformations are not employed  , as the equivalent can be achieved by simple feature assignment  . 
In all , the CAP-parser for German ( CAP-G ) that is currently being developed may be regarded as a strictly controlled production system  , where rule a ) ' missions ' have to fulfil certain linguistic tasks  . They are organised hierarchically , so that the higher missions may be said to be decomposed into partial  ( simpler ) tasks ( cf . Fig . 
3) . Thus the parsing strategy can be formulated quite explicitly  . For every mission ~ i ' expectation ' may be formulated that allows it to select parts of the database that look ' promising ' for the application of certain rules  . The mode of application ( see below ) can be determined by the linguist . 
Fig . 3NP-MISSION
SIMPLE-NP COMPLEX-NP
AP-MISSIONN=>NPAI~NP=>NPA % TRIB~I~SCOORDINATION b  ) If a linguistic task cannot be subdivided any further  , a's cout ' , that represents such an elementary task , selects a path from the data structure offered , i . e . an unambiguous sequence of arcs , and tries to apply a rule or set of rules to this path  . The grouping of rules into larger units has also been pro~msed by Carter-/Freiling  1984 and others . 
This way of organising ruless a feguards that t1~ rule writer is relieved of looking at parallel structures  . Rules can be simple , since feature agreement m6~ be checked in missions and scouts so that rules may be kept general enough to be used in different places  , i . e . in differents couts . The linguist can be quite sure his rules are applied the way he wants  t1~m to and to the structures intended . 
In fact , certain rules would be quite harmful , if they were allowed to operate on arbitrary structures  . Rules ought to be perspicuous , but we think they cannot always be as simple as theoretical linguists would like them to be  . 
The application of cf-rules such as NP+PRED=>PRED may be subject to a number of restrictions  . Earlier experience with SUSY has shown that X ~ ( cf . below ) is a good basis for such a strategy , e . g . :
PRED+NP 1=>PRED(NPI)/condition :
NPI may fill a slot in the valency frame of PRED After the application of such rules the corresponding valency is deleted  ; these rules are applied in parallel and by iteration  . They are based on what Dowty ( cf . Dowty 1982 ) calls the ' grammatical relations principle ' . 
CAP rules are augmented , i . e . they are not just structure-building rules like the ones above  , but contain also conditions for their application  , formulated for the lefthand side , and assignments to the symbols on the right hand side  ( see below )  . This approach , of course , is not new and has been taken in METAL , PATR-II , LIFER , DIAGRAM , and many other systems . The way conditions and assignments are formulated is described below  . 
CAP possesses strong lexical and morphological components  . ' ? hesestem from its predecessor and are believed to be a prereouisite for efficient parsing rather than a part of the parsing J ~ Dependency grammar offers a secure foundation for the ark nlysis of free-word-order languages like German or Russian and by no mean simpedes the analysis of languages like English or French  , as has already been demonstrated with the SUSYMT system in the  70's   ( cf . Luckhardt/Maa ~: ~ Thiel 1984) o Moreover , for the sake of easier rule writing , it is helpful to represent all arguments of a predicate as sister nodes of each other and as sister nodes of the pred-icate's governor  . This approach supports frame-oriented linguistic procedures  ( e . g . for the analysis of complements and complement clauses  , translation of valency-bound constituents etc . ) in a direct way , whereas the representation of such phenomena is not so natural in a phrase structure notation  . 
Rules , scouts , and missions
CAP rules , scouts , and missions are written in a functional metalanguage  ( FUSL , cf . Bauer et al 1986) . There are five types of rules according to the effect they have : blending rule : A + B => C start rule : A => X  ( A ) rightex ~ insion : A ( X ) + B => A ( X+B ) left expansion : A+B ( X ) => B ( A+X ) concatenati ~\]: A + B => X ( A+B ) A blending rule may be employed where a const it -uent structure does not have to be preserved  , as in : AUX + PTC => FIV for : ' was '+' treated ' => treat  ( TENSE = PAS ~ ; MS = FINITEVERB , VOICE = PASS ) AUX 4- INP=>FIV for : ' will'+'treat '=> treat ( ~NSE = FUT etc .  )
C !!!!!!
O .   .   .   .   . O .   .   .   .   .   . O => O .   .   .   .   .   .   . O .   .   .   .   .   .   . O
ABAB Fig . 5
The assignment part of such rules , of course , has to furnish the new arc on the right hand side with the respectiw ~ property/value pairs  ( cf . brackets ) ? The effect of A+B => C is demonstrated in l ! qg  .  5 . 
The arcs A and B remain intact and may be used by other rules  . Thus a quasi-parallel processing is guaranteed . In cases of non-aii ~ oiguous structures , A and B may be deleted explicitly in the scout that invokes the rule  . 
!! X !: o .   .   .   . o , ! A ' ! 0 .   .   .   .   .   .   .   .  0 => 0  .   .   .   .   .   .   .   .   .   .   .   .  0
AA Fig . 6
A start rule is employed where a nonterminal arc is constructed from a terminal  . A => X ( A ) means that a new arc X is produced with A as its substructure which spans the same part of the data structure as does A  , cf . Fig .  6 . 

An expansion rule adds an arc as a sister arc to the substructure X of another arc  . A ( X ) + B => A ( X+B ) has as a result the structure represented in Fig .  7 . 
Fig . 7
O . . . . . . . . O . . . . . . . . O ! A B !
O ........ O
X =>!! A !!!! : o- .   .   .   . o .   .   .   .   .   . o ! ! X Bio . . . . . . . . . . o . . . . . . . o ! A B !
O ....... O

A+B(Z ) => B(A+X ) is employed analogously . 
Concatenation rules are used to express coordination : NP+COMMA+NP=NEWNP  ( NP+COMMA+NP ) N % ~+ CONJ+NP=NEWNP ( NP+CONJ+NP ) These ru \] . es produce deep structures . For ' Peter , Mary and John ' the structure in Fig . 8 is generated . 
Fig . 8

NP COMMANEW NP ' Peter ' NP CONJ NP
II ' Mary '' John '
CAP rules have the architecture given in Fig . 9.
r ~\] le RULENAME lhs < lefthand side > conditions < restrictions onlhs > rhs < righthand side > assigrm~ents < assignment storhs > endFig  . 9 The conditions part may be empty . It allows navigation in the processed subchart and a variety of restrictions by means of logical expressions  . This is also true for the assignments part , which , however , must be Don-empty . An example is given in
Fig . 9a.
rule PREO+SUBJ Fig . 9 alhs X+Y condition seq(MS of X , PRED ) eq(MS of Y , NP ) not empty ( in t(FRAME of X , 
SCASE of Y , < NO ~>) note . ioty ( int ( PERNUM of X,
PERNUM of Y ) ) rhs Z ( subX+Y ) assignment scopy dec ( Z , X ) assign ( SF of Y ' , SUBJECT ) assign ( FRAME of X , rain ( FRAME of X , < NOM >) assign(SCASE of Y , < NOM > ) endTwo neighbouring arcs X and Y are expected , X being a PRED , Yan NP . The FRAME of X is to include NOM inative , which also has to be one of the cases of Y . The PERNUM feature structures for person and number have to agree  . The newly created arc Z that inherits all property/value-pairs from X  . The ( sur-face- ) syntactic function SUBJECT is assigned to the new arc Y ' which is a copy of Y  . The NOMi native-slot is deleted from the FRAME of X  . Y is given the unambiguous surface case NO Minative  . 
The system of missions and scouts guarantees that PRED+SUBJ is invoked  , when the chart consists of PREDs and NPs , i . e . when the SIMPLE-STRUCTURES-mis-sion has turned terminal elements into simple nonterminal ones  ( e . g . FIV=>PRED,DET+N=>NP etc . ) ? By iteration , the output of PRED+SUBJ is used to attach the rest of the complements  ( by rules like PRED+DAT , 

Rules are grouped under and activated by what we call's couts '  . As cout selects those paths ( = unambiguous sequences of arcs ) from the S-graph to which the rules of the scout may be applied  . The modes of application are : parallel : all rules are applied to the same structure stratificational : one rule is applied after the other  ( stop after failure preferential : stop after success iter at \] ve : repeat after success The architecture of scouts is given in Fig  . i0 . 
scoutSCOUTNAME conditions < path with conditions on arcs > user u\]e  RULE1 use rule RULE n params < mode of application > options < further options > end Fig  .   i0 < path > is a sequence of normally not more than four arcs each of which is described in the < conditions on arcs > part  ( cf . Fig . 10a ) . 
conditions Fig . 10 aarc1(X , mender ( MS of X , < ART-DEF , ART-INDEF , DEM , POSP , IND >)) arc2(Y , equal ( MS of Y , N ) ) Here two neighbouring arcs X and Y are described  , ' x ' and ' Y ' being names used only by this scout  . The morphosyntactic category ( MS ) of X must be a men ~ oer of the set in angled brackets  , the MS of Y must equal N . The scout selects all sequences ART-DEF+N , ART-INDEF + N etc . one after the other from the database offered by a mission  ( see below ) and tries to apply its rules to them . The angled brackets enclose the set of determiner types that are thought to be relevant here  ( def . art . , indef , art . , dem . 
pronoun , poss . pronoun , indef , pronoun ) and that may be combined with a noun to form an NP  . Others couts select paths like PREP+N , PREP+AP+N etc . They all have to be dealt within different scouts  , as the conditions for unifying them into an NP and the values the NP's inheritar equite different  . 
Scouts are controlled by ' missions ' . The system of rules , scouts , and missions presents the control structure of the parser  ( cf . example in Fig .  12) . 
The elementary tasks of the parsing mission are organised as scouts that activate those  ( sets of ) rules that are to be applied to fulfil the intended task  . The linguists are free to choose the strategy they like according to the field they intend to cover  . The modes of application are the same as above . 
The architecture of missions is given in Fig . ii.
mission MISSIONNAME Fig . ii expectations left-contexts cope < active area > right-context subproblems solve  ( subproblemi ) solve (  . . . ) solve ( subproblem n ) parameters goal < goal structure > end mission PARSE-GERMAN Fig  .   12 mission SIMPLE-STR~Sscout N=>NP rule N => NP scout DET+ADJ+N=>NP rule ARTD+ADJ+N rule ARTI+ADJ +N rule POSP+AIXT+N mission COMPLEX ~ UCIIFRESn ~ssion COMPLEX_NPS mission ATTRIBUTEs missionGEN ITIVE_ATI~RIBL~I~E  .   .   . 


A mission consists of a list of submissions or scouts that are applied in the mode < mode >  , if certain ' expectations ' ( = preconditions ) are fulfilled . 
The expectations part may be empty , so that the scouts may operate on the complete database  . A well-defined structure may be formulated as the ' goal ' of the mission  . The expectations part describes a section of the S-graph where the scouts of that mission may be successful  , i . e . this section with all its ambiguities ( = parallelarcs ) is taken from the database and handed over to the scouts  . An example is given in Fig .  13 . 
expectations Fig . 13 scope first(X , equal ( MS of X , FIV )) mid(Y , member ( MS of Y , < NP , AP >)) last(Z , equal ( MS of Z , VERBPREFIX )) right-context(R , member ( MS of R , < SEN , COMMA , NKO , SEM > )   ) The part of the database between the nodes nl and  n2   ( cf . Fig . 14) is selected with all parallel structures , ' dasRauchen'being analysedas'de finite article+noun '  ( in one NP ) and as ' personal pronoun + noun ' ( in two NP's )  . The expectation is to be read as follows : The first arc must be marked ' finite verb '  , the last one ' detached verbal prefix ' . Between the mone or more NP's and/or AP's ( adjective phrases ) in arbitrary distribution are expected . A full stop , comma , coordinating conjunction , or se . /colon must be the right neighbour of Z , i . e . the arc left of n2 . If these expectations are fulfilled , the partial S-graph that begins with X and ends with Z including all parallel arcs is activated for the scouts of that mission  . These expectations are so explicit , because in this way structures may ~ . ~ disambiguated quite safely . In German , most verbal prefixes may also heprepositions , cf . 
( i ) and (2).
( i ) Ergibt das Raucl~n ~ .
( Hegiw ~ supsmoking . ) (2) Ergibtein Konzert ~ IL\[der Gitarre . 
( He gives a concert on the guitar.)
The expectations described exactly fit for ( I ) , but not for (2) , and the mission activates the database accordingly  . 
I!NP!\[o----o . . . . . . . . . O!!ARTN\[nlo . . . . . . . o . . . . . . o . . . . . . . . . . . . . o . . . . . . . on 2 gibt ! das ! Rauchen ! auf !!! .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
! NP ! NP ! ! o . . . . oo . . . . . . . . . o
Fig . 14 PRD NN
The scouts used for the analysis of detached verbal prefixes are the fol\]ow ~\] g : solve RIGHT -EXPANSION solve PRE\[~VZS The firsts cout increments the predicate in the partial database between nl and  n2 until all NP's between the predicate and the verbal prefix are in the predicate's substructure  , and the seconds cout concatenates verb and verbal prefix  . The complete mission will look like Fig .  15 . 
A different approach to this problem is ' normal- ! sat!on'mentioned above  , where the verbal prefix is moved to the finite verb in the first place  . 
mission P~J ~ SE-VERBAL-PREFIXES : Fig . 15 expectations scope first(X , equal ( MS of X , FIV)mid(Y , member ( MS of Y , < NP , AP >) last(Z , equal ( MS of Z , VERBPREFIX ) right--context(R , n~mber(MS of R , < SEN , COMMA , CONJ , SEM > )   ) subproblen ~ solve ( RIGHT-EXPANSION ) solve ( PRED+VZS ) goal ( G , equal ( MS of G , PRED )) end
Feature propagation
When building syntactic structures , a parser transports features between nodes . In many modern grammar theories and formalisms this transport is achieved by unification  ( cf ? Shieber 1985 , Karttunen 1984 , Kay 1984) . For an uln ber of reasons unification has no place in the CAP-concept  ( cf . Luckhardt 1986a ) . Unification was introduced as a simple instrument  , which in fact has to achieve a very complex task . Feature propagation is too complex to be achieved by simple unification  , and if the effect of unification is differentiated  , it looses its elegance . 
In a rule like ' DET+ADJ+N=>NP'it has to be stated which features are inherited by the NP  , i . e . 
ADJ and N may have a feature FRAME , but only that of for the semantic class . 
A difference has to be made between selective ( FRAME ) and inherent features ( CASE )  . Karttunen ( 1984 ) gives an example where by unifying ' I ( CASE = NOM ) ' and ' do ' the feature CASE = NOM is inherited by the new predicate ' I do  ( CASE = NOM ) ' which is not really desirable . There are more cases where unification leads to undesirable feature propagation  . 
Especially in coordination features have to be matched explicitly which  , perhaps , is not so obvious for English . The structures in Fig .  16  ( out of the house and across the street ) have to be unified without PCASE and CASE having to match  . In Fig . \]7 ( from the conduct of Eva and her husband ) , however , the CASE-values have to match , in order to prevent the coordination of ' ausdem Verhalten ' and ' ihres Ma rules '  , and PCASE = AUS is inherited by the new NP . 
aus dem Haus und fiber die Strag . e Fig . 16 o . . . . . . . . . . . . . . . o . . . . . . o . . . . . . . . . . . . . . . . . . . o
PCASE = AUSPCASE = UBER
CASE = DATCASE = AK Kaus dem Verhalten undihres Mannes Fig  .  17 0  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  0  .   .   .   .   .  0  .   .   .   .   .   .   .   .   .   .   .   .   .   . 0! PCASE=AUSCASE=GEN!CASE=DAT!E rasO .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . O


Only those features can be unified that are car -tied by at least one of the constituents  , so that it is not easy to introduce features during the parsing mission  , which is desirable in certain cases ( cf . 
Luckbardt 1986a ) . On the other hand , it seems impossible to get rid of features that are no longer used  , like the INFL-feature ( after the agreement between the elements of an NP has been checked  )  . 
In CAP , the effect of unification is achieved by an operation that consists of a test and an action using FUSL-functions like eq  ( NUMBER of X , ~ ER of Y ) in t(FRAME of X , SCASE of Y ) n~mber(MS of X , < ARTD , ARTI , POSP , DEM , IND > assign(SF of Y , SUBJECT ) Thus explicit comparison , creation , deletion , and propagation of features is possible . 
Conclusion
CAP has to be seen in the context of automatic analysis and translation of natural language  . It commands a formalism that makes it suitable for the development of efficient parsers by allowing for extensive means to represent linguistic knowledge strategies for its use  . The way these aspects interact is currently being formalised by Thielinh is NLPT  ( Natural Language Processing Theory , cf . Thiel 1985) . 
The underlying data structure is the S-graph , which allows the management of all kinds of ambigui-essary for the linguist/user explicitly to take care of ambiguities  . Thus he/she may write rules without worrying about parallel structures  , as his-/her view of the data structure is a simple tree or sequence of trees  . There are methods , however , for indicating preference to certain structures over others  . 
Underlying linguistic features such as rule augmentation  , feature propagation , lexicalisation etc . 
that are known from GPSG , FUG , LFG etc . have been extended to cover more phenomena , espec ~ ally those encountered when parsing German . They are used in a way that allows the analysis of random samples of text in comparably short time  . 
Some special applications of CAP are- normalisation : removal of idiosyncrasies and treatment of constructions that are notorious for the problems they present  ( discontinous verb forms parentheses , etc . ) - formalisation of the complex agreement conditions on Gern~nNP's  , treatment of free word order-coping with complex forms of coordination-controlled inheritance of features-giving t ~ linguist the opportunity of determining the grade of featurisation and the depth of representation 

Bauer , M . , Licher , V . , Luckhardt , H . -D . , Sch~fer , Th . , Schworm , C . , Thiel , M .  (1985) . FUSL-eine funktic nale Sprache zur Repr ~sentation lingui-stischen Winsens und l~tiscl ~erStrateg ~ m  . 
Linguistische Arbeit endes SFBi 00 Neue Folge , Heft\]6 . Saarbr0cken : Universit ~ tdes Saarlandes Carter , A . W . , Freiling , M . J .  (1984) . Simplifying Deterministic Parsing . In : Proceedings of
Coling 1984, 239-242
Dowty , D .  (1982) . Grammatical Relations and Montague Grammar . In : P . Jacobson , G . K . Pullum ( eds . ) . 
The Nature of Syntactic Representatio ~ Dord-recht : Reidel Karttunen  , L .  (1984) . Features and Values . In : Proceedings of Coling 1984 Kay , M .  (1977) . Morphological and syntactic analysis . In : A . Zampolli ( ed . , 1977) . Linguistic Structures Processing . Amsterdam : North-Holland-(1984) . Functional Unification Grammar : a Forma-lism for Machine Translatior LIn : Proceedings of 
Coling 1984
Luckhardt , H . -D .  (1985) . Parsing with Controlled Active Procedures . CL-Report No .  2 . Saarbr?1cken :
Universit ~ tdes Saarlandes : SFB 100-(1985a) . Valenz~d Tiefenkas usin der Maschinel-len Ubersetzung  . CL-Report No .  4 . Saarbr 0cken:
Universit 6t des Saarlandes : SFB 100-(1985b) . Kontrollierte M~chti~eit : Regeln in CAP . 
CL-Report No . 8. Saarbr 0cken : Universit 6t des
Saarlandes : SFB 100-(1986) . Normalisierung deutscher Oberflachenstruk-taren\ [nit controlled active procedures  . CL-Re-port I0 .   Saarbr0cken : Universit ~ tdes Saarlandes : SFB 100  -  ( 1986 a )  . Vererbungy on Merkmal enmit controlled active prooedures  . CL-Report Noii . Saarbr ~ cken:
Universit Atdes Saarlandes : SFBI00
Luckhardt , H . -D . , Maas , H . -D . , Thiel , M .  (1984) . The SUSY-E Machine Translation System . Working Paper . Saarbr\[,cken : Universit ~ tdes Saarlandes:
SFBI00/A2
Maas , H . -D .  (1984) . Struktur und Steuerung der lin-guistischen Prozesse in SUSY-II  . In : U . Klenk ( ed . , 1985) . Kontextfreie Syntaxen und verw and te Systeme . Linguistische Arbeiten . Tdbingen : Niemeyer-(1985) . SUSY-II-H and buch . Linguistische Arbeit endes SFB 100 Neue Folge , Heft 14 . Saarbr Qcken:
Universit 6t des Saarlandes
Shieber , St . M .  (1985) . An Introduction to Unifica-tion-Based Approaches to Grammar  . Presented as a Tutorial Session at the 23rd Am . Meeting of the
Ass.f . Comp . Ling ., July 1985
Simmons , R . F .  (1985) . Technologies for Machine Translation . In : Proceedings of the Int . Symposium on MT , Tokyo , 14th Oct 1985 Thiel , M .  (1985) . Einekonzeptionelle Basisf firna-t fir lick ~ prachliche Systeme  . Paper for the GLDV-Jahrestagung \]985, Hannover . Working Paper , Saarbr0cken : Universit ~ tdes Saarlandes- ( 1985a , forthcoming ) . Weighted Parsing . In : L . 
Bolc ( ed .). Natural Language Parsing Systems.
Varile , N .  (1983) . Charts : A Data Structure for Parsing . In : M . King ( ed . ) . Parsing Natural
Language . London : Academic
Winograd , T .  (1983) . Language as a Cognitive Process . Reading , Mass . : Addison-Wesley P . C . 

