Quasi-Destructive Graph Unification
with Structure-Sharing *
Hideto Tomabechi
Carnegie Mellon University
109EDSH , Pittsburgh , PA 15213-3890

Abstract
Graphunifi ( : ation remains then lost expensive part of unificatiou-b~Lsed grammarl  ) arsing . Wefl ) cuson ( Hie 81 ee ( l-u1 ) elell tell till the design of lll llifiea-tion algorithms : avoidance of copying of umao  ( li-fled sul ) graph . s . We propose a method of attaining snchade sign through an lethod of structnre-sharing which avoids log  ( d ) overheads often associated with structure-sharil lg of graphs without any use of costly dependency pointers  . The proposed scheme eliminates redundant copying whih ~ maintaining the qua  . si-dc , q tructive scheme's ability to avoid overcopying and early copying e omlfined with its ability to handle cyclk : structures without algorithn fie additions  . 
1 Motivation
Despite recent efforts in improving graph unification algorithms  , graph unification renlains the most expensive part of parsing  , both in time and space . 
ATR's latest data fi'om the SL-TRANS largescale speech-to-speech translation project  ( \[ Morimoto , et al ,  1990\] ) show 80 to 90 percent of to t~parsing time is still consumed by graph unification where  75 to 95 percent of time is consumed by graph copying fune-ti  ( ms . 1 Qu~si-Destruetive ( QD ) Graph Unification ( \[ Tontabeehi ,  1991\] ) was deveh ) ped as a fiLst variation of non-destructive graph unification based upon the notion of time-sensit ive'qu ~ mi-destruction ' of node structures  . The QD algorithm was proposed I ) ~ Lsedup on the following m:cepted obserwttion about graph unification : Unification does not always succeed  . 
Copying is an expensive operation.
The design of t it (' , QD scheme was motiw ttcd by the following two princil  ) lesh ~ r frost gral ) hunification ba , sedup on the above observations : ? Copying shou ld be performed only for successful unifi cations  . 
? Unification failures should be found as so on as possible  . 
* This research wa . 8  ( lone while the author was ~ Visiting Research Scientist at ATR Interpreting Telephony\[O ~search 

lBased on unpublished reports from Knowledge it nd Data Processing Dept  . ATR . The observed tendency was that sen-tell CCS with very long parsing tilller equiting a large I ill tll~t ~ r of unification calls  ( over 200 l top level calls ) coll 811 lllc dextremely htrge proportion ( over 93 percent ) of total paraing time ft~rgraph unification . Similar data tep 0 rted in\[Kogure .  19901 . 
and eliminated OverCopying and Early Copying ( as defined in \[ Tomabechi ,  1991\] 2 ) and ralt about twice the speed of \[ Wroblewski . 1987\]'s algorithm , a In this pal ) er we proi ) ose another design principle f ( n'graph unification bmsed upon yet another accepted observation that : Unmodified subgraphs can be shared  . 
At lemst two schelnes have been proposed recently \]  ) a . ~ed Ul ) OU this observation ( namely \ [ Kogure . 1990\] and \[ Emele , 1991\]); however , both schemes are I ) ased upon the increlllent ' alCol ) yiugse hell leal l ( l~-LS ( \[ e-scribed in\[Tomal ) eehi ,   1991\] incremental copying schemes inherently suff crfi ' om Early Copying as defined in that article  . This is I ) eeause , when a unification falls , the copies that were ( : reated up to the point of failure are w ~ L ste ( lifcopies are created incremen-t ; all y , By way of definition we would like to categorize the sharing of struetul'e Singral  ) hs into Feature-Structure Sharing ( FS-Sharing ) ~nd Data-Structure Sharing ( DS-Sharing )  . Below arc our definitions : ? Feature-Struc ture Sharing : Two or more distinct i  ) ~ , ths within a graph share the same subgraph by ( : on wwging ( 1 11 the same node equivalent to the notion of structure sharing or reen-lrancy in linguistic theories  ( such ~ in\[Pollard and Sag ,  1987\]) . 
? Data-Structure Sharing : Two or more distinct graphs share the same subgral  ) h by converging nil the same node the not i ( mnf2 Namely . 
? Over Copying : Two dags ate created in order to create one new dag  , This typically happens when Col ) its of two input d~tgs are created prior to a destructive unific ~ L tion operation to build one new dag  . 
? Early Copying : Copiesar ~ created prior to the failure of unification so that copies  ( : reltted since the beginning of the unitication up to the point of failure are wasted  . 
Wroblewski defined Early Col ) ying as follows : " The argutnent dags are copied be/t~te unification started  . If the unilication fails then some of the Ct ) l ) ying is wasted effort " attd restricts early copying to cases that only apply to copies that are created prior to a unification  . Our definition ( ) f Early Copying includes copies that ~ rc created during a unification and created up t  ( ) the point of fltilur ( ~ width were iltt ( ! ow~red by Wroblewski's definition . 
3 Recent ( ~ xp ( ~ rilnents COlll hlctt ~ dill the Knowledge all ( \] Data Pro ( : esniugDept . of ATR shows the original QD algorithm COll siatelltly rlllSlit ~ tt ~ out  40  \] ) q ~ rctrlt ~ ff the elal ) sed tillleuf Wroblewski'8 algorithm with its SL-TRANS largescale upoken -languag  , ~ ttansl~tt lonsystem ( with overl ( t00 I grammatical gral ) h nodes )  . 
ACRESDE COLING-92 , NANTES , 2328 AOt ~ T1992440 PROC , OFCOLING-92 , NANTES , AUG .  2328 ,   1992 straeture-sharing attim data structure level . 
\[Kogurc , 1990\] cldlsColtying of sui:hstrltctures
Redundant Copy in 9.
Virtually allgral ~ ll-lutitication alg(n'itlinl , , ; suptmrt FS-Sh ~ triug and some SU liport DS-Sharing with varying levels  ( if overhead . In this lisper we prolt OSl~~t sclienle of graph unification I  ) tmedUllOnaqu ; ~si-destrtt ( : tive gratth unit i ( :ati ( minetlloll that attains DS-Sharing with virtually no over h  ( ' , adfor structure-sharing . Henceforth , in tills palter , struct ltre-sharing refers tit DS-sllariug unless otllerwise n  ( ited . Wc will see that tfi ciutroducti ( m of strlu:ture-sliari lagto qua ~ si-destructive mification art  ; tins another twofold increase illrimtiluc spired  . The graphs llamdled in the scheme (: ; titlieauy dirc ( : tedgrai ) ll and cycli ( : ity is llaudled without any algorithmic ; tdditions . 
Our design princiitles for achieving struct lu ' C -sharing in tit  ( ' , qlta . si-destructives cllell U ~ are : ? Atomic and Bot tom nodes can be shared  4 Atomic nodes can lies lt arc d sahdy since they t lever cli ~ l  , llge their w dues . B ( It tollll lodl ! sCall It ( ! share ( l5 sitt ce bottom nodes are always fl ) rwal'ded to som coth eruo ( Jeswll cn they unify . 
? Complex nodes can be shared unless they are mod if ied-conq  ) lex nodes ( : all bcCOllSld-ercd modified if they~trea target of the fitrward-ing operation m ' if riley received the curreut ad-ditiml of comlt lcment arcs  ( into COml ) -ari :- list in ( pia , si-destructives clmme ) . 
By designing an algorithm ba . sedUlt , m these pril > ( : il ) les for strlu:ture-sliarillg while retaining the quasi-destructive nature of \[ Totn at  ) echi , 1991\]'s algoritll nl , our scllmnce liniinates l , cdlnt ( tant Cllpying whih ~ el inlinating botl lEarly Copying auld Over Copying  . 
2 QD Graph Unification
We Wolddfirst like to describe tlle qu ; Lsi-destructiwe ( QD ) graph unilication schenle which is the lnLs is of ours  ( : henl (  , ' . As a data struct ltrl ~ , at nolleis rcpresent cd with live fiehls : type , arc-llst , compark-list . 
fm'w~u'd , (: oily , and geueration . 6The data structure for an at'(: has two liclds , qabel ' and ' value ' . " Lot ) el " is an atmnic symt ) ol wllicli label stile ; u ' e . and ' wdue " is allointer to all o ( lestructure . 
The central notion of tile QD algm'it lunistile del  ) eudency of the retires entational ( : on t cnt on the glob ~ d timing clol : k ( orth c global counter fortlic curr cnt generation of lUlific  ; ~ tions ) . Anyluodilic ; ~ tiol ~ made to coml ) - arc-list , forward , or i : Olly rid ( Is during one top-lcw : luniticati ( m ( : aub cinw didated by ( mein- ( : renlent otm ration in ltile global timiug counter  . COIltents of the ( xmlp-arc-list , forward and ( : opyfields arc'IA tomicl to ( \[ l ~8 ; ire I lode H(haltreprea ( ~ lltatoluic vcdue8 , lie ( lo in nodes are lloe 8 that repreuellt variabh * . 
~ As long as the unific ~ ttionOl)er , ~ tion is the only operation to nmdify graphs . 
6Note that \[ Tonlabechi , 1991\] used sellartttelltark fields f in CO ml ) - ; trc-liat , forward , fill ( copy : (: urrently however ,   ( lilyflltt general ( kinmark is used for adl three fiehls . Thanks are due to Hidehiko M~U , uo of T , ) yo Informattion Sy , tcms ( TIS ) for suggesting thin . 
NODE type + .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + are-list + .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + comp-nrc-lint + .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + ~ orward IRC + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + copy I label I + .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  + +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   . + generation I value I .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  +  .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ? Figure 1: Node and Arc Structures resl ) cctc ( l , rely wltentile ge . neration mark of the lml'-ticlll~u'node nuttches tile current glob  ; dcomat . erw due . 
QI ) graph unificatiol a hamt wo kinds of arc lists : 1 ) ar , :-list and 2) colnt ~; u'c-list . Arc-list(:Ollt ~ tins the arcs that are p(!r ln ; tu(!nl(i . e . . ordimLry gral ) liarcs ) and Cillnp-arc list contains arcs that are rally wdid during one top-h welgraph unitication oper  ; d , ion . Tim algorittun also uses two kintls of fi ) rward lng links , i . e , , l ) (! rtt la lal!nt ; IAl(l t;(!llll)Ol'&l'y , ill ( ! r l l l ~ l , llellt for war ( fill glink is the usual fm'warding linkftnmd in ottler '  ; d-gor it filns (\[ Pereir ~ t ,  19851 , \[ Wroblewski . 1987\], ctc) . 
Telnl ) or ary forwarding links arc links tlud . arc only wdid during on c toplevel unilic ~ tti ( m , Tliccurrency IIf the temporary links is ( letermiued by matching the emlteut of tim generati  ( nl field for the links witll the gl ( ibal ( : ounter ; if they nutt (: ll , the content of this tiehlis respect \[~ d7 . As in \[ Pereira , 1985\] . tile QD~dgorithlnlla . St l tree types of uodes : 1): at on fic . 2): lie(torn8, and 3): conqth!x . : at Ollli ( : tyll c nodes rep-res ( mtat ( nni ( synll ) ol values ( such ; ~ s ' Noun ') , : bettom typen ( J des are variables and: ( : ( ) lttl ) l c x t y l a c n o d e s ~ l . reIlo ( les that have art : si:ol\[litlg ( lilt of the nl . Arcs are stored in them'c qist tiehl . Tile atomic vahl (! is also storc . d in them ' c-list if the node tytt c is : at , imil : . 
: llottom nodes succeed in unifyiug withnnyuo des and the result of lint  ( it : alient ~ kestim type ~ md the value of the node tlutt the : botton an I  ) dew ; munified with . : at onli ( : nodes succeed in unifying with : bt Itt on a nodes or : at  ( lll liCllO ( li~s with the munevallle ( Stilted in the arc-list )  . Unificatio Dofan : atomicuo de with a : co\]t ll  ) lexll Odeillllte ( \[ iatclyfil Jls . : cottll ) lext aodes site ( reed in unifying with : bottolit nodes or witll : ( : OUl-l ) lextrades whose subgrlq dlsallunity . ? Figure 2 is the central qllmsi- , lestruct lw ~ graph unifi ( : ation algorithm and Figur ( ' . 3 is the dcrcfel'encing1?flulction . Fig-lit ' (?4 shows the algoritlill ; for ( : ollying ttilf l ( ! sall ( 1 ~ Lrcs ( called from lmify 0 ) wllih ~ respecting the ( : Ollt ( mts of ~ a ~4"~ x ~ ist ~ 7~1 ~ do II ( It\]l~tVe~t separate field for temporary for wtLrding links  ; instead , we desigll at ( ttile integer w due 9 to repreuent a permanent f , ~ r watding ll nk . We Ht~trt incrementing the global CO Ultterf\ [ Olll  10   , () whellever the gener ; tti ( utlu ~ trki8lIO9 , the integer vahle 11111~4te ( ltla \] the globad CO llltterv ; tl l le to reulm Ct the forwax ding link . 
8lq ottomi8 called leaf in Pereira ' u algorithm.
9 Arcwtlues are , ' always It ( Idea Lnd never synl bolie V~dlle8 because : atomic*uLd:bottom nodes lilly lie ( or \] l ( cO\]ll ( ) poillted to by luultiph : arl:x ( i . e , FS-Sh~ring ) depemlil ~ gongt 0 an nlar COll Htr . ' killtg , and we do not want arcuto ( : oltt ~ tlnterln in ~ datomic

l ? Dere fi~rel Cillgi 8 till opera ( (loll to recl lrsively traw~rae f . r-w ; trding links to return the target mille of for warding  . 
AcrEsDECOLING-92 , NANT gS , 23-28AO~"1992441I'ROC . OFCOLING-92 . NAmES , AUG .  2328  , 1992 QUASI-DI~qTnuCTIVE ~ RAPI\[UNIFICATION\]
FUNCTION unify-dg(dgl , dg2 ; result ~ catch with tag'unify-fail calling unify0  ( dgl , dg2): increment * unify-global-counter*: ; ; starts front 1( 11 ret urn ( result) ; 

FUNCTION unify0(dgl , dg2); if '* T *= unifyl(dgl , dg2) ; THEN copy ~ copy-dg-with-coml ) - arcs ( dgl) ; return ( copy ) ; 

FUNCTION unify1(dgl-underef , dg2-under cf ): dgl ~ de refer cnce-dgl-underef ) ; dg2 ~ de reference-dgl2-undercf :
IF ( dgl . copyisson-empty ) THEN dgl . copy~nil ; :; cut of fullt : ltrrent copy
IF ( dg2. copy is nonempty ) THENdg2. copy~nil;
IF ( dgl = dg2) I~THEN return ('* T *);
ELSEIF ( dgl . type=:bottom ) THEN forward-dg(dgl , dg2j temporasy ); return ('* T *);
ELSEIF(dg2 . type=:bottom ) THEN forward-dg(dg2 , dgl , : temporary ); rcturn ('* T *);
ELSEIF ( dgl . type=:atomicAND dg2 . type=:atomic ) THENIF(dgl . arc-list = dg2 . arc-list ) 13 THEN forward-dg(dg2 , dgl , : temporary : return ('* T *);
ELSE throwt4 with keyword'unify-fail;
ELSEIF ( dgl . type=:atomicOHdg2 . type=:atomic ) THEN throw with keyword ' unify-fail ; 
ELSE shared ~ intersect axcs ( dgl , dg2); forward-dg(dg2 , dgl , : temporary ); 15
FOREACH arc IN shared DO unify l ( destination f the shared arc for dgl , destination of the shared arc for dE2) ; new ~ complementarca(dg2 , dgl ); 16IF lT ( dgl . comp-arc-list is nonempty ) THENIF ( dgl . generation=*unify-gloh;d-counter *) THEN
FOREACH arc IN new DO pus has\[' . todgl , comp-arc-list , ,
ELSEdgl.colnp-arc-list ~ nil:
ELSEdgl . genera . tion ~* unify-glohal-couttter*:dgl . comp-arc-list ~- new ; return ('* T *);

Fig Lure 2: The QD Unification Functions Tit ( ' functions Contl ) lenlelttarcs ( (lgl , dg2 ) and In-119 indicates al ) ermanent for warding link . 
12 Equ Min the ' eq '8 ellse . Bec~tuae of forwarding altd cycles , it is possible that dgl and dg2 are " eq ' . 
1 3 Arc-list contains atomic value if the node is of type : atomi  (  . 
14 Catch/throw coast xuct ; i . e . , immediately return to unify-dE . 
lSThis was performed ~ dter FOREACH letup in \ [ Tonrahechi  , 19911 which couh thaw ~ c ~ . uacdit prtd demwritast tccessful cyclic call . Thanks are due to Marie Boyle of University of
Tuebing en fur suggesting the change.
16Colnplementarcs ( dg2 jlgl ) was called before unify l recur-siena in \[ Tomabechi  ,  1991\] , Currently it is moved to after all unify l recuraions successfully return  . Thanks are ; d so due to
Marie Boyle for suggestiug this.
17 This check was added after \[ Tomabechi ,   1991\] to avoid over-writilt g the conlp-arc-list wll ( ~ll it is wrltt (  , it more than once within one Ulfify0 call . Thanks are ducto Peter Neuhaus of Oniversitiid Karlsruhe for reporting this l  ) roblem . 
C;RAPll NODF"DF',F'F'FERF'NF'ING\]
FUNCTION de reference-dg(dg ): f(>rward-dest~dg . forward;
IF ( forward-dent is nonempty ) THEN
IF ( d g . generation : * unify-global-counter*ORrig . generation = 9 ) THEN de refere tu:e-dg ( forward-dent )  ; ELSEdE . forward ~ nil : :; make it GCable retura(dg ) ',
ELSE return ( rig);

Figure 3: The QD De reference Function t ( 'rsc ( 'tarcs ( dgl , dg2) return the sct-diff ( , renF ` ( "  ( the arcs with labels that exist in dgl but not in  dg2  ) and intersection ( the arcs with labels that exist both in dgl and dg2  )  . Duringth ( " sct-difl'erence and sct-iuter section otlera . tiultS , the ( , ulttent of colnp-arc-lists art " respected ms parts of arc lists if the genera  . tion mark matchs the current va . lu ( , of the globa . ltinting counter . Forward ( rig 1 , dE2 , : forward-type ) puts ( tg2 in tile for wa . rd field of dgl . If the keyword in the fun ( ' tion call is : temporary . the eurrev . tvalu ( , of the * unify-glob ; d-counter * is writtea in the generation fiehl of dgl  . If the kcy word is : perman ( , nt , 9 is written in the generation fiehl of ( lgl .   18 The temporary forwarding links are necessary to handler centrancy and cycles  . As so on a sunification ( at any level of r ( , cursion through sha . rcdart , s ) is performed , a . tem-l ) or ary forwarding link is made from dg2 todgl ( dE1 to dE2 if dgl is of type : bottom )  . Thus , during unification , a . node already unified by oth cr recursive calls to unify1 within the same unify0 c' , dl has a temporary for warding link from dg2 to dE1   ( urdgltod E2 )  . As a result , if this node becomes an int ) ut argument node , derefcrencing the node causes dg la . udd g2 tolle contetile Sall l ( , llo(lcattdunification immediately succeeds . 
Thus , a subgraph below an Mrea ( ly unified nude will not be checked in ore than once even if an a  . rgument graph has a . cycle . 19\[QUASI-DF`STI1UCTIVF , COPYING\]FUNCTION copy-dg-with-conq*-arcs ( dg-underef ) : dg ~ de referencc ~ dg ( dg-underef ; 
IF ( d g . copyisiron-emptyAND dg . copy . generation 2n ~* unify-gloh ' , d-count cr *) THEN return ( d g . copy ); 21
ELSEIF(d g . type=:atomic)THEN ncwcopy ~ create-node () ; 2 ~ new copy . type ~: a tolltic ; new copy . arc-list ~ dg , arc-list : Itew copy . geleratiol t ~* tinily-global-counter *; dg . copy ~ new copy ; return ( new copy);
ELSEIF d g , type=:bottom ) THENltewcopy ~ creat c-node l ) ; new copy , type 4~: hot tolt l ; I ~ ewcopy . gem ! rlttioll ~* unify-global-counter *; dg . copy ~ new copy ; returt t(new copy)i
ELSE 18permanent forwardings may be needled by gr~tllt lltar CO lll -pliers that merge graphs  . 
l ? Also , during copying suhaequent to amlccessful unitica - tioll  , two 0d?:8 COll vergillg into the 8&lltl ~llode will I lot c ~* , l Se ovcr copying simply because if a node already has a copy then the copy is returned  . 
AcrF , s DECOLING-92 , NANTES , 2328 AOt3T 1992442 PRec . OFCOLING-92, NANTES , AUO . 2328,1992 lieW (; Opy~(:reilt . :- node (); lle WCO py . type ~: COlllpi ~ x ; new copy . g(~neratioll ~* ltnify-glolnd-countel*:dg . col)y~-lieWco)y:23
FORALL arcINdg , arc-llst DOn ( ~warc ~ ctlpy-arc-alid-ct ) lnp-llrc ( arc ) lpllshll ( )w , % rc into new ct ) py . ttrc-li , t;IF(dg . coiup-arc-li , t is non-mnp tyAND dg . generation -* unify-glo hal-counter * ) THENFORALL c ( nnp-ar ( : INdg . conll~-itrc-li~t DO li ( ~ wlirc ~ -- Col ) y-arc-and-colllli-ltrc ( coll lp-arc ; plish liewltr cinton ? ~ w copy . arc-liut ; dg , cot np-arc-list ~ nih return ( new copy):

FUNCTION Colly-arc-aud-conq)-arc ( input-arc ; label ~- input- , xrc . labchV ~ dllOt ' ~ copy-dg-witil-coulp-arl:s ( input-arc . valul ~); return a liCW~trc with hd , elitlt dvahle;

Figure 4: Node and Arc Copying Functions 3 QD Copying+DS-Sharing In order to attainst rncture-sharing during QmLsi-Destructive gral  ) hunitication , noniodifieation is necessary for the unif ication functions descrit  ) ed in the previous section . This section describes the qua . st-destructive copying with strueturc- sharing which replaces the original copy ing algorithm  . Since uni-fication functions are unnt0d itied , the QD unities-lion without stru ( : ture-sharing e aube mixed trivially w ith the QD unificatit m with struetur c- sharlng if such a mixture is desired  ( by simply choosing differ-eat copying fime t ions  )   . Infi ) rlnally , the QD copying with structure-sharing is l  ) erformed in the following way . A tonfie and \]) ottomllodes are shared , A CO lll-plex node is shared if llo nodes below that node are changed  ( a node is considere de hange ( I by being a target of forwarding or having a valid COlnp-arc-list  )   . 
If auodeise haaged then that information is 1  ) ~ sedUl ) the graph path using multil ) le-valut ~ binding facil-ity when a copy of the nodes are recursively returned  . 
Two w dues are returned , the first value being the Col ) y ( or original ) nolle and the second value being the flag representing whethe  , rany of the node below that node ( including t , hat node ) h ; us been e hanged . Atomicaud bott onl nodes are always sharetl : however  , they are considered changed if they were at a rget of forwarding st  ) that the ' changed'inforn lation is passed up  . If theeom I ) lexnode is a target of forwarding , if no node behiw that node is changed then the ( ) rigin ; deonlple x node is shared ; however , the ' (: hanged'infornia tit)n20I . e . . the * gtill(Sratioli " fiehl of the iiodt , stored in tileq:olly ' field of the " dg ' llode  . The Mgoritln n(lescrihed in\[Tomabechi , 1991\]imt , d ~ CO lly-ln ~ rk ' fiehl of ' dg ' . Currently ' generlttion ' field replaces tile three lnltrk fiehl described ill the article  . 
21I.e .. the cx is thig copy of the ilod c.
22 Crelt to 8 finempty node 8tl liCiUr ( L ~ a'l'l li ~ of l ~ ratil ) litosetit newlyi:tl ! iited copy node into tim ' copy ' field of Mg'w ~ do lill Mter reclir SiOll in to tubgtaph ~ in tile Mgorithnl description in \[ Toinabechl  .   19911 which wa ~ it cause of iu finite D2CllrSiOll with it parlicuh tr type of cycle ~ lit the graph  . Byll loving ill > totills p ( ml tion floll lafter the recilrt don , 811 chapr(~l)hmiCall be effectively avoided . Thill lk8 it r ( 2 due to Peter Neuhaus for reporting tile prolima . 
is l > ~ Lsse(lut > when the recursion retunts . Below is the a <: tual algoritln n descript ion for the QD copying with structure - sharing  . 
\[ QI)C .   .   .   .   .   .   .   .   .   .   .   .   . s .   .   .   .   .   .   .   . . . . . . . . S .   .   .   .   .   .   . IFUNCTION copy-dg-with-conq ~- arce-share ( dg-under efI:dg ~ de reference-dg ( dg-underef )  ; 
IF ( dg , col ) yi8i to , - enlpty AND dg . ctqiy . generation=*unify-global-counter *) THEN
IF ( dg = rig . copy ) THEN ~ a new copy ~- create-i to de (   ) : new copy . typc ~-: bottom ; tmw copy . gtmt ~ ration ~* unify-gh ) b~d-ct mnter *; dg . copy ~-- newt:spy ; wdues(dg . copy . : changed):25
ELSE vMue ~( dg , col)y , : changed);
ELSEIF ( dg~dg-underef ) THEN copy-imde-comp-not-forwarded ( dg )  ; 
ELSE copy-node-cmnp-fi ) rwardedidg);

FUNCTION copy ~ node-comp-not-fi ) rwarded ( dg ) : IF ( dg , type::atolnic)THEN values(dg , uil ) ;   ; :rt ~ turn original dg with " li Och ; l l l g ( ~' f l a g . 
ELSEIF(d g . type=:bottolllTHEN wdueu(dg . nil):

IF ( d g . cmnp-arc-liatisno . -empty AND rig , generation=*unify-globaL counter * ) THE NlmW Copy ~ creatt : - node ( ) ; new copy . tylm ~ : e onwlex ; n(~w copy . genet & tiolt ~* ullify-globAl-collnter*:dg . copy ~ newct ) py:
FORALL arcINdg . arc-list DO new arc first Wdilt ~ of copy-arc - and -contp-arc-Mlltre  ( arc )  ; i ) ll sh lie witr c in to l m w cop y , arc-\]ist ; FORALL conq)-arcIN rig , cut up-arc-list DO il a wltrc ? ~ firl4 tvahlc of copy-~trc-alld-ct ) illp-arc-share ( corn\[ ) -arc ) : \] ) ufl hile W ltr ( : ilt toilew ( :opy . arc-iat ; dg . conlp-arc-list~nihwdtieulle w(:t~py , : chltltged):
ELSE state ~ Id Larcs ~ ld hdg . copy ~ rig 26, dg . gtmerittiolt ~* uliify-giol ~ al-i ; o . nt(!r*;
FORALL art:IN rig . arc-list DO itewar ? , challge ~ tl ~ (: opy-arC-~lld-t : Olllp-ar(-sh ; tr ~ ( arc ; pust new art : illt ~ arcs :
IF ( changed hasw due ) THEN state , -I : hllligl~d ;
IF ( state has vl due ) THEN
IF ( rig . copy#dg ) THENdg . copy . arc-liat , Arcs : dg . copy . type ~: complex ; vl duestlg . ct ~ py , : changed);
ELS Eliew copy ~ create-node (); new copy . type ~-: comt dex ; llew copy . getleratioll ~* tniify-gl ( ) lnd-ctnlntl ~ r * ; new copy . arc-liat ~ ~ trc ~; dg . copy ~ -- m ~ wl : opy ; vidues ( liewct ) py . : t : hallged ); ELSEdg . copy~nil ;; ; resetcopy fiekl values dg , uil):

FUNCTION copy-node-conq)-forwardeddg ); IF(dg . type::g , tomic ) THEN values ( dg . : changed ) ;   ; ; return origiaM dg with ' changed ' flag . 
ELSEIF(rig . type ~-: lmttom ) THEN values ( dg , : changed);

IF ( d g , comp-arc-li~tisu on-enipty AND dg , gener Mion : * unify-globM-counter *) THEN new copy , - create-node (): new copy . tylm * -: coil if dex ; ACRES DECOLING-92 , NAMES , 2328 AO~I 1992443 PROC . OFCOLING-92, NANTES , AUG . 2328, 1992 new copy . gencratio ~ l ~* utdfy-global-counter * ; slle ( : essfultlliticatiOllS to the totallt Ulllbcr of It llifica-dg  . copy ~ new copy:tions . Wcparsed cachs ellt cncc three times on a Sym-FOR ALL arcINdg  . arc-list DOI ) oli ( : s3620 using three t in float ontethods , namely , 
Ilew & rc ( -first value of capy-arc-and-coml ) -arc-sharc ( arc )  ; Wroblewski's algorithln , aqua , si-dcstrttctive lllethod pllsltnew & retaro new copy  . arc dist : FORALL c <> ml ) - arc IN dg . comp-arc-list D Oilewar ( : first value of copy-arc-and - ( :Olllp-ar ( :- share ( colll\] ) - arc / ; pudtnew arc into le W cg ) y . arc-list ; dg . comp-arc-list~nil:vMm~s(newcopy,:dlanged);
ELSE stale+nil , arcs ~ tail ; without structure-sharing , and aqu , % i-destructive method with structure-shariug . W c took tile shortest elapsed time for e a ( : hmetho<l ( ' W ' represents Wroblewski's algorithnl with a modification to handle cycles and wtrialllcs  29  , ' QD ' represents the < luimi-destructiven let lmd without structure-sharing  , slid ' QS ' represents the prol ) osed l nethod with structure-sharing )  . Datastru (: tures arc the same for all threedg . col)y ~( Ig , dg . gcneration +* Ulfify-glol > al-counter * ; unification methods ex ( :el ) t for additional fields for
FORALL art:IN dg . arc-list DOimwarc , changed +: CO l ) y-arc-an (- comp-arc : slare ( arc ) ; ) lII-ar-listill tile QD lnethod 8 . 8 anlefl tllctil ) ltSpush new arc into arcs ; are llsed to interface with Eal'ley~s parser and tile 
IF ( dmnged has value ) THEN stat~~cbalged;
IF ( state t its value ) THEN
IF ( rig . copy = fidg)TItEN rig . copy . arc-list ~ arcs : dg . copy . type ~: comt ) lex ; value , ( dg . col~y . :changed);
ELSE new copy ~ create-node (); new copy . type ~--: complex ; SalIICsul ) fllllCtiOllS are used wherever possible ( snch ; as creation slid access of arcs ) l , lll nilthllize th ( ! dif-fcrem : eu that are not purely algorlthl tfi < : . ' Nmnber of Copies ' represents the numl ) er of nodes created dur-ill geach parse . ' Nlllllber of Arcs ' rcprcsents then llll-ber of arcs created durill geach parse  . 
We used Earley's parsing ' algorithnl for the exper-intent  . The Japanese gralm nm'is based ontl PSG new copy . gencration ~* unify-gbJb~d-(:ounter*; new copy . arc-list ~ a ~ cs ; dg . copy ~ neweopy ; v ~ dueA ( new copy . :cllangcd);
ELSEdg , copy ~ nil ; vahte ~( d g , clmnged ); ;; considered changed

FUNCTION copy-arc-and-comp-arc-dk are ( input-arc ) ; destination , cb~tngedCol)y-rig-with-coml)-~rcs-dt are ( input- , xr (: . value );
IF ( changed has value ITItENlal ) d + in pubarc . label ; value ~ destination ; values ( a new arc witblal ml and value , : cluulged ) ; ELSE rabies ( input-arc jail): ; ; return original arc

Figure 5: Structure-Sharing Copying Functions 4 Experiments Table 1 shows the resltlts of our experiments using all HPSG-11  , ~sed sample Japanese granmtard c-vdoped at ATR br a conference registration telephone dialogue domain  . ' Unifs ' represents the totall tuln l/er of toplevel unifications during a parse  ( i . c , them unl ) er of calls to the top-lo yal " unify-dg ' , and not'tinily 1') 28 . ' US ratc'represents the ratio of 24 Currently , alll IO det larc Col ) tedillacy ch ~ il ~ order to prevent the split of the copy ~ uld the original when node above alluladl ~  . ngcd original i8 modified . T banks are due to Makoto'I'ak ~ d , a ~ i of TIS for suggesting the fix . Ofc , urue , a better method , if possihle , would be 1o copytim whole cycle only wheat at least one node in the cycle i ~ modified  , 25' Values ' retltrnnlllltil ) le values ~ rOlll ~ tflln CtioII . In our algoritlm t , two values are retunl cd . The first value is the result of copying , and the second value is ~ t flagiMicatiag if tlmre wa ~ any modificatiol t to the node or to ally of its desc  ( !n ( lallt8 . 
26 Temporarily set copy of the dg1 obe itself , 27 Multil ) te-value-hind call . The first value is homld to ' new arc ' . arid the second vahte is bt ) und to ' dumged ' . 
28 Unify lincalled several times the number ( > futtify-dg in the gtalnll & rilSC ( Iillthee Xl ) erill lCltt . For exanlpb ! nnifylwi ~ analysis ( \[Ponard and Sag ,  1987\] ) e overing l lhe-nomena such as coordination , case adjmlction , ad-junets , control , shLsh categories , zero-pronouns , interrogativ cs , WH constructs , and sonic pragmatics ( speaker , hearer relations , politeness , etc . )(\[ Yoshi-moto and Kogm'e , 1989\] . The grammar covers many of the imllortant linguistic phenomena in conversational Japaucse  . The grammar graphs which are con-vert cd front the l  ) atll equations contaiu 2324 no ( tcs , a ? W cused 16 Sclttenecs from as an lplctelet/hone con-vcrs ~ tion dialog whi  ( : hrange from very short sen-tenets ( one word , i . e . , tie ' no ' ) tordativdy hnt gones ( such as so rede hakochira karasochirani tourokuyoush , i-woookuriitashimasu ' In that case , wc\[speaker\]will send you\[hearer \] the registration form  . ') . Thus , tltc number of ( toll-level ) unifications per sentelt cewu'ic dwiddy ( from 6 to over 500 )  . 
5 Discussion:
Pereira (\ [ Percira ,  1985\] ) attaills structure-sharing I ) y having the rcsult graph share information with the origiw  , dgr~tphs by storing charges to tile'envirolt -merit '  . There will be tlle log ( d ) overhead ( where d is the nuM ) er of nodes illa graph ) associated with Percira's ntetho<l that is rcqttircd during node access to  , ~ssenfl > le the whole graph from the ' skeleton ' and the updates illthc'environment'  . Ill the proposed sd tcmc , since timar cs dircetly lloint to the original graph structures there will be no overhead till " node accesses  . Also , during unificatioli , silt cecitaltgesart ! called 3299 times for sentence 9when It nify-dg was called 480 tillies . 
29 Kogure ( \[Kogur < 1989\] ) des ( : ribe ~ It trivial time modification to Wrohlew Rki 's algorithm lo handle cycles which is used ill oltrexperillleltts  , 3tl Disjunctive quation ~ arel ) reproce H~ed hy the grammar reader module to expand into cross-multiples  , whereas il ~ ATR % SL-TraNs syRtem . Kasl ) er's method (\[ Kauper .  1987\] ) to handle disjunctive fature-strltcturesia adopted  . 
ACRESDE COLING-92 , NANTES , 2348 AOt ~ T1992444 PROe . OFCOLING-92, NANTES , AUG . 23 28,199 2sent#Unifs US rate 16 0 . 50 2 101 0  . 34 3 18 0  . 22 4 71 0  . 55 5 305 0 ,37 6 59 0 . 27 7 6 0,50 8 81 0 . 51 9 480 0  . 37 10 555 0 . 41 ii 1090 . 45 12 428 0  . 33 13 559 0 . 39 14 52 0 . 38 15 77 0  . 55 16 77 0 . 55 total 2984 ( Z for total )
Elapsodtimo(nec ) Num of Copies
WQD QS wQD q3o , 2 oo . 15 0  . 13 107 79 18 2,53 1  . 16 1  . 10 2285 1317 407 0  . 40 0  . 20 0 ,20 220 111 26 2  . 20 1 . 24 0 . 91 2151 1564 514 13 . 78 6 ,51 3  . 65 9092 5224 1220 3,20 0  . 64 0  . 50 997 549 97 0 . 21 0  . 13 0  . 11 107 79 18 3  . 17 1  . 59 1  . 21 2406 1699 401 24  . 62 8  . 11 5  . 74 15756 8986 1696 40  . 15 16  . 39 8  . 80 18822 11234 2737 4 . 60 1  . 71 1  . 41 2913 1938 555 19 . 57 8  . 24 4  . 45 13363 7491 1586 37  . 76 11  . 74 6  . 23 17741 9417 2483 3  . 61 0 . 90 0 . 50 947 693 107 2  . 50 1 . 57 0 . 93 2137 1513 428 2  . 53 1  . 57 0  . 90 2137 1513 428 161 . 23 61 . 85 36  . 7791 1815 34071 2721 ioo ~38 . 4~ 22  . 8~ 100~ 58  , 6~14~~Sd ) le 1: Comparison of three methods stored directly in the nodes  ( in the tluasi-destructiv cmaturer ) thcrc will be no ovcr head for rct lccting the changes to gral  ) hs during unitic ; ttion . We share the l ) rittciph ~ of storing changes in arcs U ) rabl cway with \[ Karttuncn ,   1986\]'s rcvtwsilfle unification and copy graphs only after as occcs shtlunification  . However , Kal'ttlll Cll ~ Snlcthod ( lot sllOtlist ! strllctllrc-sharilig . 
Also , 11 Kal'ttull cn'slllt ttll()t\[31 , whenever it destructive chaage is about to bc made  , tile attribute vahle pairs a2 stored in the body of the tlodcarcs aved ill to all array  . The dag node structure itself is idso saved in another arrlty  . The sewtlucs arc restored after the top lcvcI unification is c  ( mq ) leted . At : opyismad cprior to the rcstoratiou Ol ) cration if the unification wlus+t successful one  . )'\[' has , ill Karttuncn's lncthod , clmh node ixI the entire argull l cnt gral ) h that h i us been destructively modified must t ) crestored SCl > a ratcly by l'eXric viltg the attributc-valuess avc dill an array and rcsctting th  , ! values into the ( lagstructure skeletons sltvcd in another array . Ill the QD method . 
Olt ( ! ill Cl ' ellt to the global CO llll tcrc . q . lliav + did at call tht ' . changes made to tilt ! no < tern\[Kart tunen slid Kay  ,   1985\] suggests the use of lazy evaluation to delay dcstructive chalL ges during unificatiou  . \[Goddcn ,   1990 presents one method to delay copying until a destructive change is al  ) out to take phtcc . Godden uses delayed closures to directly imphm cnt lazy evalua-titm during unification  . While it may be concel ) tually straightforward to tak ciul van tag c of delay c  ( IcVahla-tion functionalities ill progranuning laagtlages  , actllal efficiency gain fl'on ! such as cheln c may not bc significant  . This is l ) et : aase such as chenle siml ) ly shifts t4 e time and space consmned for Col ) ying to creating and evaluating closures ( which couhl be very costly compared to ' d c f struct " operations to create CO l  ) ics 31 The discussion of Karl tunen's l nethod is ba . e , lonthe DPATR imphnuent ; ttion on Xerox 1109 machines (\[ Karttunmt ,  1986\]) . 
32I+e . , arc stru ( : turen : ' label " and ' vld\[l ( ~' \] ) ilii ' ~ illoUrw ~ cabulary . 
Num of Arcs
WqDOS 113   123   36   2441   1917   760   182   183   62   2408   2191   879   9373   7142   2272   874   797   204   113   123   36   2572   2334   710   17358   12427   3394   20323   15375   5116   3089   2712   992   14321   10218   3059   19014   13055   4471   893   983   199   2436   2185   793   2436   2185   793   97946   73950   23776   100~   76%   24~ which arc often effectively ( ) l ) timized lit many to m . . . . . . ? cial . . . . . . . l filcrs ) . \ [ Kog , l'C , 1990\]anti\[Eulelc . 19611 also use the lazy evaluation i(h' , a todel ay destructive changes . Both Kogur call ( lEme , h ~ avoid direct usage of delaye dev Muation by using pointerOln:ra-tions  . As b3m chr suggests , Kogur Cs method also requires a special dcl ) end cncy inf (  , rmation to bcmif in-tained which adds all overhead a hmg with the cost fin't raversing tiled Cl  ) cudency arcs . Also , a secon ( It ravcrs a \] of the set of dellell dell tliodes i8 required for actually pcrfl ) rming the copying . Emele proposes a method of dcrcfercncing by adding enviromnent in-forlltatiolitll d  , carries its cqtl ( Hl ( : t!ofgCl'atiollCOlll#tcrs so that a specific generation ode  ( : all I ) (~ fOlllld by traversing tim forwarding links until a node with that generation is found  . While this allows undoing destructive changes cheaply by backtracking the en-viroll lOCllt  , everytinl casp c cilic graph is to b cat : - ( : cssed the who h!gt'aphil cctlstObcrc collstrll ( : ted by following the fol'wardillg pointers , ~cqu cntildly as specitic d in the environment list  ( cxt : et ) ~ for the root node ) to find the node that shal'CS the smnegeneration number as the rootll Ode  . Therefore , similar to Pcrcira'smcthotl , there will be N log ( d ) ovcrhcadiLs-sociated with constructing t!ach graphevery tinle & gral  ) his accessed , where ( 1 is the llUillbCr of nodes ill the graph and N is the average depth of the tm viron-lll Clttal dcfcrcnc chain  , This would cause a probh ! nl if the algtl rithm is a dollt cdf in ' a large-sclde syst cmill which result graphs arc unified agidnst other graphs many times  . Like Wroblewski's method , " all three lazy methods ( i . c , Godden's , Kogure ' s and Emele's ) suffer fi'mnthet ) roblenl of Early Copyingms defined in \[ Tonlabcchi  ,  1991\] . This is because the copies that arc incrcnmntally created  u1  , to tile point of failure during the same top Acvel unification arc wasted  . The prob-lent is inherentill increlnent al copying scheme and this probhmlisel infilated completely in \[ Karttuncn  , ACRESDECOL 1NG-92 , NANTES , 2328 Aotrr 1992445 PROC . oF COLING-92, NANTES , AUO . 2328,1992 19861 and illtile QD nmtltod .   3a There is one l/o tential problent with the structure  , -sharing idea whMt is shared by each of the schemes in chlding tile proposed tnethod  . This lt all pens when operations other tll an ttnification modify the graphs  . 
(This is typical whco a parser cuts off " a part of a graph for sltbsequellt  analysisa4  . ) When suchol)-erations are perforn md , structure-sharing of t ) ottolll ( vlu'iablc ) nodes stay cause probhmts when a subgraph cott tait dog a  1  ) ottm n is shared by two different graphs and these graphs are used as argtllllellt S of a ut fification function  ( either ~ Ls the part of the same input graph or a seh mumts of dgl and  dg2  )  . When agt ' a plL that shares st bott l ) lO ( lode i NllOtIlse dill its entirety , then the , represented i : lmstraint postulated by the path leading to the bottot n no  ( h ; is no longer the same , The refl > re , when such a graph appears in the same unification aloog with so Ioe other graph with which it DS shares the same bottot n node  . there will 1) ea false FS-Sharing .   ( If the graph is used in its entirety this is not a problem since the two graph paths would unify anyway  . ) Th is problenl happens mdy when neither of the two graphs that DS-Slt ares the same I  ) ot tolll node wanultified against SO ille other graph before al  ) pearing in the santo unification , as If either was once unified , h ) rwardiug wouht have avoided this prol ) lent ) . The methods to avoid such a problent can be 1 ) As long as these convergence of bottoln nodes are used h  ) r features that are not pressed up during i ) arsing , the ln ' oblems does not affect the result of parse in any way w hMt scents the ca  , se with the gr~mtmars at ATII azl ( lCMU .  2 ) A parser call tie modified so that when it modifies a graph other than through graph unification  a6  , itet ' eatcs copies of the arcs tru ( : tures containing the bottotn nodes . 
In the prolmsedt nethod this can be done by calling the copy function without structure -sharing lle-fl  ) reaparsern to difics a grall h .  3 ) A parser can lierood ( tied so that it does not ( : litoff parts of graphs and use the graphs in their entirety  ( this should not addemnplexity ( mcc strttct ttre-sharing is introduced to unification  )  . Thus , althtmg h the space and time reductio o attained by structure-sharing  ( Jailt ) esignificant . DS-Shariag can cause l ) roblems unlessitist tsed with a eautiott ( by making sure vari M ) lesharing a a Lazy methods delayeopyiug until a destructive chaalge is to be perforlne  . d Do that unnecessary copies are not created withinal mrticula recurs  ( on into a unification function ; how over , 8 ilce each shared arc recllrsion is indellendent ( ll Oll-deterlllillistic )  .   ( ! villi if there are 11o unlteces a & rycopies created at , dliuotteparticular relalrsioll , if there is a failure in 8Ollllr other shared art : recurs ( on ( at some depth )  , then the copied that are created hysuccessful shared arc recurs  ( assup to the point of detection of failure will be conmwasted  , As long as the haste contr < fl structure retnlt in s incremental  , this is inher-(!litia the increlllent aluethod . In othe I wolds , the problem is inhereut in the seilmremental methods by definition  . 
34 For example , lnltnyparse\[ . ~ cutoff a subgraph of the path 0 hJ rapplying further rules whm zit rule is accepted  . 
35 Such cases ll tay happen whell the 8 allle rule ( such as VV augluented with a heavy use of convergence ill the bott onl nodes is applied malty times during a parse  . 
3 6Stlch as when a rule is accepted and suhgraph of O path is 
Clttoff.
does not cause crroncous sharing by using these or someothm " methods  )  . 
6 Conclusion
The structure-sharing scltem c introduced ill this paper made the QDM g  ( ~ ritlnn run significantly f~mter . 
The original gain of the QD algorit , hnt was due to the fact that it does not create ally Over Copies or Early Col > ies whereas iII crell lell tal  ( : opyillgsfllI ~ Ille inherently produces Early Copies  ( iLs defined in \[ Totnal ) echi , 19911) when a unification fails . Tilt : pro-l ) osed schenmll lakes the QD algotfflmifully i ~ v l ) i ( 1 lh~dundaltt Collies as well by only copying the lowest nodes that need to be e oI  ) ied due to dest rtt ( : tive chatlges caused by successful unifications only  . Since there will bc virtually uo overhead associated with structure = sharlng  ( except far returning two vahl ( ! sill-stead ( If oDc ' top a . sstip : chattge ( lilforltlatiollwht!llrt!-curs ( oil for copying rcturos )  , the perforn latlee of the prol ) osed strnl:ture-sharing schellle shouldllOt drop evei i when the granmlar size is significantly scaled Ul  )  . With the dent tm stratcd speed of the algorithm . 
as well as the ability to handle cyclicity in the graphs  . 
midease of switching betwemts trueture-sharittg attd non-structure sharing  , the algorithm couhllie a viable alternative to existing tttfifit : ation algorithnts used in current nature language systems  . 
References\[Emele , 1991\]E rode . M , " Unificatim t with Lazy Non-Redundant Copying ' . In Proc . of ACL-91, 1991 . 
\ [ Godden . 1990\] Godden , K . " Lazy Uuification " In Proc . of
ACL 90.1990.
\[ Katitunen . 1986\] Karttuuen . L . "D-PATR : A Deveh ) pmentEnyirOltlllelltforIJnifi ( :a . til ) it-13 muedGr 0 . llllllal rs " . In Proc . of COLING-86, 1986 . ( Also , Report CSLI-86-61 Stanford University) . 
\[Karttunen and Kay , 1985\]Katttum)n . L . ~ ndM . Kay . "8 tnu-tnre Sharing with Binary Tr(~s " . In Proc . of ACL-85 .  1985 . 
\[Kasper , 1987\] Kasper . R . " A Unifice . tion Method for Disjunc-tive Feature Descriptim ~ s  "  . In Prec . of ACL-87, 1987 . 
I Kogute , 1989\] Kogure , K . A Studyoil Feature St1*l ~ cture . ~ and Unificatim ~ . ATR Techuic M Report . TR-l-O032 .  1988 . 
\ [ Kogure . 1990\] Kogurc , K . "Strategic Lazy Incremental Copy Graph Unification "  . In Prom of COLING-go , 1990 . 
\[ Marimoto . etel , 199 (1IMorimoto , T . . H . Ilda , A . Kurem~tsu , K . 8 hikano , and T . Aizawa . " Spoken Language Translation : Toward Realizing an Automatic Telepholu ! Interprelation System "  . In P ' roc . of l ' n fo Japan 1990, 1990 . 
\ [ Pereira , 1985\]Pereira , P . " A Slructure-Sharing Representation for Unification-Based Grammar Formalls ms "  . In Proc . 
of ACL-8&1985.
\ [ Pollard ~ nd Sag . 1987\] Pollard , C . and L Sag . Infovmatio . -- based Syntax and Semantics . Vol 1 . CSLI , 1987 . 
\[ Yoshimoto and Kogure , 1989\] Yoshilnoto , K . and K . Kogure . 
Japanese Senfence Analy . ~ is by means of Phrase Strltctu . reGrammar : ATR Technical Report . TR-1-0949, 1989 . 
\[ Tolnabechi , 1991\] Tomahechi , H . " Quasi-Destructive Graph Unification " . litProc . of ACL-91, 1991 . 
\[Wroblewski , 1987\] Wrohlewski . D . " Noudestructlve Graph Unification ", In Proc . of AAAI87 .  1987 . 
AcrEsDECOLING-92 , NANTES , 2328 AOr3T1992446 PROC . OFCOLING-92, NANTEs , AUG .  2328, 1992
