An Evaluation Semantics for DATR Theories
Bill Keller
School of Cognitive and Computing Sciences
The University of Sussex , Brighton , UK
billk@cogs , susx.ac.uk

This paper describes an operational semantics for DATR theories  . The semantics is presented as a set of inference rules that axiomatises the evaluation relationship for DATR expressions  . The inference rules provide a clear picture of the way in which DATR works  , and should lead to a better understanding of the mathematical nd computational properties of the language  . 
1 Introduction
DATR was originally introduced by Evans and Gazdar  ( 1989a ; 1989b ) as a simple , nonmonotonic language for representing lexical inheritance hierarchies  . A DATR hierarchy is defined by means of path -value specifications  . Inheritance of values permits appropriate generalizations to be captured and redundancy in the description of data to be avoided  . A simple default mechanism provides for concise descriptions while allowing for particular exceptions to inherited information to be stated in a natural way  . 
Currently , DATR is the most widely-used lexical knowledge representation language in the natural language processing community  . The formalism has been applied to a wide variety of problems  , including inflectional and derivational morphology  ( Gazdar , 1992; Kilbury , 1992; Corbett and Fraser ,  1993) , lexical semantics ( Kilgariff ,  1993) , morphonology ( Cahill ,  1993) , prosody ( Gibbon and Bleiching , 1991) and speech ( Andry et al ,  1992) . In more recent work , DATR has been used to provide a concise , inheritance-based ncoding of Lexiealized Tree Adjoining Grammar  ( Evans et al ,  1995) . There are around a dozen different implementations of DATR in existence and largescale DATR lexicons have been designed for use in a number of natural anguage processing applications  ( Cahill and Evans , 1990; Andry et al , 1992; Cahill ,  1994) . A comprehensive , informal introduction to DATR and its application to the design of natural language lexicons can tbund in  ( Evans and Gazdar ,  1996) . 
The original publications on DATR sought to provide the language with  ( 1 ) a formal theory of inference ( Evans and Gazdar , 1989a ) and ( 2 ) a model theoretic semantics ( Evans and Gazdar , 1989b ) . Unfortunately , the definition set out in these papers are not general enough to cover all of the constructs available in the DATR language  . 
In particular , they fail to provide a full and correct treatment of DATR's notion of ' global inheritance '  , or the widely-used'e valuable path ' construct . A denotational semantics for DATR that covers all of the major constructs has been presented in  ( Keller ,  1995) . However , it still remains to provide a suitably general , formal theory of inference for DATR , and it is this objective that is addressed in the present paper  . 
2 Syntax of DATR Theories
Let NODE and ATOM be finite sets of symbols .   E1-eInents of NODE are called nodes and denoted by N . Elements of ATOM are called atoms and denoted by a  . Elements of ATOM * are called values and denoted by a  ,  /3 , 7 - The set DESC of DATR value descriptors ( or simply descriptors ) is built up from the nodes and atoms as shown below  . \[ n the following , sequences of descriptors in DESC * are denoted ? , ~/ J . 
1 . a CDESC for any a EATOM 2 . For any NCNODE and 66 CDESC*:
N :(?) e DES(;"N : (66) " Em . ~ sct ' ( 66 ) "E DESC"N"E DESC Elements of DESC are either atomic descriptors  ( 1 ) or else inheritance descriptors ( 2 )  . Inheritance descriptors are fllrther distinguished as being local  ( unquoted ) or global ( quoted )  . For ? CPESO * a sequence of descriptors , an expression (?) is called a path descriptor . When each element of ? is atomic , then (?) is called a path , and denoted P . 
For Nanode , Papath and ? a ( possibly empty ) sequence of value descriptors , an equation of the form N : P == 66 is called a ( definitional ) prolmrty of the node N , nalnely that the value of the path P is given by the sequence of value descriptors ?  . A DATR theory " Y is a finites e , to f definitional sentence subject to the f bllowing re  ( luirelnent of functionality : if N : 1'  == ?  6 T&N:P=--' (  ; 6Tth ( ! n ~/ ) - ~ ~ t/J t ) Smctionality thus correst ) onds to a semantic requirement that node/path pairs are associated with  ( at most ) one value . 
3 Inference in DATR
The probh'm of constructing an explicit theory of infhrence for DATR was originally addressed in  ( Evans and Gazdar , 1989a ) . In this work , an attempt is made to set out a logic of DATR state-merits  . Consider for eXaml ) le the following rule of in % rence , adapted from ( Evans and Gazdar , 1989a ) . 
NI:\['I--=N~:P'2,N~:P'2==~
Ni : l'l = '-~' ~
The prelnises are detinitional sentences which can be read : " the value of path  1'~ at node N jix ( inherited fl ' om ) the value of path P '2 at ; N2" and " the vahle of path 1 ~ , 2 at , node N2 is el " , respectively . Given the premise , s the rule lie e nees the conclusion " the value of path\['latnodeNj is  ( t " . Thus , the rule captures a logical relationship between DATR sentences  . For a given DATR theory T , rules of this kind lllay / ) e used to deduce additional sentences as theorems of '\] -  . 
In contrast , the system of in R ; renee described ill this pal ) er characterizes a relationship between DATR expressions  ( i . e . sequences of descriptors ) and the vahles they may be used to cOlnlmte . 
As an example , consider the following ( simpliiied ) rule of the operational semantics : if N1 : l ' ~= = 4  ) GT the , n
Ni : Pt ~ rt
The rule is applieat fle just in case the theory T contains a detinitional sentence N  , : t~l--eft . It states that if the sequence of value descril ) tors ( / ) on the right of the sentence valuates to (  - -> ) the sequence of atoms t t , then it may be concluded that the node/1 ) ath pair NI : I ~ also evaluates to a . Rules of this kind may be used to provide , an inductive detinition of an evaluation relation between DATR express kms and their values  . 
Both approaches to inference in DATR aim to provide a system of deductioi ~ that makes it possible to  ( teter lnine formally , for a given DATR theory 7~ , what ; follows fl ' om the stateulellts in 7 . The primary interest lies in deducing statements about the vahles associated with particular node /path pairs defined within the theory  . UnRn'tunately , the proof rules described in ( Ewms and Gazdar , 1989a ) are not su\[\[iciently general to support all of the required inferenees  , and it is not obvious that the approach can be extended appropriately to  ( : overall of the available DATR constructs . Apar-tieuiart ) rot ) hnn ( : on ( : ernsDATR's notion of nonlocal or global inheritance  . The value ( ~ xi ) resse ( lt ) y a global inheritan ( : e descriptor ( lep (  , nds on more than just the proi)er tie . s of the nodes sl ) eeified by ; he definitional sentences of a theory . In fact , it only makes sense to talk about the value of a global descrip to relative to a given context of evaluation  , or 91 obal context . Because the proof rules of ( Evans and C , azdar , 1989a ) just talk about DATR sentences , which do not make explicitre ii ' ~ r-ence to contexl  . , it is not possible to give . a satisfactory a ( : comlt of the global inheritance mechanism . 
The evaluation semantics described ill the following sections provides a perspicuous treatment of both local and global inheritance in DATR  . The , rules eapt me the essential details of the t ) roeess of evaluating DATR expressions , and for this reason silou hlprove , of use to the language imt ) lementer . 
4 Local Inheritance
As a point of departure , this section provides rules of inference for a restricted variant of DATR which lacks both global inheritance and tilt default me  ( : hmfism . This varianl ; will be refl ' ared to as DATRL . The syntax of DATRI , is as given in seeion 2 , except of course that the three forms of global inheritance descriptor are omitted  . An exami > le of a simph ; DATR ~ , theory is shown next . 
Noun : ( cat ).... nouu@un):_
Dog : ( cat ) == Noun(root ) = -- dog(sing) .   .   .   .   ( root )   ( plur )  ==  ( root ) Noun : ( sufl ) In this and all subsequent examples , an un > her of standard abbreviatory devices are adopted  . 
Sets of definitional sentences with the same node on the lefthand side are groupe  . d together and the node h ; ft implicit in all but the tirst given sentence . Als % a definitional sent ; en (: e such its Dog : ( c . at ) --=== Noun : ( , ' at ) , where the path on the right is identical to that on the left  , is written more succinctly as Dog: ( cat ) --= Noun . Similarly , nodes oil the right of a sentence a . resuppressed whe . n identical to the node on the left . 
The DATRL theory defines the propertie~s of two nodes  , Noun and Dog . The detinitional sen-te , iicesspecify values for node/path l ) airs , where the st ) eeitication is either direct ( a particular value is e?hit fited )  , or indirect ( the w flue is obtained by local inheritance )  , l % re?alnpte , the value of the node/path pair Noun : eat is specitied directly as noun  . Ill contrast , the node/path pair Dog : ( cat obtains its value indirectly , by local a ~ a Val
Definitions :
Sequences :
Evaluable Paths : if N : ( a ) == ?6T then
DefN : ( a ) ~
Seq ? === ? aN:(a ) = :: : Vp
SubN : (?) == ~ fl
Figure 1: Evaluation Semantics for DATRL inheritance from the value of Noun :  ( cat )  . Thus Dog : < cat ) also has the value noun . The value of Dog : ( plur ) is specified indirectly by a sequence of descriptors Dog:  ( root ) Noun : ( suiT )  . Intuitively , the required value is obtained by concatenating the values of the descriptors Dog :  ( root ) and Noun: ( surf , yielding dogs . 
We wish to provide an inductive definition of an evaluation relation  ( denoted ~ ) between sequences of DATR descriptors in DESC* and sequences of atoms  ( i . e . values ) in ATOM * . We write to mean that the sequences of descriptors ? evaluates to the sequence of atoms a  . With respect to the DATR/theory above we should expect that Dog:  ( cat ) ~ noun and that Dog: ( root ) Noun : ( surf ) ~ dogs , amongst other things . 
The formal definition of == v for DATRL is provided by just four rules of inference  , as shown in figure 1 . The rule for Values states simply that a sequence of atoms evaluates to itself  . Another way of thinking about this is that atom sequences are basic  , and thus cannot be evaluated further . 
The rule for Definitions was briefly discussed in the previous section  . It permits inferences to be made about the values associated with node/path pairs  , provided that the theory T contains the appropriate definitional sentences  . The third rule deals with the evaluation of sequences of descriptors  , by breaking them up into shorter sequences . 
Given that the values of the sequences ? and ? are known  , then the value of ?? can be obtained simply by concatenation  . Note that this rule introduce some nondeterminism  , since in general there is more than one way to breakup a sequence of value descriptors  . However , whichever way the sequence is broken up , the result ( i . e . 
value obtained ) should be the same . The following proof serves to illustrate the use of the rules Val  , Def and Seq . It establishes formally that the node/path pair Dog:  ( plur ) does indeed evaluate to dogs given the DATRL theory above  . 
do g == ~ dog Val s~sVal
Dcf Dog : < root ) := ~ dog Noun : < suiT ) ~sDefSeqDog : < root ) Noun : ( surf ) == ~ dogs
DcfDog : ( plur)~dogs
The final rule of figure 1 deals with DATR's evaluable path construct . Consider a value descriptor of the form A : ( B : 0 )  . To determine the value of the descriptor it is first necessary to establish what path is specified by the path descriptor  ( B : 0 ) -This involves evaluating the descriptor B : 0 and then ' plugging in ' the resultant value a to obtain the path  ( a )  . The required value is then obtained by evaluating A :  ( a )  . The rule for Evaluable Paths provides a general statement of this process : if a sequence of value descriptors ? evaluates to a and N :  ( a ) evaluates to /3 , then N : (?) also evaluates to ~ . 
5 Global Inheritance
DATR's local inheritance mechanism provides for a simple kind of data abstraction  . Thus , in the DATRL theory above , information about the plural suffix is stated once and for all at the abstract Noun node  . It is then available to any instance of Noun such as Dog via local inheritance  . On the other hand , information about the formation of singular and plural forms of dog must still be located at the Dog node  , even though the processes involved are entirely regular  . To overcome this problem , DATR provides a second form of inheritance : global inheritance  . This section provides an evaluation semantics for a default-free variant of DATR with both local and global inheritance  ( DATRG )  . A simple DATRG theory is shown below . 
Noun : < cat ) :: noun < sum == < sing ) = -"< root ) " < pint )  == " ( root ) "< surf ) 
Dog: ( cat ) == Noun < root ) == dog ( sing ) == Noun ( plur ) == Noun The new theory is equivalent to that given previously in the sense that it associates exactly the same values with node/path pairs  . However , in the DATR a theory global inheritance is used to capture the relevant generalizations about the singular and plural forms of nouns in English  . Thus , the sent~ence Noun : < sing ) =="< root ) " states that the singular form of any noun is identical to its root  ( whatever that may be )  . The sentence Noun : ( plur )  == " ( root ) "  ( surf ) states that the plural is obtained by attaching the  ( plural ) suffix to the root . 
To understand the way in which global inheritance works  , it is necessary to introduce DATR's to determine the value of Dog :  ( sing ) in the ex-alnt ) le DATRc ; theory . Initially , the global context will be the pair ( Dog , sing ) , bS " omtile theory , the value of Dog : ( sing is to be inherited ( locally ) fl'omNoun : ( sing )  , which ill turn inherits its value ( globally ) from the quoted path " ( root ) " . 
rio evaluate the quoted path , the global context is examined to find the current global node  ( this is Dog ) and the vahle of " ( root ) " is then obtained by evaluating Dog: ( root )  , which yields do gas required . 
More generally , the global context is used to fill in the missing node  ( t/ath ) when a quoted path ( node ) is encountered . In addition , as a side effect of evahlating a global inheritance descriptor the global context is updated  . Thus , after encountering the quoted path " ( root " in the preceding example , tile global context is changed from ( Dog , sing ) to(Dog , root ) . That is , the path component of the context is set totile new global path root  . 
Let T be a DATR a theory defined with respect to the set of nodes NODE and the set of atoms ATOM  . The set (: ON'X'of ( . qlobal ) contexts of 7- is defined as the set of all pairs of the form ( N , ( t ) , for NGNODE and ( . ~GATOM * . Contexts are denoted t)y C . The evaluation relation ~ is now taken to be a mapping from elements of CeNTX\]  ) ESC * to ATOM * . We write cF4 ) ~ to mean that ? evaluates to fl in the global context 

To axiomatise the IleW evaluation relation , the , DATRc rules m'e modified to incorporate the global context parameter  . For example , the rule for Evaluable Paths now be colnes : 0 t - 4  )  ~  , aCt-N : ( , ~) = -> fl

CPN : (?) ==> fl
Two sinfilar rules are required for sentences con -tMning quoted descriptors of the forms " N : ?  ) " and " ( qS ) " . Note that the context ( 7 plays no sl ) e-cial role here , but is simply carried unchanged from premises to conclusion  . The rules for Values , Definitio'ns and Sequences are modified in an entirely similar in anner  . Finally , to capture tile way in which values are derived for quoted descriptors three entirely new rules are required  , one for each of the quoted fi/rms . These rules are shown in figure 2 . 
Consider for examt ) le the Quoted Path rule.
The premise states that N : ( c  ~ ) evahm test of l in the glohal context ( N , a ) . Given rills , the rule licences the cone hlsion that the quoted descriptor '"  ( oe ) " also evaluates to fl in any context with the same node component N  . in other words , to ewd uate a quoted path " ( a ) " in a context ( N , ( f ) , just evahm te the local descriptor N : ( a ) in the
Quoted Node/Path:
Quoted Path
Quoted Node(N , .)~- N :<, ~> ~/ J

C ~ -" N : ( c ~) "= = ~ , 3(N , a ) ~ N : < o e > == :> /3
Q ~ O2(U , ~?) ~"<, ~) " ~ fi(N , , , ) ~- N : ( . ) =  .  /~
O , , o : , ( N ' , , t ) ~ - " N "= = ~ fl
Figure 2: Evaluation of Quoted Descriptors updated global context  ( N , a ) . The rules ( leal ~ ing with global node/t ) adl pairs , and global nodes work in a similar way . 
The following proof illustrates the use of tte Quoted Path rule  ( Qu % )  . It demonstrates that Dog: ( sing ) evaluates to dog , given the DATR otheory , aim when the initial global context is taken to be  ( Dog , sing ) . 
Val(Dog , root ) t-dog=-=~dog
Def(Dog , root)\[-Dog : ( root ) == ~ , logQ ' ao2(Dog , sing ) t -"( root ) "= = ~ dogDef(Dog , sing ) F-Not ,   ,   , : ( sing ) := ~ dog
Def(Dog , sing ) F-Dog : ( sing ) ~ dog 6Path Extensions and DefaultsInDATR , w flues may be associated with particular node /path pairs either explicitly  , in terms of local or global inheritance , or implicitly ' by default ' . The basic idea underlying DATR's default umchanism is as follows : any definitional sentence is applicable not only to the path specified on its lefthand side  , but also for any rightward extension of that path for which no more specitic definitional sentence xists  . Making use of defimlts , the DATRc : theory given above can be expressed more succinctly as shown next  . 
Noun : ( cat ) - - - : noun < ~ ing > -=" < root ) "  ( plur ) = : :" < root > " ( still )   (   . , , ft-)--= . 
Dog : 0== Noun(root ) == dog
Ilere , the relationship between the nodes Dog and Noun has effectively been collapsed into just a single statement Dog:  0 == Noun . This is p0s-sible because , the sentence now corresponds to a whole class of implicit definitional sentences  , each of which is obtained by extending the paths found on the left-and right hand sides ill the same way  . 
Accordingly , the value of Dog : cat ) is specified implicitly as the value of Noun : ( eat )  , and similarly for Dog: ( sing ) and Dog: ( surf . In contrast , the specification Dog : root == Noun :
ValCt-cx ~ a
Definitions : if a is the longest prefix of a 7s . t . N : < a ) - - - - - - - ? C T , then
C ~ ? ~ f l

Sequences :

CF ?? ~, aft
Evaluable Paths:
Sub1
Ct-N :< ?> === ~ fl
C\[-"N:(?>":::=~,flSub2
Sub3c~-"<?>"=%,~
Quoted Descriptors : ( N , ~) ~ N :< ~> ~
C~-"N :< a ) "= : : : ~ , fl(N , aT)I-N : ( a ) := : : V ~ fl(N ,  ~ . ?) ~ "<~>" ~

Quo ~( N,aT ) ~- N : ((~> == ~. y/3
Q~tO3(N ', a ) ~-" N "= : : : ~, fl
Path Extensions :
CFN:(c ~7) ~ fl
EztCVN : < o ~) == : ~. ~ fl
Figure 3: The Evaluation Semantics for DATR ( root does not follow ' by default ' from the definition of Dog  , even though it can be obtained by extending left and right paths in the required manner  . The reason is that the theory already contains an explicit statement about the value of 
Dog : root.
The evaluation relation is now defined as a mapping from elements of CONT ? DESC*XATOM *  ( i . e . context/descriptor sequence/path extension triples  ) to ATOM * . We write : tonman that ? evaluates to a in context C given path extension  7  . When 7= e is the emi ) ty path extension , we will continue to write C~-?~c ,  . 
A complete set of i ifference rules for DATR is shown in figure  3  . The rules for Values , Sequences and Evaluable Paths require only slight modification as the path extension is simply passed through from premises to consequent  . The rules for Quoted Descriptors are also much as hefore  . 
Here however , the path extension 7 appears as part of the global context in the premise of each rule  . This means / ; hat when a global descriptor is encountered , any path extension present is treated'globally ' rather than ' locally '  . The main change in the Definitions rule lies in the conditions under which it is applicable  . The amended rule just captures the ' most specific sentence wins'de fault mechanism  . Finally , the new rule for Path Ezten-sions serves as a way of making any path extension explicit  . For example , if Dog : ( eat evaluates to noun , then Dog : ( also evaluates to noun given the ( explicit ) path extension cat . 
An example proof showing thai ; Dog : < plur > evaluates to dogs given the DATR theory presented above is shown in figure  4  . 
7 Conclusions
The evaluation semantics presented in this paper constitutes the first fully worked out  , , formal system of inference , for DATR theories . This fulfills one of the original objectives of the DATR programme  , asset out in ( Evans and Gazdar , 1989a ; Evans and Gazdar , 1989b ) , to provide the language with an expl Mt theory of inference  . The inference rules provides a clear picture of the way in which the different constructs of the language work  , and should serve as a foundation for future investigations of the mathematical nd computational properties of DATR  . Although the rules abstract away from particular imple In entational details such as order of evaluation  , they can be rea & ily understood in computational terms and may prove useful as a guide to the construction of practical DATR interpreters  . 

The author wishes to thank Roger Evans , Gerald Gazdar and David Weir for suggestions and comments relating to this work  . 
References 1 , ? ancois Andry , Normanlh ' aser , Scott McGlashan , Simon Thornton , and Nick Youd .  1992 . Making DATR workt br speech : lexicon compilation in SUNDIAL  . Computational Linguistics , 1 . 8(3):245 267 . 
Lynne Cahill and Roger Evans .  1990 . An application of DATR : the TIC lexicon . In Pwcecdings of the 9th European Conference on Artificial Intelligence , pages 12(1125 . 
Lynne Cahill .  1993 . Mort ) honology in the lexicon . In Proceedings of the 6th Confc . rcnce of the European Chapter of thc Association for Computational Linguistics  , pages 87-96 . 
Lynne Cahill .  1994 . An inheritance-based lxicon for message understanding systems  . In Proceedings of the dth ACL Conference on Applied Natural Language Prvccssing  , pages 211212 . 
Greville Corbett and Normanl ~' aser .  1993 . Network morphology : aI ) ATR account of l/ . ussian nominal inflection . Journal of Linguistics , 29:113142 . 

Val(Dog , root ) bdog ~ dog(Dog , root ) ~- Dog : ( root ) ~ dog(Dog , plur ) I -" ( root ) " ~ dog
DefVal(Dog , plur)I-s == ~ s
Qu?2(Dog , plur ) ~- Noun : < surf)~s
Seq(Dog , plur ) I -" ( root ) " Noun : ( sufD ~ dogs ( Dog , plur)I-Noun:(plur)~dogs
E : l:t(Dog , plur)\[-Noun:0~plur(logsm:f(Dog , plur)FDog:(plur)~(logs /) ~
Figure 4: Proofutilising dcfmJ ts
Roger Evans and Gerald Gazdar . 1989a . Int brence in DATR . In Prvceedings of the 4th CoT@fence of the European Chapter of the Association for Computational Linguistics  , pages 6671 . 
Roger Ewms and Gerald Gazdar .  19891) . Tilesem~m-tics of DATR . In Proceedings of AISB-89, pages 7987 . 
Roger Evans and Gerald Gazdar .  1996 . DATI : Abm-guaget br lexical knowledge representation  . Computational Linguistics 22(2) . Also available as CSRP 382 , School of Cognitive and Computing Science , The University of Sussex and Technical report 95-15  , ITtH , University of Brighton . 
Roger Evans , Gerald Gazdar , and David Weir .  1995 . 
Encoding lexicalized tree adjoining grammars with a nonmonotonic inheritance hierarchy  . In Proceedings of tile 33rd Annual Meeting of tile Association for Computational Linguistics  , pages 7~84 . 
Gerald Gazdar .  1992 . Paradigm flmction morphology in DATR . In Lynne Cahill and Richard Coates , editors , Sussex Papers in General and Cornputational Linguistics  , munber CSRP 239 in Cognitive Science Resem'ch Papers , pages 45-53 . University of Sussex,

Da\[ydd Gibbon and Doris Bleiching .  199\] . An ILEX model tbr German coln pound stress in DATI  /  ,  . In Proceedings of the FOR , WISS-ASL Workshop on
Prosody in Man-Machine Communication.
Bill Keller . 1995. DATR theories and DATR models.
In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics  , pages 5562 . 
James Kilbury .  1992 . Pardigm-base derivati 0 nal morphology . In Gnenther Goerz , editor , Proceedings of KONVENS 92 , pages 159168 . Springer,

Adain Kilgariff .  1993 . Inheriting verb alternadons . 
In Proceedings of the 6th Conference of ttle European Chapter of the Association for Computational 
Linguistics , pages 213221.

