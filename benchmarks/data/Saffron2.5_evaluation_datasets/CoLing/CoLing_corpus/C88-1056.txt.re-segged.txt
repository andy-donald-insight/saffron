ILK' , AI' , LY ~ V ~ NS\]<%i ~ kq AND DEPENDENC ~ IPIHRSING
J ~ ppinen , hrri , Imssila ~\] ~ ro~mld Lehtola , Aarr~

SITRA Foundation
.P . OoPlox 329~   00121 Helsinki ~ VINIAND ' BJ-::~paper desc\[J . ~s the notion of \] p call . y gove ~: nedt ~: ees as an < x \] el of sttuCtu17ally \[ estrfcted dependency st ~ : uctures of sentenc . eSo 2~n abstractum chine and its supporting softwa ~: eto  *  . the building of locally go qerned t ~: ees is intr_ ( ~ iuced . The rest of the paper dis~:usse , q\[ . ewuua M\]iguous ~~<-'\] . \]- for , ~dlocal \] y governedi:~:ees can be parsed illl . i\[~ea ~: tia ~ ~ ~ encxertain ~ ' tructural ~ x ~nstr~int's a ~ einfuzceo'i ~ lephrases t ~  . ucture 1 . ttle is a widely used primitive m ) tation in literature when synt~Ictic structures of ~euteuces d~?e discussed in arJ  . gorous ~ f ~ nneroAn  ~ ajorityo ; 5 syntactic ~ ; : ~ rsJ . ngpr ~ jratt ~ also utilize phrases t ~ . 0cture rules in one vary or another ? Phrase : structure rules reflect the i~Kl-diate  79nstihuent analysis of sentences ? Fach :1lle names a ~ x ) nstituent 6 rodits specified ordered e\] . ~-\[~ nts on the lower levc\] . o~ts primitive , ~\] ations are ~ erefo ~' epart . ~of-a-- . ~ ho \] eandoon catenation o In parsing , phrase structure rules arc used to s~u . ' chahier archical c~nstituen ~ orgs nizatiop of the word string of a sentence oPhrase structure ~\] es discover the hierarchics lorganization of a sentence ~ but they do not tell  . whd ch words are the heads of the phrases ( save file X-trot theory/Jackendoff 1977/ ) nor de they further:sf?e<cify % ~ lety\[x~s of the structural relations ? Depend lency grau ~-/ rs ? incxontrast ~ indicate the  bi1~ary re )  . atious that hold between the words in sentences / ~ @ ys\]  . 964 ~?-/ aifamn\]9 65 , Robinson 1970 , 2 ~0 m \] erson 1971 ~ Hell wig 1986 , St ~ trost m 1986/ . Neithernon . 4 ~= ~ rmim ! lsy~i  ~ ol . snor phrase struct \[~ erules have any ; coletoplay because constituents are not looked for  , , A p~ser which ~0ploys dependency rules ( rather than pbras , ; structure rules ) nmkes the beads and the\[types of binding celations explicit  , but does not indicate the hierarchical constituent tx\]n figurations of ~ sentences explicitly ? We argue that dependency gra  , ~ nars suit ~ yet-er than phrase structure rnles to non-oon figt ~ ational ~ free-word ~ rder languages ~ \]\[ nsofi ~ rasdefxm dency r'elations are local  ( that is ~ they hold bet ~ . en adjacent words or trees ) and @ ~ trttctive ( that . i . s ~ are cxx\]nized dependant is rex~oved p~o ~ , ~ ) 'tly from processing ) deten ~ inistic parsing in ' line . arti ~ , e often results ? Fig = laillustrates this point for a si~zple intransitive-verb Finnish sentence ~ q  , ienen ~- ~ jan " ~ it it ~ uroi " ( A/the ~ sllboy's ~ K ) the r/
Adj ~ t tvC ~ t t ? Subject ~ = uuvui/
G ~ i - . Subjcd . / ~ aje ( ~G~s=~hthfJ~J~ttrGo~tlrSubjectt~J~t\]r '~-
Obj ~ tl , mul ~, i
Subject , /" ~ Object ~ lV ~ ttr . .~ tl laulu =* ~ ojall . /hdj Attr
MJ ~ ttr/~uskanple ~ ub ) A r ~ ) n-nK ) no to nous dependency tree
Fig ? I . Parsing dependency trees
Linear time is preserved in parsing also in many typical Finnish non-monotonous dependency trees if t~s a default control rule raw or d  attenK0ts first to governits left neigh~ro ~ is strategy is natural for Finnish as most i ? odifie L's are of prepositional type ? This rule was already  ini01J  . citJnFig ? la .   ( There are of cx ) urse exceptions which must over rule this default strategy  . 
For exan ~ gle , prepositions have their dependants , not their regents ~ on their right side . ) Finnish sentences have typically SVO structure . 
Fig ~ ib shows the l ~ rsing of an ordinary transitive-verb sentence " Pienen pojan ~\[ iti lauloi hauskan laulu ~ l "  ( A/the small boy'sr ~ athers angamerry song )  . Parsing steps are indicated by the numbers between the words  . 
This roper elaborates the locality principle in de ~ endency parsing  . First , we specify the ideas of local goverm~ent and locally governed trees ? Then we describe a ~ msic machine and its supporting software as an i ~ Kolementation of the locality principle for \] ~ rsing arbitrary locally governed trees  . ~\] e parsing syste ~ l has been it Kole / ~ ented for Finnish  . Occasio ~ lly our parser invokes expensive search because no prerequisites restrict trees  ( save locality )  . We discuss how parsing can be speeded up into linear time if certain rmtural structural constraints are inforce  . 
LOCAL CaOVF/RNMEN TrLOCAL LYGOVERNF a3'IR~ES , AND
DE~PENDENCY PARSING
The ideological mlder pinning of local dependency parsing is to focus on adjacent word pairs and see if a binary dependency relation holds between them  . The words of a sentence l~ve various attributes in our parser ? Some of the attributes have been extracted by a Iro~l ~ bological preprocessor/J ~ ippinen and Ylilammi  1986/~ while others are tagged during the parsing processo 
Local C ~) verm ~ nt
Let < wIw2 . . own > be an ordercml list of words ? We say that a ~ K  ) rdwj locally governs another word wj if j = i1 or i + lanti wiRwa where R is a binary dependency relatl on such that wi is the governor  ( or the regent ) of the pair and . wj is the de~dant ? In other words , a word locally governs another one if they are adjacent  ( at the ~ mt of the testing ) and a dependency relation holds between them . 

The governor alone represents its government : once a local government has been established between two adjacent words the dependant is linked with the governor and disappears thereafter from sight  . An elementary destructive processing step takes place  , reducing the number of visible werds by one ( shown by arrows in Fig . i ) . 
Government is transitive . If wilocally governs wj , and wj locally governs Wk , then wig over nsw k . 
G6 vernment-is also antisy~retric and irref lexive.
Locally Governed Trees
Due to the destructive processing step explained above  , a governor gets a new neighbor immediately after a local government has been built  . This new nelghbor qualifies for a local government as well  . A single word may therefore locally governa number of other words  , and two initially distant words may later on establish a local government between themselves  . If a word is the governor of several words simultaneously  , we say that it governs a locally governed tree of depth one  ( LGT-I )  . In fact , we can view a ( binary ) local government as a LGT-I having just a single branch  . 
LGT-I's are elementary trees . Relational trees which preserve the locality principle and can reach arbitrary depth are called locally governed trees  ( LGT )  . LGT's are defined recursively as follows : i . Any LGT-I is a LGT . 
ii . A tree formed by a word which locally governs
LGT's is itself a LGT.
\[~ t < wIw2 . . . Wn > be a sequence of words . If there exists a LGT which governs all the words  , the LGT is a parse tree of the words . Figure 1 portrays two parse trees . 
Parsing Strategy
In the implemented parser the parsing strategy is based on the following two control principles :  ( i ) parsing focuses first on the leftmost word ( the initial word principle )  ;   ( 2 ) the parser always tries first to establish a focused word as a governor to its left neighbor and then shifts focus to the right neighbor  ( preferred direction principle )  . 
The resulting parsing strategy is a left-corner-up strategy  . The strategy is tuned to efficiently bind prepositional attributes as dependants  . 
TI~EMACHINE
We have designed and implemented a parsing system for LGT's  . The underlying abstract machine has one focus register and two stacks which bold the left and the right contexts of the focused word  , respectively/Nelimarkka et al1985/ . Locality is enforced by permitting a focused word to bind dependants only from top of either stack -the left stack being preferred  . 
The machine has also instructions for contextual testing  . These tests may penetrate the stacks . 
THESOFTWARE
A high-level language FUNDPL ( Functional Dependency Parsing Language ) was designed for parsing locally governed trees / J ~ ppinen et al  1986b  / . A precursor w~s a more procedural language DPL/ Nelimarkka et al  1985/  . The system includes a con~piler and supporting progranming environment for the developmental work/Lehtola et al  1985/  . 
A grammar description has three parts in FUhDPL.
The initial part declares data types . The second part describes valid binary dependency relations  . For each named binary relation the user specifies valid word pairs using morphological and/or lexical attribute values  . The notation permits concise use of boolean operations on attributes  . 

The third part of a grammar description defines a set of functional schemata  . Functional schemata have beth declarative and procedural readings  . From the declarative point of view , functional schemata define a set of valid LGT-I ' s  . Each schema describes are gent and its possible local governments ? A local government is either mandatory or optional  , and an option alone may recl ~ By default the surface ordering of local gover ~ nents is free  . 
Sometimes stringent ordering constraints exist l~t ~een local governments  ; sometimes it is advantageoust ~ give probabilistic information about the ordering of positionally free governments  . Such structural information may be written in a schema  . 
Schemata have also procedural reading which is yet another distinguishing feature from phrase structure rules  . A schema actively controls the build-~up of the LGT-I it represents  . From the preoedural viewpoint a schema monitors function calls of local governments using blackboard control regime/Valkonen et al  1987/  . 
THE SEARCH PROBLE MO FPARS ING ARBITR ARYLG TgS To discover a parse tree for an arbitrary If & T is a complicated search process even in a bettom-up strategy  ( in topdown problems would be worse ) ? The basic problem is this : how does an algorit ~ n know on which level in the hierarchy a given word belongs to ? That is  , when parsing proceeds from left to right and an attempt is made to establish the right neighbor of a governor as a dependant  , the link is possible only if that word is not a governor of a yet incomplete T~To Our left-corner -upstrategy occasionally has to invoke coraplex search for this reason  . 
If a language constrains the structures of its possible LGT's  , LGT's become computationally much more economical devices  . The problem discussed above does not arise with constituent grammars and phrase structure rules because these rules indicate hierarchy implicitly through the naming of the constituents  . 
CONSTRAINEDLGT'S
Finnish is a highly inflectional , agglutinating language . Both verbs and nominals have numerous distinct surface forms which distinguish between different syntactic functions the words can have in sentences  . Wordforms carry , among other things , such syntactic information which in configurational languages is indicated by the precedence relation  . Word order in Finnish is relatively free . 
The basic Finnish sentence configuration is SVO . a subject LGT is followed by a verb , an object LGT , and possible adverbial LGT's . Topicalization , wh-movement , and other movements create variations to this basic configuration  . 
The shape of nominal LGT~s is markedly distorted.
They have almost all modifiers on their lefthand side forcing them to lean to the right  . The most important modifiers are adjectival and genitive ? Adjectival attributes modify the head noun iteratively f as in the phrase  ( i )  . 
( i ) Nu oripit k ~ vieh ~ t t ~ v ~ tytt 6
Youngt all charming girl
Genitive attributes , themselves nominals ~ im~dify head nominals recursively  , as in the phrase (2) . 
(2) X~tSn is ~ ntySnantajan auto
Girl ( gen ) father ( gen ) employex ( gem ) car ( A/the girl's father'ses loloyer ' Scar ) Other prepositional modifiers for nouns are quantifiers and demonstrative pronouns  . Prepositional modifier types can be mixed ( under certain restrictions ) as in the phrase (  3 )  . 
(3 ) T ~ m ~ n nu or envieh ~ t t ~ v ~ nt ytb ' nvan hakiero is ~ This young charming girl  ( gen ) old crooked father ( This young charming girl's old crooked father ) Prepesitionality of Finnish is also demonstrated by the fact that postpositions are common but preposition  . 3 rare . Nouns have also occasional postpositio , ~ll nondnal modifiers , but these modifiers can be governed only by the maximal nominal heads of a LGT  ( the governors which fill the valencies of verbs ) or by a nol Jler postpositionally modifying r ~ T . For example , the nominal phrase ( 4 )   ( 4 ) suuren ~ niehen pieniau total on takana bigman ( gen ) small car ( nor a ) house ( gen ) behind ( a / the bigman's small car behind the house ) has the I ~ . I ', . ~ shown in Fig .  2 . The postpositionally n~xlifying adverbial LGT " talontakana "  ( behind the house ) cannot modify the genitive attribute : * suuren miehent alont akana pieniauto  . 
Gon Attrauto Adv Attr ? . ~-~-~ im~ehen ~ Ad Attr " tr'-'~II~akana
AdjA ~ ra ? " IJie ~ i " talol ~ Objoct

Fig . 2? Postpositional modifier.
ANEFFICIENTPARSING ALGORITHMFORLGT'S The basic left-corner-up algorithm can be modified so that it hierarchically first builds nominal LGT's without  post0ositional modifiers , then LGT's governed by prepositions and postpesitions  , then mgminal IGT's with postpositional modifying nominal LGT's  , and finally the LGT governed by the finite verb . The structural constraints of LGT's prune search , and it can be p~oved that the algorithm 1~en parses unambiguous sentences in linear time . The following restrictions are assumed : io Adjectives  , quantifiers , and adverbs have nnly prepositional modifiers . 
ii . Nouns have postpositional modifiers only on the maximal level  . On lower levels they have only prepositional modifiers  . 
AMBIGUITYA ~) WELL-FORM ~ DNESS
The modified algorithm presumes that LGT's are unambiguous  . None of the bound dependants should not qualify as a dependant to any other governor than the one chosen  . Because the algorithm removes dependants after binding  , it cannot cope with alternative relations . 
Albeit rich morphology greatly helps to make unique distinctions between different binary relations in Finnish  , it leaves some residual ambiguity . The most prominent example is caused by the genitive surface case  . That ~ mse signals either accusative case , the object of a ~ , ~ entence , or possession . The governor of an adverbial n~i ~ also be ambiguous  . The basic algorithm solves ambi9%~ity by backtracking . 
In their " pure , form beth algorithms parse only wellformed\]~T ' s  . 'Ilhereare , however , soa ~ . ~ wellknown syntactic phenomena which cannot be represented by iGT's  . TG-theory postulates oer tain transformations which result in long-distance dependencies  . In modern GB-theory tl~se displacement operations  9~  ) under the general rubric " move-alpha " . 
For exanple , certain fronting n ~ vements ( wh-movement and topicalization ) remove an element and may transport it across clause boundaries onto a landing site in the beginning of the main sentence  . AI~T which originally was governed locally becomes distant to its governor and is no more within its reach  . 
The algorithm can be augmented to handle long -distance fronting movements  . At one point the algorithm has built nominal and adverbial LGT's  . The valencies for a verb are filled first locally and  , if a filler cannot be found , a search is made from the fronted LGT's . The resulting LGT is not wellformed . 

We have introduced the notions of local government and locally governed trees to express restricted dependency structures  . Theirecmputational counterparts are binary dependency relations  ( for local government ) and functional schemata ( for locally governed trees of depth one )  . We then briefly mentioned a parsing system which we have implemented for parsing dependency structures of Finnish sentences  . We then discussed how the algorithm can be augmented into a multilevel model which takes into account varying structural c~n straints in different levels of sentence hierarchies  . Linear parsing time ensues for unambiguous wellformed locally governed trees  . 

Anderson , J . M . , Dependency and grammatical functions . 
Foundations of Language 7, 1971, 3037.
Gaifman , H . , Dependency systems and phrase-structure systems . IInformation and control 8, 196 5, 304-337 . 
Hays , D . , Dependency theory : a formalism and some observations  . Language 40,196 4,511-525 . 
Hellwig , P . , Dependency unification grammar ? COLING'86,
Bonn 1986.
Hudson , R . , Arguments for a Non-transforn ~ tional Grammar . The University of Chicago Press , \]976 . 
Jackendoff , R . , Xbar Syntax : A study of Phrase Structure . Linguistic Inquiry , Monograph Series
Two , The FLIT Press , 1977.
Jgppinen , H . and Ylilammi , M . , Associative model of morphological analysis : an empirical inquiry  . 
Computational Linguistics , Vol . 12, No . 4, 1986a . 
J ~ ippinen , H . , Lehtola , A . , and Valkonen , K . , ~% mctional structures for parsing dependency constraints  . 
Proc . COLING86, Bonn , 1986b.
Lehtola , A . , J ~ ppinen , H . , and Nelimarkka , E . , Language-based environment for natural language parsing  . Proc . 2nd EUROACL , Geneve , 1985 . 
Nelimarkka , E . , J ~ ippinen , H . , and Lehtola , A . , Parsing an inflectional free word order language with two-way finite automata  . In O'Shea , T . ( Ed . ),
Advances in Artificial Intelligence.
North-Holland , 1985.
Robinson , J . , Dependency structure and transformational rules . Language , Vol . 46, No .  2, 1970 . 
Starosta , S . and Nomura , H . , Lexicase parsing : a lexicon-driven approach to syntactic analysis  . 
OOLING'86, Bonn , 1986.
Va\]\]~onen , K . , J ~ ippinen , H . , and Lehtola , A . , Blackboard-based dependency parsing . IJCAI87,
Milan , 1987.

