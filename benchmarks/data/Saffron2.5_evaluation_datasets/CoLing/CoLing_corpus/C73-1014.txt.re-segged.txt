G/J NEY G6NEN g
UNIQUE DECIPHEKABILITY OF CODES
WITHCONSTRAINTS
WITH APPLICATION TO SYLL ABIFICATION
OFTURKISH WORDS
1. INTRODUCTION
Information lossless automata were first studied by D  . A . HUFFMAN (1959) . Huffman also devised tests for information losslessness  ( IL ) and information losslessness of finite order ( ILF )  . By treating finite State machines as encoders and decoders  , the tests for IL and ILF can be applied to coding theory  . This is done by S . EV  ~ . N(1962 ,  1963 ,  1965 ) who devised testing methods for unique decipherability  ( UD ) and unique decipherability of finite delay ( UDF )  , concept shown to be parallel to IL and ILF . 
In this paper , tests for UD and UDF for codes with constraints are investigated  . The basis of the proposed method is Even's procedure  . 
The constraints are of the form " codeword X never follows codeword Y " for specific ordered pairs  ( X , Y ) of codewords . 
The need for testing UD and UDF for codes with constraints originally arised in the syllabification prob\]em for Turkish words  . The problem is , essentially , to find an algorithm for syllabification of words for a given printed Turkish text  . The construction of syllables in Turkish language is very regular and hence it is not difficult to find such algorithms intuitively  , by trial and error . By a thorough analysis of the UD and UDF properties of printed word-syllable structure conversion  , it is also possible to investigate he effects of the flood of foreign  ( mostly French ) words on the syllable structure of Turkish . 
In part 2 some basic definitions are given . In part 3 Even's procedure for testing UD and UDF is discussed briefly  . The test for codes with constraints i presented in part  4  . Finally , in part 5 , applications on Turkish syllable structure are discussed briefly  . 
184 GUNEY GONEN ~2 . NOTATION ANDBASICDEFINITIONS tSource symbols will be shown by capitaletters A  , B ,   . . . . . L,W,X,Y,Z . Code symbols will be shown by 0 and 1 . A concatenation fafinite number of code symbols is called a codeword  . A code consists of a finite number of codewords offmite length  , each representing a source symbol . A coded message is obtained by concatenating code words  , without spacing or any other punctuation . Variable-length codes in which codewords are not necessarily of the same length  , will only be considered . 
A code is said to be uniquely decipherable if and only if every coded message can be decomposed into a sequence of codewords in only one way  . A code is said to be uniquely decipherable of finite delay N if and only if N is the least integer  , so that the knowledge of the firstN symbols of the coded message suffices to determine its first codeword  . 
3. TESTSFORUD ANDUDP
By treating finite state machines as encoders and decoders  , tests for UD and UDF can be converted into tests for IL and ILF  ( S . EVEN , 1965; Z . KOHAVr , 1970) . Without going into tests for IL and ILF , we shall give Even's testing procedure for UD and UDF here  . At the same time we shall demonstrate the procedure on a binary code T which consists of  4 codewords :
A = O , B = IO , C = 01, and D = 101. ~
Procedure 1.
(! a ) Insert a separation symbol S at the beginning and end of eacl ~ Codeword in the code  .   .   .   .   .   . 
( lb ) Let codeword X be of length n . Inser the separation Symbol X i between it hand ( i+1 ) -th symbol of Codeword X for 1~i~n1 . Do 1 Basic definitions in parts 2 and 3 follows Z . KOHAW (1970) . 
If 0 denotes vocal and I denotes consonant , henA , B , C , and D are four of the 12 syllable types of Turkish . 
UNIQUEDECIPHERABILITY OF CODES WITH CONSTRAINTS 185 this for all codewords for which n ~> 2  . For example , after steps ( la ) and ( lb ) , D = 101 becomes D = S1DIOD zlS . 
( lc ) The separation symbol to the right of the code symbolt is called the t-successor f the separation symbol to the left of the same code symbol  . 
For example , D1 is the 1-successor fS , D2 is the 0-successor fD1 , and S is the 1-successor lD2 , in codeword D . 
Two separation symbols are said to be compatible if  ( I ) They are t-successors of S , for some code symbol t , or ,   ( II ) They are t-successors of two separation symbols which are themselves compatibles  . 
If ( WX ) is a compatible pair , and if Y and Zaret-successors of W and X , respectively , then the compatible pair ( Y Z ) is said to be implied by ( WX ) undert . 
Construct a testing table as follows : the column headings are the code symbols  . The first row heading is S . The entries in the first row are compatible pairs found by  ( I ) above , under corresponding columnt . 
The other row headings are the compatible pairs . The entries in row ( WX ) , columnt , are the compatible pairs implied by ( WX ) undert . 
The testing table for code T is shown in fig . 1.
code T
A : 0.....
B : 10
C:IO1-
D : 101
A:SOS
B:S1B~OS
C:SOGlS
D : S1DtOD , IS

B,D,(SD ,) sB,(sc ,)( ss)
SD , ( C,D , ) ( SD , )

C ~ D , ( sn , )( so , )( sn ,) ( SD ) ( ss)
Fig .  1 . Code T ( ld ) If the table contains pair ( SS ) then the code is not UD , otherwise it is LID . Since there are ( SS ) pairs in the testing table for code T , it is not LID . By tracing back the compatibles , tarting from a ( SS ) pair , one can arrive the symboS ( possibly through several paths )  . 
The sequence of code symbols corresponding to this traceback path gives an ambiguous message  . In fig .   2 some of these ambiguous messages are shown for code T  . 

S ?.-~ SC ~---- SB ?--~-. SS
S?SC,~-2-SO,?C,D,~----SS
S~-L-B , O , ? SD , 2--SB , ?--- SS
S1.-~B1Dl?-~SD 21.-~SDl?-LC1D~l--~-SS
GONEY G6NEN  ~  010 = AB or CA 0101 = AD or CC 1010 = BB or DA 10101 = BD or DC Fig .  2 . Some ambiguous messages in code T ( le ) If no ( SS ) pair is generated , then a test in graph is constructed from the table as follows : corresponding to every row in the table there is a vertex in the graph  . If ( YZ ) is implied by ( WX ) undert , then a directed arc labeled tleads from vertex ( WX ) to vertex ( Y Z ) in the graph . 
(1 . /' ) A code is uniquely decipherable of finite delay N if and only if its testing graph is loop-free  . If the graph is loop-free and the length of the longest path in the graph is r  , then N = r+1 . 
4. CONSTRAINTSON CODE WORDOC CURRENCES
In the above discussion , there was no constraint whatsoever regarding the occurrence of any codeword at any point of the message  . On the other hand there may be such a case that , for some specific code , the codeword X never follows the codeword Y . These constraints may arise from the physical nature of the encoder  ( for example no letter other than u can follow letter q in an English text  ) or may be deliber at-ely imposed upon a code to achieve LID or UDF properties  . 
The constraints of the form " codeword X never follows codeword Y " will be termed a first -order constraint  . For the codes with first order constraints , a testing procedure is given below :
Procedure 2.
(2a ) Insert a separation symbol Px at the beginning and a separation symbol Qx at the end of each codeword X in the code  . 
(2b ) Insert separation symbols X ~ as in ( lb) . For example after steps (2a ) and (2b ) , D = 101 becomes PnlDlOD 21 QD . 
(2c ) Let a number e(X , Y ) be defined for every ordered pair of codewords ( X , Y ) in the following way : UNIQUEDECIPHERABILITYOF CODES WITH CONSTRAINTS  187 re ( X ,  1 , ' ) =  1 if the codeword X is allowed to occur immediately after the codeword Y  , --0 otherwise . 
A constraint matrix M in which there is one row and one column for each Codeword can be defined such that the element of M in the row 
X , column Yisre(X , Y).
For example , consider code T of part 3 . Let the following four constraints be imposed on this code : A never follows C  ,  . Cnever follows C , An ever follows D , and C never follows D . These four constraints can also be expressed as " a codeword starting with a  0 never follows a codeword ending with a 1  " . The resulting code , called code\[7 , and its constraint matrix is shown in fig .  3 . 
code U
A:0P
B : 10 QAC,
C:O1

D : 101
QcB`
A:Pa0 QaQG Da
B:PB1Bt0 QBQBDa
C:Pc0G11 Qc
QDBxD:PD1D,ODalQD
QDD~(q~D .)
J(BIDI ) ( QcB , )( QcD ,)( QDB ,) ( QD Da)

B ! 1
M = C10
D 11
Fig .  3 . Code U ( 2d ) The separation symbol to the right of the code symbolt is called the t-successor f the separation symbol to the left of the same code symbol  . 
Furthermore , a separation symbol X ~ ( Qx ) is the t-successor of the separation symbol Qv if X  ( Qx ) is at-successor of Px and re ( X , Y ) = 1 . 
Two separation symbols are said to be compatible if  ( I ) They are t-successors of Px and Pr for some t , X , and Y , or 188 CONEY GONEN ~ ( II ) They are t-successors ? of two separation symbols which are themselves compatible  . 
Construc the testing table as in ( lc) , with the change : the first row heading is P . The testing table for code U is shown in fig .  3 . 
(2e ) If the table contains any pair ( Q x Q y ) for some X and Y ( possibly identical )  , then the code is not UD . Otherwise it is UD . For example it is seen from fig . 3 that code U is UD . If the code is not UD , then a trace back of compatibles which implied a pair  ( QxQY ) gives an ambiguous message . 
(2e ) If the code is UD , then one can construct the testing graph as in ( le )  . 
The testing graph for code U is shown in fig . 4.
Fig . 4. Testing raph for code U
The longest path in this graph has length 3 . Hence the code is UDF of order 4 ; in other words the knowledge of the first 4 code symbol suf-fices to determine the first code word  , but 3 is not sufficient . To demonstrate that the knowledge of the first 3 codesymbols is not sufficient , consider a path of length 3 in the graph , for example the path 101 from P to QnD1 . When we receive 101 we cannot decide whether this is word D , or word B ( = 10 ) occurred and a word D ( ----- 101 ) has just started ( the last vertex QnD1 actually points to this ambiguity )  . But , if the fourth . symbol received is a 0 we can now decide that the first codeword was B , and if the fourth symbol is a 1 we decide that the first codeword was D . 
There may be other types of constraints present on the code  . A constraint of the form " codeword X never follows YZ "  , where Y and UNIQUEDECIPHERABILITY OF CODES WITH CONSTRAINTS  189 Z are distinct , will be termed a second order constraint . If there exists such a constraint , hen it can be converted into the following first order constraints : create a new codeword  ; ~ , identical in structure to Z . Then impose the constraints " X never follows Z , Znever follows Y " ( for simplification purposes one can impose the additional constraints : " Z  , never follows Z , , X , or Z ") . Higher order constraints can be handled similarly . 
5 . SYLLABLEST RUCTURE OF TURKISH LANG UAGE In Turkish language there are  12 syllable types . These are shown in Table 1 . 
TABLE 1.
SYLLABLETY PES OF TURKISHL ANGUAGE ( 0 denotes vowel , 1 denotes consonant )
Symbol Structure Example
A0 a~lk(open)
B 10 baba ( father)
C01 e k m e k ( b r e a d )
D 101 altm(gold)
E0 11 erk ( power)
F1011 tiirk ( turkish)
G1 10 kraliqe(queen)
H1 101 kontrol(control)
I 1110 strateji ( strategy)
J 1 1 10 1 stronsiy um(strontium)
K 1 10 11 tren ~ kot(trench coat)
L10111k on trbas ( cello)
The first six syllable types ( types AF ) are syllable types of proper Turkish language . The remaining six types ( types G-L ) came into Turkish with foreign borrowings . These are somewhat characterized by consonant clusters  , which are totally alient othe language . In spok-en language , especially as spoken by not-well-educated people , these clusters are simplified by the addition of a vowel before or within the  190 GUNEY G6NEN ~ cluster , thereby increasing the number of syllables in the word  ( G . L . 
LEwis , 1967) . Since our main concern is printed texts we shall not deal with these and other aspects of the spoken language  . 
The treatment of printed Turkish words as messages encoded into a code in which syllables are code words and letters are code symbols enables us to syllabify printed texts automatically  . This is important because of the following reasons :  1  ) Automatic syllabification makes it possible to recognize and count  ( mainly for statistical purposes ) syllable types and/or syllables from texts read into the computer without any syllable separation markers  . 
2 ) Automatic syllabification is necessary in automatic type setting  , without automatic syllabification words to be separated at lineends cannot be properly syllabified  . 
3 ) Automatic syllabification gives insight into the syllable structure  , its deformation under some effects , and the relation between spoken and printed . language , thereby helping linguists working on the subject . 
The first six syllable types a without any constraints obviously form a non-UD code  . For example a word 0110 can be decoded as 01 . 10 ( CB ) or as 011 . 0 ( EA ) . On the other hand the phonetic rules of the language put some constraints as to which syllable type cannot follow a given syllable type  . The set of constraints inherent in the language can be summarized as " each vowel takes the first consonant before it into its syllable "  ( T . BANGUO ~ Ltl , 1959) . In our notation , the constraint set can be summarized as " no syllable starting with a vowel  ( 0 ) can follow a syllable ending with a consonant ( 1 )  " . The constraint matrix corresponding to this set is shown below  . 






A B C D E F -1   1   0   0   0   0   -1   1   1   1   1   1   1   1   0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   0   1   1   1   1   1   1   3 Turkish alphabet consists of eight vowels ( a , e , z , i , o , // , u , //) and 21 consonants ( b , c ,  ~ , d , f , g ,  ~ , h ,   . i , k , l,m,n,p,r,s, . s , t , y , z) . Only one vowel can be present in any syllable . There are no diphtongs in Turkish . 
UNIQUEDECIPHERABILITY OF CODES WITH CONSTRAINTS 191 Now , by constructing the testing table and graph , it can be shown that this code is UDF of order 5 . 4This simply means that there is an algorithm , to syllabify any proper Turkish word which operates in the following manner :  1  ) The only information required about the characters in the text is about their being vowel  , consonant or " other " ( such as blank , comma , numeral etc . ) . 
2) When a word is being scanned , its first syllable will be decided upon at the fifth character of the word or before  . Since the code is UD the decision process is completed when the word ends  ( i . e . upon first blank ) . 
The introduction of the syllable types G , H, . . . , L of Table 1 into the language causes the " invention " of new constraints  . These are not yet thoroughly investigated or explained  . One set of constraints can be summarized as : " no syllabting with two or more consonants can follow a syllable ending with a vowel "  . 5 With the addition of this set of contraints , the constraint matrix becomes












ABCDEFGHIJKL -1   1   0   0   0   0   1   0   1   0   0   0   -1   1   1   1   1   1   1   1   1   1   1   1   1   1   0   0   0   0   1   0   1   0   0   0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   0   0   0   0   1   0   1   0   0   0   1   1   1   1   1   1   1   1   1   1   1   1   0   0   1   1   1   1   0   1   0   1   1   1   0   0   1   1   1   1   0   1   0   1   1   1   0   0   1   1   1   1   0   1   0   1   1   1   0   0   1   1   1   1   0   1   0   1   1   1   0   0   1   1   1   1   0   1   0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 ' It is also interesting to note that the first order constraints to make the code A  , B ,   .   .   .   . Funiquely decipherable of finite delay are found to be precisely those constraints inherent in the language  . 
No mention of this kind of constraint is found in the literature  . This rule , and the one given before must clearly be the result of the shape of vocal organs  . We should also mention that no exception at all to these two rules exists  . 
192 GUNEY GSNEN ~
The code thus generated can be shown to be still non-UD  . Some typical ambiguities concerning the existing words are shown below: 
Message Ambiguous ( word ) syllabification Examples 01110 CG01 . 110 em . pri . me , is . pri . fiz . ma
EB011 . 10 ens . ti . ti ~, esk . ka . va . tSr 101110 DG101 . 110k on . gre , kom . pra . dor
FB 1011 . 10 fark . h,kiirk4 ii011101CH01 . 1101 mtran . ca , ak . tris
ED011 . 101eks . per 1011101 DH101 . 1101kan . gren , kon . trat
FD 101 1.101 tabl.dot , teks.til
A careful and thorough search ( through all borrowings in the language ) revealed one fact : if we increase the code symbols from two  ( vowel , consonant ) to three ( v-----vowel , r - - - - - letter " r " , ~ = conso-~nant other than " r " ) then the resulting code becomes UD , and act-ually UDF of delay 7 for all existing foreign ( and of course all native ) words . The examples given above hints this . Simply note that the words in the upper line in each set have an r as the second letter of second syllable  , whereas a letter other than r appears at the same position of the word  , for words of the lower lines , e . g . emprime and enistitii . 
Finally , with these considerations an algorithm for tlae syllabificat-ion is programmed  ( in rOX ~ TaAN )  . This algorithm is based on the state-table of the inverse of the finite state machine which is taken as the encoder device  4  , 7 . The input to the program is a printed text , the output is the same text ( numerals etc . skipped ), all the words being syllabified . There are minor additions to the program . For example unsyllabifiable words ( due to punching errors , etc . ) are printed out as they are , but in brackets . The program is run on mM 360/40 . An example of input data and corresponding print outs are shown in fig  .  5 . 
UNIQUEDECIPHERABILITY OF CODES WITH CONSTRAINTS 193 HECEAYIR MAPROGRAMIGEL ENEK AKARY AKITUY GULAMA HE*CEA*YIR*OG*RA*MIGE*LE*NEKA * KA*KIT UY*GU*LA*MATORTUKONG REKORK AKKANG RENT A BLDOT KONTRATTANJANTTOR*TUKON*GREKOR*KAKKAN*GREN TABL*DOTKON * TRATTAN*JANT 
STEREOS KOPAH METRIZ AOS TRC BB ANI
STE*RE*OS*KOPAH*METRI*ZAO(STRC)CBB)A*NI .   .  -  .   , ' EMPRIMEENSTITUEKS PERISTRANCAISTRONGILOs ISFENKSEM*PRI*MEENS*TI*TUEKS*PERIS*TRAN*CAIS * TRON*GI*LOSIS * FENKS FBRKET CKANDIR MAC AI  . 1 2/MAYIS/1971 GUSULHANEC FBRKE TJKAN*DIR*MA*CAMA*YISGU*SUL*HA * NESAATTATARAM FITE ATR TELEK SKREOZ OTF LAMA FLUORSA*ATTA*TARAM*FI*TE*ATRTE*LEKSKRE*O*ZOT FLA*MAFLU * ORAERODINAMIK AIT ARAPAOR TAVURT ARKEOLOGBABAA*E*RO*DI*NA*MIKA*ITA-RAPA*ORTA * VURTAR*KE*O*LOGBA*BATRAHOM FREK ANSSTRATEJI STRATOSFERARTITRA*HOMFRE * KANSSTRA*TE*JISTRA * TOS * FER AR*TI 
KONTRASTEKS KAVATORENS TITU
KON*TRASTEKS * KA*VA*TORENS*TI*TU
Fig .  5 . Computer print outs of the syllabification program  . In each set of two lines , the upper line the input data , the lower line is the output . 


T . BANGUOC , LU , Tiirk Grameri-Ses Bilgisi,
Ankara , 1959.
S . Evmq , Generalized Automat and Their
Information Loss Iessness , in Switching
Circuit Theory and Logical Design,
AIEE Special Publication , S-141, 1962, pp .  144-147 . 
S . E v ~ , Tests for Unique Decipherabitity , in , IEEE Trans . Information Theory ~, vol . IT-9 ( April 1963), pp .  109-112 . 
S . EVEN , On Information Lossless Automata of Finite Order , in ~ IEEE Trans . Elec . 
Comp . ~, vol . EC-14 ( August 1965), pp .  561-569 . 
D.A.HUFFMAN , Canonical Forms for
Information Lossless Finite State Machines , in ~ IR . E Trans . Circuit Theory ~, vol . CT-6, Special Supplement ( May 1959), pp .  41-59 . 
G . L . Lmwls , Turkish Grammar , London , 1967.
Z . KO~L~W , Switching and Finite Automata
Theory , New York , 1970.
