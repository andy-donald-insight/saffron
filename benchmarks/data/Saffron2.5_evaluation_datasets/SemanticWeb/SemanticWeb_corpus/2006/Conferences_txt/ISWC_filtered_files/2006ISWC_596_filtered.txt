Reducing the Inferred Type Statements with

Individual Grouping Constructs

 Ov un c  Ozt urk, Tu gba  Ozacar, and Murat Osman  Unalr

Department of Computer Engineering,

Ege University

{ovunc.ozturk, tugba.ozacar, murat.osman.unalir}@ege.edu.tr

Bornova, 35100, Izmir, Turkey

Abstract. A common approach for reasoning is to compute the deductive closure of an ontology using the rules specified and to work on the
closure at query time. This approach reduces the run time complexity
but increases the space requirements. The main reason of this increase is
the type and subclass statements in the ontology. Type statements show
a significant percentage in most ontologies. Since subclass is a transitive
property, derivation of other statements, in particular type statements
relying on it, gives rise to cyclic repetition and an excess of inferred
type statements. In brief, a major part of closure computation is deriving the type statements relying on subclass statements. In this paper,
we propose a syntactic transformation that is based on novel individual
grouping constructs. This transformation reduces the number of inferred
type statements relying on subclass relations. Thus, the space requirement of reasoning is reduced without affecting the soundness and the
completeness.

1 Introduction

Semantic web applications will require multiple large ontologies for querying [1].
Although current reasoners are capable of schema reasoning with these real world
ontologies, they break down for reasoning and retrieving the individuals in an ontology when the number of instances becomes large [2] [3]. It is a common and
space consuming approach to compute the deductive closure of these large ontologies and to work on the closure at query time. This approach is known as offline
reasoning that reduces run time complexity but increases space requirements.

Present work focusses at query-rewriting techniques. For example, [4] presents
the true RDF processor. This processor provides a slot access function which
allows the underlying graph to be viewed as if its RDFS-closure had been gener-
ated. This model has problems in dealing with domain and range restrictions and
does not cover the complete RDF semantics. Another query rewriting approach
for RDF reasoning [5], computes a small part of the implied statements offline
thereby reducing space requirements, upload time and maintenance overhead.
The computed fragment is chosen in such a way that the problem of inferring
implied statements at run time can be reduced to a simple query rewriting. In

I. Cruz et al. (Eds.): ISWC 2006, LNCS 4273, pp. 573582, 2006.
c Springer-Verlag Berlin Heidelberg 2006

 O.  Ozt urk, T.  Ozacar, and M.O.  Unalr

contrast to [4], [5] covers the complete RDF semantics by precomputing the
transitive closure of hierarchical relations. These approaches do not compute
complete closure offline thus they require online reasoning, which increases the
runtime complexity.

In this paper, we propose a model that introduces novel individual grouping constructs for reducing the number of inferred type statements. The major problem
with reasoning about individuals is deriving type statements relying on subclass
relations between the classes. Our approach solves this problem with only a syntactic transformation. Instead of relating the class with each of its instances, this
transformation relates the class with a group of sets where each set is a partial
extension of that class. The advantages of our approach are listed below:

 covers complete semantics of RDF-based languages, since it is only a syn-

tactic transformation

 does not affect the soundness and the completeness of the reasoning
 does not require query-rewriting and online reasoning
 does not require online reasoning

The rest of the paper is organized as follows: Section 2 introduces the model
in detail and its subsections describe the transformations required by the model.
Section 3 formulates the utilization rate of the model and evaluates utilization
with large scale ontologies by means of ontology metrics in [6]. Finally Section 4
concludes the paper with an outline of some potential future research.

2 A Model with Individual Grouping Constructs

In this paper we propose a model that introduces individual grouping constructs
for reducing the number of inferred type statements without affecting the soundness and the completeness of the reasoning.

An individual grouping construct is a partial extension of a class. The union of
these partial extensions defines the exact list of class individuals. An individual
of a class may be in one or more partial extensions of that class. These partial
extensions are called subExtensions. A subExtension is related to one or more
classes via hasSubExt predicate and it is related to individuals of the class with
contains predicate. A subExtension is direct or inherited according to its relation
with the class.

All individuals of a class, except the ones derived through a subclass relation,
are added to the directSubExtension of that class. Each anonymous and nonanonymous class in the ontology has zero or one directSubExtension. Any class
that has at least one individual has a directSubExtension. A class is related with
its directSubExtension with hasDirectSubExt predicate. A subExtension can be
related to one and only one class via hasDirectSubExt predicate.

An inheritedSubExtension of a class is the directSubExtension of a subclass of
that class. In other words, an inheritedSubExtension holds the class individuals
that are inherited to that class from one of its subclasses. A class is related
to one or more inheritedSubExtensions with hasInheritedSubExt predicate. A
?

?

?
subExtension is related to one or more classes via an inferred hasInheritedSubExt
relation. Note that, since every class is a subclass of itself, the directSubExtension
of the class is also one of its inheritedSubExtensions. Thus every subExtension
of a class is also an inheritedSubExtension of that class.

In our model the ontology is syntactically transformed to a semantically equivalent ontology with newly introduced individual grouping constructs. In order to
preserve the completeness and the soundness of the reasoning, rules and queries
are transformed in needs of these grouping constructs. These transformations 1
are described in the following subsections.

2.1 Triple Transformation
Let O be the set of triples in the ontology to be transformed, t be a type statement with subject I and object C then t is replaced with triple set S where;
if hasDirectSubExt(C, E)  O

{contains(E, I)},
{contains(E, I), hasDirectSubExt(C, E)}, otherwise.

S =

It is worth to note that the same replacement is done whenever a type state-

ment is added to or removed from ontology.

2.2 Rule/Query Transformation
Transforming rules is necessary to derive new statements with the transformed ontology without changing the completeness and the soundness of the reasoning. After the transformation, some rules have a form like head :  body1  body2. These
rules can be transformed easily via the following Lloyd-Topor transformation [7]:

head :  body1  body2  head :  body1 and head :  body2
Note that it is necessary to extend the rule set to include the following rule,
which specifies that every directSubExtension and inheritedSubExtension of a
class is also a subExtension of that class:

hasDirectSubExt(B,E)hasInheritedSubExt(B,E)

hasSubExt(B,E)

The following is the standard rule transformation, which is valid for all rules

other than RDF Rule 7 :

 A rule having a body condition with a type predicate is transformed in the

 ...hasSubExt(B,E)contains(E,U)...

h1

 A rule having a head condition with a type predicate is transformed in the

following way :
...type(U,B)...

h1

following way :
b1...bn
type(U,B)

 b1...bnhasDirectSubExt(B,E)

contains(E,U)

1 The transformation overhead is small enough to be considered negligible.

 O.  Ozt urk, T.  Ozacar, and M.O.  Unalr

RDF Rule 7 computes the type statements relying on subclass relations. In
order to reduce the number of inferred type statements, this rule is transformed
in a different manner than the standart rule transformation. Instead of deriving
a type relation between every individual of subclass and its superclass (Fig. 1a),
RDF Rule 7 simply derives only one relation with predicate hasInheritedSubExt
between the directSubExtension and each inheritedSubExtension of subclass and
its superclass (Fig. 1b). Table 1 demonstrates the transformation of some RDF
rules from RDF Semantics [8], including RDF Rule 7.

Table 1. Transformation of RDF Rules

Rule No RDFS Rule

Transformed Rule

(1)

(2)

(3)

(4)

(5)

(6)

(7)

(8)

A(X,Y )

type(A,P roperty)
domain(A,X)A(U,Y )

type(U,X)

range(A,X)A(Y,V )

type(V,X)
A(U,B)A(B,U)
type(U,Resource)

type(U,P roperty)

subP ropertyOf (U,U)

type(U,Class)

subClassOf (U,Resource)
subClassOf (U,X)type(V,U)

type(V,X)

A(X,Y )hasDirectSubExt(P roperty,E)

contains(E,A)

domain(A,X)A(U,Y )hasDirectSubExt(X,E)

contains(E,U)

range(A,X)A(Y,V )hasDirectSubExt(X,E)

contains(E,V )

(A(U,B)A(B,U))hasDirectSubExt(Resource,E)

contains(E,U)

hasSubExt(P roperty,E)contains(E,U)

subP ropertyOf (U,U)

hasSubExt(Class,E)contains(E,U)

subClassOf (U,Resource)

subClassOf (U,X)hasSubExt(U,E)

hasInheritedSubExt(X,E)

type(U,Class)

subClassOf (U,U)

hasDirectSubExt(Class,E)contains(E,U)

subClassOf (U,U)

A query is a rule without a head thus the standard rule transformation is also
applicable to queries. The queries are transformed in the following way where
h1 is an empty set:

...type(U,B)...

h1

 ...hasSubExt(B,E)contains(E,U)...

h1

It is also important to represent the answer in the standard way. Let S be
the set of all triples in the answer set then replace the following triple sets with
triple type(U, B):
 {hasDirectSubExt(B, E), contains(E, U)}
 {hasInheritedSubExt(B, E), contains(E, U)}
 {hasSubExt(B, E), contains(E, U)}
?

?

?
Fig. 1. Reducing the inferred type statements relying on subclass relations

3 Analyzing the Utilization of the Model

3.1 Computation of the Utilization Rate

Computation of the utilization rate reveals whether the model is valuable to use
with a specific ontology. In order to calculate the utilization rate, the number
of type statements in the ontology and the number of subclass relations in the
closure of the ontology must be known. Since it is necessary to know only the
number of subclass statements in the closure, it is enough to find the closure of
the schema of the ontology.

The following formula calculates the decrease in the inferred triple count by
applying the proposed model. Let  be the decrease in the inferred triple count
by applying the model. The formula finds  by calculating the difference between the decrease in inferred type statements and the newly added or inferred
triples related with grouping constructs. Before applying the model, every individual of a subclass is added to the individuals of its every superclass if the
superclass does not have this individual. The number of these additions is T . This
value is the decrease in inferred type statements. In order to calculate the exact
decrease in the inferred statements by applying the model, we have to minus
the number of newly added hasDirectSubExt, hasInferredSubExt and hasSubExt
statements from this value. Let D be the number of newly added hasDirectSubExt statements, I be the number of inferred hasInferredSubExt statements
and S be the number of hasSubExt statements, then;

(1)
Let n be the number of classes in the ontology, ECx be the set of all explicit
individuals of class Cx where 1  x  n, |X| be the number of elements in set

 = T  (I + D + S)
?

?

?
X, \ be the set minus operator and  (Cx, Cy) be a function which returns 1 if
Cx is an explicit or implicit subclass of Cy. Otherwise the returned value is 0.
And let  (Cx) be a function, which computes the number of elements in the
set-theoretic difference of U and Cx, where U is the union of all explicit and
implicit subclasses of Cx.

(Cx, Cy) =

i=1

j=1

 (Cx, Cy) =

otherwise.

 (Ci, Cj)

T =

(Ci)

i=1

i=1

,
I =

(Ci, Cx)|

n
(Cx) = | n
ECx
\ ECy , if Cx is a subclass of Cy
n
n
 1, if Cx is a subclass of Cy
n
 0, if ECx = 

0, otherwise.

 (Ci)

i=1

(Cx) =

1, otherwise.

D =

(2)

(3)

(4)

(5)

Let  (Cx) be a function which returns 0, if Cx is an empty set. Otherwise
the returned value is 1. Each non-empty class in the ontology has one and only
one directSubExtension, thus

One and only one subExtension of a class is related to that class with hasDirectSubExt predicate. All the other subExtensions are related to the class with
hasInheritedSubExt predicate. Since every class is a subclass of itself, the only
subExtension that is related to the class with hasDirectSubExt predicate is also
related to that class with hasInheritedSubExt predicate. Thus, all subExtensions
of a class are also related to the class with hasInheritedSubExt predicate. Then,
we can conclude that:

S = I

The utilization rate is the ratio between the reduction in inferred statements
and the number of statements in the closure without implementing the model.
Let t be the number of statements in the ontology before inference,  be the
number of inferred statements without implementing the model, then the utilization rate of the model U is;
?

?

?
U = 1  
t + 

If the model is useful and reduces the number of inferred statements, the utilization rate is in the interval of (0, 1]. The closer the value is to 0, the higher
the utilization of the model. If the utilization rate is equal to 1, then applying
the model shows no impact. If the utilization rate is greater than 1, then applying the model shows a negative impact (i.e., the number of inferred statements
increases).

3.2 Estimation of the Utilization Rate Using Ontology Metrics
The model shows a negative impact when the ontology has no subclass relation
or the number of type statements in the ontology is less than the number of class
definitions and subclass relations in the ontology. These two factors result in a
relatively low number of inferred type statements in the closure of the ontology.
In this case, the number of additional statements required by the technique is
greater than the decrease in the number of inferred type statements.

Obviously, this case is not very common in real world ontologies and also
is not meaningful from the perspective of knowledge representation. Table 2
depicts this issue by supplementing the number of subclass and type relations in
representative ontologies. The common characteristics of ontologies in Table 2 are
the reasonable amount of type and subclass statements and a significant increase
in type statements in their corresponding closures [5]. Consequently, the model
is valuable enough with these ontologies, but we enumerate the factors that
increase the utilization rate in order to figure out when the model is applicable.
These factors are:

 high number of subclass relations
 high number of individuals

Table 2. Behaviour of realistic data

CIA WFB

TAP KB

type
subClassOf
other

orig.
?

?

?
closure
?

?

?
orig.
?

?

?
closure
191972
?

?

?
orig.
?

?

?
closure
?

?

?
WordNet

closure
orig.
277267
?

?

?
606418
295529 374032

In order to estimate whether the model is suitable for a particular ontology,
the preceding factors can be associated with ontological metrics. Ontological
metrics are used to assess the quality of an ontology. The quality of an ontology
can be valuated in different aspects. These aspects are mainly grouped according
to their relevance with ontology, they are related either with schema or with
knowledge base, or both. Previous work in the literature is classified in [6], and
one dimension of this classification is the relevance with ontology. In accordance
with the classification, we decided to use metrics defined in OntoQA [6].

 O.  Ozt urk, T.  Ozacar, and M.O.  Unalr

OntoQA metrics are mainly divided into schema metrics and instance met-
rics. Schema metrics are about the structure of the ontology. Instance metrics
are about the population and its distribution over the classes. We selected two
metrics from the OntoQA metric set: inheritance richness and average popula-
tion. In [6], inheritance richness is defined as the average number of subclasses
per class, and average population is defined as the number of instances of
the knowledge base divided by the number of classes defined in the ontology
schema. These metrics are proportional to the utilization of the model. Although an increase in average population results in an increase in the utilization
of the model, it is necessary to note that the population intensifying in the leaf
classes has a greater effect.

3.3 Evaluation of the Utilization Rate with Large Scale Ontologies

We also applied the model on a RETE based inference engine [9], with Lehigh
University Benchmark (LUBM) in order to exemplify utilization of the model
[10]. LUBM is developed to evaluate the inference and query performance of
semantic web repositories over a large data set. The data set is generated according to one ontology, named univ-bench, using the synthetic data generation
tool provided with the benchmark. LUBM can generate datasets with chosen
size using the schema, for example LUBM(2,0) means the ontology includes two
university instances with their corresponding dataset.

We conducted the test using four different rule sets. The first two sets are related with RDF semantics. The first one contains rules covering the semantics of
partial rdfs [11], where some of the normative RDFS entailments are discharged
for performance reasons. The second one is the transformed form of the previous
rule set in needs of the proposed model. The remaining two sets are related with
OWL semantics [12]. The first one contains rules covering the semantics of a
DL that is between OWL Lite and OWL DL. This set contains 30 rules, which
satisfy completeness and soundness of LUBM queries by 100 percent. Finally,

Fig. 2. Number of inferred statements in LUBM ontologies
?

?

?
the last rule set is the transformed form of the rule set having 30 OWL rules, in
needs of the proposed model.

As can be seen from Figure 2, the model significantly reduces the number of
inferred triples and also the number of total triples in the closure of the ontology.
Therefore, the inferencing time of the ontology and the memory required to open
the ontology decrease. The utilization is higher in RDFS level because in RDFS
the ratio between inferred type statements and inferred statements is greater
than in OWL. Also query time is not affected because there is no need to make
backward chaining as in [5].

4 Conclusion and Future Work

This work is an attempt to reduce the number of inferred statements in the
closure of web ontologies. It is just a syntactic transformation that does not
change the soundness or the completeness of the reasoning. Instead of relating
a class with each of its instances, this transformation relates the class with a
group of sets where each set is a partial extension of that class.

The model is valuable with real world ontologies having a reasonable amount
of individuals. This work formulates the utilization and also tries to associate
it with ontology metrics in literature to estimate the utilization with a specific
ontology. Since there is not enough work related with ontology metrics and
the values of existent metrics with well known ontologies are not presented, we
couldnt give a detailed work on the association of the utilization and the metrics.
It will be an interesting future work to define the intervals of metrics in which
the utilization is best.

Another potential future work is to reduce the semantic coverage of the model
and specialize it to a specific ontology language, in order to gain additional
utilization rate. This will be possible by defining not only individual grouping
constructs, but also additional specific grouping constructs for a specific ontology
language (e.g. grouping constructs specific for RDF).
