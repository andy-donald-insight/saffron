A Constraint-Based Approach to Horizontal Web

Service Composition

Ahlem Ben Hassine1, Shigeo Matsubara1,2, and Toru Ishida1,3

1 Language Grid Project, National Institute of Information and Communications Technology

2 NTT Communication Science Laboratories, NTT Corporation

ahlem@nict.go.jp

matsubara@cslab.kecl.ntt.co.jp

3 Department of Social Informatics, Kyoto University

ishida@i.kyoto-u.ac.jp

Abstract. The task of automatically composing Web services involves two main
composition processes, vertical and horizontal composition. Vertical composition
consists of defining an appropriate combination of simple processes to perform
a composition task. Horizontal composition process consists of determining the
most appropriate Web service, from among a set of functionally equivalent ones
for each component process. Several recent research efforts have dealt with the
Web service composition problem. Nevertheless, most of them tackled only the
vertical composition of Web services despite the growing trend towards functionally equivalent Web services. In an attempt to facilitate and streamline the
process of horizontal composition of Web services while taking the above limitation into consideration, this work includes two main contributions. The first is a
generic formalization of any Web service composition problem based on a constraint optimization problem (COP); this formalization is compatible to any Web
service description language. The second contribution is an incremental user-
intervention-based protocol to find the optimal composite Web service according
to some predefined criteria at run-time. Our goal is i) to deal with many crucial
natural features of Web services such as dynamic and distributed environment,
uncertain and incomplete Web service information, etc; and ii) to allow human
user intervention to enhance the solving process. Three approaches are described
in this work, a centralized approach, a distributed approach and a multi-agent
approach to deal with realistic domains.

1 Introduction

The great success of Web services, due especially to their richness of application made
possible by open common standards, has led to their wide proliferation and a tremendous variety of Web services are now available. However, this proliferation has rendered
the discovery, search and use of an appropriate Web services arduous. These tasks are
increasingly complicated, especially while dealing with composite Web service to response to an ostensible long-term complex users goal. The automatic Web service composition task consists of finding an appropriate combination of existing Web services to
achieve a global goal. Solving this problem involves mixing and matching component
Web services according to certain features. These features can be divided into two main
groups:

I. Cruz et al. (Eds.): ISWC 2006, LNCS 4273, pp. 130143, 2006.
c Springer-Verlag Berlin Heidelberg 2006
?

?

?
 Features related to the user, including the users constraints and preferences.
 Features related to Web services and which can be divided into two subgroups,
internal and external features. Internal features include quality of service (QoS)
attributes, and external features include existing restrictions on the connection of
Web services, (e.g., a hotel room should be reserved for the ISWC2006 conference
usually after booking the flight). External features are specified in the Web service ontology language, OWL-S [12], through a set of control constructs such as,
Sequence, Unordered, Choice, etc.

However, there is usually a choice of many Web services for each subtask that has to
be done to fulfill the main goal. We refer to these Web services as functionally equivalent Web services. In the sequel of this paper, as is generally done in the literature, we
refer to each of subtasks making up the main goal as an abstract Web service and to
each Web service able to perform a subtask as a concrete Web service. Solving a Web
service composition problem means going through two types of composition process:

 Vertical composition, is aimed at finding the best combination of the abstract
Web services, i.e., abstract workflow, for achieving the main goal while satisfying
all existing interdependent restrictions.

 Horizontal composition, is aimed at finding the best concrete Web service, from
among a set of available functionally equivalent Web services, i.e., executable
workflow, to perform each abstract Web service. The quality of the response to the
users query (the composition task) considerably depends on the selected concrete
Web services. The choice of a concrete Web service is dictated to functional (i.e.,
related to the inputs) and/or non-functional attributes (i.e., related to the quality of
service attributes).

The main benefits from distinguishing between these two composition processes are:
i) simplifying Web service composition problem to reduce it computational complexity,
ii) avoiding any horizontal composition redundancy that may appear while searching for
the best orchestration of abstract Web services, and mainly iii) ensuring more flexibility to the user intervention, i.e., user is able to modify/adjust the abstract workflow
when needed.

The combination of Web services has attracted the interest of many researchers,
amongst [9], [13], [8], [14], and several approaches have been reported. Most of these
deal only with vertical composition, where only single concrete Web service is available
for each abstract one. However, the tremendous growing number of functionally equivalent concrete Web services makes the search for an appropriate one, i.e., horizontal
composition of concrete Web services, an NP-hard task [5]. This composition process
has the following characteristics.

 Information is often incomplete and uncertain.
 The environment is naturally distributed and dynamic.
 Many (non)-functional features, inter-related restrictions and especially the prefer-

ences of the user may affect the quality of the response to a users query.

Existing research efforts have tackled only some parts of the natural features of the
Web service composition problem [1], [7], none have tried to deal with all of them. Also,

A.B. Hassine, S. Matsubara, and T. Ishida

some complex real-world problems require some level of abstract interactions with the
user to better search for a valid composite Web service. Finally, very few studies have
considered the validity of the information concerning a concrete Web service during the
composition process and none have dealt with this question of validity during the execution process. We have learned from all these works and we have focused our research
on the requirements of the Web service composition problem that are derived from the
natural features of the problem, search-based user interventions and the information validity during the composition and execution processes. Our main goal is to provide a
means by which an optimal composite executable workflow can be created for a given
set of sub-tasks with their inter-relation restrictions, i.e., an abstract workflow.

This paper consists of two main parts. The first is a generic formalization of any Web
service composition problem as a constraint optimization problem (COP) in which we
try to express most of the Web service composition problem features in a simple and
natural way. Our main purpose is to develop a common and robust means of expressing any Web service composition problem that ideally reflects realistic domains. The
second contribution is a real-time interactive protocol to solve any Web service composition problem by overcoming most of the above encountered limitations. Although,
there are various techniques for solving a COP, none of these integrate any user interaction issues. The constraint optimization problem formalism is especially promising for
ideally describing any realistic Web service composition problem, because this problem
is a combinatorial problem that can be represented by a set of variables connected by
constraints. Three approaches are proposed in this paper, a centralized approach, a distributed approach and finally a multi-agent approach to reflect ideally realistic domains.
This paper is organized as follows. In Section 2, we give an overview of existing re-
searches. In Section 3, we present the proposed formalization. In Section 4, we describe
a real-world scenario. In Section 5, we describe the proposed algorithm. In Section 6,
we discuss possibilities of extensions of the previous algorithm. In Section 7, we conclude the paper.

2 Related Work

Several solutions to the Web service composition problem have been reported includ-
ing, integer programming (IP)-based techniques [2], [16], non-classical planning-based
techniques and logic-based techniques [9], [11]. Recently, some researchers have suggested applying existing artificial intelligence (AI) optimization techniques, such as
genetic algorithms (GA), mainly to include some Quality of Service attributes in the
search process. Regarding IP-based proposed solutions [2], [16], authors assume linearity of the constraints and of the objective function. As for non-classical planning
techniques, Sirin et al. proposed an HTN-planning based approach [13] to solve this
problem. Their efforts were directed toward encoding the OWL-S Web service description as a SHOP2 planning problem, so that SHOP2 can be used to automatically
generate a composite web service. McIlraith and Son [9] proposed an approach to building agent technology based on the notion of generic procedures and customizing user
constraints. The authors claim that an augmented version of the logic programming
language Golog provides a natural formalism for automatically composing services
?

?

?
on the semantic web. They suggested not to consider this problem as a simple plan-
ning, but as a customizations of reusable, high level generic procedures. Canfora et al.
in [5] proposed to tackle QoS-aware composition problem using Genetic Algorithm
(GA). This work deals with both vertical and horizontal compositions. However, to accomplish the Web service composition task, the Web service composition procedure
may need to retrieve information from Web services while operating. Most studies have
assumed that such information is static [9], [13], [5]. Other studies have required an
interactive process with the user to get all the necessary information as inputs. Never-
theless, the static information assumption is not always valid, the information of various Web services may change (i.e., it may be volatile information [1]) either while
the Web service composition procedure is operating or during execution of the composition process. Kuter et al. [7] present an extension of earlier non-classical planningbased research efforts to better cope with volatile information. This arises when the
information-providing Web services do not return the needed information immediately
after it is requested (or not at all). In addition, Au et al. [1] proposed two different
approaches for translating static information into volatile information. They propose
assigning a validity duration for each item of information received from informationproviding services.

3 Constraint-Based Formalization of Horizontal Web Service

Composition

The constraint satisfaction problem (CSP) framework is a key formalism for many combinatorial problems. The great success of this paradigm is due to its simplicity, its natural expressiveness of several real-world applications and especially the efficiency of
existing underlying solvers. We therefore believe that CSP formalism allows a better
and more generic representation of any Web service composition problem. Hence, we
formalize the Web service composition problem as a constraint optimization problem
(COP) in which we have two kinds of constraints: hard and soft constraints.

A static CSP is a triplet (X, D, C) composed of a finite set X of n variables, each
of which takes a value in an associated finite domain D and a set C of e constraints
between these n variables [10]. Solving a CSP consists of finding one or all complete
assignments of values to variables that satisfy all the constraints. This formalism was
extended to the COP to deal with applications where we need to optimize an objective
function. A constraint optimization problem is a CSP that includes an objective func-
tion. The goal is to choose values for variables such that the given objective function is
minimized or maximized.

We define a Web service composition problem as a COP by (X, D, C, f (sl)) where:
 X={X1, . . ., Xn} is the set of abstract Web services, each Xi being a complex
variable represented by a pair (Xi.in, Xi.out) where
 Xi.in={ini1, ini2, . . ., inip} represents the set of p inputs of the concrete Web
service, and
 Xi.out={outi1, outi2, . . ., outiq } represents the set of q outputs of the concrete
Web service.
?

?

?
 D={D1, . . ., Dn} is the set of domains, each Di representing possible concrete Web
services that fulfill the task of the corresponding abstract Web service.
Di={sij(sij.in, sij.out) | sij.in  Xi.in AND Xi.out  sij.out}
 C=CS  CH
 CS represents the soft constraints related to the preferences of the user and to
some Quality of Service attributes. For each soft constraint CSi  CS we assign
 [0, 1]. This penalty reflects the degree of unsatisfiability of
a penalty CSi
the soft constraint CSi.
 CH represents the hard constraints related to the inter-abstract Web services
relations, the OWL-S defined control constructs1, and the preconditions of each
concrete Web service. For each hard constraint CHi  CH we assign a weight
 (i.e. it should be imperatively satisfied). It is noteworthy that CH may include
also some hard constraints specified by the user, these hard constraints can be
relaxed upon request whenever no solution is found for the problem.

 For each concrete Web service we assign a weight to express the degree of user
 [0,1]. Weights are automatically accorded to the values of vari-
preference, wsij
ables in a dynamic way with respect to the goal.
 f (sl) is the objective function to optimize, f (sl)= sijsl(users preferences, penalty
over soft constraints, Quality of Service attributes, probability of information expiration ), and sl is a solution of the problem defined by the instantiation of all the
variables of the problem. In this work, we focus on optimizing both i) the users
preferences toward selected concrete Web services denoted by  (sl) and ii) the
penalty over soft constraints denoted by (sl). The Quality of Service attributes
and the probability of information expiration will be tackled in our future work.

Solving a Web service composition problem consists of finding a good assignment
  Sol:=D1 . . .  Dn of the variables in X such that all the hard constraints are
sl
satisfied while the objective function f (sl) is optimized according to Eq. 1.

f(sl

) = arg max
slSol

((sl), (sl))

(1)

In this paper, we maximize the summation of the user preferences for all concrete Web
services involved in the solution sl and minimize the summation of the penalties associated to all soft constraints2 according to Eq. 2.
?

?

?
CSiCS

f(sl

) = arg max
(
slSol
sijsl



wsij

CSi)

(2)

Since the solution might not be only a sequence of concrete Web services, i.e., it may include concurrent concrete Web services, we use , to indicate the sequential execution
and   to indicate concurrent execution. This information is useful in the execution
process. The obtained solution will have a structure such as, sl={s1i, {s2j s3k}, s4h,
. . ., snm}. This problem is considered to be a dynamic problem since the set of abstract
1 Our formalization for the OWL-S control constructs will be described below in more detail.
2 To allow more flexible and wider expression, we do not restrict the objective function to any

kind of function.
?

?

?
Web services (the set of variables) is not fixed; i.e., an abstract Web service can be divided into other abstract Web services if there is no available concrete Web services to
perform the required task. In addition, the set of values in the domain of each variable
(the set of possible concrete Web services) is not fixed. Concrete Web services can be
added/removed to/from the system.

In the Web services composition problem, several control constructs connecting Web
services can be used. The main ones, defined in the OWL-S description, can be divided
into four groups and we describe our formalization for these four groups below.

 Ordered, which involves the SEQUENCE control construct, can be expressed using
a hard constraint. Each pair of abstract Web services linked by a sequence control
construct are involved in the same CSequence constraint.

 Concurrency involves the SPLIT, SPLIT+JOIN, and UNORDERED control con-
structs. The natural aspect of the following proposed agent-based approach (Sec-
tion 5) allows the formalization of this control construct in a natural way. Note that
only JOIN will be associated with a CJoin constraint. SPLIT and UNORDERED
will be modeled using an empty constraint Cempty, that represents a universal
constraint. This constraint will be used to propagate information about parallel execution to concerned variables in the following proposed protocol.

 Choice involves IF-THEN-ELSE and CHOICE control constructs. For each set of
abstract Web services (two or more) related by the IF-THEN-ELSE or CHOICE
control construct, the corresponding variables are merged into the same global variable (Xj for example), and their domains are combined and ranked according to the
preference of the user. For example a set of m abstract Web services ({t1, t2, . . .,
tm}) related by the CHOICE control construct, we combine them into a global
variable (Xk for example) and rank their domains. For their preconditions, we assign a sub-constraint to each condition {Ccond1, Ccond2, . . ., Ccondm} and create a
global constraint CChoice=i Ccondi. At any time we are sure that only one condition will be satisfied since i Ccondi=.
 LOOP, neither the CSP formalism nor any of its extensions can handle iterative

processing. It will be considered in our future work.

4 Real-World Scenario

Consider a situation where a person living in France wants to organize a trip to Japan
to have laser eye-surgery. After the surgery, he will have to make appointments with his
ophthalmologist in France for post-operative examinations. This task involves several
interrelated subtasks as shown in Figure 1(a):

 t1 = Withdraw money from the bank to pay for the plane fare, surgery, accommo-

dation, and treatment,

 t2 = Make an appointment with the doctor, get the address of the clinic and deter-

mine the price of the surgery,

 t3 = Reserve a flight,
 t4 = Reserve accommodation, which involves,

A.B. Hassine, S. Matsubara, and T. Ishida
 t41 = Reserve accommodation in a nearby hotel if the price is less than or
equal to US$100 per night,
 t42 = Reserve accommodation at a hostel if the cost of a hotel exceeds US$100
per night,

 t5 = Make an appointment with his ophthalmologist for an examination one week

after returning to France.

 

X2 

t2 

Sequence 

t1 

X1 

Split-Join 

Sequence 
t5 

X5 

t3 
X3 

(a) 

t2=s22 

t1=s11 

X4 

t4-1 

If-Then-Else 

t4-2 

t3=s34 

t5=s51 

s52 s11 s53 
s31 
s21 
s23 

WSs Repository 

(b) 

t4=s44 

Fig. 1. (a) The set of tasks for the example with their pairwise control constructs, (b) The corresponding executable workflow solution for the problem

This problem can be formalized as follow:
 X={X1, X2, X3, X4, X5}, where each Xi=(Xi.in; Xi.out) corresponds to one of the
above tasks (Figure 1(a)).
 X1 corresponds to the task of withdrawing the required amount of money;
X1.in={Id, Password, Amount}; X1.out={RemainAmount};
 X2 corresponds to the task of making an appointment for the surgery; X2.in=
{Disease, Date}; X2.out={ClinicName, Place, Confirmation, Price};
 X3 corresponds to the task of booking a flight; X3.in={Destination, Date, Pa-
tientName}; X3.out={FlightNumber, Price};
 X4 corresponds to the two tasks to reserve accommodation in either a hotel or a
hostel depending to the cost. Recall that in our formalization we combine into
the same variable the tasks implied in the same CHOICE relation. In this example t41 and t42 are involved in the same IF-THEN-ELSE control construct,
so we combine them into X4; X4.in={Name, Place, Date, NightsNumber, Max-
Price}; X4.out={Hotel/hostelName, Address, Price};
 X5.in={DoctorName,
TreatmentType}; X5.out=
{Confirmation, Price};

PatientName, Date,
?

?

?
 D={D1, D2, D3, D4, D5}, where:
D1={s11}, D2={s21, s22, s23}, D3={s31, s32, s33, s34, s35}3, D4={s41, s42, s43, s44},
D5={s51, s52, s53, s54},
 C=CS  CH, where
 CH including
 X1.Id = nil;
 X1.Amount  X2.Price + X3.Price + X4.Price + X5.Price
 X2.Date < X3.Date;
 X3.Date < X4.Date;
 X4.Price  US$100;
 X4.Date + X4.NightsNumber+7 < X5.Date;
 Distance(X4.Place, X2.Place)10km4.

 For each sij  Di, we assign a weight wsij to express the degree of preferences of
the user PrefUser(Dj),
PrefUser(D1)={1}, PrefUser(D2)={0.26, 0.73, 0.58}, PrefUser(D3)={0.53, 0.61,
0.35, 0.82, 0.12}, PrefUser(D4)={0.33, 0.71, 0.63, 0.84}, PrefUser(D5)={0.87,
0.25, 0.59, 0.66}.
These degrees of preferences are subjective values and depend on the user.

 CS including

 The main objective is to find the best combination sl of the above abstract Web services and assign the most appropriate concrete Web services such that sl maximizes
the objective function f (sl) defined in Section 3 Eq. 2. Note that for simplicity, we
assume inter-independence between the values of the different domains. We will
consider dependence issues in future work.

Assume that Distance(s21, s44)= 13km, Distance(s22, s44)= 11km and Distance(s23,
s44)=20km, and the penalty over this soft constraint, Distance(X4.Place, X2.Place)10km
decreases as the distance converges to 10km, then Distance(s22,s44) < Distance(s21,s44)
< Distance(s23,s44). The most preferred solution for this problem is, sl={s22,{{s34, s51}
  s44}, s11} (Figure 1(b)) with (sl)= 0.73+0.82+0.84+0.87+1=4.26.

5 Constraint Optimization Problem Interactive Algorithm for

Solving the Web Service Composition Problem

The overall objective of our approach is to generate the best executable workflow (ac-
cording to the aforementioned criteria) within a feasible time. Several constraint optimization problem algorithms can be applied to solve this problem, but none allows the
intervention of the human user during the search process. In the following, we propose
an algorithm (Algorithm 1) that allows human interaction with the system to enhance
the solving process.
5 we first determine a set of candidate concrete Web services,
CandXj for its abstract Web service that satisfies all the hard constraints CHl  CH (Al-
gorithm 1 line 4), and then we rank CandXj according to the objective function defined

For each variable Xj

3 For example, Air France Web service, Lufthansa Web service, etc.
4 Distance(x, y) is a function that returns the distance between two places.
5 The variables are ordered according to the input abstract workflow.

A.B. Hassine, S. Matsubara, and T. Ishida

in Section 3. This ranked set is used to guide the selection of the next variable Xj+1 in
the search process. For Xj+1 we proceed first by applying join operation to the received
list CandXj and the current one CandXj+1, i.e., CandXj  CandXj+1 (Algorithm 1
line 12). The obtained sub-solutions are then filtered (Algorithm 1 line 12) according to
the set of existing hard constraints. Finally, the resulting set of sub-solutions is ranked
according to the objective function for optimization. If the set of candidates CandXj is
large, to avoid explosion in the join operation, we select a fixed number of the most preferred concrete Web services for each variable, (i.e., a subset of candidates), and try to
propagate these to the next variable. Whenever this subset does not lead to a complete
solution, we backtrack and then seek a solution using the remaining candidates. The
order of the values in the candidate set is established to avoid missing any solution. The
obtained sets of sub-solutions are propagated to the next variable (Algorithm 1 line 16)
and the same dynamic resumes until the instantiation of all the abstract Web services.
If the set of candidate Web services becomes empty (i.e., none of the available Web services satisfies the hard constraints), or the set of sub-solutions resulting from the join
and filter operations becomes empty and no more backtrack can be performed, the user
is asked to relax some of his/her constraints (Algorithm 1 line 23). However, if the relaxed users constraints involve the first instantiated variable in the search tree then the
search process is performed from scratch. It is noteworthy that three issues are possible
in this algorithm, i) Ask user intervention whenever a local failure is detected, which
may reduce the number of backtracks, ii) Ask user intervention only when a global failure is detected, no more backtracks can be performed, iii) keep trace of the explored
search tree to be able to point directly to the concerned variable by user relaxation and
pursue the solving process and avoid some computational redundancy.

In addition, whenever we need any information concerning any concrete Web ser-
vices, a request-message is sent to an information-providing Web service to get the
necessary information along with both its validity duration and the maximum time required to execute the underlying Web service. The agent should maintain this time so
that it can detect the information expiration and perform right decision (Algorithm 1
line 20). To deal with the main characteristic of this real-world problem, the dynamic
environment, we maintain the validity of necessary information during the solving and
execution processes, totalTime. totalTime should be less than the minimum validity time
required for any Web service information. We use the following denotation:

 T plan(sl): necessary time needed to provide a plan sl,
 texe(si): needed time to execute one concrete Web service,
 tval(inf j): estimated time before the expiration of solicited information inf j.

Naturally, the validity of information is usually considered as uncertain. Hence, for each
validity time a probability of information alteration palt(inf i) can be associated with
to the underlying information inf i. We will consider this probability of information
alteration in our future work. The maximal time T plan required to provide a solution is
defined by Eq. 3.

Tplan(sl) < min

 si  sl;

tval(infj) 

texe(sj);

(3)
?

?

?
sjsl
?

?

?
return setSubSol;

Collect necessary information; Update tval, texe and totalTime;

subCand  subset of the CandX [i]; add(checkedValues[i], subCand);
subSol  setSubSol  subCand; Filter and Rank subSol according to f (subSol);

Algorithm 1. User-intervenstion-based algorithm for Web service composition
WSCSolver(i, setSubSol, totalTime, checkedValues)
1:. if i>X then
2:.
3:. end if
4:. CandX [i]  {sik  Di | sik satisfies all the CH} \ checkedValues[i];
5:. if information required for any sij  CandX [i] then
6:.
7:. end if
8:. Rank CandX [i] according to wsij and CSj and while checking tval, texe and totalTime;
9:. subSol  ;
10:. while subSol =  do
11:.
12:.
13:. end while
14:. if subSol =  then
15:.
16:.
17:. else
18:.
19:.
20:.
21:.
22:.
23:.
24:.
25:.
26:.
27:.
28:.
29:. end if

reset to  all checkedValues[j] for j>i;
Update totalTime; Update setSubSol;
return WSCSolver(i-1, setSubSol, totalTime, checkedValues);
RelaxedConst  ask User to relax constraints involving Xk where k < i;
Update(CH, CS, RelaxedConst);
i  j such that  Xk involved in Cl and Cl  RelaxedConst, Xj lo Xk;
Update setSubSol;
return WSCSolver(i+1, setSubSol, totalTime, checkedValues);

add(setSubSol, subSol);
return WSCSolver(i+1, setSubSol, totalTime, checkedValues);

if i > 1 then

else

end if

Each sub-solution based on expired information will be temporarily discarded but
kept for use in case the agent cannot find any possible solution. This measurement is
an efficient way to cope with Web services with effects characterized mainly by their
volatile information because it allows a forward estimation of the validity of information
during both the composition process and the execution process.

6 Extended Algorithms

6.1 Web Service Composition Problem Distributed Algorithm

The main limitation of the previous algorithm is that it cannot be easily adapted to any
alteration in the environment. Whenever a user decides to relax some of his/her con-
straints, and these constraints involve already invoked variable, especially the first one
in the search tree, the search for a solution will be performed from scratch. However,

A.B. Hassine, S. Matsubara, and T. Ishida

distributed approaches can be easily adapted to the user intervention. In this solution
the same algorithm will be split on among set of homogeneous entities. Each entity
will be responsible of one variable and the same algorithm will be performed in parallel by this set of entities. In case of conflicts, i.e., no solution can be generated and no
backtrack can be performed, the system will ask the user to relax some constraints. The
concerned entity will update its view, generate new candidates and exchange them with
other concerned entities. The process resumes until either a solution for the problem is
generated or its insolubility, even with all possible relaxations, is proven. Nevertheless,
this distributed solution might be inefficient for some real-world scenarios where we
need to access a specialized Web service. A specialized Web service maintains information about a set of Web services; for example, HotelsByCity.com maintains information about several hotels Web services. The information concerning involved Web
services is considered private, which makes it difficult to gather Web services needed
information on same site and process them. Hence, we believe that extending the above
algorithm to a multi-agent system is more effective for realistic domains.

6.2 Multi-agent System for Web Service Composition Problem

The underlying multi-agent architecture consists of three kinds of agents, abstract Web
service agents, one or more Information-providing agents and an Interface agent. The
Interface agent is added to the system to inform the user of the result. Each agent Ai
maintains total validity time for all selected Web services, valTimeAi. This information
is locally maintained by each agent and updated each time a requested information is
received. All the agents will cooperate together via sending point-to-point messages
to accomplish their global goal. We assume that messages are received in the order in
which they are sent. The delivery time for each message is finite. The agents are ordered,
according to the input abstract workflow, from higher priority agents to lower priority
ones so that each constraint will be checked by only one agent. For each successive two
subtasks ti and tj such that ti<tj, their corresponding agents will be ordered as follows:
Ai lo Aj, and the agent Ai (resp. Aj) is called Parent (resp. Children) for Aj (resp.
Ai). The ordered links between agents, from the Parents to their Children, represent the
inter-agent hard constraints between the corresponding abstract Web service; i.e., these
relations represent OWL-S control constructs (sequence, choice, ordered, etc.) and/or
hard/soft user constraints.

Each agent Ai first reduces the set of candidate concrete Web services, CandXj for
its abstract Web service by keeping only those that satisfy all the hard constraints (Al-
gorithm 2, line 1), ranks it according to the user preferences (i.e., wsjk ), and to the
degree to which the soft intra-constraints are satisfied (Algorithm 2, line 15), selects
subset of best candidates then sends it to its ChildrenAi (Algorithm 2, line 17). If the
set of candidate Web services is empty, then the user is asked to relax some of his/her
constraints. In addition, whenever the agent needs information concerning any concrete
Web service, it sends a message (RequestInformationFor:) to the information-providing
agent to get the necessary information along with its validity and the maximum time
needed to execute the underlying Web service (Algorithm 2, line 10). The agent should
retain this time so that it can detect information expiration and perform right decision,
i.e., update the current solution when necessary. Each agent receiving needed infor-
?

?

?
Ask user to relax some of his hard constraints;

if inf k required for sk then

end if
send(Information-providing, self, RequestInformationFor:listRequest);

 Dj / all intra-CAj

H are satisfied;

listRequest  listRequest  sk;

Algorithm 2. Start message executed by each agent Aj.
Start
1:. Select CandXj
2:. listRequest  ;
3:. while CandXj = do
4:.
5:. end while
6:. for all sk  CandXj do
7:.
8:.
9:.
10:.
11:. end for
12:. while listRequest =  do
13:. Wait; /*Information required for Web services*/
14:. end while
15:. Rank CandXj according to wsjk and CSl;
16:. for all Ai  ChildrenAj do
17:.
18:. end for

send(Ai, self, process:CandXj within:valTimeAj );

mation from the Information-providing agent first updates its dynamic knowledge, and
then checks whether any of the information may expire before executing the workflow.
If this is the case for any of the received information, the affected Web service, sjk will
be discarded from the set of possible candidates. Finally, the agent ranks the remaining
candidates and sends them to its Children for further processing. Each agent Ai receiving a message to process candidate concrete Web services from its Parents or to process
a set of sub-solutions proceeds by first performing a join operation on all received lists
(Algorithm 3 line 1). The obtained sub-solutions are then filtered according to the set
of existing hard constraints and then ranked according to the soft constraints and user
preferences (Algorithm 3 line 3). If the set of sub-solutions is empty for the agent Ai,
then a request is sent to parents to ask for more possible candidates in a predefined order to ensure the completeness of the proposed protocol (Algorithm 3, line 7). In case,
all the possible candidates are processed and the set of possible solution is still empty,
the concerned agent asks the user to relax some of his/her constraints related directly
or indirectly to the variable Xi maintained by Ai. Thus, the appropriate agent will be
invoked to first update its set of hard constraints and then define new candidates and
send them again to the Children (Algorithm 3, line 14). The same process resumes until
stable state is detected.

In real-world scenarios, the Web service composition problem is subject to many
changes, defined on one side by the arrival of new Web services and on the other side
by the inaccessibility of one or more Web services. For each new Web service, the
appropriate agent will check whether this Web service can be included in the set of
candidates. If this new Web service satisfies the hard constraints and increases f (sl), it
will be communicated to the Children to upgrade their set of sub-solutions, if possible.

A.B. Hassine, S. Matsubara, and T. Ishida

Algorithm 3. Process-within message executed by each agent Ai.
Process:listAh within:t
1:. PossibleTupleAi  CandXi ; PossibleTupleAi  PossibleTupleAi  listAh;
2:. if All listAh are received from ParentsAi then
3:.

Filter PossibleTupleAi such that  tupleXi  PossibleTupleAi , tupleXi satisfies the interagent constraints (CAi
update totalTimeAi;
if PossibleTupleAi =  then
if Possible backtrack then

H ) and optimize the predefined criteria (Section 3);

send Backtrack message to ParentsAi to ask for more candidates;

Ask user to relax some of his hard constraints related in/directly to Xi;

else

end if

4:.
5:.
6:.
7:.
8:.
9:.
10:.
11:.
12:.
13:.
14:.
15:.
16:.
17:. end if

else

Rank PossibleTupleAi according to the criteria defined in Section 3;
for all Aj  ChildrenAi do

send(Aj, self, process:PossibleTupleAi within:valTimeAj );

end for

end if

Otherwise, the new candidate will be ignored. As for each Web service that becomes
inaccessible during the composition process, the appropriate agent should first check
whether this Web service is included in the set of sent candidates. If this is not the
case, the agent will only update its dynamic knowledge; if the inaccessible Web service has already been communicated to the Children, the agent should ask its Children
temporarily not consider this Web service in case it is involved in their sub-solutions.

The stable state is progressively detected by all the abstract Web service agents [4].
The main idea is to define an internal state for each agent Ai. This state is set to true
if and only if the internal states of all the children are true and agent Ai succeeds in
finding an appropriate concrete Web service for its abstract one. The stable state will
be detected by the children and progressively propagated to the parents. Each agent that
has no parents, ParentsAi = , informs the Interface agent regarding the final state. The
Interface agent communicates the result to the user.

7 Conclusion

The Web service composition problem is a challenging research issue because of the
tremendous growth in the number of Web services available, the dynamic environment
and changing user needs. In this paper, we have proposed a real-time interactive solution for the Web service composition problem. This problem consists of two main
composition processes, vertical composition and horizontal composition and we have
focused on the horizontal composition process. This work complements existing techniques dealing with vertical composition in that it exploits their abstract workflow to
?

?

?
determine the best executable one according to predefined optimality criteria. We have
developed a protocol that overcomes the most ascertained limitations of the existing
works and comply with most natural features of a realistic Web service composition
problem such as the dynamism of the environment and the need to deal with volatile information during the composition and execution processes, etc. Three main approaches
were proposed in this paper, the first is a user-intervention based-centralized approach,
the second is a distributed version of the previous one that can be easily adapted to any
environments alterations and the third is a multi-agent approach to cope better with realistic domains where problem required information is maintained by specialized Web
services. The multi-agent approach is currently under implementation and testing.
