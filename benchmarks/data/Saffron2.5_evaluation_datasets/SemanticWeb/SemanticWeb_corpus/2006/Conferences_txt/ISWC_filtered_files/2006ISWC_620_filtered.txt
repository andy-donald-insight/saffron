Web Service Composition Via Generic

Procedures and Customizing User Preferences

Shirin Sohrabi, Nataliya Prokoshyna, and Sheila A. McIlraith

Department of Computer Science, University of Toronto, Toronto, Canada

{shirin, nataliya, sheila}@cs.toronto.edu

Abstract. We claim that user preferences are a key component of Web
service composition  a component that has largely been ignored. In this
paper we propose a means of specifying and intergrating user preferences into Web service composition. To this end, we propose a means
of performing automated Web service composition by exploiting generic
procedures together with rich qualitative user preferences. We exploit the
agent programming language Golog to represent our generic procedures
and a first-order preference language to represent rich qualitative temporal user preferences. From these we generate Web service compositions
that realize the generic procedure, satisfying the users hard constraints
and optimizing for the users preferences. We prove our approach sound
and optimal. Our system, GologPref, is implemented and interacting
with services on the Web. The language and techniques proposed in this
paper can be integrated into a variety of approaches to Web or Grid
service composition.

1 Introduction

Web services provide a standardized means for diverse, distributed software applications to be published on the Web and to interoperate seamlessly. Simple Web
accessible programs are described using machine-processable descriptions and
can be loosely composed together to achieve complex behaviour. The weather service at www.weather.com and the flight-booking services at www.aircanada.ca,
are examples of Web applications that can be described and composed as Web
services. They might be coupled as part of a travel-booking service, for example.
Automated Web service composition is one of many interesting challenges facing the Semantic Web. Given computer-interpretable descriptions of: the task
to be performed, the properties and capabilities of available Web services, and
possibly some information about the client or users specific constraints, automated Web service composition requires a computer program to automatically
select, integrate and invoke multiple Web services in order to achieve the specified task in accordance with any user-specific constraints. Compositions of Web
or Grid services are necessary for realizing both routine and complex tasks on
the Web (resp. Grid) without the need for time-consuming manual composition
and integration of information. Compositions are also a useful way of enforcing
business rules and policies in both Web and Grid computing.

I. Cruz et al. (Eds.): ISWC 2006, LNCS 4273, pp. 597611, 2006.
c Springer-Verlag Berlin Heidelberg 2006

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

Fully automated Web service composition has been characterized as akin to
both an artificial intelligence (AI) planning task and to a restricted software
synthesis task (e.g., [1]). A composition can be achieved using classical AI planning techniques by conceiving services as primitive or complex actions and the
task description specified as a (final state) goal (e.g., [2,3]). This approach has
its drawbacks when dealing with data. In general, the search space for a composition (aka plan) is huge because of the large number of available services
(actions), which grow far larger with grounding for data.

A reasonable middle ground which we originally proposed in [4,1] is to use
generic procedures to specify the task to be performed and to customize these
procedures with user constraints. We argued that many of the tasks performed on
the Web or on intranets are repeated routinely, and the basic steps to achieving
these tasks are well understood, at least at an abstract level  travel planning
is one such example. Nevertheless, the realization of such tasks varies as it is
tailored to individual users. As such, our proposal was to specify such tasks
using a workflow or generic procedure and to customize the procedure with user
constraints at run time. Such an approach is generally of the same complexity as
planning but the search space is greatly reduced, and as such significantly more
efficient than planning without such generic advice.

In [1] we proposed to use an augmented version of the agent programming
language Golog [5] to specify our generic procedures or workflows with sufficient
nondeterminism to allow for customization. (E.g., book inter-city transporta-
tion, local transportation and accommodations in any order). User constraints
(e.g., I want to fly with Air Canada.) were limited to hard constraints (as
opposed to soft), were specified in first-order logic (FOL), and were applied to
the generic procedure at run-time to generate a user-specific composition of ser-
vices. A similar approach was adopted using hierarchical task networks (HTNs)
to represent generic procedures or templates, and realized using SHOP2 (e.g.,
[6]) without user customization of the procedures.

In this paper, we extend our Golog framework for Web service composition,
customizing Golog generic procedures not only with hard constraints but with
soft user constraints (henceforth referred to as preferences). These preferences are
defeasible and may not be mutually achievable. We argue that user preferences
are a critical and missing component of most existing approaches to Web service
composition. User preferences are key for at least two reasons. First, the users
task (specified as a goal and/or generic procedure with user constraints) is often
under constrained. As such, it induces a family of solutions. User preferences
enable a user to specify properties of solutions that make them more or less
desirable. The composition system can use these to generate preferred solutions.
A second reason why user preferences are critical to Web service composition
is with respect to how the composition is performed. A key component of Web
service composition is the selection of specific services used to realize the com-
position. In AI planning, primitive actions (the analogue of services) are selected
for composition based on their preconditions and effects, and there is often only
one primitive action that realizes a particular effect. Like actions, services are
?

?

?
selected for composition based on functional properties such as inputs, output,
preconditions and effects, but they are also selected based on domain-specific
nonfunctional properties such as, in the case of airline ticket booking, whether
they book flights with a carrier the user prefers, what credit cards they accept,
how trusted they are, etc. By integrating user preferences into Web service com-
position, preferences over services (the how) can be specified and considered
along side preferences over the solutions (the what).

In this paper we recast the problem of Web service composition as the task of
finding a composition of services that achieves the task description (specified as
a generic procedure in Golog), that achieves the users hard constraints, and that
is optimal with respect to the users preferences. To specify user preferences, we
exploit a rich qualitative preference language, recently proposed by Bienvenu et
al. to specify users preferences in a variant of linear temporal logic (LTL) [7]. We
prove the soundness of our approach and the optimality of our compositions with
respect to the users preferences. Our system can be used to select the optimal
solution from among families of solutions that achieve the users stated objective.
Our system is implemented in Prolog and integrated with a selection of scraped
Web services that are appropriate to our test domain of travel planning.

The work presented here is cast in terms of FOL, not

in terms of one of the
typical Semantic Web languages such as OWL [8] nor more specifically in terms of
a semantic Web service ontology such as OWL-S [9], WSMO [10] or SWSO [11].
Nevertheless, it is of direct significance to semantic Web services. As noted in (e.g.,
[9]) process models, necessary for Web service composition, cannot be expressed
in OWL while preserving all and only the intended interpretations of the process
model. OWL (and thus OWL-S) is not sufficiently expressive. Further OWL reasoners are not designed for the type of inference necessary for Web service composi-
tion. For both these reasons, Web service composition systems generally translate
the relevant aspects of service ontologies such as OWL-S into internal representations such as PDDL that are more amenable to AI planning (e.g., [6,12]). Golog
served as one of the inspirations for what is now OWL-S [4] and all the OWL-S
constructs have translations into Golog [13]. Further, the semantics of the OWL-
S process model has been specified in situation calculus [11,14]. Thus, our Golog
generic procedures can be expressed in OWL-S and likewise, OWL-S ontologies
can be translated into our formalism. We do not have a current implementation of
this translation, but it is conceptually straightforward.

2 Situation Calculus and Golog

We use the situation calculus and FOL to describe the functional and nonfunctional properties of our Web services. We use the agent programming language
Golog to specify composite Web services and to specify our generic procedures.
In this section, we review the essentials of situation calculus and Golog.

The situation calculus is a logical language for specifying and reasoning about
dynamical systems [5]. In the situation calculus, the state of the world is expressed in terms of functions and relations (fluents) relativized to a particular

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

situation s, e.g., F (x, s). In this paper, we distinguish between the set of fluent
predicates, F, and the set of non-fluent predicates, R, representing properties
that do not change over time. A situation s is a history of the primitive ac-
tions, a  A, performed from a distinguished initial situation S0. The function
do(a, s) maps a situation and an action into a new situation thus inducing a tree
of situations rooted in S0. Poss(a,s) is true if action a is possible in situation s.
Web services such as the Web exposed application at www.weather.com are
viewed as actions in the situation calculus and are described as actions in terms
of a situation calculus basic action theory, D. The details of D are not essential
to this paper but the interested reader is directed to [5,14,1] for further details.
Golog [5] is a high-level logic programming language for the specification and
execution of complex actions in dynamical domains. It builds on top of the situation calculus by providing Algol-inspired extralogical constructs for assembling
primitive situation calculus actions into complex actions (aka programs) . These
complex actions simply serve as constraints upon the situation tree. Complex
action constructs include the following:

a  primitive actions
1; 2  sequences
?  tests
while  do   while loops proc P (v)  endProc  procedure

if  then 1 else 2  conditionals
1|2  nondeterministic cho ice of actions
(x)  nondeterministic choice of arguments

We also include the construct anyorder[1, . . . , n] which allows any permutation of the actions listed. The conditional and while-loop constructs are defined
in terms of other constructs. For the purposes of Web service composition we
generally treat iteration as finitely bounded by a parameter k. Such finitely
bounded programs are called tree programs.

def= [?; 1] | [?; 2]
if  then 1 else 2
while1()  def= if  then  endIf 1
whilek()  def= if  then [; while k1()] endIf

These constructs can be used to write programs in the language of the domain
theory, or more specifically, they can be used to specify both composite Web
services and also generic procedures for Web service composition. E.g.2,

if far then bookCar(y) else bookTaxi(y) endIf

bookAirTicket(x) ;
bookCar(x) ; bookHotel(y).

In order to understand how we modify Golog to incorporate user preferences,
the reader must understand the basics of Golog semantics. There are two popular
semantics for Golog programs: the original evaluation semantics [5] and a related
single-step transition semantics that was proposed for on-line execution of concurrent Golog programs [15]. The transition semantics is axiomatized through
1 if-then-endIf is the obvious variant of if-then-else-endIf.
2 Following convention we will generally refer to fluents in situation-suppressed form,
e.g., at(toronto) rather than at(toronto, s). Reintroduction of the situation term is
denoted by [s]. Variables are universally quantified unless otherwise noted.
?

?

?
) and Final(, s). Given an action theory D, a
two predicates Trans(, s, 
program  and a situation s, Trans defines the set of possible successor configu-
) according to the action theory. Final defines whether a program
rations (
successfully terminated, in a given situation. Trans and Final are defined for
every complex action. A few examples follow. (See [15] for details):

, s

, s
?

?

?
Trans(nil, s, , s
Trans(a, s, , s
Trans(?, s, , s
Trans([1; 2], s, , s

Trans([1 | 2], s, , s
Trans((x), s, , s

= do(a[s], s)

= nil  s
= s

)  F alse
)  P oss(a[s], s)  
)  [s]  
= nil  s
)  Final(1, s)  Trans(2, s, , s
 .
)  Trans(1, s, , s
)  x.T rans(v

; 2)  Trans(1, s, , s
)
)  Trans(2, s, , s

x, s, , s

= (

)

)

)

Final(nil, s)  TRUE

Final(a, s)  FALSE

Final([1; 2], s)  F inal(1, s)  Final(2, s)

Thus, given the program bookCar(x); bookHotel(y), if the action bookCar(x) is

possible in situation s, then

Trans([bookCar(x); bookHotel(y)], s, bookHotel(y), do(bookCar(x), s))

the only possible transition according to the action theory.
describes
do(bookCar(x), s) is the transition and bookHotel(y) is the remaining program
to be executed. Using the transitive closure of Trans, denoted Trans, one can
define a Do predicate as follows. This Do is equivalent to the original evaluation
semantics Do [15].

Do(, s, s

) def= .Trans



(, s, , s

)  Final(, s

).

(1)
Given a domain theory, D and Golog program , program execution must
find a sequence of actions a (where a is a vector of actions) such that: D |=
Do(, S0, do(a, S0)). Do(, S0, do(a, S0)) denotes that the Golog program , starting execution in S0 will legally terminate in situation do(a, S0), where do(a, S0)
abbreviates do(an, do(an1, . . . , do(a1, S0))). Thus, given a generic procedure, described as a Golog program , and an initial situation S0, we would like to infer
a terminating situation do(a, S0) such that the vector a denotes a sequence of
Web services that can be performed to realize the generic procedure.

3 Specifying User Preferences

In this section, we describe the syntax of the first-order language we use for
specifying user preferences. This description follows the language we proposed
in [7] for preference-based planning. The semantics of the language is described
in the situation calculus. We provide an informal description here, directing
the reader to [7] for further details. Our language is richly expressive, enabling
the expression of static as well as temporal preferences. Unlike many preference
languages, it provides a total order on preferences. It is qualitative in nature,

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

facilitating elicitation. Unlike many ordinal preference languages, our language
provides a facility to stipulate the relative strength of preferences.
Illustrative example: To help illustrate our preference language, consider the
task of travel planning. A generic procedure, easily specified in Golog, might say:
In any order, book inter-city transportation, book local accommodations and book
local transportation. With this generic procedure in hand an individual user can
specify their hard constraints (e.g., Lara needs to be in Chicago July 29-Aug 5,
2006.) together with a list of preferences described in the language to follow.

To understand the preference language, consider the composition we are trying
to generate to be a situation  a sequence of actions or Web services executed
from the initial situation. A user specifies his or her preferences in terms of
a single, so-called General Preference Formula. This formula is an aggregation
of preferences over constituent properties of situations (i.e., compositions). The
basic building block of our preference formula is a Basic Desire Formula which
describes properties of (partial) situations (i.e., compositions).

Definition 1 (Basic Desire Formula (BDF)). A basic desire formula is a
sentence drawn from the smallest set B where:

1. F  B
2. R  B
3. f  F, then final(f)  B
4. If a  A, then occ(a)  B
5. If 1 and 2 are in B, then so are 1, 1  2, 1  2, (x)1, (x)1,
next(1), always(1), eventually(1), and until(1, 2).

final(f) states that fluent f holds in the final situation, occ(a) states that action
a occurs in the present situation, and next(1), always(1), eventually(1), and
until(1, 2) are basic LTL constructs.

BDFs establish properties of preferred situations (i.e., compositions of ser-
vices). By combining BDFs using boolean connectives we are able to express a
wide variety of properties of situations. E.g.3
?

?

?
(bookAir(c, economy, direct))  member(c, starAlliance)

(P1)
(P2)
(P3)

(P4)

final(at(home))
( c).occ
always((( h).hotelBooked(h)  hilton(h)))
( h, r).(occ

(bookHotel(h, r))  paymentOption(h, visa)
?

?

?
 starsGE(r, 3)

P1 says that in the final situation Lara prefers to be at home. P2 says that
Lara prefers to eventually book direct economy air travel with a Star Alliance
carrier. Recall there was no stipulation in the generic procedure regarding the
mode of transportation between cities or locally. P3 expresses the preference

3 To simplify the examples many parameters have been suppressed. For legibility,
variables are bold faced, we abbreviate eventually(occ()) by occ(), and we
refer to the preference formulae by their labels.
?

?

?
that a Hilton hotel never be booked while P4 expresses a preference for hotels
that accept visa credit cards and have a rating of 3 stars or more.

To define a preference ordering over alternative properties of situations, we
define Atomic Preference Formulae (APFs). Each alternative being ordered comprises 2 components: the property of the situation, specified by a BDF, and a
value term which stipulates the relative strength of the preference.
Definition 2 (Atomic Preference Formula (APF)). Let V be a totally ordered set with minimal element vmin and maximal element vmax. An atomic preference
formula is a formula 0[v0]  1[v1]  ...  n[vn], where each i is a BDF, each
vi  V, vi < vj for i < j, and v0 = vmin. When n = 0, atomic preference formulae
correspond to BDFs.
An APF expresses a preference over alternatives. In what follows, we let V =
[0, 1], but we could instead choose a strictly qualitative set like {best < good <
indifferent < bad < worst} since the operations on these values are limited to
max and min. The following APFs express an ordering over Laras preferences.

P2[0]

 ( c, w).occ
?

?

?
(bookAir(c, economy, w)  member(c, starAlliance)[0.2]
?

?

?
 occ
(bookCar(national, t))[0]  ( t).occ
?

?

?
(bookAir(delta, economy, direct))[0.5]
?

?

?
( t).occ

(bookCar(alamo, t))[0.2]

(P5)

(P6)
(P7)

 ( t).occ
?

?

?
(bookCar(avis, t))[0.8]

( c).occ
?

?

?
(bookCar(c, suv))[0]  ( c).occ
?

?

?
(bookCar(c, compact))[0.2]

P5 states that Lara prefers direct economy flights with a Star Alliance car-
rier, followed by economy flights with a Star Alliance carrier, followed by direct
economy flights with Delta airlines. P6 and P7 are preference over cars. Lara
strongly prefers National and then Alamo over Avis, followed by any other carrental companies. Finally she slightly prefers an SUV over a compact with any
other type of car a distant third.

To allow the user to specify more complex preferences and to aggregate prefer-
ences, General Preference Formulae (GFPs) extend our language to conditional,
conjunctive, and disjunctive preferences.

Definition 3 (General Preference Formula (GPF)). A formula  is a general preference formula if one of the following holds:

  is an APF
  is  : , where  is a BDF and  is a GPF [Conditional]
  is one of

- 0 & 1 & ... & n [General Conjunction]
- 0 | 1 | ... | n [General Disjunction]

where n  1 and each i is a GPF.

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

Continuing our example:

( h, c, e, w).always(hotelBooked(h) : occ
f ar : P5
P3 & P4 & P6 & P7 & P8 & P9
?

?

?
(bookAir(c, e, w)))

(P8)
(P9)
(P10)

P8 states that Lara prefers not to book her air ticket until she has a hotel
booked. P9 conditions Laras airline preferences on her destination being far
away. (If it is not far, she will not fly and the preferences are irrelevant.) Finally,
P10 aggregates previous preferences into one formula.

Semantics: Informally, the semantics of our preference language is achieved
through assigning a weight to a situation s with respect to a GPF, , written
ws(). This weight is a composition of its constituents. For BDFs, a situation
s is assigned the value vmin if the BDF is satisfied in s, vmax otherwise. Recall
that in our example above vmin = 0 and vmax = 1, though they could equally
well have been a qualitative e.g., [excellent, abysmal]. Similarly, given an APF,
and a situation s, s is assigned the weight of the best BDF that it satisfies
within the defined APF. Returning to our example above, for P6 if a situation
(composition) booked a car from Alamo rental car, it would get a weight of 0.2.
Finally GPF semantics follow the natural semantics of boolean connectives. As
such General Conjunction yields the maximum of its constituent GPF weights
and General Disjunction yields the minimum of its constituent GPF weights. For
a full explanation of the situation calculus semantics, please see [7]. Here we also
define further aggregations that can be performed. These are mostly syntactic
sugar that are compelling to the user and we omit them for space.

We conclude this section with the following definition which shows us how to

compare two situations (and thus two compositions) with respect to a GPF:

Definition 4 (Preferred Situations). A situation s1 is at least as preferred as
a situation s2 with respect to a GPF , written pref(s1, s2, ) if ws1()  ws2().

4 Web Service Composition
In this section, we define the notion of web service composition with generic
procedures and customizing user preferences, present an algorithm for computing
these compositions and prove properties of our algorithm. Our definition relies
on the definition of Do from (1) in Section 2.

Definition 5 (Web Service Composition w/User Preferences (WSCP)).
A Web service composition problem with user preferences is described as a 5-tuple
(D, O, , C, ) where:
 D is a situation calculus basic action theory describing functional properties of the
Web services,
 O is a FOL theory describing the non-functional properties of the Web services4,
4 The content of D and O would typically come from an OWL-S, SWSO, or other
semantic Web service ontology.
?

?

?
  is a generic procedure described in Golog,
 C is a formula expressing hard user constraints, and
  is a GPF describing user preferences.
A Web Service Composition (WSC) is a sequence of Web services a such that

D  O |= s.Do(, S0, s)  s = do(a, S0)  C(s)

A preferred WSC (WSCP) is a sequence of Web services a such that

D  O |= s.Do(, S0, s, )  s = do(a, S0)  C(s)

  s.[Do(, S0, s, )  C(s

)  pref(s, s, )]

I.e., a WSC is a sequence of Web services, a, whose execution starting in the
initial situation enforces the generic procedure and hard constraints terminating
successfully in do(a, s). A WSCP yields a most preferred terminating situation.

4.1 Computing Preferred Compositions

A Golog program places constraints on the situation tree that evolves from S0. As
such, any implementation of Golog is effectively doing planning in a constrained
search space, searching for a legal termination of the Golog program. The actions
that define this terminating situation are the plan. In the case of composing web
services, this plan is a web service composition.

To compute a preferred composition, WSCP, we search through this same
constrained search space to find the most preferred terminating situation. Our
approach, embodied in a system called GologPref, searches for this optimal terminating situation by modifying the PPLAN approach to planning with preferences proposed in [7]. In particular, GologPref performs best-first search through
the constrained search space resulting from the Golog program, ; C. The search
is guided by an admissible evaluation function that evaluates partial plans with
respect to whether they satisfy the preference formula, . The admissible evaluation function is the optimistic evaluation of the preference formula, with the
pessimistic evaluation and the plan length used as tie breakers where necessary,
in that order.

The preference formula is evaluated over intermediate situations (partial com-
positions) by exploiting progression as described in [7]. Informally, progression
takes a situation and a temporal logic formula (TLF), evaluates the TLF with
respect to the state of the situation, and generates a new formula representing
those aspects of the TLF that remain to be satisfied in subsequent situations.
Fig 1 provides a sketch of the basic GologPref algorithm following from PPLAN .
The full GologPref algorithm takes as input a 5-tuple (D, O, , C, ). For ease of
explication, our algorithm sketch in Fig 1 explictly identifies the initial situation
of D, init, the Golog program, ; C which we refer to as pgm and , which we refer to as pref. GologPref returns a sequence of Web services, i.e. a plan, and the
weight of that plan. The frontier is a list of nodes of the form [optW, pessW, pgm,
partialPlan, state, pref ], sorted by optimistic weight, pessimistic weight, and then
by length. The frontier is initialized to the input program and the empty partial

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

GologPref(init, pgm, pref )
frontier  initFrontier(init, pgm, pref )
while frontier = 
current  removeFirst(frontier)
% establishes current values for progPgm, partialPlan, state, progPref
if progPgm=nil and optW =pessW

return partialPlan, optW

end if
neighbours  expand(progPgm, partialPlan, state, progPref )
frontier  sortNmergeByVal(neighbours, frontier)

end while
return [], 

expand(progPgm, partialPlan, state, progPref ) returns a list of new nodes to add
to the frontier. If partialPlan=nil then expand returns [ ]. Otherwise, expand uses
Gologs Trans to determine all the executable actions that are legal transitions of
progPgm in state and to compute the remaining program for each.
It returns a list which contains, for each of these executable actions a a node

(optW, pessW,newProgPgm, newPartialPlan, newState, newProgPref )

and for each a leading to a terminating state, a second node

(realW, realW, nil, newPartialPlan, newState, newProgPref ).

Fig. 1. A sketch of the GologPref algorithm

plan, its optW, pessW, and pref corresponding to the progression and evaluation
of the input preference formula in the initial state.

On each iteration of the while loop, GologPref removes the first node from
the frontier and places it in current. If the Golog program of current is nil then
the situation associated with this node is a terminating situation. If it is also
the case that optW =pessW, then GologPref returns currents partial plan and
weight. Otherwise, it calls the function expand with currents node as input.

expand returns a new list of nodes to add to the frontier. If progPgm is
nil then no new nodes are added to the frontier. Otherwise, expand generates
a new set of nodes of the form [optW, pessW, prog, partialPlan, state, pref ], one
for each action that is a legal Golog transition of pgm in state. For actions leading
to terminating states, expand also generates a second node of the same form
but with optW and pessW replaced by the actual weight achieved by the plan.
The new nodes generated by expand are then sorted by optW, pessW, then
length and merged with the remainder of the frontier. If we reach the empty
frontier, we exit the while loop and return the empty plan.

We now prove the correctness of our algorithm.

Theorem 1 (Soundness and Optimality). Let P=(D, O, , C, ) be a Web
service composition problem, where  is a tree program. Let a be the plan returned by
GologPref

from input P. Then a is a WSCP of (D, O, , C, ).
?

?

?
Proof sketch: We prove that the algorithm terminates appealing to the fact that
 is a tree program. Then we prove that a is a WSC by cases over Trans and
Final. Finally we prove that a is also optimal, by exploiting the correctness of
progression of preference formuale proven in [7], the admissibility of our evaluation function, and the bounded size of the search space generated by the Golog
program ; C.

4.2 Integrated Optimal Web Service Selection

Most Web service composition systems use AI planning techniques and as such
generally ignore the important problem of Web service selection or discovery,
assuming it will be done by a separate matchmaker. The work presented here
is significant because it enables the selection of services for composition based,
not only on their inputs, outputs, preconditions and effects but also based on
other nonfunctional properties. As such, users are able to specify properties of
services that they desire along side other properties of their preferred solution,
and services are selected that optimize for the users preferences in the context
of the overall composition.

To see how selection of services can be encoded in our system, we reintroduce
the service parameter u which was suppressed from the example preferences in
Section 3. Revisiting P2, we see how the selection of a service u is easily realized
within our preference framework with preference P2.

( c, u).occ
?

?

?
(bookAir(c, economy, direct, u))  member(c, starAlliance)

 serviceT ype(u, airT icketV endor)  sellsT ickets(u, c)

(P2)

5 Implementation and Application

We have implemented the generation of Web Service compositions using generic
procedures and customizing user preferences as described in previous sections.
Our implementation, GologPref, builds on an implementation of PPLAN [7]
and an implementation of IndiGolog [5] both in SWI Prolog5.

GologPref interfaces with Web services on the Web through the implementation of domain-specific scrapers developed using AgentBuilder 3.2, and AgentRunner 3.2, Web agent design applications developed by Fetch Technologies c(.
Among the sites we have scraped are Mapquest, and several air, car and hotel
services. The information gathered is collected in XML and then processed by
GologPref.

We tested GologPref in the domain of travel planning. Our tests serve predominantly as a proof of the concept and to illustrate the utility of GologPref.
Our generic procedure which is represented in Golog was very simple, allowing
flexibility in how it could be instantiated. What follows is an example of the
Prolog encoding of a GologPref generic procedure.
5 See [5] for a description of the translation of D to Prolog.

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

anyorder [bookAcc, bookCityToCityTranspo, bookLocalTranspo]

proc(bookAcc(Location, Day, Num),
[ stayWithFriends(Location) | bookHotel(Location, Day, Num) ]).

proc(bookLocalTranspo(Location, StartDay, ReturnDay),
[

getRide(Location, StartDay, ReturnDay)
walk(Location)

|

|

bookCar(Location, StartDay, ReturnDay)

]).

proc(bookCityToCityTranspo(Location, Des, StartDay, ReturnDay),
[

getRide(Location, Des, StartDay, ReturnDay) |
bookAir(Location, Des, StartDay, ReturnDay) |
bookCar(Location, Des, StartDay, ReturnDay) ]).

We tested our GologPref generic procedure with 3 different user profiles: Jack
the impoverished university student, Lara the picky frequent flyer, and Conrad
the corporate executive who likes timely luxury travel. Each user lived in Toronto
and wanted to be in Chicago for specific days. A set of rich user preferences were
defined for each user along the lines of those illustrated in Section 3. These
preferences often required access to different Web information, such as driving
distances. Space precludes listing of the preferences, code and full test results,
but these are available at http://www.cs.toronto.edu/~sheila/gologpref/.

Not surprisingly, in all cases, GologPref found the optimal WSC for the user.
Compositions varied greatly ranging from Jack who arranged accommodations
with friends; checked out the distance to his local destinations and then arranged
his local transportation (walking since his local destination was close to where he
was staying); then once his accommodations were confirmed, booking an economy air ticket Toronto-Chicago with one stop on US Airways with Expedia. Lara
on the other hand, booked a hotel (not Hilton), booked an intermediate-sized
car with National, and a direct economy air ticket with Star Alliance partner
Air Canada via the Air Canada Web site. The optimality and the diversity of
the compositions, all from the same generic procedure, illustrate the flexibility
afforded by the WSCP approach.

Figure 2 shows the number of nodes expanded relative to the search space size
for 6 test scenarios. The full search space represents all possible combinations
of city-to-city transportation, accommodations and local transportation available to the users which could have been considered. These results illustrate the
effectiveness of the heuristic used to find optimal compositions.

6 Summary and Related Work

In this paper we argued that the integration of user preferences into Web service
composition was a key missing component of Web service composition. Building
on our previous framework for Web service composition via generic procedures
[1] and our more recent work on preference-based planning [7], we proposed a
system for Web service composition with user preferences. Key contributions of
this paper include: characterization of the task of Web service composition with
?

?

?
Case

Nodes

Nodes

Number Expanded Considered
?

?

?
Nodes in

Time
(sec) Full Search Space
28,512
28,512
28,512
28,512
28,512
28,512

20.97
19.93
2.88
2.92
21.48
21.29

Fig. 2. Test results for 6 scenarios run under Windows XP with a 593MHz processor
and 512 MB of RAM. The times shown are five run averages.

generic procedures and user preferences, provision of a previously developed language for specifying user preferences, provision of the GologPref algorithm that
integrates preference-based reasoning into Golog, a proof of the soundness and
optimality of GologPref with respect to the users preferences, and a working
implementation of our GologPref algorithm. A notable side effect of our framework is the seamless integration of Web service selection with the composition
process.

We tested GologPref on 6 diverse scenarios applied to the same generic pro-
cedure. Results illustrated the diversity of compositions that could be generated
from the same generic procedure. The number of nodes expanded by the heuristic search was several orders of magnitude smaller than the grounded search
space, illustrating the effectiveness of the heuristic and the Golog program in
guiding search.

A number of researchers have advocated using AI planning techniques to
address the task of Web service composition including using regression-based
planners [2], planners based on model checking (e.g., [3]), highly optimized hierarchical task network (HTN) planners such as SHOP2 (e.g., [16]), and most
recently a combination of classical and HTN planning called XPLAN [12]. Like
Golog, HTNs afford the user the ability to define a generic procedure or template
of how to perform a task.

Recently Sirin et al. incorporated simple service preferences into the SHOP2
HTN planner to achieve dynamic service binding [6]. Their preference language
is significantly less expressive than the one presented here and is restricted to
the task of service selection rather than solution optimization. Nevertheless, it is
a promising start. The most related previous work was performed by Fritz and
the third author in which they precompiled a subset of the preference language
presented here into Golog programs that were then integrated with a decisiontheoretic Golog (DTGolog) program [17]. The main objective of this work was
to provide a means of integrating qualitative and quantitative preferences for
agent programming. While both used a form of Golog, the form and processing
of preferences was quite different. We know of no other work integrating preferences into Web service composition. Nevertheless, there is a recent focus on
preference-based planning. Early preference-based planners include PPLAN [7]

S. Sohrabi, N. Prokoshyna, and S.A. McIlraith

and an approach to preference-based planning using answer set programming
[18]. A number of preference-based planners were developed for the 2006 International Planning Competition (IPC-5) and are yet to be published. Preliminary
descriptions of these planners can be found at http://zeus.ing.unibs.it/ipc-5/.

Acknowledgements

Thanks to Meghyn Bienvenu for her work on PPLAN which was fundamental
to the realization of this work. Thanks to Christian Fritz for useful discussions
and to Fetch Technologies for allowing us to use their AgentBuilder software.
We also gratefully acknowledge the Natural Sciences and Engineering Research
Council of Canada (NSERC) and the CRAs Canadian Distributed Mentorship
Project (CDMP) for partially funding this research.
