Web Semantics: Science, Services and Agents

on the World Wide Web 4 (2006) 2939

OWL-Eu: Adding customised datatypes into OWL


Jeff Z. Pan

, Ian Horrocks

School of Computer Science, University of Manchester, Kilburn Building, Manchester M13 9PL, UK

Received 9 May 2005; received in revised form 20 July 2005; accepted 10 August 2005

Abstract

Although OWL is rather expressive, it has a very serious limitation on datatypes; i.e., it does not support customised datatypes. It has been
pointed out that many potential users will not adopt OWL unless this limitation is overcome, and the W3C Semantic Web Best Practices and
Development Working Group has set up a task force to address this issue. This paper makes the following two contributions: (i) it provides a brief
summary of OWL-related datatype formalisms, and (ii) it provides a decidable extension of OWL DL, called OWL-Eu, that supports customised
datatypes. A detailed proof of the decidability of OWL-Eu is presented.
 2005 Elsevier B.V. All rights reserved.

Keywords: Ontologies; Semantic Web; Description Logics; Customised Datatypes; Unary datatype groups

1. Introduction

The OWL Web Ontology Language [3] is a W3C recommendation for expressing ontologies in the Semantic Web. Datatype
support [17,18] is one of the key features that OWL is expected
to provide, and has prompted extensive discussions in the RDFLogic mailing list [21] and in the Semantic Web Best Practices
mailing list [23]. Although OWL adds considerable expressive
power to the Semantic Web, the OWL datatype formalism (or
simply OWL datatyping) is much too weak for many applica-
tions; in particular, OWL datatyping does not provide a general
framework for customised datatypes,1 such as XML Schema
derived datatypes.

It has been pointed out that many potential users will not
adopt OWL unless this limitation is overcome [22], as it is often necessary to enable users to define their own datatypes and
datatype predicates for their ontologies and applications.

Example 1. Customised datatypes are important in capturing
the intended meaning of some vocabulary in ontologies. For

 This is a revised and extended version of a paper with the same title that was
published in the Second European Semantic Web Conference (ESWC2005).


Corresponding author. Tel.: +44 161 275 6139;

fax: +44 161 275 6204.

E-mail addresses: pan@cs.man.ac.uk (J. Pan),

horrocks@cs.man.ac.uk (I. Horrocks).

1 A widely discussed example would be the BigWheel example discussed in,
e.g., http://lists.w3.org/Archives/Public/public-swbp-wg/2004Apr/0061.html.

1570-8268/$  see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2005.08.001

example, the customised datatype atLeast18 can be used in
the following definition of the class Adult:

Class(Adult complete Person

restriction(age allvalueFrom

(atLeast18))),

which says that an Adult is a Person whose age is at least 18.
The datatype constraint at least 18 can be defined as an XML
Schema user-defined datatype as follows:

<simpleType name=atLeast18">

<restriction base=xsd:integer">

<minInclusive value=18"/ >

< /restriction>

< /simpleType>2

Such user-defined datatypes cannot, however, be used in OWL.

After reviewing the design of OWL, and the needs of various
applications and (potential) users, the following requirements
for an extension to OWL DL have been identified:

1. It should provide customised datatypes; therefore, it should
be based on a datatype formalism which is compatible with
OWL datatyping, provides facilities to construct customised

2 More details of XML Schema Datatypes can be found in Section 3.1.

J.Z. Pan, I. Horrocks / Web Semantics: Science, Services and Agents on the World Wide Web 4 (2006) 2939

datatypes and, most importantly, guarantees the computability of the kinds of customised datatypes it supports.

2. It should overcome other important limitations of OWL
datatyping, such as the absence of negated datatypes and the
un-intuitive semantics for unsupported datatypes (which will
be further explained in Section 4).

3. It should satisfy the small extension requirement, which is
two folded: on the one hand, the extension should be a substantial and necessary extension that overcomes the above
mentioned limitations of OWL datatyping; on the other hand,
following W3Cs one small step at a time strategy, it should
only be as large as is necessary in order to satisfy the require-
ments.

4. It should be a decidable extension of OWL DL.

This paper makes two main contributions. Firstly, it provides
an overview of relevant (to OWL) datatype formalisms, namely
those of XML, RDF and OWL itself. Secondly, and most im-
portantly, it presents an extension of OWL DL,3 called OWL
with unary datatype Expressions (OWL-Eu), which satisfies the
above requirements.

The rest of the paper is organised as follows. Section 2
briefly introduces the OWL Web Ontology Language. Section
3 describes OWL-related datatype formalisms. Section 4 summarises the limitations of OWL datatyping. Section 5 presents
the OWL-Eu language, showing how it satisfies the above four
requirements. Section 6 describes some related work, and Section 7 concludes the paper and suggests some future work.

2. An overview of OWL

OWL is a standard (W3C recommendation) for expressing
ontologies in the Semantic Web. The OWL language facilitates
greater machine understandability of Web resources than that
supported by RDFS by providing additional constructors for
building class and property descriptions (vocabulary) and new
axioms (constraints), along with a formal semantics. The OWL
recommendation actually consists of three languages of increasing expressive power: OWL Lite, OWL DL and OWL Full. OWL
Lite and OWL DL are, like DAML + OIL, basically very expressive Description Logics (DLs); they are almost4 equivalent to

the SHIF(D
) DLs. OWL Full provides the
same set of constructors as OWL DL, but allows them to be used
in an unconstrained way (in the style of RDF). It is easy to show
that OWL Full is undecidable, because it does not impose restrictions on the use of transitive properties [12]; therefore, when
we mention OWL in this paper, we usually mean OWL DL.

) and SHOIN(D+

Let C, RI, RD and I be the sets of URIrefs that can be used
to denote concepts, individual-valued properties, data-valued
properties and individuals respectively. An OWL DL interpretation is a tuple I = (
,D) where the individual domain
I is a nonempty set of individuals, the datatype domain D is
a nonempty set of data values, I is an individual interpretation
function that maps

, D,I


 each individual name a  I to an element aI  
I,
 each concept name CN  C to a subset CNI  
I,
 each individual-valued property name RN  RI to a binary
 each data-valued property name TN  RD to a binary relation

I and

relation RN

I  D,


and D is a datatype interpretation function. More details of D
and D will be presented in Section 3.3.
Let RN  RI an individual-valued property URIref, R an
individual-valued property, TN  RD a data-valued property
URIref and T a data-valued property. Valid OWL DL individualvalued properties are defined by the DL syntax:
R ::= RN|R
valid OWL DL data-valued properties are defined by the DL
syntax:
T ::= TN.
Let CN  C be a concept name, C, D concept descriptions, o 
I an individual, u an OWL datatype range (cf. Definition 8)
and m  N an integer. Valid OWL DL concept descriptions are
defined by the DL syntax:
C ::= || CN|C | C  D| C  D|{o}

R.C |R.C |  mR,|  mR
T.u|T.u|  mT,|  mT

The individual interpretation function can be extended to give
semantics to concept and property descriptions shown in Table
1, where A  C is a concept URIref, C, C1, . . . , Cn are concept
descriptions, S  RI is an individual-valued property URIref,
R is an individual-valued property description and o, o1, o2  I
are individual URIrefs, u is a data range (cf. Definition 8), T 
RD is a data-valued property and  denotes cardinality.

An OWL DL ontology can be seen as a DL knowledge base
[10], which consists of a set of axioms, including class axioms,
property axioms and individual axioms.5 Table 2 presents the abstract syntax, DL syntax and semantics of OWL axioms, where
R1, . . . , Rn are individual-valued property descriptions. More
details of the semantics of OWL DL can be found in [19].

3. Datatype formalisms

In this section we will provide a brief overview of the XML,

RDF and OWL datatype formalisms.

3.1. XML Schema Datatypes

W3C XML Schema Part 2 [4] defines facilities for defining
simple types to be used in XML Schema as well as other XML
specifications.

Definition 1. An XML Schema simple type d is characterised by
a value space, V (d), which is a non-empty set, a lexical space,

3 cf. Section 2 for the differences of three sub-languages of OWL.
4 They also provide annotation properties, which Description Logics do not.

5 Individual axioms are also called facts.

Table 1
OWL concept and property descriptions

Abstract syntax

Class(A)
Class(owl:Thing)
Class(owl:Nothing)

intersectionOf(C1, C2, . . .)
unionOf(C1, C2, . . .)
complementOf(C)
oneOf(o1, o2, . . .)

restriction(R someValuesFrom(C))
restriction(R allValuesFrom(C))
restriction(R hasValue(o))
restriction(R minCardinality(m))
restriction(R maxCardinality(m))

restriction(T someValuesFrom(u))
restriction(T allValuesFrom(u))
restriction(T hasValue(w))
restriction(T minCardinality(m))
restriction(T maxCardinality(m))

ObjectProperty(S)

ObjectProperty(S
DatatypeProperty(T)

inverseOf(S))

DL syntax

C1  C2
C1  C2

{o1}  {o2}
R.C
R.C
R.{o}
 mR
 mR
T.u
T.u
T.{w}
 mT
 mT

1 , oI

Semantics

I = 
I = 
(C1  C2)I = C

(C1  C2)I = C

(C)I = 
I \ C
({o1}  {o2})I = {oI

(R.C)I = {x|y.x, y  R
I}
I  y  C
(R.C)I = {x|y.x, y  R
I  y  C
I}
(R.{o})I = {x|x, oI  R
I}
( mR)I = {x|{y.x, y  R
I}  m}
( mR)I = {x|{y.x, y  R
I}  m}
(T.u)I = {x|t.x, t  T
I  t  uD}
I  t  uD}
(T.u)I = {x|t.x, t  T
(T.{w})I = {x|x, wD  T
I}
( mT )I = {x|{t|x, t  T
I}  m}
( mT )I = {x|{t|x, t  T
I}  m}

)I  

(S


I  D

L(d), which is a non-empty set of Unicode [6] strings, and a set
of facets, F (d), each of which characterizes a value space along
independent axes or dimensions.

XML Schema simple types are divided into disjoint builtin simple types and derived simple types. Derived datatypes
can be defined by derivation from primitive or existing derived
datatypes by the following three means:

 Derivation by restriction, i.e., by using facets on an existing
type, so as to limit the number of possible values of the derived
type.
 Derivation by union, i.e., to allow values from a list of simple
 Derivation by list, i.e., to define the list type of an existing

types.

simple type.

Table 2
OWL axioms

Abstract syntax

Class(A partial C1 . . . Cn)
Class(A complete C1 . . . Cn)
EnumeratedClass(Ao1 . . . on)
SubClassOf(C1, C2)
EquivalentClasses(C1 . . . Cn)
DisjointClasses(C1 . . . Cn)
SubPropertyOf(R1, R2)
EquivalentProperties(R1 . . . Rn)
ObjectProperty(R super(R1) . . . super(Rn)

domain (C1) . . . domain(Ck)
range (C1) . . . range(Ch)
[Symmetric]
[Functional]
[InverseFunctional]
[Transitive])

AnnotationProperty(R)
Individual(o type(C1) . . . type(Cn))

value(R1, o1) . . . value(Rn, on)

SameIndividual(o1 . . . on)
DifferentIndividuals(o1 . . . on)

DL syntax
A  C1  . . .  Cn
A  C1  . . .  Cn
A  {o1}  . . .  {on}
C1  C2
C1  . . .  Cn
Ci  Cj, (1  i < j  n)
R1  R2
R1  . . .  Rn
R  Ri
 1R  Ci
  R.Ci
R  R
Func(R)

Func(R
Trans(R)


 : Ri, 1  i  n

o : Ci, 1  i  n
o,oi
o1 = . . . = on
oi = oj , 1  i < j  n

= , (1  i < j  n)

Semantics
AI  C
 . . .  C

 . . .  C
AI = C

AI = {oI

1 , . . . , oI

= . . . = C


= . . . = R
I  R
I  C

I = (R
{x, y|{y.x, y  R
{x, y|{y.x, y  (R
I = (R

I  C

)I

I)

I}  1}
)I}  1}


oI  C
i , 1  i  n
oI

, oI
= . . . = oI
oI

= oI
oI

i , 1  i  n
j , 1  i < j  n

J.Z. Pan, I. Horrocks / Web Semantics: Science, Services and Agents on the World Wide Web 4 (2006) 2939

The atLeast18 datatype defined in Example 1 is a derived
simple type (of the base datatype xsd:integer), the value space
of which is restricted to integers that are greater than or equal
to 18 using the facet minInclusive. The cameraPrice datatype
defined in Example 4 is a derived simple type by union.

Details of XML Schema derived simple types by list and
complex types can be found in [4]. As they are not consistent
with the RDF datatype model to be presented in the next section,
they are out of the scope of this paper.

3.2. Datatypes in RDF

According to [8], RDF allows the use of datatypes defined by
any external type systems, e.g., the XML Schema type system,
which conform to the following specification.

Definition 2. A datatype d is characterised by a lexical space,
L(d), which is an non-empty set of Unicode strings; a value
space, V (d), which is an non-empty set, and a total mapping
L2V (d) from the lexical space to the value space.

This specification allows the use of non-list XML Schema
built-in simple types as datatypes in RDF, although some builtin XML Schema datatypes are problematic because they do not
fit the RDF datatype model.6 Furthermore, comparisons between
Definitions 1 and 2 show that RDF does not take XML Schema
facets into account, which are essential to define derived simple
types.

In RDF, data values are represented by literals.

Definition 3. All literals have a lexical form being a Unicode
string. Typed literals are of the form s u, where s is a Unicode string, called the lexical form of the typed literal, and u
is a datatype URI reference. Plain literals have a lexical form
and optionally a language tag as defined by [1], normalised to
lowercase.

lexical

Example 2. Boolean is a datatype with value space
{true, false},
{true, false, 1, 0}
and lexical-to-value mapping {true  true, false 
false, 1  true, 0  false}. true xsd:boolean is a
typed literal, while true is a plain literal.

space

The associations between datatype URI references (e.g.,
xsd:boolean) and datatypes (e.g., boolean) can be provided by
datatype maps defined as follows.

Definition 4. A datatype map Md is a partial mapping from
datatype URI references to datatypes.

Note that XML Schema derived simple types are not RDF
datatypes because XML Schema provides no mechanism for
using URI references to refer to derived simple types.

The semantics of RDF datatypes are defined in terms of Md-
interpretations, which extend RDF-interpretations and RDFSinterpretations (cf. RDF Semantics [8]) with extra conditions
for datatypes.

6 Readers are referred to [8] for more details.

verse) of I,

of IR) called the set of properties in I,

Definition 5. Given a datatype map Md, an RDFS Mdinterpretation I of a vocabulary V (a set of URIrefs and plain
literals) is any RDFS-interpretation of V  {u|d.u, d  Md}
which introduces
 a non-empty set IR of resources, called the domain (or uni-
 a set IP (the RDF-interpretation requires IP to be a sub-set
 a set IC (the RDFS-interpretation requires IC to be a sub-set
 a distinguished subset LV of IR, called the set of literal values,
which contains all the plain literals in V,
 a mapping IS from URIrefs in V to IR,
 a mapping IEXT, called the extension function, from IP to the
 a mapping ICEXT, called the class extension function, from
 a mapping IL from typed literals in V into IR,

of IR) called the set of classes in I, and

powerset of IR  IR,

IC to the set of subsets of IR,

and satisfies the following extra conditions:

1. LV = ICEXT(IS(rdfs:Literal)),
2. for each plain literal pl, IL(pl) = pl,
3. for each pair u, d  Md,

(a) ICEXT (d) = V (d)  LV,
(b) there exist d  IR s.t. IS(u) = d,
(c) IS(u)  ICEXT (IS(rdfs:Datatype)),
) = d,
(d) for
if

IL(s u
IR \ LV,
d  ICEXT (IS(rdfs:Datatype)),
Literal)  IEXT (rdfs:subClassOf).

  V, IS(u

) = L2V (d)(s),

s u

otherwise,

4. if

s  L(d),

then

IL(s u
d, IS(rdfs:

then

According to Definition 5, LV is a subset of IR, i.e., literal
values are resources. Condition 1 ensures that the class extension
of rdfs:Literal is LV. Condition 2 ensures that the plain literals
are interpreted as themselves, and that LV contains interpretations of all valid typed literals of datatypes in Md. Condition 3a
asserts that RDF(S) datatypes are classes (because datatypes are
interpreted using the class extension function ICEXT), Condition 3b ensures that there is a resource d for datatype d in Md,
and Condition 3c ensures that the class rdfs:Datatype contains
the datatypes used in any satisfying Md-interpretation. Condition 3d explains why the range of IL is IR rather than LV
(because, for s  u, if s  L(IS(u)), then IL(s u) / LV);
note that this is different from OWL datatypes (cf. Definition 9).
Condition 4 requires that RDF(S) datatypes are sub-classes of
rdfs:Literal.

3.3. Datatypes in OWL

OWL datatyping adopts the RDF specification of datatypes
and data values. It extends RDF datatyping by (i) allowing different OWL reasoners to provide different supported
datatypes, and (ii) introducing the use of so called enumerated
datatypes.

Definition 6. Given a datatype map Md, a datatype URI reference u is called a supported datatype URI reference w.r.t Md
if there exists a datatype d s.t. Md(u) = d (in this case, d is
called a supported datatype w.r.t. Md); otherwise, u is called an
unsupported datatype URI reference w.r.t. Md.
Definition 7. Let y1, . . . , yn be typed literals. An enumerated
datatype is of the form oneOf(y1, . . . , yn).

The kinds of datatypes provided by OWL are called OWL
data ranges, which can be used in datatype-related class de-
scriptions. In fact, in line (13) and (14) of Table 1, u is an OWL
data range.

Definition 8. An OWL data range has one of the forms: (i)
a datatype URI reference, (ii) an enumerated datatype, or (iii)
rdf:Literal.

The semantics of OWL DL datatypes are defined in terms of

which (customised) datatypes can be used together so that
the language is still decidable.

2. OWL does not support negated datatypes. For example, all
integers but 0, which is the relativised negation of the enumerated datatype oneOf(0 xsd:integer), is not expressible in OWL. Moreover, negated datatypes are necessary in
the negated normal form (NNF)8 of datatype-related class
descriptions in, e.g., DL tableaux algorithms.

3. An OWL DL datatype domain seriously restricts the interpretations of typed literals with unsupported datatype
URIrefs. According to Definition 9, datatype domain
is equal
to the set of all plain literals together with
the value spaces of all supported datatypes. For ex-
ample, given the datatype map Md1 = {xsd:integer 
integer, xsd:string  string}, 1.278e-3  xsd:float has to
be interpreted as either an integer, a string or a string with a
language tag, which is counter-intuitive.

OWL datatype interpretations.
D = PL 
Definition 9. An OWL datatype interpretation w.r.t. to a
datatype map Md is a pair (D,D), where the datatype domain
V (Mp(u))

for each supported datatype URIref u w.r.t. Mp

(PL is the value space for plain literals, i.e., the union of the
set of Unicode strings and the set of pairs of Unicode strings
and language tags) and D is a datatype interpretation function,
which has to satisfy the following conditions:
1. rdfs:LiteralD = D;
2. for each plain literal l, lD = l  PL;
3. for each supported datatype URIref u (let d = Md(u)):

4. for each unsupported datatype URIref u, uD  D, and

(a) uD = V (d)  D,
(b) if s  L(d), then (s u)D = L2V (d)(s),
(c) if s  L(d), then (s u)D is not defined;
(s u)D  uD.
 . . .  yD
n .

as yD

5. each enumerated datatype oneOf(y1, . . . , yn) is interpreted

The above definition shows that OWL datatyping is similar
to RDF datatyping, except that (i) RDF datatypes are classes,
while OWL DL datatypes are not classes,7 and (ii) in RDF
ill-defined typed literals are interpreted as resources in IR \ LV,
while in OWL DL the interpretation of ill-defined typed literals
are undefined.
4. Limitations of OWL datatyping

OWL datatyping has the following serious limitations, which
discourage potential users from adopting OWL DL in their SW
and ontology applications [16,22].

1. OWL does not support customised datatypes (except enumerated datatypes). Firstly, XML Schema derived simple
types are not OWL DL datatypes, because of the problem
of datatype URI references for XML Schema derived simple
types. Secondly, OWL does not provide a mechanism to tell

7 In fact, classes and datatypes in OWL DL use different interpretation func-

tions; cf. Section 2.

5. OWL-Eu

This section presents OWL-Eu and elaborates how OWLEu satisfies the four requirements (listed in Section 1) in the
following four sub-sections.

5.1. Supporting Customised Datatypes

OWL-Eu supports customised datatypes through unary
datatype expressions based on unary datatype groups. Intu-
itively, an unary datatype group extends the OWL datatyping
with a hierarchy of supported datatypes.9

A unary datatype group G is a triple
Definition 10.
(Md , B, dom), where Md is the datatype map of G, B is the set of
primitive base datatype URI references in G and dom is the declared domain function. We call S the set of supported datatype
URI references of G, i.e., for each u  S, Md(u) is defined; we
require B  S. We assume that there exists a unary datatype
URI reference owlx:DatatypeBottom  S. The declared domain function dom has the following properties: for each u  S,
if u  B, dom(u) = u; otherwise, dom(u) = v, where v  B.
Definition 10 ensures that all the primitive base datatype
URIrefs of G are supported (B  S) and that each supported
datatype URIref relates to a primitive base datatype URIref
through the declared domain function dom.
Example 3. G1 = (Md1, B1, dom1) is a unary datatype group,
where
 Md1 = {xsd:integer  integer, xsd:string 

string, xsd:nonNegativeInteger 0
, xsdx:integerLessThanN <N},
 B1 = {xsd:string, xsd:integer}, and

8 A concept is in negation normal form iff negation is applied only to atomic

concept names, nominals or datatypes.

9 Note that in [16] datatype groups allow arbitrary datatype predicates, while
here we consider only datatypes, which can be regarded as unary datatype pred-
icates.

J.Z. Pan, I. Horrocks / Web Semantics: Science, Services and Agents on the World Wide Web 4 (2006) 2939

 dom1 = {xsd:integer  xsd:integer, xsd:string 

xsd:string, xsd:nonNega tiveInteger 
xsd:integer, xsdx:integerLessThanN  xsd:integer}.
S1 = {xsd:integer,

to Md1, we

According

have

xsd:string, xsd:nonNegativeInteger, xsdx:integer
LessThanN}, hence B1  S1. Note that
of <N is
V (<N) = {i  V (integer)|i < L2V (integer)(N)},
and by <N we mean there exists a supported datatype <N for
each integer L2V (integer)(N).

the value space

Based on a unary datatype group, OWL-Eu provides a formalism (called datatype expressions) for constructing customised
datatypes using supported datatypes.
Definition 11. Let G be a unary datatype group. The set of
G-unary datatype expressions in abstract syntax (correspond-
ing DL syntax can be found in Table 3), abbreviated DexpG, is
inductively defined as follows:
1. atomic expressions u  Dexp (G), for a datatype URIref u;

datatype URIref u;

2. relativised negated expressions not(u)  Dexp (G), for a
3. enumerated expressions oneOf(l1, . . . , ln)  Dexp (G), for
4. conjunctive expressions and(E1, . . . , En)  Dexp (G), for
5. disjunctive expressions or(E1, . . . , En)  Dexp (G),

literals l1, . . . , ln;
datatype expressions E1, . . . , En  Dexp (G);
datatype expressions E1, . . . , En  Dexp (G).

for

Example 4. G-unary datatype expressions can be used to represent XML Schema non-list simple types. Given the unary
datatype group G1 presented in Example 3,

built-in XML Schema simple types integer, string, nonNega-

tiveInteger are supported datatypes in G1;

the XML Schema derived simple type (using only one facet)
atLeast18 defined in Example 1 can be represented by
the relativised negated expression

not(xsdx:integerLessThan18);

the following XML Schema derived simple type (using more

than one facet) humanAge

<simpleType name=humanAge>

<restriction base=xsd:integer>

<minInclusive value=0/ >
<maxExclusive value=150/ >

< /restriction>

< /simpleType>
can be represented by the following conjunctive expression

and(xsd:nonNegativeInteger, xsdx:integerLessThan150);

the following XML Schema derived union simple type
<simpleType name=cameraPrice>

<union>

<simpleType>

<restriction base=xsd:nonNegativeInteger>

<maxExclusive value=100000/ >

< /restriction>

< /simpleType>
<simpleType>

<restriction base=xsd:string>

<enumeration value=low/ >
<enumeration value=medium/ >
<enumeration value=expensive/ >

< /restriction>

< /simpleType>

< /union>

< /simpleType>
can be represented by the following disjunctive expression
or(

and(xsd:nonNegativeInteger, xsdx:integerLessThan100000)
oneOf(low xsd:string, medium xsd:string, expensive xsd:string)

).

Table 3
Syntax and semantics of datatype expressions (OWL-Eu data ranges)

Abstract syntax

a datatype URIref u
oneOf(l1, . . . , ln)
not(u)

and(E1, . . . , En)
or(P, Q)

DL syntax

{l1, . . . , ln}

E1  . . .  En
E1  . . .  En

}  . . .  {lD

Semantics
uD
{lD
(dom(u))D \ uDifu 
S \ BD \
uDotherwise
 . . .  ED

 . . .  ED

We now define the interpretation of a unary datatype group.

Definition 12. A datatype interpretation ID of a unary datatype
group G = (Md , B, dom) is a pair (D,D), where D (the
datatype domain) is a non-empty set and D is a datatype interpretation function, which has to satisfy the following conditions:
1. (rdfs:Literal)D = D and (owlx:DatatypeBottom)D = ;
2. for each plain literal l, lD = l  PL and PLD;10
3. for any two primitive base datatype URIrefs u1, u2  B :
4. for each supported datatype URIref u  S, where d =
Md(u):
(a) uD = V (d) D, L(u) L(dom(u)) and L2V (u)
then (s u)D = L2V (d)(s); otherwise,
(b) if s  L(d),

L2V (dom(u));

 uD

= ;

uD

(s u)D is not defined;

5. u  S, uDD, and s  u  uD.

Moreover, we extend D to G unary datatype expression as
shown in Table 3. Let E be a G unary datatype expression, the
negation of E is of the form E, which is interpreted as D/ED.
In Definition 12, Condition 3 ensures that the value spaces of
all primitive base datatypes are disjoint with each other. Condition 4a ensures that each supported datatype is a derived datatype
of its primitive base datatype. Please note the difference between
a relativised negated expression and the negation of a unary
datatype expression: the former one is a kind of unary datatype
expression, while the latter one is the form of negation of all
kinds of unary datatype expressions. Furthermore, Definition
12 indicates enumerated expressions are special forms of disjunctive expressions.

It is worth noting that the (full) negation of a unary datatype
expression is also a unary datatype expression. This can be easily
shown as follows.
 u: if u  B,u =  u; otherwise, u =  u  dom(u).
  u: if u  B, u = u; otherwise,  u = u  dom(u).
 (u1  . . .  un) = u1  . . .  un.
 (u1  . . .  un) = u1  . . .  un.

Next, we introduce the kind of basic reasoning mechanisms

required for a unary datatype group.

10 PL is the value space for plain literals; cf. Definition 9.

(1)

i=1

j=1

(i)
2 ),

(i)
1 , v

=i (v

uj(vj)  l

Definition 13. Let V be a set of variables, G = (Md , B, dom)
a unary datatype group and u  B a primitive base datatype
C = k
URIref. A datatype conjunction of u is of the form

(i)
where the vj are variables from V, v
2 are variables appear
j=1 uj(vj), uj are datatype URI references from S such that
in
dom(uj) = u, and =i are the inequality predicates for primitive
j=1 uj(vj).
base datatypes Md(dom(ui)) where ui appear in
A datatype conjunction C is called satisfiable iff there exist
an interpretation (D,D) of G and a function  mapping the
variables in C to data values in D s.t. (vj)  uD
j (for all 1 
j  k) and {(v
2 ) (for all 1 
1 ) = (v
i  l). Such a function  is called a solution for C w.r.t. (D,D).
We end this section by elaborating the conditions that com-

2 )}uD

i and (v

(i)
1 ), (v

(i)
1 , v

(i)

(i)

(i)

putable unary datatype groups require.

Definition 14. A unary datatype group G is conforming iff
1. for any u  S \ B: there exist u

  S \ B such that u

D =  uD,

and

2. for each primitive base datatype in G, the satisfiability problems for finite datatype conjunctions of the form (1) is
decidable.

5.2. Small extension: from OWL DL to OWL-Eu

In this section, we present a small extension of OWL DL, i.e.,
OWL-Eu. The underpinning DL of OWL-Eu is SHOIN(G1),
i.e., the SHOIN DL combined with a unary datatype group
G (1 for unary). Specifically, OWL-Eu (only) extends OWL
data range (cf. Definition 8) to OWL-Eu data ranges defined as
follows.

Definition 15. An OWL-Eu data range is a G unary datatype
expression. Abstract (as well as DL) syntax and model-theoretic
semantics of OWL-Eu data ranges are presented in Table 3.

The consequence of

the extension is that customised
datatypes, represented by OWL-Eu data ranges, can be used
in datatype exists restrictions (T.u) and datatype value restrictions (T.u), where T is a datatype property and u is an OWL-Eu
data range (cf. Table 1). Hence, this extension of OWL DL is as
large as is necessary to support customised datatypes.

Example 5. PCs with memory size greater than or equal to 512
Mb and with price cheaper than 700 pounds can be represented
in the following OWL-Eu concept description in DL syntax (cf.
Table 3):
PC  memorySizeInMb.<512 
priceInPound.<700,

where <512 is a relativised negated expression and <700 is a
supported datatype in G1.

J.Z. Pan, I. Horrocks / Web Semantics: Science, Services and Agents on the World Wide Web 4 (2006) 2939

5.3. Decidability of OWL-Eu

Now we show that OWL-Eu is decidable by showing
SHOIQ(G1)-concept satisfiability w.r.t. knowledge bases. To
decide SHOIQ(G1)-concept satisfiability and subsumption
problem w.r.t. knowledge bases, a DL reasoner can use a datatype
reasoner to answer datatype queries. Intuitively, a datatype query
is a disjunction of datatype expression conjunctions, possibly together with some equality and inequality constraints.
Definition 16. (Datatype Query) For a unary datatype group
G1, a datatype query is of the form

= (v(j1,1), v(j1,2))  k2

 k1

Q := k
= (v(j2,1), . . . , v(j2,mj2 )),

j1=1

j=1

Cdj

j2=1

(2)

where Cdj is a (possibly negated) unary datatype expression
conjunction, v(s) are variables appearing in Cd1 , . . . , Cdk , and =
and = are called the value inequality predicate and value equality
predicate, respectively. A datatype query is satisfiable iff there
exists an interpretation (D,D) of G1 and a function  mapping
the variables in Cd1 , . . . , Cdk to data values in D s.t.
 is a solution for one of Cd1 , . . . , Cdk w.r.t. (D,D) and,
(v(j1,1)) = (v(j1,2)) for all 1  j1  k1,11
there exist
(v(j2,mj2 )).
Such a function  is called a solution for Q w.r.t. (D,D).
Lemma 1. For G a conforming unary datatype group, datatype
queries of the form (2) are decidable.

s.t. (v(j2,1)) =  =

some j2(1  j2  k2)

Proof. Firstly, we will show that the satisfiability problem of
(possibly negated) G-datatype expression conjunctions is de-
cidable. It is trivial to reduce the satisfiability problem for G-
datatype expression conjunctions to the satisfiability problem
for predicate conjunctions over G:

1. Due to Condition 1 of a conforming unary datatype group (cf.
Definition 14), we can trivially eliminate relativised negated
expressions. Similarly, their (full) negations can be reduced
as follows:
ui(vi) 

ui(vi)  dom(ui)(vi)
ui(vi)

if ui  S \ B,
otherwise,

according to Definition 12.

2. The and and or constructors simply introduce disjunctions of datatype conjunctions of G. Due to Condition 3 of
Definition 12, datatype conjunctions are unsatisfiable if there
exist variables shared among supported datatypes derived
from different primitive based datatypes. Therefore, datatype
conjunctions of G can be reduced to datatype conjunctions
of primitive base datatypes. According to Definition 14,

11 Note that, if v = v1, . . . , vn, (v) is an abbreviation for (v1), . . . , (vn).

the satisfiability problem of datatype conjunctions of primitive base datatypes is decidable; therefore, a G-datatype expression conjunction is satisfiable iff one of its disjuncts is
satisfiable.

Secondly, we show how to handle the extra constraints
introduced by the value inequality predicate and value equality
predicate. We can transform the general equality and inequality constraints into V, a disjunction of conjunctions of the
forms = (vi, vj) or = (vi
). For each satisfiable G-datatype
expression conjunction CEj , we can further extend CEj to C
by
adding new conjuncts =u (vi, vj) and/or =u (vi
) into CE.
Q is unsatisfiable if all C
are unsatisfiable; otherwise, Q is
satisfiable. 

 , vj

 , vj

Ej

Ej

 AT.0

, and AT.>1

 . . .  ACn

We will show the decidability of SHOIQ(G1)-concept satisfiability w.r.t. TBoxes and RBoxes by reducing it to the SHOIQconcept satisfiability w.r.t. TBoxes and RBoxes. The proof is
inspired by the proof (Lutz [14, pp. 3233]) of the decidability of ALCF(D)-concept satisfiability w.r.t. to general TBoxes,
where ALCF(D) is obtained from ALCF(D) by restricting the
concrete domain constructor to concrete features in place of feature chains. The basic idea behind the reduction is that we can
replace each datatype group-based concept C in T with a new
atomic primitive concept AC in T 
. We then compute the satisfiability problem for all possible conjunctions of datatype groupbased concepts (and their negations) in T (of which there are
only a finite number), and in case a conjunction C1  . . .  Cn
  to T 
is unsatisfiable, we add an axiom AC1

For example, unary datatype group-based concepts T.>1
and T.0 occurring in T would be replaced with AT.>1 and
  would be added to T 
AT.0 in T 
because T.>1  T.0 is unsatisfiable (i.e., there is no solution
for the predicate conjunction >1 (v) 0 (v)).
Theorem 1. The SHOIQ(G1)-concept satisfiability problem
w.r.t. a knowledge base is decidable if the combined unary
datatype group is conforming.
Proof. We prove the theorem by reducing SHOIQ(G1)-
concept satisfiability w.r.t. a knowledge base to the SHOIQconcept satisfiability w.r.t. TBoxes and RBoxes. Let D be an
SHOIQ(G1)-concept for satisfiability checking, cIT(D) the set
of all the sub-concepts of concepts in {D}  {D1, D2|D1 
D2  Tor D1 = D2  T}, and {C1, . . . , Ck}  cIT(D) the set of
all the datatype group-based concepts (and their negations) in
cIT(D), i.e., each Ci (1  i  k) is of one of the four forms:
T.d,T.d,  nT.d and  nT.d, where T is a concrete role name,
d is a unary datatype expression and n is an integer. There are
two remarks here. Firstly, we assume that C1, . . . , Ck are in
their negation normal forms; i.e., negations only appear in front
of atomic concepts. Secondly, as we have shown in Section 5.1,
negations of unary datatype expressions are still unary datatype
expressions.

We assume that all the functional concrete role axioms in R of
the form Func(T ) are encoded into concept inclusion axioms of
the form   1T.D in T. We assume that all the individual
axioms of the form a : C are encoded into concept inclusion
axioms of the form {a}  C, that all the individual axioms of

the form a, b : R are encoded into concept inclusion axioms
of the form {a}  R.{b} and that all the individual axioms of
the form a, l : T are encoded into concept inclusion axioms of
the form {a}  T.{l}.
We define a mapping  that maps unary datatype group-based
concept conjunctions of the form S = B1  . . .  Bh, where
{B1, . . . Bh}  {C1, . . . , Ck}, to a corresponding datatype query
(S).
(Step 1) For each Bj of the form T.d, (S) contains a conjunct
d(vT
j is a variable, with the corresponding
concrete role name T as its superscript.
(Step 2) For each Bj of the form  nT.d, (S) contains a con-

junct

j ), where each vT

= (vT

, vT
jb

ja

d(vT
ja

d(v).

. . . , vT
jm

1a<bm

, where the superscript T

T. Then (S) contains a conjunct

a=1
where the inequality constraints are used to make sure the
variables vT
are mapped to different data values.
j1
We will not introduce any more new variables (with super-
scriptions) in the following steps.
(Step 3) For each Bj of the form T.d, let Aj be the set of all
variables that were introduced in (Step 1) and (Step 2) of the
form vT
matches the corresponding concrete role name T in T.d. A variable vT
matches a

concrete role T if T
vAj
(Step 4) For each Bj of the form  mT1, . . . , Tnj .E, similarly
to (Step 3), we can define a set Aj for Bj. Let |Aj| = m

  m, then let P(A, x) be the function that maps a
If m
set A to the set of all the partitions of A with size x; i.e.,
for each partition Q = {q1, . . . , qx}  P(A, x), q1, . . . , qn
are non-empty sets, qa  qb =  (for 1  a < b  x) and

A = q1  . . .  qx. Then (S) contains a conjunct
d(v1)  d(v2) = (v1, v2),
QP(Aj ,m)
we can apply the x  y  x  y equivalence and De-

Morgans law to this conjunct to give
QP(Aj ,m)

v1, v2q

v1, v2q

d(v1) d(v2) = (v1, v2).

qQ

qQ

Since the satisfiability problem for a datatype query
for each possible S = B1  . . .  Bh, where
is decidable,
{B1, . . . , Bh}  {C1, . . . , Ck}, we can decide if (S) is satisfiable or not.

Now we can reduce the SHOIQ(G1)-concept satisfiability
problem w.r.t. a knowledge base to the SHOIQ-concept satisfiability problem w.r.t. a TBox and an RBox, by introducing some new atomic primitive concepts (to represent Ci, for
each 1  i  k) and some concept inclusion axioms about these
atomic primitive concepts (to capture all the possible contradictions caused by S) as follows:

(1) We create an atomic primitive concept ACi for each Ci 
{C1, . . . , Ck}, and transform T and D into T 
by
replacing all Ci with ACi in T and D. We transform R into

{B1, . . . , Bh} 
(2) For
{C1, . . . , Ck}, if (S) is unsatisfiable, we add the following concept inclusion axiom into T 

by removing all the concrete role inclusion axioms.
each S = B1  . . .  Bh, where

and D

 . . .  ABh

AB1

Claim. (i) For any S = B1  . . .  Bh, where {B1, . . . , Bh} 
{C1, . . . , Ck}, S is satisfiable iff (S) is satisfiable. (ii) All
the possible contradictions caused by possible datatype groupbased sub-concept conjunctions in cIT(D) have been encoded in
the TBox T 
is satisfiable
w.r.t. T 

. (iii) D is satisfiable w.r.t. T and R iff D

and R

ja

ja

jb

= (vT

1a<bm

a=1 d(vT
ja

, vT
jb
)  dD and (vT

Claim (i) is true because the mappings in (Steps 14) exactly
generate the needed datatype queries (S) according to the semantics of unary datatype group-based concepts.
 (Step 1): For each Bj of the form T.d, (S) contains a con-
j ). If (D,D) is an interpretation of G and  is a
junct d(vT
j ) w.r.t. (D,D) of this conjunct, we have
solution of d(vT
j )  dD. Furthermore, the concrete role names T are used
(vT
in superscripts of the corresponding variables, so as to assure
that further constraints from datatype expression value and
atmost restrictions can be properly added to these variables.
 (Step 2): For each Bj of the form  mT.d, (S) contains a
). If (D,D)
conjunct
is an interpretation of G and  is a solution w.r.t. (D,D)
) = (vT
of this conjunct, we have (vT
) for
all 1  a < b  m; viz. there are at least m data values that
ja
satisfy the unary datatype expression d. The purpose of using
superscripts in variables is the same as (Step 1).
 (Step 3): For each Bj of the form T.d, (S) contains a con-
junct
d(v). Since in (Step 1) and (Step 2) we have generated all the needed variables, the set Aj includes all the tuples of variables, the superscripts of which match T1, . . . , Tnj .
If (D,D) is an interpretation of G and  is a solution w.r.t.
(D,D) of the above conjunct, we have (v)  dD, for all
v  Aj.
 (Step 4): For each Bj of the form  mT.d, (S) contains a
conjunct
QP(Aj ,m)
if m < |Aj|. The set Aj is constructed as that in (Step 3),
and P(Aj, m) is the set of all the partitions of Aj with size
m. If (D,D) is an interpretation of G and  is a solution
w.r.t. (D,D) of this conjunct, there exists a partition Q, s.t.
for all qi  Q (1  i  m), any pairs of variable v1, v2 must
satisfy that if both (v1)  dD and (v2)  dD are true, then
(v1) = (v2). In other words, there are at most m different
data values that are linked through the concrete roles T and
satisfy d.

d(v1)  d(v2) = (v1, v2),

v1, v2q

vAj

qQ

J.Z. Pan, I. Horrocks / Web Semantics: Science, Services and Agents on the World Wide Web 4 (2006) 2939

  in T 

w.r.t. T 

and R

from I.I

 . . .  ABh

For claim (ii). Firstly, due to the (1), it is obvious that D

is
an SHOIQ-concept and T 
contains no unary datatype groupbased concepts, and there are no concrete roles in R
. Sec-
ondly, due to (2), claim (i) and that G-datatype queries are decid-
able, for any possible datatype group-based concept conjunction
S = B1  . . .  Bh and if (S) is unsatisfiable, there is an axiom
. Therefore, all the possible contra-
AB1
dictions caused by possible datatype group-based sub-concept
conjunctions in cIT(D) have been encoded in the TBox T 
For claim (iii). If D is satisfiable w.r.t. T and R, then there
is a model I, s.t. I |= D, I |= T and I |= R. We show how to
construct a model I
of D
will be
identical to I in every respect except for concrete roles (there
are no concrete roles in I
) and the atomic primitive concepts
ACi for each Ci  {C1, . . . , Ck} (there are no ACi in I). So we
= C


only need to construct A
: A
i . Due to the constructions
= , I |= T 
, R
Ci
Ci

, T 
of D
, we have D

For the converse direction, let I
w.r.t. T 
. I will be identical to I
and R
in every respect except for
concrete roles and datatype group-based concepts C1, . . . , Ck.
We can construct C
and the inter-
 . . . 
pretations of concrete roles as follows: Let C = C
k . For each xj  C, there exists a set {Cj1 , . . . , Cjnx
} s.t.

 . . . 
. Let Sj = Cj1
for each Cjh
Cjnx . Obviously, I |= Sj. Due to claim (i), the datatype query
(Sj) is decidable; therefore, there exists a datatype interpretation (D,D) and a solution  of (Sj) w.r.t. (D,D). Let T be
a concrete role, V
the set of variables in (Sj) that match
(j)
T ) the set of data values to which  maps the set of
T, (V
I as , then for each T
variables in V
 (V
T )}. Obviously,
used in each Sj, we have T
we have I |= D. Due to claim (ii) and the construction of T 

we have I |= T. Due to the definition of match, the constructions of R
and the interpretations of concrete roles, we have
I |= R. 

(j)
T . Initially, we set all T
I  {S

and I |= R

be a model of D

i (1  i  k) as C

 {Cj1 , . . . , Cjnx

}, xj  C

jh

I = T

(j)

= A

Ci

(j)

that supports customised datatypes with unary datatype expressions (cf. Example 4). Secondly, Definition 12 defines the negations of datatype expressions and OWL-Eu provides relativised
negated datatype expression (Definition 11). Thirdly, according to Definition 12, the datatype domain in an interpretation
of a datatype group is a superset of (instead of equivalent to)
the value spaces of primitive base datatypes and plain literals;
hence, typed literals with unsupported predicates are interpreted
more intuitively.

6. Related work

The concrete domain approach [2,14] provides a rigorous
treatment of datatype predicates, rather than datatypes.12 In the
type system approach [11], datatypes are considered to be sufficiently structured by type systems; however, it does not specify
how the derivation mechanism of a type system affects the set
of datatypes D. An early version of [5] suggests some solutions
to the problem of referring to an XML Schema user defined
simple type with a URI reference; however, it does not address
the computability issue of combining the SHOIN DL with customised datatypes. The current version of this W3C technical report refers to our work on unary datatype groups, as a solution to
the problem of combining OWL DL with customised datatypes.
It is worth mentioning that the SPARQL query language for
RDF [20] allows the use not only of datatypes, but also of some
datatype predicates and operators defined in [15]. SPARQL does
not, however, allow the use of customised datatypes or datatype
predicates. Furthermore, the eq operator SPARQL supports is
not an equivalence relation because of some so-called corner
cases [5].

7. Conclusion

Although OWL is rather expressive, it has a very serious
limitation on datatypes; i.e., it does not support customised
datatypes. It has been pointed out that many potential users will
not adopt OWL unless this limitation is overcome. Accordingly,
the Semantic Web Best Practices and Development Working
Group has set up a task force to address this issue. As discussed
above, a solution to the problem should cover much more than
just a standard way of referring to an XML Schema user defined
simple type with a URI reference.

In this paper, we propose OWL-Eu, an extension of OWL DL
that supports customised datatypes. The underpinning of OWLEu is the SHOIN(G1) DL, a combination of SHOIN and a
unary datatype group. OWL-Eu is decidable if the combined
unary datatype group is conforming; conformance of a unary
datatype group precisely specifies the conditions on the set of
supported datatypes. OWL-Eu provides a general framework for
integrating OWL DL with customised datatypes, such as XML
Schema non-list simple types.

12 The reader is referred to Section 5.1.3 of [16] for detailed discussions on
concrete domains.

Since OWL-Eu corresponds to the SHOIN(G1) DL, which
is a sub-language of SHOIQ(G1), we have the following
corollary.

Corollary 1. The OWL-Eu-concept satisfiability problem w.r.t.
a knowledge base is decidable.
Lemma 2. (Tobies[24, Lemma 5.3]) If L is a DL that provides
the nominal constructor, knowledge base satisfiability can be
polynomially reduced to satisfiability of TBoxes and RBoxes.

According to Corollary 1 and Lemma 5.3, we have the fol-

lowing theorem.

Theorem 2. The knowledge base satisfiability problem of OWLEu is decidable.

5.4. Overcoming the limitations of OWL datatyping

This section summarises how OWL-Eu overcomes the limitations of OWL datatyping presented in Section 4. Firstly,
OWL-Eu is a decidable extension (Theorem 1) of OWL DL

We have implemented a prototype extension of the FaCT
[9] DL system, called FaCt-DG, to support TBox reasoning
in the SHIQ(G1) DL, a sub-language of OWL-Eu. As for
future work, we are planing to extend the DIG1.1 interface
[7] to support OWL-Eu, and to implement a prot eg e [13]
plug-in to support XML Schema non-list simple types, i.e.
users should be able to define and/or import customised XML
Schema non-list simple types based on a set of supported
datatypes, and to exploit our prototype through the extended DIG
interface.
