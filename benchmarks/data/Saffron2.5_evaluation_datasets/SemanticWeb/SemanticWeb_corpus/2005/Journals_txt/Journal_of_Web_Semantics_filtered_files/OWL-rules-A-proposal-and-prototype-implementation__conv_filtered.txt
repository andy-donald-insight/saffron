Web Semantics: Science, Services and Agents

on the World Wide Web 3 (2005) 2340

OWL rules: A proposal and prototype implementation


Ian Horrocks

, Peter F. Patel-Schneider, Sean Bechhofer, Dmitry Tsarkov

Univeristy of Manchester, Department of Computer Science, Kilburn Building, Manchester M13 9PL, UK

Received 6 May 2005; received in revised form 11 May 2005; accepted 12 May 2005

Abstract

Although the OWL Web Ontology Language adds considerable expressive power to the Semantic Web it does have expressive
limitations, particularly with respect to what can be said about properties. We present the Semantic Web Rule Language (SWRL),
a Horn clause rules extension to OWL that overcomes many of these limitations. SWRL extends OWL in a syntactically and
semantically coherent manner: the basic syntax for SWRL rules is an extension of the abstract syntax for OWL DL and OWL Lite;
SWRL rules are given formal meaning via an extension of the OWL DL model-theoretic semantics; SWRL rules are given an
XML syntax based on the OWL XML presentation syntax; and a mapping from SWRL rules to RDF graphs is given based on the
OWL RDF/XML exchange syntax. We discuss the expressive power of SWRL, showing that the ontology consistency problem is
undecidable, provide several examples of SWRL usage, and discuss a prototype implementation of reasoning support for SWRL.
 2005 Elsevier B.V. All rights reserved.

Keywords: Semantic Web; Knowledge representation; Rules languages; Model-theoretic semantics; Reasoning

1. Introduction

The OWL Web Ontology Language [46] adds
considerable expressive power to the Semantic Web.
However, for a variety of reasons (see http://lists.
w3.org/Archives/Public/www-webont-wg/and [20]),
including retaining the decidability of key inference
problems in OWL DL and OWL Lite, OWL has expressive limitations. These restrictions can be onerous
in some application domains, for example in describing web services, where it may be necessary to relate
inputs and outputs of composite processes to the in-


Corresponding author. Tel.: +44 161 275 6133;

fax: +44 161 275 6204.

E-mail address: horrocks@cs.man.ac.uk (I. Horrocks).

puts and outputs of their component processes [50], or
in medical informatics, where it may be necessary to
transfer characteristics across partitive properties [39].
Many of the limitations of OWL stem from the fact
that, while the language includes a relatively rich set
of class constructors, the language provided for talking
about properties is much weaker. In particular, there is
no composition constructor, so it is impossible to capture relationships between a composite property and
another (possibly composite) property. The standard
example here is the obvious relationship between the
composition of the parent and brother properties
and the uncle property.

One way to address this problem would be to extend
OWL with a more powerful language for describing
properties. For example, a decidable extension of the

1570-8268/$  see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2005.05.003

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

description logics underlying OWL DL to include
the use of composition in subproperty axioms has
already been investigated [22,23]. In order to maintain
decidability, however, the usage of the constructor is
limited to axioms of the form P  Q  P, i.e., axioms
asserting that the composition of two properties is
a subproperty of one of the composed properties.
This means
that complex relationships between
composed properties cannot be capturedin fact even
the relatively simple uncle example cannot not be
captured (because uncle is not one of parent or
brother).

An alternative way to overcome some of the expressive restrictions of OWL would be to extend it with
some form of rules language. In fact adding rules to
description logic based knowledge representation languages is far from being a new idea. Several early description logic systems, e.g., Classic [38,8], included a
rule language component. In these systems, however,
rules were given a weaker semantic treatment than axioms asserting sub- and super-class relationships; they
were only applied to individuals, and did not affect
class based inferences such as the computation of the
class hierarchy. More recently, the CARIN system integrated rules with a description logic in such a way
that sound and complete reasoning was still possible
[28]. This could only be achieved, however, by using a rather weak description logic (much weaker than
OWL), and by placing severe syntactic restrictions on
the occurrence of description logic terms in the (heads
of) rules. Similarly, the DLP language proposed in [14]
is based on the intersection of a description logic with
horn clause rules; the result is obviously a decidable
language, but one that is necessarily less expressive
than either the description logic or rules language from
which it is formed.

In this paper we show how a simple form of Hornstyle rules can be added to the OWL language in a syntactically and semantically coherent manner, the basic
idea being to add such rules as a new kind of axiom
in OWL DL. We show (in Section 3) how the OWL
abstract syntax in the OWL Semantics and Abstract
Syntax document [37] can be extended to provide a
formal syntax for these rules, and (in Section 4) how
the direct OWL model-theoretic semantics for OWL
DL can be extended to provide a formal meaning for
OWL ontologies including rules written in this abstract
syntax. We will also show (in Section 5) how OWLs

XML presentation syntax can be modified to deal with
the proposed rules.

The extended language was originally called the
OWL Rules Language (ORL), but is now much better
known as the Semantic Web Rules Language (SWRL),
a name that was coined when the Joint US/EU ad
hoc Agent Markup Language Committee1 developed a
W3C Member Submission based on ORL.2 Although
SWRL includes some additional features (mainly related to datatypes and predicates) and has some minor
syntactic differences, we will refer to the language described here as SWRL.

SWRL is considerably more powerful than either
OWL DL or Horn rules alone. We will show (in Section 6) that the key inference problems (e.g., ontology
consistency) for SWRL are undecidable, and (in Section 7) provide examples that utilise the power of the
combined languages.

In Section 8 we show how OWLs RDF syntax can
be extended to deal with rules, and in Sections 9 and
10 we discuss how reasoning support for SWRL might
be provided. Finally (in Section 11), we summarise the
main features of the SWRL proposal and suggest some
directions for future work.

2. Overview

The basic idea of the proposal is to extend OWL
DL with a form of rules while maintaining maximum
backwards compatibility with OWLs existing syntax
and semantics. To this end, we add a new kind of axiom
to OWL DL, namely Horn clause rules, extending the
OWL abstract syntax and the direct model-theoretic
semantics for OWL DL [37] to provide a formal semantics and syntax for OWL ontologies including such
rules.

The proposed rules are of the form of an implication
between an antecedent (body) and consequent (head).
The informal meaning of a rule can be read as:
whenever (and however) the conditions specified in
the antecedent hold, then the conditions specified in
the consequent must also hold.

1 http://www.daml.org/committee/.
2 http://www.w3.org/Submission/2004/SUBM-SWRL-

20040521/.

Both the antecedent (body) and consequent (head)
of a rule consist of zero or more atoms. Atoms
can be of the form C(x), P(x, y), sameAs(x, y) or
differentFrom(x, y), where C is an OWL DL descrip-
tion, P is an OWL property, and x, y are either vari-
ables, OWL individuals or OWL data values. Atoms
are satisfied in extended interpretations (to take care
of variables) in the usual model-theoretic way, i.e., the
extended interpretation maps the variables to domain
elements in a way that satisfies the description, prop-
erty, sameAs, or differentFrom, just as in the regular
OWL model theory.

Multiple atoms in an antecedent are treated as a con-
junction. An empty antecedent is thus treated as trivially true (i.e., satisfied by every interpretation), so the
consequent must also be satisfied by every interpreta-
tion.

Multiple atoms in a consequent are treated as separate consequences, i.e., they must all be satisfied. In
keeping with the usual treatment in rules, an empty consequent is treated as trivially false (i.e., not satisfied by
any extended interpretation). Such rules are satisfied
if and only if the antecedent is not satisfied by any
extended interpretation. Note that rules with multiple
atoms in the consequent could easily be rewritten (by
applying standard rules of distributivity) into multiple
rules each with an atomic consequent.

It is easy to see that OWL DL becomes undecidable when extended in this way as rules can be used
to simulate role value maps [45] and make it easy to
encode known undecidable problems as a SWRL ontology consistency problem (see Section 6).

3. Abstract syntax

The syntax for SWRL in this section abstracts from
any exchange syntax for OWL and thus facilitates access to and evaluation of the language. This syntax extends the abstract syntax of OWL described in the OWL
Semantics and Abstract Syntax document [37].

Like the OWL abstract syntax, we will specify the
abstract syntax for rules by means of a version of Extended BNF, very similar to the Extended BNF notation used for XML [51]. In this notation, terminals are
quoted; non-terminals are not quoted. Alternatives are
either separated by vertical bars (|) or are given in different productions. Components that can occur at most

once are enclosed in square brackets ([]); components that can occur any number of times (including
zero) are enclosed in braces ({}). Whitespace is ignored in the productions given here.

Names in the abstract syntax are RDF URI references [27]. These names may be abbreviated into
qualified names, using one of the following namespace
names:

The meaning of each construct in the abstract syntax
for rules is informally described when it is introduced.
The formal meaning of these constructs is given in Section 4 via an extension of the OWL DL model-theoretic
semantics [37].

3.1. Rules

From the OWL Semantics and Abstract Syntax document [37], an OWL ontology in the abstract syntax
contains a sequence of annotations, axioms, and facts.
Axioms may be of various kinds, for example, subClass
axioms and equivalentClass axioms. This proposal extends axioms to also allow rule axioms, by adding the
production:

axiom ::= rule

Thus a SWRL ontology could contain a mixture of
rules and other OWL DL constructs, including ontology annotations, axioms about classes and properties,
and facts about OWL individuals, as well as the rules
themselves.

A rule axiom consists of an antecedent (body)
and a consequent (head), each of which consists of
a (possibly empty) set of atoms. Just as for class
and property axioms, rule axioms can also have
annotations. These annotations can be used for several
purposes, including giving a label to the rule by using
the rdfs:label annotation property.

Informally, a rule may be read as meaning that if
the antecedent holds (is true), then the consequent

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

must also hold. An empty antecedent is treated as trivially holding (true), and an empty consequent is treated
as trivially not holding (false). Non-empty antecedents
and consequents hold iff all of their constituent atoms
hold. As mentioned above, rules with multiple consequents could easily be rewritten (using standard rules
of distributivity) into multiple rules each with a single
atomic consequent.

Atoms in rules can be of the form C(x), P(x, y),
Q(x, z), sameAs(x, y) or differentFrom(x, y), where
C is an OWL DL description, P is an OWL DL
individual-valued Property, Q is an OWL DL datavalued Property, x, y are either variables or OWL
individuals, and z is either a variable or an OWL data
value. In the context of OWL Lite, descriptions in
atoms of the form C(x) may be restricted to class
names.

In this syntax, a rule has the form:

antecedent  consequent,

where both antecedent and consequent are conjunctions of atoms written a1    an. Variables are
indicated using the standard convention of prefixing
them with a question mark (e.g., ?x). Using this syn-
tax, a rule asserting that the composition of parent and
brother properties implies the uncle property would be
written:
parent(?a, ?b)  brother(?b, ?c)  uncle(?a, ?c).

(1)

If John has Mary as a parent and Mary has Bill has a
brother, then this rule requires that John has Bill as an
uncle. Using the abstract syntax described in Section
3.1, this rule would have been written as:

Informally, an atom C(x) holds if x is an instance of
the class description C, an atom P(x, y) (resp. Q(x, z))
holds if x is related to y(z) by property P(Q), an atom
sameAs(x, y) holds if x is interpreted as the same object
as y, and an atom differentFrom(x, y) holds if x and y
are interpreted as different objects.

Atoms may refer

to individuals, data literals,
individual variables or data variables. Variables are
treated as universally quantified, with their scope
limited to a given rule. As usual, only variables that
occur in the antecedent of a rule may occur in the
consequent (a condition usually referred to as safety).

3.2. Human readable syntax

While the abstract Extended BNF syntax is consistent with the OWL specification, and is useful for defining XML and RDF serialisations, it is rather verbose
and not particularly easy to read. In the following we
will, therefore, often use a relatively informal human
readable form similar to that used in many published
works on rules.

4. Direct modeltheoretic semantics

The model-theoretic semantics for SWRL is a
straightforward extension of the semantics for OWL
DL given in [37]. The basic idea is that we define
bindingsextensions of OWL interpretations that also
map variables to elements of the domain in the usual
manner. A rule is satisfied by an interpretation iff every binding that satisfies the antecedent also satisfies
the consequent. The semantic conditions relating to
axioms and ontologies are unchanged, so an interpretation satisfies an ontology iff it satisfies every axiom
(including rules) and fact in the ontology.

4.1. Interpreting rules

From the OWL Semantics and Abstract Syntax document [37] we recall that an abstract OWL interpretation is a tuple of the form
I = R, EC, ER, L, S, LV,
where R is a set of resources, LV  R a set of literal values, EC a mapping from classes and datatypes

Table 1
Interpretation conditions

Atom

C(x)
P(x, y)
Q(x, z)
sameAs(x, y)
differentFrom(x, y)

Condition on interpretation
S(x)  EC(C)
S(x), S(y)  ER(P)
S(x), L(z)  ER(Q)
S(x) = S(y)
S(x) = S(y)

to subsets of R and LV respectively, ER a mapping
from properties to binary relations on R, L is a mapping from typed literals to elements of LV, and S
is a mapping from individual names to elements of
EC(owl : Thing).

Given an abstract OWL interpretation I, a binding B(I) is an abstract OWL interpretation that extends I such that S maps i-variables to elements of
EC(owl : Thing) and L maps d-variables to elements
of LV respectively. An atom is satisfied by a binding
B(I) under the conditions given in Table 1, where C
is an OWL DL description, P an OWL DL individualvalued Property, Q an OWL DL data-valued Property,
x, y are variables or OWL individuals, and z is a variable or an OWL data value.

A binding B(I) satisfies an antecedent A iff A is
empty or B(I) satisfies every atom in A. A binding
B(I) satisfies a consequent C iff C is not empty and
B(I) satisfies every atom in C. A rule is satisfied by an
interpretation I iff for every binding B such that B(I)
satisfies the antecedent, B(I) also satisfies the conse-
quent.

The semantic conditions relating to axioms and ontologies are unchanged. In particular, an interpretation
satisfies an ontology iff it satisfies every axiom (in-
cluding rules) and fact in the ontology; an ontology
is consistent iff it is satisfied by at least one interpre-
tation; an ontology O2 is entailed by an ontology O1
iff every interpretation that satisfies O1 also satisfies
O2.

4.2. Example

Consider, for example, the uncle rule (1) from
Section 3.2. Assuming that parent, brother and uncle
are individualvaluedPropertyIDs, then given an interpretation I = R, EC, ER, L, S, LV, a binding B(I)
extends S to map the variables ?a, ?b, and ?c to el-

ements of EC(owl : Thing); we will use a, b, and c
respectively to denote these elements. The antecedent
of the rule is satisfied by B(I) iff (a, b)  ER(parent)
and (b, c)  ER(brother). The consequent of the rule
is satisfied by B(I) iff (a, c)  ER(uncle). Thus the
rule is satisfied by I iff for every binding B(I) such
that (a, b)  ER(parent) and (b, c)  ER(brother),
is also the case that (a, c)  ER(uncle),
then it
i.e.:
a, b, c  EC(owl : Thing).

((a, b)ER(parent)(b, c)  ER(brother))

 (a, c)  ER(uncle)

5. XML concrete syntax

Many possible XML encodings could be imag-
ined, but
the most obvious solution is to extend
the existing OWL Web Ontology Language XML
Presentation Syntax [17], which can be straightforwardly modified to deal with SWRL.3 This has several
advantages:
 arbitrary OWL classes (e.g., descriptions) can be
 rules and ontology axioms can be freely mixed;
 the existing XSLT stylesheet4 can easily be extended
to provide a mapping to RDF graphs that extends
the OWL RDF/XML exchange syntax (see Section
8).

used as predicates in rules;

In the first place, the ontology root element is extended so that ontologies can include rule axioms and
variable declarations as well as OWL axioms, import statements, etc. We then simply need to add the
relevant syntax for variables and rules. In this paper we use the unspecified owlr namespace prefix
for the newly introduced syntax (the owlx namespace prefix, which should be treated as being bound
to http://www.w3.org/2003/05/owl-xml, is used for the
existing OWL XML syntax). In practice, the owlr
prefix would have to be bound to some appropriate

3 The syntax used in the W3C Member Submission was changed
slightly in order to make it more compatible with RuleML (see
http://www.ruleml.org/).

4 http://www.w3.org/TR/owl-xmlsyntax/owlxml2rdf.xsl.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

namespace name (e.g., the OWL namespace name, the
OWL XML namespace name, or some new namespace
name).

Variable declarations are statements about variables,
indicating that the given URI is to be used as a vari-
able, and (optionally) adding any annotations. For
example:

<owlr:Variable owlr:name="x1" />,

states that the URI x1 (in the current namespace) is to
be treated as a variable.

Rule axioms are similar to OWL SubClassOf
they have owlr:Rule as their ele-
axioms, except
ment name. Like SubClassOf and other axioms they
may include annotations. Rule axioms have an antecedent (owlr:antecedent) component and a consequent (owlr:consequent) component. The antecedent
and consequent of a rule are both lists of atoms and are
read as the conjunction of the component atoms. Atoms
can be formed from unary predicates (classes), binary
predicates (properties), equalities or inequalities.

Class atoms consist of a description and either an
individual name or a variable name, where the description in a class atom may be a class name, or may be a
complex description using boolean combinations, re-
strictions, etc. For example,5

<owlr:classAtom>

<owlx:Class owlx:name="Person" />
<owlr:Variable owlr:name="x1" />

</owlr:classAtom>

is a class atom using a class name (#Person), and

is a class atom using a complex description representing Persons having at least one parent who is a Physi-
cian.

Property atoms consist of a property name and two
elements that can be individual names, variable names
or data values (as OWL does not support complex
property descriptions, a property atom takes only a
property name). Note that in the case where the second
element is an individual name the property must be an
individual-valued Property, and in the case where the
second element is a data value the property must be a
data-valued Property. For example:

is a property atom using an individual-valued

Property (the second element is an individual), and

is a property atom using a data-valued Property (the
second element is a data value, in this case an integer).
Finally, same (different) individual atoms assert
equality (inequality) between sets of individual and
variable names. Note that (in)equalities can be asserted
between arbitrary combinations of variable names and
individual names. For example:

<owlr:sameIndividualAtom>

<owlr:Variable owlr:name="x1" />
<owlr:Variable owlr:name="x2" />
<owlx:Individual owlx:name="Clinton" />
<owlx:Individual owlx:name="Bill Clinton" />

</owlr:sameIndividualAtom>

asserts that the variables x1, x2 and the individual
names Clinton and Bill Clinton all refer to the same
individual.

5.1. Example

5 Note that we use the owlx namespace prefix for the names used

in examples.

The example rule from Section 3.2 can be written

in the XML concrete syntax for rules as

and y-succ, allows such a grid to be represented. This
would be possible even without the use of the sameAs
atom in the consequentit would only be necessary to
establish appropriate relationships with a diagonal
property:
x-succ(?a, ?b)  y-succ(?b, ?c)  diagonal(?a, ?c)
y-succ(?a, ?d) x-succ(?d, ?e)  diagonal(?a, ?e),

and additionally assert that every grid node is related
to exactly one other node by diagonal.

The proposed form of OWL rules seem to go beyond

basic Horn clauses in allowing:
 conjunctive consequents;
 class descriptions as well as class names as predicates in class atoms; and
 equalities and inequalities.
On closer examination, however, it becomes clear that
most of this is simply syntactic sugar, and does not
add to the power of the language.

In the case of conjunctive consequents, it is easy
to see that these could be eliminated by rewriting using standard rules of distributivity. For example, the
rule
A  C1  C2
is equivalent to A  (C1  C2) and, via distributivity,
to (A  C1)  (A  C2), so can be rewritten as a
semantically equivalent pair of rules
A  C1
A  C2.

In the case of class descriptions, it is easy to see that
a description d can be eliminated from a rule simply
by adding an OWL axiom that introduces a new class
name and asserts that it is equivalent to d, e.g.,

EquivalentClasses(D d).

The description can then be replaced with the name,
here replacing the description d with class name
D.

In the case of equality atoms, the sameAs property
could easily be substituted with a user defined owl

6. The power of rules

In OWL, the only relationship that can be asserted
between properties is subsumption between atomic
property names, e.g., asserting that hasFather is a
subPropertyOf hasParent. In Section 3.2 we have
already seen how a rule can be used to assert more
complex relationships between properties. While this
increased expressive power is clearly very useful, it
is easy to show that it leads to the undecidability of
key inference problems, in particular ontology consis-
tency.

For extensions of languages such as OWL DL,
the undecidability of the consistency problem is often
proved by showing that the extension makes it possible
to encode a known undecidable domino problem [4]
as an ontology consistency problem. In particular, it is
well known that such languages only need the ability
to represent an infinite two-dimensional grid in order
for consistency to become undecidable [2,24]. With the
addition of rules, such an encoding is trivial. For ex-
ample, given two properties x-succ and y-succ, the
rule:
x-succ(?a, ?b)  y-succ(?b, ?c)  y-succ(?a, ?d)

 x-succ(?d, ?e)  sameAs(?c, ?e),

along with the assertion that every grid node is related to exactly one other node by each of x-succ

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

property called, for example, Eq. Such a property can
be given the appropriate meaning using a rule of the
form
Thing(?x)  Eq(?x, ?x)
and by asserting that it is functional. It is easy to see
that the interpretation of Eq corresponds to equality of
elements in EC(owl : Thing), i.e.,
x, y  EC(owl : Thing).x, yER(Eq)  x = y,

(2)

and that Eq could therefore be used instead of sameAs
without changing the meaning of the ontology.

Proof: For

the if direction, assume that

for
some interpretation I there exists an element x of
EC(owl : Thing) such that x, x  ER(Eq). Then a
binding B(I) could extend I so that S maps ?x to x,
and rule (2) would not be satisfied by B(I). For the
only if direction, assume that for some interpretation I
there exist elements x, y of EC(owl : Thing) such that
x, y  ER(Eq) and x = y. From the if direction we
also have that x, x  ER(Eq), so Eq would not be
functional.

The case of inequalities is slightly more complex.
An owl property called, for example, Neq, can be introduced and used to capture some of the meaning of
the differentFrom property by adding a rule of the
form
Eq(?x, ?y)  Neq(?x, ?y)  Nothing(?x).
It is easy to see that the interpretation of Neq is disjoint
from the interpretation of Eq, i.e.,
x, y  EC(owl : Thing).x, yER(Neq)  x = y,

(3)

and that this leads to the implicit rule
Neq(?x, ?y)  differentFrom(?x, ?y).

Proof: Assume that for some interpretation I there
exist elements x, y of EC(owl : Thing) such that
x, y  ER(Neq) andx, y  ER(differentFrom). If
x, y  ER(differentFrom), then x = y and x, y 
ER(Eq). A binding B(I) could, therefore, extend I so
that S maps ?x to x and ?y to y, and rule (3) would imply that x  EC(owl:Nothing), violating the semantic
conditions on I.

Rule

(3)

that we

could

shows

eliminate
differentFrom when it occurs in the consequent
of a rule simply by substituting Neq. Neq does
not, however, fully capture the meaning of inequal-
ity, because there could be pairs of elements in
EC(owl : Thing) that are in the extension of neither
Eq nor Neq,
imply
Neq. As a result, we cannot use Neq to eliminate
occurrences of differentFrom in the antecedent of
a rule: in order to do so would require Neq to be
equivalent to the negation of Eq.

i.e., differentFrom does not

7. Examples of SWRL

We give two further examples of SWRL that serve
to illustrate some of its utility, and show how the power
of SWRL goes beyond that of either OWL DL or Horn
rules alone.

7.1. Transferring characteristics

The first example is due to Guus Schreiber, and is
based on ontologies used in an image annotation demo
[16].
Artist(?x)  Style(?y)  artistStyle(?x, ?y)
 creator(?x, ?z)  style/period(?z, ?y)

The rule expresses the fact that, given knowledge about
the Style of certain Artists (e.g., van Gogh is an Impressionist painter), we can derive the style/period of
an art object from the value of the creator of the art
object, where Style is a term from the Art and Architecture Thesaurus (AAT),6 Artist is a class from the
Union List of Artist Names (ULAN),7 artistStyle is
a property relating ULAN Artists to AAT Styles, and
both creator and style/period are properties from the
Visual Resources Association catalogue (VRA),8 with
creator being a subproperty of the Dublin Core element
dc:creator.9

6 http://www.getty.edu/research/tools/vocabulary/aat/.
7 http://www.getty.edu/research/conducting research/

vocabularies/ulan/.

8 http://www.vraweb.org/.
9 http://dublincore.org/.

This rule would be expressed in the XML concrete
syntax as follows (assuming appropriate entity decla-
rations):

The example is interesting because it shows how
rules can be used to transfer characteristics from
one class of individuals to another via properties other
than subClassOfin this case, the Style characteristics of an Artist (if any) are transferred (via the creator property) to the objects that he/she creates. This
idiom is much used in ontologies describing complex physical systems, such as medical terminolo-
gies, where partonomies may be as important as subsumption hierarchies, and where characteristics often
need to be transferred across various partitive properties [34,41,43]. For example, the location of a trauma
should be transferred across the partOf property, so that
traumas located in a partOf an anatomical structure are
also located in the structure itself [39]. This could be
expressed using a rule such as
Trauma(?x)  Location(?y)  isLocatedIn(?x, ?y)

 isPartOf(?y, ?z)  isLocatedIn(?x, ?z)

A similar technique could be used to transfer properties to composite processes from their component processes when describing web services.

Terminology languages designed specifically for
medical terminology such as Grail [40] and SNOMEDRT [47] often allow this kind of idiom to be expressed,
but it cannot be expressed in OWL (not even in OWL
Full). Thus this kind of rule shows one way in which
SWRL goes beyond the expressive power of OWL
DL.

7.2. Inferring the existence of new individuals

The second example is due to Mike Dean, and
illustrates a scenario in which we want to express
the fact that for every Airport there is a map Point
that has the same location (latitude and longitude) as
the Airport and that is an object of layer (a map
DrawingLayer).10 Moreover, this map point has the
Airport as an underlyingObject and has the Airport
name as its Label. Note how the expressive power
of SWRL allows existentials to be expressed in the
head of a ruleit is asserted that, for every Airport,
there must exist such a map point (using an OWL
someValuesFrom restriction in a class atom). In this
way SWRL goes beyond the expressive power of Horn
rules.

respectively;

that

The first part of

this example is background
knowledge about Airports and maps expressed in
OWL DL. (A few liberties have been taken with
the OWL DL abstract syntax here in the interests
of better readability.) In particular, it is stated that
map:location and map:object are individual-valued
Properties with inverse properties map:isLocationOf
latitude
and map:isObjectOf
and longitude are data-valued Properties;
that
map:Location is a class whose instances have exactly one latitude and exactly one longitude, both
being of type xsd:double; that layer is an instance
of map:DrawingLayer; that map is an instance of
map:Map whose map:name is Airports and
whose map:layer is layer; and that airport:GEC is
an instance of airport-ont:Airport whose name is
Spokane Intl and whose location is latitude
47.6197 and longitude 117.5336.

10 http://www.daml.org/2003/06/ruletests/translation-3.n3.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

Object and has a map:label which is the name of the
airport.

The first rule in the example requires that if a
map:Location is the sameLocation as another
location, then it has the same values for latitude and
longitude.

is

located,

is

The second rule requires

that wherever an
airport-ont:Airport
some
map:Location that is the sameLocation as the Airports location, and that is the location of a map:Point
that is an object of the map:DrawingLayer layer.
Note that the head of the rule is an atom of the form
C(?loc), where the class C is an OWL restriction.

there

8. Mapping to RDF graphs

It is widely assumed that the Semantic Web will
be based on a hierarchy of (increasingly expressive)
languages, with RDF/XML providing the syntactic and
semantic foundation (see, e.g., [5]). In accordance with
this design philosophy, the charter of the W3C Web
Ontology Working Group (the developers of the OWL
language) explicitly stated that The language will use
the XML syntax and datatypes wherever possible, and
will be designed for maximum compatibility with XML
and RDF language conventions.. In pursuance of this
goal, the working group devoted a great deal of effort
to developing an RDF based syntax for OWL that was
also consistent with the semantics of RDF [20]. It is,
therefore, worth considering how this design might be
extended to encompass rules.

One rather serious problem is that, unlike OWL,
rules have variables, so treating them as a semantic extension of RDF is very difficult. It is, however,
still possible to provide an RDF syntax for rules
it is just that the semantics of the resultant RDF
graphs may not be an extension of the RDF Semantics
[15].

A mapping to RDF/XML is most easily created
as an extension to the XSLT transformation for the
OWL XML Presentation syntax.11 This would introduce RDF classes for SWRL atoms and variables, and
RDF properties to link atoms to their predicates (classes
and properties) and arguments (variables, individuals
or data values).12 The example rule given in Section
7.1 (that equates the style/period of art objects with the
style of the artist that created them) would be mapped
into RDF as follows:

The third rule requires that the map:Point whose
map:location is the map:Location of an airport-
ont:Airport has the airport as a map:underlying

11 http://www.w3.org/TR/owl-xmlsyntax/owlxml2rdf.xsl.
12 The result is similar to the RDF syntax for representing disjunction and quantifiers proposed in [30].

employ either to fit within a tractable or decidable
fragment of SWRL, or so that their SWRL ontologies can be handled by existing or interim implementa-
tions.

One possible restriction in the form of the rules is
to limit antecedent and consequent classAtoms to be
named classes, with OWL axioms being used to assert
additional constraints on the instances of these classes
(in the same document or in external OWL documents).
Adhering to this format should make it easier to translate rules to or from existing (or future) rule systems,
including Prolog, production rules (descended from
OPS5), event-condition-action rules and SQL (where
views, queries, and facts can all be seen as rules); it
may also make it easier to extend existing rule based
reasoners for OWL (such as Euler13 or FOWL14) to
handle SWRL ontologies. Further, such a restriction
would maximise backwards compatibility with OWLspeaking systems that do not support SWRL. It should
be pointed out, however, that there may be some incompatibility between the first order semantics of SWRL
and the Herbrand model semantics of many rule based
reasoners.

By further restricting the form of rules and DL axioms used in SWRL ontologies it would be possible to
stay within DLP, a subset of the language that has been
shown to be expressible in either OWL DL or declarative logic programs (LP) alone [14]. This would allow
either OWL DL reasoners or LP reasoners to be used
with such ontologies, although there may again be some
incompatibility between the semantics of SWRL and
those of LP reasoners.

Another obvious strategy would be to restrict the
form of rules and DL axioms so that a hybrid system
could be used to reason about the resulting ontology.
This approach has been used, e.g., in the CLASSIC
[38] and CARIN systems [28], where sound and complete reasoning is made possible mainly by focusing on
query answering, by restricting the DL axioms to languages that are much weaker than OWL, by restricting
the use of DL terms in rules, and/or by giving a different
semantic treatment to rules.

Finally, an alternative way to provide reasoning
support for SWRL would be to extend the transla-

13 http://www.agfa.com/w3c/euler/.
14 http://fowl.sourceforge.net.

where &ulan;, &aat;, &aatulan; and &vra; are assumed to expand into the appropriate namespace
names. Note that complex OWL classes (such as OWL
restrictions) as well as class names can be used as the
object of SWRLs classPredicate property.

9. Reasoning support for SWRL

Although SWRL provides a fairly minimal rule extension to OWL, the consistency problem for SWRL
ontologies is still undecidable (as we have seen in Section 6). This raises the question of how reasoning support for SWRL might be provided.

It seems likely, at least in the first instance, that many
implementations will provide only partial support for
SWRL. For this reason, users may want to restrict the
form or expressiveness of the rules and/or axioms they

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

tion of OWL into TPTP15 implemented in the Hoolet
system,16 and use a first order prover such as Vampire
to reason with the resulting first order theory [42,53].
This technique would have several advantages: no restrictions on the form of SWRL rules or axioms would
be required; the use of a first order prover would ensure
that all inferences were sound with respect to SWRLs
first order semantics; and the use of the TPTP syntax
would make it possible to use any one of a range of
state of the art first order provers. A prototype based
on this approach is described in the following section.

10. A prototype SWRL reasoner

It is well known that OWL DL corresponds to the
SHOIND
n Description Logic (DL), and that, like
most other DLs, SHOIND
n is a fragment of classical
first-order predicate logic (FOL) [10,19,1]. This suggests the idea of using standard methods of automated
reasoning for FOL as a mechanism for reasoning with
OWL DL.

This might be done by trying to create from scratch
new architectures for reasoning in FOL, which would
be specialised for dealing efficiently with typical DL
reasoning tasks. A much less expensive option is to use
existing implementations of FOL provers, with the possibility of making adjustments that exploit the structure
of DL reasoning tasks. An additional attraction of using
a FO prover in this way is the fact that the translation
from DL to FOL can be extended to handle SWRL,
providing an implementation of a SWRL reasoner.

Here we describe our initial prototype implementation of just such a SWRL reasoner, known as Hoolet.
It should be noted that this initial implementation is
rather simplistic, and is only intended as a preliminary
feasibility study. We will, however, discuss the issue of
possible optimisations.

There have been earlier investigations of the use of
FOL provers to reason with description logics. Paramasivam and Plaisted, for example, have investigated
the use of FOL reasoning for DL classification [36],
while Ganzinger and de Nivelle have developed decision procedures for the guarded fragment, a frag-

15 A standard syntax used by many first order theorem proverssee
http://www.tptp.org.
16 http://www.w3.org/2003/08/owl-systems/test-results-out.

ment of FOL that includes many description logics
[11]. The most widely known work in this area was
by Hustadt and Schmidt [26], who used the SPASS
FOL prover to reason with propositional modal log-
ics, and, via well known correspondences [44], with
description logics. Their technique involved the use of
a relatively complex functional translation which produces a subset of FOL for which SPASS can be tuned
so as to guarantee complete reasoning. The results of
this experiment were quite encouraging, with performance of the SPASS based system being comparable,
in many cases, with that of state of the art DL reasoners.
The tests, however, mainly concentrated on checking
the satisfiability of (large) single modal logic formulae
(equivalently, OWL class descriptions/DL concepts),
rather than the more interesting task (in an ontology
reasoning context) of checking the satisfiability of formulae w.r.t. a large theory (equivalently, an OWL on-
tology/DL knowledge base).

In all of the above techniques, the DL is translated
into (the guarded fragment of) FOL in such a way that
the prover can be used as a decision procedure for the
logici.e., reasoning is sound, complete and terminat-
ing. Such techniques have, however, yet to be extended
to the more expressive DLs that underpin Web ontology
languages such as DAML + OIL and OWL DL [18],
and it is not even clear if such an extension would be
possible.

An alternative approach, and the one we describe
here, is to use a simple direct translation based on the
standard first order semantics of DLs (see, e.g., [1]). Using this approach, an ontology/knowledge base (a set of
DL axioms), is translated into a FO theory (a set of FO
axioms). A DL reasoning task w.r.t. the knowledge base
(KB) is then transformed into a FO task that uses the
theory. Unlike methods such as Hustadt and Schmidts
functional translation, this does not result in a decision
procedure for the DL. The direct translation approach
can, however, be used to provide reasoning services
(albeit without any guarantee of completeness) for the
expressive DLs underlying Web ontology languages,
DLs for which no effective decision procedure is currently known. Moreover, the translation approach can
easily deal with language extensions such as SWRL as
described here.

In recent years, a number of highly efficient FO
provers have been implemented [32,49,42]. These
provers compete annually on a set of tasks, and the

results are published [9]. One of the most successful
general-purpose provers has been Vampire [42], and
we have chosen this prover to use in our prototype.

Vampire is a general-purpose FOL prover developed by Andrei Voronkov and Alexandre Riazanov.
Given a set of first-order formulas, Vampire transforms
it into an equisatisfiable set of clauses, and then tries to
demonstrate inconsistency of the clause set by saturating it with ordered resolution and superposition (see
[3,33]). If the saturation process terminates without
finding a refutation of the input clause set, it indicates
that the clause set, and therefore the original formula
set, is satisfiable, provided that the variant of the calculus used is refutationally complete and that a fair
strategy17 has been used for saturation.

The main input format of Vampire is the TPTP syntax [48] (although a parser for a subset of KIF [12] has
been added recently). Using the TPTP syntax in our
prototype means that it would be possible to substitute
Vampire with any one of a range of state of the art first
order provers.

10.1. Translation issues

10.1.1. Translating OWL ontologies into FOL
axioms

We will only discuss the translation from DL to
FOL as the correspondence between OWL DL and
SHOIND
n is well known [19]. The translation 
maps DL concepts C and role names R into unary
and binary predicates C(x) and R(x, y) respectively.
Complex concepts and axioms are mapped into FO
formulae and axioms in the standard way [7,1]. For
example, subsumption and equivalence axioms are
translated into, respectively, FO implication and equivalence (with the free variables universally quantified).
As an example, lets see a translation of a couple of

concept and role axioms:

Simple DLs (like ALC) can be translated into the FOL
class L2 (the FOL fragment with no function symbols
and only two variables), which is known to be decidable [31]. The above translations of the role inclusion
axiom and concept equality axiom are, for example, in
L2. When number restrictions are added to these DLs,
they can be translated into C2  equivalent to L2 with
additional counting quantifiers  which is also known
to be decidable [13].

The FOL translation of more expressive description logics, e.g., with transitive roles (SHIQ, OWL
Lite and OWL DL) and/or complex role axioms (RIQ
[22]), may lead to the introduction of three or more
variables.18 The above transitivity axiom for role T is
an example of this case. FOL with three variables is
known to be undecidable [7].

OWL DL also provides for XML schema datatypes
[6], equivalent to a very simple form of concrete domains [21]. The minimum requirement for OWL DL
reasoners is that they support xsd:integer and
xsd:string datatypes, where support means providing a theory of (in)equality for integer and string
values [37].

Our translation encodes the required datatype theory
by mapping datatypes into predicates and data values
into new constants. Lexically equivalent data values
are mapped to the same constant, with integers first being canonicalised in the obvious way, and axioms are
added that assert inequality between all the string and
integer data constants introduced. If a data value DV
and a datatype DT are mapped to DV and DT respec-
tively, and DV is of type DT, then an axiom DT (DV ) is
also added. As the xsd:integer and xsd:string
interpretation domains are disjoint, we add an axiom to
that effect. Finally, we add an axiom asserting the disjointness of the datatype domain (the set of data values)
and the abstract domain (the set of individuals).

R  S
C  D  R.(E  S.F ) x(C(x)  D(x)  y(R(x, y)  (E(y)  x(S(x, y)  F (x)))))
A  3R.B

xy(R(x, y)  S(x, y))

x(A(x)  y1y2y3(R(x, y1)  B(y1)  R(x, y2)  B(y2)  R(x, y3)
B(y3)  (y1 = y2)  (y2 = y3)  (y1 = y3)))
xyz(T (x, y)  T (y, z)  T (x, z))

Transitive(T )

17 That is, all generated clauses are eventually processed.

18 In some cases, the effects of transitive roles can be axiomatised
in C2 [52].

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

Table 2
Rule atoms

Atom

C(i)
R(i,j)
i==j
i!=j

Type

Class atom
Property atom
Equality atom
Inequality atom

Table 3
Rule atom translation

Atom

C(i)
R(i,j)
i==j
i!=j

Translation

C(i)
R(i, j)
i=j
i = j

In accordance with the OWL DL semantics, other
unsupported data types are treated opaquely, i.e., data
values are mapped to the same constant if they are lexically identical, but no other assumptions are made (we
do not assume inequality if the lexical forms are not
identical) [37].

10.1.2. Translating SWRL rules into FOL axioms

Using the translation approach, we can easily extend the first-order translation to SWRL rules and thus
provide a simple implementation of a SWRL reasoner.

As we have seen, rules in SWRL are of the form:

B1, . . . , Bm  H1, . . . , Hn

where each of the Bi or Hj are rule atoms. Possible rule
atoms are shown in Table 2, where C is an OWL class
description, R an OWL property and i and j are either
OWL individual names or SWRL variables.

In our prototype we have only considered a simplification of SWRL where C must be a class name (rather
than arbitrary class descriptions), and R must be an object property. The first of these restrictions does not
affect the expressiveness of the language, as new class
names can be introduced into the ontology to represent
any complex descriptions required in rules. The restriction to object properties simplifies our implementation,
but the translation we describe could easily be extended
to handle data valued properties.

The translation of rules exactly follows the semantics of the rules as given in Section 4. Each rule is
translated as an implication, and any free variables in
the rule are assumed to be universally quantified. Thus
a rule:
B1, . . . , Bm  H1, . . . , Hn
is translated to an axiom:
x1, x2, . . . , xk.T (B1)  
T (Bm)  T (H1)    T (Hn)

where x1, x2, . . . , xk are all the variables occurring in
the Bi and Hj.

Translation of atoms is trivial and is shown in Table
3. Combining this translation with the translation from
OWL to FOL described above provides us with a prototype implementation of a SWRL reasoner. Given an
ontology and a collection of rules relating to that on-
tology, we translate the ontology to FOL, and then add
the FOL axioms generated by translating the rules. The
resulting theory is passed to a FO prover (Vampire in
our case), where it can be used for reasoning tasks such
as satisfiability checking and instance checking.

10.2. Examples

As an example, we will consider a variant on the

uncle example given in Section 3.2:

hasParent(?x,?y), hasSibling(?y,?z),

Male(?z)

 hasUncle(?x,?z)

If our ontology additionally includes the axiom and
facts (expressed here using standard DL syntax):
Uncle  hasUncle

Robert,Paul : hasParent
Paul,Ian : hasSibling


then the reasoner can infer not only hasUncle
(Robert, Ian), but also that Ian is an instance of
the Uncle class.

Another interesting aspect of the language is illus-

trated by the following rule:
Beer(?x)  Happy(Sean)

This expresses the fact that for any instances of the class
Beer, Sean must be an instance of Happy. This effectively allows us to express an existential quantification

over the class Beer: if we can prove the existence of an
instance of this class, then Sean will be Happy. Note
that we do not actually have to provide a name for such
an instance. For example, if our ontology includes the
fact:
Sean : drinks.Beer

then the reasoner can infer that Sean must be Happy
as we now know that there exists some instance of
Beereven though this instance is unnamed.

10.3. Performance and optimisation

Our prototype works well with small examples, such
as those given in Sections 7 and 10.2, and we have used
it successfully with SWRL ontologies containing up to
100 axioms, rules and facts. However, while it is useful
to have a prototype that can be used for illustrative and
test purposes, the effectiveness of such a naive approach
must be open to question with larger SWRL ontologies.
In [54] it was shown that, when using the same translation approach to reason with OWL DL ontologies,
performance could be greatly improved by using a socalled relevant only translation. The key idea is that
when ontologies are translated, Vampire receives all of
the axioms that occur in the ontology, whereas usually
only a small fraction of them are actually relevant to a
given subsumption or inconsistency problem. Vampire
is not optimised to deal efficiently with large numbers
of irrelevant axioms, and so it does not perform well
under these circumstances.

An obvious way to correct this situation is to remove all irrelevant information from the FO task given
to Vampire. An axiom is said to be irrelevant to a
consistency test of C if it can easily be shown (i.e.,
via a syntactic analysis) that removing it from the ontology would not affect the interpretation of C; other
axioms are called relevant. Note that not every relevant axiom really will affect the computation of the
consistency of C, but we cannot (easily) rule out the
possibility that it may affect the computation. An FOtranslation is called relevant-only if it contains only
FO-translations of axioms relevant (in the above sense)
to the given satisfiability test.

The definition of relevance given in [54] can be extended to SWRL by treating rules in the same way as
general concept inclusion axioms (GCIs). A concept

or role expression depends on every concept or role
that occurs in it, and a concept or role C depends on a
concept or role D if D occurs in the definition of C. In
addition, a concept C depends on every GCI and rule
in the ontology.19 Relevance is the transitive closure
of depends. The process of selecting information relevant to a concept expression E looks very much the
same as unfolding (see [1]), and assumes that the KB
is separated into a set of unfoldable axioms and a set of
GCIs [25] and rules. Every concept name CN and role
name RN appearing in E is relevant to E. The process
is then repeated recursively for unfoldable axioms with
CN on the left hand side (whether inclusion or equality
axioms). Also, if role R is relevant to E, then so are all
roles R
, along with their inverses (if the
target DL allows inverse roles). An algorithm for computing relevant information is quite straightforward and
is described in detail in [53].

s.t. R  R

Computing relevance leads to a small overhead
when translating a SWRL ontology into FOL, but it
should greatly increase the performance of the FO
prover. Preliminary experiments with an extension of
Hoolet to include an implementation of the relevant
only translation suggest that this is indeed the case [29].

11. Discussion

In this paper we have presented SWRL, a proposed
extension to OWL to include a simple form of Hornstyle rules. We have provided formal syntax and semantics for SWRL, shown how OWLs XML and RDF
syntax can be extended to deal with SWRL, illustrated
the features of SWRL with several examples, and discussed how reasoning support for SWRL might be pro-
vided.

The main strengths of the proposal are its simplicity
and its tight integration with the existing OWL lan-
guage. As we have seen, SWRL extends OWL with
the most basic kind of Horn rule (sweetened with a little syntactic sugar): predicates are limited to being
OWL classes and properties (and so have a maximum
parity of 2), there are no disjunctions or negations (of
atoms), no built in predicates (such as arithmetic pred-

19 It should be possible to treat (some) rules as unfoldable axioms,
add thus eliminate the need to include all rules in the relevant only
translation, but this is still the subject of ongoing work.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 2340

icates), and no nonmonotonic features such as negation as failure or defaults. Moreover, rules are given a
standard first order semantics. This facilitates the tight
integration with OWL, with SWRL being defined as a
syntactic and semantic extension of OWL DL.

While we believe that SWRL defines a natural and
useful level in the hierarchy of Semantic Web lan-
guages, it is clear that some applications would benefit
from further extensions in expressive power. In par-
ticular, the ability to express arithmetic relationships
between data values is important in many applications
(e.g., to assert that persons whose income at least equals
their expenditure are happy, while those whose expenditure exceeds their income are unhappy). It is not clear,
however, if this would best be achieved by extending
SWRL to include rules with built in arithmetic predi-
cates, or by extending OWL Datatypes to include nary
predicates [35].

Finally, we have shown how a first order theorem
prover can be used to provide reasoning services for
SWRL, and how some simple optimisations can be
used to improve performance. Our results were sufficiently encouraging to suggest that, with further tuning and optimisation, such a strategy would be useful
in (some) realistic applications. Future work will include such tuning and optimisation, as well as empirical investigations to determine the practical value of
the resulting system.

Acknowledgements

This document has benefited from extensive discussion in the Joint US/EU ad hoc Agent Markup Language Committee. Parts of Section 9, in particular, were
the result of feedback from and discussions with Benjamin Grosof and Mike Dean.
