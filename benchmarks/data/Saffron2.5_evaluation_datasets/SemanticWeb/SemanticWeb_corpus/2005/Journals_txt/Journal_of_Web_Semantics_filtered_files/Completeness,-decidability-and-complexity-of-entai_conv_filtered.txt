Web Semantics: Science, Services and Agents

on the World Wide Web 3 (2005) 79115

Completeness, decidability and complexity of entailment

for RDF Schema and a semantic extension

involving the OWL vocabulary

Herman J. ter Horst


Philips Research, Prof. Holstlaan 4, 5656 AA Eindhoven, The Netherlands

Received 1 June 2005; accepted 2 June 2005

Abstract

We prove that entailment for RDF Schema (RDFS) is decidable, NP-complete, and in P if the target graph does not contain
blank nodes. We show that the standard set of entailment rules for RDFS is incomplete and that this can be corrected by allowing
blank nodes in predicate position.

We define semantic extensions of RDFS that involve datatypes and a subset of the OWL vocabulary that includes the propertyrelated vocabulary (e.g. FunctionalProperty), the comparisons (e.g. sameAs and differentFrom) and the value
restrictions (e.g. allValuesFrom). These semantic extensions are in line with the if-semantics of RDFS and weaker than
the iff-semantics of D-entailment and OWL (DL or Full). For these semantic extensions we present entailment rules, prove
completeness results, prove that consistency is in P and that, just as for RDFS, entailment is NP-complete, and in P if the target
graph does not contain blank nodes. There are no restrictions on use to obtain decidability: classes can be used as instances.
 2005 Elsevier B.V. All rights reserved.

Keywords: Ontology; Semantics; Entailment; Completeness; Computational complexity

1. Introduction and overview

One of the main purposes of the Semantic Web [2]
is to make reasoning explicit: statements that enable
conclusions to be drawn are to be represented explicitly

 This paper is a revised and extended version of the paper entitled:
Extending the RDFS Entailment Lemma, which was presented at
the Third International Semantic Web Conference (ISWC2004) [10].


Tel.: +31 40 27 42026.
E-mail address: herman.ter.horst@philips.com (H.J. ter Horst).

1570-8268/$  see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2005.06.001

on the Web, for machine use. The W3C has defined two
languages for the Semantic Web: RDF and OWL. The
Resource Description Framework (RDF) [15] plays a
basic role by allowing the expression of statements, in
the form of subject-predicate-object triples. The Web
Ontology Language (OWL) [13] allows the expression
of ontologies, which define the meaning of terms used
in RDF statements. Simple ontologies can already be
expressed using the RDF Schema (RDFS) vocabulary
[15]. For RDF, RDFS and OWL, the valid conclusions,
called entailments, are determined by the semantics of

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

the language [8,14]. The RDFS entailment lemma [8]
claims completeness of a set of simple entailment rules
for RDFS. This result is used to implement reasoners and is useful for clarifying to people, in syntactic
terms, what RDFS entailment is. The RDFS entailment
lemma does not show decidability of RDFS entailment
because the closure graphs used in its proof are infinite
for finite RDF graphs. For OWL, no complete set of
entailment rules is known.

This paper has several purposes. It aims to:

RDFS entailment,

 settle the fundamental question of decidability of
 determine the computational complexity of RDFS
 extend the semantics and the complete set of simple
entailment rules for RDFS, with the results relating
to decidability and complexity, so as to apply to the
OWL vocabulary.

entailment, and

In order to achieve the first and second aims, we
prove a refined completeness result for RDFS, which
uses partial closure graphs that can be taken to be finite
for finite RDF graphs and can be computed in polynomial time. To achieve the third aim, we also consider
the inclusion of datatypes and describe a non-standard
semantics that applies to a subset of the OWL vocabu-
lary. This non-standard semantics, called the pD
se-
mantics, is defined in a way analogous to the semantics
of RDFS, but is weaker than the standard semantics of
OWL. pD
entailment shares with RDFS entailment
a relatively low computational complexity (NP, and in
a non-trivial case P) and the availability of a complete
set of simple entailment rules. This leads to a relatively
low threshold for implementation.


This paper also aims to give a mathematically clear
account of the results, including complete proofs.
Compared with [8], this paper devotes more attention
to the mathematical aspects of the RDF semantics.
While writing this paper, I discovered that the standard
set of entailment rules for RDFS is incomplete and
that this can be corrected by allowing blank nodes in
predicate position.

This paper is organized as follows. The remainder
of Section 1 provides an overview and discussion of
the results of this paper and some background, without going into mathematical details. In particular, we
discuss in Section 1.8 why it is reasonable, apart from


complexity considerations, to consider a weakened semantics in connection with the OWL vocabulary. Section 2 summarizes terminology and notation relating
to RDF graphs, defines generalized RDF graphs which
allow blank nodes in predicate position, extends the interpolation lemma to this setting, and proves that simple entailment is NP-complete. Section 3 defines the
semantics, which generalizes the RDFS semantics

to include reasoning with datatypes. Section 4 proves
that RDFS entailment is decidable, NP-complete, and
in P if the target graph does not contain blank nodes.
At the same time, these results are proved for an extension with datatypes, by means of the D
entailment
lemma. This is a completeness result which generalizes the RDFS entailment lemma. Section 5 describes
the pD
semantics and extends the completeness, de-

cidability and complexity results for RDFS to pD
entailment. Section 6 extends the completeness result
for pD
entailment to incorporate OWLs complete iff
condition for someValuesFrom. Section 7 summarizes the conclusions. In comparison with the conference version [10], this paper considers an enlarged subset of the OWL vocabulary, removes an assumption
from the results (the assumption that datatype maps
are discriminating) and completes the proofs of the re-
sults. Moreover, this paper adds to [10] several NPcompleteness proofs (announced in the presentation of
[10] and recorded in Propositions 2.9, 4.14 and 5.14,
which originally appeared in [11]) and the overview
that follows below.


1.1. RDF and OWL: semantics

Although the standard syntax for RDF and OWL
uses XML, it should be noted that the meaning of
RDF and OWL knowledge bases is independent
of XML and abstracts from the XML serialization
used. Here the notion of RDF graph [12] plays a
role. An RDF graph is a set of RDF statements, i.e.
subject-predicate-object triples; subjects and objects
of triples are viewed as nodes, linked by predicates
(predicates are usually called properties). For RDF,
RDF Schema (RDFS) and OWL, the entailments (i.e.
the valid conclusions) are determined by the semantics,
which is specified by means of a model theory [8,14].
These model-theoretic specifications follow a general
pattern that is derived from mathematical logic [3].
For an entailment relation X (e.g. RDFS entailment),

of the three standard versions of the OWL semantics,
OWL Full, OWL DL and OWL Lite, include many
iff conditions [14]. The RDF specification contains another entailment relation, for reasoning with datatypes,
called D-entailment [8]. D-entailment extends RDFS
entailment, while the OWL entailment relations in turn
extend D-entailment. Although D-entailment has been
placed on the iff side in Fig. 1, it is actually specified by
means of if conditions in combination with just one iff
condition; the latter condition requires that an element
of the universe of interpretation is a value of a datatype
if and only if it is an instance of this datatype regarded
as a class.

The meaning of the lines in Fig. 1 can be described
as follows. If an entailment relation X is connected
with a line to an entailment relation Y lower in the fig-
ure, then X extends Y (i.e., each Y-entailment is also
an X-entailment) and is stronger than Y (i.e., there
is an X-entailment that is not a Y-entailment). How-
ever, it should be noted that although there is an RDFcompatible semantics defining OWL DL (and OWL
Lite) as an extension of D-entailment (see [14], Section 5), OWL DL is normatively defined by means of
a direct model-theoretic semantics (see [14], Section
3), independently of D-entailment. The line between
D-entailment and OWL Lite in Fig. 1 has been drawn
differently from the other lines in view of the fact that
OWL DL and OWL Lite impose certain restrictive assumptions not used for D-entailment and OWL Full.

an RDF graph S is said to X-entail an RDF graph G
if each X-interpretation that satisfies S also satisfies
G. This definition is made complete with a detailed,
mathematical definition of X-interpretation. For RDF
and OWL, interpretations can be infinite and there
are infinitely many interpretations. Therefore, to make
the connection with reasoners and computation, a
bridge needs to be constructed. Before summarizing
what is known about the computational aspects of
the entailment relations specified for RDF and OWL,
we mention a fundamental distinction between two
different ways of specifying semantic conditions.

1.2. Semantics: if conditions versus iff
conditions

RDF and OWL differ in the way in which their semantics is defined [8,14]. The semantics of RDF and
RDFS is defined using if conditions, whereas the semantics of OWL uses many if-and-only-if conditions.1
A semantics that uses iff conditions in its specification
is more powerful, in the sense that it leads to more en-
tailments. The distinction can be illustrated using the
notion subClassOf from the RDF Schema (RDFS)
vocabulary. If c and d are classes, then RDFS requires
that if c is a subclass of d, then the extension of c (i.e. the
set of instances of c) is a subset of the extension of d. On
the other hand, OWL DL and OWL Full require that c is
a subclass of d if and only if the extension of c is a subset
of the extension of d. This example already indicates
that a semantics that uses iff conditions in its specification is indeed stronger: an iff-semantics may lead to entailments that are not supported under an if-semantics,
stating that a class is a subclass of another class.

1.3. RDF and OWL: overview of entailment
relations

Fig. 1 presents an overview of entailment relations
for RDF and OWL. The RDFS semantics is specified
by means of if conditions [8], as was already men-
tioned. RDFS entailment extends another entailment
relation, called simple entailment, which deals specifically with blank nodes, i.e. variables. The specifications

1 In connection with the semantics of RDFS, if conditions have
been called intensional conditions, while iff conditions have been
called extensional conditions [8].

Fig. 1. Entailment relations for RDF and OWL: overview. Entailment relations labeled complete have a complete set of entailment
rules.

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

For example, OWL DL and OWL Lite do not allow the
use of classes as instances.

What is known about these standard entailment relations from the RDF and OWL specifications? For
RDFS entailment there is a standard set of simple entailment rules, which is claimed to be complete by the
RDFS entailment lemma [8]. OWL Full entailment is
known to be undecidable [9]. For OWL DL, the restrictive assumptions already mentioned have been placed
on the use of the language to ensure decidability. With
regard to computational complexity, OWL DL entailment is known to be complete for NEXPTIME, while
entailment for the OWL Lite part is known to be complete for EXPTIME [9]. These are worst-case complexity results. Optimized reasoners exist; these make
use of techniques developed for description logics [1].
For D-entailment no complete set of entailment rules
is known and decidability is unknown.


The main results of this paper can be summarized as
follows. RDFS entailment is decidable, NP-complete,
and in P if the target graph does not contain blank nodes.
There is a somewhat weaker variant of D-entailment
that extends RDFS entailment with reasoning with
datatypes, called D
entailment, that is defined by
means of if conditions and has the same computational
properties as RDFS entailment: there is a complete set
of simple entailment rules, it is decidable, NP-complete
or even in P. A new entailment relation is considered
in the upper left quadrant of Fig. 1: there is a variant of
OWL entailment specified by means of if conditions,
again with the same computational properties as RDFS

entailment. The notion of pD
entailment extends D
entailment and includes semantic conditions for a subset of the OWL vocabulary. We also show that for the
RDFS, D
semantics, consistency is in P. We
extend the completeness result for the pD
semantics to

the pD
sv semantics, which incorporates OWLs complete iff condition for somevaluesFrom. Finally, we
show that the standard set of entailment rules for RDFS
is incomplete and that this can be corrected by allowing
blank nodes in predicate position. We consider the left
part of Fig. 1 more closely, starting at the bottom and
proceeding upward.

and pD


1.4. Simple entailment

can be used as subjects and objects of RDF statements.
Blank nodes are, implicitly, existentially quantified.
For example, the RDF statement

Iliad hasAuthor Homer .

simply entails the RDF statement

Iliad hasAuthor b .

Here b is assumed to be a blank node (in this example and several other examples, we use the N-Triples
syntax for RDF [5], in abbreviated form, using metavariables such as b in the example just given). The intuition behind simple entailment is that replacements
can be found for the blank nodes in the target graph in
a way that is consistent with the given graph. In this
paper we prove that the problem S simply entails G,
with S and G finite RDF graphs, is NP-complete. If the
target graph G does not have blank nodes, this problem
is in P, as it is only necessary to check that each triple
in G is also in S.

1.5. RDFS entailment: completeness

In [8] the RDFS entailment lemma is presented,
which aims to provide a complete reasoning procedure
for RDFS entailment, reflecting in syntactic terms
exactly what RDFS entailment is. According to the
RDFS entailment lemma, any RDFS entailment can
be obtained with a finite derivation by means of simple
entailment rules and axiomatic triples. There are 18
entailment rules and infinitely many axiomatic triples.
As an example, for RDFs standard container types
(e.g. sequence and bag) the container membership
properties rdf: i are used as well as axiomatic triples
such as

rdf: i rdf:type rdf:Property .

This triple specifies rdf: i to belong to the standard
class rdf:Property. Here i can have any value
1,2,. . ., which shows that there are infinitely many
axiomatic triples. We give three examples of rules.
According to entailment rule rdfs9, any two RDF
triples of the form

RDFS entailment extends simple entailment, which
handles blank nodes. Blank nodes are variables, which

u rdf:type v .

v rdfs:subClassOf w .

(i.e. u is of type v and v is a subclass of w) entail the
triple

u rdf:type w .

allowing blank nodes to refer to classes and properties,
the syntax does not allow blank nodes to appear in
predicate position. In view of this syntactic restriction,
the triple (4) cannot be derived from the triples (1)(3)
by means of the entailment rules for RDFS. Rule rdfs7,
for rdfs:subPropertyOf, cannot be applied to
the triples (1) and (3) to obtain the triple

According to entailment rule rdfs2, any two RDF
triples of the form

v b w .

(5)

v p w .

p rdfs:domain u.

entail the triple

v rdf:type u .

According to entailment rule rdfs7, two RDF triples
of the form

v p w .

which would be needed to complete the proof of (4)
by using triple (2) and rule rdfs2 for rdfs:domain.
In this paper we extend the notion of RDF graph to
allow blank nodes in predicate position and show that
the standard entailment rules for RDFS become complete if rule rdfs7 is replaced by a suitably extended rule
rdfs7x. In view of the fact that the semantics of RDFS
allows blank nodes to refer to properties, generalized
RDF graphs, which allow blank nodes in predicate po-
sition, seem to form a more direct abstract syntax for
RDFS than RDF graphs.

If b is a blank node that does not appear in other

triples of an RDF graph, then the triple

p rdfs:subPropertyOf q .

v b w.

(6)

entail the triple

v q w .

It turns out that the completeness claim of the RDFS
entailment lemma is not correct, as was overlooked in
[8] and [10]. We describe an example, involving the
entailment rules rdfs2 and rdfs7 just mentioned. Consider the RDF graph consisting of the following three
triples:

p rdfs:subPropertyOf b .

b rdfs:domain u .

v p w .

(1)

(2)

(3)

Here b is assumed to be a blank node. It is not difficult
to prove by means of the semantic definitions that
these three triples RDFS-entail the triple

v rdf:type u .

(4)

(See Example 4.3 for
the proof.) Although the
semantics of RDFS has a higher-order aspect,

expresses that there exists a relation between v and
w, although nothing is expressed about this relation.
It is interesting to note that in this generalized setting
for RDF, the question of whether items v and w are
related when an RDF graph is given can be answered
by checking whether the RDF graph entails the triple
(6).

1.6. RDFS entailment: decidability, complexity

The RDFS entailment

lemma does not show
decidability of RDFS entailment. The existence of
a complete reasoning procedure in itself does not
guarantee decidability; compare first-order logic, with
G odels completeness theorem and Churchs theorem
showing undecidability [3]. Moreover, the proof of
the RDFS entailment lemma [8] makes use of closure
graphs which are infinite for finite graphs. The RDFS
closure of an RDF graph is formed by first adding all
(infinitely many) axiomatic triples to the graph and by
subsequently applying the entailment rules until the
graph is unchanged. An RDFS closure may contain
an XML clash, which is an easily identifiable kind of

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

triple resulting from ill-formed XML used as object
value in an RDF statement (this will be discussed further in Section 1.7). According to the RDFS entailment
lemma, an RDF graph S RDFS-entails an RDF graph
G if and only if the RDFS closure of S simply entails G
(or contains an XML clash). This implies that in order
to decide whether S RDFS-entails G, it is sufficient to
check whether a finite subgraph of the RDFS closure
of S simply entails G. However, since the closure of
S is infinite, and therefore the number of candidate
subgraphs is infinite, this is not a finite algorithm.

We prove decidability of RDFS entailment by refining the RDFS entailment lemma. Instead of using a
full RDFS closure, we show that it is sufficient to use
a partial RDFS closure which excludes the axiomatic
triples for the container membership properties rdf: i
not used in either the source graph S or the target graph
G, as long as these axiomatic triples are included for
at least one property rdf: i. According to the version
of the RDFS entailment lemma proved in this paper,
an RDF graph S RDFS-entails an RDF graph G if and
only if such a partial closure of S simply entails G (or
contains an XML clash). This refined version of the
RDFS entailment lemma leads to most of the technical complexity of the proofs in this paper. It implies
decidability of RDFS entailment. We show that the
partial closures used can be computed in polynomial
time and that, just as for simple entailment, the problem S RDFS-entails G is in NP, and in P if G does
not have blank nodes; we also prove that this problem
(without restrictive assumptions) is NP-complete. The
partial closures that we use are, in general, generalized
RDF graphs, which allow blank nodes in predicate position (cf. Section 1.5).

The result that the problem S RDFS-entails G is
in P if G does not have blank nodes is relevant in prac-
tice. The target graph G typically forms a relatively
small part of the combined problem data S, G, and may
contain relatively few blank nodes. The results clearly
indicate the computational cost of using blank nodes
in a target graph.2

2 There seems to be little theoretical work on the RDF model and
its semantic extensions. An exception is [6], which focuses on fundamental database questions (redundancy, queries). In [6] it is also
stated, without proof, that a simplified variant of RDFS entailment,
which ignores the semantic conditions leading to infinite closures, is
NP-complete.

1.7. Inclusion of datatypes: D


entailment


RDFS entailment includes conditions for a special
datatype, rdf:XMLLiteral, which enables pieces
of XML text to be used as data values in RDF state-
ments. By applying these semantic conditions for the
datatype XMLLiteral to other datatypes as well, a
more general entailment relation is obtained, which is
called D
entailment and which extends RDFS entailment to include reasoning with datatypes. It should
be noted that the treatment of rdf:XMLLiteral
in RDFS is different from the treatment of datatypes
in datatyped interpretations, and that D
entailment
is weaker than the standard notion of D-entailment
[8] which extends RDFS with datatyped reasoning.
With respect to D
entailment (and D-entailment),
the datatypes used are combined in a datatype map,
which can include, for example, the standard XML
Schema datatypes xsd:string and xsd:integer
required for OWL entailment. D
entailment has the
same computational properties as RDFS entailment:
there is a complete set of simple entailment rules, it
is NP-complete, and in P if the target graph has no
blank nodes. These results are obtained with only one
change to the entailment rules for RDFS.3 To explain
the changes required to go from RDFS entailment to
entailment, we mention two further entailment rules

for RDFS. The literal generalization rule (lg) states that
an RDF triple of the form


v p l .

(7)

where l is a literal (i.e. a data value), entails the triple

v p bl .

where bl is a new, surrogate blank node for l. These
surrogate blank nodes are used, for example, in rule
rdf2, which states that the same given triple (7), where
l is now a well-typed XML literal, entails the triple

bl rdf:type rdf:XMLLiteral .

As was already mentioned in Section 1.6, an RDFS
closure or a partial RDFS closure may contain an XML

3 See Table 4 for the complete set of 18 entailment rules for RDFS
entailment, including the conditions of applica-


entailment and D
bility.

clash: an XML clash is a triple

bl rdf:type rdf:Literal .


where bl is the blank node allocated by rule lg to an
ill-typed XML literal. To go from RDFS entailment to
entailment, the entailment rule rdf2 just mentioned

is replaced by rule rdf2-D, with the same effect as rule
rdf2 not only for XMLLiteral but for all datatypes in
a datatype map. In addition, the notion of XML clash is
replaced by the analogous notion of D-clash which applies not only to ill-typed XML literals but to ill-typed
literals of any type in the given datatype map. While
XML clashes are the only inconsistencies that can arise
under the RDFS semantics, D-clashes are the only inconsistencies that can arise under the D
semantics. For
example, if the given datatype map contains the standard XML Schema datatypes string and integer, then
the two triples


b rdf:type xsd:string .

b rdf:type xsd:int .

(8)

(9)


where b is a blank node, are consistent under the
semantics. On the other hand, these two triples

are inconsistent under the D-semantics [8], since the
value spaces of the two datatypes string and integer
are disjoint. This shows that D-entailment is indeed
stronger than D
entailment. Consider, however, the
following meta-modeling triple, which uses the OWL
vocabulary:


xsd:string owl:disjointWith xsd:int .


semantics, to which we turn next, the
Under the pD
triples (8) and (9), together with the triple (10), are
inconsistent.

(10)


1.8. pD

entailment


By weakening the standard iff-semantics of OWL,
we define the pD
entailment relation, which extends
RDFS entailment and D
is largely
defined by means of if conditions, and applies to a
property-related subset of the OWL vocabulary. This
subset
includes FunctionalProperty, which
has been stated by several people to be the single most

entailment,


useful element of the OWL vocabulary. In addition to
semantics has
FunctionalProperty, the pD
semantic conditions for InverseFunctional-
Property, sameAs, SymmetricProperty,
TransitiveProperty, inverseOf, equiv-
alentClass, equivalentProperty, has-
Value, someValuesFrom, allValuesFrom,
differentFrom and disjointWith. With
respect to this subset of the OWL vocabulary, the
semantics is intended to represent a reasonable
pD
interpretation that is useful for drawing conclusions
about instances in the presence of an ontology, and that
leads to simple entailment rules and a relatively low
computational complexity. We show completeness of
entailment. 4
a set of simple entailment rules for pD

Just like RDFS entailment and D
entailment, pD
entailment is decidable, NP-complete, and in P if the
target graph has no blank nodes. Just as for RDFS
entailment and D
entailment, a partial closure that is
sufficient for deciding entailment can be computed in
polynomial time.


As an example of an entailment rule, rule rdfp1

states that three triples of the form

p rdf:type owl:FunctionalProperty .

u p v .

u p w .

entail the triple

v owl:sameAs w .

As another example, rule rdfp4 states that three triples
of the form

p rdf:type owl:TransitiveProperty .

u p v .

v p w .

4 The complete set of 18 entailment rules for RDFS entailment and

entailment shown in Table 4 can be combined with 23 other rules
entailment. See Table 7 for these

to form a complete set for pD
rules.


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

entail the triple

u p w .

entail the triple

u rdf:type v .


For hasValue, the complete if-and-only-if condition
of OWLs semantics is included in the pD
semantics.
For allValuesFrom and someValuesFrom, an
if-semantics is provided, realizing half of OWLs iff
conditions. The entailment rule for allValuesFrom
(rdfp16) essentially states that, for an instance of an
allValuesFrom restriction with respect to a certain
class and a certain property, each value of the property can be concluded to belong to the class. More
explicitly, rule rdfp16 states that four triples of the
form

v owl:allValuesFrom w .

v owl:onProperty p .

(11)

(12)

u rdf:type v .

u p x .

entail the triple

x rdf:type w .

Here the two triples (11) and (12) define the
allValuesFrom restriction class v with respect to
the class w and the property p.

The entailment

rule for someValuesFrom
(rdfp15) is formulated the other way around: it essentially states, for a certain given entity, that if a
value of a certain property belongs to a certain class,
then this entity can be concluded to belong to the
someValuesFrom restriction with respect to this
property and class when this someValuesFrom restriction has been defined. More explicitly, rule rdfp15
states that four triples of the form

v owl:someValuesFrom w .

v owl:onProperty p .

u p x .

x rdf:type w .


The pD
semantics for someValuesFrom may not
be sufficient for various applications. However, it is
possible to use RDFs blank nodes to capture OWLs
complete iff condition for someValuesFrom, by
combining rule rdfp15 with a second entailment rule
for someValuesFrom. Rule rdf-svx states that three
triples of the form

v owl:someValuesFrom w .

v owl:onProperty p .

u rdf:type v .

entail the two triples

u p b .

b rdf:type w .

(13)

(14)

(15)

(16)

(17)


Here b is a new blank node. It should be noted that
the decidability and complexity results obtained in this
paper for pD
entailment do not incorporate the use of
rule rdf-svx. We do, however, extend the completeness

result for pD
entailment to an extended entailment
relation, called pD
sv entailment, which incorporates
OWLs complete iff condition for someValuesFrom
as well as entailment rule rdf-svx. In some situations the
complete iff condition for someValuesFrom may
already be available in combination with a reasoner
that supports only the pD
semantics. Suppose that a
person or an application wants to add the statement
that a certain item u belongs to the class v, where v is
the someValuesFrom restriction defined by triples
(13) and (14). Then, instead of adding the triple (15),
the triples (16) and (17) can be added, where b is a
new blank node. This pair of triples reflects exactly the
intention of the class v, as u is declared to be related with
respect to p to some instance of w, while nothing more

is expressed about this instance of w. Under the pD
semantics, the two triples (16) and (17) are stronger
than the triple (15), since the latter triple is derived
by means of rule rdfp15. This more controlled way of
introducing new blank nodes may be useful in some
situations in combination with the use of a reasoner
that supports only the pD

semantics.

Although the pD

semantics does not handle explicitly owl:unionOf and owl:intersectionOf,
half of OWLs iff conditions for these constructs
are available in an alternative way, by means of
rdfs:subClassOf. It can be expressed that the
union of the classes c1, . . . , cn is contained in a class
c by saying that each class cj is a subclass of c. More-
over, it can be expressed that a class c is contained in
the intersection of the classes c1, . . . , cn by saying that
c is a subclass of each class cj.

The pD

semantics does not consider owl:
complementOf. However, part of the semantics of
OWL for this construct can be obtained by using the following meta-modeling triple, which is consistent with
the semantics of OWL:

RDFS two triples of the form

p rdfs:domain v .

v rdfs:subClassOf w .

entail the triple

p rdfs:domain w .

(19)

(20)

(21)

This entailment is not an RDFS entailment. How-
ever, entailments obtained when the entailed triple (21)
would have been added to the triples (19) and (20)
are already obtained under the standard if-semantics
for RDFS given only the original two triples (19) and
(20). For example, the two triples (19) and (20) plus the
triple

owl:complementOf rdfs:subPropertyOf

owl:disjointWith .

(18)

a p b .


Consistency with respect to the pD

semantics can
be checked in polynomial time. An RDF graph is inconsistent with respect to the pD
semantics if and only if
a partial closure of this graph contains a D-clash (see
Section 1.7) or a P-clash; a P-clash is either a combination of two triples of the form


v owl:differentFrom w .

v owl:sameAs w .

or a combination of three triples of the form

v owl:disjointWith w .

u rdf:type v .

u rdf:type w .

Why is it reasonable, apart from complexity consid-
erations, to consider a weakened semantics for OWL?
Which entailments are missed? Before considering
these questions further for OWL, we briefly consider
them for RDFS. In Sections 4.2 and 7.3.1 of [8] an
alternative semantics for RDFS is described, which is
specified by means of iff conditions and allows conclusions to be drawn about entire classes or properties (cf.
Section 1.2). For example, under an iff-semantics for

RDFS-entail, with or without the triple (21), the triple

a rdf:type w .

conditions

It turns out that entailment rules for the stronger
iff-semantics for RDFS become more complex;
no complete set of entailment rules has been de-
[8] used
scribed. Some preliminary versions of
iff
and
rdfs:subPropertyOf;
error was
found in a preliminary version of the RDFS entailment
lemma, these conditions were changed to if conditions.
The standard if-semantics for RDFS is deliberately
chosen to be the weakest reasonable interpretation
of the RDFS vocabulary [8].

rdfs:subClassOf

after

for

an

Just as for RDFS, certain reasonable entailments are
entailment relation. For exammissing from the pD
ple, under the iff conditions defining OWL, the triple


p rdf:type owl:SymmetricProperty .

entails the triple

p owl:inverseOf p .

Moreover, the triple

p owl:inverseOf q .

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

iff-entails the triple

q owl:inverseOf p .

To give another example of an iff-entailment, the two
triples

p rdf:type owl:FunctionalProperty .

p owl:inverseOf q .

entail the triple

q rdf:type owl:InverseFunctional-

Property.

Moreover, two triples of the form

(22)

(23)

(24)

p rdfs:domain u .

p owl:inverseOf q .

iff-entail the triple

q rdfs:range u .

As a final example, four triples of the form

p rdfs:range c .

v owl:allValuesFrom c .

v owl:onProperty p .

a rdf:type rdfs:Resource .

iff-entail the triple

a rdf:type v .


These iff-entailments are not pD
entailments. How-
ever, just as for the RDFS example described, in examples such as these the iff-entailed statements do not lead
to new consequences when the combination is made
with data relating to instances. It is not difficult to check
this with the entailment rules (see Tables 4 and 7). As

an example, the two triples (22) and (23) plus the two
triples

u q w .

v q w .


pD

entail, with or without the triple (24), the triple

u owl:sameAs v .


The pD
semantics does not include semantic conditions for the complete OWL vocabulary. It leaves out, in
particular, the cardinality restrictions and oneOf. We
mentioned that part of OWLs semantics for unionOf,
intersectionOf and complementOf can be obtained in an alternative way. Extension of the pD
se-
mantics to deal with the part of the OWL vocabulary
not considered explicitly will lead to some more complicated entailment rules, for example because OWL
uses lists encoded by means of RDF triples.


We discussed that the pD

semantics misses certain reasonable entailments for the part of the OWL
vocabulary it does consider. In particular, applications that use someValuesFrom may need OWLs
stronger semantic conditions, which are also included
in the pD
sv semantics. However, examples such
as those discussed also suggest that an if-semantics
seems to be sufficient for many applications where
an ontology is used in combination with data relating to instances. To summarize examples such as
these, iff-entailments missing from the pD
seman-
tics make explicit certain statements (about classes and
properties) which do not lead to new consequences
when the combination is made with data relating to
instances.


OWL DL imposes restrictions on use to obtain decidability;
in particular, classes and properties cannot be used as instances, and the use
of FunctionalProperty and TransitiveProperty is restricted (see [14], Section 2.3.1.3 for
the latter restrictions on the use of OWL DL and OWL
Lite). The pD
semantics does not impose restrictions on use to obtain decidability and supports metamodeling expressivity. In view of the complete set of
simple entailment rules, and the result that pD
en-
tailment is in NP, and in a non-trivial case even in P,
it can be said that, just as for RDFS, an if-semantics

applied to (a subset of) the OWL vocabulary leads to
computational advantages.

2.2. RDF graphs and generalized RDF graphs

An (RDF) graph G [12,8] is defined to be a subset

2. RDF graphs and simple entailment

An RDF or OWL knowledge base is formalized as
an RDF graph. This section recalls basic concepts relating to RDF graphs and simple entailment [8,12], and
introduces generalizations as well as some notation.
This section also considers the interpolation lemma [8]
which characterizes simple entailment (cf. Section 1.4)
and proves NP-completeness of simple entailment. The
basic tool that we use in the remainder of this paper
is set theory [7]. As has already been mentioned in
Section 1.5, in order to obtain a complete set of entailment rules for RDFS, we adopt a syntactic extension of
RDF. We use generalized RDF graphs, allowing blank
nodes in predicate position. Instead of only using generalized RDF graphs as closure graphs of ordinary RDF
graphs, we also state and prove the results of this paper
for generalized RDF graphs. This requires hardly any
additional effort.

2.1. URI references, blank nodes, literals

We first recall various notions from [12,8], define
the symbols U, B, L also used by other authors and
add the symbol T. RDF distinguishes three sets of syntactic entities. Let U denote the set of URI references
(i.e. Uniform Resource Identifiers) and B the set of
blank nodes, i.e. variables. The set B is assumed to
be infinite. Let L be the set of literals, i.e. data values such as strings and integers; L is the union of the
set Lp of plain literals and the set Lt of typed liter-
als. A typed literal l consists of a lexical form s and a
datatype URI t: we shall write l as a pair, l = (s, t). The
sets U, B, Lp and Lt are pairwise disjoint. A name
is an element of U  L and a vocabulary is a subset of U  L. RDF has a special datatype URI, called
rdf:XMLLiteral, which will also be written as
XMLLiteral. An XML literal is a typed literal of the
form (s, XMLLiteral). XML literals enable pieces of
XML content to be used as data values. In addition to
these notions from [12,8], an RDF term is either a URI
reference, a blank node or a literal, in line with the usage
by [16]. The set of RDF terms will be denoted by T: T =
U  B  L.

(25)

of the set
U  B  U  U  B  L.
A generalized (RDF) graph G is defined as a subset of
the set
U  B  U  B  U  B  L.
The elements (s, p, o) of a (generalized) RDF graph are
called (generalized) RDF statements or (generalized)
RDF triples, which consist of a subject, a predicate (or
property) and an object, respectively. We write triples
as s p o and use meta-variables for RDF terms in order
to shorten definitions and proofs. The notation can be
viewed as an abbreviation of the N-Triples notation [5]
used in the examples in Section 1.5

(26)

Two simple definitions [8] extend immediately from
RDF graphs to generalized RDF graphs: a subgraph of
a generalized RDF graph is a subset of the graph, while
a generalized graph is ground if it has no blank nodes.
It is useful to add some notation. Denoting the projection mappings on the three factor sets of the product
set given in (26) by i, the set of RDF terms of a generalized RDF graph G will be denoted by
T (G) = 1(G)  2(G)  3(G),
which is a subset of U  B  L. The set of blank nodes
of a generalized RDF graph G will be denoted by
bl(G) = T (G)  B.

The vocabulary of a generalized RDF graph G, denoted
by V (G), is the set of names that occur as subject, predicate or object of a triple in G:
V (G) = T (G)  (U  L).

The set of nodes of a generalized RDF graph G is
nd(G) = 1(G)  3(G).
5 As in the expression s p o  G, where G is an RDF graph, the
context will always make clear what the triple is. In the proofs we
sometimes express that two triples s p o and s
are equal (i.e.
that s = s

) by writing s p o = s

and o = o

, p = p

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

Definition 2.1
(Equivalence). Two RDF graphs G
and G
are equivalent [12] if there is a bijection f :
nd(G)  nd(G
) such that f (bl(G))  bl(G

), such
that f (v) = v for each v  nd(G)  (U  L), and such
that s p o  G if and only if f (s) p f (o)  G

. This is
the only definition in this paper for which the extension to generalized RDF graphs is not trivial. We extend this definition in the following way to generalized
graphs. Two generalized RDF graphs G and G
are
equivalent if there is a bijection f : T (G)  T (G

such that f (bl(G))  bl(G
), such that f (v) = v for

each v  V (G), and such that s p o  G if and only
if f (s) f (p) f (o)  G

. Note that equivalence forms an
equivalence relation on the class of all generalized RDF
graphs.

SI : V  U  RI  PI ,
LI : V  Lt  RI .

Here P(X) denotes the power set of the set X, i.e.
the set of all subsets of X. The function EI defines the extension of a property as a set of pairs
of resources. The functions SI and LI define the
interpretation of URI references and typed literals,
respectively.

If I is a simple interpretation of a vocabulary
V, then I also denotes a function with domain V
in the following way. For plain literals l  Lp 
V , we have I(l) = l  LVI. For typed literals l 
Lt  V, I(l) = LI(l). For URI references a  U  V,
I(a) = SI(a).
If E = s p o is a ground triple, then a simple interpretation I of a vocabulary V is said to satisfy E if
s, p, o  V, I(p)  PI, and (I(s), I(o))  EI(I(p)). If
G is a ground RDF graph, then I satisfies G if I satisfies
each triple E  G.

Given a simple interpretation I and a partial function
A : B  RI, a function IA is defined that extends I by
using A to give an interpretation of blank nodes in the
domain of A. If A(v) is defined for v  B, then IA(v) =
A(v). If G is any generalized RDF graph, then I satisfies
G if IA satisfies G for some function A : bl(G)  RI,
i.e. if, for each triple s p o  G, we have IA(p)  PI
and
(IA(s), IA(o))  EI(IA(p)).

If I is a simple interpretation and S a set of generalized
RDF graphs, then I satisfies S if I satisfies G for each
G in S; it is not difficult to see that I satisfies S if and
only if I satisfies M(S).

2.4. Simple entailment

The definition of simple entailment [8] is extended
in a straightforward way to all generalized RDF graphs:
the set S of generalized RDF graphs simply entails a
generalized RDF graph G if each simple interpretation that satisfies S also satisfies G. In this case we
write
S |= G.

The following two definitions provide straightforward extensions to generalized RDF graphs of standard
definitions for RDF graphs [8].

Definition 2.2 (Instance). Given a generalized RDF
graph G and a partial function h : B  T , another generalized RDF graph is defined, the instance Gh of G,
obtained by replacing the blank nodes v that are both
in G and the domain of h by h(v).

Definition 2.3 (Merge). Given a set S of generalized RDF graphs, a merge of S is a generalized RDF
graph that is obtained by replacing the generalized

graphs G in S by equivalent generalized graphs G
that do not share blank nodes, and by taking the
union of these generalized graphs G
. The merge of
a set of generalized RDF graphs S is uniquely defined up to equivalence. A merge of S will be denoted
by M(S).

2.3. Simple interpretations

A simple interpretation I [8] of a vocabulary V is
a 6-tuple I = (RI , PI , EI , SI , LI , LVI), where RI is a
non-empty set, called the set of resources or the uni-
verse, PI is the set of properties, LVI is the set of literal values, which is a subset of RI that contains at
least all plain literals in V, and where EI , SI and LI
are functions:
EI : PI  P(RI  RI),

For RDF graphs, simple entailment is characterized by
the interpolation lemma proved in [8].

Lemma 2.4 (Interpolation lemma). If S is a set of RDF
graphs and G is an RDF graph, then S |= G if and only
if a subset of M(S) is an instance of G.

This result shows that the simple-entailment relation
S |= G between finite sets S of finite RDF graphs and
finite RDF graphs G is decidable. We shall now show
that the interpolation lemma extends to all generalized
RDF graphs by adapting the proof of the interpolation
lemma given in [8]. The proof contains in simple form
several key ideas that will reappear in more complicated ways for RDFS and OWL in the following sec-
tions. We first need to extend two other lemmas from
[8] to generalized RDF graphs.

Lemma 2.5 (Generalized instance lemma). If H and
G are generalized RDF graphs and if H is an instance
of G, then H |= G.
Proof. Suppose that the simple interpretation I satisfies H, and suppose that H is obtained from G by
the function h : bl(G)  T (H). Extend h to become
a function h : T (G)  T (H), by means of h(v) = v
for each v in T (G)  bl(G). Choose A : bl(H) 
RI such that IA satisfies H. Let s p o  G. Then
h(s) h(p) h(o)  H, so that IA(h(p))  PI and
(IA(h(s)), IA(h(o)))  EI(IA(p)).

: bl(G)  RI to be

(b  bl(G)).

(v  T (G)),

Define A
(b) = IA(h(b))

Then we have
(v) = IA(h(v))

so that

(s), IA

(o))  EI(IA
(IA
Hence I satisfies G. 

(p)).

Definition 2.6 (Herbrand interpretation). The Herbrand interpretation of a non-empty generalized RDF
graph G is an interpretation of the vocabulary V (G),

constructed by means of G itself. It is defined as fol-
lows, generalizing the notion of simple Herbrand interpretation from [8]:
RI = T (G),
LVI = T (G)  Lp,
PI = 2(G),
SI(v) = v
LI(v) = v
EI(p) = {(s, o) : s p o  G}

(v  V (G)  U),
(v  V (G)  Lt),

(p  PI).

The Herbrand interpretation of a generalized RDF
graph G will be denoted by H(G).

Lemma 2.7 (Generalized satisfaction lemma). Each
generalized RDF graph G has a satisfying interpreta-
tion: if G is non-empty, then H(G) satisfies G.

Proof. The empty graph is satisfied by any interpreta-
tion. Suppose G is a non-empty generalized graph, let
I be the Herbrand interpretation H(G) of G, and let A
be the identity function on bl(G). Then IA(v) = v for
each v  T (G), so (IA(s), IA(o))  EI(IA(p)) for each
triple s p o  G. Therefore, I satisfies G. 
Lemma 2.8 (Generalized interpolation lemma). If S is
a set of generalized RDF graphs and G a generalized
RDF graph, then S |= G if and only if there is a subset
of M(S) that is an instance of G.
Proof.  If S is empty, then it is clear that G
must be empty as well, so that the conclusion fol-
lows. If S is non-empty, let I be the Herbrand interpretation of M(S) : I = H(M(S)). (It is assumed that
the set B of blank nodes is large enough to form the
merge M(S).) Since I satisfies S by the satisfaction
lemma, I satisfies G. Choose A : bl(G)  RI such that
IA satisfies G. It follows that for each triple s p o 
G, M(S) contains the triple IA(s) IA(p) IA(o), which
is the instance of s p o under the instance mapping A.
Hence, there is a subset of M(S) that is an instance

of G. Suppose H is a subset of M(S) and an instance
of G. Then, the instance lemma shows that H |= G,

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

and it is clear that M(S) |= H. Hence M(S) |= G and
S |= G. 

The (generalized) interpolation lemma not only
shows that the simple-entailment relation S |= G between finite sets S of finite (generalized) RDF graphs
and finite (generalized) RDF graphs G is decidable, but
also shows that this problem is in NP: guess an instance
function h : bl(G)  T (M(S)), and check that the instance Gh of G defined by means of this function is a
subset of M(S).
It is clear that this problem, the simple-entailment
relation S |= G between finite sets S of finite (general-
ized) RDF graphs and finite (generalized) RDF graphs
G, is in P if G is assumed to be ground, for in this
case it needs only to be checked that G is a subset of
M(S).

According to [8], the full simple-entailment problem (without restrictive assumptions) is NP-complete.
It seems that no complete proof has been published
yet. A proof is outlined in one sentence in [8]: This
can be shown by encoding the problem of detecting a
subgraph of an arbitrary directed graph as an RDF en-
tailment, using only blank nodes to represent the graph
(observation due to Jeremy Carroll). Note that it is not
trivial to work out the details of this proof sketch to obtain a complete proof, as the definition of instance (see
Definition 2.2) does not require the instance functions
h to be injective.

We give a full proof of the NP-completeness of simple entailment by reduction from another standard NPcomplete problem [4], the clique problem. Although
the NP-completeness results in this paper (see the following proposition and Propositions 4.14 and 5.14) are
stated for generalized RDF graphs, they clearly also
hold for RDF graphs because their proofs use only RDF
graphs.
Proposition 2.9. The simple-entailment relation S |=
G between finite sets S of finite generalized RDF graphs
and finite generalized RDF graphs G is NP-complete.

Proof. As shown above, this problem is in NP. We
prove NP-completeness using a reduction from the
clique problem. An instance of the clique problem consists of a finite undirected graph G = (V, E), where E
can be assumed to contain no loops {v, v}, and a positive integer k  |V|. The clique problem asks whether

and H

, H

and H

and H

G has a clique of size  k, i.e. whether there exists a
set of nodes W  V of size |W|  k, such that each
pair of distinct nodes v, w  W is linked by an edge in
G: {v, w}  E. An instance G = (V, E), k of the clique

problem is transformed to RDF graphs G
. Each

of the triples in G
has the same predicate p,

and all nodes of G
are blank nodes. The RDF
is formed by converting each pair {v, w}  E
graph G

into two triples v p w and w p v. The RDF graph H
consists of the triples v p w, where v and w are distinct elements of an arbitrary set of exactly k blank
nodes. It is clear that the transformation from G, k to

can be done in polynomial time. We need to

prove that the finite undirected graph without loops G
has a clique of size  k if and only if G
simply entails

. In view of the interpolation lemma, it is sufficient

to prove that the finite undirected graph without loops
G has a clique of size  k if and only if there is a
function h : bl(H
. The
only if direction is clear. Furthermore, if there is such

a function h, then h needs to be injective. Note that H
otherwise has distinct blank nodes v and w such that
h(v) = h(w). However, then it would follow that h(v)
p h(v)  G

, contradicting the assumption that G does
not contain loops. Since h is injective, G has a clique
of size  k. 

)  bl(G

) satisfying H

3. RDFS interpretations and D interpretations


As preparation for the proof of decidability of entailment for RDFS, possibly extended with datatypes,
this section defines D
interpretations, a generalization of RDFS interpretations extending the semantics of the datatype XMLLiteral to all datatypes
in a datatype map. We first consider the notion of
RDFS interpretation [8], which is defined here in a
slightly more refined way than in [8], in order to show
that RDFS interpretations are mathematically well
defined.

3.1. RDFS interpretations

The RDF and RDFS vocabulary, rdfV  rdfsV , is
a set of URI references listed in Table 1. Except for
the container membership properties rdf: i, we shall
often omit the prefixes rdf: and rdfs: from these
URIs.

rdf:Seq
rdf:Bag
rdf:Alt
rdf: 1
rdf: 2
. . .
rdf:value
rdfs:domain
rdfs:range
rdfs:Resource
rdfs:Literal

rdfs:Datatype
rdfs:Class
rdfs:subClassOf
rdfs:subPropertyOf
rdfs:member
rdfs:Container
rdfs:ContainerMembershipProperty
rdfs:comment
rdfs:seeAlso
rdfs:isDefinedBy
rdfs:label

Table 1
RDF and RDFS URIs [8]

rdf:type
rdf:Property
rdf:XMLLiteral
rdf:nil
rdf:List
rdf:Statement
rdf:subject
rdf:predicate
rdf:object
rdf:first
rdf:rest

Table 2
RDF axiomatic triples [8]

value type Property .
type type Property .
rdf: 1 type Property .
subject type Property .
predicate type Property . rdf: 2 type Property .
object type Property .
first type Property .
rest type Property .

. . .
nil type List .

Let V be a vocabulary and I a simple interpretation
of V  {type, Class} such that I(type)  PI, so
that EI(I(type)) is defined. In this case, the set CI of
classes of I is defined to be
CI = {a  RI : (a, I(Class))  EI(I(type))},
and the class extension function CEI : CI  P(RI) of
I is defined by
CEI(a) = {b RI : (b, a)  EI(I(type))}

(a  CI).

An rdfs-interpretation of a vocabulary V is a simple
interpretation I of V  rdfV  rdfsV that satisfies the
following conditions:
 I satisfies all triples in Tables 2 and 3. These triples
are together called the RDF and RDFS axiomatic
triples,
 a  PI
(a, I(Property)) 
 a  RI
(a, I(Resource)) 
 a  LVI
(a, I(Literal)) 

EI(I(type)),

EI(I(type)),

and only if

and only if

and only if

if

if

if

EI(I(type)),

and

ive on PI,
b  PI and EI(a)  EI(b),

(e, f )  EI(a), then e  CEI(b),6
(e, f )  EI(a), then f  CEI(b),

(a, b)  EI(I(domain)), a  PI , b  CI
(a, b)  EI(I(range)), a  PI , b  CI

 If
 If
and
 EI(I(subPropertyOf)) is transitive and reflex-
 If (a, b)  EI(I(subPropertyOf)), then a  PI ,
 If a  CI
then (a, I(Resource))  EI(I(sub-
ClassOf)),
 If (a, b)  EI(I(subClassOf)), then a  CI , b 
CI and CEI(a)  CEI(b),
 EI(I(subClassOf)) is transitive and reflexive on
CI,
 If
a  CEI(I(ContainerMembershipProp-
erty)), then (a, I(member))  EI(I(subProp-
ertyOf)),
 If a  CEI(I(Datatype)), then (a, I(Literal))
 EI(I(subClassOf)),
 If
l = (s, XMLLiteral)  V is a well-typed
and
 If l = (s, XMLLiteral)  V is an XML literal
then LI(l) / LVI and

then LI(l) = xml(l)  LVI
XML literal,
(LI(l), I(XMLLiteral))  EI(I(type)),

that
(LI(l), I(XMLLiteral)) / EI(I(type)).

is not well

typed,

Here the function xml assigns to each well-typed
XML literal its value [12]. Note that the first axiomatic
triple, type type Property, shows that
for
each rdfs-interpretation I, I(type)  PI, so that

6 This condition and the next condition have been reformulated
slightly in comparison with [8] to make clear that the definition uses
the functions EI and CEI inside their domains, as required. See the
explanation following the definition. Lemma 3.1 below shows that
exactly the same class of rdfs-interpretations is defined as in [8].

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

Table 3
RDFS axiomatic triples [8]

type domain Resource .
domain domain Property .
range domain Property .
subPropertyOf domain Property .
subClassOf domain Class .
subject domain Statement .
predicate domain Statement .
object domain Statement .
member domain Resource .
first domain List .
rest domain List .
seeAlso domain Resource .
isDefinedBy domain Resource .
comment domain Resource .
label domain Resource .
value domain Resource .
type range Class .
domain range Class .
range range Class .
subPropertyOf range Property .
subClassOf range Class .
subject range Resource .
predicate range Resource .
object range Resource .
member range Resource.

EI(I(type)), CI and CEI are defined, as used in
the statement of the remaining conditions. By using
the functions EI and CEI, the definition assumes,
implicitly, that certain values of I, such as I(domain)
and I(range), are in PI and that other values of I,
such as I(Datatype), are in CI. That this is allowed
is demonstrated in the next lemma. This lemma also
justifies some other conclusions that can be stated for
each rdfs-interpretation and that are used constantly
in the manipulation of rdfs-interpretations.

Lemma 3.1. rdfs-interpretations are well defined, in
the sense that each invocation of the functions EI and
CEI in the definition is allowed in view of the earlier
conditions. If I is an rdfs-interpretation of a vocabulary
V, then
 I(type), I(domain), I(range), I(subClassOf),
I(subPropertyOf) and I(member) are in PI,
 I(Property),
I(Class),
I(Literal),
I(XMLLiteral)
and I(ContainerMembershipProperty) are
in CI,

I(Resource),

I(Datatype),

first range Resource .
rest range List .
seeAlso range Resource .
isDefinedBy range Resource .
comment range Literal .
label range Literal .
value range Resource .
Alt subClassOf Container .
Bag subClassOf Container .
Seq subClassOf Container .
ContainerMembershipProperty

subClassOf Property .

isDefinedBy subPropertyOf seeAlso .
XMLLiteral type Datatype .
XMLLiteral subClassOf Literal .
Datatype subClassOf Class .
rdf: 1 type

ContainerMembershipProperty .

rdf: 1 domain Resource .
rdf: 1 range Resource .
rdf: 2 type

ContainerMembershipProperty .

rdf: 2 domain Resource .
rdf: 2 range Resource .
. . .

 PI  RI,
 PI = CEI(I(Property)),
 CI = CEI(I(Class)),
 RI = CEI(I(Resource)),
 LVI = CEI(I(Literal)),
 if
(a, b)  EI(I(type)),
then b  CI and a 
 if (a, b) is in EI(I(domain)), or EI(I(range)),
 if (a, b)  EI(I(domain)) and (e, f )  EI(a), then
 if (a, b)  EI(I(range)) and (e, f )  EI(a), then

CEI(b),
then a  PI and b  CI,
e  CEI(b),
f  CEI(b).

that

Suppose first

Proof.
is a simple interpretation of V  rdfV  rdfsV that
satisfies all
RDF and RDFS axiomatic triples. It has already
been noted that I(type)  PI.
If p = domain,
range, subClassOf or subPropertyOf,
then I satisfies an axiomatic triple v p w with
p in property position (see Table 3),
so that
I(domain), I(range), I(subClassOf) and I(sub-
PropertyOf) are in PI. If I satisfies the second

that

Suppose next

condition on subClassOf from the definition of
rdfs-interpretations, then since I satisfies the triples
ContainerMembershipProperty subClassOf Property, Datatype subClassOf Class
and XMLLiteral subClassOf Literal, it follows that I(Property), I(Class), I(Literal),
I(Datatype), I(XMLLiteral) and I(Container-
MembershipProperty) are in CI. This proves the
first statement and most of the first two conclusions
listed.
is an rdfs-interpretation
of V. The condition that a  PI
if and only if
(a, I(Property))  EI(I(type)) implies that PI 
RI. Since I(Property)  CI,
the first semantic
condition on subClassOf shows that (I(Prop-
erty), I(Resource))  EI(I(subClassOf)), so
that, by the second condition on subClassOf, it follows that I(Resource)  CI. It is now clear that PI =
CEI(I(Property)), CI = CEI(I(Class)), RI =
CEI(I(Resource)) and LVI = CEI(I(Literal)).
It follows that if (a, b)  EI(I(type)), then b  CI
and a  CEI(b): the semantic condition on I(range),
the axiomatic triple type range Class and (a, b) 
EI(I(type)) imply that b  CEI(I(Class)) = CI,
and then it also follows that a  CEI(b).

If

suppose

this is proved,

remains only to be shown that

It
if
in EI(I(domain)) or EI(I(range)),

(a, b)
is
then
a  PI and b  CI.
then the
two statements to be proved follow immedi-
last
that I satisfies the axiomatic
ately, and the fact
that
triple member domain Resource implies
I(member)  PI.
(a, b) 
EI(I(domain)). Since I satisfies the triple domain
domain Property, we get (I(domain), I(Prop-
erty))  EI(I(domain)). Combining this with
I(domain)  PI
the
semantic condition on I(domain) shows that a 
CEI(I(Property)) = PI. Since I
satisfies do-
(I(domain), I(Class)) 
main range Class,
I(domain)  PI
and
EI(I(range)).
I(Class)  CI, we get b  CEI(I(Class)) = CI.
The proof for I(range) follows in the same way. 

I(Property)  CI,

Since

that

So

and

3.2. Datatype maps and D


interpretations


Before defining D

interpretations, we summarize
some terminology and introduce some notation
relating to datatype maps [12,8]. Intuitively, a datatype

is characterized by certain strings (e.g. 11) and
corresponding values (e.g. the number 11). Formally,
a datatype d is defined by a non-empty set of strings
L(d), the lexical space, a non-empty set V (d), the
value space, and a function L2V (d) : L(d)  V (d),
the lexical-to-value mapping. A datatype map is a
partial function D from the set U of URI references to
the class of datatypes. Each datatype map is required
[8] to contain the pair (XMLLiteral, x), where
x is the built-in XML literal datatype, defined by

}, V (x) = XV ,
L(x) = {s : (s, XMLLiteral)  L
and L2V (x)(s) = xml((s, XMLLiteral)) for each

(s, XMLLiteral)  L
X. Here L
X is the set of
well-typed XML literals [12].

It is useful to add some further notation relating
to datatype maps. Suppose that a datatype map D
is given. The D-vocabulary is the domain dom(D)
of D, i.e. the set of URI references a  U such that
(a, d)  D for some datatype d. The range of D, i.e.
the set of datatypes d such that (a, d)  D for some
a  U, is denoted by ran(D). The set LD of D-literals
is the set of typed literals (s, a)  Lt with a  dom(D).
The set of all well-typed literals with type in D, i.e.
the set of all well-typed D-literals, will be denoted

by L
D:

= {(s, a)  Lt : a  dom(D), s  L(D(a))}.

The function valD is defined to map each well-typed
D-literal to its value:

valD : L

dran(D)

V (d),

valD((s, a)) = L2V (D(a))(s)

(a  dom(D), s  L(D(a))).

We assume that a few basic operations with respect
to datatype maps can be executed in polynomial time;
these operations include, in particular, the operation
determining whether a given D-literal is well typed,
the computation of values of well-typed D-literals, and
the operation determining whether the values of two
well-typed D-literals are equal.


Definition 3.2 (D
map, a D

interpretations). If D is a datatype
interpretation of a vocabulary V is defined to


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

be an rdfs-interpretation I of V  dom(D) that satisfies
the following conditions for each pair (a, d)  D:
 I(a) = d,
 I satisfies the following triples: a type Datatype
and a subClassOf Literal,
 if l = (s, a)  Lt  V and s  L(d), then LI(l) =
L2V (d)(s)  LVI and (LI(l), d)  EI(I(type)),
 if l = (s, a)  Lt  V and s / L(d), then LI(l) /
LVI and (LI(l), d) / EI(I(type)).


Definition 3.3
(D-axiomatic triples). If D is a
datatype map, the triples a type Datatype and a
subClassOf Literal appearing in the definition
interpretations are combined for a  dom(D) to
of D
form the D-axiomatic triples.


It should be noted that D
interpretations generalize the XMLLiteral-related conditions on rdfs-
interpretations.7 We conclude this section by showing that D-interpretations [8] form a special kind of
interpretation. See Section 1.7 for an example


showing that the D-semantics is stronger than the D
semantics.


(D-interpretations). If D is

Definition 3.4

datatype map, a D-interpretation of a vocabulary
V is an rdfs-interpretation I of V  dom(D) that
satisfies the following conditions for each pair
(a, d)  D:
 I(a) = d  CEI(I(Datatype)),
 CEI(d) = V (d)  LVI,
 if l = (s, a
)  Lt  V, I(a
LI(l) = L2V (d)(s),
 if l = (s, a
)  Lt  V, I(a

LI(l) / LVI.

) = d and s  L(d), then
) = d and s / L(d), then

Note that D-interpretations are well defined,
i.e.
that d  CI: since I(a) = d  CEI(I(Datatype)),
that

(d, I(Literal))  EI(I(subClassOf)),
so that

condition on rdfs-interpretations

shows


7 The definition of D

interpretations has been slightly simplified
with respect to the definition given in [10] in order to make this
correspondence with the XMLLiteral-related conditions exact. As
was already noted in [10] (Footnote 4), this change does not lead to
a change in entailments.

by another condition on rdfs-interpretations, d 
CI.

Lemma 3.5. If I is a D-interpretation of a vocabulary
V, then I is a D


interpretation of V.
(a, d)  D. Since
the

Let

satisfies

I(a) = d  CEI(
Proof.
I(Datatype)),
triple a type
Datatype. A condition on rdfs-interpretations shows
(d, I(Literal))  EI(I(subClassOf)),
that
so
that I satisfies the triple a subClassOf Literal
as well. If l = (s, a)  Lt  V and s  L(d),
then
LI(l) = L2V (d)(s)  V (d) = CEI(d), so that LI(l) 
LVI and (LI(l), d)  EI(I(type)).
l = (s, a) 
Lt  V and s / L(d), then LI(l) / LVI, so that (LI(l),
d) / EI(I(type)):
otherwise, LI(l)  CEI(d) 
LVI. 

If

4. RDFS entailment and D entailment

Using the semantic definitions of the preceding
section, this section defines RDFS entailment and

entailment and turns to completeness, decid-

ability and computational complexity. As was also
done in earlier versions of [8], we extract from
the completeness proof the notions of closure and
Herbrand interpretation, as well as a satisfaction
lemma (compare the proof of Lemma 2.8). Instead of
a full closure, a partial closure is used which can be
finite, making the closure notion of practical interest
and no longer just an abstraction in the proof. The
Herbrand construction of [8] needs to be refined to
deal with the finiteness of a partial closure and with
datatypes.


Definition 4.1 (D
D, a set S of generalized RDF graphs D
eralized RDF graph G if each D
satisfies S also satisfies G.

entailment). Given a datatype map
entails a geninterpretation I that


RDFS entailment coincides with D
entailment if the
datatype map D is assumed to consist of only the type
rdf:XMLLiteral. We use the notation
S |=s G

for D
RDFS entailment).

entailment (and also for the special case of


Since each D-interpretation is a D
interpretation

by Lemma 3.5, it is clear that if S D
entails G, then
S D-entails G. Here we extend the definition of D-
entailment [8] to generalized RDF graphs in the following way.

Definition 4.2 (D-entailment). Given a datatype map
D, a set S of generalized RDF graphs D-entails a generalized RDF graph G if each D-interpretation I that
satisfies S also satisfies G.


Example 4.3. Before turning to syntactic entailment
rules for D
entailment, we note that it is possible
to use the semantic definitions to give a direct proof
of the correctness of an entailment. To illustrate this
point, we prove that the example given in Section 1.5 is
indeed an RDFS entailment. Suppose that I is an rdfsinterpretation that satisfies the triples (1)(3), so that
there is a function A satisfying (IA(p), IA(b))  EI(
I(subPropertyOf)), (IA(b), IA(u))  EI(I(do-
main)), IA(p)  PI and (IA(v), IA(w))  EI(IA(p)).
Then a semantic condition on subPropertyOf
shows that IA(b)  PI and (IA(v), IA(w))  EI(IA(b)),
so that by Lemma 3.1 we have IA(v)  CEI(IA(u)).
showing
Therefore,
that I indeed satisfies the triple (4).

(IA(v), IA(u))  EI(I(type)),


Definition 4.4 (D
entailment rules). Given a datatype
map D, the D
entailment rules are defined in Table 4.
They consist of the 18 rules defined in [8] for RDFS,
with two differences involving rules rdf2 and rdfs7. Instead of rule rdfs7 we use rule rdfs7x to solve the problem that the standard set of entailment rules for RDFS
is incomplete (cf. Section 1.5). Rule rdfs7x differs only
from rule rdfs7 in that it can produce generalized RDF
triples with blank nodes in predicate position (see Section 2.2) when applied to ordinary RDF triples; rule
rdfs7x is the only D
entailment rule with this prop-
erty. While rule rdfs7 assumes that q  U, rule rdfs7x
assumes only that q  U  B (see Table 4). In order to
deal with datatypes, rule rdf2 is replaced by the more
general rule rdf2-D. The four D
entailment rules lg,
gl, rdf2-D and rdfs1 involve certain blank nodes bl,
called surrogate blank nodes, which we now discuss in
more detail. The first rule lg (literal generalization)


prescribes that if G contains v p l, where l is a literal,
then add v p bl to G, where bl is a blank node allocated
to l by this rule. Here allocated to means that the blank
node bl has been created by an application of rule lg on
the same literal l, or if there is no such blank node, in
which case it must be a new blank node which is not
yet in the graph. In rule rdfs1, bl is a blank node that
is allocated by rule lg to the plain literal l  Lp. In rule
rdf2-D, bl is a blank node that is allocated by rule lg to

the well-typed D-literal l  L
D. Rule rdf2-D is a direct
generalization of entailment rule rdf2 from [8], which
has the same effect only for well-typed XML literals

l  L
X. If D contains only the datatype rdf:XML-
Literal, then rule rdf2-D becomes exactly rule
rdf2.

Definition 4.5 (D-clash). The notion of XML clash
[8] is generalized in a straightforward way to any
datatype map: given a datatype map D, a D-clash is
a triple b type Literal, where b is a blank node
allocated by rule lg to an ill-typed D-literal.


Definition 4.6 (Partial and full RDFS and D
clo-
sures). We turn to a possibly finite refinement of
the notion of RDFS closure defined in [8]. Suppose
that G is a generalized RDF graph and D a datatype
map. In the definitions that follow,
the axiomatic
triples containing the URI references rdf: i (i.e. the
four triples rdf: i type Property, rdf: i type
ContainerMembershipProperty, rdf: i domain Resource and rdf: i range Resource)
are treated in a special way. Suppose that K is a nonempty subset of the positive integers {1, 2, . . .} chosen
in such a way that for each rdf: i  V (G) we have
i  K. The partial D
closure Gs,K of G is defined in
the following way. In the first step, all RDF and RDFS
axiomatic triples and D-axiomatic triples are added to
G, except for the axiomatic triples including rdf: i
such that i / K. In the next step, rule lg is applied to
each triple containing a literal in such a way that dis-
tinct, well-typed D-literals l with the same value are associated with the same surrogate blank node bl. Then,
rules rdf2-D and rdfs1 are applied to each triple containing a well-typed D-literal or a plain literal, respec-
tively. Finally, arbitrary derivations (see Definition 4.7)
are made using applications of the remaining D
en-
tailment rules until the graph is unchanged. In addition


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

Table 4


entailment rules

lg
gl
rdf1
rdf2-D
rdfs1
rdfs2

rdfs3

rdfs4a
rdfs4b
rdfs5

rdfs6
rdfs7x

rdfs8
rdfs9

rdfs10
rdfs11

rdfs12
rdfs13

If G contains

v p l
v p bl
v p w
v p l
v p l
p domain u
v p w
p range u
v p w
v p w
v p w
v subPropertyOf w
w subPropertyOf u
v type Property
p subPropertyOf q
v p w
v type Class
v subClassOf w
u type v
v type Class
v subClassOf w
w subClassOf u
v type ContainerMembershipProperty
v type Datatype

Where
l  L
l  L
l = (s, a)  L
l  Lp

w  U  B
w  U  B

q  U  B

Then add to G

v p bl
v p l
p type Property
bl type a
bl type Literal

v type u

w type u
v type Resource
w type Resource

v subPropertyOf u
v subPropertyOf v

v q w
v subClassOf Resource

u type w
v subClassOf v

v subClassOf u
v subPropertyOf member
v subClassOf Literal


to the partial D
closure Gs,K obtained in this way, the
closure Gs of G is defined by taking Gs = Gs,K,
full D
where K is the full set {1, 2, . . .}. If the datatype map
D consists of only the datatype rdf:XMLLiteral,
a partial and a full D
closure of a generalized RDF
graph G are called a partial and a full RDFS closure of
G, respectively.


As has already been mentioned, rule rdfs7x is the only
entailment rule that may produce generalized RDF

triples with blank nodes in predicate position when ap-

plied to ordinary RDF triples. In general, a partial D
closure is a generalized RDF graph, even if the given
graph is an ordinary RDF graph. With respect to a parclosure Gs,K and a literal l  V (G)  L,
tial (or full) D
the unique blank node allocated by rule lg to l is denoted
by bl.


Definition 4.7 (Derivation). Given a generalized RDF
graph G, a set of entailment rules  and a generalized RDF triple E, a derivation of E from G by means
of  is a finite sequence of generalized RDF triples

E1, . . . , En, such that En = E and such that for each
i  n, either Ei  G or Ei is obtained with a rule from
 applied to one or more triples Ej such that j < i.

Lemma 4.8. Let D be a finite datatype map. If G is

a finite generalized RDF graph, then each partial D

closure Gs,K of G is finite for K finite, and a partial D
closure of G can be computed in polynomial time.

Proof. The graph obtained from a finite generalized
RDF graph G in the first step of the definition of partial
closure is clearly finite if K is finite. Then, rule lg adds
only finitely many new triples, leading to a finite graph

containing G. In the remaining steps, no new names

, so it follows that there
or blank nodes are added to G
exist finite sets U0  U, B0  B and L0  L such that
Gs,K  U0  B0  U0  B0  U0  B0  L0.
(27)
Hence Gs,K is a finite graph.

closure can be computed in
polynomial time, choose a finite, non-empty set K 
{1, 2, . . .} such that i  K for each rdf: i  V (G).
Let g = |G|, d = |D| and k = |K|. We prove that Gs,K

To prove that a partial D

can be computed in time polynomial in g, d and k.
It will follow that a partial D
closure can be computed in time polynomial in g, since k can clearly be
taken to be 3g + 1, and d can be viewed as a con-
stant. The first step of the closure construction process adds 48 + 4k RDF and RDFS axiomatic triples
and 2d D-axiomatic triples. In the next step, rule lg
adds at most g triples. The computations needed for
these applications of rule lg can be done in polynomial time, since we assumed that the involved basic
operations connected to datatype maps (in particular,
the operation to determine whether two well-typed D-
literals have the same value) can be done in polynomial

time. It follows that the graph G
that results from these
steps has at most 2g + 2d + 4k + 48 triples, so that
the sets U0, B0 and L0 in (27) can be chosen to satisfy
|U0  B0  L0|  3(2g + 2d + 4k + 48). This shows
that |Gs,K|  27(2g + 2d + 4k + 48)3. Therefore, in
the remaining steps at most 27(2g + 2d + 4k + 48)3
rule applications can add a new triple to the partial closure graph under construction. For each of the entailment rules used it can be determined whether a successful rule application exists in at most linear or quadratic
time as a function of the size of the partial closure graph
under construction (cf. Table 4). For example, for rule
rdfs2 quadratic time is sufficient, while linear time is
sufficient for rule rdf1. It follows that Gs,K can be computed in time polynomial in g, d and k. 


Definition 4.9 (D
Herbrand interpretation). Suppose
that D is a datatype map. A D
Herbrand interpretation
of a generalized RDF graph G is a simple interpretation
SK(G) of V (Gs) defined in the following way, refining
the notion of rdfs-Herbrand interpretation defined in
[8]. K is a non-empty subset of {1, 2, . . .} chosen such
that for each rdf: i  V (G) we have i  K. RI is
defined as the union of five pairwise disjoint sets:
valD(V (Gs)  L
V (Gs)  (L  L
V (Gs)  (U  dom(D)),

D),

D),

ran(D),

bl(Gs).

The remainder of the definition makes use of the func-
tion
sur:RI  T (Gs,K)  (U  B)

D, then sur(valD(l)) = bl.

D), then sur(l) = bl.

(surrogate), which replaces the elements of RI with
non-literal terms in Gs,K. This function is defined as
follows:
 If l  V (Gs)  L
 If l  V (Gs)  (L  L
 If v  V (Gs)  (U  (dom(D){rdf: i : i /K})),
 If i / K, then sur(rdf: i) = rdf: n, where n 
 If (a, d)  D, then sur(d) = a.
 If b  bl(Gs), then sur(b) = b.

then sur(v) = v.

K is fixed.

Note that the sur function is well defined with re-

spect to well-typed D-literals l  L
D, since different
well-typed D-literals l  V (G) with the same value
valD(l) have the same surrogate blank node bl. The
other parts of SK(G) are defined in the following
way:
LVI = {x  RI : sur(x) type Literal  Gs,K},
PI = {x  RI : sur(x) type Property  Gs,K},
SI(v) = v
SI(a) = D(a)
LI(v) = v
LI(l) = valD(l)

(v  V (Gs)  U  dom(D)),
(a  V (Gs)  dom(D)),

(v  V (Gs)  Lt  L
D),

(l  V (Gs)  L
D),

EI(p) = {(s, o) : s  RI , o  RI ,

sur(s) sur(p) sur(o)  Gs,K}

(p  PI).
Note that for each v  V (Gs)  (U  {rdf: i : i /
K}), we have sur(I(v)) = v, and that sur(I(rdf: i)) =
rdf: n for i / K. Moreover, if l  V (Gs)  L, then
sur(I(l)) = bl.


Lemma 4.10 (D
satisfaction lemma). Let G be a
generalized RDF graph and D a datatype map. If the

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

including rdf: i are also satisfied. For example, the
triple rdf: i type Property is satisfied because
sur(I(rdf: i)) type Property = rdf: n type
Property  H.


partial D
clash, then SK(G) is a D
Gs,K.

closure Gs,K of G does not contain a D-
interpretation that satisfies


In the proof the D

Proof.
Herbrand interpretation
SK(G) of G is denoted by I and the partial D
closure
Gs,K of G by H. The first thing that needs to be proved
is that I is a simple interpretation, and for this we need
to show that V (Gs)  Lp  LVI. If l  V (Gs)  Lp,
then G contains a triple v p l. By rules lg and rdfs1, H
contains triples v p bl and bl type Literal. More-
over, sur(l) = bl, so that sur(l) type Literal  H
and l  LVI. It is clear that if v  V (Gs)  U then
SI(v)  RI  PI = RI, and that if v  V (Gs)  Lt then
LI(v)  RI.
Define the function A : bl(H)  RI by A(bl) =

valD(l) if l  L
D, A(bl) = l if l  L  L
D, and by
A(b) = b for other blank nodes b. Note that the function
A is well defined with respect to well-typed D-literals

l  L
D, since different well-typed D-literals l  V (G)
with the same surrogate blank node bl have the same
value valD(l). Note, moreover, that
sur(IA(v)) = v
(v  T (H)  L).
This can be seen easily in each of the following cases where v  T (H)  L : v  U, v  B allo-

D or in L  L
cated to a literal in L
D, other blank
nodes v.

(28)

We prove that IA satisfies H. Rule rdf1 shows
that for each triple v p w in H, H contains the triple
p type Property = sur (IA(p)) type Property,
so that IA(p)  PI. In order to prove that IA satisfies
v p w, i.e. that (IA(v), IA(w))  EI(IA(p)), it is sufficient to prove that v p sur(IA(w))  H, in view of
Eq. (28). Note that for each l  T (H)  L, we have
sur(IA(l)) = sur(I(l)) = bl. Combining this with Eq.
(28), it follows that if v p w  H, then v p sur (IA(w)) 
H, as desired: the only case that needs checking is
where w  L. In this case, rule lg shows that v p
bw  H, as required: there is no entailment rule that
can be applied with a literal in object position but that
cannot be applied with a blank node in object posi-
tion, so rule applications used to derive v p w can be
followed in parallel with other rule applications to provide a derivation of v p bw.
Note that I = SK(G) satisfies all axiomatic triples,
even though H may not contain all of them: if i / K then
sur(rdf: i) = rdf: n, so that the axiomatic triples

D,

If

then

prove

if

and

only

We

show that

a = rdf: i

next
that v  PI

condition
if

To
rdfs-
on
and only
sur(v) type Property  H if and only if

the
interpretations, note
if
(v, Property)  EI(type).
a  RI
if
(a, Resource)  EI(type). If (a, I(Resource)) 
EI(type), then clearly a  RI. Suppose that a  RI.
It is sufficient to prove that sur(a) type Resource 
If a = valD(l), l  V (Gs)  L
then sur(a) =
H.
triples v p l and v p bl.
and H contains
bl
Rule rdfs4b shows that sur(a) type Resource = bl
type Resource  H.
a = l  V (Gs)  (L 

then sur(l) = bl and H contains triples v p l
D),

and v p bl. Again, rule rdfs4b shows that sur(l)
type Resource = bl type Resource  H.
If
a  V (Gs)  (U  (dom(D)  {rdf: i : i / K})) or
if a  bl(Gs), then sur(a) = a and H contains, by rule
rdf1, a triple of the form a p v or v p a, so that by rule
rdfs4a or rdfs4b, we have sur(a) type Resource =
a type Resource  H.
If
and
i / K,
sur(rdf: i) type Resource =
rdf: n type Resource  H
of
view
rdf: n type Property  H and rule
rdfs4a.
If a = d  ran(D), then D contains a pair (a
, d) and
 type Datatype.
H contains the axiomatic triple a
Rule rdfs4a shows
the triple
sur(d) type Resource = a
To prove the next condition, note that a  LVI if
and only if sur(a) type Literal  H if and only if
(a, Literal)  EI(type).
(a, b)  EI(domain), a 
next
that
PI , b  CI and (e, f )  EI(a). We need to show
that e  CEI(b),
i.e. (e, b)  EI(type). We have
(e, f )  EI(a),
sur(a) domain sur(b)  H.
Since
sur(e) sur(a) sur(f )  H.
we
sur(e) type sur(b)  H,
Rule
so
on
I(range) = range is proved in the same way,
by means of rule rdfs3.
We now prove that EI(subPropertyOf)
is
transitive and reflexive on PI. For v  PI,
i.e.
sur(v) type Property  H, we need to prove
that
that
i.e.
sur(v) subPropertyOf sur(v)  H. This
follows

(v, v)  EI(subPropertyOf),

(e, b)  EI(type). The

 type Resource.

conclude
rdfs2 shows

that H contains

condition

that

that

Suppose

in

that

by rule rdfs6. If (v, w)  EI(subPropertyOf) and
(w, u)  EI(subPropertyOf), then it follows that
H contains the triples sur(v) subPropertyOf sur(w)
and sur(w) subPropertyOf sur(u), so that by rule
sur(v) subPropertyOf sur(u)  H and
rdfs5,
(v, u)  EI(subPropertyOf).
We prove that if (a, b)  EI(subPropertyOf),
then a, b  PI and EI(a)  EI(b). Note first
that
H contains the triple sur(a) subPropertyOf sur(b)
as well as the axiomatic triples subPropertyOf
domain Property and subPropertyOf range
Property. Rules rdfs2 and rdfs3 show that the triples
sur(a) type Property and sur(b) type Property
are in H, so that a  PI and b  PI. Suppose that
(e, f )  EI(a). Then we have sur(e) sur(a) sur(f ) 
H. Rule rdfs7x shows that sur(e) sur(b) sur(f )  H
so that (e, f )  EI(b). Note that the possibility is used
that rule rdfs7x may produce a generalized RDF triple
with a blank node in predicate position when applied
to ordinary RDF triples.
The next condition to be proved is that if a 
CI, then (a, Resource)  EI(subClassOf). Since
(a, Class)  EI(type), we get sur(a) type Class
 H. Rule rdfs8 shows that sur(a) subClassOf
Resource  H, as required.
To prove that if (a, b)  EI(subClassOf) then
a, b  CI and CEI(a)  CEI(b), note that H contains
the triple sur(a) subClassOf sur(b) as well as the
axiomatic
triples subClassOf domain Class
and subClassOf range Class. Rules
rdfs2
and rdfs3 show that the triples sur(a) type Class
and sur(b) type Class are in H,
(a,
Class), (b, Class)  EI(type)
a, b  CI.
Suppose that e  CEI(a). Then we have (e, a) 
EI(type), so that sur(e) type sur(a)  H. Rule
rdfs9 shows that sur(e) type sur(b)  H, so that
(e, b)  EI(type) and e  CEI(b).
We prove that EI(subClassOf) is transitive and
reflexive on CI. For v  CI,
(v, Class) 
EI(type), we need to prove that (v, v)  EI(sub-
ClassOf), i.e. that sur(v) subClassOf sur(v)  H.
Since sur(v) type Class  H, rule rdfs10 shows
(v, w) 
that
EI(subClassOf) and (w, u)  EI(subClassOf),
it follows that sur(v) subClassOf sur(w)  H and
sur(w) subClassOf sur(u)  H, so that by rule
rdfs11, sur(v) subClassOf sur(u)  H and (v, u) 
EI(subClassOf).

sur(v) subClassOf sur(v)  H.

so that

and

i.e.

If


then

In order to prove that if a  CEI(Container-
(a, member) 
MembershipProperty),
EI(subPropertyOf), note that H contains the triple
sur(a) type ContainerMembershipProperty.
Rule rdfs12 shows that H also contains the triple sur(a)
subPropertyOf member.
To prove the condition that if a  CEI(Datatype)
then (a, Literal)  EI(subClassOf), note that H
contains the triple sur(a) type Datatype, so that
rule rdfs13 shows that H also contains the triple sur(a)
subClassOf Literal.

We turn to the assumptions on D

interpretations
and thereby also the assumptions on XML literals.
Suppose that (a, d)  D. Suppose that
l = (s, a) 
Lt  V (Gs) and s  L(d). Then LI(l) = valD(l) =
L2V (d)(s) = A(bl). In order to prove that LI(l)  LVI,
we need to prove that sur(LI(l)) type Literal =
bl type Literal  H. Rule rdf2-D shows that
the triple bl type a is in H. With the axiomatic triple a subClassOf Literal and rule
rdfs9 it follows that bl type Literal  H. We
also have (LI(l), d) = (IA(bl), IA(a))  EI(I(type)),
since sur(IA(bl)) type sur(IA(a)) = bl type a  H.
Suppose that (a, d)  D and that l = (s, a)  V (Gs)
is a D-literal that is not well typed. Then A(bl) = l.
Suppose that (LI(l), d)  EI(I(type)); then bl type
a = sur(LI(l)) type sur(d)  H, so that with the
axiomatic triple a subClassOf Literal and rule
rdfs9 it follows that bl type Literal  H: H contains a D-clash. Suppose that LI(l)  LVI; then, again,
bl type Literal = sur(LI(l)) type Literal 
H : H contains a D-clash. 


Theorem 4.11 (D
entailment lemma). Let D be
a datatype map, S a set of generalized RDF graphs
and G a generalized RDF graph. Then, S |=s G if
and only if there is a generalized RDF graph H that
can be derived from M(S) combined with RDF and
RDFS axiomatic triples and D-axiomatic triples, by
entailment rules, and that either
application of the D
contains an instance of G as a subset or contains a
D-clash.


The preceding statement forms a direct extension,
to D
entailment and generalized RDF graphs, of the
RDFS entailment lemma [8]. The following statement
gives a more precise version of the D
entailment
lemma used to obtain decidability.


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115


Theorem 4.12 (D
entailment lemma (alternative
statement)). Let D be a datatype map, S a set of generalized RDF graphs and G a generalized RDF graph.
closure M(S)s,K of M(S) and
Let H be a partial D
suppose that i  K for each rdf: i  V (G). Then,
S |=s G if and only if either H contains an instance
of G as a subset or H contains a D-clash.


entailment lemma (both statements)). 
Proof (D
Let H = M(S)s,K be a partial D
closure of M(S)
such that i  K for each rdf: i  V (G), and let I be
the associated D
Herbrand interpretation SK(M(S)).
(It is assumed that the set B of blank nodes is large
enough to form the merge M(S) and the partial closure H.) If H does not contain a D-clash, then I is
a D
interpretation which satisfies H, so I satisfies
S. By S |=s G, I satisfies G. This shows, in particu-
lar, that V (G)  V (H). Choose A : bl(G)  RI such
that IA satisfies G. It follows that for each triple
s p o  G, EI(IA(p)) contains the pair (IA(s), IA(o)).
Therefore, for each triple s p o  G, H contains the
triple


if v  V (G)  U,

sur(IA(s)) sur(IA(p)) sur(IA(o)).
The assumption that i  K for each rdf: i  V (G)
then sur(I(v)) = v.
implies that
Moreover, if l  V (G)  L then sur(I(l)) = bl. Define the function h : bl(G)  T (H) to be h = sur  A,
and extend h to all of T (G) by h(v) = v for each
v  T (G)  bl(G). It follows that
 if s p o  G and o  L, then h(s) h(p) h(o)  H,
 if l  L and s p l  G, then h(s) h(p) bl  H.

In the second of these two cases it also follows that
h(s) h(p) h(l) = h(s) h(p) l  H, in view of V (G) 
V (H) and rule gl. Hence, there is a subset of H
that is an instance of G, with respect to the instance

mapping h. Suppose that the generalized RDF graph H can


be derived from M(S) combined with RDF and RDFS
and D-axiomatic triples by application of the D
entail-

ment rules. This holds, in particular, for any partial D
closure of M(S). Suppose in addition that H either contains an instance of G as a subset or contains a D-clash.
We prove that S |=s G. Let I be a D
interpretation that
satisfies M(S). By definition, I also satisfies all RDF

and RDFS axiomatic triples and D-axiomatic triples.
: bl(M(S))  RI such that IA

Choose the function A
satisfies M(S). Define the function A : bl(H)  RI by
A(b) = I(l) if b is a blank node allocated to the literal
l by rule lg, and by A(b) = A

(b) otherwise. We first
show that we can prove that S |=s G by showing that IA
satisfies H. If H contains an instance of G as a subset,
then I satisfies G by the generalized instance lemma
(Lemma 2.5), so that S |=s G. On the other hand, if
H contains a D-clash, then S cannot have a satisfy-
interpretation, so that, again, S |=s G. To prove
ing D
this, suppose that I is a D
interpretation that satisfies S. Then IA as defined above satisfies a D-clash b
type Literal, where the blank node b is allocated

by rule lg to an ill-typed literal l = (s, a)  LD  L
D of
type a  dom(D). Therefore, (LI(l), I(Literal)) =
(A(b), I(Literal))  EI(I(type)), so that LI(l) 
CEI(I(Literal)) = LVI. This contradicts the assumption that I is a D

interpretation.


We prove that IA satisfies H by induction on the
length of the derivations of the triples in H (see
Definition 4.7). It is clear that IA satisfies M(S) and
the RDF and RDFS and D-axiomatic triples. We next
consider all D

entailment rules in turn.


Suppose that the triple v p b is obtained from v p l
by means of rule lg, where b is allocated to l by rule
lg. Then, (IA(v), IA(b)) = (IA(v), IA(l))  EI(IA(p)),
so that IA satisfies v p b.
Rule gl derives the triple v p l from v p b, where
l  L and where the blank node b is allocated to l by
rule lg. Since IA satisfies v p b, we get (IA(v), IA(l)) =
(IA(v), IA(b))  EI(IA(p)).

Suppose that

the triple p type Property is
obtained from v p w by means of rule rdf1. Then
IA(p)  PI and, by a condition on rdfs-interpretations,
(IA(p), I(Property))  EI(IA(type)), so that IA
satisfies p type Property.

Suppose that the triple b type a is obtained by an
application of rule rdf2-D, given a triple v p l, where
l = (s, a) is a well-typed D-literal and where b is allocated to l by rule lg. Then l  V (S) and (IA(b), IA(a)) =
(LI(l), I(a))  EI(I(type)) by a condition on D
in-
terpretations, so that IA satisfies b type a.


Assume that

the triple b type Literal is
obtained from the
rdfs1,
where l
is a plain literal and where the blank
node b is allocated to l by rule lg. It follows
(IA(b), I(Literal)) = (I(l), I(Literal)) =
that

triple v p l by rule

(l, I(Literal))  EI(I(type)), where in the last
step we use l  LVI = CEI(I(Literal)). Hence IA
satisfies b type Literal.

Turning to rule rdfs2, suppose that

the triple
v type u is obtained from p domain u and
v p w. Then (IA(p), IA(u))  EI(I(domain)) and
(IA(v), IA(w))  EI(IA(p)), so that by Lemma 3.1,
IA(v)  CEI(IA(u)), or (IA(v), IA(u))EI(I(type)),
as required.

In order to prove the validity of rule rdfs3, supthe triple w type u is obtained from
pose that
p range u and v p w, where w  U  B. Then
(IA(p), IA(u))  EI(I(range)) and (IA(v), IA(w)) 
EI(IA(p)), so that by Lemma 3.1, IA(w)  CEI(IA(u)),
or (IA(w), IA(u))  EI(I(type)), as required.

that

For rule rdfs4a, we need to show that IA satisfies v type Resource if it satisfies v p w. Since
IA(v)  RI and RI = CEI(I(Resource)),
it fol-
(IA(v), I(Resource))  EI(I(type)).
lows
For rule rdfs4b, we need to show that IA satisfies w type Resource if
satisfies v p w
it
if w  U  B. Again,
IA(w)  RI
and
since
and RI = CEI(I(Resource)),
that
follows
(IA(w), I(Resource))  EI(I(type)).

it

it

For rule rdfs5, we need to show that IA satisfies v subPropertyOf u if
satisfies v
subPropertyOf w and w subPropertyOf
(IA(v), IA(w))  EI(I(subProperty-
u. We get
(IA(w), IA(u))  EI(I(subProperty-
Of))
and
Of)), so that by a semantic condition on subPropertyOf we get IA(v), IA(w), IA(u)  PI. Since
EI(I(subPropertyOf)) is transitive on PI, it follows that (IA(v), IA(u))  EI(I(subPropertyOf)).
Rule rdfs6 derives the triple v subPropertyOf
v from v type Property. Since IA satisfies v
type Property, we have (IA(v), I(Property)) 
EI(I(type)). Hence IA(v)  PI. Since EI(I(sub-
PropertyOf)) is reflexive on PI, it follows that
(IA(v), IA(v))  EI(I(subPropertyOf)).
Rule rdfs7x derives the triple v q w from p
subPropertyOf q and v p w if q  U  B.
We have (IA(p), IA(q))  EI(I(subPropertyOf))
and (IA(v), IA(w))  EI(IA(p)). The second seman-
that
tic condition on subPropertyOf shows
(IA(v), IA(w))  EI(IA(q)).

Rule rdfs8 derives the triple v subClassOf
Resource from v type Class. Since (IA(v),
I(Class))  EI(I(type)), it follows that IA(v) 

CEI(I(Class)) = CI, so that (IA(v), I(Resource))
 EI(I(subClassOf)).

Rule rdfs9 derives the triple u type w from v
subClassOf w and u type v. We have (IA(v),
IA(w))  EI(I(subClassOf)),
IA(v) 
CI , IA(w)  CI and CEI(IA(v))  CEI(IA(w)). More-
over, we have (IA(u), IA(v))  EI(I(type)), so that
IA(u)  CEI(IA(v)) and hence IA(u)  CEI(IA(w))
and (IA(u), IA(w))  EI(I(type)).

so that

Rule rdfs10 is handled in the same way as rule rdfs6.
Rule rdfs11 is handled in the same way as rule rdfs5.
Rule rdfs12 derives the triple v subPropertyOf
member from the
triple v type Container-
MembershipProperty. It is clear that IA(v) 
CEI(I(ContainerMembershipProperty)), so
that the semantic condition on Container MembershipProperty shows that (IA(v), I(member)) 
EI(I(subPropertyOf)).

Finally, rule rdfs13 derives the triple v subfrom v type Datatype.
ClassOf Literal
Since (IA(v), IA(Datatype))  EI(I(type)), we
IA(v)  CEI(I(Datatype)). Hence
(IA(v),
get
I(Literal))  EI(I(subClassOf)). 
Corollary 4.13. Let D be a finite datatype map. The
entailment relation S |=s G between finite sets S of

finite generalized RDF graphs and finite generalized
RDF graphs G is decidable. This problem is in NP,
and in P if G is ground.


In view of Theorem 4.12, the problem S |=s G
Proof.
closure H =
can be decided by taking a partial D
M(S)s,K of M(S) such that K is finite and i  K for each
rdf: i  V (G), and by checking whether H contains
a D-clash or whether H contains an instance of G as
a subset. By Lemma 4.8, H can be computed in time
polynomial in |M(S)| + |G|. The last statement now
follows as in the case of simple entailment (see the
remarks following the proof of Lemma 2.8). 

We shall now complement the above proof of decidability and NP-membership with a proof of NPcompleteness of D
entailment (and RDFS entail-
ment).


Proposition 4.14. Let D be a finite datatype map. The
entailment relation S |=s G between finite sets S of

finite generalized RDF graphs and finite generalized
RDF graphs G is NP-complete.

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

and H

, H

. The RDF graph H

is taken to be a partial D

)  bl(G

) satisfying H

Proof. Membership of NP has already been shown
above. As in the proof of Proposition 2.9, we prove
NP-completeness using a reduction from the clique
problem. An instance G = (V, E), k of the clique problem (see the proof of Proposition 2.9) is transformed
to RDF graphs G
con-
sists, again, of the triples v p w, where p is a fixed
property and where v and w are distinct elements of
an arbitrary set of exactly k blank nodes. It is now
also assumed that the URI reference p is not in the
RDF and RDFS vocabulary or in the D-vocabulary.

The RDF graph G
is formed in two steps. In the first
step, each pair {v, w}  E is converted into two triples
v p w and w p v, where v and w are viewed as blank
nodes. This leads to an RDF graph G
. In the second

step, the graph G
closure

. In view of Lemma 4.8, is clear that the transof G
formation from G = (V, E), k to G

can be done in
polynomial time. We need to prove that G has a clique
of size  k if and only if G
 |=s H
. It follows in the
same way as in the proof of Proposition 2.9 that G has
a clique of size  k if and only if there is a function h :

bl(H
. We still have to
)  bl(G

prove that there is a function h : bl(H
) sat-
 |=s H
isfying H
. If there is

a function h : bl(H

then the interpolation lemma (Lemma 2.4) shows that
 |= H

. To

 |=s H

prove the converse implication, suppose that G

It is clear that G

closure of G
so the D
entailment lemma (Theorem 4.12) shows
that there is a function h : bl(H
) satisfying

. The proof can be concluded by showing that

none of the triples in G
has p as predicate, for

then it follows that H
. The graph G
has a simhas the same
ple structure: each of the triples in G
predicate p, which is not in the RDF and RDFS vocabulary or in the D-vocabulary, and all nodes in G
are
blank nodes. By considering the axiomatic triples and
entailment rules it is not difficult to see that G
contains
only three further triples containing p: rules rdf1, rdfs4a
and rdfs6 produce the triples p type Property,
p type Resource and p subPropertyOf p, re-
spectively. (Similarly, each blank node x in G
ap-

pears in exactly one new triple in G
: rule rdfs4a
or rdfs4b generates the triple x type Resource.)
Therefore, none of the triples in G
has p as
predicate. 

if and only if G
)  bl(G

)  nd(G

itself is a partial D

, so that by G

) satisfying H

 |=s H

we get G

We conclude this section with a theorem summarizing a point that has been left implicit so far. A set S of
consistent if there
generalized RDF graphs is called D
is a D


interpretation that satisfies S.


Theorem 4.15. Let D be a datatype map, S a set of
generalized RDF graphs and H a partial D
closure
of M(S). Then, S is D
consistent if and only if H does
not contain a D-clash. If D is finite, the problem to
determine whether a finite set of finite generalized RDF
graphs is D

consistent is in P.


Proof. The first of these two statements follows by
Lemma 4.10 and the proof of Theorem 4.12 (). The
second statement follows from the first statement and
Lemma 4.8. 

5. pD interpretations and pD entailment


In this section, we extend the above results on RDFS
entailment and D
entailment to apply to a subset of
the OWL vocabulary (see Table 5). We do not obtain the full power of the iff-semantics (cf. Section 1.2) of OWL DL and OWL Full [14]. We consider a weaker semantics, called the pD
semantics,
which extends RDFS and which is defined in a way
analogous to the if-semantics of RDFS. This leads
to simple and useful entailment rules, which can be
used to extend RDF reasoners. This weaker semantics,
which is computationally less complex, seems to be
sufficient for many applications of this subset of the
OWL vocabulary (cf. Section 1.8). In the treatment of
entailment we follow the same pattern as in the
pD
entailment. The definitions
preceding section for D
given in this section are refinements of the definitions
given in the preceding sections, incorporating semantic conditions for the subset of the OWL vocabulary
considered.


5.1. The pD


semantics and OWL


Before turning to the formal definition of pD
interpretations, we explain the differences between
the pD
semantics and the semantics of OWL
[14]. For rdfs:subClassOf,
(DL and Full)
rdfs:subPropertyOf,
and

rdfs:range,
semantics adopts the if
conditions of
than

the pD
the RDFS semantics,

rdfs:domain

rather

Table 5
OWL URIs used in the pD


semantics

owl:FunctionalProperty
owl:InverseFunctional-

owl:Restriction
owl:onProperty

Property

owl:SymmetricProperty
owl:TransitiveProperty
owl:sameAs
owl:inverseOf
owl:equivalentClass
owl:equivalentProperty

owl:hasValue
owl:someValuesFrom
owl:allValuesFrom
owl:differentFrom
owl:disjointWith


for

the pD

iff conditions

(see
OWLs
these constructs
like
Section 1.2 for rdfs:subClassOf). Just
RDFS,
semantics adds to these if conditions the conditions that rdfs:subClassOf
and rdfs:subPropertyOf are reflexive and
transitive; the latter conditions are implied by OWLs
iff conditions. For owl:FunctionalProperty,
owl:InverseFunctionalProperty,
owl:
SymmetricProperty and owl:Transitive-
Property, the well-known corresponding standard
mathematical definitions (characterizing when binary
relations are functional, inverse-functional, etc.) are
used in if conditions, whereas OWL uses these standard mathematical definitions to form iff conditions.
In particular, the pD
semantics requires that if a
property is functional, then two values of the property
for the same subject are always owl:sameAs-related,
while OWL also requires the opposite condition. (As
we shall see, unlike OWL, the pD
semantics does
not always interpret owl:sameAs as equality.)
The pD
semantics requires that if two classes are
owl:disjointWith-related, then their extensions
are disjoint, while the OWL semantics also requires
the opposite condition. Moreover, the pD
semantics
requires that if two properties are owl:inverseOf-
related, then their extensions are each others inverse
as binary relations, while OWL also requires the
opposite condition. The pD
semantics requires that
two classes are equivalent if and only if they are both
subclasses of each other, while OWL requires that two
classes are equivalent if and only if their extensions
are equal; in combination with the pD
semantics for
rdfs:subClassOf, it is not difficult to see that
the pD
condition for owl:equivalentClass
is somewhat stronger than the only-if part of OWLs

condition for owl:equivalentClass. The pD


semantics treats owl:equivalentProperty in a
similar way to owl:equivalentClass.


While OWL DL and OWL Full always interpret
owl:sameAs as equality, the pD
semantics interprets owl:sameAs in a weaker way, as an equivalence
relation. Several essential aspects of OWLs interpretation of sameAs are also obtained under the pD
se-
mantics by adding further conditions. In particular, the
semantics requires that if two classes or properties
pD
are sameAs-related to each other, then these classes
or properties have the same extension. Moreover, if the
extension of a certain property includes a certain pair
of resources, then this extension also contains any pair
of resources obtained from the first pair of resources
by substituting either of its two entries by another resource to which it is sameAs-related. The pD
se-
mantics requires that the extensions of owl:sameAs
and owl:differentFrom are disjoint, while OWL
imposes the stronger condition that the extension of
owl:differentFrom is the not-equal relation.


The if conditions of the pD

semantics share a common pattern, which can be described as follows: if
certain instances satisfy certain conditions involving
certain classes and/or properties, and if there is information about these classes and/or properties phrased
in terms of the RDFS and/or OWL vocabulary, then
these instances are required to satisfy certain other con-
ditions. For the if conditions of the pD
semantics
just discussed, OWL also imposes the opposite con-
ditions, thus enabling conclusions to be drawn about
entire classes and properties. With respect to the subset
of the OWL vocabulary considered, the pD
seman-
tics is intended to represent a reasonable interpretation
that is useful for drawing conclusions about instances
in the presence of an ontology (compare the examples discussed in Section 1.8), and that leads to simple entailment rules and a relatively low computational
complexity.


For owl:hasValue, owl:someValuesFrom
and owl:allValuesFrom, the OWL semantics imposes certain if conditions which state equality of two
sets in their then parts. These conditions can also be
written as iff conditions. For example, OWL requires
that a given resource belongs to a hasValue restriction with respect to a property and another resource if
and only if this property has this other resource as value
for the given resource. The pD
semantics includes this
iff condition for hasValue. For someValuesFrom


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115


and allValuesFrom, the pD
semantics includes
half of OWLs iff conditions. The condition of the
semantics for allValuesFrom requires that if
pD
a resource belongs to an allValuesFrom restriction with respect to a certain class and a certain prop-
erty, then each value of this property for this resource
belongs to this class; OWL also requires the opposite
condition. Note that the direction of the if condition of
the pD
semantics for allValuesFrom is similar to
the direction of the if conditions of the pD
seman-
tics for subClassOf, FunctionalProperty,
etc.


The following if condition for someValuesFrom
is part of OWL and is analogous to the if condition of
the pD
semantics for allValuesFrom just men-
tioned: if a resource belongs to a someValuesFrom
restriction with respect to a certain class and a certain
property, then the resource is related with respect to
this property to some other resource, while this other
resource belongs to the given class. However, unlike
all the if conditions of the pD
semantics (whose
then parts make definite statements about instances
already considered in the if parts), this condition for
someValuesFrom has an existential quantification
in its then part. Although this existential quantification
can be handled with an entailment rule that introduces
a new blank node, the proofs of Lemmas 4.8 and 5.7
do not extend to such rules. Therefore, we define a
separate semantic extension of pD
entailment, called
sv entailment, which includes this condition for
pD
someValuesFrom. In Section 6 we show that the
completeness result for pD
entailment obtained in
this section can be extended to pD
sv entailment.
The pD
semantics does include the other half of
OWLs iff condition for someValuesFrom: for
a someValuesFrom restriction with respect to a
certain class and a certain property, and for a resource,
the pD
semantics requires that if there is a value for
this property belonging to the class, then this resource
belongs to the someValuesFrom restriction. As
has already been mentioned in Section 1.8,
the
semantics for someValuesFrom may not be
pD
sufficient for various applications. See Section 1.8 for
a discussion of an alternative, more controlled way
of introducing new blank nodes in connection with
someValuesFrom, which may be useful in some
situations in combination with the use of a reasoner
that supports only the pD

semantics.


5.2. pD

interpretations


 If

P-axiomatic triples,

Definition 5.1 (pD
interpretations). The P-voca-
bulary, denoted by pV , is a set of URI references from
the OWL vocabulary [14] listed in Table 5. Let D be
a datatype map. A pD
interpretation of a vocabulary
interpretation I of V  pV that satisfies the
V is a D
following conditions:
 I satisfies the triples in Table 6, which are called the
 If p  CEI(I(FunctionalProperty))

and
then (b, c)  EI(I(same-
(a, c)  EI(p),
(a, b),
As)),
p  CEI(I(InverseFunctionalProp-
erty)) and (a, c), (b, c)  EI(p),
then (a, b) 
EI(I(sameAs)),
 If p  CEI(I(SymmetricProperty)) and (a, b)
 EI(p), then (b, a)  EI(p),
 If p  CEI(I(TransitiveProperty))
and
(a, b), (b, c)  EI(p), then (a, c)  EI(p),
 EI(I(sameAs)) is an equivalence relation on RI,
 If a  CI
and (a, b)  EI(I(sameAs)),
then
 If p  PI
and (p, q)  EI(I(sameAs)),
 If

then
)  EI(I(same-

 If (p, q)  EI(I(inverseOf)) then (a, b)  EI(p)
 (a, b)  EI(I(equivalentClass))

(a, b)  EI(I(subClassOf)),
(p, q)  EI(I(subPropertyOf)),
p  PI , (a, b)  EI(p), (a, a

)  EI(I(sameAs)),

As)) and (b, b
 EI(p),
if and only if (b, a)  EI(q),

(a, b)  EI(I(hasValue))

if
(a, b)  EI(I(subClassOf))

only
(b, a)  EI(I(subClassOf)),

and
and
 (a, b)  EI(I(equivalentProperty)) if and
(a, b)  EI(I(subPropertyOf)) and
only if
(b, a)  EI(I(subPropertyOf)),
(a, p) 
EI(I(onProperty)), then x  CEI(a) if and only
if (x, b)  EI(p),
(a, p) 
EI(I(onProperty)), (x, y)  EI(p)

and
CEI(b), then x  CEI(a),
 If (a, b)  EI(I(allValuesFrom)), (a, p)  EI(
I(onProperty)), x  CEI(a) and (x, y)  EI(p),
then y  CEI(b),
 EI(I(differentFrom))  EI(I(sameAs)) =

(a, b)  EI(I(someValuesFrom)),

 If

 If

then (a

and

, b

if

Table 6
P-axiomatic triples

FunctionalProperty subClassOf Property .
InverseFunctionalProperty subClassOf Property.
SymmetricProperty subClassOf Property .
TransitiveProperty subClassOf Property .
sameAs type Property .
inverseOf type Property .
inverseOf domain Property .
inverseOf range Property .
equivalentClass type Property .
equivalentProperty type Property .
equivalentClass domain Class .
equivalentClass range Class .
equivalentProperty domain Property .
equivalentProperty range Property .
Restriction subClassOf Class .
onProperty domain Restriction .
onProperty range Property .
hasValue domain Restriction .
someValuesFrom domain Restriction .
someValuesFrom range Class .
allValuesFrom domain Restriction .
allValuesFrom range Class .
differentFrom type Property .
disjointWith domain Class .
disjointWith range Class .


 If (a, b)  EI(I(disjointWith)), then CEI(a) 

CEI(b) = .
Lemma 5.2. pD
interpretations are well defined, in
the sense that each invocation of the functions EI and
CEI in the definition is allowed in view of the earlier
conditions. If I is a pD
interpretation of a vocabulary
V, then
 I(sameAs), I(inverseOf), I(equivalent-
Class), I(equivalentProperty), I(on-
Property), I(hasValue), I(someValues-
From), I(allValuesFrom), I(different-
From) and I(disjointWith) are in PI,
 I(FunctionalProperty), I(InverseFunc-

tionalProperty), I(SymmetricProp-
erty), I(TransitiveProperty) and I(Re-
striction) are in CI.


Proof. Suppose that I is a D
interpretation of
V  pV that satisfies the P-axiomatic triples. Since
I satisfies the triples sameAs type Property,
inverseOf type Property,
equivalent-

the

Since

I(equivalentClass),

Class type Property, equivalentProperty type Property and differentFrom type
Property, it follows that I(sameAs), I(inverse-
Of),
I(equivalent-
Property), I(differentFrom) are all in CEI(
I(Property)) = PI.
satisfies

triple Functional-
seman-
Property subClassOf Property,
tic condition on subClassOf shows that we have
I(FunctionalProperty)  CI and CEI(I(Func-
tionalProperty))  CEI(I(Property)) = PI.
The cases of InverseFunctionalProperty,
SymmetricProperty and Transitive Property are handled in the same way.
Since I satisfies Restriction subClassOf
Class, we get I(Restriction)  CI. Since I
satisfies
onProperty domain Restriction,
we have (I(onProperty), I(Restriction)) 
EI(I(domain)), so that by Lemma 3.1, I(onProp-
erty)  PI.
in the same way that
It
I(hasValue), I(someValuesFrom), I(allVal-
uesFrom)  PI.
If (p, q)  EI(I(inverseOf)), then since I satisfies inverseOf domain Property and inverseOf range Property, it follows by Lemma
3.1 that p, q  CEI(I(Property)) = PI.
In order to show that if (a, b)  EI(I(hasValue))
axiomatic
triple
then
hasValue domain Restriction shows
that
(I(hasValue), I(Restriction))  EI(I(do-
main)) so that again by Lemma 3.1, a  CEI(
I(Restriction)). The axiomatic triple Restriction subClassOf Class shows
(I(Re-
striction), I(Class))  EI(I(subClassOf)),
so that a  CEI(I(Class)) = CI.
In a similar
way, it follows that if (a, b)  EI(I(someValues-
From)) or (a, b)  EI(I(allValuesFrom)), then
a  CI.
(a, p)  EI(I(on-
Property)) then p  PI, note that by the axtriple onProperty range Property
iomatic
(I(onProperty), I(Property)) 
we
EI(I(range)), so that by Lemma 3.1, p  CEI(
I(Property)) = PI.
(a, b)  EI(I(some-
ValuesFrom))
the axiomatic triple someValuesFrom range Class
(I(someValuesFrom), I(Class)) 
shows

then b  CI, note that

to show that

a  CI,

In order

to show that

if

In order

note

that

the

have

that

follows

that

if

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

EI(I(range)). It follows in the same way that if
(a, b)  EI(I(allValuesFrom)), then b  CI.

Since I satisfies disjointWith domain Class
and disjointWith range Class,
it
follows
that I(disjointWith)  PI and that
if (a, b) 
EI(I(disjointWith)) then a, b  CI. 


5.3. pD

entailment


Definition 5.3 (pD
entailment). Given a datatype
map D, a set S of generalized RDF graphs pD
entails
a generalized RDF graph G if each pD
interpretation
I that satisfies S also satisfies G. In this case, we write
S |=p G.


It is clear that each OWL Full interpretation [14] is
interpretation, so that if S |=p G, then S OWL
a pD
Full entails G. Here we extend the definition of OWL
Full entailment [8] to generalized RDF graphs in the
following way.

Definition 5.4
(OWL Full entailment). Given a
datatype map D, a set S of generalized RDF graphs
OWL Full entails a generalized RDF graph G if each
OWL Full interpretation I that satisfies S also satisfies
G.

Definition 5.5 (P-entailment rules). See Table 7 for
the definition of the P-entailment rules. Note that rules
rdfp8ax, rdfp8bx and rdfp14bx are the only rules in
this table that can produce generalized RDF triples
with blank nodes in predicate position (see Section 2.2)
when applied to ordinary RDF triples.


Definition 5.6 (Partial and full pD
closures). Suppose that G is a generalized RDF graph and D a
datatype map. The partial pD
closure Gp,K of G,
closure Gp of G, are defined in a
and the full pD
way similar to the definition of the partial and full
closures Gs,K and Gs of G (see Definition 4.6).

The only differences are in the first and last steps. In
the first step, the P-axiomatic triples are also added
the P-entailment rules are
to G. In the last step,
used as well. Just like a partial D
closure, a partial pD
closure is, in general, a generalized RDF
graph, even if the given graph is an ordinary RDF
graph.


Lemma 5.7. Let D be a finite datatype map. If G is a

finite generalized RDF graph, then each partial pD
closure Gp,K of G is finite for K finite, and a partial
closure of G can be computed in polynomial time.
pD


Proof. This is proved as for partial D
closures (see
Lemma 4.8), adding the P-axiomatic triples in the
first step. For the last part of the proof, note that for
rules rdfp1, rdfp2, rdfp4, rdfp11, rdfp14a and rdfp14bx
the existence of a successful rule application can be
detected in time O(n3), where n is the size of the
partial closure graph under construction. Since it requires two triples to define a someValuesFrom
or allValuesFrom restriction, the complexity is
higher for rules rdfp15 and rdfp16: these rules can be
handled in time O(n4). The other P-entailment rules
can be handled in linear or quadratic time, just like the

entailment rules. 


Definition 5.8 (pD
Herbrand interpretation). Given
a datatype map D and a generalized RDF graph
G, a pD
Herbrand interpretation PK(G) is defined in
a similar way to a D
Herbrand interpretation SK(G)
(see Definition 4.9). The only differences are that Gs
is replaced by Gp and Gs,K is replaced by Gp,K.


Definition 5.9
(P-clash). In addition to D-clashes
semantics also leads
(see Definition 4.5), the pD
in connection with
to possible
inconsistencies
differentFrom and disjointWith: a P-clash
is either a combination of two triples of the form v
differentFrom w, v sameAs w, or a combination
of three triples of the form v disjointWith w, u
type v, u type w.


Lemma 5.10 (pD
satisfaction lemma). Let G be a
generalized RDF graph and D a datatype map. If the
partial pD
closure Gp,K of G does not contain a P-
clash or a D-clash, then PK(G) is a pD
interpretation
that satisfies Gp,K.
Proof.
Herbrand interpretation
PK(G) of G is denoted by I and the partial pD
closure
Gp,K of G by H. Several additions need to be made to
the proof of the D
satisfaction lemma (see Lemma
4.10). It is clear that I satisfies the P-axiomatic triples.
if p  CEI(
(a, b), (a, c) 
then (b, c)  EI(I(sameAs)). We have

I(FunctionalProperty))
EI(p),

condition that
and

In this proof the pD

We prove

the

Table 7
P-entailment rules

If G contains

Where

Then add to G

rdfp1

rdfp2

rdfp3

rdfp4

rdfp5a
rdfp5b
rdfp6
rdfp7

rdfp8ax

rdfp8bx

rdfp9

rdfp10

rdfp11

rdfp12a
rdfp12b
rdfp12c

rdfp13a
rdfp13b
rdfp13c

rdfp14a

rdfp14bx

rdfp15

rdfp16

p type FunctionalProperty
u p v
u p w
p type InverseFunctionalProperty
u p w
v p w
p type SymmetricProperty
v p w
p type TransitiveProperty
u p v
v p w
v p w
v p w
v sameAs w
u sameAs v
v sameAs w
p inverseOf q
v p w
p inverseOf q
v q w
v type Class
v sameAs w
p type Property
p sameAs q
u p v

u sameAs u

v sameAs v
v equivalentClass w
v equivalentClass w
v subClassOf w
w subClassOf v
v equivalentProperty w
v equivalentProperty w
v subPropertyOf w
w subPropertyOf v
v hasValue w
v onProperty p
u p w
v hasValue w
v onProperty p
u type v
v someValuesFrom w
v onProperty p
u p x
x type w
v allValuesFrom w
v onProperty p
u type v
u p x

v  U  B

w  U  B

w  U  B
w  U  B

w, q  U  B
w  U  B

  U  B
w  U  B

w  U  B

p  U  B

v sameAs w

u sameAs v

w p v

u p w
v sameAs v
w sameAs w
w sameAs v

u sameAs w

w q v

w p v

v subClassOf w

p subPropertyOf q

p v

v subClassOf w
w subClassOf v

v equivalentClass w
v subPropertyOf w
w subPropertyOf v

v equivalentProperty w

u type v

u p w

u type v

x  U  B

x type w

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

In order to prove that

(p, FunctionalProperty)  EI(type), so that
H contains sur(p) type FunctionalProperty.
We also have sur(a) sur(p) sur(b)  H and sur(a)
sur(p) sur(c)  H, so that by rule rdfp1, sur(b)
sameAs sur(c)  H, as desired. It can be proved
if p  CEI(I(Inverse-
in a similar way that
(a, c), (b, c) 
FunctionalProperty))
and
EI(p), then (a, b)  EI(I(sameAs)).
if p  CEI(I(Symmet-
ricProperty)) and (a, b)  EI(p) then (b, a) 
EI(p), suppose that (p, SymmetricProperty) 
sur(p) type Symmetric-
EI(type),
that
Property  H. We
can
that
sur(a) sur(p) sur(b)  H,
so that by rule rdfp3,
sur(b) sur(p) sur(a)  H.
if p  CEI(I(Transitive-
We prove
Property)) and (a, b), (b, c)  EI(p), then (a, c)
 EI(p). We
(p, TransitiveProp-
erty)  EI(type), so sur(p) type TransitiveProperty  H. H also contains the triples sur(a)
sur(p) sur(b) and sur(b) sur(p) sur(c). By rule rdfp4,
sur(a) sur(p) sur(c)  H, as desired.

conclude

have

also

that

so

that

that

To prove

the five parts of

the definition of RI

l  V (Gp)  L

l  V (Gp)  (L  L

reflexivity of EI(I(sameAs)) on
(see
RI,
considered sepaDefinition 4.9) need to be

rately. Suppose first
D. Then
by rules lg and rdfp5b, H contains the triple bl
sameAs bl = sur (valD(l)) sameAs sur(valD(l)),
so
(valD(l), valD(l))  EI(sameAs), as desired.
that

D). Again
Suppose next
by rules lg and rdfp5b, H contains the triple
bl sameAs bl = sur(l) sameAs sur(l), so that (l, l) 
that
EI(I(sameAs)), as desired. Suppose next
a  V (Gp)  (U  (dom(D)  {rdf: i : i / K}))
or a  bl(Gp). Then, sur(a) = a and H contains,
by rule rdf1, a triple of the form a p v or v p a,
so that by rules rdfp5a and rdfp5b it
follows
that H contains the triple a sameAs a = sur(a)
sameAs sur(a), so that (a, a)  EI(I(sameAs)). If
i / K, then sur(rdf: i) = rdf: n and H contains
the axiomatic triple rdf: n type Property,
so that by rule
sur(rdf: i) sameAs
sur(rdf: i) = rdf: n sameAs rdf: n  H and
(rdf: i, rdf: i)  EI(I(sameAs)). If d  ran(D),
then D contains a pair (a, d) and H contains the
axiomatic triple a type Datatype. In view of
it follows that H contains the triple
rule rdfp5a,
a sameAs a = sur(d) sameAs sur(d),
that

rdfp5a

so

, b

that

Suppose

(d, d)  EI(I(sameAs)). This concludes the proof of
reflexivity.
To prove symmetry of EI(I(sameAs)), suppose that (a, b)  EI(I(sameAs)). Then H contains
sur(a) sameAs sur(b) and by rule rdfp6 also sur(b)
(b, a)  EI(I(sameAs)).
sameAs sur(a), so that
To prove transitivity of EI(I(sameAs)), suppose
that (a, b), (b, c)  EI(I(sameAs)). Then H contains
sur(a) sameAs sur(b) and sur(b) sameAs sur(c) and,
by rule rdfp7, also sur(a) sameAs sur(c), so that
(a, c)  EI(I(sameAs)).
Suppose that a  CI and (a, b)  EI(I(sameAs)).
In order to prove that (a, b)  EI(I(subClassOf)),
note that by CI = CEI(I(Class)) we have (a,
Class)  EI(type), so that sur(a) type Class 
H. Moreover, sur(a) sameAs sur(b)  H, so that by
rule rdfp9, sur(a) subClassOf sur(b)  H, as de-
sired. We can prove in the same way, using rule
rdfp10, that if p  PI and (p, q)  EI(I(sameAs))
then (p, q)  EI(I(subPropertyOf)).
p  PI , (a, b)  EI(p), (a, a

)  EI(I(sameAs)). In or-
EI(I(sameAs)) and (b, b
)  EI(p), note that H contains

der to prove that (a

the triples sur(a) sur(p) sur(b), sur(a) sameAs sur(a
and sur(b) sameAs sur(b
). Rule rdfp11 shows that H
also contains the triple sur(a
We prove that if (p, q)  EI(I(inverseOf)), then
(a, b)EI(p) if and only if (b, a)  EI(q). We have
sur(p) inverseOf sur(q)  H. Therefore, by rules
rdfp8ax and rdfp8bx, sur(a) sur(p) sur(b)  H if and
only if sur(b) sur(q) sur(a)  H.
(a, b)  EI(I(equivalent-
then (a, b)  EI(I(subClassOf)) and
Class)),
(b, a)  EI(I(subClassOf)). By sur(a) equivalentClass sur(b)  H and rules rdfp12a and
rdfp12b,
sur(a) subClassOf sur(b)
and sur(b) subClassOf sur(a) are in H, as re-
quired. To show the converse, suppose that H
sur(b)
contains
shows
subClassOf sur(a). Then rule
sur(a) equivalentClass sur(b)  H,
that
so
(a, b)  EI(I(equivalentClass)). The iff
that
condition connecting equivalentProperty and
subPropertyOf is proved in the same way.
(a, b)  EI(I(hasValue))
and
(a, p)  EI(I(onProperty)), so that
the triples
sur(a) hasValue sur(b) and sur(a) onProperty
sur(p) are in H. To prove that x  CEI(a) if and

sur(a) subClassOf sur(b)

and
rdfp12c

We prove that

) sur(p) sur(b

Suppose

triples

that

the

).

if

if

then
triples

x  CEI(a). Note

We prove that
y  CEI(b),
the
sur(a) onProperty sur(p),

only if (x, b)  EI(p), note that by rules rdfp14a
and rdfp14bx, sur(x) type sur(a)  H if and only if
sur(x) sur(p) sur(b)  H.
(a, b)  EI(I(someValues-
From)), (a, p)EI(I(onProperty)), (x, y)EI(p)
that
and
sur(a) someValues-
H contains
From sur(b),
sur(x)
sur(p) sur(y) and sur(y) type sur(b). Rule rdfp15
shows that we have sur(x) type sur(a)  H, so that
(x, a)  EI(I(type)), as desired.
(a, b)  EI(I(allValues-
We prove that
if
From)), (a, p)  EI(I(onProperty)), x  CEI(a)
then y  CEI(b). Note that H
and (x, y)  EI(p),
contains the triples sur(a) allValuesFrom sur(b),
sur(a) onProperty sur(p), sur(x) type sur(a) and
sur(x) sur(p) sur(y). Rule rdfp16 shows that we have
sur(y) type sur(b)  H, so that (y, b)  EI(I(type)),
as desired.
Suppose that I does not satisfy the condition on
differentFrom. Then, there exists a pair (a, b) 
EI(I(differentFrom))  EI(I(sameAs)), show-
ing
sur(a) difand sur(a) sameAs sur(b).
ferentFrom sur(b)
In other words, H contains
a P-clash. Sup-
I does not satisfy the condition on
pose that
exists
disjointWith.
there
follows
(a, b)  EI(I(disjointWith))

pair

c  CEI(a)  CEI(b),
resource
showing
again
that H contains a P-clash, which consists of the
triples
sur(a) disjointWith sur(b), sur(c) type
sur(a) and sur(c) type sur(b). 

that H contains

triples

that

and

the

It


Theorem 5.11 (pD
entailment lemma). Let D be
a datatype map, S a set of generalized RDF graphs
and G a generalized RDF graph. Then, S |=p G if
and only if there is a generalized RDF graph H that
can be derived from M(S) combined with RDF and
RDFS axiomatic triples and D-axiomatic triples and
P-axiomatic triples, by application of D
entailment
rules and P-entailment rules, and that either contains
an instance of G as a subset or contains a P-clash or
a D-clash.


Theorem 5.12 (pD
entailment lemma (alternative
statement)). Let D be a datatype map, S a set of generalized RDF graphs and G a generalized RDF graph.
closure M(S)p,K of M(S) and
Let H be a partial pD


suppose that i  K for each rdf: i  V (G). Then,
S |=p G if and only if either H contains an instance
of G as a subset or H contains a P-clash or a D-clash.


Proof. The proof of the pD
entailment
lemma

builds further on the proof of the D
entailment lemma
(Theorems 4.11 and 4.12). For the only if direction,
the pD
satisfaction lemma is used instead of the
satisfaction lemma. For the if direction we use

the interpretation I and the associated function IA
as described in the earlier proof. It will be shown
that IA satisfies H. This will again conclude the
proof, because if H contains a P-clash, then I cannot
be a pD
interpretation. To show this, suppose
that H contains the P-clash v different-
first
From w, v sameAs w. Then (IA(v), IA(w)) 
EI(I(differentFrom))  EI(I(sameAs)),
con-
tradicting a requirement on pD
interpretations.
Suppose next
that H contains
the P-clash v
disjointWith w, u type v, u type w.
(IA(v), IA(w))  EI(I(disjointWith))
Then
and IA(u)  CEI(IA(v))  CEI(IA(w)), which again
interpretations. It
contradicts a requirement on pD
remains only to prove the validity of the P-entailment
rules. We continue the earlier proof that IA satisfies
H by induction on the length of derivations of triples
in H.


Suppose that

rule rdfp1 is used to obtain
the triple v sameAs w from p type Function-
alProperty, u p v and u p w, where v  U 
B. Then we have IA(p)  CEI(I(Functional-
Property)), (IA(u), IA(v))  EI(IA(p)) and (IA(u),
(IA(v), IA(w)) 
IA(w))  EI(IA(p)),
EI(I(sameAs))
and
v sameAs
w. The condition on I(InverseFunctional-
Property) is used in a similar way to obtain the
validity of rule rdfp2.

that
satisfies

so

is

Assume

that w p v

obtained with

rule
rdfp3 from p type SymmetricProperty and
v p w, where w  U  B. Then we have IA(p) 
CEI(I(SymmetricProperty)) and (IA(v), IA(w))
 EI(IA(p)), so that (IA(w), IA(v))  EI(IA(p)) and
IA satisfies w p v.
that

from p
type TransitiveProperty, u p v and v p w
by means of rule rdfp4. Then we have IA(p) 
CEI(I(TransitiveProperty))
(IA(u),

u p w is

obtained

Suppose

and

H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

(IA(u),

IA(v)), (IA(v), IA(w))  EI(IA(p)), so that
IA(w))  EI(IA(p)) and IA satisfies u p w.
As to rule rdfp5a, note that if IA satisfies v p w,
then (IA(v), IA(v))  EI(I(sameAs)), so that IA satisfies v sameAs v. Similarly, for rule rdfp5b, if IA satisfies v p w, where w  U  B, then (IA(w), IA(w)) 
EI(I(sameAs)), so that IA satisfies w sameAs w.
Suppose that w sameAs v is obtained from
v sameAs w with rule rdfp6, where w  U 
B. Then (IA(v), IA(w))  EI(I(sameAs)), so that
(IA(w), IA(v))  EI(I(sameAs)) as required. Suppose that rule rdfp7 is used to derive u sameAs
w from u sameAs v and v sameAs w. Then
(IA(u), IA(v)), (IA(v), IA(w))  EI(I(sameAs)) and
therefore (IA(u), IA(w))  EI(I(sameAs)), as re-
quired.
Rule rdfp8ax is used to obtain w q v from
p inverseOf q and v p w, where w, q  U 
B. We have (IA(p), IA(q))  EI(I(inverseOf))
and (IA(v), IA(w))  EI(IA(p)),
(IA(w),
IA(v))  EI(IA(q)). Suppose that w p v is obtained
from p inverseOf q and v q w with rule
rdfp8bx, where w  U  B. Then (IA(p), IA(q)) 
EI(I(inverseOf)) and (IA(v), IA(w))  EI(IA(q)),
so that (IA(w), IA(v))  EI(IA(p)).

so that

Suppose that

rule rdfp9 is used to obtain v
subClassOf w from v type Class and v sameAs
w. Then, (IA(v), I(Class))  EI(I(type)), so that
by Lemma 3.1, IA(v)  CEI(I(Class)) = CI. More-
over, it follows that (IA(v), IA(w))  EI(I(sameAs)),
so that (IA(v), IA(w))  EI(I(subClassOf)).

Suppose that

rule rdfp12a is used to obtain
v subClassOf w from v equivalentClass w.
Then, we have (IA(v), IA(w))  EI(I(equivalent-
Class)), so that (IA(v), IA(w))  EI(I(subClass-
Of)), as desired. Suppose that rule rdfp12b is used

Rule rdfp10 derives the triple p subPropertyOf
q from p type Property and p sameAs q. We
have (IA(p), I(Property))  EI(I(type)), so that
IA(p)  CEI(I(Property)) = PI. Moreover, it follows that (IA(p), IA(q))  EI(I(sameAs)), so that
(IA(p), IA(q))  EI(I(subPropertyOf)).

(IA(u), IA(v))  EI(IA(p)), (IA(u), IA(u

from u p v, u
p v
  U  B. We
, where u
sameAs u
)) 
have
))  EI(I(same-
EI(I(sameAs)) and (IA(v), IA(v
As)). It is clear that IA(p)  PI, so it follows that
(IA(u

Rule rdfp11 is used to obtain u

))  EI(IA(p)).

and v sameAs v

), IA(v

to derive w subClassOf v from v equivalent-
(IA(v),
Class w. Then we have again that
IA(w))EI(I(equivalentClass)), so that (IA(w),
IA(v))EI(I(subClassOf)). Suppose
rule
rdfp12c
is used to obtain v equivalentClass w from v subClassOf w and w subClassOf v. Then we
(IA(v), IA(w)),
(IA(w), IA(v))EI(I(subClassOf)), so that (IA(v),
IA(w))  EI(I(equivalentClass)). The validity
of rules rdfp13a, rdfp13b and rdfp13c is proved in the
same way.

have

that

and

IA(u)  CEI(IA(v))

(IA(u), IA(w))  EI(IA(p)),

Suppose that rule rdfp14a is used to obtain u
type v from v hasValue w, v onProperty
p and u p w. Then, we have (IA(v), IA(w)) 
EI(I(hasValue)), (IA(v), IA(p))  EI(I(onProp-
so
erty))
(IA(u), IA(v)) 
that
EI(I(type)), as desired. Suppose that rule rdfp14bx
is used to derive u p w from v hasValue w, v
onProperty p and u type v, where p  U  B.
Then, we have (IA(v), IA(w))  EI(I(hasValue)),
(IA(v), IA(p))  EI(I(onProperty)) and (IA(u),
IA(v))  EI(I(type)),
(IA(u), IA(w)) 
EI(IA(p)), as desired.

that

and

so

Rule rdfp15 derives the triple u type v from
v someValuesFrom w, v onProperty p,
u p x and x type w. We have (IA(v), IA(w)) 
EI(I(someValuesFrom)), (IA(v),IA(p))EI(I(on-
Property)), (IA(u), IA(x))  EI(IA(p)) and (IA(x),
IA(w))  EI(I(type)), so that IA(u)  CEI(IA(v))
and (IA(u), IA(v))  EI(I(type)), as required.

Rule rdfp16 is used to obtain x type w from v
allValuesFrom w, v onProperty p, u type v
and u p x, where x  U  B. We have (IA(v), IA(w)) 
EI(I(allValuesFrom)), (IA(v), IA(p))EI(I(on-
Property)), (IA(u), IA(v))  EI(I(type))
and
(IA(u), IA(x))  EI(IA(p)),
IA(x)  CEI(
IA(w)) and (IA(x), IA(w))  EI(I(type)), as de-
sired. 

so that


Corollary 5.13. Let D be a finite datatype map. The
entailment relation S |=p G between finite sets S
pD
of finite generalized RDF graphs and finite generalized
RDF graphs G is decidable. This problem is in NP, and
in P if G is ground.

Proof. This follows in the same way as in the case
of D
entailment (see Corollary 4.13), noting in ad-

dition that P-clashes can be detected in polynomial
time. 


Proposition 5.14. Let D be a finite datatype map. The
entailment relation S |=p G between finite sets S
pD
of finite generalized RDF graphs and finite generalized
RDF graphs G is NP-complete.

and H

Proof. Two additions need to be made to the proof
of Proposition 4.14. In the first part of the proof it is
also assumed, of course, that the predicate p of the

triples of G
is not in the P-vocabulary. With
regard to the last part of the proof it should be noted

that G
contains a fourth triple containing p and

that G
contains no further triples containing p;
rule rdfp5a produces the triple p sameAs p. Therefore,
it is still true that none of the triples in G
has p
as predicate. 

A set S of generalized RDF graphs is called

interpretation that

consistent if there is a pD


pD
satisfies S.

Theorem 5.15. Let D be a datatype map, S a set of
generalized RDF graphs, and H a partial pD
clo-
sure of M(S). Then, S is pD
consistent if and only
if H does not contain a P-clash or a D-clash. If D is
finite, the problem to determine whether a finite set
of finite generalized RDF graphs is pD
consistent is
in P.


Proof. These statements follow in a similar way to
the corresponding statements for D
consistency (see
Theorem 4.15), by using Lemma 5.10, the proof of
Theorem 5.12 (), and Lemma 5.7. 


6. pDsv interpretations and pDsv entailment


The pD

semantics considered in the preceding section includes half of OWLs iff condition for
someValuesFrom, as is reflected by one entailment
rule, rdfp15 (see Table 7). It is possible to reflect
the complete OWL semantics for someValuesFrom
with two entailment rules by using RDFs blank
nodes (cf. Section 1.8). This is shown in this section
with a completeness result for an extension of the
sv
pD

semantics. This extension is called the pD


semantics. We introduce a new entailment rule for
someValuesFrom: rdf-svx (cf. Section 1.8). Unlike the P-entailment rules of the preceding section,
this entailment rule introduces new blank nodes. We
do not extend the decidability and complexity results
entailment obtained in the preceding secfor pD

tion to pD
sv entailment; since rule rdf-svx introduces
blank nodes, the proofs of Lemmas 4.8 and 5.7 do not
extend.


sv interpretations). The pD

Definition 6.1 (pD
sv
semantics extends the pD
semantics with OWLs
iff condition for someValuesFrom. Given a

datatype map D, a pD
sv interpretation of a vo-

cabulary V is a pD
interpretation of V (see
Definition 5.1) that satisfies the following condition:
If (a, b)  EI(I(someValuesFrom)) and (a, p) 
EI(I(onProperty)), then x  CEI(a) if and only if
there is a y  CEI(b) such that (x, y)  EI(p). Note
that the if part of this condition is already satisfied by
pD

interpretations (see Definition 5.1).


Definition 6.2 (pD
map D, a set S of generalized RDF graphs pD
a generalized RDF graph G if each pD
tion I that satisfies S also satisfies G.

sv entailment). Given a datatype
sv entails
sv interpreta-


It is clear that each OWL Full interpretation [14] is
a pD
sv interpretation. It follows that if the set of generalized RDF graphs S pD
sv entails the generalized
RDF graph G, then S OWL Full entails G (cf. Definition
5.4).


Definition 6.3
(Entailment rule rdf-svx). The entailment rule rdf-svx is defined as follows:
if a
generalized RDF graph G contains the triples v
someValuesFrom w, v onProperty p and u
type v, where p  U  B, then add to G the two triples
u p b and b type w, where b is a new blank node. Note
that entailment rule rdf-svx may introduce a triple with
a blank node in predicate position when applied to ordinary RDF triples.


sv closure Gp

Definition 6.4
(Partial pD
sv closure). A partial
K of a generalized RDF graph G is
pD
defined in the same way as a partial pD
closure Gp,K
of G (see Definition 5.6), with the addition that in the
last step entailment rule rdf-svx may also be applied


H.J. ter Horst / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 79115

to triples v someValuesFrom w, v onProperty p
and u type v, when there is no x such that the triples
u p x and x type w are included. We shall see that this
restricted form of application of entailment rule rdf-
svx, which serves to restrict the growth of partial clo-
sures, is sufficient for determining pD
sv entailment.


(pD

Definition 6.5
sv Herbrand interpretation).
Given a datatype map D and a generalized RDF graph

G, a pD
K(G) is defined as a pD
Herbrand interpretation PK(G) (see
Definition 5.8), the only differences being that Gp is
replaced by Gp = Gp{1,2,...} and Gp,K by Gp

sv Herbrand interpretation P

K.


Lemma 6.6 (pD
sv satisfaction lemma). Let G be a
generalized RDF graph and D a datatype map. If the
sv closure Gp
partial pD
K of G does not contain a

P-clash or a D-clash, then P
K(G) is a pD
sv interpretation that satisfies Gp

K.


In this proof, P

sv interpretations. Suppose that

Proof.
K(G) is denoted by I and
K by H. We use the same function A : bl(H) 
Gp
RI as in the proofs of Lemmas 4.10 and 5.10. We
only need to add to the proof of these lemmas the
proof of the only if condition for someValuesFrom
(a, b) 
on pD
EI(I(someValuesFrom)), (a, p)  EI(I(onProp-
erty)) and x  CEI(a), so that H contains the
triples
sur(a) someValuesFrom sur(b), sur(a)
onProperty sur(p) and sur(x) type sur(a). By
rule rdf-svx, H contains triples sur(x) sur(p) v and
v type sur(b). Since obviously v  U  B, we have
v = sur(IA(v)) by Eq. (28), so that H contains the triples
sur(x) sur(p) sur(IA(v)) and sur(IA(v)) type sur(b).
This shows that IA(v)  CEI(b) and (x, IA(v)) 
EI(p), which is sufficient to conclude the proof. 


Theorem 6.7 (pD
sv entailment lemma). Let D be a
datatype map, S a set of generalized RDF graphs and
G a generalized RDF graph. Then, S pD
sv entails G
if and only if there is a generalized RDF graph H that
can be derived from M(S) combined with RDF and
RDFS axiomatic triples and D-axiomatic triples and
P-axiomatic triples, by application of D
entailment
rules and P-entailment rules and entailment rule rdf-
svx, and that either contains an instance of G as a subset
or contains a P-clash or a D-clash.


Theorem 6.8 (pD
sv entailment lemma (alternative
statement)). Let D be a datatype map, S a set of generalized RDF graphs and G a generalized RDF graph.
K of M(S) and
Let H be a partial pD
suppose that i  K for each rdf: i  V (G). Then, S
sv entails G if and only if either H contains an in-
pD
stance of G as a subset or H contains a P-clash or a
D-clash.

closure M(S)p

Proof. We only need to add to the proof of Theorems
4.11, 4.12, 5.11 and 5.12 the proof of the validity of
rule rdf-svx. The function A : bl(H)  RI associated
with the interpretation I in the inductive proof of
soundness will now be defined by A(b) = I(l) if
b is a blank node allocated to the literal l by rule
lg and by A(b) = A
(b) if b  bl(M(S)); see the

. For blank nodes b
proof of Theorem 4.12 for A
introduced by entailment rule rdf-svx, we define A(b)
in a recursive way. Rule rdf-svx derives the triples
u p b and b type w from v someValuesFrom w, v
onProperty p and u type v, where p  U  B. By
the induction assumption we have (IA(v), IA(w)) 
EI(I(someValuesFrom)), (IA(v),IA(p))EI(I(on-
(IA(u), IA(v))  EI(I(type)).
Property))
Since I is a pD
it follows that
(IA(u), y)  EI(IA(p))
some y  CEI(IA(w)).
Taking A(b) to be y, we get (IA(u), A(b))  EI(IA(p))
and A(b)  CEI(IA(w)), as desired. 

sv interpretation,

and


for

A set S of generalized RDF graphs is called pD


consistent
satisfies S.

if there is a pD


sv
sv interpretation that

Theorem 6.9. Let D be a datatype map, S a set of
generalized RDF graphs and H a partial pD
sv closure
of M(S). Then, S is pD
sv consistent if and only if H
does not contain a P-clash or a D-clash.


Proof. This is proved in a similar way to Theorem
5.15. 

7. Conclusion

In this paper we have proved that RDFS entailment
is decidable. It has also been proved that the problem
S RDFS-entails G, with S and G finite RDF graphs,
is NP-complete, and in P if G is assumed to have no

entailment and pD

blank nodes. These results were obtained by refining
the central RDFS completeness result (the RDFS entailment lemma) by using partial closure graphs which
are finite and computable in polynomial time for finite RDF graphs. These completeness, decidability
and complexity results for RDFS entailment were extended to D
entailment, which
support reasoning with datatypes and a subset of the
OWL vocabulary, respectively. For these extensions
an if-semantics was used, in line with the semantics of RDFS and weaker than the standard semantics of OWL. We extended the completeness result
for pD
entailment to incorporate OWLs complete
iff condition for someValuesFrom. We proved that
consistency for the RDFS, D
semantics
is in P, and that simple entailment is NP-complete.
We have also shown that the standard set of entailment rules for RDFS is incomplete and that this can
be corrected by allowing blank nodes in predicate
position.


and pD

Acknowledgments

I am grateful to Jan Korst for his suggestion with regard to the proof of Proposition 2.9 and to Warner ten
Kate, Jan Korst and the anonymous referees of [10]
for their comments on earlier versions. The anonymous referees of this paper provided a valuable list
of comments that have been used to improve this
paper.
