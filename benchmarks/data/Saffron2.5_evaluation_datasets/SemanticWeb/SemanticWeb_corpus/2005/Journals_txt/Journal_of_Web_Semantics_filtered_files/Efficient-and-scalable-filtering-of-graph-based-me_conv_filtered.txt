Web Semantics: Science, Services and Agents

on the World Wide Web 3 (2005) 294310

Efficient and scalable filtering of graph-based metadata

Haifeng Liu a,

, Milenko Petrovic b, Hans-Arno Jacobsen a,b

b Department of Computer Engineering University of Toronto, 10 Kings College Road, Ont., Canada M5S 3G4

a Department of Computer Science, University of Toronto, Ont., Canada

Received 14 September 2005; accepted 19 September 2005

Abstract

RDF Site Summaries constitute an application of RDF on the Web that has considerably grown in popularity. However, the way
RSS systems operate today limits their scalability. Current RSS feed arregators follow a pull-based architecture model, which is
not going to scale with the increasing number of RSS feeds becoming available on the Web. In this paper, we introduce G-ToPSS,
a scalable publish/subscribe system for selective information dissemination. G-ToPSS only sends newly updated information to
the interested user and follows a push-based architecture model. G-ToPSS is particularly well suited for applications that deal with
large-volume content distribution from diverse sources. G-ToPSS allows use of an ontology as a way to provide additional information about the data disseminated. We have implemented and experimentally evaluated G-ToPSS and we provide results demonstrating its scalability compared to alternative approaches. In addition, we describe an application of G-ToPSS and RSS to a Webbased content management system that provides an expressive, efficient, and convenient update notification dissemination system.
 2005 Elsevier B.V. All rights reserved.

Keywords: Publish/subscribe; Content-based routing; RDF; Information dissemination; Graph matching

1. Introduction

The amount of information on the Internet is continuously increasing. It is becoming increasingly easier
for non-computer oriented users to publish information
on the Internet because of myriads of user-friendly tools
that now exist. For example, it is very easy for a user
to keep an online diary (e.g., blogs) using a variety of tools. Collaboration tools such as a wiki, allow


Corresponding author.
E-mail addresses: hfliu@cs.toronto.edu (H. Liu),

petrovi@eecg.toronto.edu (M. Petrovic),
jacobsen@eecg.toronto.edu (H.-A. Jacobsen).

users to quickly publish information from within a web
browser, without requiring access or knowledge of any
additional applications. Finally, applications for web
page authoring are becoming ever so easier to use. As
a result of the advances in web page authoring tools,
the number of information publishers has grown con-
siderably.

RDF Site Summary (RSS) is a metadata language
developed by the W3C for describing content changes.1
RSS is so versatile that any kind of content changes
can be described (e.g., web site modifications, wiki

1 http://web.resource.org/rss/1.0/spec.

1570-8268/$  see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2005.09.006

Fig. 1. Current RSS dissemination architecture.

updates, and source code versioning histories). An RSS
feed is a stream of RSS metadata that tracks changes
for a particular content over time.

Typically, users apply a tool, which can read RSS
feeds, to periodically check a number of RSS feeds by
pulling RSS files from a web site. When RSS feeds
indicate that the content has been updated, the user is
informed. The user is expected to explicitly specify
which RSS feeds to monitor.

A RSS feed aggregator is a service that monitors
large numbers of feeds. It allows users to subscribe to
the content that they are interested in without explicitly specifying which RSS feeds the content is coming
from. This is particularly convenient for the user, since
the number of RSS feeds that can carry information of
interest to the user can be very large. In addition, a user
does not have the resources to monitor large number of
feeds and hence the user can easily miss information
of interest.

RSS feed aggregators use pull-based architectures,
where the aggregator pulls RSS feeds from a web site
that hosts the feed. As the number of feeds on the Web
proliferates (e.g., due to ease of publishing information
on the Web), this architecture is not going to scale.
It not only consumes unnecessary resources, but also
becomes difficult to ensure timely delivery of updates.
Fig. 1 illustrates the scalability problem. Multiple
RSS aggregators (i.e., personal (desktop) aggregators,
online news aggregators, and server side aggregators)
poll numerous RSS feed sites, each. Anecdotal evidence suggests that the way RSS dissemination is currently done can severely affect the performance of web
sites hosting popular RSS feeds.2

2 InfoWorld RSS growing pains, July 16, 2004, RSS Traffic Bur-

dens Publishers Servers, July 19, 2004.

In this paper, we describe G-ToPSS3, a graphbased publish/subscribe architecture for dissemination
of RDF data. This paper extends our previous work
[22] with a presentation of a detailed application case
study initially described in Ref. [21]. The G-ToPSS
system provides fast filtering of RDF metadata such as
RSS publications, as well as timely delivery of publications to interested subscribers in a scalable manner.
Fig. 2 shows the architecture of G-ToPSS. The new
information system architecture significantly reduces
the number of unnecessary polls of RSS feed sites. New
content are only sent back to the interested aggregator,
not all (see Fig. 3).

RSS is just one application that can benefit from
this architecture. Another application that is increasingly becoming important is content management in the
enterprise. PDF is the de facto standard for representing documents in electronic form while preserving their
original formatting. RDF metadata can be embedded
in PDF documents, which aids in document manage-
ment. G-ToPSS provides an architecture that could be
applied to content-based routing to disseminate relevant documents throughout a wide area enterprise
network.

In addition, Ref. [11] describes a number of use
cases for RDF data access, many of which can directly
benefit from the described architecture. Some examples
include finding unknown media objects, avoiding
traffic jams, and exploring the neighborhood.

3 G-ToPSS is a part of the Toronto Publish/Subscribe System
(ToPSS) research effort, which comprises a large number of pub-
lish/subscribe research projects, such as M-ToPSS (mobility-aware)
[3,19,23,26], S-ToPSS (semantic matching) [20], A-ToPSS (approx-
imate matching) [18], L-ToPSS (location-based matching) [26],
PADRES (federated p/s) [13,16,17] and others.

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

Fig. 2. RDF site summary dissemination system based on G-ToPSS.

G-ToPSS employs the publish/subscribe, datacentric communication model. There are three main
entities in this model: publishers, subscribers, and bro-
kers. Publishers send all data to a broker (or a network
of brokers). Subscribers register their interest with the
broker in receiving relevant data. The role of a broker is
to mediate communication between the publishers and
the subscribers by matching the published data with the
interests of the subscribers. This way the subscribers do
not need to know who is publishing the data, as long as
the data meets their specific interest, and the publishers
do not need to know who are the ultimate receivers of
their publications. This provides decoupling of senders
and receivers of data both in space and time, which
makes the publish/subscribe paradigm particularly well
suited for structuring of large and dynamic distributed
systems such as RSS feed dissemination, for example.
The contributions of this paper are three-fold. First,
we present an original publish/subscribe system model,

referred to as G-ToPSS, for large-volume graph-based
content filtering. The G-ToPSS system supports the
use of an ontology to specify taxonomy information
about the data disseminated. Second, we develop a
novel algorithm for filtering of graph-structured data
and experimentally demonstrate the scalability of the
approach. Finally, we present an application of G-
ToPSS for the dissemination of content changes to users
of a Web-based content management system.

The paper is organized as following. In Section
2, we briefly summarize related work. The G-ToPSS
publish/subscribe model supporting graph matching
is developed in Section 3. Section 4 describes the
graph matching algorithms and data structures. Section 5 presents the experimental evaluation. In Section 6, we describe an application of G-ToPSS to
a content management system. Section 7 concludes
the paper and discusses possible directions for future
work.

Fig. 3. G-ToPSS RSS dissemination architecture.

2. Related work

The use of the publish/subscribe communication
model for selective information dissemination has been
studied extensively. Existing publish/subscribe systems [1,5,9,12] use attribute-value pairs to represent
publications, while conjunctions of predicates with
standard relational operators are used to represent sub-
scriptions. Systems such as those described in Refs.
[2,10] process XML publications and XPath subscrip-
tions. XPath expressions represent path patterns over
a document tree. XTrie [6] propose an index structure that supports filtering of XML documents based
on many XPath expressions. The approach is extensible supporting patters including constraint predi-
cates. Gupta and Suciu [14] show how to process
XML stream over XPath queries including predicates.
These approaches do not support the filtering of graphstructured data, which is the main motivation of our
work.

Previously, we have built a prototype pub-
lish/subscribe system S-ToPSS [20]
that extends
the traditional attribute-value-pair-based systems with
capabilities to process syntactically different, but
semantically-equivalent information, thus achieving
another level of decoupling, which we termed representational decoupling. S-ToPSS uses an ontology to
be able to deal with syntactically disparate subscriptions and publications. The ontology which can include
synonyms, a taxonomy, and transformation rules was
specified using S-ToPSS specific methods. On the other
hand, G-ToPSS publication and subscription data models are based on directed graphs in general and RDF in
particular. Use of RDF makes it possible for G-ToPSS
to use ontologies built on top of RDF using languages
such as RDFS and OWL. To illustrate this, in this paper,
we extend the G-ToPSS subscription language with
type constraints for subjects and objects, where the type
information is represented in a RDFS taxonomy.

OPS [25]

is another ontology-based publish/
subscribe system whose publication and subscription
model is also based on RDF. OPS uses a very general
subgraph isomorphism algorithm for matching over
overlapping graphs. However, this approach, as we
show in this paper, unnecessarily increases the matching complexity because it assumes that any node of the
publication graph can map to any node of the subscription graph. In this paper, we compare the performance

of G-ToPSS to OPS and show that G-ToPSS always
outperforms OPS.

A RDF document can be represented as directed
labelled graph. Every node in the graph has a unique
name, and no two edges between any two nodes can
have the same label. Given this assumption, in this
paper, we show how to store such graphs in a way that
exploits commonalities between them and how to use
this data structure to efficiently filter publications.

Racer [15] is a publish/subscribe system based on
a description logics inference engine. Since OWL is
based on description logics, Racer can be used for
RDF/OWL filtering. Racer does not scale as well as
G-ToPSS. Its matching times are in the order of tens of
seconds even for very simple subscriptions [15], how-
ever, it offers more powerful inference capabilities not
available in G-ToPSS. Chirita et al. [7] and Cai et al.
[4] design a publish/subscribe system supporting metadata and propose a query language based on RDF. Both
approaches are based on peer-to-peer network abstractions and express queries in a triple pattern, rather
than a graph-based language as central to G-ToPSS.
No support for including ontology information in the
filtering process is provided in either approach. Further-
more, G-ToPSS demonstrates greater scalability with
a demonstrated throughput of millions of queries per
second as compared to the throughput of 250 queries
per second reported by RDFPeers [4].

CREAM [8] is an event-based middleware platform for distributed heterogeneous event-based appli-
cations. Its event dissemination service is based on
the publish/subscribe model. Similar to other pub-
lish/subscribe systems, the subscription and publication model in CREAM, is based on attribute-value
pairs. Like S-ToPSS, attributes and values can be associated with semantic information from an ontology.
Unlike G-ToPSS, which is based on RDF, ontology and
data are represented in a CREAM-specific data model.
In addition, we are not aware of any quantitative evaluations of CREAMs scalability such as the one for
G-ToPSS presented in this paper.

3. G-ToPSS model

In this section, we describe the four components of
the G-ToPSS data model: publications, subscriptions,
matching semantics, and ontology support. Publica-

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

Fig. 4. RDF triple graph.

tions are RDF documents. Subscriptions are queries
for filtering of RDF documents following certain pat-
terns. Our subscription language model is similar to
RDF Query Language (RQL), but the difference is that
RQL is a typed language featuring variables on labels
for nodes (classes) and edges (properties). However,
our G-ToPSS model only supports variables on node
labels and opts to include ontology information in a
separate taxonomy. We refer to our subscription language as GQL.

3.1. Publication data model

A G-ToPSS publication is a RDF document, which
is represented as a directed labelled graph. By the specification of RDF semantics by Pat Hayes, an RDF graph
is a set of triples (subject, property, object). Each triple
is represented by a nodeedgenode link (as shown in
Fig. 4). subject and property are URI references, while
object is either a URI reference or a literal. A publication is a directed graph where the vertices represent
subjects and objects and edges between them represent
properties.

Fig. 5(c) illustrates a publication about one of Prof.
Jacobsens papers published in the 2001 SIGMOD con-
ference.

3.2. Subscription language model

A G-ToPSS subscription is a directed graph pattern specifying the structure of the publication graph
with optional constraints on vertices. A subscription
is represented by a set of 5-tuples (subject, property,
object, constraintSet (subject), constraintSet (object)).
Constraint sets can be empty.

Similar to the publication data model, each 5-tuple
can be represented as a link starting from the subject
node and ending at the object node with the property as
its label. From the publication data model, we know that
each node is labelled with a specific value. However,
in a subscription, we also allow subject and object to

be either a constrained or unconstrained variable. An
unconstrained variable matches any specific value of
the publication, while the constraint variable matches
only values satisfying the constraint. A constraint is
represented as a predicate of the form (?x, op, v), where
?x is the variable, op is an operator, and v is a value.

There are two types of operators: Boolean, for literal
value filtering and is-a, for RDFS taxonomy filtering.
Boolean constrains are one of =,  and  with traditional relational operator semantics. is-a operators are
also one of =,  and  but with alternative semantics.
 is descendantOf which means that variable ?x is an
instance of a descendant of class v.  is ancesterOf
which means that ?x is an instance of an ancestor of
class v. = means that ?x is the direct instance of class v
(i.e., a child of v).

For example, Fig. 5(a) illustrates a subscription that
specifies interest in a web page which is about the G-
ToPSS project supervised by Arno and published after
the year 2003. This type of constraint is for literal value
filtering.

The subscription in Fig. 5(b) is looking for a web
page about a new project after 2004. There are two vari-
ables; the one constraining the year is a literal value
filter; the other is a semantic constraint which uses
the class taxonomy. Only an instance about HomePage
which is a descendant of the Academia class is going
to match (refer to Fig. 6).

3.3. Matching semantics

We denote GP as the publication graph and GS as
the subscription graph pattern. The matching problem
is then defined as verifying whether GS is embedded in
GP (or isomorphic to one or more subgraphs of GP).
Graph pattern GS is embedded in GP if every node in
GS maps to a node in GP such that all constraints of GS
are satisfied.

Formally speaking, for each 5-tuple (subject, prop-
erty, object, constraintSet
(subject), constraintSet
(object)) in subscription graph GS, there is at least one
triple (subject, property, object) in publication GP such
that the subject and object nodes are matched and linked
by the same property edge. The nodes that match are
either the same (i.e., their labels are lexicographically
equal) or the node in GS is a variable for which the
value of the node in GP satisfies all constraints associated with the variable.

Fig. 5. Example subscriptions, publication and GM. (a) Subscription S1; (b) subscription S2; (c) publication; (d) GM contains S1 and S2.

For example, the subscription in Fig. 5(a) is matched
by the publication in Fig. 5(c) since the publication
contains the same links (Home Page #325, project, G-
ToPSS), (G-ToPSS, supervisor, Arno Jacobsen), and
(2005 > 2003), thus (G-ToPSS, year, ?x (?x > 2003)) is
satisfied.

3.4. Ontology support

An RDFS class taxonomy with is-a relationship is
the semantic information about a subject or an object
that is available in the G-ToPSS ontology. An RDF
schema supports constrain is-a relationship on proper-

ties (i.e., represented by the edge between subject and
object). However, to simplify the system design, we
only support the taxonomy information about subject
and object nodes in our G-ToPSS model. As explained
in the following section, structure matching and constraint matching are separate stages in the matching
algorithm. It is straight-forward to extend the current
model to support other RDF schema semantics (e.g.,
subPropertyOf, Datatype, etc.).

G-ToPSS allows the designer to use multiple inheritance in the taxonomy, with the restriction that the
taxonomy must be acyclic. The taxonomy lists all
instances of a class. Alternatively, this information can

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

Fig. 6. Example taxonomy.

be specified in the RDF graph using a type property,
but for simplicity we have opted to include this information in the taxonomy. Note that an instance can also
have multiple parents.

In Fig. 6, we show an example of a class taxonomy about an academic web-pages system. Class
Academia includes two subclasses: Research Lab
and University. Class Middleware Group includes
Pub/Sub System Development and Aspect Oriented
Software Development two subclasses. The document
instance Home Page #325 belongs to both UofT
and Pub/Sub System Development.

As a side note, existing publish/subscribe systems
are classified as either content-based or hierarchical
(topic)-based. Thus, a class taxonomy is a way to seamlessly integrate both models. When filtering, a subscription is matched if and only if both the content and the
hierarchical constraints are satisfied.

4. Algorithm and data structure

To exploit overlap between subscriptions we integrate all subscriptions into a single graph. We denote
the graph containing all subscriptions as GM. Given
all subscriptions, GM, a publication, GP, the pub-
lish/subscribe graph matching problem is to identify
all the subgraphs GSi (representing a subscription Si)
in GM which are matched by GP. In other words, the

goal is to determine all graph patterns, GSi that are
subscriptions, in GM that match some subgraph of
GP.

This matching problem is different from subgraph
isomorphism [24]. The subgraph isomorphism problem is defined as follows: given graphs G1 and G2,
identify all subgraphs of G2 which are isomorphic to
G1. This differs from the problem we are trying to solve,
which is to identify all subgraphs of G2 that are isomorphic to some subgraph of G1.

4.1. Data structure

Since there can be multiple edges between the same
pair of nodes, we use two-level hash tables to represent
GM. At the first level, we use a hash table to store all
the pairs of vertices taking the names of the two nodes
as the hash key. Each entry of the first hash table is a
pointer to another (second-level) hash table that contains a list of all the edges between these two nodes.
The edge label (i.e., property in the 5-tuple) is used as
the hash key. Each edge points to a list of subscriptions
that contain this edge.

Fig. 7 shows the data structure of GM. There are
two edges between nodes A and B and both s1 and s2
contain the edge a between A and B.

Any subscription can contain multiple variables that
can be matched by any vertex in the publication graph.
For example, Fig. 5(a and b) shows two subscription

Fig. 7. Data structure.

graphs containing variables and the merged subscription graph, GM, in Fig. 5(d).

The data structure from Fig. 7 allows us to store
uniquely labelled nodes only once. In other words,
nodes belonging to different subscriptions, but with the
same label map to the same node in GM. This is possible because each node in a graph is uniquely identified
by its label. However, this is not the case with nodes
with variable labels. Variable labels do not uniquely
identify nodes, but instead they represent a (possibly
constrained) pattern on node labels from a publication.
We introduce a special sequence of labels, i|i 1,
to represent variables. The value of index i is bounded
by the number of variables in the subscription with the
most variables among all subscriptions in GM.

For example, in Fig. 5(d), we use one node labelled
as 1 to represent both ?x and ?z; ?x and ?y are represented by two nodes 1 and 2 since they appear in the
same subscription. Mapping between original variable
labels from the subscription (e.g., ?x) to the corresponding star name is preserved.

Mapping of variables from subscriptions to star
labels is arbitrary for the sake of simplicity, even though
some mappings are better than others since they can
results in a sparser GM. In the future, we are going
to investigate how much can be gained, in terms of
matching performance, by having a more sophisticated
mapping.

4.2. Matching algorithm

We use a graph GM to contain all subscriptions. First,
we discuss how GM is created when inserting subscrip-
tions. Suppose GS is a subscription graph. |GS.| is the
number of variables in the subscription graph, variable
vertices in GS are labelled as i, where 0 < i <|GS.|.

GM. is the number of stars in GM. Note that all vertices
in GS and GM are unique. GM.T1 is the first-level hash
table, and T2 is the second-level hash table. E.subs is a
set of subscriptions containing edge E, GM.subs is the
set of all subscriptions in GM. E (and E2) is a directed
edge from E.v to E.w, E.smEdge is an edge in GM that
overlaps with E. newTable(A, B) creates a table with
two columns A and B that will be used to decided on
the bindings for variables.

Algorithm Insert(GS)
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

if GS. > GM.
GM. = GS.
for each edge E GS.edges
T2 = GM.T1.getTable(E.v, E.w)
if (T2 is null)

T2 = GM.T1.insert(E.v, E.w)

E2 = T2.getEdge(E)
if (E2 is null)

E2 = T2.insertEdge(E)

E2.bindingTable = newTable(E.v, E.w)
E2.subs = E2.subs + GS
GM.subs = GM.subs + GS
E.smEdge = E2

Algorithm Insert is the procedure for subscription
insertion. For each edge in GS, we check if there is a
corresponding edge in the first-level hash table. If there
is no such edge, we update the hash tables by inserting E.vE.w into the first-level hash table and inserting
edge E into the corresponding second-level hash table.
Finally, the subscription id is inserted into the list associated with edge E and added to GM.subs.

Next, we explain how to perform matching using
the subscription graph GM when a publication arrives.
GP is the publication graph (the number of edges in

GE is m). G
P is a completed graph containing vertices
E.v, E.w, i such that 0 < i <|GM.| + 1. All nodes in
GP are unique. SubSet contains all subscriptions that

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

have at least one edge in GM that are referenced by GP.
Result is a set of (S, R), where S is a subscription and
R is a satisfying binding for variables. Natural join ( )
is an equality join on all common columns.

Algorithm match(GP)
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.

for each E GP.edges
create a fully connected graph G
for each edge E2 G

T2 = GM.T1.getTable(E2.v, E2.w)
if (T2 not null)

E3 = T2.getEdge(E)
if (E3 not null)
for all S E3.subs
S.edgeCount ++
E3.bindingTable+ = (E.v, E.w)
SubSet = SubSet + E3.subs

result = 0
for all subscriptions S SubSet
if (S.edgeCount|S.edges|)

S.edgeCount = 0
b = E.smEdge.bindingTable|E S
for every edge E2 S.edges E
for every row R b

E2.smEdge.bindingTable

b = b

if CheckConstraint(R, CS, T)

result = result + (S, R)

Algorithm match is the procedure for matching publications against subscriptions. There are two stages in
the matching process. First, for each edge in the pub-
lication, we check all the corresponding subscription
edges in GM. Then we find the satisfying bindings for
variables and evaluate the constraints.

In the first stage, for the publication edge v1v2, it can
be matched by edges v1v2, v1i, iv2 and ij in GM.
There are three actions to perform on these potentially
matching edges. (1) Add v1v2 into the binding tables
of all matching edges so that they can be used in the
second stage. (2) Increase the counters of subscriptions
associated with these edges. (3) Put the subscriptions
into Subset as matching candidates. This completes the
first stage of matching.

In the second stage, we find the matched subscriptions by checking the candidates in Subset one-by-one.
For each subscription Si in Subset, we join all the binding tables of edges belonging to si. If the result table is
not empty, then the entries in the result table contain all
valid binding values for all variables in the subscrip-
tion.

Fig. 8 provides an example for a binding table join.
For example, the subscription contains two edges A1
and 1B. There are three entries in the binding table of
A1 which means A1 is matched by three edges AB,
AC and AE in the publication. 1B is matched by five
edges in the publication. Joining of these two tables
produces ACB and AEB and hence 1 can be bounded
with value C and E.

After identifying all valid bindings of variables, we
can use the binding value w to evaluate the constraint.
For the constraint (?x, op, v), we need to check whether
(w op v) is true. For the value filtering constraint, (w
op v) is evaluated using standard relational operator
comparison.

Fig. 8. Binding table join.

For the class taxonomy filtering constraint (w op
v), we need to check the descendant-ancestor relationship between the specific instance w and the class v by
traversing the taxonomy tree. The constraint checking
algorithm is shown in Algorithm CheckConstraint.

the time to load a batch of subscriptions at a time is
|GSi .edges|. Since the number of edges in each sub-
	si
scription is very small, the time complexity of loading
subscription is

O(number of subscriptions).

Algorithm CheckConstraint(R, Cs, T)
1.
2.
3.

for each variable  in S

find the value v in R and the constraint (op, c)
return isTrue (v, op, c, T)

Algorithm isTrue(v, op, c, T)
1.
2.
3.

if op = LT return isNodeDescendant(v, c, T)
if op = GT return isNodeDescendant(c, v, T)
if op = EQ return (c.equals(v))

For example, in Fig. 5(d), for subscription s2, 2 is
matched by node 2005 since 2005 > 2004 and 1 is
matched by node Home Page #325 since it is descendant of class Academia.

4.3. Analysis

4.3.1. Space complexity

The space cost mainly includes two parts: hash
tables and linked lists associated with each edge to
store the subscription ids that contain this edge. The
size for the hash tables is determined by the number of
unique edges among all the subscriptions. The length
of the linked list depends on the average number of
subscriptions each edge is associated with. Therefore,
the space complexity is
O(|GM .edgs| + |GM .edgs|  NSe)
where |GM.edges| is the number of unique edges in
matrix GM and NSe is the average number of subscriptions each edge is associated with.

4.3.2. Time complexity

For the procedure of insert a subscription into the
system, he insert(GS) algorithm iterates for every edge
in the coming subscription, locate the corresponding
list associated with the edge and add an entry of the
coming subscription into the list. Thus, the insert algorithm depends on the number of edges for each subscription and the time complexity is
O(|GS .edges|).
To form the graph GM which contains all subscriptions,
we have to insert subscriptions one by one. Therefore,

The matching algorithm consists of two stages. First
is edge matching. By checking each edge in the pub-
lication, we determine all the subscriptions that have
at least one edge matched by the publication. The time
of the first stage depends on the size of the completed

graph G
P and the number of edges in the publication.

Since each graph G
P contains all the stars in GM plus

E.v and E.w, the number of edges in G

P is

k + 2

Suppose k is the number of stars in GM, m is the number

of edges in the publication, we have

m  2

k + 2

 O(mk2).

In the second stage, for each subscription in SubSet,
if all the edges of it are matched, we perform a join
operation on the binding tables to determine whether
there is a satisfying binding for the variables, then we
check the constraints. To join two tables, the time is
linear with the size of the smaller table. The time complexity to find satisfying bindings of variables for each
subscription is
O(k  l)
where k is the number of stars in GM and l is the size
of the smallest binding table for variables.

The time to check whether the constraint for the
variable is satisfied according to the class taxonomy
is dependent on the complexity of the taxonomy tree.
Since multiple parents are allowed in the class taxonomy tree, the time is O(dt), where d is the depth of the
tree and t is the average number of parents each node
may have.

Overall, the matching time to evaluate all subscrip-

tions is
O(mk2) + O(n  k  l + n  k  dt)
where n is the number of subscriptions in SubSet. In real
applications, the class taxonomy tree is fixed, the number of variables in one subscription is small (usually
13, at most 5), m n, and n is around the number of
matched subscriptions. Therefore, the overall matching

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

time is linear with the number of matched subscrip-
tions:
O(ratiomatch  number of subscriptions).

5. Evaluation

We have implemented the algorithm in Java. We
experimentally evaluate the rate of matching and the
memory use. We run the experiments on a Linux system with 1 GB RAM and a 1 GHz microprocessor. We
are using a synthetic workload so that we can independently examine various aspects of G-ToPSS. We report
the results for the two most important metrics from a
users perspective, namely the rate of matching and the
memory requirements. The workload parameters are
shown in Table 1.

SizeP and SizeS are decided by (number of nodes,
number of edges) the publication graph and the subscription graph. The number of edges must be larger
than the number of nodes in order to obtain a connected graph. We use ratiomatch to control the number of
matched subscriptions that are generated as subgraphs
from the publication graph.

We generate the test workload using the parameter values from Table 1. A publication is generated
first. For example, for publication of size (k, m) we
first generate a simple path of length k 1 and then we
generate m k + 1 edges between random pairs of the k
nodes.

Subscriptions are generated in four steps. (1)
ratiomatch subscriptions that match the publication are

Table 1
The workload parameters in experiments

Parameters

SizeP
SizeS
Nsub
ratiomatch

Nstars

Nsub*

Default
values

(35, 90)
(5, 35)

0.1%

overlaps

50%

Description

Size of publication
Size of subscription
Number of subscriptions
Ratio of matched subscriptions among
all
Number of stars (variables) in one
subscription
Number of subscriptions containing
stars
Ratio of overlap among subscriptions

generated by randomly selecting a subgraph of the
publication. (2) Using same technique, overlapped subscriptions are generated as subgraphs from one big
graph. (3) Nsub * (1 overlapS) non-overlapping subscriptions are generated randomly in the same way that
the publication was generated. (4) Nstars vertices are
selected from all Nsub* subscriptions and replaced with
a variable (). Alternatively, we limit values that can
be bound to a variable by adding constraints.

All measurements are performed after G-ToPSS
has loaded all the subscriptions. We look at the effect
of the number of subscriptions, subscription size and
matching ratio (number of subscriptions matched by a
publication). Finally, we compare G-ToPSS with two
alternative implementations. For each experiment, we
vary one parameter and fix the others to their default
values as specified in Table 1.

5.1. Number of subscriptions

Fig. 9(a) shows the memory use with increasing
number of subscriptions. We see that the memory
size grows linearly as the number of subscriptions
increase. Since all subscriptions in our experiments
are of the same size and the overlap factor is con-
stant, the memory increase per subscription is also a
constant.

Fig. 9(b) shows the time to find all matches for a
publication given a fixed set of subscriptions. As the
set of subscriptions increases, so does the time. The
number of subscriptions that match the publication is
relative to the total number of subscriptions in the set.
Consequently, the number of matches increases as the
number of subscriptions increases.

The time to match a publication is split between
structure matching phase and constraint evaluation
phase. As the number of subscriptions increases, both
of these times increase by a fixed amount because the
number of matches increases constantly.

5.2. Subscription size

Fig. 9(c) shows how the space used by the subscriptions decreases as the overlap between them increases.
We present this to validate our workload. The matrix
space is the size of GM, while whole memory is equal
to the size of GM plus the space used to store all the
subscriptions.

Fig. 9. Experimental performance results. (a) Memory vs. #subscriptions; (b) matching time vs. #subscriptions; (c) memory vs. subscription
overlap; (d) memory vs. subscription size; (e) matching time vs. subscription overlap; (f) matching time vs. matching ratio.

Fig. 9(e) shows the effect of increasing subscription size on the matching time. We see that
the
time increases more rapidly as the number of edges
increases (e.g., from 4 to 8), the time almost dou-
bles. On the other hand, as the number of edges
increases slowly, so does the increase of matching
time, hence the matching time is not affected by the
number of nodes, but by the number of edges in the
subscription.

5.3. Matching ratio

Fig. 9(f) shows the effect of increasing the number of subscriptions that match the publication. As this

number grows, the time to match grows very rapidly.
This is mainly due to increase in time to calculate all
the bindings for each subscription.

5.4. G-ToPSS versus alternatives

In Fig. 10(a), we compare the performance of our
algorithm to the OPS algorithm [25]. As the graph
shows, OPS matching time increases very rapidly with
the number of subscriptions. The main reason for the
significant difference in matching times comes from the
differences in basic assumptions. The OPS algorithm
makes the same basic assumption as do other, tradi-
tional, subgraph isomorphism algorithms [24], namely

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

Fig. 10. Compare G-ToPSS with other algorithms. (a) G-ToPSS vs. OPS; (b) OPS vs. naive.

that every node in a subscription is a variable. In other
words, any node of a publication can match with any
other node in the subscription graph. However, this
assumption unnecessarily increases the matching com-
plexity, as we see in the evaluation. We make a more
realistic assumption that the number of variables in any
subscription is low as compared to the total number of
nodes in a subscription graph and the nodes in a RDF
publication are unique.

Fig. 10(b) illustrates that, even though OPS is less
scalable than G-ToPSS, it is still far better then a naive
approach which sequentially checks all subscriptions
to find the matching ones.

6. Application

Recent years have seen a rise in the number
of unconventional publishing tools on the Internet.
Tools such as wikis, blogs, discussion forums, and
Web-based content management systems have experienced tremendous rise in popularity and use; primarily because they provide something traditional tools
do not: easy of use for non computer-oriented users
and they are based on the idea of collaboration. It
is estimated, by www.pewinternet.org, that 32 million people in the US read blogs (which represents
27% of the estimated 120 million US Internet users),
while 8 million people have said that they have created
blogs.

Web-based collaboration is the common idea for
this new breed of content management tools. The center
piece of such tools is a web page that is being used
as an area where multiple users participate in content
creation. More significantly, the collaboration enabling
tool used is the web page itself (accessed through the
all-pervasive web browser).

With these new Web applications, there rouse a need
for users to stay informed about changes to the con-
tent. In general, users want to be updated about daily
news headlines of interest to them, or be notified when
there is a reply in a discussion they participate in, or
their favorite Web personality has updated his/her blog
(online diary, etc.).

RSS4 is quickly becoming the dominant way to disseminate content update notifications on the Internet,
pewinternet.org reports that six million people in the
US use RSS aggregators (a service/application that
monitors large numbers of RSS feeds).5

Web-based content management systems (CMS)
have also grown in popularity mainly because they are
based on the publishing tools just described, but also
because they are much easier to use and maintain than
traditional CMS.6 Like traditional CMS systems, they
provide content access control, user profiles, persistent
storage, Web access, RSS authoring, advanced content
management, content routing, and taxonomic content
classification.

In this section, we describe an extension to content management systems, CMS-ToPSS, for scalable
dissemination of RSS documents, based on the pub-
lish/subscribe model. To illustrate the effectiveness
of the system, we extend an existing open-source
Web-based content management system, Drupal (dru-
pal.org) to use CMS-ToPSS in a manner that is trans-

4 www.web.resource.org/rss/1.0/spec.
5 Reported by Pew Internet & American Life Project (www.
pewinternet.org), an organization that produces reports that explore
the impact of the Internet on families, communities, the daily life.
Also reported by RSS at Harvard Law (www.blogs.law.harvard.
edu/tech/).

6 Mid Market Web CMS Vendors Pull Ahead. Brice Dunwoodie.

www.CMSwire.com.

Fig. 11. CMS-ToPSS system architecture.

Fig. 12. RSS feed example.

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

Fig. 13. Subscription example.

parent to end users, yet provides an efficient contentrouting architecture.

CMS-ToPSS consists of three main components: the
Drupal module (a conent management system), the G-
ToPSS filtering service and connector between them.
The overall architecture is shown in Fig. 11. The Drupal module acts as a client to the filtering service. The
module does not require any changes to Drupal, and any
Drupal installation can experience the benefits of CMSToPSS by simply retrieving and installing the module.
G-ToPSS filtering service is accessible via XMLRPC and can be accessed by the XML-RPC client. The
CMS-ToPSS connector reads RSS feeds and serializes
them into publications and subscriptions as input to
G-ToPSS. In Fig. 12, we show an example of an RSS
feed (i.e., a publication) and a subscription is shown in
Fig. 13. Both publications and subscriptions are RSS
feeds. And subscriptions are differentiated by the key
word GQL in title and the query can be taken out from
description.

Upon receiving a publication and subscriptions, G-
ToPSS performs the matching between them and the

outputs are notifications which are also serialized as
RSS feeds over the converter back to the client via
XML-RPC. Each subscription that a user submits is,
in fact, a distinct RSS feed (containing items matching
the users subscription).

The Drupal module performs both subscribing and
publishing based on user interaction with Drupal CMS.
User can easily generate an RDF document using
our template and publish to G-ToPSS. Also user can
form a subscription with specified constraints from
the interaction panel and send it to G-ToPSS. The
module serializes all content changes in Drupal using
RSS and sends them to the G-ToPSS filter service.
The filtering service forwards the document to the
interested clients which could be other XML-RPC
clients as well as other Drupal modules. Note that the
G-ToPSS filtering service can serve multiple Drupal
sites.

In addition to publishing all content changes
in RSS, the Drupal module also extends different
kinds of Drupal content with change notification
capabilities. For example, users can subscribe to

Fig. 14. CMS-ToPSS user API.

receive notifications when they have replies on
the discussion forum, or when a certain web page
in Drupal has been updated. The Drupal module registers
subscriptions with
the G-ToPSS filtering service transparently to the
user.

these kinds of

A user, using a web browser, accesses a Drupal
site that is extended with the module described in
this paper. The user can choose to receive notifications for content of her choice (e.g., discussion forum
replies, web page updates, etc.) Drupal supports convenient taxonomic content classification, which can be
directly mapped to a G-ToPSS ontology. In this case,
the user will get notifications only when both the content and taxonomic constraints of her subscription are
satisfied. The users can also create content (e.g., participate in a discussion form or create/update a web
page) to trigger notifications. The users subscriptions
are stored as part of their Drupal profile. Via the profile
web page, users can review their notification requests
as well as see all notifications received for those
requests.

We also allow users to subscribe directly on the RSS
content by expressing their subscriptions in G-ToPSSs
SQL-like subscription language (GQL). The subscriptions and their results are also shown as part of the user
profile. The screenshot of the user interface is shown
in Fig. 14.

7. Conclusions and future work

Use of RDF as a language for representing metadata is growing. Applications such as RSS and content
management are exhibiting use patterns that current
systems were not designed for.

The G-ToPSS prototype shows that a data-centric,
push-based architecture such as a publish/subscribe
system is a very good fit for just such applications (as
illustrated by CMS-ToPSS described in Section 6). G-
ToPSS is able to support high matching rates for very
complex subscriptions. In practice, we expect these
subscriptions to be simpler (i.e., have smaller number
of edges and stars) on average than the ones used in our
experiments.

Being based on RDF, G-ToPSS can be easily extended to use additional semantic information
expressed in languages built on top of RDF, such as
RDFS and OWL. We show how a RDFS taxonomy can
be used to increase the expressiveness of the G-ToPSS
query language. Our implementation uses an efficient
traversal of the class hierarchy with support for multiple inheritance, which adds more expressiveness to the
language without unduly affecting the matching rate.
On the other hand, more powerful inference techniques
such as those of Descriptions Logics (on which OWL
is based) could augment the constraint filtering without
significant changes to the matching engine.

H. Liu et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 294310

In the future, we will work on extending G-ToPSS
with full RDF language features (such as bags and
sequences), which we have left out since their implementation does not affect the matching rate but merely
adds syntactic sugar.

Extending G-ToPSS to support variables on predicates is straight-forward since the same techniques
for supporting variables on subjects and objects can
be used. Consequently, matching time complexity is
not affected by this extension.
