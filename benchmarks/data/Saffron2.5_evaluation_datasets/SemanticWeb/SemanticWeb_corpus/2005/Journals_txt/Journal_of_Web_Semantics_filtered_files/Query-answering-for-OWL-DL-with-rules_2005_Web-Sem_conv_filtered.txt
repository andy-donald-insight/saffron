Web Semantics: Science, Services and Agents

on the World Wide Web 3 (2005) 4160

Query Answering for OWL-DL with rules

Boris Motika,

, Ulrike Sattlerb, Rudi Studera

a FZI Research Center for Information Technologies, University of Karlsruhe, Germany

b Department of Computer Science, University of Manchester, UK

Received 6 May 2005; received in revised form 11 May 2005; accepted 11 May 2005

Abstract

Both OWL-DL and function-free Horn rules are decidable fragments of first-order logic with interesting, yet orthogonal
expressive power. A combination of OWL-DL and rules is desirable for the Semantic Web; however, it might easily lead to the
undecidability of interesting reasoning problems. Here, we present a decidable such combination where rules are required to be
DL-safe: each variable in the rule is required to occur in a non-DL-atom in the rule body. We discuss the expressive power of
such a combination and present an algorithm for query answering in the related logic SHIQ extended with DL-safe rules, based
on a reduction to disjunctive programs.
 2005 Elsevier B.V. All rights reserved.

Keywords: Description logics; Rules; Decidability; Hybrid languages

1. Introduction

OWL-DL [25] is a W3C recommendation language
for ontology representation in the Semantic Web. It
is a syntactic variant of the SHOIN(D) description logic (DL), offering a high level of expressivity
while still being decidable. For example, SHOIN(D)
provides full negation, disjunction, and a restricted
form of universal and existential quantification of vari-
ables. A related logic, SHIQ(D) [17,16], distinguished
from SHOIN(D) mainly by not supporting nominals (concepts containing exactly the specified set of


Corresponding author. Tel.: +49 721 9654812;

fax: +49 721 9654813.

individuals), has been successfully implemented in
practical reasoning systems, such as RACER [13] and
FaCT [14]. Description logics have been found useful
in numerous applications such as information integration [1, chapter 16], software engineering [1, chapter
11], and conceptual modeling [1, chapter. 10].

Although OWL-DL is very expressive, it is a decidable fragment of first-order logic, and thus cannot
express arbitrary axioms: the only axioms it can express
are of a certain tree structure [12]. In contrast, decidable rule-based formalism such as function-free Horn
rules1 do not share this restriction, but lack some of the
expressive power of OWL-DL: they are restricted to

E-mail addresses: motik@fzi.de (B. Motik), studer@fzi.de

1 Throughout this paper, we use rules and clauses synony-

(R. Studer), sattler@cs.man.ac.uk (U. Sattler).

mously, following [15].

1570-8268/$  see front matter  2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2005.05.001

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

universal quantification and lack negation in their basic
form. To overcome the limitations of both approaches,
OWL-DL was extended with rules in [15], but this extension is undecidable [15]. Intuitively, the undecidability is due to the fact that adding rules to OWL-DL
causes the loss of any form of tree model property. In
a logic with such a property, every satisfiable knowledge base has a model of a certain tree-shaped form,
so to decide satisfiability (i.e. the existence of a model
of a knowledge base), one can restrict the search for a
model only to such tree-shaped models. For most DLs,
it is possible to ensure termination of such a search. To
see how rules can destroy this property, consider e.g.
the following rule, which obviously has only non-tree
models:

hasAunt(x, y)

 hasParent(x, z), hasSibling(z, y), Female(y)

It is natural to ask what kind of (non-tree) rules can
be added to OWL-DL while preserving decidability.
This follows a classic line of research in knowledge
representation,
investigating the trade-off between
expressivity and complexity, and providing formalisms
with varying expressive power and complexity. It not
only provides insight into the causes for the undecidability of the full combination, but also enables
a more detailed complexity analysis and, ultimately,
the design of specialized decision procedures.
Applications that do not require the expressive power
of the full combination can use such procedures,
relying upon known upper time and space bounds
required to return a correct answer. Finally, in the last
decade, it turned out that many specialized decision
procedures are amenable to optimizations,
thus
achieving surprisingly good performance in practice
even for logics with high worst-case complexity
[1, chapter 9].

In this paper, we propose a decidable combination
of OWL-DL with rules, where decidability is obtained
by restricting the rules to so-called DL-safe ones. Im-
portantly, we do not restrict the component languages,
but only reduce the interface between them. Generalizing the approaches of other decidable combinations of
rules and description logics [22,6,15], in DL-safe rules,
concepts and roles are allowed to occur in both rule
bodies and heads as unary, respectively binary predicates in atoms, but each variable of a rule is required to

occur in some body literal whose predicate is neither
a concept nor a role. We discuss the expressive power
and limitations of our approach by means of an example and show that query answering for such a combined
logic is decidable.

Moreover, we present an algorithm for query answering in the extension of SHIQ with DL-safe
rules which is based on a novel technique for reducing SHIQ knowledge bases to disjunctive programs
[20,18]. This yields a query answering algorithm which
follows the principle of graceful degradation: the
user pays only for the features she actually uses. Although a full evaluation is not yet finished, our initial
results are very promising, and we believe that this algorithm can be efficiently realized in practice.

Please note that we are primarily concerned with
the semantic and decidability aspects of hybrid reason-
ing, and not with the infrastructure aspects, such as the
syntax or the exchange of rules on the Web. For these
issues, we refer the reader to [15] since our approach
is fully compatible with the one proposed there. This
paper is an extended version of [23]. Due to space con-
straints, it does not contain all technical details and
proofs. All technical results have been summarized in
[18].

The paper is structured as follows. In Section 2 we
give the definitions necessary to understand this paper.
In Section 3 we informally discuss the difficulties in
combining OWL-DL and rules. In Section 4 we introduce the notion of DL-safe rules and show that query
answering for DL-safe rules is decidable. In Section 5
we present a practical algorithm for reasoning in a logic
obtained by combining SHIQ and DL-safe rules. Before we conclude, in Section 6 we give an overview of
the related work.

2. Preliminaries

2.1. OWL-DL and its variants

OWL-DL is a syntactic variant of the SHOIN(D)
description logic [15]. Hence, although several syntactic forms for OWL-DL exist, in this paper we use the
traditional description logic notation since it is more
compact. For the correspondence between this notation and various existing OWL-DL syntactic forms, see
[15].

SHOIN(D) supports reasoning with concrete
datatypes, such as strings or integers. Instead of axiomatizing datatypes in logic, SHOIN(D) employs a
restricted version of the approach from [2], where the
properties of concrete datatypes are encapsulated in
so-called concrete domains, which we introduce be-
low. In the rest, with x we denote a vector of variables
x1, . . . , xn and, for a function , with (x) we denote
the application of  to each element xi of x.

Definition 1. A concrete domain D is a pair
( D ,  D ), where  D is a set, called the domain
of D , and  D is a set of predicate names. Each
d   D is associated with an arity n and an extension d D  n
D . A concrete domain D is admissible if (i)  D is closed under negation, i.e. for each
d   D , there exists  d   D with  d D = n
\ d D ,
(ii)  D contains a unary predicate D interpreted as
 D , (iii)  D contains a binary predicate  D interpreted as{(x, y)| x = y}, and (iv) D -satisfiability of fi-
di(xi) is decidable.
nite conjunctions of the form
The latter is the case if an assignment  of variables to
elements of  D exists, such that (xi)  d D
, for each
1  i  n.

i=1

Notice that, since descriptions logics considered
in this paper can enforce equality between concrete
terms, we extend the notion of the admissibility
from [2] with Condition (iii). To simplify extending
first-order logic with a concrete domain, we assume the
existence of two sorts: c for the concrete domain, and
a for all other objects of the so-called abstract domain.
To distinguish the sorts syntactically, we denote the
variables (function symbols) of sort c as xc (f c). We
assume that (i) the predicates from  D are contained
in a first-order signature , (ii) they have only arguments of sort c and (iii) for each function symbol f, no
argument is of sort c. Under these assumptions, a firstorder interpretation I is called a D -interpretation if all
terms of sort c are interpreted as elements of  D and
the extension of each concrete predicate d is d D . The
notions of a model, satisfiability and entailment carry
over to the first-order logic with a concrete domain in
the obvious way. When ambiguities do not arise, we
do not stress D in  D -model,  D -satisfiability, etc.
We now define the description logic SHOIQ(D)a
generalization of all different description logics which
we consider in this paper.

and Inv(R

}. Let Inv(R) = R

Definition 2. For NRa a set of abstract role names,
the set of SHOIQ(D) abstract roles is the set Na 
{R | R  NRa
) = R
for R  NRa. Analogously, let NRc be the set of concrete roles.2 A SHOIQ(D) RBox KBR over NRa and
is a finite set of transitivity axioms Trans(R)
NRc
and role inclusion axioms R  S and T  U, such
that R  S  KBR implies Inv(R)  Inv(S)  KBR,
and Trans(R)  KBR implies Trans(Inv(R))  KBR,
for abstract roles R and S, and concrete roles T
and U.
denote the reflexive-transitive closure of .
A role R is transitive if Trans(S)  KBR for some S
with S  R and R  S; R is simple if there is no role
S such that S  R and S is transitive; and R is complex
if it is not simple.

Let 

Let NC be a set of atomic concept names, NIa
a set of abstract individuals, and NIc a set of concrete individuals. The set of SHOIQ(D) concepts
is built by the following syntactic rules, where A is
a concept name, C(i) a SHOIQ(D) concept, R an
abstract role, S a simple abstract role, T(i) a concrete role, n an integer, d a concrete predicate, a(i)
an abstract individual, cc
(i) a concrete individual, and
	  {,}:
C  || A|C | C1  C2 | C1  C2 |

R.C |R.C | 	 n S.C | {a1, . . . , an}|
	 n T |T1, . . . , Tn.D|T1, . . . , Tn.D

D  d |{cc

n}
, . . . , cc

A SHOIQ(D) TBox KBT over NC and KBR is a finite
set of concept inclusion axioms C  D, where C and
D are SHOIQ(D) concepts.

A SHOIQ(D) ABox KBA is a set of concept and
role membership axioms C(a), R(a, b), T (a, bc), and
(in)equality axioms a(c)  b(c), where   { ,}, C is
a SHOIQ(D) concept, R an abstract role, T a concrete
role, a and b abstract individuals, and ac and bc concrete
individuals.

A SHOIQ(D) knowledge base KB is a triple
(KBR, KBT, KBA), where KBR is an RBox, KBT is
a TBox, and KBA is an ABox.

2 We do not distinguish between concrete role names and concrete
roles, since inverse concrete roles do not make sense semantically
and are therefore not supported.

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

y(, X) = 
y(C, X) = y(C, X)
y(C  D, X) = y(C, X)  y(D, X)
y(R.C, X) = y : R(X, y)  x(C, y)
, . . . , cc

n}, X) = X D cc

 . . .  X D cc

y({cc

Table 1
Translation of SHOIQ(D) into FOL
Mapping concepts to FOL

y(, X) = 
y(A, X) = A(X)

y(C  D, X) = y(C, X)  y(D, X)
y(R.C, X) = y : R(X, y)  x(C, y)
y({a1 . . . , an}, X) = X a1  . . .  X an
y(d, X1, . . . , Xm) = d(X1, . . . , Xm)

R(X, yi)  
y( n R.C, X) = y1, . . . , yn+1 :

R(X, yi)  
y( n R.C, X) = y1, . . . , yn :

Ti(X, yc
, . . . , yc
m :

Ti(X, yc
, . . . , yc
m :

, . . . , yc
T (X, yc
n+1 :
, . . . , yc
n :

y(T1, . . . , Tm.D, X) = yc
y(T1, . . . , Tm.D, X) = yc
y( n T , X) = yc
y( n T , X) = yc

Mapping axioms and KB to FOL

T (X, yc

x(C, yi)  
x(C, yi)  

i )  x(D, yc
i )  x(D, yc

i )  
, . . . , yc
i  D yc

i )  
yc
i  D yc
yc

, . . . , yc
m)

yi  yj

yi  yj
m)

(C  D) = x : y(C, x)  y(D, x)
(R  S) = x, y : R(x, y)  S(x, y)
(Trans(R)) = x, y, z : R(x, y)  R(y, z)  R(x, z)
(C(a)) = y(C, a)
(R(a, b)) = R(a, b)
(a(c)  b(c)) = a(c) ( D ) b(c) for  { ,}
(KB) = 
x, y : R(x, y)  R

(y, x)  

KBRKBTKBA

()

X is a meta variable and is substituted with the actual variable. x is obtained from y by simultaneously substituting all y(i) with x(i) and y
with x, and vice versa.

SHOIN(D) is obtained from SHOIQ(D) by allowing only number restrictions of the form 	 n R.
(usually written as 	 n R). SHIQ(D) is obtained
from SHOIQ(D) by not allowing nominal concepts
{a1, . . . , an} and datatypes {cc
n}. SHOIN and
SHIQ are obtained from SHOIN(D) and SHIQ(D)
by disallowing concrete domains. Finally, ALCHIQ
and ALCHIQ(D) are obtained from SHIQ and
SHIQ(D) by disallowing transitivity axioms.

, . . . , cc

Since the algorithms we present in Section 5 are
based on resolution, instead of using a direct modeltheoretic semantics [17], we present an equivalent
semantics by translation into multi-sorted first-order
logic.

Definition 3. The semantics of a SHOIQ(D) knowledge base KB is given by the mapping  in Table 1
which transforms KB into a first-order formula. Each
atomic concept is mapped into a unary predicate, each
abstract role is mapped into a binary predicate with arguments of sort a  a and each concrete role is mapped
into a binary predicate with arguments of sort a  c.
The basic inference problem for SHOIQ(D) is checking KB satisfiability, i.e. determining whether a firstorder model of (KB) exists.

Other interesting inference problems, such as concept satisfiability, concept subsumption and instance
checking can be reduced to satisfiability by standard
transformations, cf. [1, chapter 2].

2.2. Rules

We use the standard definitions for rules. Let NP be
a set of predicate symbols. A term is either a constant
(denoted by a, b, c) or a variable (denoted by x, y, z).
An atom has the form P(s1, . . . , sn), where P  NP is
a predicate symbol and si are terms. A disjunctive rule
has the form

A1  . . .  Am  B1, . . . , Bn

where Ai and Bj are atoms; the set of atoms Ai is called
the rule head, and the set of all Bj is called the rule
body. A non-disjunctive rule is a rule with m = 1. Unless explicitly stated otherwise, the term rule refers to
a non-disjunctive rule. A program P is a finite set of disjunctive rules. For the semantics, we define the above
rule to be equivalent to the clause A1  . . .  Am 
B1  . . .  Bn. This yields a monotonic functionfree formalism compatible with the one from [15].

2.3. Basic superposition

Our algorithms from Section 5 are based on basic
superpositiona calculus optimized for theorem proving with equality [4,24], which we outline in the rest
of this section.

We assume the standard notions of first-order
clauses with equality: all existential quantifiers have
been eliminated using Skolemization; all remaining
variables are universally quantified; we only consider
the equality predicate, i.e. all non-equational literals A
are encoded as A  in a multi-sorted setting; and we
treat  as having built-in symmetry. Moreover, we assume the reader to be familiar with standard resolution
[3].

Basic superposition is an optimized version of superposition which prohibits superposition into terms
introduced by unification in inference steps applied
so far. Its inferences rules are formalized by distinguishing two parts of a clause: (i) the skeleton clause C
and (ii) the substitution  representing the cumulative
effects of all unifications. Such a representation of a
clause C is called a closure, and is written as C  .
A closure can conveniently be represented by marking each term in C occurring at a variable position of
C with [ ] if this variable is in the domain of . Any
position at or beneath a marked position is called a
substitution position.
The calculus requires two parameters. The first is
an admissible ordering on terms  , i.e. a reduction
ordering total on ground terms. If   is total on nonground terms (as it is the case in this paper), it can
be extended to literals by associating, with each literal L = s  t,  { ,}, a complexity measure cL =
(max(s, t), pL, min(s, t)), where pL is 1 if is , and 0
otherwise. Now L1   L2 iff cL1
  cL2, where cLi are
compared lexicographically, with 1   0. The second
parameter of the calculus is a selection function which
selects an arbitrary set of negative literals.

The basic superposition calculus is a refutation pro-
cedure: if a set of closures N is saturated up to redun-
dancy, then it is unsatisfiable if and only if it contains
the empty closure. The set of closures N is saturated
up to redundancy if all inferences from premises in N
are redundant in N. A literal L   is (strictly) maximal w.r.t. a closure C   if no L!  C exists, such that
L!   L (L! " L). A literal L   is (strictly) eligible for superposition in (C  L)   if there are no

selected literals in (C  L)   and L   is (strictly)
maximal w.r.t. C  ; L   is eligible for resolution in
(C  L)   if it is selected in (C  L)   or there are
no selected literals in (C  L)   and L   is maximal w.r.t. C  . We denote basic superposition with BS
and present its inference rules in Table 2. The ordered
hyperresolution rule is a macro inference, combining negative superposition and reflexivity resolution;
E is called the main premise, and Ei are called the
side premises.

3. Reasons for the undecidability of OWL-DL
with rules

 NRc

In [15], an extension of OWL-DL with rules was
 NP.
presented, by requiring that NC  NRa
In other words, integration of OWL-DL and rules is
achieved by simply allowing concepts and roles to be
used in rules as unary and binary atoms, respectively.
Furthermore, it was shown that such an extension leads
to undecidability of the following problem: given an
OWL-DL knowledge base KB and a program P, is
there a common model of (KB) and P, i.e. is KB
consistent with P? As a consequence, subsumption
and query answering w.r.t. knowledge bases and
programs are also undecidable. Investigating this
proof and the ones in [22] more closely, we note
that the undecidability is caused by the interaction
between some very basic features of description logics
and rules. In this section, we try to give an intuitive
explanation of this result and its consequences.

Consider the simple knowledge base KB from
Table 3. It is not too difficult to see that this knowledge base implies the existence of an infinite chain of
fathers: since Peter must have a father, there is some
x1 who is a Person. In turn, x1 must have some father
x2, who must be a Person, and so on. An infinite model
with such a chain is shown in Fig. 1, upper part (a). Observe that Peter is a grandchild, since he has a father
of a father, who is a person.
Let us now check if KB |= Grandchild(Jane); this
is the case if and only if KB  {Grandchild(Jane)}
is unsatisfiable, i.e. if it does not have a model. We
can check this by trying to build such a model; if we
fail, then KB  {Grandchild(Jane)} is unsatisfiable.
However, we have a problem: starting from Peter, a
na ve approach to building a model will expand the

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

Table 2
Inference rules of the BS calculus
Name of the inference rule

Positive superposition

Actual inference rule
(C  s t)   (D  w v)  

(C  D  w[t]p v)  

Negative superposition

(C  s t)   (D  wv)  

(C  D  w[t]pv)  

Reflexivity resolution

Equality factoring

Ordered hyperresolution

(C  st)  

(C  s t  s! t!

(C  tt!  s! t!)  

E1 . . . En E

(C1  . . .  Cn  D)  

Conditions
(i)  = MGU(s, w|p) and  = ,
(ii) t " s and v " w,
(iii) (s t)   is strictly eligible for superposition,
(iv) (w v)   is strictly eligible for superposition,
(v) s t " w v,
(vi) w|p is not a variable.
(i)  = MGU(s, w|p) and  = ,
(ii) t " s and v " w,
(iii) (s t)   is strictly eligible for superposition,
(iv) (wv)   is eligible for resolution,
(v) w|p is not a variable.
(i)  = MGU(s, t) and  = ,
(ii) (st)   is eligible for resolution.
(i)  = MGU(s, s!) and  = ,
(ii) t " s and t! " s!,
(iii) (s t)   is eligible for superposition.
(i) Ei are of the form (Ci  Ai)  , for 1  i  n,
(ii) E is of the form (D  B1  . . .  Bn)  ,
(iii)  is the most general substitution such that Ai = Bi
for 1  i  n, and  = ,
(iv) Ai   is strictly eligible for superposition,
(v) Bi   are selected, or nothing is selected, i = 1 and B1   is
maximal w.r.t. D  .

Table 3
Example knowledge base

Person(Peter)
Person  father.Person
father.(father.Person)  Grandchild

Peter is a person.
Each person has a father who is a person.
Things having a father of a father who is a person are grandchildren.

chain of Peters fathers indefinitely, and will therefore
not terminate.

This very simple example intuitively shows that we
have to be careful if we want to ensure termination
of a satisfiability checking algorithm. For many DLs,
termination can be ensured without losing complete-

ness because we can restrict our attention to certain
nice models. For numerous DLs, we can restrict our
attention to tree models, i.e. to models where the underlying relational structure forms a tree [29]. This is
so because every satisfiable knowledge base has such
a tree model (to be precise, for some DLs we consider

Fig. 1. Two similar models.

tree-like abstractions of non-tree models). Even if such
a tree model is infinite, we can wind this infinite tree
model into a finite structure. In our example, since KB
does not require each father in the chain to be distinct
(i.e. there is no axiom requiring the role father to be
acyclic), the model in Fig. 1, lower part (b) is the result
of winding an infinite tree into a nice, finite model.
Due to their regular structure, these windings of tree
models can be easily constructed in an automated way.
To understand why every satisfiable SHIQ knowledge
base has a tree model [17], consider the mapping 
in Table 1 more closely (we ignore some technicalities caused by the transitive roles): in all formulae
obtained by transforming the result of  into prenex
normal form, variables are connected by roles only in
a tree-like manner, as shown in the following example:
S.(R.C  R.D)  Q 
x : {[y : S(x, y)  (x : R(y, x)  C(x))
(x : R(y, x)  D(x))]  Q(x)} 
x, x1, x2, x3 : {S(x, x1)  R(x1, x2)
C(x2)  R(x1, x3)  D(x3)  Q(x)}

Let us contrast these observations with the kind of
reasoning required for function-free Horn rules. In such
rules, all variables are universally quantified, i.e. there
are no existentially quantified variables in rule conse-
quents. Hence, we never have to infer the existence of
new objects. Thus, reasoning algorithms must consider only individuals which are explicitly introduced
and are given a name in the knowledge base. Reasoning
can be performed by grounding the rules, i.e. replacing
the variables in the rules with all individuals from the
knowledge base in all possible ways. Through ground-
ing, first-order reasoning becomes propositional, since
a ground rule is essentially equivalent to a propositional
clause. For a finite program, the number of ground rules
is also finite, and satisfiability of a set of propositional
clauses is decidable. Hence, the rules, such as the one
defining hasAunt(x, y) from the introduction, are allowed to enforce arbitrary but finite, non-tree models,
and not only nice models.

Now let us see what happens if we extend a description logic such as SHIQ with function-free Horn
rules. Then, we combine a logic whose decidability
is due to the fact that we can restrict our attention to
nice models (but with individuals whose existence

may be implied by a knowledge base) with the one
whose decidability is due to the fact that we can restrict our attention to known individuals (but with
arbitrary relations between them). Unsurprisingly, this
and similar combinations are undecidable [22,15].

4. DL-safe rules

As a reaction to the observations in Section 3, in
this section we first formalize the interface between
description logics and rules, and then, to achieve de-
cidability, we define the notion of DL-safe rules and
discuss its benefits and drawbacks. Finally, we show
that query answering in SHOIN with DL-safe rules is
decidable.

4.1. Combining description logics and rules

 NRc

Definition 4 (DL rules). Let KB be a SHOIQ(D)
knowledge base and let NP be the set of predicate
symbols such that { }  NC  NRa
 NP. For
s and t constants or variables, a DL-atom is an atom
of the form A(s), where A  NC, or R(s, t), where
R  NRa
 NRc. A non-DL-atom is an atom with a
predicate from NP \ (NC  NRa
 { }). A (dis-
junctive) DL rule is a (disjunctive) rule over NP. A DL
program is a set of (disjunctive) DL rules.

 NRc

The semantics of the combined knowledge base
(KB, P), where KB is a SHOIQ(D) knowledge base
and P is a DL program, is given by translation into
first-order logic as the set of axioms (KB)  P, where
each rule A1  . . .  An  B1, . . . , Bm is treated as a
clause A1  . . .  An  B1  . . .  Bm. The main
inferences in (KB, P) are satisfiability checking, i.e.
determining whether a first-order model of (KB)  P
exists, and query answering, i.e. determining whether
(KB)  P |=  for a ground atom , written as
(KB, P) |= .

A few remarks regarding Definition 4 are in order.

4.1.1. Relationship with existing formalisms

The above definition yields a formalism compatible with the ones from [15,22]. The main difference
from [15] is that we allow non-DL-atoms to occur in a
rule, and that we only allow atomic concepts to occur
in a rule. The latter is a technical assumption and is
not really a restriction: for a complex concept C, one

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

can always introduce a new atomic concept AC, add
the axioms AC  C and C  AC to the TBox, and use
AC in the rule. This transformation is obviously linear
in the size of P.

4.1.2. Decidability

Since the formalism is compatible with [15], we
immediately have that the reasoning with combined
knowledge bases is undecidable. To achieve decidabil-
ity, we introduce the notion of DL-safety in subsection
4.2.

4.1.3. Minimal versus first-order models

Rules are usually interpreted under minimal model
semantics, i.e. only models minimal w.r.t. set inclusion are considered. We write P |=c  if a formula
 is true in all minimal models of P. However, in
Definition 5 we assume the standard first-order semantics for rules, where P |=  means that  is true
in all models of P. We briefly discuss the differences between these two approaches, and their practical
consequences.
For  a positive ground atom, P |=  if and only if
P |=c . Namely, if  is true in each model of P, it is
true in each minimal model of P as well, and vice versa.
Therefore, for entailment of positive ground atoms, it
is not important whether the semantics of P is defined
w.r.t. minimal or w.r.t. general first-order models.

Assume now that  is a negative ground atom. In
this case, there is a difference between minimal model
semantics and first-order semantics, as shown by the
following example. For  = A(b) and P = {A(a)}, it
is clear that P |= . Namely, A(b) is not explicitly
derivable from the facts in P: M1 = {A(a), A(b)} is a
first-order model of P and  is false in M1. However,
P has exactly one minimal model M2 = {A(a)} and
A(b) is obviously true in M2, so P |=c .
The choice of semantics also affects concept sub-
sumption: assume that  = x : C(x)  D(x), and
P = {C(a), D(a)}. Similarly as above, P |= : just
consider a model M1 = {C(a), D(a), C(b)} of P in
which  is false. However, the only minimal model of P
is M2 = {C(a), D(a)} and  is true in M2, so P |=c .
The distinction between minimal models and general
first-order models fundamentally changes the computational properties of concept subsumption: equivalence
of general programs under minimal model semantics
is undecidable [27] whereas, under first-order seman-

tics, it is decidable and can be reduced to satisfiability
checking using standard transformations.

To summarize, the difference between first-order
and minimal model semantics is not relevant for query
answering if queries are positive atoms; however, it is
relevant for queries which involve negation or for concept subsumption. Negative queries are usually considered in a more general framework of negation-as-
failure, where negation is interpreted as failure to prove
a query, thus yielding a non-monotonic formalism.
Whereas non-monotonic features are certainly very important for the Semantic Web, we do not address them
in this work. Instead, our results are an initial step towards providing a practical hybrid knowledge representation formalism integrating description logics and
rules. We also believe that our work may be used as a
basis for future non-monotonic extensions.

4.2. DL-safety restriction

We now introduce DL-safety restriction as one possible way to make reasoning with DL rules decidable.

Definition 5 (DL-safe rules). A (disjunctive) DL rule r
is DL-safe if each variable occurring in r also occurs in a
non-DL-atom in the body of r. A (disjunctive) program
P is DL-safe if all its rules are DL-safe.

DL-safety is similar to safety in datalog. In a safe
rule, each variable occurs in a positive atom in the body,
and may therefore be bound only to constants explicitly
present in the database. Similarly, DL-safety ensures
that each variable is bound only to individuals explicitly introduced in the ABox. For example, if Person,
livesAt, and worksAt are concepts and roles from KB,
the following rule is not DL-safe:

Homeworker(x)

 Person(x), livesAt(x, y), worksAt(x, y)

The reason for this is that both variables x and y occur
in DL-atoms, but do not occur in a body atom with a
predicate outside of KB. This rule can be made DL-safe
by adding special non-DL-atoms O(x) and O(y) to the
body of the rule, and by adding a fact O(a) for each
individual a occurring in KB and P. Thus, the above
rule becomes
Homeworker(x)  Person(x), livesAt(x, y),
worksAt(x, y), O(x), O(y)

This rule is obviously DL-safe. In Section 4.3 we discuss the consequences that this transformation has on
the semantics.

4.3. Expressivity of DL-safe rules

In our approach, to achieve decidability, we do not
restrict the component languages. Rather, we combine
full SHOIN(D) with function-free Horn rules, and
thus extend both formalisms. DL-safety only restricts
the interchange of consequences between the component languages to those consequences involving individuals explicitly introduced in the ABox.

To illustrate the expressive power of DL-safe rules,
consider the axioms from Table 4. We use a rule to define the only non-DL-predicate BadChild as a grandchild which hates some of its siblings (or itself). Notice
that this rule involves relations forming a triangle between two siblings and a parent and thus cannot be
expressed in a description logic such as SHOIN(D).
Moreover, it is not DL-safe because variables x, y and
z do not occur in a non-DL-atom in the rule body.

Now consider the first group of ABox facts. Since
Cain is a Person, as in Section 3 one may infer that
Cain is a Grandchild. Now Cain and Abel are children
of Adam, and Cain hates Abel, so Cain is a BadChild.
Similarly, Romulus has a father who is a father of
Remus, and Romulus hates Remus, so Romulus is a
BadChild as well. We are able to derive this without
knowing exactly who the father of Romulus is.
Consider now the DL-safe rule defining BadChild!

since the father of Cain and Abel is known by name
(i.e. Adam is in the ABox), the literal O(y) from the
rule for BadChild!
can be matched to O(Adam), and
we may conclude that Cain is a BadChild!
. In contrast,
the father of Romulus and Remus is not known in the
ABox. Hence, the literal O(y) from the DL-safe rule
cannot be matched to the fathers name, so the rule does
not derive that Romulus is a BadChild.!

This may seem confusing. However, DL-safe rules
do have a natural reading: just append the phrase
where the identity of all objects is known to the intuitive meaning of the rule. For example, the rule defining BadChild!
is a known
grandchild for which we know a parent, and who hates
one of his known siblings.

can be read as A BadChild!

Combining description logics with DL-safe rules increases the expressivity of both languages. Namely, a

SHOIN(D) knowledge base cannot imply that Cain is
a BadChild!
because the triangle rule cannot be expressed using SHOIN(D) constructs. Similarly, a set
of function-free Horn rules cannot imply this either:
we know that Cain has a grandfather because Cain
is a person, but we do not know who he is. Hence,
we need the existential quantifier to infer the existence of ancestors and thus to conclude that Cain is a
Grandchild.

Finally, we would like to point out that it is incorrect to compute all consequences of the description logic component first, and then to apply the rules
to the consequences. Consider the last KB part about
Oedipus: he is a GoodChild or a BadChild!
, but we
do not know exactly which is true. Either way, one
of the rules derives that Oedipus is a Child, so we
have (KB, P) |= Child(Oedipus). This cannot be derived by applying the rules defining Child to the consequences of KB since KB |= GoodChild(Oedipus)
and KB |= BadChild!

(Oedipus).

The impact of the DL-safety restriction in practice
depends a lot on the type of the application. For applications relying mainly on extensional reasoning (such
as e.g. metadata-based information retrieval), we believe that DL-safety is not a serious restriction. In such
applications, the universe of discourse is usually limited to the known objects, so DL-safe rules can draw
all or most relevant conclusions. On the contrary, in
applications requiring intensional reasoning (such as
e.g. natural language processing), DL-safety is a much
more severe restriction, as many conclusions drawn involve unnamed objects.

4.4. Decidability of Query Answering

We now show that checking satisfiability of a
SHOIN knowledge base extended with DL-safe rules
is decidable. The proof is by a non-deterministic reduction to checking satisfiability of a SHOIN knowledge
base without rules.

Theorem 1. For any SHOIN knowledge base KB
and any DL-safe program P, checking if (KB, P) is
satisfiable is decidable.

Proof. Let P g be the set of ground instances of P, i.e.
P g contains all possible ground instantiations of rules
in P with individuals from KB and P.

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

Table 4
Example with DL-safe rules
Person  father.Person
father.(father.Person)  Grandchild
father  parent
BadChild(x)  Grandchild(x), parent(x, y),
BadChild!

(x)  Grandchild(x),

parent(z, y), hates(x, z)

parent(x, y), parent(z, y), O(x), O(y), O(z)

Person(Cain)
father(Cain, Adam)
father(Abel, Adam)
hates(Cain, Abel)
Person(Romulus)
father.father.{Remus}(Romulus)
hates(Romulus, Remus)
Child(x)  GoodChild(x), O(x)
Child(x)  BadChild!
(x), O(x)
(GoodChild  BadChild!
O() for each individual  in the ABox

)(Oedipus)

Each person has a father who is a person.
Things having a father of a father who is a person are grandchildren.
Fatherhood is a kind of parenthood.
A bad child is a grandchild who hates one of his siblings.

DL-safe version of a bad child.

Cain is a person.
Cains father is Adam.
Abels father is Adam.
Cain hates Abel.
Romulus is a person.
Romulus father is a father of Remus.
Romulus hates Remus.

Good children are children.
Bad children are children.
Oedipus is a good or a bad child.

Enumeration of all ABox individuals.

We now show that (KB)  P is satisfiable if and
only if (KB)  P g is satisfiable. The () direction
is trivial. For the () direction, let I be a model of
(KB)  P g. Since (KB)  P g does not contain non-
DL-atoms with variables, we may safely assume that
the interpretation of each non-DL-predicate contains
only tuples of the form (1, . . . , n), such that, for each
i = i. Let r be a rule from
i, there is a constant ai with aI
P. Since r is DL-safe, each variable in r occurs in a body
non-DL-atom. Hence, for each valuation replacing a
variable in r with an individual  for which there is no
such constant a with aI = , there is a body atom of r
which is false in I, making r true in I. Thus, I is a model
of (KB)  P.
Satisfiability of (KB)  P g can be decided by
case analysis as follows: each model of P g satisfies
at least one literal per rule. Hence, we dont-know nondeterministically choose one literal per clause in P g
and, for Lc the resulting set of literals, we test the satisfiability of (KB)  Lc. Now (KB)  P g is satisfiable if and only if there exists a choice of Lc such
that (KB)  Lc is satisfiable.
 Lc be the subset of ground literals
of Lc involving DL predicates. Then (KB)  Lc is
unsatisfiable if and only if either Lc contains a complementary pair of ground literals or (KB)  Lc
DL is
unsatisfiable. The first case can be checked syntacti-
cally, and the second case can be reduced to standard
SHOIN reasoning as follows: Lc
DL can be viewed as an

Next, let Lc

ABox, apart from literals of the form R(a, b), which
can be transformed into equivalent SHOIN ABox assertions (R.{b})(a). Thus we have reduced query answering to deciding satisfiability of a SHOIN knowledge base.

The latter problem is decidable because (i) transitivity axioms can be eliminated from SHOIN knowledge
bases in the same way as this is done for SHIQ in [18]
and (ii) the resulting logic is a syntactic variant of the
two variable fragment of first-order logic with counting
quantifiers, which is known to be decidable [10].
Since the semantic of (KB, P) is compatible with
standard first-order semantics, (KB, P) |=  if and
only if (KB, P  { }) is unsatisfiable, for any
ground atom . Hence, Theorem 1 shows decidability of query answering as well. 

The same non-deterministic reduction of ground
DL-safe rules to sets of ground literals is applicable
even if KB is a SHOIN(D) knowledge base. Hence,
we strongly believe that Theorem 1 also holds for
SHOIN(D), since the proof that SHOIN is decidable should be easily adaptable to SHOIN(D).

5. Query Answering with DL-safe rules

The proof of Theorem 1 gives a procedure for query
answering in the full combination of OWL-DL and
DL-safe rules. However, this procedure is likely to be

hopelessly inefficient in practice, due to the huge
amount of dont-known non-determinism. At least to
a certain extent, such rather blind guessing seems un-
avoidable. Namely, in [28] it was shown that the combination of nominals, inverse roles, and number restrictions yields an increase in complexity from ExpTime
to NExpTime. Therefore, in this section we describe a
practical reasoning algorithm for the following frag-
ment: (i) the description logic is SHIQ, and (ii) in
rules, DL-atoms are restricted to concepts and simple
roles. Our algorithm is based on reducing the description logic knowledge base to a disjunctive program
which entails the same set of ground facts as the original
knowledge base. For unary coding of numbers, this algorithm runs in deterministic exponential time, which
makes it optimal since SHIQ is ExpTime-complete
[28]. Furthermore, DL-safe rules (with the above restriction to concepts and simple roles) can simply be
appended to the program obtained by the reduction.

The full presentation of the algorithm and a proof
of its correctness are technically involved and lengthy
[18,20]. Here, we just provide an overview of the pro-
cedure, without going into details.

The algorithm in [18] is capable of handling
SHIQ(D) knowledge bases. The presence of datatypes
does not significantly affect the algorithm presented in
this paper: the only change is to the basic superposition
calculus, which is extended with a so-called concrete
domain resolution rule from [19]. This rule combines
concrete domain reasoning with logical reasoning to
provide a D -refutation procedure. Since its presentation is rather technical and not essential for the ideas
described here, for details please refer to [18,19].

5.1. Overview

For a SHIQ knowledge base KB, our goal is to obtain a disjunctive program DD(KB), such that KB |= 
if and only if DD(KB) |=c , for  of the form R(a, b)
or A(a). Thus, DD(KB) can be used for answering
queries in KB.

The intuition behind our reduction is the following:
let us assume that unsatisfiability of KB can be decided
using some sound and complete calculus C. Our goal is
to simulate each inference step of C on KB by a sound
inference step on DD(KB). Hence, each proof by C in
KB can be reduced to a proof in DD(KB). Furthermore,
the program DD(KB) should allow simulating the

inferences in the other direction as well, i.e. it should
be possible to reduce each proof in DD(KB) by a sound
and complete calculus C!
to a proof in KB. Then, KB
is satisfiable if and only if DD(KB) is satisfiable.

To operationalize this idea, we use an instance of
basic superposition for C and, in Section 5.2, we show
an algorithm for deciding satisfiability of KB by BS+
DL,
a parametrization of BS. Next, in Section 5.3 we show
how this decision procedure can be used to obtain the
desired reduction. In Section 5.4 we show that DLsafe rules can simply be appended to DD(KB). In
Section 5.5 we show how to compute non-ground query
answers. Finally, in Section 5.6 we present an example
knowledge base along with the steps performed by the
reduction algorithm.

5.2. Deciding SHIQ by basic superposition

Satisfiability of a SHIQ knowledge base KB can
be decided in the framework of resolution as follows.

5.2.1. Eliminating transitivity axioms

A minor problem in deciding satisfiability of KB are
the transitivity axioms, which, in their clausal form,
do not contain so-called covering literals (i.e. literals containing all variables of a clause). Such clauses
are known to be difficult to handle, so we preprocess KB into an equisatisfiable ALCHIQ knowledge
base (KB). In short, this transformation replaces each
transitivity axiom Trans(S) with axioms of the form
R.C  S.(S.C), for each R with S  R and C a
concept occurring in KB. This transformation is poly-
nomial. Whereas KB and (KB) entail the same sets
of ground facts concerning simple roles, they do not
entail the same sets of ground facts concerning complex roles. This is the reason for allowing only simple
roles to occur in DL-safe rules.

5.2.2. Preprocessing

We translate (KB) into a first-order formula
(KB) according to Table 1. For unary coding of
numbers, (KB) can be computed in polynomial
time. To transform (KB) into a set of closures
(KB), we apply the well-known structural transformation [26]. Roughly speaking, the structural transformation introduces a new name for each nonatomic subconcept of KB. For example, in the axiom
C  R.(S.C), a new concept Q is introduced for the
subconcept S.C, and the above axiom is replaced with

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

Table 5
Types of ALCHIQ-closures

R(x, y)  Inv(R)(y, x)
R(x, y)  S(x, y)
Pf (x)  R(x,%f (x)&)
Pf (x)  R([f (x)], x)
P1(x)  P2(%f(x)&)  %fi(x)& /%fj(x)&
P1(x)  P2([g(x)])  P3(%f([g(x)])&)  %ti& /%tj&
P1(x)  R(x, yi)  P2(y)  
yi yj
R(%a&,%b&)  P(%t&)  %ti& /%tj&

where ti and tj are either of the form f ([g(x)]) or of the form x

where t, ti and tj are either some constant b or a functional term fi([a])

Conditions:
(i) in any term f (t), the inner term t occurs marked;
(ii) in all positive equality literals with at least one function symbol, both sides are marked.

axioms C  R.Q and Q  S.C. It is well-known
that (KB) and (KB) are equisatisfiable, and that
(KB) can be computed in polynomial time [26].

For any KB, the syntactic structure of closures in
(KB) follows the types given in Table 5; we call
them ALCHIQ-closures. We use the following no-
tation: for a term t, we denote with P(t) a disjunction
of the form ()P1(t)  . . .  ()Pn(t), and we denote
with P(f(x)) a disjunction of the form P1(f1(x))  . . . 
Pm(fm(x)) (notice that this allows each Pi(fi(x)) to
contain positive and negative literals). We use %t& to
denote that the term t may, but need not be marked.
In all closure types, some of the disjuncts may be
empty.

5.2.3. Decomposition

As discussed in [21,18], if KB contains number restrictions on roles that have subroles, saturating (KB)
by BS need not terminate. To remedy that, we introduce decompositionan additional inference rule
which transforms some conclusions of BS in a way
that guarantees termination. More precisely, any conclusion derived by BS of the form as specified below
left is replaced with the two closures on its right, where
t is an arbitrary term, and the predicate QS,f is a predicate not occurring in (KB) and is unique for a pair
of role and function symbols S and f :
D    R([t], [f (t)]) 

D    QR,f ([t])

D    R([f (t)], [t]) 

QR,f (x)  R(x, [f (x)])
D    QInv(R),f ([t])
QInv(R),f (x)  R([f (x)], x)

With BS+

In the rest, BS+

we denote the BS calculus where decomposition is eagerly applied to the conclusions of all BS
inference. In [21,18] we have shown that BS+
is sound
and complete, i.e. that a set of closures saturated under
BS+
up to redundancy is unsatisfiable if and only if it
contains the empty closure.
5.2.4. Parameters for BS+
DL denotes the following parametrization of BS+
. We use a standard lexicographic path
ordering [24] (LPO) for comparing terms. LPOs are
based on a precedence >P over function, constant,
and predicate symbols. If the precedence is total, then
the induced LPO is total on ground terms, and is admissible for basic superposition. To decide ALCHIQ,
we can use any precedence such that f >P c >P p >P
QS,f >P , for any function symbol f, constant c,
predicate symbol p and predicate QS,f . We use the
selection function which selects all negative binary literals in a closure.
5.2.5. Termination of BS+
The following lemma is central to our work. It states
that any BS+
DL inference, when applied to ALCHIQ-
closures, produces an ALCHIQ-closure. The proof
is by considering all BS+
DL inferences on all types of
ALCHIQ-closures.
Let N0, . . . , Ni  {C} be a BS+
Lemma 1.
DL-
derivation, where N0 = (KB) and C is the conclusion derived from premises in Ni. Then C is either an
ALCHIQ-closure or it is redundant in Ni.
by BS+

Lemma 1 is crucial to show that saturation of (KB)
DL terminates. Namely, for a finite knowl-

DL on ALCHIQ closures

edge base, the number of ALCHIQ-closures is finite:
(i) the number of variables in closures of types 1 and
2 is two, (ii) the number of variables in a closure of
type 7 is limited by the maximal number occurring in a
number restriction, (iii) the depth of a functional term
is at most two, so (iv) using a finite number of concept
and function symbols and a finite number of variables,
the number of closures that can be built without repeated literals is finite. In fact, assuming that |KB| represents the size of the knowledge base where numbers
are coded in unary, the number of ALCHIQ-closures
is exponential in |KB|.
DL takes at
most exponentially many derivation steps in |KB|.
Namely, by Lemma 1, each BS+
DL inference produces
an ALCHIQ-closure. Hence, after at most an exponential number of steps, all possible ALCHIQ-closures
will have been derived, after which any BS+
DL inference will produce an already derived closure. Since
BS+
DL is a sound and complete calculus, the saturated set contains the empty closure if and only if
(KB) is unsatisfiable. Hence, we have the following
result:

Therefore, saturation of (KB) by BS+

Theorem 2. For an ALCHIQ knowledge base KB,
saturating (KB) by BS+
DL with eager application of
redundancy elimination rules decides satisfiability of
KB and runs in time exponential in |KB| for unary
coding of numbers.

5.3. Reducing KB to a disjunctive program

We now show how BS+

DL can be used to reduce an
ALCHIQ knowledge base KB to a disjunctive program DD(KB). Using the transformation for eliminating transitivity axioms, this algorithm is easily generalized to the case where KB is a SHIQ knowledge base.
5.3.1. Saturation of TBox and RBox by BS+
Let gen(KB) be the set of all closures of the
form QR,f (x)  R(x, [f (x)]), for each role R and
a function symbol f occurring in (KB). Intuitively,
gen(KB) is the set of closures that can be introduced by the decomposition rule in the saturation
of (KB). Let TRg = (KBT  KBR)  gen(KB).
Since the predicates QR,f do not occur in (KB),
TRg  (KBA) is satisfiable if and only if (KB) is
satisfiable.

DL; let  !

The first step in the reduction of KB to a disjunctive
program is to saturate TRgthe RBox and TBox
closures of (KB)by BS+
be the set of
saturated closures. In this key step of the reduction,
we compute all non-ground consequences of KB.
As discussed in Section 5.2,  !
can be computed
in time exponential in |KB|, contains closures of
in |KB|, and contains at most
length polynomial
exponentially many ALCHIQ-closures.
(KB) is satisfiable if and only if  !  (KBA) is
satisfiable, and the latter can be decided by saturating
 !  (KBA) by BS+
DL. We also observe that, since

already contains all non-ground consequences of
(KB) and due to the syntactic form of ALCHIQ-
closures, only ground closures of type 8 are derived
in the saturation of  !  (KBA). Furthermore, closures of types 4 and 6 cannot participate in any BS+

inference with a ground closure: ground closures do
not contain terms of depth two which would unify
with the maximal literal from a closure of type 6,
and role literals do not contain functional terms which
would unify with a term f (x) from a closure of type 4.
Hence, closures of types 4 and 6 can safely be removed from  !
; with  we denote the resulting set of
closures.

5.3.2. Elimination of function symbols
We have seen that satisfiability of KB can be decided by saturating   (KBA) under BS+
DL, where
all derived closures are of type 8. Closures in  and the
closures of type 8 obtained by the saturation can contain
functional terms of depth one. To obtain a disjunctive
program from  , i.e., to remove all functional terms,
we perform the transformation described below which
allows simulating each ground functional term f (a)
with a new constant af .

More precisely, we define an operator  on the set
of terms, producing a term, as follows, where af is a
new, globally unique constant (i.e. for a pair of a and f,
there is a unique constant af ), and xf is a new, globally
unique variable:

(t) =


if t = a
if t = f (a)
if t = x
if t = f (x)

af

xf

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

We extend  to ALCHIQ-closures such that, for
a closure C, (C) is the following function-free
closure:

1. Each term t in C is replaced with (t).
2. For each variable xf introduced in the previous step,

the disjunct Sf (x, xf ) is appended to C.

3. If, after steps 1 and 2, some variable x occurs in
a positive literal, but not in a negative literal, the
disjunct HU(x) is appended to C.

Let FF(KB)=FF(KB)  FFSucc(KB)  FFHU(KB)
 (KBA) denote the function-free version of (KB),
where FF, FFSucc and FFHU are defined as follows:
FF(KB) = {(C)| C  SatR(TRg)}
FFSucc(KB) =

{Sf (a, af )| for each a and f from (KB)}

FFHU(KB) =

{HU(a)| for each a from (KB)} 
{HU(af )| for each a and f from (KB)}

Intuitively,  replaces each term of the form f (a)
with a new constant af and, for each constant a and
each function symbol f, FF(KB) contains an assertion
Sf (a, af ) stating that af is an f-successor of a. Fur-
thermore, each term f (x) in a closure is replaced with
xf , and the literal Sf (x, xf ) is appended to the clo-
sure. Hence, the fact that f (x) is the f-successor of x is
encoded in Sf . These transformations are sufficient to
simulate ground functional terms with new constants.
We explain this on a simple example. Consider the following knowledge base KB:

(1)

(2)

(3)

C(x)  R(x, f (x))

R(a, b)
R(x, y1)  R(x, y2)  y1 y2

Furthermore, consider the following BS+

DL inference in KB (we disregard markers in the conclusion):

C(a)  f (a) b

(4)

resolve (3) + (1) + (2)

The set of function-free closures FF(KB), computed according to the above definition, consists of

the following closures:

(5)

(6)

(7)

(8)

Sf (a, af )

C(x)  R(x, xf )  Sf (x, xf ) = (1)
R(a, b) = (2)
R(x, y1)  R(x, y2)  y1 y2 = (3)

Now the above inference of (4) can be simulated in
FF(KB) as shown below, where the inference deriving (9) performs a lookup for the successor in the
predicate Sf . Observe that (10) corresponds to the result of applying  to (4), i.e. it contains af instead of
f (a). Hence, we say that the functional term f (a) is
simulated with a new constant af .

(9)

(10)

C(a)  R(a, af )
C(a)  af b

By considering all inferences of BS+

resolve (5) + (6)
resolve (8) + (7) + (9)
DL, it is possible
to see that, for each closure C derived in the saturation of   (KBA), one may derive a closure (C)
from FF(KB). Hence, if the empty closure is derived
by saturation of   (KBA), it can also be derived
by saturation of FF(KB).

In a similar way it is possible to show the converse
as well, i.e. if a closure C is derivable by saturating
FF(KB), it is possible to derive the closure D from
  (KBA) such that C = (D).
Lemma 2. KB is unsatisfiable if and only if FF(KB)
is unsatisfiable.

5.3.3. Conversion to a disjunctive program

Since FF(KB) does not contain functional terms and
all its closures are safe, we can rewrite each closure into
a disjunctive rule by moving positive literals into the
head, and negative literals into the body of the rule. We
use DD(KB) for the result of this rewriting. The following theorem summarizes the propertiesof DD(KB):

Theorem 3. For KB a SHIQ knowledge base, the
following claims hold:

1. KB is unsatisfiable iff DD(KB) is unsatisfiable.
2. KB |=  iff DD(KB) |=c , for  of the form A(a)
or S(a, b) with A an atomic concept and S a simple
role.

3. KB |= C(a) iff DD(KB  {C  Q}) |=c Q(a), for
C a non-atomic concept, and Q a new atomic
concept.
4. Let |KB| be the length of KB with numbers in number restrictions coded in unary. The number of rules
in DD(KB) is at most exponential in |KB|, the number of literals in each rule is at most polynomial in
|KB|, and DD(KB) can be computed in time exponential in |KB|.

5.4. Adding DL-safe rules

Satisfiability of (KB, P) can be decided by saturat-
DL, where we extend the selecDL to select all non-DL-atoms. We

ing (KB)  P by BS+
tion function of BS+
have the following lemma:

Lemma 3. For an ALCHIQ knowledge base KB, saturation of (KB)  P by BS+
DL decides satisfiability
of (KB, P).
Since each rule r  P is DL-safe, each variable
in r occurs in a negative non-DL-atom, which is se-
lected. Hence, each non-ground rule r can be resolved
only on non-DL-atoms. Furthermore, a rule can participate as a side premise in hyperresolution only if
it does not contain negative atoms; since rules are
safe, side premises are ground. All non-DL-atoms
contain initially only constants (i.e. they do not contain functional terms), and all variables from r occur in non-DL-atoms in the body. Hence, a hyperresolution with r produces a ground closure containing only constants. Such a closure can participate
in inferences with non-ground closures from (KB)
in exactly the same way as in Lemma 1. Hence,
adding DL-safe rules does not change non-ground inferences of BS+
DL, and it simply produces new ground
closures.

It is now easy to see that Lemma 2 holds even if DLsafe rules are added since such rules do not participate
in non-ground inferences used to compute  . Further-
more, for each ground closure C derivable by saturating
  (KBA)  P, the closure (C) can be produced
from FF(KB)  P, and vice versa. This yields the following theorem:

and (ii) (KB, P) |=  if and only if DD(KB)  P |=c ,
for  a DL-atom A(a) or S(a, b) with S a simple role,
or  a ground non-DL-atom.

5.5. Evaluating queries in a disjunctive program

Answering queries in disjunctive programs is computationally more expensive than in non-disjunctive
programs [7]. Furthermore, if disjunction is not used in
a knowledge base, our algorithm should not introduce a
performance penalty. To address that, we have devised
an algorithm for evaluating queries in a disjunctive program P, which we outline next. This algorithm allows
to compute all answers to a query in one pass, and
does not require testing each possible ground answer
separately.

With P we denote the datalog program containing rules (11)(14), where (11) is instantiated for
each individual in P, and (14) is instantiated for each
predicate symbol R occurring in P. (Notice that it is
not necessary to instantiate (14) for R =  , since
such a rule logically follows from symmetry and
transitivity.)
a a
x y  y x
x z  x y, y z
R(x1, . . . , x!
 R(x1, . . . , xi, . . . , xn), xi x!

i, . . . , xn)

It is well-known [9] that P  P , where is treated
as an ordinary predicate, entails the same set of consequences as P, where  is taken to have the usual
semantics of equality.
Now for a query predicate Q and a program P without equality, computing all Q(a), such that P |=c Q(a),
can be performed as follows.

(11)

(12)

(13)

(14)

Definition 6. For a predicate symbol Q, let RQ denote
the standard ordered resolution calculus parameterized
as follows: (i) all negative literals are selected, and (ii)
all ground atoms of the form Q(a) are smallest in the
ordering  .

Theorem 4. Let KB be a SHIQ knowledge base and
P a DL-safe disjunctive program. Then (i) (KB, P) is
satisfiable if and only if DD(KB)  P is satisfiable;

Any lexicographic ordering where Q is the smallest predicate symbol is compatible with Definition 6.
As shown by the following lemma, saturating P by

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

RQ computes all ground consequences involving Q.
Observe that the restriction that Q does not occur
in the body of some rule is not really a limita-
tion: one can always introduce a new predicate AQ,
add the rule AQ(x)  Q(x), and use AQ for query
answering.

Lemma 4. Let P be a satisfiable disjunctive datalog
program and Q a predicate not occurring in the body of
any rule in P. Then P |=c Q(a) if and only if Q(a)  N,
where N is the set of clauses obtained by saturating P
under RQ up to redundancy.

Namely, P |=c Q(a) if and only if the empty clause
can be derived by saturating P  {Q(a)} by RQ.
Since P is satisfiable, the empty clause is not derived
by saturating P alone. Furthermore, since Q does not
occur in a body of any rule in P, Q occurs negated
only in Q(a). Hence, in saturating P  {Q(a)},
the only inference preformed in addition to the case
when P is saturated alone is a hyperresolution with
Q(a). However, the literals Q(a) are minimal, so
the empty clause can be derived only if saturation
of P derives Q(a). In [18], we show that, assuming
unary coding of numbers and a bound on the arity
of the non-DL-predicates, saturation of DD(KB)  P
can be performed in time exponential in |KB|, which
makes our query answering algorithm worst-case
optimal.

Apart from the fact that this algorithm computes
all non-ground consequences related to Q in one
pass, this algorithm has another interesting property.
Namely,
instead of performing an inference with
each literal of a ground disjunction, it is sufficient
to perform inferences only with the maximal literal.
This dramatically reduces the number of inferences
to be performed. Furthermore, if the program is not
disjunctive, then hyperresolution becomes exactly the
least fixpoint operator used to evaluate non-disjunctive
its consequences can be computed for
programs;
non-disjunctive programs in polynomial
time, so
we get tractable behavior. In this way our algorithm
supports the principle of graceful degradation: a
performance penalty is paid only for features actually
used.

Finally, we note that evaluating queries can be further optimized by using the magic sets transforma-
tion. In its basic form for Horn programs [5], magic
sets transformation reduces the amount of irrelevant

computation by simulating the binding propagation of
top-down SLD-resolution. This technique has recently
been extended to disjunctive programs [11], and has
shown significant benefits in practice. Magic sets transformation is not tied to the query evaluation method,
and therefore can be used in conjunction with query
answering by the RQ calculus.

5.6. Example

To help in understanding the material presented, we
now give a simple example. Let KB be the following
knowledge base:

(15)

 2 hasChild  TaxCut

People with  2 children get a tax cut.

Man  Woman  

(16)

Men and women are disjoint.

(17)

(18)

motherOf .  Woman

Mothers are women.

hasChild.(motherOf .)(Peter)
Peter has a child who is a mother.

(19)

hasChild(Peter, Paul)

Peter has a child Paul.

(20)

Man(Paul)

Paul is a man.

Now KB entails TaxCut(Peter), and here is why:
the unnamed child of Peter implied by (18) is a mother
of someone, so this unnamed child of Peter must be
a woman by (17). Furthermore, this unnamed child
must be some other child than Paul, since Paul is
a man. Hence, Peter has at least two children, so
he is eligible for a tax cut. Let us now show how
this conclusion can be drawn by reducing the knowledge base to disjunctive datalog. First, (18) contains
a non-atomic concept hasChild.(motherOf .), so
we replace it with a new atomic concept Q1. Fur-
thermore, hasChild.(motherOf .) contains a subconcept motherOf ., so we introduce a new con-

cept Q2 for it. Hence, (18) is replaced with these
axioms:

(21)

(22)

(23)

Q1(Peter)
Q1  hasChild.Q2
Q2  motherOf .

We now compute (KB) by simply translating all
axioms into first-order logic. We define the precedence
relation >P for the LPO as follows:

g > P f > P

Peter > P Paul > P

Woman > P Man > P TaxCut > P motherOf > P
hasChild > P Q2 > P Q1

Below are the closures from (KBT), where literals
eligible for inferences have been underlined (they are
either selected or maximal):

(24)

(25)

(26)

(27)

(28)

(29)

TaxCut(x)  hasChild(x, y1)
hasChild(x, y2)  y1 y2
Man(x)  Woman(x)
motherOf (x, y)  Woman(x)
Q1(x)  hasChild(x, f (x))
Q1(x)  Q2(f (x))
Q2(x)  motherOf (x, g(x))

Now we apply the inference rules of the basic superposition calculus to saturate the TBox (we show only
non-redundant consequences):

(30)

(31)

Q2(x)  Woman(x)
Q2(x)  Man(x)

resolve (26) and (29)

resolve (30) and (25)

We now eliminate function symbols from the saturated set by applying the operator  to obtain the following datalog program:
TaxCut(x)  y1 y2

(32)  hasChild(x, y1), hasChild(x, y2) = (24)
 Man(x), Woman(x) = (25)
Woman(x)  motherOf (x, y) = (26)
hasChild(x, xf )  Q1(x), Sf (x, xf ) = (27)

(34)

(35)

(33)

(36)

(38)

(37)

Q2(xf )  Q1(x), Sf (x, xf ) = (28)
motherOf (x, xg)  Q2(x), Sg(x, xg) = (29)
Woman(x)  Q2(x) = (30)
 Man(x), Q2(x) = (31)
Since there are no unsafe rules, there is no need to
append the Herbrand universe declarations. We merely
append the ABox clauses and the definitions of Sf and
Sg:

(39)

(40)

(41)

(42)

(43)

(44)

(45)

(46)

Q1(Peter)

hasChild(Peter, Paul)

Man(Paul)

Sf (Peter, Peterf )

Sf (Paul, Paulf )

Sg(Peter, Peterg)

Sg(Paul, Paulg)

To answer the query ?  TaxCut(x), we apply the
algorithm from Section 5.5, where all literals involving
the predicate TaxCut are smallest. As a result, in (52)
we indeed deduce that Peter gets a tax cut.

(47)

(48)

hasChild(Peter, Peterf )

resolve (35) + (40) + (43)

Peterf Paul  TaxCut(Peter)

resolve (32) + (41) + (47)

(49)

Sf (Peter, Paul)  TaxCut(Peter)

(50)

(51)

(52)

superpose (48) into (43)
Q2(Paul)  TaxCut(Peter)
resolve (36) + (40) + (49)

Woman(Paul)  TaxCut(Peter)

resolve (38) + (50)

TaxCut(Peter)

resolve (33) + (42) + (51)

B. Motik et al. / Web Semantics: Science, Services and Agents on the World Wide Web 3 (2005) 4160

6. Related work

AL-log [6] combines a TBox and ABox expressed
in the basic description logic ALC with datalog rules,
which may be constrained with unary atoms having
ALC concepts as predicates in the body. Query answering in AL-log is decided by a variant of constrained
resolution, combined with a tableaux algorithm for
ALC. The combined algorithm is shown to run in single non-deterministic exponential time. The fact that
atoms with concept predicates can occur only as constraints in the body makes rules applicable only to explicitly named objects. Our restriction to DL-safe rules
has the same effect. However, our approach is more
general in the following ways: (i) it supports a more
expressive description logic, (ii) it allows using both
concepts and roles in DL-atoms and (iii) DL-atoms
can be used in rule heads as well. Furthermore, we
present a query answering algorithm as an extension of
deductive database techniques running in deterministic
exponential time.

A comprehensive study of the effects of combining datalog rules with description logics is presented in
[22]. The logic considered is ALCNR, which, although
less expressive than SHIQ, contains constructors that
are characteristic of most DL languages. The results
of the study can be summarized as follows: (i) answering conjunctive queries over ALCNR knowledge bases
is decidable, (ii) query answering in the extension of
ALCNR with non-recursive datalog rules, where both
concepts and roles can occur in rule bodies (but not
in rule heads), is also decidable, as it can be reduced
to computing a union of conjunctive query answers,
(iii) if rules are recursive, query answering becomes
undecidable, (iv) decidability can be regained by disallowing certain combinations of constructors in the
logic, and (v) decidability can be regained by requiring rules to be role-safe, where at least one variable
from each role literal must occur in some non-DL-
atom. As in AL-log, query answering is decided using constrained resolution and a modified version of
the tableaux calculus. Besides the fact that we treat a
more expressive logic, in our approach all variables
in a rule must occur in at least one non-DL-atom, but
concepts and roles are allowed to occur in rule heads.
Hence, when compared to the variant (v), our approach
is slightly less general in some, and slightly more general in other aspects.

The Semantic Web Rule Language (SWRL) [15]
combines OWL-DL with rules in which concept and
role predicates are allowed to occur in the head and in
the body, without any restrictions. Hence, apart from
technicalities such as allowing concept expressions to
occur in the rules, the formalism is compatible with DL
rules. As mentioned before, this combination is undecidable but, as pointed out by the authors, (incomplete)
reasoning in such a logic can be performed using general first-order theorem provers. DL-safe rules are a
proper subset of SWRL, where some expressivity is
traded for decidability. Hence, our approach provides
an optimal query answering algorithm covering a significant portion of SWRL.

In [8] an approach for combining answer set programming with description logics is presented. The
interaction between the subsystems is enabled by exchanging only unit (i.e. non-disjunctive) ground consequences between the two components. The set of
derivable facts is obtained by fixpoint computation.
In this approach, the two systems are not tightly integrated since interaction between the systems is performed only through the exchange of consequences. As
a consequence, the resulting semantics is incompatible
with the first-order semantics; for example, the fact that
Oedipus is a child cannot be derived from the fact that
he is a GoodChild or a BadChild!
, c.f. our example at
the end of Section 4.3.

The approaches from [12,30] for reducing certain
fragments of description logics to logic programming
can easily be extended with rules, by simply appending the rules to the result of the transformation. How-
ever, the description logic considered there does not
support existential quantifiers, negation, or disjunction
under positive polarity, so it is significantly less expressive than SHIQ(D). Hence, our approach is a proper
extension.

7. Summary and outlook

We have presented an approach for extending
OWL-DL with DL-safe rules which yields a logic with
decidable reasoning algorithms. Instead of reducing
the component formalisms, we reduce the interface
between them. As a consequence, rules apply only to
individuals explicitly introduced in the ABox. We have
discussed the effects of such a definition on a non-

trivial example, which also shows that our approach
increases the expressivity of its two components.

Besides a decidability result for SHOIN with DLsafe rules, we have presented a practical algorithm for
answering queries over SHIQ extended with DL-safe
rules. This algorithm transforms a SHIQ knowledge
base into a disjunctive program. To attenuate the increased computational complexity introduced by using
disjunctive programs, we developed a query answering algorithm which supports the principle of graceful
degradation: the user only pays a performance penalty
for the features actually used in a knowledge base. Due
to space constraints, in this paper we have only presented an algorithm for SHIQ knowledge bases; we
present an extension to SHIQ(D) in [18]. Since this
algorithm handles OWL-DL apart from nominals, we
believe it provides a good foundation for extending Semantic Web ontology languages with rules.

In our future work, we shall investigate how to
extend the reduction algorithm to support all of
OWL-DL. Furthermore, we are currently implementing the algorithms presented here in KAON2, a new
hybrid reasoner,3 for which we shall conduct a thorough performance evaluation.

Acknowledgement

This work was partially funded by the EU IST

project DIP 507483.
