Towards Constructive Evidence of Data Flow-Oriented

Web Service Composition

Freddy L ecu e

IBM Research, Smarter Cities Technology Centre

Damastown Industrial Estate, Dublin, Ireland
firstname.lastname@ie.ibm.com

Abstract. Automation of service composition is one of the most interesting challenges facing the Semantic Web and the Web of services today. Despite approaches which are able to infer a partial order of services, its data flow remains
implicit and difficult to be automatically generated. Enhanced with formal rep-
resentations, the semantic links between output and input parameters of services
can be then exploited to infer their data flow. This work addresses the problem of
effectively inferring data flow between services based on their representations. To
this end, we introduce the non standard Description Logic reasoning join, aiming
to provide a constructive evidence of why services can be connected and how
non trivial links (many to many parameters) can be inferred in data flow. The
preliminary evaluation provides evidence in favor of our approach regarding the
completeness of data flow.

Keywords: Semantic Web, Web Service, Service Composition, Data Flow,
Automated Reasoning, Non Standard Reasoning.

1 Introduction

The Semantic Web [1] is considered to be the future of the current Web. In the Semantic Web, Web services [2] are enhanced using rich description languages e.g., OWL
the Web Ontology Language [3]. The underlying descriptions, expressed by means of
Description Logic (DL) concepts [4] in domain ontologies, are used to describe the
semantics of services e.g., their functional inputs, outputs parameters. Intelligent software agents can, then, use these descriptions to reason about Web services and automate
their use to accomplish goals specified by the end-user including intelligent tasks e.g.,
discovery, selection, composition and execution.

We focus on composition and more specially on its data flow i.e., links (or con-
nections) which explain how data is exchanged among services (Right Panel in Fig.1).
While most approaches [5, 6] derive control flow of compositions (i.e., a partial order
on services - Left Panel in Fig.1) according to a goal to achieve, its data flow remains
implicit [7] through opaque and pre-defined assignments from incoming to outgoing
services. Usually it is up to developers to provide their details e.g., through BPEL
(Business Process Execution Language) assign types or filtering/merging operators.

 The research leading to these results has received funding from the European Unions Seventh
Framework Programme (FP7/2007-2013) under grant agreement ID 318201 (SIMPLI-CITY).

H. Alani et al. (Eds.): ISWC 2013, Part I, LNCS 8218, pp. 298313, 2013.
c Springer-Verlag Berlin Heidelberg 2013
?

?

?
Existing approaches mainly focus in ordering services in a control flow rather than generating its data flow in an automated way. The latter limits flexibility of service oriented
computing [8]. Therefore the following are example of open questions in the Web of
service community: how to dynamically re-generate data flow specification of built-in
compositions in case of late change of services? Which data is required from which services to turn a composition in its executable state? Does it require data transformation
from one description to another? This work investigates the benefits of having semantic
descriptions of services a la SA-WSDL [9], OWL-S [10] or WSMO [11] to derive a
data flow description of any control flow-based service composition in an automated
way.

Towards these issues, some methods [12] exploit expressive DLs to link services
through their descriptions, impacting the tractability of the approach. Other approaches
[13] limit the expressivity of description through syntactic representation, making data
flow very difficult to be automatically derived. In both contexts, complex data links
(e.g., filtering, merging) between services cannot be generated in an automated way,
providing either abstract or incomplete composition specification. Despite some efforts
for pre-defining [14] and inferring [15, 16] compatibilities between services parame-
ters, it remains difficult to derive how data is actually flowing from one description
to another. In addition, data flow is mainly studied between single outputs and inputs
(aka. trivial links). Such links are not appropriate for modeling data flow of complex
compositions, limiting their application in real world scenarios. This work tackles this
problem.

s1

s2

s4

s: Service

Control FLow

s3

s6

s2

s1

s3

s6

s5

Non Trivial
Links

s4

Input Parameter
Trivial Links

s5

Output Parameter

Fig. 1. Control Flow (Left) vs. Data Flow (Right) Views

Suppose some Semantic Web services1 being organized in a partial order (based on
their overall goals): how to effectively infer their non trivial data flow (e.g., filtering,
merging). First of all we define non standard DL reasoning join to provide a con-
structive evidence of why services can be connected and how non trivial links can be
inferred in data flow. The concept join is required to exhibit descriptions J from output
parameters Out (of services) which properly ensure Out to be compatible with any
input parameter In (of services). In other words the description J is constructed for
glue-ing outputs and inputs parameters of services, and more importantly used for

1 Polymorphic services (i.e., exposing several functions depending on inputs combinations) are

not investigated here, but can be addressed though conditional compositions [6].

F. L ecu e

understanding how data is flowing among services in a composition. Then we describe
how non trivial data flow can be generated, checked and repaired using concept join in
order to ensure flexible data flow construction. Service descriptions are formalized in
EL++, where subsumption and satisfiability are decidable [17]. For the sake of clarity,
we assume compositions without open preconditions. Our work assumes that relevant
services are already identified and discovered [18]. Control [7] and data flow [19] based
composition techniques, combined with the method introduced in the paper, are then
applied to derive ready-to-be-executed compositions.

The remainder of this paper is organized as follows. First of all we summarize data
flow-oriented composition, its semantic links and limits. Then we present the DL reasoning join to provide a constructive evidence of why services can be connected. The
next sections (i) describe how join can be adapted to simulate and construct complex
data flow, and (ii) report some experimental results through comparisons with state-of-
the-art approaches. Finally we comment on related work and draw some conclusions.

2 Data Flow-Oriented Service Composition

2.1 Service, Semantic Link and Composition

In the Semantic Web, input and output parameters of services are described according to a common ontology or Terminology T (e.g., Fig.2), where the OWL-S profile,
WSMO capability or SA-WSDL can be used as encoding2, also known as fixed data
type or description. Semantic links [19] are defined between output and input parameters of services, based on semantic similarities of their DL encoding. Fig.2 sketches a
description of the axioms that are used in the ontology in which the input and output
parameters are expressed. Similarities are judged using a matching function between
two knowledge representations encoded using the same terminology.

N etwConnection  netSpeed.Speed // Netw: NetworkConnection
Speed   mBytes.N oN ilSpeed, HighReliable  Reliable
SlowN etwConnection  N etwConnection  netSpeed.Adsl1M
U SP rovider  to.U S, U KP rovider  to.U K, U K  U S  
EU P rovider  to.EU, U K  EU, EU  U S  , Business  
Adsl1M  Speed   mBytes.1M,
Fig. 2. DL EL++ Axioms used for representing Output and Input Parameters

1M  N oN ilSpeed

In this context, data flow-oriented service composition consists in retrieving semantic

links sli,j:

.= si, SimT (Out, In), sj

sli,j

(1)

between an output parameter Out of service si and input parameter In of service sj,
where both Out and In are DL descriptions. Thereby si and sj are partially linked

2 In case of multiple ontologies used for services descriptions, alignment techniques [20] need

to be investigated.
?

?

?
according to a matching function SimT , specifying its data flow. Given a terminology
T , the range of SimT is determined by five matching types following [21, 22]: i) Exact
i.e., Out  In, ii) PlugIn i.e., Out  In, iii) Subsume i.e., In  Out, iv) Intersection
i.e., (Out  In  ) and v) Disjoint i.e., Out  In  . The cases i)-iv) identify compatible descriptions while the case v) identifies incompatible descriptions Out
and In.

2.2 Limitations

As stated in Introduction, models such as (1) are mainly considered for representing
trivial semantic links i.e., (boolean) one-to-one compatibility (though matching types)
between single output and input parameters. Towards this issue, we generalize (1) by
considering In and Out respectively as a conjunction of inputs and outputs of services.
Semantic links between any output and input at a time i.e., non trivial data flow, can
be then represented in (1), which is more appropriate for modeling complex data flow.
However such a model is still limited to understand how data is flowing from
services to services. Indeed, how data is properly manipulated and adapted between
services to ensure data flow? Which part of services descriptions is the most relevant?
Is it maximal, minimal, effective and how? These are general questions which remain
open in the join domains of Semantic Web and Web of services.

This work suggests concept join as a constructive reasoning to provide a construc-
tive evidence of why services can be connected and how complex data flow can be
inferred in services composition.

3 Towards Constructive Evidence of Data Flow

Towards the issue of explaining why services can be connected and how non trivial
links can be inferred in data flow, Section 3.1 introduces the innovative concept join
(Definitions 1, 2 and Propositions 1,2) between data descriptions. Section 3.2 follows
the methodology of [23] and [24] to prove the computational complexity of the join rea-
soning. In particular Proposition 3 is inspired from [23], but highly adapted to concept
join (which constructs different descriptions - see Section 6.2). Section 3.3 combines in
an innovative way state-of-the-art abduction (Definition 3) and contraction (Definition
4) reasoning techniques to extend the applicability of concept join in a (i) context of
service composition, and (ii) when Proposition 1 does not hold (Algorithm 2). Impor-
tantly, Section 3.3 explains how non standard reasoning abduction and contraction can
be used for enriching the number of joins between services in a composition.

3.1 Concept Join: Definitions and Propositions

We are interested in descriptions in Out which ensure Out and In to be compatible.
Therefore we aim at extracting J (Join - Definition 1) from Out such that J  In
remains true in T (Definition 1). The descriptions R (Remainder), part of Out, such
that Out  R  J will need to be removed from Out since they move Out away from
In under subsumption T . J highlights descriptions which could be properly joined

F. L ecu e

with In in order to compose outputs Out and inputs In while R points out descriptions
which are not required by In.

Definition 1 (Concept Join)
Let L be a DL, Out, In be two concepts in L, and T be a set of axioms in L such
that T |= Out  In  . A Concept Join Problem, denoted as CJPL, Out, In,T 
(shortly Out  In) is finding a pair of concepts R, J  L  L such that i) T |=
Out  R  J and ii) T |= J  In. Then J (or J ), which is not symmetric, is a join
between Out and In in T .

We use P as a symbol for a CJP L, Out, In,T  and we denote with SOLCJP (P)
the set of all solutions of the form R, J to a CJP P. In case T |= Out  In, the
CJP P has no solution at all, as stated formally in Proposition 1.
Proposition 1. (No Solution of a CJP )
Let P = L, Out, In,T  be a CJP such that T |= Out  In. The set SOLCJP (P)
is defined by .
Proof. Since Out can be rewritten as R  J (condition (i) in Definition 1) with R = 
and J = Out without loss of generality, then T |= Out  In (Proposition 1) becomes
T |= J  In. The latter contradicts T |= J  In (condition (ii) in Definition 1), so no
possible solution of a CJP P in case T |= Out  In.

T |= Out  In implies that there is always the trivial solution , Out to a CJP

L, Out, In,T .
Proposition 2. (Trivial Solution of a CJP )
If Out  In in T then , Out  SOLCJP (L, Out, In,T ).

This case refers to an exact composition [25] of services si and sj: if we want to
proceed sj, all outputs Out of si are required (since J is defined by Out in Proposition
2) to achieve all input In of sj. Then, no description R has to be removed from Out.
On the other hand, when Out  In (i.e., T |= Out  In and T |= Out  In),
, Out is also one potential solution of the CJP problem. However, other solutions
with R not being  are possible. Obviously, in order to achieve a composition between
Out and In the first case (in Proposition 2) is in a much better shape than the second
one. Indeed all descriptions In, which are required by sj, are provided by Out. If we
want to use join to highlight the closest descriptions in Out (i.e., the most general) to
In, emphasising the most compatible descriptions in Out for In to compose si and sj,
effective joins under T need to be defined (Definition 2 adapted from [26]).
Definition 2 (Effective Join Solution)
Let P = L, Out, In,T  be a CJP . The set SOLCJP(P) is the subset of
SOLCJP (P) whose join concepts J are maximal under T . The set SOLCJP(P)
is the subset of SOLCJP (P) whose join concepts have minimum length.

Formally the set SOLCJP(P) satisfies both Definition 1 and the following con-
  J.
dition: R
Maximality under T is considered as a effectiveness criterion since no unnecessary
joins is assumed between Out and In.

  L  L : T |= Out  R

  In  J

  T |= J

  J
?

?

?
, J
?

?

?
Example 1 (Effective Join Solution - Fig.3)
Let s1 be an InternetEligibilityservice which returns as output Out: the NetworkConnection (e.g., Speed, UK Country) of a desired geographic zone together with
information about its network provider (Reliability, Business type). Let s2 be another telecom service which requires a Reliable network provider in UK as input In to be executed.
Out and In, as DL representations of functional parameters in Fig.3, ensure Out  In
in T . On the one hand netSpeed.Adsl1M  to.U K  N etwConnection. On
the other hand HighReliable  Reliable. In other words some outputs produced by s1
can be consumed by some inputs of s2. The effective join J of Out and In (under T ) is
netSpeed.Adsl1M  to.U K  HighReliable while the discarded description R is
Business. An instance of J is then required to instantiate In (and execute s2): SlowN C
(N C refers to N etwConnection), to.U K, Reliable while an instance of Business
is not. The description J acts as a filter between s1, s2 to restrict Out over the data flow.
In other words J establishes which descriptions are relevant to link Out to In. The two
output instances of s1 are then practically merged into one instance for s2 through the
construction of J.The latter ensures the executability of s2.

t
u
p
n

a
t
a

d
n
a

n
o
i
t
p
i
r
c
s
e

s: Service

s1

t
u

netSpeed.Adsl1M
 to.U K

Join

HighReliable

 Business Discarded

Detailed Semantic Link

N C  netSpeed.Adsl1M

 to.U K
 Reliable

In

s2

Input Parameter

Output Parameter

Fig. 3. Effective Join Solution

In [26] it was proven that -minimality is more appropriate for conciseness, but
largely depending on T . Indeed, by simply adding axioms A  R and B  J, we
obtain a -minimal solution A, B for each pair R, J  SOLCJP (P).

3.2 Computational Complexity

Since concept join can be considered as an extension of concept subsumption with
respect to a TBox, its lower bounds carry over to decision problems related to a CJP .

Proposition 3. (Deciding Existence of Join)
Let P = L, Out, In,T  be a CJP . If concept subsumption with respect to a T in L
is a problem C-hard for a complexity class C, then deciding whether a pair of concepts
R, J  L  L belongs to SOLCJP (P) is C-hard.
Proof. Since T |= Out  In iff , Out  SOLCJP (P), such a problem is C-hard.
In our EL++ context, deciding whether a pair of concepts R, J belongs to SOLCJP (P) is PTIME-hard [27] with respect to both acyclic and cyclic TBoxes T .
Regarding upper bounds, a simple result can be derived from the fact that , Out
is always a solution of the CJP L, Out, In,T  if Out  In in T (Proposition 2) although not always an effective one for join. Following [23], a total length-lexicographic

F. L ecu e

order lex can be defined over concepts as follows: given two concepts Out, In  L,
let Out lex In if either |Out| < |In|, or both |Out| = |In| and Out is lexicographically before In. Based on this total order, an approach for finding a -minimal solution
of a CJP , using polynomial space relatively to an oracle for subsumption in L, is presented in Algorithm 1. Algorithm 1 is innovative as it enumerates concept join solutions
over a total length-lexicographic ordered concepts.

Algorithm 1. Effective J of a CJP
1 Input: A CJP P = L, Out, In,T  with T |= Out  In.
2 Result: A concept x  L such that R, x  L  L is in SOLCJP(P).
3 begin

x  ; // Initialisation
while |x| < |Out| do

if T |= Out  x and T |= x  In then
x  next concept following x in lex;

return x;

x  Out; return Out;

Algorithm 1 uses polynomial space (considering one call to subsumption as an ora-
cle) since it just tries all concepts with less symbols than Out, and returns Out if it does
not find a shorter solution. Thus, it provides an upper bound on the complexity of CJP ,
depending on the complexity class to which subsumption in L belongs to. Although this
result does not directly lead to a practical algorithm, it provides an upper bound on the
complexity of the problem, hence on the complexity of every optimal algorithm.
Theorem 1. (Finding a Solution in SOLCJP(P))
Let P = L, Out, In,T  be a CJP . If concept subsumption with respect to a T in
L belongs to a complexity class C that is included in PSPACE then finding a pair of
concept in SOLCJP(P) is a problem in PSPACE. Otherwise if PSPACE is included
in C, then finding a pair of concept in SOLCJP(P) is a problem in C.

According to Theorem 1, inspired from [26], finding a pair of concept for the problem SOLCJP(P ) in EL++ is in PSPACE. Theorem 1 simply builds on top of the
subsumption properties.

3.3 Incompatible Descriptions in Concept Join
As highlighted by Proposition 1, Definition 1 has no solution if T |= Out  In.
This limits the applicability of concept join by restricting services to exchange data
(from Out to In) only under Out  In in T . Even if this is a basic requirement to
compose and join services, other potential compositions, which do not satisfy Out 
In [25], would be ignored since their join cannot be derived. Towards this issue, we
exploit constructive DL reasoning abduction [28] (Definition 3) and contraction [24]
(Definition 4) to respectively consider join if i) In does not subsume Out but have a
consistent conjunction i.e., T |= Out In   and ii) their conjunction is inconsistent
?

?

?
i.e., T |= OutIn  . While concept abduction derives description which is missing
in Out to be subsumed by In, concept contraction [24] retracts specification G (for Give
up) in Out to obtain a concept K (for Keep) such that K  In is satisfiable in T . The
latter extends abduction to unsatisfiable conjunction of Out and In.

Definition 3 (Concept Abduction)
Let L be a DL, Out, In be two concepts in L, and T be a set of axioms in L such that
T |= Out  In  . A Concept Abduction Problem: In\Out is finding a concept
H  L such that T |= Out  H  , and T |= Out  H  In.

Similarly to concept join, abduction extends subsumption. It also constructs a concept H to ensure Out  H be subsumed by In. By computing description H using
abduction, join can be derived between Out  H (instead of Out) and In. Abduction is then required to enlarge the scope of Definition 1 i.e., from Out  In to
(Out  In  ) in T .
up) in Out to obtain a concept K (for Keep) such that K  In is satisfiable in T .

Contraction, which extends satisfiability, aims to retract specification G (for Give

Definition 4 (Concept Contraction)
Let L be a DL, Out, In be two concepts in L, and T be a set of axioms in L where both
Out and In are satisfiable in T . A Concept Contraction Problem, denoted as InOut
is finding a pair of concepts G, K  L  L such that T |= Out  G  K and
T |= K  In  . Then K (or K) is a contraction of Out according to In and T .
By computing (1) contraction K: a part of Out which ensures K  In to be satisfiable in T (i.e., validating conditions of Definition 3), and then (2) abduction In\K
which ensures K(In\K)  In, join can be derived between K(In\K) and In.
Thus contraction can be applied to enlarge the scope of Definition 1: from Out  In
to Out  In   in T .

Algorithm 2 sketches the approach to enlarge the scope of Definition 1. It ensures
that Out and In can be joined by iteratively weakening and strengthening Out through
contraction and abduction. Besides the case already supported by Propositions 1 and 2
and its extension to Out  In (line 6), abduction (lines 10, 14) is applied if Out  In
is consistent (line 9) in T . Alternatively contraction (line 13) is required beforehand
(line 12). The most specific contraction is considered to obtain a description as close as
possible to Out. Thus, the join is derived between (1) Out and In in the trivial case
Out  In (line 6), (2) Out  (In\Out) and In if T |= Out  In   (line 9) and (3)
(InKOut)  (In\(InKOut)) and In if T |= Out  In   (line 12).
The complexity of Algorithm 2 is in PSPACE in EL++. Indeed lines 6, 9, 12 are
in PTIME [17], line 13 is in PTIME (Theorem 4 in [24]), lines 10, 14 are in PSPACE
(Theorem 1 in [28]), line 15 is in PSPACE (Theorem 1).

4 Composing Services with Concept Join

We present how concept join can be used to compose properly services through complex
data flow modelling.

F. L ecu e

4.1 Join-ing Data and Descriptions of Services

Compositions of any outputs Out with inputs In can be derived using Algorithm 2. The
data flow is established by joining their descriptions. In case their join cannot be derived
(lines 9 and 12), we apply contraction and abduction to identify data descriptions which
need to be removed/added from/to outputs Out of services with respect to inputs In.

Algorithm 2. Computing Join (Case T |= Out  In)
1 Input: A CJP P = L, Out, In,T .
2 Result: A pair R, J  L  L which is in SOLCJP(P).
3 begin

H  ; //Initialisation
// Trivial Case of Subsumption between Out and In.
if T |= Out  In then
; // Propositions 1, 2 and its Extension to Out  In.
// Extension to Consistent Conjunction | T |= Out  In.
else if T |= Out  In   then
H  In\Out; // Abduction
// Extension to Inconsistent Conjunction of Out and In.
else if T |= Out  In   then
Out  (InK Out); // Contraction
H  In\Out; // Abduction

R, J  SOLCJPL, Out  H, In,T ; // Min. Join
return R, J;

In some cases, Semantic Web services consumed and produced data that does not
fit its static semantic description, making semantics of data not as precise as it should
be. In this context, we proceed as following: (1) detecting the most accurate semantic
description of concrete data values following [20]), (2) expanding the domain ontology
with this new description, mainly for reasoning purpose, and (3) applying Algorithm 2
at run time to obtain joins. The steps (1) and (2) ensures that the reasoning at description
level (through Algorithm 2) is also valid at a lower (i.e., data) level. This case of nonalignment between data and their description justifies and reinforces the use of non
standard reasoning to capture composition. Indeed, more inconsistent joins could occur,
limiting the applicability of pure equivalence-based approaches [16].

4.2 Simulating Complex Data Flow Operators

Definition 1, as a way to identify (semantic) link-able descriptions in composition,
can be used to simulate/infer complex data flow operators e.g., Data Filter, Merge.
Their benefit is twofold: modeling and explaining how services and their data can be
properly manipulated and adapted in data flow-oriented composition. Contrary to [25,
16, 6], among others, automated generation, verification and repair of complex data
?

?

?
flow in composition can be enabled once integrated in a composition engine [29]. In the
following the symbol  will denote the problem in Definition 1 where both (i) effective
join solutions (Definition 2) and (ii) maximality under T are considered.
 Data Filter: [14] commonly used the data filter operator in data flow-oriented
service composition to i) extract some descriptions Y and ii) block the rest In from
an incoming description X with respect to a filter (description) Z (see illustration in
Fig.4). This operator is simulated by X  Z and its solution In, Y . X  Z since Z
is used as a filter for X. The effectiveness condition (Definition 2) is crucial to avoid
any undesired data in Y e.g., In. The more specific the filter Z (i.e., the closer to X),
the less descriptions blocked by Z (the least is ).
Example 2 (Data Filter - Fig.4 a))
Let Y be defined by to.U K and D be defined by Business. The descriptions Y and
D are respectively extracted and blocked from description X i.e., to.U K  Business
using the filter Z, defined by to.EU . Each data instance from X is split along Y and
D. Only instance of X is connected to Y .

 Data Merge: In [7] it is used to aggregate descriptions X1 and X2 into a description Y with respect to a filter Z (see illustration in Fig.4). If X1 and X2 are compatible,
this operator can be simulated by (X1X2)  Z and its solution In, Y . X1X2  Z
since Z is used as a filter for X1 and X2. In refers to descriptions which are blocked
from X1 and X2 with respect to Z. In case X1X2  Z, all descriptions from X1X2
are merged, ensuring In to be  i.e., none of descriptions in X1  X2 is blocked from
Y . A generalization to n descriptions to merge is straightforward.

Filter Z: to.EU
Y :
to.U K

to.U K
 Business

X:

X1:
X2:

netSpeed.Adsl1M
to.U K
 Reliable

Filter Z: netSpeed.Speed  to.U K

Y :
netSpeed.Adsl1M
 to.U K

D: Business
a) Data Filter

D: Reliable
b) Data Merge

Fig. 4. Simulation of Data Filter and Merge with Join

Example 3 (Data Merge - Fig.4 b))
netSpeed.Adsl1M  to.U K is the merging description of X1, X2 in Fig.4 b) using the filter netSpeed.Speed  to.U K while Reliable is the description which is
blocked.

Based on a straightforward extension of Algorithm 2 with effective concept join,
most common complex data flow operators e.g., Data Merge, Filter can be derived
in any data flow, modeling and explaining how services and their data are adapted.
Algorithm 2 can be also used to validate pre-defined links or complete existing ones.
More generally effective concept join can be used in any data-based application e.g., as
a way to retrieve instances of Z from a large set of data Y given some constraints X
i.e., Y  Z.

F. L ecu e

5 Experimental Results

In more details we analyze our approach (Algorithm 2 and its extension for data flow
simulation) by comparing its performance against existing approaches [57] along two
dimensions: (i) CPU time (in ms) to generate composition and (ii) completeness of
data flow. The second dimension is evaluated by computing the rate: data descriptions
connections retrieved against those expected in the optimal composition. This compo-
sition, which is manually constructed based on services descriptions and their goal, has
no open links (i.e., links reaching to a non executable process) and no redundant links.
The experiments have been conducted on Intel(R) Core (TM)2 CPU, 2.4GHz, 2GB
RAM.

Pistore et al. 2005
Hoffmann et al. 2009
Marconi, Pistore, and Traverso 2006
[OurApproach]

 1e+06

 100000

l

e
a
c

m
h

 

t
i
r
a
g
o

a
h

 

t
i

w

 
)
s
m

i

(
 
s
e
m
?

?

?
.

g
v

Number of services involved in Composition

Fig. 5. Computation Time of Composition Approaches

 Context: Compositions with up to 50 services have been extracted from [30] and
enriched using a commercial EL++ ontology (1100 concepts, 390 properties: 384 concepts subsume the 716 remaining ones with a maximal depth of 8). The semantic annotations are important for deriving data flow in our approach. SOUR3 is used for services
annotations. The annotation process is costly e.g., 8 person/hours for 50 services (with
an average of 5 inputs/outputs) with the latter ontology, but has a positive impact on
automation of compositions. For scalability purpose we guided the semantic link detection since each composition is bound by n  2n potential semantic links, with n be
the number of services. In more details we limited the number of Out (input of Algorithm 2) to be computed beforehand e.g., by ranking Out with respect to In (e.g.,
size of their contraction/abduction) and considering only Out which ensures to obtain
the top k contraction/abduction. The semantic link detection was required only by our
approach, mainly to (i) identify potential data flow in composition and (ii) avoid the
computation of an exponential number of join, which strongly reduce the overall computation time. The data flow requirements are formalized for [7] while only composition
goals are defined for [5, 6].

3 http://www.soa4all.eu/tools.html
?

?

?
 Results - Computation Time: Fig.5 illustrates the computation costs for constructing compositions with up to 50 services. Our approach is the most time consuming although (i) a control flow-based compositions is pre-defined and (ii) conjunctions
of outputs are considered satisfiable. Other approaches, generating control flow-based
compositions, are faster. The best approach [5] generates compositions of 50 services
in 7.2 seconds.
 Results - Data Flow Completeness: Fig.6 sketches the comparison of our approach vs. existing approaches. The same number of compositions has been retrieved
in all cases. The only difference is related to its data flow description. On average our
approach automatically derives 83% of the final data flow structure (i.e., data filter,
merge operators) of a data flow-free composition. The 17% remaining connections, are
cyclic-based data flow operators e.g., loop, which is not supported by our current im-
plementation. On average no more than 55% of connections are retrieved with the state-
of-the-art approach [7]. The approach of [5] generates an average of 9% of connections.
As reported by their authors, this is more appropriate for independent services.

s
n
o

i
t
c
e
n
n
o

a

 

t

 

a

d
e
v
e
i
r
t
e

f

o
 
)

%

t

(
 
e
a

Pistore et al. 2005
Hoffmann et al. 2009
Marconi, Pistore, and Traverso 2006
[OurApproach]

Number of services involved in Composition

Fig. 6. Data Flow Completeness

 Lessons Learned: Even if state-of-the art approaches are appropriate for fast elaboration of control-flow-based composition, they are not necessarily adequate for (i)
detecting connections between services and (ii) connecting their descriptions. The automated construction of complex data flow in EL++ DL has a negative impact on the
computation costs but ensures a finer description of compositions, which are ready for
execution. The size and the structure of the ontology have a limited impact. The main
factors for the increase of computation cost are (i) the expressivity of the DL and (ii)
the number of DL conjuncts (and their complexity) used to describe services. The reduction of its expressivity has a positive impact on scalability, but it also decreases the
completeness and quality of data flow. The scalability can be improved by considering only subsumption-based comparisons of descriptions (line 6), removing computation of abduction and contraction. In such a case the rate of data flow completeness is

F. L ecu e

also decreasing. By removing the abduction and contraction parts of Algorithm 2 (from
line 9 to 14), our approach is more scalable than state-of-the-art approaches, but only
55% of data flow description is retrieved. According to our experiments a best tradeoff is proposed in [7], while [5, 6] fits perfectly independent services with a better
scalability for [5].
 Limitations: The computed potential connections are all used for defining the data
flow of the composition. However if multiple services provide similar output (respec-
tively input) descriptions, they are all equally considered. All their output (respectively
input) descriptions are aggregated and subject to a join with other services. This case
falls in a special case of Data Merge (Fig.4 b where X1  X2, with X1 and X2 outputs of two distinct services). Additional manual efforts are required if such cases need
to be avoided, which were not foreseen in our applications.

6 Related Work

6.1 Data Flow-Based Semantic Service Composition

Fig.7 positions existing approaches in relation to 3 dimensions: control flow, data flow,
description expressivity. These dimensions aree used to structure the remainder of this
section.

Mash-up-based approaches [31, 13] and semantics-based methods [7, 32, 14], positioned in Front Cluster of Fig.7, achieve composition by linking services according to
different expressivity of static control flow and pre-defined data flow operators (with
explicit requirements). They are all limited by the expressivity of service descriptions.
Indeed the latter are constrained by RDF/S while the former support only basic XMLbased transformation. By embedding compositions with advanced control flow [7], the
data flow construction is reduced. [14] provide a more complete (pre-designed) panel of
data flow operators, such as Construct and Mix, which can be simulated by Definition
1, but support only RDF/S, focusing at instance level. Their applicability to expressive
semantics and the automated construction of data flow is then limited.

AI planning- [6, 33] and DL-based approaches [15, 12], positioned in Back Cluster of Fig.7) elaborate composition of services by reasoning on their descriptions. Despite higher expressivity, only sequence-based data flow is inferred. The approaches
of [15, 25, 32] are even more restrictive as they consider (specialized) semantic links
between one output and input. More elaborated operators have been presented by [16]
towards this issue. Contrary to our approach, data flow is based on concrete values and
not their semantic descriptions, which is more flexible for handling misalignment datadescription e.g., the instance defined by (hasConnection.ADSL512KBS) where
ADSL512KBS is a SlowN etwConnection partially respects the description Slow-
N etwConnection  to.U K. Indeed no instance of a provider is provided. We address it by using non standard reasoning. Other approaches simulate sequence [33] and
conditional-based [6], e.g., through forward effects for the latter, limiting the expressivity of compositions.
?

?

?
[Hoffmann et al., 2009] 

[McIlraith and Son, 2002]

[Lecue and Delteil, 2007]
[Hull et al., 2006]

[Ambite and Kapoor, 2007]

D escription E xpressivity

[Daniel et al., 2009]

[Krummenacher et al., 2010]

[Ennals et al., 2007]

[Ragone et al., 2007]

[Marconi et al., 2006]

[Phuoc et al., 2009]

y
t
i
v
i
s
s
e
r
p
x

w
o
l

l
o
r
t
n
o

Data Flow Operator Expressivity

Fig. 7. Classification of Data Flow-oriented Composition

6.2 Existing Constructive DL Reasoning

While abduction [26] derives description which is missing in Out to be subsumed by
In, concept contraction [24] retracts specification G (for Give up) in Out to obtain a
concept K (for Keep) such that KIn is satisfiable in T . The latter extends abduction to
unsatisfiable conjunction of Out and In. Approximate subsumption has been presented
by [34]. Such types of reasoning construct concepts which are missing or over-specified
in Out to be respectively (1) subsumed by and (2) consistent with In. Concept join
constructs more general concepts from Out which are subsumed by In. In particular,
its effective solutions (under T ) refer to the most general description of Out which
is subsumed by In. Abduction and approximate subsumption extend Out while join
extracts a part of Out for the same objective i.e., being subsumed by In. If Out  In,
abduction, contraction and approximate subsumption do not construct any description
while concept join does. It explains the way they are joined.

Subsumption between DLs concepts Out and In can be explained by deriving its
formal proof (i.e., which descriptions in In subsume which descriptions in Out) in
[35]. Concept join does not provide any explanation of subsumption, but instead closer
descriptions J (in Out) of In given Out under T .

7 Conclusion

In this paper we studied data flow-oriented Web service composition. Our work has
been directed to meet the main challenges facing this problem i.e., how to effectively
?

?

?
infer data flow between services based on their DL EL++ descriptions? Firstly we introduced the constructive reasoning join in EL++, aiming to provide a constructive
evidence of why services can be connected. Then we described how non trivial data
flow can be generated, checked and (potentially) repaired using concept join, all ensuring flexible data flow construction. Thus, implications of control flow modification on
data flow can be investigated. The experimental results provide evidence in favor of our
approach regarding the completeness of data flow.

Future works will focus on modeling data flow operators at instance level [14] i.e.,
how do loops in control flow work together with data flow? We will also investigate
metrics for evaluating data flow precision.
