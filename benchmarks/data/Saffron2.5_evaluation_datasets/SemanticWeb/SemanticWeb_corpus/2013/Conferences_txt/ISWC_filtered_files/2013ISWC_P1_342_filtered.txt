The Combined Approach to OBDA:

Taming Role Hierarchies Using Filters

Carsten Lutz1,  Inan c Seylan1, David Toman2, and Frank Wolter3

1 Universit at Bremen, Germany

{clu,seylan}@informatik.uni-bremen.de

2 Cheriton School of CS, University of Waterloo, Canada

david@cs.uwaterloo.ca

3 University of Liverpool, United Kingdom

wolter@liverpool.ac.uk

Abstract. The basic idea of the combined approach to query answering
in the presence of ontologies is to materialize the consequences of the
ontology in the data and then use a limited form of query rewriting to
deal with infinite materializations. While this approach is efficient and
scalable for ontologies that are formulated in the basic version of the
description logic DL-Lite, it incurs an exponential blowup during query
rewriting when DL-Lite is extended with the popular role hierarchies. In
this paper, we show how to replace the query rewriting with a filtering
technique. This is natural from an implementation perspective and allows
us to handle role hierarchies without an exponential blowup. We also
carry out an experimental evaluation that demonstrates the scalability
of this approach.

Introduction

In recent years, ontology-based data access (OBDA) has emerged as a promising
and challenging application of ontologies. The idea is to enrich data with a
semantic layer in the form of an ontology, used as an interface for querying
and to derive additional answers. A central research problem in this area is to
design query answering engines that can deal with sufficiently expressive ontology
languages yet scale to very large data sets. The most popular ontology languages
that have been considered for OBDA include the three OWL profiles OWL2 RL,
OWL2 QL, and OWL2 EL, as well as various description logics and Datalog
variants related to these profiles [2,3,5,14,17].

Currently, there are two major methodologies for answering queries in an
OBDA setting: rewriting-based approaches (also called backward chaining) and
materialization-based approaches (also called forward chaining). In the former,
one compiles the ontology T and the query q into a new query qT that contains
the relevant knowledge from the ontology, i.e., the answers to q over A and T
coincide with the answers to qT over A. One can thus store A in a relational
database management system (RDBMS) and execute qT over A. In materialization approaches, the data A is completed with the relevant knowledge from

H. Alani et al. (Eds.): ISWC 2013, Part I, LNCS 8218, pp. 314330, 2013.
c Springer-Verlag Berlin Heidelberg 2013
?

?

?
the ontology T , i.e., for any query q, the answers given to q over A and T coincide with the answers given to q over the completed data AT  A without any
ontology. Thus, one can store AT in a RDBMS and execute q over AT .
A technical problem that arises in materialization approaches is that the completed data AT easily becomes infinite; in particular, this may happen when
the ontology expresses cyclic dependencies and has existential quantifiers in the
heads of its concept inclusions, which is allowed in most ontology languages including the ones mentioned above. To overcome this problem, an economic way
of reusing individuals introduced for existential quantifiers has been proposed in
[9,11] for the case where ontologies are formulated in description logics from the
EL and DL-Lite families, which are the logical cores of the OWL2 EL and OWL2
QL ontology languages. While the resulting completed data sets are finite, they
can give spurious answers to conjunctive queries (CQs) that involve a cycle. To
recover soundness, it is thus necessary to include an additional step, resulting in
the combined approach to query answering: the original query is rewritten in a
way that eliminates spurious answers. In contrast to pure rewriting, the auxiliary query rewriting required in the combined approach turns out to be rather
simplean additional selection condition applied to the results of the original
CQ over the completed dataand often of polynomial size. Indeed, experiments
indicate that the combined approach admits very efficient query execution for
expressive variants of EL and DL-Lite [9,11].

Unfortunately, there are certain combinations of logical operators that are
important from an application perspective, but for which an exponential blowup
of the query seems to be unavoidable both in the query rewriting approach and
in the combined approach. In particular, this is the case for the combination
of inverse roles and role hierarchies as found in DL-LiteR [3], the extension of
basic DL-Lite with role hierarchies that underpins OWL2 QL. It has been shown
that, in the query rewriting approach, an exponential blowup of the query size is
unavoidable when the ontology is formulated in DL-LiteR [8]. For the combined
approach, an auxiliary query rewriting strategy for DL-LiteR ontologies and CQs
is presented in [9], but it incurs an exponential blowup and it seems unlikely that
the rewriting can be improved to a poly-sized one (although this question is yet
to be resolved).

In this paper, we present a new variation on the combined approach that can
handle CQs and DL-LiteR ontologies and eliminates the need for auxiliary query
rewriting altogether, thus also eliminating the need to deal with exponentially
sized queries. Specifically, we replace auxiliary query rewriting with a filtering
component : spurious answers are eliminated by a polynomial-time filtering procedure (called a filter in the rest of the paper) that is installed as a user-defined
function in the underlying RDBMS. Our main contributions are as follows.

(1) We develop a polynomial time procedure for filtering out spurious answers
to CQs for ontologies formulated in DL-LiteR. Interestingly, the existence of
such a filtering procedure appears to be quite sensitive to how exactly the
data is completed. Compared to the data completion for the original combined

C. Lutz et al.

approach [9], the filtering technique requires subtle modifications to the data
completion in order to obtain a polytime filter.

(2) To analyze the performance of our approach and to compare it with the query
rewriting approach, we modify the Lehigh University Benchmark (LUBM) [7] by
introducing additional concepts into the ontology, modifying the data generator
so that the produced data is incomplete, and replacing the original, very simple
queries by more challenging ones.
(3) We have implemented our approach in a system called Combo and carry out
an experimental evaluation based on the modified LUBM benchmark, both to
evaluate the feasibility of our approach and to compare it with the query rewriting approach. Our experiments show that the combined approach is significantly
more robust than the rewriting approach when the number of (sub)classes in the
ontology or the size of the data increases.

Some technical proofs and details of our experimental evaluation are presented
in the appendix of the full version of this paper, available at http://www.
informatik.uni-bremen.de/~clu/combined/. This paper is an extended version of the workshop paper [10]. In particular, the experimental evaluation carried out in this paper is much more comprehensive than the one in [10].

2 Preliminaries

We introduce DL-LiteR-TBoxes, ABoxes, and conjunctive queries. Let NI, NC,
and NR be countably infinite sets of individual names, concept names and role
names. Roles R, simple concepts C, and concepts D are built according to the
following syntax rules, where P ranges over NR and A over NC:



,



R ::= P | P

R to denote the set of all roles and identify (P

C ::= A | R,

D ::= C | C | R.A.


)



As usual, we use N
with P .
In DL-LiteR, a TBox is a finite set T of concept inclusions (CIs) C  D with
C a simple concept and D a concept, and role inclusions (RIs) R1  R2 with
R1, R2 roles.
An ABox is a finite set of concept assertions A(a) and role assertions P (a, b),
where A  NC, P  NR and a, b  NI. We denote by Ind(A) the set of individual
names used in A, and write P
(a, b)  A instead of P (b, a)  A if convenient.
A knowledge base (KB) is a pair (T ,A) with T a TBox and A an ABox.
The semantics of TBoxes and ABoxes is defined in the standard way based
,I
is a non-empty domain and I
on interpretations I = (

an
I  
interpretation function that maps each A  NC to a subset A

, each
P  NR to a relation P
I  
I  
I  
?

?

?
; for
details consult [1,3]. An interpretation is a model of a TBox T if it satisfies all
inclusions in T ; models of ABoxes and knowledge bases are defined analogously.
A knowledge base is consistent if it has a model. For a CI or RI , we write
T |=  when  is a consequence of T (satisfied in all models of T ). Instead of

, and each a  NI to an element a

), where 
?

?

?
T |= R  S, we usually write R 
T S to clearly distinguish consequences of
this form (which are RIs) from consequences of the form T |= R  S (which
are CIs). Note that, in DL-LiteR, deciding consistency and logical consequence
amounts to computing a form of transitive closure [3].
?

?

?

?

?

?
) and P (t

) where t, t

(t, t

Let NV be a countably infinite set of variables. Taken together, the sets NV
and NI form the set NT of terms. A conjunctive query (CQ) takes the form
q = y (y, x), where  is a conjunction of concept atoms A(t) and role atoms
  NT. As in the case of ABox assertions, we do not distinguish
P (t, t
, t). The free variables x of  are called the answer
between P
variables; we say that q is k-ary if x comprises k variables. If k = 0, then q is a
Boolean query. A union of conjunctive queries (UCQ) is a disjunction of CQs.
We denote by term(q) the set of terms in q.
Let q = y (y, x) be a k-ary CQ with x = x1, . . . , xk, and I an interpreta-
tion. A mapping  : term(q)  
for all a  term(q)  NI is a

match for q in I if I satisfies  under the variable assignment that maps each
t  term(q) to (t); in this case, we write I |= q. For a k-tuple of individual
names a = a1, . . . , ak, a match  for q in I is an a-match if (xi) = a
for
i  k. We say that a is an answer to q in an interpretation I if there is an
a-match for q in I and use ans(q,I) to denote the set of all answers to q in I.
Finally, a is a certain answer to q over a KB K = (T ,A) if a  Ind(A) and
I |= q[a] for all models I of K. The set of all certain answers to q over K is
denoted by cert(q,K). The query answering problem considered in this paper is:
given a DL-LiteR knowledge base K and a CQ q, compute cert(q,K).

with (a) = a

i

To simplify notation, throughout the paper we adopt the unique name as-

I = b

for distinct a, b  NI. This assump-

sumption (UNA), i.e., require that a
tion has no impact on the query answering problem.

3 ABox Completion

As explained in the introduction, the central idea of the combined approach is
to materialize consequences of the TBox in the ABox as a preprocessing step,
and then to execute queries over the completed data stored in an RDBMS as a
plain table. We illustrate this using two examples from the university domain,
similar in spirit to the LUBM ontology used in the experimental evaluation.
Example 1. For any ABox A, the concept inclusions

Student  Person
Student  takesCourse

(1)

(2)
lead to the following additions: (1) for every assertion Student(a)  A, add
(1) Person(a) and (2) takesCourse(a, b) for some fresh individual b (unless such
assertions are already present). After this completion, a CQ such as

q1(x) = y Person(x)  takesCourse(x, y)

correctly returns each a with Student(a)  A as a certain answer.

C. Lutz et al.

Faculty

a

degreeFrom

b Univ

degreeFrom

c

Faculty

teachesAt

deptOf

d

Dept

Fig. 1. Completed ABox for Example 3

The following example shows that naive completion can result in infinite ABoxes.
Example 2. Completed naively, the ABox {Faculty(a)} and LUBM inclusions

Faculty  degreeFrom

Univ  deptOf

Dept  teachesAt


degreeFrom

  Univ
deptOf  Dept

teachesAt  Faculty

(3)

(4)

(5)

result in an infinite role chain that indefinitely repeats the roles degreeFrom,
deptOf

, and teachesAt





.

The problem can be overcome by reusing fresh individuals in an economic way.

Example 3. Consider again the TBox (3)-(5). By reusing individuals, the ABox
{Faculty(a)} can be completed as shown in Figure 1, replacing the infinite role
chain with a cycle. Individual reuse compromises soundness of query answering
as some queries now have spurious answers; for example, the CQ

q2(x) = y, z Faculty(x)  degreeFrom(x, y)  Univ(y) 
deptOf(z, y)  Dept(z)  teachesAt(x, z)

returns c as an answer when executed over the completed ABox shown in Figure 1. This answer is spurious for two reasons: first, the cycle in Figure 1 is
present only due to individual reuse and thus should be disregarded for answering queries; and second, the freshly introduced individuals b, c, d are labeled nulls
and thus can never be returned as answers.

To recover soundness, it is necessary to eliminate the spurious answers. In the
original combined approach, this was achieved by query rewriting [9,11]. In this
paper, the spurious answers are eliminated by a filtering procedure that is installed as a user-defined function in the RDBMS. In the remainder of this sec-
tion, we introduce ABox completion in full detail. In the subsequent section, we
describe the filtering procedure.
From a conceptual perspective, the ABox completion step can be viewed as
replacing the original ABox with the canonical model IK of the knowledge
base K [9]. To define IK, we need a few preliminaries. From now on, we will
?

?

?


 C, where RC is a fresh role name.

generally disallow concepts of the form R.C. This can be done without loss of
generality since each CI D  R.C can be replaced with D  RC , RC  R,
and R
Let K = (T ,A) be a DL-LiteR KB. We use rol(T ) to denote the set of all
role names in T plus their inverses. The canonical model comprises at most two
fresh individuals for every role in rol(T ). However, we only want to introduce
the fresh individuals for a given role when necessary. Formally, we call a role
R  rol(T ) generating in K if there exist an a  Ind(A) and R0, . . . , Rn  rol(T )
such that Rn = R and the following conditions hold:
(agen) K |= R0(a) and R0(a, b) / A for all b  Ind(A) (written a  R0),
(rgen) for i < n, T |= R
To facilitate the implementation of efficient filters, we refine the definition of
canonical models as given in [9]: in some cases, we introduce two fresh individuals
for a given role instead of only a single one. This helps to avoid choices in the
elimination of spurious answers (see Example 8), which are related to particular
role configurations in the TBox called a loop: a set {R, S}  rol(T ) (where
  R,
potentially R = S) is a loop in T if R = S
and there is some T  rol(T ) such that S
T T . Let LT denote
the set of all roles that occur in a loop in T . The canonical model IK is then
based on the domain

, T |= R
T T and R 

= Ri+1 (written R

  S, T |= S

 Ri+1 and R

 Ri+1).


 


i


i


i



IK = Ind(A)  {cR,0 | R  rol(T ) \ LT is generating in K}

 {cR,0, cR,1 | R  LT is generating in K}.

  
whenever there is an S such that S 

To define the extension of roles in IK, we need some additional preparation. Let
 be an arbitrary, but fixed total ordering on rol(T ). For all d, d
IK and

each role R, we write d R d
T R and
one of the following cases applies:
 d = a  Ind(A), a  S, and d

 d = cT,i, T

= cS,0;
 i = j and {S, T} is not a loop in T ;
 i = j, {S, T} is a loop in T , and S  T ;
 i = j, {S, T} is a loop in T , and T = S or T  S (for 0 = 1 and 1 = 0).
The canonical model IK for K is now defined as follows, based on the domain
IK introduced above:


= cS,j, and one of the following holds

  S, d
?

?

?
IK = {a  Ind(A) | K |= A(a)}  {cR,i  
IK = {(a, b)  Ind(A)  Ind(A) | S : S(a, b)  A and S 

IK | T |= R

  A},
T R} 

{(d, d
?

?

?
)  

IK | d R d
?

?

?
 R d},

or d

IK = a.

a

Note that the slightly more straightforward version of canonical models defined
in [9] can be obtained from our canonical models by identifying all elements cR,0
and cR,1.

C. Lutz et al.

i

w

a

p

i

p

i

cw,0

cw,1

w

i

i

w

cp,0

cp,1

a

w

i

acw,0

p

i

acw,0cp,0

w

i

acw,0cp,0cw,1
.
.
.

Fig. 2. Canonical model IK and unraveled canonical model UK for Example 5

The ABox completion consists of replacing the ABox A originally stored in
the RDBMS with its canonical model IK. This can be achieved by executing a
set of FO/SQL-queries whose size is polynomial in the size of T [9].
It can be shown that IK is a model of K whenever K is consistent. Note that
one can find a Boolean CQ qT of size polynomial in the size of T such that for
any ABox A stored in the RDBMS, qT gives a positive answer iff K = (T ,A)
is consistent [9]. We can thus safely assume that the knowledge base has been
tested for consistency before query answering.



Example 4. Reconsider Examples 2 and 3. The canonical model for the ABox
{Faculty(a)} and TBox (3)-(5) is the structure displayed in Figure 1. Following our construction above, the fresh individuals b, c, d are named cdegreeFrom,0,
,0. Note that the TBox (3)-(5) does not give rise to any
cteachesAt
loops, and thus all cR,i have index i = 0.
Example 5. The following TBox gives rise to the loop {worksFor, paysSalaryOf}:
(6)

,0, and cdeptOf



worksFor
paysSalaryOf

  Employer
  Employee

(7)

Employee  worksFor
Employer  paysSalaryOf
  isAffiliatedWith
worksFor

(8)
A part of the canonical model for the ABox {Employee(a)} and the TBox (6)-(8)
with paysSalaryOf  worksFor is shown on the left-hand side of Figure 2, where
concept names are omitted and role names are abbreviated by their first letter.

paysSalaryOf  isAffiliatedWith.

To characterize the spurious answers that have to be filtered out, it is useful
to introduce an unraveled (infinite) version of canonical models. Let K be a
knowledge base. A path is a finite sequence ad1  dn, n  0, such that a 
Ind(A), d1, . . . , dn  
IK \ Ind(A), a R d1 for some R  N

R , and di R di+1
for some R  N
R , 1  i < n. We denote by tail() the last element of the path .

The unraveled canonical model UK is then defined by taking:

UK is the set of all paths in IK,

UK = a, for all a  Ind(A),
a
UK = {  
IK},
UK | tail()  A
?

?

?
UK = {(a, b)  Ind(A)  Ind(A) | S : S(a, b)  A and S 

T R} 

{(, d) | d  
{(d, ) | d  

UK and tail() R d} 
UK and tail() R d}.

As an example, the canonical model UK for the KB from Example 5 is shown on
the right-hand side of Figure 2. The following result shows that, as one would
expect, UK does not suffer from spurious answers.
Theorem 1. For every consistent DL-LiteR-KB K and every CQ q, we have
cert(q,K) = ans(q,UK).
The proof of Theorem 1 is standard and omitted, see [9] for a similar proof.

4 Filtering

To remove spurious answers, we install a filtering procedure as a user-defined
function in the RDBMS. In this approach, calls to the filtering procedure are
delegated to the RDBMS in hopes that the query optimizer will eliminate spurious answers as early as possible in the execution plan. The procedure takes as
input a match of the query in the canonical model IK stored in the RDBMS and
returns false if this match is spurious and true otherwise. We assume that
the filtering procedure has access to the query and the TBox, but not to the
data. To define its behavior more precisely, we formally define spurious matches
based on unraveled canonical models UK and Theorem 1.
Let K be a KB and q(x) a CQ. A match  of q in IK is reproduced by a match
 of q in UK if for all t  term(q), we have (t) = tail( (t)). We say that  is
spurious if it is not reproduced by any match  of q in UK. The following lemma,
which is an immediate consequence of Theorem 1, shows that IK can be used
for query answering when spurious matches are filtered out.
Lemma 1. a  cert(q,K) iff there is a non-spurious a-match  of q in IK.
We want to show that it can be decided in time polynomial in the size of q and T
(and without accessing A at all) whether a given match in IK is spurious. Clearly,
it is enough to test for each maximally connected component of q whether the
match is spurious on that component. We thus assume that q is connected.

We need a few preliminaries. An anonymous path is a path without the leading

individual name, i.e., it is a finite sequence d1  dn, n  1, such that d1, . . . , dn 
IK\Ind(A) and di R di+1 for some R  N
R , 1  i < n. We use Paths to denote


the set of all paths, both anonymous and non-anonymous. A root configuration
for q given  is a set   term(q) such that one of the following conditions is
true:

  is the set of those t  term(q) such that (t)  NI and this set is non-empty;

 the above set is empty and  contains exactly one term (actually a variable).

The filtering procedure immediately returns false if some answer variable is
IK that is not from Ind(A) (based on the name of
mapped to an element of 

C. Lutz et al.

Student
a1

Student

a2

  

Student

an

takesCourse

takesCourse

ctakesCourse,0

Fig. 3. Canonical model IK for Example 6

the element, i.e., whether it is of the form cR,i). Then the procedure iterates
through all root configurations . For each , it constructs a sequence S0
, . . .
of relations Si


, S1

 term(q)  Paths as follows:
 contains all pairs (t, (t)) with t  ;
 S0
 Si+1
 extended with the following pairs:
(a) (t, (t)) for all R(s, t)  q with (s, )  Si
(b) (t, (t)) for all R(s, t)  q with (s, (t)(s))  Si

is Si



 and (s) R (t);

 and (t) R (s).

The computation stops as soon as the sequence stabilizes or Si
 becomes nonfunctional which happens after at most |term(q)| iterations. The procedure returns true if the final Si
 is a function with domain term(q) for some root
configuration , and false otherwise.

Example 6. Consider the TBox (1)-(2) from Example 1, the query

q3(x, y) = z Student(x)Student(y)takesCourse(x, z)takesCourse(y, z), (9)

and the ABox

{Student(a1), . . . , Student(an)}.

(10)
The canonical model IK is shown in Figure 3. Suppose the filter gets as input
the match  = {x  a1, y  a2, z  ctakesCourse,0}. There is only one possible
root configuration for , which is  = {x, y}. The procedure computes
S = {(x, a1), (y, a2), (z, a1ctakesCourse,0), (z, a2ctakesCourse,0)}

which is not a function; thus, the match is spurious and false is returned.

Example 3. To make things a bit more interesting, assume that x is a quantified

Example 7. Consider the ABox {Faculty(a)}, TBox (3)-(5), and query q2 from
variable in q2 rather than an answer variable. Recall that the canonical model IK
is shown in Figure 1, modulo the names of fresh individuals. Given the match
 = {x  c, y  b, z  d} and considering the root configuration  = {x}, the
procedure computes

S = {(x, c), (y, cb), (z, cbd), (x, cbdc)}

and stops because of non-functionality. For the other root configurations  = {y}
and  = {z}, the procedure fails in a similar way and thus returns false.
?

?

?
Similar to the tree witnesses from [9], the filtering procedure follows a simple
idea for reproducing the input match  in IK as a match  in UK: when we have
already decided that  (x) =  / Ind(A) and R(x, y)  q, then there is a uniquely
to which y can be matched. This follows from requiring
determined individual 
(y) = tail( (y)) and the following property of UK:
 = 
?

?

?
UK and (, 

UK with 
?

?

?
) = tail(
?

?

?
)  R
?

?

?
)  R

if (, 
?

?

?
, then tail(
?

?

?
).

In fact, it is this determinism of matches that is made explicit by Conditions (a)
and (b) of the filtering procedure. Note that, without introducing two individual
names cR,0 and cR,1 whenever R is involved in a loop, the above crucial property
of UK fails. In fact, we do not know whether polytime filtering is possible based
on the variation of the canonical model where all individuals cR,0 and cR,1 are
identified. The problem is illustrated by the following example.
Example 8. Consider the ABox {Employee(a)} and TBox (6)-(8) from Example 5 and the CQ

q4(x) = y, z, u w(x, y)  p(y, z)  i(u, z).

Let  = {x  a, y  cw,0, z  cp,0, u  cw,1}. The only root configuration is
 = {x}. During the first two iterations, the filtering procedure produces

 = {(x, a), (y, acw,0), (z, acw,0cp,0)}.
S2

 says that z has to be mapped to acw,0cp,0. Due to the atom i(u, z)  q4 and
S2
the two i-edges incoming to acw,0cp,0 in UK, the possible targets for u are acw,0
and acw,0cp,0cw,1. However, to produce a match in UK that is compatible with ,
we can only choose a target that ends with (u) = cw,1 and obtain
 = {(x, a), (y, acw,0), (z, acw,0cp,0), (u, acw,0cp,0cw,1)}
S3

which is functional, showing that the match  is not spurious. In a canonical

model IK where cw,0 and cw,1 are identified, there are indeed two choices for

mapping of u. This makes it non-obvious how to find a polytime filtering procedure in this case, if one exists at all.

We now analyze the runtime and correctness of the filtering procedure. First
note that, in Conditions (a) and (b), the filtering procedure has to check whether
(s) R (t) and (t) R (s), respectively. As required, both conditions can
be tested without access to the ABox A. For example, in Condition (a) we have:
 if (t)  Ind(A), then (s) R (t) does not hold and checking whether
(t)  Ind(A) requires only to check whether or not (t) is of the form cR,i;
 if (s)  Ind(A) and (t) / Ind(A), then (s) R (t) holds by the construction of IK since  is a match of q in IK, and;
 if (s) / Ind(A) and (t) / Ind(A), then (s) R (t) can be checked by
using only  and T based on the definition of R.

C. Lutz et al.

It is not hard to see that the algorithm runs in polynomial time. The runtime
is quadratic in the size of q because we first have to iterate over all root configurations  and then need to compute S, essentially a breadth-first search
of (the graph of) q. We conjecture that iterating over all root configurations
is avoidable at the cost of a less transparent filtering procedure, improving the
runtime to linear in the size of q. The runtime also depends on T as checking
the applicability of Conditions (a) and (b) involves testing consequences of the
forms T |= R  S and S 
T R. Since it is efficient to pre-compute all these
consequences in practical cases, this amounts to a simple lookup.

The following lemma asserts correctness of the filtering procedure. It is proved

in the appendix of the full version.
Lemma 2. Given a match  of q in IK, the filtering procedure returns true
iff  is not spurious.

Implementation and Experiments

We have implemented our approach in the Combo system, a collection of tools
that support the user in setting up the tables of a relational database system to
store ABoxes and their completion, implements the actual data completion via
querying, and allows to compile an ontology into a filter that takes the form of
a user defined function. The preferred relational database system for use with
Combo is IBM DB2.

version

of

the

on

a modified

We use this combination to carry out an experimental evaluation of our ap-
proach, and to compare it to the query rewriting approach. The experiments are
based
from the Lehigh
University Benchmark (LUBM) [7] and on ABoxes produced by a modified version of the LUBM data generator. We use six queries that were hand-crafted
specifically for our experiments. The mentioned modifications aim at making
the LUBM suite more realistic for OBDA evaluation. We believe that this
setup might be interesting also for future experiments and provide it online
at http://www.informatik.uni-bremen.de/~clu/combined/.

ontology

Regarding the query rewriting approach, we use Rapid (v0.3) [4] and Presto
(version March 25th 2013) [15] as typical examples of state-of-the-art rewriting
tools. Both Rapid and Presto are able to generate rewritings into UCQs and into
non-recursive Datalog (DLog), and they use various optimizations to generate
as small rewritings as possible.

5.1 Ontology, Data, and Queries

The LUBM ontology comprises 42 concept names and 25 role names and is
formulated in the description logic ELI extended with transitive roles, role hier-
archies, and datatypes. The TBox contains concept inclusions of the form A  C,
concept definitions A  C as abbreviations for A  C, C  A, and domain and
  A. We converted this onrange restrictions of the form R  A and R
tology to DL-LiteR by dropping all datatypes, treating the only transitive role
?

?

?
subOrganizationOf as a standard role, replacing concept equations A  C with
A  C, and breaking up conjunctions A  C1  C2 into A  C1, A  C2.

While the resulting TBox is formulated in DL-LiteR as required, it is only
moderately interesting for evaluating query answering techniques: first, there is
a lack of existential restrictions R and R.C on the right-hand side of concept inclusions, which leads to extremely few fresh anonymous individuals being
generated during the ABox completion, and consequently to very few role edges
between those individuals (from now on, we call this part of the canonical model
IK the anonymous part ); second, the overall size of the TBox is too small to be
representative for real-world ontologies. To attenuate these deficiencies while still
being able to use the LUBM data generator, we extended the DL-LiteR-version
of LUBM in two directions:
(1) We added 26 carefully chosen concept inclusions, many of which have existential restrictions on the right-hand side, to generate a more interesting anonymous part of canonical models. A complete list of these CIs can be found in the
appendix of the full version of this paper.
(2) With reasonable effort, it does not seem possible to significantly increase
the size of LUBM (to hundreds or thousands of concepts) while retaining a
careful modeling. One particularly unrealistic aspect of LUBM and a striking
difference to many real-world ontologies is its limited concept hierarchy, where
each concept has only very few subconcepts. To alleviate this shortcoming, we
added subconcepts to each of the LUBM concepts Course, Department, Professor,
and Student by introducing subject areas, such as MathCourse, BioCourse, and
CSCourse for courses, MathProfessor, BioProfessor for professors, etc.


n with n indicating the number of subWe call the resulting TBox LUBM


concepts introduced in Point 2 above (20 by default). For example, LUBM
contains 106 concept names and 27 role names.

To generate ABoxes, we use the LUBM Data Generator (UBA) version 1.7,
modified so as to complement our modifications to the TBox. Specifically, the
original UBA generates data that is complete w.r.t. existential restrictions in the
LUBM ontology: it produces ABoxes A such that for every assertion A(a)  A
and CI A  R (and A  R.B) in LUBM

n, there is already an R-successor of
a in A. Our modifications introduce a controlled amount of incompleteness: the
modified data generator takes a probability p as a parameter and, in selected
parts of the data, drops generated role assertions with probability p. More information can be found in the appendix of the full version. The second modification
of the data generator is linked to the subconcepts introduced in Point 2 above.
Whenever the original generator produces an instance a of Student, the new
generator randomly chooses a value between 1 and n and generates an assertion for the i-th subject, SubjiStudent(a); similarly for Course, Department, and
Professor.

We use the six queries in Figure 4 that we have hand-crafted specifically for our
experiments. Note that cq3 is designed to stress-test the filtering approach: based
on the data generation scheme, it is expected to produce a very large number
of spurious answers. Requiem test queries are commonly used for benchmarking

C. Lutz et al.

query rewriting systems [12]. We did not include those queries since they are
too simple for our purposes. In fact, they are answered effortlessly both by our
approach and by the query rewriting approach.

5.2 Results

We report on two experiments: in the first experiment we vary the complexity
of the ontology by increasing the number of subclasses (the parameter n of

the ontology LUBM
n) and in the second experiment we vary the data size by
increasing the number of universities that are generated by the modified LUBM
data generator. It turned out that, in general, the degree of incompleteness had
only very limited effect on the execution time of queries. We therefore do not
vary the degree of incompleteness but use 5% incompleteness in the data for
both experiments. All experiments were carried out on a Linux (3.2.0) machine
with a 3.5Ghz quad-core processor and 8GB of RAM, using IBM DB2 Express-C
version 9.7.5.

cq1(x,z)<-Student(x), takesCourse(x,y), Subj1Course(y), teacherOf(z,y),

Professor(z), headOf(z,w), Department(w), memberOf(x,w)

cq2(x)

<-Faculty(x), degreeFrom(x,y), University(y),

subOrganizationOf(z,y), Department(z), memberOf(x,z)

cq3(x,y)<-Professor(z), memberOf(z,x), Subj3Department(x),

publicationAuthor(w,z), Professor(v), memberOf(v,y),
Subj4Department(y), publicationAuthor(w,v)

cq4(x,y)<-Department(x), memberOf(z,x), Student(z), takesCourse(z,v),

cq5(x)

teacherOf(w,v), Professor(w), memberOf(w,y), Department(y)
<-Person(x), worksFor(x,y), Department(y), takesCourse(x,z),

Course(z)

cq6(x)

<-Student(x), publicationAuthor(y,x), Publication(y),

teachingAssistantOf(x,z), Course(z)

Fig. 4. Queries cq1 to cq6

Original ABox

Data Completion

#Univ. individuals concepts
?

?

?
4M
10M
21M

7M
17M
35M

roles
time
12M 7m30s
31M 39m06s
63M 43m17s

concepts

time

roles
22M 16m55s
12M
31M
55M 70m48s
63M 111M 146m39s

Fig. 5. Size original and completed ABox (in million) and load and completion time

The size of the test data for the experiments is detailed in Figure 5, where we
give (for 20 subclasses) the number of individuals in the original ABox (there are
only about 200 additional individuals in the completion), the number of concept
and role assertions (in the original ABox and in its completion), and the load
time for the original and the completed ABox (including the completion time).
?

?

?
System

Test
1000.10 Rap-DLog
Pre-DLog
Combo

1000.20 Rap-DLog
Pre-DLog
Combo

1000.40 Rap-DLog
Pre-DLog
Combo

1000.80 Rap-DLog
Pre-DLog
Combo

cq1
23.54
23.61
24.42

22.86
18.13

23.21
13.56
?

?

?
7.10

cq2
?

?

?
393.97
?

?

?
460.16
?

?

?
456.84
?

?

?
448.69

cq3
40.88
43.66

33.80
32.48
587.76
76.69
75.71
279.09
?

?

?
152.55

cq4

75.33
267.55
?

?

?
266.97
?

?

?
270.12
?

?

?
268.86

cq5
?

?

?
23.67
?

?

?
28.30
?

?

?
28.31
?

?

?
28.07

Fig. 6. Run time for varying number of subclasses

Test

System

cq1

200.20 Rap-DLog
Pre-DLog
Combo

500.20 Rap-DLog
Pre-DLog
Combo

1000.20 Rap-DLog
Pre-DLog
Combo

6.72
5.84
4.75
14.32
11.32
14.14

22.86
18.13

cq2

4.68
55.55
22.65
343.47
344.36
116.34
?

?

?
460.16

cq3

3.35
5.79
25.58
15.04
14.96
161.16
33.80
32.48
587.76

cq4
13.37
146,26
51.17
?

?

?
135.36
?

?

?
266.97

cq5
14.36
11.76
6.50
?

?

?
11.59
?

?

?
28.30

cq6
50.41
15.69
38.93
54.12
17.24
38.72
65.45
18.27
37.43

17.81
39.26

cq6

9.22
2.78
4.07
25.58
8.18
19.46
54.12
17.24
38.72

Fig. 7. Run time for varying number of universities

cq1
Rap-UCQ 57984
Rap-DLog
Pre-UCQ
Pre-DLog
?

?

?
cq2

cq3

cq4

162288
?

?

?
cq5
?

?

?
cq6
?

?

?
Fig. 8. Number of disjuncts in UCQ and rules in Datalog program

For our experiments, summarized in Figures 6 and 7, we report the execution
time (in seconds; TO stands for 600s timeout, TC for the DB2 output The
statement is too long or too complex, and UM for the DB2 output Unexpect
maxNumBrunch) for the Datalog rewritings generated by Rapid and Presto
(transformed into SQL by unfolding them into positive existential queries) and
for the Combo filtering approach. We do not report execution times for any
UCQ rewritings because they are excessively large and DB2 fails to execute
them in all of our experiments, see Figure 8.1

1 We are not aware of any experimental evaluation of the query execution time of
rewritings into non-recursive Datalog. Our experiments show that Datalog rewritings
can be significantly more efficient than UCQ rewritings.

C. Lutz et al.

spurious answers
valid answers

cq1

32K

cq2

2K

cq3
600K

cq4
35K
20K

cq5
?

?

?
cq6

465K

Fig. 9. Number of answers for 1000 universities, 20 subclasses

The main outcomes of our experiments are as follows:

1. the Combo filtering approach is significantly more robust than the rewriting
approaches when both the complexity of the ontology and the size of the data
increase. We observe only one timeout for the filtering approach (cq3 for 1000
universities and 10 subclasses) but the rewriting approach eventually fails
for all queries with the exception of cq6.

2. For smaller data sets or for simple class hierarchies (e.g., 200 universities

and 20 subclasses), the filtering and rewriting approaches are comparable.

3. In contrast to the rewriting approach, the performance of the filtering ap-

proach does not depend significantly on the number of subclasses.2

The poor performance of the rewriting approach for complex ontologies and
large data is due to the fact that for complex queries (the SQL queries corresponding to the datalog rewriting) the DB2 query optimizer realizes that the
use of data structures, such as B-tree indices, becomes imperative and attempts
to distribute (index) joins into unions to take advantage of these indices. Such
an attempt, however, commonly leads to exhausting the resources available for
query optimization (DB2 then aborts by outputting TC or UM).

The poor performance of the filtering approach for query cq3 is due to the
large number of spurious answers, see Table 9 for an overview of the number of
valid and spurious answers for all queries. It is possible to avoid this behavior at
the cost of slight increase of the size of the canonical model: by duplicating the
anonymous parts of the canonical model so that no two (or few) individuals in
the original ABox share an anonymous part of the canonical model.

We close by commenting on the data loading and completion times reported
in Figure 5. Here the completion time is spent almost exclusively on loading the
data into the DBMS: indeed, loading large amounts of data into a relational
DBMS can be time consuming since the system needs to build up indexes and
other auxiliary data structures. Note, however, that bulk-loading data is rare in
most applications: standard workloads typically add and remove few tuples at a
time. In our case adding (removing), e.g., 100 concept/role assertions into (from)
the original ABox results in adding and removing less than 500 tuples from the
completed data (for the LUBM ontology), yielding an essentially instant update.
Moreover, the changes to the completed data can be efficiently computed given
the original ABox and the update request using incremental view maintenance
technology [6].

2 The increase of performance for cq1 and cq3 when the number of subclasses grows

is due to each subclass becoming less populated as the data size is fixed.
?

?

?
6 Conclusion

We have modified the combined approach to OBDA by replacing the query
rewriting part with a filtering technique. This is natural from an implementation
perspective and allows to avoid an exponential blowup of the query. We have
implemented our approach in the Combo system and generated an improved
version of the LUBM benchmark that aims at evaluating OBDA approaches.
Our experiments demonstrate the scalability and robustness of our approach.

In the future we plan to extend the combined approach with filtering to other
description logics for which, until now, it is unknown how to avoid an exponential
blowup of the query. For example, we believe that polytime filtering is possible
for the extension of EL with transitive roles, as found in the OWL2 EL profile.
Note that, based on the workshop predecessor [10] of this paper, the combined
approach with filtering has already been picked up to implement OBDA for an
extension of EL (but without transitive roles) [16].

From an applied perspective, it would be interesting to compare our approach
also with the promising new optimization techniques that have recently been
developed in [13,14]. While some of them (such as the exploitation of ABox
integrity constraints) aim specifically at the query rewriting approach, others
(such as semantic indexing) can easily be used also for the combined approach.
We did not include those optimizations and systems in our evaluation because
all available implementations seem to require prerequisites that are not satisfied
in our tests (such as the availability of mappings from a relational database to
the ontology or the storage of the ABox in an in-memory database).
