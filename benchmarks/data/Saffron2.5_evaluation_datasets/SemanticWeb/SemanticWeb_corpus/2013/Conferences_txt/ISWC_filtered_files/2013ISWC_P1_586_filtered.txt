Ontology-Based Data Access:

Ontop of Databases

Mariano Rodr guez-Muro1, Roman Kontchakov2, and Michael Zakharyaschev2

1 Faculty of Computer Science, Free University of Bozen-Bolzano, Italy

2 Department of Computer Science and Information Systems,

Birkbeck, University of London, U.K.

Abstract. We present the architecture and technologies underpinning
the OBDA system Ontop and taking full advantage of storing data in
relational databases. We discuss the theoretical foundations of Ontop:
the tree-witness query rewriting, T -mappings and optimisations based
on database integrity constraints and SQL features. We analyse the performance of Ontop in a series of experiments and demonstrate that, for
standard ontologies, queries and data stored in relational databases, Ontop is fast, efficient and produces SQL rewritings of high quality.

Introduction

Ontology-based data access (OBDA) [6,11,22] is regarded as a key ingredient for
the new generation of information systems, especially for Semantic Web applications that involve large amounts of data. In the OBDA paradigm, an ontology
defines a high-level global schema and provides a vocabulary for user queries,
thus isolating the user from the details of the structure of data sources (which
can be relational databases, triple stores, datalog engines, etc.). The OBDA system transforms user queries into the vocabulary of the data and then delegates
the actual query evaluation to the data sources.

In this paper, we concentrate on OBDA with ontologies given in OWL 2 QL,
a profile of OWL 2 designed to support rewriting of conjunctive queries (CQs)
over ontologies into first-order (FO) queries. A standard architecture of such an
OBDA system over relational data sources can be represented as follows:

CQ q

rewriting

+

ontology T

FO q

ABox A

unfolding

+

mapping

+

data D

The user is given an OWL 2 QL ontology T and can formulate CQs q(x) in the
signature of T . The system rewrites q and T into an FO-query q
(x), called
a rewriting of q and T , such that (T ,A) |= q(a) iff A |= q
(a), for any set
A of ground atoms (called an ABox) in the signature of T and any tuple a

ABox virtualisation

H. Alani et al. (Eds.): ISWC 2013, Part I, LNCS 8218, pp. 558573, 2013.
c Springer-Verlag Berlin Heidelberg 2013
?

?

?
The rewriting q

of individuals in A. A number of different rewriting techniques have been proposed and implemented for OWL 2 QL (PerfectRef [22], Presto/Prexto [27,26],
Rapid [5], the tree-witness rewriting [15]) and its extensions ([16], Nyaya [9],
Requiem/Blackout [20,21], Clipper [7]).
is formulated in the signature of T and, before evaluation,
has to be further transformed into the vocabulary of the data source D. For
can be unfolded into an SQL query by means of a GAV mapping M
instance, q
relating the signature of T to the vocabulary of D. Strangely enough, mappings
and unfoldings have largely been ignored by query rewriting algorithms (with
Mastro-I [22] being an exception), partly because the data was assumed to be
given as an ABox (say, as a universal table in a database or as a triple store).
We consider the query transformation process as consisting of two stepsquery
rewriting and unfoldingand argue that this brings practical benefits (even in
the case of seemingly trivial mappings for universal tables or triple stores).

The performance of first OBDA systems based on the architecture above was
marred by large rewritings that could not be processed by RDBMSs, which led
the OBDA community to intensive investigations of rewriting techniques and
optimisations. There are 3 main reasons for large CQ rewritings and unfoldings:
(E) Sub-queries of q with existentially quantified variables can be folded in
many different ways to match the canonical models of possible knowledge
bases (T ,A), all of which must be reflected in the rewriting q
.
according to T , which all have to be included in the rewriting q
may result in an exponential blowup when q
for RDBMSs) union of Select-Project-Join queries.

(H) Classes/properties occurring in q can have many subclasses/subproperties
(M) The mapping M can have multiple definitions of the ontology terms, which
is unfolded into a (most suitable

.

In fact, most of the proposed techniques produce rewritings in the form of unions
of CQs (UCQs) and try to tame (E) using various optimisations in unification
strategies to reduce the size of rewritings, with expensive CQ containment as the
last resort. Presto [27] and the tree-witness rewriting [15] use nonrecursive datalog to deal with (H); this, however, is of little help if a further transformation to
a UCQ is required. The combined approach [17] constructs finite representations
of (in general) infinite canonical models of (T ,A) thereby totally removing (H).
It also solves (E) for ontologies without role inclusions; otherwise, rewritings
can still be of exponential size, or the filtering procedure [19] may have to run
exponentially many times.

In theory, (E) turns out to be incurable under the architecture above: there
are CQs and OWL 2 QL ontologies for which any FO- (or nonrecursive datalog)
rewriting is superpolynomial (or exponential) [13,14], which happens independently of the contribution of (H) and (M); the polynomial rewriting of [10] hides
this blowup behind extra existential quantifiers. Fortunately, it seems that only
(artificially) complex CQs and ontologies trigger issues with (E). Our experiments show that, for standard benchmark CQs and ontologies, the number of
foldings in (E) is small and can be efficiently dealt with by the tree-witness
rewriting.

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev

In this paper, we attack both (H) and (M) at the same time using two key
observations. First, the schema and integrity constraints (dependencies), , of
the data source D together with the mapping M often provide valuable information about the class of possible ABoxes over which the user CQ is rewritten.
(These ABoxes are virtual representations of D and are not materialised.) For
example, if we know that all our virtual ABoxes A are -complete with respect
to T (that is, contain witnesses for all R in T ) then we can ignore (E); if
all A are H-complete (that is, A contains A(a) whenever it contains B(a) and
T |= B  A, and similarly for properties) then the problem (H) does not exist.
Second, we can make the virtual ABoxes H-complete by taking the composition
of T and M as a new mapping. This composition, called a T -mapping [24], can
be simplified with the help of  and the features of the target query language
before being used in the unfolding. As the simplifications use , they preserve
correct answers only over database instances satisfying . (Even if the mappings
are trivial and the data comes from a universal table or a triple store, it often
has a certain structure and satisfies certain constraints, which could be taken
into account to make query answering more efficient [12]).

These observations underpin the system Ontop (ontop.inf.unibz.it) implemented at the Free University of Bozen-Bolzano and available as a plugin for
Prot eg e 4, SPARQL end-point and OWLAPI and Sesame libraries. The process
of query rewriting and unfolding in Ontop with all optimisations is shown below
(the dashed lines show processes that aid explanations but do not take place):

tw-rewriting 

CQ q

+

UCQ q

tw

ontology T

unfolding

composition 



+

dependencies 



+

mapping M

T -mapping

+

virtual ABox

+

H-completion

H-complete ABox A

ABox virtualisation

+

data D

ABox virtualisation

This architecture, which is our main theoretical contribution, will be discussed
in detail in Section 2. Here we only emphasise the key ingredients:
 the tree-witness rewriting q

tw assumes the virtual ABoxes to be H-complete;
it separates the topology of q from the taxonomy defined by T , is fast in
practice and produces short UCQs;
 the T -mapping combines the system mapping M with the taxonomy of T
to ensure H-completeness of virtual ABoxes;
 the T -mapping is simplified using the Semantic Query Optimisation (SQO)
technique and SQL features; the T -mapping is constructed and optimised
for the given T and  only once, and is used to unfold all rewritings q
tw;

 the unfolding algorithm uses SQO to produce small and efficient SQL queries.
?

?

?
In Section 3, we evaluate the performance of Ontop and compare it with other
systems using a number of standard ontologies, including LUBM with generated
data and the Movie Ontology with real data. Our experimental results show that
UCQ rewritings over arbitrary ABoxes are not scalable in the presence of class
and property hierarchies; in contrast to that, rewritings of real-world queries
and ontologies over H-complete ABoxes (or equivalent datalog rewritings) turn
out to be unions of few (at most two, in our experiments) CQs whose size does
not exceed (in fact, is often smaller than) the size of the original query. Class
and property hierarchies can be tackled by optimisations of T -mappings and
the SQO, which use the structure of databases and integrity constraints, so that
Ontop automatically produces SQL queries of reasonably high quality. As a
result, Ontop successfully competes with and often outperforms systems based
on materialisation of inferences.

2 The Architecture of Ontop

We begin by describing the three main ingredients of Ontop: the tree-witness
rewriting over H-complete ABoxes, T -mappings and the unfolding algorithm. To
avoid long formulas, we use the DL parlance [2] for OWL 2 QL ontologies and the
datalog notation for conjunctive queries. Thus, subclass axioms are of the form

A1  A2, for concept (class) names Ai; property inclusions are R1  R2, where
the Ri are role (object and datatype property) names or their inverses; and
property P domain and range axioms are P  A1 and P
  A2, respectively.
Conjunctive queries (CQs) are of the form q(x)  1, . . . , n, where x is a
vector of answer variables and each i is a unary or binary atom (the variables
in the i that are not in x are existentially quantified ). Throughout the paper,
we identify atoms P
(y, x) and P (x, y) (in query heads, bodies and ABoxes).
Suppose we are given a CQ q(x) and an OWL 2 QL ontology T . Ontop starts
its work by constructing the semantic-based tree-witness rewriting of q and T
over H-complete ABoxes. We say that an ABox A is H-complete with respect to
T in case it satisfies the following conditions:



A(a)  A if A

P (a, b)  A if R(a, b)  A and T |= R  P.

(a)  A,T |= A

  A or R(a, b)  A,T |= R  A,

2.1 Tree-Witness Rewriting over H-Complete ABoxes

RA  worksOn.Project,
worksOn

We explain the essence of the tree-witness rewriting using an example; a formal
definition can be found in [25]. Consider an ontology T with the axioms
Project  isManagedBy.Prof,
isManagedBy  involves,
and the CQ q(x) asking to find those who work with professors:
q(x)  worksOn(x, y), involves(y, z), Prof(z).

  involves,

(1)

(2)

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev

Observe that if a model I of (T ,A), for some ABox A, contains individuals
a  RA

then I must also contain the following fragments:

and b  Project

a

worksOn


involves

u

isManagedBy

Project

involves

v

Prof

b

isManagedBy

Project

involves

w

Prof

where the points u, v, w are not necessarily named individuals from the ABox,
but can be (anonymous) witness for the existential quantifiers of (1) (or labelled
nulls in the chase); we say that these fragments are generated by RA and Project,
respectively, and use the bold-faced font to indicate that. It follows that a is an

, in which case the atoms of q
answer to q(x) whenever a is an instance of RA
(thick lines) are mapped to the fragment generated by RA as follows:
z

x

involves

worksOn

y

q

Prof

a

worksOn, involves



Project

isManagedBy, involves

Prof

Alternatively, we obtain the following match (provided that a is also in Prof

):

z

Prof
x

a

q

RA, Prof

involves

worksOn

y

worksOn, involves



Project

isManagedBy, involves

Prof

Another option is to map x and y to ABox individuals, a and b, and if b is in
, then the last two atoms of q can be mapped to the anonymous part
Project
generated by Project:

q

x

worksOn

y

involves

z

Prof

b

Project

isManagedBy, involves

Prof

Finally, all the atoms of q can be mapped to ABox individuals. The possible
ways of mapping parts of the CQ to the anonymous part of the models are
called tree witnesses. The tree-witnesses for q found above give the following
UCQ tree-witness rewriting q

tw(x) of q(x) and T over H-complete ABoxes:

tw(x)  RA(x),
tw(x)  Prof(x), RA(x),
tw(x)  worksOn(x, y), Project(y),
tw(x)  worksOn(x, y), involves(y, z), Prof(z).

q

q
q

q

(It is to be noted that q

Having computed the UCQ q

tw(x) is not a rewriting of q(x) and T over all ABoxes.)
tw, Ontop simplifies it using two optimisations.
First, it applies a subsumption algorithm to remove redundant CQs from the
union: for example, the first query in the example above subsumes the second,
which can be safely removed. It also reduces the size of the individual CQs in
?

?

?
the union using the following observation: any CQ q (viewed as a set of atoms)
has the same certain answers over H-complete ABoxes as

q \ {A(x)},
q \ {A(x)},
q \ {P (x, y)},

(x)  q and T |= A
?

?

?
if A
if R(x, y)  q and T |= R  A,
if R(x, y)  q and T |= R  P with R = P,

  A with A

 = A,

(3)

(4)
(5)

Surprisingly, such a simple optimisation, especially (4) for domains and ranges,
makes rewritings substantially shorter [27,9].

n

n

We have to bear in mind, however, that in theory, the size of the resulting
UCQ rewritings can be very large: there exists [13,14] a sequence of q
n and
Tn generating exponentially many (in |q
|) tree witnesses, and any first-order
n and Tn is of superpolynomial (or ex-
(or nonrecursive datalog) rewriting of q
ponential) size (unless it employs |q
|-many additional existentially quantified
variables [10]). On the other hand, to generate many tree witnesses, the CQ q
must have many subqueries that can be matched in the canonical models, which
requires both q and T to be quite sophisticated, with q mimicking parts of
the canonical models for T . To the best of our knowledge, this never happens
in real-world CQs and ontologies used for OBDA. More often than not, they
do not generate tree witnesses at all; see Section 3.1. It is also known [15, Theorem 21] that, if the query and ontology do not contain fragments as in the
example considered above, then the number of tree witnesses is polynomial.
2.2 Optimising T -Mappings
In a typical scenario for Ontop, the data comes from a relational database rather
than an ABox. A database schema [1] contains predicate symbols (with their
arity) for both stored database relations and views (with their definitions in
terms of stored relations) as well as a set  of integrity constraints (in the
form of inclusion and functional dependencies). Any instance I of the database
schema must satisfy its integrity constraints . The vocabularies of a database
schema and an ontology are linked together by means of mappings. We define a
mapping, M, as a set of GAV rules of the form
S(x)  (x, z),

where S is a class or property name in the ontology and (x, z) a conjunction of
atoms with database relations (both stored relations and views) and a filter, that
is, a Boolean combination of built-in predicates such as = and <. (Note that,
by including views in the schema, we can express any SQL query in mappings.)
Given a mapping M and a data instance I, the ground atoms

S(a),

for S(x)  (x, z) in M and I |= z (a, z),

comprise the ABox, AI,M, which is called the virtual ABox for M over I. We can
now define certain answers to a CQ q over an ontology T linked by a mapping
M to a database instance I as certain answers to q over (T ,AI,M).

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev

The tree-witness rewriting q

An obvious way to define such ABoxes is to take the composition MT
the inclusions in T given by

tw of q and T works only for H-complete ABoxes.
of M and

A(x)  (x, z)
A(x)  (x, y, z)
P (x, y)  (x, y, z),

(x)  (x, z)  M and T |= A
?

?

?
if A
if R(x, y)  (x, y, z)  M and T |= R  A,
if R(x, y)  (x, y, z)  M and T |= R  P

  A,



tw(a).

iff AI,MT |= q

(T ,AI,M) |= q(a)

(y, x) and P (x, y)). Thus, to compute answers
(we do not distinguish between P
to q over T with M and a database instance I, it suffices to evaluate the rewriting
tw over AI,MT : for any I and any tuple a of individuals in AI,M,
q
(6)
Given a CQ q and an ontology T , most OBDA systems first construct a
rewriting of q and T over arbitrary ABoxes and then unfold it, using a mapping
M, into a union of Select-Project-Join (SPJ) queries, which is forwarded for
execution to an RDBMS. By (6), the same result can be achieved by unfolding
a rewriting over H-complete ABoxes with the help of the composition MT
. In
principle, this may bring some benefits if the SQL query is represented as a union
of SPJ queries over views for class and property names, but only if the RDBMS
can evaluate such queries efficiently (each view is a union of simple queries, for
rules in MT
listing subclasses and subproperties). On the other hand, there
will be no benefit if the query is unfolded into a union of SPJ queries either by
the RDBMS or by the OBDA system itself. However, the resulting query will
produce duplicating answers if the ontology axioms express the same properties
of the application domain as the integrity constraints of the database [23].

For this reason, before applying MT

to unfold the tree-witness rewriting in
Ontop, we optimise the mapping using the database integrity constraints . This
allows us to (a) reduce redundancy in answers, and (b) substantially shorten the
SQL queries. We say that a mapping M is a T -mapping over  if the ABox
AI,M is H-complete with respect to T , for any data instance I satisfying .
(The composition MT
the

IMDb
(www.imdb.com/interfaces) whose schema contains relations title[m, t, y] with information about movies (ID, title, production year), and castinfo[p, m, r] with
information about movie casts (person ID, movie ID, person role), and an ontology MO (www.movieontology.org) describing the application domain in terms
of, for example, classes mo:Movie and mo:Person, and properties mo:cast and
mo:year:

is trivially a T -mapping over any .)

optimisations, we

simplified

illustrate

take

To

a

mo:Movie  mo:title,
mo:Movie  mo:cast,

mo:Movie  mo:year,
  mo:Person.
mo:cast

A mapping M that relates the ontology terms to the database schema contains,
for example, the following rules:

mo:Movie(m), mo:title(m, t), mo:year(m, y)  title(m, t, y),

mo:cast(m, p), mo:Person(p)  castinfo(p, m, r).
?

?

?
Inclusion Dependencies. Suppose M  {S(x)  1(x, z)} is a T -mapping
over . If there is a more specific rule than S(x)  1(x, z) in M, then M itself
is also a T -mapping. To discover such more specific rules, we run the standard
query containment check (see, e.g., [1]), but taking account of the inclusion
dependencies. For example, since T |= mo:cast  mo:Movie, the composition
MMO of mapping M and MO contains the following rules for mo:Movie:

The latter is redundant as IMDb contains the foreign key (inclusion dependency)

mo:Movie(m)  title(m, t, y),
mo:Movie(m)  castinfo(p, m, r).

p, r castinfo(p, m, r)  t, y title(m, t, y)
?

?

?
m

.

Disjunctions in SQL. Another way to reduce the size of a T -mapping is to
identify pairs of rules whose bodies are equivalent up to filters w.r.t. constant
values. This optimisation deals with the rules introduced due to the so-called type
(discriminating) attributes [8] in database schemas. For example, the mapping
M for IMDb and MO contains six rules for subclasses of mo:Person:

mo:Actor(p)  castinfo(c, p, m, r), (r = 1),
mo:Editor(p)  castinfo(c, p, m, r), (r = 6).



Then the composition MMO contains six rules for mo:Person that differ only in
the last condition (r = k), 1  k  6. These can be reduced to a single rule:

mo:Person(p)  castinfo(c, p, m, r), (r = 1)    (r = 6).

Note that such disjunctions lend themselves to efficient evaluation by RDBMSs.

Materialised ABoxes and Semantic Index. In addition to working with
proper relational data sources, Ontop supports ABox storage in the form of
structureless universal tables: a binary relation CA[id, class-id ] and a ternary
relation RA[id1, id2, property-id ] represent class and property membership asser-
tions. The universal tables give rise to trivial mappings, and Ontop implements
a technique, the semantic index [24], that takes advantage of SQL features in
T -mappings for this scenario. The key observation is that since the IDs in the
universal tables CA and RA can be chosen by the system, each class and property
name in the TBox T can be assigned a numeric index and a set of numeric intervals in such a way that the resulting T -mapping contains simple SQL queries
with interval filter conditions. For example, in IMDb, we have
mo:Actor  mo:Artist, mo:Artist  mo:Person, mo:Director  mo:Person;

so we can choose index 1 and interval [1,1] for mo:Actor, 2 and [1,2] for mo:Artist,
3 and [3,3] for mo:Director and 6 and [1,6] for mo:Person. This will generate a
T -mapping with, for instance,

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev

mo:Person(p)  CA(p, class-id), (1  class-id  6),
mo:Artist(p)  CA(p, class-id), (1  class-id  2).

So, by choosing appropriate class and property IDs, we effectively construct
H-complete ABoxes without the expensive forward chaining procedure (and the
need to store large amounts of derived assertions). On the other hand, the semantic index T -mappings are based on range expressions that can be evaluated
efficiently by RDBMSs using standard B-tree indexes [8].

2.3 Unfolding with Semantic Query Optimisation (SQO)

tw and the T -mapping,
The unfolding procedure [22] applies SLD-resolution to q
and returns those rules whose bodies contain only database atoms (cf. partial
evaluation [18]). Ontop applies SQO [4] to rules obtained at the intermediate
steps of unfolding. In particular, it eliminates redundant self-Join operations
caused by reification of database relations by means of classes and properties.
Consider, for example, the CQ

q(t, y)  mo:Movie(m), mo:title(m, t), mo:year(m, y), (y > 2010).

It has no tree witnesses, and so q
unfolding to q

tw and the T -mapping M above, we obtain the query

tw = q. By straightforwardly applying the

which requires two (potentially) expensive Join operations. However, by using
the primary key m of title:

tw(t, y)  title(m, t0, y0), title(m, t, y1), title(m, t2, y), (y > 2010),
q

y title(m, t1, y)  y title(m, t2, y)  (t1 = t2)

t title(m, t, y1)  t title(m, t, y2)  (y1 = y2)

mt1t2
my1y2

,

(a functional dependency with determinant m), we reduce two Join operations
in the first three atoms of q

tw to a single atom title(m, t, y):
tw(t, y)  title(m, t, y), (y > 2010).
q

Note that these two Join operations were introduced to reconstruct the ternary
relation from its reification by means of the roles mo:title and mo:year.

The role of SQO in OBDA systems appears to be much more prominent
than in conventional RDBMSs, where it was initially proposed to optimise SQL
queries. While some of the SQO techniques reached industrial RDBMSs, it never
had a strong impact on the database community because it is costly compared
to statistics- and heuristics-based methods, and because most SQL queries are
written by highly-skilled experts (and so are nearly optimal anyway). In OBDA
scenarios, in contrast, SQL queries are generated automatically, and so SQO
becomes the only tool to avoid redundant and expensive Join operations [28].
?

?

?
Table 1. Tree-witness UCQ rewritings over H-complete ABoxes

A & S

tree witnesses

CQs in q
tw
atoms in q
atoms in q

tw

a1
?

?

?
2+2

a2

a3

a4

a5

s1

s2

s3

s4

s5
?

?

?
1+3
?

?

?
2+3
?

?

?

?

?

?
r1

r2

r3

r4

r5

q1

q2

q3

q4

q5

q6

q7

q8

q9

tree witnesses

CQs in q
tw
atoms in q
atoms in q

tw
?

?

?
2 4+6 3+4
?

?

?
5 5+8
?

?

?
8 13 13 34
6 12
6 33

3 Experiments

In this section, we present the results of experiments conducted to evaluate
the performance of Ontop in comparison with other systems (for details see
sites.google.com/site/ontopiswc13). We begin by testing the tree-witness
rewriter.

3.1 Tree Witnesses: The Topology of Ontop Rewritings
We ran the Ontop tree-witness rewriter on the usual set of ontologies and CQs:
Adolena (A) and StockExchange (S) [20] with the original queries a1a5 and

s1s5, respectively, and LUBM
20 [19] with queries r1r5 from the Requiem evaluation [20], q1q6 from the combined approach evaluation [19], and q7q9 from
the Clipper evaluation [30]. Our aim was to understand the size of the topological part of the rewritings that reflects matches into the anonymous part of
the canonical models (as opposed to the taxonomical one). Table 1 shows the
number of tree witnesses, the number of CQs in the rewriting, and the number
of atoms in the input query and in each of the CQs of the rewriting.

Note that these CQs and ontologies have very few tree witnesses. More pre-
cisely, in 67% of the cases there are no tree witnesses at all, and in 29% we have
only one. Even for the specially designed q8, the structure of tree witnesses is
simpler than in our example from Section 2.1 (e.g., they do not overlap). And
although q8 and q9 do have tree witnesses, the resulting UCQs contain only one
CQ since these tree witnesses are generated by other atoms of the queries. In
fact, all tree-witness rewritings in our experiments contain at most two CQs: one
of them is an optimised original CQ (in particular, by the domain/range optimisation (4) in s2s5, r2r5, q1, q3, q5q8) and the other is obtained by replacing
the atoms of the tree-witness with its generator. Thus, each of the CQs in the
rewritings is not larger than the input query and has a very similar structure.

To illustrate, consider the following subquery of q8:
0(x0)  Publication(x0), publicationAuthor(x0, x11), Subj1Professor(x11),
worksFor(x11, x12), Department(x12),

q

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev


Table 2. The size of rewritings over LUBM
20 (DNF = Did Not Finish in 600s)

r1 r2 r3 r4 r5

q1 q2

q3

q4

q5

q6

q7

q8

q9

UCQ (number of CQs)

DNF DNF DNF DNF

Requiem 2
Nyaya

IQAROS 2
Rapid

1 23
1 23
1 23
1 23

2 10
2 10
2 10
2 10 3,887
?

?

?
DNF 14,880 690
DNF 690

DNF DNF DNF DNF
DNF 1 15,120 14,400 690 23,552 DNF DNF DNF

2 15,120 14,880 690 23,552 DNF

datalog (number of non-taxonomical rules)

Rapid
Clipper

tw-rewriter 1
?

?

?
1 512
?

?

?
Requiem

Nyaya

IQAROS

Rapid-UCQ

Rapid

tw-rewriting

600s
60s

1s

0.05s

0s

r1

r2

r5

r4

r3

q6

Fig. 1. Rewriting time for queries over LUBM

q5

q1

q2

q3

q4

q7

q8

q9

where x11, x12 do not occur in the rest of q8. This CQ has a tree witness com20 axiom Faculty  worksFor.

prising the last two atoms because of the LUBM
However, Subj1Professor is a subclass of Faculty, and so any of its instances is
always connected to Department by worksFor (either in the ABox or in the
anonymous part). Thus, the last two atoms of q
0 do not affect its answers
and can be removed. The first atom is redundant by (4) with the domain axiom publicationAuthor  Publication, which results in the following rewriting:
0(x0)  publicationAuthor(x0, x11), Subj1Professor(x11). As q
q
0 represents a
natural and common pattern for expressing queriesselect a Publication whose
publicationAuthor is a Subj1Professor, etc.any OBDA system should be able
to detect such redundancies automatically.


20 usFor comparison, we computed the rewritings of the CQs over LUBM
ing Requiem [20], Nyaya [9], IQAROS (v 0.2) [29], Rapid (v 0.3) [5] and Clipper
(v 0.1) [7]. The first four return UCQ rewritings, the numbers of CQs in which are
shown in Table 2. The last two return nonrecursive datalog rewritings over arbitrary ABoxes. These rewritings consist of a number of main rules and a number
of taxonomical rules for completing the ABoxes by subclasses/subproperties; to
compare with Ontop, Table 2 shows only the number of the main rules. In-
terestingly, Clipper and Rapid return single-rule rewritings in the cases without
tree witnesses, but generate more rules than Ontop (e.g., q8 and q9) otherwise.
Figure 1 shows the time required for rewriting (it was impossible to separate rewriting from DLV execution in Clipper, but it terminated within 1.5s
on every query). The UCQ-based systems do not finish in many cases and
?

?

?
require a substantial amount of memory (up to 1GB in some cases). In contrast,
the datalog-based systems and Ontop produce rewritings very quickly. Observe
that the rewritings returned by the four UCQ-based systems can be obtained
from the tree-witness rewritings by replacing each class/property with its sub-
classes/subproperties (IQAROSs rewritings of q2 and possibly q4 are incorrect):
for instance, q7 gives 216,000 (= 30323) CQs, q3 gives 15,120 (=452136) CQs
and q1 gives 3,887 (= 23 + 242123) CQs as Student, Faculty and Professor
have 23, 36 and 30 subclasses, respectively, worksFor has 2 subproperties, etc.
Such an operation (if needed) could be performed in fractions of seconds.

The experiments reported in this section imply that dealing efficiently with
class/property hierarchies is the most critical component of any OBDA system.
We discuss how Ontop copes with this task in the next section.
3.2 T -mappings: Class and Property Hierarchies
We compare the query execution time in Ontop, Stardog 1.2 [21] and OWLIM [3].
Both Stardog and OWLIM use internal data structures to store RDF triples.
Stardog is based on rewriting into UCQs (as we saw above, such systems can
run out of memory during the rewriting stage, even before accessing the data).
OWLIM is based on inference materialisation (forward chaining); but the implemented algorithm is known to be incomplete for OWL 2 QL [3].

It was impossible to compare Ontop with other systems: Rapid and IQAROS
are just query rewriting algorithms; Clipper (v 0.1) supports only the DLV datalog engine that reads queries and triples at the same time (which would be
a serious disadvantage for large datasets). The experiments were run on an
HP Proliant with 24 Intel Xeon 6-core 3.47GHz CPUs, 106GB RAM and a
1TB@15000rpm HD under 64-bit Ubuntu 12.04 with Java 7, MySQL 5.6 and
DB2 10.1.

Data as Triples: The Semantic Index. We first compare the performance of
the three systems for the case where the data is stored in the form of triples. In
this case, Ontop uses universal tables, and the SQO optimisations do not play

20 with the data created by the modified LUBM data
any role. We took LUBM
generator [19] for 50, 200 and 1000 universities (5% incompleteness) with 7m,
29m and 143m triples, respectively.

OWLIM requires a considerable amount of time for loading and materialising
the inferences14min, 1h 23min and 8h 4min, respectivelyexpanding the data
by 93% and obtaining 13m, 52m and 252m triples. Neither Stardog nor Ontop
need this expensive loading stage. The results of executing the queries from
Section 3.1 are given in Table 3 (in order to reduce the influence of the result
size, which are quite large in some cases, we executed queries that counted the
number of distinct tuples rather than returned the tuples themselves). We note
first that Stardog runs out of memory on 50% of the queries, with a likely cause
being the query rewriting algorithm, which is an improved version of Requiem
(cf. Table 2). On the remaining queries, Stardog is fast, which is probably due
to its optimised triple store. Unlike Stardog, both OWLIM and Ontop return

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev


Table 3. Query execution time (in seconds) and the result size over LUBM

r1

r2

r3

r4

r5

q1

q2

q3

q4

q5

q6

q7

q8

q9

DB2

0 0.03 0.50 0.01
MySQL 0 0.19 3.76 0.08

p
0 25.2
o
t
n
0 31.0

OWLIM 0.01 0.78 2.43 0.28 0.17 12.9
Stardog 0.01 0.79 1.16 0.34 0.10
result size


 102k

12k

34k

DNF 0.10
1.2m


50 universities

0.47
2.48 10.54
2.68 0.21

0.13
0.29

0.39 0.04 1.37 0.07 0.51 0.13
4.22 2.19 0.48 0.13

3.95 0.78 0.23 0.23 0.04
DNF DNF DNF DNF 0.04
205k


DNF DNF









200 universities

DB2

0 0.08 7.33 0.07
MySQL 0 1.21 14.6 0.32

p

o
t
n
?

?

?
OWLIM 0.01 3.10 9.28 0.94 0.79 46.4 10.52 0.89 15.15 16.91 3.32 0.92 0.92 0.05
Stardog 0.01 3.22 2.92 1.12 0.27
DNF DNF DNF DNF 0.06

825k

result size

3.48 0.12 5.52 0.26 0.86 0.25
0.49 16.11 8.45 1.66 0.54

DNF 0.33

4.6m

1.75
9.30 34.02

0 522.9
0 260.4

48k 137k

DNF DNF

 410k









1000 universities

DB2

0 0.24 11.6 0.19
MySQL 0 1.54 70.9 0.85

p

o
t
n
?

?

?
OWLIM 0.01 18.9 63.6 6.40 3.38 308 65.7 5.11 94.3 105.7 2.76 5.84 5.79 0.10
DNF DNF DNF DNF 0.17
Stardog 0.21 20.7 13.7 9.36 1.11
result size

4.1m


11.3 0.58 12.7 1.15 5.38 1.23
2.37 132.7 2.86 7.75 2.48

0 2761
0 1232 90.9 185.3

DNF 3.07
23m


2m 239k 685k

DNF DNF

3.29

2k











answers to all queries, and their performance is comparable. In fact, in 83% of
the cases Ontop with DB2 outperforms OWLIM.

It is to be emphasised that Ontop can work with a variety of database
engines and that, as these experiments demonstrate, Ontop with MySQL in
many case is worse in executing queries than with DB2 (but is still competitive with OWLIM). Two techniques turned out to be crucial to improve the
performance of the engines. First, in the universal relations CA[id, class-id] and
RA[id1, id2, property-id], we store integer URI identifiers rather than URIs them-
selves, with a special relation URI[id, uri] serving as a dictionary to de-reference
the URI identifiers. Second, a significant improvement of performance was achieved by creating indexes on sequences of attributes of the universal relations: for
example, CA has indexes on (id, class-id), (id) and (class-id). The full impact of
such indexes on storing data in the form of RDF triples is yet to be investigated.
Finally, we observe that some queries do not need evaluation because Ontop
simplifies them to empty queries: in fact, r1, r5 and q9 contain atoms that have
no instances in the generated data, and only 6 out of the 14 CQs return any
answers (which probably reflects the artificial nature of the benchmark).

These experiments confirm once again that rewritings into UCQs over arbitrary ABoxes can be prohibitively large even for high-performance triple stores
such as Stardog. The materialisation approach should by definition cope with
large taxonomies. We have demonstrated that the semantic index used in Ontop
is able to deal with this problem as efficiently as (and often better than) inference
materialisation, without the considerable overhead expense of the latter.
?

?

?
Table 4. Query and rewriting metrics, result sizes and execution times (in seconds)

q1

q2

q3

q4

q5

q6
?

?

?
q7

q8
?

?

?
4 59,211

27,804

q9

9+f
?

?

?
q10

3+f
?

?

?
atoms in query
?

?

?
UCQ rewriting
?

?

?
tables in SQL
?

?

?
result size
6 14,688 15,010 2,224 1,921
Stardog result size
?

?

?
Ontop-DB2 0.003
Ontop-MySQL 0.005

6+f
?

?

?
4+f
?

?

?
4,047

0.626 0.495 0.355 7.525 0.005 0.001 0.699 0.167 0.358
6.138
3.563 0.460 0.457
4.307 0.046 0.836
0.005 0.562
0.030
1.136
1.277 0.409 0.584

0.679 0.571 9.190 0.009 0.023
5.413 2.833 0.681 0.009 0.007
1.329 2.227 1.389 0.029 0.038

Stardog

Ontop of Databases. We now evaluate the performance of the T -mapping
approach to answering queries over OWL 2 QL ontologies with mappings to
real-world databases. We use the Movie Ontology (MO, www.movieontology.org)
and the data from the SQL version of the Internet Movie Database (IMDb,
www.imdb.com/interfaces). Both the database and ontology were developed
independently by third parties for purposes different from benchmarking; the
mapping was created by the Ontop development team. MO has 137 class and
property names and 157 inclusion axioms; the mapping contains 271 rules and
the virtual ABox has 42m assertions. We tested 10 natural queries to IMDb:
e.g., q3 retrieves the companies from East Asia and the movies they produced
between 2006 and 2010.

The metrics of the queries and their rewritings, the numbers of returned tu-
ples, and the execution times by Ontop with DB2 and MySQL, OWLIM and
Stardog over the materialised ABox are shown in Table 4. The line atoms in
query gives the number of atoms in the input query (+f denotes a filter ex-
pression). Each query coincides with its tree-witness rewriting (there are no tree
witnesses, and none of the atoms is redundant). The line UCQ rewriting shows
the number of CQs in the rewritings over arbitrary ABoxes, which reflects the
size of class and property hierarchies. The resulting SQL query contains a single
Select-Project-Join component with the number of tables given by tables
in SQLthis corresponds to the number of Joins in the SQL query. Because of
the SQO, the SQL queries have fewer tables and Joins than the original one (or
the rewriting). For example, q3 with 6 atoms produces a single SPJ query with
3 tables (and one disjunction over 7 country codes rather than 7 subqueries):

SELECT DISTINCT Q3.name, Q1.title, Q1.production year
FROM title Q1, movie companies Q2, company name Q3
WHERE (Q1.id = Q2.movie id) AND (Q2.company id = Q3.id) AND

(([tw] = Q3.country code) OR ... OR ([kr] = Q3.country code)) AND
(Q1.production year <= 2010) AND (Q1.production year >= 2006)

Note that Stardog, on the same set of triples as OWLIM, returns fewer tuples
in all cases but q10, which may explain the better execution times (one of the
Stardog optimisations [21] removes empty CQs from the rewriting and may be
responsible for the missing tuples).

M. Rodr guez-Muro, R. Kontchakov, and M. Zakharyaschev

In 70% cases, Ontop with DB2 outperforms OWLIM (and is efficient even
with MySQL). Moreover, OWLIM takes 45min to load the data into the triple
store (and will have to do this again every time the data is changed). This
demonstrates that on-the-fly inference over real-world databases by means of the
tree-witness rewriting and T -mappings is efficient enough to successfully compete with materialisation-based techniques. Moreover, the usual problems associated with query-rewriting-based approaches disappear in Ontop: T -mappings
efficiently deal with hierarchical reasoning avoiding the exponential blowup, and
the SQO improves the performance of the produced SQL queries by taking account of the structure and integrity constraints of the database.

4 Conclusions

To conclude, we believe this paper shows thatdespite the negative theoretical
results on the worst-case OWL 2 QL query rewriting and sometimes disappointing experiences of the first OBDA systemshigh-performance OBDA is achievable in practice when applied to real-world ontologies, queries and data stored
in relational databases. In such cases, query rewriting together with SQO and
SQL optimisations is fast, efficient and produces SQL queries of high quality.

Acknowledgements. We thank G. Orsi for providing Nyaya, G. Xiao for providing queries and the Ontop development team (J. Hardi, T. Bagosi, M. Slus-
nys) for the help with the experiments. This work was supported by the EU FP7
project Optique (grant 318338) and UK EPSRC project ExODA (EP/H05099X).
