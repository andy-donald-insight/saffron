A Decision Procedure for SHOIQ with Transitive

Closure of Roles

Chan Le Duc1, Myriam Lamolle1, and Olivier Cur e2

1 LIASD Universit e Paris 8 - IUT de Montreuil, France

{chan.leduc,myriam.lamolle}@iut.univ-paris8.fr

2 LIGM Universit e Paris-Est, France

ocure@univ-mlv.fr

Abstract. The Semantic Web makes an extensive use of the OWL DL ontology
language, underlied by the SHOIQ description logic, to formalize its resources.
In this paper, we propose a decision procedure for this logic extended with the
transitive closure of roles in concept axioms, a feature needed in several application domains. The most challenging issue we have to deal with when designing such a decision procedure is to represent infinitely non-tree-shaped models,
which are different from those of SHOIQ ontologies. To address this issue, we
introduce a new blocking condition for characterizing models which may have an
infinite non-tree-shaped part.

1 Introduction

The ontology language OWL-DL [1] is widely used to formalize data resources on
the Semantic Web. This language is mainly based on the description logic SHOIN
which is known to be decidable [2]. Although SHOIN provides transitive roles to
model transitivity of relations, we can find several applications in which the transitive
closure of roles, that is more expressive than transitive roles, is needed. For instance,
we consider an ontology, namely O1, that consists of the following axioms:
Human  hasAncestor.{Eva},
hasParent  hasAncestor, {Mike}  Human, {Mike}  hasParent.
We can see that O1 is consistent. However, the last axiom in O1 would be considered
as a design error which should lead to inconsistency. If the transitive role hasAncestor
is replaced with the transitive closure hasParent+ (and the second axiom is removed),
the first axiom becomes:

where hasAncestor is transitive

Human  hasParent+.{Eva}

It follows that the modified ontology is consistent. The point is that an instance of
hasParent+ represents exactly a sequence of instances of hasParent while an instance of hasAncestor corresponds to a sequence of instances of itself. In this paper,
we consider an extension of SHOIQ by enabling transitive closure of roles in concept axioms. In the general case, transitive closure is not expressible in the first order
logic [3], the logic from which DL is a sublanguage, while the second order logic is
sufficiently expressive to do so.

H. Alani et al. (Eds.): ISWC 2013, Part I, LNCS 8218, pp. 264279, 2013.
c Springer-Verlag Berlin Heidelberg 2013
?

?

?
In the DL literature ([4]; [5]), there have been works dealing with transitive closure
of roles. Recently, Ortiz [5] has proposed an algorithm for deciding consistency in the
logic ALCQIb+
reg which allows for transitive closure of roles. However, nominals are
disallowed in this logic. It is known that reasoning with a DL including number re-
strictions, inverse roles, nominals and transitive closure of roles is hard. The reason
for this is that there exists an ontology in that DL whose models have an infinite non-
tree-shaped part. Calvanese et al. [6] have presented an automata-based technique for
dealing with the logic ZOIQ that includes transitive closure of roles, and showed that
the sublogics ZIQ, ZOQ and ZOI are decidable. To obtain this result, the authors
have introduced the quasi-forest model property to characterize models of ontologies
in these sublogics. Although they are very expressive, none of these sublogics includes
SHOIQ with transitive closure of roles, namely SHOIQ(+). The following exam-
ple1, noted K1, shows that there is an ontology in SHOIQ(+) which does not enjoy
the quasi-forest model property. We consider the following axioms:

(1) {o}  A; A  B  ; A  R.A  R
(2) {o}  X


.;    1 X.;    1 X


.B; B  S+.{o}
?

?

?
Figure 1 shows an infinite non-tree-shaped model of K1. In fact, each individual x
that satisfies S+.{o} must have two distinct paths from x to the individual satisfying
nominal o. Intuitively, we can see that (i) such a x must satisfy S+.{o} and B, (ii)
an individual satisfying B must connect to another individual satisfying A which must
have a R-path to nominal o, and (iii) two concepts A and B are disjoint.

. where X  {R, R
?

?

?
, S}

{o}, A


, S
?

?

?
B,S+.{o}




?

?

?
B,S+.{o}
B,S+.{o}

B,S+.{o}

Fig. 1. An infinite non tree-shaped model of K1

This example shows that methods ([7], [8], [6]) based on the hypothesis which says
that if an ontology is consistent it has a quasi-forest model, could fail to address the
problem of consistency in a DL including simultaneously O (nominals), I (inverse
roles), Q (number restrictions) and transitive closure of roles.
In this paper, we propose a decision procedure for the problem of consistency in
SHOIQ with transitive closure of roles in concept axioms. The underlying idea of our
algorithm is founded on the star-type and frame notions introduced by Pratt-Hartmann
[9]. This technique uses star-types to represent individuals and tiles them together
to form a frame for representing a model. For each star-type , we maintain a function
() which stores the number of individuals satisfying this star-type. To obtain termina-
tion, we introduce two additional structures for establishing a new blocking condition:

1 This example is initially proposed by Sebastian Rudolph from an informal discussion.

C. Le Duc, M. Lamolle, and O. Cur e

(i) the first one, namely cycles, describes duplicate parts of a model resulting from
interactions of logic constructors in SHOIQ, (ii) the second one, namely blockingblocked cycles, describes parts of a model bordered by cycles which allow a frame to
satisfy transitive closure of roles occurring in concepts of the form R+.C.

2 The Description Logic SHOIQ(+)

In this section, we present the syntax, the semantics and main inference problems of
SHOIQ(+). In addition, we introduce a tableau structure for SHOIQ(+), which allows us to represent a model of a SHOIQ(+) knowledge base.
Definition 1. Let R be a non-empty set of role names and R+  R be a set of transitive role names. We use RI = {P
 | P  R} to denote a set of inverse roles, and
R = {Q+ | Q  R  RI} to denote a set of transitive closure of roles. Each element
of R  RI  R is called a SHOIQ(+)-role. A role inclusion axiom is of the form
R  S for two SHOIQ(+)-roles R and S such that R / R and S / R. A role
hierarchy R is a finite set of role inclusion axioms. An interpretation I = (
,I

)

consists of a non-empty set 
which maps each role name
to a subset of 

(domain) and a function I
such that

I  
I | y, x  R
I} for all R  R,
= {x, y  
implies x, y  S
for each S  R+, and
,z, y  S
?

?

?
(Qn)
(Q+)
with (Q1)
= Q
=
I} for Q+  R
= {x, y  (
)2 | z  
,x, z  (Qn1)
,z, y  Q
n>0
?

?

?
(Qn)
 An interpretation I satisfies a role hierarchy R if R
for each R  S  R.
I  S
Such an interpretation is called a model of R, denoted by I |= R. To simplify notations
for nested inverse roles and transitive closures of roles, we define two functions 
and


I  

I
x, z  S

)+ if R = S+, S  R,

and S  R;
)+, S  R


if R  R;
if R = (S+)+ and S  R;

and S  R
 
 | Q  R  RI}. We
 | P 
 | P  R  RI} such that QR  R+. A role R is called simple w.r.t. R

and S  R;

if R = (S
 A relation  is defined as the transitive-reflexive closure R+ of  on R  {R
 | R  S  R}  {R

define a function Trans(R) which returns true iff there is some Q  R+  {P
R+}  {P
if Trans(R) = false.

 | R  S  R}  {Q  Q

)+ if R = S
)+ if R = (S+)

 R+

S+

(S

(S

 R

if R  R;

if R = S

as follows:




(S
S+

  S

=

,
?

?

?


=



The reason for the introduction of two functions 

in Definition 1 is that
)+.
they avoid using R
is not allowed in a role hierarchy R since
According to Definition 1, axiom R  Q
this may lead to undecidability [10] even if R is simple. Notice that the closure R+
may contain R  Q

and R++. Moreover, it remains a unique nested case (R

if R  Q belongs to R.

and 






?

?

?
= 

={x  

I | |{y  C

, (C  D)

= 
= {x  

Definition 2 (terminology). Let C be a non-empty set of concept names with a nonempty subset Co  C of nominals. The set of SHOIQ(+)-concepts is inductively
defined as the smallest set containing all C in C, , C  D, C ! D, C, R.C, R.C,
( n S.C) and ( n S.C) where n is a positive integer, C and D are SHOIQ(+)-
concepts, R is an SHOIQ(+)-role and S is a simple role w.r.t. a role hierarchy. We
denote  for . The interpretation function I
,I
of an interpretation I = (

) maps
such that I
I  D
?

?

?
each concept name to a subset of 
,
= C
(C!D)
I}| = 1 for all o  Co, (R.C)
, |{o
= {x 
I\C
, (C)
ID
?

?

?
= C
I | y  
I}, (R.C)
, x, y 
I | y  
I  y  C
, x, y  R
?

?

?

= {x  
I|  n},
I | x, y  S
I | |{y  C
I}, ( n S.C)
I  y  C
?

?

?
( n S.C)
I|  n} where |S| is denoted for the
I | x, y  S

cardinality of a set S. An axiom C  D is called a general concept inclusion (GCI)
where C, D are SHOIQ(+)-concepts (possibly complex), and a finite set of GCIs is
called a terminology T . An interpretation I satisfies a GCI C  D if C
and I
satisfies a terminology T if I satisfies each GCI in T . Such an interpretation is called
a model of T , denoted by I |= T . A pair (T ,R) is called a SHOIQ(+) knowledge
base where R is a SHOIQ(+) role hierarchy and T is a SHOIQ(+) terminology. A
knowledge base (T ,R) is said to be consistent if there is a model I of both T and R,
i.e., I |= T and I |= R. A concept C is called satisfiable w.r.t. (T ,R) iff there is some
I = . Such an interpretation is called
interpretation I such that I |= R, I |= T and C
a model of C w.r.t. (T ,R). A concept D subsumes a concept C w.r.t. (T ,R), denoted
by C  D, if C

Since unsatisfiability, subsumption and consistency w.r.t. a SHOIQ(+) knowledge
base can be reduced to each other, it suffices to study knowledge base consistency. For
the ease of construction, we assume all concepts to be in negation normal form (NNF),
i.e., negation occurs only in front of concept names. Any SHOIQ(+)-concept can be
transformed to an equivalent one in NNF by using DeMorgans laws and some equivalences as presented in [11]. According to [12], nnf(C) can be computed in polynomial
time in the size of C. For a concept C, we denote the nnf of C by nnf(C) and the
nnf of C by  C. Let D be a SHOIQ(+)-concept in NNF. We define cl(D) to be
the smallest set that contains all sub-concepts of D including D. For a knowledge base
(T ,R), we reuse cl(T ,R) introduced by Horrocks et al. [7] to denote all sub-concepts
occurring in the axioms of (T ,R) as follows:

holds in each model I of (T ,R).

I  D

I  D
?

?

?
cl(T ,R) =
cl(E,R) = cl(E)  {  C | C  cl(E)} 

cl(nnf(C ! D),R) where

CDT

{S.C | (R.C  cl(E), S R) or (  R.C  cl(E), S R)
?

?

?
where S occurs in T or R} 
.C)

cl(Q.C ! Q.Q



Q.C occurs in T

(1)

(2)

(3)

Since (1) consists of sub-concepts from T and (2) is formed from concepts in (1)
by replacing a role or a logic constructor with respective another role occurring in R or
?

?

?
(nS.C)
?

?

?
j /I

Cj

|(T ,R)|

(S.C)
(nS.C)

(nS.C) where Ci

C. Le Duc, M. Lamolle, and O. Cur e

another logic constructor, both of these sets are bounded by O(|(T ,R)|). Thus, cl(T ,R)
is bounded by O(|(T ,R)|).
We have cl(T ,R) is bounded by O(|(T ,R)|) [7]. To translate star-type and frame
structures presented by Pratt-Hartmann (2005) for C2 into those for SHOIQ, we need
to add new sets of concepts, denoted cl1(T ,R) and cl2(T ,R), to the signature of a
SHOIQ(+) knowledge base (T ,R).
cl1(T ,R) = { mS.C | {( nS.C), ( nS.C)}  cl(T ,R) = , 1  m  n} 

{ mS.C | {( nS.C), ( nS.C)}  cl(T ,R) = , 1  m  n}
For a generating concept ( nS.C) and a set I  {0, ,&log n + 1}, we denote

C I
(nS.C) are new concept names
(nS.C) =
iI
for 0  i  &log n + 1. We define cl2(T ,R) as follows:
cl2(T ,R) = {Ci
{C I

| ( nS.C)  cl(T ,R)  cl1(T ,R), 0  i  &log n + 1}
| ( nS.C)  cl(T ,R)  cl1(T ,R), I  {0,,&log n + 1}}
Remark 1. If numbers are encoded in binary then the number of new concept names
(nS.D) for 0  i  &log n + 1, is bounded by O(|(T ,R)|) since n is bounded
Ci
by O(2
). This implies that |cl2(T ,R)| is bounded by O(|(T ,R)|). Note that
(nS.C) are disjoint for all I, J  {0, ,&log n + 1},
two concepts C I
(nS.C) and C J
I = J. The concepts C(S.C) and C I
(nS.C) will be used for building chromatic star-
types. This notion will be clarified after introducing the frame structure (Definition 6).
Finally, we denote CL(T ,R) = cl(T ,R)  cl1(T ,R)  cl2(T ,R), and use R(T ,R)
to denote the set of all role names occurring in T ,R with their inverse. The definition
of CL(T ,R) is inspired from the Fischer-Ladner closure that was introduced in [13].
The closure CL(T ,R) contains not only sub-concepts syntactically obtained from T
but also sub-concepts that are semantically derived from T w.r.t. R. For instance, if
S.C is a sub-concept from T and RS  R then R.C  CL(T ,R).
To describe a model of a SHOIQ(+) knowledge base in a more intuitive way, we
use a tableau structure that expresses semantic constraints resulting directly from the
logic constructors in SHOIQ(+).
Definition 3. Let (T ,R) be an SHOIQ(+) knowledge base. A tableau T for (T ,R)
is defined to be a triplet (S,L,E) such that S is a set of individuals, L: S  2CL(T ,R)
and E: R(T ,R)  2SS. For all s, t  S, C, C1, C2  CL(T ,R), and R, S, Q
 
R(T ,R), T satisfies the following properties:
P1 If C1  C2  T and s  S then nnf(C1 ! C2)  L(s);
P2 If C  L(s), then C / L(s);
P3 If C1  C2  L(s), then C1  L(s) and C2  L(s);
P4 If C1 ! C2  L(s), then C1  L(s) or C2  L(s);
P5 If S.C  L(s) and s, t  E(S), then C  L(t);
P6 If S.C  L(s) then there is some t  S such that s, t  E(S) and
P7 If S.C  L(s) and s, t  E(R) for RS and Trans(R) then R.C  L(t);

{C, C(S.C)}  L(t);
?

?

?
P8 If Q



.C  L(s) then (Q.C ! Q.Q

.C)  L(s) and there are s1, , sn1
 S such that Q.C  L(s0)  L(sn1), si, si+1  E(Q) with 0  i < n  1,
s0 = s and Q

.C  L(sj) for all 0  j < n  1.




?

?

?
P9 s, t  E(R) iff t, s  E(R
P10 If s, t  E(R), RS then s, t  E(S);
P11 If ( n S C)  L(s) then there are t1, , tn  S such that

}  L(ti) and s, ti  E(S) for all 1  i  n, and
{C, C Ii
Ij , Ik  {0, ,&log n + 1}, Ij = Ik for all 1  j < k  n;

(nS.C)

);

P12 If ( n S C)  L(s) then |ST (s, C)|  n;
P13 If ( n S C)  L(s) and s, t  E(S) then
P14 If o  L(s)  L(t) for some o  Co then s = t.
P15 For each o  Co, if o occurs in T then there is s  S such that o  L(s).

{C, .C}  L(t) =  where ST (s, C) := {t  S|s, t  E(S)  C  L(t)};

Note that the property P8 is added to deal with transitive closure of roles. The following
lemma establishes the equivalence between a model of an ontology and a tableau.
Lemma 1. Let (T ,R) be a SHOIQ(+) knowledge base. (T ,R) is consistent iff there
is a tableau for (T ,R).

A proof of Lemma 1 can be found in [14].

3 A Decision Procedure For SHOIQ(+)

This section starts by translating star-type and frame structures presented by PrattHartmann (2005) for C2 into those for SHOIQ(+).
Definition 4 (star-type). Let (T ,R) be a SHOIQ(+) knowledge base. A star-type
is a pair  = (), (), where ()  2CL(T ,R) is called core label, () =
(r1, l1, ,rd, ld) is a d-tuple over 2R(T ,R)  2CL(T ,R). A pair r, l is a ray of
 if r, l = ri, li for some 1  i  d. We use r(), l() to denote a ray  = r, l
where r() = r and l() = l.
 A star-type  is nominal if o  () for some o  Co.
 A star-type  is chromatic if  = 

implies l() = l(

) for two rays , 

of .
?

?

?
 Two star-types , 

When a star-type  is chromatic, () can be considered as a set of rays.
?

?

?
are equivalent if () = (

) such that () = 

between () and (

implies r(
?

?

?
We denote  for the set of all star-types for (T ,R).
?

?

?
) = r() and l(

), and there is a bijection 
) = l().
?

?

?
Note that for a chromatic star-type , () can be considered as a set of rays since
rays are distinct and not ordered. We can think of a star-type  as the set of individuals
x satisfying all concepts in (), and each ray  of  corresponds to a neighbor
individual xi of x such that r() is the label of the link between x and xi; and xi
satisfies all concepts in l(). In this case, we say that x satisfies .

C. Le Duc, M. Lamolle, and O. Cur e

  ();

Definition 5 (valid star-type). Let (T ,R) be a SHOIQ(+) knowledge base. Let  be
a star-type for (T ,R) where  = (), (). The star-type  is valid if  is chromatic
and the following conditions are satisfied:
1. If C  D  T then nnf(C ! D)  ();
2. {A,A}   for every concept name A where  = () or  = l() for each
3. If C1  C2  () then {C1, C2}  ();
4. If C1 ! C2  () then {C1, C2}  () = ;
5. If R.C  () then there is some ray   () such that C  l() and R  r();
6. If ( nS.C)  () and there is some ray   () such that S  r() then
C  l() or  C  l();
7. If ( nS.C)  () and there is some ray   () such that C  l() and S 
r() then there is some 1  m  n such that {( mS.C), ( mS.C)}  ();
8. For each ray   (), if R  r() and RS then S  r();
9. If R.C  () and R  r() for some ray   () then C  l();
10. If R.D  (), S R, Trans(S) and R  r() for some ray   () then
11. If Q
12. If ( nS.C)  () then there are n distinct rays 1,  , n  () such that
{C, C Ii
}  l(i), S  r(i) for all 1  i  n; and Ij, Ik  {0, , log n +
1}, Ij = Ik for all 1  j < k  n;
13. If ( nS.C)  () and there do not exist n + 1 rays 0,  , n  () such that
C  l(i) and S  r(i) for all 0  i  n.
?

?

?
.C  () then (Q.C ! Q.Q

S.D  l();

.C)  ();

(nS.C)





Roughly speaking, a star-type  is valid if each individual x satisfies semantically all
concepts in (). In fact, each condition in Definition 5 represents the semantics of a
constructor in SHOIQ(+) except for transitive closure of roles. From valid star-types,
we can tile a model instead of using expansion rules for generating nodes as described
in tableau algorithms. Before presenting how to tile a model from star-types, we need
some notation that will be used in the remainder of the paper.
Notation 1. We call P = (1, 1, d1), , (k, k, dk) a sequence where i  ,
i  (i) and di  N for 1  i  k.
 tail(P) = (k, k, dk), tail(P) = k, tail(P) = k, tail(P) = dk and |P| = k.
 pi(P) = (i, i, di), pi
(P) = di for each 1  i  k.
 an operation add(P, (, , d)) extendsP to a new sequence with add(P, (, , d)) =

We denote L(P) = (tail(P)).

(P) = i and pi

(P) = i, pi

P, (, , d).

Definition 6 (frame). Let (T ,R) be a SHOIQ(+) knowledge base. A frame for (T ,R)
is a tuple F = N ,No, , , where
1. N is a set of valid star-types such that  is not equivalent to 
2. No  N is a set of nominal star-types;

  N ;

for all , 
?

?

?
() where r

A Decision Procedure for SHOIQ with Transitive Closure of Roles

3.  is a function that maps each pair (, ) with   N and   () to a sequence
(, ) = (1, 1, d1), , (m, m, dm) with i  N , i  (i), di  N for
1  i  m such that for each i with 1  i  m, it holds that l() = (i),
l(i) = () and r(i) = r
4.  is a function  : N  N. By abuse of notation, we also use  to denote a function
which maps each pair (, ) with   N and   () into a number in N, i.e.,
(, )  N.

Since a frame cannot contain two equivalent star-type (Condition 1 in Definition 6),
the number of different star-types in a frame is bounded. The following lemma provides
such a bound.
Lemma 2. Let F = N ,No, ,  be a frame for a SHOIQ(+) knowledge base
(T ,R). The number of different star-types is bounded by O(22

 | R  r()}.

() = {R

|(T ,R)|



).

|(T ,R)|

|(T ,R)|

) due to binary coding of numbers.

The lemma is a consequence of the following facts : (i) the number of different core
labels of star-types is bounded by O(|(T ,R)|), (ii) the number of different ray labels of
star-types is bounded by O(2
), and (iii) the number of different rays of a star-type
is bounded by O(2
The frame structure, as introduced in Definition 6, allows us to compress individuals
of a model into star-types. For each star-type  and each ray   (), a list (, ) of
triples (i, i, di) with i  (i) is maintained where i is a neighbor star-type of
 via   (), and di indicates the di-th layer of rays of i. We can think a layer of
rays of i as an individual that connects to its neighbor individuals via the rays of i.
The following definition presents how to connect such layers to form paths in a frame.
Definition 7 (path). Let F = N ,No, ,  be a frame for a SHOIQ(+) knowledge
base (T ,R). A path is inductively defined as follows:
1. A sequence , (, , 1) is a path, namely nominal path, if   No and   ();
2. A sequence P, (, , d) with P =  and tail(P) = (0, 0, d0), is a path if
 = 0. In this case, we say that P, (, , d)
(, , d) = pd0((0, 
is the 
) then P, (, , d)
Additionally, if P, (, , d) is a 
is a Q-neighbor of P. In this case, we say that P, (, , d) is a Q-neighbor of P,
or P is a Q

-neighbor of P, and two paths P, P, (, , d) are neighbors.

-neighbor of P and Q  r(

) and tail(P) = tail(P

-neighbor of P, (, , d).
if tail(P) = tail(P
?

?

?
). Since  is an
We define P  P
equivalence relation over the set of all paths, we use P to denote the set of all equivalence classes [P] of paths in F. For [P], [Q]  P, we define:
-neighbor) of [Q] if there are P  [P] and Q  [Q] such that
1. [P] is a neighbor (

Q
-neighbor) of P

is a neighbor (
2. [Q] is a reachable path of [P] via a ray   (tail(P)) if there are [P1], , [Pn] 
P such that [Pi] = [Pj] for 1  i < j  n, [P] = [P1], [Q] = [Pn], [P2] is the
-neighbor of [P1], [Pi+1] is a neighbor of [Pi] for all 1  i < n  1.
Q-neighbor of P

3. [Q] is a Q-neighbor of [P] if there are P  [P] and Q  [Q] such that Q

-neighbor of Q

)) for each 

, or P

is a

;
?

?

?
is a Q

;
?

?

?
C. Le Duc, M. Lamolle, and O. Cur e

), we have P  P

with tail(P) = tail(P

4. [Q] is a Q-reachable path of [P] if there are [P1], , [Pn]  P such that [Pi] =
[Pj] for 1  i < j  n, [P] = [P1], [Q] = [Pn], [P2] is the -neighbor of [P1],
and [Pi+1] is a Q-neighbor of [Pi] for all 1  i < n.

Since two paths P and P
meet at the same star-type (i.e. tail(P) = tail(P
))
and the same layer (i.e. tail(P) = tail(P
)) should be considered as identical, we
define the equivalence relation  in Definition 7 to formalize this idea. Note that for
if tail(P) = tail(P
two paths P,P
)
and tail(P) = tail(P
). This does not allow for extending tail(P) to tail([P]).
As a consequence, there may be several predecessors of an equivalence class [P].
However, we can define tail([P]) = tail(P), tail([P]) = tail(P) and L([P]) =
L(P). In the sequel, we use P instead of [P] whenever it is clear from the context.
In a tree-shaped structure where each node has a unique predecessor, each path P
is identical to its equivalence class [P]. This no longer holds for the general graph
structure. The notion of paths in a frame is needed to define cycles which are crucial to
establish termination condition when building a frame.
Definition 8 (cycle). Let F = N ,No, ,  be a frame for a SHOIQ(+) knowledge
base (T ,R) with a set P of paths in F. Let R be a set of pairs (Pr, r), called root
paths, where Pr  P and r  (tail(Pr)). Let  be a set of quadruples (P, ,Q, )
where P,Q  P (P = Q), respectively called cycled and cycling paths of  ,  
(tail(P)),   (tail(Q)), respectively called cycled and cycling rays of . A -
neighbor of a cycled (resp. cycling) path P is a cycled (resp. cycling) neighbor of P if 
is a cycled (resp. cycling) ray of P. We say that  is a cycle w.r.t. a set R of root paths
if for each quadruple (P, ,Q, )   the following conditions are satisfied:

1. o / L(P)  L(Q) 

(tail (P))(tail(Q)) l() for all o  Co;

2. L(P) = l(), L(Q) = l() and r() = r
3. for each ray 



().

4. for each ray 
?

?

?
  (tail(P)) that is not cycled, there are a sequence P1, ,Pn 
P, some (P0, 0,Q0, 0)   and a root path (Pr, r)  R such that Pi = Pj
-neighbor of P1, Pi+1 is a neighbor of
for 1  i < j  n, P1 = P, P2 is the 
Pi for 1  i < n, Pk = Q0 for some 1 < k < n  1, and Pn = Pr, Pn1 is a
r-neighbor of Pn with r  r.
  (tail(Q)) that is not cycling and each sequence P1, ,Pn 
P such that Pi = Pj for 1  i < j  n, P1 = Q, P2 is the 
-neighbor of Q, and
Pi+1 is a neighbor of Pi for 1  i < n, there is some (P0, 0,Q0, 0)   such
that one of the following conditions is satisfied:
(a) there is some 1 < k  n with Pk = Q0 or Pk = P0, and Pi is not a cycling
and cycled neighbor for all 1  i  k;
(b) there are Pn+1, ,Pn+m  P with P0 = Pn+m or Q0 = Pn+m such that
Pi = Pj for 1  i < j  n + m, Pi+1 is a neighbor of Pi for all n  i <
n + m, and Pi is not a cycling and cycled neighbor for all 1  i  n + m;
?

?

?
We use R0 to denote the set of all pairs (Pr, (tail(Pr))) where Pr is a nominal path.
A primary cycle 0 is a cycle w.r.t. R0. Furthermore, we define a reachable cycle 
of
is a cycle w.r.t. the set of all pairs (Pr, r) where Pr is a cycled path
a cycle of  if 
of  and r is the set of all cycled rays of Pr.
?

?

?
,Q

A Decision Procedure for SHOIQ with Transitive Closure of Roles

Note that a cycle  may encapsulate a loop if it includes two quadruples (P, ,Q, ),
(P
is a reachable path of Q via . A loop can be formed from
, 
a sequence P1, ,Pn  P (n > 3) such that P1 = Pn, Pi = Pj for 1  i < j < n
and Pi+1 is a neighbor of Pi for 1  i < n). Moreover, it is possible that there are two
quadruples (P, ,Q, ), (P
and P = P,
 = 
?

?

?
, 
and Q = Q,  = 

)   such that Q

) such that Q

= Q,  = 

= P,  = 

, or P
?

?

?
,Q
?

?

?
.

, 
?

?

?
, 
?

?

?
Intuitively, a (primary) cycle allows one to cut all paths started from nominal paths
of a frame into two parts : the first path which is connected to nominal paths is not
replicated while the second part can be infinitely lengthened. Condition 1, Definition
8 says that a cycle should not include nominal star-types which must not replicated.
Condition 2 says that a cycled path matches its cycling path via a ray with the same
label. Condition 3 not only provides the relationship between two paths P,Q for each
(P, ,Q, )   but also ensures that all non-cycled neighbors of each P are filled
in a cycle. Condition 4 ensures that an extension of cycled paths P via their cycled
neighbors is possible by replicating paths from its cycling path Q via cycling rays.

a frame to obtain a possibly infinite set P of paths. The following lemma characterizes

As a consequence, the existence of a cycle allows one to unravel a set P of paths in

this crucial property and provides a bound on the size of a cycle.
Lemma 3. Let F = N ,No, ,  be a frame for a SHOIQ(+) knowledge base
(T ,R). Let  be a cycle in F.

1. There exists an extensionP of paths between cycled and cycling paths such that
each path P0  P has exactly |(tail(P0))| neighbors.

2. If 
?

?

?
is a reachable cycle of  then |

|  ||  ||2

number of rays of a star-type, and  = 22|CL(T ,R)||R(T ,R)|

.

where || is the maximal

Assume that there is a pair of paths (Q,Q

is at level i + 1 if it has a neighbor at level i, and all neighbors of P

A proof of Lemma 3 can be based on the fact that all paths between cycling and
cycled paths of a cycle do not cross the borders defined by the cycle. Therefore, these
paths can be replicated and pasted to cycled paths. With regard to the size of a cycle, we
can use the following construction: each path starts from a nominal star-type in No and
is lengthened through star-types (more precisely, through layers of rays of star-types).
We define inductively a level n of a path P as follows: (i) all nominal paths are at level
0, (ii) a path P
are
at a level which are equal or greater than i. This implies that there are no two neighbor
paths which are located on two levels whose difference is greater than 1.
is a
-neighbor of Q at level i  1 iff there is a pair of paths (P,P
) such that P is at level
j > i, P
) = L(P),
is a -neighbor of P at level j + 1, and L(Q) = L(P
(). This implies that all such quadruples (P, ,Q, ) can form a cycle.

r() = r
Moreover, there are at most  different labels of pairs (Q, ). This implies that one
|  ||  ||2
cycle can be detected after creating at most 2 levels. Thus, we have |
where || is the maximal number of rays of star-type. A more complete proof of Lemma
3 can be found in [14].
path Q with (P, ,Q, )   goes through a star-type  = tail(P

Let  be a cycle in a frame. Definition 8 ensures that each reachable path of some
) with some

) such that Q is at level i > 1 and Q

), L(Q
?

?

?




, 

, 

C. Le Duc, M. Lamolle, and O. Cur e
,Q

(P
)  . As mentioned in Lemma 3, such a cycle allows one to unravel
infinitely the frame to obtain a model of a KB in SHOIQ (without transitive closure
of roles). However, such a cycle structure is not sufficient to represent models of a KB
.D  L(P) can be satisfied
with transitive closure of roles since a concept such as Q
by a Q-reachable path P
of P which is arbitrarily far from P. There are the following
possibilities for an algorithm which builds a frame: (i) the algorithm stops building the
frame as soon as a cycle  is detected such that each concept of the form Q
.D occurring in L(P) is satisfied for each cycled path P of , i.e., P has a Q-reachable path
with Q.D  L(P), (ii) despite of several detected cycles, the algorithm continues
P
building the frame until each concept of the form Q
.D occurring in L(P) is satisfied for each cycled path P of . If we adopt the first possibility, the completeness of
such an algorithm cannot be established since there are models in which paths satisfying concepts of the form Q
.D can spread over several iterative structures such as
cycles. For this reason, we adopt the second possibility by introducing into frames an
additional structure, namely blocking-blocked cycles, which determines a sequence of
cycles 1, , k such that i+1 is a reachable cycle of i for satisfying concepts of
the form Q
Definition 9 (blocking). Let F = N ,No, ,  be a frame for a SHOIQ(+) knowledge base (T ,R) with a set P of paths in F. A cycle 
is blocked by a cycle  if
there are cycles 1, , k with  = 1, 
= k such that i+1 is a reachable
cycle of i for 1  i < k, and the following conditions are satisfied:
1. For each 1  i < k, there is no cycle 

such that

.D.






?

?

?
(a) 
(b) For each (P, ,Q, )  

is a reachable cycle of i and i+1 is a reachable cycle of 
via a non cycled ray with Q.D  L(P

and each concept Q


?

?

?
, and

.D  L(P), P has a
) iff the -
via a non cycling ray with

of Q has a Q-reachable path Q
).

Q-reachable path P
neighbor Q
Q.D  L(Q



with Q.D  L(Q

2. For each (Pk, k,Qk, k)  k, there is some (P1, 1,Q1, 1)  1 such that

(a) L(P1) = L(Pk), L(Q1) = L(Qk), r(1) = r(k), and
(b) If there is a concept Q

.D  L(Pk) such that the path Pk has no Q-
) then the path Q1 has a Q-reachable

some 1  j < k such that Q
reachable path of Q

reachable path P
path Q such that the two following conditions are satisfied:
i. Q.D  L(Q), or Q has a Q-reachable path Q
ii. there are (Pj, j,Qj, j)  j, (Pj+1, j+1,Qj+1, j+1)  j+1 with
is a reachable path of Qj and Qj+1 is a
In this case, we say that the path Pk is blocked by the path Q1 via the ray k. 
Definition 9 provides an exact structure of a frame in which blocked paths can
be detected. Such a frame contains sequentially reachable cycles between a blocking
cycle 1 and its blocked cycle k, which allows for unravelling the frame between
k and 1, and satisfying all concepts of the form Q
.D in the labels of paths in
1. Condition 1 ensures that there is no useless cycle for the satisfaction of concepts
Q
.D which is located between two cycles i and i with i < k. For a concept
Q
.D  L(Pk) that is not satisfied from the path Pk to all existing paths (i.e. it is

with Q.D  L(Q






),

.
?

?

?


not satisfied in the past), it must be satisfied from Pk to paths that are devised by
unravelling (i.e. it is satisfied in the future). Therefore, it is required that such concepts Q
.D are satisfied in the future from the blocking path P1 of Pk (Condition
.D  L(P) that is not satisfied in the
2, Definition 9). Moreover, for a concept Q
past, either it is satisfied from P to some paths that are explicitly added to the frame,
or it is propagated to a some blocked path thanks to Property 11, Definition 4.







Remark 2. The constant k mentioned in Definition 9 depends to the number of distinct
ray labels (i.e. the triple L(P), r(), l() for each ray   tail(P)) occurring a
blocking cycle 1 and the number of concepts Q
.D occurring in each cycling path
label in 1. Since the number of distinct ray labels is bounded by  (Lemma 3) and
the number of concepts Q
.D occurring in each cycling path label is bounded by
CL(T ,R), we have k is bounded by 2   where  = 22|CL(T ,R)||R(T ,R)|
Definition 10 (valid frame). Let (T ,R) be a SHOIQ knowledge base. A frame F =
N ,No, ,  with a set P of paths is valid if the following conditions are satisfied:
1. For each nominal o  Co, there is a unique o  No such that o  (o) and
2. For each star-type   N ,  is valid.
3. If Q

.C  L(P0) for some P0  P then there are P,P  P such that one of

(o) = 1;



.

and Q.C  L(P0);

the following conditions is satisfied:
(a) P0 = P = P
(b) P
(c) P is a Q
P0.

-reachable of P

is a Q-reachable of P, and Q.C  L(P

, and Q.C  L(P
?

?

?
) where P = P0 or P blocks P0;
) where P = P0 or P blocks
?

?

?


Conditions 1-3 in Definition 10 ensure the satisfaction of tableau properties in Definition 3. Note that Condition 1 is compatible with the fact that cycles in a frame never
consist of nominal star-types (Definition 8). In particular, Condition 3 provides the satisfaction of concepts Q
.D occurring in the labels of paths thanks to the blocking
condition introduced in Definition 9.
We now present Algorithm 1 for building a valid frame. This algorithm starts by
adding nominal star-types to the frame. For each non blocked path P with a ray  
(tail(P)) such that (tail(P), ) = (tail(P)) + 1, the algorithm picks in a nondeterministic way a valid star-type  that matches tail(P) via , and updates the values
(tail(P), ), (, 
), eventually, (tail(P)) and () by
calling updateFrame( ). The algorithm terminates when a blocked cycle is detected.
To check the blocking condition, the algorithm can compare Ri for each new level i of
rays with each Rj for all j < i (the notion of levels of rays in a frame is given in the
proof of Lemma 3) where Rj is denoted for the set of different ray labels at level i. If
Rj = Ri and the last cycle that was detected located at some level l < j, then a new
(reachable) cycle from level j to i is formed.
Figure 2 depicts a frame when executing Algorithm 1 for K1 in the example presented in Section 1. The algorithm builds a frame F = N ,No, ,  where N =
{0, 1, 2, 3, 4} and No = {0}. The dashed arrows indicate how the function
(, ) can be built. For example, (0, 0) = {(1, 0, 1)}, (0, 1) = {(2, 
0, 1)}
?

?

?
), (tail(P), ), (, 
?

?

?
C. Le Duc, M. Lamolle, and O. Cur e

if there is no   N such that o  () then

Require: A SHOIQ(+) knowledge base (T ,R)
Ensure: A frame N ,No, ,  for (T ,R)
1: Let  be the set of all star-types for (T ,R)
2: for all o  Co do
3:
4:
5:
6:
7:
8: end for
9: while there is a path P that is not blocked and a ray   (tail(P)) such that

Choose a star-type o   such that o  (o)
Set (o) = 1, N = N  {o} and No = No  {o}
Set (o, ) = 0, (o, ) =  for all   (o)

end if

tail(P) = (tail(P), ) + 1 do
   such that there is a ray 
Choose a star-type 
?

?

?
) = (), r(
(), and
), l(
l() = (
  N implies (
?

?

?
, 


, 

) = r
) + 1 or (
?

?

?
) = (

)

updateFrame(, , 


?

?

?
  (
?

?

?
) = (

) satisfying
?

?

?
, 

) for all 

  (
?

?

?
)

10:

11:
12: end while

Algorithm 1. An algorithm for building a frame

Require: A star-type   N in a frame F = N ,No, ,  with a ray   (), and a new
?

?

?


) = r

()

) = (), r(
?

?

?
then
?

?

?
  (

, 
)
?

?

?
)

star-type 

with a ray 

) and l() = l(

) such that l() = (

Set (, ) = (, ) + 1
Let   () such that r() = r(
if (, ) == () then
Set () = () + 1

), l(
Ensure: updateFrame(, , 
1: if there exists a star-type   N such that  is equivalent to 
2:
3:
4:
5:
6:
7:
8:
9:
10: else
11:
12:
13:
14:
15:
16: end if

Add 
Set (, )=(, ) + 1

Set (
Set (
add((, ), (

end if
Set (, ) = (, ) + 1
add((, ), (, , (, )))
add((, ), (, , (, )))

) =  for all 

) = 1, (
, 

to N
?

?

?
) = 0 and (

) = 1 and (

 = 
?

?

?
, 

, 

, 1))

, 

, 
?

?

?
) = {(, , (, ))}

Algorithm 2. updateFrame(, , 

, 
?

?

?
) updates F when adding 
?

?

?
to N
?

?

?
where 0 and 1 are the respective horizontal and vertical rays of 0; 0 is the left ray of

1; 
0 is the vertical ray of 2. Moreover, the directed dashed arrow from 0 to 1 indicates that the ray 0 of 0 can match the ray 0 on the left ray of 1 since l(0) = (1),
r(0) = (0), r(0) = r

(0).



The algorithm generates (0) = 1, (1) = 1, (2) = 1 and forms a cycle 
consisting of the following quadruples : ((3, 3), 1, (3, 2), 2) (1 and 2 are the right
and left rays of 3, respectively) and ((4, 2), 3, (4, 1), 4) (3 and 4 are the right
and left rays of 4 respectively). Note that for the sake of brevity, we use just tail(P)
and tail(P) to denote a path in the quadruples.
The cycle  is blocked since all concepts S+.{o} occurring in cycled paths are
satisfied. A model of the ontology can be built by starting from 0 and getting (i) 4
via 1, (ii) 3 via 1, and (iii) 3 via 2. From 3 and 4, the model goes through 3
and 4 infinitely. Note that from any individual x satisfying 3 (or 4), i.e. the label
of x contains Q+.{o}, there is a path containing S which goes back the individual
satisfying 0. Thus, the concept Q+.{o} is satisfied for each individual whose label
contains Q+.{o}.

{o}, A

 A

{o}, A
0

, S



B,S+.{o}
?

?

?
{o}, A


, S

2

B,S+.{o}

1
?

?

?
B,S+.{o}

B,S+.{o}

B,S+.{o}



4
?

?

?
B,S+.{o}

B,S+.{o}



3



B,S+.{o}

Fig. 2. A frame obtained by Algorithm 1 for K1 in the example in Section 1

Lemma 4. Let (T ,R) be a SHOIQ(+) knowledge base.
1. Algorithm 1 terminates.
2. If Algorithm 1 can build a valid frame for (T ,R) then there is a tableau for (T ,R).
3. If there is a tableau for (T ,R) then Algorithm 1 can build a valid frame F for

(T ,R).

|(T ,R)|

Proof (sketch). Let k be a blocked cycle by 1. According to Remark 2, k is bounded
by O(2
). Moreover, after eliminating useless cycles between two cycles i
and i+1 for 1  i < k according to Condition 1, Definition 9 the number of useful
cycles between i and i+1 is bounded by O(22
). This implies that Algorithm
1 can add at most a triple exponential number of paths to the frame to form a blocked

cycle. For the soundness of Algorithm 1, we can extend the set P of paths to a set P
P allows one to satisfy concepts Q

of extended paths by unravelling the frame between blocking-blocked cycles. The set
.D in blocked paths which are not satisfied in the

|(T ,R)|


?

?

?
propagated to a blocked path via a Q-path. Therefore, it will be satisfied in P. Unlike

past. Moreover, a concept Q
.D of a path that is not satisfied in the past will be
the unravelling of a completion graph for SHOIQ where there is no loop in the model,
the unravelling of a frame may yield an infinite number of loops in the model. Note
that the unravelling of a frame replicates cycles which may encapsulate loops.



Regarding completeness, we first reduce a tableau to a frame that does not contain
any useless cycle. Then, we use the obtained frame to guide the algorithm (i) to choose
valid star-types, (ii) to ensure that () = 1 for each nominal star-type , and (iii) to
detect a pair (1, k) of blocking and blocked cycles as soon as some representative
concepts of the form Q
.D in 1 are satisfied. We refer the readers to [14] for a

complete proof of Lemma 4.



The following theorem is a consequence of Lemma 4.

Theorem 1. The problem of consistency forSHOIQ(+) can be decided in non-determi-
nistic triply exponential time in the size of a SHOIQ(+) knowledge base.

4 Optimizing The Algorithm
The algorithm for deciding the consistency of a SHOIQ(+) knowledge base (Algo-
rithm 1) uses at most a doubly exponential number of star-types to build a frame. This
is due to the fact that numbers are encoded in binary, that is, a star-type may have an
exponential number of rays. Pratt-Hartmann [9] has shown that it is possible to use an
exponential number of star-types to represent a model of a KB in C2 which is slightly
different from SHOIQ in terms of expressiveness. If we can transfer this method to
SHOIQ for compressing star-types, it would be applied to SHOIQ(+) since the number of star-types in a frame does not depend on the presence of transitive closure of
roles.
?

?

?
) and (

) but also (

, 

, 
is a neighbor of 

Another technique presented in [15] can be used to reduce non-determinisms due to
the choice of valid star-types. Instead of guessing a valid star-type from a set of valid
star-types, this technique allows one to build a star-type  by applying expansion rules
by
to concepts in the core label of . Hence, when a star-type  is transformed into 
an expansion rule, an algorithm that implements this technique has to update not only

of  and 
(

(
)). These updates must
. This process of
ensure that each path which has got through  can now get through 
changes can spread over neighbors of 
With regard to blocking, the technique presented in [15] can take advantage of a
specific structure of frames for SHOIQ to design an efficient algorithm for checking
blocking condition. This structure consists of partitioning star-types into layers. Although such a structure of frames cannot be maintained for SHOIQ(+), paths in a
frame for SHOIQ(+) would allow us to achieve the same behavior.
?

?

?
) for each neighbor 
) and (
)  (

, d

if there is some (

and so on.

, 
?

?

?
, 
?

?

?
5 Conclusion
In this paper, we have presented a decision procedure for the description logic SHOIQ
with transitive closure of roles in concept axioms, whose decidability was not known.
?

?

?
The most significant feature of our contribution is to introduce a structure based on
a new blocking condition for characterizing models which have an infinite non-tree-
shaped part. This structure would provide an insight into regularity of such models
which would be enjoyed by a more expressive DL, such as ZOIQ [6], whose decidability remains open. In future work, we aim to improve the algorithm by making it
more goal-directed and aim to investigate another open question about the hardness of
SHOIQ(+).
