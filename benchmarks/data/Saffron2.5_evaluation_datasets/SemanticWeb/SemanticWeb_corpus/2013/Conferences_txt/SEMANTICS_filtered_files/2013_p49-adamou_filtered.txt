The foundations of virtual ontology networks

Alessandro Adamou
KMi, The Open University,

United Kingdom

alessandro.adamou@open.ac.uk

Aldo Gangemi

LIPN, University of Paris 13,

France

Paolo Ciancarini

DISI, University of Bologna,

Italy

ciancarini@cs.unibo.it
Valentina Presutti

ISTC, National Research

Council, Italy

gangemi@lipn.univ-paris13.fr

valentina.presutti@cnr.it

ABSTRACT
The notion of ontology network is relatively recent and rooted
in the field of knowledge engineering. It concerns those ontology networks assembled at design time and established
by their authors. Nowadays, however, the need to deal with
heterogeneous semantic data sources, such as Linked Data
and reengineered resources, gives rise to new use cases: ontologies now also need to be selected and combined in ways
that were unpredictable at design time. This process is nontrivial and error-prone: if improperly dealt with, it can lead
to loss of expressivity when interpreting resources (e.g. RDF
graphs) as ontologies. Previous attempts at formally representing ontology relations assumed a controlled environment
where axioms are unequivocally determined, and as such did
not need to capture this distinction and its creeping issues.
One possible solution is to assemble ontology networks
at runtime by mimicking part of the design-time process;
however, this requires that the difference between ontology
networks assembled statically by their authors, and dynamically by consumer agents, be formally represented. The notion of virtual ontology network introduced here establishes
this distinction.
In this paper, we provide the theoretical
underpinnings of virtual ontology network management. We
define the representational primitives and abstract relationships that virtual networks are constructed upon.

To validate the theory and demonstrate the feasibility of
virtualization in contemporary ontology management, we
show that this formal framework is compatible with the existing theory of ontology relations. To that end, we illustrate
which constructs from existing representation languages can
be used to implement the relations that characterize a virtual ontology network. We show this both in OWL 2 and
with E-connections. This paper is a prelude to actual virtualization methods that we have devised and implemented:
the finalization of their evaluation is underway and will be
presented as a follow-up to the work presented herein.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear
this notice and the full citation on the first page. Copyrights for components
of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on
servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from Permissions@acm.org.
ISEM 13, September 04 - 06 2013, Graz, Austria
Copyright is held by the owner/author(s). Publication rights licensed to
ACM.
ACM 978-1-4503-1972-0/13/09. . . $15.00.
http://dx.doi.org/10.1145/2506182.2506189.

Categories and Subject Descriptors
I.2.4 [Artificial Intelligence]: Knowledge Representation
Formalisms and Methods

Keywords
ontology network, OWL, epsilon-connections

1.

INTRODUCTION

Ontology networks are a relatively recent concept, mostly
formulated in the knowledge engineering domain.
In lit-
erature, an ontology network is defined as a collection
of ontologies related together via a variety of relationships,
such as alignment, modularization, version and dependency
[9]. This definition presents ontology relationships in operational terms, in that some of these notions, such as alignment and modularization, describe the tasks performed on
the ontologies involved, rather than the actual outcome of
these tasks. This also explains why most of the literature
and methodological coverage on ontology networks concerns
the engineering part of their lifecycle, where ontologies are
authored, decomposed, reused etc. until they are published
as Web resources by their authors. At this point in time, the
management of these resources as parts of a connected structure ends, until they are picked up during the development
phase of another ontology network. Ultimately, however, ontology networks mostly remain limited to those assembled
by the authors of one or more of their components.

We can summarize the above by saying that ontology networks are typically conceived at design time, or that they are
static artifacts. However, the range of semantic applications
is growing to encompass multiple sources of data that can be
interpreted as ontologies and, for instance, reasoned upon or
enhanced by means of inference rules. Linked data obtained
in various forms, such as SPARQL queries, entity URI dereferencing and RDF dumps, are examples of such sources. So
are other heterogeneous data, such as Web Service output,
raw relational databases and custom XML content, once
reengineered into RDF. The latter, in turn, is still not a final form of an ontology, because within RDF we cannot yet
tell if a statement using a certain property will become an
annotation, data or object property axiom in OWL, which
is crucial for reasoning. Depending on the specific undertaking of an application at one time, a different set of ontologies
has to be treated like a single, interconnected ontology, and
as such processed. If that application needs to alter the con-

                                               49nectivity of an ontology for its own purposes (e.g. executing
alignment rules for refactoring ontologies), it has to maintain a local copy and manipulate the relations that define
its connectivity, e.g. import declarations and alignments. In
these scenarios ontology networks are assembled at runtime,
and their lifecycles controlled by applications, or more in
general, consumer agents. We call these ontology networks
dynamic1. Unlike static ontology networks, dynamic ones
do not necessarily outlive their creators, nor should they
necessarily be republished on the Web.

Shaping an ontology network at runtime can be tedious
and error-prone. First, the practicalities of performing this
task include adding or modifying statements in the data to
be interpreted, or creating new ontologies for the sole purpose of connecting others, not to mention republishing them
to controlled Web resources so that import targets resolve to
the modified ontologies. Having to perform these steps manually can be unfeasible at times, and introduces a cognitive
overhead that application developers will not necessarily ac-
cept. Second, the shape of the network can affect the interpretation of its nodes as ontologies in ways unforeseen, and
with a creeping negative impact that transcends the boundaries of Description Logics, which are the basis of Web on-
tologies. A frequent side-effect is that RDF triples that use
a certain property are resolved as annotation axioms, even
though there is another ontology in the knowledge base that
uses that property as an OWL object property.

It cannot be asked of application developers to know these
subtleties and the details on how to resolve them. This is
why we claim there is a need for a further level of formalization of Web ontologies, that takes into account issues that
standard ontology representation languages hardly consider.
Without this, the gap with the application world is at risk
of never being bridged, and semantic data, for most of their
part, would keep being processed without taking advantage
of the high-level semantics of ontologies and inferencing.

The aim of this paper is to introduce the theoretical underpinnings of a practice needed by modern semantic appli-
cations, i.e. dynamic ontology network assembly, which here
goes by the name of virtualization [of ontologies into ontology networks]. In Section 2 we describe the existing efforts in
formalizing ontology relations that inspired our work. Section 3 describes the theoretical framework itself and its arti-
facts, including [virtual] ontology networks themselves. To
validate this framework, we needed to show that it is compatible with existing ontology representation languages, i.e.
that they can be used for representing virtual ontology net-
works. In Section 4, we pick OWL 2 and E-connections as
languages that encompass ontology relations. Because this
theoretical work is a basis for further algorithmic and implementation efforts that we are already undertaking, Section
5 concludes with an overview of ongoing and future work.

2. RELATED WORK

Several attempts at specifying the relationships between
ontologies are the result of a bottom-up analysis work on domain ontologies, and as such are biased towards representing
conceptual similarities. Some of the properties defined for

1Note that the intended dynamism refers to the way an ontology appears to applications at runtime; a published ontology that results from an evolutionary process can certainly
be regarded as dynamic from the engineering standpoint.

describing relations are a consequence of viewing ontologies
as collections of agreements over domain terminologies, and
identify relations such as sharing conceptualizations (e.g. by
equivalence of applied logical theories), resemblance, simplification and composition of ontologies [7].

The Descriptive Ontology of Ontology Relations
(DOOR) attempts a rigorous definition of these relationships in the form of an ontology itself [1]. This modeling
approach uses the primitives and rules of ontology languages
to define a hierarchy of possible relations occurring between
two ontologies in a collection. DOOR distinguishes relationships holding at the lexicographic, syntactic, structural,
semantic and temporal levels. On the top level of the hier-
archy, there are inclusion relations, as well as agreement and
disagreement (further specialized using compatibility factors
which to manage incoherence or inconsistency), ABox/TBox
connections, alignments, similarities and versioning.

Diaz et al. argued that the relationships described in
DOOR required further specification, claiming that the logical constructs in the original ontology aimed at classifying
relations in a hierarchical structure, rather than applying
them directly. Therefore, they proceeded to provide DLbased definitions of some relations extracted from DOOR,
namely isTheSchemaFor, isAConservativeExtensionOf and
mappingSimilarTo, as well as extending them with a purely
syntactic relation called usesSymbolsOf [3].

The work presented in this paper is partly inspired from
the above work. However, our theoretical goal is not to
describe existing relations one by one, rather, to provide
a general-purpose framework that can accommodate relations resulting from, among other things, bottom-up anal-
ysis. That way, if further connectivity factors emerge from
future ontology use, our proposal can serve as a base toolkit
for rendering them formally. Also, the aforementioned approaches do not take into account the discrepancy between
the ontologies as high-level logical artifacts and their raw
sources which have to be interpreted as such, and only deal
with the former level. This is expectable, as these approaches
were the result of an analysis work over the way ontologies
are engineered. However, the content of these sources alone,
in terms of raw statements that map to logical axioms, does
not always match these axioms deterministically, as it occurs
with the conservative policies adopted by modern OWL applications and libraries such as the OWL API [6]. Then,
formal specifications like the ones above fall short of practi-
cability. For instance, if an ontology that is supposed to extend an object property of another ontology turns out having
its extensions classified as annotation properties  a likely
and verifiable scenario  then a relation such as isAConservativeExtensionOf can no longer hold between these.

Within the domain of OWL, which we assume as the family of languages that every ontology network should be interpreted as, distributed approaches have also been defined,
such as the E-connection language solution proposal devised
by Cuenca Grau et al. [2]. This proposal, dated as of OWL
1, was justified by the failure of the more common OWL
imports to deliver logical modularity and contextualized ax-
ioms, something that the introduction of punning in OWL
2 now brings into question [4]. If the E-connection theory
is adapted to OWL 2, then it will be possible (and advis-
able) to design and implement virtualization methods based
on these knowledge representation languages, which is the
reason why we will explore its applicability in Section 4.2.

                                               503. THEORETICAL FRAMEWORK

The representational primitives of virtual ontology networks are introduced in two dedicated sections. In Section
3.1 we define the basic concepts around ontology networks,
both real and virtual, and establish the separation between
ontologies and their sources in the theory. In Section 3.2 we
describe the classes of artifacts, i.e. what there actually is in
a virtual ontology network, and how these objects relate to
the original (pre-virtualization) ontologies or their sources.

3.1 Ontology networks

We now give a formal equivalent of the intuitive definition
given in the introduction. For the following, the term signature of an axiom (resp. ontology) will be used to identify the
set of all the entities, non-literal, referenced by that axiom
(resp. all the axioms in the ontology). This is a commonly
accepted notation [8] in ontologies and description logics.

Definition (ontology and knowledge base).

An ontology is here defined as a triplet o = (N, T, A),
where N is a set of non-logical (i.e. not computable) ax-
ioms, T is a set of terminological axioms (TBox), and A is
a set of assertional axioms (ABox). A set of ontologies O is
also called a knowledge base.

The name of an ontology is not a parameter of its own,
since anonymous ontologies are contemplated at this stage,
and their naming can safely be delegated to a member of N .

Definition (ontology source).

An ontology source so for an ontology o is an object such
that a resolution function f exists, that can be applied to
so in order to output o. It is then said that f (so) = o, or so
resolves to o, or so is a source for o.

Practically, so can be a file in an RDF format, the result
of a SPARQL query, or even a non-RDF nor native OWL
resource at all, if we have a way of obtaining an ontology
from it. The resolution function f is the one responsible for
the (possibly unexpected) interpretation of raw statements
in so as axioms in o. We will assume f to be given and not
re-definable, but virtual networks can still be manipulated to
trick f into providing optimal expressiveness for its axioms.
Let us now provide a base for ontology relations, as are

those specified in DOOR and its extensions [1, 3].

Definition (direct dependency).
Let O be the set of all ontologies, or universal knowledge
base. Then a direct dependency is a relation d : O  O so
that d(oi, oj) (to be read as oi directly depends on oj) is
true iff, given oi = (N, T, A), a  N  T  A so that the
signature of a includes either oj or soj .

By the above definition, an ontology directly depends on
another ontology if it references the latter, either directly
or via its source, in some axiom, even (and especially) non-
logical. The meaning of this definition is as simple as it is
strong. Since the universe of ontologies O is assumed to
be known in the definition, we can always tell if the concept
referenced by an axiom is an ontology, an ontology source, or
neither. In other words, there is a global knowledge of which
identifiers reference ontologies and which do not, but that

does not imply local knowledge within one ontology of O.
The property used as the axiom predicate alone does not
necessarily imply its subjects or objects being ontologies,
although this may be true in cases such as owl:imports.

Example.

Suppose an ontology has the following axioms (in OWL

functional syntax):

ClassAssertion( owl:Thing :in1 )
AnnotationAssertion( rdfs:isDefinedBy :in1

<http://example.com/resource/res1> )

These axioms state that :in1 is a named individual (which
follows from it being an owl:Thing), and that any further
information that defines :in1 is somehow addressed by the
object of the assertion, which incidentally is an IRI. If that
IRI is the location of an ontology source or the identifier of an
ontology, then we can say that a direct dependency relation
holds. Otherwise, if <http://example.com/resource/res1>
resolves to an image or a document in PDF that describes
it, and we are not accepting that resource as an ontology,
then no direct dependency is implied.

If the ontology has an import declaration (e.g. an inter-

preted owl:imports triple in its RDF source) such as:

Ontology( <http://www.example.com/ontology/1>

Import( <http://www.example.com/ontology/2> ) )

then this ontology, whose name is <http://www.example.com
/ontology/1>, depends on the ontology whose source is identified by the IRI in the Import declaration <http://www.
example.com/ontology/2>. Recall [8] that OWL 2 uses an
import-by-location scheme, so the object of the Import dec-
laration, i.e. the import target, is expected to be a dereferenceable URL that resolves into a resource that can be
interpreted as an ontology, otherwise an anomaly occurs.

Other vocabularies can define direct dependency relationships if so we choose: for example, rdfs:isDefinedBy triples
may be regarded as direct dependency predicates whenever
their objects are ontologies or ontology sources.

Direct dependency is not transitive. For completeness, a

recursive definition of its transitive extension is provided.

Definition (dependency).

A dependency is a relation d : O  O so that d(oi, oj)

(to be read as oi depends on oj) iff:

1. either d(oi, oj) or
2. k, k = i, j : d(oi, ok) and d(ok, oj).
A weaker kind of dependency, called connectivity, follows.

Definition (connectivity).

A connectivity relation is a relation c : O  O so that

c(oi, oj) (to be read as oi is connected to oj) iff:

1. either d(oi, oj) or
2. oi = (N, T, A) a  N  T  A so that the signature of
a includes an element of oj, i.e. an entity contained in
the signature of oj.

Connectivity is weaker than direct dependency, as in O
there are more connected ontologies than there are ontologies that directly depend on one another; it follows from

                                               51condition 1 of the definition, that the set of the former includes that of the latter. Also note that connectivity is not
an equivalence relation, since it is not transitive and condition 1 denotes a non-symmetric relation. On the contrary,
the relation denoted by condition 2 is symmetric, because
the usage of one concept in two ontologies implies its presence in both of their signatures, and there is no such notion
as using in ontology A a concept defined in ontology B,
since the definition of a concept lies in its usage.

Definition (ontology network).
Given a knowledge base O = {oi}, an ontology network for
O is any maximal subset ON of O where oi  ON oj 
ON , i = j so that:

1. either c(oi, oj) or c(oj, oi) is true;
2. if both c(oi, oj) and c(oj, oi), then k, i = k = j so

that {oi, ok, oj} is an ontology network for itself.

According to the definition above, mutual connectivity between two ontologies in an ontology network is possible, so
long as it is not the only existing connectivity relationship
involving those ontologies. The latter requirement is an expedient for making sure one ontology can always be elected
as the entry node for parsing the entire network. The maximality requirement means that if any ontology in O that is
not connected (i.e. does not fulfill the connectivity condi-
tions) is added to ON , then ON is not an ontology network
anymore. In other words, ontology networks cannot have is-
lands. Also note that, as there is no minimality requirement,
a so-defined ontology network tolerates broken links. This is
necessary in order to conform to the open world assumption
(OWA) made in OWL [5]. Suppose two ontologies o1 and
o2 in O are strictly weakly connected, i.e. o1 is connected
to, but not dependent on, o2. Then it means these two ontologies are using some entity e in common. If o1 belongs to
an ontology network that does not include o2, this simply
means that the axioms in o2 concerning e will not be part of
the ontology network, but will not invalidate the ontology
network either, otherwise the OWA would be violated.

Detecting an ontology network in a set of ontologies means
picking as many mutually connected ontologies as possible
from the set, as long as there is only one connected com-
ponent. All this is performed by taking the ontologies as
they are, with all the logical and non-logical axioms they
come with.
In other words, they are real ontology net-
works, whose connectivity is established by the agents that
created and published the ontologies. We refer to these ontology networks as real in order to distinguish them from
those created by manipulating some axioms of these ontologies and not necessarily re-publishing them in this form. We
will call those ontology networks virtual.

Definition (virtual ontology network).

Given a set of ontologies O = {oi}, a virtual ontology

network for O is a set of ontologies OVso that:

1. OV is an ontology network for its own members;
2. o = (N, T, A)  O:

(a) oV = (N, T , A)  OV
(b) for any axiom in N that references an ontology,

that ontology is in OV;

3. o  O : o / OV
A way to read this definition informally could be that a
virtual ontology network can be constructed by taking a set
of ontologies and adding or replacing some axioms that connect these ontologies. Per (2), there is an ontology in the
virtual network for each ontology in the initial set O (a), and
the virtual network references only ontologies within itself
(b). Per (3), if the original set of ontologies is already an
ontology network, a virtual ontology network cannot match
it, since they have to differ by at least one ontology. How-
ever, a virtual ontology network can add axioms to a real
one and preserve its nature as an ontology network.

By the above definition, it would seem that a virtual ontology network can be constructed on top of a set of ontologies by adding axioms (both logical and non-logical) that
reference ontologies in the set, or their entities. This is in-
exact, as a method for creating virtual networks must be
strong enough to work not by manipulating axioms in the
ontology, but by manipulating raw statements in its source
so that a resolution function f can be tricked into delivering axioms of the desired classes. This is the reason why
the respective members of (N, T, A) and (N, T , A) are not
bound to one another in the general case: we may require
these sets to have specific properties as needed, and develop
virtualization methods accordingly. For example, we might
desire that, if T contains an object property declaration in
one ontology of O, then for all the ontologies of OV there is
no usage of that property in their N s but only in their T s.
3.2 Artifacts

This section introduces the novel classes of primitive objects usable in any method designed for building virtual ontology networks. The core artifacts introduced herein are
those that allow ontologies to be part of a network. How-
ever, there are additional supporting artifacts and notions
employed in combination with them, which can be useful for
the conversion of this framework to ontological standards
such as OWL 2.

Let us first introduce a general referencing mechanism for

addressing ontologies through mnemonic identifiers.

Definition (ontology reference).

A reference $o for an ontology o is a pair $o = (io, vo),
where io and vo are two objects, respectively called ontology
identifier and version identifier, that support a concatenation operator. Each ontology reference is unique within a
knowledge base, that is, given a knowledge base O = {oj, j =
1..n}, then for any k, l  {1..n} $ok = $ol iff k = l.

The relationship between this definition and the IRI pair
(ontologyIRI, versionIRI) that (optionally) identifies ontologies in OWL 2 [8] is evident. At this stage, however,
there is no enforcement on the members of an ontology reference being IRIs, hence their underspecification as objects.
The key requirements, which the following artifacts will jus-
tify, are that a reference be a pair, and that both the reference and its members should support a concatenation operator (though not necessarily the same), which we shall refer
to using the vector concatenation symbol ||.

It can be surmised from the definition above, that ontology references and the integers used earlier for indexing
members of a knowledge base are interchangeable, i.e. a bijective function  : O  N exists for any O. Therefore,

                                               52Figure 1: Virtualization of a knowledge base O with two connected components (o1, o2) and (o3, o4, o5) (below dashed line)
into a single connected virtual network oV using three ontology collectors C1, C2 and C3 (above dashed line). The arrows
in the upper section all denote connectivity relations holding between virtualized ontologies and the ontological forms of C1,
C2 and C3, replacing the original connectivity relations.

the uniqueness of ontology references can be restricted to a
narrower scope than the whole Web.

We now proceed to lay out the definitions of the new components for an ontology network architecture as described
here. The following will provide a definition of the abstract
notion of ontology collector. An ontology collector is the
primary artifact that keeps track of references to those ontologies which were not originally created as part of an ontology network, or at least not a subnetwork of the (explicit)
virtual network that is being assembled. The name is to signify that this type of artifact is neither a collection of, nor
a container for ontologies, assuming that collecting or containing ontologies means referencing their axioms, and not
the ontologies as atomic objects.

Definition (ontology collector).

An ontology collector C in a knowledge base O is a pair

C = (IC , RC ), where:

1. for no o  O there is x so that IC||x = $o, where || is
a concatenation operator that applies to members of
the domains of IC and $o.

2. RC is a set of $o for some o  O.
IC is called the identifier of the ontology collector, and
per (1), it is never the prefix of any reference $o for any
ontology in O. RC is called the reference set of the ontology
collector. If $o  RC , o  O, then o is said to be managed by
C (through $o). Conversely, C manages o. Because IC has
to be comparable to ontology references, as it must share
their concatenation operator, it will sometimes be expanded
as (iC ,) or (iC , nil), indicating that any version identifier is
either disregarded or explicitly null for ontology collectors.

An ideal assumption concerning the existence of ontologies
on the Web is that each logical identifier, comprehensive of a
version indicator, uniquely identifies a set of logical axioms.
While the Web is far from realizing this vision, the assumption becomes far more reasonable when the knowledge base

Imaging

at hand is a controlled environment. Because virtual ontology networks are not required to be persistent and have all
of their parts uniquely identifiable on the Web, we can shift
the problem towards ensuring the uniqueness of identifiers
for the provided ontologies with respect to the outside world.
We then summarily distinguish global uniqueness from local
uniqueness, the former applying to the entire unbounded
Web, the latter being restricted to the knowledge base directly accessed by the framework. In global uniqueness, any
$o is a reference for o in the universal knowledge base O,
whereas local uniqueness holds within a knowledge base O
but not necessarily in O. The uniqueness problem can then
be formulated as follows: given a knowledge base where local
uniqueness is guaranteed, expose its ontologies to the Web
so as not to impair global uniqueness.

Guaranteeing local uniqueness within O means ensuring
that ontology references can be used for unambiguously addressing its ontologies. If O is an ontology network, local
uniqueness comes for free, but if it is not, then local uniqueness should be guaranteed at least for a virtual ontology
network OV . A strategy for doing so is by manipulating
the sources of the ontologies in O, thereby obtaining other
ontologies. This operation is what we call imaging.

Definition (ontology image).
Given an ontology o = (N, T, A) and an ontology collector
C = ((iC ,), RC ) so that $o  RC , then the image of o
with respect to C (or C-image of o) is an ontology oC =
(N C , T C , AC ) so that:

1. N C always contains exactly one ontology naming ax-

2. $C

iom and one ontology versioning axiom;
o = (i, v), where iC is a prefix for either i or v
(i.e. w.(i = iC||w  v = iC||w) where || is a
concatenation operator), is a valid reference for o;

3. if f is a resolution function so that f (so) = o, then

also f (soC ) = oC .

From the standpoint of ontology collectors, the image of

                                               53an ontology is the outcome of the manipulation that an ontology collector performs on the ontology it manages. The
essential meaning of this definition, especially in (3), is that
the raw statements in the source of o can be manipulated so
that the same resolution function, once applied to the modified source, still produces an ontology, and that ontology
has at least characteristics (1) and (2).

Note that the above conditions do not imply that a single
ontology collector should be responsible for imaging the entire knowledge base into a virtual ontology network, but only
that every ontology in the virtual network must be managed
by at least one collector.
3.3 Assembly

We need to combine instances of the above artifacts in
order to obtain an ontology network as defined earlier in
this section. The following items can be used for assembling
a virtual ontology network OV given a knowledge base O:

1. A set of ontology collectors C = {Ci|i = 1..n}.
2. For each o  O, an image of o with respect to at least

one ontology collector in C.

To that end it has to be possible to export an ontology
collector itself to an ontology, i.e. every Ci must have an ontological form. We will show a possible procedure for OWL
2 in Section 4.1. The number of ontology collectors to be
used, and the distribution of ontologies in O across collec-
tors, both depend on the virtualization method: one possible
rationale is to employ as many collectors as is the maximum
length of a dependency/connectivity relation chain.

We have exemplified such a scheme for virtual ontology
network assembly in Figure 1. There, the knowledge base
O has two connected components (o1, o2) and (o3, o4, o5),
and we want to obtain a single connected OV that respects
the same direct dependency (non-symmetric) or connectivity
(symmetric) relations holding between the members of each
connected component. This example uses three ontology
collectors C1, C2 and C3, as many as the size of the largest
connected component.

Above in the figure, for each ontology managed by a col-
lector, there is a direct dependency holding from the ontological form of that collector to its image of the managed
since C3 manages o5, then the ontological
ontology (e.g.
form of C3 directly depends on oC3
5 ). Also, there is a total
ordering defined for ontology collectors, and every ontology
image with respect to a collector directly depends on the ontological form of the predecessor (e.g. oC3
5 depends on C2).
Therefore, in order to obtain the entire ontology network, it
will be sufficient to load the ontological form of C3.

4. VALIDATION ON EXISTING THEORIES
One of the possible ways to validate a theoretical work,
which preludes to traditional experimental evaluation, is to
prove that it is a sound match with reality or with the existing theory. To that end, we can demonstrate that virtualization in ontology networks can be represented using existing
ontology languages which are either common or have desirable properties, and that in addition it shows properties
that do not belong to those languages. In this section, we
will show how virtualization can be implemented in a standard language, i.e. OWL 2, and in an extension of OWLDL for representing contexts in ontology relationships, i.e.

E-connections, bearing in mind that, on top of these, the
virtual ontology network theory maintains a separation between ontologies and their sources, which allows us to keep
track of issues related to ontology resolution.
4.1 OWL 2

In this section, we show one possible way of manipulating
constructs of the latest OWL ontology language in order to
represent a virtual ontology network out of a given knowledge base, without extending the language itself or altering
the semantics of its constructs. This particular approach
explicitly manipulates non-logical axioms only, and leaves it
up to the resolution function to derive its logical axioms.
We will assume the na ve ontology network for a knowledge base O to be O{o0}, where o0 is an ontology that, for
each oi  O, contains an OWL import declaration pointing
to soi . We also assumed to be given the resolution function
f , and that we cannot replace it with another function. In
the work that follows up from this paper, we will demonstrate how some common f can be tricked into generating
more expressive logical axioms from a virtual network than
from its na ve counterpart.

We will refer to the structural syntax of the OWL 2 language [8]. An excerpt of its grammar (in EBNF) is reported
below:
(cid:104)ontology(cid:105) ::= Ontology ( [ (cid:104)ontologyID(cid:105) ]

(cid:104)importDeclarations(cid:105) (cid:104)ontologyAnnotations(cid:105)
(cid:104)axioms(cid:105) )

(cid:104)ontologyID(cid:105) ::= (cid:104)IRI(cid:105) [ (cid:104)IRI(cid:105) ]
(cid:104)importDeclarations(cid:105) ::= { Import ( (cid:104)IRI(cid:105) ) }
(cid:104)axioms(cid:105) ::= { (cid:104)Axiom(cid:105) }

The nonterminal (cid:104)ontologyID(cid:105), appearing at most once in
an ontology, can be used to represent ontology references in
virtual networks, under the conditions that (i) such nonterminal always has a non-empty production; and (ii) ontology
references can never be of type (nil, v). The first condition
is dictated by the need to always be able to reference virtualized ontologies, even when the real ones are anonymous;
the second is a restriction placed by OWL 2, which deems
illegal any ID with a version IRI but no ontology IRI.
We need to specify some dependency relation. If we pick
(cid:104)importDeclarations(cid:105), we must show that it can be used to
form connectivity structures that encompass the primitives
of a virtual network. One way to do so is to export both ontology collectors and ontology images (wrt. those collectors)
as OWL 2 ontologies so that they only import one another.
In the following, we will assume to have a global parameter p, also called connectivity policy, whose value can be one
of {TIGHT,LOOSE}. This parameter can be tailored by virtualization methods and applications in order to establish how
virtual network artifacts connect to one another.
4.1.1 Ontology collector
Table 2 shows how an ontology collector can be exported
to an OWL 2 ontology, thus obtaining its ontological form.
The new ontology is named after the collector itself (which
is always named) and not given a version IRI. For any ontology managed by the collector, an import statement is added.

                                               54This import statement references the managed ontology using its newly created source so. If the global connectivity
policy is set to LOOSE, for every referenced collector an additional import statement will connect the two collectors.

Collector C = ((iC ,), RC )

Node

Condition
IC = (iC ,)
$o = (io, vo)  RC , o  O (cid:104)ontology(cid:105)
$C1 = (iC1 ,)  RC ,
(cid:104)ontology(cid:105)
C1 is a collector
p = LOOSE

Axiom to add
Ontology(iC )
Import(iri($o))
Import(iC1 )

Table 1: OWL 2 export of generic ontology collectors.

4.1.2 Ontology images
Table 2 shows a way of exporting an ontology, in its managed form by an ontology collector, to OWL 2. The version IRI of the ontology is set to one prefixed by the collector identifier whenever possible, and import statements are
added for all dependencies. If the global connectivity policy
is TIGHT, then the ontology image will also reference the ontological form of each referenced collector. This is also what
happens in the previous example shown in Figure 1.
Image of o wrt. Collector C = ((iC ,), R)
Axiom to add
Ontology(io vo)
Ontology(io iC||io)
Import(iri($o ))
Import(iS)

(cid:104)ontology(cid:105)
(cid:104)ontology(cid:105)

Node

Condition
$o = (io, vo)
$o = (io, nil)
d(o, o), o  O
$S = (iS,)  R,
S is a collector
p = TIGHT.
W  so

(cid:104)axioms(cid:105)

resolutions of W

Table 2: OWL 2 export of generic ontology images.

It is apparent from this construction, that we can traverse
an entire virtual ontology network starting from the ontological form of the only collector that is not a dependency
of other ontologies, unless a dependency cycle exists in the
virtual network, in which case any collector in the cycle can
be picked.

E-connections

E-connections (epsilon-connections) are a way to interpret
a concept in an ontology by selectively inheriting its context
from another ontology [2]. Their application to ontologies
dates back to the OWL 1 specification, and because it was
based on naming restrictions that no longer apply to OWL
2 due to the punning feature, it would require a partial reformulation to adapt to OWL 2.
We recall some of the core components of the E-connection

grammar for the OWL abstract syntax (in EBNF):
(cid:104)linkID(cid:105) ::= (cid:104)IRI(cid:105)
(cid:104)linkPropertyAxiom(cid:105) ::= Link( (cid:104)linkID(cid:105) [Deprecated]

{ (cid:104)annotation(cid:105) } foreignOntology( (cid:104)ontologyID(cid:105) )
{ super( (cid:104)linkID(cid:105) ) }
{ domain( (cid:104)description(cid:105) ) }
{ range( (cid:104)foreignDescription(cid:105) ) }

[ inverseOf( (cid:104)linkID(cid:105) ) ]
[ Functional | InverseFunctional ] )

(cid:104)restriction(cid:105) ::== Restriction( (cid:104)linkID(cid:105)

(cid:104)linkRestrictionComponent(cid:105)
{ (cid:104)linkRestrictionComponent(cid:105) } )

(cid:104)foreignDescription(cid:105) )
someValuesFrom( (cid:104)foreignDescription(cid:105) )
value( ForeignIndividual( (cid:104)individualID(cid:105) ))
(cid:104)cardinality(cid:105)

(cid:104)linkRestrictionComponent(cid:105) ::= allValuesFrom(


(cid:104)foreignDescription(cid:105) ::= ForeignClass( (cid:104)description(cid:105) )

For simplicity, we omit the grammar for constructs such
as (cid:104)annotation(cid:105), (cid:104)description(cid:105) and (cid:104)individualID(cid:105), which
are used in the OWL abstract syntax for declaring named
and anonymous items.
The goal is to find at at least one E-connection language
construct that can be used as a dependency, or at least a
connectivity, relation to link both two members of a virtual
ontology network, and one member of a virtual network with
an unmanaged ontology. If so, this means that a virtualization method can apply such a construct to a knowledge base
in order to create an ontology network from it.
Let us consider (cid:104)linkP ropertyAxiom(cid:105). As its definition
does not allow link properties to be transitive, we cannot
use it as a (plain) dependency relation. Still, it is a possible
candidate for direct dependency. The simplest form of a link
property axiom is:

Link( <linkID> foreignOntology( <ontologyID> ))

To be able to use it as a direct dependency, it must be
possible for (cid:104)ontologyID(cid:105) to be mapped both to the ID of a
virtualized ontology and to the ID of a non-virtualized one,
or to their sources. The latter is generally not recommend-
able, unless (cid:104)ontologyID(cid:105) is written as a single IRI that
is both its logical identifier and the physical locator of its
source, which would lose the connection between an ontology image and its original ontology. The former is possible
if the production rules of (cid:104)ontologyID(cid:105) allow us to write
it as an ontology reference, i.e. as something of the form
$o = (i, v). Again, we can borrow the OWL 2 export of
(cid:104)ontologyID(cid:105) which is of the form (cid:104)IRI(cid:105) [(cid:104)IRI(cid:105)]. If the target is the OWL form of an ontology collector, then it is of
the unique form (iC , nil); if it is an ontology image, then
it has a reference of the form (iC||i, v) or (i, iC||v) for some
collector C, and this reference is unique by definition.

If the target is an unmanaged ontology, then we must distinguish three cases. If it has a fully qualified OWL2 name,
this is not a problem since we can use that; if it has an ontology IRI but no version IRI then we fall back to the form
(i, nil); otherwise, if it is anonymous, then the virtualization method must have its own scheme for computing and
maintaining ontology references, e.g. by hashing their con-
tents. This poses a restriction on the possible virtualization
methods if we want them to virtualize via E-connections.
With link properties sorted out, we may want to explore
the possibility to strengthen virtualization by applying E-
connections to (cid:104)restriction(cid:105) axioms.
If a restriction on a
property defined in an ontology, be it real or virtual, is applied to a class used in one or more other ontologies, then

                                               55there already is a weak connectivity relation holding. We can
then use E-connections to ensure that a restriction in a virtual ontology only refers to a class as described in a specific
ontology. To that end, we can add a (cid:104)f oreignDescription(cid:105)
item, where the (cid:104)description(cid:105) nonterminal in the grammar
produces a (cid:104)linkP ropertyAxiom(cid:105) exactly as described above.
We can therefore transform a weak connectivity relation in
the original ontology into a direct dependency relation in its
virtual counterpart(s).

We have demonstrated that, in order to represent a virtual
ontology network in an ontology language, both OWL 2 and
E-connections are suitable formalisms. How they effectively
do so will depend on the virtualization method chosen and
the properties we want to guarantee.

5. CONCLUSION

We have given a formal introduction to the notion of virtual ontology network: what it means, how it relates to the
existing yet sparse theory of ontology networks, and what
issues in ontology management justify the need for it. We
laid out the foundations of a general theory on ontology networks that keeps ontologies separated from their sources, as
it is not straightforward to resolve the latter into the for-
mer. This framework accommodates both static ontology
networks assembled at design time and dynamic ones assembled at runtime, and takes up from existing attempts at
formalizing ontology relations.

As a purely theoretical work could not be immediately
evaluated experimentally, we proceeded to validate our framework by showing how existing ontology language constructs
can be used to represent virtual ontology networks, without necessarily extending these constructs or dramatically
altering their semantics. For OWL 2, we showed a possible
representation of virtual network artifacts using versioned
ontology IDs and the raw yet commonly used import-by-
location scheme.
In addition, we showed how to exploit
the extension of OWL with E-connections, which allow a
more fine-grained contextualization of ontology relations.
This work could therefore aid the migration of E-connections
from OWL-DL to OWL 2, and hopefully introduce a flexible mechanism for handling ontology relations dynamically
in Semantic Web applications.
5.1 Ongoing work

A great deal of methodological and implementation work
is underway, on the basis of the theoretical framework described in this paper. In Section 3 we illustrated how a virtual network can be extracted from a knowledge base, and
claimed that the choice of an actual procedure for doing so is
a methodological problem that depends of the desired features for the generated virtual network. We have devised
one such method, which specializes ontology collectors into
a limited number of sub-types (namely four) and spreads
managed ontologies across instances of such specialized col-
lectors. The main desired result for such a method was to
maximize the expressiveness of properties and their usage
into OWL object property axioms, as opposed to data property axioms or annotations. This method applies to virtual
ontology networks in OWL 2, as per Section 4.1, and is also
partly implemented in a top-level Apache software project2.
We are also measuring the memory overhead, and more in

2Apache Stanbol, http://stanbol.apache.org

general the impact on the memory footprint of virtual ontology networks. The experimental evaluation of this implemented method is currently being finalized, and its results
and details are scheduled for subsequent publications.

The virtualization method that uses imports in OWL 2
is intended to be a set of guidelines for application developers that need to combine heterogeneous semantic resources
into ontology networks to be processed at runtime. In other
words, it is an engineering method that targets an audience not fully aware of the creeping issues of ontology network assembly, and tries to provide them with a more intuitive approach to solving them. Whether the proposed
approach is intuitive enough, this needs to be proved via
a user study, which is currently scheduled for future work.
Alternatively, the virtualization method could be taken to
the next level and made automatic, so that a virtualization procedure would take an arbitrary knowledge base and
automatically produce a virtual ontology network that guarantees the greatest possible expressivity of its axioms.
Likewise, it will be interesting for us to design an implement a virtualization method based on E-connections (cf.
Section 4.2), provided it is implemented as an extension of
the OWL 2 method, rather than the OWL-DL it was originally based upon.
