RDFS with Attribute Equations via SPARQL Rewriting

Stefan Bischof1,2 and Axel Polleres1

Siemens AG Osterreich, Siemensstrae 90, 1210 Vienna, Austria

2 Vienna University of Technology, Favoritenstrae 9, 1040 Vienna, Austria

Abstract. In addition to taxonomic knowledge about concepts and properties
typically expressible in languages such as RDFS and OWL, implicit information
in an RDF graph may be likewise determined by arithmetic equations. The main
use case here is exploiting knowledge about functional dependencies among numerical attributes expressible by means of such equations. While some of this
knowledge can be encoded in rule extensions to ontology languages, we provide
an arguably more flexible framework that treats attribute equations as first class
citizens in the ontology language. The combination of ontological reasoning and
attribute equations is realized by extending query rewriting techniques already
successfully applied for ontology languages such as (the DL-Lite-fragment of)
RDFS or OWL, respectively. We deploy this technique for rewriting SPARQL
queries and discuss the feasibility of alternative implementations, such as rulebased approaches.

1 Introduction

A wide range of literature has discussed completion of data represented in RDF with
implicit information through ontologies, mainly through taxonomic reasoning within a
hierarchy of concepts (classes) and roles (properties) using RDFS and OWL. However,
a lot of implicit knowledge within real world RDF data does not fall into this category:
a large amount of emerging RDF data is composed of numerical attribute-value pairs
assigned to resources which likewise contains a lot of implicit information, such as
functional dependencies between numerical attributes expressible in the form of simple
mathematical equations. These dependencies include unit conversions (e.g. between
Fahrenheit and Celsius), or functional dependencies, such as the population density that
can be computed from total population and area. Such numerical dependencies between
datatype properties are not expressible in standard ontology languages such as RDFS
or OWL. Rule based approaches also fail to encode such dependencies in the general
case.

Example 1. Sample RDF data about cities, aggregated from sources such as DBPedia
or Eurostat,1 may contain data of various levels of completeness and using numerical
attributes based on different units like
:Jakarta :tempHighC 33 .
:New_York :population 8244910 .
:Vienna :population 1714142 .
:Vienna :populationDensity 4134 .

:New_York :tempHighF 84 .
:New_York :area_mile2 468.5 .
:Vienna :area_km2 414.6 .

...

1 cf. http://dbpedia.org/, http://eurostat.linked-statistics.org/

P. Cimiano et al. (Eds.): ESWC 2013, LNCS 7882, pp. 335350, 2013.
 Springer-Verlag Berlin Heidelberg 2013

S. Bischof and A. Polleres

Users familiar with SPARQL might expect to be able to ask for the population den-

sity, or for places with temperatures over 90
SELECT ?C ?P WHERE { ?C :populationDensity ?P
SELECT ?C WHERE { ?C :tempHighF ?TempF FILTER(?TempF > 90) }
However, implicit answers from mathematical knowledge such as the following equations would not be returned by those queries:

F with queries like

} or

tempHighC = (tempHighF  32)  5/9
populationDensity = population  areakm2

One might ask why such equations cannot be directly added to the terminological
knowledge modeled in ontologies? We aim to show that it actually can; further, we
present an approach how to extend the inference machinery for SPARQL query answering under ontologies to cater for such equations. Inspired by query rewriting algorithms
for query answering over DL-Lite [3], we show how similar ideas can be deployed to
extend a DL-Lite fragment covering the core of RDFS with so-called equation axioms.
We focus on query rewriting techniques rather than e.g. rule-based approaches such

as SWRL [13], where the equations from Example 1 could encoded as
tempHighC(X, C)  tempHighF(X, F ), C = (F  32)  5/9

populationDensity(X, PD)  population(X, P ), areakm2 (X, A), PD = P  A

(1)
(2)

given respective arithmetic built-in support in a SWRL reasoner. However, note that these
rules are not sufficient: (i) rule (1) is in the wrong direction for the query in Example 1,
that is, we would need different variants of the rule for converting from tempHighC to
tempHighF and vice versa; (ii) the above rules are not DL safe (i.e., we do not suffice
to bind values only to explicitly named individuals, as we want to compute new values)
which potentially leads to termination problems in rule-based approaches (and as we will
see it actually does in existing systems). Our approach addresses both these points in that
(i) equations are added as first class citizens to the ontology language, where variants are
considered directly in the semantics, (ii) the presented query rewriting algorithm always
terminates and returns finite answers; we also discuss reasonable completeness criteria.
In the remainder of this paper, we first define our ontology language DLERDFS which
extends the RDFS fragment of DL-Lite by simple equations (Sect. 2). In Sect. 3 we
define SPARQL queries over DLERDFS and present our query rewriting algorithm along
with a discussion of considerations on soundness and completeness. Alternative implementation approaches with DL reasoners and rules are discussed briefly in Sect. 4,
followed by the discussion of a use case experiment in Sect. 5. We wrap up with a
discussion of related and future work as well as conclusions (Sects. 6 and 7).

2 Extending Description Logics by Equations

We herein define a simple, restricted form of arithmetic equations and extend a
lightweight fragment of DL-Lite by such equations.
Definition 1. Let {x1, . . . , xn} be a set of variables. A simple equation E is an algebraic equation of the form x1 = f(x2, . . . , xn) such that f(x2, . . . , xn) is an arithmetic
?

?

?
expression over numerical constants and variables x2, . . . , xn where f uses the elementary algebraic operators +, , ,  and contains each xi exactly once. vars(E) is the
set of variables {x1, . . . , xn} appearing in E.
That is, we allow non-polynomials for f  since divisions are permitted  but do not
allow exponents (different from 1) for any variable; such equations can be solved
uniquely for each xi by only applying elementary transformations, assuming that all xj
for j = i are known: i.e., for each xi, such that 2  i  n, an equivalent equation

(x1, . . . , xi1, xi+1, . . . , xn) is uniquely determined. Note that

since each variable occurs only once, the standard procedure for solving single variable
equations can be used, we write solve(x1 = f(x2, . . . , xn), xi) to denote E

of the form xi = f
?

?

?
.2

2.1 The Description Logic DLE
When we talk about Description Logics (DL), we consider a fragment of DL-LiteA [18]
with basic concepts, existential quantification, attributes over concrete value domains,
role/attribute inclusions, and inverse roles which we extend by simple attribute equations.
We we call this fragment DLERDFS, i.e., it is just expressive enough to capture (the DL
fragment of) the RDFS semantics [11] extended with equations. In contrast to DL-LiteA,
DLERDFS leaves out role functionality, as well as concept and role negation, and we restrict
ourselves to a single value domain for attributes, the set of rational numbers Q.3

 | U

Definition 2. Let A be an atomic concept name, P be an atomic role name, and U be
an atomic attribute name. As usual, we assume the sets of atomic concept names, role
name, and attribute names to be disjoint. Then DL concept expressions are defined as
C ::= A | P | P
In the following, let  be an infinite set of constant symbols (which, in the context of
RDF(S) essentially equates to the set I of IRIs).
Definition 3. A DLERDFS knowledge base (KB) K = (T ,A) consists of a finite set of
terminological axioms T (TBox) and assertions A (ABox). For A, Pi, Ui and C denoting atomic concepts, roles, attributes, and concept expressions, resp., T can contain:

C  A
P1  P2
U1  U2
U0 = f(U1, . . . , Un)

(concept inclusion axiom)
(role inclusion axiom)
(attribute inclusion axiom)
(equation axiom)

A set of role (attribute, resp.) inclusion axioms is called a role hierarchy (attribute hi-
erarchy, resp.). For a, b   , and q  Q , an ABox is a set of concept assertions
C(a), role assertions R(a, b), and attribute assertions U(a, q). Finally, by K (and
A, P , U , resp.), we denote the (finite) sets of constants from  appearing in K (as
concepts, roles, and attributes, resp.).

2 In analogy to notation used by computer algebra systems (such as Mathematica or Maxima).
3 Note that since we only consider this single type of attributes, we also do not introduce valuedomain expressions from [18]. Further, instead of (U) in [18] we just write U.

S. Bischof and A. Polleres

Rows 16 of Table 1 show the obvious correspondence between DLERDFS syntax and
the essential RDFS terminological vocabulary. As for line 7, we can encode equation
axioms in RDF by means of a new property definedByEquation and write the respective
arithmetic expressions f(U1, . . . , Un) as plain literals (instead of e.g. breaking down the
arithmetic expressions into RDF triples). ABox assertions are covered in rows 810,
where we note that we use datatype literals of the type owl:rational from OWL2 for rational numbers (which however subsumes datatypes such as xsd:integer, xsd:decimal
more commonly used in real world RDF data).

As mentioned before in the context of Definition 1, we consider equations that result
from just applying elementary transformations as equivalent. In order to define the semantics of equation axioms accordingly, we will make use of the following definition.

Definition 4. Let E : U0 = f(U1, . . . , Un) be an equation axiom then, for any Ui with
0  i  n we call the equation axiom solve(E, Ui) the Uivariant of E.
Note that the DL defined herein encompasses the basic expressivity of RDFS (subprop-
erty, subclassOf, domain, range)4 and in fact, rather than talking about a restriction of
DL-LiteA, we could also talk about an extension of DL-LiteRDFS [1].5
Definition 5 (Interpretation). An interpretation I = 
?

?

?
set 

called the object domain, and an interpretation function I
I  

 each atomic concept A to a subset of the domain A
,
I  
 each atomic role P to a binary relation over the domain R
 each attribute U to a binary relation over the domain and the rational numbers

,I consists of a non-empty

which maps
I  

,

I  

I  Q, and

 each element of  to an element of 

.

For concept descriptions the interpretation function is defined as follows:

Table 1. DLERDFS axioms in RDFS

DLERDFS
A1  A2
P  A
  A
P
U  A
P1  P2
U1  U2

A1 rdfs:subClassOf A2

P rdfs:domain A
P rdfs:range A
U rdfs:domain A
?

?

?
7 U0 = f(U1, . . . , Un) U0 definedByEquation f(U1, . . . , Un)
?

?

?
P1 rdfs:subPropertyOf P2
U1 rdfs:subPropertyOf U2

x U "q"owl:rational

A(x)
R(x, y)
U(x, q)

x rdf :type A

x R y

4 Leaving out subtleties such as e.g. those arising from non-standard use [2] of the RDF
vocabulary.
5 DL-LiteRDFS actually also allows to write axioms of the form P1  P
allow since these in fact are beyond the basic expressivity of RDFS.


2 which we do not
?

?

?
I

Iy.(x, y)  R
I
Ix.(x, y)  R
I
Iq  Q.(x, q)  U
?

?

?
x  
 (R)I =

)I =
y  
 (R
x  
 (U)I =
Definition 6 (Model). An interpretation I satisfies an axiom of the form
I  A
 C  A if C

1  P
 P1  P2 if P
?

?

?
 U1  U2 if U
1  U
?

?

?
 U0 = f(U1, . . . , Un) if
x, y1, . . . , yn(
i=1(x, yi)  U
 (x, eval(f(U1/y1, . . . , Un/yn))  U

i )  defined(f(U1/y1, . . . , Un/yn)

n
?

?

?
where, by eval(f(U1/y1, . . . , Un/yn)) we denote the actual value in Q from evaluating the arithmetic expression f(U1, . . . , Un) after substituting each Ui with yi, and by
defined(f(U1/y1, . . . , Un/yn)) we denote that this value is actually defined (i.e., does
not contain a division by zero). Analogously, I satisfies an ABox assertion of the form
I  C

 C(a) if a
I)  P
?

?

?
 P(a, b) if (a
, b
, q)  U
?

?

?
 U(a, q) if (a
Finally, an interpretation I is called a model of a KB K = (T ,A), written I |= K, if I
satisfies all (role, attribute and concept) inclusion axioms in T , all variants of equation
axioms in T , and all assertions in A.
Finally, we define conjunctive queries (with assignments) over DLERDFS.
Definition 7. A conjunctive query (CQ) is an expression of the form

q(x)  y.(x, y)

where x is a sequence of variables called distinguished variables, y is a sequence of
variables called non-distinguished variables, and  is a conjunction of class, role or
attribute atoms of the forms C(x), P(x, y), and U(x, z), respectively, and assignments
of the form x0 = f(x1, . . . , xn) representing simple equations, where x, y are constant
symbols from  or variables (distinguished or non-distinguished), and z is either a
value from Q or a variable, and the xi are variables such that for all i  1, xi appears
in an atom of the form U(x, xi) within . A set of queries with the same head q(x) is a
union of conjunctive queries (UCQ).
For an interpretation I, we denote by q
the set of tuples a of domain elements and
elements of Q which makes  true6 when a is assigned to distinguished variables x in
q.
Definition 8. For a conjunctive query q and a KB K the answer to q over K is the set
ans(q,K) consisting of tuples a of constants from K  Q such that aM  q
for
every model M of the KB K.

6 We mean true in the sense of first-order logic, where we assume that the interpretation of
arithmetic expressions is built-in with the usual semantics for arithmetics over the rational
numbers Q, and that equality = is false for expressions that yield division by zero on the
RHS.
?

?

?
Note that, as opposed to most DL-Lite variants (such as [3]), ans(q,K) in our setting is
not necessarily finite, as shown by the following example.
Example 2. Let K1 = (T1,A1) with A1 = u1(o1, 1), u2(o1, 1), u3(o1, 1), T1 = {e: u1
= u2 + u3} and q(x)  u1(o1, x) then ans(q,K) contains any value from N.

3 SPARQL over DLE

The semantics of SPARQL is defined as usual based on matching of basic graph patterns (BGPs), more complex patterns are defined as per the usual SPARQL algebra and
evaluated on top of basic graph pattern matching, cf. for instance [16, 19]. In order to
remain compatible with the notion of CQs in DLERDFS, we only allow restricted BGPs.7

Definition 9. Let V be an infinite set of variables, I be the set of
IRIs,
IRDF = {rdfs:subClassOf, rdfs:subPropertyOf, rdfs:domain, rdfs:range, rdf :type,
 = I \ IRDF , then basic graph patterns (BGPs) are sets
definedByEquation}, and I
  V ) 
of RDF triple patterns (s, p, o) from ((I
{rdf : type}  I

  Q  V ))  ((I

)

  V )  I

  (I

More complex graph patterns can be defined recursively on top of basic graph patterns,
i.e., if P1 and P2 are graph patterns, v  V , g  IV , R is a filter expression, and Expr
an arithmetic expression over constants and variables in V , then (i) {{P1}{P2}} (con-
junction), (ii) {P1} UNION{P2} (disjunction), (iii) P1 OPTIONAL{P2} (left-outer
join), (iv) P1 FILTER(R) (filter), and (v) P1 BIND (Expr AS v) (assignment) are graph
patterns; as a syntactic restriction we assume that v / vars(P1). The evaluation semantics of complex patterns builds up on basic graph pattern matching,8 which we define
in our setting simply in terms of conjunctive query answering over the underlying DL.
Following the correspondence of Table 1 and the restrictions we have imposed on
BGPs, any BGP P can trivially be mapped to a (non-distinguished-variable-free) conjunctive query of the form qP : q(vars(P))  (P), where vars(P) is the set of variables occurring in P .

Example 3. Within the SPARQL query
SELECT ?X WHERE { { :o1 :u1 ?X } FILTER ( ?X > 1 )
the BGP { :o1 :u1 ?X } corresponds to the CQ from Example 2. FILTERs and other
complex patterns are evaluated on top of BGP matching:

}

Definition 10 (Basic graph pattern matching for DLERDFS). Let G be an RDF representation of a DLERDFS KB (cf. Table 1) K. Then, the solutions of a BGP P for G,
denoted (analogously to [16]) as P G = ans(qP ,K).

7 We note though, that soundness of our query rewriting approach would not be affected if we

allowed arbitrary BGPs.
8 For simplicity we leave our GRAPH graph patterns or other new features except BIND introduced in SPARQL1.1.
?

?

?
Note that here we slightly abused notation using ans(qP ,K) synonymous for what
would be more precisely the set of SPARQL variable mappings corresponding to
ans(qP ,K). As for the semantics of more complex patterns, we refer the reader to
[16, 19] for details, except for the semantics of BIND which is newly introduced in
SPARQL 1.1 [10], which we define as:

P BIND (Expr AS v)

G = {  {v  eval((Expr))} |   P G}

Here, by eval((Expr)) we denote the actual value in Q from evaluating the arithmetic
expression Expr after applying the substitutions from .

3.1 Adapting PerfectRef to DLE
Next, we extend the PerfectRef algorithm [3] which reformulates a conjunctive query
to directly encode needed TBox assertions in the query. The algorithm PerfectRefE
in Algorithm 1 extends the original PerfectRef by equation axioms and conjunctive
queries containing assignments, as defined before, following the idea of query rewriting

Algorithm 1. Rewriting algorithm PerfectRefE
Input: Conjunctive query q, TBox T
Output: Union (set) of conjunctive queries
1 P := {q}
2 repeat
 := P
?

?

?
foreach q  P
?

?

?
foreach inclusion axiom I in T do

q[g/ gr(g, I)]
foreach equation axiom E in T do
if g = U
vars(E)  adn(g) =  then

if I is applicable to g then

foreach g in q do

P := P 

// expansion
?

?

?
do
?

?

?
12 until P
13 return P

 = P

adn(g)(x, y) is an (adorned) attribute atom and

P := P 

q[g/ expand(g, E)]
?

?

?
Table 2. Semantics of gr(g, I) of Algorithm 1

g

A(x)

P1(x, y)
adn(g)
?

?

?
(x, y)

B  A
P  A
  A
P
U  A
P2  P1
U2  U1 U

gr(g/I)
B(x)
P (x, _)
P (_, x)
U(x, _)
P2(x, y)
adn(g)

(x, y)

S. Bischof and A. Polleres

by expanding a conjunctive query (CQ) Q to a union of conjunctive queries (UCQ)
Q0 that is translated to a regular SPARQL 1.1 query which is executed over an RDF
Store.

PerfectRefE first expands atoms using inclusion axioms (lines 68) as in the original
PerfectRef algorithm. Here, an DLERDFS inclusion axiom I is applicable to a query
atom g if the function gr (Table 2) is defined.9 The only new thing compared to [3]
in Table 2 is the adornment adn(g) of attribute atoms which we explain next, when
turning to the expansion of equation axioms.

The actually new part of PerfectRefE that reformulates attribute atoms in terms of
equation axioms is in lines 911. In order to avoid infinite expansion of equation axioms during the rewriting, the algorithm adorns attribute atoms in a conjunctive query
by a set of attribute names. That is, given an attribute atom U(x, z) and a set of attribute names {U1, . . . , Uk} we call g = U U1,...,Uk(x, z) an adorned attribute atom
and write adn(g) = {U1, . . . , Uk} to denote the set of adornments. For an unadorned
g = U(x, z), obviously adn(g) = . Accordingly, we call an adorned conjunctive
query a CQ where adorned attribute atoms are allowed.
 : U = f(U1, . . . , Un)

The function expand(g, E) returns for g = U adn(g)(x, y) and E

being the U -variant of E the following conjunction:
(x, y1)  . . .  U adn(g){U}

adn(g){U}

(x, yn)  y = f(y1, . . . , yn)

n

where y1, . . . , yn are fresh variables. Here, the condition vars(E)adn(g) =  ensures
that U is not re-used during expansion to compute its own value recursively. The
adornment thus prohibits infinite recursion.

We note that we leave out the reduction step of the original PerfectRef algorithm
from [3][Fig.2, step (b)], since it does not lead to any additional applicability of inclusion axioms in the restricted Description Logic DLERDFS. As we may extend PerfectRefE
to more expressive DLs as part of future work, this step may need to be re-introduced
accordingly.
Finally, just as before we have defined how to translate a SPARQL BGP P to a
conjunctive query, we translate the result of PerfectRefE(qP ,T ) back to SPARQL
by means of a recursive translation function tr(PerfectRefE(qP ,T )). That is, for
PerfectRefE(qP ,T ) = {q1, . . . qm} and each qi being of the form
ki
j=0 atomj, we

define tr as follows:
tr({q1, . . . qm})
tr(
j = 0ki atomj)
tr(A(x))
tr(P (x, y))
tr(U(x, y))
tr(y = f(y1, . . . , yn)) BIND(f(tr(y1),. . .,tr(yn)) AS tr(y) )
tr(x), for x  V
tr(x), for x  
tr(x), for x  Q

{ tr(q1) } UNION . . .UNION { tr(qm) }
tr(atom1) . . . .tr(atomki)
tr(x) rdf : type A
tr(x) P tr(y)
tr(x) U tr(y)

?x
x
xowl:rational
?

?

?
9 With DLERDFS we cover only a very weak DL, but we expect that our extension is applicable

to more complex DLs such as the one mentioned in [3], which we leave for future work.
?

?

?
The following proposition follows from the results in [3], since (a) PerfectRefE is a restriction of the original PerfectRef algorithm as long as no equation axioms are allowed,
and (b) any DLERDFS KB is consistent.
Proposition 1. Let q be a conjunctive query without assignments and K = T ,A be
a DLERDFS KB without equation axioms. Then PerfectRefE is sound and complete, i.e.

ans(q,K) = ans(PerfectRefE(q,T ),,A)

The following corollary follows similarly.

Corollary 1. Let q be a conjunctive query without assignments and without attribute
axioms and let K = T ,A be an arbitrary DLERDFS KB. Then PerfectRefE is sound
and complete.

As for arbitrary DLERDFS knowledge bases, let us return to Example 2.
Example 4. Given the knowledge base K1 = T1,A1 and query q from Example 2.
The query PerfectRefE(q,T ) is

{ q(x)  u1(o1, x), q(x)  uu1

2 (o1, x2), uu1

3 (o1, x3), x = x2 + x3}

which only has the certain answers x = 1 and x = 2, showing that PerfectRefE is incomplete in general. As a variant of K1, lets consider K2 = T1,A2 with the modified
ABox A2 = {u1(o1, 2), u2(o1, 1), u3(o1, 1)}. In this case, notably PerfectRefE delivers complete results for K2, i.e., ans(q,K2) = ans(PerfectRefE(q,T1),,A2) with
the single certain answer x = 2. Finally, the rewritten version of the SPARQL query in
Example 3 is
SELECT ?X WHERE {

{ { :o1 :u1 ?X } UNION

{ :o1 :u2 ?X2 . :o1 :u3 ?X3 . BIND(?X2+?X3 AS ?X ) } }

FILTER ( ?X > 1 )

}

In order to capture a class of DLERDFS KBs, where completeness can be retained, we
will use the following definition.
Definition 11. An ABox A is data-coherent with T , if there is no pair of ground atoms
U(x, d

entailed by K = T ,A

), U(x, d) with d = d
?

?

?
The following result is obvious.
Lemma 1. Whenever A is data-coherent with T , any conjunctive query has a finite
number of certain answers.

Proof (Sketch). Assume that the certain answers to q are infinite. From Corollary 1 we
can conclude that infiniteness can only stem from distinguished variables that occur
as attribute value y in some attribute atom U(x, y) in the query. However, that would
in turn mean that there is at least one x with an infinite set of findings for y, which
contradicts the assumption of data-coherence.

S. Bischof and A. Polleres

The following stronger result (which for our particular use case of BGP matching in
SPARQL we only consider for non-distinguished-variable-free conjunctive queries)
states that data-coherence in fact implies completeness.
Theorem 1. If A is data-coherent with T , the for any non-distinguished-variable-free
conjunctive query q PerfectRefE is sound and complete.
Proof (Sketch). The idea here is that whenever A is data-coherent with T for any fixed
x any certain value y for U(x, y) will be returned by PerfectRefE: assuming the con-
trary, following a shortest derivation chain U(x, y) can be either (i) be derived by only
atoms Ui(x, yi) such that any Ui is different from U , in which case this chain would
have been expanded by PerfectRefE, or (ii) by a derivation chain that involves an
instance of U(x, z). Assuming now that z = y would violate the assumption of data-
coherence, whereas if z = y then U(x, y) was already proven by a shorter derivation
chain.

In what follows, we will define a fragment of DLERDFS KBs where data-coherence
can be checked efficiently. First, we note that a data-coherent ABox alone, such as for
instance in K2 in Example 4 above, is in general not a guarantee for data-coherence. To
show this, let us consider the following additional example.
Example 5. Consider the TBox T2 = {e: u1 = u2 + 1, u2  u1} As easily can be
seen, any ABox containing an attribute assertion for either u1 or u2 is data-incoherent
with T2.
The example also shows that considering equation axioms only is not sufficient to decide data-coherence, but we also need to consider attribute inclusion axioms. Following
this intuition, we define a dependency graph over T as follows.
Definition 12. A TBox dependency graph is GT = N, E is constructed from nodes
for each attribute and each equation axiom N = {e | e is an equation axiom in T }U .
There exist edges (e, v) and (v, e) between every equation e and its variables v 
vars(e). Furthermore there exists an edge (u, v) for each attribute inclusion axiom
u  v. If G contains no (simple) cycle with length greater than 2, then we call T
attribute-acyclic.
Example 6. Given T1,T2 from Examples 2 and 5, let further T3 = {e1 : u1 = u2 +
1, e2 : u2 = u1 + 1}, T4 = {e1 : u1 = u2 + 1, e2 : u2 = u1  1}, and T5 = {e1 : u1 =
u2  u3, e2 : u4 = u2 e3 : u4 = u3} T6 = {e: u1 = u2  u3, u4  u2 u4  u3} then
the resp. dependency graphs are as follows where the graphs for T2T5 are cyclic.
?

?

?
u1

u3

e
?

?

?
e

u2

u1

u2

3,T
u1

e2

e1
?

?

?
u2

u1

e1

u2

u3

e3

e3
?

?

?
u1

u4

e

u2

u3

u4

Notably, since e2 is a variant of e1 in T4, T4 is actually equivalent to an acyclic TBox
(removing either e1 or e2), whereas this is not the case for T3; more refined notions of
acyclicity, which we leave for future work, might capture this difference. Therefore, as
shown in Examples 2 and 4 for T1,T2. Further, let us point out the subtle difference
?

?

?
between T5 and T6. In T5, when e1e3 are viewed as equation system, partially solving
this system would result in the new equation u1 = 0, independent of the ABox. Since
PerfectRefE does not solve any equation systems (but only instantiates equations with
values from the ABox), it would not detect this. On the contrary, in T6, only when a
concrete witness for u4 is available in the ABox, this constrains the value of u1 to
be 0, which could be correctly detected by means of PerfectRefE: for attribute-acyclic
TBoxes, data-coherence indeed (finitely) depends on the ABox and we can define a
procedure to check data-coherence (and thus completeness) by means of PerfectRefE
itself.
Proposition 2. Let T be an attribute-acyclic TBox, and U = {u1, . . . , um}. The following SPARQL query Q
ASK { { tr(PerfectRefE(qP1 ,T )) FILTER( ?Y1 != ?Z1) }
UNION . . . UNION
{ tr(PerfectRefE(qPm ,T )) FILTER( ?Y1 != ?Z1) } }

check

where Pi = { ?X ui ?Y1 . ?X ui ?Z2 } determines data-coherence in the following sense:
an ABox A is data-coherent with T if Q returns no.
The idea here is that since T is attribute-acyclic, and due to the restriction that variable
occurs at most once in simple equations, finite witnesses for data-incoherences can be
acyclically derived from the ABox, and thus would be revealed by PerfectRefE.

4 Discussion of Alternative Implementation Approaches

Our approach relies on standard SPARQL1.1 queries and runs on top of any off-the-
shelf SPARQL1.1 implementation by first extracting the TBox and then rewriting BGPs
in each query according to the method described in the previous section. In order to
compare this rewriting to alternative approaches, we have looked into DL reasoners
as well as rule-based reasoners, namely, Racer, Pellet, and Jena Rules. We discuss the
feasibility of using either of these for query answering under DLERDFS separately.

Racer [8] provides no SPARQL interface but uses its own functional query language
new Racer Query Language (nRQL). The system allows for modeling some forms of
equation axioms, cf. examples modeling unit conversions in [9], but Racer only uses
these for satisfiability testing and not for query answering (which is orthogonal to our
approach, as due to the lack of negation there is no inconsistency in DLERDFS).

SWRL [12, 13] implementations like Pellet [26] allow to handle DL-safe rules [15],
that is, rules where each variable appears in at least one non-DL-Atom. We discussed
potential modeling of equation axioms as SWRL rules already in Example 1: as mentioned there, rules for each variant of each equation axiom must be added to enable
query answering for DLERDFS. Taking this approach, experiments with Pellet showed
that queries over certain data-coherent ABoxes were answered correctly (despite  to
our reading  rules like (1)+(2) are not DL-safe in the strict sense), but we still experienced termination problems for e.g. the data and query mentioned in Example 1,
since strictly speaking, the data for :Vienna is not data-coherent (due to rounding er-
rors). Due to the finite nature of our rewriting, our approach always terminates and is

S. Bischof and A. Polleres

thus robust even for such  strictly speaking  incoherent data. Sect. 5 will give more
details.

Jena10 provides rule-based inference on top of TDB in a proprietary rule language
with built-ins, with SPARQL querying on top. Similar to SWRL, we can encode all
variants of equation axioms. Jena allows to execute rules in backward and forward
mode, where backward execution does not terminate due to its recursive nature (includ-
ing empty ABoxes). Forward execution suffers from similar non-termination problems
as mentioned above for incoherent data as in Example 1, whereas forward execution
for data-coherent ABoxes terminates. Jena offers a hybrid rule based reasoning where
pure RDFS inferencing is executed in a backward-chaining manner, but still can be
combined with forward rules; this approach was incomplete in our experiments, because property inclusion axioms did not trigger the forward rules modeling equation
axioms correctly.

5 A Practical Use Case and Experiments

For a prototypical application to compare and compute base indicators of cities  as its
needed for studies like Siemens Green City Index11  we collected open data about
cities from several sources (DBPedia, Eurostat, . . .) from several years. When aggregating these sources into a joint RDF dataset, different kinds of problems such as incoher-
ences, incomplete data, incomparable units along the lines of the extract in Example 1
occurred. Most indicators (such as demography, economy, or climate data) comprise
numeric values, where functional dependencies modeled as equation axioms are exploitable to arrive at more complete data from the sparse raw values.

For an initial experiment to test the feasibility of the query answering approach presented in this paper, we assembled a dataset containing ABox 254,081 triples for a total
of 3162 city contexts (i.e., when we speak of a city sloppily, we actually mean one
particular city in a particular year) along with the following (attribute-acyclic) TBox:
e1 :tempHighC = (:tempHighF  32)  5  9
e2 :populationRateMale = :populationMale  :population
e3 :populationRateFemale = :populationFemale  :population
e4 :area_km2 = :area_m2  1000000
e5 :area_km2 = :area_mile2  2.589988110336
e6 :populationDensity = :population  :area_km2
:City :Location foaf :name  rdfs:label dbpedia:name  rdfs:label
We use the following queries for our experiments:

Q1. Return the population density of all cities:

SELECT ?C ?P
WHERE { ?C rdf:type :City . ?C :populationDensity ?P . }

Q2. Select cities with a maximum annual temperature above 90

F.

10 http://jena.apache.org/documentation/inference/index.html
11 http://www.siemens.com/entry/cc/en/greencityindex.htm
?

?

?
SELECT ?C
WHERE { ?C rdf:type :City . ?C rdfs:label ?L .

?C :tempHighF ?P . FILTER(?F > 90) }

Q3. Select locations with a label that starts with W and a population over 1 million:

SELECT ?C
WHERE { ?C rdf:type :Location . ?C rdfs:label ?L .

?C :population ?P .
FILTER(?P > 1000000 && STRSTARTS(?L,"W")) }

Q4. Select places with a higher female than male population rate.

SELECT ?C
WHERE { ?C :populationRateFemale ?F .

?C :populationRateMale ?M . FILTER( ?F > ?M ) }

Experimental results are summarized in Table 3. For the reasons given in Sect. 4, we
compare our approach only to Jena Rules. Experiments were run on the dataset using Jena and ARQ 2.9.2 (without a persistent RDF Store). For Jena Rules, first we
encoded the essential RDFS rules plus all variants of equation axioms in a straightforward manner as forward rules, leading to the expected non-termination problems with
incoherent data. To avoid this, we created a coherent sample of our dataset (253,114
triples) by removing triples leading to possible incoherences, however still reaching a
timeout of 10min for all 4 queries. As an alternative approach, we used Jenas negation-
as-failure built-in noValue which returns sound but incomplete results, in that it fires
a rule only if no value exists for a certain attribute (on the inferences so far or in the
data); similar to our approach, this returns complete results for data-coherent datasets
and always terminates. As an example of encoding the variants of an axiom in Jena
Rules, we show the encoding of equation e6 (which is identical to the naive encoding
except the noValue predicates). Possible divisions by 0, which we do not need to care
about in our SPARQL rewriting, since BIND just filters them out as errors, are caught
by notEqual(Quotient,0) predicates.

[ (?city :area ?ar) (?city :population ?p)

notEqual(?ar, 0) quotient(?p, ?ar, ?pd)
noValue(?city, :populationDensity)
-> (?city :populationDensity ?d)]

[ (?city :area ?ar) (?city :populationDensity ?pd)

product(?ar, ?pd, ?p) noValue(?city, :population)
-> (?city :population ?p)]

[ (?city :populationDensity ?pd) (?city :population ?p)

notEqual(?pd, 0) quotient(?p, ?pd, ?ar) noValue(?city, :area)
-> (?city :area ?ar)]

Overall, while this experiment was mainly meant as a feasibility study of our queryrewriting approach, the results as shown in Table 3 are promising: we clearly outperform the only rule-based approach we could compare to. However, looking further into
alternative implementation strategies and optimizations remains on our agenda.

As a final remark, we observed during our experiments that single Web sources tend
to be coherent in the values they report for a single city, thus data-incoherences, i.e.
ambiguous results in our queries for one city typically stem from the combination of
different sources considered for computing values through equations. As a part of future

S. Bischof and A. Polleres

work, we aim to further investigate this, building up on our earlier results for combining
inferences in SPARQL with conveying provenance information in the results, cf. [27].

6 Further Related Work and Possible Future Directions

OWL ontologies for measurements and units such as QUDT [20], OM [21] provide
means to describe units and  to a certain extent  model conversion between these
units, though without the concrete machinery to execute these conversions in terms
of arbitrary SPARQL queries. Our approach is orthogonal to these efforts in that (a) it
provides not only a modeling tool for unit conversions, but integrates attribute equations
as axioms in the ontology language, and (b) allows for a wider range of use cases,
beyond conversions between pairs of units only. It would be interesting to investigate
whether ontologies like QUDT and OM can be mapped to the framework of DLERDFS
or extensions thereof.

Moreover, in the realm of DL-Lite query rewriting, following the PerfectRef algorithm [3] which we base on, there have been a number of extensions and alternative
query rewriting techniques proposed [7, 14, 17, 22, 23] which could likewise serve as
a basis for extensions by attribute equations. Another obvious direction for further research is the extension to more expressive ontology languages than DLERDFS. Whereas
we have deliberately kept expressivity to a minimum in this paper, apart from further DL-Lite fragments we are particularly also interested in lightweight extensions
of RDFS such as OWL LD [6] which we aim to consider for future work.

Apart from query answering, this work opens up research in other reasoning tasks
such as query containment of SPARQL queries over DLERDFS. While containment and
equivalence in SPARQL are a topic of active research [4,16,25] we note that containment
could in our setting depends not only on the BGPs, but also on FILTERs. E.g., intuitively
query Q4 in our setting would be equivalent (assuming :population > 0) to

SELECT ?C WHERE { ?C :populationFemale ?F .

?C :populationMale ?M . FILTER( ?F > ?M ) }

While we leave closer investigation for future work, we note another possible connection to related work [24] on efficient query answering under FILTER expression also
based in constraint-based techniques.

Lastly, we would like to point out that our approach could be viewed as rather related
to Constraint-handling-rules [5] than to mainstream semantic Web rules approaches
such as SWRL, etc.; we aim to further look into this.

Table 3. Query response times in seconds

Coherent Sample of our Dataset

Full Dataset

Our System Jena naive

Jena noValue Our System Jena naive

Jena noValue

6.5
5.8
7.8
6.9

>600
>600
>600
>600

30.7
32.7
32.5
34.3

7.3
5.7
8.2
7.9






30.1
31.3
29.0
32.4

#

Q1
Q2
Q3
Q4
?

?

?
7 Conclusions

We have presented a novel approach to model mathematical equations as axioms in an
ontology, along with a practical algorithm for query answering using SPARQL over
such enriched ontologies. To the best of our knowledge, this is the first framework that
combines ontological reasoning in RDFS, inferencing about functional dependencies
among attributes formulated as generic equations, and query answering for SPARQL.
Experimental results compared to rule-based reasoning are encouraging. Given the increasing amount of published numerical data in RDF on the emerging Web of data, we
strongly believe that this topic deserves increased attention within the Semantic Web
reasoning community.

Acknowledgements. Stefan Bischof has been partially funded by the Vienna Science
and Technology Fund (WWTF) through project ICT12-015.
