Graph-Based Ontology

Classification in OWL 2 QL

Domenico Lembo, Valerio Santarelli, and Domenico Fabio Savo

Dipartimento di Ing. Informatica, Automatica e Gestionale Antonio Ruberti

Sapienza Universit`a di Roma

Via Ariosto 25, I-00186 Roma, Italy

{lembo,santarelli,savo}@dis.uniroma1.it

Abstract. Ontology classification is the reasoning service that computes all subsumption relationships inferred in an ontology between con-
cept, role, and attribute names in the ontology signature. OWL 2 QL is a
tractable profile of OWL 2 for which ontology classification is polynomial
in the size of the ontology TBox. However, to date, no efficient methods
and implementations specifically tailored to OWL 2 QL ontologies have
been developed. In this paper, we provide a new algorithm for ontology classification in OWL 2 QL, which is based on the idea of encoding
the ontology TBox into a directed graph and reducing core reasoning to
computation of the transitive closure of the graph. We have implemented
the algorithm in the QuOnto reasoner and extensively evaluated it over
very large ontologies. Our experiments show that QuOnto outperforms
various popular reasoners in classification of OWL 2 QL ontologies.

Introduction

Ontology classification is the problem of computing all subsumption relationships
inferred in an ontology between predicate names in the ontology signature, i.e.,
named concepts (a.k.a. classes), roles (a.k.a. object-properties), and attributes
(a.k.a. data-properties). It is considered a core service for ontology reasoning,
which can be exploited for various tasks, at both design-time and run-time,
ranging from ontology navigation and visualization to query answering.

Devising efficient ontology classification methods and implementations is a
challenging issue, since classification is in general a costly operation. Most popular reasoners for Description Logic (DL) ontologies, i.e., OWL ontologies, such
as Pellet [22], Racer [11], FACT++ [23], and HermiT [9], offer highly optimized
classification services for expressive DLs. Various experimental studies show that
such reasoners have reached very good performances through the years. How-
ever, they are still not able to efficiently classify very large ontologies, such as
the full versions of GALEN [21] or of the FMA ontology [10].
Whereas the above tools use algorithms based on model construction through
tableau (or hyper-tableau [9]), the CB reasoner [14] for the Horn-SHIQ DL is
a consequence-driven reasoner. The use of this technique allows CB to obtain
an impressive gain on very large ontologies, such as full GALEN. However, the

P. Cimiano et al. (Eds.): ESWC 2013, LNCS 7882, pp. 320334, 2013.
c Springer-Verlag Berlin Heidelberg 2013
?

?

?
current implementation of the CB reasoner is rather specific for particular fragments of Horn-SHIQ (and incomplete for the general case) [14]. For example,
it does not allow for classification of properties.

Other recently developed tools, such as Snorocket [17], ELK [15], and
JCEL [19], are specifically tailored to intensional reasoning over logics of the
EL family, and show excellent performances in classification of ontologies specified in such languages, which are the logical underpinning of OWL 2 EL, one of
the tractable profile of OWL 2 [20].

Instead, to the best of our knowledge, ontology classification in the other
OWL 2 profiles has received so far little attention. In particular, classification in
OWL 2 RL has been investigated only in [16], whereas, to date, no techniques
have been developed that are specifically tailored to intensional reasoning in
OWL 2 QL, the data oriented profile of OWL 2, nor for any logic of the DL-Lite
family [6], which constitutes the logical underpinning of OWL 2 QL. Our aim
is then to contribute to fill this lack on OWL 2 QL, encouraged also by the
fact that such language, like all logics of the DL-Lite family, allows for tractable
intensional reasoning, and in particular for PTime ontology classification, as it
immediately follows from the results in [6].

In this paper, we thus provide a new method for ontology classification in
the OWL 2 QL profile. In our technique, we encode the ontology terminology
(TBox) into a graph, and compute the transitive closure of the graph to then
obtain the ontology classification. The analogy between simple inference rules
in DLs and graph reachability is indeed very natural: consider, for example, an

ontology containing the subsumptions A1  A2 and A2  A3, where A1, A2,
and A3 are class names in the ontology signature. We can then associate to this
ontology a graph having three nodes labeled with A1, A2, and A3, respectively,
an edge from A1 to A2 and an edge from A2 to A3. It is straightforward to see
that A3 is reachable from A1, and therefore an edge from A1 to A3 is contained in
the transitive closure of the graph. This corresponds to the inferred subsumption
A1  A3. On the other hand, things become soon much more complicated when

complex (OWL) axioms come into play.

In this respect, we will show that for an OWL 2 QL ontology it is possible
to easily construct a graph whose closure constitutes the major sub-task in ontology classification, because it allows us to obtain all subsumptions inferred by
the positive knowledge specified by the TBox. We will show that the computed classification misses only trivial subsumptions inferred by unsatisfiable
predicates, i.e., named classes (resp. properties) that always have an empty interpretation in every model of the ontology, and that are therefore subsumed
by every class (resp. property) in the ontology signature. We therefore provide
an algorithm that, exploiting the transitive closure of the graph, computes all
unsatisfiable predicates, thus allowing us to obtain a complete ontology classi-
fication. We notice that the presence of unsatisfiable predicates in an ontology
is mainly due to errors in the design. However, it is not rare to find such pred-
icates, especially in very large ontologies or in ontologies that are still under
construction. In particular, we could find unsatisfiable concepts even in some

D. Lembo, V. Santarelli, and D.F. Savo

benchmark ontologies we used in our experiments (cf. Section 4). Of course, already debugged ontologies might not present such predicates [13,12]. In this case,
one can avoid executing our algorithm for computing unsatisfiable predicates.

We have implemented our technique in a new module of QuOnto [1], the
reasoner at the base of the Mastro [5,7] system, and have carried out extensive
experimentation, focusing in particular on very large ontologies. We have considered well-known ontologies, often used as benchmark for ontology classification,
and we have suitably approximated them in OWL 2 QL.

QuOnto showed better performances, in some cases corresponding to enormous gains, with respect to tableau-based reasoners (in particular, Pellet,
Fact++, and HermiT). We also obtained comparable or better results with respect to the CB reasoner, for almost all ontologies considered, but, differently
from CB reasoner, we were always able to compute a complete classification. We
finally compared QuOnto with ELK, one of the most performing reasoner for
EL, for those approximated ontologies that turned out to be both in OWL 2 QL
and OWL 2 EL, obtaining similar performances in almost all cases.

We conclude by noticing that, even though we refer here to OWL 2 QL, our
algorithms and implementations can be easily adapted to deal with all logics
of the DL-Lite family mentioned in [6], excluding those allowing for the use
of conjunction in the left-hand side of inclusion assertions or the use of n-ary
relations instead of binary roles.

The rest of the paper is organized as follows. In Section 2, we provide some
preliminaries. In Section 3, we describe our technique for ontology classification
in OWL 2 QL. In Section 4, we describe our experimentation, and finally, in
Section 5, we conclude the paper.

2 Preliminaries

In this section, we present some basic notions on DL ontologies, the formal
underpinning of the OWL 2 language, and on OWL 2 QL. We also recall some
notions of graph theory needed later on.

Description Logic Ontologies. We consider a signature , partitioned in two
disjoint signatures, namely, P , containing symbols for predicates, i.e., atomic
concepts, atomic roles, atomic attributes, and value-domains, and C, containing
symbols for individual (object and value) constants. Complex concept, role, and
attribute expressions are constructed starting from predicates of P by applying
suitable constructs, which vary in different DL languages. Given a DL language
L, an L-TBox (or simply a TBox, when L is clear) over  contains universally
quantified first-order (FOL) assertions, i.e., axioms specifying general properties
of concepts, roles, and attributes. Again, different DLs allow for different axioms.
An L-ABox (or simply an ABox, when L is clear) is a set of assertions on
individual constants, which specify extensional knowledge. An L-ontology O is
constituted by both an L-TBox T and an L-ABox A, denoted as O = T ,A.
The semantics of a DL ontology O is given in terms of FOL interpretations
(cf. [3]). We denote with Mod (O) the set of models of O, i.e., the set of FOLinterpretations that satisfy all TBox axioms and ABox assertions in O, where
?

?

?
the definition of satisfaction depends on the DL language in which O is specified.
An ontology O is satisfiable if Mod (O) = . A FOL-sentence  is entailed by an
ontology O, denoted O |= , if  is satisfied by every model in Mod (O). All the
above notions naturally apply to a TBox T alone.

Traditional intensional reasoning tasks with respect to a given TBox are verification of subsumption and satisfiability of concepts, roles, and attributes [3].

More precisely, a concept C1 is subsumed in T by a concept C2, written
T |= C1  C2, if, in every model I of T , the interpretation of C1, denoted
1 , is contained in the interpretation of C2, denoted CI

2 for every
I  Mod (T ). Furthermore, a concept C in T is unsatisfiable, which we wrote as
T |= C  C, if the interpretation of C is empty in every model of T , i.e., CI = 
for every I  Mod (T ). Analogous definitions hold for roles and attributes.

2 , i.e., CI

 CI

Strictly related to the previous reasoning tasks is the classification inference
service, which we focus on in this paper. Given a signature P and a TBox
T over P , such a service allows to determine subsumption relationships in T
between concepts, roles, and attributes in P . Therefore, classification allows
to structure the terminology of T in the form of a subsumption hierarchy that
provides useful information on the connection between different terms, and can
be used to speed up other inference services. Here we define it more formally.

Definition 1. Let T be a satisfiable L-TBox over P . We define the T -
classification of P (or simply T -classification when P is clear from the con-

text) as the set of inclusion assertions defined as follows:

Let S1 and S2 be either two concepts, roles, or attributes in P . If
T |= S1  S2 then S1  S2 belongs to the T -classification of P .

The OWL 2 QL Language. We now present OWL 2 QL. We use the German
notation for describing its constructs and axioms, and refer the reader to [20]
for the OWL functional style syntax.

Expressions in OWL 2 QL are formed according to the following syntax:

B  A | Q | (U )
C  B | B | Q.A | F (U )
Q  P | P



R  Q | Q
V  U | U

E  (U )
F  T1 |



| Tn



where: A, P , and U are symbols in P denoting respectively an atomic concept,
denotes the inverse of P ; Q, also
an atomic role, and an atomic attribute; P
called unqualified existential role, denotes the set of objects related to some
object by the role Q; (U ) denotes the domain of U , i.e., the set of objects that
U relates to values; (U ) denotes the range of U , i.e., the set of values related
to objects by U ; T1, . . . , Tn denote n unbounded value-domains (i.e., datatypes);
the concept Q.A, or qualified existential role, denotes the qualified domain of
Q with respect to A, i.e., the set of objects that Q relates to some instance of
A. Similarly, F (U ) denotes the qualified domain of U with respect to a valuedomain F , i.e., the set of objects that U relates to some value in F . In the
following, we call B a basic concept, and Q a basic role.

D. Lembo, V. Santarelli, and D.F. Savo

An OWL 2 QL TBox T is a finite set of axioms of the form:

B  C

E  F

Q  R

U  V

From left to right, the above axioms denote subsumptions between concepts,
roles, attributes, and value-domains, respectively. We call positive inclusions
axioms of the form B1  B2, B1  Q.A, B1  F (U ), Q1  Q2, and U1  U2,
value-domain inclusions axioms of the form E  F , and negative inclusions
axioms of the form B1  B2, Q1  Q2 and U1  U2.

We notice that also other constructs and axioms are in fact allowed in
OWL 2 QL. In particular, it allows for the use of F (U ) in the left-hand side of
subsumptions, or in the right-hand side of negative inclusions, the use of top
constructs in the left hand-side of subsumptions, corresponding to rdfs:Literal,
owl:Thing, owl:topObjectProperty, and owl:topDataProperty, and the use of reflexivity and irreflexivity on roles (i.e., object-properties). For the sake of pre-
sentation, in this paper we prefer to not consider such aspects of OWL 2 QL,
since their presence requires to burden our algorithms with some technicalities,
which represent very minor contributions of our approach. Also, such constructs
and axioms are rarely used in the practice, and in particular are never used in
the benchmark ontologies considered in our experimentations (cf. Section 4). We
notice however, that all the techniques presented in the following sections can be
extended to full OWL 2 QL with minimal adaptations. Other constructs, such
us symmetric or asymmetric roles, even though not explicitly mentioned, can be
easily expressed by the OWL 2 QL syntax we consider.

As for OWL 2 QL ABoxes, we do not present them here, since we concentrate

on intensional reasoning, and refer the interested reader to [20].

The semantics of OWL 2 QL ontologies and TBoxes is given in the standard
way [20,3]. We only recall here that, datatypes, i.e., value-domains, have a fixed
predefined interpretation, i.e., each datatype Ti is interpreted always in the same
way, denoted val (Ti), in every interpretation of the ontology. Notice also that
OWL 2 QL supports only OWL datatypes such that the intersection of the value
spaces of any set of these datatypes is either infinite or empty, i.e., for each i, j 
{1, . . . , n}, it holds either that val (Ti)val (Tj) is infinite or val (Ti)val (Tj) = .
Graph Theory Notions. In this paper we use the term digraph to refer to a
directed graph. We assume that a digraph G is a pair (N ,E), where N is a set of
elements called nodes, and E is a set of ordered pairs (s, t) of nodes in N , called
arcs, where s is denoted the source of the arc, and t the target of the arc.
) of a digraph G = (N ,E) is a digraph such
that there is an arc in E
having a node s as source and a node t as target if and
only if there is a path from s to t in G [4]. Let G = (N ,E) be a digraph, and let
n be a node in N . We denote with predecessors(n,G) the set of nodes pn in N
such that there exists in E an arc (pn, n).

The transitive closure G

= (N ,E

3 T -Classification in OWL 2 QL

In this section we describe our approach to computing, given a signature P
and an OWL 2 QL TBox T over P , the T -classification of P .
?

?

?
In OWL 2 QL, a subsumption relation between two concepts, roles, or attributes in P , can be inferred by a TBox T if and only if (i) T contains such
subsumption; (ii) T contains a set of positive inclusion assertions that together
entail the subsumption; or (iii), trivially, the subsumed concept, role, or attribute
is unsatisfiable in T . The above observation is formalized as follows.
Theorem 1. Let T be an OWL 2 QL TBox containing only positive inclusions,
and let S1 and S2 be two atomic concepts, two atomic roles, or two atomic
attributes. S1  S2 is entailed by T if and only if at least one of the following

conditions holds:

1. a set P of positive inclusions exists in T , such that P |= S1  S2;
2. T |= S1  S1.
Proof. (sketch) () This is trivially proven.
() Assume T |= S1  S2. Towards a contradiction, suppose that both statements 1 and 2 are false. If T |= S1  S2 then the following cases are conceivable:
(a) S1  S2  T , but this implies that statement 1 is true (contradiction);
(b) S1  S2 / T and S1 is satisfiable. Since statement 1 does not hold, it remains
of T formed by positive inclusions and at least
that there exists a subset T 
one negative inclusion such that T  |= S1  S2. It can be shown that in
OWL 2 QL negative inclusions do not concur in the entailment of positive
inclusions [6], and therefore S1  S2 follows only from the positive inclusions
of T 
(c) S1  S2 / T and S1 is unsatisfiable. But then statement 2 is true (contra-

, which contradicts that statement 1 is false;

diction).

Given a OWL 2 QL TBox T over a signature P , we use T and T to denote
two sets of positive inclusions of the form S1  S2, with S1, S2  P , such
that T contains only positive inclusions for which statement 1 holds, and T
contains only positive inclusions for which statement 2 holds. It is easy to see
that T and T are not disjoint. From Definition 1 and Theorem 1 it follows
that the T -classification coincides with the union of the sets T and T .
In the following, we describe our approach to the computation of the T -
classification by firstly computing the set T , and then computing the set T .
Computation of T . Given an OWL 2 QL TBox T , in order to compute T ,
we encode the set of positive inclusions in T into a digraph GT and compute
the transitive closure of GT in such a way that each subsumption S1  S2 in
T corresponds to an arc (S1, S2) in such transitive closure, and vice versa. The
following constructive definition describes the appropriate manner to obtain the
digraph TBox representation for our aims.

Definition 2. Let T be an OWL 2 QL TBox over a signature P . We call the
digraph representation of T the digraph GT = (N ,E) built as follows:
1. for each atomic concept A in P , N contains the node A;
2. for each atomic role P in P , N contains the nodes P , P

, P , P





;

D. Lembo, V. Santarelli, and D.F. Savo


1 , Q

(Q

((U1), (U2));

 P

1 ,Q



2 );

2 ), (Q1 ,Q2), and (Q


3. for each atomic attribute U in P , N contains the nodes U and (U );
4. for each concept inclusion B1  B2  T , E contains the arc (B1, B2);
5. for each role inclusion Q1  Q2  T , E contains the arcs (Q1, Q2),
6. for each attribute inclusion U1  U2  T , E contains the arcs (U1, U2) and
7. for each concept inclusion B1  Q.A  T , E contains the arc (B1,Q);
8. for each concept inclusion B1  F (U )  T , E contains the arc (B1, (U )).
The idea is that each node in the digraph GT represents a basic concept, a basic
role or an attribute, and each arc models a positive inclusion, i.e., a subsumption,
contained in T , where the source node of the arc represents the left-hand side of
the subsumption and the target node of the arc represents the right-hand side
of the subsumption. Observe that for each role inclusion assertion P1  P2 in
the TBox T , we also represent as nodes and arcs in the digraph GT the entailed


positive inclusions P
2 . We operate in a
similar fashion for positive inclusions on attributes in T .

Let T be an OWL 2 QL TBox and let GT = (N ,E) be its digraph represen-
tation. We denote with G
) the transitive closure of GT . Note that by
definition of digraph transitive closure, for each node n  N there exists in E
an arc (n, n). Moreover, in what follows, we denote with (E
) the set of arcs
(S1, S2)  E
such that both terms S1 and S2 denote in T either two atomic

T = (N ,E

2 , P1  P2, and P




 P

concepts, two atomic roles, or two attributes. Then, the following property holds.
Theorem 2. Let T be an OWL 2 QL TBox and let GT = (N ,E) be its digraph
representation. Let S1 and S2 be two atomic concepts, two atomic roles, or two
atomic attributes. An inclusion assertion S1  S2 belongs to T if and only if
there exists in (E
Proof. (sketch) () This is trivially proven.
() To prove the thesis we need to introduce the notion of chase for an OWL
2 QL ontology, which is analogous to the notion of chase given in [6,8]. We first
note that every positive inclusion in the TBox can be formulated as a FOL
implication of the form

) an arc (S1, S2).

x, y.S(x, y)  z.(x, z)

(1)

where S is an atomic concept, an atomic attribute, or an atomic role,  is a
single atom or a conjunction of two atoms constructed on predicates of P , x
is a vector of one or two variables, y and z are vectors of one or zero variables,
i.e., they may be missing. For example, a positive inclusion of the form A1  A2
is written as x.A1(x)  A2(x), the positive inclusion P
 P2.A is written
as x, y.P1(x, y)  z.P2(y, z)  A(z), or the inclusion U1  U2 is written as
x, y.U1(x, y)  U2(x, y).
Now, let O = T ,A be an OWL 2 QL ontology. Our notion of chase is given
inductively as follows. We pose chase 0(O) = A, and for every non-negative
integer i, we define chase i+1(O) as the set of ABox assertions obtained from
chase i(O) by applying the following rule:


?

?

?
Chase Rule. Let I be a positive inclusion in T of the form (1). Let h
be a homomorphism from S(x, y) to chase i(O) such that h(S(x, y)) =
S(a, b), and such that there is no extension of h to a homomorphism
from S(x, y)  (x, z) to chase i(O) (we say in this case that I is

h
applicable to S(a, b)). Then chase i+1(O) = chase i(O){(a, n)}, where
n is a fresh constant, i.e., a constant in C not occurring in chase i(O),
if z is a single variable in (1), or chase i+1(O) = chase i(O)  {(a)}, if
z is absent in (1). We say that chase i+1(O) is obtained from chase i(O)
via application of the positive inclusion I to S(a, b).

We assume that the chase rule is always executed in such a way that if a positive

inclusion I becomes applicable to an ABox assertion  in a certain chase i(O),
then there exists j > i such that chase j(O) is obtained from chase j1(O) via
application of I to . Then, we call chase of O, denoted chase(O), the set of

ABox assertions obtained as the infinite union of all chase i(O), i.e., chase(O) =
iN chase i(O). Associated to the chase, we consider the so-called canonical
interpretation of O, denoted can(O), in which every constant is interpreted by
itself, and for every predicate S, we have that Scan(O) = {a | S(a)  chase(O)}.
It is possible to show that can(O) is a model of O [6].
Let us now turn back to our proof, and show that from the fact that an arc
(A1, A2) / (E
), where A1 and A2 are atomic concepts, it follows that there
does not exist a set P of positive inclusions in T such that P |= A1  A2. The
cases of arcs between nodes corresponding to roles or attributes can be proved
analogously. Let us consider any set P  T of positive inclusions. To prove the
thesis we construct a model I of P and show that if (A1, A2) / (E
), I is
not a model of A1  A2. To this aim, we consider the ABox AA1 = {A1(d)},
where d is a constant in C , and the canonical interpretation can(OP ) of the
ontology OP = P,AA1
, i.e., the model associated to chase(OP ). Since can(OP )
is a model of OP , it is also a model of P. We show now that can(OP ) is not
a model of A1  A2. Let us denote with chase i(OP ) the chase obtained after
i applications of the chase rule. We can now show that chase i(OP ) contains
an ABox assertion of the form A(d) (resp. P (d, n), P (n, d), or U (d, n)) if and
only if there exists an arc from A1 to A (resp. to P , P
, or (U )) in G
P .
The if direction of this property can be easily verified. For the only if direction
we proceed by induction on the construction of the chase. The base step is
indeed trivial. As for the inductive step, various cases are possible. We consider
here the case in which chase i+1(OP ) contains the fact A(d) that is generated
from chase i(OP ) by applying the axiom A
  A of P (in fact its FOL version,
according to our definition of chase). This means that chase i(OP ) contains the

P contains the arc
ABox assertion A

P contains the arc (A1, A). Other possible
(A1, A
cases can be proved in an analogous way. It is now very easy to conclude that
can(OP ) is not a model of A1  A2, since the arc (A1, A2) is not in (E

(d), and, by the inductive hypothesis, G

). It is easy then to see that G



We can then easily construct an algorithm, called Compute, that, taken as
input an OWL 2 QL TBox T , first builds the digraph GT = (N ,E) according

).

D. Lembo, V. Santarelli, and D.F. Savo

to Definition 2, then computes its transitive closure, and finally returns the set
T , which contains an inclusion assertion S1  S2 for each arc (S1, S2)  (E
).
According to Theorem 2, Compute is sound and complete with respect to the
problem of computing T for any OWL 2 QL TBox T containing only positive
inclusions.
Computation of T . In OWL 2 QL, unsatisfiability of concepts, roles, and attributes can mainly arise due to a malicious interaction of negative and positive
inclusions. However, also disjoint value-domains, i.e., datatypes having empty
intersection of their value spaces, can cause unsatisfiability. This can happen,
due to the presence in the TBox of ill-defined value-domain inclusions, which
can make one derive contradictory information. For instance, consider the TBox
T containing the assertions (U )  xsd:dateTime and (U )  xsd:integer.
Since the xsd:dateTime and xsd:integer datatypes are disjoint, we have that
T |= U  U . The detection of the situation above described is rather technical,
and does not add particular value to our overall technique for identification of
unsatisfiable predicates. Furthermore, this situation is quite rare in the practice
(for example, no ill-typed attributes are present in the benchmark ontologies
used in Section 4). Therefore, for the sake of presentation, we prefer here to not
consider this case, and assume that the TBox does not contain value-domain in-
clusions. Furthermore, since under such assumption the treatment of attributes
and roles is analogous, we limit here our attention to the case where the TBox
does not contain axioms involving attributes. All results given below apply however also to full-fledged OWL 2 QL TBoxes.

We first observe that, according Definition 2, no node corresponding to a
qualified existential role is created in the TBox digraph representation. This
kind of node is indeed not useful for computing T . Differently, if one aims to
identify every cause of unsatisfiability, the creation of nodes corresponding to a
qualified existential role is needed. This is due to the fact that a TBox may entail
that a qualified existential role P.A is unsatisfiable, even in case of satisfiability
of P . Specifically, this may occur in two instances: (i) if the TBox T entails
  A, and (ii), the TBox T entails A  A. Clearly, in both
the assertion P
cases the concept P.A is unsatisfiable. We therefore modify here Definition 2
by substituting Rule 7 with the following one:


. for each concept inclusion B1  Q.A  T , N contains the node Q.A, and
E contains the arches (B1,Q.A) and (Q.A,Q);

From now on, we adopt the digraph representation built according to Definireplaces rule 7, and, according to the above assumptions,
tion 2, where rule 7
we consider only OWL 2 QL TBoxes that do not contain axioms involving at-



tributes in P . Given one such TBox T over a signature P , the algorithm
P , by exploiting the transitive closure of the digraph representation of T .
and a node n  N , the set predecessors(n,G

such that G

computeUnsat given in Figure 1 returns all unsatisfiable concepts and roles in
Before describing the algorithm, we recall that, given a digraph G = (N ,E)
in N

, n), which means that there exists a path from n

) contains all those nodes n

contains the arc (n
?

?

?


and n1 = A)

/* step 1 */

/* step 2 */

Algorithm: computeUnsat
Input: an OWL 2 QL TBox T
Output: a set of concept and role expressions
foreach negative inclusion S1  S2  T do

foreach n1  predecessors(S1,G

T ) do
foreach n2  predecessors(S2,G

T ) do

if n1 = n2
then Emp  Emp  {n1};
if (n1 = Q
then Emp  Emp  {Q.A};



and n2 = A) or (n2 = Q

  ;
?

?

?
Emp
while Emp = Emp
  Emp;
foreach n  predecessors(S,G

do
Emp
foreach S  Emp

do
?

?

?
T ) do

Emp  Emp  {n};

if n = P or n = P
then Emp  Emp  {P, P

if there exists B  Q.n  T
then Emp  Emp  {Q.n};

or n = P or n = P



,P,P

};

return Emp.

Fig. 1. The algorithm computeUnsat(T )

to n in G. Also, it can be shown that G
T allows in fact to obtain all subsumptions
between satisfiable basic concepts or roles, in the sense that the TBox T infers
one such subsumption S1  S2 if and only if there is an arc (S1, S2) in E
. Then,

the two steps that compose the algorithm proceed as follows:

T ) and for each Sj

Step 1. Let S be either a concept expression or a role expression. We have
T ) the TBox T entails Si  S.


 predecessors(S2,G
2. Therefore, for each negative inclusion S1  S2  T , the algo-
T ) and
is able to: (i) recognize as unsatisfiable all those concepts and roles
T ) and
T ), and (ii) identify those unsatisfiable qualified exisoccurs in
T ) (resp. predecessors(S2,G
T )) and whose concept node A
T )), which indeed im-

that for each Si  predecessors(S,G
Hence, given a negative inclusion assertion S1  S2, for each Si
predecessors(S1,G
T ), T |= Si
Sj
T ) and predecessors(S2,G
rithm computes the set predecessors(S1,G
whose corresponding nodes occur in both the set predecessors(S1,G
predecessors(S2,G
tential roles Q.A whose inverse existential role node Q
predecessors(S1,G
occurs in predecessors(S2,G
plies Q

T ) (resp. predecessors(S1,G
  A and therefore unsatisfiability of Q.A.



Step 2. Further unsatisfiable concepts and roles are identified by the algorithm
through a cycle in which: (i) if a concept or role S is in Emp, then all the expressions corresponding to the nodes in predecessors(S,G
T ) are in Emp. This
captures propagation of unsatisfiability through chains of positive inclusions;
is in Emp, then all four
(ii) if at least one of the expressions P, P
expressions are in Emp; (iii) for each expression Q.A in N , if A  Emp,

,P,P





D. Lembo, V. Santarelli, and D.F. Savo

then Q.A  Emp. We notice that the algorithm stops cycling when no new
expressions of the form Q or Q.A are added to Emp (indeed, in this case
only a single further iteration may be needed).

The following theorem shows that algorithm computeUnsat can be used for

It easy to see that, by virtue of the fact that the size of the set N of the digraph
representation of the TBox T is finite, computeUnsat(T ) terminates, and that
the number of executions of the while cycle is less than or equal to |N|.
computing the set containing all the unsatisfiable concepts and roles in T .
Theorem 3. Let T be an OWL 2 QL TBox without axioms involving attributes
and let S be either an atomic concept or an atomic role in P . T |= S  S if
and only if S  computeUnsat(T ).

As already said, it is easy to extend computeUnsat in such a way that it returns
all unsatisfiable atomic concepts, atomic roles, and attributes occurring in general
OWL 2 QL TBoxes. Therefore, we can restate Theorem 3 considering OWL 2 QL
ontologies with also attributes and value-domain inclusions, and S that can be also
an attribute. As an immediate consequence of this, we can compute the set T of
all trivial inclusion assertions inferred by an OWL 2 QL ontology T , by means
of the unsatisfiable predicates identified by computeUnsat. We call Compute the
algorithm that, taken T as input, returns T by making use of computeUnsat.

The following theorem, which is a direct consequence of Theorem 2 and of
(the generalized version of) Theorem 3, states that our technique is sound and
complete with respect to the problem of classifying an OWL 2 QL TBox.

Theorem 4. Let T be an OWL 2 QL TBox and let S1 and S2 be either two
atomic concepts, two atomic roles, or two attributes. T |= S1  S2 if and only
if S1  S2  Compute(T )  Compute(T ).

Implementation and Evaluation

By exploiting the results presented in Section 3, we have developed a Java-based
OWL 2 QL classification module for the QuOnto reasoner [1,5,7].
This module computes the classification of an OWL 2 QL TBox T by adopting the technique described in Section 3. In this implementation the transitive
closure of the digraph GT is based on a breadth first search through GT .

We have performed comparative experiments, where QuOnto was tested
against several popular ontology reasoners. Specifically, during our test we compared ourselves with the Fact++ [23], Hermit [9], and Pellet [22] OWL reasoners,
and with the CB [14] Horn SHIQ reasoner, and with the ELK [15] reasoner for
those ontologies that are also in OWL 2 EL.

The ontology suite used during testing includes twenty OWL ontologies, assembled from the TONES Ontology Repository1 and from other independent
sources. The six reasoners exhibited negligible differences in performance for the

http://owl.cs.manchester.ac.uk/repository/
?

?

?
Table 1. In the table the Original and OWL 2 QL axioms fields indicate respectively
the total number of axioms in the original version of the ontology and in the OWL 2
QL-approximated version. The Negative inclusion field reports the number of negative
inclusions in the OWL 2 QL-approximated version.

Ontology

Concepts Roles Attributes

Original DL

fragment

Original
axioms

Owl 2 QL

axioms

Mouse
Transportation
?

?

?
Gene
EL-Galen
Galen
FMA 1.4
FMA 2.0
FMA 3.2.1
FMA-OBO
?

?

?
4 ALCH(D)
4 SHOIN(D)
SHIN(D)
?

?

?
0 ALEHIF+
0 ALCOIF

20 ALCOIF(D)
67 ALCOIF(D)
?

?

?
123610

119558
?

?

?
118181

119558

Negative
inclusions
?

?

?
majority of the smaller tested ontologies, so we will only discuss the ontologies
which offered interesting results, meaning those on which reasoning times are
significantly different for at least a subset of the reasoners.

These ontologies include: the Mouse ontology; the Transportation ontol-
ogy2; the Descriptive Ontology for Linguistic and Cognitive Engineering
(DOLCE) [18]; the Athletic Events Ontology (AEO)3; the Gene Ontology
(GO) [2]; two versions of the GALEN ontology [21]; and four versions of the
Foundational Model of Anatomy Ontology (FMA) [10].

Because QuOnto is an OWL 2 QL reasoner, each benchmark ontology was
preprocessed prior to classification in order to fit OWL 2 QL expressivity. There-
fore, every OWL expression which cannot be expressed by OWL 2 QL axioms
was approximated from the ontology specifications. This approximation follows
this procedure: each axiom in the ontology is fed to an external reasoner, specifically Hermit, and every OWL 2 QL-compliant axiom that is implied from
that axiom, between the ontology symbols that appear in it, is added to the
OWL 2 QL-approximated ontology. For instance, the OWL assertion Equiva-
lentClasses(ObjectUnionOf(:Male :Female) :Person) is approximated by the two
assertions SubClassOf(:Male :Person) and SubClassOf(:Female :Person). Note
that, as is the case in this example, the OWL 2 QL-approximated ontology may
contain a greater number of axioms than the original ontology.

During the tests for each reasoner, classification was performed on the OWL
2 QL-compliant versions of the ontologies resulting from the above described
preprocessing. Metrics about the ontologies are reported in Table 1.

All tests were performed on a DELL Latitude E6320 notebook with Intel
Core i7-2640M 2.8Ghz CPU and 4GB of RAM, running Microsoft Windows 7
Premium operating system, and Java 1.6 with 2GB of heap space. Classification
timeout was set at one hour, and aborting if maximum available memory was

http://www.daml.org/ontologies/409
http://www.boemie.org/deliverable_d_3_5

D. Lembo, V. Santarelli, and D.F. Savo

Table 2. Classification times of benchmark OWL 2 QL ontologies by QuOnto and
other tested reasoners

Ontology

Mouse
Transportation
?

?

?
Gene
EL-Galen
Galen
FMA 1.4
FMA 2.0
FMA 3.2.1
FMA-OBO

QuOnto

FaCT++

HermiT

Pellet

0.282
0.045
0.245
0.743
1.400
109.835
145.485

0.156
0.150
1.327
0.650
1.255
2.788
4.600
0.688 timeout
4.111 out of memory
4.146
4.827 timeout

4.576

0.296
0.163
25.619
0.920
3.810
7.966

0.179
0.151
1.696
0.647
2.803
50.770

34.608 timeout
93.781 timeout
timeout

out of memory

11.518
50.842

24.117
16.852

0.159
0.195
1.358
0.605
1.918
2.446
2.505
1.243
7.142
4.976
7.433

0.246
0.343




1.419
1.205






4.078

exhausted. All figures reported in Table 2 are in seconds, and, because classification results are subject to minor fluctuation, particularly when dealing with
large ontologies, are the average of 3 classifications of the respective ontologies
with each reasoner. The following versions of the OWL reasoners were tested:
Fact++ v.1.5.34, HermiT v.1.3.65, Pellet v.2.3.06, CB v.127, and ELK v.0.3.28.
In our test configuration, the classifications of the FMA 2.0 ontology by the
Hermit and FaCT++ reasoners terminate due to an out-of-memory error. In [9],
classification of this ontology by the Hermit reasoner is performed successfully,
but classification time far exceeds the one registered by QuOnto.

The results of the experiments are summarized in Table 2. These results confirm that the performance offered by QuOnto compares favorably to other reasoners for almost all tested ontologies. Classification for even the largest of the
tested ontologies, i.e., the FMA-OBO and FMA 3.2.1 ontologies, is performed
in under 5 seconds, and memory space issues were never experienced during
our tests with QuOnto. For some test cases, the gap in performance between
QuOnto and other reasoners is sizeable: for instance, classification by Pellet of
the Galen and FMA (1.4 and 2.0) and by FaCT++ of the FMA (1.4 and OBO)
ontologies exceeds the predetermined timeout limit of one hour.

Detailed analysis of the results provided in Table 2 shows that only the CB
and ELK reasoners consistently display comparable performances to QuOnto,
which is fastest for all ontologies which feature only positive inclusions, with the
exception of the EL-Galen, Galen, and FMA-OBO ontologies. The CB reasoner,
which is the best-performing reasoner for the Galen ontology, does not however
always perform complete classification. For instance, it does not compute property hierarchies. The ELK reasoner instead is slower than QuOnto for three
out of the five ontologies also in OWL 2 EL, showing instead markedly better
performance for EL-Galen.

http://code.google.com/p/factplusplus/
http://hermit-reasoner.com/
http://clarkparsia.com/pellet
http://code.google.com/p/cb-reasoner/
http://code.google.com/p/elk-reasoner/
?

?

?
Furthermore, if, as it is usually the case, an ontology does not present unsatisfiable predicates, the computation of such predicates through the exploration
of all negative inclusions can be avoided. This is the case for ontologies such
as DOLCE and AEO, for which computation of the set T of positive inclusion
assertions resulting from the transitive closure of GT is performed respectively in
0.347 and 0.384 seconds, fastest among tested reasoners. Instead, for ontologies
such as Pizza and Transportation, which feature respectively 2 and 62 unsatisfiable atomic concepts, the identification of all such predicates is unavoidable,
and the resulting set of trivial inclusion assertions must be added to T .

5 Conclusions

The research presented in this paper can be extended in various directions. First
of all, in the implementation of our technique we have adopted a naive algorithm
for computing the digraph transitive closure. We are currently experimenting
more sophisticated and efficient techniques for this task. We are also working
to optimize the procedure through which we identify unsatisfiable predicates.
Finally, we are working to extend our technique to compute all inclusions that are
inferred by the TBox (which, in OWL 2 QL, are a finite number). In this respect,
we notice that through G
T it is already possible to obtain the classification of all
basic concepts, basic roles, and attributes, and not only that of predicates in the
signature, and that, with slight modifications of computeUnsat, we can actually
obtain the set of all negative inclusions inferred by an OWL 2 QL TBox. The
remaining challenge is to devise an efficient mechanism to obtain all inferred
positive inclusions involving qualified existential roles and attribute domains.

Acknowledgments. This research has been partially supported by the EU
under FP7 project Optique  Scalable End-user Access to Big Data (grant n.
FP7-318338).
