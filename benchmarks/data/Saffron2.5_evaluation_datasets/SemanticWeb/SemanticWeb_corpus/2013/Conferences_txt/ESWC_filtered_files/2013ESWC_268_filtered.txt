Lightweight Spatial Conjunctive Query Answering

Using Keywords

Thomas Eiter, Thomas Krennwallner, and Patrik Schneider

Institut fur Informationssysteme, Technische Universitat Wien

Favoritenstrae 9-11, A-1040 Vienna, Austria

{eiter,tkren,patrik}@kr.tuwien.ac.at

Abstract. With the advent of publicly available geospatial data, ontology-based
data access (OBDA) over spatial data has gained increasing interest. Spatiorelational DBMSs are used to implement geographic information systems (GIS)
and are fit to manage large amounts of data and geographic objects such as points,
lines, polygons, etc. In this paper, we extend the Description Logic DL-Lite with
spatial objects and show how to answer spatial conjunctive queries (SCQs) over
ontologiesthat is, conjunctive queries with point-set topological relations such
as next and withinexpressed in this language. The goal of this extension is to
enable an off-the-shelf use of spatio-relational DBMSs to answer SCQs using
rewriting techniques, where data sources and geographic objects are stored in a
database and spatial conjunctive queries are rewritten to SQL statements with
spatial functions. Furthermore, we consider keyword-based querying over spatial
OBDA data sources, and show how to map queries expressed as simple keyword
lists describing objects of interest to SCQs, using a meta-model for completing
the SCQs with spatial aspects. We have implemented our lightweight approach
to spatial OBDA in a prototype and show initial experimental results using data
sources such as Open Street Maps and Open Government Data Vienna from an
associated project. We show that for real-world scenarios, practical queries are
expressible under meta-model completion, and that query answering is computationally feasible.

1 Introduction

By the ever increasing availability of mobile devices, location-aware search providers
are becoming increasingly commonplace. Search providers (e.g., Google Maps
http://maps.google.com/or Nokia Maps http://here.net) offer the possibility
to explore their surroundings for desired locations, also called points-of-interest (POIs),
but usually miss the possibility to express spatial relations (e.g., next and within). For
an expressive location-aware search, the combination of Semantic Web techniques and
spatial data processing (with spatial relations) is appropriate, given they provide a data
backbone for spatial and taxonomic information to query semantically-enriched POIs.
To realize location-aware semantic search support, one needs to capture categories
of POIs (e.g., Italian restaurant), their relations to additional qualitative attributes (e.g.,

 Supported by the Austrian Research Promotion Agency (FFG) project P828897, and the Aus-

trian Science Fund (FWF) project P20840.

P. Cimiano et al. (Eds.): ESWC 2013, LNCS 7882, pp. 243258, 2013.
c Springer-Verlag Berlin Heidelberg 2013

T. Eiter, T. Krennwallner, and P. Schneider

hasQVal

Shop  SpatialFeat
  SpatialFeat
Park  SpatialFeat

Supermarket  Shop
Walmart  Op

hasOp  hasQVal
Shop  hasOp

hasOp

  Op

QVal  hasQVal

Op  QVal
Wlan  QVal
GuestGarden  QVal
SpatialFeat  Geometry

Fig. 1. Ontology with integrated meta-model (TBox excerpt; role names start lowercase)

having a guest garden). Further, one needs to capture the spatial relations between POIs
(e.g., located inside a park). For modeling and interpreting a users intention, it seems
suggestive to use ontology languages and associated reasoning services. However, for
spatial aspects we need to extend or combine them with spatial data reasoning. Further-
more, we must respect that ordinary users of location-aware search need a plain query
interface; they are not experts in query languages, and an interface to express search
intentions by lists of keywords in a Google-like manner would be desirable.

However, we face several obstacles for a seamless keyword-based querying and integration of geospatial data sources and ontologies. First, for a meaningful search result,
we need to consider data obtained by integrating multiple data sources, which may be
provided by autonomous vendors in heterogeneous formats (e.g., OpenStreetMap or
Open Government Data data, a restaurant guide, etc). Using various data sources of
substantial size gives the opportunity to find intended POIs, which may fall into multiple concepts ranging from rather generic to more detailed ones such as restaurant vs.
pizzeria. Moreover, we can exploit the structure of the taxonomic information that is
implicit in the data sources by making it concrete in an ontology. Such ontology-based
data access can be used to answer broad queries like restaurants with Italian Cuisine,
that should return pizzerias, trattorias, and osterias.

Second, from keyword-based input, we must generate meaningful formal queries to
an ontology. In that, we must respect that the users may have no prior knowledge of
the domain. Thus, we must be able to recognize and generate relevant combinations of
possible keywords according to the ontology that represents the domain.

Third, as we query mainly spatial data, we need to capture spatial relations between
different spatial objects and give users the possibility to use a fixed set of keywords to
express them. For spatial querying answering, we must define an appropriate semantics
and provide techniques that combine spatial with ontological query answering.

Fourth, a lot of research has been put into efficient query answering techniques over
lightweight ontology languages, such as the DL-Lite family [7]. Conjunctive query
(CQ) evaluation over DL-Lite ontologies can be delegated, by first-order query rewrit-
ing, to a Relational Database Management System (RDBMS), which facilitates scalable
query processing. To secure this for an extension with spatial reasoning, the first-order
rewritability of the latter is desirable. Furthermore, as first-order rewritings of queries
might get prohibitively large in general (a known feature), also issues of manageable
query generation from keywords must be respected.
 Various data sources are integrated via a global schema represented by an DL-LiteR
ontology that is enriched with spatial information. The ontology-based knowledge base

We address the above issues with the following approach outlined in a nutshell.
?

?

?
(KB) is separated into a TBox, an ABox with normal individuals and a spatio-relational
database with spatial objects. We apply a mild extension to DL-LiteR by associating individuals to spatial objects by a predefined binding. A preprocessor creates this binding
using a domain-specific heuristic (which is not considered here).
 The enriched ontology can be accessed, at the system level, by spatial conjunctive
queries (SCQ), which extend conjunctive queries with spatial predicates (e.g. inter-
sects). In such queries, individuals can be located with spatial objects whose relationships are determined. By rewriting techniques, and in exploiting the PerfectRef
algorithm [7], SCQs can be rewritten to a union of conjunctive queries (UCQ). Under
certain syntactic conditions, a 2-stage evaluationevaluation of the ontology part of the
query (over the ABox, which is stored in an RDBMS) followed by filtering via spatial
conditionsis possible, which makes this approach attractive for practical realization.
 For keyword-based query answering, concepts of the ontology are labeled with key-
words. On query evaluation, the keywords which the user enters are mapped to concepts
and roles from the ontology; an auto-completion service aids the user to compensate
lack of domain knowledge. Based on the keyword structure, a feasible CQ is generated
and extended with spatial predicates to SCQs; in that, we use a specific meta-model
that is stored in the ontology. Fig. 1 shows an excerpt of the ontology; the concept
SpatialFeat intuitively says that the individual has spatial features, which is extended
by the subroles of hasQVal with qualitative values, which are asserted to subconcepts
of QVal. Furthermore, the individual is represented by a geometry, asserted to subconcepts of Geometry. However, also normal role assertions for qualitative attributes are
considered (e.g., a restaurant with a guest garden).

We have implemented this approach in an experimental prototype, which is part of
a more extensive system for smart, semantically enriched route planning system (My-
ITS, http://myits.at/) over real world data sources such as OpenStreetMap (OSM),
Open Government Data (OGD) of Vienna, and the Falter restaurant guide for Vienna.
The data sources are integrated by a global schema represented by an ontology expressed in DL-LiteR. It turns out that naively generated UCQs may be too large for
execution on conventional RDBMS. We thus improved our approach by exploiting the
structure of the TBox in an optimized generation of queries from keyword, to eventually obtain smaller UCQs. First experiments show that this approach is feasible in
a real-world scenario. Furthermore, we show that the optimizations described are important for feasibility. An extended version of this paper provides more details that are
omitted for space reasons.1

2 Preliminaries

We adopt DL-LiteR [7] as the underlying ontological language and introduce an approach in which the FO-rewriting of PerfectRef (see [7] and [6] for details) is strictly
separated from spatial querying. As a result of this separation, we only allow spatial
predicates (e.g., Contains) on the top level of the query structure. Regarding the se-
mantics, we following partly the ideas of [15], but focus primarily on query answering
(not solely satisfiability). Furthermore, we use a different notion for spatial relations.

1 http://www.kr.tuwien.ac.at/staff/patrik/ESWC2013Ext.pdf

T. Eiter, T. Krennwallner, and P. Schneider

i1 PF

i.

sS points(s): a

Spatio-relational Database. Thus, we define a spatio-relational database over S as

Point-Set Topological Relations. We follow the point-set topological relation model
in [13], where spatial relations are defined in terms of pure set theoretic operations.
The realization of spatial objects is based on a set PE  R2 of points in the plane;
the (names of) spatial objects themselves are in a set S. While the set of points for a
spatial object s is infinite (unless it is a point), it can be finitely defined by an associated
admissible geometry g(s). The geometries are defined by sequences p = (p1, . . . , pn)
of points that induce a point (n = 1), a line segment (n = 2), a line (n > 2), or a
polygon. All points used for admissible geometries are from a finite set PF  PE of
points.
a pair S = (PF , g) of a point set PF  R2 and a mapping g : S 
?

?

?
The extent of a geometry p (full point set) is given by the function points(p) and is a
(possibly infinite) subset of PE. For a spatial object s, we let points(s) = points(g(s)).
We need points to evaluate the spatial relations of two spatial objects via their respective
geometries. For our spatio-thematic KBs, we consider the following types of admissible
geometries p over PF (with their representation), and let PE =
 point is a sequence p = (p1), where points(p1) = {p1};
 line segment is a sequence p = (p1, p2), and points(p) = {p1 + (1  )p2 |  
R, 0    1};
 line is a sequence p = (p1, . . . , pn) of line segments (pi, pi+1), 1  i < n, the first

(p1, p2) and last (pn1, pn) segments do not share an end-point, and points(p) =

points(a) =
the separation of PE by p into two disjoint regions.
?

?

?
 polygon is like a line but (p1, p2) and (pn1, pn) share an end point; we have
i=1 points(pi)  int(lc), where int(lc) is the interior built from
n1
Some s  S may serve to define via g a bounding box. We omit more complex geometries like areas or polygons with holes. Based on points(x), we can define the spatial
relation of point-sets in terms of pure set operations:
 Equals(x, y) : points(x)=points(y) and NotEquals(x, y) : points(x)=points(y);
 Inside(x, y) : points(x)points(y) and Outside(x, y) : points(x)points (y)=;
 Intersect(x, y) : points(x)  points(y) =  and NextTo(x, y) : b(x)  b(y) =
, where b(z) = {a  PE | dist(a, points(z))  dB} for a distance function
0 and a distance value dB  R.
dist : R2  R+
  S, holds on a spatio-relational DB S,

Now for any spatial relation S(s, s
) and s, s
written S |= S(s, s
?

?

?
), if S(g(s), g(s
) evaluates to true. Relative to points and dist (and
dB), this is easily captured by a first-order formula over (R2,), and with regard to
geo-spatial RDBMS trivially first-order expressible.

n1
i=1 points(pi);

Note that the space model of [13] differs from the more detailed 9-Intersection model
(DE-9IM) of [10], which considers strict separation of the interior and object boundary;
this leads to 9 instead of 5 spatial relations. We also omit spatial predicates in the sig-
nature, assuming a standard point-set interpretation of the spatial-relations [13]. Our
approach is modular and flexible enough to allow further relations (e.g., connects) or
use other interpretations such as DE-9IM.
?

?

?


Syntax and Semantics of DL-LiteR. We recall the definitions from [7]. Consider a
vocabulary of individual names I , atomic concepts C, and atomic roles R. Given
atomic concepts A and atomic roles P , we define basic concepts B and basic roles R,
complex concepts C and complex role expressions E, and P
R ::= P | P


be the inverse of P as
E ::= R | R .

C ::= B | B

B ::= A | R

A DL-LiteR knowledge base is a pair K = (T ,A) where the TBox T consists of a
finite set of inclusion assertions of the form B  C and R  E, and the ABox A
is a finite set of membership assertions on atomic concepts and on atomic roles of the
form A(a) and P (a, b), where a and b are individual names.
,I
The semantics of DL-LiteR is given in terms of FO interpretations I = (

),
I  

I
an interpretation function such that a
for all P  R, and
I  

a1 | a2  
s.t. (a1, a2)  R

;
.

is a nonempty domain and I

I
?

?

?
where 
I  
for all a  I, A
for all A  C, P
I  

; (R)
(a2, a1) | (a1, a2)  P
?

?

?

(P
)
=
(B)
I \ R
I  
; and (R)
I \ B
?

?

?
The notions of satisfaction of inclusion axioms and assertions, TBox and ABox resp.
knowledge base is as usual, as well as logical implication; both are denoted with |=. We
assume the unique name assumption holds for different individuals and values.
Checking satisfiability of DL-LiteR ontologies is first-order (FO) rewritable [7], i.e.,
for all T , there is a Boolean FO query QT (constructible from T ) s.t. for every A, T A
is satisfiable iff DB(A) |= QT , where DB(A) is the least Herbrand model of A.

=
= 

= 

3 DL-LiteR(S)

In this section, we extend DL-LiteR with spatial objects to DL-LiteR(S). We present its
syntax and semantics, a transformation of to DL-Lite, and show that satisfiability and
conjunctive query answering over DL-LiteR(S) KBs are FO-rewritable.
Syntax. Let S and I be pairwise disjoint sets as defined above. A spatio-thematic
knowledge base (KB) is defined as LS = T ,A,S,B, where T (resp. A) is defined
as a DL-LiteR TBox (resp. ABox), S is a spatio-relational database, and B  I  S
is a partial function called the binding from A to S, similar to [15]; we apply a mild
extension to DL-LiteR by associating individuals from A to spatial objects from S.
We assume B to be already given. Furthermore, we extend DL-LiteR with the ability

to specify the localization of a concept. For this purpose, we extend the syntax with

where A is an atomic concept in T ; intuitively, (loc A) is the set of individuals in A
that can have a spatial extension, and (locs A) is the subset which have extension s.
Semantics. Our aim is to give a semantics to the localization concepts (loc A) and
(locs A) such that a KB LS = T ,A,S,B can be readily transformed into an ordinary
DL-LiteR KB KS = T 
,A, using concepts CST and Cs for individuals with some
spatial extension resp. located at s. Note that CST cannot be forced to be the union of
all Cs, as this would introduce disjunction (this hinders the passing from the open to
the closed world assumption, which is important for the FO-rewriting of DL-Lite).

C ::= B | B | (loc A) | (locs A),

s  S,
?

?

?
T. Eiter, T. Krennwallner, and P. Schneider

An (DL-LiteR) interpretation of LS is a structure I=

I
, where 

is an interpretation of T ,A, and b
individuals a location, such that for every a  I, (a, s)  B implies b

an atomic concept in T :
I  {e  
(loc A)
= {e  

(locs A)

,I
I  S is a partial function that assigns some

We extend the semantics of the previous section with (loc A), (locs A), where A is

I  s  S : (e, s)  b
I  (e, s)  b

I | e  A
I | e  A

I  

) = s.

I}.

I},



,I

, b

(a

,A, where T 

The interpretation of complex concepts, satisfaction, etc. is then as usual. For example,
A  (locs A) expresses that all individuals in A are located at s; B  (loc A) states
that individuals in B can have a location if they are in A.
Transformation to DL-LiteR. Let CST and Cs, for every s  S, be fresh concepts.
We transform LS to KS = T 
=  (A)AB, and
  (X) replaces each occurrence of (loc A) and (locs A) in X with CST  A and
Cs  A, respectively, and splits  up;
 TS represents generic localization information via concepts, and contains the axiom
Cs  CST , and the constraints Cs  Cs for all s = s
 AB represents the concrete bindings between A and S, and for every (a, s)  B,
we add Cs(a) in AB. Note that we do not assert Cs(a) for (a, s)  B, keeping
the open world assumption for bindings.

=  (T )TS and A

  S;

For example, let A (resp. CST ) be the concept Park (resp. SpatialFeat ), cp be the
spatial object of City Park, and the polygon poly_cp representing cps spatial extend.
The KB has the assertions Park  (loc P ark), CityParkCafe  (loccp Park ), and
CityParkCafe (c). Then, the transformation produces Park  (SpatialFeat  Park ),
CityParkCafe  (Cpoly_cp  Park ), Cpoly_cp  SpatialFeat , and Cpoly_cp(cp).
Note that KS is indeed a DL-LiteR ontology, by the syntactic restrictions on localization concepts. It is not hard to verify that the models of LS and KS with the
?

?

?
) coincide on common concepts and roles as follows: (i) if
same domain (
I |= LS, then I |= KS where C
I | (e, s)  b
I
sS C
= {(e, s) | e  C
}
)); conversely, (ii) if I |= KS, then I |= LS where b
I
(= dom(b

s
. As an easy consequence of this correspondence, we obtain:
and (loc A)
= C

s = {e  
I

I}, C

I
ST =

= 

ST A
I
I

I

Proposition 1. Satisfiability checking and CQ answering for ontologies in DL-LiteR(S)
is FO-rewritable.
As the models of LS and KS correspond, we can check satisfiability on KS, i.e., a
standard DL-LiteR KB. An ontology CQ q over LS is easily rewritten to a CQ over KS.

4 Query Answering in DL-LiteR(S)
We next define spatial conjunctive queries (SCQ) overLS = T ,A,S,B. Such queries
may contain ontology and spatial predicates. Formally, an SCQ q(x) is a formula

QO1 (x, y)    QOn (x, y)  QS1(x, y)    QSm(x, y),

(1)
where x are the distinguished variables and y are either non-distinguished (bound)
variables or individuals from I. Each QOi (x, y) is an atom for T and of the form
?

?

?
, b
?

?

?
I  ((z
?

?

?
), with z, z
?

?

?
from x  y.

), if QSj (x, y) = S(z, z

A(z) or P (z, z
for the spatial relations in Sec. 2 and of the form S(z, z

), with z, z

The semantic correspondence between LS and KS = T 
= T 

from x  y; the atoms QSj (x, y) are over the vocabulary
For example, q(x) = P layground(x)  W ithin(x, y)  P ark(y) is a SCQ which
I

intuitively returns the playgrounds located in parks.
be an interpretation of LS. A match for q(x) in I is a
Semantics. Let I=
,I


function  : x y  
, for each constant c in x y, and for each
?

?

?
such that (c) = c
)) 
i = 1, . . . n and j = 1, . . . , m, (i) (z)  A

, if QOi (x, y) = A(z); (ii) ((z), (z
); and (iii) s, s
  S : ((z), s)  b
) 
?

?

?
, if QOi(x, y) = P (z, z

), s
I  S |= S(s, s

). That is, for spatial predicates individuals
b
must have (unique) spatial extensions and the relationship between them must hold.
Then, a tuple c = c1, . . . , ck over I is an answer for q(x) in I, x = x1, . . ., if q(x)
has some match  in I such that (xi) = ci, i = 1, . . . , k; furthermore, c is an answer
for q(x) over LS, if it is an answer in every model I of LS. The result of q(x) over LS,
denoted res(q(x),LS ), is the set of all its answers.
,A guarantees that we
can transform q(x) into an equivalent query over LS
,A
,S,B by replacing
each spatial atom S(z, z
)  S(s, s
(2)
The resulting formula is easily cast into form uq(x) = q1(x)   ql(x), i.e., a union
of CQs qi(x). The answers of uq(x) in an interpretation I
are the answers of
all qi(x) in I
) is defined in the obvious way. We then can show:
Proposition 2. For every SQC q(x) over LS, res(q(x),LS ) = res(uq(x),LS
Hence, answering SCQs in DL-LiteR(S) ontologies is FOL-rewritable. In particular,
for fixed S, we can eliminate S(s, s
) from (2), which yields a pure ontology query.
Alternatively, we can replace it with Ss,s (z), where Ss,s is a fresh concept, and add
Cs  Ss,s to the TBox T 
Spatial Conjunctive Query Evaluation. The above SCQ rewriting is exponential in
the number of spatial atoms, which incurs limitations. However, if no bounded variables
occur in spatial atoms, we can separate query answering into an ontology part and a
spatial query part, which can be efficiently evaluated in two stages:
(1) evaluate the ontology part of the query q(x) (i.e., drop all spatial atoms) over LS
.
For that we can apply the standard DL-LiteR query rewriting of PerfectRef and
evaluate the result over the ABox, stored in an RDBMS.
?

?

?
) in q(x) with
s,sS (Cs(z)  Cs(z

, and res(uq(x),LS 

iff S |= S(s, s
?

?

?
), thus changing S more flexibly.

)).
of LS
?

?

?
).
?

?

?
(2) filter the result of Step (1), by evaluating the formulas (2) on the bindings  for the
distinguished variables x (which are mapped to individuals). For that, retrieve in
Step (1) also all instances of Cs, for all s  S.

Step (2) amounts to computing a spatial join S, for which (at least) different evaluation strategies exist. One strategy, denoted as OD, relies entirely on the functions of
a spatial-extended RDBMS. The other, denoted as OI , relies on an internal evaluation
of S, i.e., spatial relations, where the intermediate results are kept in-memory.

We have considered both strategies, restricting to acyclic queries (i.e., the query hypergraph is tree-shaped; see e.g. [12] for a definition). For such queries, join trees can
be built, which can be processed in a bottom up manner. In doing so, we distinguish

T. Eiter, T. Krennwallner, and P. Schneider

between ontology and spatial nodes, and actually interleave the DL-LiteR query rewriting (Step (1)) and spatial join checking (Step (2)). For space reasons, we omit details.
Note that for strategy OD, we rewrite the spatial atoms (Contains, W ithin, etc.)
directly to corresponding functions (cf. [8] for details) of the spatial-extension of the
RDBMS. The different strategies noticeably affect the performance (see Sec. 8).

5 From Keywords to Spatial Conjunctive Queries

In this section, we provide the details for the generation of SCQ from a valid sequence
of keywords; We shall consider in the next section how such sequences are obtained in
a controlled way, by automatic completion and checking keyword combinations.

We assume an ontology OU , which has an associated meta-model for structuring the
query generation (described below). The generation is realized in three steps. First, the
keywords are mapped to concepts from OU and to spatial predicates. Then, a set of
completion rules (which regard the meta-model) is applied to the resulting sequence of
atomic formulas. Finally the completed sequence is converted into a SCQ.
We assume that spatio-thematic KBs are labeled, i.e., they are of the form LS =
T ,A,S,B,N, where N is a set of textual labels representing keywords. The labels
of N are assigned by rdfs:label to the concepts of T . Multiple labels can be assigned
to a single element, which allows to have synonyms. Further, translations for keywords
in different languages can be enabled by the assignments.
Meta-model for Structured Query Generation. We require on the top level of the
ontology in use a strict separation of the concepts for spatial features SpatialFeat (e.g.,
Park , Restaurant, etc.), qualitative values QVal (e.g., operator Op, Cuisine, etc.), and
Geometry (e.g., Point , Polygon, etc.). Since our approach is designed to query spatial
objects, every query has to be related to some SpatialFeat, which is extended by the
subroles of hasQVal with qualitative values (asserted to QVal) and is represented by
the role hasGeometry as a geometry (asserted to Geometry). By this separation on the
top level (which also exists in GeoOWL http://www.w3.org/2005/Incubator/
geo/XGR-geo/), we have a meta-model, which is then used for the generation of
meaningful queries. Any ontology used with our approach has to be structured according to the meta-model. Fig. 1 shows some axioms of the meta-model for a specific
ontology.
Generation of SCQs from Keywords. The automatic completion and combination
step produces a set of valid keyword sequences, from which one sequence K = (k1,
k2, . . . , kn) is chosen (unless the user determines one). Each keyword ki represents
either a concept or a spatial predicate. We must connect all ki according to the metamodel to obtain SCQs, which then evaluate to spatial objects.

The rewriting of K to a SCQ Q is based on three steps that resemble a transducer with a context-free (left-recursive) grammar and a set of completion rules.
The latter are important, because even if the transducer generates syntactically correct queries, their results might not consist of spatial objects. E.g., we could have a
query ItalianCuisine(x), but the results R = (pizza, pasta, ...) could not be located on a map. Therefore, we have to extend the query as follows: Restaurant(x) 
hasCuisine(x, y)  ItalianCuisine(y).
?

?

?
to ((C1 hasQVal C2) hasQVal C3);

Table 1. Completion rules; the result of rules (R1)(R4) is denoted as subquery (SQ)
(R1) If C1  SpatialFeat and C2  QualAttribute rewrite to (C1 hasQVal C2);
(R2) If C1  SpatialFeat, C2  QualAttribute, C3  QualAttribute rewrite
(R3) If C1  QualAttribute rewrite to (SpatialF eat hasQVal C1);
(R4) If C1  QualAttribute and C2  QualAttribute rewrite
(R5) If E1  SpatialFeat or E1 is a SQ, E2  SpatialFeat or E2 is SQ, and S is a
(R6) If E1  SpatialFeat or E1 is a SQ, and E2  SpatialFeat or E2 is SQ rewrite

to ((SpatialFeat hasQVal C1) hasQVal C2);

spatial predicate rewrite to ((E1) S E2);

to ((E1) NextTo E2);

(1) We obtain a new sequence K

In the following, we describe the three steps in the rewriting of K in detail:
from the sequence K by replacing every keyword
with either a concept from T or a predefined spatial predicate. We check whether
the keywords are associated to a concept in N , otherwise we ignore it.
?

?

?
(2) We apply the completion rules in Table 1 on K

in a left-to-right order until no rules
?

?

?
are applicable, resulting in a sequence K
?

?

?
.
?

?

?
(3) We generate the query q(x) from K

according to the function
?

?

?
f (K

) = ( ((C1(x1)  E1,1(x1, y1)  E1,2(y1))  2)   )  n

where i = Ei,1((Ei1,1), yi)  Ei,2(yi) and C1 is a concept atom; each Ei,1
is either empty, a role atom, or a spatial atom, and each Ei,2 is either empty or
a concept atom; (Ei,1) is xi if Ei,1 is a spatial atom, and xi1 if Ei,1 is a role
atom. These assignments ensure that the spatial atoms are always related to the top
concept, while role atoms are related to the next level in the query tree.

After these steps, we obtain a valid SPQ q(x) for query evaluation (Sec. 4). For rules
(R2)(R4), Table 1 shows in fact a simplified version, as they could be extended to
arbitrary sequences of QualAttributes. Furthermore, rule (R6) defines a default re-
lationship, if two spatial features are queried. Rewriting them to a simple conjunction
between C1(x) and C2(x) would often lead to empty results, as two identical objects
assigned to different concepts do not often exist within geospatial data sources.
?

?

?
Example 1. Given the keywords K = (italian cuisine, non-smoking, in, park), we
apply the first step, where we replace every ki with an associated concept Ci from
N : K
= (ItalianCuisine, NonSmoking, Within, Park ). In the second step we apply the completion rules to obtain K
ItalianCuisine)
hasQVal NonSmoking) Within Park ). Finally we get a SCQ q(x1, x2)=f (K
) with

SpatialFeat (x1)  hasQVal (x1, y1)  ItalianCuisine(y1)  hasQVal (x1, y2)

= (((SpatialFeat hasQVal
?

?

?
NonSmoking(y2)  Within(x1, x2)  Park (x2) .

6 Generating Keyword Sequences

Since our approach is designed to have a single text-field for the keyword entries, we
aim to provide fast automatic completion, keywords detection, and keyword combination functions. If a user enters keywords on a user interface (UI), we guide her by

T. Eiter, T. Krennwallner, and P. Schneider

automatic completion and by showing possible combinations compliant with the on-
tology. For that, we must take the structure of the KB into account. Furthermore, as
many combinations may be compliant, a selection of relevant combinations must be
provided.
?

?

?
nN (Pref (e)  Pref (n)).

As the need for very low response time (e.g., below 100ms) makes on-demand calculation from the KB infeasible, a prefix index is created offline that stores all possible
prefixes for a label of N . It amounts to a function fP (e) which maps a string e to all
possible labels of N , such that
For example, the labels N = {pub, public, park}, fP map p, pub, and park as
follows: {p}  {park, pub, public}, {pu}  {pub, public},{park}  {park}.
Syntactic Connectivity of Concepts. As multiple keywords are entered, we need to
determine which concepts are connectable. We use a notion of syntactic connectivity C
based on the syntactic structure of the KB, which captures the connection between two
concepts through subconcepts and roles, but also through a common subsumer. For two
concepts, we follow the inclusion assertion and check whether they share a common
subsumer denoted as CS, excluding the top concept. As the KB is based on DL-LiteR,
we can capture the following inclusion assertions: (i) concept inclusion MC : C1  C2,
role hierarchies MH : R1  R2; (ii) role membership which covers the range (resp.
domain) of a role as MR : R
  C (resp. MD : R  C ); and (iii) mandatory
participation MP : C  R. We deliberately do not consider disjoint concepts as
C1  C2 in the inclusions, and distinguish direct and indirect connections between
two concepts.
A direct connection between concepts CA and CB exists, denoted D(CA, CB), if
a sequence CA M R1 M C1 M R1 . . . Cn M Rn M CB exists, where
M = MD  MH  MC  MR  MP . Furthermore, an indirect connection between CA
and CB exists, denoted I (CA, CB), if D(CA, CS)D(CB, CS) holds for some CS.

Example 2. In the example Fig. 1, the concepts Supermarket and Op are directly
connected: Supermarket MC Shop MP hasOp MR Op. On the other hand,
GuestGarden and W lan are indirectly connected: GuestGarden MC QV al MP
hasQV al MR SpatialFeat MR hasQV al MP QV al MC W lan.

In general, several sequences that witness D(CA, CB) resp. I (CA, CB) exist.

Automatic Completion, Detection, and Combination of Keywords. As we get a
sequence of entered strings E = (e1, e2, . . . , en), we need several steps to create the
completed keywords, as the strings could be prefixes or misspelled.
First, we obtain the set of labels L  N by applying the prefix function fP (ei) for
every ei  E. Second, we build several levels of labels L1, , Lm based on the size of
the subsets of L. As every Li has the subsets Li,1, , Li,o of the same size, we check
for every Li,j, if every pair of concepts (assigned to the labels of Li,j) is syntactically
connected at least in one direction. If we have found a Li,j with connected concepts, we
add all sets of Li (which are connectable) to the results. This is done by concatenating
the labels of every set of Li and add them to the result strings.
?

?

?
By introducing an iterative algorithm, we return the largest possible combinations
of keywords, thus excluding misspelled strings. However, we have in the worst-case
exponentially many connectivity checks in the lengths of E.

indian food,

food, non-smoking}. The first

Example 3. Given E = (rest,
in, non-smok), we obtain the labels L =
{restaurant,
level of L contains the sets L1,1 = {restaurant,
indian food, non-smoking} and L1,2 =
{restaurant, intl food, non-smoking}. The concepts assigned to them are C1,1 =
{Restaurant, IndianCuisine, NonSmoking} and C1,2 = {Restaurant, IntlCuisine,
NonSmoking}. Then, we check for C1,1, if every pair (C, C
  C1,1, is syntactically connected, and likewise for C1,2. The first two pairs are directly connected
and the last pair is indirectly connected by the common subsumer SpatialFeat . Hence,
the concepts in C1,1 (and in C1,2) are connectable. Then, we concatenate L1,1 (resp.
L1,2) and add the strings to the results.

intl
?

?

?
), C = C

7 Refinement of Conjunctive Query Generation

While FO-rewritability of CQ answering over DL-LiteR KBs implies tractable data
complexity, the size of the rewriting can increase exponentially with the number of
atoms in the input CQ. Empirical findings [20] are that queries with more than 5-7 atoms
can lead to large UCQs (e.g., unions of thousands of CQs) which cannot be handled by
current RDBMS. Similar problems emerge with our generated SCQ (Sec. 8). One reason
is the completion step in the SCQ generation. The generated SCQ can be too general, as
(Sec. 5) with the concept SpatialFeat and
we complete the intermediate sequence K
role hasQVal, which are at the top-level (by our meta-model) of an ontology.
The refinement OQ of the completion step is applied on every ontological subquery
of a SCQ of the form S(x1)R1(x1, y1)C1(y1). . .Rn(xn1, yn)Cn(yn), where
S  SpatialF eat, {R1 . . . , Rn}  hasQV al, and {C1, . . . , Cn}  QualAttribute
holds. It is based on the following ideas:
?

?

?
 Reduce the concept and role hierarchies: every edge in a path of D or I is an
inclusion assertion, which increases the size of the rewritten UCQ; in particular,
role inclusions can cause an exponential blow up [7];
 keep connectivity: by choosing paths according to I, we keep the domain, range,
mandatory participation, regarding the roles connecting S to {C1, . . . , Cn}.

Before applying OQ, note that so far, S is a most common subsumer different from
the top concept with respect to I ; i.e., for every pairs (S, C1), . . . , (S, Ci), I (S, Cj)
holds for all j and the sum of path lengths for I (S, Cj) is maximal. Thus, we try to
minimize the path lengths under the constraint that I is fulfilled for all pairs I (S, Cj ).
Briefly, it works as follows. We start the refinement OQ by taking every subconcept
Si of S. We choose a shortest path, say pj, according to I for every pair (Si, Cj ),
1  j  n, and we add up all path lengths |pj| to lenSi. Finally, we choose the Si with
the lowest lenSi as a replacement of S and R1 . . . , Rn, where the latter are replaced
with the roles appearing on the shortest paths pj for Si.
Example 4. Let q(x1) be SpatialFeat (x1) hasQVal (x1, y1) ItalianCuisine(y1)
hasQVal (x1, y2) NonSmoking(y2). For the pairs (Rest, ItalianCuisine) and (Rest ,

T. Eiter, T. Krennwallner, and P. Schneider
?

?

?
NonSmoking), we have a path p1 of length 2 (ResthasCuisineItalianCuisine)
and another path p2 of length 2 (Rest  provides  NonSmoking). Hence, the
refinement OQ produces the optimized query q
(x1), as the original paths are both of
length 3 and Rest is a subconcept of SpatialFeat: Rest(x1)  hasCusine(x1, y1) 
ItalianCuisine(y1)  provides (x1, y2)  NonSmoking(y2).
We point out that after applying OQ, we may lose completeness with respect to the original SCQ, as shown by the following example. Given a spatio-thematic KB containing
ABox assertions Rest(i1), hasCuisine(i1, i2), ItalianCuisine(i2), SpatialFeat (i3),
hasQVal (i3, i2), and ItalianCuisine(i2), such that hasCuisine has defined domain
Rest and range Cuisine. The query q(x1) = SpatialFeat (x1) hasQVal (x1, y1)
ItalianCuisine(y1) evaluates to {i1, i3}. If we refine q(x1) to the SCQ q
(x1) =
Rest(x1)  hasCuisine(x1, y1)  ItalianCuisine(y1), we just get {i1} as a result. In-
formally, completeness can be lost if the ABox assertions are very general. One way to
keep completeness is thus to impose conditions on the ABox, which ensure that ABox
assertions have to fulfill certain conditions.
?

?

?
8 Implementation and Experimental Results

We have implemented a prototype of our keyword-based query answering approach.
It is developed in Java 1.6 and uses PostGIS 1.5.1 (for PostgreSQL 9.0) as spatialextended RDBMS. For the FO-rewriting of DL-LiteR, we adapted OWLGRES 0.1 [22]
to obtain the perfect rewriting (with PerfectRef ) of a CQ and the TBox. We evaluate spatial atoms in two different ways (Sec. 4), namely as OD by using the query evaluation of
PostGIS or as OI as a built-in component of our query evaluation algorithm. For OD, we
use the PostGIS functions for evaluation, e.g., ST_Contains(x, y), and for OI , we apply the functions of the JTS Topology Suite (http://tsusiatsoftware.net/jts).
As part of a consortium with AIT Mobility Department (routing), Fluidtime (UI), ITS
Vienna Region (data and routing), we have integrated our prototype for the keywordbased query answering in the MyITS system for intention-oriented route planning
(http://myits.at/). Currently, the following services are available:
1. Neighborhood routing, where a user desires to explore the neighborhood for a

keyword-based query; and

2. Via routing, where a route is calculated between a given origin-destination pair via

some POI, which is dynamically determined by a keyword-based query.

Scenario. Our benchmarks are based on the usage scenarios of MyITS, which has
a DL-LiteR geo-ontology with the following metrics: 324 concepts (with 327 inclusion assertions); 30 roles (with 19 inclusion assertions); 2 inverse roles; 23 (resp. 25)
domains (resp. ranges) of roles; 124 normal individuals; a maximal depth of 7 (4)
in the concept (role) hierarchy (http://www.kr.tuwien.ac.at/staff/patrik/
GeoConceptsMyITS-v0.9-Lite.owl). For the spatial objects, we added and mapped
the POIs of greater Vienna contained in OSM ( 70k instances), in the Falter database
( 3700 instances), and parts of the OGD Vienna data ( 7200 instances). The annotation step created 18700 individuals, which lead to 18700 concepts and 26000 role
assertions. The low annotation rate of 23% is related to the exclusion of some OSM
POIs (e.g., benches, etc.) and the ongoing extensions of the mapping framework.
?

?

?
Table 2. Benchmark Results (Evaluation time in secs), unrefined results in parentheses

(a) Benchmark B1

(b) Benchmark B2, time only with OQ

Instances Query Size

Time

Instances Query Size

Time

Q1
Q2 1623 (1623)
Q3
Q4
Q5

106 (109) 438 (2256)
51 (2256)
204 (s) 28 (71712)
32 (m)
3 (m)

1.66 (4.96)
1.23 (5.59)
1.14 (s)
56 (m) 1.48 (m)
112 (m) 4.11 ( m)

OI OD

93 (93)
Q6
Q7 378 (378)
Q8
Q9 151 (151)

2 (2) 1.54 19.3
4 (4) 2.22 t
26 (s) 30 (71714) 3.37 t
2 (2) 2.02 t

Experiments. We conducted our experiments on a Mac OS X 10.6.8 system with an Intel Core i7 2.66GHz and 4 GB of RAM. We increased shared_buffers and work_mem
of PostgreSQL 9.0 to utilize available RAM. For each benchmark, the average of five
runs for the query rewriting and evaluation time was calculated, having a timeout of 10
minutes, and a memout of 750 MB for each run. The results shown in Table 2 present
runtime in seconds and query size (number of atoms in the CQ), and use s to denote
DB errors (e.g., the stack depth limit of Postgres 9.0 is reached), m for Java heap
space limit has been reached (750 MB), and t for timeout.
Benchmarks. We designed the first benchmark B1 based on keywords to measure the
refinement OQ on CQ without spatial predicates. The queries used in B1 are
Q1: (spar ) matches individuals run by Spar;
Q2: (guest garden) returns the individuals with a guest garden;
Q3: (italian cuisine, guest garden) retrieves individuals that serve italian cuisine (in-

cluding Pizzerias, etc.) and have a guest garden;

Q4: (italian cuisine, guest garden, wlan ) gives individuals of Q3 that in addition pro-

vide WLAN; and

Q5: (italian cuisine, guest garden, wlan, child friendly ) returns individuals of Q4

that in addition are child-friendly.

As described above, the keywords are completed to SCQ prior to evaluation as de-
scribed.

The benchmark B2 aims at comparing the database (denoted OD) and internal eval-

uation of spatial predicates (denoted OI ) under the refinement OQ. Its queries are
Q6: (playground , within, park ) returns playgrounds in a park;
Q7: (supermarket , next to, pharmacy ) matches supermarkets next to a pharmacy;
Q8: (italian cuisine, guest garden, next to, atm, next to, metro station) gives individuals with Italian food and a guest garden, whereby these individuals are next
to an ATM and a metro station. The nesting of the query is as previously defined
(((italian cuisine, guest garden), next to), . . . , metro station); and

Q9: (playground , disjoint , park ) retrieves playgrounds outside a park.
As the results in Table 2 show, the refinement OQ is essential for feasibility. Without
it, Java exceeds heap space limitation during perfect rewriting in most cases, and SQL
queries become too large for the RDBMS. The ontology of our scenario is big, yet
captures only a domain for cities using OSM, OGD Vienna, and Falter.

T. Eiter, T. Krennwallner, and P. Schneider

As ground truth we assume the unrefined query. We lost completeness only in Q1;
this is due to three objects, which were tagged in OSM as shops but not supermarkets.
With respect to the benchmark queries, the OSM tagging and our (heuristic) mapping
has a minor effect on the completeness. Further, the results for Q2 to Q5 reflect the fact
that adding keywords extends the selectivity of the query (smaller results), but enlarges
the UCQ considerably.

We were surprised by the large difference between internal and external evaluation
of the spatial relations. We would have expected the external evaluation by the RDBMS
is more efficient. Rewritten SQL queries have a three-leveled nesting, which consists
of spatial joins (S) on the first, unions () on the second, and normal joins () on
third level. It seems that standard query evaluation and optimization (in Postgres 9.0)
are overwhelmed by such complex structures.

9 Related Work and Conclusion

Regarding SCQ, the closest to our work is [18], where crisp results for the combination
of FO-rewritability of DL-Lite combined with the RCC -family (which offers qualitative models of abstract regions in topological space) are provided. For more expressive
DLs, Lutz et al. [17] introduced the notion of -admissibility, which allows the combination of ALC and RCC8 [19], for subsumption testing. In PelletSpatial [21], the authors implemented a hybrid combination of SHOIN and RCC8 . We follow a different
approach in which the spatial regions are considered as point sets as in [14,15]. How-
ever, we focus on scalable query answering (without distance primitives) and the related
implementation issues. In this way, we face similar challenges as recent Geo-SPARQL
engines did (e.g., Strabon [16] and Parliament [3]). However, we have a stronger focus
on ontology-based data access than on linked open-data (with an RDF data model).

Keyword-based search on the Semantic Web is a well-covered field of research. A necessarily incomplete list of relevant approaches is SemSearch [24], XXploreKnow [23],
and QUICK [25] which are general purpose search engines. The KOIOS [4], DOROAM [9], and the system of [2] support (text-based) spatial queries using ontologies.
Our approach differs from these systems regarding the expressivity of DL-Lite, with the
addition of spatial querying; the use of a meta-model for suitable query generation; and
a focus on gradual extendibility with new data sources.

In this paper, we presented an extension of DL-LiteR with spatial objects using pointset topological relations for query answering. The extension preserves FO-rewritability,
which allows us to evaluate a restricted class of conjunctive queries with spatial atoms
over existing spatio-relational RDBMS. Second, we provided a technique for the generation of spatial conjunctive queries from a set of keywords. For this, we introduced a
combination of a meta-model and completion rules to generate meaningful queries.
Third, we implemented a prototype and performed experiments to evaluate the applicability in a real-world scenario. From our point of view, the first results are encouraging,
as the evaluation time appeared to be moderate (always below 5 secs). Furthermore, our
keyword-based approach is easy to extend, the text-based input is lightweight, and it has
a reasonable precision through auto-completion and keyword combinations. However,
precision could be improved by more advanced query expansion techniques (cf. [11]).
?

?

?


Future research is naturally directed to variants and extensions of the presented ontology and query language. E.g., one could investigate how spatial conjunctive queries
work over EL [1] or Datalog
[5]. For our motivating application, the point set model
was sufficient, but extending our approach with the DE-9IM model [10] would be appealing and introduce further spatial relations. Then, one could work on query expansion techniques and on refinement of query generation, in a way such that completeness
is ensured. Finally, regarding the implementation, one could investigate the reason for
the unexpected performance on very large queries with spatial functions and conduct
further experiments on larger geospatial DBs, possibly comparing our approach to the
mentioned Geo-SPARQL engines.
