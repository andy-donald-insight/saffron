Semantic Web 0 (0) 1
IOS Press

Model Outlines: a Visual Language
for DL Concept Descriptions 1

Editor(s): Thomas Lukasiewicz, University of Oxford, UK; Diego Calvanese, Free University of Bozen-Bolzano, Italy
Solicited review(s): Natalya Keberle, Zaporozhye National University, Ukraine; Gergely Lukacsy, CISCO Systems, Ireland; Domenico Lembo,
Sapienza Universita di Roma, Italy

Fernando Naufel do Amaral
LLaRC  Laboratorio de Logica e Representacao do Conhecimento,
Depto. de Fisica e Matematica, Polo Universitario de Rio das Ostras,
Universidade Federal Fluminense, Rio das Ostras, RJ, Brazil
Email: fnaufel@gmail.com

Abstract. The development and use of ontologies may require users with no training in formal logic to handle complex concept
descriptions. To aid such users, we propose a new visualization framework called model outlines, where more emphasis is
placed on the semantics of concept descriptions than on their syntax. We present a rigorous definition of our visual language,
as well as detailed algorithms for translating between model outlines and the Description Logic ALCN . We have recently
conducted a usability study comparing model outlines and Manchester OWL; here, we report on its results, which indicate the
potential benefits of our visual language for understanding concept descriptions.

Keywords: Description Logics, visual languages, diagrammatic reasoning, usability

1. Introduction

When working with formal ontologies, one often
needs to formally represent conditions for membership in the defined classes. In this paper, we will call
such conditions concept descriptions, following the
Description Logic (DL) tradition [1].

Concept descriptions are important in many scenarios related to ontology development and use. For
example, DL reasoners perform logical inferences by
manipulating concept descriptions according to a specific deductive calculus. In many cases, users may be
interested not only in the answers provided by such
reasoners, but also in the chains of reasoning that led
to those answers. In order to understand such chains of
reasoning, users must be able to understand the mean-

1Work partially supported by research grant E-26/112.038/2008

from FAPERJ.

ing of the concept descriptions involved. This area of
study is referred to as proof explanation [17].

Another situation where concept descriptions play a
role is in ontology query languages [2]; for example,
in the DL Query Tab Protege plugin [5], a concept description C is given to a reasoner, which then returns
items of information about C, such as all its instances,
named subclasses, superclasses and equivalent classes.
Because many users of formal ontologies have no
specific training in logic, the problem of representing
concept descriptions in a user-friendly fashion is an
important one, and many researchers have proposed
different ways of solving it: replacing logical symbols with keywords in DL languages [12], automatically generating natural language paraphrases of concept descriptions [10], or using diagrammatic representations [11,15].

As an example to make this discussion more con-
crete, consider the following concept description in
DL syntax (to be formally introduced in Sect. 2 below),

1570-0844/0-1900/$27.50 c 0  IOS Press and the authors. All rights reserved

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

which appears in [4], a paper about proof explanation:

hasChild.
(cid:117) hasChild.

((hasChild.Doctor)

(cid:116) (hasChild.Lawyer))

(1)

(This description represents individuals having one
or more children, such that these children, in turn, have
no children who are not doctors, and no children who
are lawyers.)

Diagrammatic representations of concept descriptions have given rise to implementations of visual
ontology browsers. One such example is the visualization tool GrOWL [16], which produces the diagram in
Figure 1 for the concept description in (1). As can be
seen, the diagram is essentially an abstract syntax tree,
which offers nonspecialist users little help in understanding the semantics of the description, especially
if those users are not familiar with the DL operators
, ,  and (cid:116). In fact, we have found this to
be a common phenomenon: many visualization frameworks for concept descriptions are too faithful to the
syntax of the representation languages (e.g., DL), a
feature which may prevent users from grasping the semantics of the concept descriptions.

This paper discusses model outlines, which depart
from the syntax-based tradition in that they consist of
diagrams characterizing the class of models of a given
concept description  here, we use the term model
in the logical sense; see, e.g., [1]. The model outline
for (1), produced after applying a carefully defined set
of simplification rules to the original concept description (see Section 4), is presented in Figure 2. By adhering to some simple graphical conventions, such as
the convention that figures drawn in dashed stroke represent elements whose existence is optional, a user can
understand that the concept description represents a set
of individuals having at least one child and having as
grandchildren (if any) only doctors and non-lawyers.
Our previous papers [6,8] introduced the first version of model outlines and compared them to natural
language paraphrases of concept descriptions. Since
then [7], we have reformulated the visual language so
as to make it more intuitive (e.g., including optional labeled clusters, rendering cardinality restrictions as text
and fine-tuning the placement of inner boxes). We have
also altered the conversion algorithms to conform to
the new visual language.

Fig. 1. Diagram produced by GrOWL [16] (manually laid out)

Fig. 2. Model outline for description (1)

Most importantly, we have conducted a first usability test of model outlines, with promising results. Users
from different backgrounds were shown concept descriptions in two formalisms: our model outlines and
Manchester OWL (a textual notation for DL which
uses keywords for logical symbols, infix notation for
restrictions, syntax highlighting and indentation in order to make descriptions more readable for nonspecialists  see [12]). We then tested ease of understanding
for each formalism by asking the users questions about
the concept descriptions shown.

This paper is structured as follows: Sect. 2 presents
the syntax of model outlines for the Description Logic
ALCN , at the concrete (token) and at the abstract
(type) levels, as is recommended for diagrammatic
systems [14]; Sect. 3 defines the precise semantics of
model outlines, in the form of algorithms that translate
from model outlines to ALCN concept descriptions;
Sect. 4 discusses the translation of ALCN concept de-

C, D  A


| C
| C (cid:117) D
| C (cid:116) D
| R.C
| R.C
|  n.R
|  n.R
| = n.R

Manchester

Meaning

NOTHING
NOT C
C AND D
C OR D
R ONLY C
R SOME C
R MAX n
R MIN n
R EXACTLY n
Fig. 3. ALCN concept descriptions and their meanings

I(A)


  I(C)
I(C)  I(D)
I(C)  I(D)
{a   | b.[(a, b)  I(R)  b  I(C)]}
{a   | b.[(a, b)  I(R)  b  I(C)]}
{a   | #{b | (a, b)  I(R)}  n}
{a   | #{b | (a, b)  I(R)}  n}
{a   | #{b | (a, b)  I(R)} = n}

scriptions to model outlines; Sect. 5 reports and analyzes the results of the usability test; Sect. 6 considers some specific aspects and possible applications of
our visual language; Sect. 7 contains our concluding
remarks; an appendix provides a proof of correctness
of the translation algorithms.

2. Syntax of model outlines

We consider the Description Logic ALCN , whose
language of concept descriptions is specified in Figure 3, both in the DL syntax and in Manchester OWL.
(Work is under way to define model outlines for more
expressive languages, such as the concept language underlying OWL 2 DL [13].) In Figure 3, A stands for a
class name (i.e., an atomic concept term), R stands for
a property name (i.e., an atomic role term), and n represents a natural number. The (set-theoretical) meaning of these descriptions is given by a nonempty set
 (the universe or domain) along with an interpretation I mapping each concept description C to a set
I(C)  , and each role term R to a binary relation
I(R)    . An interpretation I must map each
description in the first two columns to the set in the
third column. #S denotes the cardinality of a set S.
A literal is , or , or a description of the form A or
of the form A, where A is an atomic concept term.
The concrete syntax of model outlines defines their
physical representation. What follows is an informal
definition.

A model outline contains clusters (solid or dashed),
arrows (solid or dashed) and boxes. We follow the
symbology established by the Protege1 user interfaces

1http://protege.stanford.edu

in representing individuals as dark-colored diamonds.
When cardinality restrictions are not present, the number of individuals satisfying certain conditions is not
important; therefore, so as not to mislead users into
thinking that only one individual is allowed in a certain
situation, we show a little cluster of diamonds.

The root of the model outline is a solid cluster. A
cluster may have an optional class label below it, consisting of a disjunction or of a conjunction of literals.
So may a box. A box may also have an optional cardinality label below it, which may be of the form (from
m thru n), (m or more), or (exactly m), with m, n
natural numbers, m < n. The source of an arrow may
be a cluster or a box. The target of an arrow is always
a box. Each box is the target of exactly one arrow. An
arrow must have a role label above it, consisting of a
role name. A box contains one or more clusters, according to constraints that we do not include in this
informal description, but which will be made explicit
in the abstract syntax below. A box may also contain
at most one among-which inner box, which in turn
contains one or more clusters, all of them solid. Inner
boxes are never the source of arrows. A box or a cluster
may have a case widget above it.

Figure 4 shows an example model outline. The target box of the arrow labeled hasAttendance has
both a class label (Enrolled) and a cardinality label (from 10 to 50). The target box of the arrow labeled hasAttendance also has an among-which inner box. This model outline does not have case wid-
gets.

At this point, the reader should test the appropriateness of the choice of visual presentation of the components of model outlines. We suggest that the reader
(without any further knowledge of the meaning of

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

Fig. 4. Example model outline

these components) formulate a natural language description of the constraints imposed upon the individuals of class GraduateCourse at the root of the out-
line. If the reader is knowledgeable in DL syntax, the
reader should also produce an ALCN concept descrip-
tion. In Sect. 3 below, we explain the precise meaning
of this model outline, and in Sect. 4 we show the steps
involved in its construction.

Case widgets indicate alternatives (i.e., disjunction).
If a cluster or a box has a case widget above it, the user
may browse the different cases interactively, one case
at a time, by clicking on the triangles on either side of
the case widget.

In Figure 5, for example, there are 4 cases alto-
gether, specifying objects that satisfy one or more of
the following conditions:

1. Textbooks having all extras (if any) translated to

Portuguese (and possibly other languages), or

2. Textbooks having all extras (if any) in Audio for-

mat (and possibly other formats), or

3. ClassNotes having at least one Free copy in PDF
format (and possibly other formats, and other
copies), or

4. ClassNotes having at least one Low-priced copy

(and possibly other copies).

Fig. 5. Example model outline with case widgets

More formally, the model outline in Figure 5 corre-

sponds to the description

[Textbook (cid:117) hasExtras.

(hasTranslation.Portuguese (cid:116)

hasFormat.Audio)] (cid:116)
{ClassNotes (cid:117) hasCopy.

[(Free (cid:117) hasFormat.PDF) (cid:116)

(hasPrice.Low (cid:117) hasPrice.Low)]}

Note that there are textual elements in the concrete
syntax of model outlines: labels associated to arrows,
clusters and boxes. These textual elements, however,
are kept simple so as not to compete with the diagrammatic elements for the users attention.

An arrow label consists solely of a role name. Cluster and box labels are either conjunctions or disjunctions of literals (box labels are prefixed by the word
ALL so as to emphasize that the label serves as
a universal restriction). Cardinality restrictions are of
one of three forms: EXACTLY n, n OR MORE,
FROM m THRU n.

We believe that these textual expressions are simple enough to be understood by a nonspecialist user; in
particular, as cluster and box labels never mix disjunction and conjunction, the logical complexity of labels
is kept in check. Furthermore, we see no substantial
gain in trying to present the information in these labels
in diagrammatic form (e.g., as abstract syntax trees).
As we asserted in [6], a previous paper by us comparing textual and diagrammatic representations of con-
cepts, logocentric [i.e., textual] and diagrammatic approaches to the representation of concepts are not mu-

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

(cid:104)outline(cid:105)  (cid:104)solidClstrCases(cid:105)

(cid:104)solidClstrCases(cid:105)  ( cases (cid:104)solidCluster(cid:105)+ )

(cid:104)solidCluster(cid:105)  ( cluster solid (cid:104)classLabel(cid:105) ( (cid:104)arrow(cid:105) ) )
(cid:104)classLabel(cid:105)  ( ) | ( (cid:104)literal(cid:105) )

| ( and (cid:104)literal(cid:105) (cid:104)literal(cid:105)+ ) | ( or (cid:104)literal(cid:105) (cid:104)literal(cid:105)+ )

(cid:104)literal(cid:105)  (cid:104)conceptName(cid:105) | ( not (cid:104)conceptName(cid:105) )
(cid:104)arrow(cid:105)  ( arrow solid (cid:104)roleName(cid:105) ( (cid:104)intrvl(cid:105) ) (cid:104)solidBoxCases(cid:105) )
(cid:104)intrvl(cid:105)  ( (cid:104)number(cid:105) (cid:104)number(cid:105) ) | ( (cid:104)number(cid:105) infty )

| ( arrow dashed (cid:104)roleName(cid:105) ( (cid:104)intrvl(cid:105) ) (cid:104)dashedBoxCases(cid:105) )

(cid:104)solidBoxCases(cid:105)  ( cases (cid:104)solidBox(cid:105)+ )

(cid:104)solidBox(cid:105)  ( box (cid:104)classLabel(cid:105) ( (cid:104)solidClstrCases(cid:105)+ ) (cid:104)opt(cid:105) ( (cid:104)arrow(cid:105) ) )

(cid:104)opt(cid:105)  ( (cid:104)unlabeledCluster(cid:105) ) | ( (cid:104)innerBox(cid:105)? ( (cid:104)dashedClstrCases(cid:105) ) )

(cid:104)unlabeledCluster(cid:105)  ( cluster dashed ( ) ( ) )
(cid:104)dashedBoxCases(cid:105)  ( cases (cid:104)dashedBox(cid:105)+ )

(cid:104)innerBox(cid:105)  ( innerBox (cid:104)solidClstrCases(cid:105)+ )
(cid:104)dashedBox(cid:105)  ( box (cid:104)classLabel(cid:105) ( (cid:104)snglDashedCluster(cid:105) ) ( ) ( (cid:104)arrow(cid:105) ) )

(cid:104)snglDashedCluster(cid:105)  ( cases ( cluster dashed (cid:104)classLabel(cid:105) ( (cid:104)arrow(cid:105) ) ) )
(cid:104)dashedClstrCases(cid:105)  ( cases (cid:104)dashedCluster(cid:105)+ )

(cid:104)dashedCluster(cid:105)  ( cluster dashed (cid:104)classLabel(cid:105) ( (cid:104)arrow(cid:105) ) )

Fig. 6. Abstract, formal syntax for ALCN model outlines

tually exclusive; in fact, since human beings are fluent in both modes of communication (verbal and pic-
torial), we believe these modes can complement each
other to great benefit.

If model outlines are used to help construct concept
descriptions, a software tool can provide guidance to
the user, ensuring that labels are filled out according to
the syntactic restrictions explained above. For exam-
ple, a graphical interface can present the user with a
list of atomic class names and options to negate chosen
names of the list and to join them in a conjunction or
in a disjunction.

The abstract syntax of a model outline is formally
defined as a LISP-style list generated by the grammar in Figure 6, which is in extended BNF notation.
The abstract syntax of a model outline is intended to
provide a structural representation of the components
of the diagram, without regard for graphical details
such as position, color, size or orientation. As an ex-
ample, Figure 7 contains the list representation of the
model outline in Figure 5. Note that the abstract syntax is not meant for human consumption, but rather for
automatic processing by algorithms such as the ones
presented in the next section.

3. Semantics of model outlines

The appearance of the components of a model outline follows some (hopefully intuitive) graphical con-
ventions:

Individuals are represented by clusters of diamonds.
The presence of a cluster (as opposed to a single dia-
mond) emphasizes the idea that one or more individuals may appear in a given situation. E.g., in Figure 4,
the graduate courses in question may have as lecturers
more than one tenured department professor holding a
CompSci or Math PhD degree and supervising at least
one graduate student from a total of 2 or more indi-
viduals; the presence of the dashed cluster in the target
box of the arrow labeled supervises indicates that the
professors may also supervise individuals that are not
graduate students (e.g., undergraduates).

Clusters of solid diamonds represent individuals that
must exist. In Figure 4, it is mandatory that the graduate courses in question have as lecturer at least one
tenured department professor holding a CompSci or
Math PhD degree and supervising at least one graduate
student from a total of 2 or more individuals. Likewise,
the attendance must include students and graduate stu-
dents.

Clusters of dashed diamonds represent optional in-
dividuals. If the cluster is labeled or has outgoing ar-
rows, the individuals must belong to the corresponding

(cases (cluster solid (Textbook)

((arrow dashed (hasExtras) ()

(cases (box () (cases (cluster dashed ()())) ()

(arrow solid (hasTranslation) ()

(cases (box () (cases (cluster solid (Portuguese) ()))

(cluster dashed ()()) ()))))

(box () (cases (cluster dashed ()())) ()

(arrow solid (hasFormat) ()

(cases (box () (cases (cluster solid (Audio) ()))

(cluster dashed ()()) ()))))))))

(cluster solid (ClassNotes)
((arrow solid (hasCopy) ()

(cases (box ()

(cases (cluster solid (Free)

(arrow solid (hasFormat) ()

(cases (box () (cases (cluster solid (PDF) ()))

(cluster dashed ()()) ()))))

(cluster solid ()

(arrow solid (hasPrice) ()

(cases (box () (cases (cluster solid (Low) ()))

(cluster dashed ()()) ()))))))

()())))))

Fig. 7. Abstract syntax for model outline in Fig. 5

class (e.g., Guest in Figure 4). If the cluster is un-
labeled, the individuals may belong to any class, subject to the constraints stipulated by the label and the
outgoing arrows of the outer box where the cluster is
located (e.g., in Figure 4, the unlabeled cluster in the
hasLecturer box represents lecturers that do not have
to be tenured department professors, but that must hold
a CompSci or Math PhD degree).

Arrows represent relationships. Arrows may originate from clusters or from boxes. Given a role name R,
each cluster or box may have at most one outgoing arrow labeled by R.

As previously indicated, box labels and arrows originating from boxes represent constraints that must be
satisfied by all individuals corresponding to clusters in
the box. E.g., in Figure 4, all individuals attending the
graduate courses in question must belong to class En-
rolled.

The absence of a dashed cluster in a box means that
all the individuals represented in the box must belong
to the classes specified by their respective labels and
to the class specified by the box label and arrows (if
present). This is evident in Figure 4, where it is required that the lecturers hold a PhD degree only in
CompSci or Math (a rather exclusivist and unfair re-
quirement, but this is only an example).

Dashed boxes, always the target of dashed arrows,
always contain a dashed cluster, representing optional
individuals. In Figure 4, the graduate courses in question may or may not involve the use of (up to 2) department labs.

Among which inner boxes contain clusters representing individuals that belong to subclasses of one or
more classes specified in the outer box. In Figure 4, the
attendance of the graduate courses in question consists
of students, some of which are required to be graduate
students. Optionally, guests may attend.

The above remarks are included here only for pedagogical purposes. In fact, we define the precise semantics of model outlines by means of the DESCR pro-
cedure, which, when given a model outline C (in abstract syntax), yields the ALCN concept description
taken as the meaning of C. The DESCR procedure calls
BOXDESCR to build the concept description denoted
by a box. Algorithm 1 shows both procedures in pseu-
docode.

The reader should refer to the grammar in Figure 6
for the structure of the lists that the algorithms ma-
nipulate. These algorithms can be modified to produce more legible output; here, their only purpose is to
serve as the precise semantics of model outlines. When
given as input the model outline in Figure 2, e.g., algo-

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

 C has the form ( cases C1  Cm )

 Ci has the form ( cluster S L ( A1  An ) )

do if L = ( )

for each Ci in C1, . . . , Cm
then Case  
else if L = ( NOTHING ) then Case   else Case  L
for each Aj in A1, . . . , An
do Case  Case (cid:117) BOXDESCR(Aj)
Descr  Descr (cid:116) Case

 A has the form ( arrow S RN ( I1  In ) ( cases B1  Bm ) )

for each Bi in B1  Bm

 Each box case Bi has the form ( box BL ( C1  Cp ) Opt ( A

1  A

q ) )

DESCR(C)
1 Descr  

return Descr

if n = 0

BOXDESCR(A)
1 BDescr  

 No cardinality restrictions

then Card  
else Card  

for each Ij in I1, . . . , In

 Ij is interval of the form ( X Y )

do if Y = infty

then Card  (Card (cid:116)  X.RN )
else Card  (Card (cid:116) ( X.RN (cid:117)  Y.RN ))

do Universal  ; Existentials  

for each Cj in C1, . . . , Cp

do Universal  Universal (cid:116) DESCR(Cj)

 Solid cluster cases

if Cj has the form ( cluster solid . . . )
then Existentials  Existentials (cid:117) RN .DESCR(Cj)

if Opt contains ( innerBox C

then for each C

j in C

1, . . . , C

1  C
r )

do Existentials  Existentials (cid:117) RN .DESCR(C
j)

 Optional clusters

do Universal  Universal (cid:116) DESCR(C
j )

if Opt contains ( cluster dashed ( ) ( ) )
then Universal  
1  C
if Opt contains ( cases C
s )
j in C
1 , . . . , C
then for each C
Universal  RN .(Universal )
if BL = ( )
then BCase  Universal (cid:117) Existentials
else BCase  RN .BL (cid:117) Universal (cid:117) Existentials
for each A
do BCase  BCase (cid:117) RN .BOXDESCR(A
j)
BDescr  BDescr (cid:116) BCase

 Box arrows

1, . . . , A

j in A

return Card (cid:117) BDescr

Algorithm 1. Conversion from model outlines to ALCN

rithm DESCR returns the following description, which
is equivalent to (1):

The remarks below will help the reader follow the

code of DESCR and BOXDESCR in Algorithm 1:

 (cid:116) { (cid:117) hasChild.( (cid:116)  (cid:116) ) (cid:117)  (cid:117)
hasChild.( (cid:116) ) (cid:117) hasChild.[ (cid:117)
( (cid:116) hasChild.( (cid:116) (Doctor (cid:117) Lawyer)))]}

 When DESCR(C) is called, C is a list containing
a collection of cluster cases. Each cluster case Ci
is processed by the loop in lines 28. In line 9,
the disjunction of the descriptions corresponding
to the cluster cases is returned.

 In DESCR, each cluster case Ci has its label processed (lines 35) and its collection of arrows sent
to BOXDESCR (line 7). The conjunction of the
descriptions corresponding to those label and arrows is stored in variable Case.

 Procedure BOXDESCR is responsible for processing the arrow represented by the argument A and
all the box cases that the arrow points to.

 In BOXDESCR, lines 28 handle the cardinality

restrictions (if any) associated to the arrow.

 In BOXDESCR, the loop in lines 929 handles

each box case Bi that the arrow points to.
 In the loop, variable Universal will store a description of the form R.D. At first, D will be a
disjunction of all the descriptions corresponding
to the solid cluster cases in the box (line 12).

 However, if there is an unlabeled dashed cluster
in the box, then there is no universal restriction
corresponding to the box (based on the clusters in
the box, that is), and Universal gets  (line 19).
 If there are labeled dashed clusters in the box
(which precludes the unlabeled dashed cluster
mentioned in the previous remark  see grammar in Figure 6), the descriptions corresponding
to such clusters will also be included in the disjunction stored in Universal (line 22).

 In the loop, variable Existentials will hold a conjunction of descriptions, each one of the form
R.D. These concept descriptions originate from
the solid clusters in the box (line 14) and from
the solid clusters in the among which inner box
(line 17).

 Finally, BOXDESCR will process the box label
(lines 2426), and the box arrows (lines 2728).

4. Constructing model outlines

In [8] we presented a first algorithm for translating ALCN concept descriptions into model outlines.
In this paper, we incorporate some important changes
to the algorithm (e.g., to account for labeled optional
clusters) and give a more informal explanation of the
main steps involved in such a translation, using as a
working example the concept description that originated the model outline in Figure 4.
Given an ALCN concept description C, we start
by converting C to modified disjunctive normal form
(mDNF), applying simplification rules in the process.
A concept description is in mDNF if it fits the pattern

D1 (cid:116) . . . (cid:116) Dn

where each disjunct Di is a conjunction of the form

C1 (cid:117)  (cid:117) Cp

where each conjunct Cj is either a literal, or a collection of intervals of natural numbers (whose upper
bound may be ) associated to a role R, or a description of the form R.C or of the form R.C, where
C is itself in mDNF.

The modification is in the way number restrictions
are represented: using appropriate rewrite rules, any
conjunction of cardinality restrictions over a role Ri
can be converted to a collection of intervals of natural numbers; for role R, the interval [m, n] represents
the constraint ( m.R (cid:117)  n.R). Likewise, [m, m]
represents (= m.R), and [0, m] represents ( m.R),
and [m,] represents ( m.R).

To each Di we then apply the simplification rule

R.C1 (cid:117) . . . (cid:117) R.Cn  R.(C1 (cid:117) . . . (cid:117) Cn)

As a result, we obtain C, which is a disjunction D
. . . (cid:116) D

n, where each D

i can be written as

1 (cid:116)

L1 (cid:117) . . . (cid:117) Lm (cid:117) C1 (cid:117)  (cid:117) Cp

where each Li is a literal, and each Cj can be written
as

R.F (cid:117) R.G1 (cid:117) . . . (cid:117) R.Gq (cid:117) K

where F and all the Gi are in mDNF and K is a collection of intervals of natural numbers representing cardinality restrictions over role R. Any (or all) of these elements may be absent. Note that we have grouped the
conjuncts according to the role R they refer to. Later,
when the model outline is built, each of these groups
will originate an arrow labeled by R (this is why at
most one arrow labeled by R may originate from any
given cluster or any given box).

Following these guidelines, the simplified mDNF of
the concept description corresponding to the example

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

model outline in Figure 4 is found to be

includes the first transformation. Whenever the conjuncts for role R are of the form

GraduateCourse

(cid:117) hasLecturer.

[holdsPhDIn.(CompSci (cid:116) Math)
(cid:117) holdsPhDIn.(CompSci (cid:116) Math)]

(2d)
(cid:117) hasLecturer.(DeptProfessor (cid:117) Tenured (2e)
(2f)

(cid:117) supervises.GradStudent
(cid:117) {[2,]}.supervises)

(cid:117) {[2, 2]}.hasLecturer
(cid:117) hasAttendance.[(Student (cid:117) Enrolled)

(cid:116) (Guest (cid:117) Enrolled)]

(cid:117) hasAttendance.Student
(cid:117) hasAttendance.GradStudent
(cid:117) {[10, 50]}.hasAttendance
(cid:117) usesLab.(DeptLab (cid:117) Closed)
(cid:117) {[0, 2]}.usesLab

(2a)

(2b)

(2c)

(2g)

(2h)

(2i)

(2j)

(2k)

(2l)

(2m)

(2n)

(2o)

R[(C1 (cid:117) D) (cid:116)  (cid:116) (Cn (cid:117) D)

(cid:116) (Cn+1 (cid:117) D) (cid:116)  (cid:116) (Cn+p (cid:117) D)]

(cid:117) R.C1 (cid:117)  (cid:117) R.Cn (cid:117) R.F1 (cid:117)  (cid:117) R.Fq
where D is a conjunction (with D =  as the trivial
case) it proceeds as follows:

 Solid clusters for C1, . . . , Cn are created in the

main target box for the R-arrow.

 If D is a conjunction of literals, then the main
target box for the R-arrow gets D as a label. If
D = , this label is not shown.

 If D is not a conjunction of literals (i.e., if one of
the conjuncts is not a literal), then the main target box for the R-arrow gets the literal conjuncts
as a label and the nonliteral conjuncts as arrows
originating from the box.

 The main target box for the R-arrow gets an
among which inner box containing solid clusters for F1, . . . , Fq.

 Dashed clusters for Cn+1, . . . , Cp are created in

the main target box for the R-arrow.

Note how the constraints have been grouped by the
roles they act upon. Note also how the cardinality constraints in lines (2g), (2h), (2m) and (2o) have been
written with (singleton) collections of intervals of natural numbers.

Two transformations must be effected before the

model outline can be built.

The first one concerns lines (2c)(2d), where the set
of objects related to the lecturers through holdsPhDIn
is closed: i.e., the lecturers must hold some PhD degree
in CompSci or Math and only PhD degrees in CompSci
or Math.

The algorithm detects such a closure whenever it

finds conjuncts of the form

R(C1 (cid:116)  (cid:116) Cn) (cid:117) R.C1 (cid:117)  (cid:117) R.Cn

Here, we have n = 1 and C1 = CompSci (cid:116) Math.
Then, to indicate the closure, the algorithm refrains
from adding a dashed, unlabeled cluster to the target
box of the holdsPhDIn arrow (see Figure 4).

The second transformation is similar: in lines (2i)
(2l), we can see there is some sort of closure related to
the role hasAttendance, but the situation is more com-
plicated. In fact, this is the general case, which also

In our example description, in lines (2i)(2l), we
have that n = 1, and C1 = Student, and D =
Enrolled, and p = 1, and C2 = Guest, and q = 1, and
F1 = GradStudent.
Algorithms 24 show the detailed pseudocode for
converting an ALCN concept description C in modified DNF to the abstract syntax of its corresponding
model outline. Next, we present remarks about the behavior of each procedure in the algorithms.
In order to build the entire model outline for an
ALCN concept description C, one should call the procedure as BUILDCLUSTERCASES(solid, C).

The remarks below will help the reader follow the

code of BUILDCLUSTERCASES in Algorithm 2:

 Lines 18 treat the base cases, where the description in modified DNF is , , a disjunction of
literals, or a conjunction of literals, respectively.
 In line 2, this piece of abstract syntax should be
rendered visually in such a way as to make it clear
that C is inconsistent (i.e., C denotes the empty
set).
 If the algorithm does not exit before or at line 8,
then we know C is of the form L1 (cid:116)  (cid:116) Lm (cid:116)
D1 (cid:116)  (cid:116) Dn, with m  0, n  1, where each
Li is a literal, and each Di is a nonliteral.

 A disjunction of literals

 A conjunction of literals

then return ( cases ( cluster stroke ( NOTHING ) ( ) ) )

if C = 
if C = 
if C = L1 (cid:116)  (cid:116) Ln
if C = L1 (cid:117)  (cid:117) Ln

then return ( cases ( cluster stroke ( ) ( ) ) )
then return ( cases ( cluster stroke ( OR L1  Ln ) ( ) ) )
then return ( cases ( cluster stroke ( AND L1  Ln ) ( ) ) )

BUILDCLUSTERCASES(stroke, C)

9  From here on, C is of the form L1 (cid:116)  (cid:116) Lm (cid:116) D1 (cid:116)  (cid:116) Dn, with m  0, n  1,
10  all of the Li literals, and all of the Di nonliterals
cases  ( cluster stroke ( OR L1  Lm ) ( ) )

for each Di in D1  Dn

13  Di is of the form L1 (cid:117)  (cid:117) Lm (cid:117) C1 (cid:117)  (cid:117) Cp, with m + p > 0

arrows  ( )
for each Cj in C1  Cp
cases  cases + ( cluster stroke classLabel arrows )

do arrows  arrows + BUILDARROW(Cj)

do classLabel  ( AND L1  Lm )

return ( cases cases )

Algorithm 2. Conversion from ALCN to model outlines: BUILDCLUSTERCASES

 Line 11 gathers all the literals in L1 (cid:116)  (cid:116) Lm
into one single case.

 The loop in lines 1218 produces a case rooted
in the present cluster for each of the remaining
disjuncts Di, each of which is of the form

L1 (cid:117)  (cid:117) Lm (cid:117) C1 (cid:117)  (cid:117) Cp

subject to all of the following conditions:

 m + p > 0 (i.e., there must be at least
one conjunct; otherwise, C would be , and
would have been treated in one of the base
cases of the algorithm).
 If p = 0 then m  2 (i.e., if there are only
literals in the conjunction, there must be
more than one literal; otherwise, Di would
be a literal, and would have been treated in
line 11 above, which gathers all literals into
a single case).

 In line 14, if m = 0, then classLabel should be
empty. If m = 1 then, it should get L1, with no
AND.

 Now, each Cj consists of a conjunction of all restrictions over a single role R, including cardinality restrictions.

 Then, in the loop consisting of lines 1617, each
Cj gives rise to an arrow leaving the present case,

and in line 18 the present case is added to the set
of cases associated to the present cluster.

Each arrow (along with its target box or box cases) is
built by procedure BUILDARROW, whose pseudocode
is detailed in Algorithm 3.

The following remarks are intended to help the

reader follow the steps involved:

 Strictly speaking, the BUILDARROW procedure is
non-deterministic, as there may be more than one
way to parse the input concept description C in
the form outlined in lines 1 6.
 More precisely, there may be more than one conjunct D common to all disjuncts in the R universal restriction.

 Concept descriptions C1 . . . Cn will correspond

to solid clusters in the target box.

 Concept descriptions Cn+1 . . . Cn+p will correspond to dashed clusters (i.e., optional individu-
als) in the target box.

 Concept description D will correspond to the target boxs label and to arrows leaving the target
box.

 Concept descriptions F1 . . . Fq will correspond
either to solid clusters in the among which inner box or to solid clusters in the target box, depending on circumstances explained below.

 The procedure is structured in 3 cases:

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

then opt  ( cluster dashed ( ) ( ) )

if q = 0
then opt  ( )
else opt  ( innerBox BUILDCLUSTERCASE(solid, F1) . . . BUILDCLUSTERCASE(solid, Fq) )
if p > 0
then opt  opt + ( cases BUILDCLUSTERCASE(dashed, Cn+1) . . . BUILDCLUSTERCASE(dashed, Cn+p) )
boxCase  BUILDBOXCASE(D, existentials, opt)
return ( arrow solid ( R ) ( K(R) ) ( cases boxCase ) )

if n > 0

then existentials  ( C1 . . . Cn )

else if K(R) has an interval containing 0

existentials  ( F1 . . . Fq ); stroke  solid
then opt  ( cluster dashed ( ) ( ) )
else opt  ( ); existentials  (  ); stroke  solid

existentials  ( ); stroke  dashed
boxCase  BUILDBOXCASE(, existentials, opt)
return ( arrow stroke ( R ) ( K(R) ) ( cases boxCase ) )

R.[(C1 (cid:117) D) (cid:116)  (cid:116) (Cn (cid:117) D) (cid:116) (Cn+1 (cid:117) D) (cid:116)  (cid:116) (Cn+p (cid:117) D)]
(cid:117) R.C1 (cid:117)  (cid:117) R.Cn
(cid:117) R.F1 (cid:117)  (cid:117) R.Fq
(cid:117) K(R)
if n = 0  p = 0
then if q > 0

BUILDARROW(C)
1  C is of the form
2 
3 
4 
5 
6  with K(R) a (possibly empty) list of natural number intervals representing cardinality restrictions over R

then existentials  ( ); opt  ( ); literals  ( ); disjuncts  ( Cn+1 . . . Cn+p )

then return ( arrow dashed ( R ) ( K(R) ) ( boxCases ) )
else return ( arrow solid ( R ) ( K(R) ) ( boxCases ) )

then opt  BUILDCLUSTERCASE(dashed, literals)

boxCases  boxCases +BUILDBOXCASE(D, existentials, opt)

do opt  BUILDCLUSTERCASE(dashed, C)

boxCases  boxCases +BUILDBOXCASE(D, existentials, opt)

do opt  BUILDCLUSTERCASE(dashed, C)

boxCases  boxCases + BUILDBOXCASE(D, existentials, opt)

if literals is nonempty
then opt  BUILDCLUSTERCASE(dashed, literals)

boxCases  boxCases + BUILDBOXCASE(D, existentials, opt)

then literals  literals (cid:116) Ci; disjuncts  disjuncts  Ci

for each Ci in Cn+1 . . . Cn+p

do if Ci is a literal
boxCases  ( cases )
if q = 0

then if literals is nonempty

for each C in disjuncts

else existentials  F1 . . . Fq

for each C in disjuncts

if n = 0  p > 0

if K(R) is absent or has an interval containing 0

return ( arrow solid ( R ) ( K(R) ) ( boxCases ) )

Algorithm 3. Conversion from ALCN to model outlines: BUILDARROW

BUILDBOXCASE(D, E, opt)
1  D is of the form L1 (cid:117)  (cid:117) Ln (cid:117) C1 (cid:117)  (cid:117) Cm, with each Ci over a role name
boxLabel  ( AND L1  Ln )

boxArrows  ( )

for each Ci in C1  Cm

6 allClusterCases  ( )
for each element G in E

allClusterCases  allClusterCases + clusterCases
return ( box ( boxLabel ) allClusterCases opt boxArrows )

do clusterCases  ( cases ) + BUILDCLUSTERCASES(solid, G)

do boxArrows  boxArrows + BUILDARROW(Ci)

Algorithm 4. Conversion from ALCN to model outlines: BUILDBOXCASE

1. n = 0  p = 0 (starting on line 7): there is
only one target box case. If present, concept
descriptions F1 . . . Fq give rise to solid clus-
ters. As there are no universal restrictions,
the target box will contain a dashed, unlabeled cluster, unless the cardinality restrictions K force the existence of individuals in
the target box, in which case, the unlabeled
cluster will be solid.

2. n > 0 (starting on line 17): there is only
one target box case. Concept descriptions
C1 . . . Cn will give rise to solid clusters.
If present, descriptions Cn+1 . . . Cn+p will
give rise to dashed, labeled clusters corresponding to optional individuals. If present,
concept descriptions F1 . . . Fq will give rise
to solid clusters in the among which inner
box. D will give rise to the target boxs label
and outgoing arrows.
3. n = 0  p > 0 (starting on line 26): multiple box cases may be produced here. Each
of Cn+1 . . . Cn+p that is not a literal will
give rise to a box case (literals will be gathered into one single box case and appear as a
disjunction in the dashed clusters label). If
present, concept descriptions F1 . . . Fq will
give rise to solid clusters in the among
which inner box, which will be common to
all box cases. D will participate in the target
boxs label and outgoing arrows.

Finally, procedure BUILDBOXCASE in Algorithm 4
is responsible for building each box case. Concept description D gives rise to the boxs label and outgoing arrows. The contents of the box case are generated
from parameters E (solid clusters) and opt (dashed
clusters and/or an among which inner box). Note

that the stroke of the box (dashed or solid) and the cardinality restrictions are actually associated to the arrow
incident to the box, which is computed by the BUILDARROW procedure.

5. Usability Evaluation

We have conducted a usability study in order to evaluate our proposed diagrammatic notation. The main
aim was to test the usefulness of model outlines for the
understanding of complex concept descriptions.

Note that it is the model outline notation itself that is
being evaluated, not a specific graphical user interface
(GUI) implementing the notation. Thus, the focus of
the study is on understanding, not on interaction. We
find this to be an advantage, as changes can be made
to the notation before we are committed to a specific
GUI, and problems can be identified in relation to specific features of the notation, so that special attention
can be given to these problems in order to solve or mitigate them through the use of appropriate human interaction techniques. From a practical point of view, this
potentially reduces the need for radical, costly changes
after implementation.
Likewise, we have chosen model outlines for the
simpler ALCN language so we could find out early if
something needs to be changed in our most basic as-
sumptions. The result of this test will help us design
the extensions of model outlines to deal with more expressive concept languages.

Following [9], our main goal is to show that model
outlines can help users with little or no training in
Logic to understand complex concept descriptions.
In particular, model outlines are more effective than
Manchester OWL for this task.

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

Manchester OWL (see Figure 3 and also [12]) is
a textual notation for DL which uses keywords for
logical symbols (e.g., SOME for ), infix notation for restrictions (e.g., hasChild SOME Man for
hasChild.Man), syntax highlighting and indentation in order to make descriptions more readable for
nonspecialists. So, we are comparing our diagrammatic notation with a textual notation designed for the
same target audience. As the test participants were all
Brazilians, we used Brazilian Portuguese translations
of the Manchester OWL keywords, as listed below:

SOMENTE

ONLYSOME SOMENTEALGUM

EXACTLY

EXATAMENTE

The decision to use Brazilian Portuguese translations of Manchester OWL keywords may have introduced an extra variable in the usability study, as one
must now worry about how faithful to the original keywords those translations are. However, educated Portuguese speakers will notice that the translations reflect
the semantics of the original keywords, including the
potential for undesired interpretations (i.e., those that
do not agree with the formal semantics of DL opera-
tors).

For example, Brazilian Portuguese OU is as ambiguous as English OR, as many speakers tend to
interpret it as exclusive or instead of inclusive or.

Also, the mistake of interpreting universal restrictions as implying existence is as common with English
ONLY as with Portuguese SOMENTE.

As noted in [12], users still needed training to
re-align their natural interpretation with the correct OWL/DL interpretation. [. . . ] However, it is arguable that explanations of OWL semantics would be
required whatever syntax was chosen. In our usability
study, participants took a tutorial on Manchester OWL
(in Portuguese) containing many examples before they
had to answer questions to test their understanding of
concept descriptions.

The material used in the tutorials and the tests is
available online at http://www.professores.
uff.br/fnaufel/mo/us01.html.

Next, we defined a set of concerns, in the form
of questions like: Can users understand the meaning of X?, where X is one of the elements present in
model outlines (solid clusters, dashed clusters, arrows,
boxes, inner boxes, case widgets, etc.). Specific concerns were also formulated (e.g., Can users understand that individuals in among which inner boxes
are mandatory?).

We selected 10 participants for our study (note that
[9] recommends 6 to 12). These participants come
from several backgrounds and occupations, as detailed
below. All received detailed information on the procedures and on their rights as participants. All signed
terms of informed consent.

One session of the study consisted of:

1. a pre-test questionnaire,
2. a tutorial on notation A,
3. a specification on domain X using notation A,
4. 15 questions about the specification,
5. a post-task questionnaire,
6. a tutorial on notation B,
7. a specification on domain Y using notation B,
8. 15 questions about the specification,
9. a post-task questionnaire,
10. a post-test questionnaire.

Notations A and B alternated between model outlines and Manchester OWL. Domains X and Y alternated between graduate courses (which included Figure 4 of this paper) and family relations. Each participant answered 15 questions for each domain. The
questions for each domain were fixed, regardless of
the notation used. For each domain, half the participants answered questions on model outlines, and half
answered questions on Manchester OWL specifica-
tions. Half the participants saw model outlines before
Manchester OWL, and half saw Manchester OWL before model outlines.

The number of correct answers and the time to answer were measured. Additional information was obtained in the form of comments collected through the
thinking out loud protocol [9] and through question-
naires. Table 1 shows the occupation and the number
of correct answers for each participant.

For the graduate courses domain, we note the fol-

lowing highlights:

Question 8 was related to Figure 4 of this paper, and
elicited 5 errors using Manchester OWL, and no errors
using model outlines. The question was: If a course
is attended only by students that are not graduate stu-

Occupation and number of correct answers for each participant

Table 1

Occupation

Logician
Theoretical physicist
Software engineer
Secretary
Nurse
Graphics designer
Social worker
Comp. Science undergrad
Production engineer
Mathematician
Totals:
Percentages:

Correct
answers
(model
outlines)

Correct
answers

(Manchester

OWL)

91.3%

77.3%

dents, does the course meet the specification? The error was probably induced by the abbreviation recommended in [12]:

hasAttendance SOME [Student, GradStudent]

which seems to have evoked the idea that the bracketed list consisted of a set of alternatives. This question was answered correctly by all participants using
model outlines, which indicates that users understood
the meaning of among which inner boxes.

Question 14 elicited 4 errors with Manchester OWL,
and 3 errors with model outlines. This question was
about a specification consisting of 4 cases. The situation proposed in the question satisfied exactly one
of the 4 cases. With Manchester OWL, the participants had difficulty in finding their way among multiple parentheses and complex disjunctions. With model
outlines, they apparently thought that the proposed situation had to satisfy all cases.

For the family relations domain, we note the follow-

ing highlights:

Question 6 elicited 4 errors with Manchester OWL,
and no errors with model outlines. This question asked
if a person satisfying the given specification could
have jobless children. The specification in Manchester
OWL included the sentence

hasChild SOME

(Man AND worksAt ONLY Hospital)

Apparently, the users forgot the fact that ONLY
(which stands for ) does not imply the existence of
objects. In the model outline, the presence of a dashed
cluster, a dashed box and a dashed arrow made it clear
that existence was not required.

Question 8 elicited 3 errors using Manchester OWL,
and 1 error using model outlines. This question asked
if a person satisfying the given specification had to
have a grandchild working as a surgeon. Some users
found it confusing to follow the composition of roles
(hasChildhasChild), and were again, as in question 8
about graduate courses, confused by the Manchester
OWL abbreviation SOME [ ]. In the model out-
line, the presence of a solid cluster labeled Surgeon inside an among which inner box made the correct answer more clear.

One trend was clearly observed in both domains:
specifications that involve cases (i.e., complex disjunc-
tions), such as the one in Figure 5 of this paper, are
more difficult to understand than those that do not, as
Table 2 indicates.

Table 2

Number of correct answers per domain and type of specification
Correct answers

Domain and

Correct answers
(model outlines)

(Manchester

type of

specification
Family, no cases
Courses, no cases
Family, with cases
Courses, with cases

94%
96%
84%
84%

OWL)
72%
84%
72%
80%

Among the comments offered by the participants,
many indicated confusion due to the way cases were
presented in model outlines (like in Figure 5 of this pa-
per, the layout used in the test consisted of 4 diagrams
on a single page). Some users thought that all 4 diagrams had to be satisfied. This is clearly one weakness
of model outlines (on paper) that we must try to eliminate in the GUI implementation. We predict that such
confusion will not arise if the user interacts with the
model outline (e.g., dynamically expanding and collapsing cases). The GUI should also make clear when
clusters in different cases actually correspond to the
same cluster, by showing one single cluster which can
be expanded in different ways.

As for time: in the courses domain, each user took in
average 28 seconds per question, regardless of the no-
tation. In the family relations domain, each user took in
average 26 seconds per question with model outlines,
but 40 seconds per question with Manchester OWL.

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

Of the 10 participants, 5 said they preferred model
outlines, 4 said they liked both notations equally well,
and 1 said both notations were equally bad, remarking
that he preferred formal logic notation.

6. Discussion

Among several questions related to our proposed visual framework, we examine here the issue of possible
applications and a more specific problem regarding the
interaction of concept descriptions with the axioms in
the TBox of a formal ontology.

6.1. Applications

Apart from the usability issues discussed in Section 5, we can examine the question of usefulness;
more precisely, in what applications and tasks can
model outlines be of help to users?

The algorithms presented in Sections 3 and 4 provide a translation-based formal semantics to our visual
language. Such algorithms also suggest two basic ways
of using model outlines:

In a first scenario, an ontology browser can show
nonspecialist users model outlines corresponding to
complex concept descriptions (such as necessary and
sufficient conditions in the definitions of classes). This
was our original motivation, and this is the application the usability test was designed to take into account
(investigating how well nonspecialist users could understand concept descriptions rendered as model out-
lines). Here, a concept description is translated into a
model outline, and the user takes on a more or less passive stance, interacting with a finished diagram only
to collapse and expand elements, switch the focus to
certain cases, etc.

Of course, the usefulness of model outlines in this
scenario depends on the frequency with which users
have to deal with complex concept descriptions such as
the one represented by the model outline in Figure 4.
We conjecture that in the context of proof explanation,
at least, complex concept descriptions arise naturally.
The answer to the more general question  how often
do complex concept descriptions occur in practice? 
requires designing specific tests and surveys targeted
at a broad population of ontology users, and is not examined further in this article.

In a second situation, the user may be expected to
create and edit model outlines. We can envision a dedicated graphical editor which will guide the user in the

task of assembling a diagram from basic elements such
as clusters, boxes and arrows, providing autocompletion and other facilities to help the user find the desired
class and role names to include in labels. In this sce-
nario, the user takes on a much more active role, and
the interaction provided by the graphical editor must
be carefully planned in order to prevent the user from
building nonsensical diagrams or, even worse, to prevent the user from becoming confused because a certain operation he is trying to perform (and which he
finds to be intuitive) is not being allowed by the edi-
tor. In other words, the manual construction of model
outlines by the user presents interaction and usability
problems that seem to be harder than those involved in
the mere exhibition of finished model outlines. If such
a graphical editor is to be made available, more specific usability tests must be conducted first.

The manual construction of model outlines is an activity that may be required in at least two tasks: the user
may want to define concept descriptions to serve as
necessary and sufficient conditions in class definitions,
or the user may want to construct a diagram to submit
as a visual query on the ontology he is working on. In
this latter case, the definition of model outlines must
be altered to provide features that are typical of query
languages, such as clusters marked as variables to be
bound by the query results. One possibility that seems
worth investigating is the formatting of the querys results themselves as model outlines, allowing the same
visual language to be used for queries and for the data
returned by them.

The use of model outlines to exhibit instance data
leads to a third possible application: model exploration [3], where a user may interact with generated
models of the formal ontology he is working on, so as
to gain better understanding of the axioms in the ontology and their logical consequences and/or to test con-
jectures.

6.2. Model outlines and the TBox

Model outlines have been originally designed to denote standalone concept descriptions, which means
that the atomic concepts and the role names that appear in the diagram are not constrained in any way
other than what is shown in the diagram itself. How-
ever, in real life, concept descriptions usually appear
in the context of a formal ontology, whose TBox axioms affect the interpretation of atomic concepts and
role names.

A simple example is the fact that a solid cluster labeled Class1 AND Class2  will denote nonexistent
individuals if the ontologys TBox contains the axiom

Class1 (cid:118)  Class2

which states that the atomic concepts Class1 and
Class2 are disjoint.

A slightly more complex situation is illustrated by
Figure 4, which seems to suggest that GradStudent
is a subclass of Student, but this type of knowledge
belongs in the TBox, and should not be conveyed by
a model outline! To be exact, the among which inner box in Figure 4 is only saying that if GradStudent
and Student are disjoint, then the GraduateCourses
at the root of the diagram can have no attendance.

This is a general phenomenon related to among
which inner boxes. A question that naturally arises,
then, is whether these inner boxes are really necessary
in the visual language.
sponds to the ALCN description

Consider the model outline in Figure 8. It corre-

Fig. 8. A model outline with an inner box

R.(A (cid:116) B) (cid:117) R.A (cid:117) R.B (cid:117) R.C

The modified model outline obtained by removing
the inner box and placing the cluster labeled C in the
main box, along with the clusters labeled A and B,
shown in Figure 9, corresponds to the ALCN descrip-
tion

R.(A (cid:116) B (cid:116) C) (cid:117) R.A (cid:117) R.B (cid:117) R.C

Fig. 9. A similar model outline, without the inner box

bility that individuals could appear at the same time as
instances of A (cid:116) B and of C.

7. Conclusions

It can be shown that these two descriptions are
equivalent if and only if the interpretation of C is contained in the interpretation of A (cid:116) B, but this containment is not the kind of information we have designed
model outlines to convey.

In the context of a model-outline-based tool used for
ontology browsing, one solution would be to invoke a
DL reasoner to check the consistency of each cluster
label and each box, using the knowledge present in the
TBox. Then the tool could somehow visually highlight
the inconsistent elements of the diagram, alerting the
user.

In the context of a model-outline-based visual query
language, it seems that among which inner boxes
can be eliminated without essentially compromising
the range of queries that can be formulated. This is because the user could build a query corresponding to
Figure 9 and be informed, in the results, of the possi-

The main achievements of the work related here
are the reformulation of our model outline visual language and its related algorithms, as well as the results
of our first usability test, comparing model outlines to
Manchester OWL.

Ontology visualization is a very active field of study.
The survey [15] discusses over 40 ontology visualization tools, all of them developed in the past 10 years.
All of those tools are general, in the sense that they
use one single visualization framework to show several
types of information about the ontology: the subsumption hierarchy, roles, etc. In particular, those tools show
concept descriptions either textually (e.g., Protege) or
in the form of abstract syntax trees (as in Figure 1 of
this paper).

Model outlines, on the other hand, are specialized,
having been designed specifically to show concept de-
scriptions. Although the notation used is new, our usability test indicates it is intuitive enough to be un-

F.N. do Amaral / Model Outlines: a Visual Language for DL Concept Descriptions

derstood by nonspecialists. The specialized nature of
model outlines suggests that they can be integrated
with a more general tool, so that users can easily
switch views, e.g., from the subsumption hierarchy as
a tree to the definition of a class as a model outline.

To summarize, this article has provided a precise,
updated presentation of our visual framework, with
rigorous definitions of the syntax and the semantics of
model outlines. Furthermore, the results of a carefully
conducted usability test indicate that our framework is
more useful in helping nonspecialist users understand
complex concept descriptions than a text-based notation (Manchester OWL).

We are currently implementing a concept description browser based on model outlines, as a Protege plu-
gin. We are taking special care to rely on graphical
conventions and interaction techniques that profit from
the vast body of knowledge related to visual perception
and cognitive principles, as described, e.g., in [18].

Work is also under way to extend model outlines to
the concept language of OWL 2 DL [13], based on the
following remarks:

 A nominal {a} is represented by a single diamond
(instead of a cluster) labeled a. This also applies to value restrictions such as R  a (or, in
Manchester OWL, R VALUE a);
 A negated nominal {a} is represented by a cluster labeled NOT a;
 A set {a1, . . . , an} is represented by a cluster labeled CONTAINED IN {a1, . . . , an};
 A negated set {a1, . . . , an} is represented by a
cluster labeled NONE OF {a1, . . . , an};
 Equivalences are used to convert conjunctions
and disjunctions of (possibly negated) nominals
or value restrictions into expressions using sets of
nominals. For example:

{a} (cid:116) {b}  {a, b}
{a} (cid:117) {b}  {a, b}
(R  a)  R.{a}

 Qualified number restrictions correspond to cardinality labels attached to clusters (while nonqualified number restrictions remain attached to
boxes);
 Local reflexivity (e.g., R.SELF) is represented
by an arrow from a cluster or a diamond to itself;

While these remarks are rather intuitive, there are
more difficult challenges in extending model outlines

to OWL 2 DL. Representing concrete domains is one.
Deciding how much information from the RBox we
can effectively represent in diagrammatic form is another (e.g., inverse roles, role chains). These are issues
still to be resolved.
