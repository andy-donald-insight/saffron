Optimizing Query Shortcuts in RDF Databases

Vicky Dritsou1,3, Panos Constantopoulos1,3,

Antonios Deligiannakis2,3, and Yannis Kotidis1,3

1 Athens University of Economics and Business, Athens, Greece

2 Technical University of Crete, Crete, Greece

3 Digital Curation Unit, IMIS, Athena Research Centre, Greece

{vdritsou,panosc,kotidis}@aueb.gr, adeli@softnet.tuc.gr

Abstract. The emergence of the Semantic Web has led to the creation of large
semantic knowledge bases, often in the form of RDF databases. Improving the
performance of RDF databases necessitates the development of specialized data
management techniques, such as the use of shortcuts in the place of path queries.
In this paper we deal with the problem of selecting the most beneficial shortcuts
that reduce the execution cost of path queries in RDF databases given a space
constraint. We first demonstrate that this problem is an instance of the quadratic
knapsack problem. Given the computational complexity of solving such prob-
lems, we then develop an alternative formulation based on a bi-criterion linear
relaxation, which essentially seeks to minimize a weighted sum of the query cost
and of the required space consumption. As we demonstrate in this paper, this
relaxation leads to very efficient classes of linear programming solutions. We
utilize this bi-criterion linear relaxation in an algorithm that selects a subset of
shortcuts to materialize. This shortcut selection algorithm is extensively evaluated and compared with a greedy algorithm that we developed in prior work. The
reported experiments show that the linear relaxation algorithm manages to significantly reduce the query execution times, while also outperforming the greedy
solution.

1 Introduction

The Semantic Web involves, among other things, the development of semantic repositories in which structured data is expressed in RDF(S) or OWL. The structure of this data -
and of its underlying ontologies - is commonly seen as a directed graph, with nodes
representing concepts and edges representing relationships between concepts. A basic
issue that semantic repositories need to address is the formulation of ontology-based
queries, often by repeatedly traversing particular paths [11] of large data graphs. Regardless of the specific model used to store these data graphs (RDF/OWL files, relational
databases, etc.), path expressions require substantial processing; for instance, when using relational databases, multiple join expressions are often involved [3,20,22,28].

By analogy to materialized views in relational databases, a shortcut construct can be
used in RDF repositories to achieve better performance in formulating and executing
frequent path queries. In this paper we elaborate on the creation of shortcuts that correspond to frequently accessed paths by augmenting the schema and the data graph of an

G. Antoniou et al. (Eds.): ESWC 2011, Part II, LNCS 6644, pp. 7792, 2011.
c Springer-Verlag Berlin Heidelberg 2011

V. Dritsou et al.

Institute

funds

Author

writes

Paper

acceptedBy

Conference

hasTitle

takesPlace

Title

City

Fig. 1. Sample Schema Graph

RDF repository with additional triples, effectively substituting the execution of the corresponding path queries. Considering all possible shortcuts in a large RDF repository
gives rise to an optimization problem in which we seek to select shortcuts that maximize
the reduction of query processing cost subject to a given space allocation for storing the
shortcuts. For this problem, which turns out to be a knapsack problem, known to be
NP-hard, we have previously developed a greedy algorithm [13] which, however, leans
on the side of wasting space whenever it comes to dealing with particular types of query
workloads, especially correlated ones. We thus consider an alternative formulation in
this paper, which leads to the development of a more efficient linear algorithm.

The contributions of this work are: (i) we elaborate on the notion of shortcuts and
the decomposition of a set of user queries that describe popular user requests into a
set of simple path expressions in the RDF schema graph of an RDF repository, which
are then combined in order to form a set of candidate shortcuts that can help during
the evaluation of the original queries; (ii) we formally define the shortcut selection
problem as one of maximizing the expected benefit of reducing query processing cost
by materializing shortcuts in the knowledge base, under a given space constraint; (iii)
we provide an alternative formulation of the shortcut selection problem that trades off
the benefit of a shortcut with the space required for storing its instances in the RDF
database: the constraint matrix of the resulting bi-criterion optimization problem enjoys
the property of total unimodularity, by virtue of which we obtain very efficient classes
of linear programming solutions; and (iv) through extensive experimental evaluation we
demonstrate that the linear algorithm outperforms our greedy solution in most cases.

2 Problem Formulation

In this section we provide the underlying concepts that are required in order to formulate
our problem. Sections 2.1 and 2.2 describe these preliminary concepts, which have been
introduced in [13].

q1

q2

Institute

funds

Author

writes

Paper

acceptedBy

Conference

hasTitle

Title

Institute

funds

Author

writes

Paper

acceptedBy

Conference

takesPlace

City

q3

Paper

acceptedBy

Conference

hasTitle

Title

Fig. 2. Sample Queries
?

?

?
sh4

sh3

sh1

Institute

funds

Author

writes

Paper

acceptedBy

Conference

hasTitle

sh5

sh2

takesPlace

sh6

Title

City

qf1

qf3

qf5

GQ1

qf4

Fig. 3. Candidate Shortcuts

Fig. 4. Graph GQ1

2.1 Preliminary Concepts

Assume an RDF database G containing two parts: (i) a schema graph, GS(VS, ES),
where VS is a set of nodes that represent entity classes (or, concepts) and a set of edges
ES, representing relationship classes (or, properties); and (ii) a data graph, GD(VD, ED),
consisting of a set of nodes, VD, that are instances of nodes in VS and a set of edges, ED,
that are instances of edges in ES. More generally, G could be any graph-structured semantic database. A sample schema graph of an RDF database is presented in Figure 1.
Assume now a query workload Q = {q1, q2, q3, . . . , qm} of m queries. Each qi is associated with a frequency fi and comprises a data-level query (querying the schema graph
is out of scope in this paper). Moreover, it is represented as a weakly connected subgraph
Gq of the schema graph GS. For example, consider the schema graph of Figure 1 and the
three related queries: q1: For each institute, find the titles of the conferences in which
the papers of the authors it funds have been accepted; q2: For each institute, find the
cities where the conferences in which the papers of the authors it funds have been accepted are taking place; and q3: For each paper, find the title of the conference in which
it has been accepted. The subgraphs of these queries are shown in Figure 2. Regardless
of the query language used, to evaluate the queries and retrieve their matching instances
we need to traverse the corresponding paths.

In this paper we deal only with path queries, like the three examples presented above.
More complex queries can also be formulated, requiring more than one paths in order to
be expressed, e.g. in our sample graph a query that relates Institutes with conference
T itles together with the City each one is located. Although this query cannot be part
of our assumed workload, we can retrieve its matching instances by joining the results
of the path queries it contains (namely q1 and q2).
Query fragments and candidate shortcuts. Each path query qi in Q has a length li
expressing the number of relationships its path contains. We call query fragment any
subpath containing more than one edge. In our framework, a shortcut matches exactly one
such query fragment. Given a query workload Q, containing|Q| queries, and L the length
of the query having the longest path among all queries in Q, there are O(|Q| L2) query
fragments (and shortcuts). This large number is reduced when we define as candidate
shortcuts only those that originate from or terminate to nodes that we consider to be
interesting: a node u  GS is considered to be a candidate shortcut node iff (i) u is a
starting node or an ending node of a query q  Q; or (ii) u is a starting node or an ending
node of two different edges ei, ej of GS, each being traversed by at least one query q  Q.
Having defined the set of candidate nodes, we develop the set SH of candidate shortcuts
by considering all valid combinations between candidate shortcut nodes, so that these
are connected through an existing path of GS and this path is traversed by at least one
?

?

?
query q  Q. For example, consider again the sample graph of Figure 1 and the queries
of Figure 2 constituting the workload Q. Given Q, the candidate shortcut nodes are: (i)
Institute, as starting node of q1 and q2; (ii) Paper, as starting node of q3; (iii) Conference,
since two edges belonging to two different queries originate from it; (iv) Title, as ending
node of q1 and q3; and (v) City, as ending node of q2. Starting from these, we generate
the set of candidate shortcuts presented in Figure 31.

Each candidate shortcut shi maps to exactly one query fragment qfi, which may be
contained in more than one queries of Q. The set of queries in which qfi is contained
is called related queries of shi and is denoted as RQi. For instance, the set of related
queries of sh4 in Figure 3 is RQ4 = {q1, q2}. Regarding the relationships between
shortcuts, we distinguish the following three cases: (i) a shortcut shi is disjoint to shj
if the query fragments they map to do not share any common edge; (ii) a shortcut shi
is fully contained in shj iff the query fragment that shi maps to is a subpath of the
corresponding query fragment of shj, denoted hereafter as shi  shj; and (iii) a shortcut shi overlaps shj if they are not disjoint, and none of them fully contains the other.
Finally, for each shortcut shi we denote the set SFi = {qfj | qfj  qfi}.

2.2 Estimating Shortcut Benefit

We now turn to defining the benefit of introducing a shortcut and formulating shortcut
selection as a benefit maximization problem. Assume a candidate shortcut shi with underlying query fragment qfi and its set of related queries RQi. An estimate of the cost
of retrieving the answer to qfi may be given by (i) the number of edges that need to be
traversed in the data graph GD; (ii) the actual query time of qfi; (iii) an estimate by a
query optimizer. For the formulation of our problem we assume that this cost is given
by the number of edges, tri, that need to be traversed in the data graph GD (however
in Section 4 we present a comparison of the results obtained when considering as cost
the number of traversals on one hand and the actual query times on the other). Note
that not all edges traversed necessarily lead to an answer, however they do contribute
to the counting of tri. Now suppose that we augment the database by shortcut shi.
This involves inserting one edge in the schema graph GS, while in the data graph GD
one edge is inserted for each result of qfi, a total of ri edges between the corresponding nodes. Hence, by inserting one instance of shi for each result of qfi using RDF
Bags2, thus allowing duplicate instances of shortcuts (triples) to be inserted, we retain
the result cardinalities and obtain exactly the same query results. Then the new cost of
answering qfi is equal to the new number of traversals required, i.e. the number ri of
results of qfi. Therefore, the benefit obtained by introducing a shortcut shi in order
to answer qfi is equal to the difference between the initial cost minus the new cost,
tri  ri. Since qfi is used in answering each of its related queries, the benefit for query
qk  RQi can be estimated by multiplying the fragment benefit by the frequency of the
query, i.e. fk(tri  ri). The total benefit obtained by introducing shortcut shi is then
equal to the sum of the benefits obtained for each related query. If the query fragments

1 Due to readability issues, the number contained in the label of shortcuts is not presented in the

figure as subscript.

2 http://www.w3.org/TR/rdf-schema/
?

?

?
underlying the candidate shortcuts are disjoint then the aggregate benefit is the sum of
the benefits of all candidate shortcuts. If, however, there are containment relationships
between fragments, things get more complicated. For example, take the above mentioned queries q1 and q3 described in Figure 2. According to the definition of candidate
shortcuts, there are four candidates beneficial for these queries, namely sh1, sh3, sh4
and sh5. Assume now that shortcut sh5 has been implemented first and that adding sh1
is being considered. The benefit of adding sh1 with regard to query q1 will be smaller
than what it would have been without sh5 in place. Indeed, sh1 is not going to elim-
f unds Author
inate the traversals initially required for the fragment qf1 = Institute
acceptedBy Conf erence hasT itle T itle but, rather, the traversals of edges
writes P aper
of type sh5. We denote as dij the difference in the number of traversals required to
answer qfi due to the existence of a shortcut induced by qfj. This difference is positive
for all qfj  qfi, i.e. for each qfj  SFi. Finally, shortcuts induced by overlapping
query fragments do not interfere in the above sense: since the starting node of one of
them is internal to the other, they cannot have common related queries.

Let us now turn to the space consumption of shortcuts. Regardless of how many
queries are related to a query fragment qfi, the space consumption that results from
introducing the corresponding shortcut shi is ri as above. The total space consumption
of all shortcuts actually introduced should not exceed some given space budget b.

2.3 Space-Constrained Benefit Maximization

|

We are now ready to formulate the problem of selecting beneficial shortcuts as a benefit
maximization problem. Assume an RDF graph G, a finite set of m path queries Q =
{qi
i =
1, . . . , n} of n query fragments, n  m, n  N deriving from the set Q and a space
budget b > 0. Our problem is then defined as:

i = 1, . . . , m}, m  N, each with a frequency fi, a set QF = {qfi

|

{fk(tri  ri)xi  fk

dij xixj}
?

?

?
qfjSFi

n
?

?

?
max

qkRQi

i=1
?

?

?
n

i=1

rixi  b

subject to
?

?

?
if shortcut shi is established
xi =
otherwise
SFi = {qfj | qfj  qfi, qfj  QF}
RQi = {qj | qfi  qj, qj  Q}.

This is a 0-1 quadratic knapsack problem, known to be NP-hard [15]. Several systematic and heuristic methods have been proposed in the literature [27] to obtain approximate solutions to this problem. All computationally reasonable methods assume
non-negative terms in the objective function. This is obviously not the case of our prob-
lem, since the reductions dij of the traversals are non-negative integers thus resulting in
non-positive quadratic terms.

V. Dritsou et al.

To address this problem, we have previously developed a greedy algorithm [13] that
seeks to maximize the overall benefit by selecting a subset of candidate shortcuts to
materialize given a space budget. The algorithm takes as input the schema and data
graph, together with the query workload, finds the candidate shortcuts and then computes the benefit of each one, considering as cost the number of edge traversals. It then
incrementally selects the candidate with the maximum per-unit of space benefit that fits
into the remaining budget, until it reaches the defined space consumption. This algorithm succeeds in identifying beneficial shortcuts, yet it wastes space, especially when
the queries of the workload are correlated. This led us to consider an alternative formulation and develop a new algorithm, as described in the following Section. A detailed
comparison of the two approaches is presented in Section 4.

3 Bi-criterion Optimization

One established class of solution methods for the 0-1 quadratic knapsack problem are
Lagrangean methods, including the traditional Lagrangean relaxation of the capacity
constraint and a more sophisticated variant, Lagrangean decomposition [8,10,25,27].
As explained in Section 2, such techniques are inapplicable to our problem, due to
the negative quadratic terms in the objective function. However, the techniques cited
above, provided the inspiration for an alternative modelling approach that would avoid
the combined presence of binary decision variables and a capacity constraint.

Instead of stating a space constraint, we employ a cost term for space consumption
in the objective function. This means that the utility of each calculated solution will, on
one hand, increase based on the benefit of the selected shortcuts but, on the other hand,
it will decrease proportionally to the solutions space consumption. The factor that determines the exact penalty incurred in our objective function per space unit significantly
influences the final space required by the solution of our algorithm. A small penalty per
space unit used typically leads to solutions that select many shortcuts, thus consuming a
lot of space. On the contrary, a large penalty per space unit used typically leads to selecting fewer shortcuts of high benefit for materialization. As we describe at the end of this
section, a binary search process will help determine the right value of this parameter,
so as to select a solution that respects a space budget. Unlike Lagrangean methods that
penalize consumption in excess of the budget, in our formulation space consumption is
penalized from the first byte. As explained below, this formulation yields an efficiently
solvable linear program.

We will now describe how the constraints are derived for three important cases:
 Specifying that a candidate shortcut may be useful (or not) for evaluating specific

queries that contain its corresponding query fragment.

 Specifying how to prevent containment relations for the same query. For the same
query, whenever we consider two materialized shortcuts such that one fully contains the other, then only one of them can be used for the evaluation of the query.3
Expressing such constraints is crucial for the quality of the obtained solution. The

3 In this case, it is not true that the larger of the two shortcuts will always be used, as the presence
of additional materialized shortcuts for the same query may result in utilizing the smaller one.
?

?

?
greedy algorithm may select a smaller shortcut for materialization, and then select
a shortcut that fully contains the first one.

 Specifying that two overlapping shortcuts (but none of them is fully contained in

the other) cannot be useful at the same time for the same query.

In the model of Section 2, the resource-oriented treatment of space employs the space
budget as a parameter for controlling system behavior. In the alternative, price-oriented
model presented in this section, a price coefficient on space consumption is the control
parameter. A small price on space consumption has an analogous effect to setting a high
space budget. By iteratively solving the price-oriented model over a range of prices we
effectively determine pairs of space consumption and corresponding solutions (sets of
shortcuts). So, both the resource-oriented and the price-oriented approach yield shortcut
selection policies the outcomes of which will be compared in terms of query evaluation
cost and space consumption in Section 4.

Another important feature of the alternative model is the explicit representation of the
usage of shortcuts in evaluating queries. In the model of Section 2, decision variables xi
express whether shortcut shi is inserted or not. The actual usage of selected shortcuts
regarding each query is not captured by these variables. In fact, the set of shortcuts that
serve a given query in an optimal solution as determined by the greedy algorithm has
no containment relationships among shortcuts and no overlapping shortcuts. Of course,
containment and overlapping can occur between shortcuts serving different queries.
For example, consider again the queries q1, q2 and q3 mentioned above. The greedy
algorithm will not propose to use both shortcuts sh1 and sh3, which have a containment
relationship, to serve q1. Even if sh3 is selected in one step and sh1 in a subsequent step,
only sh1 will finally be used for the execution of q1. Similarly, sh5 and sh3 will not
be proposed by greedy for q1, since their query fragments overlap. If we use sh5 then
acceptedBy Conf erence will be
the part of q1 that corresponds to the subgraph P aper
hidden under the new edge sh5 and therefore shortcut sh3 cannot be applied.
Specifying that a shortcut is useful for a specific query. We introduce additional
decision variables that express the usage of a given shortcut to serve a given query. In
particular, xik denotes whether shortcut shi is useful for the query qk, where xik =
{0, 1} and qk  RQi.

The xik variables depend on each other and on xi in various ways. Note that if a
shortcut shi is selected to serve any query qk (specified by xik = 1), then this shortcut
is also selected by our algorithm for materialization (specified by xi = 1). Thus:

i = 1, ..., n; k  RQi
xik  xi,
?

?

?
i = 1, ..., n

(1)

(2)

Moreover, if a shortcut has been selected for materialization, then this shortcut is useful
for at least one query. Thus:

xi 

xik,

kRQi

Avoiding containment. For each query qk we construct an auxiliary directed graph
GQk as follows: The nodes of GQk represent the query fragments related to qk. If (i)
a query fragment qfi is fully contained in another fragment qfj, and (ii) there does not

V. Dritsou et al.

exist any qfk (k = i, j) such that qfi  qfk and qfk  qfj, then an edge is inserted in
GQk starting from the bigger fragment qfj and ending at the smaller fragment qfi. Note
that we connect each such node with its children only and not with all of its descendants.
An example illustrating such a graph is shown in Figure 4, where the graph of query q1
is presented. This graph is constructed with the help of Figure 3, and by recalling that
each candidate shortcut shi matches the query fragment qfi.

Using GQk we generate the containment constraints by the following procedure:

2. For each path pk
t

1 = {qf1, qf3} and p1

qk, find all possible paths pk
no outgoing edges) and store them in a set of paths P k.

1. For each root node of the graph (i.e., each node with no incoming edges) of query
t leading to leaf nodes of the graph (i.e., to nodes with
 P k, create a containment constraint by restricting the sum of
all variables xik whose fragment is present in the path to be less than or equal to 1.
The second step enforces that among all the candidate shortcuts participating in each
path pk
t , at most one can be selected. Continuing our previous example based on Fig-
2 =
ure 4, there exist two paths in P 1 for query q1, namely p1
{qf1, qf5, qf4}. These paths generate two containment constraints, namely x11+x31 
1 and x11 + x51 + x41  1.
Avoiding overlaps. Overlapping candidates are treated in a similar way. In graph GQk
we compare each node with all other nodes on different paths of the graph. For each
pair of compared nodes, if the corresponding query fragments of the nodes under comparison have edges in common, then we insert this pair of nodes in a set OFk which
stores the pairs of overlapping fragments with respect to query qk. For each pair in
OFk we create a constraint specifying that the sum of its decision variables be less
than or equal to 1, indicating that only one of the candidate shortcuts in the pair can be
selected to serve the query qk. In the previous example of query q1, we would check
the two pairs (qf5, qf3) and (qf4, qf3). Only the first of these pairs contains fragments
acceptedBy
that have edges in common, as qf5 and qf3 both contain the edge P aper
Conf erence. In order to specify that the shortcuts of these two query fragments cannot be useful for the same query q1, we generate the constraint: x51 + x31  1.

In conclusion, given a parameter c (called price coefficient) that specifies the per
space penalty of the chosen solution, we obtain the following bi-criterion 0-1 integer
linear programming formulation for the shortcut selection problem:

n
?

?

?
max

qkRQi

i=1

fk(tri  ri)xik  c

n

rixi

i=1

subject to

i = 1, ..., n; k  RQi
?

?

?
xik  xi  0,

?

?

?
ipk

u

xik + xi  0,

i = 1, ..., n

kRQi
xik  1, k = 1, ..., m; pk

u

 P k

(3)

(4)

(5)

(6)
?

?

?
xik + xjk  1, k = 1, ..., m; (qfi, qfj)  OFk
if shortcut shi is selected for query qk
otherwise
?

?

?
xik =

xi  {0, 1}

(7)

3.1 Linear Relaxation

In the general case (i.e., unless particular conditions are satisfied), integer linear programs are NP-hard. In our problem though, a particular linear relaxation allows us to
obtain fast solutions. Constraint (5) ensures that if all xik = 0, then also xi = 0. If we
remove this constraint, then it is possible to have xi = 1 (i.e., to consume space) without using the shortcut in any query qk. However, since this is a maximization problem
and xi has a negative coefficient in the objective function (3), a solution with xi = 1
and all corresponding xik = 0 can be improved by setting xi = 0. We can therefore
drop the constraint from the problem, since it is never violated by optimal solutions.

For a reason that will shortly become clear, we also drop the overlap constraint(7).
Contrary to constraint (5), this one can be violated by an optimal solution of the linear
program. Then, a cutting plane method is used to restore feasibility with two alternative
heuristics for cut selection, that will be presented in the sequel.

Consider now a relaxed linear program comprising the remaining constraints and

with the 0-1 variables replaced by real variables in the interval [0, 1]:

n
?

?

?
max

fk(tri  ri)xik  c

n

rixi

i=1

subject to

i=1

qkRQi
xik  xi  0,
?

?

?
i = 1, ..., n; k  RQi
 P k

xik  1, k = 1, ..., m; pk

u

ipk

u

0  xik  1, 0  xi  1

(8)

(9)

(10)

The constraint matrix of the above linear program can be proven to fulfill the sufficient conditions of total unimodularity given in [31]. The proof is omitted due to space
limitations. By virtue of this property, the linear program is guaranteed to have integer
solutions (thus each xik and xi will either be equal 0 or 1). Furthermore, the relaxation enables much more efficient solution since the empirical average performance of
simplex-based linear program solvers is polynomial, in fact almost linear [4,7].

Satisfying the overlap constraints. The solution of the relaxed problem may violate
constraint (9) that we have ignored in the relaxation. Here we propose a cutting plane
method with two alternative heuristics for restoring constraint satisfaction. After solving the relaxed problem, we check whether the solution violates any of the omitted
overlap constraints. Recall that these constraints contain two variables (representing

V. Dritsou et al.

two shortcuts used for the same query) that are not both allowed to be equal to 1. For
each such violation we set the value of one of the variables equal to 0 (i.e., we exclude
the respective shortcut) and insert this as an additional constraint into the initial prob-
lem. It can be proven that adding such constraints in the problem does not affect total
unimodularity. The problem is solved again and new cuts are introduced as needed until
we reach a solution that does not violate any overlap constraint.

But how do we choose which of the two variables to set equal to zero? We explore
two alternative heuristics. The first heuristic (LRb) selects to prohibit the shortcut with
the smallest benefit for the given query qk. The second heuristic (LRl) chooses to prohibit the shortcut with the shortest corresponding query fragment. Both heuristics have
been developed in evaluation tests and are discussed in Section 4.

Selecting the Value of the Price Coefficient c. In order to find a solution that is appropriate for a given space budget, we perform a binary search on the value of c. Both
linear algorithms (i.e., heuristics) developed here take as input the space budget and
then create linear models based on different values of c until they reach a solution the
space consumption of which is close to (or, even better, equal to) the given budget.

4 Evaluation

In this section we present an experimental study of the two variations of the linear
algorithm. We implemented LRb and LRl in C++ and compared their results with our
previously developed greedy algorithm (GR) described in [13]. Our goal is to evaluate
the reduction in query costs w.r.t. different RDF stores and data sets, to compare the
performance of LRb/LRl with GR in general and more specifically to check whether
LRb/LRl can capture the dependencies produced by strongly correlated workloads in
a more effective way than GR. By strongly correlated we mean workloads containing
path queries with containment relationships among the majority of them. In this spirit,
we report on the reduction of the total execution time of the given query workloads
after augmenting the database by the proposed shortcuts, vis-a-vis the allocated space
budget. We used four different systems for our experiments, each of them following
a different type of RDF store approach: (i) the SWKM4 management system, which
relies on a relational DBMS, (ii) the native Sesame5 repository, (iii) the in-memory
Sesame repository and (iv) the native RDF3X6 system. In the following experiments,
unless otherwise stated, we present in the graphs the percentage of reduction achieved
in the query time of the entire workload after augmenting the system by the proposed
shortcuts (y-axis) with regard to the space consumed for this augmentation, expressed
as a fraction of the database size (x-axis). All reported experiments were executed on
a Intel Core 2 Duo 2.33GHz PC with 4GB RAM running 32bit Windows Vista. In the
reported experiments we used Lingo 9.07 as linear solver for LRb and LRl.

Before discussing the results obtained with strongly correlated queries, we examine
the dependence of performance on the query cost metrics used. Recall from Section 2.2

4 Available at http://139.91.183.30:9090/SWKM/
5 Available at http://www.openrdf.org/
6 Available at http://www.mpi-inf.mpg.de/ neumann/rdf3x/
7 LINDO Systems, http://www.lindo.com
?

?

?
)
c
e
s
(
 
e
m
m

i

i
t
 
g
n
n
n
n
u
r

t

Input cost: actual times [LR]

Input cost: actual times [GR]
[GR]
Input cost: traversals [LR]
Input cost: traversals [GR]

l ti

t

t

% of data space consumed

% of data space consumed

e
m

i
t
 
y
r
e
u
q
n

 

i
 

n
o

i
t
c
u
d
e
e
r
 
f

 

o
%

Fig. 5. Yago in Sesame Native

Fig. 6. Running Times of Algorithms

LRl[Sesame]
LRl[RDF3X]

LRb[Sesame]
LRb[RDF3X]

GR[Sesame]
GR[RDF3X]
?

?

?
e
m

i
t

y
r
e
u
u
q
n
?

?

?
i
?

?

?
n
o
i
t
c
c
u
d
e
r
?

?

?
%

%ofdataspaceconsumed

Fig. 7. Experiment with Correlated Queries

that computing the benefit of candidate shortcuts requires a cost metric of the query
fragments. Our theoretical formulation employs the number of traversals required to
answer the query, while the actual query times must also be considered. In [13] we have
shown that both cost metrics give qualitatively similar results for the greedy algorithm.
To confirm that this stands true for LRb/LRl too, we used the Yago data set [34] that
contains 1.62 million real data triples. We considered as query workload the 233 distinct
query paths of length 3 contained in the schema graph of Yago and used as RDF store
the Sesame native repository. In Figure 5 we present the percentage of reduction in
query time achieved for the entire workload (y-axis) after augmenting the system by
the selected shortcuts w.r.t. the fraction of data space required to be consumed by the
shortcut edges. In this experiment LRb and LRl give the same solutions, due to the
small length of queries (presented as LR in Figure 5).

It is obvious that our approach significantly reduces the overall query execution time
without consuming large amounts of space. Moreover, LR achieves a bigger reduction
compared to greedy (GR): when using traversals as cost metric, LR reduces the query
time by 55% by consuming only 6% of the data space, while GR reaches a reduction
of 33% for the same consumption. LR reaches the maximum reduction of 86% of the
initial query time with GR stopping at a maximum reduction of 66%. The reported
results confirm that the two cost metrics used give qualitatively similar results. We

V. Dritsou et al.

Table 1. Relative Improvement of Query Times in Sesame (over Greedy)

tGR

Space tGRtLRb
2.5% 2%
5.0% 32%
7.5% 32%
10.0% 33%
12.5% 36%
15.0% 49%
17.5% 61%

tGRtLRl

tGR

5%
34%
34%
40%
42%
52%
83%

will therefore continue in the following experiments by considering the traversals as
input cost metric for our algorithms. Regarding the running times of the algorithms,
we present in Figure 6 the time in seconds required by each algorithm to choose the
appropriate shortcuts for the experiment described with the Yago data set. The graph
shows the running time of the algorithms for each given budget. GR runs faster than
LR in all cases, since LR must iterate through the binary search, with LR being from 2
to 13 seconds slower. On the other hand, running times are a secondary consideration,
since shortcut selection is an offline procedure.

To evaluate the performance of the algorithms with strongly correlated queries, we
generated a synthetic schema graph comprising 143 nodes and 117 edges and then used
a Perl script to generate synthetic data. This script randomly picks a schema node at
the beginning and generates one data node from it. It then produces all the data edges
emanating from the latter according to the schema graph. This process is repeated on
the newly created ending data nodes of the produced edges. A parameter p defining
the probability of breaking a path (stop following the edges of the current node and
continue with a new one) is also used, which in this experiment is set to 0.4. The data
set generated for this experiment contains 1 million triples. For the correlated workload
we used 31 path queries of length from 5 to 15 with 29 of them being fully contained
in at least one other query of the workload; the smallest having length equal to 5 are
fully contained in 10 longer queries. We used Sesame native repository and RDF3X
for this experiment and the results obtained are presented in Figure 7. All algorithms
show significant reduction in query time: by consuming just 2.5% of the data space
they all reduce the query time by 65% in Sesame, while in RDF3X they all reach a
reduction of 43% for the same space consumption. Moreover, LRb and LRl show much
better results than GR in Sesame, while in RDF3X LRl outperforms the two remaining
algorithms. We can thus confirm that the linear approach, and mostly LRl, captures the
dependencies that exist in correlated workloads in a more effective way: LRl manages to
reduce the query time by 96% when consuming only 17.5% of the data space in Sesame,
while for the same consumption it achieves a reduction of 68% in RDF3X. Table 1
shows the relative improvement in query time reduction achieved in Sesame by the two
variants of LR over GR for various space budgets. Both LRb and LRl show better results
in most cases (LRb is by 2% worse than GR in one case of very small budget), while
LRl yields 83% more efficient shortcuts than GR for the maximum budget.
?

?

?
LRl[Sesame]
LRl[SWKM]

LRb[Sesame]
LRb[SWKM]

GR[Sesame]
GR[SWKM]

e
m

i
t

y
r
e
u
u
q
n
?

?

?
i
?

?

?
n
o
i
t
c
u
d
e
r

f
o
%
?

?

?
LRb[Sesame]
LRb[RDF3X]

LRl[Sesame]
LRl[RDF3X]

GR[Sesame]
GR[RDF3X]
?

?

?
e
e
m

i
t

y
r
e
u
q
q
n
?

?

?
i
?

?

?
n
o
i
t
c
u
u
d
e
r

f
o
%
?

?

?
%ofdataspaceconsumption
?

?

?
%ofdataspaceconsumption

Fig. 8. Experiment with CIDOC Ontology

Fig. 9. Using Long Path Queries

In Figure 8 we present the results obtained by a different type of ontology, namely
the CIDOC CRM8, which is characterized by a schema graph forming a constella-
tion graph structure with non-uniform density. This contains a small number of star
nodes, each connected with a large number of planet nodes and sparsely connected
with other star nodes. Our goal here is to evaluate the performance of LR algorithms
with these schema graphs. We generated 1 million synthetic triples with the aforementioned Perl script and used as query workload 65 queries of length 2 to 4. We tested the
algorithms using both the Sesame in-memory repository and the SWKM system. The
reduction achieved is much bigger with Sesame than SWKM. Moreover, LRb and LRl
perform better than GR when using Sesame, while this is not the case with SWKM:
although in the majority of cases the three algorithms show similar results, in 3 cases
GR achieves a bigger reduction by 5  7%.

To examine the performance of the algorithms with longer path queries, we generated
a synthetic schema graph containing 189 nodes and 467 edges and populated it using
the Perl script with 4 million of synthetic triples. The query workload here comprises
26 queries with length from 10 to 15. For this experiment we used the Sesame native
repository and RDF3X, and obtained the results presented in Figure 9. The reduction
achieved in both systems is similar in this case: all algorithms achieve a reduction of
at least 40% by consuming only 5% of the data space. Moreover, LRb and LRl still
give better results when compared to GR. E.g., for the maximum budget given in the
experiment, the execution of the workload after augmenting the RDF3X system by the
shortcuts proposed by LRl is by 39% faster than after inserting those proposed by GR.

5 Related Work

The emerging Semantic Web necessitates the development of methods to efficiently
manage semantic data, often expressed in OWL and/or RDF. To this end, a variety
of systems have been developed to handle RDF data including, among others, Jena9,
Sesame, RDF3X, SWKM. For the efficient querying of semantic data, several RDF

8 Available at http://www.cidoc-crm.org/rdfs/cidoc crm v5.0.2 english label.rdfs
9 Available at http://jena.sourceforge.net/

V. Dritsou et al.

languages have been proposed, with SPARQL [2], RQL [19] and RDQL [1] standing
as main representatives.

In the relational world, views have long been explored in database management systems [30], either as pure programs [32,33], derived data that can be further queried [23],
pure data (detached from the view query) or pure index [29]. The selection of shortcuts
in RDF databases is similar to materialized views in relational systems, which has long
been studied: selecting and materializing a proper set of views with respect to the query
workload and the available system resources optimizes frequent computations [18,21].
Moreover, restricting the solution space into a set of views with containment properties
has been proposed in the Data Cube [16] framework.

Indexing RDF data is similar in concept (due to the hierarchical nature of path
queries) to indexing data in object oriented (OO) and XML Databases. An overview
of indexing techniques for OO databases is presented in [5]. In [17] a uniform indexing scheme, termed U-index, for OO databases is presented, while in [6] the authors
present techniques for selecting the optimal index configuration in OO databases when
only a single path is considered and without taking into account overlaps of subpaths.
The work of [12] targets building indices over XML data. Unlike XML data, RDF data
is not rooted at a single node. Moreover, the above techniques target the creation of
indices over paths, thus not tackling the problem of this paper, which is the selection of
shortcuts to materialize given a workload of overlapping queries.

Following the experience from relational databases, indexing techniques for RDF
databases have already been explored [14,24,35]. A technique for selecting which (out
of all available) indices can help accelerate a given SPARQL query is proposed in [9].
In [3] the authors propose a vertically partitioned approach to storing RDF triples and
consider materialized path expression joins for improving performance. While their approach is similar in spirit to the notion of shortcuts we introduce, the path expression
joins they consider are hand-crafted (thus, there is no automated way to generate them in
an arbitrary graph). Moreover the proposed solutions are tailored to relational backends
(and more precisely column stores), while in our work we do not assume a particular
storage model for the RDF database. Our technique can be applied in conjunction with
these approaches to accelerate query processing, since it targets the problem of determining the proper set of shortcuts to materialize without assuming a particular RDF
storage model. In [26] the authors propose a novel architecture for indexing and querying RDF data. While their system (RDF3X) efficiently handles large data sets using
indices and optimizes the execution cost of small path queries, our evaluation shows
that our technique further reduces the execution cost of long path queries in RDF3X.

6 Conclusions

Shortcuts are introduced as a device for facilitating the expression and accelerating the
execution of frequent RDF path queries, much like materialized database views, but
with distinctive traits and novel features. Shortcut selection is initially formulated as
a benefit maximization problem under a space budget constraint. In order to overcome
the shortcomings of a previous greedy algorithm solution to this problem, we developed
an alternative bi-criterion optimization model and a linear solution method.
?

?

?
We have shown through an extensive experimental study that the augmentation of
RDF databases with shortcuts reduces significantly the query time of the workload,
while in the majority of cases the two variations of our algorithm outperform our previous greedy solution. This reduction was obtained using different types of RDF stores,
uniform and non-uniform schema graphs, real as well as synthetic ontologies, different
database sizes and different types of query workloads. In the case of strongly correlated
query workloads, where the greedy solution tends to waste space, we have seen that
our two variations (LRl and LRb) better capture the dependencies among queries and
achieve a bigger reduction in query execution time.
