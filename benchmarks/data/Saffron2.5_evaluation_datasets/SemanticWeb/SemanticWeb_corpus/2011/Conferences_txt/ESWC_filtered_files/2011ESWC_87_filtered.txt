Query Relaxation for Entity-Relationship Search

Shady Elbassuoni, Maya Ramanath, and Gerhard Weikum

Max-Planck Institute for Informatics

{elbass,ramanath,weikum}@mpii.de

Abstract. Entity-relationship-structured data is becoming more important on the
Web. For example, large knowledge bases have been automatically constructed
by information extraction from Wikipedia and other Web sources. Entities and
relationships can be represented by subject-property-object triples in the RDF
model, and can then be precisely searched by structured query languages like
SPARQL. Because of their Boolean-match semantics, such queries often return
too few or even no results. To improve recall, it is thus desirable to support users
by automatically relaxing or reformulating queries in such a way that the intention of the original user query is preserved while returning a sufficient number of
ranked results.

In this paper we describe comprehensive methods to relax SPARQL-like triplepattern queries in a fully automated manner. Our framework produces a set of
relaxations by means of statistical language models for structured RDF data and
queries. The query processing algorithms merge the results of different relaxations into a unified result list, with ranking based on any ranking function for
structured queries over RDF-data. Our experimental evaluation, with two different datasets about movies and books, shows the effectiveness of the automatically
generated relaxations and the improved quality of query results based on assessments collected on the Amazon Mechanical Turk platform.

1 Introduction

1.1 Motivation

There is a trend towards viewing Web or digital-library information in an entity-centric
manner: what is the relevant information about a given sports club, a movie star, a politi-
cian, a company, a city, a poem, etc. Moreover, when querying the Web, news, or blogs,
we like the search results to be organized on a per-entity basis. Prominent examples of
this kind of search are entitycube.research.microsoft.com or google.com/squared/. Ad-
ditionally, services that contribute towards more semantic search are large knowledge
repositories, including both handcrafted ones such as freebase.com as well as automatically constructed ones such as trueknowledge.com or dbpedia.org. These have been
enabled by knowledge-sharing communities such as Wikipedia and by advances in information extraction (e.g., [2, 6, 17, 23, 20]).

One way of representing entity-centric information, along with structured relationships between entities, is the Semantic-Web data model RDF. An RDF collection consists of a set of subject-property-object (SPO) triples. Each triple is a pair of entities
with a named relationship. A small example about books is shown in Table 1.

G. Antoniou et al. (Eds.): ESWC 2011, Part II, LNCS 6644, pp. 6276, 2011.
c Springer-Verlag Berlin Heidelberg 2011
?

?

?
Table 1. RDF triples

Property (P) Object (O)
Subject (S)
wrote
Carl Sagan
type
Carl Sagan
type
Carl Sagan
bornIn
Carl Sagan
wonAward
Carl Sagan
type
Contact
hasGenre
Contact
hasTag
Contact
Contact
hasTag
Jon Krakauer wrote
Into the Wild type
Into the Wild hasTag
Into the Wild hasTag
Jon Krakauer hasBestseller Into Thin Air
Jon Krakauer citizenOf

Contact
American Writer
Astronomer

Pulitzer Prize
novel
Science Fiction
aliens
philosopy
Into the Wild
biography
adventure
wilderness

RDF data of this kind can be queried using a conjunction of triple patterns  the
core of SPARQL  where a triple pattern is a triple with variables and the same variable
in different patterns denotes a join condition. For example, searching for Pulitzer-prize
winning science fiction authors from the USA could be phrased as:

?a wrote ?b ; ?b hasGenre Science Fiction ;
?a wonAward Pulitzer Prize ; ?a bornIn USA

This query contains a conjunction (denoted by ;) of four triple patterns where ?a

and ?b denote variables that should match authors and their books respectively.

While the use of triple patterns enables users to formulate their queries in a precise
manner, it is possible that the queries are overly constrained and lead to unsatisfactory
recall. For example, this query would return very few results even on large book collec-
tions, and only one - Carl Sagan - for our example data. However, if the system were
able to automatically reformulate one or more conditions in the query, say, replacing
bornIn with citizenOf, the system would potentially return a larger number of results.

1.2 Query Relaxation Problem

This paper addresses the query relaxation problem: automatically broadening or reformulating triple-pattern queries to retrieve more results without unduly sacrificing preci-
sion. We can view this problem as the entity-relationship-oriented counterpart of query
expansion in the traditional keyword-search setting. Automatically expanding queries
in a robust way so that they would not suffer from topic drifts (e.g., overly broad gener-
alizations) is a difficult problem [3].

The problem of query relaxation for triple-pattern queries has been considered in limited form in [22, 11, 7, 10] and our previous work [8]. Each of these prior approaches

S. Elbassuoni, M. Ramanath, and G. Weikum

focused on very specific aspects of the problem, and only two of them [22, 8] conducted experimental studies on the effectiveness of their proposals. These techniques
are discussed in more detail in Sect. 5.

1.3 Our Approach

This paper develops a comprehensive set of query relaxation techniques, where the
relaxation candidates can be derived from both the RDF data itself as well as from
external ontological and textual sources. Our framework is based on statistical language
models (LMs) and provides a principled basis for generating relaxed query candidates.
Moreover, we develop a model for holistically ranking results of both the original query
and different relaxations into a unified result list.

Our query relaxation framework consists of the following three types of relaxations:

 Entities (subject, object) and relations (property) specified in a triple pattern are
relaxed by substituting with related entities and relations. For example, bornIn
could be substituted with citizenOf or livesIn and Pulitzer Prize could be replaced
by Hugo Award or Booker Prize.

 Entities and relations specified in a triple pattern could be substituted with variables.
For example, Pulitzer Prize could be replaced by ?p to cover arbitrary awards or
wonAward could be replaced by ?r, allowing for matches such as nominatedFor and
shortlistedFor.

 Triple patterns from the entire query could be either removed or made optional. For
example, the triple pattern ?b hasGenre Science Fiction could be removed entirely,
thus increasing the number of authors returned.

The technical contributions of this paper are the following:

 We develop a novel, comprehensive framework for different kinds of query relax-
ation, in an RDF setting, based on language modeling techniques. Our framework
can incorporate external sources such as ontologies and text documents to generate
candidate relaxations. Our relaxation framework is described in Sect. 2.

 We develop a general ranking model that combines the results of the original and
relaxed queries and utilizes relaxation weights for computing, in a principled man-
ner, query-result rankings. The ranking model is described in Sect. 3.

 We evaluate our model and techniques with two datasets  movie data from
imdb.com and book information from the online community librarything.com, and
show that our methods provide very good results in terms of NDCG. The results of
our user study are reported in Sect. 4.

2 Relaxation Framework

We start by describing the basic setting and some of the terminology used in the rest of
this paper.

Knowledge Base. A knowledge base KB of entities and relations is a set of triples,
where a triple is of the form e1, r, e2 with entities e1, e2 and relation r (or s, p, o
?

?

?
with subject s, object o, and property p in RDF terminology). An example of such a
triple is: Carl Sagan wrote Contact.

Queries. A query consists of triple patterns where a triple pattern is a triple with at
least 1 variable. For example, the query science-fiction books written by Carl Sagan
can be expressed as: Carl Sagan wrote ?b; ?b hasGenre Science Fiction consisting of
2 triple patterns.

Given a query with k triple patterns, the result of the query is the set of all k-tuples
that are isomorphic to the query when binding the query variables with matching entities
and relations in KB. For example, the results for the example query includes the 2-tuple
Carl Sagan wrote Contact;Contact hasGenre Science Fiction.

2.1 Relaxation Strategy

As mentioned in the introduction, we are interested in three types of relaxations: i)
replacing a constant (corresponding to an entity or a relation) in one or more triple
patterns of the query with another constant which still reflects the users intention, ii)
replacing a constant in one or more triple patterns with a variable, and iii) removing
a triple pattern altogether. In the rest of this section, we describe a framework which
incorporates all three relaxations in a holistic manner. Specific details about how the
knowledge-base is utilized in the framework are described in Sect. 2.2.
Finding Similar Entities1. For each entity Ei in the knowledge base KB, we construct
a document D(Ei) (the exact method of doing so will be described in Sect. 2.2). For
each document D(Ei), let LM(Ei) be its language model. The similarity between two
entities Ei and Ej is now computed as the distance between the LMs of the corresponding
documents. Specifically, we use the square-root of the Jensen-Shannon divergence (JS-
divergence) between two probability distributions (that is, LM(Ei) and LM(Ej), in this
case), which is a metric. And so, for an entity of interest E, we can compute a ranked
list of similar entities.

Replacing Entities with Variables. We interpret replacing an entity in a triple pattern with a variable as being equivalent to replacing that entity with any entity in the
knowledge base.

We first construct a special document for the entire knowledge base, D(KB). Let
E be the entity of interest (i.e., the entity in the triple pattern to be replaced with a
variable). Let D(E) be its document. Now, we construct a document corresponding to
any entity other than E as: D(ANY) = D(KB)  D(E) (i.e., remove the contents
of D(E) from D(KB)). The similarity between the entity E and any entity ANY is
computed as the distance between the LMs of their corresponding documents.

In the ranked list of potential replacements for entity E, a variable replacement is
now simply another candidate. In other words, the candidates beyond a certain rank are
so dissimilar from the given entity, that they may as well be ignored and represented by
a single variable.

1 Note that, even though we refer only to entities in the following, the same applies to relations

as well.

S. Elbassuoni, M. Ramanath, and G. Weikum

Removing Triple Patterns. So far, we gave a high-level description of our relaxation
technique for individual entities (or relations) in a triple pattern, without treating the
triple pattern holistically. In a given query containing multiple triple patterns, a large
number of relaxed queries can be generated by systematically substituting each constant
with other constants or variables. We now consider the case when a triple pattern in
the query contains only variables. In a post-processing step, we can now choose one
of the following options. First, the triple pattern can be made optional. Second, the
triple pattern can be removed from the query. To illustrate the two cases, consider the
following examples.

Example 1: Consider the query asking for married couples who have acted in the
same movie: ?a1 actedIn ?m; ?a2 actedIn ?m; ?a1 marriedTo ?a2 and a relaxation:
?a1 actedIn ?m; ?a2 ?r ?m; ?a1 marriedTo ?a2. Even though the second triple pattern
contains only variables, retaining this pattern in the query still gives the user potentially
valuable information  that ?a2 was related some how to the movie ?m. Hence, instead
of removing this triple pattern from the query, it is only made optional  that is, a result
may or may not have a triple which matches this triple pattern.

Example 2: Consider the query asking for movies which James Cameron produced,
directed as well as acted in: James Cameron produced ?m; James Cameron directed
?m; James Cameron actedIn ?m and a relaxation: ?x ?r ?m; James Cameron directed
?m; James Cameron actedIn ?m. In this case, the first triple pattern matches any random fact about the movie ?m. This does not give any valuable information to the user
as in the previous case and can be removed.

2.2 Constructing Documents and LMs

We now describe how to construct documents for entities and relations and how to
estimate their corresponding LMs.

Sources of Information. The document for an entity should describe the entity. There
are at least three different sources of information which we can leverage in order to
construct such a document. First, we have the knowledge base itself  this is also the
primary source of information in our case since we are processing our queries on the
knowledge base. Second, we could make use of external textual sources  for exam-
ple, we could extract contextual snippets or keywords from text/web documents from
which the triples were extracted. Third, we could also utilize external ontologies such
as Wordnet, in order to find terms which are semantically close to the entity.

In this paper, our main focus is on utilizing the knowledge base as the information
source and hence, we describe our techniques in this context and perform experiments
using these techniques. But, our framework can be easily extended to incorporate other
information sources and we briefly describe how this can be done at the end of this
section.
Documents and LMs for entities. Let E be the entity of interest and D(E) be its docu-
ment, which is constructed as the set of all triples in which E occurs either as a subject
or an object. That is,

D(E) = {E r o : E r o  KB}  {s r E : s r E  KB}
?

?

?
We now need to define the set of terms over which the LM is estimated. We define two kinds of terms: i) unigrams U , corresponding to all entities in KB, and, ii)
bigrams B, corresponding to all entity-relation pairs. That is,
U = {e : e r o  KB||s r e  KB}

B = {(er) : e r o  KB}  {(re) : s r e  KB}

Example: The entity Woody Allen would have a document consisting of triples
Woody Allen directed Manhattan, Woody Allen directed Match Point, Woody Allen actedIn Scoop, Woody Allen type Director, Federico Fellini
influences Woody Allen, etc.
The terms in the document would include Scoop, Match Point, (type,Director), (Fed-
erico Fellini,influences), etc.

Note that the bi-grams usually occur exactly once per entity, but it is still important
to capture this information. When we compare the LMs of two entities, we would like
identical relationships to be recognized. For example, if for a given entity, we have the
bigram (hasWonAward, Academy Award), we can then distinguish the case where a candidate entity has the term (hasWonAward, Academy Award) and the term (nominated-
For, Academy Award). This distinction cannot be made if only unigrams are considered.
Estimating the LM. The LM corresponding to document D(E) is now a mixture model
of two LMs: PU , corresponding to the unigram LM and PB, the bigram LM. That is,

PE(w) = PU (w) + (1  )PB(w)

where  controls the influence of each component. The unigram and bigram LMs are
estimated in the standard way with linear interpolation smoothing from the corpus. That
is,

PU (w) = 

c(w; D(E))

wU c(w; D(E))

+ (1  )

c(w; D(KB))

wU c(w; D(KB))

where w  U , c(w; D(E)) and c(w; D(KB)) are the frequencies of occurrences of w
in D(E) and D(KB) respectively and  is the smoothing parameter. The bigram LM is
estimated in an analogous manner.
Documents and LMs for relations. Let R be the relation of interest and let D(R) be
its document, which is constructed as the set of all triples in which R occurs. That is,

D(R) = {s
?

?

?
 : s
?

?

?
R o

  KB}

R o

As with the case of entities, we again define two kinds of terms  unigrams and
bigrams. Unigrams correspond to the set of all entities in KB. But, we make a distinction here between entities that occur as subjects and those that occur as objects, since
the relation is directional (note that there could be entities that occur as both). That is,

S = {s : s r o  KB}
O = {o : s r o  KB}
B = {(so) : s r o  KB}

S. Elbassuoni, M. Ramanath, and G. Weikum

Example: Given the relation directed, D(directed) would consist of all triples
containing that relation, including, James Cameron directed Aliens, Woody Allen directed Manhattan, Woody Allen directed Match Point, Sam Mendes directed American Beauty, etc. The terms in the document would include James Cameron, Manhattan,
Woody Allen, (James Cameron, Aliens), (Sam Mendes, American Beauty), etc.
Estimating the LM. The LM of D(R) is a mixture model of three LMs: PS, corresponding to the unigram LM of terms in S, PO, corresponding to the unigram LM of
terms in O and PB, corresponding to the bigram LM. That is,

PR(w) = sPS(w) + oPO(w) + (1  s  o)PB(w)

where s, o control the influence of each component. The unigram and bigram LMs
are estimated in the standard way with linear interpolation smoothing from the corpus.
That is,

PS(w) = 

c(w; D(R))

wSc(w; D(R))

+ (1  )

c(w; D(KB))

wSc(w; D(KB))

where w  S, c(w; D(R)) and c(w; D(KB)) are the frequencies of occurrences of w in
D(R) and D(KB) respectively, and  is a smoothing parameter. The other unigram LM
and the bigram LM are estimated in an analogous manner.

Generating the Candidate List of Relaxations. As previously mentioned, we make
use of the square root of the JS-divergence as the similarity score between two entities
(or relations). Given probability distributions P and Q, the JS-divergence between them
is defined as follows,

JS(P||Q) = KL(P||M) + KL(Q||M)

where, given two probability distributions R and S, the KL-divergence is defined as,

KL(R||S) = jR(j) log R(j)
S(j)

M =
?

?

?
(P + Q)

and

2.3 Examples

Table 2 shows example entities and relations from the IMDB and LibraryThing datasets
and their top-5 relaxations derived from these datasets, using the techniques described
above. The entry var represents the variable candidate. As previously explained, a variable substitution indicates that there were no other specific candidates which had a high
similarity to the given entity or relation. For example, the commentedOn relation has
only one specific candidate relaxation above the variable relaxation  hasFriend. Note
that the two relations are relations between people - a person X could comment on
something a person Y wrote, or a person X could have a friend Y - whereas the remaining relations are not relations between people. When generating relaxed queries using
these individual relaxations, we ignore all candidates which occur after the variable.
The process of generating relaxed queries will be explained in Sect. 3.
?

?

?
Table 2. Example entities and relations and their top-5 relaxations

LibraryThing

Academy Award for Best Actor Thriller
BAFTA Award for Best Actor

Sociology
Essays

History

Non-fiction
Politics
American History Golden Globe Award
for Best Actor Drama
var
Golden Globe Award
for Best Actor Musical or Comedy
New York Film Critics Circle
Award for Best Actor
directed
actedIn
created
produced
var
type

commentedOn
hasFriend
var
hasBook
hasTag

Crime
Horror

Action
Mystery

var

bornIn
livesIn
originatesFrom
var
diedIn
isCitizenOf

Egypt
Ancient Egypt
Mummies

Egyptian
Cairo

Egyptology

wrote
hasBook
hasTagged
var
hasTag
hasLibraryThingPage hasTagged

2.4 Using Other Information Sources

The core of our technique lies in constructing the document for an entity E or relation R
and estimating its LM. And so, given an information source, it is sufficient to describe:
i) how the document is constructed, ii) what the terms are, and, iii) how the LM is esti-
mated. In this paper, we have described these three steps when the information source
is the knowledge base of RDF triples. It is easy to extend the same method for other
sources. For example, for the case of entities, we could make use of a keyword context
or the text documents from which an entity or a triple was extracted. Then a document
for an entity will be the set of all keywords or a union of all text snippets associated
with it. The terms can be any combination of n-grams and the LM is computed using
well-known techniques from the IR literature (see for example, entity LM estimation in
[16, 18, 15, 9, 21], in the context of entity ranking).

Once individual LMs have been estimated for an entity or a relation from each information source, a straight-forward method to combine them into a single LM is to use
a mixture model of all LMs. The parameters of the mixture model can be set based on
the importance of each source. Note that this method does not preclude having different
subsets of sources for different entities or relations.

3 Relaxing Queries and Ranking Results

We have so far described techniques to construct candidate lists of relaxations for entities and relations. In this section we describe how we generate relaxed queries and how
results for the original and relaxed queries are ranked.

S. Elbassuoni, M. Ramanath, and G. Weikum

3.1 Generating Relaxed Queries
Let Q0 = {q1, q2, ..., qn} be the query, where qi is a triple pattern. Let the set of relaxed
queries be R = {Q1, Q2, ..., Qr}, where Qj is a query with one or more of its triple
patterns relaxed. A triple pattern qi is relaxed by relaxing at least one of its constants.
Let sj be the relaxation score of Qj, computed by adding up the scores of all entity
and relation relaxations in Qj. Recall that an individual entity or relation score is the
square root of the JS-divergence between the LMs of the relaxed entity/relation and
the original entity/relation. Clearly, the score s0 for the original query Q0 is 0 and the
queries can be ordered in ascending order of sjs.

Example: Consider the query asking for Academy award winning action movies and
their directors. Table 3 shows the lists L1, L2 and L3 containing the top-3 closest relaxations for each triple pattern along with their scores. Table 4 shows the top-5 relaxed
queries and their scores.

Table 3. Top-3 relaxation lists for the triple patterns for an example query

Q: ?x directed ?m; ?m won Academy Award; ?m hasGenre Action

L1
?x directed ?m : 0.0
?x actedIn ?m : 0.643
?x created ?m : 0.647
?x produced ?m : 0.662 ?m ?r Academy Award : 0.778 ?m hasGenre Crime : 0.653

L2
?m won Academy Award : 0.0 ?m hasGenre Action : 0.0
?m won Golden Globe : 0.624 ?m hasGenre Adventure : 0.602
?m won BAFTA Award : 0.659 ?m hasGenre Thriller : 0.612

L3

Table 4. Top-5 relaxed queries for an example query. The relaxed entities/relations are underlined.

Q: ?x directed ?m; ?m won Academy Award; ?m hasGenre Action

Relaxed Queries
score
?x directed ?m;?m won Academy Award;?m hasGenre Adventure 0.602
?x directed ?m;?m won Academy Award;?m hasGenre Thriller
0.612
?x directed ?m;?m won Golden Globe;?m hasGenre Action
0.624
?x actedIn ?m;?m won Academy Award;?m hasGenre Action
0.643
?x created ?m;?m won Academy Award;?m hasGenre Action
0.647

Now, we describe how results of the original and relaxed queries can be merged and

ranked before representing them to the user.

3.2 Result Ranking
Let Q0 be the original query and let the set of its relaxations be R = {Q1, Q2, ..., Qr}.
Moreover, let the results of the query Q0 and all its relaxations be the set {T1, T2, ..., Tn}
where Ti is a result matching one (or more) of the queries Qj. Note that a result Ti can
be a match to more than one query. For example, consider the query Q0 = ?m hasGenre
Action and a relaxation Qj = ?m hasGenre ?x. The result Batman Begins hasGenre
Action matches both Q0 and Qj.
?

?

?
To be able to rank the results of the original and relaxed queries, we assume that a
result T matching query Qj is scored using some score function f . The scoring function
can be any ranking function for structured triple-pattern queries over RDF-data. In this
paper, we make use of the language-model based ranking function described in [8]. Let
the score of each result T with respect to query Qj be f(T, Qj) and let the score of each
relaxed query Qj be sj where the score of a relaxed query is computed as described in
the previous subsection. In order to merge the results of the original and relaxed queires
into a unified result set, we utilize the following scoring function for computing the
score of a result T :

S(T ) = r

j=0jf(T, Qj)

We next describe two techniques to set the values of the different s.

Adaptive Weighting. In this weighting scheme, we assume that the user is interested
in seeing the results in a holistic manner. That is, a match to a lower ranked (relaxed)
query can appear before a match to a higher ranked query. For example, consider the
query Q0 = ?m hasGenre Action and a relaxation Qj = ?m hasGenre Thriller. The
assumption now is that the user would rather see a famous movie of genre thriller,
rather than an obscure movie of genre action. And so, a mixing of results is allowed.
To this end, we set the js as a function of the scores of the relaxed queries sjs as
follows:

j =

1  sj
i=0(1  si)
r

Recall that the smaller the sj is, the closer Qj is to the original query Q0. Also
recall that s0 is equal to 0. This weighting scheme basically gives higher weights to the
matches to relaxed queries which are closer to the original query. However, matches for
a lower ranked query with sufficiently high scores can be ranked above matches for a
higher ranked query.

Incremental Weighting. In this weighting scheme, we assume that the user is interested
in seeing results in order. That is, all ranked matches of the original query first, followed
by all ranked matches of the first relaxed query, then those of the second relaxed query,
etc. That is, the results are presented block-wise.

In order to do this, we need to set the js by examining the scores of the highest
scoring and lowest scoring result to a given query. For example, consider our example
query : ?m hasGenre Action. Suppose a relaxation to this query is ?x hasGenre Thriller.
If we want to ensure that all matches of the original query are displayed before the first
match of the relaxed query, we first examine the result with the lowest score for the
original query and the highest score for the relaxed query. Let these results be T low
and
, Q0) > 1 f(T high
T high
, Q1).

Note that both incremental as well as adaptive weighting are only two ways in which
we can present results to the user. Additional schemes can include a mixture of both
schemes for instance, or any other variations. Our ranking model is general enough and
can support any number of such fine-grained result presentation schemes.

, respectively. We now need to ensure that 0 f(T low

S. Elbassuoni, M. Ramanath, and G. Weikum

4 Experimental Evaluation

We evaluated the effectiveness of our relaxation techniques in 2 experiments. The first
one evaluated the quality of individual entity and relation relaxations. It also evaluated
the quality of the relaxed queries overall. The second experiment evaluated the quality
of the final query results obtained from both original and relaxed queries. The complete
set of evaluation queries used, relevance assessments collected and an online demo can
be found at http://www.mpii.de/ elbass/demo/demo.html.

4.1 Setup

All experiments were conducted over two datasets using the Amazon Mechanical Turk
service2. The first dataset was derived from the LibaryThing community, which is an
online catalog and forum about books. The second dataset was derived from a subset
of the Internet Movie Database (IMDB). The data from both sources was automatically
parsed and converted into RDF triples. Overall, the number of unique entities was over
48,000 for LibraryThing and 59,000 for IMDB. The number of triples was over 700,000
and 600,000 for LibraryThing and IMDB, respectively.

Due to the lack of an RDF query benchmark, we constructed 40 evaluation queries
for each dataset and converted them into structured triple-pattern queries. The number
of triple patterns in the constructed queries ranged from 1 to 4. Some example queries
include: People who both acted as well as directed an Academy Award winning movie
(3 triple patterns), Childrens book writers who have won the Booker prize (3 triple
patterns), etc.

4.2 Quality of Relaxations

To evaluate the quality of individual entity and relation relaxations, we extracted all
unique entities and relations occurring in all evaluation queries. The total numbers of
entities and relations are given in Table 5. For each entity, the top-5 relaxations were re-
trieved, excluding the variable relaxation. We presented the entity and each relaxation to
6 evaluators and asked them to assess how closely related the two are on a 3-point scale:
2 corresponding to closely related, 1 corresponding to related and 0 corresponding
to unrelated. The same was done for each relation.

To evaluate the quality of relaxed queries overall, we generated the top-5 relaxed
queries for each evaluation query. The relaxed queries were ranked in ascending order
of their scores, which were computed as described in Sect. 3.1. We asked 6 evaluators
to assess how close a relaxed query is to the original one on a 4-point scale: 3 corresponding to very-close, 2 to close, 1 to not so close and 0 corresponding to
unrelated.

Table 5 shows the results obtained for entity, relation and query relaxations. For a
given entity, the average rating for each relaxation was first computed and then this
rating was averaged over the top-5 relaxations for that entity. A similar computation
was performed for relations and query relaxations. The second row shows the average
rating over all relaxed entities, relations and queries. The third row shows the Pearson

2 http://aws.amazon.com/mturk/
?

?

?
correlation between the average rating and the JS-divergence. We achieved a strong
negative correlation for all relaxations which shows that the smaller the score of the
relaxation (closer the relaxation is to the original), the higher the rating assigned by the
evaluators. The fourth row shows the average rating for the top relaxation.

The fifth and sixth rows in Table 5 show the average rating for relaxations that ranked
above and below the variable relaxation respectively. Recall that, for each entity or
relation, a possible entry in the relaxation candidate-list is a variable as described in
Section 2. For those relaxations that ranked above a variable (i.e., whose JS-divergence
is less than that of a variable), the average rating was more than 1.29 for both entities
and relations, indicating how close these relaxations are to the original entity or relation.
For those relaxations that ranked below a variable, the average rating was less than 1.1
for entities and 0.8 for relations. This shows that the evaluators, in effect, agreed with
the ranking of the variable relaxation.

Table 5. Results for entity, relation and
query relaxations

Table 6. Average NDCG and rating for all
evaluation queries for both datasets

Row Metric

Entities Relations Queries
(0-2)

(0-3)

(0-2)

of
?

?

?
No.
items
Avg. rating 1.228
Correlation-0.251
Avg. rating
1.323
for top re-
laxation
Avg. rating
above vari-
able
Avg. rating
below vari-
able

1.007

1.295

Librarything

Adaptive Incremental Baseline

0.868
Avg. Rating 2.062

0.920
2.192

0.799
1.827

Adaptive Incremental Baseline

0.880
Avg. Rating 1.874

0.900
1.928

0.838
1.792

0.863
-0.431
1.058

1.89
-0.119
1.94

1.292

0.781

-

-

4.3 Quality of Query Results

We compared our relaxation framework, with its two weighting scheme variants, Adaptive and Incremental (see Sect. 3.2), against a baseline approach outlined in [8]. The
latter simply replaces a constant in the original query with a variable to generate a relaxed query. The weight of the relaxed triple pattern is determined based on the number
of constants replaced. For all 3 methods, we set the weight of an original triple pattern
to the same value, to ensure that exact matches would rank on top, and thus make the
differences rely solely on the quality and weights of the relaxations. We used the same
ranking function f to rank the results with respect to a query Qj for all 3 techniques.
The ranking function was based on the LM-based ranking model in [8].

We pooled the top-10 results from all 3 approaches and presented them to 6 evaluators in no particular order. The evaluators were required to assess the results on a 4

S. Elbassuoni, M. Ramanath, and G. Weikum

point scale: 3 corresponding to highly relevant, 2 corresponding to relevant, 1 corresponding to somewhat relevant, and 0 corresponding to irrelevant. To measure
the ranking quality of each technique, we used the Normalized Discounted Cumulative Gain (DCG) [12], a standard IR measure that takes into consideration the rank of
relevant results and allows the incorporation of different relevance levels.

The results of our user evaluation are shown in Table 6. The reported NDCG values were averaged over all evaluation queries. Both variations of our framework (the
first two columns) significantly outperformed the baseline approach, with a one-tailed
paired t-test (p-value  0.01). The Adaptive approach had over 8% improvement in
NDCG over the baseline for Librarything and over 5% for IMDB. The Incremental approach had improvements over 15% for Librarything and 7% for IMDB. Furthermore,
we computed the average rating over all results for each technique as shown in the
second and fourth rows (Avg. Rating) in Table 6.

Finally, in Table 7 we show an example evaluation query and the top-3 results returned by each relaxation approach. Next to each result, we show the average rating
given by the evaluators. The relaxed constants are underlined.

The example query in Table 7 asks for science fiction books that have tag Film.
There is only one one such result which is ranked as the top result by all 3 approaches.
Since the Adaptive approach ranks the whole set of approximate results, it allows
for more diversity in terms of relaxations. And so, the Adaptive approach returns the
more famous and iconic movies, Blade and Star Wars as the top results compared to
The Last Unicorn and The Mists Of Avalon returned by the Incremental scheme.

Table 7. Top-ranked results for the example query A science-fiction book that has tag Film

Result

Rating

Q: ?b type Science Fiction; ?b hasTag Film

Adaptive

Star Trek Insurrection type Science Fiction; Star Trek Insurrection hasTag Film 2.50
Blade type Science Fiction; Blade hasTag Movies
2.83
Star Wars type Science Fiction; Star Wars hasTag Made Into Movie
2.00

Star Trek Insurrection type Science Fiction; Star Trek Insurrection hasTag Film 2.50
The Last Unicorn type Science Fiction; The Last Unicorn hasTag Movie/tv
2.50
The Mists of Avalon type Science Fiction; The Mists of Avalon hasTag Movie/tv 2.17

Incremental

Star Trek Insurrection type Science Fiction; Star Trek Insurrection hasTag Film 2.50
Helter Skelter type History; Helter Skelter hasTag Film
0.83
Fear & Loathing in Vegas type History; Fear & Loathing in Vegas hasTag Film 1.83

Baseline

5 Related Work

One of the problems addressed in this paper is that of relaxing entities and relations with
similar ones. This is somewhat related to both record linkage [14], and ontology matching [19]. But a key difference is that we are merely trying to find candidates which are
?

?

?
close in spirit to an entity or relation, and not trying to solve the entity disambiguation
problem. Other kinds of reformulations such as spelling correction, etc. directly benefit
from techniques for record linkage, but are beyond the scope of our work.

Query reformulation in general has been studied in other contexts such as keyword
queries [5] (more generally called query expansion), XML [1, 13], SQL [4, 22] as well
as RDF [11, 7, 10]. Our setting of RDF and triple patterns is different in being schemaless (as opposed to relational data) and graph-structured (as opposed to XML which is
mainly tree-structured and supports navigational predicates).

For RDF triple-pattern queries, relaxation has been addressed to some extent in [22,
11, 7, 10, 8]. This prior work can be classified based on several criteria as described
below. Note that except for [22] and our previous work in [8], none of the other papers
report on experimental studies.

Scope of Relaxations. With the exception of [7, 11], the types of relaxations considered
in previous papers are limited. For example, [22] considers relaxations of relations only,
while [10, 8] consider both entity and relation relaxations. The work in [8], in particular,
considers a very limited form of relaxation  replacing entities or relations specified in
the triple patterns with variables. Our approach, on the other hand, considers a comprehensive set of relaxations and in contrast to most other previous approaches, weights
the relaxed query in terms of the quality of the relaxation, rather than the number of
relaxations that the query contains.

Relaxation Framework. While each of the proposals mentioned generates multiple
relaxed query candidates, the method in which they do so differ. While [7, 11, 10]
make use of rule-based rewriting, the work in [22] and our own work make use of the
data itself to determine appropriate relaxation candidates. Note that rule-based rewriting
requires human input, while our approach is completely automatic.

Result Ranking. Our approach towards result ranking is the only one that takes a holistic view of both the original and relaxed query results. This allows us to rank results
based on both the relevance of the result itself, as well as the closeness of the relaxed
query to the original query. The block-wise ranking adopted by previous work  that
is, results for the original query are listed first, followed by results of the first relaxation
and so on  is only one strategy for ranking, among others, that can be supported by our
ranking model.

6 Conclusion

We proposed a comprehensive and extensible framework for query relaxation for entityrelationship search. Our framework makes use of language models as its foundation and
can incorporate a variety of information sources on entities and relations. We showed
how to use an RDF knowledge base to generate high quality relaxations. Furthermore,
we showed how different weighting schemes can be used to rank results. Finally, we
showed the effectiveness of our techniques through a comprehensive user evaluation.
We believe that our contributions are of great importance for an extended-SPARQL API
that could underlie the emerging Web-of-Data applications such as Linking-Open-
Data across heterogeneous RDF sources.

S. Elbassuoni, M. Ramanath, and G. Weikum
