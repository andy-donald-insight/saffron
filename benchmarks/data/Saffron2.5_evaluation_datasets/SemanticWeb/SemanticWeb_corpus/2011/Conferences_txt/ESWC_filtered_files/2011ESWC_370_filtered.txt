Towards Custom Cloud Services

Using Semantic Technology to Optimize Resource

Configuration

Steffen Haak and Stephan Grimm

Research Center for Information Technology (FZI)

D-76131 Karlsruhe, Germany

Haid-und-Neu-Str. 10-14
{haak,grimm}@fzi.de

Abstract. In todays highly dynamic economy, businesses have to adapt
quickly to market changes, be it customer, competition- or regulation-
driven. Cloud computing promises to be a solution to the ever changing
computing demand of businesses. Current SaaS, PaaS and IaaS services
are often found to be too inflexible to meet the diverse customer requirements regarding service composition and Quality-of-Service. We therefore propose an ontology-based optimization framework allowing Cloud
providers to find the best suiting resource composition based on an abstract request for a custom service. Our contribution is three-fold. First,
we describe an OWL/SWRL based ontology framework for describing
resources (hard- and software) along with their dependencies, interoperability constraints and meta information. Second, we provide an algorithm that makes use of some reasoning queries to derive a graph over all
feasible resource compositions based on the abstract request. Third, we
show how the graph can be transformed into an integer program, allowing to find the optimal solution from a profit maximizing perspective.

1 Introduction

In the last decades, most companies regarded their IT systems as a necessary
but unimportant part of their business models. Investments into IT infrastructure were cost- rather than quality-driven and long product life cycles made
investments long-term rather than flexible. However the Internets increasing
importance for global business, emerging new paradigms like Service Oriented
Architectures (SOA) and Cloud computing, and the ever increasing competition
fostered through globalization has made many companies rethink their IT strat-
egy. Even in traditional industries, IT no longer just acts as a supporting unit -
in many cases IT has become a strategic competitive factor. The challenge has
become even harder, as product and service life cycles become shorter and adaptation to market changes needs to be more agile as ever before [6]. Naturally this
challenge is encountered by all parts of modern business, putting high demands
on flexibility and agility on a companys supporting IT services.

G. Antoniou et al. (Eds.): ESWC 2011, Part II, LNCS 6644, pp. 345359, 2011.
c Springer-Verlag Berlin Heidelberg 2011

S. Haak and S. Grimm

Cloud computing (and its SaaS, PaaS and IaaS offerings) promises to be a solution for cutting costs in IT spending while simultaneously increasing flexibility.
According to thecloudmarket.com [1], there already exist over 11.000 different
preconfigured Amazon EC2 images from various providers, that can be run as
virtual appliance on Amazons Elastic Compute Cloud (EC2). The large variety
indicates the importance of custom service offers. However, the customer has
little support in the technical and economic decision process for selecting an
appropriate image and deploying it on the Cloud. It is neither guaranteed, that
there finds an image that is configured exactly according to the customer needs.
Apparently there is a great business opportunity for Cloud providers who
manage to offer Custom Cloud Services tailored to their customers needs. Transferring the selection and deployment process to the provider simplifies the cus-
tomers decision process significantly. In such a scenario, the provider faces the
challenging task of automatically finding the optimal service composition based
on the customer request, from both a technical and an economic view. A customer requesting a database service having for example only preferences on the
underlying operating system or the available storage space leaves a lot of room
for economic optimization of the service composition. A MySQL database running on a Linux-based virtual machine (VM) might be advantageous over the
more costly Oracle alternative on a Windows-based VM.

Custom Cloud Services, as referred to in this paper, are compositions of commercial off-the-shelf software, operating system and virtualized hardware, bundled to offer a particular functionality as requested by a customer. The functional
requirements usually leave many choices when choosing required resources from
groups that offer equal or similar functionalities as in the above mentioned exam-
ple. Finding the optimal choice involves many different aspects, including (among
others) technical dependencies and interoperability constraints, customer preferences on resources and Quality-of-Service (QoS) attributes, capacity constraints
and license costs. In a sense, it is a configuration problem as known from typical
configurators for products like cars, etc. However, stated as integer programming or constraint optimization problem [15,7], it is underspecified as not all
configuration variables (the set of required service resource types) can be clearly
specified ex ante from the customer request. The missing variables however can
be derived dynamically as they are implicitly contained in the resources depen-
dencies. For example, a customer request for a CRM software might implicitly
require an additional database, some underlying operating system on some virtualized hardware.

As mentioned before, traditional linear or constraint programming techniques
require the knowledge of all variables. In order to overcome this problem, we propose an ontology-based approach for a convenient and standardized knowledge
representation of all known Cloud service resources, allowing to derive the complete configuration problem by subsequently resolving resource dependencies.

The remainder of this paper is structured as follows. Section 2 describes
an example use case, which helps us to derive requirements for the designated
?

?

?
framework. These requirements are also used for a qualitative evaluation of our
approach and to distinguish it from related work.

In Section 3 we describe our main contribution. We start by describing our
understanding of functional requirements, which serve as input for the ontologybased optimization framework. We then propose the usage of a three-fold ontology system to serve as knowledge base. We distinguish between a generic service
ontology, that contains the meta concepts provided in this paper, a domain ontology that makes use of these concepts and contains the actual knowledge about
known infrastructure resources, and a result ontology that is used to represent a
graph, spanning a network over different choices based on abstract dependency
relations that can exist between different resources (e.g. that every application
needs some operating system). We formally describe this dependency graph and
show how it can be derived algorithmically, making use of different queries to
the ontology system. Further we show how this graph can be used to obtain all
feasible infrastructure compositions. In addition, we show how the graph can be
transformed into an integer program for finding the profit optimal configuration
with respect to customer preferences and costs. For knowledge representation,
we make use of the Semantic Web ontology and rule languages OWL and SWRL
combined with SPARQL querying facilities.

Section 4 describes a proof-of-concept implementation of the presented framework and reviews the requirements from Section 2 with respect to our contribu-
tion. In Section 5 we conclude this paper by giving an overview on open issues
and an outlook on future research.

2 Use Case, Requirements and Related Work

For a better understanding and evaluating our research we present a use case
describing an example request for a Custom Cloud Service. We use it to derive
a set of required properties for our contribution. The section is concluded by an
overview on the related literature.

2.1 Use Case

Consider a service request from a customer who wants to set up an online survey
for a two months period. The customer has no preferences regarding the survey
system, however would slightly prefer a Windows-based operating system over
Linux. As he is quite acquainted with Oracle products, the survey systems
underlying database is preferably also Oracle-based. The expected workload in
form of concurrent users is unclear, however this is not considered a problem
due to scalability of Cloud services.

In a typical scenario the provider wants to maximize profit, i.e. the difference
between the offer price and the accruing costs. The challenge is to find the
configuration that is in line with the customer preferences, thus having a high
offer price, while simultaneously considering cost aspects.

S. Haak and S. Grimm

2.2 Requirements

Based on the use case, we can now derive a set of requirements, defining and
clarifying the goals of the desired solution. We identify five major properties that
we find necessary to provide an adequate solution for finding the optimal service
configuration in this case:

R 1 (Top Down Dependency Resolution). Automatic resolution of all
transitive dependencies between resource classes, starting from the top level functional requirement resources until no more unresolved dependencies exist. Thus
deducting all variables for the Custom Cloud Service configuration problem.
R 2 (Functional Requirements). The functional requirements for the designated service should be describable by abstract or concrete resources (on different
levels).

R 3 (Customer Preferences). The approach should be able to consider customer preferences regarding different configuration options.

R 4 (Interoperability Check). The interoperability/compatibility between resources has to be validated. For reducing the modeling overhead, this validation
should be possible on both instance and higher abstraction levels.

R 5 (Profit Optimization). The profit maximizing Custom Cloud Service
configuration has to be found. I.e. the configuration yielding the greatest difference between the achievable offer price for a configuration and the accruing
costs on provider side.

Additionally we require correctness, completeness and consistency for the designated decision support mechanism. However, as these properties are rather
generic we do not consider them for our related literature review.

2.3 Related Work

For solving the technically and economically complex problem of deriving and
optimizing configuration alternatives, we have to touch a broad spectrum of
research areas, from Web service composition to techniques from operations
research and constraint programming.

Berardi et al. [4] address the problem of automatic service composition by
describing a service in terms of an execution tree, then making use of finite
state machines to check for possible service compositions that match a requested
behavior. L ecu e et al. [11] present an AI planning-oriented approach using Se-
mantics. Based on causal link matrices, the algorithm calculates a regressionbased optimal service chain. Both [4] and [11] concentrate on input/output
based matching of Web services, thus they are not suitable for infrastructure
service compositions, where the interfaces are much more complex and cannot
be described in terms of input and output. Another work from the Semantic Web
context by Lamparter et al. [10] describes the matching process between requests
and offers of Web services. This approach is a related example for the matching
?

?

?
of interoperability constraints (R 4), however it does not include dependency
resolution.

Blau et al. [5] propose an ontology-based tool for planning and pricing of
service mash-ups. The tool can be used to compose complex Web services from
a set of known atomic services, which are stored in a domain specific ontology.
Afterwards the complex service can be validated based on axioms and rules in
the ontology.

Sabin et al. [15] present different constraint programming approaches for product configuration. Van Hoeve [7] describes optimization approaches for constraint
satisfaction problems. In [9] an optimization framework combining constraint
programming with a description logic is provided. All related to R 5.

We also want to mention two software tools that include a transitive dependency management, thus are mainly related to requirements 1 and 4. Advanced
Packaging Tool (APT) [16] is a package management system to handle the installation and removal of software packages on Linux distributions. APT allows to
automatically install further packages required by the desired software to avoid
missing dependencies. The dependency management also includes compatibility
checks, however only in form of a rather simple version level check. Another
dependency manager is Apache Ivy [2]. Dependencies in Ivy are resolved tran-
sitively, i.e. you have to declare only direct dependencies, further dependencies
of required resources are resolved automatically. Both approaches do not allow
semantic annotations to allow more complex dependencies or interoperability
constraints.

3 Custom Cloud Service Configuration

The contribution of our work consists of several elements in the context of configuring Custom Cloud Services. For a common understanding we first want to
provide our own definition:

Definition 1 (Custom Cloud Service). A Custom Cloud Service is a Cloud
Computing service, composed by a set of software components and existing Cloud
infrastructure resources, according to the abstract functional requirements and
non-functional preferences of an individual customer or target customer group.

In the following section we provide a formal definition on the functional requirements on Custom Cloud Services, tailored to the described use case. We then
present an ontology model, that can be used to formally capture the knowledge
about Cloud resources, their interdependencies and compatibility constraints as
well as cost meta information. We also present an algorithm to build a dependency graph based on this knowledge, which can be seen as completely specified
configuration problem. Lastly we show how the graph can be transformed into
an integer program, allowing to find the optimal solution from a cost-benefit per-
spective. A sequence diagram to visualize the proposed interaction is depicted
in Figure 1.

S. Haak and S. Grimm

Customer

Provider

Functional Requirements

Dependency Graph

Dependency 
Graph Algorithm

Decline

Preferences

Service Offer

Accept

Optimization

Deployment

Fig. 1. Interaction Process

3.1 Functional Requirements

Functional requirements describe what is needed, i.e. the components required
for a functioning service, whereas non-functional requirements describe how it is
needed, i.e. the desired quality of the service. For the declarative description of
functional requirements, we build on concepts taken from an ontology that contains background information in form of an abstract resource description layer
(service ontology) and a domain-specific layer containing domain-dependent descriptions of available resources (domain ontology). We define functional requirements as follows.

Definition 2 (Functional Requirements). For a background ontology O the
functional requirements for deploying a service is described by the tuple R =
(C, t), with C = {C1, . . . , Cn}, a set of concepts in O, and t, the requested time
period for the service.

For illustration, the functional requirements of the presented use case would be
the tuple R = ({OnlineSurvey} , 1440h).

3.2 Knowledge Representation

For knowledge representation, we rely on the Web Ontology Language (OWL)
[12] specification for several reasons. It has been established as the leading Semantic Web standard, is widely spread thus offering a large set of modeling tools
and inference engines, is well documented and offers description logics (DL) expressiveness that fits well our anticipated description of services at class-level.
In addition, OWL comes with a standardized, web-compliant serialization which
ensures interoperability over the borders of single institutions.
?

?

?
For stating more complex compatibility constraints that go beyond the DL
expressivity, we also make use of the Semantic Web Rule Language (SWRL) [8]
in combination with OWL, while we restrict ourselves to DL-safe rules [14] as is a
decidable fragment supported by OWL reasoners like Pellet [17] or KAON2 [13].
We make use of three different ontologies. A generic service ontology, which
defines the fundamental concepts of our model. The actual knowledge on the
known software and Cloud resources is modeled in the domain ontology and will
differ for the various users or use cases. While the service ontology is a static
model, the domain ontology has to be dynamic, i.e. it will need constant updates
on the current infrastructure situation. The third ontology is used to store the
results of the algorithm that derives all alternatives by dissolving the resources
dependencies. Both domain and result ontology import the fundamental concepts
defined in the service ontology.

hasValue

Costs

xsd:float

hasCosts

requires

Alternative

ResultNode

ServiceComponent

contains

hasOption

OrNode

FixCosts

VariableCosts

isCompatibleTo

choice

connectsTo

multiplyer

xsd:float

connectsTo

SinkNode

SourceNode

Costs

Dependency & Compatibility

Result Graph

Fig. 2. Service Ontology

Service Ontology. The service ontology is partially depicted in Figure 2. For
the readers convenience we illustrate the ontology in UML notation where UML
classes correspond to OWL concepts, UML associations to object properties,
UML inheritance to sub-concept relations and UML objects to OWL instances.
Basically, the service ontology provides concepts for three different aspects:

1. Service resources along with dependencies and compatibility information,

needed to derive all valid service configuration alternatives

2. Cost meta information for evaluating these alternatives
3. Structure elements needed for an ontology representation of the dependency

graph

The most fundamental concept for deriving all feasible deployment alternatives is the class ServiceComponent along with the corresponding object properties

S. Haak and S. Grimm

requires and isCompatibleTo. The requires property is used to describe the functional dependency between two resource instances. In most cases, dependencies
can and should be described in an abstract way at class-level. We can do this
by including the dependency relation into the class axiom in conjunction with
an object restriction in the form of an existential quantifier on the required
class:

ComponentA  ServiceComponent

 requires.ComponentB

Hereby we state that each resource of type ComponentA requires some resource
of type ComponentB. As a more concrete example, we could state that every
instance of the class Application requires at least some operating system:

Application  ServiceComponent

 requires.OS

The compatibility can be asserted on instance level using the isCompatibleTo
object property. That implies that there has to be one object relation between
all possible combinations of interdependent resources. To reduce this modeling
overhead, we propose the usage of SWRL rules, which allow us to state compatibility on class level:

isCompatibleTo(x,y) 
ComponentA(x)
ComponentB(y)

(L1.1)
(L1.2)
(L1.3)

We can exploit the full expressiveness of DL-safe SWRL rules. E.g. to state that
all versions of MySQL are compatible to all Windows versions except Windows
95, we include the following rule:

isCompatibleTo(x,y) 
MySQL(x)
Windows(y)
differentFrom(y,Windows95)

(L2.1)
(L2.2)
(L2.3)
(L2.4)

For inclusion of cost information we distinguish between non-recurring FixCosts and recurring VariableCosts. The latter being more complex, as the total
amount depends on another variable, which has to be defined in the context to
serve as a multiplier. E.g. the overall usage fee for a cloud provider depends on
the planned usage period for the service.

Domain Ontology. The domain ontology uses the concepts described in the
preceding section to capture the knowledge about the Cloud service resources of
?

?

?
a certain domain of interest. This allows to easily use the same technology for
many different contexts, just by loading a different domain ontology. In addition,
knowledge can be combined by loading several domain ontologies, as long as this
does not lead to inconsistencies.

Result Ontology. By resolving the transitive dependencies for the set of resources from the functional requirements, it is clear that we cannot add any
knowledge, we can only make additional knowledge explicit, that is contained in
the knowledge base implicitly.

For persisting the extended model, we also rely on an OWL ontology, such
that it can be used for further reasoning tasks. The result ontology makes use
of the concepts SourceNode, SinkNode, OrNode and Alternative, all defined in
the service ontology. SourceNode and SinkNode are a helper nodes to have a
distinct starting and ending points in the graph. They correspond to the source
and sink nodes in a network. The OrNode is introduced to capture the branching
whenever there is more than one compatible resource instance that fulfills the
dependency requirement.

In the remainder of the paper we work with a more formal notation for the
dependency graph. Note that both notations are semantically the same. An
example graph is depicted in Figure 3.

Quikpoll 

requires

Script

option

Perl

requires

r
e

q

o

option

u

ir

e

s

option

Oracle

requires

Source

Online
Survey

option

option

MySQL

requires

n

o

i
t

p

o

requires

LimeSurvey

requires

Script

option

requires

p

ti

o

Win

requires

option

Xen

n

o

i
t

p

o

Sink

Linux

requires

VM option

VMware

n

option

o

n

i

t

p

o

o

n

o

p
t
i

option
n
ptio
o p t i o n
o
option

Fig. 3. Example Dependency Graph

Definition 3 (Dependency Graph). For a background ontology O and a
functional requirements tuple R = (C, t), the dependency graph G = (V, E)
is a directed, acyclic, labeled graph with vertices V and edges E and a labeling
function L, recursively defined as follows:
 n0  V is the source node of G
 n  V is the sink node of G
 there is a node nC  V with label L(nC) = C for each (atomic or nominal)
class C  C and an edge (n0, nC)  E
 if n  V is a node with an atomic class label L(n) = A then there is a node
no with label L(no) = {o} for each individual o  O with O |= A(o), and an
edge e = (n, no) with label L(e) = or

S. Haak and S. Grimm

 if n  V is a node with a nominal class label L(n) = {o} then there is a node
nC with label L(nC) = C for each atomic or nominal class C with O |= C(x)
for all x such that O |= requires(o, x) and O |= isCompatibleT o(o, x), and
an edge e = (n, nC) with label L(e) = and.

3.3 Dependency Graph Algorithm

OWL reasoners typically construct models for answering standard reasoning
tasks but do not expose them as such. Since we need to explicitly access such
models as configuration alternatives at the instance-level, we chose an algorithmic solution, making use of OWL reasoning capabilities in between the construction of dependency graphs.

Algorithm 1. determineDependencies(R, O; G)  Initiate the construction of a
dependency graph.
Require: a functional requirement tuple R = (C, F ) and ontology O
Ensure: G contains the dependency graph for R



V := {n0, n}, V
for all C  C do

:= E := 
V := V  {nC}, L(nC ) := C
E := E  {(n0, nC )}, L((n0, nC )) = and
for all o with O |= C(o) do

V := V  {no}, L(no) = {o}
E := E  {(nC , no)}, L((nC, no)) = or

deductServiceInfrastructure(O, o, G, V

)

end for

end for

The procedure determineDependencies in Algorithm 1 initiates the construction
of a dependency graph, starting from functional requirements R, and calls the
procedure deductServiceInfrastructure in Algorithm 2, which recursively finds suitable service resource instances by following the object property requires.

In the procedure getRequiredClasses we invoke the reasoning engine with the
following SPARQL query to find all implicitly stated dependencies, i.e. through
a class axiom rather than explicitly on instance level:

SELECT ? sub ? t ? o b j
WHERE {

? sub owl : sameAs dm: component
? sub s o : r e q u i r e s

: b0 .

.

: b0 r d f : type ? t .
r d f : type ? t }

? o b j

ORDER BY ? t

so hereby refers to the name space of the service ontology, dm to the name
:b0 refers to a blank node, i.e. there

space of the domain ontology. The literal
?

?

?
dependency graph for a given ontology and resource instance.
Require: an ontology O and a resource instance o  O
Ensure: G = (V, E) contains a dependency graph for o, V



contains all resource

Towards Custom Cloud Services

)  Recursively construct a

:= V

  {no}

instance nodes visited


C := , getRequiredClasses(o; C)
if C =  then E := E  {(no, n)}
for all C  C do

V := V  {nC}, L(nC ) := C
E := E  {(no, nC )}, L((no, nC)) = and

for all o

with O |= C(o
?

?

?
) and O |= isCompatibleT o(o, o
?

?

?
) do

V := V  {no}, L(no ) = {o
}
E := E  {(nC , no )}, L((nC , no )) = or
if no  V
?

?

?
then deductServiceInfrastructure(O, o



, G, V



)

end for

end for

do not exist two individuals for which we find the requires property, but based
from the axiomatic knowledge we know there has to be at least one.

The query will answer us with a set of all types of these anonymous individuals.
This has one disadvantage: we are only interested in the most specific class
assertions. E.g. if it was stated that every application needs an operating system,
the query would have the class OS in its result set, however also every superclass
up to Thing.

Therefore, in a second step, we need to find out the most specific classes,
i.e. all classes that have no subclasses also contained in the result set. This can
be achieved by a simple algorithm which has a worst case runtime of O(n2)
subsumption checks.

As there are redundant dependencies, which by themselves again might have
), as we do not need

further dependencies, we memorize the visited resources (V
to resolve their dependencies more than once.

Further the algorithm remembers unfulfilled requirements and recursively
traces them back, deleting unfeasible paths. We have not included these steps in
the above printed pseudo algorithm, as they would only confuse the reader.

Constraint Satisfaction Problem In another formal representation of the
graph (Figure 4), denoted as GF , we can recognize the analogy to a constraint
satisfaction problem [7], which is defined by a set of variables X = {X1, . . . , Xn},
} defining the possible values for X and a set
a set of domains D = {DX1, . . . , DXn
of constraints C. In GF the variables X are equal to vertices labeled with classes
C  O, and the domains DXi equal to vertices labeled with resource instances
o  O. Vertices, labeled with an identical resource class C, are subsumed by one
variable XC. The constraints in C can be derived from the edges denoting the
interoperability between resources.

S. Haak and S. Grimm

Source

X1

option

n

o

i
t

p

o

x1

requires

r
e

q

u

ir

e

s

requires

requires

x1

X2

X3

X3

X2

option

option

option

option

option

x2

x3

x3

x2

requires

requires

requires

requires

X4

X4

X4

X4

o

p

ti

o

x4

requires

X5

x5

option

n

o

i
t

p

o

Sink

x4

requires

X5

option

x5

n

option

o

n

i

t

p

o

o

n

o

p
t
i

option
n
ptio
o p t i o n
o
option

Fig. 4. Formal Dependency Graph

3.4 Preferences

As shown in Figure 1, after receiving the dependency graph, the customer can
specify preferences. For quantifying the customer satisfaction for a certain con-
figuration, we introduce the notion of a scoring function [3]. The scoring function
maps the customer preferences on certain configuration choices to a real number
in the interval [0, 1]. We achieve that by a weighted aggregation of the single
preference values regarding the different configuration choices (cf. Section 3.5).
For expressing non-compensating preferences, we define a set of additional restrictions R added to set of constraints C.
Definition 4 (Preferences). For a dependency graph GF the customer preferences are described by the triplet P = (P, ,R), with P = {P1, . . . , Pn}, a set
of preference vectors,  = {1, . . . , n} a set of weights for each variable Xi in
X with

i i = 1 and R a set of non-compensating restrictions.
?

?

?
Example. For a variable XOS representing the various operating system choices
with DXOS = {W in, Linux}, the preferences are denoted by the vector POS =
(1, 0.8)T , expressing the slight preference for a Windows-based system, as described in our use case. Analogously, we would denote PDB = (0.5, 1)T with
DXDB = {M ySQL, Oracle}. If both preference values are considered equally
important, we would denote OS = DB = 0.5. A non-compensating restriction
could be that
to be PHP-based, denoted by
R = {XScript

the online survey has

!= P HP}.

3.5 Optimization
Having the dependency graph GF and the customer preferences P we want to
find the optimal configuration that will be offered to the customer. The optimal
configuration can differ in various scenarios with different pricing schemes and
potential additional constraints (like capacity restrictions). In this work we define
the optimum as the configuration that yields the highest profit, i.e. the achieved
price minus the accruing costs. Hereby we assume, that customer is sharing his
?

?

?
subject to

with

  S(X )  C(X )
?

?

?
Xi

xj
i

Xi  X
xj
i = 1
i, j : Xi r Xk
Xi  Xk  Iik
R  R constraints from P
?

?

?
i  Xi  Pi
Ci  Xi

XiX

S(X ) =
C(X ) =

Towards Custom Cloud Services

willingness to pay for a service perfectly fulfilling all his preferences, denoted by
. Extensions to this simple economic model are considered in ongoing research.
In a naive approach, we could try to iterate over all feasible configurations
in GF . One configuration is a sub graph, as the meaning of the edges can be
interpreted as and and or. As a matter of fact, we can rewrite the dependency
graph as Boolean formula.If we convert the Boolean formula (which is already
in negation normal form) into its disjunctive normal form (DNF) by a step-wise
replacement using de Morgans laws, we exactly get an enumeration over all sets
of resource instances that reflect the different configurations.

However, we are interested in the optimal configuration, thus iterating over
all configurations might not be the best choice as it is very costly with respect
to runtime. We therefore set up an integer program, which calculates the profit
maximizing configuration. The variables from the constraint satisfaction problem
are by modeled a vector of binary decision variables Xi = (X 1
i ) for m
different choices.

i , . . . , X m

XiX

Iik hereby denotes an interoperability matrix between Xi and Xk that can
be derived from GF . The cost function C(X ) merely is the sum over all costs
for the chosen resources, which are stored in the ontology O. In case of variable
costs, we multiply the cost value with the requested time period for the service
t from R (cf. Section 3.1).

4 Evaluation

We evaluate our contribution qualitatively by having implemented a proof-of-
concept prototype and comparing the presented approach to the requirements
from Section 2.2.

4.1 Implementation
The implemented prototype can be executed using Java Web Start1. For using
the prototype, a domain ontology (an example ontology is provided) has to be

http://research.steffenhaak.de/ServicePlanner/

S. Haak and S. Grimm

loaded, before one can add the set of resources C. Eventually, the algorithms can
be started by using the menu items ResolveDependencies and Evaluate. However,
not all functionalities presented in this paper are integrated. We can derive all
feasible configurations using the described DNF approach. The integer program
has been implemented using CPLEX, thus not being part of the downloadable
prototype. As reasoning engine we have chosen Pellet [17], as to our knowledge it
is the only OWL DL reasoner that is capable of both SWRL rules and SPARQL
queries that involve blank nodes.

4.2 Requirements Review
Taking a look back to the requirements derived from the use case, we have presented a framework to model knowledge about Cloud resource dependencies and
compatibilities. Based on this knowledge base a set of functional requirements
can be defined in from of classes from the ontology on arbitrary abstraction level.
It is used to derive a dependency graph ensuring interoperability of all configura-
tions. Based on the graph, the customer can define preferences for each variable,
which are subsumed in a scoring function. Stated as constraint satisfaction prob-
lem, an integer program finds out the profit maximizing configuration, making
use of the scoring function and the cost information stored in the ontology. The
proposed approach therefore fulfills requirements R 1 to R 5.

5 Conclusion

In this paper, we propose an ontology-based optimization framework for finding
the optimal Cloud service configuration based on a set of functional require-
ments, customer preferences and cost information. We do this by means of an
OWL DL approach, combined with DL-safe SWRL rules and SPARQL querying
facilities. We can model dependencies between resource classes of any abstraction
level and use complex rules to ensure compatibility between resources. An integer program allows us to find the profit maximizing configuration. We provide a
prototypical implementation as proof-of-concept.

We recognize several reasonable extensions and shortcomings to our approach.
The economic model for the profit maximization is very simplistic. It is arguable
that the customer is willing to give price his preferences and willingness to pay
in a truthful manner. Further extensions from an economic perspective are the
integration of capacity constraints and optimizing several concurrent requests.
Ongoing research is dealing with both issues.

From the semantic perspective, a more complex cost and quality model would
be beneficial. In addition, we plan to investigate on how the proposed domain
ontology can be maintained collaboratively by incentivizing resource suppliers
to contribute the necessary knowledge about their resources as interoperability
and dependencies themselves.

We also recognize the need for a better evaluation, qualitatively, through relying on an industry use case, and quantitatively, by analyzing both the economic
benefit of our solution and its computational complexity.
?

?

