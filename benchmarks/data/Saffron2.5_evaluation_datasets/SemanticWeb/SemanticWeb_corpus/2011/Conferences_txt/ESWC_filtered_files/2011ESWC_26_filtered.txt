Semantics and Optimization of the SPARQL 1.1

Federation Extension

Carlos Buil-Aranda1, Marcelo Arenas2, and Oscar Corcho1

1 Ontology Engineering Group, Facultad de Inform atica, UPM, Spain

2 Department of Computer Science, PUC Chile

Abstract. The W3C SPARQL working group is defining the new SPARQL 1.1
query language. The current working draft of SPARQL 1.1 focuses mainly on the
description of the language. In this paper, we provide a formalization of the syntax
and semantics of the SPARQL 1.1 federation extension, an important fragment of
the language that has not yet received much attention. Besides, we propose optimization techniques for this fragment, provide an implementation of the fragment
including these techniques, and carry out a series of experiments that show that
our optimization procedures significantly speed up the query evaluation process.

1 Introduction

The recent years have witnessed a constant growth in the amount of RDF data avail-
able, exposed by means of Linked Data-enabled URLs and SPARQL endpoints. Several
non-exhaustive, and sometimes out-of-date, lists of SPARQL endpoints or data catalogs
are available in different formats (from wiki-based HTML pages to SPARQL endpoints
using data catalog description vocabularies). Besides, most of these datasets are inter-
linked, what allows navigating through them and facilitates building complex queries
combining data from heterogeneous datasets.

These SPARQL endpoints accept queries written in SPARQL and adhere to the
SPARQL protocol, as defined by the W3C recommendation. However, the current
SPARQL recommendation has an important limitation in defining and executing queries
that span across distributed datasets, since it only considers the possibility of executing
these queries in isolated SPARQL endpoints. Hence users willing to federate queries
across a number of SPARQL endpoints have been forced to create ad-hoc extensions
of the query language or to include additional information about data sources in the
configuration of their SPARQL endpoint servers [14,15]. This has led to the inclusion
of query federation extensions in the current SPARQL 1.1 working draft [12] (together
with other extensions that are out of the scope of this paper), which are studied in detail
in order to generate a new W3C recommendation in the coming months.

The federation extension of SPARQL 1.1 includes two new operators in the query
language: SERVICE and BINDINGS. The former allows specifying, inside a SPARQL
query, the SPARQL query service in which a portion of the query will be executed. This
query service may be known at the time of building the query, and hence the SERVICE
operator will already specify the IRI of the SPARQL endpoint where it will be executed;
or may be retrieved at query execution time after executing an initial SPARQL query

G. Antoniou et al. (Eds.): ESWC 2011, Part II, LNCS 6644, pp. 115, 2011.
c Springer-Verlag Berlin Heidelberg 2011

C. Buil-Aranda, M. Arenas, and O. Corcho

fragment in one of the aforementioned RDF-enabled data catalogs, so that potential
SPARQL endpoints that can answer the rest of the query can be obtained and used. The
latter (BINDINGS) allows transferring results that are used to constrain a query, and
which will normally come from previous executions of other queries or from constraints
specified in user interfaces that then transform these into SPARQL queries.

Till now, most of the work done on federation extensions in the context of the W3C
working group has been focused on the description of the language grammar. In this
paper we complement this work with the formalization of the syntax and semantics of
these federation extensions of SPARQL 1.1, and with the definition of the constraints
that have to be considered in their use (which is currently not too restricted) in order to
be able to provide pragmatic implementations of query evaluators. As an extreme example of bad performance, we may imagine a query that uses the SERVICE operator with
a free variable to specify the SPARQL endpoint where the rest of the query has to be
evaluated. We may imagine that a na ve implementation may need to go through all existing SPARQL endpoints on the Web evaluating that query fragment before providing
a result, something that can be considered infeasible in practical terms. For our purpose,
we define the notions of service-boundedness and service-safeness, which ensure that
the SERVICE operator can be safely evaluated.

Besides, we implement the optimizations proposed in [11], using the notion of welldesigned patterns, which prove to be effective in the optimization of queries that contain
the OPTIONAL operator, the most costly operator in SPARQL [11,17]. This has also
important implications in the number of tuples being transferred and joined in federated
queries, and hence our implementation benefits from this.

As a result of our work, we have not only formalized these notions, but we have
also implemented a system that supports the current SPARQL 1.1 federation extensions and makes use of these optimizations. This system, SPARQL-DQP (which stands
for SPARQL Distributed Query Processing), is built on top of the OGSA-DAI and
OGSA-DQP infrastructure [3,10], what provides additional robustness to deal with
large amounts of data in distributed settings, supporting for example an indirect access mode that is normally used in the development of data-intensive workflows. We
have evaluated our system using a small benchmark of real SPARQL 1.1 queries from
the bioinformatics domain, and compared it with other similar systems, in some cases
adapting the queries to their own ad-hoc SPARQL extensions, so that the benefits of our
implementation can be illustrated.

With this work, we aim at advancing to the current state of the art hoping to include
it in the next versions of the SPARQL working drafts, and providing SPARQL-DQP as
one of the reference implementations of this part of the recommendation. We also hope
that the initial benchmark that we have defined can be extended and stabilized in order
to provide a good evaluation framework, complementing existing benchmarks.
Organization of the paper. In Section 2, we describe the syntax and semantics of the
SPARQL 1.1 federation extension. In Section 3, we introduce the notions of service-
safeness, which ensures that the SERVICE operator can be safely evaluated. In Section
4, we present some optimization techniques for the evaluation of the SPARQL 1.1 federation extension. Finally, in Section 5, we present our implementation as well as an
experimental evaluation of it.
?

?

?
2 Syntax and Semantics of the SPARQL 1.1 Federation Extension

In this section, we give an algebraic formalization of the SPARQL 1.1 federation extension over simple RDF, that is, RDF without RDFS vocabulary and literal rules. Our
starting point is the existing formalization of SPARQL described in [11], to which we
add the operators SERVICE and BINDINGS proposed in [12].

We introduce first the necessary notions about RDF (taken mainly from [11]). Assume there are pairwise disjoint infinite sets I, B, and L (IRIs [6], Blank nodes, and
Literals, respectively). Then a triple (s, p, o)  (I  B)  I  (I  B  L) is called
an RDF triple. In this tuple, s is the subject, p the predicate and o the object. An RDF
graph is a set of RDF triples. Moreover, assume the existence of an infinite set V of
variables disjoint from the above sets, and leave UNBOUND to be a reserve word that
does not belong to any of the sets mentioned previously.

2.1 Syntax of the Federation Extension

The official syntax of SPARQL [13] considers operators OPTIONAL, UNION,
FILTER, SELECT and concatenation via a point symbol (.), to construct graph pattern expressions. Operators SERVICE and BINDINGS are introduced in the SPARQL
1.1 federation extension, the former for allowing users to direct a portion of a query
to a particular SPARQL endpoint, and the latter for transferring results that are used
to constrain a query. The syntax of the language also considers { } to group patterns,
and some implicit rules of precedence and association. In order to avoid ambiguities
in the parsing, we follow the approach proposed in [11], and we first present the syntax of SPARQL graph patterns in a more traditional algebraic formalism, using operators AND (.), UNION (UNION), OPT (OPTIONAL), FILTER (FILTER) and
SERVICE (SERVICE), then we introduce the syntax of BINDINGS queries, which
use the BINDINGS operator (BINDINGS), and we conclude by defining the syntax
of SELECT queries, which use the SELECT operator (SELECT). More precisely, a
SPARQL graph pattern expression is defined recursively as follows:
(1) A tuple from (I  L  V )  (I  V )  (I  L  V ) is a graph pattern (a triple

pattern).

(2) If P1 and P2 are graph patterns, then expressions (P1 AND P2), (P1 OPT P2),

and (P1 UNION P2) are graph patterns.

(P FILTER R) is a graph pattern.

(3) If P is a graph pattern and R is a SPARQL built-in condition, then the expression
(4) If P is a graph pattern and a  (I  V ), then (SERVICE a P ) is a graph pattern.
Moreover, a SPARQL BINDINGS query is defined as follows:

(5) If P is a graph pattern, S is a nonempty list of pairwise distinct variables and
{A1, . . . , An} is a nonempty set of lists such that for every i  {1, . . . , n}, it holds
that Ai and S have the same length and each element in Ai belongs to (I  L 
{UNBOUND}), then (P BINDINGS S {A1, . . . , An}) is a BINDINGS query.
Finally, assuming that P is either a graph pattern or a BINDINGS query, let var(P ) be
the set of variables mentioned in P . Then a SPARQL SELECT query is defined as:

C. Buil-Aranda, M. Arenas, and O. Corcho

(6) If P is either a graph pattern or a BINDINGS query, and W is a set of variables

such that W  var(P ), then (SELECT W P ) is a SELECT query.

It is important to notice that the rules (1)(3) above were introduced in [11], while we
formalize in the rules (4)(6) the federation extension of SPARQL proposed in [12].
In the previous definition, we use the notion of built-in condition for the filter opera-
tor. A SPARQL built-in condition is constructed using elements of the set (I  L  V )
and constants, logical connectives (, , ), inequality symbols (<, , , >), the
equality symbol (=), unary predicates like bound, isBlank, and isIRI, plus other features (see [13] for a complete list). Due to the lack of space, we restrict in this paper
to the fragment of SPARQL where the built-in condition is a Boolean combination of
terms constructed by using = and bound, that is: (1) if ?X, ?Y  V and c  (I  L),
then bound(?X), ?X = c and ?X =?Y are built-in conditions, and (2) if R1 and R2
are built-in conditions, then (R1), (R1  R2) and (R1  R2) are built-in conditions.
It should be noticed that the results of the paper can be easily extended to the other
built-in predicates in SPARQL.

Let P be either a graph pattern or a BINDINGS query or a SELECT query. In the
rest of the paper, we use var(P ) to denote the set of variables occurring in P . Similarly,
for a built-in condition R, we use var(R) to denote the set of variables occurring in R.

2.2 Semantics of the Federation Extension

To define the semantics of SPARQL queries, we need to introduce some extra terminology from [11]. A mapping  from V to (I  B  L) is a partial function
 : V  (I  B  L). Abusing notation, for a triple pattern t we denote by (t) the
triple obtained by replacing the variables in t according to . The domain of , denoted
by dom(), is the subset of V where  is defined. Two mappings 1 and 2 are compatible when for all ?X  dom(1)  dom(2), it is the case that 1(?X) = 2(?X),
i.e. when 1  2 is also a mapping.

Let 1 and 2 be sets of mappings. Then the join of, the union of, the difference

between and the left outer-join between 1 and 2 are defined as follows [11]:
1  2 = {1  2 | 1  1, 2  2 and 1, 2 are compatible mappings},
1  2 = { |   1 or   2},
1  2 = {  1 | for all 
1 2 = (1  2)  (1  2).

are not compatible},

  2,  and 
?

?

?
Next we use the preceding operators to give semantics to graph pattern expressions,
BINDINGS queries and SELECT queries. More specifically, we define this semantics
as a function  G, which takes as input any of these types of queries and returns a
set of mappings. In this definition, we assume given a partial function ep from the set
I of IRIs such that for every c  I, if ep(c) is defined, then ep(c) is an RDF graph.
Intuitively, function ep is defined for an element c  I (c  dom(ep)) if and only if c
is the IRI of a SPARQL endpoint, and ep(c) is the default RDF graph of that endpoint1.

1 For simplicity, we only assume a single (default) graph and no named graphs per remote

SPARQL endpoint.
?

?

?
Moreover, in this definition  represents the mapping with empty domain (which is
compatible with any other mapping).

The evaluation of a graph pattern P over an RDF graph G, denoted by P G, is defined recursively as follows (due to the lack of space, we refer the reader to the extended
version of the paper for the definition of the semantics of the FILTER operator):
(1) If P is a triple pattern t, then P G = { | dom() = var(t) and (t)  G}.
(2) If P is (P1 AND P2), then P G = P1G  P2G.
(3) If P is (P1 OPT P2), then P G = P1G
P2G.
(4) If P is (P1 UNION P2), then P G = P1G  P2G.
(5) If P is (SERVICE c P1) with c  I, then
?

?

?
P G =

P1ep(c)
{}

if c  dom(ep)
otherwise
?

?

?
cI

(6) If P is (SERVICE ?X P1) with ?X  V , then P G is equal to:

 | there exists 

  (SERVICE c P1)G s.t. dom() = (dom(
?

?

?
)  {?X}),
?

?

?
(?X) = c and (?Y ) = 

(?Y ) for every ?Y  dom(
?

?

?
)
?

?

?
Moreover, the semantics of BINDINGS queries is defined as follows. Given a list S =
[?X1, . . . , ?X] of pairwise distinct variables, where   1, and a list A = [a1, . . . , a]
of values from (I  L  {UNBOUND}), let S,A be a mapping with domain {?Xi |
i  {1, . . . , } and ai  (I  L)} and such that S,A(?Xi) = ai for every ?Xi 
dom(S,A). Then
(7) If P = (P1 BINDINGS S {A1, . . . , An}) is a BINDINGS query:

P G = P1G  {S,A1, . . . , S,An

}.

Finally, the semantics of SELECT queries is defined as follows. Given a mapping  :
V  (I  B  L) and a set of variables W  V , the restriction of  to W , denoted by
|W , is a mapping such that dom(|W ) = (dom()  W ) and |W (?X) = (?X) for
every ?X  (dom()  W ). Then
(8) If P = (SELECT W P1) is a SELECT query: P G = {|W
It is important to notice that the rules (1)(4) above were introduced in [11], while we
propose in the rules (5)(8) a semantics for the operators SERVICE and BINDINGS
introduced in [12]. Intuitively, if c  I is the IRI of a SPARQL endpoint, then the idea
behind the definition of (SERVICE c P1) is to evaluate query P1 in the SPARQL endpoint specified by c. On the other hand, if c  I is not the IRI of a SPARQL endpoint,
then (SERVICE c P1) leaves unbounded all the variables in P1, as this query cannot
be evaluated in this case. This idea is formalized by making  the only mapping in the
evaluation of (SERVICE c P1) if c  dom(ep). In the same way, (SERVICE ?X P1)

|   P1G}.

C. Buil-Aranda, M. Arenas, and O. Corcho

is defined by considering all the possible IRIs for the variable ?X, that is, all the values c  I. In fact, (SERVICE ?X P1) is defined as the union of the evaluation of the
graph patterns (SERVICE c P1) for the values c  I, but also storing in ?X the IRIs
from where the values of the variables in P1 are coming from. Finally, the idea behind
the definition of (P1 BINDINGS S {A1, . . . , An}) is to constrain the values of the
variables in S to the values specified in A1, . . ., An.

Example 1. Assume that G is an RDF graph that uses triples of
the form
(a, service address, b) to indicate that a SPARQL endpoint with name a is located at
the IRI b. Moreover, let P be the following SPARQL query:
?

?

?
SELECT {?X, ?N, ?E}
?

?

?
(?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E))
?

?

?
BINDINGS [?N ] {[ John ], [ Peter ]}
?

?

?
Query P is used to compute the list of names and email addresses that can be retrieved
from the SPARQL endpoints stored in an RDF graph. In fact, if   P G, then (?X)
is the name of a SPARQL endpoint stored in G, (?N) is the name of a person stored
in that SPARQL endpoint and (?E) is the email address of that person. Moreover,
the operator BINDINGS in this query is used to filter the values of the variable ?N .

Specifically, if   P G, then (?N) is either John or Peter.
The goal of the rules (5)(8) is to define in an unambiguous way what the result of
evaluating an expression containing the operators SERVICE and BINDINGS should
be. As such, these rules should not be considered as an implementation of the language.
In fact, a direct implementation of the rule (6), that defines the semantics of a pattern of
the form (SERVICE ?X P1), would involve evaluating a particular query in every possible SPARQL endpoint, which is obviously infeasible in practice. In the next section,
we face this issue and, in particular, we introduce a syntactic condition on SPARQL
queries that ensures that a pattern of the form (SERVICE ?X P1) can be evaluated by
only considering a finite set of SPARQL endpoints, whose IRIs are actually taken from
the RDF graph where the query is being evaluated.

3 On Evaluating the SERVICE Operator

As we pointed out in the previous section, the evaluation of a pattern of the form
(SERVICE ?X P ) is infeasible unless the variable ?X is bound to a finite set of IRIs.
This notion of boundedness is one of the most significant and unclear concepts in the
SPARQL federation extension. In fact, the current version of the specification [12] only
specifies that a variable ?X in a pattern of the form (SERVICE ?X P ) must be bound,
but without providing a formal definition of what that means. Here we provide a formalization of this concept, studying the complexity issues associated with it.
?

?

?
3.1 The Notion of Boundedness

In Example 1, we present a SPARQL query containing a pattern (SERVICE ?Y
(?N, email, ?E)). Given that variable ?Y is used to store the address of a remote
SPARQL endpoint to be queried, it is important to assign a value to ?Y prior to the evaluation of the SERVICE pattern. In the case of the query in Example 1, this needs of a
simple strategy: given an RDF graph G, first compute (?X, service address, ?Y )G,
and then for every  in this set, compute (SERVICE a (?N, email, ?E))G with
a = (?Y ). More generally, SPARQL pattern (SERVICE ?Y (?N, email, ?E)) can
be evaluated in this case as only a finite set of values from the domain of G need to be
considered as the possible values of ?Y . This idea naturally gives rise to the following
notion of boundedness for the variables of a SPARQL query. In the definition of this
notion, dom(G) refers to the domain of G, that is, the set of elements from (I  B  L)
that are mentioned in G, and dom(P ) refers to the set of elements from (I  L) that are
mentioned in P .
Definition 1 (Boundedness). Let P be a SPARQL query and ?X  var(P ). Then ?X
is bound in P if one of the following conditions holds:

 P is either a graph pattern or a BINDINGS query, and for every RDF graph G
and mapping   P G, it holds that ?X  dom() and (?X)  (dom(G) 
dom(P )).

 P is a SELECT query (SELECT W P1) and ?X is bound in P1.

The BINDINGS operator can make a variable ?X in a query P to be bound by assigning to it a fixed set of values. Given that these values are not necessarily mentioned in
the RDF graph G where P is being evaluated, the previous definition first imposes the
condition that ?X  dom(), and then not only considers the case (?X)  dom(G)
but also the case (?X)  dom(P ). As an example of the above definition, we note
that variable ?Y is bound in the graph pattern

P1 = ((?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E))),

as for every RDF graph G and mapping   P1G, we know that ?Y  dom()
and (?Y )  dom(G). Moreover, we also have that variable ?Y is bound in
(SELECT {?X, ?N, ?E} P1) as ?Y is bound in graph pattern P1.

A natural way to ensure that a SPARQL query P can be evaluated in practice is by
imposing the restriction that for every sub-pattern (SERVICE ?X P1) of P , it holds
that ?X is bound in P . However, in the following theorem we show that such a condition
is undecidable and, thus, a SPARQL query engine would not be able to check it in order
to ensure that a query can be evaluated.
Theorem 1. The problem of verifying, given a SPARQL query P and a variable ?X 
var(P ), whether ?X is bound in P is undecidable.

The fact that the notion of boundedness is undecidable prevents one from using it as
a restriction over the variables in SPARQL queries. To overcome this limitation, we
introduce here a syntactic condition that ensures that a variable is bound in a pattern
and that can be efficiently verified.

C. Buil-Aranda, M. Arenas, and O. Corcho

Definition 2 (Strong boundedness). Let P be a SPARQL query. Then the set of
strongly bound variables in P , denoted by SB(P ), is recursively defined as follows:

 if P = t, where t is a triple pattern, then SB(P ) = var(t);
 if P = (P1 AND P2), then SB(P ) = SB(P1)  SB(P2);
 if P = (P1 UNION P2), then SB(P ) = SB(P1)  SB(P2);
 if P = (P1 OPT P2) or P = (P1 FILTER R), then SB(P ) = SB(P1);
 if P = (SERVICE c P1), with c  I, or P = (SERVICE ?X P1), with ?X  V ,
then SB(P ) = ;
 if P = (P1 BINDINGS S {A1, . . . , An}), then SB(P ) = SB(P1)  {?X |
?X is in S and for every i  {1, . . . , n}, it holds that ?X  dom(S,Ai)}.
 if P = (SELECT W P1), then SB(P ) = (W  SB(P1)).
The previous definition recursively collects from a SPARQL query P a set of variables that are guaranteed to be bound in P . For example, if P is a triple pattern t, then
SB(P ) = var(t) as one knows that for every variable ?X  var(t) and for every RDF
graph G, if   tG, then ?X  dom() and (?X)  dom(G). In the same way,
if P = (P1 AND P2), then SB(P ) = SB(P1)  SB(P2) as one knows that if ?X
is bound in P1 or in P2, then ?X is bound in P . As a final example, notice that if
P = (P1 BINDINGS S {A1, . . . , An}) and ?X is a variable mentioned in S such
that ?X  dom(S,Ai) for every i  {1, . . . , n}, then ?X  SB(P ). In this case, one
knows that ?X is bound in P since P G = P1G  {S,A1, . . . , S,An
} and ?X is in
the domain of each one of the mappings S,Ai, which implies that (?X)  dom(P )
for every   P G. In the following proposition, we formally show that our intuition
about SB(P ) is correct, in the sense that every variable in this set is bound in P .
Proposition 1. For every SPARQL query P and variable ?X  var(P ), if ?X 
SB(P ), then ?X is bound in P .
Given a SPARQL query P and a variable ?X  var(P ), it can be efficiently verified
whether ?X is strongly bound in P . Thus, a natural and efficiently verifiable way to ensure that a SPARQL query P can be evaluated in practice is by imposing the restriction
that for every sub-pattern (SERVICE ?X P1) of P , it holds that ?X is strongly bound
in P . However, this notion still needs to be modified in order to be useful in practice, as
shown by the following examples.

Example 2. Assume first that P1 is the following graph pattern:

P1 = ((?X, service description, ?Z) UNION

((?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E)))).

is, either ?X and ?Z store the name of a SPARQL endpoint and a de-
That
scription of its functionalities, or ?X and ?Y store the name of a SPARQL endpoint and the IRI where it is located (together with a list of names and email
addresses retrieved from that location). Variable ?Y is neither bound nor strongly
bound in P1. However, there is a simple strategy that ensures that P1 can be
evaluated over an RDF graph G: first compute (?X, service description, ?Z)G,
then compute (?X, service address, ?Y )G, and finally for every  in the set
?

?

?
(?X, service address, ?Y )G, compute (SERVICE a (?N, email, ?E))G with a =
(?Y ). In fact, the reason why P1 can be evaluated in this case is that ?Y is
bound (and strongly bound) in the sub-pattern ((?X, service address, ?Y ) AND
(SERVICE ?Y (?N, email, ?E))) of P1.

As a second example, assume that G is an RDF graph that uses triples of the form
(a1, related with, a2) to indicate that the SPARQL endpoints located at the IRIs a1 and
a2 store related data. Moreover, assume that P2 is the following graph pattern:

P2 = ((?U1, related with, ?U2) AND

(SERVICE ?U1 ((?N, email, ?E) OPT (SERVICE ?U2 (?N, phone, ?F ))))).

When this query is evaluated over the RDF graph G, it returns for every tuple
(a1, related with, a2) in G, the list of names and email addresses that that can be retrieved from the SPARQL endpoint located at a1, together with the phone number for
each person in this list for which this data can be retrieved from the SPARQL endpoint
located at a2 (recall that graph pattern (SERVICE ?U2 (?N, phone, ?F )) is nested inside the first SERVICE operator in P2). To evaluate this query over an RDF graph, first
it is necessary to determine the possible values for variable ?U1, and then to submit the
query ((?N, email, ?E) OPT (SERVICE ?U2 (?N, phone, ?F ))) to each one of the
endpoints located at the IRIs stored in ?U1. In this case, variable ?U2 is bound (and
also strongly bound) in P2. However, this variable is not bound in the graph pattern
((?N, email, ?E) OPT (SERVICE ?U2 (?N, phone, ?F ))), which has to be evaluated
in some of the SPARQL endpoints stored in the RDF graph where P2 is being evalu-
ated, something that is infeasible in practice. Notice that the difficulties in evaluating P2
are caused by the nesting of SERVICE operators (more precisely, by the fact that P2
has a sub-pattern of the form (SERVICE ?X1 Q1), where Q1 has in turn a sub-pattern

of the form (SERVICE ?X2 Q2) such that ?X2 is bound in P2 but not in Q1).

In the following section, we use the concept of strongly boundedness to define a notion
that ensures that a SPARQL query containing the SERVICE operator can be evaluated
in practice, and which takes into consideration the ideas presented in Example 2.

3.2 The Notion of Service-Safeness: Considering Sub-patterns and Nested

Service Operators

The goal of this section is to provide a condition that ensures that a SPARQL query
containing the SERVICE operator can be safely evaluated . To this end, we first need
to introduce some terminology. Given a SPARQL query P , define T (P ) as the parse
tree of P . In this tree, every node corresponds to a sub-pattern of P . An example of
a parse tree of a pattern Q is shown in Figure 1. In this figure, u1, u2, u3, u4, u5, u6
are the identifiers of the nodes of the tree, which are labeled with the sub-patterns of
Q. It is important to notice that in this tree we do not make any distinction between
the different operators in SPARQL, we just store the structure of the sub-patterns of a
SPARQL query.
Tree T (P ) is used to define the notion of service-boundedness, which extends the
concept of boundedness, introduced in the previous section, to consider variables that

C. Buil-Aranda, M. Arenas, and O. Corcho

u1 : ((?Y, a, ?Z) UNION ((?X, b, c) AND (SERVICE ?X (?Y, a, ?Z))))

u2 : (?Y, a, ?Z)

u3 : ((?X, b, c) AND (SERVICE ?X (?Y, a, ?Z)))

u4 : (?X, b, c)

u5 : (SERVICE ?X (?Y, a, ?Z))

Fig. 1. Parse tree T (Q) for the graph pattern Q = ((?Y, a, ?Z) UNION ((?X, b, c) AND
(SERVICE ?X (?Y, a, ?Z))))

u6 : (?Y, a, ?Z)

are bound inside sub-patterns and nested SERVICE operators. It should be noticed that
these two features were identified in the previous section as important for the definition
of a notion of boundedness (see Example 2).

Definition 3 (Service-boundedness). A SPARQL query P is service-bound if for every
node u of T (P ) with label (SERVICE ?X P1), it holds that: (1) there exists a node v
of T (P ) with label P2 such that v is an ancestor of u in T (P ) and ?X is bound in P2;
(2) P1 is service-bound.

For example, query Q in Figure 1 is service-bound. In fact, condition (1) of Definition 3 is satisfied as u5 is the only node in T (Q) having as label a SERVICE
graph pattern, in this case (SERVICE ?X (?Y, a, ?Z)), and for the node u3, it holds
that: u3 is an ancestor of u5 in T (P ), the label of u3 is P = ((?X, b, c) AND
(SERVICE ?X (?Y, a, ?Z))) and ?X is bound in P . Moreover, condition (2) of Definition 3 is satisfied as the sub-pattern (?Y, a, ?Z) of the label of u5 is also service-bound.
The notion of service-boundedness captures our intuition about the condition that a
SPARQL query containing the SERVICE operator should satisfy. Unfortunately, the
following theorem shows that such a condition is undecidable and, thus, a query engine
would not be able to check it in order to ensure that a query can be evaluated.

Theorem 2. The problem of verifying, given a SPARQL query P , whether P is servicebound is undecidable.

As for the case of the notion of boundedness, the fact that the notion of serviceboundedness is undecidable prevents one from using it as a restriction over the variables
used in SERVICE calls. To overcome this limitation, we replace the restriction that the
variables used in SERVICE calls are bound by the decidable restriction that they are
strongly bound. In this way, we obtain a syntactic condition over SPARQL patterns that
ensures that they are service-bound, and which can be efficiently verified.

Definition 4 (Service-safeness). A SPARQL query P is service-safe if for every node
u of T (P ) with label (SERVICE ?X P1), it holds that: (1) there exists a node v of
T (P ) with label P2 such that v is an ancestor of u in T (P ) and ?X  SB(P2); (2) P1
is service-safe.

Proposition 2. If a SPARQL query P is service-safe, then P is service-bound.
?

?

?
The notion of service-safeness is used in our system to verify that a SPARQL pattern
can be evaluated in practice. We conclude this section by pointing out that it can be
efficiently verified whether a SPARQL query P is service-safe, by using a bottom-up
approach over the parse tree T (P ) of P .

4 Optimizing the Evaluation of the OPTIONAL Operator in

SPARQL Federated Queries

If a SPARQL query Q including the SERVICE operator has to be evaluated in a
SPARQL endpoint A, then some of the sub-queries of Q may have to be evaluated
in some external SPARQL endpoints. Thus, the problem of optimizing the evaluation
of Q in A, and, in particular, the problem of reordering Q in A to optimize this evalu-
ation, becomes particularly relevant in this scenario, as in some cases one cannot rely
on the optimizers of the external SPARQL endpoints. Motivating by this, we present in
this section some optimization techniques that extend the techniques presented in [11]
to the case of SPARQL queries using the SERVICE operator, and which can be applied
to a considerable number of SPARQL federated queries.

4.1 Optimization via Well-Designed Patterns

In [11,17], the authors study the complexity of evaluating the fragment of SPARQL
consisting of the operators AND, UNION, OPT and FILTER. One of the conclusions
of these papers is that the main source of complexity in SPARQL comes from the use
of the OPT operator. In light of these results, it was introduced in [11] a fragment
of SPARQL that forbids a special form of interaction between variables appearing in
optional parts, which rarely occurs in practice. The patterns in this fragment, which are
called well-designed patterns [11], can be evaluated more efficiently and are suitable for
reordering and optimization. In this section, we extend the definition of the notion of
being well-designed to the case of SPARQL patterns using the SERVICE operator, and
prove that the reordering rules proposed in [11], for optimizing the evaluation of welldesigned patterns, also hold in this extension. The use of these rules allows to reduce
the number of tuples being transferred and joined in federated queries, and hence our
implementation benefits from this as shown in Section 5.

Let P be a graph pattern constructed by using the operators AND, OPT, FILTER
and SERVICE, and assume that P satisfies the safety condition that for every subpattern (P1 FILTER R) of P , it holds that var(R)  var(P1). Then, by following [11],
 = (P1 OPT P2) of P and
we say that P is well-designed if for every sub-pattern P

for every variable ?X occurring in P : If ?X occurs both inside P2 and outside P
,
then it also occurs in P1. All the graph patterns given in the previous sections are well-
designed. On the other hand, the following pattern P is not well-designed:

((?X, nickname, ?Y ) AND (SERVICE c ((?X, email, ?U) OPT (?Y, email, ?V )))),
 = (P1 OPT P2) of P with P1 = (?X, email, ?U) and
in the triple

as for the sub-pattern P
P2 = (?Y, email, ?V )), we have that ?Y occurs in P2 and outside P
?

?

?
C. Buil-Aranda, M. Arenas, and O. Corcho

pattern (?X, nickname, ?Y ), but it does not occur in P1. Given an RDF graph G,
graph pattern P retrieves from G a list of people with their nicknames, and retrieves
from the SPARQL endpoint located at the IRI c the email addresses of these people
and, optionally, the email addresses associated to their nicknames. What is unnatural about this graph pattern is the fact that (?Y, email, ?V ) is giving optional information for (?X, nickname, ?Y ), but in P appears as giving optional information for
(?X, name, ?U). In fact, it could happen that some of the results retrieved by using the
triple pattern (?X, nickname, ?Y ) are not included in the final answer of P , as the value
of variable ?Y in these intermediate results could be incompatible with the values for
this variable retrieved by using the triple pattern (?Y, email, ?V ).

In the following proposition, we show that well-designed patterns including the

SERVICE operator are suitable for reordering and, thus, for optimization.

Proposition 3. Let P be a well-designed pattern and P
using one of the following reordering rules:
?

?

?
a pattern obtained from P by

((P1 OPT P2) FILTER R)  ((P1 FILTER R) OPT P2),

(P1 AND (P2 OPT P3))  ((P1 AND P2) OPT P3),
((P1 OPT P2) AND P3)  ((P1 AND P3) OPT P2).
?

?

?
Then P

is a well-designed pattern equivalent to P .

The proof of this proposition is a simple extension of the proof of Proposition 4.10
in [11]. In the following section, we show that the use of these rules can have a considerable impact in the cost of evaluating graph patterns.

5 Implementation of SPARQL-DQP and Well-Designed Patterns

Optimization

In this section, we describe how we implemented and evaluated the optimization techniques presented in the previous section. In particular, we demonstrate that they effectively decrease the processing time of SPARQL 1.1 federated queries.

5.1 Implementation: SPARQL-DQP

We have implemented the rewriting rules described in Section 4.1 in SPARQL-DQP
[5], together with a bottom up algorithm for checking the condition of being well-
designed. SPARQL-DQP is a query evaluation system built on top of OGSA-DAI [3]
and OGSA-DQP [10]. OGSA-DAI is a generic service-based data access, integration,
transformation and delivery framework that allows executing data-centric workflows
involving heterogeneous data resources. OGSA-DAI is integrated in Apache Tomcat
and within the Globus Toolkit, and is used in OMII-UK, the UK e-Science platform.
OGSA-DQP is the Distributed Query Processing extension of OGSA-DAI, which access distributed OGSA-DAI data resources and provides parallelization mechanisms.
SPARQL-DQP [5] extends this framework with new SPARQL parsers, logical query
plan builders, operators and optimizers for distributed query processing. The main reason for selecting this framework is that it provides built-in infrastructure to support DQP
?

?

?
and enables handling large datasets and tuple streams, which may result from the execution of queries in different query services and data sources. The low level technical
details of our implementation can be found in [5].

5.2 Evaluation

In our evaluation, we compare the results and performance of our system with
other similar systems that provide some support for SPARQL query federation. Cur-
rently, the engines supporting the official SPARQL 1.1 federation extension are:
DARQ [14], Networked Graphs [15] and ARQ, which is available via an online web service (http://www.sparql.org/) as well as a library for Jena
(http://jena.sourceforge.net/). Other system that supports distributed
RDF querying is presented in [18]. We do not consider this system here as it uses the
query language SeRQL instead of SPARQL.

The objective of our evaluation is to show first that we can handle SPARQL queries
that comply with the federated extension, and second that the optimization techniques
proposed in Section 4.1 actually reduce the time needed to process queries. We have
checked for existing SPARQL benchmarks like the Berlin SPARQL Benchmark [4],
SP2Bench [16] and the benchmark proposed in [7]. Unfortunately for our purposes, the
first two are not designed for a distributed environment, while the third one is based
on a federated scenario but is not as comprehensive as the Berlin SPARQL Benchmark
and SP2Bench. Thus, we decided to base our evaluation on some queries from the life
sciences domain, similar to those in [7] but using a base query and increasing its complexity like in [4]. These queries are real queries used by Bio2RDF experts.

Datasets description. The Bio2RDF datasets contains 2,3 billion triples organized
around 40 datasets with sometimes overlapping information. The Bio2RDF datasets
that we have used in our benchmark are: Entrez Gene (13 million triples, stored in the
local endpoint sparql-pubmed), Pubmed (797 million triples), HHPID (244,021 triples)
and MeSH (689,542 triples, stored in the local endpoint sparql-mesh). One of the practical problems that these benchmarks have is that public SPARQL endpoints normally
restrict the amount of results that they provide. To overcome this limitation we installed
Entrez Gene and MeSH in servers without these restrictions. We also divided them in
files of 300,000 triples, creating endpoints for each one of them.

Queries used in the evaluation. We used 7 queries in our evaluation. The query structure follows the following path: using the Pubmed references obtained from the Entrez
gene dataset, we access the Pubmed endpoint (queries Q1 and Q2). In these queries,
we retrieve information about genes and their references in the Pubmed dataset. From
Pubmed we access the information in the National Library of Medicines controlled
vocabulary thesaurus (queries Q3 and Q4), stored at MeSH endpoint, so we have more
complete information about such genes. Finally, to increase the data retrieved by our
queries we also access the HHPID endpoint (queries Q5, Q6 and Q7), which is the
knowledge base for the HIV-1 protein. The queries, in increasing order of complexity,
can be found at http://www.oeg-upm.net/files/sparql-dqp/. Next we
show query Q4 to give the reader an idea of the type of queries that we are considering:

C. Buil-Aranda, M. Arenas, and O. Corcho

SELECT ?pubmed ?gene1 ?mesh ?descriptor ?meshReference

{

{SERVICE <http://127.0.0.1:2020/sparql-pubmed> {

?gene1 <http://bio2rdf.org/geneid_resource:pubmed_xref> ?pubmed .}}.

{SERVICE <http://pubmed.bio2rdf.org/sparql> {

?pubmed <http://bio2rdf.org/pubmed_resource:meshref> ?mesh .
?mesh

<http://bio2rdf.org/pubmed_resource:descriptor> ?descriptor .}}.

OPTIONAL { SERVICE <http://127.0.0.1:2021/sparql-mesh> {

?meshReference <http://www.w3.org/2002/07/owl#sameAs> ?descriptor .}}.

}

Results. Our evaluation was done in an Amazon EC2 instance. The instance has 2
cores and 7.5 GB of memory run by Ubuntu 10.04. The data used in this evaluation,
together with the generated query plans and the original queries in Java formatting, can
be found at http://www.oeg-upm.net/files/sparql-dqp/. The results of
our evaluation are shown in the following table:

Query

Not optimized
SPARQL-DQP

Optimized
SPARQL-DQP

NetworkedGraphs

Q1
Q2
Q3
Q4
Q5
Q6
Q7

79,000ms.
64,179ms.
134,324ms.
152,559ms.
146,575ms.
322,792ms.
350,554ms.

79,000ms.
64,179ms.
134,324ms.
136,482ms.
146,575ms.
79,178ms.
83,153ms.

10+ min.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.

10+ min.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.

440,296ms.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.
10+ min.

A first clear advantage of our implementation is the ability to use asynchronous calls
facilitated by the use of indirect access mode, what means that we do not get time out
in any of the queries. This time out happens when accessing an online distributed query
processing like in the case of ARQ (www.sparql.org/query). It is important to
note that the ability to handle this type of queries is essential for many types of dataintensive applications, such as those based on Bio2RDF. Data transfer also plays a key
role in query response times. For example, in some queries the local query engine received 150,000 results from Entrez gene, 10,000 results from Pubmed, 23,841 results
from MeSH and 10,000 results from HHPID. The implemented optimizations are less
noticeable when the amount of transferred data is fewer.

It is possible to observe three different sets of results from this preliminary evalua-
tion. The first set (Q1Q3 and Q5) are those that are not optimized because the reordering rules in Section 4.1 are not applicable. The second query group (Q4) represents
the class of queries that can be optimized using our approach, but where the difference is not too relevant, because the less amount of transferred data. The last group
of queries (Q6Q7) shows a clear optimization when using the well-designed patterns
rewriting rules. For example, in query 6 the amount of transferred data varies from a
join of 150, 000  10, 000 tuples to a join of 10, 000  23, 841 tuples (using Entrez,
Pubmed and MeSH endpoints), which highly reduces the global processing time of the
query. Regarding the comparison with other systems, they do not properly handle these
amounts of data. We represent as 10+ min. those queries that need more than 10 minutes
to be answered.
?

?

?
In summary, we have shown that our implementation provides better results than
other similar systems. Besides, we have also shown that our implementation, which benefits from an indirect access mode, can be more appropriate to deal with large datasets.

Acknowledgments. We thank the anonymous referees, the OGSA-DAI team (spe-
cially Ally Hume), Marc-Alexandre Nolin, Jorge P erez and Axel Polleres for their help
with this work. This research was supported by ADMIRE project FP7 ICT-215024 and
FONDECYT grant 1090565.
