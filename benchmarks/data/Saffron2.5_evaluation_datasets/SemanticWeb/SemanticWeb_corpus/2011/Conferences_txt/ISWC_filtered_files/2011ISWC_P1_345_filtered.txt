Capturing Instance Level Ontology Evolution

for DL-Lite

Evgeny Kharlamov and Dmitriy Zheleznyakov

KRDB Research Centre, Free University of Bozen-Bolzano, Italy

last_name@inf.unibz.it

Abstract. Evolution of Knowledge Bases (KBs) expressed in Description Logics (DLs) proved its importance. Recent studies of the topic mostly focussed on
model-based approaches (MBAs), where an evolution (of a KB) results in a set of
models. For KBs expressed in tractable DLs, such as DL-Lite, it was shown that
the evolution suffers from inexpressibility, i.e., the result of evolution cannot be
expressed in DL-Lite. What is missing in these studies is understanding: in which
DL-Lite fragments evolution can be captured, what causes the inexpressibility,
which logics is sufficient to express evolution, whether and how one can approximate it in DL-Lite. This work provides some understanding of these issues for
eight of MBAs which cover the case of both update and revision. We found what
causes inexpressibility and isolated a fragment of DL-Lite where evolution is ex-
pressible. For this fragment we provided polynomial-time algorithms to compute
evolution results. For the general case we proposed techniques (based on what we
called prototypes) to capture DL-Lite evolution corresponding to a well-known
Winsletts approach in a DL SHOIQ (which is subsumed by OWL 2 DL). We
also showed how to approximate this evolution in DL-Lite.

1 Introduction

Description Logics (DLs) provide excellent mechanisms for representing structured
knowledge by means of Knowledge Bases (KBs) K that are composed of two compo-
nents: TBox (describes intensional or general knowledge about an application domain)
and ABox (describes facts about individual objects). DLs constitute the foundations for
various dialects of OWL, the Semantic Web ontology language.

Traditionally DLs have been used for modeling static and structural aspects of application domains [1]. Recently, however, the scope of KBs has broadened, and they
are now used also for providing support in the maintenance and evolution phase of information systems. This makes it necessary to study evolution of Knowledge Bases [2],
where the goal is to incorporate new knowledge N into an existing KB K so as to take
into account changes that occur in the underlying application domain. In general, N
is represented by a set of formulas denoting properties that should be true after K has
evolved, and the result of evolution, denoted K  N , is also intended to be a set of for-
mulas. In the case where N interacts with K in an undesirable way, e.g., by causing the
KB or relevant parts of it to become unsatisfiable, N cannot be simply added to the KB.
Instead, suitable changes need to be made in K so as to avoid this undesirable interac-
tion, e.g., by deleting parts of K conflicting with N . Different choices for changes are
possible, corresponding to different approaches to semantics for KB evolution [3,4,5].

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 321337, 2011.
c Springer-Verlag Berlin Heidelberg 2011

E. Kharlamov and D. Zheleznyakov

An important group of approaches to evolution semantics, that we focus in this
paper, is called model-based (MBAs). Under MBAs the result of evolution K  N is
a set of models of N that are minimally distanced from models of K. Depending on
what the distance between models is and how to measure it, eight different MBAs were
introduced (see Section 2.2 for details). Since K  N is a set of models, while K and
N are logical theories, it is desirable to represent K  N as a logical theory using the
same language as for K and N . Thus, looking for representations of K  N is the main
challenge in studies of evolution under MBAs. When K and N are propositional the-
ories, representing K  N is well understood [5], while it becomes dramatically more
complicated as soon as K and N are first-order, e.g., DL KBs [6].
Model based evolution of KBs where K and N are written in a language of the
DL-Lite family [7] has been recently extensively studied [6,8,9]. The focus on DLLite is not surprising since it is the basis of OWL 2 QL, a tractable OWL 2 profile.
It has been shown that for every of the eight MBAs one can find DL-Lite K and N
such that K  N cannot be expressed in DL-Lite [10,11], i.e., DL-Lite is not closed
under MBA evolution. This phenomenon was also noted in [6,10] for some of the eight
semantics. What is missing in all these studies of evolution for DL-Lite is understanding
of

(1) DL-Lite wrt evolution: What DL-Lite fragments are closed under MBAs? What DL-

Lite formulas are in charge of inexpressibility?

(2) Evolution wrt DL-Lite : Is it possible and how to capture evolution of DL-Lite KBs
(3) Approximation of evolution results: For DL-Lite KB K and an ABox N , is it

in richer logics? What are these logics?
possible and how to do good approximations of K  N in DL-Lite?

In this paper we study the problems (1)-(3) for so-called ABox evolution, i.e., N
is a new ABox and the TBox of K should remain the same after the evolution.
ABox evolution is important for areas, e.g., artifact-centered service interoperation (http://www.acsi-project.eu/), where the structural knowledge (TBox)
is well crafted and stable, while (ABox) facts about individuals may get changed. These
ABox changes should be reflected in KBs in a way that the TBox is not affected. Our
study covers both the case of ABox updates and ABox revision [4].

The contributions of the paper are: We provide relationships between MBAs for
DL-LiteR by showing which approaches subsume each other (Section 3). We introduce DL-LiteprR , a restriction on DL-LiteR where disjointness of concepts with role
projections is forbidden. We show that DL-LiteprR is closed under most of MBA evolutions and provide polynomial-time algorithms to compute (representations of) K  N
(Section 4). For DL-LiteR we focus on an important MBA corresponding to a well accepted Winsletts semantics and show how to capture K  N for this semantics in a DL
SHOIQ (Section 5). We show what combination of assertions in T together with N
can lead to inexpressibility of (T ,A)N in DL-LiteR (Section 5.1). For the case when
K  N is not expressible in DL-LiteR we study how to approximate it in DL-LiteR
(Section 5.4).
?

?

?
2 Preliminaries

2.1 DL-LiteR



.(a, a

)  R

of , and to R a binary relation R

, (R)I = {a | a
?

?

?
), of P (a, b) if (a, b)  P

and P (a, b)  I iff (a, b)  P

I}, and (P
I}. We assume that  contains the constants and that c

We introduce some basic notions of DLs, (see [1] for more details). We consider a
logic DL-LiteR of DL-Lite family of DLs [7,12]. DL-LiteR has the following constructs for (complex) concepts and roles: (i) B ::= A | R, (ii) C ::= B | B,
(iii) R ::= P | P
, where A and P stand for an atomic concept and role, respectively,
which are just names. A knowledge base (KB) K = (T ,A) is compounded of two sets
of assertions: TBox T , and ABox A. DL-LiteR TBox assertions are concept inclusion
assertions of the form B  C and role inclusion assertions R1  R2, while ABox
assertions are membership assertions of the form A(a), A(a), and R(a, b). The active
domain of K, denoted adom(K), is the set of all constants occurring in K. In Section 5
we will also talk about a DL SHOIQ [1] while we do not define it here due to space
limit.
The semantics of DL-Lite KBs is given in the standard way, using first order inter-
pretations, all over the same countable domain . An interpretation I is a function I
over  in
that assigns to each C a subset C
a way that (B)I =  \ B
)I =
{(a2, a1) | (a1, a2)  P
I = c
(we adopt standard names). Alternatively, we view interpretations as sets of atoms
and say that A(a)  I iff a  A

. An interpretation I is a model of a membership assertion A(a) (resp., A(a)) if a  A

(resp., a / A

?

?

?
2 .

As usual, we use I |= F to denote that I is a model of an assertion F , and I |= K
denotes that I |= F for each F in K. We use Mod(K) to denote the set of all models
of K. A KB is satisfiable if it has at least one model. The DL-Lite family has nice computational properties, for example, KB satisfiability has polynomial-time complexity in
the size of the TBox and logarithmic-space in the size of the ABox [12,13]. We use
in the standard sense. An ABox A T -entails an ABox A
entailment on KBs K |= K
,
denoted A |=T A
, denoted A T A
, if
A |=T A
and A |=T A.
The deductive closure of a TBox T , denoted cl(T ), is the set of all TBox assertions
F such that T |= F . For satisfiable KBs K = (T ,A), a full closure of A (wrt T ),
denoted fclT (A), is the set of all membership assertions f (both positive and negative)
over adom(K) such that A |=T f . In DL-LiteR both cl(T ) and fclT (A) are computable
in time quadratic in, respectively, |T |, i.e., the number of assertions of T , and |T 
A|. In our work we assume that all TBoxes and ABoxes are closed, while results are
extendable to arbitrarily KBs.
A homomorphism h from a model I to a model J is a mapping from  to  sat-
isfying: (i) h(a) = a for every constant a; (ii) if   A

), then
h()  A

) for every A (resp., P ). A canonical model of
K is a model which can be homomorphically embedded in every model of K, denoted
IcanK or just Ican when K is clear from the context.

, and of an assertion D1  D2 if D

, if T  A |= A

, and A is T -equivalent to A

(resp., (h(), h())  P

(resp., (, )  P

E. Kharlamov and D. Zheleznyakov

Mod(K) :

I0

I1

Mod(T  N ) :

J0 J1 J2

J3

Approach

global:

local:
?

?

?


set:

number:

#

Distance is 
built upon

atoms:

a

symbols:

s

Type of distance

Fig. 1. Left: measuring distances between models and finding local minimums.
Right: three-dimensional space of approaches to model-based evolution semantics.

2.2 Evolution of Knowledge Bases
This section is based on [10]. Let K = (T ,A) be a DL-LiteR KB and N a new ABox.
We study how to incorporate N s assertions into K, that is, how K evolves under N [2].
More practically, we study evolution operators that take K and N as input and return,
possibly in polynomial time, a DL-LiteR K = (T ,A) (with the same TBox as K) that
captures the evolution, and which we call the (ABox) evolution of K under N . Based
on the evolution principles of [10], we require K and K
to be satisfiable. A DL-LiteR
KB K = (T ,A) and an ABox N is a evolution setting if K and (T ,N ) are satisfiable.

Model-Based Semantics of Evolution. In model-based approaches (MBAs), the result
of evolution of a KB K wrt new knowledge N is a set K  N of models. The idea of
MBAs is to choose as KN some models of (T ,N ) depending on their distance to Ks
models. Katsuno and Mendelzon [4] considered two ways, so called local and global,
of choosing these models of (T ,N ), where the first choice corresponds to knowledge
update and the second one to knowledge revision.
The idea of the local approaches is to consider all models I of K one by one and for
each I to take those models J of (T ,N ) that are minimally distant from I. Formally,
?

?

?
K  N =

IMod(K)

I  N , where I  N = arg min
J Mod(T N )

dist(I,J ).

where dist(,) is a function whose range is a partially ordered domain and arg min
stands for the argument of the minimum, that is, in our case, the set of models J
for which the value of dist(I,J ) reaches its minimum value, given I. The distance
function dist varies from approach to approach and commonly takes as values either
numbers or subsets of some fixed set. To get a better intuition of the local semantics,
consider Figure 1, left, where we present two model I0 and I1 of a KB K and four
models J0, . . . ,J3 of (T ,N ). We represent the distance between a model of K and
a model of T  N by the length of a line connecting them. Solid lines correspond to
minimal distances, dashed lines to distances that are not minimal. In this figure {J0} =
arg minJ {J0,...,J3} dist(I0,J ) and {J2,J3} = arg minJ {J0,...,J3} dist(I1,J ).
In the global approach one choses models of T  N that are minimally distant from
K:

K  N = arg min
J Mod(T N )

dist(Mod(K),J ),

(1)
?

?

?
where dist(Mod(K),J ) = minIMod(K) dist(I,J ). Consider again Figure 1, left, and
assume that the distance between I0 and J0 is the global minimum, hence, {J0} =
arg minJ {J0,...,J3} dist({I0,I1},J ).
Measuring Distance Between Interpretations. The classical MBAs were developed for
propositional theories [5], where interpretation were sets of propositional atoms, two
distance functions were introduced, respectively based on symmetric difference 
and on the cardinality of symmetric difference:

dist(I,J ) = I  J

and

dist#(I,J ) = |I  J |,

I = S

J },

I = S

and dists

(2)
where I J = (I \J ) (J \I). Distances under dist are sets and are compared by
set inclusion, that is, dist(I1,J1)  dist(I2,J2) iff dist(I1,J1)  dist(I2,J2).
Finite distances under dist# are natural numbers and are compared in the standard way.
One can extend these distances to DL interpretations in two different ways. One
way is to consider interpretations I, J as sets of atoms. Then I  J is again a set
of atoms and we can define distances as in Equation (2). We denote these distances
as dista(I,J ) and dista
#(I,J ). Another way is to define distances at the level of the
concept and role symbols in the signature  underlying the interpretations:
J }|.
dists(I,J ) = {S   | S
#(I,J ) = |{S   | S
Summing up across the different possibilities, we have three dimensions, which give
eight semantics of evolution according to MBAs by choosing: (1) the local or the global
approach, (2) atoms or symbols for defining distances, and (3) set inclusion or cardinality to compare symmetric differences. In Figure 1, right, we depict these three dimen-
sions. We denote each of these eight possibilities by a combination of three symbols,
indicating the choice in each dimension, e.g., La
# denotes the local semantics where the
distances are expressed in terms of cardinality of sets of atoms.
Closure Under Evolution. Let D be a DL and M one of the eight MBAs introduced
above. We say D is closed under evolution wrt M (or evolution wrt M is expressible in
written in D
D) if for every evolution setting K and N written in D, there is a KB K
such that Mod(K) = K  N , where K  N is the evolution result under semantics M .
We showed in [10,11] that DL-Lite is not closed under any of the eight model based
semantics. The observation underlying these results is that on the one hand, the minimality of change principle intrinsically introduces implicit disjunction in the evolved
KB. On the other hand, since DL-Lite is a slight extension of Horn logic [14], it does
not allow one to express genuine disjunction (see Lemma 1 in [10] for details).
Let M be a set of models that resulted from the evolution of (T ,A) with N . A KB
(T ,A) is a sound approximation of M if M  Mod(T ,A). A sound approximation
(T ,A) is minimal if for every sound approximation (T ,A) inequivalent to (T ,A),
it holds that Mod(T ,A)  Mod(T ,A), i.e., (T ,A) is minimal wrt .

3 Relationships between Model-Based Semantics
Let S1 and S2 be two evolution semantics and D a logic language. Then S1 is subsumed
by S2 wrt D, denoted (S1 sem S2)(D), or just S1 sem S2 when D is clear from the

E. Kharlamov and D. Zheleznyakov

Ga

#

Ga

La

#

La

Gs

#

Gs

Ls

#

Ls

Fig. 2. Subsumptions for evolution semantics.

Dashed frame surrounds semantics under which DL-LiteprR is closed.

: for DL-LiteR (Theorem 1). 

: for DL-LiteprR (Theorems 4, 5).

context, if K S1 N  K S2 N for all satisfiable KBs K and N written in D, where
K Si N denotes evolution under Si. Two semantics S1 and S2 are equivalent (wrt
D), denoted (S1 sem S2)(D), if (S1 sem S2)(D) and (S2 sem S1)(D). Further in
this section we will consider K and N written in DL-LiteR. The following theorem
shows the subsumption relation between different semantics. We depict these relations
in Figure 2 using solid arrows. The figure is complete in the following sense: there is a
solid path (a sequence of solid arrows) between any two semantics S1 and S2 iff there
is a subsumption S1 sem S2.
Theorem 1. Let   {a, s} and   {, #}. Then for DL-LiteR it holds that

sem L

, Gs

#

sem Gs,



#

#

, there is no J  |= T  N such that dist
sem La
#, Ga sem La, Gs
Consider E# = K  N wrt L

sem Ls.
and Ls
G
 and EL = K  N wrt L
 be a distance function, EG = K  N wrt G
Proof. Let dist

be corresponding global and local semantics based on dist
. For an evolution setting
|= K and
K and N , let J   EG. Then, there is I
|= K such that for every I
J  |= T  N it does not hold that dist
,J ). In particular, when
(I
(I
,J )  dist
,J ), which
I = I
,J )  dist
(I
(I
yields that J   arg minJ Mod(T N ) dist
,J ), and J   EL. We conclude that:
(I
Ga
#, Gs sem Ls.
sem Ls
#, which is based on dist#, and E = K  N wrt L,
which is based on dist. We now check whether E# sem E holds. Assume J   E#
and J   E. Then, from the former assumption we conclude existence of I |= K such
that J   arg minJ Mod(T N ) dist#(I
/ E, we
conclude existence of a model J 
,J ). This yields
,J )  dist#(I
,J ), which contradicts the fact that J   E#, assuming
that dist#(I
,J ) is finite. Thus, E# sem E as soon as dist(I,J ) is finite. This
that dist(I
finiteness condition always holds for when  = s since the signature of KN is finite.
sem La.
It is easy to check that dist(I,J ) may not be finite when  = a, hence, La

sem Ga in DL-LiteR.

,J ). From the latter assumption, J 

Similarly, one can show that Gs

such that dist(I

,J )  dist(I

sem Gs and Ga

#

#

#

#

4 Evolution of DL-LiteprR KBs

Consider a restriction of DL-LiteR, which we call DL-LiteprR (pr stands for positive role
interaction), where disjointness that involves roles is forbidden (only positive inclusions
?

?

?
INPUT : satisfiable DL-LiteprR KB (T ,A) and DL-LiteR ABox N
OUTPUT: a set A  fclT (A) of ABox assertions
A
repeat

:= ; S := fclT (A);
choose some   S; S := S \ {};
if {}  fclT (N ) is satisfiable then A

:= A  {}
?

?

?
until S =  ;

Algorithm 1. Algorithm AlignAlg((T ,A),N ) for A

deterministic computation

involving roles are permitted). Formally, T is in DL-LiteprR if it is in DL-LiteR and T |=
R  B for any role R and any concept B. DL-LiteprR is defined semantically, while
one can syntactically check (in quadratic time), given a DL-LiteR TBox T whether it
is in DL-LiteprR : compute a closure of T , check that no assertion of the form R  B
is in the closure and if it is the case, then K is in DL-LiteprR . Note that DL-LiteprR is
an extension of RDFS ontology language (of its first-order logics fragment). DL-LiteprR
adds to RDFS the ability of expressing disjointness of atomic concepts (A1  A2) and
mandatory participation (A  R). In the rest of the section we investigate whether and
how to capture K  N in DL-LiteprR for DL-LiteprR KBs K under all the eight MBAs.

is the interpretation {f

4.1 Capturing Atom-Based Evolution
We first study evolution under La. Let I be an interpretation. An alignment Align(I,N ) of I with an ABox N ,
| f 
I and f is satisfiable with N}.
Consider an algorithm AlignAlg (see Algorithm 1) that inputs an evolution setting
K, N , and returns the alignment Align(Ican,N ) of a canonical model Ican of K: it
drops all the assertions of fclT (A) contradicting N and keeps the rest. Using AlignAlg
we can compute representation of K  N in DL-LiteprR :
Theorem 2. Let K = (T ,A) and N be an evolution setting, and T be in DL-LiteprR .
Then there exists a DL-LiteprR representation of KN under La, and it can be computed
in time polynomial in |K  N| as follows:

K  N = Mod(T , AlignAlg(K,N )  N ).

Example 3. Consider T = {B0  B, B  C}, A = {C(a)}, and N = B(a). Then,
fclT (A) = {C(a),B0(a),B(a)} and AlignAlg((T ,A),N ) = {B0(a)}. Hence,
the result of evolution (T ,A)  N under La is (T ,{B(a),B0(a)}).

Relationships between Atom-Based Semantics. Next theorem shows that in DL-LiteprR
all four atom-based MBAs coincide We depict these relations between semantics in
Figure 2 using dashed arrows, e.g., as between La and Ga
#. Note that there is a path
with solid or dashed arrows (a sequence of such arrows) between any two semantics if
and only if in DL-LiteprR there is a subsumption between them.

E. Kharlamov and D. Zheleznyakov

Theorem 4. For DL-LiteprR: La
Theorems 2 and 4 imply that in DL-LiteprR one can use AlignAlg to compute (a representation of) evolution under all MBAs on atoms.

sem La sem Ga

sem Ga.

#

#

4.2 Capturing Symbol-Based Evolution

Observe that symbol-based semantics behave differently from atom-based ones: two
local semantics (on set inclusion and cardinality) coincide, as well as two global se-
mantics, while there is no subsumption between local and global ones, as depicted in
Figure 2:

#

sem La;

#, while Ls sem Gs
#.

#, while Gs
#, and Gs sem Gs

Theorem 5. The following relations on symbols-based MBAs hold for DL-LiteprR :
(i) La sem Gs
(ii) Ls sem Ls
As a corollary of Theorem 5, in general the approach presented in Theorem 2 does
not work for computing K  N under any of the symbol-based MBAs. At the same
time, as follows from the following Theorems 6 and 8, this approach gives complete
approximations of all symbol-based semantics, while it approximates global semantics
better than the local ones.
Consider the algorithm SymAlg in Algorithm 2 that will be used for evolutions on
symbols. It works as follows: it inputs an evolution setting (T ,A), N and a unary
property  of assertions. Then for every atom  in N it checks whether  satisfies 
(Line 4). If it the case, SymAlg deletes from AlignAlg((T ,A),N ) all literals 

that
share concept name with . Both local and global semantics have their own : G and
L.
Capturing Global Semantics. G() checks whether  of N T -contradicts A: G()
is true iff   fclT (A) \ AlignAlg((T ,A),N ). Intuitively, SymAlg for global semantics works as follows: having contradiction between N and A on  = B(c), the
change of Bs interpretation is inevitable. Since the semantics traces changes on symbols only, and B is already changed, one can drop from A all the assertions of the form
B(d). Clearly, SymAlg(K,N , G) can be computed in time polynomial in |K  N|.
The following theorem shows correctness of this algorithm.
Theorem 6. Let K = (T ,A) and N be an evolution setting, and T be in DL-LiteprR .
Then a DL-LiteprR representation of K  N under both Gs and Gs
# exists and can be
computed in time polynomial in |K  N| as follows:

K  N = Mod(T , SymAlg(K,N , G)).

Capturing Local Semantics. Observe that Ls and Ls
# are not expressible in DL-LiteprR
because they require for a disjunction which is not available in DL-LiteR (we omit
details due to space limit).
Theorem 7. DL-LiteprR is not closed under Ls and Ls

# semantics.
?

?

?
INPUT : satisfiable DL-LiteprR KB (T ,A) and ABox N , a property  of assertions
OUTPUT: a set A  fclT (A)  fclT (N ) of ABox assertions
A
repeat

:= ; S1 := AlignAlg((T ,A), N ); S2 := fclT (N );
choose some   S2; S2 := S2 \ {};
if () = TRUE then S1 := S1 \ { |  and 
:= S1  fclT (N )

have the same concept name}
?

?

?
until S2 =  ;
5 A

Algorithm 2. Algorithm SymAlg((T ,A),N , ) for deterministic computation
of K  N under Gs and Gs
# semantics and minimal sound approximation under
Ls and Ls

# semantics

To compute a minimal sound approximations under local semantics on symbols, we
use SymAlg with the following L: L() is true iff  / S1. That is, L checks
whether the ABox A T -entails A(c)  fclT (N ), and if it does not, then the algorithm
deletes all the assertions from fclT (A) that share the concept name with A(c). This
property is weaker than the one for global semantics, since it is easier to get changes
in interpretation of A by choosing a model of K which does not include A(c). The
following theorem shows correctness and complexity of the algorithm.
Theorem 8. Let K = (T ,A) and N be an evolution setting, and T be in DL-LiteprR .
Then a DL-LiteprR minimal sound approximation K
of K  N under both Ls and Ls
exists and can be computed in time polynomial in |K  N| as follows:

#

K

= (T , SymAlg(K,N , L)).

Example 9. Consider the following DL-LiteprR KB K = (,A) and N :
A = {A(a), A(b), B(c), B(d)}; N = {A(a), B(e)}.

It is easy to see that A = SymAlg(K,N , G) is {A(a), B(c), B(d), B(e)}, and
A = SymAlg(K,N , L) is {A(a), B(e)}. That is, K  N under Gs
 is equal to
Mod(,A), and under Ls
 is approximated by Mod(,A), where   {, #}. A
closer look at A
 is very counter-
intuitive: as soon as we declare that the object a is not in A, all the information about
another objects in A is erased. Local semantics Ls
 are even worse: the evolution under
them erases information about B as soon as we just add information about a new object
e in B.

shows that the behaviour of the evolution under Gs

To sum up on DL-LiteprR : atom-based approaches (which all coincide) can be captured
using a polynomial-time time algorithm based on alignment. Moreover, the evolution
results produced under these MBAs are intuitive and expected, e.g., see Example 3,
while symbol-based approaches produce quite unexpected and counterintuitive results
(these semantics delete too much data). Furthermore, two out of four of the latter approaches cannot be captured in DL-LiteprR . Based on these results we conclude that using atom-based approaches for applications seem to be more practical. In Figure 2 we
framed in a dashed rectangle six out of eight MBAs under which DL-LiteprR is closed.

E. Kharlamov and D. Zheleznyakov

5 La Evolution of DL-LiteR KBs
In the previous section we showed that atom-based MBAs behave well for DL-LiteprR
evolution settings, while symbol-based ones do not. This suggests to investigate atombased MBAs for the entire DL-LiteR. Moreover, one of the atom-based semantics La
which is essentially the same as a so-called Winsletts semantics [15] (WS) was widely
studied in the literature [6,8]. Liu, Lutz, Milicic, and Wolter studied WS for expressive
DLs [6], and KBs with empty TBoxes. Most of the DLs they considered are not closed
under WS. Poggi, Lembo, De Giacomo, Lenzerini, and Rosati applied WS to the same
setting as we have in this work: to what they called instance level (ABox) update for DLLite [8]. They proposed an algorithm to compute the result of updates, which has technical issues, i.e., it is neither sound, nor complete [10]. They further use this algorithm
to compute approximations of ABox updates in sublogics of DL-Lite, which inherits
these technical issues. Actually, ABox update algorithm cannot exist since Calvanese,
Kharlamov, Nutt, and Zheleznyakov showed that DL-Lite is not closed under La [11].
We now investigate La evolution for DL-LiteR and firstly explain why DL-LiteR is not
closed under La.

5.1 Understanding Inexpressibility of Evolution in DL-LiteR
Recall that for every DL-Lite KB K, the set Mod(K) has a canonical model. The following example illustrates the lack of canonical models for K  N under La, which
yields inexpressibility of K  N in DL-Lite.
Example 10. Consider the following DL-Lite KB K1 = (T1,A1) and N1 = {C(b)}:

  C}; A1 = {A(a), C(e), C(d), R(a, b)}.
I = {a, x}, C

T1 = {A  R,R
I = {(a, b), (x, b)},
I = {d, e}, and R
Consider a model I of K1: A
where x   \ adom(K1  N1). The following models belong to I  N1:
I = ,
I = ,
I = {d, e, b}, R
?

?

?
I = {(x, d)},
I = {e, b},
I = {x},
?

?

?
I = {x},
I = {(x, e)}.
I = {d, b},
?

?

?
J0:
J1:
J2:

Indeed, all the models satisfy N1 and T1. To see that they are in I  N1 observe that
every model J (I)  (I  N1) can be obtained from I by making modifications that
guarantee that J (I) |= (N1T1) and that the distance between I and J (I) is minimal.
What are these modifications? Since in every J (I) the new assertion C(b) holds and
  C)  T1, there should be no R-atoms with b-fillers (at the second coordinate)
(R
in J (I). Hence, the necessary modifications of I are either to drop (some of) the R-
atoms R(a, b) and R(x, b), or to modify (some of) them, by substituting the b-fillers
with another ones, while keeping the elements a and x on the first coordinate. The
model J0 corresponds to the case when both R-atoms are dropped, while in J1 and J2
only R(a, b) is dropped and R(x, b) is modified to R(x, d) and R(x, e), respectively.
Note that the modification in R(x, b) leads to a further change in the interpretation of
C in both J1 and J2, namely, C(d) and C(e) should be dropped, respectively.
One can verify that any model Jcan that can be homomorphically embedded into J0,
J1, and J2 is such that A
Jcan. It is easy to check that

Jcan = , and e, d / C

Jcan = R
?

?

?
  C forbids R-atoms with C-constants on the second coordinate.

such a model does not belong to K1N1. Hence, there is no canonical model in K1N1
and it is inexpressible in DL-Lite.
We now give an intuition why in K  N under La canonical models may be missing.
Observe that in Example 10, the role R is affected by the old TBox T1 as follows:
(i) T1 places (i.e., enforces the existence of) R-atoms in the evolution result, and on
one of coordinates of these R-atoms, there are constants from specific sets, e.g.,
A  R of T1 enforces R-atoms with constants from A on the first coordinate,
and
(ii) T1 forbids R-atoms in K1  N1 with specific constants on the other coordinate,
e.g., R
Due to this dual-affection (both positive and negative) of the role R in T1, we were able
to provide ABoxes A1 and N1, which together triggered the case analyses of modifications on the model I, that is, A1 and N1 were triggers for R. Existence of such an
affected R and triggers A1 and N1 made K1N1 inexpressible in DL-LiteR. Therefore,
we now formally define and then learn how to detect dually-affected roles in TBoxes T
and how to understand whether these roles are triggered by A and N .
Definition 11. Let T be a DL-LiteR TBox. Then a role R is dually-affected in T if for
  B. A duallysome concepts A and B it holds that T |= A  R and T |= R
affected role R is triggered by N if there is a concept C such that T |= R
  C
and N |=T C(b) for some constant b.
As we saw in Example 10, even one dually-affected role in a TBox can cause inexpressibility of evolution. Moreover, if there is a dually affected role, we can always find A
and N to trigger it. We generalize this observation as follows:
Theorem 12. Let T be a DL-LiteR TBox and R be a role dually affected in T . Then
there exist ABoxes A and N s.t. (T ,A)  N is inexpressible in DL-LiteR under La.

5.2 Prototypes
Closer look at the sets of models K  N for DL-LiteR KBs K gives a surprising result:
Theorem 13. The set of models K  N under La can be divided (but in general
not partitioned) into worst-case exponentially many in |K  N| subsets S0, . . . ,Sn,
where each Si has a canonical model Ji, which is a minimal element in K  N wrt
homomorphisms.
We call these Jis prototypes. Thus, capturing K  N in some logics boils down to
(i) capturing each Si with some theory KSi and (ii) taking the disjunction across all KSi.
This will give the desired theory K = KS1    KSn that captures K  N . As
we will see some of KSis are not DL-Lite theories (while they are SHOIQ theories,
see Section 5.4 for details). We construct each KSi in two steps. First, we construct a
DL-LiteR KB K(Ji) which is a sound approximations of Si, i.e., Si  Mod(K(Ji)).
Second, based on K and N , we construct a SHOIQ formula , which cancels out all
the models in Mod(K(Ji)) \ Si, i.e., KSi =   K(Ji). Finally,
KS0    KSn = (  K(J0))    (  K(Jn)) =   (K(J0)    K(Jn)).

E. Kharlamov and D. Zheleznyakov

Mod(K(J0))

Mod(K(J1)) Mod(K(J2))

J0

J1

J2

Mod(K(J3))

K  N

S0

S1

S2

S3

J3

Fig. 3. Graphical representation of our approach to capture the result of evolution under La

To get a better intuition on our approach consider Figure 3, where the result of evolution K N is depicted as the figure with solid-line borders (each point within the figure
is a model of K  N ). For the sake of example, let K  N under La can be divided in
four subsets S0, . . . ,S3. To emphasize this fact, KN looks similar to a hand with four
fingers, where each finger represents an Si. Consider the left part of Figure 3, where the
canonical Ji model of each Si is depicted as a star. Using DL-LiteR, we can provide
KBs K(Ji)s that are sound approximation of corresponding Sis. We depict the models
Mod(K(Ji)) as ovals with dashed-line boarders. In the right part of Figure 3 we depict
in grey the models Mod(K(Ji)) \ Si that are cut off by .

We now define prototypes formally and proceed to procedures discussed above.

Definition 14. Let K and N be an evolution setting. A prototypal set for K  N under La is a minimal subset = {J0, . . . ,Jn} of K  N satisfying the following prop-
erty:

for every J  K  N there exists Ji  homomorphically embeddable in J .

We call every Ji  a prototype for K  N . Note that prototypes generalize canonical
models in the sense that every set of models with a canonical one, say Mod(K) for a
DL-LiteR KB K, has a prototype, which is exactly this canonical model.
5.3 Computing La Evolution for DL-LiteR
For the ease of exhibition of our procedure that computes evolution K  N under La
semantics we restrict DL-LiteR by assuming that TBoxes T should satisfy: for any
. That is, we forbid
two roles R and R
direct interaction (subsumption and disjoint) between role projections and call such T
is still possible,
as without direct role interactions. Some interaction between R and R
e.g., role projections may contain the same concept. This restriction allows us to analyze
evolution that affects roles independently for every role. We will further comment on
how the following techniques can be extended to the case when roles interact in an
arbitrary way.

and T |= R  R
?

?

?
, T |= R  R
?

?

?
Components for Computation. We now introduce several notions and notations that we
further use in the description of our procedure. The notion of alignment was introduced
?

?

?
BZP (K, N )

For each R(a, b)  AA(K,N ), do J0 := J0 \ {R(a, b)},

1. J0 := Align(Ican,N )  N , where Ican is the canonical model of K.
2.
3. Return J0.

if there is no R(a, )  Ican \ AA(K,N ) do J0 := J0 \ rootatT (R(a)).

Fig. 4. The procedure of building zero-prototype

in Section 4.1. An auxiliary set of atoms AA (Auxiliary Atoms) that, due to evolution,
should be deleted from the original KB and have some extra condition on the first
coordinate is:
AA(T ,A,N ) = {R(a, b)  fclT (A) | T |= A  R,A |=T A(a),N |=T R
(b)}.
If Ri is a dually-affected role of T triggered by A and N , then the set of forbidden
atoms (of the original ABox) FA[T ,A,N ](Ri) for Ri is:
{D(c)  fclT (A) | R
Consequently, the set of forbidden atoms for the entire KB (T ,A) and N is

i (c)  D(c) |=T  and N |=T D(c), and N |=T D(c)}.




FA(T ,A,N ) =

FA(T ,A,N )(Ri),
?

?

?
RiTR

and T |= A

s.t. T |= A  A
?

?

?
where TR(T ,N ) (or simply TR, which stands for triggered roles) is the set of all roles
dually-affected in T that are triggered by N . In the following we omit the arguments
(T ,A,N ) in FA when they are clear from the context. For a role R, the set SC(R),
where SC stands for sub-concepts, is a set of concepts that are immediately under R
in the concept hierarchy generated by T :
  R}.
SC(R) = {A | T |= A  R and there is no A

If f is an ABox assertion, then rootatT (f) is a set of all the atoms that T -entail f . For
example, if T |= A  R, then A(x)  rootatT (R(x)).
We are ready to proceed to construction of prototypes.
Constructing Zero-Prototype. The procedure BZP (K,N ) (Build Zero Prototype) in
Figure 4 constructs the main prototype J0 for K and N , which we call zero-prototype.
Based on J0 we will construct all the other prototypes. To build J0 one should align the
canonical model Ican of K with N , and then delete from the resulting set of atoms all the
auxiliary atoms R(a, b) of AA(K,N ). If Ican contains no atoms R(a, )  AA(K,N )
for some , then we further delete atoms rootatT (R(a)) from J0, otherwise would we
get a contradiction with the TBox. Note that J0 can be infinite.
Constructing Other Prototypes. The procedure BP (K,N ,J0) (Build Prototypes) of
takes J0 and, based on it, builds the other prototypes by (i) dropping
constructing
FA-atoms from J0 and then (ii) adding atoms necessary to obtain a model of K  N .
This procedure can be found in Figure 5.

We conclude the discussion on the procedures with a theorem:

E. Kharlamov and D. Zheleznyakov

1.
2.

BP (K,N ,J0)

:= {J0}.
For each subset D = {D1(c1), . . . , Dk(ck)}  FA do

for each R = (Ri1 , . . . , Rik ) such that Dj (cj )  FA(Rij ) for j = 1, . . . , k do
for each B = (Ai1 , . . . , Aik ) such that Aj  SC(Rj) do
J [D, R, B] :=
where all xis are different constants from  \ adom(K), fresh for Ican.
:=  {J [D, R, B]}.
?

?

?
fclT (Rij (xj, cj ))  {ARij (xj)}

J0 \k

i=1 rootT (Di(ci))

k
?

?

?
j=1

,

3. Return .

Fig. 5. The procedure of building prototypes in DL-LiteR without direct role interactions based
on the zero prototype J0
Theorem 15. Let K = (T ,A), N be an evolution setting and T without direct role
interactions. Then the set BP (K,N , BZP (K,N )) is prototypal for K  N under La.
Continuing with Example 10, one can check that the prototypal set for K1 and N1 is
{J0,J1,J2,J3}, where J0, J1, and J2 are as in the example and A
J3 = {x, y},
J3 = {b}, and R

We proceed to correctness of BP in capturing evolution in DL-LiteR, where we use the
following set FC[T ,A,N ](Ri) = {c | D(c)  FA[T ,A,N ](Ri)}, that collects all the
constants that participate in the forbidden atoms.
Theorem 16. Let K = (T ,A), N be an evolution setting, T without direct role in-
teractions, and BP (K,N , BZP (K,N )) = {J0, . . . ,Jn} a prototypal set for K  N .

Then K  N under La is expressible in SHOIQ and moreover
(T ,A0)    (T ,An)
?

?

?
 
K  N = Mod

J3 = {(x, d), (y, e)}.

,

where Ai is a DL-LiteR ABox such that Ji is a canonical model for (T ,Ai),  =
R.(1  2), where R is the top role (which is present in OWL 2) and
?

?

?
Ri.{cj} 
?

?

?
{x}  B

 ,

B(x)rootatT (Ri(x))

 .

1  
RiTR
?

?

?
cjFC[Ri]


?

?

?
Ri.{cj}  ( 1R.)
({a}  R.) 

2  

R(a,b)AA
?

?

?
{a}  C

C(a)rootatT (R(a))fclT (A)

What is missing in the theorem above is how to compute the ABoxes Ais. One can do
it using a similar procedure to the one of constructing Jis, with the difference that one
has to take the original ABox A instead of Ican as the input. Note that A may include
negative atoms, like B(c), which should be treated in the same way as positive ones.

Continuing with Example 10, the ABoxes A0 and A1 are as follows:

A0 = {C(d), C(e), C(b)}; A1 = {A(x), C(e), C(b), R(x, d)}.
?

?

?
  P



Section 4.

A2 and A3 can be built in the similar way. Note that only A0 is in DL-LiteR, while
writing A1, . . . ,A3 requires variables in ABoxes. Variables, also known as soft con-
stants, are not allowed in DL-LiteR ABoxes, while present in DL-LiteRS ABoxes. Soft
constants x are constants not constrained by the Unique Name Assumption: it is not
I = x. Since DL-LiteRS is tractable and first-order rewritable [12],
necessary that x
expressing A1 in DL-LiteRS instead of DL-LiteR does not affect tractability.
Note that the number of prototypes is exponential in the number of constants, and
therefore the size of the SHOIQ theory described in Theorem 16 is also exponential
in the number of constants.
Capturing La Semantics for DL-LiteR KBs with Direct Role Interactions. In this general case the BP procedure does return prototypes but not all of them. To capture the
La for such KBs one should iterate BP over (already constructed) prototypes until no
new prototypes can be constructed. Intuitively the reason is that BP deletes forbidden
atoms (atoms of FA) and add new atoms of the form R(a, b) for some triggered duallyaffected role R which may in turn trigger another dually-affected role, say P , and such
triggering may require further modifications, already for P . This further modification
require a new run of BP. For example, if we have R
in the TBox and we set
R(a, b) in a prototype, say Jk, this modification triggers role P and we should run BP
recursively with the prototype Jk as if it was the zero prototype. We shall not discuss
the general procedures in more details due to space limit.
5.4 Practical Considerations on La Evolution
As a summary of Sections 4 and 5, we now discuss how one can compute La-evolution
of DL-LiteR KBs in practice. For an evolution setting K and N consider the following
procedure of computing K
1. Check whether K is in DL-LiteprR . This test can be done in polynomial time, see
2. If K is in DL-LiteprR , then K
is in DL-LiteprR and can be computed in polynomial
3. If K is not in DL-LiteprR , then check whether any dually-affected role of K is trig-
4. If the test of Case 3 fails, then K
5. If the test of Case 3 succeeds, then K

time using the algorithm AlignAlg as described in Theorem 2 of Section 4.
gered by N . This test can be done in polynomial time, see Section 5.1.

such that Mod(K) = K  N :

could be exponential in |K  N|.

is in DL-LiteR and can be computed as in Case 2.
is in SHOIQ, but not in DL-LiteR, and
can be computed using prototype-based techniques as described in Theorem 16.
The size of this K
is polynomial in the number of prototypes for K  N . Since the
number of prototypes is worst-case exponential in the number of constants in A,
the size of K
The case when computation of K
can be intractable is of K with dually-affected roles
triggered by N . It is unclear how often this case may occur in practice. While the
tractable case of DL-LiteprR where we disallow assertions of the form R  A seems
to be practical, since it extends the (first-order fragment) of RDFS.
We now discuss a way to approximate K  N with a DL-LiteR KB when this set
is not expressible in DL-LiteR. Let K = (T ,A) and N be an evolution setting, then a
DL-LiteR KB Kc = (T ,Ac) is a certain La-approximation of KN if Ac = {F | K 
N |= F}. We called Kc certain since it resembles certain answers for queries over KBs.

E. Kharlamov and D. Zheleznyakov

|= C(a) is equivalent to checking whether K

Proposition 17. Let K, N be an evolution setting. Then the certain La-approximation
of K  N exists, unique, and can be computed in non-deterministic exponential time.
Proof. Clearly all ABox assertions of Ac are over concepts, roles, and constants of K,
thus, there are at most a quadratic many (in |K  N|) of them, and we can simply test
whether F  Ac for each such assertion F . Since K  N is representable in SHOIQ,
this test can be reduced to the subsumption problem for SHOIQ (checking whether
|= {a}  C). Subsumption for
K
SHOIQ is NExpTime-complete and can be tested using the algorithms of [16].
The proposition above gives the upper bound for Kc computations. We do not know the
lower bound, but conjecture it to be in polynomial time. Note that NExpTime lower
bound for SHOIQ subsumption checking holds for arbitrarySHOIQ concepts, while
Theorem 16 gives us K
with concepts of a specific kind. Moreover, the authors of [16]
argue that despite the high complexity of subsumption checking their algorithms should
behave well in many typically encountered cases. Note also that for DL-LiteprR KBs
certain approximations in fact capture the evolution result, that is Mod(Kc) = K  N .
6 Conclusion

We studied model-based approaches to ABox evolution (update and revision) over
DL-LiteR and its fragment DL-LiteprR , which both extend (first-order fragment of) RDFS.
DL-LiteprR is closed under most of the MBAs, while DL-LiteR is not closed under any
of them. We showed that if the TBox of K entails a pair of assertions of the form
  C, then an interplay of N and A may lead to inexpressibil-
A  R and R
ity of K  N . For DL-LiteprR we provided algorithms how to compute evolution results
for six model-based approaches and approximate for the remaining two. For DL-LiteR
we capture evolution of KBs under a local model-based approach with SHOIQ using
novel techniques based on what we called prototypes. We believe that prototypes are
important since they can be used to study evolution for ontology languages other than
DL-LiteR. Finally, we showed how to approximate evolution when it is not expressible
in DL-LiteR using what we called certain approximations.

It is the first attempt to provide an understanding of inexpressibility of MBAs for DLLite evolution. Without this understanding it is unclear how to proceed with the study
of evolution in more expressive DLs and what to expect from MBAs in such logics.
We also believe that our techniques of capturing semantics based on prototypes give a
better understanding of how MBAs behave.

Acknowledgements. We are thankful to Diego Calvanese, Balder ten Cate, and Werner
Nutt for insightful discussions. We thank anonymous reviewers for constructive com-
ments. The authors are supported by EU projects ACSI (FP7-ICT-257593) and Ontorule
(FP7-ICT-231875); the first author is supported by ERC FP7 grant Webdam (agreement
