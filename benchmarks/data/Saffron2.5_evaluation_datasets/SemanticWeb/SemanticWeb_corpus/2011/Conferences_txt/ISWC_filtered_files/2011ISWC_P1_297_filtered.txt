Logic-Based and Scalable Ontology Matching

LogMap:

Ernesto Jim enez-Ruiz and Bernardo Cuenca Grau

Department of Computer Science, University of Oxford

{ernesto,berg}@cs.ox.ac.uk

Abstract. In this paper, we present LogMapa highly scalable ontology matching system with built-in reasoning and diagnosis capabilities.
To the best of our knowledge, LogMap is the only matching system that
can deal with semantically rich ontologies containing tens (and even hun-
dreds) of thousands of classes. In contrast to most existing tools, LogMap
also implements algorithms for on the fly unsatisfiability detection and
repair. Our experiments with the ontologies NCI, FMA and SNOMED
CT confirm that our system can efficiently match even the largest existing bio-medical ontologies. Furthermore, LogMap is able to produce
a clean set of output mappings in many cases, in the sense that the
ontology obtained by integrating LogMaps output mappings with the
input ontologies is consistent and does not contain unsatisfiable classes.

1 Introduction

OWL ontologies are extensively used in biology and medicine. Ontologies such as
SNOMED CT, the National Cancer Institute Thesaurus (NCI), and the Foundational Model of Anatomy (FMA) are gradually superseding existing medical
classifications and are becoming core platforms for accessing, gathering and sharing bio-medical knowledge and data.

These reference bio-medical ontologies, however, are being developed independently by different groups of experts and, as a result, they use different entity
naming schemes in their vocabularies. As a consequence, to integrate and migrate data among applications, it is crucial to first establish correspondences (or
mappings) between the vocabularies of their respective ontologies.

In the last ten years, the Semantic Web and bio-informatics research communities have extensively investigated the problem of automatically computing
mappings between independently developed ontologies, usually referred to as the
ontology matching problem (see [8] for a comprehensive and up-to-date survey).
The growing number of available techniques and increasingly mature tools,
together with substantial human curation effort and complex auditing protocols,
has made the generation of mappings between real-world ontologies possible.
For example, one of the most comprehensive efforts for integrating bio-medical
ontologies through mappings is the UMLS Metathesaurus (UMLS) [2], which
integrates more than 100 thesauri and ontologies.

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 273288, 2011.
c Springer-Verlag Berlin Heidelberg 2011

E. Jim enez-Ruiz and B. Cuenca Grau

However, despite the impressive state of the art, modern bio-medical ontolo-

gies still pose serious challenges to existing ontology matching tools.
Insufficient scalability. Although existing matching tools can efficiently deal
with moderately sized ontologies, large-scale bio-medical ontologies such as NCI,
FMA or SNOMED CT are still beyond their reach. The largest test ontologies
in existing benchmarks (e.g., those in the OAEI initiative) contain around 20003000 classes (i.e., with several million possible mappings); however, to the best of
our knowledge, no tool has been able to process ontologies with tens or hundreds
of thousands of classes (i.e., with several billion possible mappings).
Logical inconsistencies. OWL ontologies have well-defined semantics based on
first-order logic, and mappings are commonly represented as OWL class axioms.
Hence, the ontology O1  O2  M resulting from the integration of O1 and O2
via mappings M may entail axioms that dont follow from O1, O2, or M alone.
Many such entailments correspond to logical inconsistencies due to erroneous
mappings in M, or to inherent disagreements between O1 and O2. Recent work
has shown that even the integration of ontologies via carefully-curated mappings can lead to thousands such inconsistencies [9,5,16,13] (e.g., the integration
of FMA-SNOMED via UMLS yields over 6, 000 unsatisfiable classes). Most existing tools are based on lexical matching algorithms, and may also exploit the
structure of the ontologies or access external sources such as WordNet; however,
these tools disregard the semantics of the input ontologies and are thus unable
to detect and repair inconsistencies. Although the first reasoning-based techniques for ontology matching were proposed relatively early on (e.g., S-Match
[10]), in practice reasoning is known to aggravate the scalability problem (e.g., no
reasoner known to us can classify the integration NCI-SNOMED via UMLS). Despite the technical challenges, there is a growing interest in reasoning techniques
for ontology matching. In particular, there has been recent work on a-posteriori
mapping debugging [12,13,14,15], and a few matching tools (e.g., ASMOV [11],
KOSIMap [21], CODI [19,20]) incorporate techniques for on the fly semantic
verification.

In this paper, we present LogMapa novel ontology matching tool that addresses both of these challenges. LogMap implements highly optimised data
structures for lexically and structurally indexing the input ontologies. These
structures are used to compute an initial set of anchor mappings (i.e., almost
exact lexical correspondences) and to assign a confidence value to each of them.
The core of LogMap is an iterative process that, starting from the initial anchors,
alternates mapping repair and mapping discovery steps. In order to detect and
repair unsatisfiable classes on the fly during the matching process, LogMap
implements a sound and highly scalable (but possibly incomplete) ontology reasoner as well as a greedy diagnosis algorithm. New mappings are discovered
by iteratively exploring the input ontologies starting from the initial anchor
mappings and using the ontologies extended class hierarchy.

To the best of our knowledge, LogMap is the only matching tool that has
shown to scale for rich ontologies with tens (even hundreds) of thousands of
classes. Furthermore, LogMap is able to produce an almost clean set of output
?

?

?
O1O2

Lexical and

Compute

Structural

Indexation

Initial

Anchors

Mapping

Repair

Expand?

Compute

No

Overlapping

Yes

Mapping

Discovery

Fig. 1. LogMap in a nutshell

O
O

mappings between FMA, SNOMED and NCI; as shown a posteriori using a
fully-fledged DL reasoner, LogMap only failed to detect one unsatisfiable class
(out of a total of several thousands) when integrating these large-scale ontologies.

2 The Anatomy of LogMap

We next provide an overview of the main steps performed by LogMap, which
are schematically represented in Figure 1.

1. Lexical indexation. The first step after parsing the input ontologies is their
lexical indexation. LogMap indexes the labels of the classes in each ontology
as well as their lexical variations, and allows for the possibility of enriching
the indexes by using an external lexicon (e.g., WordNet or UMLS-lexicon).
2. Structural indexation. LogMap uses an interval labelling schema [1,4,18]
to represent the extended class hierarchy of each input ontology. Each extended hierarchy can be computed using either simple structural heuristics,
or an off-the-shelf DL reasoner.

3. Computation of initial anchor mappings. LogMap computes an initial
set of equivalence anchor mappings by intersecting the lexical indexes of each
input ontology. These mappings can be considered exact and will later serve
as starting point for the further discovery of additional mappings.

4. Mapping repair and discovery. The core of LogMap is an iterative pro-

cess that alternates repair and discovery steps.

 In the repair step, LogMap uses a sound and highly scalable (but possibly
incomplete) reasoning algorithm to detect classes that are unsatisfiable
w.r.t. (the merge of) both input ontologies and the mappings computed
thus far. Then, each of these undesirable logical consequences is automatically repaired using a greedy diagnosis algorithm.

 To discover new mappings, LogMap maintains two contexts (sets of se-
mantically related classes) for each anchor. Contexts for the same anchor are expanded in parallel using the class hierarchies of the input
ontologies. New mappings are then computed by matching the classes
in the relevant contexts using ISUB [23]a flexible tool that computes
a similarity score for any pair of input strings. This mapping discovery strategy is based on a principle of locality: if classes C1 and C2 are

E. Jim enez-Ruiz and B. Cuenca Grau

Table 1. Fragment of the lexical indexes for NCI and FMA ontologies

Inverted index for NCI labels
Entry

Cls ids

Index for NCI class URIs
Cls id URI

secretion

cellular,secretion 49901

cellular,secrete
37975,62999
trapezoid
trapezoid,bone

smegma

Inverted index for FMA labels
Entry

Cls ids

secretion
bone,trapezoid
trapezoid
smegma

20948,47996
?

?

?
NCI:CellularSecretion
NCI:Trapezoid
NCI:TrapezoidBone
NCI:Smegma

Index for FMA class URIs
Cls id URI
?

?

?
FMA:Secretion
FMA:Bone of Trapezoid
FMA:Trapezoid
FMA:Smegma

correctly mapped, then the classes semantically related to C1 in O1 are
likely to be mapped to those semantically related to C2 in O2.

LogMap continues the iteration of repair and discovery steps until no context
is expanded in the discovery step. The output of this process is a set of
mappings that are likely to be cleanthat is, it will not lead to logical
errors when merged with the input ontologies (c.f., evaluation section).

5. Ontology overlapping estimation. In addition to the final set of map-
pings, LogMap computes a fragment of each input ontology, which intuitively
represent the overlapping between both ontologies. When manually looking
for additional mappings that LogMap might have missed, curators can restrict themselves to these fragments since correct mappings between classes
not mentioned in these fragments are likely to be rare.

2.1 Lexical Indexation

LogMap constructs an inverted lexical index (see Table 1) for each input on-
tology. This type of index, which is commonly used in information retrieval
applications, will be exploited by LogMap to efficiently compute an initial set of
anchor mappings.

The English name of ontology classes as well as their alternative names (e.g.,
synonyms) are usually stored in OWL in label annotations. LogMap splits each
label of each class in the input ontologies into components; for example, the NCI
class cellular secretion is broken into its component English words cellular and
secretion. LogMap allows for the use of an external lexicon (e.g., UMLS lexicon1
or WordNet) to find both their synonyms and lexical variations; for example,
UMLS lexicon indicates that secrete is a lexical variation of secretion.

1 UMLS Lexicon, unlike WordNet, provides only normalisations and spelling variants.
?

?

?
LogMap groups the component words of each class label and their variations
into sets, which will then constitute the key of an inverted index. For example,
the inverted index for NCI contains entries for the sets cellular, secretion and
cellular, secrete. The range of the index is a numerical ID that LogMap associates to each corresponding class (see Table 1). Thus, in general, an entry in
the index can be mapped to several classes (e.g., see trapezoid in Table 1) .

The use of external lexicons to produce a richer index is optional and LogMap
allows users to select among well-known lexicons depending on the application.
These indexes can be efficiently computed and bear a low memory overhead.

Furthermore, they only need to be computed once for each input ontology.

2.2 Structural Indexation

LogMap exploits the information in the (extended) class hierarchy of the input
ontologies in different steps of the matching process. Thus, efficient access to the
information in the hierarchies is critical for LogMaps scalability.

The basic hierarchies can be computed by either using structural heuristics,
or an off-the-shelf DL reasoner. LogMap bundles HermiT [17] and Condor [22],
which are highly optimised for classification. Although DL classification might
be computationally expensive, it is performed only once for each ontology.

The class hierarchies computed by LogMap are extendedthat is, they contain more information than the typical classification output of DL reasoners. In
particular, LogMap exploits information about explicit disjoint classes, as well as
the information in certain complex class axioms (e.g., those stating subsumption
between an intersection of named classes and a named class).

These extended hierarchies are indexed using an interval labelling schemaan
optimised data structure for storing DAGs and trees [1]. The use of an interval
labelling schema has been shown to significantly reduce the cost of computing
typical queries over large class hierarchies [4,18].

In this context, the ontology hierarchy is treated as two DAGs: the descendants
DAG representing the descendants relationship, and the ancestors DAG, which
represents the ancestor relationship. Each named class C in the ontology is
represented as a node in each of these DAGs, and is associated with the following
information (as in [18]).

 Descendants preorder number: predesc(C) is the order in which C is

visited using depth-first traversal of the descendants DAG.

 Ancestors preorder number: preanc(C) is the preorder number of C in

the ancestors DAG.

 Topological order: deepest associated level within the descendants DAG.
 Descendants interval: the information about descendants of C is encoded
using the interval [predesc(C), maxpredesc(C)], where maxpredesc(C) is the
highest preorder number of the children of C in the descendants DAG.

 Ancestors interval: the information about ancestors of C is encoded using
the interval [preanc(C),maxpreanc(C)] where maxpreanc(C) is the highest
(ancestor) preorder number of the parents of C in the ancestors DAG.

E. Jim enez-Ruiz and B. Cuenca Grau

Anatomy  BiologicalProcess
TransmembraneTransport  BP hasLocation.CellularMembrane
BP hasLocation.  BiologicalProcess
  BP hasLocation.Anatomy
CellularSecretion  TransmembraneTransport
ExocrineGlandFluid  AS hasLocation.ExocrineSystem
  AS hasLocation.Anatomy
AS hasLocation.  Anatomy
Smegma  ExocrineGlandFluid
ExocrineGlandFluid  ExfoliatedCells  Smegma
(a) NCI ontology fragment
?

?

?
[1,9]



[2,4]


[1,9]

[5,9]

[2,4]

[5,7]

[8,8]
[7,7]

[9,9]
[7,7]

[3,4]

[6,7]

[8,8]

[9,9]

[3,4]

[6,7]

[4,4]

[7,7]

[4,4]

[7,7]

(b) Descendant intervals

(c) Ancerstor intervals

Fig. 2. NCI extended hierarchies. Abbreviations: BP =BiologicalProcess, A=Anatomy,
TT =TransmembraneTransport, CM =CellularMembrane, EGF =ExocrineGlandFluid,
CS =CellularSecretion, ES =ExocrineSystem, S =Smegma

Figure 2 shows a fragment of NCI and its labelled (entailed) hierarchy. Disjointness and complex class axioms are represented in a separate structure that also
uses integer intervals.

The interval labelling schemas provides LogMap with an interface to efficiently
answer queries about taxonomic relationships. For example, the following typical
queries over ontology hierarchies only require simple integer operations (please,
refer to Figure 2 for the class label abbreviations):

 Is Smegma a subclass of Anatomy?: check if predesc(S)=7 is contained in

descendants interval [predesc(A), maxpredesc(A)]=[5,9];

 Do Smegma and CellularSecretion have ancestors in common?: check if
the intersection of ancestors intervals [preanc(S), maxpreanc(S)]=[5,7] and
[preanc(CS), maxpreanc(CS)]=[2,4] is non-empty.
?

?

?
Table 2. Fragment of the intersection between the inverted indexes for FMA and NCI

FMA ids NCI ids Mappings
?

?

?
Entry
secretion
smegma

trapezoid

trapezoid,bone

20948,
?

?

?
37975,

FMA:Secretion  NCI:CellularSecretion
FMA:Smegma  NCI:Smegma
FMA:Trapezoid  NCI:Trapezoid
FMA:Trapezoid  NCI:TrapezoidBone
FMA:Trapezoid  NCI:TrapezoidBone
FMA:Bone of Trapezoid  NCI:TrapezoidBone

2.3 Computing Anchor Mappings

LogMap computes an initial set of anchor mappings by simply intersecting the
inverted indexes of the input ontologies (i.e., by checking whether two lexical
entries in the indexes of the input ontologies contain exactly the same strings).
Anchor computation is hence extremely efficient. Table 2 shows the result of
intersecting the inverted indexes of Table 1, which yields five anchor mappings.
Given an anchor m = (C1  C2), LogMap uses the string matching tool ISUB
to match the neighbours of C1 in the ontology hierarchy of O1 to the neighbours
of C2 in the hierarchy of O2. LogMap then assigns a confidence value to m by
computing the proportion of matching neighbours weighted by the ISUB similarity values. This technique is based on a principle of locality: if the hierarchy
neighbours of the classes in an anchor match with low confidence, then the anchor may be incorrect. For example, LogMap matches classes FMA:Trapezoid and
NCI:Trapezoid (see Table 2). However, NCI:Trapezoid is classified as a polygon
whereas FMA:Trapezoid is classified as a bone. LogMap assigns a low confidence
to such mappings and hence they will be susceptible to be removed during repair.

2.4 Mapping Repair and Discovery

The core of LogMap is an iterative process that alternates mapping repair and
mapping discovery steps. In each iteration, LogMap maintains two structures.

 A working set of active mappings, which are mappings that were discovered
in the immediately preceding iteration. Mappings found in earlier iterations
are established, and cannot be eliminated in the repair step. In the first
iteration, the active mappings coincide with the set of anchors.

 For each anchor, LogMap maintains two contexts (one per input ontology),
which can be expanded in different iterations. Each context consists of a set
of classes and has a distinguished subset of active classes, which is specific
to the current iteration. In the first iteration, the contexts for an anchor
C1  C2 are {C1} and {C2} respectively, which are also the active classes.
Thus, active mappings are the only possible elements of a repair plan, whereas
contexts constitute the basis for mapping discovery.

E. Jim enez-Ruiz and B. Cuenca Grau

Table 3. Propositional representations of FMA, NCI, and the computed mappings

(1)

(2)
(3)

Propositional FMA (P1)
Smegma  Secretion
Secretion  PortionBodySusbstance
PortionBodySusbstance  AnatomicalEntity (10) CellularSecretion  TransmembraneTransport
(11) TransmembraneTransport  TransportProcess
Computed mappings (PM )
(12) TransportProcess  BiologicalProcess
(13) Anatomy  BiologicalProcess  false
(14) ExocrineGlandFluid  ExfolCells  Smegma

Propositional NCI (P2)
Smegma  ExocrineGlandFluid
ExocrineGlandFluid  Anatomy

(m4) FMA:Secretion  NCI:CellularSecretion
(m5) NCI:CellularSecretion  FMA:Secretion
(m6) FMA:Smegma  NCI:Smegma
(m7) NCI:Smegma  FMA:Smegma

(8)

(9)

FMA:AnatomicalEntity

NCI:BiologicalProcess

NCI:TransportProcess

FMA:PortionBodySusbstance

NCI:Anatomy

NCI:TransmembraneTransport

FMA:Secretion

NCI:CellularSecretion

m4

m5

NCI:ExocrineGlandFluid

FMA:Smegma

m6

m7

NCI:Smegma

NCI:ExfolCells

Fig. 3. Graph representation of Horn-clauses in Table 3

.

Mapping Repair. LogMap uses a Horn propositional logic representation of
the extended hierarchy of each ontology together with all existing mappings
(both active and established). As an example, Table 3 shows Horn clauses obtained from the extended hierarchies of FMA and NCI (which have been computed using a DL reasoner), and the anchor mappings computed by LogMap.
As shown in the table, LogMap splits each equivalence mapping into two Horn
clauses.

The use of a propositional Horn representation for unsatisfiability detection
and repair is key to LogMaps scalability since DL reasoners do not scale well
with the integration of large ontologies via mappings. The scalability problem is
exacerbated by the number of unsatisfiable classes (more than 10,000 found by
LogMap when integrating SNOMED and NCI using only anchors) and the large
number of additional reasoner calls required for repairing each unsatisfiability.
Unsatisfiability checking. LogMap implements the well-known Dowling-Gallier
algorithm [7] for propositional Horn satisfiability, and calls the Dowling-Gallier
module once (in each repair step) for each class. Our implementation takes as
input a class C (represented as a propositional variable) and determines the
satisfiability of the propositional theory PC consisting of
?

?

?
hierarchies of the input ontologies O1 and O2; and

 the rule (true  C);
 the propositional representations P1 and P2 (as in Table 3) of the extended
 the propositional representation PM of the mappings computed thus far.
We make the following important observations concerning our encoding of the
class satisfiability problem into propositional logic.
 Our encoding is sound. If the propositional theory PC is unsatisfiable, then
the class C is indeed unsatisfiable w.r.t. the DL ontology O1O2M, where
O1 and O2 are the input ontologies and M is the set of mappings computed
so far by LogMap (represented as DL concept inclusions)
 Due to the properties of the Dowling-Gallier algorithm, our encoding is
worst-case linear in the size of PC. Furthermore, the total number of calls
to the Dowling-Gallier module is also linear in the number of classes of O1
and O2. As shown in the evaluation section, these favourable computational
properties are key to the scalability of LogMap.

 Our encoding is incomplete, and hence we might be reporting unsatisfiable
classes as satisfiable. Incompleteness is, however, mitigated by the following
facts. First, the extended hierarchies of O1 and O2 have been computed
using a complete reasoner and many consequences that depend on nonpropositional reasoning have already been pre-computed. Second, mappings
computed by LogMap (and by most ontology matching tools) correspond to
Horn rules. For example, as shown in our experiments, LogMap only failed
to report one unsatisfiable class for FMA-NCI (from more than 600).

A complete description of the Dowling and Gallier algorithm can be found in [7].
As an example, consider Figure 3, which shows the graph representation of all
propositional clauses that are involved in the unsatisfiability of the class Smegma
in FMA. Each node represents a propositional variable in Table 3; furthermore,
the graph contains a directed edge labelled with a propositional rule r from
variable C to variable D if the head of r is D and C occurs in the body of r.
Note that there is a path from true to NCI:BiologicalProcess and a path from true
to NCI:Anatomy which involve only rules with a single variable in the antecedent;
furthermore, the variables NCI:BiologicalProcess and NCI:Anatomy constitute the
body of rule (13), whose head is precisely false.
Computing repair plans. LogMap computes a repair for each unsatisfiable class
identified in the input ontologies. Given an unsatisfiable class C and the propositional theory PC, a repair R of PC is a minimal subset of the active mappings
in PM such that PC \ R is satisfiable.
To facilitate computation of repairs, LogMap extends Dowling-Galliers
algorithm to record all active mappings (Pact) that may be involved in each
unsatisfiability. For our example in Figure 3, LogMap records the active mappings Pact = {m4, m5, m6, m7}, which may be relevant to the unsatisfiability of
FMA:Smegma. This information is used in the subsequent repair process.

To improve scalability, repair computation is based on the greedy algorithm
in Table 4. Unsatisfiable classes in each ontology are ordered by their topological

E. Jim enez-Ruiz and B. Cuenca Grau

Table 4. Repair in LogMap. A call to DowlingGallier returns a satisfiability value sat
and, if sat = false, it optionally returns the relevant active mappings (Pact).

PC := P1  P2  PM  {true  C}
sat,Pact := DowlingGallier(PC)
if sat = false then

Repairs := 
repair size := 1
repeat

Procedure Repair
Input: List: Ordered classes; P1, P2 and PM Horn-propositional theories.
Output: PM : set of repaired mappings
1: for each C  List do
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
end if
16:
17: end for
18: return PM

until |Repairs| > 0
R := element of Repairs with minimum confidence.
PM := PM \ R

for each subset R of Pact of size repair size do
sat := DowlingGallier(PC \ R)
if sat = true then Repairs := Repairs  {R}

end for
repair size := repair size + 1

level in the hierarchy. Since subclasses of an unsatisfiable class are unsatisfiable,
repairing first classes high-up in the hierarchy is a well-known repair strategy.
Given each unsatisfiable class C and the relevant active mappings Pact computed using Dowling-Gallier, the algorithm identifies subsets of Pact of increasing
size until a repair is found. Thus, our algorithm is guaranteed to compute all repairs of smallest size. In our example, our algorithm computes repairs R1 = {m4}
and R2 = {m6} consisting of only one mapping. If more than one repair is found,
LogMap selects the one with the minimum confidence value.

Finally, each equivalence mapping is split into two propositional rules, which
are treated independently for repair purposes. Hence, a repair may include only
one such rule, thus weakening the mapping, as in the case of R1 and R2.

Mapping Discovery. LogMap computes new mappings by first expanding the
contexts Cm
2 for each anchor m, and then (incrementally) matching the
classes in Cm

1 and Cm
1 to those in Cm

2 using ISUB, as described next.

Context expansion. LogMap only expands contexts that are open (i.e., with at
least one active class). The expansion of an open context is performed by adding
each neighbour (in the corresponding class hierarchy) of an active class in the
context. The set of active classes in each context is then reset to the empty set.

Context matching using ISUB. LogMap makes a call to ISUB for each pair of
classes C  Cm
2 , but only if the same call has not been performed

1 and D  Cm
?

?

?
in previous discovery steps (for these or other contexts). Thus, LogMap never
calls ISUB twice for the same input classes. We call relevant those new lexical
correspondences found by ISUB (in the current iteration) with a similarity value
exceeding a given expansion threshold.

classes of Cm

LogMap uses these relevant correspondences to determine the set of active
2 for the next iteration as well as the set of new mappings.
2 are those that participate in some

 The new active classes of Cm

1 and Cm

1 and Cm

relevant correspondence.

 The current set of mappings is expanded with those relevant correspondences
with similarity value exceeding a mapping threshold (which is higher than the
expansion threshold). These new mappings will constitute the set of active
mappings for the next repair step.

The use of ISUB allows LogMap to discover new mappings that, unlike anchors,
are not lexically exact (but with similarity higher than the mapping threshold).
The number of ISUB tests performed is relatively small: only contexts for the
same anchor are matched using ISUB, the same ISUB call is never performed
twice, and context growth is limited by the expansion threshold.

2.5 Overlapping Estimation

1 and O

1 and O

2 of O1 and O2, respectively. Intuitively, O

In addition to the mappings, LogMap also returns two (hopefully small) fragments O
2 represent
the overlapping between O1 and O2, in the sense that each correct mapping
not found by LogMap is likely to involve only classes in these fragments. Thus,
1 and O
domain experts can focus only on O
2 when looking for missing mappings
between O1 and O2. The computation of O
1 and O
2 is performed in two steps.
1. Computation of weak anchors. Recall that LogMap computed the initial
anchors by checking whether two entries in the inverted index of O1 and O2
contained exactly the same set of strings (c.f., Section 2.3). For the purpose of
overlapping estimation (only), LogMap also computes new anchor mappings
that are weak in the sense that the relevant entries in the inverted index are
only required to contain some common string. Thus, weak anchors represent
correspondences between classes that have a common lexical component.
2. Module extraction. The sets Si of classes in Oi involved in either a weak
anchor or a mapping computed by LogMap are then used as seed signatures for module extraction. In particular, O
2) are computed by
extracting a locality-based module [6] for S1 in O1 (resp. for S2 in O2).

1 (resp. O

Note that, unlike anchors,
weak anchors are not well-suited for mapping
computation since they rarely correspond to real mappings, and hence they
introduce unmanageable levels of noise. For example, the discovered correspondence NCI:CommonCarotidArteryBranch  FMA:BranchOfCommonCochlearArtery
is a weak anchor between NCI and FMA because both classes share the terms
branch, common and artery; however, such correspondence is clearly not a
standard mapping since none of the involved classes is subsumed by the other.
?

?

?
Table 5. Repairing Gold Standards. The  column indicates subsumption mappings.
The % of total mappings includes those weakened from equivalence to subsumption.

Ontologies

GS Mappings
Total Unsat.

Total

Repaired Mappings

 Time (s)
10.6
(96%) 2,898

81.4
(89%) 8,111 1,619
812.4

-
-

20,944 (93%) 18,322
1,520

6,179

FMA-NCI
3,024
FMA-SNOMED 9,072
19,622
SNOMED-NCI
Mouse-NCIAnat.
1,520

3 Evaluation

We have implemented LogMap in Java and evaluated it using a standard laptop
computer with 4 Gb of RAM.

We have used the following ontologies in our experiments: SNOMED CT Jan.
2009 version (306, 591 classes); NCI version 08.05d (66, 724 classes); FMA version
2.0 (78, 989 classes); and NCI Anatomy (3, 304 classes) and Mouse Anatomy
(2, 744 classes), both from the OAEI 2010 benchmark [8]. Classification times
for these ontologies were the following: 89s for SNOMED, 575s for NCI, 28s for
FMA, 1s for Mouse Anatomy, and 3s for NCI Anatomy.2 We have performed
the following experiments,3 which we describe in detail in the following sections.

1. Repair of gold standards. We have used LogMaps mapping repair module
(c.f. Section 2.4) to automatically repair the mappings in two gold standards:
 The mappings FMA-NCI, FMA-SNOMED and SNOMED-NCI included

in UMLS Metathesaurus [2] version 2009AA;4 and

 the OAEI 2010 anatomy track gold standard [3].

2. Matching large ontologies. We have used LogMap to match the following
pairs of ontologies: FMA-NCI, FMA-SNOMED, SNOMED-NCI, and Mouse
Anatomy-NCI Anatomy. To the best of our knowledge, no tool has so far
matched FMA, NCI and SNOMED; hence, we only compare our results with
other tools for the case of Mouse Anatomy-NCI Anatomy.

3. Overlapping estimation. We have used LogMap to estimate the overlapping

between our test ontologies as described in Section 2.5.

3.1 Repairing Gold Standards

Table 5 summarises our results. We can observe the large number of UMLS mappings between these ontologies (e.g., almost 20, 000 for SNOMED-NCI). Using
LogMap we could also detect a large number of unsatisfiable classes (ranging
from 655 for FMA-NCI to 20, 944 for SNOMED-NCI), which could be repaired
efficiently (times range from 10.6s for FMA-NCI to 812.4s for SNOMED-NCI).

2 We used ConDOR [22] to classify SNOMED, and HermiT [17] for the others.
3 Output resources available in: http://www.cs.ox.ac.uk/isg/projects/LogMap/
4 The mappings are extracted from the UMLS distribution files (see [13] for details).
?

?

?
Table 6. Mappings computed by LogMap

Found Mapp. Output Mapp.
Total Unsat.

Total

Time (s)

Ontologies

FMA-NCI
3,185
FMA-SNOMED 2,068
14,250
SNOMED-NCI
Mouse-NCIAnat
1,369

 Anchors Total
69.8

92.2

528.6 1370.0
10,452 (95%) 13,562 1,540

15.7

(94%) 3,000
(99%) 2,059

(99%) 1,367

28.3
35.6
?

?

?
1.8

Finally, the repair process was not aggressive, as it resulted in the deletion of a
small number of mappings;5 for example, in the case of NCI and FMA LogMap
preserved 96% of the original mappings, and also managed to weaken 78 equivalence mappings into subsumption mappings (instead of deleting them).

We have used the reasoners HermiT and ConDOR to classify the merge of the
ontologies and the repaired mappings, thus verifying the results of the repair. For
FMA-NCI, we found one unsatisfiable class that was not detected by LogMaps
(incomplete) reasoning algorithm. Unsatisfiability was due to a complex interaction of three exact lexical mappings with axioms in NCI and FMA involving
existential and universal restrictions. For FMA-SNOMED and SNOMED-NCI
we could not classify the merged ontologies, so we extracted a module [6] of the
mapped classes in each ontology. For FMA-SNOMED we could classify the merge
of the corresponding modules and found no unsatisfiable classes. For SNOMEDNCI no reasoner could classify the merge of the modules.

In the case of the Mouse Anatomy and NCI Anatomy ontologies from OEAI,

we found no unsatisfiable class using both LogMap and a DL reasoner.

3.2 Matching Large Ontologies

Table 6 summarises the results obtained when matching our test ontologies using
LogMap for a default expansion threshold of 0.70 and mapping threshold of 0.95.
The second and third columns in Table 6 indicate the total number of mappings found by LogMap (in all repair-discovery iterations), and the total number
of detected unsatisfiable classes, respectively. The fourth and fifth columns provide the total number of output mappings (excluding those discarded during
repair) and shows how many of those mappings were weakened from equivalence to simple subsumption during the repair process. We can observe that,
despite the large number of unsatisfiable classes, the repair process was not aggressive and more than 94% (in the worst case) of all discovered mappings were
returned as output. Finally, the last two columns show the times for anchor
computation and repair, and the total matching time.6

Total matching time (including anchor computation and repair-discovery it-
erations) was less than two minutes for FMA-NCI and FMA-SNOMED. The

5 The repair process in our prior work was much more aggressive [13]; for example,

63% of UMLS for SNOMED-NCI were deleted.

6 Excluding only indexation time, which is negligible.

E. Jim enez-Ruiz and B. Cuenca Grau

Table 7. Precision and recall w.r.t. Gold Standard

Found Mappings

Output Mappings

Ontologies

Precision Recall F-score Precision Recall F-score

FMA-NCI
FMA-SNOMED
SNOMED-NCI
Mouse-NCIAnat

0.767
0.767
0.753
0.917

0.843
0.195
0.585
0.826

0.803
0.312
0.659
0.870

0.811
0.771
0.786
0.918

0.840
0.195
0.582
0.826

0.825
0.312
0,668
0.870

Table 8. Missed mappings by LogMap with respect to repaired gold standard
GS ISUB  0.95 GS ISUB  0.80 GS ISUB  0.50
% Mapp. Recall % Mapp. Recall % Mapp. Recall

Ontologies

FMA-NCI
FMA-SNOMED
SNOMED-NCI
Mouse-NCIAnat

88%
21%
62%
75%

0.96
0.95
0.94
0.99

93%
64%
75%
87%

0.90
0.30
0.77
0.95

97%
92%
89%
95%

0.87
0.21
0.65
0.88

slowest result was obtained for SNOMED-NCI (20 minutes) since repair was
costly due to the huge number of unsatisfiable classes. We could only compare
performance with other tools for Mouse-NCIAnat (the largest ontology benchmark in the OAEI). LogMap matched these ontologies in 15.7 seconds, whereas
the top three tools in the 2009 campaign (no official times in 2010) required 19,
23 and 10 minutes, respectively; furthermore, the CODI tool, which uses sophisticated logic-based techniques to reduce unsatisfiability, reported times between
60 to 157 minutes in the 2010 OAEI [20].

Table 7 shows precision and recall values w.r.t. our Gold Standards (the
clean UMLS-Mappings from our previous experiment and the mappings in the
anatomy track of the OAEI 2010 benchmark). The left-hand-side of the table
shows precision/recall values for the set of all mappings found by LogMap (by
disabling the repair module), whereas the right-hand-side shows precision/recall
for the actual set of output mappings. Our results can be summarised as follows:
 Although the main benefit of repair is to prevent logical errors, the table

shows that repair also increases precision without harming recall.

 In the case of Mouse-NCIAnat we obtained an F-score in line with the best

systems in the 2010 OAEI competition [8].

 Results for FMA-NCI were very positive, with both precision and recall exceeding 0.8. Although precision was also high for SNOMED-NCI and FMA-
SNOMED, recall values were much lower, especially for FMA-SNOMED.

We have analysed the reason for the low recall values for FMA-SNOMED and
SNOMED-NCI. Our hypothesis was that SNOMED is lexically incompatible
with FMA and NCI since it uses very different naming conventions. Results in
Table 8 support this hypothesis. Table 8 shows, on the one hand, the percentage
of gold standard mappings with an ISUB similarity exceeding a given threshold
and, on the other hand, the recall values for LogMap w.r.t. such mappings only.
?

?

?
Table 9. Overlapping computed by LogMap

Ontologies

O1-O2
FMA-NCI

Overlapping for O1
O
1 % O1 Recall
6,512
FMA-SNOMED 20,278
70,705
SNOMED-NCI
Mouse-NCIAnat
1,864

8%
26%
23%
68%

Overlapping for O2
O
2 % O2 Recall
0.97
0.95 12,867
0.94
0.92 50,656
0.96
0.86 33,829
0.93
1,894
0.93

19%
17%
51%
57%

Note that LogMap could find in all cases more than 94% of the gold standard
mappings having ISUB similarity above 0.95. However, only 21% of the gold standard FMA-SNOMED mappings exceeded this value (in contrast to 88% between
FMA and NCI), showing that these ontologies use very different naming con-
ventions. To achieve a high recall for FMA-SNOMED mappings, LogMap would
need to use a mapping threshold of 0.5, which would introduce an unmanageable
amount of noisy mappings, thus damaging both precision and scalability.

3.3 Overlapping Estimation
Our results concerning overlapping are summarised in Table 9, where O
O
2 are the fragments of the input ontologies computed by LogMap.
We can see that the output fragments are relatively small (e.g., only 8% of
FMA and 19% of NCI for FMA-NCI and only 26% of FMA and 17% of SNOMED
for FMA-SNOMED). Our results also confirm the hypothesis that correct mappings involving an entity outside these fragments are rare. As shown in the table,
a minimum of 86% and a maximum of 97% of Gold Standard UMLS mappings
involve only classes in the computed fragments. Thus, these results confirm our
hypothesis even for FMA-SNOMED and SNOMED-NCI, where LogMap could
only compute a relatively small fraction of the Gold Standard mappings.

1 and

4 Conclusion and Future Work

In this paper, we have presented LogMapa highly scalable ontology matching tool with built-in reasoning and diagnosis capabilities. LogMaps features
and scalability behaviour make it well-suited for matching large-scale ontolo-
gies. LogMap, however, is still an early-stage prototype and there is plenty of
room for improvement. We are currently working on further optimisations, and
in the near future we are planning to integrate LogMap with a Protege-based
front-end, such as the one implemented in our tool ContentMap [12].
Acknowledgements. We would like to acknowledge the funding support of the
Royal Society and the EPSRC project LogMap, and also thank V. Nebot and R.
Berlanga for their support in our first experiments with structural indexation.
