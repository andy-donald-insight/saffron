Extending Logic Programs with Description

Logic Expressions for the Semantic Web

Yi-Dong Shen1 and Kewen Wang2

1 State Key Laboratory of Computer Science, Institute of Software

Chinese Academy of Sciences, Beijing 100190, China

2 School of Computing and Information Technology, Griffith University

ydshen@ios.ac.cn

Brisbane, QLD 4111, Australia

k.wang@griffith.edu.au

Abstract. Recently much attention has been directed to extending logic
programming with description logic (DL) expressions, so that logic programs have access to DL knowledge bases and thus are able to reason
with ontologies in the Semantic Web. In this paper, we propose a new
extension of logic programs with DL expressions, called normal DL logic
programs. In a normal DL logic program arbitrary DL expressions are
allowed to appear in rule bodies and atomic DL expressions (i.e., atomic
concepts and atomic roles) allowed in rule heads. We extend the key condition of well-supportedness for normal logic programs under the standard answer set semantics to normal DL logic programs and define an
answer set semantics for DL logic programs which satisfies the extended
well-supportedness condition. We show that the answer set semantics for
normal DL logic programs is decidable if the underlying description logic
is decidable (e.g. SHOIN or SROIQ).

1 Introduction

In the development of Semantic Web languages we are concerned with two major
components: ontologies and rules. Ontologies describe terminological knowledge
and rules model constraints and exceptions over the ontologies. Since the two
components provide complementary descriptions of the same problem domain,
they are supposed to be integrated in some ways (e.g., [2,4,16,18,19]; see [3] for
a survey). The core of the Web ontology language OWL (more recently, OWL
2) [13,9] is description logics (DLs) [1] and thus in this paper we assume an
ontology is represented as a knowledge base in DLs.

Logic programming under the (standard) answer set semantics [8] is currently a widely used declarative language paradigm for knowledge representation and reasoning. A normal logic program  consists of rules of the form
H  A1, , Am, not B1, , not Bn, where H and each Ai and Bi are atoms.
Such a rule states that if the body A1, , Am, not B1, , not Bn holds, then
the head H holds. The semantics of  is defined by answer sets, which are Herbrand models of  satisfying the well-supportedness condition [8,7]. Informally,

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 633648, 2011.
c Springer-Verlag Berlin Heidelberg 2011

Y.-D. Shen and K. Wang

a Herbrand model I is well-supported if for any H  I, there is a rule as above
from  such that I satisfies the rule body and for no Ai the evidence of the truth
of Ai is circularly dependent on H in I. It is this well-supportedness condition
that lets rules in a logic program differ from formulas (implications) in classical
logic and guarantees that answer sets are free of circular justifications.

Recently, much attention has been directed to using logic programs to express
rules in the Semantic Web by extending logic programming under the answer set
semantics with DL expressions [4,16,19]. By allowing DL expressions to appear
in rules, logic programs have access to DL knowledge bases and thus are able
to reason with ontologies in the Semantic Web. Major current extensions of
logic programs with DL expressions include description logic programs (or dl-
programs) [4], DL+log [19] and disjunctive dl-programs [16].

Given an external DL knowledge base L, a dl-program extends a normal logic
program  by adding dl-atoms to rule bodies as an interface to access to L [4].
A dl-atom is of the form DL[S1op1P1, , SmopmPm; Q](t), where each SiopiPi
semantically maps a predicate symbol Pi in  to a concept or role Si in L via
a special interface operator opi  { + , - , - }, and Q(t) is a DL expression
which will be evaluated against L after the predicate mapping. For instance,
p(a)  DL[c + p, b - q; cb](a) is a rule, where the dl-atom queries L if a is in
the concept c but not in the concept b, given the mapping that for any x, if p(x)
is true then x is in c and if q(x) is false then x is not in b. Note that predicate
symbols in  must be disjoint from predicate symbols (i.e., atomic concepts and
atomic roles) in L. Moreover, DL expressions are not allowed to appear in the
head of a rule, thus no conclusion about L can be inferred from .

It is necessary to allow DL expressions to occur in rule heads because DL
knowledge bases (ontologies) define only general terminological knowledge, while
additional constraints and exceptions over some DL concepts/roles must be defined by rules. To avoid predicate mappings between L and  and allow DL
expressions to appear in rule heads, another extension, called DL+log, is introduced [19]. DL+log lets  and L share some predicate symbols and allows
atomic DL expressions (i.e. atomic concepts and atomic roles) to appear either
in bodies or heads of rules without using any predicate mapping operators. One
restriction of this extension is that DL expressions are not allowed to appear
behind the negation operator not.

Disjunctive dl-programs [16] are a third extension of logic programs with DL
expressions. This extension allows atomic DL expressions to appear anywhere in
a rule, and has a semantics substantially different from that of DL+log.

For dl-programs, three answer set semantics are introduced in [4,5], called the
weak, strong, and FLP-reduct based semantics, respectively. These semantics
are proper extensions of the standard answer set semantics, but their answer
sets do not satisfy the well-supportedness condition and thus may incur circular
justifications by self-supporting loops. For DL+log, a semantics is defined with a
class of first-order models, called NM-models [19]. Such NM-models are not wellsupported models. For disjunctive dl-programs, an FLP-reduct based answer set
semantics is defined [16]. It is a proper extension of the standard answer set
?

?

?
semantics, but its answer sets do not satisfy the well-supportedness condition
either and thus may also incur circular justifications.

Observe that the three major extensions of logic programs with DL expressions
have complementary features. In syntax, dl-programs allow arbitrary DL expressions in rule bodies, while DL+log and disjunctive dl-programs allow atomic DL
expressions in rule heads. In semantics, in dl-programs and DL+log, DL concepts
and roles occurring in  are all interpreted against the external DL knowledge
base L under the first-order semantics, while in disjunctive dl-programs, these
DL concepts and roles are all included in the Herbrand base of  and interpreted under the answer set semantics. These observations suggest that it is
desirable to have a new extension of logic programs with DL expressions, which
allows arbitrary DL expressions in rule bodies and atomic DL expressions in rule
heads, and interprets DL concepts and roles occurring in  flexibly in either of
the above ways. Moreover, as we mentioned earlier, well-supportedness is a key
condition of logic programming under the standard answer set semantics, so it is
desirable to extend this condition to logic programs with DL expressions. In fact,
the well-supportedness condition has recently been extended to dl-programs and
a new answer set semantics for dl-programs has been developed which satisfies
the extended well-supportedness condition [20].

Therefore, in this paper we advance one step further by introducing a fourth
extension of logic programs with DL expressions as follows: (1) Given an external
DL knowledge base L, we extend a normal logic program  with DL expressions relative to L by introducing rules of the form H  A1, , Am, not B1, ,
not Bn, where H is an atom or an atomic DL expression, and each Ai and Bi
are either atoms or arbitrary DL expressions. We call this extension  relative
to L a normal DL logic program. (2) We allow DL concepts and roles occurring
in  to flexibly choose between first-order interpretations and Herbrand inter-
pretations, as described above. (3) We extend the well-supportedness condition
of the standard answer set semantics from normal logic programs to normal DL
logic programs, and define an answer set semantics which satisfies the extended
well-supportedness condition and thus whose answer sets are free of circular jus-
tifications. (4) We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN
or SROIQ [13,12]).

The paper is arranged as follows. Section 2 briefly reviews logic programs
and DL knowledge bases. Section 3 defines normal DL logic programs. Section
4 mentions related approaches, and Section 5 concludes with future work.

2 Preliminaries

2.1 Logic Programs

Consider a vocabulary  = (P, C), where P is a finite set of predicate symbols
and C a nonempty finite set of constants. A term is either a constant from C
or a variable. Predicate symbols begin with a capital letter, and constants with
a lower case letter. We use strings starting with X, Y or Z to denote variables.

Y.-D. Shen and K. Wang

An atom is of the form P (t1, ..., tm), where P is a predicate symbol from P, and
ti is a term. A rule r is of the form

H  A1, , Am, not B1, , not Bn

(1)

where H and each Ai and Bi are atoms. Each Ai is called a positive literal,
and each not Bi called a negative literal. We use head(r) and body(r) to denote
the head H and the body A1, , Am, not B1, , not Bn, respectively. We also
use pos(r) to denote the positive literals A1, , Am, and neg(r) to denote the
negative literals not B1, , not Bn. Therefore, a rule r can simply be written
as head(r)  body(r) or head(r)  pos(r), neg(r).

 = {A | A  I

A normal logic program  consists of a finite set of rules. A ground instance
of a rule r is obtained by replacing every variable in r with a constant from C.
We use ground() to denote the set of all ground instances of rules in . The
Herbrand base of , denoted HB, is the set of all ground atoms P (t1, ..., tm),
where P  P occurs in  and ti is in C. Any subset of HB is a Herbrand
interpretation (or interpretation for short) of . For an interpretation I, let
 = HB \ I and I

An interpretation I satisfies a ground atom A  HB if A  I, and I satisfies
not A if A  I. For a rule r in ground(), I satisfies body(r) if for each (positive
or negative) literal l in body(r), I satisfies l; I satisfies r if I does not satisfy
body(r) or I satisfies head(r). I is a model of  if I satisfies all r  ground().
A minimal model is a model that is minimal in terms of set inclusion.
Let  I = {A  pos(r) | A  pos(r), neg(r)  ground() and I satisfies
neg(r)}. Since  I has no negative literals in rule bodies, it has a least model.
The standard answer set semantics defines I to be an answer set of  if I is the
least model of  I [8].

}.

2.2 DL Knowledge Bases

We assume familiarity with the basics of description logics (DLs) [1], and for
simplicity consider SHOIN , a DL underlying the Web ontology language OWL
DL [13]. The approach presented in this paper can easily be extended to other
more expressive DLs such as SROIQ (a logical underpinning for OWL 2) [12,9],
and to DLs with datatypes such as SHOIN (D) and SROIQ(D).
Consider a vocabulary  = (A  R, I), where A, R and I are pairwise disjoint
(denumerable) sets of atomic concepts, atomic roles and individuals, respectively.
. General
A role is either an atomic role R from R or its inverse, denoted R
concepts C are formed from atomic concepts, roles and individuals, according to
the following syntax:
C ::= |  | A | {a} | C  C1 | C  C1 | C | R.C | R.C | n R | n R
where A is an atomic concept from A, R is a role, a is an individual from
I, C and C1 are concepts, and n is a non-negative integer. An axiom is of the
form C  D (concept inclusion axiom), R  R1 (role inclusion axiom), Trans(R)
(transitivity axiom), C(a) (concept membership axiom), R(a, b) (role membership
?

?

?
axiom), =(a, b) (equality axiom), or =(a, b) (inequality axiom), where C, D are
concepts, R, R1 are atomic roles in R, and a, b are individuals in I. We use
C  D to denote C  D and D  C.

A DL knowledge base L is a finite set of axioms. Since DLs are fragments
of first-order logic with equality, where atomic concepts (resp. roles) are unary
(resp. binary) predicate symbols, and individuals are constants, L has the firstorder semantics. When we say predicate symbols in L, we refer to atomic concepts or atomic roles in L. L is consistent (or satisfiable) if L has a first-order
model. For an axiom F , the entailment relation L |= F is defined as in firstorder logic, i.e., L entails F if all models of L are models of F . Note that if L is
inconsistent, L entails everything.

A DL expression, also called a DL query in [4], which is allowed to appear in
rules of a logic program, is either (i) a concept inclusion axiom F or its negation
F ; or (ii) of the form C(t) or C(t), where C is a concept, and t is a term (i.e.,
a variable or a constant); or (iii) of the form R(t1, t2) or R(t1, t2), where R is a
role, and t1 and t2 are terms; or (iv) of the form =(t1, t2) or =(t1, t2), where t1 and
t2 are terms. An atomic DL expression is either C(t) or R(t1, t2), where C is an
atomic concept and R an atomic role. For convenience, we denote a DL expression
by Q(t), where t denotes all terms occurring in the expression (e.g., t1 and t2 in
(iii)), and Q denotes the remaining part of the expression (e.g., R or R in (iii)).

3 Normal DL Logic Programs
Let L be a DL knowledge base built over a vocabulary  = (A  R, I), and
 be a normal logic program built over  = (P, C). To extend  with DL
expressions relative to L, we first extend  such that: (i) all constants in C are
individuals in I (i.e., C  I), so that constants occurring in DL expressions are
individuals, and (ii) some atomic concepts and roles in A  R are included in
P (as unary and binary predicate symbols, respectively), so that we can make
conclusions about them in the same way as other predicate symbols in P. To
ensure decidability, we require that P and C be finite. Let  = P  (A  R)
denote the set of predicate symbols shared by  and L.

Definition 1. Let L be a DL knowledge base. A normal DL logic program 
with DL expressions relative to L consists of a finite set of rules of form (1),
where H is an atom, and each Ai and Bi are either atoms or DL expressions.
Note that when the predicate symbol of an atom in  is in , the atom is also
an atomic DL expression.

A ground instance of a rule (resp. a DL expression) in  is obtained by
replacing all variables with constants in C. Let ground() denote the set of
ground instances of all rules in . The Herbrand base HB of  relative to L
is the set of all ground atoms P (t1, ..., tm), where P  P occurs either in  or
in L and each ti is in C. Any subset of HB is a Herbrand interpretation (or
simply interpretation) of  relative to L. When the context is clear, we omit the
phrase relative to L.

Y.-D. Shen and K. Wang

For an interpretation I, let I| = {A  I | the predicate symbol of A is in
 | the predicate symbol of A is in }. We say that I is
| is consistent. Note that when I is consistent

} and I
consistent with L if L I| I
with L, L must be consistent.

| = {A  I

Since DL expressions must be evaluated against L, the satisfaction relation
for normal logic programs needs to be extended to normal DL logic programs.
In the sequel, by a literal we refer to A or not A, where A is an atom or a DL
expression.

if A  I.

| |= A.

Definition 2. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L, I an interpretation, and l a ground literal. We use
I |=L l to denote that I satisfies l under L, which is defined as follows:
1. For a ground atom A  HB, which is not an atomic DL expression, I |=L A
2. For a ground DL expression A, I |=L A if L  I| I
3. For a ground atom or a ground DL expression A, I |=L not A if I |=L A.
For a rule r in ground(), I |=L body(r) if for each (positive or negative)
literal l in body(r), I |=L l; I |=L r if I |=L body(r) or I |=L head(r). I is a model
of  relative to L if I is consistent with L and I |=L r for all r  ground().
Note that when L is inconsistent,  has no model relative to L.
Example 1. Let L = {B(a)} and  = {A(X)  not (A  B)(X)}. Let
P = {A}, C = {a} and  = {A}. Note that (AB)(X) is a DL expression, and
A(X) is both an atom and an atomic DL expression. We have HB = {A(a)}
and ground() = {A(a)  not (A  B)(a)}.  has two models relative to
L: I1 =  and I2 = {A(a)}. For the rule r in ground(), I1 |=L body(r),
I2 |=L body(r), and I2 |=L head(r).

3.1 Well-Supported Models

The notion of well-supportedness in logic programming is defined by Fages in
[7] as a key characterization of the standard answer set semantics. For a normal
logic program , an interpretation I is well-supported if there exists a strict
well-founded partial order  on I such that for any A  I, there is a rule
A  body(r) in ground() such that I satisfies body(r) and for every positive
literal B in body(r), B  A. A binary relation  is well-founded if there is
no infinite decreasing chain A0  A1  . A well-supported interpretation I
guarantees that every A  I is free of circular justifications in I.

To extend Fages well-supportedness condition to normal DL logic programs

with DL expressions, we introduce a notion of up to satisfaction.

Definition 3. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L, I an interpretation consistent with L, and l a ground
literal. For any E  I, we use (E, I) |=L l to denote that E up to I satisfies
l under L, which is defined as follows: For any ground atom or ground DL
?

?

?
expression A, (E, I) |=L A if for every F with E  F  I, F |=L A; (E, I) |=L
not A if for no F with E  F  I, F |=L A. For a rule r in ground(),
(E, I) |=L body(r) if for every literal l in body(r), (E, I) |=L l.

As the phrase up to suggests, for any ground (positive or negative) literal l,
(E, I) |=L l means that for all interpretations F between E and I, F |=L l. This
implies that the truth of l depends on E and I
 and is independent of atoms
in I \ E, since for any A  I \ E and any interpretation F with E  F  I,
whether or not A is in F , F |=L l.
Theorem 1. Let l be a ground literal. For any E1  E2  I, if (E1, I) |=L l
then (E2, I) |=L l.
Proof: Straightforward from Definition 3.
?

?

?
| |= A.

Theorem 1 shows that the up to satisfaction is monotonic. In addition, it has
the following two properties.
Proposition 1. For any ground DL expression A, (E, I) |=L A iff L  E|
I
Proof: (E, I) |=L A means that E  I and for every F with E  F  I, F |=L
A. Then, by Definition 2, (E, I) |=L A means that for every F with E  F  I,
L  F| F
  (I \ F ). So
(E, I) |=L A means that for every F with E  F  I,

| |= A. Note that F = E  (F \ E) and F

 = I

L  E |  I

 |  (F \ E) |  (I \ F ) | |= A

(2)

Then, to prove this proposition it suffices to prove that the entailment (2) holds
for every F with E  F  I iff the following entailment holds:

L  E |  I

 | |= A

(3)

Note that for any model M of the left side of the entailment (2) or (3), we have
E  M  I.
Assume that the entailment (2) holds for every F with E  F  I. Let M be
a model of the left side of the entailment (3). Since E  M  I, M is a model
of the left side of the entailment (2), where F = M. Then, M is a model of A
(the right side of the entailment (2)). This means the entailment (3) holds.

Conversely, assume the entailment (3) holds. Let M be a model of the left
side of the entailment (2). M is also a model of the left side of the entailment (3)
and thus M is a model of A (the right side of the entailment (3)). This means

the entailment (2) holds.
Proposition 2. For any ground atom A  HB, which is not an atomic DL
expression, (E, I) |=L A iff A  E; (E, I) |=L not A iff A  I.
Proof: Straightforward from Definitions 3 and 2.
?

?

?
Next we extend the well-supportedness condition for normal logic programs to
normal DL logic programs by means of the up to satisfaction.

Y.-D. Shen and K. Wang

Definition 4. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L, and I an interpretation consistent with L. I is wellsupported if there exists a strict well-founded partial order  on I such that for
any A  I, there exists E  I, where for every B  E, B  A, such that either
(i) L  E| I
| |= A, or (ii) there is a rule A  body(r) in ground() such
that (E, I) |=L body(r).
The above conditions (i) and (ii) imply that the truth of A  I is determined by
. Since for every B  E, B  A, the truth of A is not circularly de-
E and I
pendent on itself. As a result, a well-supported interpretation I of  guarantees
that every A  I is free of circular justifications in I.
Observe in Definition 4 that due to the occurrence of DL expressions, some
A  I may be supported by no rule A  body(r) in ground() such that
| |= A.
I |=L body(r). Instead, A is supported by L such that L  I| I
This is a special property of the well-supportedness condition for normal DL
logic programs. The next example further illustrates this property.
Example 2. Let L = {B(a), B  A} and  = {A(X)  C(X)}. Let P =
{A, C}, C = {a} and  = {A}. We have HB = {A(a), C(a)} and ground() =
{A(a)  C(a)}.  has two models relative to L: I1 = {A(a)} and I2 =
{A(a), C(a)}. Only I1 is a well-supported model, where for A(a)  I1, we have
E =  and condition (i) of Definition 4 holds. Note that there is no rule of the
form A(a)  body(r) in ground() such that I1 |=L body(r).

The following result shows that Definition 4 is a proper extension to Fages

well-supportedness condition.
Theorem 2. Let L =  and  be a normal logic program without DL expres-
sions. An interpretation I is a well-supported model of  relative to L iff I is a
well-supported model of  under Fages definition.

Proof: Let I be an interpretation of  relative to L. I is also an interpretation
of . Since L = , for any A  I the condition (i) of Definition 4 does not hold.
Since  is a normal logic program without DL expressions, each Ai and Bi occurring in the body of each rule r of the form A  A1, , Am, not B1, , not Bn
in ground() are ground atoms. For such rules, I |=L body(r) iff every Ai is in
I and no Bi is in I.
Assume that I is a well-supported model of  relative to L. By Definition 4,
there exists a strict well-founded partial order  on I such that for any A  I,
there exists E  I, where for every B  E, B  A, and there is a rule r as
above in ground() such that (E, I) |=L body(r). Note that (E, I) |=L body(r)
implies E |=L body(r) and I |=L body(r), which implies that both I and E satisfy
body(r). This means that for every positive literal Ai in body(r), Ai  E and
thus Ai  A. As a result, for any A  I, there is a rule r as above in ground()
such that I satisfies body(r) and for every positive literal Ai in body(r), Ai  A.
This shows that I is a well-supported model of  under Fages definition.
Assume I is a well-supported model of  under Fages definition. There exists
a strict well-founded partial order  on I such that for any A  I, there is a rule r
?

?

?
as above in ground() such that I satisfies body(r) and for every positive literal
Ai in body(r), Ai  A. Let E  I and for every Ai  body(r), Ai  E. Then, E
contains no Bi in body(r), since no Bi is in I. For any F with E  F  I, F
satisfies body(r) and thus F |=L body(r). That means (E, I) |=L body(r). As a
result, for any A  I, there exists E  I, where for every B  E, B  A, and
there is a rule r as above in ground() such that (E, I) |=L body(r). This shows

that I is a well-supported model of  relative to L.

3.2 Well-Supported Answer Set Semantics

We define an answer set semantics for normal DL logic programs whose answer sets are well-supported models. We first define an immediate consequence
operator.

Definition 5. Let  be a normal DL logic program relative to a DL knowledge
base L, and I an interpretation consistent with L. For E  I, define

T(E, I) ={A | A  body(r)  ground() and (E, I) |=L body(r)}.
By Theorem 1, when the second argument I is a model of , T is monotone

w.r.t. its first argument E.

Theorem 3. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L, and I a model of  relative to L. For any E1  E2 
I, T(E1, I)  T(E2, I)  I.
Proof: For any A  T(E1, I), there is a rule A  body(r) in ground() such
that (E1, I) |=L body(r). Since E1  E2, by Theorem 1, (E2, I) |=L body(r),
and thus A  T(E2, I). This shows T(E1, I)  T(E2, I). Since E2  I, it
follows (I, I) |=L body(r) and A  T(I, I). Therefore, T(E1, I)  T(E2, I) 
T(I, I). Note that (I, I) |=L body(r) means I |=L body(r). Since I is a model of
 relative to L, I |=L body(r) implies A  I. This shows that when I is a model
of  relative to L, every A  T(I, I) is in I. Hence, T(E1, I)  T(E2, I) 
T(I, I)  I.

Therefore, for any model I of  relative to L, the sequence T i
T 0
(, I) =  and T i+1
 (, I). This fixpoint has the following properties.
T 
Theorem 4. Let I be a model of  relative to L. (1) T 
T 
 (, I)| I
J  I, T 
Proof: (1) It suffices to prove that for any i  0, T i
for i = 0. Assume T k
 (, I) = T(T k
 (, I)  I.
T k+1
(2) Since I is a model of  relative to L, L  I| I
T 
 (, I)  I, L  T 
| is also consistent.

(, I)  I. It is obvious
(, I)  I for k  0. For i = k + 1, by Theorem 3,
| is consistent. Since

 (, I)  I. (2) L 
| is consistent. (3) For any model J of  relative to L with

(, I), I)  I. Therefore, T 
 (, I)| I

 (, I) = T(T i

i=0, where
(, I), I), converges to a fixpoint, denoted

(, I)

 (, I)  T 

 (, J)  J.

Y.-D. Shen and K. Wang

(3) By Definition 3, for any rule body body(r) in ground() and any E1
and E2 with E1  E2  J, if (E1, I) |=L body(r) then (E2, J) |=L body(r).
Then, by Definition 5, T(E1, I)  T(E2, J). Next we prove that for any i  0,
(, I)  T i
(, J)  J
T i
for any i  k  0. For i = k + 1, by Theorem 3, T k+1
(, I), I) 
T k+1
 (, J) = T(T k

We define answer sets for normal DL logic programs using the above fixpoint.

(, I)  T i
 (, I) = T(T k
 (, J)  J.
 (, I)  T 

(, J)  J. It is obvious for i = 0. Assume T i

(, J), J)  J. Therefore, T 

Definition 6. Let  be a normal DL logic program relative to a DL knowledge
base L, and I a model of  relative to L. I is an answer set of  relative to L
if for every A  I, either A  T 

 (, I) or L  T 

 (, I)| I

| |= A.

It is immediate that when L = , a model I is an answer set of  relative to

L iff I = T 

 (, I).

The answer set semantics for  relative to L is then defined by answer sets of
. That is, a ground literal l is credulously (resp. skeptically) true in  relative
to L if I |=L l for some (resp. every) answer set I of  relative to L.
Example 3. Consider Example 1. For I1 = , T 
 (, I1) = , so I1 is an answer set
(, I2) =  and T 1
of  relative to L. For I2 = {A(a)}, T 0
(, I2) = T(, I2) = ,
so T 
|

|= A(a). Thus I2 is not an answer set of  relative to L.

(, I1) =
(, I1) =  and T 1
T(, I1) = , so T 
 (, I1) = . For A(a)  I1, A(a)  T 
 (, I1), but
| |= A(a), so I1 is an answer set of  relative to L.
 (, I1)| I
L  T 

It is easy to verify that I2 = {A(a), C(a)} is not an answer set of  relative

to L.

 (, I2) = . For A(a)  I2, A(a)  T 
Consider Example 2. For I1 = {A(a)}, T 0

 (, I2) and L  T 

 (, I2)| I

The following result shows that answer sets must be minimal models.

Theorem 5. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L. If I is an answer set of  relative to L, then I is a
minimal model of  relative to L.

Proof: Assume, on the contrary, that I is not a minimal model relative to L. Let
 (, J)  J.
J  I be a minimal model relative to L. By Theorem 4, T 
Let S = I\ J. Note that S is not empty and for any A  S, A  T 
 (, I). Since I
is an answer set of , for any A  S, LT 
  I
,
L J| J
| |= A. This
means that L  J| J
| is not consistent, and thus J is not a model of 
relative to L. We then have a contradiction. Therefore, I is a minimal model of

 relative to L.

 (, I)  T 
| |= A. Since J

| |= A. Since every A  S is in J

, L J| J

 (, I)| I

The next result shows that answer sets are exactly well-supported models.

Theorem 6. Let  be a normal DL logic program with DL expressions relative
to a DL knowledge base L, and I a model of  relative to L. I is an answer set
of  relative to L iff I is a well-supported model of  relative to L.
?

?

?
Proof: Assume that I is an answer set relative to L. We can construct a level
mapping f : I  N, where N is an integer, as follows: For each A  I, we
assign f(A) = i, where i  0 is the smallest number such that either L 
(, I)| I
| |= A or there is a rule A  body(r) in ground() such that
T i
(T i
(, I), I) |=L body(r).
We then define a strict well-founded partial order  on I such that for any
A, B  I, B  A iff f(B) < f(A). For each A  I with f(A) = i, we always
have E = T i
(, I)  I, where for every B  E, B  A, such that either
L  E| I
| |= A or there is a rule A  body(r) in ground() such that
(E, I) |=L body(r). By Definition 4, I is a well-supported model relative to L.
Conversely, assume that I is a well-supported model relative to L. Then, there
exists a strict well-founded partial order  on I such that for any A  I, there
exists E  I, where for every B  E, B  A, such that either L  E| I
|
|= A or there is a rule A  body(r) in ground() such that (E, I) |=L body(r).
Such a partial order establishes a level mapping f : I  N so that for any A  I,
A can be derived from some E  I at lower levels in the way as above. Next,
(, I) satisfying the
we show that for every A  I at level i  0 we have E = T i
above conditions.
First, each A  I at the lowest level (i = 0) does not depend on any other atom
B  I, i.e., there is no B  I with B  A. By the assumption that there exists
| |= A
E  I, where for every B  E, B  A, such that either L  E| I
or there is a rule A  body(r) in ground() such that (E, I) |=L body(r), we
(, I) which
have E = . Therefore, for each A  I at level 0, we have E = T 0
satisfies the above conditions.
As the induction hypothesis, assume that for any i  n and any A  I at level
| |= A or there is a rule
i, we have E = T i
A  body(r) in ground() such that (E, I) |=L body(r). Then, by Theorem 3,
 (, I) which satisfies the above
for each A  I at level i  n, we have E = T n
conditions.
Consider A  I at level n + 1. Then, there exists E  I, where for every
B  E, B  A, such that either (1) L  E| I
| |= A, or (2) there is a
rule A  body(r) in ground() such that (E, I) |=L body(r). Next, we show
that when using T n+1
 (, I) to replace E, the conditions (1) and (2) still hold
for every A  I at level n + 1.
For every B  E, since B is at a level below n+1, by the induction hypothesis,
 (, I)| I
| |= B, or (b) there is a rule B  body(r)
either (a) L  T n
in ground() such that (T n
 (, I), I) |=L body(r). For case (a), we distinguish
between two cases: (i) B  T n
 (, I). In this case, if we replace B in E by
 (, I), the conditions (1) and (2) above still hold for each A  I at level
T n+1
n + 1. (ii) B  T n
(, I); thus B is an
atomic DL expression. In this case, if we replace B in E by T n+1
 (, I), the
| |= B. Consider
condition (1) above still holds, since L  T n
the condition (2). (E, I) |=L body(r) means that for every F with E  F 
I, F |=L body(r). Let us replace B in E by T n+1
 (, I). Since B is a ground
atomic DL expression, by Proposition 1, (E\{B}T n+1
 (, I), I) |=L B, because

 (, I). Then, for no i  n, B  T i
 (, I)| I

(, I) such that either L E| I

Y.-D. Shen and K. Wang

 (, I), I) |=L body(r) iff (E  T n+1

| |= B. This shows that for any body(r),
L  (E \ {B}  T n+1
 (, I))| I
(E \ {B}  T n+1
 (, I), I) |=L body(r). Then,
when (E, I) |=L body(r), (E  T n+1
 (, I), I) |=L body(r) and thus (E \ {B} 
 (, I),
 (, I), I) |=L body(r). This shows that after replacing B in E by T n+1
T n+1
the condition (2) above still holds, Therefore, if we replace B in E by T n+1
 (, I),
the conditions (1) and (2) above still hold. For case (b), B  T n+1
 (, I). So if
we replace B in E by T n+1
As a result, if we replace all B  E by T n+1
 (, I), the conditions (1) and
(2) above still hold. Therefore, for every A  I at level n + 1. we have E =
| |= A or there is a rule A  body(r)
 (, I) such that either L E| I
T n+1
in ground() such that (E, I) |=L body(r).
| |= A or A 
 (, I)| I
Consequently, for every A  I, either L  T 
T 
 (, I). This shows that I is an answer set of  relative to L.

Example 4. Let L =  and

 (, I), the conditions (1) and (2) above still hold.

 : A(g). B(g)  C(g). C(g)  ((A  C)  B)(g).

Let P = {A, B, C}, C = {g} and  = {A, B, C}. HB = {A(g), B(g), C(g)}
and ground() = .  has only one model relative to L, I = {A(g), B(g), C(g)}.
This model is not an answer set, since it is not a well-supported model of  relative to L.
(A  C)  B and add to L an axiom D  (A  C)  B. This yields

Note that we can use a fresh DL concept D to replace the DL expression

 : A(g). B(g)  C(g). C(g)  D(g).

 : D  (A  C)  B.

Using the same P, C and  as above, 
 as  relative to L.

The following result shows that this answer set semantics is a proper extension

 has the same answer sets relative to

to the standard answer set semantics for normal logic programs.
Theorem 7. Let L =  and  be a normal logic program without DL expres-
sions. An interpretation I is an answer set of  relative to L iff I is an answer
set of  under the standard answer set semantics.

Proof: By Theorem 6, I is an answer set of  relative to L iff I is a wellsupported model of  relative to L. By Theorem 2, I is a well-supported model
of  relative to L iff I is a well-supported model of  under Fages definition.
Then as shown in [7], the well-supported models of  under Fages definition

are exactly the answer sets of  under the standard answer set semantics.

3.3 Decidability Property

For a normal DL logic program  with DL expressions relative to a DL knowledge base L, the decidability of computing answer sets of  relative to L depends
on the decidability of satisfiability of L. Since DLs are fragments of first-order
?

?

?
logic, the satisfiability of L is undecidable in general cases. However, if L is built
from the description logic SHOIN or SROIQ, its satisfiability is decidable
[4,13,12].
Let L be a DL knowledge base built from a decidable description logic such
as SHOIN or SROIQ. Since HB and ground() are finite, it is decidable
to determine if an interpretation I is a model of  relative to L. For any E  I
and any ground atom or DL expression A in ground(), it is decidable to
determine if (E, I) |=L A (resp. (E, I) |=L not A) holds, and thus it is decidable
to determine if (E, I) |=L body(r) holds for each rule r in ground(). Since
ground() consists of a finite set of rules, it takes finite time to compute the
fixpoint T 
 (, I). As a result, it is decidable to determine if an interpretation I is
an answer set of  relative to L. Since  has only a finite set of interpretations,
it is decidable to compute all answer sets of  relative to L.

4 Related Work

Although many approaches to integrating rules and DLs have been proposed in
the literature [2,4,10,11,14,16,18,19], to the best of our knowledge dl-programs [4]
are the first framework which extends normal logic programs under the standard
answer set semantics to logic programs with arbitrary DL expressions relative to
an external DL knowledge base. Four different answer set semantics have been
defined for dl-programs. The first one, called weak answer set semantics [4], easily incurs circular justifications by self-supporting loops, so a second one, called
strong answer set semantics, was introduced [4]. Answer sets under the strong
answer set semantics are not minimal models of a dl-program, then a third one,
called FLP-reduct based answer set semantics, was proposed [5]. This semantics
is based on the concept of FLP-reduct from [6]. It turns out, however, that none
of the three answer set semantics extends the key well-supportedness condition
of the standard answer set semantics to dl-programs, so that their answer sets
may incur circular justifications by self-supporting loops. To resolve this prob-
lem, a fourth semantics, called well-supported answer set semantics, was recently
introduced [20], which extends the well-supportedness condition to dl-programs.
Dl-programs differ in fundamental ways from normal DL logic programs. First,
in a dl-program,  and L share no predicate symbols, so DL expressions Q(t)
must occur together with predicate mapping operations SiopiPi. Note that in
dl-programs one cannot use only dl-atoms of the form DL[Q](t) to express all
DL expressions Q(t) because that would cut the knowledge flow from  to L.
Second, in a dl-program, DL expressions (dl-atoms) are not allowed to occur in a
rule head, so no conclusions about L can be inferred from . Third, in this paper
we extend the well-supportedness condition to normal DL logic programs. The
extension process is similar to that in [20] by introducing an up to satisfaction
relation (Definition 3), but the formalization of the well-supportedness condition is significantly different. For dl-programs, since  and L share no predicate
symbols, a model I of  is well-supported if and only if for each A  I there
is a rule A  body(r) in ground() such that I satisfies body(r) and the evidence

Y.-D. Shen and K. Wang

of the truth of body(r) is not circularly dependent on A in I. For normal DL
logic programs, however, the situation is much more complicated. As illustrated
in Example 2, since  and L share some predicate symbols, a model I of 
relative to L would be well-supported even if some A  I is not supported by
any rule A  body(r) in ground() such that I satisfies body(r). This presents
additional difficulties in formalizing the well-supportedness condition for normal
DL logic programs.
DL+log [19] (and its variant such as guarded hybrid knowledge bases [11]) is
closely related to but differs significantly from normal DL logic programs. Syn-
tactically, it divides predicate symbols into Datalog predicates and DL predicates.
The former type can only occur in , while the latter is not allowed to occur
(as DL expressions) behind the negation operator not. Semantically, it considers
first-order interpretations, instead of Herbrand interpretations, and defines a semantics with a class of first-order models, called NM-models. In an NM-model,
DL predicates can take arbitrary truth values (as in first-order logic), but Datalog predicates take truth values that must be minimal (as in logic programming)
when the truth values of all DL predicates are fixed. Consider a DL+log program with  = {B(g)  A(g)} and L = {A  C}. A, C must be DL predicates.
Let B be a Datalog predicate. This program has at least three NM-models:
I1 = {A(g), B(g)}, I2 = {A(g), B(g), C(g)} and I3 = {C(g)}. In contrast, if we
take  as a normal DL logic program relative to L, where P = {B}, C = {g}
and  = ,  has a unique well-supported model/answer set  relative to L.

Disjunctive dl-programs [16] are closely related to normal DL logic programs,
but differ significantly at least in three ways. Let  be a disjunctive dl-program
relative to L, where  is built over a vocabulary  = (P, C), P is a finite set of
predicate symbols, and C is a nonempty finite set of constants. (1) All concepts
and roles occurring in  are required to be included in P, so that all of them are
interpreted over the Herbrand base HB of . This strict requirement does not

seem to be intuitive in some cases. For Example 4, since D is a fresh concept of L
introduced to represent (AC) B, D is expected to be interpreted against L

in first-order logic. But in a disjunctive dl-program, D must be included in P and
thus be interpreted over the Herbrand base HB. (2) The semantics of disjunctive dl-programs is based on FLP-reduct. Like the FLP-reduct based semantics
for dl-programs [5], this FLP-reduct based semantics for disjunctive dl-programs
yields answer sets that are minimal but not necessarily well-supported models.
 be a disjunctive dl-program. I = {A(g), B(g), C(g), D(g)}
For Example 4, let 
 relative to L
 under the FLP-reduct based semantics. Obis an answer set of 
serve that the evidence of the truth of B(g), C(g), D(g) in the answer set can
only be inferred via a self-supporting loop B(g)  C(g)  D(g)  B(g). (3)
Disjunctive dl-programs allow only atomic DL expressions in rule bodies. We
cannot have a disjunctive dl-program with  = {A  A} and L = , since A
is not an atomic DL expression. One might think that this issue could be handled by introducing a fresh concept B to represent the DL expression A, which
 = {B  A}.
yields a disjunctive dl-program with 

 = {A  B} and L
?

?

?
However, this would produce an answer set I = {A}, which is not a wellsupported model of .
Extensions of logic programs with DL expressions, such as dl-programs,
DL+log, disjunctive dl-programs, and normal DL logic programs, are different
in fundamental ways from embeddings of rules and DLs into some unifying logic
formalisms, such as the embedding [2] to first-order autoepistemic logic [17] and
the embedding [18] to the logic of Minimal Knowledge and Negation as Failure
(MKNF) [15]. The two embeddings employ modal logics and transform rules 
and DL axioms L to autoepistemic (resp. MKNF) logic formulas 
with
modal operators. Then, the semantics of  and L is defined by the semantics of
  L


 under autoepistemic (resp. MKNF) modal logic.

 and L
?

?

?
5 Summary

We have introduced a new extension, called normal DL logic programs, of normal
logic programs with DL expressions relative to an external DL knowledge base.
In normal DL logic programs, arbitrary DL expressions are allowed to appear
in rule bodies and atomic DL expressions allowed in rule heads. We extended
the key condition of well-supportedness for normal logic programs under the
standard answer set semantics to normal DL logic programs and defined an answer set semantics which satisfies the extended condition of well-supportedness.
As a result, answer sets under the well-supported semantics are free of circular
justifications. We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN
or SROIQ).

As future work, we will study computational properties of normal DL logic
programs w.r.t. different DLs, and extend normal DL logic programs to disjunctive DL logic programs, where the head of a rule is a disjunction of atoms.

Acknowledgments. We would like to thank all anonymous reviewers for their
helpful comments. This work is supported in part by the National Natural
Science Foundation of China (NSFC) grants 60970045 and 60833001, and by
the Australia Research Council (ARC) Discovery Projects DP110101042 and
DP1093652.
