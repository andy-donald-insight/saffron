Semantic Search: Reconciling Expressive

Querying and Exploratory Search

S ebastien Ferr e1 and Alice Hermann2

1 IRISA/Universit e de Rennes 1, Campus de Beaulieu, 35042 Rennes cedex, France

2 IRISA/INSA de Rennes, Campus de Beaulieu, 35708 Rennes cedex 7, France

ferre@irisa.fr

alice.hermann@irisa.fr

Abstract. Faceted search and querying are two well-known paradigms
to search the Semantic Web. Querying languages, such as SPARQL, offer expressive means for searching RDF datasets, but they are difficult
to use. Query assistants help users to write well-formed queries, but
they do not prevent empty results. Faceted search supports exploratory
search, i.e., guided navigation that returns rich feedbacks to users, and
prevents them to fall in dead-ends (empty results). However, faceted
search systems do not offer the same expressiveness as query languages.
We introduce Query-based Faceted Search (QFS), the combination of
an expressive query language and faceted search, to reconcile the two
paradigms. In this paper, the LISQL query language generalizes existing
semantic faceted search systems, and covers most features of SPARQL. A
prototype, Sewelis (aka. Camelis 2), has been implemented, and a usability evaluation demonstrated that QFS retains the ease-of-use of faceted
search, and enables users to build complex queries with little training.

1 Introduction

With the growing amount of available resources in the Semantic Web (SW), it is a
key issue to provide an easy and effective access to them, not only to specialists,
but also to casual users. The challenge is not only to allow users to retrieve
particular resources (e.g., flights), but to support them in the exploration of a
knowledge base (e.g., which are the destinations? Which are the most frequent
flights? With which companies and at which price?). We call the first mode
retrieval search, and, following Marchionini [10], the second mode exploratory
search. Exploratory search is often associated to faceted search [5,13], but it
is also at the core of Logical Information Systems (LIS) [4,2], and Dynamic
Taxonomies [12]. Exploratory search allows users to find information without
a priori knowledge about either the data or its schema. Faceted search works
by suggesting restrictions, i.e., selectors for subsets of the current selection of
items. Restrictions are organized into facets, and only those that share items
with the current selection are suggested. This has the advantage to provide
guided navigation, and to prevent dead-ends, i.e., empty selections. Therefore,
faceted search is easy-to-use and safe: easy-to-use because users only have to

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 177192, 2011.
c Springer-Verlag Berlin Heidelberg 2011

S. Ferr e and A. Hermann

choose among the suggested restrictions, and safe because, whatever the choice
made by users, the resulting selection is not empty. The selections that can
be reached by navigation correspond to queries that are generally limited to
conjunctions of restrictions, possibly with negation and disjunction on values.
This is far from the expressiveness of query languages for the semantic web, such
as SPARQL1. There are semantic faceted search that extend the expressiveness of
reachable queries, but still to a small fragment of SPARQL (e.g., SlashFacet [7],
BrowseRDF [11], SOR [9], gFacet [6]). For instance, none of them allow for cycles
in graph patterns, unions of complex graph patterns, or negations of complex
graph patterns.

Querying languages for the semantic web are quite expressive but are difficult
to use, even for specialists. Users are asked to fill an empty field (problem of the
writers block), and nothing prevents them to write a query that has no answer
(dead-end). Even if users have a perfect knowledge of the syntax and semantics
of the query language, they may be ignorant about the data schema, i.e., the
ontology. If they also master the ontology or if they use a graphical query editor
(e.g., SemanticCrystal [8], SCRIBO Graphical Editor2) or an auto-completion
system (e.g., Ginseng [8]) or keyword query translation (e.g., Hermes [14]), the
query will be syntactically correct and semantically consistent w.r.t. the ontology
but it can still produce no answer.

The contribution of this paper, Query-based Faceted Search (QFS), is to define
a semantic search that is (1) easy to use, (2) safe, and (3) expressive. Ease-of-use
and safeness are retained from existing faceted search systems by keeping their
general principles, as well as the visual aspect of their interface. Expressiveness is
obtained by representing the current selection by a query rather than by a set of
items, and by representing navigation links by query transformations rather than
by set operations (e.g., intersection, crossing). In this way, the expressiveness of
faceted search is determined by the expressiveness of the query language, rather
than by the combinatorics of user interface controls. In this paper, the query lan-
guage, named LISQL, generalizes existing semantic faceted search systems, and
covers most features of SPARQL. The use of queries for representing selections
in faceted search has other benefits than navigation expressiveness. The current
query is an intensional description of the current selection that complements its
extensional description (list of items). It informs users in a precise and concise
way about their exact position in the navigation space. It can easily be copied
and pasted, stored and retrieved later. Finally, it allows expert users to modify
the query by hand at any stage of the navigation process, without loosing the
ability to proceed by navigation.

The paper is organized as follows. Section 2 discusses the limits of set-based
faceted search by formalizing the navigation from selection to selection. Section 3
introduces LISQL queries and their transformations. In Section 4, navigation
with QFS is formalized and proved to be safe and complete w.r.t. LISQL, and
efficient. Section 5 reports about a usability evaluation, and Section 6 concludes.

1 see http://www.w3.org/TR/rdf-sparql-query/

http://www.scribo.ws/xwiki/bin/view/Blog/SparqlGraphicalEditor
?

?

?
2 Limits of Set-Based Faceted Search

The principle of faceted search [13] is to guide users from selection of items
to selection of items. At each navigation step, a new selection is derived by
applying a set operation between the current selection S and a restriction R. A
restriction is a feature that applies to at least one item of the current selection,
i.e., S  R = . Typically, a feature is a pair facet-value, and the set operation
is intersection: S := S  R. The new selection is the set of items that belong to
the current selection, and that belong to the restriction. Extensions of faceted
search may allow for the exclusion of a restriction (S := S \ R), or the union
with a restriction (S := S  R). Restrictions can also be tags or item names.

In the context of the Semantic Web, items and values are resources, facets
are properties, and tags are classes. Because of the relational nature of semantic
data, new kinds of restrictions and set operations have been introduced in semantic faceted search (e.g., /facet [7], BrowseRDF [11], SOR [9], gFacet [6]). A
restriction can be the set of items that are subject of some property (the domain
of the property), or that are object of some property (the range of the property)
(e.g., BrowseRDF). A facet can be defined as a path of properties. Finally, a
property p can be crossed forwards (S := p(S, .)) or backwards (S := p(., S))
(e.g., /facet, SOR, gFacet).

Both in theory and in practice, it is useful to distinguish between syntax
and semantics. For example, we should distinguish between a pair facet-value
(syntax), and the set of items it matches (semantics). In the following table, we
define the syntax and semantics of the various kinds of restrictions: r denotes any
RDF resource (URI, literal), c denotes a RDFS class, p denotes a RDF property,
and S0 denotes the set of all items (possibly all resources of a RDF dataset).

syntax semantics
r
a c

restriction
name
tag
(facet, value) p : r p(.,{r})
(facet, value) p of r p({r}, .)
p : ? p(., S0)
domain
range
p of ? p(S0, .)

examples
{r}
<JohnSmith>, "John", 2011
rdf:type(.,{c}) a person

year : 2011
mother of <JohnSmith>
year : ?
mother of ?

The same distinction can be made for complex selections, and we introduce in
the following table a syntax for the various set operations that can be applied
between selections and restrictions: S denotes a selection, and R denotes a restriction that is relevant to S: i.e., S  R = .
semantics
syntax
?
S0
S  R
S and R
S and not R S \ R
S  R
S or R
p(., S)
p(S, .)

selection
initial
intersection
exclusion
union
crossing backwards p : S
crossing forwards
p of S

S. Ferr e and A. Hermann

The syntactic form of restrictions are features. The syntactic form of selections
are queries whose answers are sets of items, i.e., subsets of S0. The above tables
implicitly define a grammar for features and queries:

S  ? | S and R | S and not R | S or R | p : S | p of S
R  r | a c | p : r | p of r | p : ? | p of ?.

This grammar already defines a rich language of accessible queries, but it has
strong limits in terms of flexibility and expressivity, as we discuss now. To reach
some selections requires a precise ordering in navigation steps, which hinders the
flexibility of the search, and assumes that the user has a clear idea of his query
in advance. For example, to reach the query father of (mother of (name :
"John") and name : "Jane"), the user has first to select name : "John" (peo-
ple named John), then to cross forward mother (their mothers), then to intersect with name : "Jane" (. . . whose name is Jane), and finally to cross forward
father (their fathers). Any other ordering will fail; starting from the expected
result (grand-fathers) will lead to the set of grand-children instead.

Some useful selections that can be defined in terms of set operations are
not reachable by set-based faceted search. For example, the following kinds of
selections are not reachable: unions of complex selections. e.g., (R1  R2) (R3 
R4); or intersection of crossings from complex selections, e.g., p1(., R1  R2) 
p2(., R3  R4). Note that a selection S1  p(., S2) cannot in general be obtained
by first navigating to S1, then crossing forwards p, navigating to S2, and finally
crossing backwards p, because it is not equivalent to p(., p(S1, .)  S2) unless p
is inverse functional. Therefore, not all combinations of intersection, union, and
crossing are reachable, which is counter-intuitive and limiting for end users.

Existing approaches to semantic faceted search often have additional limi-
tations, which are sometimes hidden behind a lack of formalization. A same
facet (a property path) cannot be used several times, which is fine for functional
properties but not for relations such as child: p(., f1  f2) is reachable but not
p(., f1)p(., f2) (e.g., BrowseRDF, gFacet). A property whose domain and range
are the same cannot be used as a facet (e.g., /facet), which includes all family
and friend relationships for instance.

3 Expressive Queries and Their Transformations

The contribution of our approach, Query-based Faceted Search (QFS), is to significantly improve the expressivity of faceted search, while retaining its properties
of safeness (no dead-end), and ease-of-use. The key idea is to define navigation
steps at the syntactic level as query transformations, rather than at the semantic level as set operations. The navigation from selection to selection, as well as
the computation of restrictions related to the current selection, are retained by
defining the semantics of features and queries, i.e., the mapping from a feature f
or a query q to a set of items: R = items(f) and S = items(q). Transformations
at the syntactic level are necessary because there exist useful navigation steps
that cannot be obtained by applying set operations on the current selection. For
?

?

?
 = R1  (R2  R3) cannot be
example, given S = R1  R2, the set of items S
derived from S and R3. On the contrary, the query f1 and (f2 or f3) can be
derived from the query f1 and f2 and the feature f3 because enough information
is retained at the syntactic level.

In this section, we generalize in a natural way the set of queries compared
to Section 2. This defines a query language, which we call LISQL (LIS Query
Language). We then define a set of query transformations so that every LISQL
query can be reached in a finite sequence of such transformations. This is in
contrast with previous contributions in faceted search that introduce new selection transformations, and leave the query language implicit. We think that
making the language of reachable queries explicit is important for reasoning on
and comparing different faceted search systems. In Section 3.3, we give a translation from LISQL to SPARQL, the reference query language of the Semantic
Web. This provides both a way to compute the answers of queries with existing
tools, and a way to evaluate the level of expressivity achieved by LISQL.

3.1 The LIS Query Language (LISQL)

A more general query language, LISQL, can be obtained simply by merging the
syntactic categories of features and queries in the grammar of Section 2, so that
every query can be used in place of a feature.

Definition 1 (LISQL queries). The syntax and semantics of the LISQL constructs is defined in the following table, where r is a resource, c is a class,
p is a property, S0 is the set of all items, and q1, q2 are LISQL queries s.t.
S1 = items(q1) and S2 = items(q2).

syntax (q) semantics (items(q))
r
a c
?

query
{r}
resource
rdf:type(.,{c})
class
all
S0
crossing backwards p : q1
p(., S1)
crossing forwards p of q1
p(S1, .)
S0 \ S1
complement
not q1
q1 and q2 S1  S2
intersection
q1 or q2 S1  S2
union

The definition of LISQL allows for the arbitrary combination of intersection,
union, complement, and crossings. In order to further improve the expressiveness of LISQL from tree patterns to graph patterns, we add variables (e.g., ?X) as
an additional construct. Variables serve as co-references between distant parts
of the query, and allows for the expression of cycles. For example, the query
that selects people who are an employee of their own father can be expressed as
a person and father : ?X and employee of ?X, or alternately as a person
and ?X and employee of father of ?X. The semantics of queries with variables is given with the translation to SPARQL in Section 3.3, because it cannot
be defined like in the table of Definition 1.

S. Ferr e and A. Hermann

Syntactic constructs are given in increasing priority order, and brackets are
used in concrete syntax for disambiguation. The most general query ? is a
neutral element for intersection, and an absorbing element for union. In the
following, we use the example query qex = a person and birth : (year :
(1601 or 1649) and place : (?X and part of England)) and father :
birth : place : not ?X, which uses all constructs of LISQL, and selects the
set of persons born in 1601 or 1649 at some place in England, and whose father
is born at another place.

3.2 Query Transformations
We have generalized the query language by allowing complex selections in place
of restrictions: e.g., S1  S2 instead of S  R. However, because the number of
suggested restrictions in faceted search must be finite, it is not possible to suggest
arbitrarily complex restrictions. More precisely, the vocabulary of features must
be finite. In QFS, we retain the same set of features as in Section 2, which is a
finite subset of LISQL for any given dataset.

The key notion we introduce to reconcile this finite vocabulary, and the reach-

ability of arbitrary LISQL queries is the notion of focus in a query.
Definition 2 (focus). A focus of a LISQL query q is a node of the syntax tree
of q, or equivalently, a subquery of q. The set of foci of q is noted (q); the root
focus corresponds to the root of the syntax tree, and represents the whole query.
The subquery at focus   (q) is noted q[]; and q[ := q1] denotes the modified
query q, where the subquery at focus  has been replaced by q1.
In the following, when it is necessary to refer to a focus in a query, the corresponding subquery is underlined with the focus name as a subscript, like in
mother of ?. Foci are used in QFS to specify on which subquery a query transformation should be applied. For example, the query (f1 and f2) or (f3 and
f4) can be reached from the query (f1 and f2) or f3 by applying the intersection with restriction f4 to the subquery f3, instead of to the whole query.
Similarly, the query p1 : (f1 and f2) and p2 : (f3 and f4) can be reached
by applying the intersection with restriction f4 to the subquery f3. This removes
the problem of unreachable selections in set-based faceted search presented in
Section 2. Moreover, this removes the need for a strategy in the ordering of navigation steps. For example, the query a woman and mother of name : "John"
can be reached by first selecting a woman, then by selecting mother of ?, then
by inserting name : "John" at the focus .
Definition 3 (query transformation). The different kinds of LISQL query
transformations are listed in the following table, where each transformation is
paramaterized by a focus  and a query q1. The expression q[t] is the query that
results from the application of transformation t to query q.

transformation notation (t)
intersection
exclusion
union

 and q1
 and not q1 q[ := q[] and not q1]
 or q1

q[ := q[] or q1]

result query (q[t])
q[ := q[] and q1]
?

?

?
We show in the following equations how the intersection with an arbitrary
LISQL query can be recursively decomposed into a finite sequence of intersections with features, and exclusions and unions with the most general query ?.

= q
q[ and (?)]
q[ and (p : q1)]
= q[ and p : ?1][1 and q1]
q[ and (p of q1)] = q[ and p of ?1][1 and q1]
q[ and (not q1)]
= q[ and not ?1][1 and q1]
q[ and (q1 and q2)] = q[ and q11][1 and q2]
q[ and (q1 or q2)] = q[ and q11][1 or ?2][2 and q2]

For example, the complex query qex = a person and birth : (year :
(1601 or 1649) and place : (?X and part of England)) and father :
birth : place : not ?X can be reached through the navigation path:
[1 and year : 16012]
?0[0 and a person]
[2 or ?3]
[4 and ?X]
[4 and part of England]
[5 and birth : ?6]
[6 and place : ?7] [7 and not ?8] [8 and ?X]. The classical facet-value
features appear to be redundant for navigation as their intersection can be
decomposed, but they are still useful for visualization in a faceted search
interface.

[0 and father : ?5]

[0 and birth : ?1]

[3 and 1649]

[1 and place : ?4]

Sequences of query transformations are analogous to the use of graphical query
editors, but the key difference is that answers and restrictions are returned at
each step, providing feedback, understanding-at-a-glance, no dead-end, and all
benefits of exploratory search. Despite the syntax-based definition of navigation
steps, those have a clear semantic counterpart. Intersection is the same as in
standard faceted search, only making it available on the different entities involved
in the current query. In the above example, intersection is alternately applied
to the person, his birth, his births place, his father, etc. The set of relevant
restrictions is obviously different at different foci. The union transformation
introduces an alternative to some subquery (e.g., an alternative births year).
The exclusion transformation introduces a set of exceptions to the subquery
(e.g., excluding some fathers births place). In Section 4, we precisely define
which query transformations are suggested at each navigation step, and we prove
that the resulting navigation graph is safe (no dead-end), and complete (every
safe query is reachable).

3.3 Translation to and Comparison with SPARQL

We here propose a (naive) translation of LISQL queries to SPARQL queries.
It involves the introduction of variables that are implicit in LISQL queries. As
this translation applies to LISQL queries with co-reference variables, it becomes
possible to compute their set of items.

Definition 4 (SPARQL translation). The SPARQL translation of a LISQL
query q is sparql(q) = SELECT DISTINCT ?x WHERE { S0(x) GP(x, q) }, where

S. Ferr e and A. Hermann

the graph pattern S0(x) binds x to any element of the set of all items S0, and
the function GP inductively defines the graph pattern of q with variable x representing the root focus.

GP(x, ?v)
= S0(v) FILTER (?x = ?v)
GP(x, r)
= FILTER (?x = r)
GP(x, a c)
= ?x rdf:type c
= ?x p ?y. GP(y, q1) where y is a fresh variable
GP(x, p : q1)
GP(x, p of q1) = ?y p ?x. GP(y, q1) where y is a fresh variable
= { }
GP(x, ?)
= NOT EXISTS { GP(x, q1) }
GP(x, not q1)
GP(x, q1 and q2) = GP(x, q1) GP(x, q2)
GP(x, q1 or q2) = { GP(x, q1) } UNION { GP(x, q2) }

We now discuss the translations of LISQL queries compared to SPARQL in gen-
eral. They have only one variable in the SELECT clause because of the nature of
faceted search, i.e., navigation from set to set. From SPARQL 1.0, LISQL misses
the optional graph pattern, and the named graph pattern. Optional graph patterns are mostly useful when there are several variables in the SELECT clause.
LISQL has the NOT EXISTS construct of SPARQL 1.1. If we look at the graph
patterns generated for intersection and union, the two subpatterns necessarily
share at least one variable, x. This is a restriction compared to SPARQL, but
one that makes little difference in practice as disconnected graph patterns are
hardly useful in practice.

4 A Safe and Complete Navigation Graph

In this section, we formally define the navigation space over a RDF dataset as
a graph, where vertices are navigation places, and edges are navigation links.
A navigation place is made of a query q and a focus  of this query. The focus determines the selection of items to be displayed, and the corresponding
restrictions at this focus. A navigation link is defined by a query transformation
and, possibly, a focus move. Before defining the navigation graph itself, we first
define the set of items and the set of restrictions for some query q and some focus   (q). The set of items is defined as the set of items of the query flip(q, )
that is the reformulation of q from the point of view of the focus . For exam-
ple, the reformulation, called the flip, of the query a woman and mother of
name : "John" is the query name : "John" and mother : a woman.
Definition 5 (flip at focus). The flip of a query q at a focus   (q) is
defined as flip(q, ) = flip(?, q, ), where the function flip(k, q
, ) is inductively
 in q, by (only main cases are given):
defined, with k representing the context of q
?

?

?
= flip(p of k, q1, )

flip(k, p : q1, )
flip(k, q1 and q2, ) = flip(k and q2, q1, )
flip(k, q1 or q2, ) = flip(k, q1, )
= flip(k, q1, )
flip(k, not q1, )
flip(k, q
= q

and k
?

?

?
, )

if   q1
if   q1
if   q1
if   q1
otherwise
?

?

?
When the focus is in the scope of an union, only the alternative that contains
the focus is used in the flipped query. This is necessary to have the correct
set of restrictions at that focus, and this is also useful to access the different subselections that compose an union. For example, in the query a man and
(firstname : "John" or lastname : "John"), the focus  allows to know
the set of men whose firstname is John without forgetting the second alternative.
When the focus is in the scope of a complement, this complement is ignored in
the flipped query. This is useful to access the subselection to be excluded. For
example, in the query a man and not father : ?, the focus  allows to know
the set of men who have a father, i.e., those who are to be excluded from the
selection of men.
Definition 6 (items at focus). The items of a query q at focus  is defined
as the items of the flip of q at focus , i.e., items(q, ) = items(flip(q, )).
This enables the definition of the set of restrictions at each focus in the normal
way. The navigation graph can then be formally defined.
Definition 7 (restrictions at focus). The restrictions of a query q at focus 
is defined as the features that share items with the query q at focus :

restr(q, ) = {f | items(q, )  items(f) = }.

Definition 8 (navigation graph). Let D be a RDF dataset. The navigation
graph GD = (V, E) of D has its set of vertices defined by
V = {(q, ) | q  LISQL,   (q)},

and its set of edges defined by the following table for every vertice (q, ). The
) = (q, )[l] denotes the navigation place obtained by traversing
notation (q
the navigation link l from the navigation place (q, ).

, 
?

?

?
delete

delete

(q[ := ?], )

The number of navigation places (vertices) is infinite because there are infinetely
many LISQL queries, but the number of outgoing navigation links (edges) is
finite at each navigation place because the vocabulary of features is finite, and
the number of foci and variables in a query is finite. By default, the initial
navigation place is v0 = (?, ). The following lemma shows that intersection
navigation links behave as in standard faceted search.
Lemma 1. For every query q, focus   (q), and feature f, the following
equality holds: items((q, )[and f]) = items(q, )  items(f).
?

?

?
))

, 

navigation link notation (l) target ((q
focus change
intersection
exclusion
union
