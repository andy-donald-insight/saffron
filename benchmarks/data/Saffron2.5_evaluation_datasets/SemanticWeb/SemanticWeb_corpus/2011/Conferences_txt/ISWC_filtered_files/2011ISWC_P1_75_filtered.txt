Alignment-Based Trust for Resource Finding

in Semantic P2P Networks

Manuel Atencia1,2, J erome Euzenat1,

Giuseppe Pirr`o3, and Marie-Christine Rousset2

1 INRIA, Grenoble, France

{Manuel.Atencia,Jerome.Euzenat}@inrialpes.fr

2 University of Grenoble, Grenoble, France

Marie-Christine.Rousset@imag.fr

3 Free University of Bolzano-Bozen, Bolzano, Italy

giuseppe.pirro@unibz.it

Abstract. In a semantic P2P network, peers use separate ontologies
and rely on alignments between their ontologies for translating queries.
Nonetheless, alignments may be limited unsound or incomplete and
generate flawed translations, leading to unsatisfactory answers. In this
paper we present a trust mechanism that can assist peers to select those
in the network that are better suited to answer their queries. The trust
that a peer has towards another peer depends on a specific query and
represents the probability that the latter peer will provide a satisfactory
answer. In order to compute trust, we exploit both alignments and peers
direct experience, and perform Bayesian inference. We have implemented
our technique and conducted an evaluation. Experimental results showed
that trust values converge as more queries are sent and answers received.
Furthermore, the use of trust improves both precision and recall.

1 Introduction

Peer-to-peer (P2P) systems have received considerable attention because their
underlying infrastructure is very appropriate for scalable and flexible distributed
applications over Internet. In P2P systems, there is no centralised control or
hierarchical organisation: each peer is equivalent in functionality and cooperates
with other peers in order to solve a collective task. P2P systems have evolved
from simple keyword-based file sharing systems such as Napster and Gnutella
to semantic data management systems such as Edutella [14], Piazza [8] or
SomeWhere [1].

In this paper, by a semantic P2P network we refer to a fully decentralised
overlay network of people or machines (peers) sharing and searching for resources
(documents, videos, photos, data, services) based on their semantic annotations
using ontologies. In semantic P2P systems, every peer is free to organise her local
resources as instances of classes of her own ontology serving as query interface
for other peers. Alignments between ontologies make possible to reformulate
queries from one local peer vocabulary to another. The result of a query is a set

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 5166, 2011.
c Springer-Verlag Berlin Heidelberg 2011

M. Atencia et al.

of resources (e.g., documents) which are instances of some classes corresponding,
possibly via subsumption or equality, to the initial query posed to a specific peer.
Trust is widely acknowledged as a central factor when considering networks
of autonomous interacting entities and notably in the context of the Semantic
Web. When referring to the notion of trust, T. Berners-Lee advocates for a
user to be able to search for reasons why he or she should be confident of a
returned answer [3]. Trust is helpful to select, from a given set of peers, those
that are expected to answer with most satisfactory instances. Peers may use
this information for broadcasting their queries to a reduced set of peers and to
have an approximation of the reliability of provided answers. Furthermore, peers
may preventively send selected queries in order to improve the trust they have
towards another peer. Finally, by identifying weak correspondences, peers may
signal faulty alignments and trigger new matching of the ontologies.

Several proposals have been made that do not share the same meaning for
trust [15,2]. Many are user/agent/peer centred and rely on the assumption that
all peers share similar implicit goals. Trust is then closely related to the notion
of reputation in a community.

In contrast, in the context of semantic P2P systems, each peer may have her
own view on how categorising the resources that are exchanged between peers.
For this reason, we rather promote the computation of subjective trust values
based on direct experiences between peers. We also argue for a finer grained
approach to trust in order to take into account the fact that, for answers provided
by the same peer, the trust into these answers may vary according to which class
they are instance of within the peer ontology.

An Illustrative Scenario
Consider a semantic P2P system for exchanging bookmarks, in which a peer Alice
organises her bookmarks according to two main categories: FavouriteMusic and
GoodRestaurants. These in turn are divided into subcategories: Jazz, PopRock
and Folk for FavouriteMusic, and Italian and Chinese for GoodRestaurants.
Within the Semantic Web, this can be implemented as a lightweight ontology
that can be expressed in RDFS, in which categories and subcategories correspond
to classes and subclasses, and the URLs identifying bookmarks correspond to
URIs declared as instances of some classes.

Suppose that Alice is acquainted with Bob and Chris with whom she shares
some interests in music and restaurants. This is captured by correspondences
between her ontology and Bobs and Chriss ontologies. If Bob organises his
best-of songs according to his favourite singers (e.g., the classes MichaelJackson
and LouisArmstrong are declared as subclasses of BestSongs in his ontology),
the following correspondence expresses that any URL bookmarked by Bob as an
instance of his class MichaelJackson can be bookmarked by Alice as an instance
of her own class PopRock:1

Bob : MichaelJackson  Alice : PopRock

1 We make use of the notation P : A for identifying a class A of peer P s ontology.
?

?

?
An alignment between two peer ontologies is a set of correspondences between
some classes used by these peers. Figure 1 shows the ontologies and alignments
between Alices, Bobs and Chriss ontologies. It must be seen as a (small) part
of a semantic P2P system that can be queried for resource finding.

Alice

FavouriteBookmarks

FavouriteMusic

GoodRestaurants

Jazz PopRock Folk

Italian

Chinese

Bob : MichaelJackson  Alice : PopRock
Bob : LouisArmstrong  Alice : Jazz

Bob : Pizzeria  Alice : Italian

Chris : Gastronomic  Alice : GoodRestaurant

Chris : Trattoria  Alice : Italian

Chris : BluesMusic  Alice : Jazz

Bob

BestOf

Chris

MyBookmarks

BestSongs

BestRestaurants

Restaurants

BluesMusic

MichaelJackson

LouisArmstrong

Pizzeria

FastFood

Gastronomic Trattoria

Fig. 1. Three semantic peers in a P2P semantic network

Suppose Alice wants to get bookmarks from her acquaintances in the network
to enrich her bookmarks about Italian restaurants. The alignments between her
ontology and Bobs and Chriss ontologies allow to reformulate her initial query
about Italian restaurants into the query Pizzeria asked to Bob, and Trattoria
asked to Chris. As his answer set, Bob will return to her the set of instances in
the extension of his class Pizzeria, and Chris the set of instances in the extension
of his class Trattoria.

Alice notices that Chris has some bookmarks in common with her, and thus
tends to trust Chris for providing her with instances that fits well with her taste
in terms of Italian restaurants. Subsequently, she may be inclined to add new
bookmarks in her class Italian when they come from Chris.

However, although she trusts Chris for restaurants, she may not trust him
for his musical tastes. For instance, for getting new bookmarks about Jazz, she
can discover by choosing a sample of the set of URLs returned by Chris as the
extension of his class BluesMusic that very few corresponding music files fit well
with her taste in terms of Jazz music. For music, she will later tend not to trust
Chris and will prefer to query Bob on this topic.

M. Atencia et al.

Contributions
In this paper we propose a probabilistic model to handle trust in a semantic P2P
 regarding a
setting. We define the trust of a peer P towards another peer P
class C (belonging to P s ontology) as the probability that an instance returned
 as an answer to the query asking for instances of C is satisfactory for P . In
by P
order to compute trust, we exploit the information provided by peers ontologies
and alignments, along with the information that comes from direct experience.
Trust values are refined over time as more queries are sent and answers received.
We have designed an experimental protocol to study the convergence of trust,

and to measure the gain of using trust for resource finding in practice.

Finally, a by-product of our trust model is a probabilistic setting for resource
finding, in which the instances returned as answer for a given query are associated
with a probability. This is in line with the recent trends towards probabilistic
databases [4].

The paper is organised as follows. The background of our work is presented
firstly. Then we introduce the notion of probabilistic populated ontology and
the definition of trust. Later we explain the computation of trust and update of
probabilistic populated ontologies. We discuss experimental results, and finally
give some concluding remarks.

2 Preliminaries

In this section the components of a semantic peer-to-peer network are presented:
populated ontologies, alignments and acquaintance graphs. The kind of queries
that we take into account is also described.

2.1 Ontologies and Populated Ontologies
We draw a distinction between the ontological structure and the instances used
to populate it. We deal with lightweight ontologies: classes linked by means of a
less-general-than relation and a disjointness relation.
Definition 1. An ontology is a tuple O = C, , where C is a non-empty
finite set of class symbols;  is a partial order on C;  is an irreflexive and

symmetric relation on C; and for all c, c
  c and d

  C,
, d, d
  d then c

if c  d, c

  d
?

?

?
A populated ontology is the result of adding instances to an ontology in accordance to the intended meaning of the two ontological relations.
Definition 2. A populated ontology O is a tuple O, I, ext, where O is an
ontology, I is a set of
instances, and ext is a function that maps each class c
of O with a subset ext(c) of I called the extension of c, in such a way that the
family of class extensions covers I, and for all classes c, d the following hold:
1. if c  d then ext(c)  ext(d), and
2. if c  d then ext(c)  ext(d) = .
?

?

?
2.2 Alignments

In an open and dynamic environment as a P2P network, the assumption of peers
sharing the same ontology is not realistic. But if peers fall back on different
ontologies, there must be a way to connect ontologies and translate queries so
that their addressees are able to process them. Typically this is done by means
of alignments sets of correspondences between semantically related ontological
entities and finding alignments is what ontology matching is aimed at (see [7]).
 of two ontologies O and O
,
respectively, is usually defined as a tuple c, c
, r with r  {, =, ,}, where

 (or c, c
, c = c
 is read c is equal
c  c
, and c  c
 is read c is more general than c
 is read c is disjoint
, c  c
to c
. Here, however, we deal with a more general notion of a correspondence
from c
inspired from [6].

A correspondence between two classes c and c
, ) is read c is less general than c
?

?

?
 be two classes
Definition 3. Let O and O
, R
, respectively. A correspondence between c and c
of O and O
with R  2 where  is the set {=, >, <, ,}. An alignment A between O and
.
 is a set of correspondences between classes of O and O

 be two ontologies, and let c and c

 is a tuple c, c
?

?

?
,{>, <}) is read either c is more general than c

In such correspondences, a class is connected to another through a set of base
relations to be thought of as an exclusive disjunction. For instance, c{>, <}c

(i.e., c, c
 or less general than
. In this way, we can express uncertainty with regard to the alignment relation.
c
Note that the relations  and  can be seen as abbreviations for {=, >} and
{=, <}, respectively. Secondly, a nonstandard symbol  is introduced. It reflects
the idea of overlapping: classes the extensions of which share some instances
 states total
but no one is equal to or contained into the other. Finally, c  c
uncertainty about the relation between c and c

.

, . If c, c

According to Definition 3, an alignment may include correspondences that
link the same two classes through different relations, or no one connecting two
particular classes. However, one would like alignments to relate any pair of classes
 in
and to do it in one way. If there exists no correspondence between c and c
, S  A with
an alignment A, we can simply add c, c

R = S, we can replace both with c, c
, R S. This follows the interpretation of

alignments as a set of correspondences which all hold. The resulting alignment
is said to be normalised.
Definition 4. Let A be an alignment between two ontologies O and O
. The
normalisation of A is the alignment A made up of all correspondences c, c
, R

with c  C, c
, S  A}.
The alignment A is said to be normalised providing A = A.
Remark 1. Recall that if RA(c, c
) = .

RA(c, c

) where RA(c, c

) = {S : c, c

) =  then

 and R =
?

?

?
, R,c, c
?

?

?
  C
?

?

?
RA(c, c

All alignments considered in this work are assumed to be normalised.

M. Atencia et al.

2.3 Peers and Acquaintance Graphs
We consider a finite set P = {Pi}n
i=1 of peers. In this work, Pi will be identified
by i. We assume that each peer Pi is associated with one populated ontology
Oi = Oi, Ii, exti (where 1  i  n).

An acquaintance graph stands for peers acquaintances (or neighbours) in the
network. As usual, a link between two peers reflects the fact that they know the
existence of each other. In addition, we assume that there exists one alignment
between their respective ontologies.
Definition 5. An acquaintance graph is a labelled directed graph P, acq where
P = {Pi}n
i=1 is the set of vertices and any edge in acq is of the form i, j with
i = j, and it is labelled with an alignment Aij between ontologies Oi and Oj.
Moreover, if i, j  acq then j, i  acq and Aji is the inverse of Aij.2
Peer Pj is said to be an acquaintance of peer Pi if i, j  acq. The set of

acquaintances of Pi is denoted by acq(Pi).
, we can always consider
Remark 2. Note that, given two ontologies O and O
the trivial alignment, that is, the one that is made up of all correspondences
c, c

,  with c  C and c

  C

.
?

?

?
2.4 Queries and Query Translations
Peers pose queries to obtain information concerning other peers populated on-
tologies. We deal with a simple query language, as peers can only request class
instances: if peer Pj is an acquaintance of peer Pi, she may be asked

Q = c(X)?

(1)
by Pi with c  Oi. Now, since we do not assume that all peers share the same
ontology, queries may require to be translated for their recipients to be able to
process them.
Query translations are determined by correspondences of the alignments of
the network. Specifically, if peer Pi wants to send Q to Pj, she will first choose
one correspondence c, d, R  Aij (typically R is equal to = or >) and then
send Pj the translation

= d(X)?

(2)
The answer to (1) through its translation (2) is the set of instances of class d
in Pjs populated ontology. Unlike queries, we assume that no translation of
instances is ever required. Since alignments may be unsound and incomplete,
this answer may contain unsatisfactory instances, i.e., instances which are not
considered instances of c by Pi.

A peer cannot foresee whether the answer that another peer provides to one
of her queries contains satisfactory instances or not, but this uncertainty can be
estimated with the help of a trust mechanism.
2 Given an alignment A between O and O
{c, c, R1 : c, c, R  A} between O
is > and < if r is < and >, respectively, and r1 = r otherwise.

, the inverse of A is the alignment A1 =
and O, where R1 = {r1 : r  R} and r1

Q
?

?

?
3 The Trust Mechanism

As mentioned above we look at trust as a way to estimate the proportion of
satisfactory instances in a peer answer. The notion of satisfactory instance can
be faithfully captured by an ideal populated ontology O
i that corresponds to
a hypothetical situation in which peer Pi classified all instances of the network
according to her ontology Oi. In this way we can express the fact that Pi considers
an arbitrary instance a as an instance of c  Oi by a  ext

i (c). It is assumed that
i (c) for every class c  Ci. This populated ontology
i and exti(c)  ext


Oi = O
is referred to as the reference populated ontology of peer Pi.
If peer Pi receives a set B as an answer to the query (2), the proportion of
i (c)|B). The

satisfactory instances is given by the conditional probability p(ext
probability space under consideration here is the triple (, A, p()) where  is the
set of instances of the network (a finite set), the -algebra A is the power set of
, and p() is Laplaces definition of probability. Our approach for trust aims at
finding approximations to these conditional probabilities. Before the definition
of trust we introduce the notion of a probabilistic populated ontology.

3.1 Probabilistic Populated Ontologies

Once an answer is received, it can be (partly) added or not to the extension of
the queried class. In order to capture the evolution of class extensions in the
network, we consider a time variable t  N, and we will write Ot
i to denote peer
Pis populated ontology at instant t (beginning with Oi):

Oi = O0

i ,O1

i , . . . ,Ot

i, . . .

(3)
i (t  N),
We assume that the underlying ontology never changes, i.e., Oi = Ot
i(c)}tN is monotonically increasing
and that the sequence of class extensions {extt
for all c  Ci.
Nonetheless, since we deal with probabilities new instances may not be 100%
satisfactory. For this reason, at t  N, peer Pi is associated with a probabilistic
populated ontology.

Definition 6. Peer Pis probabilistic populated ontology at time t is a triple

Ot
i = Oi, I t

i ,ext
?

?

?
t
i

i is a set of instances and ext

where I t
Oi with its probabilistic extension

ext
i(c) = A


t

t
i is a function that maps each class c of

,F with F = {Ak, [pk, qk]}kK where

 A

 is a (possibly empty) subset of ext
i (c), that is, a set of instances which
are certain to be instances of the class c, and all
 Ak are pairwise disjoint subsets of I t
, and
all [pk, qk] are distinct subintervals of the unit interval [0, 1], where k  K
and K is a (possibly empty) index set of integers.

i which are also disjoint from A

M. Atencia et al.

Furthermore, the tuple Ot
kK Ak must be
a populated ontology (so that the axioms that relate classes with their extensions
are fulfilled).

i = Oi, I t

 with extt

i(c) = A

i , extt
i

A probabilistic extension ext

t

 

, A1, . . . , An. All instances of A

i(c) can be seen as a classical extension extt

i(c)

 are
partitioned into a number of subsets A
i (c)|A

) = 1. However, the
sure to be instances of the class c and then p(ext
set Ak (1  k  n) may contain instances that are actually not instances of c.
The idea behind the interval [pk, qk]  [0, 1] is that there exists some statistical
evidence for pk  p(ext
i (c)|Ak)  qk.3 The way probabilistic extensions are

built is explained in Section 3.5.
Remark 3. Every populated ontology Oi can be seen as a probabilistic populated

ontology Oi = Oi, Ii, exti where exti(c) = {exti(c),} for all c  Ci.

Peers build probabilistic populated ontologies as more queries are sent and answered (starting with the probabilistic version of Oi):

Oi = O0
i , O1
i , . . . , Ot

i, . . .

(4)

And what was said about (3) at the beginning of this section holds for the
underlying populated ontologies of (4).

3.2 Definition of Trust

With the new terminology, Pjs answer to query (1) via its translation (2) at time
j(d), and an arbitrary instance a  extt
j(d) is qualified as
t is the extension extt
satisfactory provided that a  ext

i (c). The proportion of satisfactory instances
i (c)|extt

in extt
j(d) is given by the conditional probability p(ext
j(d)). Our proposal
is that the higher this value is, the more Pi trusts Pj.
Definition 7. Let us consider two peers Pi and Pj (i = j) and two classes c
and d of Oi and Oj, respectively. The trust that Pi has towards Pj with respect
to the translation c, d at time t is the conditional probability p(ext
i (c)|extt

j(d))
and it is denoted by trustt(Pi, Pj,c, d).
This idea is slightly different from most of the existing approaches for trust. In
our setting cheating is not directly addressed: unsatisfactory answers are seen
as the result of peers incapacity to understand each other. In addition, trust
is dependent on translations: peers may be very trustworthy in regard with
some translations but not with others. In the following section, we explain our
approach for computing trust. It exploits the information provided by alignments
and revises it with direct experience.

3 The use of intervals follows Lukasiewiczs notation for conditional constraints in

probabilistic knowledge bases [11].
?

?

?
3.3 Computation of Trust
Our approach for trust aims at approximating trustt(Pi, Pj ,c, d) by Bayesian
inference. A probability distribution T t(Pi, Pj,c, d) represents Pis belief about
i (c)|extt

j(d)). If there is no direct experience, alignments are taken to
 = p(ext
construct prior beliefs. Answers are later used to revise these beliefs. As they can
be of a size that cannot be processed manually, we propose to perform sampling
with replacement in order to estimate the number of satisfactory instances. We
work with beta distributions as they are typically used to describe the parameter
of a binomial distribution.
No direct experience: alignment-based trust. If T t(Pi, Pj,c, d) is not defined
(this is the case when, for instance, t = 0), we fall back on alignments. Peers Pi
and Pjs ontologies are linked through Aij. Since this alignment is normalised
then there exists a unique R   such that c, d, R  Aij. The intending
meaning of correspondences is
R = {=}
R = {>}
R = {<}
R = {}
R = {  }



i (c) = ext
j (d)
iff
ext
i (c)  ext


j (d)
iff
ext
i (c)  ext


iff
j (d)
ext
i (c)  ext
j (d) = 


iff
ext
none of the above holds
iff
j(d)  ext

j (d),

Hence, provided that extt

if R is = or >
if R is 
if R is < or   

then
then
then

i (c)|extt

j(d)) = 1
p(ext
i (c)|extt

p(ext
j(d)) = 0
j(d))  [0, 1]
i (c)|extt

p(ext
n
n

n

bk

k=1

In the general case, R is a set {r1, . . . , rn}   (with n  5). If we assume that
all relations in R are equiprobable, by the law of total probability, we have

trustt(Pi, Pj,c, d)  [u, v] with u =

n

k=1

ak

v =

where [ak, bk] = [1, 1] if rk is = or >, [ak, bk] = [0, 0] if rk is , and finally
[ak, bk] = [0, 1] if rk is < or  (k = 1, . . . , n).

The information above can be used to construct Pis prior belief about the
i (c)|extt

parameter  = p(ext
j(d)) by means of a beta distribution Beta(, ). If
[u, v] = [0, 1], we take the uniform distribution U[0, 1] = Beta(1, 1). If not, and
u < v, we equal [u, v] with [ 2,  + 2] and then find Beta(, ) whose mean
and deviation are  and . This is the standard way to find a confidence interval
based on the normal distribution. If u = v, we proceed with  = 0.005 and  = u
unless u = 1 and u = 0, in which cases  = 0.99 and  = 0.01, respectively.4 In
this way, we define the trust distribution T t(Pi, Pj,c, d) = Beta(, ).
(1)
4 The values for  and  can be found by solving  = 
++1 .

+ and  =
?

?

?
M. Atencia et al.

Example 1. If R = {<, =} then [u, v] = [.5, 1]. If we make [.5, 1] = [2, +2]
then  = .75 and  = .125. This leads to Beta(8.25, 2.75) whose shape is depicted
in Figure 2(a). Figure 2 is completed with the shapes of beta distributions for
the relations R = {=} and R = . The latter corresponds to Beta(0.4, 0.8).5

.

.

.

.

.

.

.

0.0

0.4

0.8

0.2

(a) c,{<, =}, d

0.6
?

?

?
1.0

0.0

0.8

1.0

0.0

0.2

0.4

0.6

(c) c, , d

0.8

1.0

0.6

0.4

0.2

(b) c,{=}, d

Fig. 2. Beta distributions for different correspondences

that Pi is associated with a probabilistic populated ontology Ot

Direct experience. Trust at time t is used to choose a peer to which to send a
query, as well as a class through which to translate it. This is explained in detail
in Section 3.4. Let us imagine that Pi receives B = extt
j(d). A sampling with
replacement is performed over B in order to estimate the number of satisfactory
instances. Let S  B be a sample (strictly speaking, S is a multiset). We assume
that every peer can call an oracle (typically the user) to find out whether an
instance is satisfactory or not. More specifically, given a  S, Pis oracle provides
a yes/no response to the question: a  ext

i (c)?. Even this, nonetheless, may
be a high burden for Pis oracle. We can benefit from peers populated ontologies
to process some instances automatically without the need to call oracles. Recall
i, and that the
 of instances which are certain
probabilistic extension of class c includes a set A
i (c). So if a  B  A
, a  ext


to be instances of ext
i (c). We can also identify
unsatisfactory instances automatically: if a  S is such that there exists c
 in Oi
 then a / ext
with c  c
 and a  A

i (c). The remaining instances are processed
by peer Pis oracle.
Assume that T t(Pi, Pj,c, d) = Beta(, ). If s is the sample size, s+ is the
 = s  s+ is the number of
number of successes (satisfactory instances), and s
i (c)|extt

failures, peer Pis posterior belief about  = p(ext
j(d)) is summarised in
Beta( + s+,  + s

). Thus we define
T t+1(Pi, Pj ,c, d) = Beta( + s+,  + s



)

(5)

5 Although cd stands for total uncertainty about the relation between c and d, the
mean of its associated beta distribution, Beta(0.4, 0.8), is not 0.5 but 0.6. However,
our aim is not to find out the correct relation between c and d, but to estimate the
probability p(ext
j(d)). In this sense, total uncertainty arises with c < d, c  d
or c{<, }d, which are all modelled with a uniform distribution (whose mean is 0.5).

i (c)|extt
?

?

?
3.4 Use of Trust
Imagine that peer Pi wants to query c(X)? (c  Ci) at time t  N. Then Pi
chooses an element from the set

P0 = {Pj, dj : Pj  acq(Pi) and dj  Oj}

so that, if Pj0 , dj0 is the preferred tuple, Pi will send dj0(X)? to Pj0. This
choice depends on trust: Pi opts for Pj0 , dj0 iff

E(T t(Pi, Pj0 ,c, dj0)) = max

{E(T t(Pi, Pj,c, dj))}

Pj ,djP0

where E() denotes the expected value of a distribution.

3.5 Updating Probabilistic Populated Ontologies

In the end, trust is used for class extensions to be increased with new satisfactory
instances. If peer Pi receives B = extt
j(d) as an answer to c(X)? then B will be
(partly) added to extt
i(c). In line with the computation of trust based on direct
experience (see Section 3.3), the set B is partitioned into three subsets:

aut

}


aut)

 B

B = B+
aut
aut
i(c)} = B  extt
aut and a / B

aut

 Baut
i(c)
  Oi with a  extt
i(c
} = B \ (B+

) and c  c
 B

aut contains the instances in B that already belong to extt

 B+
aut = {a  B : a  extt
aut = {a  B : there exists c
 B

 Baut = {a  B : a / B+
The set B+
i(c), and

i(c), would yield to a logical
aut comprises those instances that, if added to extt

inconsistency. The set Baut embodies the new information that can be included
i(c).6 Since the answer B was received as the result of a comparison of
in extt
trust values, it seems reasonable to add all instances of Baut to extt
i(c). The fact
that these instances may not be 100% satisfactory, though, should be reflected
in Pis populated ontology. As described in Section 3.1, probabilistic populated
ontologies are designed for this purpose.
The set Baut will be included in extt
i(c) along with an interval [p, q] such that
i (c)|Baut)  q on the basis of statistical evidence. Again, we propose
p  p(ext

to perform Bayesian inference, but, instead of weighing more on Pis oracle, we
lean on the previous sampling and make use of the formula
i (c)|Baut)  p(Baut

j(d)) = p(ext


i (c), Baut
p(ext

|extt

|extt

j(d))

(6)

Let us explain this in detail. The probability p(Baut
portion of instances of Baut in extt
By monotonicity, we have
0  p(ext

i (c), Baut

j(d))  p(Baut

|extt

|extt

j(d))

j(d)) represents the pro-
j(d) and its computation is straightforward.

|extt

6 The subscript aut stands for automatic, as both instances from B+

can be automatically processed, whereas this is not the case for Baut.

aut and B

aut

M. Atencia et al.

|extt


In order to compute a prior about  = p(ext
j(d)), we proceed as
i (c), Baut
the computation of alignment-based trust (Section 3.3): we equate the interval
j(d)), with [  2,  + 2], and then find
[u, v], where u = 0 and v = p(Baut
Beta(, ) whose mean and deviation are  and , respectively. A posterior is
computed with the same sampling S used for Equation 5, but this time we count
as a success any satisfactory instance that also belongs to Baut.
 and 
 be its mean and
i(c) along with the interval [p, q] where

) be the resulting posterior, and let 

deviation. The set Baut is included in extt
?

?

?
Let Beta(

|extt

, 

j(d))

q =

j(d))

p =
?

?

?
(
?

?

?
+ 2

)

p(Baut

  2
?

?

?
)

(

|extt

 S+ and Baut

\ S+, which are added to extt

i is defined as the probabilistic version of Pis

|extt
p(Baut
i (c)|Baut)  q with 95% probability, which is based on the
Hence, p  p(ext

normal approximation to the posterior density for  and Equation 6. Actually, if
S+ denotes the set of satisfactory instances in the sample S, Baut is partitioned
into Baut
i(c) separately. Thus [p, q]

]. Below
As remarked in Section 3.1, O0
must be resized accordingly, and then replaced by another interval [p
, q
we explain explicitly how probabilistic populated ontologies are built.
 O0
i = Oi, and
initial populated ontology Oi, that is,
 at time t  N, if ext
ext
In order for Ot+1

(c) = A
to be a probabilistic populated ontology, though, Baut must
 of c. For the sake of space, we
be included in the extension of any superclass c
give a brief explanation of how this is done. Notice first that no instance in Baut
 Baut =  and c
belongs to the extension of a class disjoint from c
 since
. All instances in Baut
is a subclass of c
i (c)  ext


)) as some
). Instead of Baut
i (c
ext
\ S+ may already belong to extt
). In order to find an interval
i(c
instances of Baut
\ (S+ extt
)|Baut

))), we proceed as before to
with which to estimate p(ext
i(c
i (c
i (c)|Baut
\ (S+  extt
))) and then apply the monotonicity

By construction, Ot+1
approximate p(ext
i(c
of probability. In this way, the upper bound that we obtain is equal to 1.

,F then we define
 S+),F  Baut

 S+ are certainly instances of c

is a probabilistic populated ontology.

\ S+ we include Baut

\ (S+ extt
i(c

t

i(c) = A


  (Baut

\ S+, [p
?

?

?
 as B


aut
?

?

?
]

, q

t+1
i

i

i

4 Experimental Analysis

This section reports on a preliminary experimental campaign that has been
conducted to test the viability of the trust mechanism described in this paper.

We set out to answer two research questions:

1. Do trust values converge as more queries are sent and answers received?
2. Is there any gain in query-answering performance measured in precision

and recall by using the trust technique?

In what follows we first describe the experimental setting and then explain the
execution and evaluation.
?

?

?
4.1 Experimental Setting

The trust mechanism presented in this work has been implemented in a simulator
written in Java. The simulator also deals with aspects indirectly related to trust,
such as generation of P2P networks, populated ontologies and alignments. In the
remainder of the section we elaborate more on these aspects.

P2P network topology. Social networks are well-known to exhibit small-world
characteristics [5]. For this reason, a small-world topology was used for the entire
evaluation. To generate this topology, we ran Kleinbergs algorithm included in
the JUNG Java library.7 A node in the network represents a peer associated
with a populated ontology. The total number of peers in our evaluation was 20.

i

i and initial populated ontologies Oi = O0

Populated ontologies. All populated ontologies in the evaluation had the same
underlying ontology Oi = O. More specifically, we chose the ontological scheme
described in [10] (with 64 classes). The semantic heterogeneity was reproduced
by the way classes were populated with instances. The simulator implements
an ontology population module which was utilised for both reference populated
ontologies O
i . First, a set S of abstract
instances is generated. In our evaluation, the size of S was 6000. Second, for each
peer Pi, a sample Si is taken from S. Furthermore, this sampling is performed in
a way that Si and Sj overlap for each pair i, j. The size of each Si is determined
with a Zipfian distribution, which is often used to approximate data in physical
and social sciences [12]. The skewing factor considered was 0.5. Third, the top
class of O
is populated with Si and a top-down population process is carried
out by removing instances randomly for the remainder of classes. During this
process, we check that all ontological axioms subclass and disjoint relations
are fulfilled. Initial populated ontologies are generated in a similar way, starting
this time with a sample of Si instead of S to populate the top class in Oi.
Alignment generation. A connection between peers Pi and Pj in the network
(edge between nodes) is labelled with an alignment Aij between their respective
ontologies. This is seen as a declined version of a reference alignment A
ij which
is never available to the peers. Thus we can capture the real practice of ontology
matching. Reference alignments are built by comparing class extensions in the
i (c) 
reference populated ontologies (for instance, c < d is included in A

ij iff ext

j (d)). To build initial alignments, correspondences in reference alignments are
ext
discarded or replaced randomly in accord with global values for precision and
recall. In our evaluation, we chose 0.6 for both measures.

4.2 Execution and Evaluation
From all peers and classes in the network we chose a subset P0  P of 15 peers
and a subset C0  C of 25 classes randomly and ran 100 simulations. At each
round n  100 of the execution, a peer Pi  P0 and a class c  C0 are randomly
chosen. Then an acquaintance Pj of Pi and a class d  Cj are selected by using

http://jung.sourceforge.net

M. Atencia et al.

the trust mechanism (Section 3.4). Notice that Ci = Cj = C as we chose a single
ontological scheme O. To process answers, the maximum number of oracle calls
allowed was 40. The subset Baut
j(d) is included in peer Pis probabilistic
populated ontology if the expected value E(T n(Pi, Pj,c, d)) is greater than a
given threshold. In our evaluation, this threshold was 0.6.

 extt

In order to test the convergence of trust, we analysed the difference

n = |E(T n(Pi, Pj,c, d))  p(ext
i (c)|ext
j (d))|



over the 10 most occurred queries. Figure 3 shows the experimentation results.
After a number of rounds, n approached 0. Actually, in most of the cases, no
more than 5 rounds were needed for n to be close to 0.1.

 0.9

 0.8

 0.7

 0.6
?

?

?
 0.5

a

t
l

e

 0.4

 0.3

 0.2

 0.1

q1
q2
q3
q4
q5
q6
q7
q8
q9
q10

Round
Round

Fig. 3. Test of convergence of trust

In order to test the gain in query-answering performance, we compared the
use of the trust mechanism with a naive strategy. In the latter, peers randomly
choose acquaintances and always accept their answers. For the evaluation to be
fair, the same set of queries was used in both strategies. This time we analysed
precision and recall measured by

Precision(n) =

Recall(n) =

i (c)  extn
|ext

|extn
i (c)|

i (c)|

|ext
i (c)  extn

|ext
i (c)|


i (c)|

Figure 4 depicts the average precision and recall over the 100 rounds for the 20
most occurred queries. As expected, the naive strategy produced lower values
for both measures. Furthermore, the use of the trust mechanism ensured high
precision. However, this was not the case for recall. The reason is that peers only
ask their neighbours, and these ones never change. As instances are spread all
over the network, many instances may be unaccessible to peers. It is expected
that if instances were more accessible, recall would be higher, but this remains
to be experimented. The theoretical model presented in this paper is general
enough to cover the case where peers receive answers from non-neighbour peers.
?

?

?
n
o
i
s
i
c
e
r

 0.8

 0.6

 0.4

 0.2

Trust
Naive

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

l
l
a
c
e

 0.8

 0.6

 0.4

 0.2

Trust
Naive

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

Query

Query

Fig. 4. Comparison between the use of trust and the naive strategy

5 Concluding Remarks

We have proposed a trust mechanism in semantic P2P systems. The trust that
a peer has towards another peer depends on a specific query and represents the
probability that the latter will provide a satisfactory answer. In order to compute
trust, we exploit alignments and peers direct experience, and perform Bayesian
inference. Preliminary experimental results show that trust values converge as
more queries are sent and answers received, and that there is a gain in queryanswering precision and recall when peers make use of the trust mechanism.

The notion of probabilistic populated ontology has been introduced. This is a
by-product of trust computation that allows to store and process the instances
obtained from query answers in the same way as it is done in probabilistic
databases [4]. More precisely, a probabilistic populated ontology can be seen as
a probabilistic database in which each fact C(i) is associated with a (lower bound
of) probability. As a result, query answers can be ranked, and only top-k answers
can be returned to interested users. In addition, since trust evolves over time as
more queries are spread over the network and their answers are processed and
stored with their probabilities, the resulting probabilistic populated ontologies
somehow capture and compile the results of a trust propagation.

Many different probabilistic approaches to trust can be found in the literature
[16,13]. Some also perform Bayesian inference over feedback on past interactions.
However, to the best of our knowledge, our model is the only one which explicitly
benefits from ontological content and alignments.

EigenTrust [9] is a peer-to-peer algorithm which, like ours, has a direct trust
computation. Direct trust is then propagated among peers and aggregated to
calculate global trust which can be very costly. As remarked above, we avoid this
computation by exploiting the information on global trust stored and compiled
in the probabilistic populated ontologies of acquaintance peers.

As future work, we plan to extend our trust model in order to deal with
more expressive ontology and query languages. Although witness peers are not
considered in this paper, the use of witness information is another future research
line. Witness peers can help to find new trustworthy acquaintances. In this way,
recall values can increase. Furthermore, the impact of malicious peers that hide
or bias information, or lie, will be studied too.

M. Atencia et al.

Regarding the experimentation, we aim to perform a thorough experimental
analysis concerning different network configurations in terms of number of peers,
instances and oracle calls. Moreover, we want to investigate the relation between
the quality of alignments and the speed of convergence of trust values.

Acknowledgements. This work is supported under the Dataring project, which
is sponsored by the Agence Nationale de Recherche (ANR-08-VERS-007), and
the Webdam project, sponsored by the European Research Council (FP7-226513).
