Repairing Ontologies for Incomplete Reasoners

Giorgos Stoilos, Bernardo Cuenca Grau, Boris Motik, and Ian Horrocks

Department of Computer Science, University of Oxford

Wolfson Building, Parks Road, OX1 3QD, Oxford

Abstract. The need for scalable query answering often forces Semantic
Web applications to use incomplete OWL 2 reasoners, which in some
cases fail to derive all answers to a query. This is clearly undesirable,
and in some applications may even be unacceptable. To address this
problem, we investigate the problem of repairing an ontology T that
is, computing an ontology R such that a reasoner that is incomplete for
T becomes complete when used with T R. We identify conditions on T
and the reasoner that make this possible, present a practical algorithm
for computing R, and present a preliminary evaluation which shows that,
in some realistic cases, repairs are feasible to compute, reasonable in size,
and do not significantly affect reasoner performance.

1 Introduction

Answering SPARQL queries over RDF data sets structured using an OWL 2
ontology provides the basis for a large number of Semantic Web applications.
Such data sets can, however, be extremely large, and reasoning with OWL 2 DL
ontologies is known to be of high computational complexity. As a consequence,
complete reasonersthat is, reasoners such as Pellet, HermiT, and RACER that
are capable (modulo bugs) of correctly computing all answers to all queries for
all ontologies and datasetsoften fail to deliver the required level of scalability.
Application developers thus often use scalable but incomplete reasonersthat is,
reasoners that, for some query, ontology, and dataset, fail to compute all answers
to the query. Examples of such incomplete reasoners include state of the art RDF
management systems, such as Jena [8], OWLim [6], DLE-Jena [9], and Oracles
Semantic Store [17], which typically provide completeness guarantees only for
ontologies expressed in the OWL 2 RL [11] profile of OWL 2 DL.

The lack of a completeness guarantee may be unacceptable for applications
in areas such as healthcare and defence, where missing answers may have serious consequences. Furthermore, even if an application can tolerate some level
of incompleteness, it is desirable to provide the highest level of completeness
that is compatible with the required scalability. Hence, techniques for improving the completeness of incomplete reasoners have recently been investigated.
A common approach is to materialise certain kinds of ontology consequences
before computing query answers. Such a solution does not require modifying
the internals of the reasoner since the relevant consequences can be added as
ontology axioms in a preprocessing step. In fact, systems such as DLE-Jena [9],

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 681696, 2011.
c Springer-Verlag Berlin Heidelberg 2011

G. Stoilos et al.

PelletDB,1 TrOWL [12], Minerva [7], and DLDB [4] internally use a complete
OWL 2 DL reasoner to transparently materialise certain axioms. Furthermore,
materialisation is used in approximation frameworks [12,2], where an OWL 2
DL ontology is projected into OWL 2 QL to allow for scalable reasoning.

Existing materialisation approaches, however, exhibit several important lim-
itations. First, materialisation is commonly performed without taking into account the capabilities of the incomplete reasoner and may thus introduce redundant axioms. Second, to avoid a blowup in the ontology size, typically only
subsumptions between (named) classes are materialised. Third, the extent to
which materialisation improves a reasoners completeness is often unclear, particularly if the data set is large, frequently changing, or unknown in advance.
In this paper, we present a novel approach to materialisation that addresses
these limitations. Given an OWL 2 DL ontology T and a reasoner complete for
OWL 2 RL, we show how to compute a repair R of T for the given reasoner.
Intuitively, R is a set of OWL 2 RL consequences of T that, if added to T ,
allow the reasoner to become complete for T that is, by using T  R as input,
the reasoner can correctly answer all queries w.r.t. T for all data sets. We focus
on achieving completeness w.r.t. ground certain answers (i.e., answers obtained
by matching query variables to named individuals). This is consistent with the
semantics of SPARQL, and it allows us to ensure the existence of a repair whenever T can be rewritten into an OWL 2 RL ontology. Our technique is guided
by both the input ontology and the reasoner, which limits the size of R and
ensures that adding R to T has minimal impact on the reasoners scalability.
Towards this goal, we proceed as follows.

In Section 3, similarly to our previous work [16,15], we devise a way of abstracting concrete reasoners using a notion of a reasoning algorithm, and we
formalise the notion of an ontology repair for a reasoning algorithm.
In Section 4 we present a practical, two-step technique for computing a repair
of an OWL 2 DL ontology T for a reasoner complete for OWL 2 RL. We first
rewrite T into an OWL 2 RL ontology T  that is entailed by T and that preserves
all ground answers to arbitrary queries over T , regardless of the data. Based on
this rewriting, we subject the incomplete reasoner to a series of tests, whose
results identify the subset of the rewriting that constitutes a repair.

In Section 5 we demonstrate empirically that repairs can be computed in
practice for well-known ontologies and reasoners. Our experiments show that the
size of repairs is typically quite small, and that extending the original ontology
with a repair typically has a negligible impact on reasoner performance.

2 Preliminaries

In this paper we use the standard notions of constants, variables, (function-
free) atoms, sentences, substitutions, satisfiability, unsatisfiability, and entailment
(written |=) from first-order logic. An application of a substitution  to a term,
atom, or formula  is written as (). The falsum symbol (i.e., the symbol that

http://clarkparsia.com/files/pdf/pelletdb-whitepaper.pdf
?

?

?
is false in all interpretations) is written as . A datalog rule r is an expression
of the form B1  . . .  Bn  H where H is either  or an atom, each Bi is an
atom, and each variable occurring in H occurs in some Bi as well. The body
of r is the set body(r) = {B1, . . . , Bn}, and the head of r is head(r) = H. Both
head and body atoms can contain the equality predicate , and head atoms
can also contain the inequality predicate . A datalog rule is interpreted as
a universally-quantified first-order implication. It is well known that checking
whether a first-order theory entails a datalog rule can be realised as follows.
Proposition 1. Let F be a set of first-order sentences and let r be a datalog rule
such that body(r) = {B1, . . . , Bn} and head(r) = H. Then, for each substitution
 mapping the variables of r to distinct constants not occurring in F or r, we
have F |= r if and only if F  {(B1), . . . , (Bn)} |= (H).

2.1 OWL 2 DL and OWL 2 RL
We assume the reader to be familiar with the OWL 2 DL ontology language
[10]. For succinctness, we use the Description Logics (DL) notation to write
down OWL 2 DL axioms; please refer to [1] for an overview of the relationship
between DLs and OWL. As is common in the literature, we partition an OWL 2
DL ontology into a TBox (i.e., a finite set of axioms describing the classes and
properties in a domain of discourse) and an ABox (i.e., a finite set of facts). For
simplicity, we assume that all ABox assertions refer to classes and properties
only (i.e., that they do not contain complex class and property expressions); an
ABox is thus allowed to contain class and property assertions, equalities, and
inequalities, all of which can involve named and/or unnamed individuals.

OWL 2 RL [11] is a prominent profile of OWL 2 DL. Each OWL 2 RL ontology
can be translated into an equivalent datalog program using (a straightforward
extension of) the transformation presented in [3]. This close connection with
datalog makes OWL 2 RL a popular implementation target since OWL 2 RL
reasoners can be implemented by extending RDF triple stores with deductive
features. For simplicity, in this paper we assume that each OWL 2 RL axiom
 can be translated into a single datalog rule (); this can be ensured by
transforming axioms using de Morgan identities to eliminate disjunctions and
conjunctions in subclass and superclass positions, respectively.
Example 1. Consider the following OWL 2 DL ontology that describes the
organisation of a typical university.

GradCo  Co  GradCo(x)  Co(x)

take.Co  Student  take(x, y)  Co(y)  Student(x) (1)
(2)
(3)
(4)
(5)
(6)
(7)

PhDSt  GradSt  PhDSt(x)  GradSt(x)
Student  Co    Student(x)  Co(x)  
teach.  Employee  teach(x, y)  Employee(x)
GradSt  take.GradCo
ResAsst  PhDSt  teach.LabPrac

G. Stoilos et al.

According to the definition of OWL 2 RL [11], axioms (1)(5) are OWL 2 RL
axioms, and so each axiom can be transformed into an equivalent datalog rule
shown on the righthand side. In contrast, axioms (6) and (7) contain an existential quantifier (someValuesFrom in OWL 2 jargon) in the superclass position,
so they cannot be translated into an equivalent datalog rule. The OWL 2 RL

profile therefore disallows axioms such as (6) and (7).

2.2 Queries
A union of conjunctive queries (UCQ) Q with a query predicate Q is a datalog
program in which each rule contains Q in the head but not in the body. We
assume that query predicates do not occur in TBoxes and ABoxes.
Let Q be a UCQ with query predicate Q; let F be a set of first-order sentences;
let A be an ABox; let G be a class not occurring in F, A, and Q; let AG be the
ABox containing the class assertion G(a) for each individual a occurring in A;
and let QG be the UCQ obtained from Q by adding to the body of each rule
r  Q the atom G(x) for each variable x occurring in r. A tuple of constants a
is a certain answer to Q w.r.t. F and A if the arity of a agrees with the arity
of Q and T  A  Q |= Q(a). The set of all certain answers of Q w.r.t. F and A
is written as cert(Q,F ,A). If Q is propositional (i.e., if the query is Boolean),
then cert(Q,F ,A) is either empty or it contains the tuple of zero length; in such
cases, we commonly write cert(Q,F ,A) = f and cert(Q,F ,A) = t, respectively.
Furthermore, a is a ground certain answer to Q w.r.t. F and A if the arity of a
agrees with the arity of Q and F  A  QG  AG |= Q(a). The set of all ground
certain answers of Q w.r.t. F and A is written as certG(Q,F ,A).

3 A Framework for Repairing OWL Ontologies

We now introduce the technical framework that the rest of this paper depends
on. In particular, in Section 3.1, we formalise the notion of a reasoning algorithm,
and in Section 3.2 we formalise the notion of an ontology repair.

3.1 Reasoning Algorithms

As in [16,15], we abstract concrete reasoners using a notion of a reasoning algo-
rithm. This has several benefits: it allows us to precisely specify the assumptions
that a reasoner must satisfy for our results to be applicable, it allows us to precisely define the notions of completeness and repair, and it allows us to prove
that our algorithm for repairing ontologies indeed guarantees completeness.

Definition 1. A reasoning algorithm ans is a computable function that takes
as input an arbitrary OWL 2 DL TBox T , an arbitrary ABox A, and either a
special unsatisfiability query  or an arbitrary UCQ Q. The return value of ans
is defined as follows:
 ans(,T ,A) is either t or f; and
?

?

?
 ans(Q,T ,A) is defined only if ans(,T ,A) = f, in which case the result is a

set of tuples each having the same arity as the query predicate of Q.

Intuitively, ans(,T ,A) asks the reasoner to check whether T  A is unsatisfi-
able, and ans(Q,T ,A) asks the reasoner to evaluate Q w.r.t. T and A. If T A
is unsatisfiable, then each tuple of the same arity as the query predicate of Q is
trivially an answer to Q; therefore, the result of ans(Q,T ,A) is of interest only
if ans(,T ,A) = fthat is, if ans identifies T  A as satisfiable.
Example 2. Let rdf, rdfs, rl, and classify be reasoning algorithms that, given a
UCQ Q, an OWL 2 TBox T , and an ABox A, proceed as described next.
The algorithm rdf ignores T and evaluates Q w.r.t. A; more precisely, we
have rdf(,T ,A) = f and rdf(Q,T ,A) = cert(Q,,A). Thus, rdf captures the
behaviour of RDF reasoners.
The algorithm rdfs constructs a datalog program Prdfs by translating each
RDFS axiom  in T into an equivalent datalog rule; then, rdfs(,T ,A) is always
answered as f; furthermore, Q is evaluated w.r.t. T and A by evaluating Prdfs over
Athat is, rdfs(Q,T ,A) = cert(Q,Prdfs,A). Thus, rdfs captures the behaviour
of RDFS reasoners such as Sesame.
The algorithm rl constructs a datalog program Prl by translating each OWL
2 RL axiom  in T into an equivalent datalog rule; then, rl(,T ,A) is answered
by checking whether Prl  A is satisfiablethat is, rl(,T ,A) = t if and only
if Prl  A |= ; furthermore, Q is evaluated w.r.t. T and A by evaluating Prl
over Athat is, rl(Q,T ,A) = cert(Q,Prl,A). Thus, rl captures the behaviour of
OWL 2 RL reasoners such as Jena and Oracles Semantic Data Store.
The algorithm classify first classifies T using a complete OWL 2 DL reasoner;
that is, it computes a TBox T  containing each subclass axiom A  B such
that T |= A  B, and A and B are (named) classes occurring in T . The algorithm then proceeds as rl, but considers T  T  instead of T ; more precisely,
classify(,T ,A) = rl(,T  T 
,A). In
this way, classify captures the behaviour of OWL 2 RL reasoners such as DLDB
and DLE-Jena that try to be more complete by materialising certain conse-

quences of T .
Reasoning algorithms such as the ones specified in Example 2 are incomplete
for OWL 2 DLthat is, there exist inputs for which they fail to compute all
ground certain answers. These algorithms, however, are complete for a fragment
of OWL 2 DL: algorithms rl and classify are complete for OWL 2 RL inputs,
and algorithms rdf and rdfs are complete for RDF and RDFS, respectively. We
next formally define the notion of an algorithm being complete for a fragment
of OWL 2 DL (w.r.t. ground certain answers). Intuitively, for each UCQ, such
an algorithm computes at least all ground certain answers for the UCQ and the
part of the TBox that fits into the fragment in question.
Definition 2. Given an OWL 2 DL TBox T and a fragment L of OWL 2 DL,
T |L is the set of all L-axioms in T .

,Ain) and classify(Q,T ,A) = rl(Q,T  T 

G. Stoilos et al.

Let ans be a reasoning algorithm, and let L be a fragment of OWL 2 DL. We
say that ans is complete for L if the following conditions hold for each OWL 2
DL TBox T , each UCQ Q, and each ABox A:
 T |L  A |=  implies ans(,T ,A) = t; and
 ans(,T |L,A) = f implies certG(Q,T |L,A)  ans(Q,T ,A).
Note that an L-complete reasoning algorithm need not be sound (i.e., it may
compute answers that are not certain answers). Although virtually all existing
concrete reasoners are based on sound algorithms, their implementation may
be unsound due to bugs. The results presented in this paper, however, do not
require reasoning algorithms to be sound, so we can repair ontologies for concrete
reasoners even if they are unsound. This is important in practice since testing
reasoners for soundness is currently infeasible.

3.2 The Notion of a Repair
Intuitively, a repair of an OWL 2 DL TBox T for an algorithm ans is a TBox
R such that adding R to T allows ans to correctly compute all ground certain
answers for all UCQs and all ABoxes. For a repair to be useful, R should not
introduce new consequencesthat is, R should be a logical consequence of T .
This intuition is captured by the following definition.
Definition 3. Let T be an OWL 2 DL TBox and let ans be a reasoning algo-
rithm. A repair of T for ans is an OWL 2 DL TBox R such that T |= R, and
the following conditions hold for each UCQ Q and each ABox A:
 T  A |=  implies ans(,T  R,A) = t; and
 ans(,T  R,A) = f implies certG(Q,T ,A)  ans(Q,T  R,A).
Example 3. Let T be the TBox containing axioms (1)(7) from Example 1, let
A = {PhDSt(a), ResAsst(a)}, and let Q1 and Q2 be the following UCQs:

Q1 = {Student(x)  Q(x)}
Q2 = {Employee(x)  Q(x)}

(8)
(9)

One can check that certG(Q1,T ,A) = certG(Q2,T ,A) = {a}.

Consider now the algorithm rl from Example 2. Since axioms (6) and (7) are
not in OWL 2 RL, the axioms are ignored by the algorithm. Consequently,
Prl contains only the datalog rules corresponding to axioms (1)(5), and so
rl(Q1,T ,A) = rl(Q2,T ,A) = that is, rl is not complete for T . One can, how-
ever, simulate the relevant consequences of axioms (6) and (7) using the OWL
2 RL TBox R1 containing the following axioms:

GradSt  Student  GradSt(x)  Student(x)

(10)
ResAsst  PhDSt  Employee  ResAsst(x)  PhDSt(x)  Employee(x) (11)
Clearly, T |= R1; hence, extending T with R1 does not change the consequences
of T . The addition of axioms (10) and (11) to T , however, changes the behaviour
?

?

?
of algorithm rl; indeed, rl(Q1,T  R1,A) = rl(Q2,T  R1,A) = {a}. We show in
the following section that R1 is a repair of T for rl; that is, for an arbitrary UCQ
Q and ABox A, running algorithm rl on Q, T  R1, and A computes all ground
certain answers of Q w.r.t. T and A.
Next, consider the algorithm classify from Example 2. One can see that
classify(Q1,T ,A) = {a} but classify(Q2,T ,A) = that is, classify is also not
complete for T . Moreover, since classify is complete for OWL 2 RL, TBox R1 is
a repair of T for classify. Note, however, that the classification of T takes care
of axiom (10). Let R2 be the TBox containing only axiom (11). One can easily
see that rl(Q2,T  R2,A) = {a}; in fact, we show in the following section that
R2 is a repair of T for classify.
Finally, consider the algorithm rdfs form Example 2. In spite of the fact that
rdfs(Q1,T  R1,A) = {a}, TBox R1 is not a repair of T for rdfs: since (11) is not
an RDFS axiom, it is ignored by algorithm rdfs and so rdfs(Q2,T  R1,A) = .
In fact, even if we take R to be the maximal set of RDFS axioms that logically
follow from T (which is finite for RDFS), we can see that rdfs(Q2,T  R
,A) = ;
consequently, no repair of T for rdfs exists.


4 Repairing OWL 2 RL Reasoners

We now turn our attention to the problem of computing a repair for an OWL 2
DL TBox and a reasoning algorithm. In Section 4.1 we present a straightforward
way of repairing via so-called TBox rewritings, and in Section 4.2 we show how
to optimise repairs for reasoning algorithms that are complete for OWL 2 RL.

4.1 TBox Rewritings as Repairs
We next show that a repair of an OWL 2 TBox T for an algorithm ans can be
obtained by rewriting T into the fragment of OWL 2 DL that ans can handle.
Before proceeding, we first recapitulate the formal definition of a TBox rewriting.
Definition 4. Let T be an OWL 2 DL TBox and let L be a fragment of OWL
2 DL. An L-rewriting of T is a TBox T  in fragment L such that T |= T  and
the following conditions hold for each ABox A and each UCQ Q:
 T  A |=  implies T   A |= ; and
 certG(Q,T ,A) = certG(Q,T 
Note that, unlike T |L, an L-rewriting of T may not be a subset of T , and
may even be disjoint from T . Rewritings were introduced mainly to facilitate
reasoning in a complex ontology language by reasoning in a simpler language:
instead of reasoning directly with an OWL 2 DL TBox T , we compute a TBox
T  in a simpler fragment L such that, for an arbitrary UCQ Q and an arbitrary
ABox A, the ground certain answers of T and T  coincide; we can then answer
queries over T by applying to T  a reasoning algorithm complete for L.
Example 4. Let T be the TBox consisting of axioms (1)(7). The OWL 2 RL
TBox T  consisting of axioms (1)(5) and (10)(11) is an OWL 2 RL rewriting

,A).

G. Stoilos et al.

, A) = .

of T . Thus, instead of answering a query over T using an OWL 2 DL reasoner,
we can answer the query over T  using an OWL 2 RL reasoner.
Note, however, that no RDFS rewriting of T exists: even if we take T  to be
the maximal set of RDFS axioms that logically follow from T , for Q2 and A as
defined in Example 3 we have certG(Q2,T 

The following proposition, the proof of which is straightforward, establishes
the connection between TBox rewritings and repairs. According to this propo-
sition, the TBox T  in Example 4 is a repair of T for algorithm rl.
Proposition 2. Let T be an OWL 2 TBox, let L be a fragment of OWL 2, and
let ans be a reasoning algorithm complete for L. If R is an L-rewriting of T ,
then R is a repair of T for ans.
Although this simple result provides us with a straightforward way of repairing
certain OWL 2 DL ontologies, as we discuss in the following section, repairs obtained in this way can be unnecessarily large. Therefore, we develop a technique
that optimises a repair for the reasoner at hand.

4.2 Repairing a Class of Algorithms Complete for OWL 2 RL

Reasoners based on RDF triple stores and databases, such as Jena, OWLim,
Oracles Semantic Datastore and DLE-Jena, are typically complete at least for
OWL 2 RL. Therefore, in the rest of this section we focus on repairing an OWL
2 DL TBox T for a reasoner ans that is complete for OWL 2 RL.
By Proposition 2, we can solve the aforementioned problem by computing
an OWL 2 RL rewriting of T . Depending on the language that T is expressed
in, systems such as REQUIEM [13] and KAON2 [5] can compute a (possibly
disjunctive) datalog rewriting; now whenever the rewriting is a datalog program,
each datalog rule in the rewriting can always be rolled-up into an OWL 2
RL axiom. Therefore, in order to simplify the presentation, we consider such
rewritings to be OWL 2 RL TBoxes rather than datalog programs.
Note, however, that, if an OWL 2 RL rewriting T  of T exists, it must capture
all OWL 2 RL consequences of T and can thus be very large; in fact, the size
of T  can in the worst case even be exponential in the size of T . Thus, to make
our approach practicable, it is desirable to reduce the size of a repair as much
as possible. This can be achieved in (at least) two ways.
First, rewritings often contain redundant axioms, so we can try to minimise
themthat is, we can identify a smallest subset of T  that is also a rewriting of T .
While minimisation can be computationally very expensive, as a bare minimum
we can eliminate from T  each axiom  for which T |rl |=  holds; this can be
straightforwardly checked using a sound and complete OWL 2 DL reasoner. A
repair obtained in this way does not contain axioms whose consequences can be
derived from T |rl by OWL 2 RL complete reasoning algorithms.

Second, we can exploit the fact that, while a reasoning algorithm might be
complete only for OWL 2 RL, the algorithm may actually take into account
some consequences of the axioms in T \ T |rl. Consider again algorithm classify
?

?

?
from Example 2 and a TBox consisting of axioms (1)(7). As shown in Example
4, a rewriting of this TBox consists of axioms (1)(5) and (10)(11); however, as
discussed in Example 3, only axiom (11) is needed to repair the TBox for classify.
Based on this observation, in the rest of this section we show how to reduce the
size of a repair beyond what is possible via minimisation of a rewriting.

In order to achieve this goal, we first introduce the notion of a datalogreproducible algorithm, which captures the class of reasoners to which our approach is applicable. This notion was inspired by an observation that many state
of the art reasoners that can handle (a fragment of) OWL 2 DL are based on
deductive database technologies: given a UCQ Q, a TBox T , and an ABox A,
these reasoners first saturate A by adding all assertions that are entailed by
T  A ; next, they answer Q by simply evaluating it over the saturated ABox.
The ABox saturation process depends only on T and A, and it can be characterised at an abstract level as evaluating over A a datalog program that depends
only on T . This intuition is formalised by the following definition.
Definition 5. A reasoning algorithm ans is datalog-reproducible if, for each
OWL 2 DL TBox T , a datalog program PT exists such that the following holds:
 for each ABox A and each UCQ Q,

 ans(,T ,A) = t if and only if PT  A |= , and
 ans(,T ,A) = f implies ans(Q,T ,A) = cert(Q,PT ,A); and
we have PT T  |= PT .

 algorithm ans is monotonicthat is, for all OWL 2 DL TBoxes T and T ,

If program PT contains predicates or individuals that do not occur in T , these
are considered to be private to ans and are not accessible elsewhere (e.g., in
queries, TBoxes, and ABoxes).

Note that a datalog-reproducible reasoning algorithm does not need to construct PT ; what matters is that some datalog program PT exists that characterises the behaviour of the algorithm.
Example 5. Algorithms rdf, rdfs and rl from Example 2 explicitly construct a
datalog program PT , so they are clearly datalog-reproducible. Note, however,
that algorithm classify is also datalog-reproducible even through it does not
directly construct a datalog program: the algorithms behaviour can be characterised by a program PT containing all rules corresponding to the axioms in T |rl
extended with the rule A(x)  B(x) for each pair of classes A and B occurring
in T such that T |= A  B.

Note also that, even if a reasoner uses a particular datalog program as part
of its implementation, the actual rules of the program may not be available to
the users of the reasoner. For example, the rules used for reasoning by Oracles
Semantic Data Store are not publicly available; however, the reasoner can still
be considered datalog-reproducible as its external behaviour can be captured
using a datalog program. As we show next, our approach does not need to know
the actual rules in order to repair an ontology: it suffices to know that a suitable
datalog program exists.

G. Stoilos et al.

As we discuss next, not all reasoning algorithms are datalog-reproducible.

Example 6. Reasoning algorithms based on query rewriting (e.g., algorithms
underpinning the QuONTO reasoner) are not datalog-reproducible: although
they answer queries by first constructing a datalog program, this program depends on both on the query and the TBox, and not on the TBox alone.

As another example, consider a reasoning algorithm that behaves as algorithm
rdf from Example 2, but that first removes from the input ABox each assertion
involving an individual whose IRI belongs to a certain predefined namespace.
(This could be done, e.g., for efficiency or trust reasons.) Fact removal cannot
be represented using a monotonic theory, so this algorithm is clearly not datalog-

reproducible.
We now show how to compute a repair of a TBox T for an algorithm ans that
is datalog-reproducible and complete for OWL 2 RL. Intuitively, the behaviour
of ans on T is characterised by a datalog program PT so, given an OWL 2 RL
rewriting T  of T , we can safely disregard each axiom in T  that is logically
entailed by PT . In other words, a repair of T for ans needs to contain only
the essential axioms of T that is, the axioms that are not entailed by PT .
Furthermore, the rewriting T  is an OWL 2 RL TBox, so each axiom   T 
corresponds to an equivalent datalog rule (); but then, by Proposition 1 we can
construct from () an ABox A and a query Q such that ans(Q,T ,A) = t if
and only if PT |= . A repair R of T for ans can thus be obtained as a TBox that
contains each axiom   T  such that ans(Q,T ,A) = f. Since ans is complete
for OWL 2 RL and R is an OWL 2 RL TBox, extending T with R will allow
ans to recover the missing consequences of T and thus become complete.
Definition 6. Let T be an OWL 2 TBox, let T  be an OWL 2 RL rewriting of T ,
let ans be a datalog-reproducible reasoning algorithm, and let  be a substitution
that maps each variable in the signature to a fresh individual. The essential
subset of T  for ans is the TBox R that contains each axiom   T  satisfying
the following conditions, where r = () and Ar
1. head(r) =  and ans(,T ,Ar
2. head(r) = H with H =  and ans({(H)  Q},T ,Ar

 = {(B) | B  body(r)}:2

) = f, for Q a propo-

) = f; or

sitional query predicate.

 = {GradSt(a)} and Q = {St(a)  Q} we have rl(Q,T ,Ar

Example 7. Let T contain axioms (1)(7), and let T  be a rewriting of T that
contains axioms (1)(5) and (10)(11).
The essential subset of T  for algorithm rl from Example 2 contains (10) and
(11). For example, let  be axiom (10), so () = r = GradSt(x)  Student(x).
Then for Ar
) = f, so
 must be included into the essential subset of T . Analogous reasoning applies
to axiom (11).
In contrast, the essential subset of T  for algorithm classify contains only (11)

since, for Q and Ar
) = t.
2 Note that () is the translation of  into a datalog rule from Section 2.

 as defined above, we have classify(Q,T ,Ar
?

?

?
We next present the main result of this paper, which shows that essential

subsets can be used as repairs.
Theorem 8. Let T be an OWL 2 TBox, let T  be an OWL 2 RL rewriting of
T , let ans be a datalog-reproducible algorithm complete for OWL 2 RL, and let
R be the essential subset of T  for ans. Then, R is a repair of T for ans.
Proof. Assume that ans is complete for OWL 2 RL and let  be a substitution
that maps each variable in the signature to a fresh individual.

We first show that PR |= R. To this end, let R1 be the subset of all rules
r  R such that PR  Ar
|= , and let R2 = R \ R1. Furthermore, let R1 be
the set of rules obtained by replacing the head atom in each rule in R1 with .
Since clearly R1  R2 |= R, it suffices to show that PR |= R1  R2. So, let r be
an arbitrary rule in R1  R2.
 Assume that r  R1. Then, by the definition of R1, we have PR  Ar
 Assume that r  R2. Then, PR  Ar

|= .
But then, since head(r) = , by Proposition 1 we have PR |= r, as required.
|= . By the definition of datalogreproducible algorithms, then ans(,R,Ar
) = f. Furthermore, we clearly
have R  Ar
) = t for
Q = {(H)  Q}. But then, since ans is complete for OWL 2 RL and R
is an OWL 2 RL TBox, we have that certG(Q,R,Ar
) for
each UCQ Q. Therefore, ans(Q,R,Ar
) = t, so by the definition of datalogreproducible algorithms we also have PR Ar
|= (H). But then, by Proposition 1, we have PR |= r, as required.

|= (H), where H = head(r). Hence, certG(Q,R,Ar

)  ans(Q,R,Ar













) = t and hence PT  Ar

ans(,T ,Ar
have PT |= r.
ans({(H)  Q},T ,Ar

We next show that, since R is an essential subset of T  for ans, we have
PT |= T  \ R. To this end, consider an arbitrary rule in r  T  \ R. We have
the following possibilities:
 head(r) = . In this case, by the definition of essential subset we have that
|= . But then, by Proposition 1 we
 head(r) = H where H = . By the definition of essential subset, we have
) = t. But then, by Proposition 1 we have PT |= r.
We now show that PT |= T  \ R and PR |= R imply PT R |= T . Since we
have PT |= T  \ R, we also clearly have PT  R |= T ; since PR |= R, we have
PT  PR |= T  as well. Since ans satisfies the monotonicity property from Definition 5, we have PT R |= PT and PT R |= PR; thus, PT R |= PT  PR. But
then, PT R |= T , as required.

We finally use the fact that PT R |= T  to show that the following properties

hold for each UCQ Q and each ABox A.
1. T  A |=  implies ans(,T  R,A) = t; and
2. ans(,T  R,A) = f implies then certG(Q,T ,A)  ans(Q,T  R,A).

G. Stoilos et al.

(Property 1). Assume that T  A |= . Since T  is an OWL 2 RL rewriting of T ,
we have T   A |= . But then, since PT R |= T , we also have PT R  A |= ,
as required.
(Property 2). Assume that ans(,T  R,A) = f and consider an arbitrary tuple
a  certG(Q,T ,A). Since T  is an OWL 2 RL rewriting of T , then we have
a  certG(Q,T 
,A), so T   A  QG  AG |= Q(a). But then, since PT R |= T ,
we also have that PT R  A  QG  AG |= Q(a). Furthermore, since PT R is
a datalog program, we have that PT R  A  Q |= Q(a) and hence we have
a  cert(Q,PT R,A); consequently, a  ans(Q,T  R,A), as required.

We finally show that R is a repair of T for ans. Since T  is an OWL 2
RL rewriting of T , we have T |= T ; since R  T , we also have T |= R. This

together with Properties 1 and 2 implies our claim.

Theorem 8 and the observations made in Example 7 thus confirm our claims
from Example 3: axioms (10) and (11) constitute a repair of T for algorithm rl,
and axiom (11) alone constitutes a repair for algorithm classify.

5 Evaluation

We developed a prototype tool for computing repairs. Our implementation uses
the system REQUIEM [13] for the computation of TBox rewritings. We evaluated our approach using the following two well-known ontologies.

First, we used the well-known Lehigh University Benchmark (LUBM) [4]an
ontology extensively used for evaluating performance of ontology-based systems.
We used LUBMs generator of large datasets and the supplied 14 test queries.
Second, we used a small subset of the GALEN ontology [14]a complex
medical ontology. We used a subset of GALEN because REQUIEM was unable
to handle the full version of GALEN. Since we are not aware of a large ABox
or a data generator for GALEN, we created synthetic data by extending the
techniques for ABox generation from [16,15]; we thus obtained ABoxes with
(approximately) 2000, 4000, 8000, 16000 and 32000 assertions. Furthermore, we
tested the systems using four atomic queries presented in [15].

and DLE-Jena v2.0.5

We evaluated the following reasoning systems: OWLim v2.9.1,3 Jena v2.6.34
For each test ontology T and each reasoning system ans mentioned above, we

performed the following tasks.
1. We computed an OWL 2 RL rewriting Trew of the input TBox T and recorded
the time needed to complete this step.
2. As mentioned in Section 4.2, Trew can contain many axioms, so we minimised
Trew as follows. First, we eliminated each axiom  such that T |rl |= . Second,

http://www.ontotext.com/owlim/
http://jena.sourceforge.net/
http://lpis.csd.auth.gr/systems/DLEJena/
?

?

?
Table 1. Repairing the LUBM ontology for OWLim, Jena and DLE-Jena

Trew Tmin Rowlim Rjena Rdle-jena
331 7
Time to compute ontology (in s) 4.7 7.9

Ontology size

Ontology

3.3

6.3
?

?

?
for all pairs of distinct remaining axioms 1 and 2, we eliminated 2 if
T |rl  {1} |= 2. Let Tmin be the resulting set of axioms; clearly, T |rl  Tmin
is still a rewriting of T . Note that Tmin can depend on the order in which we
select 1 and 2 in the second step; however, we did not notice significant
variance in our tests. We conducted all entailment checks using HermiTa
sound and complete OWL 2 DL reasonerand we recorded the time needed
to complete this step.
3. We extracted from Tmin the essential subset R for ans as described in Definition 6, and we recorded the time needed to complete this step. By Theorem
8, R is a repair of T for ans.
4. To estimate the effect that repairing T has on the performance of ans, we
proceeded as follows. We first applied ans to T and each corresponding data
set and query, and we recorded the load time, the query evaluation time, and
the number of certain answers returned. Next, we repeated the experiment
by applying ans to T  R. The results obtained using T  R are compared
against Pelleta sound and complete OWL 2 DL reasoner.

The results of repairing LUBM are shown in Table 1. Although the initial rewriting is quite large, our procedure computes repairs for OWLim and Jena that
consist of only the following three axioms:

GradStudent  Student Director  Employee ResearchAssist  Employee

The repair for DLE-Jena is emptythat is, the system is already complete for
LUBM. This is due to the fact that the repair for OWLim and Jena consists only
of simple subclass axioms, all of which are derived by DLE-Jenas preprocessing
phase (DLE-Jena is similar to the classify algorithm from Example 2). In all
cases computing the repair took less than 15 seconds.
For OWLim and Jena, Tmin\R is non-empty, which suggests that these systems
can process more than just OWL 2 RL. We observed that, for many axioms
in Tmin \ R of the form A  B, TBox T contains an axiom A  B  R.C. The
latter is not an OWL 2 RL axiom, so T |rl |= A  B and A  B is not removed
from Tmin. The OWL 2 RL/RDF rules from [11], however, correctly handle the
conjunction in the superclass positionthat is, given an assertion A(a), they
derive B(a) and R.C(a). This effectively allows OWLim and Jena to use the
A  B part of A  B  R.C, so the repair does not need to contain A  B.
Thus, tailoring the repair to a particular reasoner can exploit the reasoning
capabilities of the reasoner at hand and thus produce smaller repairs.

We observed no measurable performance changes for OWLim and Jena after
repairing, which is not surprising since the repairs contained only a few simple

G. Stoilos et al.

Table 2. Repairing GALEN for OWLim, Jena and DLE-Jena
Trew Tmin Rowlim Rjena Rdle-jena
1666 291

Time to compute ontology (in s) 380 126 426 1586

Ontology size

Ontology

-

Table 3. Number of certain answers for GALEN (without repairs)

Queries J D O P

J D O P O P
?

?

?
Q1
Q2
Q3
Q4

73 65 65 92 226 206 206 280 501 672 1281 1587 1379 1727
49 43 43 72 158 135 135 217 368 532 1008 1353 1148 1502
81 74 74 97 234 212 212 283 515 678 1301 1588 1355 1714
112 226 78 260 334 656 232 756 547 1687 1272 3463 1445 3706

J=Jena, D=DLE-Jena, O=OWLim, P=Pellet

axioms. Moreover, both OWLim and Jena are complete for the LUBM dataset
already when using the original TBox, so no change in the number of answers
produced was observed either.

The results of repairing GALEN are shown in Table 2. Again, the repair is
quite small, despite the fact that GALEN heavily uses features outside OWL 2
RL such as existential quantification. The repair, however, is more complex than
in the case of LUBM, containing axioms such as subsumptions between complex
class expressions with several nested existential quantifiers. As with LUBM, the
repair for DLE-Jena is smaller than the repairs for OWLim and Jena. Note,
however, that DLE-Jena ran out of memory while computing the repair from
Tmin; thus, since DLE-Jena is more complete than Jena, we produced Rdle-jena
by applying Definition 6 to Rjena.

Table 3 shows the number of certain answers computed by each system for
each dataset, using the original GALEN TBox; please note that we could only
load datasets 2000 and 4000 into Jena and DLE-Jena. As expected, all systems
returned fewer answers than Pellet. Using the repaired TBoxes, however, all
systems returned the same number of certain answers as Pellet. Thus, repairing
an ontology can significantly improve the quality of answers that a reasoner
produces for a given ontology.

Table 4 shows the loading times for both the original and the repaired ontolo-
gies. As one can see, repairing the ontology leads to an increase in loading times
of about 20% on average. The times for the repaired ontology, however, are of
the same order of magnitude as the original times; hence, the increase in loading
time may be acceptable given that the systems then return complete answers.
Furthermore, OWLim is much faster than Pellet even on the repaired ontology,
which suggests that using an incomplete reasoner with a repaired ontology might
be more appropriate in practice than using a complete reasoner.

Table 5 shows the query answering times for the repaired ontology. Since all
systems perform reasoning during loading (i.e., they saturate the input ABox),
repairing the ontology produced no noticeable difference on the query answering
?

?

?
Table 4. Loading times for original and repaired TBoxes (in ms)

OWLim

Pellet

Jena

DLE-Jena
?

?

?
T  R 1768

25524 117524
T  R 34000 139839
23198 138075
T  R 24844 139129

4000 8000 16000 32000
2328 3611 6000 6871
2807 4279 7815 8696
4623 9596 11275 12086

-
-
-
-

-
-
-
-

-
-
-
-

Table 5. Query answering times for repaired GALEN (in ms)

Queries J D O P J D O P O P O P O P

15 156 39 734 5 155 46 1765 41 5503 53 7460 50 8122
6 2635 15 4271 17 4620
?

?

?
4 2711 100 6473 18 10188 20 11866

1 425 5 11 3 1226
1 926 8
1 37 21 21 11 47

55 127
J=Jena, D=DLE-Jena, O=OWLim, P=Pellet

42 136
?

?

?
Q1
Q2
Q3
Q4

times. Note that all systems are much faster than Pellet, which again suggests
that using an incomplete reasoner with a repaired ontology might offer significant
advantages compared to using a complete reasoner.

6 Conclusions

In this paper, we studied the problem of repairing an ontology for a given incomplete reasoner in a way that guarantees completeness. Our repairs guarantee
completeness w.r.t. ground certain answers independently of data and queries:
once an ontology has been repaired for a given system, the system will, for any
given query and data set, compute all ground certain answers that follow from
the original ontology. Our approach tries to limit the size of the repair as much
as possible. Our experiments suggest that repairs may indeed be very small,
and that their effect on system performance may be negligible. This allows application designers to use highly scalable incomplete reasoners, but with the
guarantee that they produce the same answers as provably complete reasoners,
thus having the the best of both worlds.

We leave the extension of our techniques to more expressive DLs, as well as

a more extensive evaluation, for future work.

Acknowledgments. Research supported by project SEALS (FP7-ICT-238975).
B. Cuenca Grau is supported by a Royal Society University Research Fellowship.

G. Stoilos et al.
