Local Closed World Semantics:

Grounded Circumscription for OWL

Kunal Sengupta, Adila Alfa Krisnadhi, and Pascal Hitzler

Wright State University, Dayton OH 45435, USA

{kunal,adila,pascal}@knoesis.org

Abstract. We present a new approach to adding closed world reasoning
to the Web Ontology Language OWL. It transcends previous work on
circumscriptive description logics which had the drawback of yielding an
undecidable logic unless severe restrictions were imposed. In particular,
it was not possible, in general, to apply local closure to roles.
In this paper, we provide a new approach, called grounded circum-
scription, which is applicable to SROIQ and other description logics
around OWL without these restrictions. We show that the resulting language is decidable, and we derive an upper complexity bound. We also
provide a decision procedure in the form of a tableaux algorithm.

1 Introduction

The semantics of the Web Ontology Language OWL [8] (which is based on the
description logic SROIQ [9]) adheres to the Open World Assumption (OWA):
statements which are not logical consequences of a given knowledge base are not
necessarily considered false. The OWA is a reasonable assumption to make in the
World Wide Web context (and thus for Semantic Web applications). However,
situations naturally arise where it would be preferable to use the Closed World
Assumption (CWA), that is, statements which are not logical consequences of a
given knowledge base are considered false. Such situations include, for example,
when data is being retrieved from a database, or when data can be considered
complete with respect to the application at hand (see, e.g., [6,23]).

As a consequence, efforts have been made to combine OWA and CWA modeling for the Semantic Web, and knowledge representation languages which
have both OWA and CWA modeling features are said to adhere to the Local
Closed World Assumption (LCWA). Most of these combinations are derived
from non-monotonic logics which have been studied in logic programming [10]
or on first-order predicate logic [19,20,24]. Furthermore, many of them are of
a hybrid nature, meaning that they achieve the LCWA by combining, e.g., description logics with (logic programming) rules. Please see [14, Section 4].

On the other hand, there are not that many approaches which provide a
seamless (non-hybrid) integration of OWA and CWA, and each of them has its
drawbacks. This is despite the fact that the modeling task, from the perspective
of the application developer, seems rather simple: Users would want to specify,

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 617632, 2011.
c Springer-Verlag Berlin Heidelberg 2011

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

simply, that individuals in the extension of a predicate should be exactly those
which are necessarily required to be in it, i.e., extensions should be minimized.
Thus, what is needed for applications is a simple, intuitive approach to closed
world modeling which caters for the above intuition, and is also sound, complete
and computationally feasible.

Among the primary approaches to non-monotonic reasoning, there is one approach which employs the minimization idea in a very straightforward and intuitively simple manner, namely circumscription [19]. However, a naive transfer of
the circumscription approach to description logics, which was done in [2,3,6,7],
appears to have three primary drawbacks.
1. The approach is undedicable for expressive description logics (e.g., for the
description logic SROIQ) unless awkward restrictions are put in place. More
precisely, it is not possible to have non-empty TBoxes plus minimization of
roles if decidability is to be retained.

2. Extensions of minimized predicates can still contain elements which are not
named individuals (or pairs of such, for roles) in the knowledge base, which
is not intuitive for modeling (see also [6]).
3. Complexity of the approach is very high.
The undecidability issue (point 1) hinges, in a sense, also on point 2 above. In
this paper, we provide a modified approach to circumscription for description
logics, which we call grounded circumscription, that remedies both points 1 and
2.1 Our idea is simple yet effective: we modify the circumscription approach
from [2,3,6,7] by adding the additional requirement that extensions of minimized
predicates may only contain named individuals (or pairs of such, for roles). In a
sense, this can be understood as porting a desirable feature from (hybrid) MNKF
description logics [5,12,13,21] to the circumscription approach. In another (but
related) sense, it can also be understood as employing the idea of DL-safety [22],
respectively of DL-safe variables [17] or nominal schemas [4,15,16].

The paper is a substantial extension of the workshop paper [14] and will be
structured as follows. In Section 2, we introduce the semantics of grounded cir-
cumscription. In Section 3, we show that the resulting language is decidable.
Next, we provide a tableaux calculus in Section 4 to reason with grounded cir-
cumscription. We conclude with a discussion of further work in Section 5.

2 Local Closed World Reasoning with Grounded

Circumscription

In this section we describe LCW reasoning with grounded circumscription (GC)
and also revisit the syntax and semantics of the Description Logic ALC and extend it with GC. Some results in this paper also apply to many other description
logics besides ALC, and we will point this out in each case.

1 We are not yet addressing the complexity issue; this will be done in future work.
?

?

?
2.1 The Description Logic ALC

Let NC , NR and NI be countably infinite sets of concept names, role names and
individual names, respectively. The set of ALC concepts is the smallest set that is
created using the following grammar where A  NC denotes an atomic concept,
R  NR is a role name and C, D are concepts.

C   |  | A | C | C  D | C  D | R.C | R.C

The semantics is defined in terms of interpretations I = (I, .

An ALC TBox is a finite set of axioms of the form C  D, called general
concept inclusion (GCI) axioms, where C and D are concepts. An ALC ABox is
a finite set of axioms of the form C(a) and R(a, b), which are called concept and
role assertion axioms, where C is a concept, R is a role and a, b are individual
names. An ALC knowledge base is a union of an ALC ABox and an ALC TBox
I), where I is
I is an interpretation
a non-empty set called the domain of interpretation and .
function which maps each individual name to an element of the domain I and
interprets concepts and roles as follows.
I  

(C1  C2)

I  

(C1  C2)

=  , A

I  
 C

2 ,
I}
implies y  C

, I

= 
I \ C

= 
,
I | (x, y)  r
= {x  
I | there is some y with (x, y)  r
= {x  

I
(C)

( r .C)

( r .C)

An interpretation I satisfies (is a model of) a GCI C  D if C
I, a concept
I. We say I
assertion C(a) if a
, b
satisfies (is a model of) a knowledge base K if it satisfies every axiom in K. K
is satisfiable if such a model I exists.

I, a role assertion R(a, b) if (a

I}
I  D
I)  R

and y  C

, R

= C

I  C

= C

 C
?

?

?
The negation normal form of a concept C, denoted by NNF(C), is obtained
by pushing the negation symbols inward, as usual, such that negation appears
only in front of atomic concepts, e.g., NNF((C  D)) = C  D.
Throughout the paper, we will often talk about L knowledge bases (L-KBs
for short), where L is some decidable description logic. When we do this, then
this indicates that the result does not only hold for L being ALC, but rather for
many decidable description logics around OWL. We will point out restrictions
in each case. For general background on various description logics, as well as for
established names (like ALC) for different description logics, see [1,9].

Besides widely known DL constructors, we will also make use of Boolean role
constructors (in limited form), which can be added to many description logics
without loss of decidability or even of complexity [25,28]. We also make limited
use of the concept product, written C  D with C, D concepts in L, which allows
a role to be constructed from the Cartesian product of two concepts, and which
can actually be eliminated in the presence of Boolean role constructors [16,26].
In terms of interpretations I, concept products are characterized by the equation
(C  D)I = {(x, y) | x  C

, y  D

I}.

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

2.2 Grounded Circumscription

We now describe a very simple way for ontology engineers to model local closed
world aspects in their ontologies: simply use a description logic (DL) knowledge
base (KB) as usual, and augment it with meta-information which states that
some predicates (concept names or role names) are closed. Semantically, those
predicates are considered minimized, i.e., their extensions contain only what is
absolutely required, and furthermore only contain known (or named) individuals,
i.e., individuals which are explicitly mentioned in the KB. In the case of concept
names, the idea of restricting their extensions only to known individuals is similar
to the notion of nominal schema [4,16] (and thus, DL-safe rules [17,22]) and
also the notion of DBox [27], while the minimization idea is borrowed from
circumscription [19], one of the primary approaches to non-monotonic reasoning.
In the earlier efforts to carry over circumscription to DLs [2,3,6,7], circumscription is realized by the notion of circumscription pattern. A circumscription
pattern consists of three disjoint sets of predicates (i.e., concept names and role
names) which are called minimized, fixed and varying predicates, and a preference relation on interpretations.2 The preference relation allows us to pick
minimal models as the preferred models with respect to set inclusion of the
extensions of the minimized predicates.

Our formalism here is inspired by one of the approaches described by Makinson in [18], namely restricting the set of valuations to get more logical consequences than what we can get as classical consequences. Intuitively, this approach
is a simpler version of the circumscription formalism for DLs as presented in [3,7]
in the sense that we restrict our attention only to models in which the extension of minimized predicates may only contain known individuals from the KB.
Furthermore, the predicates (concept names and role names) in KB are partitioned into two disjoint sets of minimized and non-minimized predicates, i.e., no
predicate is considered fixed.3 The non-minimized predicates would be viewed
as varying in the more general circumscription formalism mentioned above.
The non-monotonic feature of the formalism is given by restricting models
of an L-KB such that the extension of closed predicates may only contain individuals (or pairs of them) which are explicitly occurring in the KB, plus a
minimization of the extensions of these predicates. We define a function Ind that
maps each L-KB to the set of individual names it contains, i.e., given an L-KB
K, Ind(K) = {b  NI | b occurs in K}. Among all possible models of K that are
obtained by the aforementioned restriction to Ind(K), we then select a model
that is minimal w.r.t. concept inclusion or role inclusion, in accordance with the
following definition.

2 There is also a notion of prioritization which we will not use, mainly because we
are not convinced yet that it is a desirable modeling feature for local closed world
reasoning for the Semantic Web.

3 Fixed predicates can be simulated in the original circumscriptive DL approach if
negation is available, i.e., for fixed concept names, concept negation is required,
while for fixed role names, role negation is required. The latter can be added to
expressive DLs without jeopardizing decidability [16,28].
?

?

?
Definition 1. A GC-L-KB is a pair (K, M) where K is an L-KB and M 
NCNr. For every concept name and role name W  M, we say that W is closed
with respect to K. For any two models I and J of K, we furthermore say that
I is smaller than (or preferred over) J w.r.t. M, written I M J , iff all of the
J for
following hold: (i) 
every W  M; and (iii) there exists a W  M such that W

J for every a  NI; (ii) W
I  W
I  W

J and a

I = 

I = a

The following notion will be helpful.

Definition 2 (grounded model). Given a GC-L-KB (K, M), a model I of
K is called a grounded model w.r.t M if all of the following hold:
(1) C
(2) R

I | b  Ind(K)} for each concept C  M; and
I) | a, b  Ind(K)} for each role R  M

I  {b
I  {(a

, b

We now define models and logical consequence of GC-L-KBs as follows.

Definition 3. Let (K, M) be a GC-L-KB. An interpretation I is a GC-model
of (K, M) if it is a grounded model of K w.r.t. M and I is minimal w.r.t. M, i.e.,
there is no model J of K with J M I. A statement (GCI, concept assertion,
or role assertion)  is a logical consequence (a GC-inference) of (K, M) if every
GC-model of (K, M) satisfies . Finally, a GC-L-KB is said to be GC-satisfiable
if it has a GC-model.

Note that every GC-model is also a grounded model. Moreover, in comparison
with the more general circumscription formalism for DLs as presented in [3,7],
every GC-model of a KB is also a circumscriptive model,4 hence every circumscriptive inference is also a valid GC-inference.

To give an example, consider the knowledge base K consisting of the axioms

hasAuthor(paper1, author1)
hasAuthor(paper2, author3)

hasAuthor(paper1, author2)
  hasAuthor.Author

Consider the following (ABox) statements: hasAuthor(paper1, author3) and
(2 hasAuthor.Author)(paper1).5 Neither of them is a logical consequence of
K under classical DL semantics. However, if we assume that we have complete
information on authorship relevant to the application under consideration, then
it would be reasonable to close parts of the knowledge base in the sense of
the LCWA. In the original approach to circumscriptive DLs, we could close the
concept name Author, but to no avail. But if we close hasAuthor, we obtain
(2 hasAuthor.Author)(paper1) as a logical consequence. In addition, if we
adopt the Unique Name Assumption (UNA), hasAuthor(paper1, author3) is
also a logical consequence of K. Even without UNA, we can still obtain this
as a logical consequence if we add the following axioms to K, which essentially

4 This can be seen, e.g., by a straightforward proof by contradiction.
and y  CI}|  n};
5 The semantics is (n R.C)
this qualified number restriction is not part of ALC, though it makes a very good
example without depending on the UNA.

I | |{y | (x, y)  RI

= {x  

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

forces the UNA:6 A1(author1); A2(author2); A3(author3); Ai  Aj   for all
i = j. With regard to this example, note that the closure of roles in the original
circumscriptive DL approach leads to undecidability [3]. The GC-semantics, in
contrast, is decidable even under role closure (see Section 3 below), and also
yields the desired inferences.

3 Decidability of Grounded Circumscription

As noted earlier, circumscription in many expressive DLs is undecidable [3].
Undecidability even extends to the basic DL ALC when non-empty TBoxes are
considered and roles are allowed as minimized predicates. Such a bleak outlook
would greatly discourage useful application of circumscription, despite the fact
that there is a clear need of such a formalism to model LCWA.

Our formalism aims to fill this gap by offering a simpler approach to circumscription in DLs that is decidable provided that the underlying DL is also
decidable. The decidability result is obtained due to the imposed restriction of
minimized predicates to known individuals in the KB as specified in Definition 3.
Let L be any standard DL. We consider the reasoning task of GC-KB satisfia-
bility: given a GC-L-KB (K, M), does (K, M) have a GC-model? and show in
the following that this is decidable.
Assume that L is any DL featuring nominals, concept disjunction, concept
products, role hierarchies and role disjunctions. We show that GC-KB satisfiability in L is decidable if satisfiability in L is decidable.
Let (K, M) be a GC-L-KB. We assume that M = MA  Mr where MA =
{A1, . . . , An} is the set of minimized concept names and Mr = {r1, . . . , rm} is
the set of minimized role names. Now define a family of (n + m)-tuples as

G(K,M) = {(X1, . . . , Xn, Y1, . . . , Ym) | Xi  Ind(K), Yj  Ind(K)  Ind(K)}

with 1  i  n, 1  j  m. Note that there are
?

?

?
|Ind(K)|

n 

|Ind(K)|2

m

= 2n|Ind(K)|+m|Ind(K)|2

(1)

of such tuples; in particular note that G(K,M) is a finite set.
Now, given (K, M) and some G = (X1, . . . , Xn, Y1, . . . , Ym)  G(K,M), let KG
be the L-KB consisting of all axioms in K together with all of the following
axioms, where the Ai and rj are all the predicates in Mnote that we require
role disjunction and concept products for this.
?

?

?
{a}
({a}  {b})

Ai 
rj 

for every a  Xi and i = 1, . . . , n

for every pair (a, b)  Yj and j = 1, . . . , m

Then the following result clearly holds.
6 The UNA can be enforced in an ALC KB by adding ABox statements Ai(ai), where
ai are all individuals and Ai are new concept names, to the knowledge base, together
with all disjointness axioms of the form Ai  Aj   for all i = j.
?

?

?
Lemma 1. Let (K, M) be a GC-L-KB. If K has a grounded model I w.r.t.
M, then there exists G  G(K,M) such that KG has a (classical) model J which
coincides with I on all minimized predicates. Likewise, if there exists G  G(K,M)
such that KG has a (classical) model J , then K has a grounded model I which
coincides with J on all minimized predicates.

Now consider the set

G
(K,M) = {G  G(K,M) | KG has a (classical) model},

and note that this set is finite and computable in finite time since G(K,M) is
finite and L is decidable. Furthermore, consider G
(K,M) to be ordered by the
pointwise ordering  induced by . Note that the pointwise ordering of the
finite set G
Lemma 2. Let (K, M) be a GC-L-KB and let

(K,M) is also computable in finite time.

(K,M) = {G  G
G

(K,M)

| G is minimal in (G

(K,M),)}.
(K,M) is non-empty.

Then (K, M) has a GC-model if and only if G
Proof. This follows immediately from Lemma 1 together with the following ob-
servation: Whenever K has two grounded models I and J such that I is smaller
than J , then there exist GI, GJ  G
(K,M) with GI  GJ such that KGI and
KGJ have (classical) models I and J , respectively, which coincide with I,
respectively, J , on the minimized predicates.
Theorem 1. GC-KB-satisfiability is decidable.
Proof. This follows from Lemma 2 since the set G
(K,M), for any given GC-KB
(K, M), can be computed in finite time, i.e., it can be decided in finite time
whether G
Some remarks on complexity are as follows. Assume that the problem of deciding
KB satisfiability in L is in the complexity class C. Observe from equation (1) that
there are exponentially many possible choices of the (n + m)-tuples in G(K,M)
(in the size of the input knowledge base). Computation of G
(K,M) is thus in
ExpC, and subsequent computation of G
(K,M) is also in Exp. We thus obtain
the following upper bound.
Proposition 1. The problem of finding a GC-model (if one exists) of a given
GC-L-KB is in ExpC, where C is the complexity class of L. Likewise, GC-L-KB
satisfiability is in ExpC.

(K,M) is empty.

4 Algorithms for Grounded Circumscriptive Reasoning

We now present algorithms for reasoning with grounded circumscription. We
start with a tableaux algorithm to decide knowledge base GC-satisfiability and
then discuss how to extend it to other reasoning tasks. For simplicity of presen-
tation, we only consider GC-KB-satisfiability in ALC, but the procedure should
be adaptable to other DLs. Inspiration for the algorithm comes from [7,11].

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

4.1 Decision Procedure for GC-Satisfiability in ALC
The algorithm is a tableaux procedure as usual where the expansion rules are
defined to be compatible with the semantics of the language, and for easier
reference, we call the resulting algorithm Tableau1. It starts with an initial graph
Fi constructed using the ABox of a given GC-ALC-KB (K, M), such that all
known individuals are represented as nodes along with their labels that consist of
the concepts that contain them in the ABox. Additionally, links are added for all
role assertions using labels that consist of the roles in the ABox assertion axioms.
We call this set of nodes and labels the initial graph. The creation of the initial
graph Fi is described in terms of the following steps called the initialization
process:

 create a node a, for each individual a that appears in at least one assertion
of the form C(a) in K (we call these nodes nominal nodes),
 add C to L(a), for each assertion of the form C(a) or R(a, b) in K,
 add R to L(a, b), for each assertion of the form R(a, b) in K,
 initialize a set T := {NNF(C  D) | C  D  K}.
The algorithm begins with the initial graph Fi along with the sets T and M, and
proceeds by non-deterministically applying the rules defined in Table 1, a process
which can be understood as creating a candidate model for the knowledge base.
The T Box,, and  rules are deterministic rules, whereas the
,GCC and GCR rules are non-deterministic rules, as they provide a
choice, with each choice leading to possibly a different graph. The algorithm
differs from the usual tableaux algorithm for ALC, as it provides extra GCC
and GCR non-deterministic rules, such that the candidate models are in fact
grounded candidate models as defined in Definition 2. The rules are applied
until a clash is detected or until none of the rules is applicable. A graph is said
to contain an inconsistency clash when one of the node labels contains both
C and C, or it contains , and it is called inconsistency-clash-free if it does
not contain an inconsistency clash. The algorithm by application of the rules
upon termination generates a so-called completion graph. A notion of blocking
is required to ensure termination, and we define it as follows.
Definition 4 (Blocking). A non-nominal node x is blocked
1. if it has a blocked ancestor; or
 such that L(x)  L(x
2. if it has a non-nominal ancestor x

) and the path
. Note that

between x

 and x consists only of non-nominal nodes.

In the second case, we say that x is directly blocked by the node x
any non-nominal successor node of x is also blocked.
For a GC-ALC-KB (K, M), the tableau expansion rules when applied exhaus-
tively, generate a completion graph which consists of nodes, edges and their
labels, each node x of the graph is labeled with a set of (complex or atomic)
concepts and each edge (x, y) is labeled with a set of roles.
Lemma 3 (termination). Given any GC-ALC-KB (K, M), the tableaux procedure for (K, M) terminates.
?

?

?
Table 1. Tableau1 expansion rules for GC-ALC-KBs (K, M ). The first five rules are
taken directly from the ALC tableaux algorithm. Input: Fi, T and M .

:

T Box :




:

:



:

GCC :

GCR :

with C / L(y)

with C  L(y)

if C  T and C / L(x)
then L(x) := L(x)  {C}
if C1  C2  L(x), x is not blocked, and {C1, C2}  L(x)
then L(x) := L(x)  {C1, C2}
if C1  C2  L(x), x is not blocked, and {C1, C2}  L(x) = 
then L(x) := L(x)  {C1} or L(x) := L(x)  {C2}
if R.C  L(x), x is not blocked, and x has no R-successor y
then add a new node y with L(y) := {C} and L(x, y) := {R}
if R.C  L(x), x is not blocked, and x has an R-successor y
then L(y) := L(y)  {C}
if C  L(x), C  M, x / Ind(K) and x is not blocked
then for some a  Ind(K) do
1. L(a) := L(a)  L(x),
2. if x has a predecessor y, then L(y, a) := L(y, a)  L(y, x),
3. remove x and all incoming edges to x in the completion graph
if R  L(x, y), R  M and y is not blocked.
then initialize variables x
1. if x / Ind(K) then for some a  Ind(K),L(a) := L(a)  L(x),
2. if y / Ind(K) for some b  Ind(K), L(b) := L(b)  L(y) and
3. if x
4. L(x, y
5. if x
if y
from the completion graph.

y
then L(z, a) := L(z, a)  L(z, x).

= a remove x and all incoming edges to x and
= b remove y and all incoming edges to y

= a and x has a predecessor z,

) := L(x, y

)  {R}

:= x and y

:= y, and do

x

:= a.

:= b

Proof. First note that node labels can only consist of axioms from K in NNF
or of subconcepts of axioms from K in NNF. Thus, there is only a finite set
of possible node labels, and thus there is a global bound, say m  N, on the
cardinality of node labels.

Now note the following. (1) The number of times any rule can be applied to a
node is finite, since the labels trigger the rules and the size of labels is bounded
by m. (2) The outdegree of each node is bounded by the number of possible
elements of node labels of the form R.C, since only the  rule generates
new nodes. Thus the outdegree is also bounded by m. Further, infinite nonlooping paths cannot occur since there are at most 2m possible different labels,
and so the blocking condition from Definition 4 implies that some node along
such a path would be blocked, contradicting the assumption that the path would
be infinite. (3) While the GCC rule and the GCR rule delete nodes, they
can only change labels of nominal nodes by possibly adding elements to nominal

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

node labels. Since the number of possible elements of node labels is bounded
by m, at some stage application of the GCC rule or the GCR rule will no
longer add anything to nominal node labels, and then no new applications of
rules can be enabled by this process.

From (1), (2) we obtain a global bound on the size of the completion graphs
which can be generated by the algorithm, and from (3) we see that infinite
loops due to deletion and recreation of nodes cannot occur. Thus, the algorithm
necessarily terminates.

Before we show that the tableaux calculus is sound and complete, we define a
function called read function which will be needed for clarity of the proof and
verification of minimality of the models.

Definition 5 (read function). Given an inconsistency-clash-free completion
graph F , we define a read function r which maps the graph to an interpretation
r(F ) = I in the following manner. The interpretation domain I contains all
the non-blocked nodes in the completion graph. Further, for each atomic concept
I to be the set of all non-blocked nodes x for which A  L(x). For
A, we set A
I to be the set of pairs (x, y) which satisfy any of the
each role name R, we set R
following conditions:
 R  L(x, y) and y is not blocked; or
 x is an immediate R-predecessor of some node z, and y directly blocks z

The mapping just defined is then lifted to complex concept descriptions as usual.

The second condition is due to the well-known technique of unraveling (see, e.g.,
[11]): while disregarding blocked nodes, an incoming edge from an immediate
R-predecessor x of the blocked node z is considered to be replaced by an edge
from the predecessor to the node y which directly blocks z. This accounts for
the intuition that a path ending in a blocked node stands for an infinite but
repetitive path in the model.
Lemma 4 (soundness). If the expansion rules are applied to a GC-ALC-KB
(K, M), such that they result in an inconsistency-clash-free completion graph F ,
then K has a grounded model I = r(F ). Furthermore, the extension A
I of each
concept A  M under I coincides with the set {x | x  Ar(F )}, the extension R

of each role R  M under I coincides with the set {(x, y) | (x, y)  Rr(F )}, and
both these sets can be read off directly from the labels of the completion graph.

Proof. From the inconsistency-clash-free completion graph F , we create an interpretation I = r(F ) where r is the read function defined in Definition 5. Since
the completion graph is free of inconsistency clashes, and the first five expansion
rules from Table 1 follow the definition of a model from Section 2, the resulting
interpretation is indeed a model of K.7 Moreover, the GCC and GCR rules
ensure that the extensions of minimized predicates contain only (pairs of) known
individuals. Hence, r(F ) = I is a grounded model of K w.r.t M, and Definition 5
shows how the desired extensions can be read off from the completion graph.

7 This can be proven formally by structural induction on formulas as in [11].
?

?

?
Lemma 5 (completeness). If a GC-ALC-KB (K, M) has a grounded model
I, then the expansion rules can be applied to the initial graph Fi of (K, M) in
such a way that they lead to an inconsistency-clash-free completion graph F , and
such that the following hold.
 r(F )  I
 ar(F ) = a
 W r(F )  W
 the extensions, under r(F ), of the closed concept and role names can be read

I for every nominal node a

I for every W  M

off from F as in the statement of Lemma 4.

Proof. Given a grounded model I for K w.r.t M, we can apply the completion
rules to Fi in such a way that they result in an inconsistency-clash-free completion graph F . To do this we only have to ascertain that, for any nodes x and
I} and L(x, y)  {R |
y in the graph, the conditions L(x)  {C | (x)  C
((x), (y))  R
I} are satisfied, where  is mapping from nodes to I. This
construction is very similar to the one in [11, Lemma 6], to which we refer for
details of the argument.

The remainder of the statement follows from the fact that the two conditions
just given are satisfied, and from the reading-off process specified in Lemma 4.

We have provided an algorithm that generates a set of completion graphs and
each inconsistency-clash-free completion graph represents a grounded model.
In fact (K, M) is GC-satisfiable if at least one of the completion graphs is
inconsistency-clash-free.
Theorem 2. Let (K, M) be a GC-ALC-KB. Then (K, M) has a grounded model
if and only if it is GC-satisfiable.

Proof. The if part of the proof is trivial.

We prove the only if part. For any grounded model I, let |MI| denote the
sum of the cardinalities of all extensions of all the minimized predicates in M,
and note that, for any two grounded models I and J of K w.r.t. M, we have
|MJ | < |MI| whenever J M I. Hence, for any grounded model I of K w.r.t.
M which is not a GC-model of (K, M), there is a grounded model J of K w.r.t.
M with J M I and |MJ | < |MI|. Since |MI| > 0 for all grounded models I
(and because M is transitive), we obtain that, given some grounded model I,
it is not possible that there is an infinite descending chain of grounded models
preferred over I. Consequently, there must be some grounded model J of K
w.r.t. M which is minimal w.r.t. |MJ | among all models which are preferred
over I. This model J must be a GC-model, since otherwise it would not be
minimal.

The following is a direct consequence of Lemmas 3, 4, 5, and Theorem 2.

Theorem 3. The tableaux algorithm Tableau1 presented above is a decision procedure to determine GC-satisfiability of GC-ALC-KBs.

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

4.2 Inference Problems beyond GC-Satisfiability

Unlike in other description logics, common reasoning tasks such as concept satisfiability or instance checking cannot be readily reduced to GC-satisfiability
checking.8 To cover other inference tasks, we need to extend the previously described algorithm. To do this, we first describe a tableaux algorithm Tableau2
which is a modification of Tableau1, as follows. All computations are done with
respect to an input GC-ALC-KB (K, M).
(i) Initialization of Tableau2 is done on the basis of a inconsistency-clash-free
completion graph F , as follows. We create a finite set of nodes which is
exactly the domain I of a grounded model I = r(F ). We distinguish between two different kinds of nodes, the I-nominal nodes, which are nodes
I  I where a is an individual name, and the
corresponding to some a
remaining nodes which we call variable nodes. For initialization, we furthermore add all information from the ABox of K to the graph and create
the set T from K, as in the initialization of Tableau1.

(ii) We modify the  rule as follows.

 : if R.C  L(x), and x has no R-successor y with C  L(y)

then select an existing node y and

set L(y) := {C} and L(x, y) := {R}

The above change in the -rule enables us to restrict the graph to
contain only the nodes it was initialized with, which means new nodes are
not created.

 W r(F
 W r(F
 W r(F

) = W
) {a
){(a
?

?

?
(iii) We retain all other completion rules, however we dispose of blocking.
(iv) We retain the notion of inconsistency clash, and add a new notion of pref-
 obtained during the graph construction
erence clash as follows. A graph F
performed by Tableau2 is said to contain a preference clash with I if at
least one of the following holds.

I for each predicate W  M
I | a an individual }  W
I) | a, b individuals }  W

, b

I for some concept name W  M
I for some role name W  M
Proposition 2. Tableau2 always terminates. If it terminates by constructing
) is
, then r(F
an inconsistency- and preference-clash-free completion graph F
preferred over I, i.e., it shows that I is not a GC-model. If no such graph F
 is
found, then I has been verified to be a GC-model.
Proof. Termination is obvious due to the fact that no new nodes are created, i.e.,
the algorithm will eventually run out of choices for applying completion rules.

8 E.g., say we want to decide whether (K, M ) GC-entails C(a). We cannot do this,
in general, by using the GC-satisfiability algorithm in the usual way, i.e., by adding
C(a) to K with subsequent checking of its GC-satisfiability. This is because in
general it does not hold that (K, M ) does not GC-entail C(a) if (K  C(a), M ) is
GC-satisfiable. This is due to the non-monotonic nature of circumscription.
?

?

?
. We have to show that r(F

Now assume that the algorithm terminates by finding an inconsistency- and
) is pre-
preference-clash-free completion graph F
ferred over I, i.e., we need to verify the properties listed in Definition 1. I =
) holds because we initiate the algorithm with nodes being elements from
r(F
I and no new nodes are created. In case nodes are lost due to the grounding
rules of Tableau2, we can simply extend r(F
) with some additional elements
I = ar(F

which are not otherwise of relevance for the model. The condition a
)
for every a
) holds because this is how the algorithm is initialized. The
remaining two conditions hold due to the absence of a preference clash.

I  r(F

For the last statement of the proposition, note that Tableau2 will non-deter-
ministically find an inconsistency- and preference-clash-free completion graph if
such a graph exists. This can be seen in a similar way as done in the proof of
Lemma 5.
We next use Tableau1 and Tableau2 together to create an algorithm which finds
GC-models for (K, M) if they exists. We call this algorithm GC-model finder.
The algorithm is specified as follows, on input (K, M).
1. Initialize and run Tableau1 on (K, M). If no inconsistency-clash-free completion graph is found, then (K, M) has no GC-model and the algorithm
terminates. Otherwise let F be the resulting completion graph.

 and go to step 2.

2. Initialize Tableau2 from F and run it. If no inconsistency- and preference-
clash-free completion graph is found, then r(F ) is a GC-model of (K, M) and
 be the resulting
the algorithm terminates with output r(F ). Otherwise let F
completion graph.

 as specified, then r(F

3. Set F = F
The loop in steps 2 and 3 necessarily terminates, because whenever step 2 finds
) is preferred over r(F ). As argued
a completion graph F
in the proof of Theorem 2, there are no infinite descending chains of grounded
models w.r.t. the preferred over relation, so the loop necessarily terminates. The
output r(F ) of the GC-model finder is a GC-model of (K, M), and we call F a
GC-model graph of (K, M) in this case.
Theorem 4. On input a GC-ALC-KB (K, M), the GC-model finder creates a
GC-model I of (K, M) if such a model exists. Conversely, for every GC-model
J of (K, M), there exist non-deterministic choices of rule applications in the
GC-model finder such that they result in a model I which coincides with J on
all extensions of minimized predicates.
Proof. The first statement follows from Propositon 2 together with the explanations already given. The second statement follows due to Lemma 5, since
Tableau1 can already create the sought GC-model I.

We now consider the reasoning tasks usually known as instance checking, concept
satisfiability and concept subsumption. We provide a convenient way to utilize
the GC-model finder algorithm to solve these problems by use of another notion
of clash called entailment clash. The following definition describes the inference
tasks and provides the notion of entailment clash for each of them as well.

K. Sengupta, A.A. Krisnadhi, and P. Hitzler

Definition 6. For a GC-ALC-KB (K, M).
 Instance checking: Given an atomic concept C and an individual a in (K, M),
I for all GC-models I of (K, M).
(K, M) |=GC C(a) if and only if a
For instance checking of C(a), a GC-model graph F is said to contain an
entailment clash if C  L(a) in F .

I  C

 Concept satisfiability: Given an atomic concept C in (K, M), C is GC-
I =  for some GC-model of (K, M). For checking
satisfiable if and only if C
satisfiability of C, a GC-model graph F is said to contain an entailment
clash if C  L(x) for any node x in F .
 Concept subsumption: Given concepts C and D in (K, M), (K, M) |=GC
I for all models I in (K, M). Subsumption can
C  D if and only if C
be reduced to concept satisfiability: GC-ALC-KB(K, M) |=GC C  D if and
only if C  D is not GC-satisfiable.

I  D

We use the following process to solve these inference problems:

To determine if C(a) is entailed by a GC-ALC-KB (K, M), we invoke the
GC-model finder until we find a GC-model. If this non-deterministic procedure
results in a GC-model graph which does not contain an entailment clash, then
(K, M) |=GC C(a). If no such GC-model graph can be generated this way, then
(K, M) |=GC C(a).

To determine if C is GC-satisfiable, we invoke the GC-model finder until
we find a GC-model. If this non-deterministic procedure results in a GC-model
graph which contains an entailment clash, then C is satisfiable. If no such GCmodel graph can be generated this way, then C is unsatisfiable.

5 Conclusion

We have provided a new approach for incorporating the LCWA into description
logics. Our approach, grounded circumscription, is a variant of circumscriptive
description logics which avoids two major issues of the original approach: Extensions of minimized predicates can only contain named individuals, and we
retain decidability even for very expressive description logics while we can allow
for the minimization of roles. We have also provided a tableaux algorithm for
reasoning with grounded circumscription.

While the contributions in this paper provide a novel and, in our opinion,
very reasonable perspective on LCWA reasoning with description logics, there
are obviously also many open questions. A primary theoretical task is to investigate the complexity of our approach. Of more practical relevance would be
an implementation of our algorithm with a substantial evaluation to investigate
its efficiency empirically. More work also needs to be done in carrying over the
concrete algorithm to description logics which are more expressive than ALC.
It also remains to investigate the added value and limitations in practice
of modeling with grounded circumscription. This will also shed light onto the
question whether fixed predicates and prioritization are required for applications.
?

?

?
Acknowledgements. This work was supported by the National Science Foundation under award 1017225 III: Small: TROnTractable Reasoning with On-
tologies, and by State of Ohio Research Incentive funding in the Kno.e.CoM
project. Adila Krisnadhi acknowledges support by a Fulbright Indonesia Presidential Scholarship PhD Grant 2010.
