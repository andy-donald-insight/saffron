Querying OWL 2 QL and Non-monotonic Rules

Matthias Knorr and Jos e J ulio Alferes

CENTRIA, FCT, Universidade Nova de Lisboa

Abstract. Answering (conjunctive) queries is an important reasoning
task in Description Logics (DL), hence also in highly expressive ontology
languages, such as OWL. Extending such ontology languages with rules,
such as those expressible in RIF-Core, and further with non-monotonic
rules, integrating default negation as described in the RIF-FLD, yields
an even more expressive language that allows for modeling defaults, ex-
ceptions, and integrity constraints.

Here, we present a top-down procedure for querying knowledge bases
(KB) that combine non-monotonic rules with an ontology in DL-LiteR
 the DL underlying the OWL 2 profile OWL 2 QL. This profile aims
particularly at answering queries in an efficient way for KB with large
ABoxes. Our procedure extends the query-answering facility to KB that
also include non-monotonic rules, while maintaining tractability of reasoning (w.r.t. data complexity). We show that the answers are sound and
complete w.r.t. the well-founded MKNF model for hybrid MKNF KB K.

1 Introduction

Combining highly expressive ontology languages, such as OWL [9], (or their
underlying DL) and rules, such as in RIF-Core [3], is an important task in the
on-going standardization driven by the World Wide Web Consortium1 (W3C).
Both languages are quite different in terms of expressiveness and how decidability
is achieved, and providing a joint formalism is non-trivial, all the more if the
rules include mechanisms for non-monotonic reasoning, such as the NAF operator
described in the RIF-FLD [4].

Non-monotonic rules provide expressive features, such as the ability to model
defaults, exceptions, and integrity constraints, and its usefulness is frequently
being voiced. E.g., in [14], an ontology language is used for matching clinical
trials criteria with patient records, but one open problem is that medication of
patients, which is fully known, should be modeled by defaults.

Several approaches that combine rules and DL have been defined (see, e.g.,
[11,13] for an overview) but, among them, the approach of hybrid MKNF knowledge bases [13], which is based on the logics of minimal knowledge and negation
as failure (MKNF) [12], is one of the most advanced. The integration of monotonic and non-monotonic reasoning is seamless yet allows for a modular re-use
of reasoning algorithms of each of its components. Thus, hybrid MKNF is more
expressive than comparable approaches but at least as competitive in terms of

http://www.w3.org/

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 338353, 2011.
c Springer-Verlag Berlin Heidelberg 2011
?

?

?
computation. At the cost of having a weaker form of reasoning, the well-founded
MKNF semantics for hybrid MKNF knowledge bases [11] achieves an even lower
computational (data) complexity in general. For example, if reasoning in the DL
is in PTIME, then the computation of the well-founded MKNF model remains
polynomial, while [13] is in NP. This is clearly preferable for large applications,
such as the one described in [14], which uses data of over 240,000 patients.

A further improvement in efficiency can be achieved if we query for information in a top-down manner: instead of computing the entire model of a knowledge
base we could, e.g., just query for the medication of one patient ignoring all the
others. Queries are considered in the W3C with SPARQL [15] and answering
(conjunctive) queries is an important reasoning task in DL [7].
In [1], SLG(O) is introduced, which allows us to pose queries to a hybrid
MKNF KB and whose semantics is shown to correspond to that of [11]. The work
is based on an extension of SLG  a procedure for query-answering in normal
logic programs under the well-founded semantics resorting to tabling techniques
 that besides the operations for resolution in the rules, also incorporates calls to
a parametric oracle that deals with the reasoning task in the DL part of the KB.
It is shown that, if the number of answers of the oracle is appropriately restricted,
the favorable computational complexity of [11] is maintained. However, it is not
spelled out how these conditions are achieved for a concrete DL.
In this paper, we present a top-down procedure based on SLG(O) for querying KB that combine non-monotonic rules with an ontology in DL-LiteR  the
DL underlying the OWL 2 profile OWL 2 QL. This profile aims particularly
at answering queries in an efficient way for KB with large ABoxes. It is thus
a natural choice as DL language for a procedure for query answering in KB
that, besides the ontology with large ABoxes, also includes the features of expressing defaults, constraints and exceptions, provided by non-monotonic rules.
Our procedure achieves that, while maintaining tractability of reasoning (w.r.t.
data complexity) on hybrid KB and reasoning in LOGSPACE on DL-LiteR alone.
In particular, query-answering is obtained by a combination of techniques from
top-down procedures in logic programs, and reasoning in relational databases
as done in DL-LiteR. We show that the answers are sound and complete w.r.t.
the well-founded MKNF model for hybrid MKNF knowledge bases K if K is
MKNF-consistent, and a paraconsistent approximation of that model otherwise.
As such, our work provides a way for querying KB consisting of an ontology in
the profile OWL 2 QL and a RIF dialect that allows for non-monotonic rules,
and, together with [10], such a query procedure for each tractable OWL profile.

2 Preliminaries

2.1 DL-LiteR
The description logic underlying OWL 2 QL is DL-LiteR, one language of the
DL-Lite family [5], which we recall in the following.

The syntax of DL-LiteR is based on three disjoint sets of individual names
NI, concept names NC, and role names NR. Complex concepts and roles can be

M. Knorr and J.J. Alferes

formed according to the following syntax, where A  NC is a concept name,
P  NR a role name, and P

 its inverse.

C  A | R

R  P | P



D  C | C

E  R | R

A DL-LiteR knowledge base O = (T ,A) consists of a TBox T and an ABox
A. The TBox contains general inclusion axioms (GCI) of the form C  D, where
C and D are defined as above. Thus, the left and right hand sides of GCI are of
different expressiveness in DL-LiteR. Additionally, DL-LiteR TBoxes contain
role inclusion axioms (RI) of the form R  E where R and E are formed as
introduced above. Such axioms permit to express properties, such as symmetry.
The ABox contains assertions of the form A(a) and P (a, b) where A  NC,
P  NR, and a, b  NI. Assertions C(a) for general concepts C are included by
adding A  C to the TBox and A(a) to the ABox for a new concept name A.
,I) consisting
I and an interpretation function I that
I, to each concept C a
I over I. This can be

I of 
I, and to each role name R a binary relation R

of a nonempty interpretation domain 
assigns to each individual a a distinct2 element a
subset C
generalized to complex expressions as usual:

The semantics of DL-LiteR is based on interpretations I = (

I}

I ((a

, b
?

?

?
)  R

I}

I \ C



(P
)
(R)

= {(i2, i1) | (i1, i2)  P
= {i | (i, i

(C)

(R)

An interpretation I is a model of the GCI C  D if C
I. It is a model
of an RI R  E if R
I. I is also a model of an assertion A(a) (P (a, b)) if
I  E
I). Given an axiom/assertion  we denote by I |=  that
I  A
I)  P
a
I is a model of . A model of a DL-LiteR KB O = (T ,A) is an interpretation
I such that I |=  holds for all   T and all   A. A KB O is satisfiable if it
has at least one model.

= 
=    \ R
I  D

Standard reasoning tasks in DL-LiteR are polynomial in the size of the TBox,
and in LOGSPACE in the size of the ABox, i.e., in data complexity. The same holds
for answering conjunctive queries, but if we consider the combined complexity
(including the query), then answering conjunctive queries is NP-complete [5].

2.2 Well-Founded Semantics for Hybrid MKNF

Hybrid MKNF knowledge bases are introduced in [13] as a combination of nonmonotonic rules and a DL that is translatable into first-order logic, and in which
standard reasoning tasks, namely satisfiability and instance checking, are decid-
able. Here, we recall only the version with rules without disjunction in heads and
the computation of the complete well-founded MKNF model for such knowledge
bases [11], for which we define a top-down procedure for DL-LiteR. Recalling the
computation of the complete well-founded MKNF model is not strictly needed
for the definition of the top-down procedure itself, but we present it here since

2 Hence, the unique name assumption is applied and, as shown in [2], dropping it

would increase significantly the computational complexity of DL-LiteR.
?

?

?
it provides valuable insights into the combined model for which we query. More-
over, the operator DKG, defined in this section, provides exactly the counterpart
of the oracle to the DL in the top-down procedure we present in this paper.
Definition 1. Let O be a DL knowledge base. A function-free first-order atom
P (t1, . . . , tn) such that P is  or occurs in O is called a DL-atom; otherwise it
is called non-DL-atom. An MKNF rule r has the following form where H, Ai,
and Bi are function-free first-order atoms:

K H  K A1, . . . , K An, not B1, . . . , not Bm

(1)

K-atoms (resp. not-atoms) are atoms with a leading K (resp. not). A program
is a finite set of MKNF rules, and a hybrid MKNF knowledge base K is a
pair (O,P) and positive if m = 0 holds for all MKNF rules in K. The ground
instantiation of K is the KB KG = (O,PG) where PG is obtained from P by
replacing each rule r of P with a set of rules substituting each variable in r with
constants from K in all possible ways.

may appear anywhere in the rules.

There is no restriction on the interaction between O and P, i.e., DL-atoms
The semantics of K is based on a transformation of K into an MKNF formula
to which the MKNF semantics can be applied (see [11,12,13] for details). Decidability is achieved by applying the well-known notion of DL-safety, in which
each variable in a rule appears in at least one non-DL K-atom [13]. This essentially restricts the application of rules to individuals explicitly appearing in
the knowledge base in consideration [13]. Instead of spelling out the technical
details of the original MKNF semantics [13] or its three-valued counterpart [11],
we focus on a compact representation of models for which the computation of
the well-founded MKNF model is defined3. This representation is based on a set
of K-atoms and (O), the translation of O into first-order logic.
Definition 2. Let KG = (O,PG) be a ground hybrid MKNF knowledge base.
The set of K-atoms of KG, written KA(KG), is the smallest set that contains (i)
all ground K-atoms occurring in PG, and (ii) a K-atom K for each ground notatom not  occurring in PG. For a subset S of KA(KG), the objective knowledge
of S w.r.t. KG is the set of first-order formulas OBO,S = {(O)}{ | K   S}.
The set KA(KG) contains all atoms occurring in KG, only with not-atoms
substituted by corresponding modal K-atoms, while OBO,S provides a first-order
representation of O together with a set of known/derived facts.

In the three-valued MKNF semantics, this set of K-atoms can be divided
into true, undefined and false modal atoms. Next, we recall operators from [11]
that derive consequences based on KG and a set of K-atoms that is considered
to hold. To further simplify notation, in the remainder of the paper we abuse
notation and consider all operators K implicit.

3 Strictly speaking, this computation yields the so-called well-founded partition from

which the well-founded MKNF model is defined (see [11] for details).

M. Knorr and J.J. Alferes

Definition 3. Let KG = (O,PG) be a positive, ground hybrid MKNF knowledge
base. The operators RKG, DKG, and TKG are defined on subsets of KA(KG):

RKG(S) ={H | PG contains a rule of the form H  A1, . . . An
DKG(S) ={ |   KA(KG) and OBO,S |= }
TKG(S) =RKG(S)  DKG(S)

such that, for all i, 1  i  n, Ai  S}

The operator TKG is monotonic, and thus has a least fixpoint TKG  . Transformations can be defined that turn an arbitrary hybrid MKNF KB KG into a
positive one (respecting the given set S) to which TKG can be applied. To ensure
coherence, i.e., that classical negation in the DL enforces default negation in the
rules, two slightly different transformations are defined (see [11] for details).
Definition 4. Let KG = (O,PG) be a ground hybrid MKNF knowledge base and
S  KA(KG). The MKNF transform KG/S is defined as KG/S = (O,PG/S),
where PG/S contains all rules H  A1, . . . , An for which there exists a rule
H  A1, . . . , An, not B1, . . . , not Bm in PG with Bj  S for all 1  j  m.
The MKNF-coherent transform KG//S is defined as KG//S = (O,PG//S),
where PG//S contains all rules H  A1, . . . , An for which there exists a rule
H  A1, . . . , An, not B1, . . . , not Bm in PG with Bj  S for all 1  j  m and
OBO,S |= H. We define KG(S) = TKG/S   and 

KG(S) = TKG//S  .
?

?

?
Based on these two antitonic operators [11], two sequences Pi and Ni are

defined, which correspond to the true and non-false derivations.
N0 = KA(KG)

KG(Pn)
Ni

P0 = 
?

?

?
Pn+1 = KG(Nn)

Nn+1 = 

"

P =

Pi

N =

The fixpoints, which are reached after finitely many iterations, yield the well-

founded MKNF model [11].
Definition 5. The well-founded MKNF model of an MKNF-consistent ground
hybrid MKNF knowledge base KG = (O,PG) is defined as (P, KA(KG) \ N).
If KG is MKNF-inconsistent, then there is no MKNF model, hence no wellfounded MKNF model.
Example 1. Consider the hybrid MKNF KB K4 consisting of O:

We use a simple example adapted from [5] to illustrate this computation.

Professor  TeachesTo

Student  HasTutor
  Professor
  TeachesTo

TeachesTo

  Student
Professor  Student
and the rules (including the facts):
4 We use capital letters for DL-atoms and individuals. Note that K is not DL-safe,
but we assume that each rule contains implicitly, for all variables x appearing in the
rule, an additional atom o(x), and that K contains facts o(x), for every object x.

HasTutor
HasTutor
?

?

?
hasKnownTutor(x)  Student(x), HasTutor(x, y)

hasUnknownTutor(x)  Student(x), not HasTutor(x, y)

(2)
(3)

Student(Paul)  HasTutor(Jane, Mary)  TeachesTo(Mary, Bill) 

We only consider the set KA(KG) for the computation, i.e., only the atoms
that actually appear in the ground rules and we abbreviate the names in this
example appropriately. Starting with P0 =  and N0 = KA(KG), we compute
P1 = {S(P), HT(J, M), TT(M, B), S(J), S(B), HT(B, M), hKT(J), hKT(B)} and N1 = P1
{hUT(P), hUT(J), hUT(B)}. We continue with P2 = P1  {hUT(P)} and N2 = P2,
and these are already the fixpoints.We obtain that Jane and Bill have a known
tutor, while Paul has not. Other derivations, such as Professor(Mary) can be
obtained from the fixpoints and O. Note that rule (3) can be understood as a
default: it states that by default students have unknown tutors.

3 Queries in Hybrid MKNF
In [1], a procedure, called SLG(O), is defined for querying arbitrary hybrid
MKNF knowledge bases. This procedure extends SLG resolution with tabling
[6] with an oracle to O that handles ground queries to the DL-part of KG: given
the already derived information and O, the oracle returns a (possibly empty) set
of atoms that allows us, together with O and the already derived information, to
derive the queried atom. Recalling the full procedure would be beyond the scope
of this paper, so we just give an intuitive overview of the general procedure and
only point out the specific technical details that are required for the concrete
oracle to DL-LiteR in terms of an interface. All the details can be found at [1].
The general idea is that SLG(O) creates a forest of derivation trees starting
with the initial query. If the initial query is unifiable with a rule head, then
the rule body is added as a child node to the respective tree. In each such new
node, we consider each atom according to a given selection order, create new
trees, and try to resolve these so-called goals. Due to potential circularities in
the derivations, some goals may be delayed, possibly giving rise to conditional
answers. If we achieve an unconditional answer for such a goal, i.e., a leaf node
without any remaining goals, then the (instantiated) atom in the root is true,
and the goal is resolved. If no further operation is applicable, but no leaf node is
empty, then the root(s) corresponding to such a (set of) tree(s) is (are) considered
false. If a (default) negated atom not A is selected, then a tree for A is created:
if A succeeds then not A fails; otherwise not A is resolved.

If the queried/selected atom is a DL-atom, then a query is posed to an oracle,
which encapsulates reasoning in the DL part of the KB, to check whether the
DL-atom can be derived from the DL-part. For that purpose, all DL-atoms that
are already known to be true in the derivation forest are added to the ontology
before calling the oracle. It may happen that only a subsequent derivation step
contains the necessary information to derive the queried atom, so we would
have to call the oracle over and over again. To avoid this problem, rather than

M. Knorr and J.J. Alferes

answering whether the queried atom is derivable, an oracle in SLG(O) returns
a set (conjunction) of atoms that, if proven true, would allow us to derive the
queried atom. This set is added as a child to the respective tree and treated like
the result of an operation on rules.

In the end, if we achieve an unconditional answer for the initial query, the
(instantiated) query is true; if all answers are conditional, then the query is
undefined; otherwise it is false. The following example shall clarify the idea.
Example 2. Consider again the hybrid MKNF knowledge base K from Example
1 and the query Student(Bill). A root Student(Bill) is created and since no
rule head is unifiable, we call the oracle. If TeachesTo(x, Bill) holds for some x,
then Student(Bill) would hold. Thus a child with the goal TeachesTo(x, Bill)
is added to the tree. Then, a new tree for TeachesTo(x, Bill) is created whose
root unifies with TeachesTo(Mary, Bill). We obtain an unconditional answer,
and, after resolving TeachesTo(x, Bill) in the tree with root Student(Bill), an
unconditional answer for Student(Bill), thus finishing the derivation.

Alternatively, consider the query hUT(P) (with abbreviations as in Example
1). Since the root of the corresponding tree is a non-DL-atom, only rules can be
considered, and, in fact, rule (3) is applicable. The resulting child contains two
goals, namely S(P) and not HT(P, y). Note that implicitly o(y) also occurs so that
y is ground when querying for not HT(P, y). A separate tree is created for S(P)
and easily resolved with the given fact. Then we consider any of the meanwhile
grounded not HT(P, y). A new tree is created for HT(P, y) (with ground y) but
neither the rules nor the oracle allow us to derive an unconditional answer and
eventually each such tree is failed, since there is no known tutor for P. If the tree
for HT(P, y) fails, then not HT(P, y) holds and can be resolved, which yields an
unconditional answer for hUT(P).

As already said, we only want to consider specifically the mechanism that provides the oracle for DL-LiteR, and here we only recall the relevant notions for
that task. We start by defining the reasoning task in consideration, namely DLsafe conjunctive queries.

Definition 6. A (DL-safe) conjunctive query q is a non-empty set, i.e. conjunc-
tion, of literals where each variable in q occurs in at least one non-DL atom in q.
We also write q as a rule q(Xi)  A1, . . . , An, not B1, . . . , not Bm where Xi is
the (possibly empty) set of variables, appearing in the body, which are requested.
This guarantees that SLG(O) does always pose ground queries to the oracle,
avoiding problems with DL where conjunctive query answering is undecidable in
general, and, in particular, with inconsistent DL-LiteR KB that would simply
return arbitrary solutions [5] in opposite to our intentions (see Definition 8).
Now, we recall the definition of a complete oracle that provides the relation
for the intended derivation. We point out that Fn is the current derivation forest,
where n is increased with each applied SLG(O) operation. In it, IFn corresponds
to all already derived (true or false) atoms in a concrete derivation forest.
?

?

?
Definition 7. Let K = (O,P) be a hybrid MKNF knowledge base, S a ground
goal, L a set of ground atoms that appear in at least one rule head in PG, and
I +Fn = IFn\{not A | not A  IFn}. The complete oracle for O, denoted compTO,
is defined by compTO(IFn , S, L) iff O  I +Fn

 L |= S.

This notion of a complete oracle is used to define the SLG(O) operation that

handles the oracle calls to the DL (see [1] for notation of trees in SLG(O)).
 Oracle Resolution: Let Fn contain a tree with root node N = S :- |S,
where S is ground. Assume that compTO(IFn , S, Goals). If N does not have
a child Nchild = S :- |Goals in Fn then add Nchild as a child of N.

It is shown (in Theorem 5.3 of [1]) that answers to queries in SLG(O) correspond
to the hybrid MKNF well-founded model as in [11].

 L |= S and O  I +Fn

The complete oracle is unfortunately not efficient, in that it potentially creates
a lot of superfluous answers, such as supersets of correct minimal answers. This
problem is tackled with the introduction of a partial oracle [1].
Definition 8. Let KG = (O,PG) be a hybrid MKNF knowledge base, S a ground
goal, and L a set of atoms that are unifiable with at least one rule head in PG.
A partial oracle for KG, denoted pTO, is a relation pTO(IFn , S, L) such that if
pTO(IFn , S, L), then O  I +Fn
 L consistent. A partial
oracle pTO is correct w.r.t. compTO iff, for all MKNF-consistent KG, replacing
compTO in SLG(O) with pTO succeeds for exactly the same set of queries.
There are three main differences between complete and partial oracles. First, in
the latter we do not have to consider all possible answers, thus restricting the
number of returned answers for a given query. This is important, because, as
pointed out in [1], the favorable computational properties of the well-founded
MKNF model are only maintained if the number of returned answers is appro-
 L
priately bounded. Second, only derivations based on a consistent O  I +Fn
are considered. This removes all pointless attempts to derive an inconsistency
for an MKNF-consistent KB K. It also removes derivations based on explosive
behavior w.r.t. inconsistencies, which is why the correctness result of the partial
oracle is limited to MKNF-consistent KB. This may not be a problem, since it
has already been conjectured in [1] that the resulting paraconsistent behavior
should be beneficial in practice. Finally, instead of requiring ground sets L, we
admit sets of atoms that are unifiable with heads. This simplifies notation and
postpones the necessary grounding to be handled in SLG(O) w.r.t. the rules.
How such a partial oracle is defined for a concrete DL is not specified in [1]

and, in Section 5, we present a concrete oracle for DL-LiteR.

4 Satisfiability in DL-LiteR

For defining an oracle for DL-LiteR we rely on the reasoning algorithms provided
for DL-LiteR in [5]. The basic reasoning service to which all others are reduced is
satisfiability. Satisfiability of a DL-LiteR KB is checked by evaluating a suitable

M. Knorr and J.J. Alferes

Boolean first-order logic query w.r.t. a canonical model of its ABox. We recall
the construction and evaluation of such a formula here specifically, since our
work is based on an adaptation of that algorithm. First, we recall the definition
of a canonical interpretation of the ABox from [5].
Definition 9. Let A be a DL-LiteR ABox. By db(A) = (db(A),db(A)) we
denote the interpretation defined as follows:
 db(A) is the nonempty set consisting of all constants occurring in A;
 adb(A) = a for each constant a;
 Adb(A) = {a | A(a)  A} for each atomic concept A; and
 Rdb(A) = {(a, b) | R(a, b)  A} for each atomic role R.
It is easy to see that db(A) is in fact a model of A and a minimal one [5].

This forms the basis for checking satisfiability in DL-LiteR, i.e., we are able

to reduce satisfiability to evaluating a Boolean FOL query.
Definition 10. Satisfiability in DL-LiteR is FOL-reducible if, for every TBox
T expressed in DL-LiteR, there exists a Boolean FOL query q, over the alphabet
of T , such that, for every nonempty ABox A, (T ,A) is satisfiable if and only if
q evaluates to false in db(A).
Now, a query is constructed, by first splitting all GCI into those with  on
the right hand side (called negative inclusions (NI)) and those without (called
positive inclusions (PI)) and by considering the negative inclusions as a starting
point to compute all derivable negative inclusions.
Definition 11. Let T be a DL-LiteR TBox. We call NI-closure of T , denoted
by cln(T ), the set defined inductively as follows:
1. All negative inclusion assertions in T are also in cln(T ).
2. If B1  B2 is in T and B2  B3 or B3  B2 is in cln(T ), then also
3. If R1  R2 is in T and R2  B or B  R2 is in cln(T ), then also
4. If R1  R2 is in T and R
2 is in cln(T ), then also

5. If R1  R2 is in T and R2  R3 or R3  R2 is in cln(T ), then also
, or R  R is in cln(T ),
6. If one of the assertions R  R, R

B1  B3 is in cln(T ).
R1  B is in cln(T ).
 B is in cln(T ).
R
R1  R3 is in cln(T ).
then all three such assertions are in cln(T ).

 B or B  R

  R





A translation function from assertions in cln(T ) to FOL formulas is defined [5].
Definition 12. Let O be a DL-LiteR KB and cln(T ) the NI-closure of T . The
translation function  from axioms in cln(T ) to first-order formulas is:

(B1  B2) = x.1(x)  2(x)
(R1  R2) = x, y.1(x, y)  2(x, y)

where i(x) = Ai(x) if Bi = Ai, i(x) = yi.Ri(x, yi) if Bi = Ri, and i(x) =
yi.Ri(yi, x) if Bi = R
; and i(x, y) = Pi(x, y) if Ri = Pi, and i(x, y) =
Pi(y, x) if Ri = P


i .
?

?

?
Require: DL-LiteR KB O = (T ,A)
Ensure: true if O is satisfiable, false otherwise

qunsat = 
for all   cln(T ) do

qunsat = qunsat  ()
unsat =  then
return true

end for
if qdb(A)

else

return false

end if

Fig. 1. Algorithm Consistent

The algorithm in Fig. 1 checks satisfiability of a DL-LiteR knowledge base O
by testing if qunsat is not satisfied if evaluated over db(A). Of course, if O is free
of negative inclusions, then the algorithm succeeds automatically.

With this, instance checking is straightforwardly obtained in [5] as a reduction

to satisfiability checking.
Theorem 1. Let O be DL-LiteR KB, and H either a general concept (with
ground argument ti) appearing in O where A an atomic concept not appearing
in O or a role name or its inverse (with ground arguments ti) appearing in O and
A an atomic role not appearing in O. Then O |= H(ti) iff O  { A  H, A(ti)}
is unsatisfiable.

Note that this theorem is a generalization of two separate theorems for con-

cepts and roles in [5] joined here for reasons of notation.

5 An Oracle for DL-LiteR

The material presented in Section 4 suffices to handle the bottom-up computation of the well-founded MKNF model w.r.t. DL-LiteR. In the subsequent
example, which we recall from [5], and which is a modification of Example 1
now without rules and with the facts turned into ABox assertions, we not only
present how satisfiability and instance checking work, but also intuitively sketch
the solution for defining an oracle.
Example 3. Consider the DL-LiteR KB O consisting of the axioms in the TBox:

Professor  TeachesTo
Student  HasTutor

TeachesTo

  Student

(4)
(5)
(6)

  Professor
HasTutor
Professor  Student
  TeachesTo
HasTutor

(7)
(8)
(9)

and the simple ABox:

Student(Paul)

HasTutor(Jane, Mary)

TeachesTo(Mary, Bill).

(10)

M. Knorr and J.J. Alferes

For checking satisfiability, we consider db(A) with db(A) = {Paul, Jane, Mary,
Bill} whose elements are all mapped to themselves, and the interpretation of
all concept and role names according to A, e.g., Studentdb(A) = {Paul} and
Professordb(A) = .

Then, we compute cln(T ) as follows.

Professor  Student
HasTutor
  Student
  Professor
TeachesTo

(11)
(12)
(13)

TeachesTo  Student
HasTutor  Professor

(14)
(15)

Axiom 11 occurs in T , Axiom 12 follows from (11) and (7), Axiom 13 follows
from (11) and (6), and (14) and (15) follow from (9) and (12), respectively (13).
The translation function  can be applied to each negative inclusion in cln(T ).

(TeachesTo

  Student) = x.(yHasTutor(y, x))  Student(x)

(Professor  Student) = x.Professor(x)  Student(x)
(HasTutor

(16)
(17)
  Professor) = x.(yTeachesTo(y, x))  Professor(x) (18)
(TeachesTo  Student) = x.(yTeachesTo(x, y))  Student(x)
(19)
(HasTutor  Professor) = x.(yHasTutor(x, y))  Professor(x)
(20)
Considering db(A) and the disjunction of first-order formulas resulting from
the translation yields a successful test for satisfiability.
If we want to verify, e.g., Student(Paul), then we extend O with A(Paul) and
A  Student resulting in O, update db(A) appropriately, and add three more
negative inclusions to cln(T ) resulting in cln(T ):
  A

HasTutor  A

A  Student

TeachesTo

These axioms can again be translated, and it can be verified that the resulting

check yields unsatisfiability. From this, we derive that Student(Paul) holds.

(TeachesTo

(A  Student) = x.^A(x)  Student(x)

  ^A) = x.(yTeachesTo(y, x))  ^A(x)
(HasTutor  ^A) = x.(yHasTutor(x, y))  ^A(x)

(21)
(22)
(23)
If we want to incorporate this into the top-down query procedure SLG(O),
then there are two possible ways for the concrete example. First, we may, e.g.,
query for Student(Paul) and the previously presented steps would derive this
from O alone, so that we would expect the empty answer for SLG(O). I.e.,
nothing needs to be added to O to derive the queried atom from O and an
unconditional answer is created in the tree for Student(Paul).

Alternatively, consider that the ABox is not present, but that, for simplicity,
the corresponding statements occur as rule facts as in Example 1. In this case,
we want the oracle to return a set of atoms, which if resolved prove the original
?

?

?
query. Clearly, we can derive Student(Paul) if the satisfiability test for O fails.
This is the case if one of the disjuncts in qdb(A)
unsat is satisfiable, e.g., if there is an x
such that Professor(x)  Student(x). Of course, it is counterintuitive to prove
that Paul is a student by showing that there is some other individual that is a
professor and a student, i.e., by deriving some inconsistency in the interaction
of O and the rules. Thus, all the disjuncts resulting from (16)(20), do not yield
meaningful derivations. Instead they yield derivations based on some general
MKNF-inconsistency, which is not possible in a partial oracle (cf. Definition 8).
However, if we resolve the disjuncts resulting from (21)(23) with A(Paul),
then we obtain more meaningful answers that can be used in the derivation tree
for Student(Paul). Namely, Student(Paul) itself is obtained, which is immediately discarded in SLG(O) since Student(Paul) is already a child in this tree,
and (yTeachesTo(y, Paul)) and (yHasTutor(Paul, y)) are also obtained as
possible children. Both do not contribute to the derivation of Student(Paul) it-
self, which is in fact obtained from the rule fact, but if we query for Student(Jane)
or Student(Bill), then in each case one of the two goals unifies with a fact in
the given rules.

The insights gained with this example can be formalized in the algorithm
(Fig. 2) that provides an oracle for DL-LiteR. We only have to formalize the
resolution step of the newly introduced query atom with each of the results of
applications of . The result of such a resolution step is either a ground (unary
or binary) atom or a binary atom with one existentially quantified variable.
To check whether adding this atom to O and the already derived information
remains consistent, we additionally introduce a uniform notion that turns the
new atom into DL notation.
Definition 13. Let O be a DL-LiteR KB,  an axiom in cln(T ), and () =
x.(C1  C2) such that H is unifiable with mgu5  with Ci, for some i, in ().
Then res((), H) is defined as (C2) if i = 1, and (C1) otherwise. The DL
representation resDL((), H) of res((), H) is defined depending on the form
of res((), H):

res((), H)

resDL((), H) =

(R)(a)
(R
)(a)

if res((), H) is a ground atom
if res((), H) = y.R(a, y) for ground a
if res((), H) = y.R(y, a) for ground a
We recall that assertions for complex concepts such as (R)(a) are represented
by A(a) and A  R for a new concept name A. This encoding may also affect
atoms appearing in I +Fn which is why we directly incorporate I +Fn into O in Fig. 2
to avoid a more complicated notation.
The algorithm itself proceeds as outlined in the example. It checks first whether
O together with the already proven true knowledge yields a satisfiable knowledge base. If not, the algorithm stops and returns the empty set; thus, O is not
5 most general unifier

M. Knorr and J.J. Alferes

Require: DL-LiteR KB O = (T ,A), which already contains I +Fn, and a ground atomic
query q = H(ti)
Ensure: a set L of Li such that O  Li |= H(ti) with O  Li consistent
L = 
qunsat = 
for all   cln(T ) do

qunsat = qunsat  ()
end for
unsat =  then
if qdb(A)
L = 

else
qinst = qunsat
= T  { A  H}
T 
= A  { A(ti)}
A
= (T ,A
O
for all   cln(T 
qinst = qinst  ()

)

) \ cln(T ) do

inst

=  then

end for
if qdb(A)
L = {}
for all   cln(T 

else

) \ cln(T ) do
= O  {resDL((), A(ti))}
) \ cln(T ) do

O
quns = qunsat
for all   cln(T 

quns = quns  ()
=  then

end for
if qdb(A )

uns

L = L  {res((), A(ti))}

end if
end for
end if
return L

end if

Fig. 2. Algorithm DL-LiteR Oracle

used for further derivations. Otherwise, it proceeds with an instance check for
the query, i.e., by checking for unsatisfiability of the extended knowledge base,
and, in the case of success, returns a set containing only the empty answer,
hence, an unconditional answer in the respective tree of SLG(O). If the instance check fails, then, for all newly introduced axioms in cln(T ), it is verified
whether resDL((), A(ti)) does not cause an inconsistency if added to O and
the already derived knowledge. If this is successful then the corresponding atom
res((), A(ti)) is included in the set of returned answers, which if proven true,
allow us to derive the considered query.
w.r.t. SLG(O).

We show that this algorithm provides a correct partial oracle for DL-LiteR
?

?

?
Theorem 2. The algorithm DL-LiteR Oracle is sound and complete, i.e., the
returned answers in L correspond to the definition of a partial oracle for DLLiteR and the algorithm allows the computation of all the minimal sets L according to the partial oracle for DL-LiteR.
L is consistent (Definition 8)
Proof. We consider OI +Fn
and q is the queried atom.

L |= q where OI +Fn

to the definition of a partial oracle for DL-LiteR.

We show soundness, i.e., we show that the returned answers in L correspond
If the algorithm returns L = , then O  I +Fn is not consistent, which means
that the result from the algorithm is sound for this case. Otherwise, if the algorithm returns L = {}, then the instance check for the query succeeds and in
this case (for consistent O  I +Fn as checked) O  I +Fn
|= q holds, which is also
a sound answer. Finally, if the algorithm returns L = {L1, . . . , Ln}, then the
 Li |= q
direct instance check failed, but O  I +Fn
holds because the addition of L to I +Fn would exactly enable the instance check
to succeed (see Theorem 1).

 Li is consistent and O  I +Fn

 L

 L

 L

 |= q and O  I +Fn

To show completeness, we have to show that the algorithm enables us to
compute all the minimal sets L according to the partial oracle for DL-LiteR.
First, if O  I +Fn is not consistent, then the partial oracle does not return any
answer and this is covered by the returned empty set L in the algorithm. Then,
if O  I +Fn
 L |= q holds for empty L, then the only minimal answer for the
partial oracle is the empty set. The algorithm DL-LiteR Oracle returns exactly
only the empty set. It remains to be shown that the correctness result holds
 is a nonempty minimal set such
for nonempty L as well. So suppose that L
that O  I +Fn
 is consistent. First, any minimal set
can only consist of one atom due to the restricted syntax of GCI in DL-LiteR.
 and q = H(ti) together with A  H and
Furthermore, joining O  I +Fn
A(ti) yields an inconsistent DL-LiteR KB O1, hence a successful instance check
, then the KB is consistent but the check
for q (Theorem 1). If we remove L
for consistency would still compute all axioms such that the boolean disjunctive
query quns w.r.t. O1 without L
 would be unsatisfiable as such, but satisfiable
, i.e., indicate a successful instance check. This is exactly what
upon addition of L
the algorithm DL-LiteR Oracle computes and, for consistent O  I +Fn
 is
returned as one of the answers. Note that none of the   cln(T ) is considered
since if one of these succeeds, the entire knowledge base is inconsistent. Thus,
considering only   cln(T ) \ cln(T ) suffices to find all possible sets L, since

res is applicable by construction in each such case.
Building on the results on computational complexity in DL-LiteR ([5]), we
can show that the algorithm ensures that the oracle is polynomial.
Theorem 3. Let K = (O,P) be a hybrid MKNF knowledge base with O in DL-
LiteR. An SLG(O) evaluation of a query q in the algorithm DL-LiteR Oracle is
decidable with combined complexity PTIME and with data complexity LOGSPACE.
Proof. We know from the proof of Theorem 43 in [5] that the combined complexity for computing the disjunctive formula using  on  in cln(T ) is polyno-

 L

, L

M. Knorr and J.J. Alferes

mial, while the evaluation w.r.t. db(A) is in LOGSPACE. Consequently, instance
checking and checking satisfiability for DL-LiteR is in PTIME and LOGSPACE re-
spectively. The algorithm DL-LiteR Oracle applies one such satisfiability check
for O  IFn and conditionally a further one for the instance check. Then, conditionally a set of (polynomially many in combined complexity) () is processed
(each in the worst case containing a further satisfiability check, which is a slight
extension of the first). We conclude that the combined complexity of DL-LiteR

Oracle is in PTIME and the data complexity LOGSPACE.

Intuitively, this result is achieved because GCI and RI are of a particular
restricted form, so that the oracle only returns single atoms, and does not need
to compute minimal subsets of arbitrary size in the power set of all atoms.

Consequently, we obtain the computational complexity of answering DL-safe
conjunctive queries in hybrid MKNF knowledge bases with a DL-LiteR DL part.

Theorem 4. Let K = (O,P) be a hybrid MKNF knowledge base with O in DL-
LiteR. Answering a DL-safe conjunctive query q in SLG(O) is decidable with
data complexity PTIME and LOGSPACE if P is empty.
Proof. This is a direct consequence of Theorem 5.4 in [1] and Theorem 3 and

the fact that, for nonempty P, PTIME from the rules includes LOGSPACE.
Hence, reasoning can still partially be done with relational databases.
Theorem 5. Let K = (O,P) be a consistent hybrid MKNF knowledge base
with O in DL-LiteR. The answer to a DL-safe conjunctive query q in SLG(O)
corresponds to the well-founded MKNF model.
?

?

?
Proof. The result follows from Theorem 5.3 in [1] and Theorem 2.
If K is MKNF-inconsistent, then there is no well-founded MKNF model, but
we obtain a paraconsistent approximation. Consider that the KB from Example
1 is part of a larger KB that is MKNF-inconsistent, but the inconsistency is
not related to the predicates shown in the example, i.e., no rule or GCI links
predicates from the example to those causing the inconsistency. Then, querying
for atoms from Example 1 yields the same results as if K was MKNF-consistent.

6 Conclusions

In [10] we provided a concrete procedure for KB with non-monotonic rules and
an ontology in the DL REL, a fragment of the DL underlying OWL 2 EL. This
slightly easier to obtain procedure relies, after preprocessing, on translating the
DL to rules rather than on defining an oracle in the true sense of [1] as done
here for DL-LiteR. We note that the resulting data complexity is identical, but
higher than the one for DL-LiteR, simply because it has a lower complexity
than REL in [10]. By translating the DL into rules, one can also easily obtain a
procedure for DLP [8]  the DL underlying OWL 2 RL.
?

?

?
With the results in this paper, query-answering procedures that do not jeopardize tractability are now available for MKNF KB with rules and ontologies
for the DL underlying all the three OWL2 profiles defined by W3C. As the
next step, we want to provide an implementation of our work, building on XSB6
and QuOnto/Mastro7. Moreover, OWL 2 QL has some expressive features not
contained in DL-LiteR and an extension is considered for future work.
