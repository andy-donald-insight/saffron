Inspecting Regularities in Ontology Design

Using Clustering

Eleni Mikroyannidi, Luigi Iannone, Robert Stevens, and Alan Rector

The University of Manchester

{mikroyannidi,iannone,stevens,rector}@cs.manchester.ac.uk

Oxford Road, Manchester, M13 9PL

Abstract. We propose a novel application of clustering analysis to identify regularities in the usage of entities in axioms within an ontology.
We argue that such regularities will be able to help to identify parts of
the schemas and guidelines upon which ontologies are often built, especially in the absence of explicit documentation. Such analysis can also
isolate irregular entities, thus highlighting possible deviations from the
initial design. The clusters we obtain can be fully described in terms of
generalised axioms that offer a synthetic representation of the detected
regularity. In this paper we discuss the results of the application of our
analysis to different ontologies and we discuss the potential advantages
of incorporating it into future authoring tools.

1 Introduction

Ontologies are often built according to guidelines or schemas that give rise to
repeating regularities in the use of entities in axioms. Recognising those regularities is important in understanding the ontology and assuring that it conforms
to the schemas. A regular ontology shows organisation of the knowledge and
thus its coherence. For example, in the wine ontology1, all the wines at the individual level are described in similar ways; they have a particular type of wine
and there are property assertions defining their body, origin, maker, flavour etc.
The inspection of these regularities can give an insight into the construction of
the ontology. By looking at the description of some wines, the user can have an
insight about the template that was used to describe them. Deviations from this
regular design might either be legitimate exceptions in the regularities or defects
in modelling. For example, the individual TaylorPort does not have any property
assertions referring to its origin, as this is defined on its type (Port SubClassOf
locatedIn value PortugalRegion). Having a mechanism that can help to isolate such
deviations could be a useful tool for quality assurance.

It is, however, difficult to trace irregularities and regularities by eye, especially
in big ontologies. The reasoner can check the satisfiability of concepts in the
ontology, and there are tools [9,5] that provide explanations for unsatisfiabilities

1 http://www.w3.org/TR/owl-guide/wine

L. Aroyo et al. (Eds.): ISWC 2011, Part I, LNCS 7031, pp. 438453, 2011.
c Springer-Verlag Berlin Heidelberg 2011
?

?

?
and other entailments. However, they cannot trace irregularities in the design as
these are not logical errors.

Ontology environments such as Prot eg e-4, Swoop, NeOn Toolkit and Top
Braid Composer provide some structural information about the ontology through
visualisations, such as hierarchies and panels showing the usage of the entities.
The task of spotting regularities in the usage of axioms in entity descriptions is,
however, not supported beyond this basic exposure of usage.

Ontology engineering has adopted the idea of design patterns [4] to capture
accepted modelling solutions to common issues [2,3]. Patterns of axioms, how-
ever, can exist throughout an ontology without being an accepted design pattern.
In this paper we focus on the general notion of patterns. In the remainder of the
paper we will refer to them as regularities. Such a regularity is illustrated in the
following axioms in the wine ontology:

1 = PinotBlanc EquivalentTo wine and

(madeFromGrape value PinotBlancGrape) and (madeFromGrape max 1 Thing)

2 = CabernetSauvignon EquivalentTo wine and (madeFromGrape value

CabernetSauvignonGrape) and (madeFromGrape max 1 Thing)

The regularity can be expressed with the abstract axiom:

 = ?xWine EquivalentTo wine and

(madeFromGrape some ?xGrape) and (madeFromGrape max 1 Thing)

where ?xWine = {PinotBlanc, CabernetSauvignon }, ?xGrape ={PinotBlancGrape, Caber-
netSauvignonGrape} are variables holding similar entities.

We present a novel framework for inspecting such regularities and clustering entities in the ontology according to these kinds of regularities. Clustering
is a common scientific approach for identifying similarities [13]. The proposed
method is based on capturing similar usage of the entities; such similar entities
are expected to result in the same cluster. The description of the clusters is provided in abstract forms; axioms containing meaningful placeholders (e.g. ?xWine
EquivalentTo wine and (madeFromGrape some ?xGrape) and (madeFromGrape max 1
Thing)). With such a framework, tools could help the inspection of regularities
when attempting to comprehend ontologies, where information on the design
style and schemas is often poorly documented and not represented explicitly in
the ontology itself.

Efforts for developing or transforming ontologies using patterns are reported
in [12], [2]. In [7], the use of the Ontology Pre-Processor Language (OPPL) as a
means of embedding knowledge patterns in OWL ontologies is presented. How-
ever, little work is known in the field of regularity detection in ontologies. In [11]
an analysis of collections of OWL ontologies with the aim of determining the
frequency of several combined name and graph patterns is described. However,
this work mainly focuses on lexical patterns, with some additional examination
on how these apply in the taxonomy hierarchy. It does not explicitly involve
identification of regularities in axiom usage. There appears to be no framework

E. Mikroyannidi et al.

that can identify regularities in the axioms of an ontology and highlight entities
that have been designed according to these regularities.

2 Clustering Framework

The purpose of cluster analysis is to divide data into groups (clusters) that are
meaningful, useful or both [13]. Our particular problem is to partition the set
of entities in an ontology according to their usage, i.e.: entities in the same
cluster occur with similar axioms playing similar roles. Cluster analysis relies
on the notion of distance to quantify how similar (or dissimilar) and, therefore,
how close or far apart two entities are in the clustering space. In the literature
there are several clustering techniques; we chose agglomerative clustering and
we report an informal description of the algorithm we used in Algorithm 1. In
our algorithm, the implementation of step 1, and in particular, the distance
adopted to compute the proximity matrix is the most important aspect of the
implementation and the main focus of the rest of this section; steps 27 are
typical steps for agglomerative cluster analysis and are not explained further.
However, in our implementation, the algorithm will continue agglomerating until
the distance between all possible pairs of elements in the two closest clusters is
less than 1.

Algorithm 1. Clustering algorithm
Require: A set of entities.
Ensure: A set of clusters.
1: Compute the proximity matrix {matrix containing the values of the distance be-

tween all entities}

2: Assign to the current set of clusters the set of singleton clusters, each representing

an input entity.

3: repeat
4: Merge the closest two clusters, replace them with the result of the merge in the

5:

current set of clusters.
Update the proximity matrix, with the new distance between the newly created
cluster and the original ones.

6: until The stopping criterion is met
7: return The current set of clusters.

In the approach taken here, the calculation of the distance is based on the similarity of the structure of the axioms in the ontology. For axiom comparison, we
transform them into a more abstract form following a place-holder replacement
policy. We will define the notion of similar structure of axioms more formally in
the following, and show how this leads to the particular distance we adopted for
our cluster analysis.

Comparing axioms: Let us consider the Pizza Ontology2. Its main scope is
pizzas and their toppings along with other information such as the country of

http://www.co-ode.org/ontologies/pizza/
?

?

?
origin for each pizza, the spiciness of some toppings, or their classification as
vegetables, fish, or meat. Among other things, in this ontology, we observe that
all the topping classes are used as fillers in axioms like:

aPizza SubClassOf hasTopping some aTopping
aPizza SubClassOf hasTopping only (aTopping or anotherTopping or . . . )
In other words, classes like MozzarellaTopping and TomatoTopping seem similar because they appear as fillers of an existential restriction on the property
hasTopping within a sub-class axiom where the left-hand side is a pizza. They
also appear as disjuncts in a universal restriction on the same property in another sub-class axiom whose left-hand side is, again, a pizza. Likewise, pizzas in
this ontology tend to appear on the left-hand side of sub-class axioms describing their toppings, base, and country of origin. Therefore, our cluster analysis
should, in the case of the pizza ontology, put together all toppings in a single
cluster, pizzas in another, and countries of origin in a third one and so on. More
formally, we need to introduce a distance that quantifies the difference between
the usage of two entities in a set of axioms (ontology).
Definition 1. [Place-holder replacement] Let O be an ontology and let  =
{owlClass, owlObjectProperty, owlDataProperty, owlAnnotationProperty,
owlIndividual, *} be a set of six symbols that do not appear in the signature3
of O - sig(O). A place-holder replacement is a function  : sig(O)  sig(O)  
satisfying the following constraints: Consider e  O then (e) =
 e or * or owlClass if e is a class name;
 e or * or owlObjectProperty if e is a object property name;
 e or * or owlDataProperty if e is a data property name;
 e or * or owlAnnotationProperty if e is a annotation property name;
 e or * or owlIndividual if e is an individual property name.

We define the particular placeholder replacement S as S(e)=

 owlClass if e is a class name;
 owlObjectProperty if e is an object property name;
 owlDataProperty if e is a data property name;
 owlAnnotationProperty if e is an annotation property name;
 owlIndividual if e is an individual property name.
Definition 2. [Place-holder replacement in axioms] Let O be an ontology,  
O one of its axioms and  a place-holder replacement function. We define Ax
as a function that for the input  returns a new axiom by applying  to all the
entities e  sig().
Example 1. Let our O be the Pizza ontology mentioned above and let us define
 as follows. e  O, (e)=
3 For signature here we mean the set of class names, data/object/annotation property
names, individuals referenced in the axioms of an ontology O.

E. Mikroyannidi et al.

 * if e  {Margherita, Capricciosa}4;
 S(e) otherwise;
Let us now compute the values of Ax() for some of the axioms in O
  = Margherita DisjointWith Cajun, Ax()= * DisjointWith owlClass;
  = Capricciosa DisjointWith Cajun, Ax()= * DisjointWith owlClass;
  = Margherita SubClassOf hasTopping some TomatoTopping,

Ax()= * SubClassOf owlObjectProperty some owlClass;

  = Capricciosa SubClassOf hasTopping some TomatoTopping,

Ax()= * SubClassOf owlObjectProperty some owlClass;

We have defined the replacement function that transforms the axioms into abstractions and we can proceed with the measure of the distance.

Distance measure: We define the distance function as follows:
Definition 3. [Distance] Let O be an ontology, e1 and e2 be two entities from
sig(O) and  a place-holder replacement function. We denote Ax(e) the set
{Ax(),   O, e  sig()}, i.e: the set of pace-holder replacements for the
axioms in O that reference e.

We define the distance between the two entities, d(e1, e2) as:

d(e1, e2) =

|(Ax(e1)  Ax(e2)|  |Ax(e1)  Ax(e2))|

|(Ax(e1)  Ax(e2)|

From this we can observe that O, , e1, e2 : 0  d(e1, e2)  1. The place-holder
replacement function  is a way to control the granularity of our distance.
Example 2. Let our O be the Pizza ontology again and let us define 1 as follows.
e  O, 1(e)=
 * if e  {TomatoTopping, PizzaBase};
 S(e) otherwise;
Let us now compute the values of 1Ax() for a pair of axioms in O
  = Margherita SubClassOf hasTopping some TomatoTopping,

1Ax() = owlClass SubClassOf owlObjectProperty some *;

1Ax() = owlClass SubClassOf owlObjectProperty some *.

  = Pizza SubClassOf hasBase some PizzaBase,
This means that d1(TomatoTopping, PizzaBase) < 1 as |Ax1(e1)Ax1(e2)| > 0
and, therefore, |(Ax1(e1)  Ax1(e2)|  |Ax1(e1)  Ax1(e2)| < |(Ax1(e1) 
Ax1(e2)|.

The consequence would be that our distance d1 does not separate as cleanly
as possible TomatoTopping (and likewise several sub-classes of PizzaTopping)
from PizzaBase. Let us now compare it with another place-holder replacement
function, 2, defined as follows:
4 The * placeholder represents entities, which distance is computed. We denote this
placeholder for keeping track of the position of the entities in the referencing axioms.
?

?

?
 * if e  {TomatoTopping, PizzaBase};
 e if e is a object property name;
 S(e) otherwise;

Then our 2Ax for the same values for  will be:

  = Margherita SubClassOf hasTopping some TomatoTopping,

2Ax() = owlClass SubClassOf hasTopping some *;

  = Pizza SubClassOf hasBase some PizzaBase,
2Ax() = owlClass SubClassOf hasBase some *

This will keep d2(TomatoTopping, PizzaBase) = 1

Changing the granularity of the place-holder replacement function produces
more or less sensitive distance functions. The two extremes are replacing every
entity with a place-holder or not replacing any of them. Whilst the former produces a distance that is far too tolerant and puts together entities that seem
unrelated, the latter will most likely result in a distance that scores 1 (maximal
distance) for most entity pairs. In this work we propose a tradeoff where we
delegate the decision of whether to replace an entity in an axiom to a measure
of its popularity with respect to the other entities in the same kind of axiom
within the ontology. More formally:
Definition 4 (Popularity). Let O be an ontology, e  sig(O) an entity. The
Ax for the axioms of O will extract the
place-holder replacement function S
structure of each axiom.

Given an axiom   O, let us define the set Ax = {  O, S
Ax() =
Ax()}, that is, the set of axioms in O that have the same structure as .
We can, finally, define popularity Ax of an entity f  sig(O)as

S

Ax(f) =

|{Ax,fsig()}|

|Ax|

that is, the number of axioms in Ax that reference f over the size of Ax

itself.

We can plug-in popularity as defined above into a place-holder replacement
function and therefore in our distance as follows: When computing a distance
between two entities, namely e1 and e2, for each axiom  where either occurs,
the function replaces e1 or e2 with * and decides whether to replace the other
entities with a place-holder depending on their popularity across all the axioms
that have the same structure as .
Definition 5 (Popularity based place-holder replacement). Let O be an
ontology, e  sig(O) an entity, and   O an axiom. Let Ax and Ax be respectively the set of axioms sharing the same structure as  and the popularity
metric defined in Definition 4. Finally, let  be a function that we call popularity criterion and maps a popularity value into the set {true, false}.

f  sig(O), we define our function as follows: 

e (f)

E. Mikroyannidi et al.

 * if f = e;
 f if (Ax(f)) = true;
 S(f) otherwise.

We can now use the popularity based place-holder replacement defined above
in our distance (Definition 3). Given two entities e1 and e2 according to the
formula we need to compute Ax(e1) and Ax(e2). For every axiom  in the
ontology O that references e1 (resp. e2), we compute Ax() = 
e1 Ax() (resp.
Ax() = 
e2 Ax()). Informally, for each axiom, we compute our replacement
function based on the popularity of the entities across the set of axioms sharing
the same structure as the axiom we are currently considering. In the definition
above we deliberately parameterised the decision criterion to make our distance
framework independent from any particular implementation. In this work, how-
ever, we compute a confidence interval [l, u] for the mean value of Ax. (95%
confidence). We assume the variance is unknown; therefore in order to compute the area under the distribution function (z), we use the values for the t
distribution, rather than the normal one in the formulas:
sd

u = M + z 

l = M  z 

sd

,

where with sd we denote the standard deviation and with M the mean computed on the set of entities (whose size is N) in the ontology. If the popularity
of a given entity is greater than u then we assign true to our  (see Definition 5),
false otherwise.
Example 3. Once again, let our ontology be the Pizza ontology and let us use
as our place-holder replacement function , the one in Definition 5 (based on
popularity). Let us compute the replacements for the same axioms as in Example 2. We omit the calculations but the confidence interval for the popularity
when applied to such axioms are such that the only entities which will not be
replaced are: hasTopping and TomatoTopping, therefore:

  = Margherita SubClassOf hasTopping some TomatoTopping,

1Ax() = owlClass SubClassOf hasTopping some *;

  = Pizza SubClassOf hasBase some PizzaBase,

1Ax() = owlClass SubClassOf owlObjectProperty some *.

The extensive usage of object property hasTopping in this particular kind of
axiom is the reason why our place-holder replacement function deems it as important and preserves it in the replacement result.

We observe, however, that deciding replacements based on confidence intervals is strongly dependant on the quality of the sample data. TomatoTopping,
for instance, in the example above, is judged popular too. The reason is that
all pizzas in the ontology have TomatoTopping (and MozzarellaTopping) among
their toppings. Conversely, the formula correctly spots that several other entities (Margherita, Pizza, hasBase, . . . ) are not relevant when dealing with axioms
presenting a particular structure (owlClass SubClassOf owlObjectProperty some
?

?

?
owlClass). We claim that this is preferable w.r.t. making an a priori decision,
maybe based on users intuitions, on what should be replaced and when.

Agglomerative hierarchical clustering: To complete the discussion of our
implementation for Algorithm 1, we need to illustrate how we update the distances in our proximity matrix at every agglomeration and what we use as
our stopping criterion. For the former we use the Lance-Williams formula (see
Section 8.3.3 in [13] - page 524). This formula computes the distance between
cluster Q and R, where R is the result of a merger between clusters A and B,
as a function of the distances between Q, A, and B. The distance between two
sets (clusters) is a function of the distance between their single elements. There
are several approaches to compute this, each corresponds to a different value
configuration of the coefficients in the general Lance-Williams formula. In the
experiments described in the following sections, we used the so-called centroid
configuration5.

As its stopping criterion, our implementation uses a heuristic decision:

Definition 6 (Agglomerate decision function). Let O be an ontology and d
a distance function. We define the function aggd : 2sig(O)  2sig(O)  {true, false}
as follows: Given E = {e1, e2, . . . , en} and F = {f1, f2, . . . , fm} be two clusters,
aggd(E, F ) =
 false if 1  i  n(1  j  m : d(ei, fj) = 1);
 true otherwise.

The algorithm terminates when no pair in the current set of clusters returns true
for the Agglomeration decision function aggd, defined above. When clustering
the Pizza ontology, our implementation returns 17 clusters containing over 110
entities in total; these include: a cluster for the toppings that are used in pizzas;
one for the named pizzas (pizza with a name and a description of their toppings);
and one for the country of origin of the toppings.

As intuitive these groups may seem, given the average familiarity people have
with the pizza domain, this represents a cluster analysis based on the actual
usage of the entities in the ontology. In this example clusters seem to follow the
taxonomy quite well, however, as we shall see in the next section this may not be
the case. Performing this kind of analysis can indeed reveal common use between
entities that are far apart in the taxonomical hierarchy.

Description of the clusters: Once the clusters are available, the axioms that
reference entities in the same cluster can be generalised and provide a more
abstract view on the entire cluster. We can define a generalisation as a simple
substitution of an entity with a variable within an axiom. More formally
Definition 7 (Generalisation). Let O be an ontology, E = {e  sig(O)} a set
of entities, and   O an axiom. Let us now choose a symbol (variable name),
5 Although vaguely related, not to be confused with a centroid in the K-means cluster

analysis - see Chapter 8 in [13].

E. Mikroyannidi et al.

say ?x. We generalise over E with ?x in  (g(, E, ?x)) when we replace every
element of E in  with ?x.

In the definition above, as well as in the remainder of the paper, we will borrow
the syntax for variables from OPPL6, a declarative language for manipulating
OWL ontologies [6]. However, for the purpose of this paper, it is sufficient to
say that an OPPL variable can be: Input or Non generated, i.e.: they can
replace entities in axioms of the corresponding type (there are OPPL variables
for each type of entity in a signature); Generated, i.e: their value is the result
of an expression depending on other variables.
Example 4 (Generalised Pizzas). Let O be our Pizza ontology and let cluster1 be
the cluster of all the toppings used in pizzas obtained using our cluster analysis
above, and cluster2 be the cluster of all pizzas. Given  = Margherita SubClassOf
hasTopping some TomatoTopping:

 g(, cluster1, ?cluster1) = Margherita SubClassOf hasTopping some ?cluster1;
 g(, cluster2, ?cluster2) = ?cluster2 SubClassOf hasTopping some TomatoTopping;

or composing the two

 g(g(, cluster2, ?cluster2), cluster1, ?cluster1) = ?cluster2 SubClassOf hasTopping

some ?cluster1
where ?cluster1 and ?cluster2 are two variables of type class. (In OPPL: ?cluster1

:CLASS, ?cluster2:CLASS).

Generalisations provide a synthetic view of all the axioms that contribute to
generate a cluster of entities. Each of these axioms can indeed be regarded as
an instantiation of a generalisation, as they can be obtained by replacing each
variable in g with entities in the signature of the ontology.

3 Results and Evaluation

Four ontologies (AminoAcid 7, OBI8, a module of the SNOMED-CT9 containing
axioms about hypertension and KUPO10) were selected for testing the clustering
framework; Table 1 summarises some results.

The AminoAcid ontology has been developed internally, allowing comments
on the clusters from the ontologys authors. The remaining ontologies are docu-
mented, enabling further analysis and evaluation of the clusters and regularities.
All of the selected ontologies preexisted the clustering framework. A quantitive
analysis was also performed on 85 ontologies from the BioPortal11 repository for

http://oppl2.sourceforge.net
http://www2.cs.man.ac.uk/ mikroyae/2011/
iswc/files/amino-acid-original.owl
http://purl.obolibrary.org/obo/obi.owl
http://www2.cs.man.ac.uk/ mikroyae/2011/iswc/files/
sct-20100731-stated Hypertension-subs module.owl
http://www.e-lico.eu/public/kupkb
http://bioportal.bioontology.org/
?

?

?
Table 1. Clustering results on the four selected ontologies

Ontology name No of Clusters No of Clustered entities Cluster coverage per

generalisation (%)

AminoAcid

SNOMED-CT
?

?

?
77 (84%)

2832 (70%)
470 (44%)
420 (80%)
?

?

?
which clusters were computed in less than 3 minutes. The framework was tested
with the asserted information of the ontologies, for analysing the regularities of
their construction.

The number of clusters in Table 1 shows that in most cases more than 50%
of the entities in the ontologies were clustered. In principal, the union of the
generalisations describes the cluster, thus a single generalisation might not be
necessarily applicable for all the values in the cluster. However, in all four ontologies the majority of the values in a cluster is covered by a single generalisation
(cluster coverage percentiles in Table 1).

The results in all of the ontologies are of similar impact and can be found in
detail online12. In this section, however, we will highlight some cases from each
ontology.

Inspecting regularities: We detected regularities in all four ontologies and we
evaluate them by referring to their documentation or ontology authors. In OBI
ontology, ?cluster7 includes 47 T cell epitopes of specific type that are equivalent
classes. The structure of the definition of these terms is similar. To demonstrate
this regularity we will consider two classes from ?cluster7, the epitope specific
killing by T cells and the epitope specific T cell activation. These classes appear
on the left hand side of the axioms:

 = epitope specific killing by T cells EquivalentTo T cell mediated cytotoxicity

and (process is result of some MHC:epitope complex binding to TCR)

 = epitope specific T cell activation EquivalentTo T cell activation

and (process is result of some MHC:epitope complex binding to TCR)

The generalisation for these axioms is:

g() = cluster7 EquivalentTo ?cluster8 and (process is result of some cluster91)
where ?cluster8 = {T cell mediated cytotoxicity, T cell activation},
?cluster91 = {MHC:epitope complex binding to TCR}

?cluster8, ?cluster91 are placeholders for the corresponding classes, while the
object property process is result of does not belong to any cluster, thus it is not
represented by a placeholder.

In [10], a methodology for developing analyte assay terms in OBI using a template based on spreadsheets is described. The clustering framework, gave such a

http://www2.cs.man.ac.uk/~mikroyae/2011/iswc/

E. Mikroyannidi et al.

cluster of classes (cluster35) and their descriptions in the form of generalisations
highlighting their commonalities. For example, there are 13 axioms in cluster35
covered by the following generalisation, which describes the analyte assays that
are used to achieve a planned objective:

g() = ?cluster35 SubClassOf ?cluster117 some ?cluster16
Example instantiation:  = genotyping assay SubClassOf achieves planned objective

some sequence feature identification objective

In [8] the design process of the KUP ontology is explained and two main
patterns are described for generating the cell types in the ontology. The results
of the clustering framework showed such clusters of cells and clusters of classes
used as fillers of the properties describing the cells (e.g. participates in, part of).
Two example generalisations capturing these regularities are:

1. g() = ?cluster13 EquivalentTo ?cluster27 and (part of some ?cluster2),
where ?cluster13, ?cluster27, ?cluster2 : CLASS, ?cluster27 = {cell}
Example Instantiation:
 = bladder cell EquivalentTo cell and (part of some bladder)
2. g() = ?cluster1 SubClassOf (participates in some ?cluster16) and (participates in

some ?cluster19), where ?cluster1, ?cluster16, ?cluster19 : CLASS

Example Instantiation:
 = kidney interstitial fibroblast SubClassOf (participates in some cytokine production)

and (participates in some extracellular matrix constituent secretion)

Each one of these generalisations corresponds to a different cluster in the
ontology. Also, these regularities were described in [8]. The first regularity is encapsulated in the description of the first pattern and the second regularity is encapsulated in the description of the second pattern. Additional regularities were
also detected that refer to longer conjunctions of the previous generalisations (e.g.
a conjuction of part of relationships on the right hand side of the axiom).

In addition, the clustering framework gave an alternative view based on the
similar usage of the entities in the ontology. It could selectively reveal repeating
structures in the ontology that were more difficult to inspect manually. For
example, in SNOMED the highlighted classes of Figure 1(a) are grouped in the
same cluster and their similar definition is given by the generalisation of Figure
1(b). However, the inspection of regularities through navigation in the class
hierarchy is not an easy task because of the high level of nesting and complexity
of the hierarchy. The form of regularity of Figure 1(b) is also described in the
technical guide of the ontology [1](section 17.2.2., page 180).

Fully covered generalisations: As it has been shown in Table 1 a single
generalisation does not necessarily apply to all of the values in the cluster.

However, there are cases that an individual generalisation can be applicable
to all values of its cluster. Such an example is shown in Figure 2, taken from
?

?

?
Generalisation:

g() = ?cluster18 EquivalentTo ?cluster4

and ?cluster6
and (RoleGroup some
((?cluster10 some ?cluster2)
and (?cluster74 some ?cluster16)))

where

?cluster6, ?cluster18, ?cluster4, ?cluster2,

?cluster16 : CLASS

?cluster10, ?cluster74 : OBJECTPROPERTY.

Example Instantiation:

 = SCT 79537002 EquivalentTo SCT 118681009

and SCT 387713003
and (RoleGroup some
((SCT 260686004 some SCT 129284003))
and (SCT 363704007 some SCT 113331007)))

SCT 79537002: Operation on endocrine

system (procedure)

SCT 118681009: Procedure on

endocrine system (procedure)

SCT 387713003: Surgical procedure (procedure)

SCT 260686004: Method (attribute)

SCT 129284003: Surgical action (qualifier value)

SCT 113331007: Procedure site (attribute)

SCT 113331007: Structure of endocrine

system (body structure)

(b) Generalisation and example instantiation of ?cluster18

(a) Classes of ?cluster18 as shown in
Prot eg e class hierarchy view. The similar entities do not appear to be siblings
in the class hierarchy.

Fig. 1. View and description of entities of cluster18 in SNOMED hierarchy

the AminoAcid ontology. The first generalisation covers more than one axiom
corresponding to a single entity in ?cluster1 (an example instantiation is shown
in Figure 2). All the amino acids in the ontology are described following the
same template, expressed by the set of 4 generalisations of Figure 2, abstracting
202 axioms. This is a clear indication of the impact the abstraction can achieve
when trying to comprehend the ontology. The information that describes these
entities is gathered in one place and expressed in a synthetic and meaningful
way. That is, because each variable represents a cluster of entities. For example,
the ontology engineer by looking the instantiation of the first generalisation
understands that cluster5 holds all the physicochemical properties of the amino
acids and cluster2 holds all the fillers of these properties.

An analysis of the generalisation coverage and axiom coverage for 85 ontologies from BioPortal is presented in Figure 3(a) and Figure 3(b) respectively. The
results of Figure 3 show that there are ontologies, which have cluster coverage
higher than 30% and in many cases the average number of instantiations per generalisation exceeds 20. It should be marked that most of the ontologies that have

E. Mikroyannidi et al.

Values:

?cluster1 : CLASS
?cluster1 = {Alanine, Arginine, Aspartate,
Cysteine, Glutamate, Glutamine, Histidine,

Isoleucine, Leucine, Lysine, Methionine,

Phenylalanine, Proline, Serine, Threonine,

TinyAromaticAminoAcid, Tryptophan,
Tyrosine, Valine, Glycine}

Example Instantiations:
f or the value ?cluster1 = {Alanine}
1.Alanine SubClassOf hasSize some Tiny
Alanine SubClassOf hasSideChainStructure

some Aliphatic

Alanine SubClassOf hasCharge some Neutral
Alanine SubClassOf hasPolarity some Non-Polar
Alanine SubClassOf hasHydrophobicity

Generalisations:
1.?cluster1 SubClassOf ?cluster5 some ?cluster3
2.?cluster1.IRI?cluster7constant

some Hydrophobic

2.Alanine label Alanine

3.Alanine SubClassOf AminoAcid

3.?cluster1 SubClassOf AminoAcid

4.DisjointClasses: Alanine, Cysteine, Aspartate,

4.DisjointClasses:set(?cluster1.VALUES)

Glutamate,Phenylalanine, Glycine, Histidine,

where ?cluster3 : CLASS,

Isoleucine,Lysine, Leucine, Methionine,

?cluster7 : ANNOTATIONPROPERTY,

Asparagine, Proline, Glutamine, Arginine, Serine,

?cluster5 : OBJECTPROPERTY

Threonine, Valine, Tryptophan, Tyrosine

Fig. 2. Values, generalisations and example instantiation of ?cluster1 in the AminoAcid
Ontology

a high cluster coverage percentile they also have a high average number of instantiations per generalisation. For example, in ontology 34 the cluster coverage
per generalisation is 87% and the average number of axioms per generalisation is
560. These cases show that very few generalisations can summarise big number
of axioms and can give an inclusive description of the clusters in the ontology.

Inspecting irregularities: In the example of Figure 2, we notice that a possible
value of ?cluster1 is the TinyAromaticAminoAcid. This value is covered only by
the third generalisation. The axioms describing this class are:

1. TinyAromaticAminoAcid EquivalentTo AminoAcid and hasSize some Tiny
2. TinyAromaticAminoAcid SubClassOf AminoAcid
The second axiom is redundant causing the TinyAromaticAminoAcid class to
result in the same cluster with the amino acids. By removing this axiom, the
TinyAromaticAminoAcid no longer is a value of ?cluster1. This irregularity is a
design defect.

However, there were cases that entities were not included in a cluster because
their description was a deliberate exception in the regularity. E.g., in SNOMED,
the Surgical insertion - action (qualifier value) is not included in cluster16 as it is
not used in a regular axiom like the Transplantation - action (qualifier value):

 = Transplantation (procedure) EquivalentTo Procedure by method (procedure) and
(RoleGroup some (Method (attribute) some Transplantation-action (qualifier value))),
g() = ?cluster30 EquivalentTo Procedure by method (procedure) and (RoleGroup some

(?cluster74 some ?cluster16)))
?

?

?
(a) average cluster coverage per generalisation

(b) average instantiations per generalisation

Fig. 3. Graph showing selected clustering results for 85 ontologies in BioPortal

Values:

?cluster6 : CLASS
?cluster6 = {SmallHydrophilicAminoAcid,
SmallHydrophobicAminoAcid,

SmallNonPolarAminoAcid, SmallPolarAminoAcid,
SmallPositiveAminoAcid},
Generalisation :
g() = ?cluster6 EquivalentTo ?cluster2 and ?cluster9
where cluster2, cluster9 : CLASS

Example instantiation:

 = SmallPositiveAminoAcid EquivalentTo

Values:
?cluster8 = {TinyHydrophobicAminoAcid,
TinyNonPolarAminoAcid, TinyPolarAminoAcid}
Generalisation :

g() = ?cluster8 EquivalentTo AminoAcid

and (?cluster5 some ?cluster10)
and (?cluster5 some ?cluster3)
where ?cluster3 = {Tiny (CLASS)}
?cluster5 : OBJECTPROPERTY,

?cluster10 : CLASS.

Example instantiation:

PositiveChargedAminoAcid and SmallAminoAcid

2 = TinyPolarAminoAcid EquivalentTo

AminoAcid and hasSize some Tiny
and hasPolarity some Polar

Fig. 4. Values, generalisations and
example instantiation of ?cluster6 in
the AminoAcid Ontology

Fig. 5. Values, generalisations and
example instantiation of ?cluster8 in
the AminoAcid Ontology

To evaluate the sensitivity of the framework, we edited regular axioms of the
ontologies to check if these can be identified by the algorithm. In the AminoAcid
ontology these irregularities already existed. In particular, cluster6 and cluster8
include equivalent classes in the ontology, which are used to categorise the amino
acids according to their chemical properties. The equivalent classes are grouped
into different clusters according to their regular usage and description. In Figures

E. Mikroyannidi et al.

4, 5 the description of cluster6 and cluster8 is presented respectively. Cluster6
includes small amino acids with an additional chemical property. On the other
hand, cluster8 has a different design from this of cluster6 (e.g. it would be expected
to be  =TinyPolarAminoAcid EquivalentTo TinyAminoAcid and PolarAminoAcid). For
preserving a regular design in the ontology, the terms of cluster8 are transformed
similar to the design of terms of cluster6. This change has an impact on the
clustering; the number of clusters is decreased, but these are more homogenous.
For the rest of the three ontologies, we removed 2 axioms that appear to have
a regularity and check if the clustering framework corresponded to these changes.
All the entities of which regular axioms were modified were discarded from their
initial cluster because the regularity no longer existed.

4 Conclusions and Future Work

We presented a framework for identifying regularities and clustering the entities
in an ontology according to these regularities. The application of the approach to
4 ontologies detected regularities that were expected to be found. These findings
we confirm and evaluate through access to the ontology authors or the published
documentation from the ontologys authors. The framework also provided an alternative presentation of an ontology based on its regularities, giving an insight
about the major components of its construction. The generalisations provided
a meaningful abstract form of axioms, in which each variable was representing
a cluster of similar entities. This abstraction has potential as a tool for comprehension of an ontology, as it manages to summarise axioms in a coherent
way. The method tended to give good coverage of an ontologys axioms within
clusters, suggesting that it could show the significant portions of the ontology.
The analysis on the BioPortal ontologies also highlighted such cases. That not
all axioms are clustered is also meaningful; not all axioms can be part of regularities and those that do not cluster can indicate deviations from a style or
simply deliberate authoring techniques. Either reason could be informative to a
person comprehending an ontology.

The evaluation showed that changing regularities affected clustering results.
Altering referencing axioms of entities that belonged to a cluster either caused
them to be regrouped in a different cluster or their exclusion from any clus-
ter. This shows the method to be sensitive to changes and a potential tool for
helping authors to  tidy up their ontology. Future work will include the development of plugins for the Prot eg e editor for supporting the development process
dynamically through access to these features.

The inspection of regularities in known ontologies helped us to derive knowledge patterns when they existed. We expect that the further exploitation of the
generalisation forms and the examination of possible combinations of these can
lead to the induction of patterns in the ontology (e.g. like the pattern describing
the amino acids in Figure 2). Future work will also involve alternative decisions
of a transformation policy and of a clustering algorithm. Although the current
implementation, which is based on a popularity transformation, produced adequate results, it will be worth examining other techniques that can generate
?

?

?
homogenous and well defined clusters. The inspection of regularities in known
ontologies helped us to derive knowledge patterns when they existed.

Our use of a basic clustering approach has a demonstrable use in finding regularities and irregularities in an ontology. It has potential for offering authors a
means to gain generalisation of the major portions of an ontology; to detect deviations from a given style of representation and to facilitate the comprehension
of what can be large and complex logical artefacts. As ontologies using OWL
can be large and complex, the provision of techniques to manage this complexity,
especially when attempting to understand an ontologys construction, should be
an important addition to an ontology authors toolbox.
