Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : h t t p : / / w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Provenance-based reproducibility in the Semantic Web

Luc Moreau

Electronics and Computer Science, University of Southampton, Southampton SO17 1BJ, UK

a r t i c l e

i n f o

a b s t r a c t

Article history:
Available online 21 April 2011

Keywords:
Provenance
Reproducibility
Denotational semantics
Primitive environment

Reproducibility is a crucial property of data since it allows users to understand and verify how data were
derived, and therefore allows them to put their trust in such data. Reproducibility is essential for science,
because the reproducibility of experimental results is a tenet of the scientific method, but reproducibility
is also beneficial in many other fields, including automated decision making, visualization, and automated data feeds. To achieve the vision of reproducibility, the workflow-based community has strongly
advocated the use of provenance as an underpinning mechanism for reproducibility, since a rich representation of provenance allows steps to be reproduced and all intermediary and final results checked
and validated. Concurrently, multiple ontology-based representations of provenance have been devised,
to be able to describe past computations, uniformly across a variety of technologies. However, such
Semantic Web representations of provenance do not have any formal link with execution. Even assuming
a faithful and non-malicious environment, how can we claim that an ontology-based representation of provenance enables reproducibility, since it has not been given any execution semantics, and therefore has no formal way of expressing the reproduction of computations? This is the problem that this paper tackles by
defining a denotational semantics for the Open Provenance Model, which is referred to as the reproducibility semantics. This semantics is used to implement a reproducibility service, leveraging multiple Semantic Web technologies, and offering a variety of reproducibility approaches, found in the literature. A series
of empirical experiments were designed to exhibit the range of reproducibility capabilities of our
approach; in particular, we demonstrate the ability to reproduce computations involving multiple tech-
nologies, as is commonly found on the Web.

O 2011 Elsevier B.V. All rights reserved.

1. Introduction

The envisaged applications of science and technology are far
reaching, from Government personalised services for the citizen1
to personalised medicine,2 from understanding climate change, to
its tackling by smart energy usage [1]. Technology is revolutionising
the way scientists undertake science, as illustrated by Grid Computing [2], e-Science [3], or the Fourth Paradigm [4]. While science is
becoming computation and data intensive, the fundamental tenet
of the scientific method remains unchanged: experimental results
need to be reproducible [5].

The fundamental principle of reproducibility is particularly
important given the importance of science in our life. This importance is illustrated by the scientific advice on climate change that
has helped shape governmental policies. The mail controversy of
the Climatic Research Unit Climate-Gate3 highlights how global

E-mail address: l.moreau@ecs.soton.ac.uk

1 http://www.telegraph.co.uk/technology/news/7484600/Every-citizen-to-have-

personal-webpage.html

the impact of science has become. As a result, calls for more transparency in climate science have been issued; specifically, a parliament committee called for the release of both the raw data and
the computer code used in research.4 This is in no way limited to climate science: in social science, evidence-based policy refers to
public policy that is informed by rigorously established objective
evidence [6]. Similar calls exist for transparency in clinical trial results used in drug approval.5 It is no surprise that novel initiatives
[7] and recommendations [8] that encourage the publication of
data sets are emerging. These are steps in the right direction, but
by themselves, they do not ensure reproducibility of scientific
results.

Provenance refers to the source or origin of something. In a
computational setting, provenance of a data item is an explicit representation of the processes that led to that data item [9]. The
workflow-based scientific community has strongly advocated the
use of provenance as an underpinning mechanism for reproducibil-
ity: reproducibility requires rich provenance information, so that
researchers can repeat techniques and analysis methods to obtain

4 http://blogs.nature.com/news/thegreatbeyond/2010/03/parliament_

2 http://www.futuremedicine.com/doi/abs/10.2217/17410541.5.1.55
3 http://en.wikipedia.org/wiki/Climatic_Research_Unit_email_controversy

committee_calls_for.html

5 http://www.sciencebasedmedicine.org/?p=215

1570-8268/$ - see front matter O 2011 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2011.03.001

scientifically similar results . . . In order to support reproducibility,
workflow management systems must capture and generate provenance information as a critical part of the workflow-generated data.
[10]. The strong belief that provenance can support reproducibility
is also echoed by the provenance community, with more than 20
papers cited by a recent survey on provenance [11] mentioning
reproducibility in their abstract.

To relate reproducibility to provenance, various approaches
have emerged in which provenance is defined in the context of
specific execution semantics. Why-provenance [12] and lineage
[13] identify source tuples that contributed to a result returned
by a database query (within the relational and xml models). By
applying the same query to such source tuples, the result could
be reproduced. Souilah et al. [14] define a denotation of provenance in the context of a p-calculus variant: this denotation can replay the sending and receiving of data values across processes.
Cheney et al. [15] define a notion of traces faithful to a program
if they record enough information to recompute the program when
the inputs change; this definition is proposed in the context of the
Nested Relational Calculus, which is a core database query lan-
guage, also capturing aspects of functional languages, and distributed programming systems such as MapReduce [16]. Similarly,
Acar et al. [17] assume the existence of a common language that
can express both database queries and workflows, and in this con-
text, define a provenance graph to be consistent with a program if
it matches the evaluation traces generated by the program. In
workflow systems, the Virtual Data Systems [18] view provenance
as consisting of two components: all the aspects of the procedure
or workflow for creating a data object (referred to as prospective
provenance), and the information about the runtime environment
in which these procedures were executed (retrospective prove-
nance), the combination of both offering reproducibility. By means
of a translation from provenance to its workflow language [19],
Taverna is also able to reproduce past results.

All of these approaches have in common strong assumptions
that they make on the execution environment(s) in which the
application is executed: they assume it is a given database engine,
workflow system, or distributed programming environment. But
such assumptions are not aligned with the reality of Web applica-
tions, which typically involve multiple different technologies, with
different underpinning semantics, hosted by different providers.

In a previous paper [11], the author articulated the Open Provenance Vision, consisting of architectural guidelines to support
provenance inter-operability on the Web, by means of open mod-
els, open serialization formats and open APIs. As envisaged in the
Open Provenance Vision, the provenance from individual systems
or components can be expressed, connected in a coherent fashion,
and queried seamlessly. Several models for provenance have
emerged to tackle this vision, including Provenir [20,21], the Provenance Vocabulary [22], PASOA [23], OPMV [24], PML [25] and the
Open Provenance Model [26]. All rely on Semantic Web definitions,
consisting of ontologies, vocabularies or abstract models. Assuming that provenance based on these models was generated faithfully and non-maliciously, how can it be claimed that provenance
enables reproducibility, given that there is no execution semantics attached to these models? This is precisely the problem that this paper
tackles, offering a definition of reproducibility for the Open Provenance Model (OPM) [26].

Several provenance approaches (by Cheney et al. [15], Souilah
et al. [14], Acar et al. [17], and Missier and Goble [19]) have in common the idea that provenance can be seen as a program, for which
an executable semantics can be defined. Hence, using provenance
as a program, one can re-execute past computations, and reproduce results. In this paper, we leverage this idea and formalize it
for OPM, while still ensuring that OPM remains independent of
any technology used in the application execution environment.

To address this problem, this paper offers the following

contributions:

1. Adopting a Semantic Web perspective to the problem, we
extend the Open Provenance Model with minimum executional
information and assumptions related to execution. In particular,
we introduce the class of primitive procedures and the notion of
primitive environment that maps such primitive procedures to
something that can be executed. OPM processes are themselves
caused by primitive procedure invocations.

2. We present

the reproducibility semantics, a denotational
semantics for OPM graphs. This mathematical (and therefore
technology independent) definition formulates how an OPM
graph can be seen as a mathematical function, taking some
inputs and a primitive environment, and resulting in another
OPM graph. This semantics is novel because it tackles a substantial subset of OPM, and in particular, its notion of account.
With this semantics, we also identify a class of OPM graphs that
are reproducible, and at the same time recognize that not all
OPM graphs are by default reproducible. Specifically, we define
a provenance graph as reproducible, if combined with a primitive environment, it contains enough information to be interpreted as a program (or workflow) whose execution can yield
an isomorphic provenance graph. Furthermore, this mathematical formulation also allows us to specify variants of reproduc-
ibility, which help us provide formal groundings for other
reproducibility proposals found in the literature.

3. We propose a Semantic Web based architecture for a reproducibility service, which can take OPM graphs and check their repro-
ducibility. This architecture, which relies on an extended OWL
ontology for OPM, SWRL rules, and a set of SPARQL queries, is
intended to act as a reference implementation for the reproducibility service.

4. We provide an evaluation of the approach by demonstrating: (i)
how the reproducibility service is capable of reproducing the
results of the First Provenance Challenge [27]; (ii) how the
reproducibility service can easily be customized to invoke multiple execution technologies, such as command line and Web
services, simply by changing its primitive environment; and
(iii) how it can be used with different inputs.

This work is significant for several reasons. First, Semantic Web
provenance languages are defined in terms of an ontology, but do
not have an execution semantics; with this work, we establish that
such provenance data models can and should also be interpreted as
executable programs. Second, from a provenance perspective,
approaches such as OPM have been criticised as lacking formal
foundations, and therefore, leading to incompatibility and misinterpretation [28]; the formal semantics presented in this paper
addresses these concerns head on. Third, OPM, itself, contains
original features, such as accounts, which have never been forma-
lised. This paper provides an original way of formalizing them; in
particular, it identifies a set of conditions required to be met for
provenance claims in different accounts to be consistent.

There is no strong consensus on what reproducibility means,
and how it can be achieved. Hence, we start by surveying related
work, by providing several definitions of reproducibility, and explain how this work compares against them (Section 3). We then
introduce the reproducibility semantics in Section 4, first considering account-less OPM graphs, and then multi-account OPM graphs.
Next, we study the idea of a reproducibility service in the context
of the Semantic Web, overview its architecture, and discuss the
Semantic Web techniques that we leveraged for its implementation (Section 5). We then undertake a range of empirical evaluations aiming to demonstrate the capability of the reproducibility
service, and its suitability for deployment in a multi-technology

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

environment such as the Web (Section 6). This is followed by a discussion of the approach (Section 7) before we conclude the paper
and summarize possible future work (Section 8). Beforehand, we
summarize the OPM terminology.

2. OPM terminology in one paragraph and figure

We assume that the reader is familiar with the OPM specification [26]; a tutorial on OPM is also available from openprove-
nance.org/tutorial. The following example acts as a reminder for
the OPM terminology. Fig. 1 illustrates an OPM graph describing
the evaluation of a numeric expression (10 + 20) 
 30/9 resulting
in value 100. Ovals represent artifacts and are here associated with
numeric values; black rectangles denote processes. Plain edges
represent data derivations (referred to as was-derived-from
dependencies); dotted edges represent the dependencies between
processes and artifacts, denoting the consumption of the latter by
the former (used edges) or the generation of the latter by the former (was-generated-by edges); they are annotated by their roles in
bracket. Gray post-it rectangles are annotations. The OPM specification [26] also introduces a notion of inference by which novel
edges can be inferred from existing edges of an OPM graph. For in-
stance, p3 used a6, which itself was derived from a5, itself also derived from a1 and a2. So, we can infer that p3 used a1 and a2
indirectly. Likewise, it can be inferred that a6 was derived from
a1 and a2 indirectly. Finally, OPM edges that have not been inferred
are said to be asserted.

3. Related work

In this section, we first review several definitions of reproduc-
ibility. We then discuss work on reproducibility that is not provenance specific, before focusing on provenance based approaches.
Finally, given that our work consists of a novel formalization of
OPM, we review extant efforts in that field.

3.1. What is reproducibility?

There is no strong consensus on what reproducibility means in
the context of computational science or computer-based systems.
Wikipedia defines reproducibility6 generally as follows: Reproducibility is one of the main principles of the scientific method, and
refers to the ability of a test or experiment to be accurately repro-
duced, or replicated, by someone else working independently to
see if the reproduced experiments gives similar results to those
originally reported. Wikipedia further contrasts reproducibility
from repeatability,7 which measures the success rate in successive
experiments, possibly conducted by the same experimenters.
Reproducibility relates to the agreement of test results with different
operators, test apparatus, and laboratory locations.

In computer systems, experiments are encoded as programs or
workflows [10] that, like recipes, describe the various steps of exe-
cution, and can be executed time and time again. In computer sys-
tems, however, extensive logs of past activities, which we will refer
to as provenance, can provide an accurate description of what
occurred in the past, and can be used to reproduce experiments:
the difference is that reproduction can be based on the logs, rather
than the recipe.

Bechhofer et al. [29] see the need for a framework that facilitates the reuse and exchange of digital knowledge. They put forward the idea of Research Objects as containers for a principled

6 http://en.wikipedia.org/wiki/Reproducibility
7 http://en.wikipedia.org/wiki/Repeatability

Fig. 1. OPM graph for numeric expression.

aggregation of resources, produced and consumed by common services and shareable between scientists. In this context, they distinguish the following terms:

 Repeatability: relies on sufficient information for the original
researchers or others to be able to repeat the study. This may
involve access to data or execution of services.

 Reproducibility of a result consists of starting with the same
materials and methods and checking if a prior result can be con-
firmed. It is a special case of repeatability, since it contains complete information such that a final or intermediate result can be
verified.

 Replayability allows the investigator to go back and see what
happened. It does not necessarily involve execution or enactment of processes and services. It places a requirement on provenance of data.

From the above definitions, it is not entirely clear whether Bechhofers repeatability and reproducibility draw on the original recipe or
provenance of a past execution, or a combination of both. On the
other hand, replayability seems to rely explicitly on provenance.

In their classification of provenance requirements, Miles et al.
[30] identify a use case (Use Case 17) that distinguishes reenact-
ment, i.e., performing the same experiment, but using contemporary data and services, from repetition, which means performing
the same experiment with the same data and services as before,
e.g., to test that the results can be reproduced. Whilst framed in
the context of provenance, reenactment seems to apply equally
to provenance and workflows.

So, reproducibility is a multi-dimensional problem, where
several issues need to be taken into consideration: (i) which
scripts?: is this workflow or provenance based reproducibility?
(ii) which inputs?: is the experiment reproduced with the same
inputs or others? (by inputs, we include not only experimental
data, but also parameters); (iii) which primitives?: are the original primitives or services invoked? (iv) which results?: are intermediary and final results comparable to the original ones? In
this paper, we fix the first dimension, focusing on provenancebased reproducibility, while considering all other dimensions of
the problem.

3.2. Reproducibility without provenance

Reproducibility has initially been researched without taking
provenance into consideration. We review some salient outcomes,
before focusing on provenance-based reproducibility.

Claerbout pioneered the concept of really reproducible research,
An article about computational science in a scientific publication is
not the scholarship itself, it is merely advertising of the scholarship.
The actual scholarship is the complete software development environment and the complete set of instructions which generated the fig-
ures. [31].

This pioneering approach has led to the more recent ReDoc [32],
a system for reproducing scientific computations in electronic doc-
uments. It consists of three components, makefiles, make rules and
naming conventions. Such an environment is akin to a workflow
system, where the workflow script is a makefile, which can be executed over any input. It however does not describe a past execution
and how a past result was achieved. But this shows that under the
term reproducibility, one can find two very different understand-
ings: regenerate a result by applying a recipe on arbitrary inputs vs
reproduce all the steps found in an evidence of a past execution.
In forensic investigations, a key factor is reproducibility, defined
as the ability to achieve a consistent level of quality throughout the
investigative process, no matter how many times it is repeated under the same conditions [33]. Pan and Batten [33] propose a model
based on read and write operations, and associated timestamps,
allowing them to be ordered in a linear time flow. This model is
targeted to forensic investigations and is not aimed to generic com-
putations. An alternative approach, which is provenance-based, is
proposed by Levine and Liberatore [34] and discussed in Section
3.3.

Similar ideas, though not referred to as reproducibility, have already been developed in the context of digital preservation formalization [35]; for instance, rerunning past programs over past data
over different machines, with potentially different hardware, can
be achieved by means of emulators.

Stodden [36] defines reproducibility as the ability of others to
recreate and verify computational results, given appropriate software and computing resources. Stodden investigates the legal
impediment to scientific reproducibility, and proposes a reproducible research standard. We do not denigrate the importance of legal
issues, but this article only focuses on the technical aspects of
reproducibility.

space of visualization pipelines created for a given exploration
task. Vistrails adopts an action-based provenance model, intended
to help reproducibility. We conjecture that the reproducibility
capability is based on replaying such actions, but the authors do
not include an explicit description of how such functionality can
be achieved outside the context of Vistrails itself. Koop et al. [40]
discuss the problem of managing upgrades of tools and libraries,
while still being able to run a previous computation in a new envi-
ronment; this work is specifically focused on the Vistrails system
and methods necessary to automatically update workflows and
provenance.

Mesirov [5] proposes a Reproducible Research System (RRS),
consisting of two components. The first is the Reproducible Research Environment (RRE), which provides computational tools together with the ability to automatically track the provenance of
data, analyses, and results and to package them (or pointers to persistent versions of them) for redistribution. The second element is a
Reproducible Research Publisher (RRP), which is a documentpreparation system, such as standard word-processing software,
that provides an easy link to the RRE.

Cheney et al. [15] provide an operational semantics for the
Nested Relational Calculus (NRC) that generate traces, intented to
capture the execution history of a query. Such a notion of trace is
a representation of provenance which is directly inspired by the
syntax of NRC constructs. They define properties of such traces
and NRC programs, such as consistency and fidelity. A trace is said
to be consistent to a program, if it is an explanation of what happened when the program was evaluated. Fidelity is the property
that holds when the trace records enough information to recompute a program when the inputs change.

The provenance approaches that have been reviewed in this
section are all grounded in a specific execution environment.
Hence, because of their dependencies to a specific technology or
execution semantics, they fail to meet a key requirement of the
Open Provenance Vision [11] for provenance on the Web. Alternative provenance definitions are ontology-based and not specific to
an execution technology: Provenir [20,21], the Provenance Vocabulary [22], PASOA [23], OPMV [24], PML [25], and the Open Provenance Model [26]. None of them, however, has been given a
semantics that is suitable for reproducibility purpose. This is a
shortcoming that we address for OPM in this paper. This work
complements other endeavours aiming to provide a formal underpinning to OPM, which we survey in the following section.

3.3. Provenance-based reproducibility

3.4. Formal definitions of OPM

Davidson and Freire explain that a key benefit for maintaining
provenance of computational results is reproducibility: a detailed
record of the steps followed to produce a result allows others to
reproduce and validate these results [37]. Specifically, with an explicit representation of provenance, so-called provenance queries
can be expressed to identify all the data objects and the sequence
of steps that have been used to produce a result [38].

Levine and Liberatore [34] seek to improve the reproducibility
and comparison of digital forensic evidence. They propose a simple
canonical description of digital evidence provenance that explicitly
states the set of tools and transformations that led from acquired
raw data to the resulting product. This provenance representation
allows for the comparison and the reproduction of results. Inspired
by the principle of N-version programming, their approach allows
multiple tools/libraries to be used to reproduce a result, thereby
increasing the confidence that can be put in investigations.

Silva et al. [39] argue about the importance of reproducibility in
visualization. Leveraging the Vistrails systems, they exploit the
provenance it generates to ensure that users will be able to reproduce the visualizations and let them easily navigate through the

Moreau et al. [41] provide a set-theoretic definition of OPM, as
well as an illustration of how an abstract machine execution can
generate OPM-based provenance traces. The mapping from execution to OPM graphs is not formally characterized, and no attempt is
made to provide a converse mapping. In the subsequent version,
Kwasnikowska et al. [42] provide a temporal interpretation of
OPM graphs, defined as the set of temporal inequalities implied
by its edges. OPM inferences combined with graph patterns are
shown to be sound and complete with respect to inferences that
can be made over graph interpretations. This temporal interpretation does not provide an understanding of OPM from an execution
perspective either.

Cheney [43] investigates the use of structural causal models as a
semantics for provenance graphs, and relates some OPM concepts
to notions of actual cause and explanation proposed by Halpern
and Pearl [44,45]. At some level, the semantics we propose here
bears some similarity to Cheneys since it is also a denotation of
a provenance graph, i.e., it sees a graph as a mathematical function,
resulting in a new provenance graph. In practice, they differ for
several reasons: (i) our semantics conforms to OPM v1.1 and in

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

particular handles OPM accounts, whereas Cheneys is account-less
and regards single-step derivation edges as inferrable, when they
can only be asserted in OPM; (ii) our semantics builds on the
Semantic Web philosophy, where globally unique names are
meant to capture well understood concepts (in this case, primi-
tives), which are explicitly captured within a notion of primitive
environment; (iii) Cheneys semantics attempts the more ambitious goal of providing a global approximation (using the predictive nature of causal models) for the program being executed
(without having its explicit code), so that its behaviour can be repeated for any arbitrary input; (iv) our semantics allows us to explore and characterize variants of reproducibility.

Missier and Goble [19] address the question of whether, for any
OPM graph, there exists a plausible workflow in the Taverna workflow language, which could have generated the graph. To this end,
they identify the extra information that should be captured as part
of an OPM graph so that the mapping from OPM to a workflow representation can be derived. Whilst this work focuses on some specificities of the Taverna workflow language, such as the implicit
iterator semantics, it is similar in spirit to ours, since it derives
an executable semantics for OPM. In their case, it is obtained by
composing their translation to the Taverna semantics [46]. It however does not tackle OPM in full, ignoring accounts, and does not
define reproducibility itself.

Various ontological definitions of the Open Provenance Model
have emerged. The OPM toolbox8 supports bidirectional conversions between XML and RDF serializations, respectively, defined
according to an XML schema and an OWL ontology [47]. This ontology was inspired by the OWL definition compatible with the OPM
implementation of Tupelo9 [48]. During the third provenance chal-
lenge, the Tetherless team also defined an OPM OWL ontology.10

As part of the W3C Provenance Incubator activity [49], mappings of multiple provenance ontologies to OPM were defined
[50]. These mappings showed that concepts such as processes, arti-
facts, and agents can be mapped quite naturally between the mod-
els. The mappings however do not characterize the computational
implications associated with those models, and do establish
whether reproducibility is preserved during translation across
models.

4. Reproducibility semantics

In this section, we specify the reproducibility semantics for OPM
graphs, which we define as the mathematical meaning of an OPM
graph, seen as a program and whose execution results in a new
OPM graph. First, we study reproducibility in account-less OPM
graphs (Sections 4.2, 4.3, 4.4) and then in multi-account graphs
(Sections 4.5 and 4.6).

4.1. Intuition of the reproducibility semantics

Before delving into the technical details of a denotational
semantics, we provide some intuition of how we propose to reproduce the execution on an OPM graph. We assume that each process
in an OPM graph is annotated with the name of a primitive, and
that there is a primitive environment that maps primitive names
to actual functions, which in a first approximation take some inputs and produce some outputs. Here, function arguments are
not identified by their position in a sequence of arguments but
by their roles; likewise, outputs can be multiple and are identified
by their role.

Fig. 2. Account-less OPM graph.

The inputs of an OPM graph are all the artifacts for which there
is no was-generated-by edge; its outputs are all the artifacts that
are not adjacent to a used edge; intermediary artifacts are those
that are not inputs or outputs. Given an acyclic OPM graph, we assume the existence of a function that returns a list of all its pro-
cesses, sorted by order of execution: by this, we mean that a
process in the sorted list does not use any artifact generated by a
process that is subsequent in the list.

Reproducibility is formalized by a recursive function that traverses the sorted list of processes, executing each of them in turn.
Execution of a process is achieved by invoking its associated primitive function on the values of artifacts (paired with roles) it uses,
and results in values (also paired with roles), for which new artifacts are created. The reproducibility function constructs a new
OPM graph at the same time, describing the re-execution of the
graph. The new graph is initialized with the set of input artifacts
(with the same value as in the original graphs, or different values,
depending on the kind of reproducibility one wants to achieve).
Each process execution adds the process and the output artifacts
it generated, and all associated edges with roles, where appropri-
ate. Each function of the primitive environment not only results
in artifacts for given inputs, but also in a set of was-derived-from
edges, which are added to the newly produced graph.

For comparing the original graph and the new graph, but also
for book-keeping, a mapping from nodes of the original graph to
those of the new graph is constructed. It allows us to check
whether all nodes have been mapped, and whether they have the
same associated values. Furthermore, in the case of multi-account
OPM graphs, the mapping allows us to decide whether we are processing a node that has already been encountered.

So, in summary, the reproducibility semantics is expressed by a
function that takes a set of input artifacts (with their associated
values), a primitive environment, and an input graph, and returns
a mapping and a new OPM graph, which describes the reexecution
of the input graph, and a mapping. We now formalize this
semantics.

4.2. Preliminary definitions

First, an account-less OPM graph is defined in terms of its constituents in Fig. 2, before its semantics is formalized in Section 4.3.
An account-less OPM graph consists of a set of nodes and a set of
edges. Nodes can be artifacts or processes,11 whereas edges are

8 http://openprovenance.org
9 http://twiki.ipaw.info/pub/Challenge/OpenProvenanceModelBindings/opm.owl
10 http://twiki.ipaw.info/bin/view/Challenge/TetherlessPC3

11 As in [41], we ignore agents in this paper, since their role as catalyst does not
directly affect computational reproducibility.

of four permitted types. Artifacts and processes, respectively, belong to primitive sets Artifact and Process. Fig. 2 and following figures are a stylised representation of a Standard ML encoding of the
reproducibility function available for download.12

Artifacts are associated with values (belonging to a primitive set
of values), whereas each process is associated with the name of a
primitive, whose invocation resulted in this process. The association is defined by the mappings AResolver and PResolver. A FullOPMGraph then refers to an OPMGraph accompanied by the artifact and
the process resolvers.

The OPM graph of Fig. 1 can be formalized by Gv 14 G;Va;Vp as

follows:

G = h{a1,a2,a3,a4,a5,a6,a7,p1,p2,p3}, {used(p1,summand1,a1), used
(p1,summand2,a2), wgb(a5,out,p1), used(p2,factor1,a3), used(p2,fac-
tor2,a5), wgb(a6,product,p2), used(p3,divisor,a4), used(p3,dividend,a6),
wgb(a7,quotient,p3), wdf(a5,a1), wdf(a5,a2), wdf(a6,a3), wdf(a6, a5),
wdf(a7,a4), wdf(a7,a6)}i.
Va 14fa1; 10;a2; 20;a3; 30;a4; 9;a5; 30;a6; 900;a7; 100g
Vp 14fp1; prim : sum; p2; prim : mult; p3; prim : divg:

In this graph, a1, a2, a3, a4 are inputs and a7 is an output,

whereas the other artifacts a5 and a6 are intermediary artifacts.

In order to define a reproducibility function, some topological
constraints are introduced on OPM graphs. Ways of relaxing these
constraints are discussed further in Section 7.

Definition 1 (Reproducibility graph constraints).

1. Well formed: OPM graphs are supposed to be well-formed as per
OPM v1.1 [26]: an artifact can be generated by at most one pro-
cess, and there exists no cycle formed of edges of type was-
derived-from.

2. Acyclic: For the purpose of the reproducibility semantics, we
assume that an OPM graph is fully acyclic, i.e., no cycle can be
formed with any edge.

3. Sortable: From the acyclicity property, we can derive an ordered
list of processes such that the invocation of a process in the list
does not require the outputs of any subsequent processes in the
list. Furthermore, we assume the existence of sortProcesses, a
function13 that can returns this ordered list of processes.

4. No was-triggered-by: We assume that there is no edge was-trig-

gered-by.

5. Role unicity: We also assume that inputs and outputs are
uniquely identified by a role, for a given process: for any edges
used(p,r,a1), used(p,r,a2), then a1 = a2; likewise, for any edges
wgb(a1,r,p), wgb(a2,r,p), then a1 = a2. h

Our formalization relies on partial maps, mapping roles to some
set (e.g., role-values or role-artifacts). For instance rv 2 Role ? Va-
lue. Given a role r 2 DOM(rv), then rv(r) denotes the value associated with r. For convenience, our notation also allows for such a
partial map to be seen as a finite sequence of role-value pairs
PRoleValue, over which we can perform a map operation. Finite
sequences are represented with the SML list notation x::x.

with primitives, which essentially produce some output values for
some input values. In OPM, values (whether input or output of a pro-
cess) are associated with a role. Hence, primitives take sets of rolevalue pairs, and produce sets of role-value pairs (cf. Fig. 3, line 2).
Furthermore, edges of type was-derived-from (wdf) need to be
asserted and cannot be inferred (cf. OPM specification [26] for
the definition of OPM inference and [42] for its characterization).
The only component that has knowledge of such dependencies is
the primitive itself. So we expect a primitive not only to return a
set of role-value pairs, but also which was-derived-from dependency exists between which output (identified by its role) and
which input (similarly identified). Such a pair of roles, an element
of EdgeSpec (cf. Fig. 3, line 4), can be used to reconstruct the appropriate was-derived-from edge in the resulting graph. The intent of
the type InvocationResult is similar, except that it refers to role-arti-
fact pairs rather than role-value pairs (cf. Fig. 3, line 5).

Reproducing an OPM graph results in a new OPM graph. There
is some mundane activity involved in constructing such a new
OPM graph: how should artifacts and processes be created? Hence,
we assume the presence of factories: given a node from the old
graph and the current new graph that we are in the process of
building, such a factory results in a new node and a new OPM
graph containing that node (lines 810). Parameterizing the reproducibility function by such factories allows us to consider a range
of options, such as the resulting graph has the same nodes as the
original or the resulting graph has fresh nodes.

Finally, to be able to compare the results of the reproduced
computation and the original results (whether final or intermedi-
ary), we introduce a mapping function that maps nodes of the original graph to nodes of the resulting graph. The pair of mappers
AMapper and PMapper is conveniently referred to as Mappers (cf.
Fig. 3, lines 13).

The reproducibility function has a signature of type Reproduce
(cf. Fig. 3, lines 1618). Given a graph factory (i.e., how we construct nodes), a primitive environment, an input OPM graph and
some input artifacts, a reproducibility function must produce a
resulting OPM graph and mappings from the input graph to the
output graph. Such a reproducibility function recursively traverses
the input graph, reproducing the invocation of every primitive; to
this end, it relies on an auxiliary function of type Execute, reproducing the invocation of a single process (cf. Fig. 3, lines 1214).

Having defined all the necessary sets, the reproducibilitysemantics can be expressed as in Fig. 4. The reproducibility-seman-
tics is captured by function reproduce1 of type Reproduce, which relies on the auxiliary function reproduce2 to recursively execute
each process of its input graph Gv
1.

The auxiliary function reproduce2 relies on execute to invoke
primitives, and for each such invocation, ensures that new edges
of the appropriated type are accumulated in the graph Gv
2.

The auxiliary function execute of type Execute invokes a primi-
tive, as per defined in the primitive environment E and extends
its input graph Gv with new artifacts and processes, created with
the respective factories. It also ensures that the mappers are suitably extended with new mappings and valuations for the process
and its output artifacts.

4.3. Reproducibility of an account-less OPM graph

4.4. A definition of reproducibility

Key to reproducibility is a definition for each of the primitives referred to by processes of an OPM graph. To this end, we introduce
the concept of a primitive environment associating primitive names

In this section, we show that the reproducibility function can be
applied to any OPM graph, but it does not always terminate, or it
results in a different graph. Hence, we define here what we mean
by a reproducible graph. First, we define role-value map equality.

12 http://eprints.ecs.soton.ac.uk/21992/
13 The function sortProcesses selects a deterministic order of processes, when it does
not exist in the graph.

Definition 2 ( Role-value map equality). Two role-value maps rv
2r for
and rv
any r 2 DOMrv

2 are equal if DOMrv

1 14 DOMrv

1. h

2 and rv

1r 14 rv

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

Fig. 3. Reproducibility in a single account.

Graph equality up to mapping is satisfied if graphs are isomorphic and have the same values for corresponding nodes. For
completeness, formalization is provided as follows.

2;Vp

2 14 G2;Va

1 14 G1;Va
Definition 3 (Graph equality up to mapping). Let Gv
1;
Vp
2 be two full OPM graphs. Let M be a pair
1 and Gv
hMa;Mpi of bijections such that their domains are the nodes in G1
and their range the nodes in G2. Two graphs Gv
2 are equal up
to mapping M, noted
1MGv
Gv
2 ;
if the following conditions hold:

1 ; Gv

2Maa.
2Mpp.

 For any a 2 G1; Va
1a 14 Va
 For any p 2 G1; Vp
1p 14 Vp
 For any edge hn1,n2i 2 G1 (or h n1,r,n2i 2 G1), hMn1;Mn2i 2 G2
(or hMn1; r;Mn2i 2 G2).
 For every edge hn0
2i 2 G2 , there exists hn1,n2i 2 G1 such that
1; n0
hMn1;Mn2i 14 hn0
2i
1; n0
edges with
roles). h

(and likewise,

for

Graph equality up to mapping implies that graphs have the
same artifacts and processes (up to naming), the same used and
was-generated-by edges connecting processes and artifacts, and
similar was-derived-from edges linking artifacts.

Having specified a reproducibility function in Fig. 4, we can now
define the notion of a reproducible graph as follows. A graph is reproducible if, given the same inputs, the reproducibility function produces another graph that is equal up to the mapping between
nodes, for a given primitive environment. In other words, we define
a provenance graph as reproducible, if combined with a primitive
environment, it contains enough information to be interpreted as a
program whose execution can yield an isomorphic provenance graph.

Definition 4 (Reproducible graph). Let Gv
1 be an OPM graph. Let
F a;F p be artifact/process factories; let E be a primitive environ-
ment,
1. Let
M2; Gv

let inGv
1 be the values of
input artifacts in Gv
2 14 reproduce1 F a; F p E Gv
1 is reproducible in E, if the following holds:
The graph Gv
1M2Gv

Gv
2 :

1 inGv
1.

We observe that the reproducibility function may not be de-
fined, for different reasons, which we now discuss and illustrate
with simple examples pertaining to Fig. 1. (i) An incomplete set
of inputs is provided: e.g., {(a1,10), (a2,20), (a3,30)}. (ii) Inputs or
intermediary results are not in the domain of some primitives:
e.g., {(a1,10), (a2,20), (a3,30), (a4,0)}. (iii) Incorrect number of in-
puts, incorrect roles or incorrect types are provided to a primitive;
e.g., for primitive environment mapping prim:sum to the unary log
function. We note that some of these failure reasons can be
checked statically without re-executing primitives, if primitive signature and arity are available.

Based on Definition 4, for given factories and primitive environ-
ment, we can identify the class of reproducible OPM graphs. We
note that not all graphs are reproducible. For instance, the OPM
graph of Fig. 1 is no longer reproducible with a primitive environment associating p3 to the addition operation, since the graph
output would be 909 instead of 100. Likewise, if a primitive returns
different was-derived-from edges, the graph is not reproducible
either. If the primitive environment maps p1 to prim:sum defined
rv(summand1) + rv(summand2)i, {hout,summand1i,
as
hout,summand2i}i, or to the primitive ignoring its arguments
hkrv.hout,30i,{}i, generated artifacts will have the same values as
their original counter-parts, but graph topologies will differ. Hence,
with the latter primitive environment, the graph is not reproducible for such primitive definition.

hkrv.hout,

Definition 4 is related to Cheneys pointwise approximation
[43]; a pointwise approximation of a graph is a function that returns the same outputs (and intermediary results) when provided
with the same inputs. Definition 4 generalizes this notion by mandating that the graph topology be preserved. It assumes that a
same primitive environment is used to compute the original graph
and the reproduced graph (hence, performing a consistency check
[15]). The reproducibility function however allows other primitive
environments to be used to reproduce computation (such as
upgraded libraries [40]); we discuss the opportunities these present in Section 6.

In Section 5, we investigate the implementation of this semantics in a reproducibility service. Beforehand, we focus on reproducibility in the more general multi-account graphs. In this context,
we establish a property of reproducible graphs.

Fig. 4. Reproducibility semantics.

4.5. Multi-account OPM graphs

So far, we have tackled account-less OPM graphs.

In this
section, we provide a definition of multi-account graphs with a
view of defining the associated reproducibility semantics. Fig. 5
displays a definition of a multi-account graph MAccOPMGraph.
It is a triple consisting of a set of accounts, a partial function
mapping an account to an OPM graph, and a refinement func-
tion.

Fig. 5. Multi-account OPM graph.

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

Fig. 6. A multi-account OPM graph. q a0 p1 = a1, q a0 p2 = a2 with a0: black, a1: red, a2: blue. (For interpretation of the references to colour in this figure legend, the reader is
referred to the web version of this article.)

With this definition, the set of accounts known to a MAccOPMGraph is given by the first component of the triple. For each ac-
count, the multi-account OPM graph provides us with one OPM
graph.

The third component of a MAccOPMGraph is a refinement func-
tion, which is a partial function capturing a specific form of refine-
ment, corresponding to process nesting due to procedural
abstraction. A process is allowed to be refined into a subgraph (it-
self consisting of processes and artifact and associated edges); if
p is the process, a the account in which p occurs, the subgraph
must correspond to an account, say a0. In that case, the refinement
function q is such that qap = a0.

To be well-formed, a multi-account graph needs to satisfy some

constraints, as follows.

formed multi-account graph). Let G 2 MAc
Definition 5 (Well
cOPMGraph be the triple (a, C,q). The graph G is well-formed, if
the following constraints hold:

 for any account a 2 a, then C(a) is defined;
 for any account a 2 a and process p, if qap is defined, then p is a

process in graph C(a).

We note that q is not necessarily defined for all processes in all ac-
counts, meaning that some processes are not
refined into
subgraphs.

A FullMAccOPMGraph includes artifact and process resolvers,
mapping them to values and primitive names, respectively. Two
OPM graphs in a multi-account OPM graph overlap if they share
some artifact or process. We note that these resolvers are defined
for a FullMAccOPMGraph, meaning that an artifact or a process is
associated with a single value for all the accounts of the graph.
The reason for this design decision is that we seek to define a
reproducibility function, and we see accounts as a mechanism that
provides multiple levels of details about a same execution.

To enable the definition of a reproducibility function, we set
some strict constraints on the refinement function. To help their
formulation, we introduce a relation between accounts.

Definition 6 (Descendant). Let G 2 MAccOPMGraph be the triple
(a,C,q). Let a1, a2 be two accounts of G, the account a2 is said to be
a descendant of a1, noted a1 / a2, if qa1p = a2 for some p belonging
to C(a1). We use E to denote the reflexive, transitive closure of /.
Beyond well-formedness, a graph must satisfy constraints to
ensure that it can be evaluated by the reproducibility function.
These constraints do not exist in the original OPM specification. In-
stead, they reflect the view that each account can be interpreted
like a detailed execution trace of a single process.

refinement constraints). Let G 2 MAccO
Definition 7 (Account
PMGraph be (a,C,q). Account refinements form a hierarchy,
without sharing, that satisfies the following constraints:

i = 0, . . . , n  1) and an = a0, for any process pi and n P 1.

 Acyclic: there is no sequence a0, . . . ,an where ai / ai+1 (for
 No account sharing: let qa1p1 = a2 and qa3p2 = a4. We have that
a2 = a4 if and only if a1 = a3 and p1 = p2.
 No process sharing: for any distinct accounts a1, a2 in a, C(a1)
and C(a2) do not have any common processes.
 Consistent generation: if there are edges wgb(a,r1,p1) in C(a1) and
wgb(a,r2,p2) in C(a2), then a1 E a2 or a2 E a1.
 Sortable: for any account a in G, let hp0, . . . , pn1i = sortProcess-
es(C(a)), then if qapi = ai and qapj = aj, if i < j, then (graphOut-
puts(C(aj)) [ graphInterm(C(aj))) \ graphInputs(C(ai)) = ;.
 Input preserving: for any account ai in G, an input artifact a in
graphInputs(C(ai)) cannot be generated in an account aj, where
ai E aj.
 Output preserving: outputs of a process that is refined in an
account must be generated in a refinement of that process. h

The above properties are purely syntactic, constraining the
topology of a multi-account OPM graph. In addition, the following
property refers to the primitive environment.

Definition 8 (Refinement consistency). An artifact generated by
two processes in different accounts requires the corresponding
primitive to produce the same value. h

Fig. 7. Reproducibility of a multi-account OPM graph.

Taken together, Definitions 7 and 8 provide a set of conditions
that OPM graphs need to satisfy, for provenance claims in different
accounts to be consistent, in the context of a given primitive
environment.

Fig. 6 contains a multi-account graph, with a toplevel account
a0 represented in black. Process p1 is refined into account a1, represented in red, whereas process p2 is refined into account a2 represented in blue.14 In other words, a0 / a1 and a0 / a2. This graph
satisfies the account refinement constraints of Definition 7. Indeed,
the descendant relationship is acyclic and forms a tree strictly. The
graphs C(a0), C(a1), C(a2) overlap over artifacts but not processes.
Artifact a2 was generated by p1 in C(a0) and by p3 in C(a1), with

14 For interpretation of color in Fig. 6, the reader is referred to the web version of
this article.

a0 / a1 (and similarly for a3). Processes in C(a0) can be sorted as
hp1,p2i, and inputs of C(a1) (i.e., a1, a4) are not outputs or intermediaries of C(a2). Artifact a1 is an input in C(a0) and in the refinement C(a2). Finally, artifacts a2 and a3, generated, respectively,
by p1 and p2 in C(a0), are also generated in the refinements a1
and a2.

In this graph, we see that the refinement C(a1) can have more
inputs than process p1: this is the essence of abstraction,
in
C(a1), details of the computation can be revealed, when they were
hidden in a0. Likewise, C(a1) can have more outputs than process
p1. Furthermore, a5, an output of C(a1) is allowed to be used as input of C(a2), despite being absent in graph C(a0).

So far, our discussion of this graph has been independent of the
primitive environment. We can see that the graph satisfies Definition 8: if p1 and p2 are associated with primitives subtracting 10
and 2, respectively, and p3 and p4 are both associated with the

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

division primitive, then we see that for the input values (a1 = 14,
a4 = 3), p1 and p3 both assign value 4 to a2 (and similarly, for a3).

4.6. Reproducibility of a multi-account OPM graph

for a given account and input artifacts,

Fig. 7 displays the reproducibility semantics for multi-account
OPM graphs, expressed by a function of type MAccReproduce. Provided with the appropriate graph factories and a primitive environ-
ment,
takes a
FullMAccOPMGraph and returns another FullMAccOPMGraph and
a set of mapper functions. The account provided as input is the account in which computation needs to be reproduced. Mappers can
now map accounts of the original graph to accounts in the resulting graph; account mappings are noted Ma. Likewise, factories
comprise a factory for accounts; account factories are noted F a.

it

The reproducibility semantics is expressed by function repro-
duce4, invoking the recursive function reproduce3 after initializing
a FullMAccOPMGraph acting as an accumulator. The function reproduce3 uses a breadth-first strategy to reproduce a multi-account
graph. Its third argument lists all accounts, at the current level,
which need to be reproduced, whereas its fourth argument enumerates all direct descendant accounts, which will be iterated over,
at the next level. The function reproduce3 relies on reproduce2 (de-
fined in Fig. 4) iteratively reproducing each account (and its
refinements).

To ensure that nodes are properly shared across accounts in the
resulting graph, we rely on the following operator, defining a factory function that creates a new artifact only for those that have
not been mapped yet.

F a n Ma 14 kxG:


Max;fMaxg [ G
F a x G otherwise:

 if Max  ?;

We also introduce a combining operator, that takes the union

of two functions, preferring the first over the second.
h1 ] h2 14 kx:

if h1x  ?
h1x
h2x otherwise:

After reproducing the current account a, the function reproduce3
ensures that all accounts that are direct descendant of a, noted a,
are also given the current set of artifact values, Va
2, as a
way of resolving the refinements inputs; likewise, any remaining
accounts at the same level have their inputs extended in the same
way. Referring to the example of Fig. 6, this ensure that a5 is provided as an input to account a2, after completion of evaluation of
account a1.

2  Ma

We note that the reproducibility function may be provided with
inputs that differ from those that were used in the original execu-
tion. For instance, the graph of Fig. 6 may be executed with inputs
(a1 = 100, a4 = 10) and the same primitive environment, but would
result in a2 being assigned two different values. Hence, the reproducibility function is not defined for such a graph, these inputs and
primitive environment. However, if p1 (and likewise p2) was assigned to primitive div10, dividing its input by 10, then this
inconsistency would not occur.

The following lemma summarizes a key property of the reproducibility function. If a graph G2 is the result of the reproducibility
function for a given primitive environment, G2 is itself reproducible
in that environment.

Lemma 1. For any primitive environment E, for any factory F , for
any multi-account graph G1, for any resolvers Va
1, and for any
input h1, if
reproduce4 F E a; h1 G1;Va
and

1 14 M1; G2;Va

2;Vp

1; Vp

1;Vp

3;

3;Vp

2 14 M2; G3;Va

1a; h2 G2;Va
2;Vp
1v if h1(x,v), then

reproduce4 F E Ma
where h2Ma
1x 14 Va
G2M2G3:
Sketch of proof: we proceed by induction on the ordered list of processes in G2, and the current level of refinement. At each step, we
can establish that the same primitive is applied to the same inputs,
generating new output artifacts and edges G3 which correspond to
those in G2. Furthermore, given that G2 was itself generated by
reproduce4, it does not contain any edge that was not produced by
application of a primitive. Hence, the resulting graph G3 is equal
to the original graph G2 up to mapping.

5. Semantic web and reproducibility

In this section, we investigate how to leverage the reproducibility semantics of Section 4 in order to define a reproducibility service for the Semantic Web. First, we outline an architecture for a
reference implementation of this service. Then, we survey the
Semantic Web techniques that are exploited in this implementa-
tion. Finally, we summarize the assumptions underlying OPM
graphs for reproducibility in the Semantic Web.

5.1. Reproducibility service architecture

Fig. 8 displays the architecture of a reproducibility service. It
consists of four key components: (i) the reproducibility engine,
which implements the reproducibility semantics of Section 4; (ii)
a triple store containing representations of the OPM graph to repro-
duce, and of the OPM graph being generated, and semantic declarations of primitives; (iii) the primitive environment, which maps
primitive names to actual primitives; (iv) the execution engines,
which are implementations of the primitive. We now discuss them
below.

The reproducibility engine implements the reproducibility
semantics. Given an OPM graph, it extracts processes in their invocation order (as specified by dependencies). Each process is annotated with a primitive name.

For instance, in the First Provenance Challenge [27] workflow
(discussed in Section 6), process p1 results from the activation of
the primitive prim:align_warp.

@prefix opm: http://openprovenance.org/ontology#
@prefix prim: http://openprovenance.org/

primitives#

@prefix pc1: http://www.ipaw.info/pc1/

pc1:p1 opm:annotation pc1:an1_p1.

pc1:an1_p1 a opm:Annotation;
opm:property pc1:pr_9.

pc1:pr_9 a opm:Property;

opm:uri prim:primitive;
opm:value prim:align_warp.

Each primitive name is associated with an implementation of
that primitive by the primitive environment. For instance, the default environment contains a mapping from prim:align_warp to
the name http://openprovenance.org/reproducibility/swift#align_-
warp, which is itself mapped to an implementation procedure in
the execution engine. We have developed two types of execution
engines, inline in the Java virtual machine, or delegated to the command line by means of the Swift workflow engine [51].

Swift encompasses Swift script, a declarative language allowing
the type of procedures to be declared, as well as the necessary

the header files are explicitly declared with roles hdr and hdrRef,
but are not passed explicitly to the executable align_warp since it
derives them automatically by replacing the extension img by hdr.
So far, within an OPM graph that we wish to reproduce, we find
an explicit representation of processes and annotations indicating
which primitives caused their executions. These primitives are represented by URIs that are mapped to procedure definitions executable by a specific execution engine. These executables need to be
fed with the relevant inputs.

In order to illustrate how actual inputs are identified at re-exe-
cution time, let us examine an original OPM graph that we wish to
reexecute. For the sake of illustration, the graph contains pc1:a1
an input artifact with type File, at location /home/pc1/refer-
ence.img, all of this expressed in RDF as follows:

pc1:a1 a opm:Artifact;
opm:account pc1:black;
opm:label Reference Image";
opm:type prim:File.

pc1:a1 opm:annotation pc1:an1_a1.

pc1:an1_a1 a opm:Annotation;

opm:property pc1:pr_23.

pc1:pr_23 a opm:Property;
opm:uri prim:path;
opm:value /home/pc1/reference.img".

The reproducibility engine identifies all input artifacts, and uses
them to reproduce the original OPM graph. In practice, for each
input artifact such as pc1:a1, we may want to use its exact file

Fig. 8. Reproducibility architecture.

plumbing to invoke the executable on the command line. Fig. 9
illustrates a Swift declaration for align_warp specified as taking
four inputs (i1, i2, i3, i4) and producing an output (o). Each in-
put/output element is associated with its OPM role, unique for this
primitive. For instance, the output o has role out, whereas the
anatomy image i1 has role img. We note that the actual invocation
makes explicit use of the image files i1 and i2. On the other hand,

Fig. 9. Swift script for align_warp.

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

or another one, possibly at an alternative location (since the machine we reproduce may not have the same file system as the
one in which the original graph was produced). The reproducibility
engine allows for a novel location to be specified, by making use of
engine-specific configuration files. For instance, with Swift, a configuration indicates the path where the file must be retrieved from.

<variable name="var_i1" type="ReferenceImage">
<file name="//home/user/pc1/reference.img"/>

</variable>

Likewise, we do not necessarily want the reproducibility engine
to write output files at the same location, because we do not want
to overwrite existing files, or because we do not have the rights to
write at that location. So, engine-specific configuration files also
specify the actual location where output files must be stored into.
In this example, they take place in the current directory.

<variable name="var_o" type="WarpParameters">

<file name="./params1.warp"/>

</variable>

This kind of plumbing activity is taken care of automatically

by pre-defined artifact factories.

5.2. Semantic Web techniques for reproducibility service

Multiple Semantic Web technologies have been exploited to
build a reference implementation of the reproducibility service.
Our baseline is a pre-existing OWL ontology for OPM [47]. We discuss the technologies that have been used, the purpose for which
they were used, and their limitations.

Queries. Having represented OPM graphs in RDF, it is natural to
use SPARQL [52] to express provenance queries. This use of SPARQL
is well documented in the literature (e.g., MINDSWAP [53] and
Wings [54] in the first Provenance Challenge, Tetherless [55] in
the third Challenge). Two issues are worth discussing. Identifying
all inputs of an OPM graph requires negation by failure, which
can be encoded in SPARQL as illustrated in Fig. 10. Querying transitive properties is discussed next in this section.

Transitive closures. When multiple or disconnected OPM graphs
co-exist in a triple store, and we wish to reproduce a specific re-
sult, the above query return all graph inputs, including some that
may not have affected the result. Instead, transitive closures are
useful to identify the inputs that indirectly cause some specific
outputs. Fig. 11 displays a possible definition of the multi-step
edge WasDerivedFrom* as a transitive property in OWL. In the
baseline OPM ontology [47], a WasDerivedFrom OPM edge is expressed as an OWL class and not an OWL property, since such an
encoding facilitates the expressiveness of other OPM properties,
such as account membership,
time information, and OPM
annotations.

We then define an OWL property, _wasDerivedFrom with
Artifact as domain and range. Such a property can be inferred15
by OWL by means of a property chain: if there is an artifact that is
the effect of a WasDerivedFrom edge, itself with another artifact as
its cause, then we can infer a property _wasDerivedFrom between
these two artifacts.

Then, property _wasDerivedFrom_star is defined as transi-
tive, with _wasDerivedFrom declared as a subproperty of _was-

15 In the process of defining this ontology, it was necessary to sacrifice elegance for
consistency. Indeed, instead of defining properties effect and cause from Edge to
Node, we had to define effectWasDerivedFrom and causeWasDerivedFrom from
Wasderivedfrom to Node; similar properties were also defined for other OPM edges.
Such a kind of definition ensured the ontology was consistent.

Fig. 10. SPARQL query: inputs to an OPM graph.

DerivedFrom_star. Similar definitions can be adopted for all
multi-step inferences permitted by OPM.

Using OWL to encode OPM inferences (as described in [26]) presents some further challenges. First, we note that OPM completion
rules (artifact and process introductions) are not expressible16 in
OWL 2 since they require the inference of novel individuals and
properties between novel and existing individuals; encoding these
would require us to declare a property as a subproperty of a property chain, which is explicitly forbidden by OWL 2 [56]. Second, the
transitive closure defined in Fig. 11 ignores accounts: it could infer
a _wasDerivedFrom_star property by composing (properties inferred from) edges declared in two separate accounts, which is not
a legal inference in OPM. A solution to this problem is to consider
named graphs [57] to capture assertions related to an account, and
ensure that OWL inferences are limited to a graph [58].

Ontological definitions. We crafted an ontology for reproducibility that is being used at design time. Here, design time refers to the
moment a system with reproducibility capabilities is being de-
signed; it is to be contrasted with runtime, which denotes the moment when the reproducibility function is being executed.

The ontology allows us to express core concepts, such as common artifacts (files with their path, numbers, collections), processes (with a reference to a primitive name), and kinds of
primitives. This ontology (with prefix prim) extends the OPM
OWL ontology, by subclassing its core classes artifacts and pro-
cesses. It allows designers to check for consistency of the various
concepts and to express primitive signatures.

and corresponding

Furthermore, still at design time, the ontology allows us to define common derivations, corresponding to EdgeSpec in the reproducibility semantics,
the
WasDerivedFrom relation, and associate them with the corresponding primitives. For instance, the addition primitive PrimitivePlus has
two derivations Summand0Derivation and
Summand1Derivation from its output (identified by role out0)
to its respective inputs identified by roles summand0 and sum-
mand1. Fig. 12 illustrate an excerpt of the primitive ontology.

subtypes of

Hence, the use of ontologies facilitates the typing of primitives
(seen as functions operating over typed role-value pairs) and their
associated typed derivations. The kind of static type checking of
OPM graphs discussed in Section 4.4 can be implemented by
means of this ontology, and was referred to as semantic validity
by Miles et al. [59]. We note that execution of primitives is not
modelled by the ontology, but instead relies on the execution engines (cf. Fig. 8).

Runtime rules. The reproducibility semantics expresses how
OPM edges can be constructed for every enacted process. Such
edges can be asserted by new SWRL rules.17 For instance, in
Fig. 13, a new edge _wasDerivedFrom is added to an OPM graph
by means of a SWRL rule that checks the existence of an input

16 This problem was also observed by McGrath and Futrelle [48].
17 It is important to note that OPM provides no inference rule to infer WasDerivedFrom edges; instead, they must be asserted [26]. By constructing WasDerivedFrom edges by SWRL rules, we are not misinterpreting OPM semantics. Indeed,
these edges are constructed according to an ontological definition of primitives,
characterizing their signatures and their dependencies. We note that the current
version of this ontology only supports static WasDerivedFrom edges, always
between the same outputs and inputs (identified by their roles), for whatever
invocation of the primitive. An alternative design supports conditional edges,
according to the inputs to the primitive.

Fig. 11. Transitive _wasDerivedFrom_star.

artifact a2 and an output artifact a1, respectively, used and generated by a process under some roles; this process is associated with
a primitive, declared to produce a derivation between those roles.

5.3. Semantic Web assumptions for reproducibility

In this section, we summarize the assumption that underpin

OPM graphs for reproducibility in the Semantic Web.

 Well defined global names: Primitive names should be defined by
a global unique name, with a precise meaning. Likewise, their
implementations must be uniquely identified. In the Semantic
Web tradition, such primitive names and implementations
can be identified by URIs. For instance, we previously named
the primitive align_warp with the URI prim:align_warp.

 Explicit representation of information: Each execution engine
may itself be configurable, and such configurations need to be
made explicit. For instance, Fig. 9 displays the Swift script for
the implementation of align_warp. Furthermore, the Swift
engine relies on a file tc.data to map executable name to a
specific executable in the file system; this file must also be
made explicit.

6. Evaluation

We have undertaken three empirical evaluations aiming to
demonstrate the capability of the reproducibility service, and its
suitability for deployment in a multi-technology environment such
as the Web. We discuss them in turn.

6.1. Feasibility: First Provenance Challenge

workflow [27], which has become a de-facto benchmark in the
provenance community.

By hand, we constructed pc1trace,18 an OPM provenance trace
of the First Provenance Challenge (see Fig. A1, in Appendix). The
trace pc1trace is minimal in the sense that it is not annotated
or decorated with any information that is not required for repro-
ducibility. We applied the reproducibility function to pc1trace,
and obtained the following:

 an output trace with the same structure as pc1trace;
 a precise mapping of pc1trace node ids to the output trace ids;
 a set of intermediary and final output files.

We have checked that the resulting trace is identical up to the

node ids, the locations of produced files, and the file contents.

Fig. 14 summarizes the outcome of this experiment. The input
artifacts were chosen to be the same files (at a location of our
choice). The intermediary artifacts a11 to a24 were shown to be
the same. We however observe that the artifacts following the
slicer stage differed. For instance, the artifact atlas-x.pgm
had 8 bytes that differed by one unit. This difference is due to a
more recent version of the fsl library19 (version 4.1.6. which
was prevailing in 2010), whereas the original artifact was generated by version 3.3.1 of fsl in 2006.

The outcome of this experiment highlights the benefits of this
approach. By keeping explicit provenance and intermediary results
(which in this example were 4 years old), we were able to rerun the
experiment and compare results. Reproducing the experiment allowed us to identify a specific library as the cause of the divergent
results. The installed version was found to be more recent than in
the original execution; reverting to the older version of the library,
we were then able to reproduce all artifacts.

Our first experience is designed to demonstrate that the reproducibility service is capable of reproducing the results of a significant computation. We used the First Provenance Challenge

18 The OPM graph had to be created after the facts since the First Provenance
Challenge predates OPM.
19 http://www.fmrib.ox.ac.uk/fsl/

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

Fig. 13. SWRL rule to construct derivations according to the semantics of
primitives.

Fig. 14. Experiment 1: result comparability.

Fig. 12. Primitive ontology.

Fig. 15. Experiment 2: reproducibility variants.

6.2. Reproducibility variants

In the second experiment, we establish that the reproducibility
service can easily be customized to invoke multiple execution
technologies, such as command line and Java code, simply by
changing its primitive environment. Furthermore, the reproducibility service can be parameterized with different graph factories,
to customize execution or to ensure the uniqueness of the generated graph.

The results of this experiment are summarized in Fig. 15. The
Java Inline execution refers to the ability to invoke Java code di-
rectly. This was achieved by reproducing the OPM graph of Fig. 1,
where the invoked primitives were implemented in Java directly.
Alternatively, the PC1 OPM graph (Fig. A1) was reproduced using
primitives implemented in Swift, invoking command lines. Work
is in progress to support Web Services implementations of
primitives; to this end, we are planning to make use of the D-Pro-
file [60] to minimize the size of the OPM graph. We have also

demonstrated that the reproducibility service can be configured
with mock-up implementation of primitives, which are hardwired
and return specific outputs for specific inputs (similarly to
Bechhofers [29] replayability). Such replayability was demonstrated for the PC1 OPM graph, with primitives returning directly
the URLs as per specified in the First Challenge; such primitives
were then described as dummies [27].

A driver for this paper is to provide a reproducibility semantics
for an ontology-based representation of provenance, allowing a
uniform representation of provenance, despite multiple execution
technologies being involved in executions across the Web. To demonstrate this capability, we have configured the reproducibility
service, with implementation of PC1 primitives using different
technologies, e.g., Swift and Java, and have successfully reproduced
the experiment.

The second part of Fig. 15 demonstrates how the reproducibility
service can be configured with various graph factories. The graph
factory can be used to generate new ids for nodes (and edges),

Fig. 16. Experiment 3: other inputs.

but also to change the location of files to be generated by the command line executables, so that they do not overwrite previously
existing files. Both were successfully demonstrated using the PC1
OPM graph.

6.3. Other inputs

In the third experiment (see Fig. 16), we establish that the
reproducibility service can be used to reproduce experiments with
inputs that differ from those used in the original experiment.

One should note that in this experiment we do not have the original workflow but just a trace of its past execution. Given the numeric expression OPM graph (Fig. 1), one can recompute the
expression with alternate inputs. When the original process makes
decisions on its inputs, the outcome of such decision-making may
differ when new inputs are provided. In that case, the provenance
trace may not contain enough information to reproduce the original process (essentially alternate branches may be missing). This is
an issue that Cheney et al. tackle under their fidelity property
[15], which relies on a form of continuation [61], a data structure
that combines computational state and program structure, to allow
computations to be resumed and continued.

OPM requires the encoding of artifact values to be made expli-
cit. Hence, alternate encodings of a same input can be supported
(e.g., an integer passed by reference in a file, instead of by value).
We note that this type of conversion, referred to a shim by Hull
et al. [62], can be handled automatically and systematically in a
number of cases using appropriate type declarations [63].

Finally, parameter sweeps are possible by changing workflow
parameters, considered as an input by the reproducibility
service.

7. Discussion

7.1. OPM

This paper is the first to provide an executable semantics for a
substantial subset of OPM, independently of a given execution
technology. This formalization complements the ones discussed
in Section 3.4: Cheneys causal perspective of OPM [43], Moreau
et al.s set-theoretic definition of OPM [41], Kwasnikowska et al.s
temporal interpretation of OPM [42], and Missier and Gobles
translation of OPM to a workflow language [19]. The fact that each
formalization covers a different subset of OPM, and that no equivalence between formalizations has been established yet, is indicative of a lack of a grand theory of OPM.

OPM introduced interesting features, such as the notions of accounts and refinements. This paper has proposed a novel definition
for these, which corresponds to the nested invocation of procedures in programming languages: a process can be refined into a
subaccount. Alternate definitions have been proposed, and their
implication for reproducibility need to be investigated. Kwasnikowska and Van Den Bussche [64] propose a methodology to
accommodate hierarchical refinements in OPM. Their notion of
refinement allows for an OPM subgraph to be refined into another
OPM subgraph. Groth and Moreau [60] propose the D-profile, a
profile to express details of execution in distributed systems, such
as communication and messages; the D-profile introduces an alternative form of refinement, where an artifact is refined into a

subgraph. Whilst the notions of refinement defined in these proposals are more general than the one presented here, no reproducibility semantics of such refinements has been proposed.

This paper has introduced constraints on the topology of OPM
graphs to enable the definition of a reproducibility function (cf.
Definition 1). It is our belief that the acyclicity constraint could
be relaxed whilst still preserving reproducibility, for networks of
processes exchanging artifacts. Indeed, provided that there is no
cycle with was-derived-from edges, we can identify processes in
subaccounts that exchange such artifacts. The current semantics
would have to be extended in two different ways to support these:
procedures would have to be called by name and no longer by
value, and processes would have to be ordered across multiple ac-
counts. A number of edges have been ignored in the reproducibility
semantics, because they hide execution details, such as wtb and
all multi-step edges. It would be interesting to investigate how
their temporal interpretation [42] can be folded into the reproducibility semantics.

7.2. OPM and Semantic Web technologies

McGrath and Futrelle [48] show limitations of SWRL and OWL
in expressing OPM inferences. They did not consider property
chains as we did in this paper. They propose a hybrid approach
combining OWL, SWRL, RDF with extra tools to handle all OPM
requirements. We are following a similar approach here. We note
that our encoding of OPM graphs differs from the encoding of
structured objects by description graphs, as described by Motik
et al. [65] and Hastings et al. [66]. Indeed, as valid OPM graphs
are assumed to be acyclic, we did not have to encode such topological constraints in the ontology. However, we share with these approaches the combined use of ontological descriptions and rules.
Zhaos Open Provenance Model Vocabulary (OPMV) [67] aims to
encode OPM in RDF, attempting to leverage existing vocabularies
and ontologies such as Dublin Core, FOAF, and the Provenance
Vocabulary [68], its predecessor. OPMV is work in progress, and
does not support the full expressivity of OPM yet. It may benefit
from some of the encoding of relations introduced by this paper.
A challenge brought by this work was putting Semantic Web
technologies into action in order to implement the reproducibility
service. The challenge was both conceptual and implementational.
First, there is not a single Semantic Web technology that allows us,
today, to tackle all the issues we have encountered: (i) SPARQL
does not support recursive queries over multi-step OPM edges;
(ii) multi-step edges can be inferred by SWRL rules or OWL property chains; (iii) OPM n-ary relations are not naturally encoded
in RDF; (iv) RDF named graphs go some way capturing OPM features [58] such as account; (v) OPM completion rules require the
inference of individuals, which can only be supported by some
non-standardized extensions. Adopting all these technologies together result in a framework, whose semantics are not clear, and
good properties such as inference decidability are lost. From a
practical point of view, at the time of writing, only a few reasoner
could support the property chains described in this paper (TROWL
and Pellet were successful, whilst FACT++ and HermiT failed). Pellet supported many of the above technologies, and was complemented by Java code, but performance of the overall approach
remains a serious concern.

7.3. Reproducibility

In this paper, we have essentially regarded an OPM graph as a
workflow, interpretable according to the reproducibility semantics.
Therefore, this work bears relation with the workflow literature
[69]. Techniques such a workflow abstraction and elaboration

L. Moreau / Web Semantics: Science, Services and Agents on the World Wide Web 9 (2011) 202221

wonder how faithful a provenance record is to some original com-
putation. Two different approaches should be considered to answer this question. First, with the reproducibility semantics, we
have provided a precise meaning for OPM graphs; notions of fidelity [15] can now be adapted to OPM traces. Second, since the
meaning of primitives still needs to be defined, the Semantic
Web approach plays an important role in specifying ontologies,
making their concepts globally referenceable by means of URIs,
and standardizing them.

8. Conclusion

Results reproducibility is crucial in scientific and non-scientific
contexts to gain confidence in results and ensure their quality. It is
particularly important when such results are derived from computations that make use of third-party services across the Web. In
this context, ontology-based representations of provenance offer
a uniform description of past executions across such services. Provenance is usually considered as a strong foundation for ensuring
reproducibility, since its rich representation encompasses the necessary details to reproduce execution steps, and check all results,
whether intermediary or final. However, ontology-based representations of provenance lack any formal link with execution, which
makes it unclear why provenance is a sound foundation for repro-
ducibility. We have tackled this problem by providing the reproducibility semantics for
this
semantics takes the form of a denotational semantics, which assigns well-formed OPM graphs to a function, which for some in-
puts, produces an OPM graph describing the reproduction of the
result.

the Open Provenance Model;

The benefits of the reproducibility semantics are multifold.

1. It provides a strong, technology-neutral, understanding of provenance by defining the mathematical meaning of OPM graphs. It
allows us to define reproducibility formally, and classes of
reproducible graphs, for given primitive environments. It is
therefore
theory of provenance-based
reproducibility.

the basis of

2. It is a specification of a reproducibility service, which we envision
as deployable on the Web or on Intranets. It allows users who
publish results and their provenance, to check that their results
are reproducible, and users who discover data, to verify how
they were produced. Hence, it permits users to increase their
confidence in such data.

3. From a methodological viewpoint, one always wonders what
should be included in provenance. The semantics provides an
algorithmic way to decide what needs to be recorded in provenance to ensure past computation reproducibility.

Our future work will address several concerns. From a theoretical perspective, we will aim to relax the topological constraints
that we set on OPM graphs, and define a broader class of reproducible OPM graphs. Better and more scalable Semantic Web reasoning techniques are required to support
the OPM specific
inferences, and the necessary inferences required for reproducibil-
ity. Finally, we will seek to deploy a reproducibility service in the
context of the Fourth Provenance Challenge, as a means to validate,
automatically, the provenance traces produced by the participating
teams.

Acknowledgements

Special thanks to James Cheney for his constructive comments
on the paper. Also, thanks to Jan Van den Bussche and Simon Miles
for their feedback on an early draft of the paper, and to Jeff Pan and
Nick Gibbins for discussions on ontologies.

Fig. 17. Classification of reproducibility approaches.

[70], scheduling [69], and collection-support are also applicable
here [70].

The reproducibility semantics has been implemented using the
OPM toolbox.20 Its wrapping as a reproducibility service remains to
be undertaken. We envisage this service of being capable of taking
OPM graphs, and reproducing their execution, timestamping and
signing the resulting provenance trace, hence confirming, in a
non-forgeable way, that it is reproducible. Such a service would
need to be scalable, and is obviously a good candidate for
parallelization.

In Section 3.1, we introduced dimensions to the problem of
reproducibility: inputs, primitives, and results. They are captured
by h (inputs), E; Vp (primitives), and Va (results) in the reproducibility semantics. Fig. 17 categorizes the various kinds of prove-
nance-based reproducibility found in the literature according to
these dimensions.

In multiple publications [9,23,11], our preferred definition of
provenance stated that it is an explicit representation of the processes that led to that data item. In particular, we used the past
tense to indicate that some processes produced a data item. In this
paper, we looked at provenance as a program, which can be executed in the future. Hence, to accomodate this new perspective
on provenance, we propose the following revised definition: provenance of a data item is an explicit representation of a computational activity, which in the past led to that data item, and which
can be seen as a program and reexecuted in the future, possibly
to derive similar new data items. We are not the first to consider
an OPM graph as a program. Cheney [43] considers a subset of
OPM as a series of nested let expressions, and Miles [71] introduces POEM, a textual notation to create OPM graphs.

Davidson et al. [72] study the problem of providing workflow
data provenance without revealing the functionality of any mod-
ule. To this end, they focus on the Secure View problem, which
consists in ensuring privacy of all modules in a workflow, by hiding
the smallest amount of data. The problem is established to be NP-
hard, and they propose a polynomial-time approximation. We conjecture that there is a trade-off between full-reproducibility and
full-privacy, since the reproducibility semantics expects primitive
names (and implementations) to be shared. However, there may
be a useful class of reproducibility behaviour, possibly similar to
replayability [29], that can be performed on privacy-preserving
provenance. Such an investigation has also to take into account
the specific OPM graph structure,
including was-derived-from
edges, which partially reveal the private behaviour of processes.

Our assumption in this paper has been that we operate in a nonmalicious environment, in which provenance is an authentic record of past execution. If this assumption no longer holds, one
needs to identify the trusted base in the execution environment,
and possibly exploit cryptographic techniques to be able to attribute provenance claims and check their integrity. Some of these
techniques are reviewed elsewhere [11]. Furthermore, one may

20 http://github.com/lucmoreau/OpenProvenanceModel

Appendix A

See Fig. A1.
