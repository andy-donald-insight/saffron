Web Semantics: Science, Services and Agents

on the World Wide Web 1 (2003) 726

From SHIQ and RDF to OWL: the making of a Web

Ontology Language

Ian Horrocks a,

, Peter F. Patel-Schneider b, Frank van Harmelen c
a Department of Computer Science, University of Manchester, Oxford Road, Manchester M13 9PL, UK

b Bell Labs Research, Lucent Technologies, 600 Mountain Avenue, Murray Hill, NJ 07974, USA

c AI Department, Vrije Universiteit Amsterdam, de Boelelaan 1081a, 1081HV Amsterdam, The Netherlands

Received 26 March 2003; received in revised form 8 May 2003; accepted 16 July 2003

Abstract

The OWL Web Ontology Language is a new formal language for representing ontologies in the Semantic Web. OWL has
features from several families of representation languages, including primarily Description Logics and frames. OWL also shares
many characteristics with RDF, the W3C base of the Semantic Web. In this paper, we discuss how the philosophy and features
of OWL can be traced back to these older formalisms, with modifications driven by several other constraints on OWL. Several
interesting problems have arisen where these influences on OWL have clashed.
 2003 Elsevier B.V. All rights reserved.

Keywords: Ontologies; Semantic Web; Description Logics; Frames; RDF

1. Introduction

OWL [1] is a new ontology language for the Semantic Web, developed by the World Wide Web Consortium (W3C) Web Ontology Working Group. OWL was
primarily designed to represent information about categories of objects and how objects are interrelated
the sort of information that is often called an ontol-
ogy. OWL can also represent information about the
objects themselvesthe sort of information that is often thought of as data.


Corresponding author. Tel.: +44-161-2756133;

fax: +44-161-2756204.

OWL was not designed in a vacuum. There were
many influences on OWLs design, some mandated by
the charter of the Web Ontology Working Group.1 As
OWL is an effort in W3Cs Semantic Web activity, it
had to fit into the Semantic Web vision of a stack of
languages including XML and RDF. As OWL is supposed to be an ontology language, it had to be able to
represent a useful group of ontology features. As there
were already several ontology languages designed for
use in the Web, OWL had to maintain as much compatibility as possible with these existing languages,
including SHOE [2], OIL [3] and DAML + OIL [4].
The multiple influences on OWL resulted in some
difficult trade-offs. Also, and somewhat surprisingly,

E-mail addresses: horrocks@cs.man.ac.uk (I. Horrocks),

pfps@research.bell-labs.com (P.F. Patel-Schneider),
frank.van.harmelen@cs.vu.nl (F. van Harmelen).

1 http://www.w3.org/2001/sw/WebOnt/charter.

1570-8268/$  see front matter  2003 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2003.07.001

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

considerable technical work had to be performed to
devise OWL in such a way that it could be shown
to have various desirable features, while still retaining sufficient compatibility with its roots. This
paper describes some of the trade-offs and design
decisions that had to be made by the Web Ontology
Working Group during the design of OWL. Although
many of these decisions were based on the requirements drawn up for OWL [5], and on solid scientific
knowledge, some of them were necessarily based on
softer judgements, and some were simply a matter
of taste.

This paper presents an account of the trade-offs
and design decisions behind OWL. The views presented are those of the authors, and are not necessarily
shared by all members of the Web Ontology Working
Group.

After a brief introduction and quick survey of OWL,
Sections 3 and 4 discuss the historical roots of OWL.
Section 5 then surveys some of the major problems
that had to be resolved in the design of OWL, while
Section 6 describes the solutions and compromises
that have been found. Section 7 describes how these
solutions have been incorporated in the final design of
the OWL language, Section 8 describes extensions of
OWL that are already under discussion and Section 9
gives summary of the article.

2. OWL overview

This paper is an account of the design choices and
trade-offs that went into the making of OWL, and is
not meant as an exhaustive description of the OWL
language (for which the reader should turn to the OWL
documents, including the OWL Language Reference
[1] and Guide [6].) Nevertheless, to make the paper
self-contained, it contains a short description of the
language and its most important uses.

In the context of the Semantic Web, ontologies are
expected to play an important role in helping automated processes (so called intelligent agents) to access information. In particular, ontologies are expected
to be used to provide structured vocabularies that explicate the relationships between different terms, allowing intelligent agents (and humans) to interpret
their meaning flexibly yet unambiguously. For exam-
ple, a suitable pizza ontology might include the in-

formation that Mozzarella and Gorgonzola are kinds
of cheese, that cheese is not a kind of meat or fish,
and that a vegetarian pizza is one whose toppings do
not include any meat or fish. This information allows
the term pizza topped with (only) Mozzarella and
Gorgonzola to be unambiguously interpreted (by, e.g.
a pizza ordering agent) as a specialisation of the term
vegetarian pizza.

Terms whose meanings are defined in ontologies
can be used in semantic markup that describes the
content and functionality of Web-accessible resources
[7]. Ontologies and ontology-based semantic markup
could be used in
 e-commerce [8], where they can facilitate communication between buying and selling agents
by providing a common vocabulary to describe
goods (such as pizzas) and services (see, e.g.
http://www.verticalnet.com/);
 search engines [9], where they can help in finding
pages that contain semantically similar but syntactically different words and phrases (see, e.g.
http://www.hotbot.com/); and
 Web and grid services [10,11], where they can provide rich service descriptions that can help in locating suitable services.

In order to support these and other usage scenar-
ios, OWL takes the basic fact-stating ability of RDF
[12] and the class- and property-structuring capabilities of RDF schema [13] and extends them in important ways. OWL can declare classes, and organise
these classes in a subsumption (subclass) hierarchy,
as can RDF schema. OWL classes can be specified as
logical combinations (intersections, unions or comple-
ments) of other classes, or as enumerations of specified
objects, going beyond the capabilities of RDFS. OWL
can also declare properties, organise these properties
into a subproperty hierarchy, and provide domains
and ranges for these properties, again as in RDFS.
The domains of OWL properties are OWL classes, and
ranges can be either OWL classes or externally-defined
datatypes such as string or integer. OWL can state that
a property is transitive, symmetric, functional, or is
the inverse of another property, here again extending
RDFS.

OWL can express which objects (also called indi-
viduals) belong to which classes, and what the property values are of specific individuals. Equivalence

statements can be made on classes and on proper-
ties, disjointness statements can be made on classes,
and equality and inequality can be asserted between
individuals.

However, the major extension over RDFS is the
ability in OWL to provide restrictions on how properties behave that are local to a class. OWL can define classes where a particular property is restricted
so that all the values for the property in instances of
the class must belong to a certain class (or datatype);
at least one value must come from a certain class (or
datatype); there must be at least certain specific values
and there must be at least or at most a certain number
of distinct values.

For example, using RDFS, we can

and Canadian;

of the class Country;

 declare classes like Country, Person, Student
 state that Student is a subclass of Person;
 state that Canada and England are both instances
 declare Nationality as a property relating to
the classes Person (its domain) and Country (its
range);
 state that age is a property with Person as its
 state that Peter is an instance of

domain and integer as its range; and

the class

Canadian, and that his age has value 48.

classes;

viduals;

With OWL, we can additionally
 state that Country and Person are disjoint
 state that Canada and England are distinct indi-
 declare HasCitizen as the inverse property of
 state that the class Stateless is defined precisely
as those members of the class Person that have
no values for the property Nationality;

Nationality;

 state that

the class MultipleNationals is
defined precisely as those members of the class
Person that have at least two values for the property Nationality;
 state that the class Canadian is defined precisely
as those members of the class Person that have
Canada as a value of the property Nationality;
and

 state that age is a functional property.

The above shows that OWL is quite a sophisticated
language. OWL has both an RDF/XML exchange
syntax and an abstract frame-like syntax, and it has
three named sublanguages. This multiplicity is the
direct result of trying to satisfy a large number of
sometimes conflicting influences and requirements,
as will be discussed throughout the remainder of this
paper.

3. Influences on OWL

As mentioned above, the design of OWL has been
subject to a variety of influences. These included influences from established formalisms and knowledge
representation paradigms, influences from existing ontology languages and influences from existing Semantic Web languages.
Some of the most important influences on the design of OWL came, via its predecessor DAML+ OIL,
from Description Logics, from the frames paradigm
and from RDF. In particular, the formal specification
of the language was influenced by Description Logics,
the surface structure of the language (as seen in the abstract syntax) was influenced by the frames paradigm
and the RDF/XML exchange syntax was influenced
by a requirement for upwards compatibility with RDF.
Each of these influences will be examined in more

detail in the following sections.

3.1. Description Logics

Description Logics are a family of class-based
(concept-based) knowledge representation formalisms
[14]. They are characterised by the use of various
constructors to build complex classes from simpler
ones, an emphasis on the decidability of key reasoning problems, and by the provision of sound, complete and (empirically) tractable reasoning services.
Description Logics, and insights from Description
Logic research, had a strong influence on the design
of OWL, particularly on the formalisation of the se-
mantics, the choice of language constructors and the
integration of datatypes and data values. In fact, OWL
DL and OWL Lite (two of the three species of OWL)
can be viewed as expressive Description Logics, with
an ontology being equivalent to a Description Logic
knowledge base.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

3.1.1. Semantics

A key feature of Description Logics is that they are
logics, i.e. formal languages with well-defined seman-
tics. The standard technique for specifying the meaning of a Description Logic is via a model theoretic
semantics, whose purpose is to explicate the relationship between the language syntax and the intended
model(s) of the domain. A model consists of a domain
(often written as I) and an interpretation function
(often written as I), where the domain is a set of objects and the interpretation function is a mapping from
individual, class and property names to elements of the
domain, subsets of the domain and binary relations on
the domain, respectively. So, for an individual John,
JohnI  I, for a class Person, PersonI  I and
for a property friend, friendI  I  I.

The interpretation function can be extended from
class names to complex class descriptions in the obvious way. For example, given two classes Male and
Person interpreted as the sets MaleI = {w, x, y}
and PersonI = {x, y, z}, then the intersection of Male
and Person (i.e. male persons) is interpreted as the
intersection of {w, x, y} and {x, y, z}, i.e. (Male and
Person)I = {x, y}.

Objects in the domain do not in themselves have any
meaning, nor does the choice of any particular set of
objects that make up the domainwhat is important is
the relationships between objects and sets of objects.
In a given model, for example, an individual i is an
instance of a class C, just in case i is interpreted as an
element of the interpretation of C (i.e. iI  CI), and
a class C is a subclass of a class D just in case the
interpretation of C is a subset of the interpretation of
D (i.e. CI  DI).

A Description Logic knowledge base consists of a
set of axioms asserting, e.g. that one class is a subclass of another, or that an individual is an instance
of a particular class. The meaning of these axioms is
given by corresponding constraints on models. If, for
example, the knowledge base contains an axiom stating that Person is a subclass of Animal (written as
Person  Animal), then in a model of the knowledge
base the interpretation of Person must always be a
subset of the interpretation of Animal. The meaning
of a knowledge base derives from features and relationships that are common to all possible models. If,
for example, the interpretation of a class must always
be the empty set, then that class is said to be incon-

sistent, while if there are no possible interpretations,
the knowledge base itself is said to be inconsistent. If
the relationship specified by a given axiom must hold
in all interpretations of a knowledge base, then that
axiom is said to be entailed by the knowledge base,
and if one knowledge base entails every axiom in another knowledge base, then the first knowledge base
is said to entail the second knowledge base. A knowledge base containing the axiom Person  Animal,
for example, entails that the intersection of Male and
Person is also a subclass of Animal. This entailment is quite trivial, but with a language as complex
as OWL, checking entailments may, in general, be a
very hard task (see Section 6.5).
Like OIL and DAML + OIL, OWL uses a Description Logic style model theory to formalise the meaning
of the language. This was recognised as an essential
feature in all three languages, as it allows ontologies,
and information using vocabulary defined by ontolo-
gies, to be shared and exchanged without disputes as
to precise meaning. The need for this kind of formality
was reinforced by experience with early versions of
the RDF and RDFS specification, where a lack of formality soon led to arguments as to the meaning of language constructs such as domain and range constraints
[15]. In order to avoid such problems, the meaning of
RDF is now also defined in terms of a model theory
[16].

Another advantage of formalising the meaning of
the language in this way is that automated reasoning
techniques can be used to check the consistency of
classes and ontologies, and to check entailment rela-
tionships. This is crucial if the full power of ontologies is to be exploited by intelligent agents, and the
ability to provide such reasoning support was a key
design goal for OWL.

3.1.2. Language constructors

The expressive power of a language like OWL is
determined by the class (and property) constructors
supported, and by the kinds of axioms that can occur
in an ontology. Of course increased expressive power
inevitably means increased computational complexity
for key reasoning problems such as entailment.

The design of OWL was influenced by more than
10 years of Description Logic research, which has
mapped out in considerable detail the complexity
tractability landscape for a wide range of constructors

and axioms, and their various combinations [14]. This
knowledge allowed the set of constructors and axioms
supported by OWL to be carefully chosen so as to
balance the expressive requirements of typical applications with a requirement for reliable and efficient
reasoning support.

A particular goal of this design process was to ensure that OWL entailment would at least be decidable,
i.e. that it would be possible to design an algorithm
that could guarantee to determine whether or not one
OWL ontology entails another (such an algorithm is
often called a decision procedure). The availability
of practical decision procedures (for entailment), and
even implemented systems, was also an important
consideration.

A suitable balance between these computational
requirements and the expressive requirements identified in [5] was achieved by basing the design of OWL
on the SH family of Description Logics [17]. The
constructors and axioms supported by SH are similar to those described in Section 2, and include the
boolean connectives (intersection, union and comple-
ment), restrictions on properties, transitive properties
and a property hierarchy, i.e. equivalent to the ALC
Description Logic [18] extended with transitive properties and a property hierarchy. The property hierarchy is important for OWL as it is a feature of RDFS,
while transitive properties have been identified as
an important requirement in many applications [5].
Members of the SH family include the influential
SHIQ Description Logic [19], which adds inverse
properties and generalised cardinality restrictions,
and SHOQ(D) [20], which adds the ability to define
a class by enumerating its instances (e.g. the class
{Monday, Tuesday, Wednesday, Thursday,
Friday}) and support for datatypes and values (e.g.
integer and string datatypes, and values such as 35).

3.1.3. Datatypes

As well as dealing with abstract classes such
as Person and Animal, many practical applications need to represent and reason about datatypes
and values such as integers and strings. The integration of datatypes in the OWL language is again
heavily influenced by Description Logic research,
which has demonstrated that care is required in order
to avoid complexity blowups or even undecidability

being caused by datatypes [21].2 In the SHOQ(D)
Description Logic, it was shown that this could be
achieved by strictly separating the interpretation of
datatypes and values from that of classes and individ-
uals: SHOQ(D) interpretations include an additional
interpretation domain for data values I
D which is disjoint from the domain of individuals I. Datatypes,
such as integer, are interpreted as a subset of I
D,
and values such as the integer 35 are interpreted as
elements of I
D. The separation is further strengthened by dividing properties into two disjoint sets of
abstract and datatype properties. Abstract properties
such as brother are interpreted as binary relations on
I (i.e. subsets of I  I), while datatype properties such as age are interpreted as binary relations
between I and I

D (i.e. subsets of I  I
D).

This design has the advantage that reasoning with
datatypes and values can be almost entirely separated from reasoning with classes and individualsa
class-based reasoner simply needs access to a datatype
oracle that can answer simple questions with respect
to datatypes and values (e.g. is 5 a non-negative
integer?). Moreover, the language remains decidable
if datatype and value reasoning is decidable, i.e. if
oracle can guarantee to answer all questions of the
relevant kind for supported datatypes. This can easily
be achieved for a range of common datatypes such as
integers, decimals and strings [21].

As well as these practical considerations, it can
also be argued that
the separation of classes and
datatypes makes sense from a philosophical standpoint as datatypes are already structured by built-in
predicates such as greater-than and less-than. From
this point of view, it does not make sense to use ontology axioms to add further structure to datatypes or to
form hybrid classes such as the class of red integers.

3.2. Frames paradigm

In the Semantic Web context, where users with a
wide range of expertise might be expected to create
or modify ontologies, readability and general ease of
use are important considerations for an ontology lan-
guage. In the design of OIL, one of the languages

2 Reasoners for undecidable languages may have undesirable
characteristics, including poor performance and/or unpredictability.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

on which OWL is based, these requirements were addressed by providing a surface syntax based on the
frames paradigm. Frames group together information
about each class, making ontologies easier to read and
understand, particularly for users not familiar with
(Description) Logics. The frames paradigm has been
used in a number of well-known knowledge representation systems including the Protege ontology design
tool [22] and the OKBC knowledge model [23]. The
design of OIL was influenced by XOL [24]a proposal for an XML syntax for OKBC Lite (a cut down
version of the OKBC knowledge model).

In frame-based languages, each class is described
by a frame. The frame includes the name of the class,
identifies the more general class (or classes) that it spe-
cialises, and lists a set of slots. A slot may consist of
a propertyvalue pair, or a constraint on the values that
can act as slot fillers (in this context, value means either an individual or a data value). This structure was
used in the OIL language, with some enrichment of
the syntax for specifying classes and slot constraints
so as to enable the full power of a Description Logic
style language to be captured. In addition, property
frames were used to describe properties, e.g. specifying more general properties, range and domain con-
straints, transitivity and inverse property relationships.
A class frame is semantically equivalent to a Description Logic axiom asserting that the class being
described by the frame is a subclass of each of the
classes that it specialises and of each of the property
restrictions corresponding to the slots. As well as a
richer slot syntax, OIL also offered the possibility of
asserting that the class being described by the frame
was exactly equivalent to the relevant intersection class
(i.e. that they were mutually subsuming). A property
frame is equivalent to a set of axioms asserting the
relevant subproperty relationships, range and domain
constraints, etc. OIL was designed so that OIL frames
could easily be mapped to equivalent axioms in the
SHOQ(D) Description Logic [25].

The formal specification and semantics of OWL are
given by an abstract syntax [26] that has been heavily influenced by frames in general and by the design of OIL in particular. In the abstract syntax, axioms are compound constructions that are very like an
OIL-style frame. For classes, they consist of the name
of the class being described, a modality of partial
or complete (indicating that the axiom is asserting a

subclass or equivalence relationship, respectively), and
a sequence of property restrictions and names of more
general classes. Similarly, a property axiom specifies
the name of the property and its various features.

The frame style of the abstract syntax makes it
much easier to read (compared to the RDF/XML syn-
tax), and also easier to understand and use. Moreover,
abstract syntax axioms have a direct correspondence
with Description Logic axioms, and they can also be
mapped to a set of RDF triples.

3.3. RDF syntax

The third major influence on the design of OWL
was the requirement to maintain the maximum upwards compatibility with existing Web languages, and
in particular with RDF [27]. On the face of it, this
requirement made good sense as RDF (and in particular RDF schema) already included several of the
basic features of a class and property based ontology
language, e.g. it allows subclass and subproperty relationships to be asserted. Moreover, the development
of RDF preceded that of OWL, and it seemed reasonable to try to appeal to any user community already
established by RDF.

It may seem easy to meet this requirement simply by giving OWL an RDF-based syntax. In order
to provide maximum upwards compatibility, however,
it was also thought necessary to ensure that the semantics of OWL ontologies was also consistent with
the semantics of RDF. This proved to be difficult
given the greatly increased expressive power provided
by OWL. This will be discussed in more detail in
Section 5.

4. Predecessors of OWL

OWL was not

the first Web-enabled ontology
language, and its design was influenced by several
pre-existing languages including RDFS, SHOE, OIL,
DAML-ONT and DAML + OIL. DAML + OIL in
particular was a major influence on OWL, and the
charter of the Web Ontology working group explicitly states that the design of OWL should be based
on DAML + OIL. DAML + OIL in turn was heavily influenced by the OIL language, with additional
influence from work on DAML-ONT and RDFS.

4.1. SHOE

One of the first attempts at defining an ontology
language for deployment on the Web was SHOE [28].
SHOE is a frame-based language with an XML syntax that could be safely embedded in existing HTML
documents. SHOE used URI references for names, an
important innovation (see Section 7) that was subsequently adopted by both DAML-ONT and DAML +
OIL. SHOE also placed emphasis on the fact that ontologies would be tightly interlinked and subject to
change. Consequently, SHOE included a number of
directives which allowed importing of other ontolo-
gies, local renaming of imported constants, and stating versioning and compatibility information between
ontologies. This line of thinking has influenced the
extra-logical vocabulary of OWL that is designed to
partially deal with such issues. SHOE was of lesser influence on the syntactic and semantic design of OWL,
since it was not based on RDF and did not come with
a formal semantics.

4.2. DAML-ONT

In 1999,

the DARPA Agent Markup Language
(DAML) program3 was initiated with the aim of providing the foundations of a next generation semantic
Web [29]. As a first step, it was decided that the adoption of a common ontology language would facilitate
semantic interoperability across the various projects
making up the program. RDFS (which had already
been proposed as a W3C standard) was seen as a good
starting point, but was not sufficiently expressive to
meet DAMLs requirements. A new language called
DAML-ONT was therefore developed that extended
RDF with language constructors from object-oriented
and frame-based knowledge representation languages.
DAML-ONT was tightly integrated with RDFS, and
while this was useful from a compatibility viewpoint,
it led to some serious problems in the design of the
language. Like RDFS, DAML-ONT suffered from an
inadequate semantic specification, and it was soon
realised that this could lead to disagreements, both
amongst humans and machines, as to the precise meaning of terms in a DAML-ONT ontology. Moreover,

DAML-ONT property restrictions had, like those of
RDFS, global rather than local scope, and while this
was reasonable for the domain and range constraints
provided by RDFS, global cardinality constrains, for
example, are difficult to understand and of doubtful
utility; in fact it seems likely that this would have been
recognised as a design flaw if the semantics of the
language had been adequately formalised.

4.3. OIL

At around the same time that DAML-ONT was
being developed, a group of (largely European) researchers with aims similar to those of the DAML researchers had designed another Web-oriented ontology
language called OIL4 (the Ontology Inference Layer)
[3]. OIL was the first ontology language to combine
elements from Description Logics, frame languages
and Web standards such as XML and RDF. OIL placed
a strong emphasis on formal rigor, and the language
was explicitly designed so that its semantics could
be specified via a mapping to the SHIQ Description
Logic [19]. The structure of the language was, how-
ever, frame-based, using compound class definitions
in the style described in Section 3.2. OIL had both
XML and RDF syntaxes, but although the RDF syntax
was designed to maintain compatibility with RDFS, it
did not concern itself with the precise details of RDF
semantics, which had not at that time been formally
defined.
4.4. DAML + OIL

It became obvious to both the DAML-ONT and OIL
groups that their objectives could best be served by
combining their efforts, the result being the merging of
DAML-ONT and OIL to produce DAML + OIL. The
development of DAML + OIL was undertaken by a
committee largely made up of members of the two language design teams, and rather grandly titled the Joint
US/EU ad hoc Agent Markup Language Committee.5
The merged language has a formal semantics given
by its own DL style model theory instead of via a translation into a suitable DL. The DL-derived language
constructors of OIL were retained in DAML + OIL,

3 http://www.daml.org/.

4 http://www.ontoknowledge.org/oil.
5 http://www.daml.org/committee.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

but the frame structure was largely discarded in favour
of DL style axioms, which were more easily integrated
with RDF syntax.
Influenced by DAML-ONT, DAML + OIL is more
tightly integrated with RDF. DAML + OIL, however,
only provided a meaning for those parts of RDF which
were consistent with its own syntax and DL style
model theory. This did not seem to be too much of
a problem given that RDF did not at that time have
a formally specified meaning of its own, but was the
cause of serious difficulties when DAML + OIL was
used as the basis for OWL.

5. Problems along the path

The multiple influences on OWL have lead to a
number of problems. Some of these problems are a
result of conflicting requirements, as in the conflict
between using RDF/XML as the offcial OWL syntax and having an easy-to-read syntax. Some of these
problems arise from a need to extend previous solu-
tions, as in the problems arising in crafting an extension to RDF that incorporates information that does
not fit well into the RDF world view.

5.1. Syntactic problems

For a number of reasons, including maintaining
connections to frames and Description Logics, OWL
should have an easy-to-read syntax that can be easily
understood and easily created. However, it was a requirement of OWL that it use XML as its normative
syntax, and, moreover, use XML in the same way as
it is used in RDF [30]. This requirement had already
been addressed by OIL and, later, by DAML + OIL:
OIL has both an RDF/XML and an XML syntax [31],
while DAML + OIL has only an RDF/XML syntax
[4].

Taken just as a syntax for OWL, RDF in the form
of RDF/XML has a number of problems. These problems can be overcome, but they do make OWL more
complex that it might otherwise be.

One problem is that RDF/XML is extremely ver-
bose. Compare for example, information about a class
as it would be given in a Description Logic syntax
Student = Person  1enrolledIn

(a Student is a Person who is enrolledIn at
least one thing), with how it would most naturally be
written using the OWL RDF/XML syntax6

<owl:Class rdf:ID=Student>

<owl:intersectionOf rdf:parsetype

=Collection>
<owl:Class rdfs:about=

Person/>

<owl:Restriction>

<owl:onProperty rdf:resource

<owl:minCardinality rdfs:

=enrolledIn/>
datatype=&xsd;Integer>

</owl:minCardinality>

</owl:Restriction>
<owl:intersectionOf>

</owl:Class>

Another problem is that RDF breaks everything
down into RDF triples [12].7 This means that many
OWL constructs, such as property restrictions, have to
be encoded as several triples. OWL generally uses an
encoding similar to that used by DAML + OIL. For
example, an OWL value restriction that would be written in Description Logic syntax as child.person
(the class whose instances have some child that is
a person) is encoded as two RDF triples something
like

:x owl:onProperty ex:child.
:x owl:someValuesFrom ex:Person.

where :x is a syntactic placeholder for the restriction
as a whole.

A third problem is that all RDF triples are indepen-
dent. This means, for example, that as far as RDF is
concerned there is no requirement that the two above
triples must always occur together. Similarly, there
is no requirement that there not be extra triples, so
adding

6 Full details on the OWL RDF/XML syntax can be found in

the OWL reference document [1].

7 The syntax for RDF triples here is one used in the RDF
Semantics document [16]. An RDF triple is written as a subject,
a predicate and an object, in that order. RDF URI references in
triples are generally abbreviated as XML qualified names. RDF
blank nodes (anonymous objects) are written with a leading  :.

:x owl:onProperty ex:friend.
:x owl:allValuesFrom ex:Doctor.

to the above two triples cannot be ruled out in RDF.
A fourth problem is that RDF triples are all accessi-
ble. This means that circular and other unusual structures cannot be ruled out. For example, there is no
problem in RDF with collections of triples like

:x owl:onProperty ex:child.
:x owl:allValuesFrom :x.

These issues are not addressed in OIL, which provides no guidance as to what should happen for collections of triples that do not match the syntax productions of the language. DAML + OIL takes a different
approach, allowing unusual constructions but declining to give them a DAML + OIL meaning. OWL has
roughly followed the DAML+ OIL solution, but with
several modifications.

5.2. Semantic problems

Once issues of syntax have been addressed, issues
related to meaning still remain. RDF provides a meaning for every triple, so if OWL is to be considered to
be an extension of RDF, the meaning that OWL provides for triples needs to be an extension of this RDF
meaning.
This was not as much of an issue when OIL and
DAML + OIL were designed, as the meaning of RDF
was not very well specified. OIL in particular does not
bother to relate the RDF meaning of its RDF/XML
syntax to the OIL meaning of
this syntaxthe
RDF/XML syntax for some OIL constructs does
more-or-less line up with the RDF meaning of these
constructs but this is by no means the case for all
such constructs. For example, OIL has a special property (oil:hasSlotConstraint) used to relate a
class to its slots, but the RDF meaning [16] of this
property, namely the standard meaning assigned to
any RDF triple is ignored by the OIL semantics.
DAML + OIL does a better job of abiding by the
RDF meaning of its syntax. The DAML+ OIL model
theory [32] includes a semantic condition for triples
that is close to the RDF meaning (as defined at that
time) for triples. Further, DAML + OIL uses the
built-in RDF and RDFS vocabulary to a greater extent
than does OIL, and uses it in a way generally compati-

ble with the RDF or RDFS meaning (as defined at that
time) for this vocabulary. For example DAML + OIL
uses rdfs:subClassOf to relate classes to super-
classes, including DAML + OIL restrictions, whereas
OIL uses oil:hasSlotConstraint in some of
these situations.
Even when DAML + OIL was being developed,
however, there were some aspects of the meaning of
RDFS that could not be reconciled with the appropriate meaning in DAML + OIL. In particular, RDFS
[33] then had an unusual meaning for domains and
ranges of properties. Only a single range was permitted for properties and multiple domains were treated
disjunctively. For example,

ex:foo rdfs:domain ex:Person.
ex:foo rdfs:domain ex:Rock.

would allow both people and rocks to participate in
the foo property.
This disjunctive reading of domains caused problems for the DAML+ OIL semantics, so a choice was
made to change this to a conjunctive reading and petition the newly-formed RDF core working group to
change RDFS to allow multiple domains and ranges,
both with a conjunctive reading. As part of its clean
up of the RDF and RDFS semantics, the RDF core
working group has decided to make this change, eliminating a problem for OWL.

While cleaning up problems with RDF and RDFS,
the RDF core working group also decided to put RDF
on a firmer semantic ground. It did this by providing a
model theory for RDF and RDFS, along with a standard treatment of inference for RDF and RDFS. This
has meant that there is now more meaning provided
for RDF and RDFS that OWL has to be compatible
with. In particular, all the triples that are used to encode the OWL syntax now have RDF meaning, and
this RDF meaning has to be taken into account by
OWL if the semantics of OWL are to be fully compatible with those of RDF and RDFS.
Neither OIL nor DAML + OIL provided a standard theory of inference. This was common in the
formalisms that influenced OIL and DAML + OIL.
Frames generally provided an interface to the internal
data structures in lieu of any other inferences or even
queries. Description Logics do provide a formal theory of querying, but this is somewhat different from a
standard theory of inference.

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

The difference is that Description Logic querying
could have been defined for DAML+OIL in a way that
would have helped to hide the RDF meaning of triples.
For example, asking whether an individual belonged
to a class could add the syntax used to specify the
class to the premises of the query. However, a standard
theory of inferencing cannot do this.

The effects of this change can be seen in a simple

example. Given the following information

ex:John rdf:type ex:Student.
ex:John rdf:type ex:Employee.

it would have been fairly easy to arrange it so that
asking whether John belonged to the intersection of
student and employee first ensured that this intersection existed and then asked whether John belonged to
it. However, turning this into an entailment requires
the above information to entail

:c owl:intersectionOf :l1.
:l1 rdf:first ex:Student.
:l1 rdf:rest :l2.
:l2 rdf:first ex:Employee.
:l2 rdf:rest rdf:nil.
ex:John rdf:type :c.

which, because of the RDF meaning ascribed to all
triples, requires the existence of the triples that encode
the syntax.8

OWL thus has had to develop a method that augments the new RDF semantics just enough to support
the above inferences without being too strong, and
thus ending up with semantic paradoxes (this will be
discussed in more detail in Section 6.4).

5.3. Expressive power

Because many things were expected of OWL (see
the long list of design goals, requirements and objectives in [5]), there were many demands for expressive
power going beyond that generally provided by Description Logics. For example, many users wanted
to be able to associate information with classes
and properties and to make classes belong to other

classes, as is possible in RDF. Similarly, there were
many demands for expressive power going beyond
RDF and RDFS. For example, many users wanted
to be able to provide local typing for property val-
ues, as is possible in Description Logics. OWL had
to be designed to somehow allow these sorts of
expressivity while still retaining connections to its
roots.

When DAML + OIL was developed,

the only
datatype supported by RDF was literals: roughly undifferentiated values given as strings. DAML + OIL
thus had to provide its own solution for datatypes,
and did so by allowing the use of XML schema
datatypes [34]. However, any reasonable solution to
datatyping that uses only RDF syntax needs help from
RDF (i.e. an extension to RDF syntax), and thus the
DAML + OIL solution remained incomplete.
Recently RDF has added its own version of datatyp-
ing, similar to, but different from, the DAML+OIL so-
lution. OWL has thus needed to move from DAML +
OIL datatyping to RDF datatyping.

5.4. Computational problems

One aspect of OWL that distinguishes it from RDF
and RDFS is that it supports a rich set of inferences.
Some of these inferences are quite obvious, such as
the example given above about students and employ-
ees, and thus appear to be easy to compute. Other inferences supported by OWL, however, are quite com-
plex, requiring, e.g. reasoning by cases and following
chains of properties.

Taking all the representational desires for OWL
together would have created a formalism where key
inference problems were undecidable. For example,
allowing relationships to be asserted between property chains (such as saying that an uncle is precisely
a parents brother) would make OWL entailment
undecidable.9 In addition, some aspects of RDF, such
as the use of classes as instances, interact with the rest
of OWL to create computational difficulties, taking
OWL beyond the range of practical algorithms and
implemented reasoning systems.

8 Note that OWL constructs such as intersectionOf
and unionOf are encoded using RDF lists constructed of
rdf:first and rdf:rest triples; see the OWL reference document [1] for full details.

9 It is easy to show that, if extended in this way, OWL could
be used to encode the word problem, which is well known to be
undecidable [38].

OWL has thus had to provide a solution for these
issues while still retaining upwards

computational
compatibility with RDF and RDFS.

6. Solutions

The Web Ontology Working Group spent the better
part of a year overcoming the basic tensions underlying the above problems. The difficulty lay not in each
problem in isolation, but in the combination of all the
above problems and the constraints placed on the design of OWL. It would have been much easier, for
example, to meet all the above requirements if only

6.1. Readability

As shown by the examples above, OWL is not very
readable when written as RDF/XML or even as RDF
triples. Part of this problem is that RDF/XML is extremely verbose, but the major part of the readability problem is the encoding of OWL constructs into
RDF/XML or RDF triples.

In part to address this problem, an abstract syntax
(cf., Section 7.1) was created for OWL, along with
a mapping from abstract syntax to RDF graphs. This
abstract syntax is closer to the syntax of OIL than of
DAML + OIL, but without OILs extreme emphasis
on readability. In this abstract syntax, the Student example above would be written

Class(Student complete

Person
restriction(enrolledIn minCardinality(1))).

OWL could have used an extension of the RDF syn-
tax. If this had been allowed, OWL could have added
new, natural syntax for its constructs whose semantics
would not have been required to carry along an RDF
triple meaning.

Nevertheless a viable solution has been found that
satisfies all the above requirements. Or, actually, it is
more accurate to say that three solutions have been
found, each of which satisfies almost all of the above
requirements.

1. OWL DL: If friendly syntax or decidable inference
is considered of primary importance, then OWL
DL, a version of OWL with decidable inference
that can be written in a frame or Description Logic
manner, is appropriate.

2. OWL Lite: If an even simpler syntax and more
tractable inference is considered of primary impor-
tance, then OWL Lite, a syntactic subset of OWL
DL, is appropriate.

3. OWL Full: If compatibility with RDF and RDFS
is considered of primary importance, then OWL
Full, a syntactic and semantic extension of RDFS,
is appropriate.

The next section provides a more-detailed description of these versions (species) of OWL, and explains
how the problems described above have been over-
come.

OWL DL was then defined as the syntactic subset of OWL induced by the translation from the abstract syntax to RDF graphs. That is, an RDF graph
is an OWL DL ontology just when it is the translation of some ontology in the abstract syntax. Users
and tools that are more interested in readability than in
RDF/XML can use this abstract syntax internally, or
even externally for presentation to users, reserving the
RDF/XML syntax for purposes of exchange between
applications.

6.2. Handling malformed graphs

Because OWL Full allows arbitrary RDF graphs, it
must be able to handle malformed OWL syntax. (OWL
DL does not suffer from this problem as it is defined
in terms of the necessarily well-formed RDF graphs
that can be generated from the abstract syntax.) OWL
uses an extension of the DAML + OIL solution: only
triples that together form well-formed OWL constructs
are given an extra meaning, so

:x owl:onProperty ex:child.

by itself does not have any special OWL meaning.
To handle the cases of too many triples, OWL again
uses the DAML + OIL solution of picking out all the
well-formed subsets and giving them OWL meaning.
This has unusual consequences, for example

I. Horrocks et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2003) 726

:x owl:onProperty ex:child.
:x owl:someValuesFrom ex:Person.
:x owl:onProperty ex:friend.
:x owl:allValuesFrom ex:Doctor.

These comprehension principles support the entail-

ment from

ex:John rdf:type ex:Student.
ex:John rdf:type ex:Employee.

ends up equating the extension of four different
OWL restrictions (all possible combinations of the
two properties with the two classes), which is almost
certainly not what was intended by the user. This
solution, however, maintains monotonicity, and the
(possibly) non-intuitive meaning is a minor problem
given that such malformed constructions can easily be
avoided.

The lack of structure in RDF graphs has to be han-

dled by semantic means, which are described next.

6.3. Providing a viable semantic theory for OWL

As RDF now has a model theory, with a full-fledged
notion of entailment, OWL has to provide an
upward-compatible model theory that appropriately
handles entailments over the OWL constructs. This
would have been easy if OWL had been able to extend the RDF syntax, as then these new bits of syntax
could have had an OWL-only meaning. However, it
was a requirement that OWL had an RDF syntax, and
that this syntax carried all of its RDF meaning. This
two-way compatibility requirement is much stronger
than that usually imposed between weaker formalisms
(like propositional
logic) and stronger formalisms
(like first-order logic) where the stronger formalism is allowed to extend the syntax of the weaker
formalism.

The most severe aspect of this problem is that OWL
syntactic constructs that are encoded as multiple triples
have to retain the RDF meaning for these triples. As
all RDF triples carry semantic conditions, they cannot
just be inferred from nothing. Instead, the OWL semantics has had to add special constraints that essentially state that every OWL interpretation must include
certain constructs. (Such constraints are usually called
comprehension principles.) For example, one comprehension principle for OWL states that every model
must include all finite lists of classes; another states
that every such list must have a corresponding intersection class, by requiring that there is some class that is
connected to the list by an owl:intersectionOf
property.

to

:c owl:intersectionOf :l1.
:l1 rdf:first ex:Student.
:l1 rdf:rest :l2.
:l2 rdf:first ex:Employee.
:l2 rdf:rest rdf:nil.
ex:John rdf:type :c.

because :l1 can be the required list of Student
and Employee, :l2 can be the required tail of this
list, and :c can be the required intersection of the
list. Additional (and more-usual) semantic conditions
require that ex:John belong to :c, finishing all that
is required for the entailment to hold.

6.4. Avoiding paradoxes

Comprehension principles are very powerful, as
they create something from nothing (or, at
least,
something from very little). This power can easily
lead to serious problems.

For example, the Russell paradox is a paradox precisely because of the comprehension principles built
into an early version of set theory. This early version of set theory had a comprehension principle that
stated that a set could be constructed of the things that
satisfied a formula with one free variable, e.g. the formula of being a human, x  human, could be used to
construct the set of humans, {x|x  human}. Unfortu-
nately, from the formula of not belonging to oneself,
x / x, the set {x|x / x} arises. This set causes problems wherever it exists because it is impossible to
determine whether it belongs to itself. The comprehension principle mandates that it exists everywhere, thus
causing this early version of set theory to collapse.

A similar situation can arise with OWL. It seems
natural to want to have circular OWL-like constructs,
for example classes whose instances are related only
to other instances of the class, such as in
:c owl:onProperty ex:child.
:c owl:allValuesFrom :c.

that might be used in a naive representation of some
aspects of biology.

However, having comprehension principles for such
circular classes can easily lead to a requirement for
the existence of classes like

:c owl:onProperty rdf:type.
:c owl:allValuesFrom :d.
:d owl:complementOf :l.
:l rdf:first :c.
:l rdf:rest rdf:nil.

which is the class of things that have no type relationship to the class itself. Objects that belong to this class
can not belong to it, and vice versa, so if the comprehension principles required the existence of this class,
then every OWL ontology would be paradoxical.

To avoid these paradoxes, the OWL comprehension principles never require the existence of circular chains of reference like the one above. However,
this does mean that there are entailments that one
might expect, such as ones involving the construct
with ex:child above, for example having a person with no children belong to such a construct, that
are not valid in OWL. Devising these comprehension
principles took a surprising amount of effort (much of
which involved determining the ground rules for the
principles).

6.5. Retaining decidability

OWL Full is undecidable (for a number of reasons),
and even OWL DL could easily be undecidable if it included certain constructs known to cause undecidability in Description Logics (see, e.g. [19]). Therefore,
OWL DL was carefully crafted to remain decidable,
and does not include, for example, relationships between role chains, which would cause undecidability
by embedding the word problem in OWL DL.

This is not to say that inference in OWL DL is
not hard. OWL DL has a difficult entailment problem,
as inference in SHOIN(D) is of worst-case nondeterministic exponential time (NExpTime) complexity
[35], and OWL DL should have the same complexity.
Worse, there is as of yet no known practical complete algorithm for inference in SHOIN(D), i.e. one
that is likely to perform well on the kinds of problem
encountered in typical applications. In default of such
an algorithm, the behaviour of OWL DL reasoners is
likely to be less predictable (both in terms of the time
taken to respond to queries, and the use of system re-

sources), and they may sometimes return the answer
unknown in response to queries.

OWL Lite is better in this regard. Inference in
SHIF(D) is of worst-case deterministic exponential
time (ExpTime) complexity [35], and OWL Lite has
the same complexity. Moreover, there are practical
optimized algorithms for inference in OWL Lite, such
as the algorithm underlying the Description Logic
systems FaCT [36] and RACER [37]. These systems
have been shown to work well in realistic applications
and to be able to reason with large ontologies.

7. OWL

This section describes how the solutions outlined
above have been incorporated in the final design of the
OWL language. It is not intended as a full description
of the language, for this, readers should turn to the
W3C documents on OWL [1,6,26].

For various reasons, described in the preceding sec-
tions, there are two styles of using OWL. In the first
style, embodied in OWL DL and OWL Lite, only certain constructions are allowed, and these constructions
can only be combined in certain ways. The benefits of
staying within these limitations include decidability of
inferences and the possibility of thinking of OWL in
a more-standard fashion, essentially as an expressive
Description Logic. In the second style, embodied in
OWL Full, all RDF graphs are allowed. The benefits
of this expansive style include total upward compatibility with RDF and a greater expressive power.

Even the more-limited versions of OWL have some
differences from standard Description Logics. These
differences move these versions of OWL from the formal Description Logic world to the Semantic Web
world.
 OWL uses URI references as names, and constructs these URI references in the same manner as that used by RDF. It is thus common in
OWL to use qualified names as shorthands for
the qualfor example,
