Abstraction Refinement for Ontology Materialization

Birte Glimm1, Yevgeny Kazakov1, Thorsten Liebig2,

Trung-Kien Tran1, and Vincent Vialard2

1 University of Ulm, Ulm, Germany

{firstname.lastname}@uni-ulm.de

2 derivo GmbH, Ulm, Germany
{lastname}@derivo.de

Abstract. We present a new procedure for ontology materialization (comput-
ing all entailed instances of every atomic concept) in which reasoning over a
large ABox is reduced to reasoning over a smaller abstract ABox. The abstract
ABox is obtained as the result of a fixed-point computation involving two stages:
1) abstraction: partition the individuals into equivalence classes based on told
information and use one representative individual per equivalence class, and 2)
refinement: iteratively split (refine) the equivalence classes, when new assertions
are derived that distinguish individuals within the same class. We prove that the
method is complete for Horn ALCHOI ontologies, that is, all entailed instances
will be derived once the fixed-point is reached. We implement the procedure in
a new database-backed reasoning system and evaluate it empirically on existing
ontologies with large ABoxes. We demonstrate that the obtained abstract ABoxes
are significantly smaller than the original ones and can be computed with few refinement steps.

1 Introduction

Ontology based data access (OBDA) is an increasingly popular paradigm in the area
of knowledge representation and information systems. In ODBA, a TBox with background knowledge is used to enrich and integrate large, incomplete, and possibly semistructured data, which users can then access via queries. To efficiently handle large data
sets (called ABoxes), OBDA approaches assume that the data is stored in a database
or triple store. Nevertheless, the assumption of complete data that is typically made in
databases does not hold and reasoning is required to compute the (entailed) types of
individuals or answers to queries in general.

Different reasoning approaches have been developed in the OBDA context: (i) Query
rewriting or backward-chaining approaches answer a query, by compiling the background knowledge of the TBox into the query [2,12]. The analysis of which languages
are FO rewritable (i.e., which queries can be answered by query rewriting) inspired
the development of DL-Lite [2] and resulted in the OWL QL profile [11] of the Web
Ontology Language OWL 2. (ii) Materialization or forward-chaining techniques take
the opposite approach by pre-computing all entailed information upfront, independent
of the queries [1,14,8]. After extending the ABox with all pre-computed facts, the unmodified queries can be evaluated over the enriched data only (i.e., without considering
the schema). The idea of query answering via materialization is directly present in the

P. Mika et al. (Eds.) ISWC 2014, Part II, LNCS 8797, pp. 180195, 2014.
c Springer International Publishing Switzerland 2014
?

?

?
OWL RL profile [11], which specifies a suitable set of materialization rules. (iii) Fi-
nally, also combined approaches have been proposed, which allow for smaller rewritten
queries by materializing some (but not all) entailments [10,9] or for computing the materialization dynamically as required for a given query.

In this paper, we focus on the materialization of entailed facts for large ABoxes
that are stored in a (graph)database or triple store and where the schema is expressed
in terms of a Horn ALCHOI ontology. For full OWL RL support, functionality and
property chains have to be encoded, but Horn ALCHOI also goes beyond OWL RL
(and OWL QL). For example, existential quantification (owl:someValuesFrom) is fully
supported, which is a feature that is difficult for standard materialization and rewriting
approaches. While the principle of materialization is conceptually simple, it requires
considerable computational resources in particular for large ABoxes or expressive TBox
languages. Furthermore, reasoners for the language we tackle, are typically main memory and refutation-based, i.e., to show that an individual a is an instance of the concept
C, the reasoner tries to derive a contradiction for the ontology (temporarily) extended
with C(a) (asserting that a is not an instance of C). Consequently, handling large
ABoxes directly is infeasible.

Our approach for handling large ABoxes is based on the assumption that individuals with similar asserted types are likely to have the same inferred types. We group
such individuals into equivalence classes and compute the types just for one representative individual. For building the initial equivalence classes, we also consider the role
(property) assertions in the ABox, but we do not simply merge individuals. Instead, we
iteratively compute a so-called abstraction that contains one representative individual
for each equivalence class plus representative individuals for its direct role successors
and predecessors in the ABox. We show how derivations for the latter individuals can
be used in the refinement process to split equivalence classes for individuals that no
longer have the same assertions. The number of individuals in the abstraction is always
bounded exponentially in the number of different concepts and roles and linearly in the
size of the original ABox; hence the abstraction is relatively small when the number of
individuals is much larger than the number of concepts and roles used in the ontology.
We implement the technique in a database-backed system that interacts with a highly
optimized in-memory reasoner that materializes the abstract ABox. The database engine needs to support only simple operations and does not require any knowledge of
the TBox. We show that the procedure is sound and it is complete for computing the
entailed types of individuals in Horn ALCHOI ontologies.

The paper is structured as follows: We next introduce directly related approaches.
In Section 3, we present some preliminaries and continue with the presentation of the
theoretical foundation of our approach in Section 4. In Section 5, we prove completeness of our procedure. In Section 6, we evaluate the procedure on a range of real-world
ontologies with large ABoxes, and conclude in Section 7. Full proofs and further details
are available in a technical report [5].

2 Related Work

In this section, we focus on work that is closely related to our aim of abstracting the
ABox. The SHER approach [4,3] merges similar individuals to obtain a compressed,

B. Glimm et al.

so-called summary ABox, which is then used for (refutation-based) consistency check-
ing. The technique (as well as ours) is based on the observation that individuals with the
same asserted types are likely to have the same entailed types. Since merging in SHER
is only based on asserted concepts, the resulting summary ABox might be inconsistent
even if the original ABox is consistent w.r.t. the TBox. To remedy this, justifications [6]
are used to decide which merges caused the inconsistency and to refine the summary
accordingly. Justification-based refinements are also needed for query answering since
SHER is not a materialization approach and performs reasoning at query time. We avoid
justification computation by partitioning individuals of the same type into equivalence
classes. Such partitioning guarantees the soundness of derived atomic concept asser-
tions. We also have to perform refinement steps, but the refinement is to incrementally
derive more consequences. What is computed before remains sound.
Wandelt and M oller propose a technique for (refutation-based) instance retrieval over
SHI ontologies based on modularization [15,16]. As an optimization and similar to our
approach, they group individuals into equivalence classes based on the asserted types
of an individual, its successors, predecessors and the asserted types of the successors
and predecessors.1 The assertions that define the equivalence class of an individual are
used for finding sound entailments. For checking entailments that cannot be read-off
from these assertions, it might be necessary to fall-back to (refutation-based) reasoning over the (possibly large) ABox module for the individual. Instead of falling back to
modules of the original ABox, we propose an iterative refinement process for the equivalence classes. The refinement is based on semantic criteria, i.e., only when individuals
are semantically distinguishable, we refine the equivalence class, whereas the modules
defined by Wandelt and M oller are syntactically defined.

3 Preliminaries
We first define the syntax and semantics of the Description Logic (DL) ALCHOI,
which is the main ontology language we consider in this paper.
The syntax of ALCHOI is defined using a vocabulary (signature) consisting of
countably infinite disjoint sets NC of concept names, NO of nominals, NR of role
names, and NI of individual names. Note that concepts are called classes and roles
are called properties in OWL. Complex concepts and axioms are defined recursively in
Table 1. An ontology O is a finite set of axioms and we often write O = A  T , where
A is an ABox consisting of the concept and role assertions in O and T a TBox consisting
of the concept and role inclusions in O. We use con(O), rol(O), ind(O) for the sets of
concept names, role names, and individual names occurring in O, respectively.
, the domain of I,
An interpretation I = (

and an interpretation function I
, to
each o  NO a singleton subset o
I|| = 1, to each R  NR a binary relation
I  
. This assignment is extended

to complex concepts as shown in Table 1. I satisfies an axiom  (written I |= ) if
the corresponding condition in Table 1 holds. I is a model of an ontology O (written
I |= O) if I satisfies all axioms in O. We say that O is consistent if O has a model.
1 We ignore the types of successors and predecessors to achieve larger equivalence classes.

,I) consists of a non-empty set 

, that assigns to each A  NC a subset A
I  

I  

, ||o

I  

, and to each a  NI an element a

I  
?

?

?
Table 1. The syntax and semantics of ALCHOI

Syntax Semantics

(given by I)

RI  I  I
{e, d | d, e  RI}
(given by I)
A  I
oI  I
, ||oI|| = 1 (given by I)
I


Roles:

atomic role
inverse role
Concepts:

R

atomic concept
nominal
top
bottom
negation
conjunction
disjunction
existential restriction R.C {d | e  CI : d, e  RI}
universal restriction R.C {d | e  I : d, e  RI  e  CI}

o


C I \ CI
C  D CI  DI
C  D CI  DI

Axioms:

concept inclusion
role inclusion
concept assertion
role assertion

C  D CI  DI
R  S RI  SI
aI  CI
C(a)
aI, bI  RI
R(a, b)

We say that O entails an axiom  (written O |= ), if every model of O satisfies . We
say that O is concept materialized if A(a)  O whenever O |= A(a), A  con(O) and
a  ind(O); O is role materialized if R(a, b)  O whenever O |= R(a, b), R  rol(O),
a, b  ind(O); O is materialized if it is both concept and role materialized.
Remark 1. Some definitions do not present nominals as primitive symbols, but use a
special nominal constructor {a} with individual a (in this case, {a}I
I}). We can
easily convert such ontologies to our representation by renaming every nominal {a}
with the corresponding nominal symbol oa and adding a concept assertion oa(a). This
transformation is a conservative extension, i.e., it preserves all original entailments.

= {a

4 Computing ABox Materialization by Abstraction

The typical OBDA scenario is such that the ABox contains a large number of individuals and its size is significantly larger than the size of the TBox. Hence, the number
of different concept names is typically much smaller than the number of different in-
dividuals, which also means that many individuals are instances of the same concepts.
If we can identify individuals that yield the same consequences, we can compute the
materialization by computing entailed consequences only for representative individuals.

4.1 Bi-homomorphic Individuals and Individual Types

In order to (syntactically) characterize individuals that yield the same consequences, we
study structure-preserving transformations of ABoxes.
?

?

?
Definition 1. Let A and B be two ABoxes and h : ind(A)  ind(B) a mapping from
the individuals in A to individuals in B. We extend h to axioms in a straightforward
way: h(C(a)) = C(h(a)), h(R(a, b)) = R(h(a), h(b)), and h() =  for other
axioms . We say that h is a homomorphism (from A to B) if h(A)  B. An individual
a in A is homomorphic to an individual b in B if there exists a homomorphism h from
A to B such that h(a) = b; in addition, if b is homomorphic to a, then a and b are
bi-homomorphic.
Example 1. Consider the ABox A = {R(a, a), R(a, b), R(b, b)}. Then the mappings
h1 = {a  b, b  b} and h2 = {a  a, b  a} are homomorphisms from A to A.
Since h1(a) = b and h2(b) = a, the individuals a and b are bi-homomorphic. Note that
there is no isomorphism h from A to A (a bijective homomorphism such that its inverse
is also a homomorphism) such that h(a) = b or h(b) = a.

It is easy to show that entailed axioms are preserved under homomorphisms between
ABoxes. In particular, bi-homomorphic individuals are instances of the same concepts.
Lemma 1. Let h : ind(A)  ind(B) be a homomorphism between ABoxes A and B.
Then for every TBox T and every axiom , A  T |=  implies B  T |= h().
Proof. We show that Lemma 1 even holds for SROIQ without unique name as-
sumption. Suppose that A  T |= . Then h(A  T ) |= h(). Since h(A  T ) =
h(A)  h(T ) = h(A)  T  B  T , by monotonicity we obtain B  T |= h().

Corollary 1. If individuals a and b in an ABox A are bi-homomorphic, then for every
TBox T and every concept C, we have A  T |= C(a) if and only if A  T |= C(b).

If an ABox does not have role assertions, the bi-homomorphic individuals are exactly those that have the same concepts in the assertions. Hence, we can identify bihomomorphic individuals by just looking at their typesthe set of concepts of which
the individual is an (asserted) instance. Clearly, the number of different types, and hence
the maximal number of individuals that are not bi-homomorphic to each other is at most
exponential in the number of different concepts used in the ABox. With role assertions,
however, we cannot decide whether individuals are bi-homomorphic by just looking at
their assertions. In fact, the number of non-bi-homomorphic individuals can be arbitrary
large even if just one role is used in role assertions and there are no concept assertions.
Example 2. Consider an ABox A = {R(ai1, ai) | 1 < i  n}. It can be easily shown
that the only homomorphism h : ind(A)  ind(A) from A to A is the identity h =
{ai  ai | 1  i  n}, i.e., no different individuals in A are bi-homomorphic to each
other. In fact, it is easy to find a TBox T with which all individuals in A entail different
sets of assertions. Indeed, take T = {  A1, Ai1  R.Ai, 1 < i  n}. Then we
have A  T |= Aj(ai) if and only if 1  j  i  n.

From Example 2 one can see that with many role assertions, an ABox is less likely
to have many bi-homomorphic individuals. Note from Corollary 1 that if two individuals are bi-homomorphic, then they entail the same assertions w.r.t. every TBox. This
property is too strong for our purpose, as we need to deal with just one given TBox. It
?

?

?
can be that many (non-bi-homomorphic) individuals are still materialized in the same
way. To take this into account, instead of partitioning the individuals in equivalence
classes according to the bi-homomorphism relation, we start with an approximation to
this relation, which makes more individuals equivalent. As soon as entailed assertions
are obtained using a reasoner that distinguish elements within the same equivalence
class, we refine our approximation and repeat the process until the fixpoint.
Definition 2. Let A be an ABox. The type of an individual a (w.r.t. A) is a triple
tp(a) = (tp(a), tp(a), tp(a)) where tp(a) = {C | C(a)  A}, tp(a) = {R |
b : R(a, b)  A}, and tp(a) = {S | c : S(c, a)  A}.
Intuitively, the type of an individual is obtained by considering all assertions in which
this individual occurs in the ABox, and ignoring all other individuals in these assertions.
Note that bi-homomorphic individuals have the same types, so the relation between
individuals of the same types is an approximation to the bi-homomorphism relation.

4.2 Abstraction of an ABox

If we compress the ABox by simply merging all individuals with the same type into one,
we might obtain unexpected entailments, even if all individuals are bi-homomorphic.
Example 3. Consider the following ABox A = {R(a, b), R(b, a)}. Clearly, a and b are
bi-homomorphic in A. Let B = {R(a, a)} be obtained from A by replacing individual b
with a, and let T = {  B  C, R.B  C}. It is easy to check that BT |= C(a),
but A  T |= C(a) (and hence A  T |= C(b)).
We could follow the approach in the SHER system and compute justifications for entailed assertions to determine which individuals should not be merged, but our goal is
to avoid such computationally expensive operations. Instead of merging all individuals
with the same type into one, we realize every individual type in our abstract ABox. With
abstract ABoxes defined as follows, we can guarantee that assertions that are entailed
for the representative individuals also hold for the original individuals.
Definition 3 (ABox Abstraction). The abstraction of an ABox A is an ABox B =

aind(A) Btp(a), where for each type tp = (tp, tp, tp), we define Btp = {C(xtp) |
C  tp}  {R(xtp, yR
) | R  tp}  {S(zS
tp , and zS
tp
are fresh distinguished abstract individuals.

tp, xtp) | S  tp}, where xtp, yR

tp

Intuitively, the abstraction of an ABox is a disjoint union of small ABoxes witnessing
each individual type realized in the ABox.
Example 4. Consider the ABox A = {A(a), A(d), R(a, b), R(a, e), R(b, c), R(b, e),
R(c, a), R(d, c), R(e, d)}. We have tp(b) = tp(c) = tp(e) = tp1 = (,{R}, {R}) and
tp(a) = tp(d) = tp2 = ({A},{R},{R}). The abstraction of A is B = Btp1
 Btp2 with
Btp1
), R(zR

= {R(xtp1 , yR
The following lemma shows the soundness of concept assertions derived from the

= {A(xtp2

), R(xtp2, yR
tp2

)}, Btp2

), R(zR

tp1, xtp1

tp1

)}.

tp2 , xtp2

abstraction.
?

?

?
tp

B. Glimm et al.

Lemma 2. Let A be an ABox, B its abstraction, and T a TBox. Then for every type
tp = (tp, tp, tp), every a  ind(A) with tp(a) = tp w.r.t. A, and every concept C:
(1) B  T |= C(xtp) implies A  T |= C(a),
(2) B  T |= C(yR
) and R(a, b)  A implies A  T |= C(b), and
) and S(c, a)  A implies A  T |= C(c).
(3) B  T |= C(zS
Proof. Consider all mappings h : ind(B)  ind(A) such that:
h(xtp)  {a  ind(A) | tp(a) = tp},
)  {b | R(h(xtp), b)  A}, and
h(yR
tp
)  {c | S(c, h(xtp))  A}.
h(zS
tp

Clearly, h(B)  A for every such mapping h. Furthermore, for every a  ind(A), every
R(a, b)  A and every S(c, a)  A, there exists h with h(xtp) = a, h(yR
) = b, and

h(zS
tp

) = c for tp = tp(a). Hence, claims (1)(3) follow by Lemma 1.

tp

tp and zS

4.3 Abstraction Refinement
Note that the individuals from an ABox A may correspond to several abstract individuals
in the ABox abstraction B: Each individual a corresponds to the abstract individual xtp
for tp = tp(a). In addition, if R(b, a)  A or S(a, b)  A for some individual b, then a
also corresponds to yR
tp respectively for tp = tp(b). The additional individuals yR
tp
and zS
tp were introduced intentionally to refine the initial abstraction when new assertions
of abstract individuals are derived, which in turn, can be used to derive new assertions
of individuals in A. Specifically, assume that we have materialized all entailed atomic
assertions for the abstract ABox B w.r.t. the TBox using a reasoner. By Lemma 2, the
corresponding assertions must also be entailed in the original ABox A. In particular, by
case (1), the new assertions computed for the individual xtp, also hold for every individual
a in A with tp(a) = tp. If we add all such assertions to the original ABox A, these
individuals would still have the same types, so even by building a new abstraction for
the extended ABox, we would not derive new assertions for the abstraction. On the other
hand, if we add the new assertion according to cases (2) and (3) of Lemma 2, we may
obtain different assertions for individuals that previously had the same types. Indeed, if
R(a, b)  A, and we have derived a new assertion A(b) using case (2) of the lemma,

then it is not necessary that a similar assertion A(b
with
)  A
tp(b
) = tp(a), for which this case also applies. Hence, adding the newly derived
with tp(a
assertions using Lemma 2 may refine the types of the original individuals and, in turn,
result in a new abstraction, for which new assertions can be derived once again.
The above suggests the following materialization procedure based on abstraction
refinement. Given an ontology O = A  T we proceed as follows:
1. Build an initial abstraction B of A according to Definition 3.
2. Materialize B  T using a reasoner.
3. Extend A with the newly derived assertions according to Lemma 2.
4. Update the types of the individuals in A and re-compute its abstraction B.
5. Repeat from Step 2 until no new assertions can be added to A.

) = tp(b), because it is not necessarily the case that there exists R(a

) will be derived for every b
, b
?

?

?
ABox: A =

A(I)
a

B(II)

e

B(II), A(III)

b

d

c

A(I)

B(II)

TBox: T =
A  R.B
B  R.A

Materialized

abstract ABoxes

yR
tp1
xtp1
zR
tp1

yR
tp2
xtp2
zR
tp2

yR
tp3
xtp3
zR
tp3

yR
tp4
xtp4
zR
tp4

+B

+A

+B

A, B

+A

Abstractions

{c, e, a, d}
{b, c, e}
{a, b, d}
{b, e, c}
{a, d}
{c, e}

{b, e, c}
{a, d}
{c, e}
{c, e, a, d}
{b, e, c}
{a, b, d}

{b, e, c}
{a, d}
{c, e}
{a, d}
{c, e}
{b, d, a}
{c, e}
{b}
{a}

Fig. 1. The abstractions I-III produced in Example 5. Each abstraction consists of the ABoxes
corresponding to the four individual types. The inferred assertions are indicated with the + sign
and are added to the corresponding original individuals shown in each column. The materialized
assertions in the original ABox are labeled with the first iteration in which they appear.



Example 5 (Example 4 continued). Let AI be the ABox A from Example 4 and T =
{A  R.B, B  R
.A} a TBox. Let BI be the abstraction B of AI = A computed
in Example 4 (see Figure 1). By materializing BI w.r.t. T we get B(yR
), from which
we obtain AII = AI  {B(b), B(e), B(c)} using Lemma 2. Recomputing the types
of individuals in AII yields tp(b) = tp(c) = tp(e) = tp3= ({B}, {R}, {R}), while
the types of a and d remain unchanged. The abstraction of AII is thus BII = Btp2

Btp3, where Btp3
)}. By materializing BII, we get
), from which we obtain AIII = AII  {A(b)}. We again recompute the types of
A(zR
individuals in AIII, which gives tp(b) = tp4 = ({A, B},{R},{R}), while the types of
tp3
 Btp3

the other individuals do not change. The abstraction of AIII is thus BIII = Btp2
Btp4, where Btp4
)}. Materializing BIII
), R(zR
yields B(yR
), which correspond to B(c), B(e), and A(a). However, those
assertions already exist in AIII, so the procedure terminates.
tp4

= {B(xtp3

= {A(xtp4

), R(xtp4 , yR
tp4

), R(xtp3, yR
tp3

), R(zR

tp3 , xtp3

tp2

), B(xtp4

tp4, xtp4

) and A(zR
tp4

The abstraction refinement procedure terminates since after every iteration except the
last one, new atomic assertions must be added to A, and there is a bounded number of
such assertions. Specifically, the number of iterations is at most ||ind(O)||  ||con(O)||.
The number of realized individual types in every ABox A, and hence the size of every
abstract ABox B, is at most exponential in the number of different concepts and roles
in O. In practice, however, it is likely to be much smaller since not every possible type
is realized in real ontologies. Note also that in practice, it is not necessary to add the
newly derived assertions explicitly to the original ABoxone can recompute the new

B. Glimm et al.

types using some simple operations on the sets of individuals (intersection and unions),
and keep the derived assertions only once for every new equivalence class. Note also
that without nominals, we can exploit that B is a disjoint union of very simple ABoxes
corresponding to the types of individuals, so they can be materialized independently
of each other. This is particularly useful for updating the abstraction since only those
ABoxes that correspond to newly created types should be materialized at every iteration.

5 Completeness

Lemma 2 guarantees that at every point of the iteration, our abstraction refinement
procedure adds only entailed assertions to the ABox A. In other words, our procedure
is sound. The main question of this section is, whether our procedure is complete, i.e.,
whether we always compute all entailed atomic assertions in this way. Unfortunately,
this is in general not the case, as demonstrated by the following example.
Example 6. Consider the ABox A = {A(a), R(a, b), B(b)} and the TBox T = {B 
C  D,R.C  C, A  C  R.D}. Note that A  T |= D(b). Let us compute
the materialization using abstraction. We have tp(a) = ({A},{R},) and tp(b) =
({B},,{R}). Therefore B = Btp(a)  Btp(b), where Btp(a) = {A(xtp(a)), R(xtp(a),
tp(a))} and Btp(b) = {B(xtp(b)), R(zR
tp(b), xtp(b))}. It is easy to see that B  T does
yR
not entail any new atomic concept assertions. Hence, our procedure terminates after the
first iteration without producing the entailment A  T |= D(b).

The primary reason why our method does not work in this example is that our abstraction breaks the ABox into disconnected parts, which cannot communicate the nondeterministic choices, e.g., for the disjunction CD. The only communication between
ABoxes happens through the entailment of new assertions. If the ontology language
does not allow such non-deterministic constructors, it is possible to obtain a complete
procedure.

5.1 Horn ALCHOI
While the results on the previous sections hold for ALCHOI in general (and even extensions thereof), we restrict ontologies in this section to a Horn fragment of ALCHOI:

Definition 4 (Horn ALCHOI). An ALCHOI ontology O is Horn if, for every concept assertion D(a) and every axiom C  D, the concepts C and D satisfy, respec-
tively, the following grammar definitions:

C(i) ::=  |  | A | o | C1  C2 | C1  C2 | R.C,
D(i) ::=  |  | A | o | D1  D2 | R.D | R.D | C.

(1)
(2)

Intuitively, negations and universal restrictions should not occur negatively, and disjunctions should not occur positively. We can also allow TBox axioms that are equivalent
to Horn axioms. For example, A  R.  S.(B  C) is not Horn according to
Definition 4, but is equivalent to the Horn axiom A  R.  S.(B  C).
?

?

?
It is a well-known property of Horn languages that every consistent Horn ontology
has a so-called canonical model that entails exactly the consequences entailed by the
ontology. For the purpose of the paper, we require a weaker version of this property that
speaks only about entailment of atomic concept assertions.
Theorem 1 (Weak Canonical Model Property for Horn ALCHOI). Every consistent Horn ALCHOI ontology O has a model I such that I |= A(a) implies O |= A(a)
for every atomic concept assertion A(a) with a  ind(O) and A  con(O).
Theorem 1 can be proved using the property that Horn ALCHOI models are closed
under direct products. Then a canonical model is obtained from the direct product of
models refuting (finitely many) atomic non-types.

), R(zR

tp2, xtp2

T  |= X(zR

tp2

 T  |= C(xtp3

= {A(xtp1

), R(xtp1 , yR
tp1

 T |= (R.B)(zR

tp2

 Btp2 consist of two ABoxes Btp1

Before formulating our completeness result, we need to solve one small technical
problem illustrated in the following example.
Example 7. Consider A = {A(a), B(b), R(a, b)} and T = {A  R.B  C}, which
consist of Horn axioms. Clearly, A  T |= C(a). A realizes two different individual
types: tp(a) = tp1 = ({A},{R},) and tp(b) = tp2 = ({B},,{R}), so our ab-
)}, and
straction B = Btp1
Btp2
)}. In neither of these ABoxes we obtain a new assertion
after materialization, so our procedure terminates without deriving C(a).

= {B(xtp2
In order to see how to fix this problem, note that Btp2

), so there
is an entailed assertion, just not an atomic one. To capture this inference, we introduce
a new concept that defines R.B. Specifically, let T  = {R.B  X, A  X  C}
where X is a fresh concept name. Clearly, T 
is a conservative extension of T (one can
by interpreting X as R.B), so the assertions
extend every model of T to a model of T 
for A, B, and C entailed by T 
we can derive a
new assertion Btp2
). If we now add the corresponding assertion X(a) to
A and recompute the abstraction for the updated type tp(a) = tp3 = ({A, X},{R},)
(tp(b) does not change), we have Btp3
)}, and obtain
Btp3
Example 7 suggests that to achieve completeness, we need to represent existential restrictions on the left hand side of the axioms using new atomic concepts. Note that
R.B  X is equivalent to B  R
.X. Thus we can just require that there are
no existential restrictions on the left hand side of concept inclusions, and all universal
restrictions on the right have only atomic concepts as fillers.
Definition 5 (Normal Form for Horn ALCHOI). Horn ALCHOI axioms D(a) and
C  D are in normal form if they satisfy the following grammar definitions:

are the same as for T . However, with T 

), which gives us the intended result.

), X(xtp3

), R(xtp3, yR
tp3

= {A(xtp3



C(i) ::= |  | A | o | C1  C2 | C1  C2
D(i) ::= |  | A | o | D1  D2 | R.D | R.A | C

(3)
(4)
Intuitively, in addition to the constraints for Horn ALCHOI ontologies given by (1)
and (2) of Definition 4, negative occurrences of existential restrictions are not allowed,
and (positive) occurrences of universal restrictions can only have concept names as
fillers. It is easy to convert axioms to such a normal form using the well-known structural transformation. Specifically, we can repeatedly replace every existential restriction
?

?

?
B. Glimm et al.

R.C in (1) with a fresh concept name X and add a new axiom C  R
.X. Likewise,
we can replace every universal restriction R.D in (2) with R.Y for a fresh concept
name Y and add an axiom Y  D. As with Horn axioms, we do not actually need
the axioms in the TBox to be syntactically in the normal form. It is sufficient that they
are equivalent to axioms in the normal form  the reasoner will still produce the same
result. For example, an axiom R.(A1  A2)  B1  B2 can be left untouched because
it is equivalent to an axiom A1  A2  R
.B2 in normal form. Note that
the axiom A  R.B  C in T from Example 7 is not equivalent to the pair of axioms
R.B  X, A  X  C in T 
because the latter axioms contain a new symbol X. In
fact, A  R.B  C is not equivalent to any axiom(s) in normal form.

.B1  R





5.2 Completeness Proof

tp

) and R(a, b)  A implies A(b)  A, and
) and S(c, a)  A implies A(c)  A.

We are now ready to show the following completeness result:
Theorem 2. Let O = A  T be a normalized Horn ALCHOI ontology and B the
abstraction of A. O is concept materialized if, for every type tp = (tp, tp, tp),
every individual a  ind(A) with tp(a) = tp, and every atomic concept A, we have:
(1) B  T |= A(xtp) implies A(a)  A,
(2) B  T |= A(yR
(3) B  T |= A(zS
Proof. To prove Theorem 2, we extend the abstraction B of A with new role assertions
R(xtp(a), xtp(b)) for every R(a, b)  A. Let us denote this extended abstract ABox by
B
. Since, for every C(a)  A, we also have C  tp(a) and, thus, C(xtp(a))  B  B
,
the mapping h : ind(A)  ind(B) defined by h(a) = xtp(a) is a homomorphism from
. Therefore, by Lemma 1, if A  T |= A(a), then B  T |= A(xtp(a)). The key
A to B
part of the proof is to demonstrate that in this case we also have B  T |= A(xtp(a)).
That is, the extended abstract ABox B
does not entail new atomic concept assertions
compared to B. It follows then that A(a)  A by condition (1) of the theorem. This
implies that O is concept materialized.

tp

To prove that B

entails the same atomic concept assertions as B, we use the remaining conditions (2) and (3) of Theorem 2 and the canonical model property formulated in Theorem 1. Note that since new role assertions of the form R(xtp(a), xtp(b))
only if R(a, b)  A, we have R  tp(a) and R  tp(b) by Defare added to B
tp(a))  B and likewise
inition 2. Therefore, we already had role assertions R(xtp(a), yR
tp(b), xtp(b))  B for the same role R. Furthermore, by condition (2) of Theorem 2,
R(zR
if B  T |= A(yR
tp(a)), then since R(a, b)  A, we also have A(b)  A, and thus
A(xtp(b))  B. Likewise, by condition (3), if B  T |= A(zR
tp(b)), then A(xtp(a))  B.
The following lemma shows that with these properties for B, after adding the new role
assertion R(xtp(a), xtp(b)) to B, no new atomic concept assertions can be entailed.
Lemma 3 (Four-Individual Lemma). Let O be a normalized Horn ALCHOI ontology such that {R(x1, y1), R(z2, x2)}  O for some x1, y1, z2, x2, and R. Further,
assume that for every concept name A we have:
?

?

?
(1) O |= A(y1) implies O |= A(x2), and
(2) O |= A(z2) implies O |= A(x1).
Finally, let O = O{R(x1, x2)}. Then for every concept name A and every individual
a, we have O |= A(a) implies O |= A(a).
Proof (Sketch). Suppose that O |= A(a). We will show that O |= A(a). If O is inconsistent then this holds trivially. Otherwise, there exists a model I of O satisfying
that coincides with I apart from
Theorem 1. From I we construct an interpretation I
the interpretation of role names. With the given individuals x1 and x2, for every role
name S we define





I

I 

{(x
2 )}
?

?

?
1 , x
{(x
1 )}
?

?

?
2 , x
1 )}
{(x
?

?

?
2 ), (x
2 , x
1 , x

We will prove that I

|= O

= S

thus I |= A(a) by definition of I
Theorem 1.

if O |= R  S and O |= R  S

if O |= R  S
and O |= R  S
if O |= R  S and O |= R  S

otherwise



, which implies I

|= A(a) since O |= A(a), and
, from which O |= A(a) follows since I satisfies

I

I

I = C

I

  S

with d, d

, we need to prove that d

First, we prove by induction that for each C and D defined respectively by (3) and
I  D
. The only non-trivial case is D = S.A with
and D
(4), we have C
O |= R  S and S  rol(O) (the case where S is an inverse role can be proved
analogously). Take any d  D
. To show that d  D
  A

I
. If d, d
 =
  S
I

for every d
x
2. By assumption, I |= R(x1, y1) and O |= R  S, hence, I |= S(x1, y1),
?

?

?
1 , x
1  D
. Thus I |= A(y1). Since
?

?

?
which, together with d = x
, implies y
I satisfies Theorem 1, we have O |= A(y1). By Condition (1), O |= A(x2). Thus
1  D
2  A
 = x
?

?

?
, and hence, d = x
d
with O = O  {R(x1, x2)}. Since I |= O, for
It remains to show that I |= O
every C  D  O we have C
I  D
, for every D(a)  O we have
= C
I 
I  D
I
= a
a
ensures that for every role inclusion S  P  O
. Finally, the definition of I
I  R
I

I  P

we have S

, this is obvious. Otherwise, d, d
1  A
?

?

?
, and that I |= R(x1, x2). Thus I |= O

, and for every R(a, b)  O we have a

, what was required to show.

I = a

I
I = A

I  D

I  D

, b

I

, b

I

I

I

I

I

.

By repeatedly applying Lemma 3 for each x1 = xtp(a), y1 = yR
z2 = zR
assertions that are entailed by B, which completes the proof of Theorem 2.

tp(b) and R such that R(a, b)  A, we obtain that B

tp(a), x2 = xtp(b),
entails only those atomic
?

?

?
6 Implementation and Evaluation

To evaluate the feasibility of our approach, we implemented the procedure sketched in
Section 4.3 in Java. The system relies on Neo4j 1.9.42 to store the ABoxes and uses an
external OWL reasoner for materializing the abstractions.

2 http://www.neo4j.org

B. Glimm et al.

Table 2. Test suite statistics with the number of atomic concepts in the ontology (#A and #AN
for the normalized ontology), roles (#R), individuals (#I), role (#R(a, b)) and concept (#A(a))
assertions, and the number of concept assertions inferred by the system

Ontology
Gazetteer
Coburn
LUBM 1
LUBM 10
LUBM 50
LUBM 100
LUBM 500
UOBM 1
UOBM 10
UOBM 50
UOBM 100
UOBM 500
?

?

?
#I
516 150
123 515
17 174
207 426
1 082 818
2 153 645

#R(a, b)
604 164
237 620
49 336
630 753
3 298 813
6 645 928

#A(a)
#R
#A #AN
11 112
?

?

?
297 002
719 1 161 109
18 128

219 680

1 147 136
?

?

?
2 281 035
25 10 189 173 31 073 066 10 793 509
44 680
?

?

?
434 115
2 197 035
?

?

?
4 409 891
35 12 379 113 76 612 736 22 168 148

153 571
24 925
1 500 628
242 549
1 227 445
7 594 996
2 462 012 15 241 909
?

?

?
#A(a) inferred
538 799
535 124
48 326
593 485
3 097 722
6 164 538
29 169 321
142 747
1 381 722
6 991 583
14 027 772
72 215 007

The goal of our evaluation is to estimate whether our assumption that in relatively
simple ontologies with large ABoxes the number of realized types and, consequently,
the size of the abstract ABoxes is small. Furthermore, we analyze whether it is indeed
the case that real-world ontologies have relatively simple axioms that do not require
many refinement steps, where a refinement step is the process of refining the individual
types.

We selected ontologies with large ABoxes that are also used to evaluate other ap-
proaches.3 Table 2 provides relevant metrics for the test ontologies. Gazetteer is from
the NCBO BioPortal, Coburn is a large bio ontology from the Phenoscape project, and
LUBM (UOBM) refers to the Lehigh University Benchmark4 (the University Ontology
Benchmark).5 LUBM n (UOBM n) denotes the data set for n universities. Gazetteer
is genuinely within Horn ALEO and the remaining ontologies have been converted to
Horn ALCHOI. Note that the increase of normalized concepts (AN ) in comparison
to the original concepts (A) in Table 2 is a rough indicator of TBox complexity, which
adds extra workload to reasoners.

Tables 3 and 4 show the results of computing and iteratively refining the abstract
ABoxes until the fixpoint. The second column in Table 3 shows the number of refinement steps. The third and fourth (fifth and sixth) columns show the number of individuals (assertions) in the first and last abstraction, respectively, while the last four columns
show the according relative reduction in percent compared to the original ABoxes. Table 4 shows the type statistics, i.e. the number of types and the average number of
individuals, concept names, and property names per type.

In general, the abstract ABoxes are significantly smaller than the original ones and
the ontologies can be materialized with few refinement steps. For ontologies with

3 Download and references at http://www.derivo.de/dl14-ontologies/
4 http://swat.cse.lehigh.edu/projects/lubm
5 http://www.cs.ox.ac.uk/isg/tools/UOBMGenerator
?

?

?
Table 3. Number of refinement steps, size of the abstract ABoxes, and size of the abstract ABoxes
in comparison with the original ABoxes for the first and the last abstraction

Ontology

Gazetteer
Coburn
LUBM 1
LUBM 10
LUBM 50
LUBM 100
LUBM 500
UOBM 1
UOBM 10
UOBM 50
UOBM 100
UOBM 500

# of
steps
?

?

?
Abstract ABox size

# indiv.

5 640
4 059
?

?

?
Abstract ABox size (%)
% indiv.
1.09
3.23
0.81
0.07
0.01

% assertions
# assertions
1.09 0.79 1.31
5 142
5 640
3.29 1.04 2.16
5 569
3 992
0.81 0.21 0.38
?

?

?
0.07 0.02 0.03
?

?

?
0.01 0.003 0.006
?

?

?
0.007 0.007 0.002 0.003
?

?

?
0.001 0.001 0.001 0.001
?

?

?
101 324 101.82 157.76 15.97 51.11
39 322 31 659
25 378
448 400
40.51 69.92 6.46 23.18
169 579 125 056
98 266
18.43 32.26 2.97 10.80
395 956 290 652 1 057 854
226 176
12.66 22.23 2.05 7.49
311 574
547 361 402 188 1 472 058
596 135 1 033 685 772 920 2 806 786
8.35 0.78 2.84

8 512
8 633
?

?

?
4.82

simple TBoxes, which contain mostly atomic concept
inclusions, domains and
ranges for roles, and conjunctions, only one refinement step is required. This is the
case since any concept assertion derived for a successor or predecessor of an abstract
individual is also derived for the individual itself. LUBM and UOBM additionally contain universal quantifications, e.g. Department  headOf
.Chair (rewritten from
headOf.Department  Chair), but these axioms do not create long propagations of
concept Assertions over roles. For LUBM, many individuals have similar types and can
be grouped into equivalence classes. This results in an extremely good compression
with abstractions of nearly constant size for arbitrarily many LUBM universities. For
instance, the final abstractions are just 0.38 % (for LUBM 1) and 0.001 % (for LUBM
500) of the size of the original ABox. This and the fact that only one refinement step
is needed also explains that other related approaches like SHER and Wandelts and
M ollers approach show a very good performance for LUBM. UOBM also contains
nominals and the individuals are more diverse than in LUBM. Thus, UOBM requires
one more refinement step compared to LUBM.

Our qualitative performance evaluation confirms the correlation between the size of
abstract ABoxes and the total time for the materialization. We compared the respective
materialization times of the original ABox with the sum of materialization times for
all abstract ABoxes using the reasoners HermiT and Konclude.6 For ontologies with
small abstract ABoxes such as LUBM, Gazetteer and Coburn, the sum of the reasoning
times for all abstract ABoxes is less than a tenth of the reasoning time for the original
ABox. While the runtimes for the abstractions of UOBM 1 are still 2 to 4 times that of
the original ABox, the runtimes for UOBM 50 are already down by 50%. The original
UOBM 100 ontology could neither be processed within eight hours by HermiT nor by
Konclude with a 32 GB RAM limit run on Intel Xeon E5-2440 6 cores, but its abstraction can easily be materialized, e.g., within 84 seconds and 8 GB RAM by Konclude.
Currently, we re-compute the abstraction after each refinement step. There is certainly

6 See http://www.hermit-reasoner.com and http://www.konclude.com

B. Glimm et al.

Table 4. Statistics about individual types for the first and the last abstraction: number of individual
types, average number of individuals, concept names, and property names per individual type

Ontology

# Individual

Individual type statistics

types

# indiv. / type

1 845
1 056
?

?

?
3 104

Gazetteer
Coburn
LUBM 1
LUBM 10
LUBM 50
LUBM 100
LUBM 500
4 705
UOBM 1
11 453 17 347
UOBM 10
25 636 43 283
UOBM 50
UOBM 100 34 992 59 184
UOBM 500 65 148 108 691
?

?

?
7 153

#AN / type #R / type
280 0.73 2.56 2.05 2.05
1 845
115 2.49 5.27 2.79 2.79
1 072
572 1.13 4.83 3.63 3.63

7 153 1.14 5.38 4.31 4.31

40 104 40 104 1.15 5.56 4.48 4.48
?

?

?
79 765 79 765 1.15 5.56 4.48 4.48
27 377 377 377 377 1.15 5.56 4.48 4.48
5 3.02 14.18 7.18 7.35
14 3.34 15.48 7.58 7.86
28 3.52 16.29 7.82 8.14
42 3.59 16.62 7.91 8.24
114 3.71 17.31 8.15 8.51
?

?

?
room for optimizations, e.g. by updating the types and computing the abstractions in-
crementally.

7 Conclusions and Future Work

We have presented an approach for ontology materialization based on abstraction re-
finement. The main idea is to represent ABox individuals using several (overlapping)
equivalent classes and to use information derived for their abstract representatives to
refine the abstraction. Although the approach does not necessarily guarantee that the
abstraction is always smaller than the original ABox, the method particularly pays off
for ontologies with large ABoxes and relatively small and simple TBoxes.
Currently, our approach is complete for Horn ALCHOI ontologies due to the property that only (deterministically) derived assertions are used for abstraction refinement.
We could potentially extend our approach to non-Horn ontology languages by exploiting additional information about non-deterministically derived instances as provided,
for example, by the HermiT reasoner [7]. Some Horn features, on the other hand, could
be supported, e.g., it is easy to support transitive roles and role chains by using the
well-known encoding of these axioms via concept inclusions [13].
In this paper we mainly focus on concept materialization since role materialization
for Horn ALCHOI can essentially be computed by expanding role hierarchies (spe-
cial care needs to be taken of nominals though). When ontologies contain role chains
and functional roles, however, materialization of role assertions becomes less trivial,
e.g. the encoding of role chains is not enough and a naive encoding of functionality is
inefficient. We currently investigate how these features can efficiently be supported.

Since the abstraction consists of disjoint parts, these parts can be processed independently of each other (if nominals are taken care of). This can be used in the refinement
steps to process only the parts that have really changed or for an efficient support of
updates to the ABox. In addition, the abstract ABoxes could serve not only as a generic
?

?

?
interface for communication with the reasoner, but also as a compact representation of
the materialization. This can be particularly useful when answering instance and conjunctive queries over the materialized ABoxes, where the abstraction can be used to
prune the search space.
