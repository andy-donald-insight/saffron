Detecting and Correcting Conservativity Principle

Violations in Ontology-to-Ontology Mappings

Alessandro Solimando1, Ernesto Jim enez-Ruiz2, and Giovanna Guerrini1

1 Dipartimento di Informatica, Universit`a di Genova, Italy

2 Department of Computer Science, University of Oxford, UK

Abstract. In order to enable interoperability between ontology-based systems,
ontology matching techniques have been proposed. However, when the generated mappings suffer from logical flaws, their usefulness may be diminished. In
this paper we present an approximate method to detect and correct violations to
the so-called conservativity principle where novel subsumption entailments between named concepts in one of the input ontologies are considered as unwanted.
We show that this is indeed the case in our application domain based on the EU
Optique project. Additionally, our extensive evaluation conducted with both the
Optique use case and the data sets from the Ontology Alignment Evaluation Initiative (OAEI) suggests that our method is both useful and feasible in practice.

1 Introduction

Ontologies play a key role in the development of the Semantic Web and are being used
in many diverse application domains, ranging from biomedicine to energy industry. An
application domain may have been modeled with different points of view and purposes.
This situation usually leads to the development of different ontologies that intuitively
overlap, but they use different naming and modeling conventions.

In particular, this is the case we are facing in the EU Optique project.1 Optique aims
at facilitating scalable end-user access to big data in the oil and gas industry. The project
is focused around two demanding use cases provided by Siemens and Statoil. Optique
advocates for an Ontology Based Data Access (OBDA) approach [24] so that end-users
formulate queries using the vocabulary of a domain ontology instead of composing
queries directly against the database. Ontology-based queries (e.g., SPARQL) are then
automatically rewritten to SQL and executed over the database.

In Optique two independently developed ontologies co-exist. The first ontology has
been directly bootstrapped from one of the relational databases in Optique and it is
linked to the database via direct ontology-to-database mappings;2 while the second
ontology is a domain ontology based on the Norwegian Petroleum Directorate (NPD)
FactPages3 [41] and it is currently preferred by Optique end-users to feed the visual
query formulation interface4 [42]. This setting requires the query formulation ontology to be linked to the relational database. In Optique we follow two approaches that

1 http://www.optique-project.eu/
2 http://www.w3.org/TR/rdb-direct-mapping/
3 http://factpages.npd.no/factpages/
4 The query formulation interface has been evaluated with end-users at Statoil.

P. Mika et al. (Eds.) ISWC 2014, Part II, LNCS 8797, pp. 116, 2014.
c Springer International Publishing Switzerland 2014

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

will complement each other: (i) creation of ontology-to-database mappings between
the query formulation ontology and the database; (ii) creation of ontology-to-ontology
mappings between the bootstrapped ontology and the query formulation ontology. In
this paper we only deal with ontology-to-ontology mappings (or mappings for short).
The creation, analysis and evolution of ontology-to-database mappings are also key
research topics within Optique, however, they fall out of the scope of this paper.

The problem of (semi-)automatically computing mappings between independently
developed ontologies is usually referred to as the ontology matching problem. A number of sophisticated ontology matching systems have been developed in the last years
[11, 40]. Ontology matching systems, however, rely on lexical and structural heuristics
and the integration of the input ontologies and the mappings may lead to many undesired logical consequences. In [19] three principles were proposed to minimize the
number of potentially unintended consequences, namely: (i) consistency principle, the
mappings should not lead to unsatisfiable classes in the integrated ontology, (ii) locality
principle, the mappings should link entities that have similar neighbourhoods, (iii) conservativity principle, the mappings should not introduce new semantic relationships
between concepts from one of the input ontologies.

The occurrence of these violations is frequent, even in the reference mapping sets
of the Ontology Alignment Evaluation Initiative5 (OAEI). Also manually curated align-
ments, such as UMLS-Metathesaurus [3] (UMLS), a comprehensive effort for integrating biomedical knowledge bases, suffer from these violations. Violations to these principles may hinder the usefulness of ontology mappings. In particular, in the Optiques
scenario, violation of the consistency or conservativity principles will directly affect the
quality of the query results, since queries will be rewritten according to the ontology
axioms, the ontology-to-ontology mappings and the ontology-to-database mappings.

These principles has been actively investigated in the last years (e.g., [31, 30, 15, 19,
17, 29, 37]). In this paper we focus on the conservativity principle and we explore a
variant of violation of this principle which we consider appropriate for the application
domain in Optique. Furthermore, this variant of the conservativity principle allows us to
reduce the problem to a consistency principle problem. We have implemented a method
which relies on the projection of the input ontologies to Horn propositional logic. This
projection allows us to be efficient in both the reduction to the consistency principle and
the subsequent repair process. Our evaluation suggests that our method is feasible even
with the largest test cases of the OAEI campaign.

The remainder of the paper is organised as follows. Section 2 summarises the basics
concepts and definitions we will rely on along the paper. In Section 3 we introduce our
motivating scenario based on Optique. Section 4 describes our method. In Section 5 we
present the conducted evaluation. A comparison with relevant related work is provided
in Section 6. Finally, Section 7 gives some conclusions and future work lines.

2 Preliminaries

In this section, we present the formal representation of ontology mappings and the notions of semantic difference, mapping coherence and conservativity principle violation.

5 http://oaei.ontologymatching.org/
?

?

?
2.1 Representation of Ontology Mappings
Mappings are conceptualised as 5-tuples of the form id, e1, e2, n, , with id a unique
identifier, e1, e2 entities in the vocabulary or signature of the relevant input ontologies
(i.e., e1  Sig(O1) and e2  Sig(O2)), n a confidence measure between 0 and 1, and 
a relation between e1 and e2, typically subsumption, equivalence or disjointness [10].
RDF Alignment [8] is the main format used in the OAEI campaign to represent
mappings containing the aforementioned elements. Additionally, mappings are also represented as OWL 2 subclass, equivalence, and disjointness axioms [6]; mapping identifiers (id) and confidence values (n) are then represented as axiom annotations. Such
a representation enables the reuse of the extensive range of OWL 2 reasoning infrastructure that is currently available. Note that alternative formal semantics for ontology
mappings have been proposed in the literature (e.g., [4]).

Intuitively, the deductive difference between O and O

2.2 Semantic Consequences of the Integration
The ontology resulting from the integration of two ontologies O1 and O2 via a set of
mappings M may entail axioms that do not follow from O1, O2, or M alone. These
new semantic consequences can be captured by the notion of deductive difference [25].
w.r.t. a signature  (i.e., set
of entities) is the set of entailments constructed over  that do not hold in O, but do
hold in O
. The notion of deductive difference, however, has several drawbacks in prac-
tice. First, there is no algorithm for computing the deductive difference in expressive
DLs [25]. Second, the number of entailments in the difference can be infinite.
Definition 1 (Approximation of the Deductive Difference). Let A, B be atomic concepts (including ,),  be a signature, O and O
be two OWL 2 ontologies. We
define the approximation of the -deductive difference between O and O
(denoted
(O,O) as the set of axioms of the form A  B satisfying: (i) A, B  ,

diff
(ii) O |= A  B, and (iii) O |= A  B.

In order to avoid the drawbacks of the deductive difference, in this paper we rely on
the approximation given in Definition 1. This approximation only requires comparing
the classification hierarchies of O and O
provided by an OWL 2 reasoner, and it has
successfully been used in the past in the context of ontology integration [18].

2.3 Mapping Coherence and Mapping Repair
The consistency principle requires that the vocabulary in OU = O1  O2  M be
satisfiable, assuming the union of input ontologies O1  O2 (without the mappings M)
(O1  O2,OU ) should not contain

does not contain unsatisfiable concepts. Thus diff
any axiom of the form A  , for any A   = Sig(O1  O2).
Definition 2 (Mapping Incoherence). A set of mappings M is incoherent with respect
to O1 and O2, if there exists a class A, in the signature of O1O2, such that O1O2 |=
A   and O1  O2  M |= A  .

An incoherent set of mappings M can be fixed by removing mappings from M. This

process is referred to as mapping repair (or repair for short).
?

?

?
Definition 3 (Mapping Repair). Let M be an incoherent set of mappings w.r.t. O1
and O2. A set of mappings R  M is a mapping repair for M w.r.t. O1 and O2 iff
M \ R is coherent w.r.t. O1 and O2.
A trivial repair is R = M, since an empty set of mappings is trivially coherent (ac-
cording to Definition 2). Nevertheless, the objective is to remove as few mappings as
possible. Minimal (mapping) repairs are typically referred to in the literature as mapping diagnoses [29]  a term coined by Reiter [36] and introduced to the field of ontology debugging in [39]. A repair or diagnosis can be computed by extracting the justifications for the unsatisfiable concepts (e.g., [38, 22, 43]), and selecting a hitting set of
mappings to be removed, following a minimality criteria (e.g., the number of removed
mappings). However, justification-based technologies do not scale when the number of
unsatisfiabilities is large (a typical scenario in mapping repair problems [16]). To address this scalability issue, mapping repair systems usually compute an approximate
repair using incomplete reasoning techniques (e.g., [17, 29, 37]). An approximate repair R
is coherent, but it will (in general) significantly
reduce the number of unsatisfiabilities caused by the original set of mappings M.

does not guarantee that M\R


1

(O1,OU ) and diff

(O2,O2  M)) must be empty for  = Sig(O1) (resp.  = Sig(O2)).


2.4 Conservativity Principle
The conservativity principle (general notion) states that the integrated ontology OU =
O1  O2  M should not induce any change in the concept hierarchies of the input
ontologies O1 and O2. That is, the sets diff
(O2,OU ) must be

empty for signatures 1 = Sig(O1) and 2 = Sig(O2), respectively.
2
In [19] a lighter variant of the conservativity principle was proposed. This variant required that the mappings M alone should not introduce new subsumption relationships
(O1,O1  M)

between concepts from one of the input ontologies. That is, the set diff
(resp. diff
In this paper we propose a different variant of the conservativity principle where
we require that the integrated ontology OU does not introduce new subsumption relationships between concepts from one of the input ontologies, unless they were already
involved in a subsumption relationship or they shared a common descendant. Note that
we assume that the mappings M are coherent with respect to O1 and O2.
Definition 4 (Conservativity Principle Violations). Let A, B, C be atomic concepts
(not including ,), let O be one of the input ontologies, let Sig(O) be its signature,
and let OU be the integrated ontology. We define the set of conservativity principle
violations of OU w.r.t. O (denoted consViol(O,OU )) as the set of axioms of the form
A  B satisfying: (i) A, B, C  Sig(O), (ii) A  B  diff
Sig(O)(O,OU ), (iii) O |=

B  A, and (iv) there is no C s.t. O |= C  A, and O |= C  B.

This variant of the conservativity principle follows the assumption of disjointness
proposed in [38]. That is, if two atomic concepts A, B from one of the input ontologies are not involved in a subsumption relationship nor share a common subconcept
(excluding ) they can be considered as disjoint. Hence, the conservativity principle
can be reduced to the consistency principle, if the input ontologies are extended with
sufficient disjointness axioms. This reduction will allow us to reuse the available infrastructure and techniques for mapping repair.
?

?

?
Table 1. Fragments of the ontologies used in Optique

Ontology O1

Ontology O2

1 WellBore  belongsTo.Well
2 WellBore  hasOperator.Operator 2 Explor borehole  Borehole
3 WellBore  locatedIn.Field
4 AppraisalWellBore  WellBore
5 ExplorationWellBore  WellBore
6 Operator  Owner
7 Operator  Company
8 Field  hasOperator.Company
9 Field  hasOwner.Owner

1 Exploration well  Well
3 Appraisal exp borehole  Explor borehole
4 Appraisal well  Well
5 Field  hasFieldOperator.Field operator
6 Field operator  Owner  Field owner
7 Company  Field operator
8 Field owner  Owner
9 Borehole  Continuant  Occurrent
Table 2. Ontology mappings for the vocabulary in O1 and O2

Mappings M
e2
O2:Well
O2:Borehole

e1

n 
id
0.9 
m1 O1:Well
0.7 
m2 O1:WellBore
m3 O1:ExplorationWellBore O2:Exploration well
0.6 
0.8 
m4 O1:ExplorationWellBore O2:Explor borehole
m5 O1:AppraisalWellBore O2:Appraisal exp borehole 0.7 
m6 O1:Field
0.9 
m7 O1:Operator
0.7 
m8 O1:Company
0.9 
0.6 
m9 O1:hasOperator
m10 O1:Owner
0.9 

O2:Field
O2:Field operator
O2:Company
O2:hasFieldOperator
O2:Owner

3 Conservativity Principle Violations in Practice

In this section, we show the problems led by the violation of the conservativity principle
when integrating ontologies via mappings in a real-world scenario. To this end, we
consider as motivating example a use case based on the Optiques application domain.
Table 1 shows the fragments of two ontologies in the context of the oil and gas
industry. The ontology O1 has been directly bootstrapped from a relational database
in Optique, and it is linked to the data via direct ontology-to-database mappings. The
ontology O2, instead, is a domain ontology, based on the NPD FactPages, preferred by
Optique end-users to feed the visual query formulation interface.6
The integration via ontology matching of O1 and O2 is required since the vocabulary
in O2 is used to formulate queries, but only the vocabulary of O1 is connected to the
database.7 Consider the set of mappings M in Table 2 between O1 and O2 generated
by an off-the-shelf ontology alignment system. As described in Section 2.1, mappings
are represented as 5-tuples; for example the mapping m2 suggests an equivalence relationship between the entities O1:WellBore and O2:Borehole, with confidence 0.7.
The integrated ontology OU = O1  O2  M, however, violates the conservativity
principle, according to Definition 4, and introduces non desired subsumption relationhips (see Table 3). Note that the entailments 4 and 5 are not included in our variant of
conservativity violation, since O1:Company and O1:Operator (resp. O2:Field operator
and O2:Company) are involved in a subsumption relationship in O1 (resp. O2).
6 In Optique we use OWL 2 QL ontologies for query rewriting, while the query formulation
may be based on much richer OWL 2 ontologies. The axioms that fall outside the OWL 2 QL
profile are either approximated or not considered for the rewriting.

7 As mentioned in Section 1, in this paper we only focus on ontology-to-ontology mappings.

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

Table 3. Example of conservativity principle violations

 Entailment:
1 O2:Explor borehole  O2:Exploration well
2 O1:AppraisalWellBore  O1:ExplorationWellBore
3 O2:Field operator  O2:Field owner
4 O1:Company  O1:Operator
5 O2:Field operator  O2:Company
6 O1:Company  O1:Owner
7 O2:Company  O2:Field owner

follows from:

Violation?

m3, m4

3, m4, m5

6, 6, m7, m10
?

?

?
7, 7, m7, m8

NO (*)

4, 6
3, 5
?

?

?
However, these entailments lead to other violations included in our variant (6 and 7),
and may also be considered as violations. These conservativity principle violations may
hinder the usefulness of the generated ontology mappings since may affect the quality
of the results when performing OBDA queries over the vocabulary of O2.
Example 1. Consider the following conjunctive query CQ(x)  O2:Well(x). The query
asks for wells and has been formulated from the Optiques query formulation interface,
using the vocabulary of O2. The query is rewritten, according to the ontology axioms
and mappings 1, 4, m1, m3, m4 in OU = O1  O2  M, into the following union
of conjunctive queries UCQ(x)  O2:Well(x)O1:Well(x)O2:Exploration well(x)
O2:Appraisal well(x)O1:ExplorationWellBore(x)O2:Explor borehole(x). Since only
the vocabulary of O1 is linked to the data, the union of conjunctive queries could be simplified as UCQ(x)  Well(x) ExplorationWellBore(x), which will clearly lead to non
desired results. The original query was only asking for wells, while the rewritten query
will also return data about exploration wellbores.

We have shown that the quality of the mappings in terms of conservativity principle
violations will directly affect the quality of the query results. Therefore, the detection
and repair of these violations arise as an important quality assessment step in Optique.

4 Methods

We have reduced the problem of detecting and solving conservativity principle viola-
tions, following our notion of conservativity (see Section 2), to a mapping (incoherence)
repair problem. Currently, our method relies on the indexing and reasoning techniques
implemented in LogMap, an ontology matching and mapping repair system [17, 20, 21].
Algorithm 1 shows the pseudocode of the implemented method. The algorithm accepts as input two OWL 2 ontologies, O1 and O2, and a set of mappings M which are
coherent8 with respect to O1 and O2. Additionally, an optimised variant to add disjointness axioms can be selected. The algorithm outputs the number of added disjointness
during the process disj, a set of mappings M
such
that M = M \ R
aims at solving most of the conservativity principle violations of M with respect to O1 and O2. We next describe the
techniques used in each step.
Module Extraction. In order to reduce the size of the problem our method extracts
two locality-based modules [7], one for each input ontology, using the entities involved
8 Note that M may be the result of a prior mapping (incoherence) repair process.

, and an (approximate) repair R

. The (approximate) repair R
?

?

?
: approximate repair; disj: number of disjointness rules

: output mappings; R
2 := ModuleExtractor(O1, O2, M)
1, O
2)

Algorithm 1. Algorithm to detect and solve conservativity principle violations
Input: O1, O2: input ontologies; M: (coherent) input mappings; Optimization: Boolean value
Output: M
1, O
1: O
2: P1, P2 := PropositionalEncoding(O
3: SI1 := StructuralIndex(O
1)
4: SI2 := StructuralIndex(O
2)
5: if (Optimization = true) then
SIU := StructuralIndex(O
6:
P d
7:
P d
8:
9: else
P d
10:
P d
11:
12: end if
13: M, R := MappingRepair(P d
14: disj := disj1 + disj2
15: return M, R, disj

1 , disj1 := DisjointAxiomsExtensionOptimized(P1, SI1, SIU )
2 , disj2 := DisjointAxiomsExtensionOptimized(P2, SI2, SIU )
1 , disj1 := DisjointAxiomsExtensionBasic(P1, SI1)
2 , disj2 := DisjointAxiomsExtensionBasic(P2, SI2)

2  M)

1 , P d

2 , M)

1  O

 See Algorithm 3

 See Algorithm 2

 See Algorithm 2 in [21]

1 and O

in the mappings M as seed signatures for the module extractor (step 1 in Algorithm
1). These modules preserve the semantics for the given entities, can be efficiently com-
puted, and are typically much smaller than the original ontologies.
Propositional Horn Encoding. The modules O
2 are encoded as the Horn
propositional theories, P1 and P2 (step 2 in Algorithm 1). This encoding includes rules
of the form A1  . . .  An  B. For example, the concept hierarchy provided by an
OWL 2 reasoner (e.g., [32, 23]) will be encoded as A  B rules, while the explicit
disjointness relationships between concepts will be represented as Ai  Aj  false.
Note that the input mappings M can already be seen as propositional implications.
This encoding is key to the mapping repair process.
Example 2. Consider the ontologies and mappings in Tables 1 and 2. The axiom 6 is
encoded as Field operatorOwner  Field owner, while the mapping m2 is translated
into rules O1:WellBore  O2:Borehole, and O2:Borehole  O1:WellBore.
Structural Index. The concept hierarchies provided by an OWL 2 reasoner (exclud-
ing ) and the explicit disjointness axioms of the modules O
2 are efficiently
indexed using an interval labelling schema [1] (steps 3 and 4 in Algorithm 1). This
structural index exploits an optimised data structure for storing directed acyclic graphs
(DAGs), and allows us to answer many entailment queries over the concept hierarchy
as an index lookup operation, and hence without the need of an OWL 2 reasoner. This
kind of index has shown to significantly reduce the cost of answering taxonomic queries
[5, 33] and disjointness relationships queries [17, 20].
Disjointness Axioms Extension.
In order to reduce the conservativity problem to a
mapping incoherence repair problem following the notion of assumption of disjoint-
ness, we need to automatically add sufficient disjointness axioms into each module O
i.
However, the insertion of additional disjointness axioms  may lead to unsatisfiable
classes in O
Example 3. Consider the axiom 9 from Table 1. Following the assumption of disjointness a very na ve algorithm would add disjointness axioms between Borehole,
Continuant and Occurrent, which would make Borehole unsatisfiable.

1 and O

i  .

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

Algorithm 2. Basic disjointness axioms extension
Input: P: propositional theory; SI: structural index
Output: P d: extended propositional theory;disj: number of disjointness rules
1: disj := 0
2: P d := P
3: for each pair A, B  OrderedVariablePairs(P) do
4:
5:
6:
7:
8:
9: end for
10: return P d, disj

P d := P d  {A  B  f alse}
SI := updateIndex(SI, A  B  )
disj := disj + 1

end if

if not (areDisj(SI, A, B) or inSubSupRel(SI, A, B) or shareDesc(SI, A, B)) then

In order to detect if each candidate disjointness axiom leads to an unsatisfiability,
a non na ve algorithm requires to make an extensive use of an OWL 2 reasoner. In
large ontologies, however, such extensive use of the reasoner may be prohibitive. Our
method, in order to address this issue, exploits the propositional encoding and structural
i   contains unsatisfiable classes is
index of the input ontologies. Thus, checking if O
restricted to the Horn propositional case.
We have implemented two algorithms to extend the propositional theories P1 and
P2 with disjointness rules of the form A  B   (see steps 5-12 in Algorithm 1).
These algorithms guarantee that, for every propositional variable A in the extended
i  {true  A} is satisfiable.
propositional theory P d
Note that this does not necessarily hold if the disjointness axioms are added to the OWL
2 ontology modules, O
Algorithm 2 presents a (basic) algorithm to add as many disjointness rules as possi-
ble, for every pair of propositional variables A, B in the propositional theory P given
as input. In order to minimize the number of necessary disjointness rules, the variables
in P are ordered in pairs following a top-down approach. The algorithm exploits the
structural index SI to check if two propositional variables (i.e., classes in the input
ontologies) are disjoint (areDisj(SI, A, B)), they keep a sub/super-class relationship
(inSubSupRel(SI, A, B)), or they share a common descendant (shareDesc(SI, A, B))
(step 4 in Algorithm 2). Note that the structural index is also updated to take into account the new disjointness rules (step 6 in Algorithm 2).

i (with i  {1, 2}), the theory P d
1 and O

2, as discussed above.

1  O

The addition of disjointness rules in Algorithm 2, however, may be prohibitive for
large ontologies (see Section 5). Intuitively, in order to reduce the number of disjointness axioms, one should only focus on the cases where a conservativity principle violation occurs in the integrated ontology OU = O
2  M, with respect to one of the
ontology modules O
i (with i  {1, 2}); i.e., adding a disjointness axiom between each
i,OU ), as in Definition 4.
pair of classes A, B  O
Algorithm 3 implements this idea for the Horn propositional case and extensively exploits the structural indexing to identify the conservativity principle violations (step 3
in Algorithm 3). Note that this algorithm also requires to compute the structural index
of the integrated ontology, and thus its classification with an OWL 2 reasoner (step 6
in Algorithm 1). The classification of the integrated ontology is known to be typically
much higher than the classification of the input ontologies individually [16]. However,
this was not a bottleneck in our experiments, as shown in Section 5.

i such that A  B  consViol(O
?

?

?
Algorithm 3. Optimised disjointness axioms extension
Input: P: propositional theory; SI: structural index SIU : structural index of the union ontology
Output: P d: extended propositional theory;disj: number of disjointness rules
1: disj := 0
2: P d := P
3: for A  B  ConservativityViolations(SI, SIU ) do
4:
5:
6:
7:
8:
9: end for
10: return P d, disj

P d := P d  {A  B  f alse}
SI := updateIndex(SI, A  B  )
disj := disj + 1

if not (areDisj(SI, A, B)) then

end if

1 P d

1 P d

1  P d

2 , the satisfiability of the propositional theory PA = P d

Mapping Repair. The step 13 of Algorithm 1 uses the mapping (incoherence) repair
algorithm presented in [17, 21] for the extended Horn propositional theories P d
1 and P d
2 ,
and the input mappings M. The mapping repair process exploits the Dowling-Gallier
algorithm for propositional Horn satisfiability [9] and checks, for every propositional
2 M
variable A  P d
{true  A}. Satisfiability of PA is checked in worst-case linear time in the size of PA,
and the number of Dowling-Gallier calls is also linear in the number of propositional
variables in P d
2 . In case of unsatisfiability, the algorithm also allows us to record
conflicting mappings involved in the unsatisfiability, which will be considered for the
subsequent repair process. The unsatisfiability will be fixed by removing some of the
identified mappings. In case of multiple options, the mapping confidence will be used
as a differentiating factor.9
Example 4. Consider the propositional encoding P1 and P2 of the axioms of Table 1
and the mappings M in Table 2, seen as propositional rules. P d
2 have been created by adding disjointness rules to P1 and P2, according to Algorithm 2 or 3. For
example, P d
2 includes the rule  = O2:Well  O2:Borehole  f alse. The map-
2  M  {true 
ping repair algorithm identifies the propositional theory P d
O1:ExplorationWellbore} as unsatisfiable. This is due to the combination of the mappings m3 and m4, the propositional projection of axioms 1 and 2, and the rule . The
mapping repair algorithm also identifies m3 and m4 as the cause of the unsatisfiability,
and discards m3, since its confidence is smaller than that of m4 (see Table 2).

1 and P d

1  P d

. M

is coherent with respect to P d

, and an (approximate) repair R

Algorithm 1 gives as output the number of added disjointness rules during the prosuch that M =
cess disj, a set of mappings M
M \ R
2 (according to the propositional
case of Definition 2). Furthermore, the propositional theory P1  P2  M
does not
contain any conservativity principle violation with respect to P1 and P2 (according to
the propositional case of Definition 4). However, our encoding is incomplete, and we
2  M
cannot guarantee that O
does not contain conservativity principle violations with respect to O
2. Nonetheless, our evaluation suggests that the number
of remaining violations after repair is typically small (see Section 5).

1  O
1 and O

1 and P d

9 In scenarios where the confidence of the mapping is missing (e.g., in reference or manually
created mapping sets) or unreliable, our mapping repair technique computes fresh confidence
values based on the locality principle [19].

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

Algorithm 4. Conducted evaluation over the Optique and OAEI data sets
Input: O1, O2: input ontologies M: reference mappings for O1 and O2
1: OU := O1  O2  M
2: Store size of Sig(O1) (I), Sig(O2) (II) and M (III)
principle
3: Compute

conservativity

number

variant

(our

as

of

in

diff

number

 := |diff

violations
consViol := |consViol(O1, OU )| + |consViol(O2, OU )| (IV)
violations
Sig(O2 )(O2, OU )| (V)


Sig(O1 )(O1, OU )| + |diff


4: Compute
of
conservativity
2.4):
5: Compute two repairs R
using Algorithm 1 for O1, O2, M, with the Optimization set to false (see Table 5) and
6: Store number of added disjointness disj (VI and XII), size of repair |R| (VII and XIII), time to compute disjointness
7: OU := O1  O2  M \ R
8: Compute

rules td (VIII and XIV), and time to compute the mapping repair tr (IX and XV)

true (see Table 6)

Definition

4):

conservativity

remaining

violations

principle

principle

variant):

(general

number

Section

notion

as

in

consViol := |consViol(O1, OU )| + |consViol(O2, OU )| (X and XVI)
principle

number
Sig(O1 )(O1, OU )| + |diff


remaining
Sig(O2 )(O2, OU )| (XI and XVII)


 := |diff

conservativity

diff

of

9: Compute

of

(our

violations

(general

notion):

5 Evaluation

In this section we evaluate the feasibility of using our method to detect and correct conservativity principle violations in practice. To this end we have conducted the evaluation
in Algorithm 4 (the Roman numbers refer to stored measurements) over the Optiques
use case and the ontologies and reference mapping sets of the OAEI 2013 campaign:10

i Optiques use case is based on the NPD ontology and a bootstrapped ontology
(BootsOnto) from one of the Optique databases. The mappings between these ontologies were semi-automatically created using the ontology matcher LogMap [20].
Although the NPD ontology is small with respect to the size of the bootstrapped on-
tology, its vocabulary covers a large portion of the current query catalog in Optique.
ii LargeBio: this dataset includes the biomedical ontologies FMA, NCI and (a frag-

ment of) SNOMED, and reference mappings based on the UMLS [3].

iii Anatomy: the Anatomy dataset involves the Adult Mouse Anatomy (MO) ontology
and a fragment of the NCI ontology (NCIAnat), describing human anatomy. The
reference alignment has been manually curated [48].

iv Library: this OAEI dataset includes the real-word thesauri STW and TheSoz from

the social sciences. The reference mappings have been manually validated.

v Conference: this dataset uses a collection of 16 ontologies from the domain of
academic conferences [46]. Currently, there are 21 manually created mapping sets
among 7 of the ontologies.

Table 4 shows the size of the evaluated ontologies and mappings (I, II and III).
For the Conference dataset we have selected only 5 pair of ontologies for which the
reference mappings lead to more than five conservativity principle violations. Note that
we count equivalence mappings as two subsumption mappings, and hence M represents
subsumption mappings. Table 4 also shows the conservativity principle violations for

10 Note that the reference mappings of the OAEI 2013 campaign are coherent with respect to the
test case ontologies [13]. More information about the used ontology versions can be found in
http://oaei.ontologymatching.org/2013/
?

?

?
Table 4. Test cases and violations with original reference mappings. BootsOnto contains around
3,000 concepts, and a large number of properties.

Dataset

Optique

LargeBio

Anatomy
Library

Conference

O1  O2

NPDBootsOnto
SNOMEDNCI
FMASNOMED
FMANCI
MONCIAnat
STWTheSoz
cmtconfof
conferenceedas
conferenceiasted
confofekaw
edasiasted

|Sig(O1)|

Problem size
|Sig(O2)|

122,519
79,042
79,042
2,747
6,575
?

?

?
40,671
66,914
122,519
66,914
3,306
8,376
?

?

?
|M|

Original Violations


consViol

diff

36,405 >525,515 >546,181
127,668
17,212
19,799
5,821
3,032
1,335
42,872
6,322

125,232
19,740
1,321
42,045
?

?

?
Table 5. Results of our basic method to detect and solve conservativity principle violations

Times

Remaining Violations

Dataset

Optique

LargeBio

Anatomy
Library

Conference

O1  O2

NPDBootsOnto
SNOMEDNCI
FMASNOMED
FMANCI
MONCIAnat
STWTheSoz
cmtconfof
conferenceedas
conferenceiasted
confofekaw
edasiasted

Solution size

|R|

#disj

4,716,685



1,106,259
347,801
1,331,374
591,115
?

?

?
2,189

1,210



8,234
2,176

2,969
?

?

?
td(s)
9,840



35,817
2,471

4,126
0.01
0.03
0.06
0.02
0.06

tr(s)



1,127
?

?

?
0.01
0.01
0.02
0.01
0.02

consViol


?

?

?

diff


?

?

?
the reference mappings (IV and V). For LargeBio and Library the number is expecially
large using both our variant and the general notion of the conservativity principle.11

Tables 5 and 6 show the obtained results for our method using both the basic and

optimised algorithms to add disjointness axioms.12

We have run the experiments on a desktop computer with an AMD Fusion A6-3670K

CPU and allocating 12 GB of RAM. The obtained results are summarized as follows:

i The number of added disjointness rules disj (VI), as expected, is very large in the
basic algorithm and the required time prohibitive (VIII) when involving SNOMED
(it did not finish for SNOMED-NCI). This is clearly solved in our optimised algorithm that considerably reduces the number of necessary disjoitness rules (XII) and
it requires only 275 seconds to compute them in the SNOMED-NCI case (XIV).

11 In the SNOMED-NCI case no OWL 2 reasoner could succeed in classifying the integrated
ontology via mappings [16], so we used the OWL 2 EL reasoner ELK [23] for providing a
lower bound on the number of conservativity principle violations.

12 The computation times of Steps 1-4 in Algorithm 1 were negligible with respect to the repair
and disjointness addition times (tr and td) and thus they were not included in the result tables.

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

Table 6. Results of our optimised method to detect and solve conservativity principle violations

Times

Remaining Violations

Dataset

Optique

LargeBio

Anatomy
Library

Conference

O1  O2

NPDBootsOnto
SNOMEDNCI
FMASNOMED
FMANCI
MONCIAnat
STWTheSoz
cmtconfof
conferenceedas
conferenceiasted
confofekaw
edasiasted

Solution size
?

?

?
|R|
#disj

525,515
125,232
19,740
1,321
42,045

15,957
8,342
2,175

3,058
?

?

?
td(s)
2.54
?

?

?
1.39
4.93
0.05
0.07
0.22
0.04
0.21

tr(s)
0.17
3,755

6.18
0.53

0.01
0.01
0.01
0.01
0.02

consViol

>411
?

?

?

diff

>1,624
?

?

?
ii The computed repairs R

(VII and XIII) using both the basic and optimised algorithms are of comparable size. This suggests that the large number of added
disjointness in the basic algorithm does not have a negative impact (in terms of
aggressiveness) on the repair process.

iii Repair times tr (IX and XV) are small and they do not represent a bottleneck in

spite of the large number of added disjointness rules.

iv The conservativity principle violations using both algorithms and considering our
variant (X and XVI) are completely removed in the Optique, Anatomy and Library
cases, and almost completely removed in the Conference and LargeBio datasets.

v The number of missed violations is only slightly higher when considering the general notion of the conservativity principle (XI and XVII), which suggests that our
(approximate) variant is also suitable in practice. Furthermore, in several test cases
these violations are also almost removed.

, using both algorithms (VII and XIII), are rather aggressive and they can remove from 16% (Anatomy) up to 48% (Optique) of the
mappings. In the Optiques use case, however, we follow a better safe than sorry
approach and we prefer to remove as many violations as possible, rather than preserving potentially conflicting mapping sets.

vi The computed repairs R

In summary, the results suggest that our method to repair conservativity principle
violations is suitable for Optique, and it is feasible in practice, even when considering
the largest datasets of the OAEI.

6 Related Work
The conservativity principle problem, although indirectly, has been actively studied in
the literature. For example, the assumption of disjointness was originally introduced by
Schlobach [38] to enhance the repair of ontologies that were underspecified in terms of
disjointness axioms. In [30], a similar assumption is followed in the context of repairing
ontology mappings, where the authors restricted the number of disjointness axioms by
using learning techniques [45]. These techniques, however, typically require a manually
created training set. In [12] the authors present an interactive system to guide the expert
user in the manual enrichment of the ontologies with disjointness axioms. In this paper,
?

?

?
as in [45, 30, 12], we have also focused on the addition of a small set of disjointness
axioms, since adding all possible disjointness may be unfeasible for large ontologies.
However, our method does not require manual intervention. Furthermore, to address the
scalability problem when dealing with large ontologies and mapping sets, our method
relies on the propositional projection of the input ontologies.

Ontology matching systems have also dealt with the conservativity principle in order
to improve the precision (with respect to a reference mapping set) of the computed
mappings. For example, systems such as ASMOV [15], Lily [47] and YAM++ [34] have
implemented different heuristics and patterns to avoid violations of the conservativity
principle. Another relevant approach has been presented in [2], where a set of sanity
checks and best practices are proposed for computing ontology mappings. In this paper
we present an elegant way to detect and solve conservativity principle violations by
reducing the problem to a consistency principle violation problem. Concretely, we have
reused and adapted the infrastructure provided by LogMap [17, 20]. However, other
mapping repair systems, such as Alcomo [29] or AML [37], could be considered. Note
that, to the best of our knowledge, these mapping repair systems have only focused on
solving violations of the consistency principle.

The work presented in [26, 14, 27] deserves a special attention since they propose an
opposite approach with respect to ours. Authors consider the violations of the conservativity principle as false positives, based on the potential incompleteness of the input
ontologies. Hence, the correction strategy does not aim at removing mappings but at inserting subsumption axioms to the input ontologies to enrich their concept hierarchies.
Authors in [35] also suggest that removing mapping may not be the best solution in a
mapping repair process, and fixing the input ontologies may be an alternative.

Currently, in the Optique use case, we consider that the input ontologies are not
modifiable. The query formulation ontology is based on the NPD ontology, which includes knowledge already agreed by the community, while the bootstrapped ontology
is directly linked to the information represented in the database. Nevertheless, future
extensions in Optique may consider appropriate the extension of the input ontologies.

7 Conclusions and Future Work

In this paper we have presented an approximate and fully-automatic method to detect
and correct conservativity principle violations in practice. We have characterised the
conservativity principle problem, following the assumption of disjointness, as a consistency principle problem. We have also presented an elegant and scalable way to detect
and repair violations in the Horn propositional case. Thus, our method is incomplete
and it may fail to detect and repair all violations. However, the conducted evaluation
suggests that our method produces competitive results in practice. In the close future
we plan to consider extensions of the current projection to Horn propositional logic
while keeping the nice scalability properties of the current method.

The implemented method follows a better safe than sorry approach, which we
currently consider suitable for the Optique project since we do not want ontology-to-
ontology mappings to lead to unexpected results for the OBDA queries, as motivated
in Section 3. Hence, we currently delegate complex relationhips between ontology entities and the database to the (hand-crafted) schema-to-ontology mappings, which will

A. Solimando, E. Jim enez-Ruiz, and G. Guerrini

also play an important role in Optique. Nevertheless we do not discard in the future
to explore alternative methods to detect and repair conservative principle violations.
In particular, we plan to study the potential application of approaches based on graph-
theory, in order to extend the detection and repair of conservativity principle violations.
Strongly connected compontents of a graph representation of the subsumption relation
between named concepts (as defined in [29]), for instance, may be used to capture violations between pairs of concepts already involved in a subsumption relationship.

Additionally, we will also consider exploring the use of learning techniques for the
addition of disjointness axioms [45], and to involve the domain experts in the assess-
ment/addition of such disjointness [18, 12]. This manual assessment may also be used
to consider violations as false positives, as proposed in [26, 14, 27], and suggest them
as candidate extensions of the input ontologies.

We consider that the proposed method has also potential in scenarios others than
Optique. For instance, the authors in [28] apply ontology matching in a multi-agent
system scenario in order to allow the exchange and extension of ontology-based action plans among agents. In such a context, violations of the conservativity principle
should be taken into account and highly critical tasks should not be performed if violations are detected. In [44], authors present an ontology-based data integration (OBDI)
system, which integrates ontology mapping and query reformulation techniques. As in
Optique, mappings violating the conservativity principle may compromise the quality
of the query results in the proposed OBDI system.

Finally, we have short-term plans for deployment in the Optique industry partners
Statoil and Siemens. The techniques described in this paper have already been integrated within the ontology and mapping management module (see [24] for details
about the Optique architecture).

Acknowledgements. This work was supported by the EU FP7 IP project Optique (no.
318338), the MIUR project CINA (Compositionality, Interaction, Negotiation, Autonomicity for the future ICT society) and the EPSRC project Score!. We also thank the
unvaluable help provided by Bernardo Cuenca and Ian Horrocks. Finally, we are also
very grateful for the support of the Optique colleagues that facilitated our understanding of the domain, especially: Dag Hovland, Evgeny Kharlamov, Dmitry Zheleznyakov
and Martin G. Skjveland.
