Answering SPARQL Queries over Databases under

OWL 2 QL Entailment Regime

Roman Kontchakov1, Martin Rezk2, Mariano Rodr guez-Muro3,

Guohui Xiao2, and Michael Zakharyaschev1

1 Department of Computer Science and Information Systems,

Birkbeck, University of London, U.K.

2 Faculty of Computer Science, Free University of Bozen-Bolzano, Italy

3 IBM T.J. Watson Research Center, Yorktown Heights, NY, USA

Abstract. We present an extension of the ontology-based data access platform
Ontop that supports answering SPARQL queries under the OWL 2 QL direct
semantics entailment regime for data instances stored in relational databases.
On the theoretical side, we show how any input SPARQL query, OWL 2 QL
ontology and R2RML mappings can be rewritten to an equivalent SQL query
solely over the data. On the practical side, we present initial experimental results demonstrating that by applying the Ontop technologiesthe tree-witness
query rewriting, T -mappings compiling R2RML mappings with ontology hier-
archies, and T -mapping optimisations using SQL expressivity and database integrity constraintsthe system produces scalable SQL queries.

1 Introduction

Ontology-based data access and management (OBDA) is a popular paradigm of organising access to various types of data sources that has been developed since the mid
2000s [11,17,24]. In a nutshell, OBDA separates the user from the data sources (rela-
tional databases, triple stores, etc.) by means of an ontology which provides the user
with a convenient query vocabulary, hides the structure of the data sources, and can enrich incomplete data with background knowledge. About a dozen OBDA systems have
been implemented in both academia and industry; e.g., [27,30,24,4,23,15,12,8,20,22].
Most of them support conjunctive queries and the OWL 2 QL profile of OWL 2 as the
ontology language (or its generalisations to existential datalog rules). Thus, the OBDA
platform Ontop [29] was designed to query data instances stored in relational databases,
with the vocabularies of the data and OWL 2 QL ontologies linked by means of global-
as-view (GAV) mappings. Given a conjunctive query in the vocabulary of such an on-
tology, Ontop rewrites it to an SQL query in the vocabulary of the data, optimises the
rewriting and delegates its evaluation to the database system.

One of the main aims behind the newly designed query language SPARQL 1.1a
W3C recommendation since 2013has been to support various entailment regimes,
which can be regarded as variants of OBDA. Thus, the OWL 2 direct semantics entailment regime allows SPARQL queries over OWL 2 DL ontologies and RDF graphs
(which can be thought of as 3-column database tables). SPARQL queries are in many
aspects more expressive than conjunctive queries as they offer more complex query

P. Mika et al. (Eds.) ISWC 2014, Part I, LNCS 8796, pp. 552567, 2014.
c Springer International Publishing Switzerland 2014
?

?

?
constructs and can retrieve not only domain elements but also class and property names
using second-order variables. (Note, however, that SPARQL 1.1 does not cover all conjunctive queries.) OWL 2 DL is also vastly superior to OWL 2 QL, but this makes query
answering under the OWL 2 direct semantics entailment regime intractable (CONP-
hard for data complexity). For example, the query evaluation algorithm of [19] calls an
OWL 2 DL reasoner for each possible assignment to the variables in a given query, and
therefore cannot cope with large data instances.

In this paper, we investigate answering SPARQL queries under a less expressive
entailment regime, which corresponds to OWL 2 QL, assuming that data is stored in
relational databases. It is to be noted that the W3C specification1 of SPARQL 1.1 defines
entailment regimes for the profiles of OWL 2 by restricting the general definition to the
profile constructs that can be used in the queries. However, in the case of OWL 2 QL,
this generic approach leads to a sub-optimal, almost trivial query language, which is
essentially subsumed by the OWL 2 RL entailment regime.

The first aim of this paper is to give an optimal definition of the OWL 2 QL direct
semantics entailment regime and prove thatsimilarly to OBDA with OWL 2 QL and
conjunctive queriesanswering SPARQL queries under this regime is reducible to answering queries under simple entailment. More precisely, in Theorem 4 we construct a
rewriting 
of any given SPARQL query and ontology under the OWL 2 QL entailment
regime to a SPARQL query that can be evaluated on any dataset directly.

In a typical Ontop scenario, data is stored in a relational database whose schema is
linked to the vocabulary of the given OWL 2 QL ontology via a GAV mapping in the
language R2RML. The mapping allows one to transform the relational data instance
into an RDF representation, called the virtual RDF graph (which is not materialised in
our scenario). The rewriting 

constructs a SPARQL query over this virtual graph.

Our second aim is to show how such a SPARQL query can be translated to an equivalent SQL query over a relational representation of the virtual RDF graph as a 3-column
table (translation  in Theorem 7). The third aim is to show that the resulting SQL
query can be unfolded, using a given R2RML mapping M, to an SQL query over the
original database (trM in Theorem 12), which is evaluated by the database system.
SPARQL query

trM





SQL query

SQL query

& ontology

entailment
regime

SPARQL query
simple entailment
virtual RDF graph

evaluation

triple-database



evaluation

mapping M

database

Unfortunately, each of these three transformations may involve an exponential blowup.
We tackle this problem in Ontop using the following optimisation techniques. (i) The
mapping is compiled with the ontology into a T -mapping [29] and optimised by database
dependencies (e.g., primary, candidate and foreign keys) and SQL disjunctions. (ii) The
SPARQL-to-SQL translation is optimised using null join elimination (Theorem 8). (iii)
The unfolding is optimised by eliminating joins with mismatching R2RML IRI tem-
plates, de-IRIing the join conditions (Section 3.3) and using database dependencies.

Our contributions (Theorems 4, 7, 8 and 12 and optimisations in Section 3.3) make
Ontop the first system to support the W3C recommendations OWL 2 QL, R2RML,
SPARQL and the OWL 2 QL direct semantics entailment regime; its architecture is

1 http://www.w3.org/TR/sparql11-entailment

R. Kontchakov et al.

outlined in Section 4. We evaluate the performance of Ontop using the LUBM Benchmark [16] extended with queries containing class and property variables, and compare it with two other systems that support the OWL 2 entailment regime by calling
OWL DL reasoners (Section 5). Our experiments show that Ontop outperforms the
reasoner-based systems for most of the queries over small datasets; over larger datasets
the difference becomes dramatic, with Ontop demonstrating a solid performance even
on 69 million triples in LUBM500. Finally, we note that, although Ontop was designed
to work with existing relational databases, it is also applicable in the context of RDF
triple stores, in which case approaches such as the one from [3] can be used to generate
suitable relational schemas. Omitted proofs and evaluation details can be found in the
full version at http://www.dcs.bbk.ac.uk/ michael/ISWC-14-v2.pdf.

2 SPARQL Queries under OWL 2 QL Entailment Regime

SPARQL is a W3C standard language designed to query RDF graphs. Its vocabulary
contains four pairwise disjoint and countably infinite sets of symbols: I for IRIs, B for
blank nodes, L for RDF literals, and V for variables. The elements of C = I  B  L
are called RDF terms. A triple pattern is an element of (C  V)  (I  V)  (C  V). A
basic graph pattern (BGP) is a finite set of triple patterns. Finally, a graph pattern, P ,
is an expression defined by the grammar

P ::= BGP | FILTER(P, F ) | BIND(P, v, c) | UNION(P1, P2) |

JOIN(P1, P2) | OPT(P1, P2, F ),
?

?

?
where F , a filter, is a formula constructed from atoms of the form bound(v), (v = c),
  V, c  C, and possibly other built-in predicates using the logical
(v = v
connectives  and . The set of variables in P is denoted by var(P ).

), for v, v

A SPARQL query is a graph pattern P with a solution modifier, which specifies the
answer variablesthe variables in P whose values we are interested inand the form
of the output (we ignore other solution modifiers for simplicity). The values to variables
are given by solution mappings, which are partial maps s : V  C with (possibly
empty) domain dom(s). In this paper, we use the set-based (rather than bag-based, as
in the specification) semantics for SPARQL. For sets S1 and S2 of solution mappings,
a filter F , a variable v  V and a term c  C, let
 FILTER(S, F ) = {s  S | F s = "};
 BIND(S, v, c) = {s  {v  c} | s  S} (provided that v / dom(s), for s  S);
 UNION(S1, S2) = {s | s  S1 or s  S2};
 JOIN(S1, S2) = {s1  s2 | s1  S1 and s2  S2 are compatible};
 OPT(S1, S2, F ) = FILTER(JOIN(S1, S2), F )  {s1  S1 | for all s2  S2,

either s1, s2 are incompatible or F s1s2 = "}.
Here, s1 and s2 are compatible if s1(v) = s2(v), for any v  dom(s1)  dom(s2), in
which case s1  s2 is a solution mapping with s1  s2 : v  s1(v), for v  dom(s1),
s1 s2 : v  s2(v), for v  dom(s2), and domain dom(s1) dom(s2). The truth-value
F s  {",, } of a filter F under a solution mapping s is defined inductively:
?

?

?
 (bound(v))s is " if v  dom(s) and  otherwise;
 (v = c)s =  if v / dom(s); otherwise, (v = c)s is the classical truth-value of the
/ dom(s); otherwise,

)s is the classical truth-value of the predicate s(v) = s(v
);
1 =  or F s
2 = ,
if F s
2 = ",
if F s
1 = F s
otherwise.

predicate s(v) = c; similarly, (v = v
(v = v

if F s = ,
,
F s, otherwise,

and (F1  F2)s =


,
",
,

)s =  if either v or v

 (F )s =
?

?

?
Finally, given an RDF graph G, the answer to a graph pattern P over G is the set PG
of solution mappings defined by induction using the operations above and starting from
the following base case: for a basic graph pattern B,

BG = {s : var(B)  C | s(B)  G},

(1)

where s(B) is the set of triples resulting from substituting each variable u in B by s(u).
This semantics is known as simple entailment.
Remark 1. The condition F s1s2 is not true in the definition of OPT is different from
F s1s2 has an effective Boolean value of false given by the W3C specification:2 the
effective Boolean value can be undefined (type error) if a variable in F is not bound by
s1  s2. As we shall see in Section 3.1, our reading corresponds to LEFT JOIN in SQL.
(Note also that the informal explanation of OPT in the W3C specification is inconsistent
with the definition of DIFF; see the full version for details.)

Under the OWL 2 QL direct semantics entailment regime, one can query an RDF
graph G that consist of two parts: an extensional sub-graph A representing the data as
OWL 2 QL class and property assertions, and the intensional sub-graph T representing
the background knowledge as OWL 2 QL class and property axioms. We write (T ,A)
in place of G to emphasise the partitioning. To illustrate, we give a simple example.
Example 2. Consider the following two axioms from the LUBM ontology (T ,A) (see
Section 5), which are given here in the functional-style syntax (FSS):

SubClassOf(ub:UGStudent, ub:Student), SubClassOf(ub:GradStudent, ub:Student).

Under the entailment regime, we can write a query that retrieves all named subclasses
of students in (T ,A) and all instances of each of these subclasses (cf. q

9 in Section 5):

SELECT ?x ?C WHERE { ?C rdfs:subClassOf ub:Student. ?x rdf:type ?C. }.

Here ?C ranges over the class names (IRIs) in (T ,A) and ?x over the IRIs of individ-
uals. If, for example, A consists of the two assertions on the left-hand side, then the
answer to the query over (T ,A) is on the right-hand side:

ClassAssertion(ub:UGStudent, ub:jim)
ClassAssertion(ub:Student, ub:bob)

?x

?C

ub:jim ub:UGStudent
ub:jim
ub:bob

ub:Student
ub:Student

2 http://www.w3.org/TR/sparql11-query/#sparqlAlgebra

R. Kontchakov et al.

To formally define SPARQL queries that can be used under the OWL 2 QL direct
semantics entailment regime, we assume that the set I of IRIs is partitioned into disjoint
and countably infinite sets of class names IC, object property names IR and individual
names II. Similarly, the variables V are also assumed to be a disjoint union of countably
infinite sets VC, VR, VI . Now, we define an OWL 2 QL BGP as a finite set of triple
patterns representing OWL 2 QL axiom and assertion templates in the FSS such as:3

SubClassOf(SubC, SuperC),
DisjointClasses(SubC1, . . . , SubCn),
ObjectPropertyDomain(OP, SuperC), ObjectPropertyRange(OP, SuperC),
SubObjectPropertyOf(OP, OP),
ClassAssertion(SuperC, I),

DisjointObjectProperties(OP1, . . . , OPn),
ObjectPropertyAssertion(OP, I, I),

where I  II  VI and OP, SubC and SuperC are defined by the following grammar
with C  IC  VC and R  IR  VR:

OP ::= R | ObjectInverseOf(R),
SubC ::= C | ObjectSomeValuesFrom(OP, owl:Thing),
SuperC ::= C | ObjectIntersectionOf(SuperC1, . . . , SuperCn)

|

ObjectSomeValuesFrom(OP, SuperC).

OWL 2 QL graph patterns are constructed from OWL 2 QL BGPs using the SPARQL
operators. Finally, an OWL 2 QL query is a pair (P, V ), where P is an OWL 2 QL graph
pattern and V  var(P ). To define the answer to such a query (P, V ) over an RDF
graph (T ,A), we fix a finite vocabulary IT ,A  I that includes all names (IRIs) in T
and A as well as the required finite part of the OWL 2 RDF-based vocabulary (e.g.,
owl:Thing but not the infinite number of the rdf: n). To ensure finiteness of the answers
and proper typing of variables, in the following definition we only consider solution
1(I)  V, for   {C, R, I}. For each
mappings s : var(P )  IT ,A such that s
BGP B, we define the answer BT ,A to B over (T ,A) by taking

BT ,A = {s : var(B)  IT ,A | (T ,A) |= s(B)},

where |= is the entailment relation given by the OWL 2 direct semantics. Starting from
the BT ,A and applying the SPARQL operators in P , we compute the set PT ,A of
solution mappings. The answer to (P, V ) over (T ,A) is the restriction PT ,A|V of
the solution mappings in PT ,A to the variables in V .
Example 3. Suppose T contains

SubClassOf(:A, ObjectSomeValuesFrom(:P, owl:Thing)),
SubObjectPropertyOf(:P, :R), SubObjectPropertyOf(:P, ObjectInverseOf(:S)).

Consider the following OWL 2 QL BGP B:

ClassAssertion(ObjectSomeValuesFrom(:R, ObjectSomeValuesFrom(:S,

ObjectSomeValuesFrom(:T, owl:Thing))), ?x).

3 The official specification of legal queries under the OWL 2 QL entailment regime only allows
ClassAssertion(C, I) rather than ClassAssertion(SuperC, I), which makes the OWL 2 QL entailment regime trivial and essentially subsumed by the OWL 2 RL entailment regime.
?

?

?
Assuming that A = {ClassAssertion(:A, :a), ObjectPropertyAssertion(:T, :a, :b)}, it is
not hard to see that BT ,A = {?x  :a}. Indeed, by the first assertion of A and the
first two axioms of T , any model of (T ,A) contains a domain element w (not necessarily among the individuals in A) such that ObjectPropertyAssertion(:R, :a, w) holds.
In addition, the third axiom of T implies ObjectPropertyAssertion(:S, w, :a), which together with the second assertion of A mean that {?x  :a} is an answer.









A|V .

The following theorem shows that answering OWL 2 QL queries under the direct
semantics entailment regime can be reduced to answering OWL 2 QL queries under
simple entailment, which are evaluated only on the extensional part of the RDF graph:
Theorem 4. Given any intensional graph T and OWL 2 QL query (P, V ), one can con-
, V ) such that, for any extensional graph A (in some fixed
struct an OWL 2 QL query (P
finite vocabulary), PT ,A|V = P
Proof sketch. By the definition of the entailment regime, it suffices to construct B
, for
any BGP B; the rewriting P
is obtained then by replacing each BGP B in P with
. First, we instantiate the class and property variables in B by all possible class and

property names in the given vocabulary and add the respective BIND operations. In each
of the resulting BGPs, we remove the class and property axioms if they are entailed by
T ; otherwise we replace the BGP with an empty one. The obtained BGPs are (SPARQL
representations of) conjunctive queries (with non-distinguished variables in complex
concepts SuperC of the assertions ClassAssertion(SuperC, I)). The second step is to
rewrite these conjunctive queries together with T into unions of conjunctive queries
(BGPs) that can be evaluated over any extensional graph A [5,21]. (We emphasise that
the SPARQL algebra operations, including difference and OPT, are applied to BGPs

and do not interact with the two steps of our rewriting.)
We illustrate the proof of Theorem 4 using the queries from Examples 2 and 3.

Example 5. The class variable ?C in the query from Example 2 can be instantiated,
using BIND, by all possible values from IC  IT ,A, which gives the rewriting

SELECT ?x ?C WHERE {

{ ?x rdf:type ub:Student. BIND(ub:Student as ?C) } UNION
{ ?x rdf:type ub:GradStudent. BIND(ub:GradStudent as ?C) } UNION
{ ?x rdf:type ub:UGStudent. BIND(ub:UGStudent as ?C) } }.

The query from Example 3 is equivalent to a (tree-shaped) conjunctive query with three
non-distinguished and one answer variable, which can be rewritten to

SELECT ?x WHERE { { ?x :R ?y. ?y :S ?z. ?z :T ?u. } UNION

{ ?x rdf:type :A. ?x :T ?u. } }.

3 Translating SPARQL under Simple Entailment to SQL

A number of translations of SPARQL queries (under simple entailment) to SQL queries
have already been suggested in the literature; see, e.g., [9,13,7,32,27]. However, none

R. Kontchakov et al.

of them is suitable for our aims because they do not take into account the three-valued
logic used in the OPTIONAL and BOUND constructs of the current SPARQL 1.1 (the semantics of OPTIONAL was not compositional in SPARQL 1.0). Note also that SPARQL
has been translated to Datalog [25,2,26].
We begin by recapping the basics of relational algebra and SQL (see e.g., [1]). Let
U be a finite (possibly empty) set of attributes. A tuple over U is a map t : U  ,
where  is the underlying domain, which always contains a distinguished element null.
A (|U|-ary) relation over U is a finite set of tuples over U (again, we use the set-based
rather than bag-based semantics). A filter F over U is a formula constructed from atoms
  U and c  , using the
isNull(U
connectives  and . Let F be a filter with variables U and let t be a tuple over U . The
truth-value F t  {",, } of F over t is defined inductively:
 (isNull(U
 (u = c)t =  if t(u) is null; otherwise, (u = c)t is the classical truth-value of
) is null;

)t is the classical truth-value of the predicate t(u) = t(u
);
1 =  or F t
2 = ,
if F t
2 = ",
if F t
1 = F t
otherwise.

))t is " if t(u) is null, for all u  U
?

?

?
the predicate t(u) = c; similarly, (u = u
otherwise, (u = u

if F t = ,
,
F t, otherwise,

and (F1  F2)t =


,
",
,
?

?

?
, and  otherwise;

), (u = c) and (u = u

), where U

)t =  if either t(u) or t(u
?

?

?
  U , u, u
?

?

?
 (F )t =

(Note that  and  are interpreted in the same three-valued logic as in SPARQL.) We
use standard relational algebra operations such as union, difference, projection, selec-
tion, renaming and natural (inner) join. Let Ri be a relation over Ui, i = 1, 2.
 If U1 = U2 then the standard R1  R2 and R1 \ R2 are relations over U1.
 If U  U1 then U R1 = R1|U is a relation over U .
"
#
 If F is a filter over U1 then F R1 = {t  R1 | F t = "} is a relation over U1.
 If v / U1 and u  U1 then v/uR1 =
, where tv/u : v  t(u) and
tv/u | t  R1
tv/u : u
 R1 1 R2 = {t1  t2 | t1  R1 and t2  R2 are compatible} is a relation over
U1U2. Here, t1 and t2 are compatible if t1(u) = t2(u) = null, for all u  U1U2,
in which case a tuple t1  t2 over U1  U2 is defined by taking t1  t2 : u  t1(u),
for u  U1, and t1  t2 : u  t2(u), for u  U2 (note that if u is null in either of
the tuples then they are incompatible).

  U1 \ {u}, is a relation over (U1 \ {u})  {v}.

  t(u

), for u
?

?

?
To bridge the gap between partial functions (solution mappings) in SPARQL and total
mappings (on attributes) in SQL, we require one more operation (expressible in SQL):
 If U  U1 =  then the padding U R1 is R1 1 nullU , where nullU is the relation
consisting of a single tuple t over U with t : u  null, for all u  U .

By an SQL query, Q, we understand any expression constructed from relation symbols
(each over a fixed set of attributes) and filters using the relational algebra operations
given above (and complying with all restrictions on the structure). Suppose Q is an
SQL query and D a data instance which, for any relation symbol in the schema under
consideration, gives a concrete relation over the corresponding set of attributes. The
?

?

?
answer to Q over D is a relation )Q)D defined inductively in the obvious way starting
from the base case: for a relation symbol Q, )Q)D is the corresponding relation in D.
We now define a translation,  , which, given a graph pattern P , returns an SQL query
 (P ) with the same answers as P . More formally, for a set of variables V , let extV be
a function transforming any solution mapping s with dom(s)  V to a tuple over V by
padding it with nulls:

extV (s) = {v  s(v) | v  dom(s)}  {v  null | v  V \ dom(s)}.

The relational answer to P over G is )P)G = {extvar(P )(s) | s  PG}. The SQL

query  (P ) will be such that, for any RDF graph G, the relational answer to P over G
coincides with the answer to  (P ) over triple(G), the database instance storing G as a
ternary relation triple with the attributes subj, pred, obj. First, we define the translation
of a SPARQL filter F by taking  (F ) to be the SQL filter obtained by replacing each
bound(v) with isNull(v) (other built-in predicates can be handled similarly).
Proposition 6. Let F be a SPARQL filter and let V be the set of variables in F . Then
F s = ( (F ))extV (s), for any solution mapping s with dom(s)  V .

The definition of  proceeds by induction on the construction of P . Note that we can
always assume that graph patterns under simple entailment do not contain blank nodes
} is
because they can be replaced by fresh variables. It follows that a BGP {tp1, . . . , tpn
equivalent to JOIN({tp1
}, . . . )). So, for the basis of induction we set

}, JOIN({tp2




 ({s, p, o}) =

(subj=s)(pred=p)(obj=o) triple,
ss/subj (pred=p)(obj=o) triple,
s,os/subj o/obj pred=p triple,
ss/subj (pred=p)(subj=obj) triple,
. . .

if s, p, o  I  L,
if s  V and p, o  I  L,
if s, o  V, s = o, p  I  L,
if s, o  V, s = o, p  I  L,

(the remaining cases are similar). Now, if P1 and P2 are graph patterns and F1 and F
are filters containing only variables in var(P1) and var(P1)var(P2), respectively, then
we set Ui = var(Pi), i = 1, 2, and

 (FILTER(P1, F1)) =  (F1) (P1),
 (BIND(P1, v, c)) =  (P1) 1 {v  c},
 (UNION(P1, P2)) = U2\U1  (P1)  U1\U2  (P2),
 (JOIN(P1, P2)) =
?

?

?
V1V2

$

V1,V2U1U2

V1V2=

 (OPT(P1, P2, F )) =  (F )( (JOIN(P1, P2))) 

(U1\V1 isNull(V1) (P1)) 1 (U2\V2 isNull(V2) (P2))

,
?

?

?
 (P1) \ U1  (F )( (JOIN(P1, P2)))

.

U2\U1

%

It is readily seen that any  (P ) is a valid SQL query and defines a relation over var(P ).
Theorem 7. For any RDF graph G and any graph pattern P , )P)G = ) (P ))triple(G).

R. Kontchakov et al.

Proof. The proof is by induction on the structure of P . Here we only consider the
induction step for P = JOIN(P1, P2). Let Ui = var(Pi), i = 1, 2, and U = U1  U2.
If t  )JOIN(P1, P2))G then there is a solution mapping s  JOIN(P1, P2)G with
extU1U2(s) = t, and so there are si  PiG such that s1 and s2 are compatible
and s1  s2 = s. Since, extUi(si)  )Pi)G, by IH, extUi(si)  ) (Pi))triple(G). Let
V = dom(s1)  dom(s2) and Vi = U \ dom(si). Then V1, V2 and V are disjoint and
partition U . By definition, extUi(si) : v  null, for each v  Vi, and therefore extUi (si)
is in )isNull(Vi) (Pi))triple(G). Let ti = extUi\Vi (si) and Qi = Ui\Vi (isNull(Vi) (Pi)).
We have ti  )Qi)triple(G), and since s1 and s2 are compatible and V are the common
non-null attributes of t1 and t2, we obtain t1  t2  )Q1 1 Q2)triple(G). As t extends
t1  t2 to V1  V2 by nulls, we have t  ) (JOIN(P1, P2)))triple(G).
If t  ) (JOIN(P1, P2)))triple(G) then there are disjoint V1, V2  U and compatible
tuples t1 and t2 such that ti  )Ui\Vi (isNull(Vi) (Pi)))triple(G) and t extends t1 t2 to
V1  V2 by nulls. Let si = {v  t(v) | v  Ui and t(v) is not null}. Then s1 and s2 are
compatible and extUi(si)  ) (Pi))triple(G). By IH, extUi (si)  )Pi)G and si  PiG.
So, s1  s2  JOIN(P1, P2)G and extU1U2(s1  s2) = t  )JOIN(P1, P2))G.



3.1 Optimising SPARQL JOIN and OPT

By definition,  (JOIN(P1, P2)) is a union of exponentially many natural joins (1).
}, none of the attributes in the
Observe, however, that for any BGP B = {tp1, . . . , tpn
 (tpi) can be null. So, we can drastically simplify the definition of  (B) by taking

 ({tp1, . . . , tpn

}) =  (tp1) 1  1  (tpn).

Moreover, this observation can be generalised. First, we identify the variables in graph
patterns that are not necessarily bound in solution mappings:

(B) = ,

B is a BGP,

(FILTER(P1, F )) = (P1) \ {v | bound(v) is a conjunct of F},
(BIND(P1, v, c)) = (P1),
(UNION(P1, P2)) = (var(P1) \ var(P2))  (var(P2) \ var(P1))  (P1)  (P2),
(JOIN(P1, P2)) = (P1)  (P2),
(OPT(P1, P2, F )) = (P1)  var(P2).
Thus, if a variable v in P does not belong to (P ), then v  dom(s), for any solution
mapping s  PG and RDF graph G (but not the other way round). Now, we observe
that the union in the definition of  (JOIN(P1, P2)) can be taken over those subsets of
var(P1)  var(P2) that only contain variables from (P1)  (P2). This gives us:
Theorem 8. If var(P1)  var(P2)  ((P1)  (P2)) =  then we can define
 (JOIN(P1, P2)) =  (P1) 1  (P2),

 (F ) (P2),
F R2 = F (R1 1 R2) U2\U1(R1\U1 (F (R1 1 R2))), for Ri over Ui.
F corresponds to LEFT JOIN in SQL with the

where R1
(Note that the relational operation
condition F placed in its ON clause.)

 (OPT(P1, P2, F )) =  (P1)
?

?

?
Example 9. Consider the following BGP B taken from the official SPARQL specification (find the names of people who do not know anyone):
FILTER(OPT({ ?x foaf:givenName ?n}, { ?x foaf:knows ?w }, "),bound(?w)).

By Theorem 8,  (B) is defined as isNull(w)(x,nQ1 x,wQ2), where Q1 and Q2
are pred=foaf:givenNamex/subjn/obj triple and pred=foaf:knowsx/subjw/obj triple, respectively (we note in passing that the projection on x is equivalent to xQ1 \ xQ2).

3.2 R2RML Mappings

The SQL translation of a SPARQL query constructed above has to be evaluated over
the ternary relation triple(G) representing the virtual RDF graph G. Our aim now is to
transform it to an SQL query over the actual database, which is related to G by means of
an R2RML mapping [10]. A variant of such a transformation has been suggested in [27].
Here we develop the idea first presented in [28]. We begin with a simple example.

Example 10. The following R2RML mapping (in the Turtle syntax) populates an object
property ub:UGDegreeFrom from a relational table students, whose attributes id and
degreeuniid identify graduate students and their universities:

:m1 a rr:TripleMap;

rr:logicalTable [ rr:sqlQuery SELECT * FROM students WHERE stype=1 ];
rr:subjectMap [ rr:template /GradStudent{id} ] ;
rr:predicateObjectMap [ rr:predicate ub:UGDegreeFrom ;

rr:objectMap [ rr:template /Uni{degreeuniid} ] ]

More specifically, for each tuple in the query, an R2RML processor generates an RDF
triple with the predicate ub:UGDegreeFrom and the subject and object constructed from
attributes id and degreeuniid, respectively, using IRI templates.

Our aim now is as follows: given an R2RML mapping M, we are going to define
an SQL query trM(triple) that constructs the relational representation triple(GD,M) of
the virtual RDF graph GD,M obtained by M from any given data instance D. Without
loss of generality and to simplify presentation, we assume that each triple map has

 one logical table (rr:sqlQuery),
 one subject map (rr:subjectMap), which does not have resource typing (rr:class),
 and one predicate-object map with one rr:predicateMap and one rr:objectMap.

This normal form can be achieved by introducing predicate-object maps with rdf:type
and splitting any triple map into a number of triple maps with the same logical table and subject. We also assume that triple maps contain no referencing object maps
(rr:parentTriplesMap, etc.) since they can be eliminated using joint SQL queries [10].
Finally, we assume that the term maps (i.e., subject, predicate and object maps) contain
no constant shortcuts and are of the form [rr:column v], [rr:constant c] or [rr:template s].
Given a triple map m with a logical table (SQL query) R, we construct a selection isNull(v1)  isNull(vk)R, where v1, . . . , vk are the referenced columns of m
(attributes of R in the term maps in m)this is done to exclude tuples that contain
null [10]. To construct trm, the selection filter is prefixed with projection subj,pred,obj

R. Kontchakov et al.

and, for each of the three term maps, either with renaming (e.g., with obj/v if the object
map is of the form [rr:column v]) or with value creation (if the term map is of the form
[rr:constant c] or [rr:template s]; in the latter case, we use the built-in string concatenation function ). For instance, the mapping :m1 from Example 10 is converted to the
SQL query

SELECT (/GradStudent

id) AS subj, ub:UGDegreeFrom AS pred,

(/Uni degreeuniid) AS obj FROM students
?

?

?
WHERE (id IS NOT NULL) AND (degreeuniid IS NOT NULL) AND (stype=1).

Given an R2RML mapping M, we set trM(triple) =
Proposition 11. For any R2RML mapping M and data instance D, t  )trM(triple))D
if and only if t  triple(GD,M).

mM trm.

Finally, given a graph pattern P and an R2RML mapping M, we define trM( (P ))
to be the result of replacing every occurrence of the relation triple in the query  (P ),
constructed in Section 3, with trM(triple). By Theorem 7 and Proposition 11, we ob-
tain:
Theorem 12. For any graph pattern P , R2RML mapping M and data instance D,
)P)GD,M = )trM( (P )))D.

3.3 Optimising SQL Translation
The straightforward application of trM to  (P ) can result in a very complex SQL
query. We now show that such queries can be optimised by the following techniques:
 choosing matching trm from trM(triple), for each occurrence of triple in  (P );
 using the distributivity of 1 over  and removing sub-queries with incompatible

IRI templates and de-IRIing join conditions;

 functional dependencies (e.g., primary keys) for self-join elimination [6,18,29,30].
To illustrate, suppose we are given a mapping M containing :m1 from Example 10 and
the following triple maps (which are a simplified version of those in Section 5):

:m2 a rr:TripleMap;

rr:logicalTable [ rr:sqlQuery SELECT * FROM students WHERE stype=0 ];
rr:subjectMap [ rr:template /UGStudent{id}; rr:class ub:Student ].

:m3 a rr:TripleMap;

rr:logicalTable [ rr:sqlQuery SELECT * FROM students WHERE stype=1 ];
rr:subjectMap [ rr:template /GradStudent{id}; rr:class ub:Student ].

which generate undergraduate and graduate students (both are instances of ub:Student,
but their IRIs are constructed using different templates [16]). Consider the following
query (a fragment of qobg

from Section 5):

SELECT ?x ?y WHERE { ?x rdf:type ub:Student. ?x ub:UGDegreeFrom ?y }.

The translation  of its BGP (after the SPARQL JOIN optimisation of Section 3.1) is

(xx/subj(pred=rdf:type)(obj=ub:Student) triple) 1

(x,yx/subjy/objpred=ub:UGDegreeFrom triple)
?

?

?
First, since triple always occurs in the scope of some selection operation F , we can
mM trm that have matching values of pred and/or
choose only those elements in
obj. In our example, the first occurrence of triple is replaced by tr :m2  tr :m3, and the
second one by tr :m1. This results in the natural join of the following union, denoted A:
?

?

?
(SELECT DISTINCT /UGStudent
WHERE (id IS NOT NULL) AND (stype=0))
UNION (SELECT DISTINCT /GradStudent

id AS x FROM students

id AS x FROM students

WHERE (id IS NOT NULL) AND (stype=1))

and of the following query, denoted B:

SELECT DISTINCT /GradStudent
WHERE (id IS NOT NULL) AND (degreeuniid IS NOT NULL) AND (stype=1)

id AS x, /Uni degreeuniid AS y FROM students

Second, observe that the IRI template in B is compatible only with the second component of A. Moreover, since the two compatible templates coincide, we can de-IRI the
join, namely, replace the join over the constructed strings (A.x = B.x) by the join over
the numerical attributes (A.id = B.id), which results in a more efficient query:

SELECT DISTINCT A.x, B.y FROM

(SELECT id, /GradStudent
WHERE (id IS NOT NULL) AND (stype=1)) A

id AS x FROM students

id AS x, /Uni degreeuniid AS y FROM students
(SELECT id, /GradStudent
WHERE(id IS NOT NULL)AND(degreeuniid IS NOT NULL)AND(stype=1))B

ON A.id = B.id

Finally, by using self-join elimination and the fact that id and stype are the composite
primary key in students, we obtain the query (without DISTINCT as x is unique)

SELECT /GradStudent
WHERE (degreeuniid IS NOT NULL) AND (stype=1)

id AS x, /Uni degreeuniid AS y FROM students

4 Putting It All Together

The techniques introduced above suggest the following architecture to support answering SPARQL queries under the OWL 2 QL entailment regime with data instances stored
in a database. Suppose we are given an ontology with an intensional part T and an extensional part stored in a database, D, over a schema . Suppose also that the languages
of  and T are connected by an R2RML mappingM. The process of answering a given
OWL 2 QL query (P, V ) involves two stages, off-line and on-line.

OWL 2 QL

query (P, V )

entailment regime

rewriter

ontology T

(intensional part)

R2RML

mapping M

OWL 2 QL
reasoner
T -mapping
optimiser

classified ontology
T -mapping M

OWL 2 QL query (P
, V )
over H-complete RDF graph

under simple entailment



SPARQL to SQL

translator

OFFLINE

SQL query
The off-line stage takes T , M and  and proceeds via the following steps:
 An OWL 2 QL reasoner is used to obtain a complete class / property hierarchy in T .

DB integrity constraints 

ONLINE

R. Kontchakov et al.
of M with the class and property hierarchy in T is taken as
 The composition MT
an initial T -mapping. Recall [29] that a mapping M
is a T -mapping over  if, for any
data instance D satisfying , the virtual (not materialised) RDF graph GD,M obtained
to D contains all class and property assertions  with (T , GD,M ) |= .
by applyingM
As a result, GD,M is complete with respect to the class and property hierarchy in T (or
H-complete), which allows us to avoid reasoning about class and property inclusions (in
particular, inferences that involve property domains and ranges) at the query rewriting
step  and drastically simplify rewritings (see [29] for details).
 The initial T -mapping MT
is then optimised by (i) eliminating redundant triple
maps detected by query containment with inclusion dependencies in , (ii) eliminating
redundant joins in logical tables using the functional dependencies in , and (iii) merging sets of triple maps by means of interval expressions or disjunctions in logical tables
(see [29] for details). Let M
The on-line stage takes an OWL 2 QL query (P, V ) as an input and proceeds as follows:
 The graph pattern P and T are rewritten to the OWL 2 QL graph pattern P
over the
H-complete virtual RDF graph GD,M under simple entailment by applying the classified ontology of step  to instantiate class and property variables and then using a
query rewriting algorithm (e.g., the tree-witness rewriter of [29]); see Theorem 4.
 The graph pattern P
) over the 3-column
) is unfolded
representation triple of the RDF graph (Theorem 7). Next, the query  (P
into the SQL query trM( (P
)) over the original database D (Theorem 12). The unfolded query is optimised using the techniques similar to the ones employed in step .
 The optimised query is executed by the database.
As follows from Theorems 4, 7 and 12, the resulting query gives us all correct answers
to the original OWL 2 QL query (P, V ) over T and D with the R2RML mapping M.

be the resulting T -mapping over .

is transformed to the SQL query  (P











5 Evaluation

The architecture described above has been implemented in the open-source OBDA system Ontop4. We evaluated its performance using the OWL 2 QL version of the Lehigh
University Benchmark LUBM [16]. The ontology contains 43 classes, 32 object and
data properties and 243 axioms. The benchmark also includes a data generator and a
set of 14 queries q1q14. We added 7 queries with second-order variables ranging over
class and property names: q
10 taken
from [19]. The LUBM data generator produces an OWL file with class and property as-
sertions. To store the assertions in a database, we created a database schema with 11
relations and an R2RML mapping with 89 predicate-object maps. For instance, the information about undergraduate and graduate students (id, name, etc.) from Example 10
is collected in the relation students, where the attribute stype distinguishes between the
types of students (stype is known as a discriminant column in databases); more details
including primary and foreign keys and indexes are provided in the full version.
?

?

?
9 derived from q4 and q9, and qobg

2 , qobg

4 , qobg
?

?

?
4 , q
?

?

?
4, q
?

?

?
9, q

We experimented with the data instances LUBMn, n = 1, 9, 20, 50, 100, 200, 500
(where n specifies the number of universities; LUBM1 and LUBM9 were used in [19]).

4 http://ontop.inf.unibz.it
?

?

?
Table 1. Start up time, data loading time (in s) and query execution time (in ms): O is Ontop,
OBH and OBP are OWL-BGP with Hermit and Pellet, respectively, and P is standalone Pellet

LUBM1

LUBM100

q1
q2
q3
q4
q5
q6
q7
q8
q9
q10
q11
q12
q13
q14

q
?

?

?
q
?

?

?
q
?

?

?
q

qobg

qobg

qobg

start up
data load

O OBH
?

?

?
13.6s
3.1s
10s
n/a
?

?

?
11 137
?

?

?
4 451

34 005
95 875
168 978
?

?

?
91 855
65 916
57 141

31 269
7.7s
n/a
?

?

?
3.6s
n/a
?

?

?
5 076
?

?

?
1 168
?

?

?
4 686
6 093
9 992

6 998
3.1s
15s

LUBM9
?

?

?
2 531
?

?

?
189 126
?

?

?
40 575
178 401
?

?

?
149 191
80m33s
n/a
?

?

?
1 385
1 214
?

?

?
2 258
18s
n/a
?

?

?
58 968
?

?

?
7 466
?

?

?
13 524
?

?

?
54 092
67 123
39 477

163 308
3.1s
1m56s
?

?

?
30 593
2 087
2 093
2 182
10 781
2 171
2 131
12 125
2 134
2 093
2 114
2 657
4 457
4 422
9 179
19 945
19 705
5 411
3 969
17 929
3m23s
n/a

LUBM200 LUBM500
?

?

?
434 349
?

?

?
44 598
?

?

?
92 376
?

?

?
295 228
356 176
206 061

459 669
3.1s
10m17s
?

?

?
123 578
?

?

?
15 227
?

?

?
29 512
?

?

?
115 110
151 376
79 351

174 362
3.1s
3m35s

Here we only show the results for n = 1, 9, 100, 200, 500 containing 103k, 1.2M, 14M,
28M and 69M triples, respectively; the complete table can be found in the full version.
All the materials required for the experiments are available online5. We compared Ontop with two other systems, OWL-BGP r123 [19] and Pellet 2.3.1 [31] (Stardog and
OWLIM are incomplete for the OWL 2 QL entailment regime). OWL-BGP requires an
OWL 2 reasoner as a backend; as in [19], we employed HermiT 1.3.8 [14] and Pellet 2.3.1. The hardware was an HP Proliant Linux server with 144 cores @3.47GHz,
106GB of RAM and a 1TB 15k RPM HD. Each system used a single core and was
given 20 GB of Java 7 heap memory. Ontop used MySQL 5.6 database engine.

The evaluation results are given in Table 1. OWL-BGP and Pellet used significantly
more time to start up (last but one row) because they do not rely on query rewriting and
require costly pre-computations. OWL-BGP failed to start on LUBM9 with Pellet and
on LUBM20 with HermiT; Pellet ran out of memory after 10hrs loading LUBM200. For
Ontop, the start up is the off-line stage described in Section 4; it does not include the
time of loading the data into MySQL, which is specified in the last row of Table 1 (note
that the data is loaded only once, not every time Ontop starts; moreover, this could be
improved with CSV loading and delayed indexing rather than SQL dumps we used).

On queries q1q14, Ontop generally outperforms OWL-BGP and Pellet. Due to the
optimisations, the SQL queries generated by Ontop are very simple, and MySQL is
able to execute them efficiently. This is also the case for large datasets, where Ontop is
able to maintain almost constant times for many of the queries. Notable exceptions are
q6, q8 and q14 that return a very large number (hundreds of thousands) of results (low
selectivity). A closer inspection reveals that execution time is mostly spent on fetching
the results from disk. On the queries with second-order variables, the picture is mixed.

5 https://github.com/ontop/iswc2014-benchmark

R. Kontchakov et al.

While indeed these queries are not the strongest point of Ontop at the moment, we see
that in general the performance is good. Although Pellet outperforms Ontop on small
datasets, only Ontop is able to provide answers for very large datasets. For second-

4 ) and large datasets, the performance
order queries with high selectivity (e.g., q
of Ontop is very good while the other systems fail to return answers.
?

?

?
4 and q

6 Conclusions
In this paper, we gave both a theoretical background and a practical implementation
of a procedure for answering SPARQL 1.1 queries under the OWL 2 QL direct semantics entailment regime in the scenario where data instances are stored in a relational
database whose schema is connected to the language of the given OWL 2 QL ontology
via an R2RML mapping. Our main contributions can be summarised as follows:

 We defined an entailment regime for SPARQL 1.1 corresponding to the OWL 2 QL
profile of OWL 2 (which was specifically designed for ontology-based data access).
 We proved that answering SPARQL queries under this regime is reducible to answering SPARQL queries under simple entailment (where no reasoning is involved).
 We showed how to transform such SPARQL queries to equivalent SQL queries over
an RDF representation of the data, and then unfold them, using R2RML mappings,
into SQL queries over the original relational data.

 We developed optimisation techniques to substantially reduce the size and improve

the quality of the resulting SQL queries.

 We implemented these rewriting and optimisation techniques in the OBDA system
Ontop. Our initial experiments showed that Ontop generally outperforms reasonerbased systems, especially on large data instances.

Some aspects of SPARQL 1.1 (such as RDF types, property paths, aggregates) were not
discussed here and are left for future work.

Acknowledgements. Our work was supported by EU project Optique. We thank S. Ko-
