On the Semantics of SPARQL Queries with

Optional Matching under Entailment Regimes

Egor V. Kostylev and Bernardo Cuenca Grau

Department of Computer Science, University of Oxford

Abstract. We study the semantics of SPARQL queries with optional
matching features under entailment regimes. We argue that the normative semantics may lead to answers that are in conflict with the intuitive
meaning of optional matching, where unbound variables naturally represent unknown information. We propose an extension of the SPARQL
algebra that addresses these issues and is compatible with any entailment
regime satisfying the minimal requirements given in the normative speci-
fication. We then study the complexity of query evaluation and show that
our extension comes at no cost for regimes with an entailment relation
of reasonable complexity. Finally, we show that our semantics preserves
the known properties of optional matching that are commonly exploited
for static analysis and optimisation.

Introduction

SPARQL became the standard language for querying RDF in 2008 [1]. Since
then, the theoretical properties of SPARQL have been the subject of intensive research efforts and are by now relatively well-understood [2,3,4,5,6,7]. At the same
time, SPARQL has become a core technology in practice, and most RDF-based
applications rely on SPARQL endpoints for query formulation and processing.

The functionality of many such applications is enhanced by OWL 2 ontologies [8], which are used to provide background knowledge about the application
domain, and to enrich query answers with implicit information. A new version
of SPARQL, called SPARQL 1.1, was released in 2013 [9]. This new version captures the capabilities of OWL 2 by means of the so-called entailment regimes [10]:
a flexible mechanism for extending SPARQL query answering to the W3C standards layered on top of RDF. A regime specifies which RDF graphs and SPARQL
queries are legal (i.e., admissible) for the regime, as well as an entailment relation
that unambiguously defines query answers for all legal queries and graphs.

The semantics of SPARQL under entailment regimes is specified for the conjunctive fragment, where queries are represented as basic graph patterns (i.e.,
sets of RDF triples with variables) and query answers are directly provided by
the entailment relation of the regime. Roughly speaking, to check whether a mapping from variables of the query to nodes in the RDF graph is an answer to the
query, one first transforms the query itself into an RDF graph by substituting
each variable with the corresponding value, and then checks whether this graph
is entailed in the regime by the original data graph [10,11].

P. Mika et al. (Eds.) ISWC 2014, Part II, LNCS 8797, pp. 374389, 2014.
c Springer International Publishing Switzerland 2014
?

?

?
When one goes beyond the basic fragment of SPARQL the language becomes
considerably more complicated, but the effect of entailment regimes on the query semantics remains cirscumscribed to basic graph patterns. Thus, to evaluate a query
one must first evaluate its component basic patterns using the relevant regime, and
then compose the results by means of the SPARQL algebra operations.

Of particular interest from both a theoretical and a practical perspective is
the extension of the basic fragment of SPARQL with the optional matching
feature, which is realised in the language by means of the OPTIONAL operator
(abbreviated by OPT in this paper). This feature allows the optional information
to be added to query answers only when the information is available in the RDF
data graph: if the optional part of the query does not match the data, then the
relevant variables are left unbounded in query answers.

One of the main motivations behind optional matching in SPARQL was to
deal with the lack of regular, complete structures in RDF graphs (see [9] Section 6) and hence with the inherent incompleteness of information in RDF data
sources where only partial information about the relevant Web resources is typically available. In this setting, an unbound variable in an answer mapping is
naturally interpreted as a null value, meaning that there might exist a binding
for this variable if we consider other information elsewhere on the Web, but none
is currently available in the RDF graph at hand. An additional (and slightly dif-
ferent) motivation for optional matching was to introduce a mechanism for not
rejecting solutions because some part of the query pattern does not match [1];
in this sense, one would naturally expect optional matching to either extend
solutions with the optional information, or to leave solutions unchanged.

Both readings of optional matching coincide if we focus just on RDF, and they
are faithfully captured by the normative semantics. In this paper, however, we
argue that they naturally diverge once we consider more sophisticated entailment
regimes. Furthermore, the differences that arise, even if subtle, can have a major
impact on expected answers.

To make this discussion concrete, let us briefly discuss a simple example of
an RDF graph representing the direct train lines between UK cities as well as
ferry boat transfers from UK cities to international destinations. Let this graph
be exhaustive in its description of rail connections, but much less so in what
concerns ferry transfers. We may exploit optional matching to retrieve all direct
train connections between cities X and Y, extended with ferry transfers from Y
to other cities Z whenever possible. Under the normative semantics of SPARQL
we may obtain answers (London, Oxford,) and (London, Holyhead ,) provided
the graph has information about direct train lines from London to both Oxford
and Holyhead , but no matching can be found in the graph for ferry connections
starting from Oxford or Holyhead to other cities. Suppose next that the data
graph is extended to a graph corresponding to an OWL 2 ontology in which
it is stated that inland cities do not have ferry connections, and that Oxford
is an inland city. The ontology establishes a clear distinction between Oxford
and Holyhead : whereas the former is inland and cannot have ferry connections,
the latter may still well be (and indeed is) a coastal city offering a number of

E.V. Kostylev and B. Cuenca Grau

transfers to international destinations. The normative OWL 2 direct semantics
entailment regime, however, does not distinguish between the case of Holyhead
(where the information about ferry connections is still unknown) and Oxford
(where the information is certain), and both answers would be returned. In this
way, the normative semantics adopts the reading of optional matching where the
optional information is used to complete (but never discard) query answers. In
contrast, under the reading of unbounded variables as placeholders for unknown
information, one would naturally expect the answer on Oxford to be ruled out.
Indeed, if our goal were to find rail to ferry transfers starting from London
and terminating in Dublin by first querying this graph and then looking for the
missing information elsewhere on the Web, discarding cities like Oxford on the
first stage would significantly facilitate our task.

In this paper, we propose an alternative semantics for the OPT operator which
adopts the aforementioned reading of optional matching as an incomplete null.
We call our semantics strict, which reflects the fact that it rules out those answers in which unbound variables in the optional part cannot be matched to any
consistent extension of the input graph. Our semantics is given as an extension of
the SPARQL algebra and hence satisfies the expected compositionality properties of algebraic query languages. Furthermore, it is backwards-compatible with
the normative semantics for regimes in which all legal graphs are consistent, such
as the RDF regime [10]. We also study the complexity of query evaluation and
show that our extension comes at no cost for regimes in which entailment is not
harder than query evaluation under normative semantics for the RDF regime.
Finally, we show that our semantics preserves the known properties of optional
matching that are commonly exploited for static analysis and optimisation.

2 SPARQL 1.1 under Entailment Regimes

In this section, we formalise the syntax and normative semantics of a core fragment of SPARQL 1.1 with optional matching under entailment regimes. Our
formalisation is based on the normative specification documents [9,10,11] and
builds on the well-known foundational works on SPARQL [2,3,6].

2.1 Syntax

Let I, L, and B be countably infinite sets of IRIs, literals, and blank nodes,
respectively. The set of RDF terms T is I  L  B. An RDF triple is a triple
(s p o) from T  I  T, where s is called subject, p predicate, and o object. An
(RDF) graph is a finite set of RDF triples.
Assume additionally the existence of a countably infinite set V of variables
disjoint from T. A triple pattern is a tuple from (T  V)  (I  V)  (T  V). A
basic graph pattern (BGP) is a finite set of triple patterns. Built-in conditions
are inductively defined as follows:
1. if ?X, ?Y  V and c  T then bound(?X), ?X = c, and ?X =?Y are built-in

conditions; and
?

?

?
2. if R1 and R2 are built-in conditions then R1, R1  R2 and R1  R2 are

built-in conditions.

Complex graph patterns are constructed from BGPs using a wide range of available operators that are applicable to graph patterns and built-in conditions. We
focus on the AND-OPT-FILTER fragment (i.e., we consider neither union nor
projection), which is widely accepted to be the fundamental core of SPARQL [2].
In this setting, graph patterns are inductively defined as follows (e.g., see [11]):

1. every BGP is a graph pattern;
2. if P1 and P2 are graph patterns that share no blank nodes then (P1 AND P2)

and (P1 OPT P2) are graph patterns (called AND and OPT patterns); and
3. if P is a graph pattern and R is a built-in condition, then (P FILTER R) is

a graph pattern (called FILTER pattern).

We denote vars(P ) (resp. with triples(P )) all the variables from V (resp. all triple
patterns) which appear in a graph pattern P .

We conclude with the definition of a special class of graph patterns with
intuitive behaviour [2]. A graph pattern is well-designed iff (a) for each of its
FILTER sub-patterns (P FILTER R) all the variables of R are in vars(P ), and
(b) for each of its OPT sub-patterns (P1 OPT P2) the pattern P1 mentions all
the variables of P2 which appear outside this sub-pattern. Note that all graph
patterns in the examples of this paper are well-designed.

2.2 Semantics of BGPs under Entailment Regimes

The semantics of graph patterns is defined in terms of mappings; that is, partial
functions from variables V to terms T. The domain dom() of a mapping  is
the set of variables on which  is defined. For a BGP P we denote with (P )
the BGP obtained by applying  to all variables in P from dom().
Two mappings 1 and 2 are compatible (written as 1  2) if 1(?X) =
2(?X) for all variables ?X which are in both dom(1) and dom(2). If 1  2,
then we write 1  2 for the mapping obtained by extending 1 with 2 on
variables undefined in 1. A mapping 1 is subsumed by a mapping 2 (written
1  2) iff 1  2 and dom(1)  dom(2). Finally, a set of mappings 1 is
subsumed by a set of mappings 2 (written 1  2) iff for each 1  1 there
exists 2  2 such that 1  2.
as a tuple (R,G,P,C, ), where

Based on [10], an entailment regime R (or simply a regime) can be formalised

1. R is a set of reserved IRIs from I;
2. G is the set of legal graphs;
3. P is the set of legal BGPs;
4. C is the set of consistent graphs, such that C  G; and
5.  is the query answering function, that takes a graph G from G and a
BGP P from P and returns either a set P G of mappings  such that
dom() = vars(P ), if P  C; or Err, otherwise.

E.V. Kostylev and B. Cuenca Grau

As in most theoretical works on SPARQL [2,3,6,12], we assume that the query
answering function returns a set of mappings, rather than a multiset. In the
normative specification [10] the value of  for inconsistent graphs is explicitly
undefined, and the only thing which is guaranteed is that the answer is finite.
However, an assumed behaviour is to at least issue a warning for inconsistent
graphs. Moreover, in some regimes such as the OWL 2 Direct Semantics Regime
issuing an error is mandatory. A regime must also satisfy certain basic additional
conditions, which are immaterial to our results (see [10] Section 1.3).

The definitions of query answering and consistency in a regime are based on an
entailment relation [10], which is also specified as part of the regime. We do not
model the entailment relation explicitly, but assume two conditions that capture
the effects of any reasonable entailment relation on legality and consistency. All
regimes mentioned in the normative specification satisfy these properties and in
this paper we consider only regimes that do so.

(C1) If graphs G, G1 and G2 are legal and there is h : T  T, preserving R,
such that h(G1  G2)  G then G1  G2 is legal; if, in addition, G is in C
then G1  G2 is also in C.
(C2) If a BGP P is in P then (P ) is in G for any (total)  : V  (T\ R), such
that (P ) is a graph; if also (P ) is in C then   P (P ).

Condition (C1) formalises (a weak form of) the monotonicity of legality and
consistency: an illegal graph that is a union of legal ones cannot be made legal
by identifying and renaming of non-reserved terms or adding triples to it; more-
over, a similar property holds for consistency. Condition (C2) guarantees, that
freezing variables of a legal BGP to non-reserved terms gives us a legal graph,
and, moreover, if such a graph is consistent, then the answer of the BGP on this
graph contains the mapping corresponding to the freezing.

The notions introduced in the remainder of this paper are parameterised with

a regime R, which is not mentioned explicitly for brevity.

2.3 Normative Semantics under Entailment Regimes
Following [2], now we show how the query answering function  extends to
complex graph patterns (we refer to [2] for details). A mapping  satisfies a
built-in condition R, denoted  |= R, if one of the following holds:
1. R is bound(?X) and ?X  dom(); or
2. R is ?X = c, ?X  dom() and (?X) = c; or
3. R is ?X =?Y , ?X  dom(), ?Y  dom() and (?X) = (?Y ); or
4. R is an evaluating to true Boolean combination of other built-in conditions.

Given two sets of mappings 1 and 2, the join, union and difference opera-

tions are defined as follows:

1  2 = {1  2 | 1  1 and 2  2 such that 1  2},
1  2 = { |   1 or   2},
1 \ 2 = {1 | 1  1, there is no 2  2 such that 1  2}.
?

?

?
Based on these, the left outer join operation is defined as follows:

1  2 = (1  2)  (1 \ 2).

G = P G;

A graph pattern is legal for a regime R if all the BGPs it contains are legal.
The normative query answering function n is inductively defined for all legal
graph patterns P on the base of  as follows. For graphs G from C we have:
1. if P is a BGP then P n
2. if P is P1 AND P2 then P n
3. if P is P1 OPT P2 then P n
 FILTER R then P n
4. if P is P
If G  C then P n
G = Err for any graph pattern P (which again coincides with
P G when P is a BGP). Note, that by these definitions   P n
G implies that
dom()  vars(P ), but this inclusion may be strict if P contains OPT operator.
Having the semantics defined, we say that two legal patterns P1 and P2 are
equivalent (under normative semantics) with respect to a regime R, denoted by
P1 n P2, if P1n

G = P1n
G  P2n
G;
G  P2n
G = P1n
G; and
G = { |   P
G and  |= R}.
n

G = P2n

G for every RDF graph G  G.

3 On Optional Matching under the Normative Semantics

One of the main motivations for optional matching in SPARQL was to deal with
the lack of regular, complete structures in RDF graphs [9]. In contrast to relational databases, RDF data is loosely structured and hence in many applications
it is not satisfactory to reject an answer if some relevant information is missing.
For example, if we are interested in retrieving the names, emails, and websites
of employees, we may not want to discard a partial answer involving the name
and email address of a particular employee merely because the information on
the employees website is not available in the graph.

The normative semantics was designed to deal with such situations: the optional information is included in query answers only when the information is
available; otherwise, the relevant variables are left unbounded. An unbound variable in an answer is thus a manifestation of inherent incompleteness of RDF
data sources, and the missing information is interpreted as unknown.

This natural interpretation of query results, however, no longer holds if the
query is evaluated under certain entailment regimes, as we illustrate next by
means of examples. In these and all other examples given later on, we focus on
the OWL 2 direct semantics regime. In order for an RDF graph to be legal for
this regime, it must correspond to an OWL 2 ontology; similarly, legal BGPs
must correspond to an extended ontology in which variables are allowed [10].
Thus, in the examples we express RDF graphs and BGPs in (extended) OWL 2
functional syntax, and use words ontology and graph interchangeably.1

1 Declaration axioms are omitted in ontologies and BGPs. Also, we use shortened

names for some constructs, i.e., PropertyDomain instead of ObjectPropertyDomain.

E.V. Kostylev and B. Cuenca Grau

Example 1. Consider the OWL 2 ontology O1 consisting of the following axioms:

ClassAssertion(InlandCity Oxford ), PropertyAssertion(train London Oxford ),
ClassAssertion(CoastalCity Holyhead ), PropertyAssertion(train London Holyhead ),
DisjointClasses(CoastalCity InlandCity).

PropertyDomain(ferry CoastalCity),

Consider also the following graph pattern P1, which we wish to evaluate over O1:
PropertyAssertion(train ?X ?Y ) OPT PropertyAssertion(ferry ?Y ?Z).

Intuitively, solutions to P1 provide direct train lines from city X to city Y as well
as, optionally, the ferry transfers from Y to other cities Z. Under the normative
semantics, the BGPs in P1 are evaluated separately. In particular, the optional
BGP is evaluated to the empty set, and P1nO1 = {1, 2}, where

1 = {?X  London, ?Y  Oxford}, and
2 = {?X  London, ?Y  Holyhead}.

In both answers, variable ?Z is unbounded and hence we conclude that O1

contains no relevant information about ferry connections starting from Oxford
or Holyhead . However, the nature of the lack of such information is fundamentally
different. On the one hand, the connections from Holyhead (e.g., to Dublin) are

missing from O1 just by the incompleteness of the information in the graph,

which is usual in (and also a feature of) Semantic Web applications. On the
other hand, Oxford cannot have a ferry connection because it is a landlocked
city, and hence the information about its (lack of) ferry connections is certain.
Thus, the normative semantics cannot distinguish between unknown and nonexistent ferry connections. However, if we adhere to the reading of unbounded
variables as incomplete information or nulls, then 1 should not be returned
as an answer.

The issues described in this example become even more apparent in cases
where the optional part alone cannot be satisfied, as it is incompatible with the
information in the graph, as illustrated by the following example.

Example 2. Consider the ontology O2 with the following axioms:

ClassAssertion(Person Peter ), DisjointProperties(hasFather hasMother ).

Furthermore, consider the following pattern P2:

ClassAssertion(Person ?X) OPT ({

PropertyAssertion(hasFather ?X ?Y ),
PropertyAssertion(hasMother ?X ?Y )}).

The optional BGP is evaluated to the empty mapping and hence under the
normative semantics we have the mapping {?X  Peter} forming the answer
set P2nO2 . Note, however, that the optional BGP in P2 is in contradiction with
the disjointness axiom: under the OWL 2 regime, no solution to P2 can exist for
any ontology containing that axiom.
?

?

?
As these examples suggest, if we interpret unbound variables in answers to
queries with optional parts as an indication of unknown information in the data
graph, then the normative semantics may yield counter-intuitive answers.

At the core of this issue is the inability of the normative semantics to distinguish between answers in which it is possible to assign values to the missing
optional part (a natural reflection of incompleteness in the data), and those
where this is impossible (a reflection that the missing information is fundamentally incompatible with the answer). This distinction is immaterial for regimes
in which all legal graphs are consistent, but it quickly becomes apparent in more
sophisticated regimes, such as those based on OWL 2.

4 Semantics of Strict Optional Matching

In this section, we propose our novel semantics for optional matching under
regimes. In a nutshell, our semantics addresses the issues described in Section 3
by ruling out those answer mappings where unbound variables in the optional
part cannot be matched to any consistent extension of the input graph. Our
semantics is therefore strict , in the sense that only answers in which unbound
variables are genuine manifestations of incompleteness in the data are returned.

4.1 Definition of Strict Semantics

We start by introducing the notion of a frozen RDF graph for a pattern P and
a mapping . Roughly speaking, this graph is obtained by taking all the triple
patterns in P and transforming them into RDF triples by applying the extension
of  where unbounded variables are frozen to arbitrary fresh constants.
Definition 1. Let R = (R,G,P,C, ) be an entailment regime. Let P be a
legal graph pattern, and let  be a mapping from variables V to RDF terms T.
Then, the freezing GP
 of P under  is the RDF graph  (triples(P )), where   is
the mapping that extends  by assigning each variable in vars(P ), which is not
in dom(), to a globally fresh IRI from I (not belonging to R).

The freezing GP

 depends only on the candidate mapping  and the triple
patterns occurring in P ; thus, it does not depend either on the specific operators
used in P , or on the RDF graph over which the query pattern is to be evaluated.

Example 3. For the pattern P1 and mappings 1 and 2 from Example 1 we
have the following freezings in functional-style syntax:

1 = {PropertyAssertion(train London Oxford ),
GP1

PropertyAssertion(ferry Oxford w1)};

2 = {PropertyAssertion(train London Holyhead ),
GP1

PropertyAssertion(ferry Holyhead w2)};

where w1 and w2 are freshly introduced IRIs.

E.V. Kostylev and B. Cuenca Grau

Intuitively, the freezing represents the simplest, most general, RDF graph
over which all the undefined variables in a given solution mapping could be
bounded to concrete values. Thus, if GP
 together with the input graph G is
not a consistent graph for the relevant regime, we can conclude, using condition
(C1) of the regime, that the undefined variables in  will never be matched to
concrete values in any consistent extension of G and hence  should be ruled out
as an answer. On the other hand, if G GP
 is consistent, then such an extension
exists and, by condition (C2), the undefined variables can be mapped in this
extension.
Definition 2. Let R = (R,G,P,C, ) be an entailment regime. A mapping 
is R-admissible for a graph G  C and legal graph pattern P if G GP
 is a graph
belonging to C. The set of all R-admissible mappings for a consistent graph G
and a legal graph pattern P is denoted as Adm(G, P ).

Example 4. Clearly, O1GP1
cities, but Oxford is an inland city. In contrast, O1  GP1
have 1 / Adm(O1, P ), but 2  Adm(O1, P ).

1 is inconsistent since ferries only depart from coastal
2 is consistent. Thus, we

We are now ready to formalise our semantics.

Definition 3. Let R = (R,G,P,C, ) be an entailment regime. The strict
query answering function s is inductively defined for all legal graph patterns
P on the base of  as follows. For graphs G from C we have:
1. if P is a BGP then P s
2. if P is P1 AND P2 then P s
3. if P is P1 OPT P2 then P s
 FILTER R then P s
4. if P is P
where  denotes the standard set-theoretic intersection. If G  C then P s
G =
Err for any graph pattern P . Finally, legal patterns P1 and P2 are equivalent
(under strict semantics), written P1 s P2, if P1s

G)  Adm(G, P );
G = (P1s
G  P2s
G)  Adm(G, P ); and
G  P2s
G = (P1s
G = { |   P
G and  |= R},
s

G for any legal G.

G = P G;

G = P2s

Example 5. The strict semantics behaves as expected for our running examples.

For O1 and P1 from Example 1 we have that P1sO1 = {1}, whereas for O2
and P2 from Example 2 we have P2sO2 = .

The strict and normative semantics coincide in two limit cases. First, if the
entailment regime does not allow for inconsistent graphs (i.e., if C = G) as is
the case for the RDF regime [10], then P s
G for every legal pattern P
and graph G. Second, if the relevant pattern P is OPT-free then the freezing for
every candidate answer mapping contains no fresh IRIs and is R-entailed by G;
thus, we again have P s
Thus, the difference between the normative semantics n and strict semantics
s manifests only for regimes that admit inconsistency, and is circumscribed
to the presence of OPT in graph patterns, where non-admissible mappings are
excluded in the case of the strict semantics. Note, however, that even if a mapping

G for every legal graph G.

G = P n

G = P n
?

?

?
1 (resp. 2) is admissible for a sub-pattern P1 (resp. P2) containing OPT, it is
possible for 1  2 not to be admissible for the joined pattern P = P1 AND P2.

Thus, the admissibility restriction is also explicitly reflected in the semantics of
AND given in Definition 3. This is illustrated in the example given next.
Example 6. Consider ontology O3, consisting of the following axioms:

SubClassOf(

IntersectionOf(SomeValuesFrom(husband Thing)

SomeValuesFrom(wife Thing))

Nothing),

ClassAssertion(Person Mary ).

The first axiom establishes that a person cannot have both a husband and a wife.
Consider also the following well-designed graph pattern P3:
?

?

?
ClassAssertion(Person ?X) OPT (PropertyAssertion(husband ?X ?Y ))
?

?

?
ClassAssertion(Person ?X) OPT (PropertyAssertion(wife ?X ?Z))

.

Clearly,  = {?X  Mary} belongs to the strict answer to each of the OPT
sub-patterns of P3 since each of them independently can match to a consistent
extension of O3. However,  is not admissible for P3 since Mary has both a
 is inconsistent. Thus, P3sO3 = .
husband and a wife in GP3

 , and hence O3GP3

4.2 Comparing the Normative and Strict Semantics

Our previous examples support the expected behaviour of our semantics, namely
that its effect is circumscribed to filtering out problematic answers returned under the normative semantics. We next formally show that our semantics behaves
as expected in general, provided that we restrict ourselves to well-designed patterns and negation-free FILTER expressions (which are rather mild restrictions).
It is known that patterns which are not well-designed easily lead to unexpected
answers, even under the normative semantics (we refer to [2] for a detailed dis-
cussion). Therefore, it comes at no surprise that the intuitive behaviour of our
semantics is only guaranteed under this assumption.

But before stating our main result in this section, we establish first a useful

lemma that is applicable to well-designed patterns under both semantics.
Lemma 1. Let R = (R,G,P,C, ) be an entailment regime, and let P be a
sub-pattern of a well-designed graph pattern. If a variable appears both inside
and outside P , then it is defined in each mapping from P n
G for any consistent
G as well as in each mapping from P s
G.

Proof. For the sake of contradiction, let ?X be a variable which appears both
inside and outside P , but is undefined in some mapping   P n
G. Since
?X is undefined, it appears in the optional (i.e., right) part of an OPT-sub-
pattern of P . The overall graph pattern is well-designed, so ?X must appear in
the mandatory (i.e., left) part of the OPT-sub-pattern of P . If this sub-pattern

G  P s

E.V. Kostylev and B. Cuenca Grau

G  P n

is not in the optional part of another higher-level sub-pattern, then ?X must be
defined in , which contradicts the original assumption. Otherwise, we can apply
the same argument and show that ?X is in the mandatory part of the higherlevel sub-pattern. Such reasoning would eventually lead to a contradiction. 
Theorem 1. Let R = (R,G,P,C, ) be an entailment regime. The inclusion
G holds for any graph G from C and any legal well-designed graph
P s
pattern P which does not use negation  in FILTER expressions.
Proof. The proof is by induction on the structure of the graph pattern P .
1. Let P be a BGP. Then P s
2. Let P be P1 AND P2, P1s

G = P G by definition of the semantics.
G, P2s
G, and  be a mapping
from P s
G. By the definition of the semantics of AND patterns we have that
G)  Adm(G, P ), that is there exist compatible 1 
G = (P1s
G  P2s
P s
G and 2  P1s
G such that  = 1  2. By the inductive assumption,
P1s
 P1n
?

?

?
G and 
there exist 
2. By
?

?

?
Lemma 1, 
1 and 
2 are compatible. Indeed, if a variable is defined in both
of them, it occurs in P1 and P2, so, by the lemma, it is defined in both 1 and

2 which are compatible; hence the values of this variable in all 1, 2, 
 
?

?

?
and 

is in P1n
?

?

?
2 coincide, which implies that the last two are compatible. So, 

G such that 1  

1 and 2  
?

?

?
G = P n
G  P1n

G  P2n

 P1n

G  P2n
?

?

?
G  P2s

G = (P1s

G  P2s
G \ P2s

G)  Adm(G, P ), that is, we have two options.

from P s
P s
(a) Let   P1s
(b) Let   P1s
P1s
G. By the inductive assumption, there exists a mapping 
such that   

1. Hence, as required, there exists a mapping 
 
?

?

?
(which is either 
2 for some 
2 does not exist), such that   
?

?

?
itself, if such a 
G  P
 FILTER R, P
s
G. By the definition of semantics of FILTER patterns,   P

G, and  be a mapping
G. By the definition of the semantics of OPT patterns we have that
G and   Adm(G, P ). In this case the rest of the
proof goes the same lines as the case when P is an AND graph pattern.
G and   Adm(G, P ). Hence, in particular,  

1 in P1n
?

?

?
in P n
?

?

?
1, or 

G, R be a built-in condition not using ,
n
s
G.
G such that   
n

.

G, as required.

4. Let P be P
and   P s
Hence, by the inductive assumption, there exists 
Since R does not use , 
Note that Theorem 1 is formulated in terms of subsumption, instead of set-

 |= R. So, 

G compatible with 

  P n

 P2n

  P
?

?

?
.

G = P n
3. Let P be P1 OPT P2, P1s

G as required.
G  P1n

G, P2s

G  P2n

theoretic containment. The rationale behind this formulation is clarified next.
Example 7. Consider the ontology O
by removing all axioms involving Holyhead , and adding the following axiom:

1, which is obtained from O1 in Example 1

PropertyAssertion(bus Canterbury London).

Consider also the following graph pattern P
?

?

?
1:

PropertyAssertion(bus ?U ?X) OPT

(PropertyAssertion(train ?X ?Y ) OPT

PropertyAssertion(ferry ?Y ?Z)).
?

?

?
The following mapping  is returned by the normative semantics:
{?U  Canterbury, ?X  London, ?Y  Oxford}.

As already discussed, Oxford is an inland city and hence cannot have ferry
connections; thus,  is not returned under strict semantics. However, it may be
possible to reach a ferry connection from London (although none is given), and

hence the following answer 

is returned instead of  under strict semantics.

{?U  Canterbury, ?X  London}.
?

?

?
is not returned under normative semantics and hence P



sO

Clearly, 

P

nO

; however, 

   and P
?

?

?
sO

 P
?

?

?
nO

.

5 Computational Properties and Static Optimisation

In this section, we first study the computational properties of our semantics. We
show that the complexity of graph pattern evaluation under strict and normative
semantics coincide, provided that consistency checking is feasible in PSPACE
for the regime at hand. Then we focus on static query analysis, and in particular
on pattern equivalence. We show that the key equivalence-preserving transformation rules that have been proposed for static optimisation of SPARQL queries
continue to hold if we consider equivalence under strict semantics.

5.1 Complexity of Strict Graph Pattern Evaluation

Recall that the graph pattern evaluation is the key reasoning problem in
SPARQL. In the context of entailment regimes, it is defined as given next, where
x is either n or s, depending of the semantics.

Graph pattern evaluation

G under the regime R?

Regime R, legal graph G, legal graph pattern P , and mapping .

Input :
Question: Is   P x
Here, when we say that regime R is a part of the input, we mean that it includes
two oracle functions checking consistency of legal graphs and evaluating legal
BGPs over legal graphs, respectively. In what follows, we refer to the problem
as Normative if x = n, and as Strict if x = s.

It is known that the normative graph pattern evaluation problem is in
PSPACE for the RDF regime [2]. We next argue that membership in PSPACE
holds in general for any regime satisfying the basic properties discussed in Section 2 and for both normative and strict versions of the problem, provided that
the complexity of both oracles of the regime is in PSPACE.

Theorem 2. Normative and strict graph pattern evaluation problems
are in PSPACE, provided the oracles associated to input regimes are in PSPACE.

E.V. Kostylev and B. Cuenca Grau

Proof. We start with the normative semantics. If the regime R allows for inconsistent graphs, then the regime may require to first check the input graph for
consistency, which is feasible in PSPACE by the assumptions of the theorem.
Then, the same recursive procedure Eval(, P, G) for a mapping , graph pattern P and graph G described in [2] for the RDF regime is applicable to evaluate
queries under R. The procedure is in PSPACE because each BGP in the input
pattern can be evaluated by the second oracle in PSPACE by the assumptions.
The situation is analogous for the strict semantics: consistency checking may
be required upfront by the regime and the recursive PSPACE procedure
Eval(, P, G) can be designed by a straightforward implementation of the definition of strict semantics. The only difference with the normative case is that in
each step we need to check for admissibility, which is possible in PSPACE given
our assumptions about the oracles of the regime. For example, if P is a pattern
of the form P1 OPT P2, then Eval first checks whether Eval(, P1 AND P2, G)
) 
holds, or Eval(, P1, G) with not Eval(
vars(P2), holds; and then checks, by means of the oracle function, whether
  Adm(G, P ). If both of the checks are positive, then the answer is true,

otherwise, it is false.
Consequently, the use of our strict semantics does not increase the computational complexity for reasonable regimes. In particular, it follows directly from
Theorem 2 that the evaluation problem is in PSPACE under both semantics for
the tractable entailment regimes associated to the OWL 2 profiles [13].

, P2, G) for any mapping 
?

?

?
, dom(

It is also well-known that graph pattern evaluation under normative semantics is PSPACE-hard for the RDF regime [2]. To formulate a general hardness
result that holds for any regime we would need to require additional properties
for a regime to qualify as reasonable. In order not to unnecessarily complicate
the presentation, we simply point out that PSPACE-hardness holds for all the
regimes mentioned in the specification under both normative and strict semantics [10]. This is immediate for the normative semantics. The hardness for the
strict semantics can be proved by reduction from quantified boolean formula validity as it is done in [2]. This reduction encodes a formula in the query pattern,
and relies on a fixed RDF dataset, which corresponds to a set of first-order facts.
Thus, the extension of such fixed graph with the freezing of a sub-pattern of the
query pattern is always consistent under all the regimes in the specification.

5.2 Static Analysis and Optimisation

Static analysis and optimisation of SPARQL queries has received significant attention in recent years [4,6,14,15,16]. A key ingredient for query optimisation is
the availability of a comprehensive catalog of equivalence-preserving transformation rules for SPARQL patterns. Schmidt et al. [4] and Perez et al. [2] provide
a rich set of such equivalences, which holds under normative semantics for RDF
regime. Some of these equivalences, such as idempotence, commutativity, and
associativity of the AND operator, hold without any restrictions (for our core
fragment of SPARQL) and are quite easy to prove. However, those that involve
OPT are more intricate and hold only for well-designed patterns.
?

?

?
The claim of this section is that these equivalences continue to hold for any
entailment regime, under both normative and strict semantics. For brevity, we
concentrate only on strict semantics and the equivalences with OPT, leaving
the proofs for the rest out of the scope of this paper. But before doing so we
state the following auxiliary lemma, which proof is straightforward application
of conditions (C1)(C2) on regimes and omitted for brevity.
Lemma 2. Let R = (R,G,P,C, ) be an entailment regime. If   Adm(G, P )
for a mapping , graph G  C and legal graph pattern P , then 
  Adm(G, P

)
) 
for any mapping 
triples(P ).

   and legal graph pattern P
?

?

?
such that triples(P
?

?

?
The following theorem establishes that the known equivalences involving OPT
in well-designed patterns hold for any entailment regime under strict semantics.

Theorem 3. Let R be an entailment regime.The following equivalences hold,
provided the graph patterns on both sides are legal and well-designed:

(P1 OPT P2) FILTER R s (P1 FILTER R) OPT P2,
P1 AND (P2 OPT P3) s (P1 AND P2) OPT P3,
(P1 OPT P2) AND P3 s (P1 AND P3) OPT P2,
(P1 OPT P2) OPT P3 s (P1 OPT P3) OPT P2.

(1)

(2)
(3)

(4)

Proof. Equivalence (1). For brevity we give a proof only for the fact that for
every graph each mapping in the semantics of the pattern on the left is in the
semantics of the pattern on the right, and the other direction is similar. Let
  (P1 OPT P2) FILTER Rs
G for a consistent graph G, built-in condition R and
legal graph patterns P1 and P2, such that the both sides of the equivalence are
well-designed. By the definition of strict semantics there are two possibilities.
Case 1:  = 12 for i  Pis
G, such that   Adm(G, P1 OPTP2) and  |= R.
To show that   (P1 FILTER R) OPT P2s
G the only thing we need to prove is
that 1 |= R, and we do it by showing that for every ?X which appears in R the
values of  and 1 on ?X are either the same or both undefined. Indeed, if such
?X is in P2 then, since (P1 OPT P2) FILTER R is well-designed, it appears in P1,
and hence, by Lemma 1, ?X  dom(1), which means that (?X) = 1(?X). On
the other hand, if ?X is not in P2, then ?X / dom(2), that is either the value
of  on ?X coincides with the value of 1 or both of them are undefined.
Case 2:   P1s
G, such that   Adm(G, P1 OPT P2),  |= R, and there is
no 2  P2s
G such that   2. Immediately we have that   (P1 FILTER
R) OPT P2s
G.
Equivalence (2). For brevity, we show the more involved direction that shows
containment from right to left. Let   (P1 ANDP2)OPTP3s
G for a consistent G,
and legal patterns P1, P2 and P3, such that the both sides of the equivalence are
well-designed. We have the following cases by the definition of strict semantics.
Case 1:  = 1  2  3 for i  Pis
G, such that 1  2  Adm(G, P1 AND P2)
and   Adm(G, (P1 AND P2) OPT P3). By Lemma 2 the last inclusion implies

E.V. Kostylev and B. Cuenca Grau

the first. Moreover, it implies that 23  Adm(G, P2 OPTP3), which, together
with the fact that Adm(G, (P1 AND P2) OPT P3) = Adm(G, P1 AND (P2 OPT P3))
guarantees that   P1 AND (P2 OPT P3)s
G as required.
Case 2:  = 1  2 for i  Pis
G, such that   Adm(G, P1 AND P2),  
Adm(G, (P1 AND P2) OPT P3), and there is no 3  P3s
G such that   3. By
Lemma 2 2  Adm(G, P2 OPT P3) holds. Also, since P1 AND(P2 OPTP3) is well-

3; otherwise there would be a
variable ?X  dom(1)  dom(3), but ?X / dom(2), with 1(?X) = 3(?X),

G such that 2  

designed, there is no 

 P3s
?

?

?
which by the fact that the pattern is well-designed would imply that ?X appears
in P2 and by Lemma 1 would lead to a contradiction. Putting the facts above
together with the equality Adm(G, (P1 AND P2) OPT P3) = Adm(G, P1 AND
(P2 OPT P3)) we obtain that   (P1 AND P2) OPT P3s

G as required.

Equivalence (3) follows from (2) and commutativity of AND.
Equivalence (4). We concentrate again on forward direction. Let   (P1 OPT
P2)OPTP3s
G for a consistent graph G, and legal patterns P1, P2 and P3 such that
the both sides of the equivalence are well-designed. We have four possibilities.
We prove the first two, omitting the very similar proofs for other two for brevity.

Case 1:  = 1  2  3 for i  Pis
G, such that 1  2  Adm(G, P1 OPT P2)
and   Adm(G, (P1 OPT P2) OPT P3). By Lemma 2 the last inclusion implies
1  3  Adm(G, P1 OPT P3), which, together with Adm(G, (P1 OPT P2) OPT
P3) = Adm(G, (P1 OPT P3) OPT P2) guarantees   (P1 OPT P3) OPT P2s
G.
Case 2:  = 1  2 for i  Pis
G, where   Adm(G, P1 OPT P2),  
Adm(G, (P1 OPT P2) OPT P3), and there is no 3  P3s
G with   3. By
Lemma 2 we have 1  Adm(G, P1 OPT P3). Similar to Case 2 in the proof
of (2), since (P1 OPT P2) OPT P3 is well-designed, by Lemma 1 there is no
?

?

?
3. But then, since Adm(G, (P1 OPT P2) OPT P3) =

Adm(G, (P1 OPT P3) OPT P2) we have   (P1 OPT P3) OPT P1s

G as required.
Case 3:  = 1  3 for i  Pis
G, such that 1  Adm(G, P1 OPT P2),
  Adm(G, (P1 OPT P2) OPT P3), and there is no 2  P2s
G such that 1  2.
Case 4:   P1s
G,   Adm(G, P1 OPT P2),   Adm(G, (P1 OPT P2) OPT P3),
G such that   3. 
and neither 2  P2s

G such that   2, nor 3  P3s

G such that 1  

 P3s

6 Conclusion

In this paper, we have proposed a novel semantics for optional matching in
SPARQL under entailment regimes where unbound variables in answer mappings
are naturally interpreted as null values. Our strict semantics has been designed
to deal in a faithful way with the lack of regular, complete structures in RDF
graphs and hence with the fundamental incompleteness of information on the
Semantic Web [1]. We believe that both strict and normative semantics are valid,
but one may be more appropriate than the other in certain applications. Both
semantics are compatible at a fundamental level and it would be possible to
exploit them in the same application by letting users commit to one or the other
explicitly when posing queries. Integrating them in a clean way from a syntactic
point of view is more tricky, and it is something we leave for future investigation.
?

?

?
Acknowledgements. This work was supported by the Royal Society, and the
EPSRC projects Score!, Exoda, and MaSI3.
