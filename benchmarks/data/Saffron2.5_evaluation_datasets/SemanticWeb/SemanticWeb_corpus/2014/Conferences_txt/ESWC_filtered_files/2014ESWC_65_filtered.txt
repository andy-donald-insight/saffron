Error-Tolerant RDF Subgraph Matching for

Adaptive Presentation of Linked Data on Mobile

Luca Costabello

Inria, Sophia Antipolis, France

luca.costabello@inria.fr

Abstract. We present PRISSMA, a context-aware presentation layer
for Linked Data. PRISSMA extends the Fresnel vocabulary with the notion of mobile context. Besides, it includes an algorithm that determines
whether the sensed context is compatible with some context declarations.
The algorithm finds optimal error-tolerant subgraph isomorphisms between RDF graphs using the notion of graph edit distance and is sublinear in the number of context declarations in the system.

Keywords: #eswc2014Costabello.

Introduction

Semantic Web mobile applications might not have built-in assumptions about
the schemas of the data they consume, as data models could be unknown a-
priori, and provided by heterogeneous sources: users might consume any type of
data, as long as it is relevant to their context [17]. To improve the effectiveness of
Linked Data consumption, content adaptation must be adopted, i.e. the process
of selecting, generating, or modifying content units in response to a requested
URI1. Essential in the mobile Web, such process is driven by the multifaceted
notion of client context [9]. Content adaptation reduces the fan-out of RDF
entities, and provides coherent information by using context as a dynamic filter.
Furthermore, it orders, groups, and formats triples, thus creating optimized
content units ready for user consumption.

This paper addresses the question of how to enable context-aware adaptation
for Linked Data consumption. We split up the problem in two sub-questions: i)
how to model context for Linked Data presentation and ii) how to deal with context imprecision to select proper presentation metadata at runtime. Modelling
context-aware presentation concepts for Linked Data needs a proper ontology
that fills the gap between traditional context ontologies and the Web of Data
(e.g. support for future extensions, adoption of a lightweight vocabulary instead
of a vast, monolithic context ontology, etc). The selection of presentation metadata is complicated by a series of constraints: first, the intrinsic imprecision of
context data determines the need for an error-tolerant strategy that takes into
account possible discrepancies between context descriptions and actual context.

1 See Adaptation definition: http://www.w3.org/TR/di-gloss/#sec-glossary

V. Presutti et al. (Eds.): ESWC 2014, LNCS 8465, pp. 3651, 2014.
c Springer International Publishing Switzerland 2014
?

?

?
Second, this error-tolerant mechanism must support heterogeneous context dimensions (e.g. location, time, strings). Third, since the procedure must run on
the client-side - to avoid disclosing sensitive context data - we must design a
mobile-friendly algorithm, with acceptable time and space complexity. Finally,
the adopted strategy must support runtime updates of RDF graphs, as context
descriptions might be fetched from remote repositories and added to the selection
process at runtime, and the sensed context may change at any time.

Our contribution is PRISSMA, a context-aware presentation framework for
Linked Data. PRISSMA answers our two-fold research question with the following contributions: i) a vocabulary for describing context conditions, compatible
with Fresnel [19], and ii) an error-tolerant subgraph matching algorithm that
determines whether the sensed context is compatible with context declarations.
In Section 2 we present the state-of-the-art presentation-level frameworks for
the Semantic Web, along with an overview of error-tolerant matching techniques.
Section 3 describes the PRISSMA vocabulary and explains the error-tolerant presentation metadata selection algorithm. The algorithm experimental evaluation
results are described in Section 4.

2 Related Work

As shown in Table 1a, none of the existing presentation frameworks for Linked
Data [1,4,8,11,12,15,20] completely supports context awareness. One of these
works is Fresnel [19], a rendering engine for RDF. Fresnel is built on the assumption that data and its related schema do not carry sufficient information
for representing triples, hence it provides additional presentation-level knowl-
edge. Developers create Fresnel declarations for RDF instances or classes that
will be displayed by their applications using the Fresnel vocabulary, an ontology
built on the separation between data selection and formatting. Data selection
and filtering is implemented by Fresnel Lenses, while Formats define how to
present data.

Castano et al. [3] provide an overview of matching techniques for RDF in-
stances; most of these works stem from ontology matching strategies [10]. Figure 1b compares error-tolerant works closer to our requirements: iSPARQL [16]
is designed for error-tolerant matching, but it neither supports heterogeneous dimensions (such as location), nor is it designed for computationally-constrained
mobile platforms. The Silk framework [24] includes geographical and time distances but such metrics do not consider data imprecision. Furthermore, Silk is
not designed to run on mobile devices. RDF semantics states that two RDF
graphs are semantically equivalent if they entail one another2, and, as underlined by Carrol [2], the important concept for entailment between RDF graphs
is subgraph isomorphism, known to be NP-complete. Subgraph isomorphism is
at the heart of a recent pattern matching engine for SPARQL by Zou et al. [25].
Unfortunately, the authors do not provide an error-tolerant version of their al-
gorithm. It has been proved [6] that finding the optimal error-tolerant subgraph

http://www.w3.org/TR/rdf-concepts/

L. Costabello

Table 1. A comparison of presentation layers for the Semantic Web (a) and of errortolerant matching techniques for RDF (b). Full support is identified by , partial support by , no support by the empty cell.

]

[
k
c
a
t

e
h
t

e
d
i







]

[
?

?

?


]

[
f
d
?

?

?
l
a




]
?

?

?
[
l
e
n
s
e
r





]
?

?

?
[
n
o
n
e





]
?

?

?
[
s
e
t
a
g
o
r
r
u
















]
?

?

?
[
e
n
o
z

k
c
a
t
s
y
a





]
?

?

?
[
r
e
t
s
d
a
o



(a)

Declarative
approach
Domain
Independence
Standard
Languages
Context
Awareness
Automatic
stylesheets
Evaluation
Distribution
Multimodality

]
?

?

?
[
?

?

?
 
 
 






]
?

?

?
[
.
l
a

t
e

u
o



]
?

?

?
[
k
l
i




]
?

?

?
[
?

?

?
i





RDF-specific
Data
Heterogeneity
Client-side
Execution
Incremental
index updates
Selective
matching cache

(b)

]
?

?

?
[
e
k
n
u

d
n
a

r
e
m

s
s
e
?

?

?

 
 
 
 

isomorphism between two graphs can be reduced to the computation of graph edit
distance: the idea is that differences between graphs can be modelled in terms
of operations to apply to graphs, such as adding a node or modifying an arc.
Graph edit distance provides the required flexibility for building an error-tolerant
subgraph matching algorithm, and supports customized and heterogeneous cost
functions (comparing contexts means dealing with data such as location, time,
string literals, URIs). Nevertheless, computational complexity is exponential in
the number of graph nodes, since graph edit distance algorithms assume that
every node can be mapped on every node of another graph. Although context
descriptions are rather small graphs, computing graph edit distance remains a
computationally expensive task, in particular on mobile devices. Traditional approaches to compute graph edit distance between an input graph and a set of
reference graphs apply a pairwise comparison, but such methods do not scale
well and badly perform with runtime updates [13]. Messmer and Bunke [18]
adopt a different strategy: they fragment directed, labelled graphs into smaller
subgraphs, and store them into a single data structure, to avoid duplicates.
Given an input graph, an online search algorithm searches for the error-tolerant
subgraph isomorphisms with the lowest edit costs.

3 Prism Selection Algorithm

We extend the Fresnel presentation-level ontology with context awareness. The
PRISSMA vocabulary3 (Figure 1) broadens the semantics of fresnel:Purpose

http://ns.inria.fr/prissma
?

?

?
fresnel:Group

owl:equivalentClass

fresnel:Purpose

fresnel:purpose

owl:equivalentClass

Prism

fresnel:group

fresnel:Lens

fresnel:group

fresnel:Format

dcn:Device

Device

device

Context

user

User

foaf:Person

owl:equivalentClass

environment

owl:equivalentClass

tl:start
tl:duration

time:Interval

ao:time

Environment

poi

subClassOf

geo:Point

motion

ao:activity

poiLabel

nearbyEntity

radius

poiCategory

geo:lon

geo:lat

owl:Thing

Activity

Fig. 1. The PRISSMA vocabulary

to delegate the selection of Lenses and Formats to a broader and more expressive
definition of mobile context, modelled by the prissma:Context class. PRISSMA
is not meant to provide yet another mobile context model, as that is out of the
scope of our work. Instead, we reuse and combine well-known vocabularies: we
are based on the widely-accepted formalization of context proposed by Dey [9]
and we extend the W3C Model-Based User Interface Incubator Group4 proposal,
that models mobile context as the sum of the User model, the Device features,
and the Environment in which the action is performed (we have described the
PRISSMA vocabulary in further detail in [7]). To wrap up each context-aware
presentation-level unit of information, the concept of Prism is introduced (a
Prism is owl:equivalentClass to a fresnel:Group):

Definition 1 (Prism). A Prism P is an RDF graph that describes the context
conditions under which a given RDF presentation must be activated.

Fig. 2 shows the sample Prism :museumPrism. The Prism styles dbpedia:Museum
instances when requested by art-loving users walking in Paris. Fresnel lenses and
formats (8-27) are coupled to the PRISSMA context description of lines 29-43.
Before rendering an RDF resource with Fresnel, PRISSMA-equipped applications search the available Prisms and select the better match for the context in
which the desired resource is accessed, thus our second research question: how to
select the proper context description at runtime? The most relevant challenge of
this task is the imprecise and incomplete nature of context data, that complicates
the matching procedure between declared and sensed contexts, and requires an
error-tolerant approach. Context data is riddled by the following issues:

Ambiguity. Some RDF Entities and literals used in PRISSMA declarations
might not match with the actual context entities. Nevertheless, in some
cases entities and literals might be similar.

Incompleteness. The authors of PRISSMA context declarations might omit
or forget certain properties, when describing a context. Nevertheless, in

http://www.w3.org/2005/Incubator/model-based-ui/XGR-mbui/

L. Costabello

1 # Styles a Museum when walking in Paris
2 :museumPrism a prissma:Prism ;

a fresnel:Group ;

fresnel:purpose :

walkingInParisArtLover ;

fresnel:stylesheetLink <style.css>.

7 # Fresnel presentation-level triples
8 :museumlens a fresnel:Lens;

fresnel:group :museumPrism;
fresnel:classLensDomain dbpedia:

Museum;

fresnel:showProperties (

dbpprop:location
dbpprop:

publictransit

ex:telephone
ex:openingHours
ex:ticketPrice ) .

18 :addressFormat a fresnel:Format ;

fresnel:group :museumPrism ;
fresnel:propertyFormatDomain

"css-class1"^^fresnel:styleClass

;

fresnel:valueStyle

"css-class2"^^fresnel:styleClass

.

28 # [...]

30 # PRISSMA context description
31 :walkingInParisArtLover a prissma:

Context ;

prissma:user :artLover ;
prissma:environment :parisWalking .

35 :artLover a prissma:User ;

foaf:interest "art".

38 :parisWalking a prissma:Environment ;

prissma:poi :paris ;
prissma:motion "walking" .

42 :paris geo:lat "48.8567" ;

geo:long "2.3508" ;
prissma:radius "5000" .

dbpprop:location ;

fresnel:label "Address" ;
fresnel:labelStyle

Fig. 2. A sample Prism (prefixes are omitted)

certain cases the context graph, although topologically different, should still
be considered as a valid candidate by the selection algorithm.

Sensor Noise. Onboard sensors might provide erroneous information that will
be part of the actual context graph [14]. This is a well-known problem when
determining geographic location (e.g. weak GPS signal, indoor location, etc).
To overcome such issues, we extended and adapted to RDF the Messmer and
Bunke error-tolerant algorithm for finding optimal subgraph isomorphisms for
labelled, directed graphs [18].

3.1 Definitions

Before describing the adapted algorithm, we remind some useful definitions provided in Messmer [18], adjusting them to our scenario:

Definition 2 (RDF Graph). An RDF graph is a set of RDF triples G =

{(s1, p1, o1) . . . (sn, pn, on)} = (V, E) where st is the subject, pt the property and
ot the object of each triple t. V is the set of labelled vertices and contains the
elements st and ot, that are entities or literals. E is the set of directed edges and
contains all the triple properties pt.

Definition 3 (Graph Edit Operation). Given an RDF graph G = (V, E), a
graph edit operation 3(G) is one of the following:
- v  v
, v  V, v

, e  E (substituting an RDF property)
- e  e

- v  , v  V (deleting an RDF instance or literal)
- e  , e  E (deleting an RDF property)

  V (substituting an RDF entity or literal)
?

?

?
-   e (adding an RDF property between existing nodes)
where  is an empty RDF entity, literal, or property.

These five edit operations are sufficient to transform any graph G into a subgraph

of any graph G
. Note that the algorithm searches for subgraph isomorphisms
from a model graph to the input graph, hence there is no need to consider
exterior RDF instances or literals in the input graph, i.e. there is no need for a
  v, v  V operation.
Definition 4 (Edited Graph). Given an RDF graph G and a sequence  =
(31, 32, . . . , 3n) of edit operations, the edited graph (G) = ((V ), (E)) is the
graph (G) = 3n(. . . 31(G)).

Definition 5 (Error-Tolerant RDF Subgraph Isomorphism). Given two

), an error-tolerant RDF subgraph
RDF graphs G = (V, E) and G

isomorphism f from G to G

is a two-tuple f = (, f) where:

= (V

, E





-  is a sequence of graph edit operations that transforms G in (G).
- f is an injective function f : (V )  V
phism5 from (G) to a subgraph S  G

We now introduce the definition of cost of error-tolerant subgraph isomor-

such that  a graph isomor-

.



phism, preceded by the cost of an edit operation:

Definition 6 (Cost of Edit Operation). Given an edit operation 3i, the cost
of 3i is a value C(3i)  [0, 1].
The cost C(3i) of an edit operation 3i varies according to the type of edit operation (e.g. instance substitution, property deletion, etc.) and the nature of the
involved RDF element. We cover in more details C(3i) in Section 3.4.

Definition 7 (Cost of Error-Tolerant RDF Subgraph Isomorphism).
Given an error-tolerant RDF subgraph isomorphism f = (, f), its cost C(f ) is
defined as the normalized cost of the sequence of edit operations  = (31, . . . 3n),
C(f ) = C()

n
i=1 C(i)
?

?

?
.

n =

n

The cost of error-tolerant subgraph isomorphism described in Definition 7
adopts the arithmetic mean to normalize the cost of the sequence of edit opera-
tions. Other strategies might be adopted, such as using a weighted mean or the
maximum cost in the sequence.

It is evident that there might exist multiple sequences  of edit operations

from graph G to graph G
, each with a different cost: we are interested in finding
the optimal error-tolerant subgraph isomorphism, i.e. the error-tolerant subgraph
isomorphism with the least expensive sequence of edit operations. In other words,
we want to find the minimum amount of distortion needed to transform a Prism
into the actual mobile context, thus computing their graph edit distance [21]:

Definition 8 (Optimal Error-Tolerant RDF Subgraph Isomorphism).
Given the set of error-tolerant subgraph isomorphisms F = f1 . . . fn between two
graphs, the optimal error-tolerant subgraph isomorphism fopt is the element of
F with cost C(fopt) = minfiF C(fi).
5 Definition of graph isomorphism provided in [18].

L. Costabello

prissma:User

geo:lat

prissma:radius

geo:lon

"Walking"

prissma:Environment

prissma:Context

"Art"

48.8567

2.3508

{2,0,1,{foaf:interest}}

{6,4,5,{prissma:motion}}

{7,3,6,{prissma:poi}}

{9,7,8,{prissma:environment}}

:walkingInParisArtLover

{10,2,9,{prissma:user}}

Fig. 3. A decomposition of context data of :museumPrism showed in Figure 1

3.2 Decomposition

The context-related triples included in each Prism are split in subgraphs and
saved in a structure called decomposition, a recursive partitioning of a set of
RDF models (Prisms). The decomposition algorithm works on the set of Prisms
pre-loaded by the PRISSMA-equipped mobile application. The idea is building
the decomposition by detecting and merging common subgraphs: in the decom-
position, subgraphs duplicated in different Prisms are collapsed and represented
only once, thus providing a compact representation of possible contexts. As remarked by Messmer and Bunke, there exists more than one decomposition for a
set of graphs: the adopted strategy does not provide an optimal decomposition
(e.g. in the number of elements), but it is computationally inexpensive compared
to other strategies [18].

The elements of a decomposition are tuples that include graph patterns sharing the same topology and whose RDF elements have the same classes. Among
the decomposition elements, some consist in groups of non-decomposable, atomic
graph patterns called context units:

Definition 9 (Context Unit). A context unit is an RDF graph U = (VU , EU )
representing atomic context information. A context unit U consists in either
a single class, or a single RDF entity, or a single literal, or in a graph that
describes an atomic context information.

In the original proposition, Messmer and Bunke deal with graphs with a limited range of discrete values, thus they decompose graphs up to single nodes.
We compare more complex structures, hence the need to preserve context units
(e.g. we cannot split latitude,
longitude, and radius when comparing loca-
tions). Thus, different types of context units have been defined, according to
the type of context information: Class context units consist in core PRISSMA
?

?

?
classes (e.g. prissma:Context, prissma:User, prissma:Environment, and
prissma:Device). Class context units are created by a preliminary step, where
instances of core PRISSMA classes are substituted by their class. This operation decreases the size of the decomposition without losing information, since
the URIs of such core instances are not important for matching purposes. Entity
context units are RDF entities, whose classes are not among PRISSMA core
classes. Entity context units may be blank nodes. Geo context units represent
geographic locations, while Time elements include temporal information. Both
Geo and Time context units may be blank nodes. String and Numeric context
units are associated to string and numeric literals. The decomposition is formally
defined as follows:

Definition 10 (Decomposition). Given a set of Prisms P = {P1, . . . , Pn},


the decomposition D(P ) is a set of 4-tuple (G, G
  G

1. G, G
2. E is a set of RDF properties such that G = G


are RDF graphs, with G


, G

, G


of G


and G

properties.


3. for each Pi there exists a 4-tuple (Pi, G

4. for each 4-tuple (G, G


, G


, G


, G

, E) where:

 E G

, E)  D(P )

, where E is the union

D(P ) with G = G1


5. for each 4-tuple (G, G

1 , E) 


, E) there exists no other 4-tuple (G1, G
1, G
, E)  D(P )

, G


(a) if G


(b) if G


(c) if G


(d) if G

= G1



1, G
is not a context unit, there exists a 4-tuple (G1, G


2, G
is not a context unit, there exists a 4-tuple (G2, G


3, G
is a context unit, there exists no 4-tuple (G3, G


4, G
is a context unit, there exists no 4-tuple (G4, G

= G2

= G3

1 , E)  D(P )
2 , E)  D(P )
3 , E)  D(P )
4 , E)  D(P )


such that G


such that G


such that G


such that G

= G4

Figure 3 shows the decomposition of :walkingInParisArtLover, the Prism
in Figure 2. Uppermost elements are context units: 0 and 4 are String context
units, 1, 5, and 8 are Class context units, and 3 is a Geo context unit.

Each decomposition elements contains the IDs of the ancestors (G
) and
the set of connecting RDF properties E. Element 10 represents the complete
prissma:Context graph.


, G

The recursive function decompose() (Algorithm 1) is executed on each Prism
G in the decomposition D. The function searches in the decomposition for Smax,
the biggest subgraph of G (lines 3-5): the goal is to determine if there exists a
graph pattern in common with the decomposition6. If Smax is isomorphic6 to
G, then G is already represented in D and the algorithm stops (lines 6-7). If
no subgraph is found, and G can be further decomposed (i.e. it is not a context unit), the procedure chooses Smax (line 9) and recursively decomposes it

6 The graph isomorphism and the exact subgraph isomorphism operations are delegated to off-the-shelf algorithms, such as [23] whose description is out of the scope
of this work.

L. Costabello

Alg. 1. decompose(G,D)

Data: a Prism G, the decomposition D
Result: The updated decomposition D

1 Smax = 

2 if G not context unit then

foreach (Gi, G


i, G


i , Ei) do

if Gi is a subgraph of G and Smax smaller than Gi then

Smax = Gi

if Smax is isomorphic to G then
if (Smax = ) then

exit

choose subgraph Smax, priority to PRISSMA properties
decompose(Smax)
decompose(G  Smax)
add (G, Smax, G  Smax, E) to D

(line 10). The choice of Smax is determined by a list of ordered RDF proper-
ties, with a priority for PRISSMA background ontology core properties (e.g.
prissma:user, prissma:environment, prissma:device, etc). This enhances
the chances of merging decomposition elements, thus resulting in a more compact structure. The procedure is invoked recursively on G Smax, the part of G
not yet decomposed (line 11). Finally, (G, Smax, G  Smax, E) is added to D.

3.3 Search Algorithm

Every significant context change7 detected by the device triggers the search for
Prisms that fit the updated context requirements. PRISSMA carries out this
operation with an adapted version of Messmer and Bunke online search algorithm [18]. The algorithm detects optimal error-tolerant subgraph isomorphisms
between the graph of the sensed context and the Prisms stored in the decom-
position. The algorithm first computes edit operations between context units in
the decomposition D and context units of the input graph. Second, it combines
such edit operations to obtain optimal error-tolerant subgraph isomorphisms for
larger patterns, up to complete Prisms (Algorithm 3). To avoid combinatorial
explosion, the concatenation of error-tolerant subgraph isomorphisms includes
only the cheapest error-tolerant graph isomorphisms: this guarantees to find
optimal error-tolerant subgraph isomorphisms.

Algorithm 2 presents the search procedure: first, it finds the error-tolerant
subgraph isomorphisms from each context unit S of the decomposition D to
the input context graph GI and stores them in the list candidates(S) (lines 1-
2). This operation is performed by the context unit matching() function. From
line 3 to 12 such error-tolerant subgraph isomorphisms are concatenated to find
error-tolerant subgraph isomorphisms for larger graphs, up to Prisms:

7 The notion of significant context change is scenario-dependent, and it is not inves-

tigated in this paper.
?

?

?
Alg. 2. search(GI , D)

Data: a Decomposition D, a context graph GI
Result: the result set R containing selectable Prisms

1 foreach S context unit in D do

3 while choose S1 |  f1  candidates(S1) with C(f1) minimal in D and C(f1)  T do

candidates(S) = context unit matching(S, GI )
winners(S1) = winners(S1)  {f1}
candidates(S1) = candidates(S1)  {f1}
if S1 is a Prism then
foreach (S, S1, S2, E)  D || (S, S2, S1, E)  D do

R = R  {S1}
foreach f2  winners(S2) do

f = combine(S1, S2, E, GI , f1, f2)
if f =  then

candidates(S) = candidates(S)  {f}

13 return R

Alg. 3. combine()

Alg. 4. context unit matching(U, GI)

Data: S1, S2, E, GI , f1 =

Data: context unit U, input context graph

(1, f1 ), f2 =
(2, f2 ), 1 =
(V1 , E1 ), 2 = (V2 , E2 )

Result: f

1 if f1 (V1 )  f2 (V2 ) =  then
3 foreach v  (V1  V2 ) do

exit

if v  V1 then
f(v) = f1 (v)
else if v  V2 then
f(v) = f2 (v)

GI = (VI , EI )

Result: the list of error-tolerant subgraph

isomorphisms F

1 F = 
2 foreach context unit UI  GI do

generate an error-tolerant subgraph
isomorphism f between U and UI
F = F  {f}
= (v  	) and

= (


 = 


5 f
, f
f
6 F = F  {f
7 return F



) with 
}

8  = 1 + 2 + E
9 return f = (, f)

in line 3 we select the subgraph S1 whose error-tolerant subgraph isomorphism
f1 has the minimum cost in D. Note that C(f1) must be lower than a threshold T  [0, 1]. The error-tolerant subgraph isomorphism f1 is removed from
candidates(S1) in line 5 and added to the list winners(S1), the container of
error-tolerant subgraph isomorphism chosen to be combined. If S1 is a Prism,
the algorithm has found a result (lines 6-7). Otherwise, we generate error-tolerant
subgraph isomorphisms for each subgraph S having S1 as ancestor (lines 8-12).
Such generation is done with the combine() function that concatenates f1 to each
f2  winners(S2), where S2 is the other ancestor of S. If a combination is feasi-

ble, the resulting error-tolerant subgraph isomorphism is added to candidates(S)
(line 12).

Algorithm 3 details the combine() procedure: first (line 1), the function tests
if f1 and f2 do not contain mappings to the same node in GI (this is necessary
because subgraph isomorphisms are injective functions [18]). If this condition is
satisfied, an error-tolerant subgraph isomorphism is constructed as a concatenation of the edit operations of f1 and f2 and of the edit operations on the edge
between S1 and S2, E (line 8). Mappings are chosen among the mappings of
f1 and f2 (lines 3-7).

L. Costabello

We now discuss in further detail context unit matching(), the function used
by the search algorithm to compute error-tolerant subgraph isomorphisms for
context units (Algorithm 4). Given a context unit U and an input context graph
GI , the procedure finds the edit operations from U to each context unit of GI
(line 2-3) and stores them as error-tolerant subgraph isomorphisms. Moreover,
the deletion of U is considered (line 5).

Worst case computational complexity analysis shows that the complexity of
the search procedure varies from O(Lmnn2) when Prisms in the decomposition
are completely different, to O(mnn2) when Prisms are highly similar (L is the
number of Prisms in the decompositions, m the number of vertices of the input
context graph and n the number of vertices of each Prism included in a decomposition D made of Prisms with same number of nodes). Hence, the search
algorithm is sublinear in the number L of Prisms included in the decomposition
(for a detailed theoretical analysis of the computational complexity of the search
algorithm, see [18]). This is an important property of the algorithm, since the
number of Prisms in the system can be potentially high and unknown a priori.

3.4 Cost of Edit Operations

Each graph edit operation 3 computed by the Prism selection algorithm is associated to a cost C(3)  [0, 1]. Unlike Messmer and Bunke that only consider
topological differences and limit to graphs with discrete node values, in our scenario cost functions are influenced by the presence of heterogeneous context
dimensions.

Topology. The algorithm assigns the highest cost C(3) = 1 to the substitution of Class context units, core PRISSMA vocabulary properties (such
as prissma:environment), and to the deletion of Class, Geo or Time
context units. Hence, whenever an input context graph needs such edit oper-
ations, the cost of the resulting error-tolerant subgraph isomorphism will be
higher than the threshold T . The algorithm assigns lower costs for edit operations on non-core properties, and on Entity context units (e.g. a missing
foaf:interest property in the user dimension may not prevent a Prism
match). Such cost is determined by the Ctopology  [0, 1] parameter. Note

that the presence of additional properties between two context units is not
considered to affect global cost, and is therefore assigned cost 0.

Location. A Geo context unit is a subgraph composed by geo:lat, geo:long
and a prissma:radius (e.g. context unit 3 in Fig. 3). The cost of the substitution of a location context unit depends on the geographic distance. We
first compute the distance d of the two points using the Haversine formula.
If d is within the declared radius, the edit operation has cost C(3) = 0.
Otherwise, PRISSMA features an exponential decay function to smooth the
transition between a perfect match and a mismatch8:

8 More refined geospatial matching techniques are out of the scope of this work, e.g.

http://linkedgeodata.org/
?

?

?
Cgeo(d) =



e

d
geo

if d < dradius

if d > dradius

Time. Temporal context units include a start timestamp tstart and a duration
t (Figure 1). The cost of the substitution of a temporal pattern is computed
to an exponential decay function:
ttstart
time



Ctime(t) =



e

t+tstart +t

time



e

if t < tstart
if tstart < t < tstart + t

if t > tstart + t

Strings. The cost Cstring of substituting a string literal is computed with an
approximate string matching strategy, to overcome problems such as spelling
variants (to date, the Prism selection algorithm focus only on this string similarity problem). The algorithm adopts the Monge-Elkan distance function
(according to Cohen et al. [5] such function outperforms other approaches
when dealing with spelling variants).

Precision-recall analysis9 has been carried out to assess the validity of the
Prism selection algorithm with different cost functions parameters, and with
different similarity thresholds T . Future work will include a thorough campaign
evaluation to assess the algorithm performance on a wider scale, and will involve
PRISSMA-enabled applications users in the loop.

4 Evaluation

The PRISSMA decomposition and selection algorithms have been implemented
as an Android library9. The library is showcased by the PRISSMA Browser9, a
mobile Linked Data browser enhanced with PRISSMA context-aware adaptation
(Figure 5).

The first test analyses the decomposition memory consumption (Figure 4a).
The test measured the decomposition size of groups of Prisms with a variable
number of identical context units. Groups included 20 Prisms, each containing
10 context units. Overall, test Prisms accounted for 340 triples. The percentage
of identical context units in each group of Prisms is progressively increased,
ranging from 10% to 100% (where the latter means that all Prisms in the group
are represented by the same decomposition item).

We assigned an arbitrary size of 30 Bytes to context units (we consider UTF-8
strings with an average length of 30 characters), and 42 Bytes to intermediate
decomposition elements (one integer ID, two integer ancestors IDs, and a list of
connecting edges. Each edge includes a triple of estimated size 90 characters).
The size of PRISSMA decompositions are compared with the retained size of a
group of Jena Model10, each containing a test Prism. As expected, with higher

9 Binaries, code, and evaluation results available at:

http://wimmics.inria.fr/projects/prissma
http://jena.apache.org/documentation/notes/model-factory.html

L. Costabello

(a)

(c)

(b)

(d)

Fig. 4. Memory consumption (a) and Response time (b,c,d) of Prism selection
algorithm

common context units percentages, we have lower decomposition memory foot-
prints. Nevertheless, the memory size of PRISSMA decomposition is in the same
order of magnitude as the Jena models size.

A series of tests have been run to prove the computational complexity analysis of the search algorithm. The algorithm response time has been tested with
the proof-of-concept PRISSMA Browser on a group of Android mobile devices
(Google Nexus 4, Google Nexus 10, Samsung Galaxy Mega, and Samsung Galaxy
Note). All phones were running Android 4.2.2. Figure 4b shows the relationship
between L, the number of Prisms in the decomposition, and response time.
Prisms in each group are all different (thus testing the worst case decomposition
configuration). Prisms contain n = 10 context units and the test context to be
matched is made of m = 10 context units. Five independent runs have been
executed for each group of Prisms, thus computing average response time mea-
surements. Results prove a linear dependency, thus confirming the worst case
complexity analysis of the search algorithm for what concerns the number of
Prisms O(L). Figure 4c shows how the size of the incoming context graph impacts on response time. In this case, each run varied the size m of input context
(ranging from 10 to 50 context units) using a fixed group of L = 5 Prisms each
made of n = 2 context units. Results match computational complexity analy-
sis, thus giving a O(mn) relationship (experimental setup shown in Figure 4c
has n = 2, thus giving a O(m2) relationship). Unlike the number of Prisms,
the growth associated to the size of the incoming context graph suggests that
the size of the latter must be kept as small as possible, to consistently reduce
response time. Finally, in Figure 4d the size n of each Prism has been tested.
Five independent test runs assessed response time using an incoming context
graph of m = 50 context units and a decomposition made of L = 5 Prisms.
?

?

?
(a)

(b)

Fig. 5. Two screenshots of the PRISSMA Browser Android application. Content and
layout in (a) are optimized for tablets, while (b) is optimized for users walking in Paris
(see the Prism in Figure 2).

Results confirm the complexity analysis O(n2). As for the case of incoming context graph, the size of Prisms impacts with a quadratic growth on response
time, thus it is important to avoid defining useless context conditions in Prisms
to lower response time.

5 Conclusions

Extending Fresnel with context awareness favours the sharing and reuse of prisms
across applications, does not introduce new formalisms, and is extensible to
domain-specific context data. Operating on the client side guarantees privacy
preservation, because context data does not have to be disclosed to third-party
adaptation servers. Moreover, the decomposition structure supports incremental updates. Memory consumption tests show that the decomposition structure
reduces memory usage when Prisms contain repeated subgraphs. Response time
test campaign shows the sublinear dependence on the number of Prisms in the
system. The main limitation of PRISSMA is the need for a proper parametrization of the selection algorithm. This is a well-known issue of strategies based on
graph edit distance, that will be addressed in future work with machine learning
techniques. Additional cost functions will be added (e.g. semantic distance between URIs). Response time comparison with cited state-of-the-art solutions is

L. Costabello

envisaged, although experimental conditions vary, making the task tricky. Future
work will also include deal user acceptability evaluation campaigns. Prisms distribution has not been examined yet: PRISSMA might support multiple strategies
for discovery, retrieve, and consume Prisms published as Linked Data.
