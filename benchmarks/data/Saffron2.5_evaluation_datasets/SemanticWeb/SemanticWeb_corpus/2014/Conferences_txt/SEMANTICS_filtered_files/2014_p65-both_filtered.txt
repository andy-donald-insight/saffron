A Service-oriented Search Framework for Full Text,

Geospatial and Semantic Search

Andreas Both

R&D, Unister GmbH
Leipzig (Germany)

andreas.both@unister.de

Axel-Cyrille Ngonga

Ngomo

Universitat Leipzig, IFI/AKSW

Leipzig (Germany)

ngonga@informatik.uni-

leipzig.de

Ricardo Usbeck

Universitat Leipzig, IFI/AKSW

Unister GmbH, Leipzig
usbeck@informatik.

uni-leipzig.de

Denis Lukovnikov

Universitat Leipzig, IFI/AKSW

Leipzig (Germany)

lukovnikov@informatik.uni-

leipzig.de

Christiane Lemke
R&D, Unister GmbH
Leipzig (Germany)

christiane.lemke@unister.de

Maximilian Speicher

TU Chemnitz, VSR

Unister GmbH, Leipzig

speim@hrz.tu-
chemnitz.de

ABSTRACT
Over the last decade, a growing importance of search engines
could be observed. An increasing amount of knowledge is exposed and connected within the Linked Open Data Cloud,
which raises users expectations to be able to search for any
information that is directly or indirectly contained. How-
ever, diverse data types require tailored search functionalitiessuch as semantic, geospatial and full text search.

Hence, using only one data management system will not provide the required functionality at the expected level. In this
paper, we will describe search services that provide specific
search functionality via a generalized interface inspired by
RDF. In addition, we introduce an application layer on top
of these services that enables to query them in a unified way.
This allows for the implementation of a distributed search
that leverages the identification of the optimal search service
for each query and subquery. This is achieved by connecting powerful tools like Openlink Virtuoso, ElasticSearch and
PostGIS within a single framework.

General Terms
Distributed Search, Semantic Web, Information Retrieval

INTRODUCTION

1.
Over the last two decades, the content of the World Wide
Web has grown to an enormous collection of webpages. In
addition, users have shifted their preference from desktop to
Web applications. This is primarily driven by growing technical capabilities of Web browsers as well as the demand
for exploiting the knowledge available on the Web. ParticPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear
this notice and the full citation on the first page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. Request
permissions from Permissions@acm.org.
SEM 14 September 04 - 05 2014, Leipzig, AA, Germany
ACM 978-1-4503-2927-9/14/09 http://dx.doi.org/10.1145/
2660517.2660528

ularly, large Web application providersincluding Google,
Bing and Yahoo!promise that any kind of information will
be made available through simple search queries.

In recent years, a very large number of datasets have been
published based on Semantic Web standards. More than 61
trillion triples1 are available through the Linked Open Data
(LOD) cloud by now. Instead of publishing text documents
containing unstructured information, the new paradigms demand information which are structured by standards like
the Resource Description Framework (RDF)2. RDF can be
used for for publishing logical properties like typeOf relations (e.g., Germany is of the type country), standard type
properties (e.g., the number of people living on a square kilometer within Germany: 229) or complex data types such as
geospatial coordinates (e.g., POINT(13.3833, 52.5167) in
the case of Germany). Since this data is published in a standardized format (i.e., RDF), it can be read and processed
by machines. This provides opportunities for creating novel
industrial applications.

The trend just described leads to a situation in which a
vast amount of unstructured information is available on the
Web next to a large amount of structured data accessible
for automatic processing by machines. While the latter data
representation enables direct access of annotated knowledge
and a derivation of insights, the knowledge of the textual
representations (mostly HTML documents) is not directly
accessible in an easy way. Thus, information retrieval methods are needed in a preprocessing step to compute semantic information which can be annotated within the (HTML)
document.

In the course of the current developments, users will tend
to reject search solutions based on the knowledge originating from one data representation only. On the one hand,
Googles Web search3 demonstrates the advantages of sear-

1http://stats.lod2.eu/, retrieved June 16, 2014.
2http://www.w3.org/TR/rdf11-concepts/
3http://www.google.com


hand, applications like Wolfram Alpha4 and Apples Siri5
present the advantages of knowledge-driven search functio-
nalities.

Thus, a search infrastructure is required, which is capable of
integrating the functionalities of textual search with search
methods working on top of annotated semantics. User demands in the context of e-commerce are particularly driven
by queries for products (i.e., the type of the subject of in-
terest), such as hotel, flight or winter holiday. Addi-
tionally, properties can express the requirements posed on
the subject of interest. Three different types have to be
considered in this case:

 logical properties, e.g., has wifi, suitable for vege-

tarians;

 geospatial properties, e.g., north of London, close to

a beach;

 properties driven by textual information, e.g., pool for
children6 or a part of the name of the searched entity
(like Kempinski).

All three types of queries are well supported by specific instances of data stores:

 searches for logical properties are implemented by triple

stores, e.g., the Openlink Virtuoso Server [6];

 searches for geospatial properties are supported by database management systems with extensions for geographic information system (GIS), e.g., PostGIS [23], an
open source software program that adds support for geographic objects to the PostgreSQL object-relational
database [20];

 searches within text documents are supported by indexbased data stores, e.g., the scalable search solution
ElasticSearch [16] based on Apache Lucene [11].

In this paper, we will present an architectural layer on top of
these well-known search solutions. In particular, we will take
care of preserving their scalability aspects, like the search on
large sets of text documents. A data representation close to
RDF will be used within our architecture. However, there is
no need for using a particular data store for semantic data
(i.e., mostly a triple store) since our approach is agnostic
with respect to the backends used. Our main contribution
is an engineering approach for creating a scalable search solution capable of conducting semantic search with geospatial
aspects as well as information retrieval from text documents.
The benefits of the different search systems are combined
and integrated in order to better deliver on the expectations
of the users.

4http://www.wolframalpha.com/
5https://www.apple.com/de/ios/siri/
6We assume that such properties are not directly modeled
in the underlying structured knowledge base.

The rest of the paper is organized as follows. Section 2
addresses related work while Section 3 describes general requirements for our approach as well as its architecture. Sub-
sequently, we present our approach to search query representation in Section 4 and introduce our approach to interpreting search queries in Section 5. Section 6 describes
our federated search architecture, before giving concluding
remarks in Section 7.

2. RELATED WORK
Our approach is related to the research area of search over
Linked Data and thus to keyword search and question answering (QA) over Linked Data. Several systems have been
developed for the latter task. One of the first systems was
AquaLog [19], an ontology-driven QA system for the Semantic Web. Aqualog uses linguistic analysis to transform
the input query to a set of query-triples. Then, these query
triples are interpreted using lexical resources and the given
ontology. The interpreted query-triples are sent to an inference engine to find the answer. One major drawback of
AquaLog is that it is limited to one ontology at a time.
To address this and other drawbacks of AquaLog, PowerAqua [18] was developed. PowerAqua follows an approach
similar to that of AquaLog, reusing AquaLogs linguistic
analysis. However, PowerAqua performs more advanced
query-triple interpretation using different ontologies simul-
taneously.

Treo [7] is a method for querying Linked Data that relies on spreading activation. First, pivot entities in the
query are identified. Then, from the dependency structure of
the input sentence, Treo constructs a Partially Ordered Dependency Structure (PODS). The PODS is used to resolve
the query in the spreading activation search step where semantic relatedness scores are used to rank candidates and
subsequently spread activation. Pythia [29] is a more recent QA system.
It uses lexica that define mappings between a syntactic and a semantic representation of an ex-
pression. With these lexica, Pythia also introduces a distinction between ontology-dependent and ontology-independent
lexica. Whereas the former depends on the verbalizations
of entities from some ontology, the latter describe ontologyindependent expressions (determiners, question words,...).
The sentence is parsed using such lexica and the resulting semantic representation is translated to a formal query. Building upon Pythias dichotomy between ontology-dependent
and -independent lexical entries, TBSL [28] presents a tem-
plate-based QA approach. This approach consists of 3 steps.
First, SPARQL query templates are generated by using do-
main-specific and generic language resources. The template
slots are filled by using a combination of resource lookup and
natural-language patterns extracted using the BOA framework [9]. The resulting SPARQL queries are finally scored
and the best query (i.e., the highest ranking query that
returns a non-empty result set) is selected and returned.
More recently, several novel systems have participated in the
QALD-3 challenge on QA over Linked Data [3]. CASIA [12]
(the currently best-performing system on the QALD-3 benchmark dataset) relies on a three-step approach resembling
AquaLogs architecture. During the first step, the question
type is determined and text triples are constructed from the
dependency parse tree of the question sentence. In the second step, RDF resources which match phrases from the text


terns from PATTY [21] to map text fragments to properties
and classes. In the final step, a SPARQL query is generated
based on the question type and the RDF resources detected
in the input question. CASIA achieves an F-score of 0.36 on
the QALD-3 benchmark.

Approaches on keyword-based querying of the Web of Data
include SINA [26] and the work of Tran et al. [27]. SINA [26]
aims at answering a keyword question using diverse datasets.
First, simultaneous disambiguation and segmentation is performed using Hidden Markov Models (HMM) and the Hyper-
link-Induced Topic Search (HITS) algorithm. The found resources are used to construct an Incomplete Query Graph
(IQG) consisting of disjoint sub-graphs. To build the federated SPARQL query that retrieves the results, the IQGs
are connected using a Minimum Spanning Tree approach
inspired by Prims algorithm. The work of Tran et al. [27]
tackles the problem of keyword search over RDF data. More
specifically, the work of Tran et al. is concerned with mapping keywords to a list of ranked conjunctive queries, with
a special focus on efficient inference of implied connections.
To accomplish this, a top-k algorithm is proposed that computes the best query interpretations of the keyword query
using bidirectional graph exploration. The interpretations
are then scored and mapped to conjunctive queries. The
performance of the proposed top-k approach is evaluated on
DBLP.

Generic frameworks for searching over RDF data have been
suggested in the past. For example, the OKBQA framework7 presents a modular architecture for search over structured and unstructured sources. This architecture is yet not
fully instantiated and it is thus difficult to compare with our
approach.

Usbeck [30] presents a generic architecture for hybrid search
using a holistic framework comprising information extraction methods for unstructured [31] and semi-structured data
sources.Afterwards, the framework combines the underlying
heterogeneous data stores to answer keyword and natural
language queries via transforming each query into generic
SPARQL queries returning only the highest ranked results.

In contrast to the state of the art, we propose a generic
framework which integrates state of the art approaches for
search over both Linked Data, unstructured data and arbitrary APIs.

In [22] a federated SPARQL search engineFedSearch is
presented, which presents a hybrid combination of SPARQL
and full-text search tackling data heterogeneity and lacking statistical data. Since SPARQL lacks full-text search
support the authors propose a triple-store-independent way
of querying different RDF stores such as OWLIM, Virtuoso and LuceneSail. Their vendor independent approach
of keyword query search pattern is evaluated next to several
optimizations against two benchmarks showing superior performs against other state-of-the-art systems.

Meta-search engines (e.g.,

[17, 10]) are a different approach

7http://www.okbqa.org

for taking advantage of the power of different search services.
However, meta-search engines do not re-use intermediate results to refine parts of the search query, at the most they
improve the representation by re-ranking or clustering the
summarized search results (e.g.,

[2]).

Service-oriented architecture (SOA) [8, 24] can be seen as
an architectural pattern providing the needed tools for organizing the communication between distributed (software)
components [1]. The SOA manifesto8 prioritizes intrinsic interoperability over custom integration, shared services over
specific-purpose implementations and flexibility over opti-
mization. Its main purpose is providing an infrastructure for
connecting loosely coupled components by defining processes
using dynamic component discovery and registration [5].

Thus, the goals of SOAs are close to the ones of Linked Data.
In contrast, SOA is interface-driven not data-driven like
Linked Data. In particular, it is not connected to SPARQL
or RDF. However, the concepts can be combined aiming for
the best of both worlds, e.g., as [34] has shown for the e-
learning domain.

3. HIGH-LEVEL ARCHITECTURE AND

GENERAL REQUIREMENTS

The concept of a service-oriented search framework poses
several specific requirements that have to be met to realize a corresponding architecture. They will be described in
the following. First of all, the framework has to ensure the
integrability of the various intended search functionalities,
which is derived from the properties of (extensible) serviceoriented architectures:

Requirement 1. An interface for search services has to
be defined. The definition has to comprise a summarization of all needed attributes for controlling the execution of
(sub)queries.

We focus on a generalized approach, especially w.r.t. the
communication across the diverse search services. Thus, we
demand:

Requirement 2. The communication with the search ser-

vices has to be stateless and transparent.

Derived from the required stateless and transparent commu-
nication, each search service has to encode all information
about itself via its interface ,i.e., in the message during the
communication9. Hence, the information about each search
service has be retrieved by querying the implemented interface methods. However, to provide a structured search
query, an analysis of the textual user input is needed, which
we consider to be beyond the scope of this paper. We will
assume the search query is already available in a structured
representation (e.g., by having used approaches like [4, 19,
28]).

8http://soa-manifesto.org/
9This requirement is comparable to REStful communication [25] via the stateless HTTP protocol http://tools.
ietf.org/html/rfc7231.


Requirement 3. The search query requires a structured
representation which encapsulates information about all relevant parts of the search query.

Hence, the high-level infrastructure of a federated search
requires a two-step process:

1. search query analyzer

 input: unstructured search query
 output: structured search query

2. search query interpreter

 input: structured search query
 output: ranked search results

A graphical overview of the workflow is shown in Figure 1.
To achieve the intended service-oriented architecture, it is
crucial to hide the implementation details of the contained
search services [5]. As sketched in Figure 1, the structured
search query is the main carrier of information. Hence, no
knowledge about the behavior of a particular search service
may be contained in a structured search query, except in the
case that it was computed by a search service itself. This is
because the structured search query has to be independent
from the particular implementation of any search service
to ensure their exchangeability within the service-oriented
architecture. The following requirement is derived:

Requirement 4. The structured search query representation has to be independent from the implementation of any
particular search service.

In the following, we will describe the data structure required
for the representation of an analyzed search query.

4. SEARCH QUERY REPRESENTATION
Understanding what the user is looking for is the starting
point of every information retrieval process. Yet, in the
following section, the focus is not on the analysis of unstructured search queries. Rather, search query analysis is
considered a black box, i.e., we focus on the representation
of the structured search query after analysis.

For our purpose, we build on a search query representation
that is close to RDF:

Definition 1

(RDF triples). Assume there are pairwise disjoint infinite sets I, B, and L representing IRIs10,
blank nodes, and RDF literals, respectively.
A triple (v1, v2, v3)  (I  B)  I  (I  B  L) is called an
RDF triple. We call v1 the subject, v2 the predicate and v3
the object. We denote the union I  B  L by T called RDF
terms.

However, we need a definition of the target resource. There-
fore, we allow a specific IRI to indicate the target elements,
i.e., our system performs a pure resource search. For the
sake of simplicity, we denote it as follows:

Definition 2

(Searched resource). The place holder for the searched resource is denoted as urn:placeholder.

Obviously, this mechanism can be used for referencing different variables by adding any ID (e.g., urn:placeholder2).

For example, it is possible to express an actual search query,
e.g., family-friendly hotel in Leipzig in the following
way: Potential target hotels (urn:id:hotel) are restricted
to those being located in the city center of Leipzig (expressed
using the relation urn:rel:cityCenter). Furthermore, a
target hotel has to be marked (urn:rel:hasFeature) as
family-friendly (urn:id:familyFriendly) and the description of the hotel has to contain the word family-friendly.
The corresponding search query representation is shown in
Figure 2.

4.1 Search Query Tagging
Given the intention of using different search queries within a
federated search architecture connecting diverse search func-
tionalities, there is a need for separating a given search query
into smaller parts. These parts should be solvable by one
or more search services providing the best match to the required search functionality.

In accordance with Requirement 4, it is not allowed to encode the control of the execution directly within the representation of a (sub-)query. Instead, the triples (i.e., sub-
queries) contained in the structured search query are assigned to every search service for annotation. That is, a subquery is annotated with (a) whether the given service is eligible for interpreting the sub-query, (b) the estimated costs
10Internationalized Resource Identifier, i.e., a URI that may
contain any Unicode character (cf. http://tools.ietf.
org/html/rfc3987).

unstructuredsearch querysearch queryanalyzersearch queryinterpretersearch queryinterpretersearch queryinterpretersstructuredsearch querysearch resultsNESWt1
t2
t3
t4

urn:placeholder
urn:placeholder
urn:placeholder
urn:placeholder2

owl:typeof
urn:rel:citycenter
urn:rel:description
urn:rel:sublabel

urn:id:hotel
urn:id:Leipzig
urn:placeholder2
family-friendly

Figure 2: Example of a structured search query family-friendly hotel in Leipzig according to our RDF-like
representation.

t1
t2
t3
t3
t4

urn:placeholder
urn:placeholder
urn:placeholder
urn:placeholder
urn:placeholder2

owl:typeof
urn:rel:citycenter
urn:rel:description
urn:rel:description
urn:rel:sublabel

urn:id:hotel
urn:id:Leipzig
urn:placeholder2
urn:placeholder2
family-friendly

(urn:service:triplestore,250,500)
(urn:service:gis,100,400)
(urn:service:triplestore,4000,1000)
(urn:service:fulltext,300,200)
(urn:service:fulltext,300,200)

Figure 3: Example of an annotated search query family-friendly hotel in Leipzig.

for processing the sub-query and (c) the estimated number
of results. In particular, it is possible that a triple is tagged
by several search services. The annotation processes for a
given sub-query are started for each search service concur-
rently.

After this step, the triples contained in a structured search
query are annotated. Thus, the structured search query is
now defined as follows:

Definition 3. A set A of pairs (t, a) where t is a triple of
a search query Q and a is the annotation of a search service,
is called structured search query with annotations.

Note: It is possible that not all triples of Q are annotated
within A. However, without loss of generality, it is assumed
that all triples are tagged at least once.

To ensure performant computation of a query plan, an annotation is defined as follows:

Definition 4. A query annotation a is a triple (i, r, e),
where i is the IRI of the service, r is the estimated number
of results and e is the estimated execution time (in millisec-
onds).

This definition satisfies Requirement 3. Imagine a user wants
to pose the following query to our framework:

Example 1. family-friendly hotel in Leipzig

The annotated example query is shown in Figure 3. In this
example, urn:service:fulltext is an IRI of a service providing a full text search, urn:service:triplestore references a triple store and urn:service:gis points to a search
service encapsulating a GIS server.

5. SEARCH QUERY INTERPRETATION
Given a structured and annotated search query, a reasonable query plan for the eligible search services has to be
computed. This can be done by scheduling algorithms with

different optimization strategies. In this paper, we will focus
on the general requirements only.

Requirement 5. All triples of a structured and annotated search query have to be interpreted by at least one
search service.

Note: As mentioned before, it is explicitly possible to have
a triple interpreted by more than one search service.

Hence, a query plan can be computed by creating a topological order [14] of the graph defined by the triples (i.e., the
triple S P O is interpreted as S P O) of the structured
search query where the result node is the root node of the
graph. A straight-forward implementation is shown in Figure 4. There is numerous existing work dedicated to scheduler implementations [13, 15, 32]. A schedule graph is shown
in Figure 5 with respect to our running example.
6. FEDERATED SEARCH ARCHITECTURE
In this section, we present our federated search infrastruc-
ture. Particularly, it contains a service layer to which the
diverse search services can be connected.
6.1 Search Service Interface
For integration into the overall system, all search services
have to implement a specific interface that facilitates ex-
changeability. As a consequence, by implementing this given
interface, services can be loosely coupled to the service layer.
The search service interface is defined as follows:
i n t e r f a c e S e a r c h S e r v i c e {

s e a r c h q u e r y Q

/ a n n o t a t i o n
 i n :
 o u t : a n n o t a t e d s e a r c h q u e r y A
/
A annotateQuery (Q) ;
/ q u e r y e x e c u t i o n
 i n : a n n o t a t e d s e a r c h q u e r y A
 o u t :
/
R executeQuery (A ) ;

s e a r c h r e s u l t s R


i n t e r p r e t e d as d i r e c t e d e d g e S > O w i t h l a b e l P

/ compute t o p o l o g i c a l o r d e r o f
 S P O i s
 S ,O a r e i n t e r p r e t e d as nodes /
A s c h e d u l e S u b Q u e r i e s (A){
L i s t <node> r e s u l t L i s t
Set<node> s t a r t S e t= f indNo de sW ithoutIncEdges (A) // s e t w i t h nodes w i t h o u t
in t orderTag = 0 ;
while ( ! s t a r t S e t . isEmpty ( ) ){

// l i s t w i l l c o n t a i n t h e o r d e r e d r e s u l t s

t h e s t r u c t u r e d s e a r c h q u e r y

incoming e d g e s

n = s t a r t S e t . pop ( ) // removes a node
n . orderTag = orderTag++; // a s s i g n s c h e d u l e o r d e r
L . queue ( n ) // adds t h e node t o t h e end o f
f o r ( node m where ( n ,m)

i n A){

t h e

l i s t L

from A

remove ( n ,m)
i f ( no p e x i s t s with ( p , m) ){ // no o t h e r incoming e d g e s

s t a r t S e t . push (m)

f o r m

i f ( hasEdges (A) )

return e r r o r // graph has a t

l e a s t one c y c l e

return L // a t o p o l o g i c a l l y s o r t e d o r d e r

e l s e

Figure 4: Exemplary scheduler implementation

Figure 5: Scheduled query plan after topological sorting.

urn:placeholderurn:id:hotelowl:typeOfurn:id:leipzigurn:rel:citycenterurn:placeholder2urn:placeholder2urn:rel:descriptionurn:rel:descriptionfamily-friendlyurn:rel:sublabelurn:rel:sublabel0  orderTag12345s e a r c h q u e r y Q

s e a r c h r e s u l t s R

/ q u e r y e x e c u t i o n
 i n :
 o u t :
/
R executeQuery (Q) ;
/ s e a r c h s e r v i c e
 i n :
/
void r e g i s t e r ( IRI ) ;
/ d e r e g i s t e r a s e a r c h s e r v i c e
 i n :
/
void d e r e g i s t e r ( IRI ) ;

r e g i s t r a t i o n

IRI o f

t h e s e a r c h s e r v i c e

IRI o f

t h e s e a r c h s e r v i c e

It is common to call annotateQuery with a complete structured query Q to get a complete annotated query A of all
triples contained in Q. Yet, the executeQuery method of an
implementing search service is usually called passing only
the sub-query the service is eligible for (e.g., passing only
the property in Leipzig to the geospatial search service).
Eligibility of a service is decided by the scheduler.

6.2 Search Provider
The search provider is an interface for integrated search services and defined as follows:
i n t e r f a c e S e a r c h P r o v i d e r {

Hence, the search provider provides a method (executeQuery)
for been accessed from a client while it also works as directory server (similar to a UDDI server [33]). The directory
functionality is achieved by the register and deregister
methods allowing search services to connect and disconnect
from the search provider.

7. CONCLUSIONS
We presented an architecture for a distributed search following the principles of service-oriented architectures. For this,
we introduced a descriptive data representation, i.e., the
data representation does not contain implementation details
of the underlying search services. Our implementation of
such a structured search query is based on RDF. After the
tagging process, the annotated structured search query can
be expressed using our RDF-like representation only.

Our main contribution is the proposed architectures capability of integrating and disintegrating (RDF unaware)
search services dynamically. This property is achieved by
the descriptive message format as well as the generalized service interface, which allows for a stateless and transparent
communication with the integrated search services. Hence,
completely novel use cases are possible, in which search service integration happens on-the-fly to facilitate more dynamic environments. Since the architecture is agnostic to
the functionality of the search services, it is possible to integrate search services having not only (RDF-driven) semantic
search functionalities but also other specialized search capa-
bilities. For example, search services could comprise any
specialized search functionality like ElasticSearch (provid-
ing high-performance federated large-scale full text search),

or Web APIs encapsulating search functions with special semantics like SoundCloud11 or Github12. Our approach is
superior as it does not burden these search services with the
interpretation of the complete RDF (or SPARQL) standard.
Moreover, the architecture is scalable by design in the sense
of the capability of integrating scalable and distributable
search services. Finally, our SearchProvider provides a generalized interface being capable of receiving search queries
via SPARQL (or any other representation, such as SQL or
SeRQL). Therefore, a consolidated view on the dynamically
summarized search services can be provided. This allows for
a transparent integration as a SPARQL endpoint, or using
any other data access standard.

In the future, we will evaluate the capabilities of our architecture of providing rapid access to distributed data resources by comparing an implementation of the architecture
to monolithic approaches. As possible data resources we
consider datasets of the Linked Open Data Cloud as well
as unstructured data provided by the Document Web in
general or private data sets with restricted accessibility (by
account or on the network level). Hence, providing personalized search functionalities seems to be achievable.

Finally, the implementations are yet to be evaluated regarding performance and (re-)ranking issues. In the context of
providing a distributed search, these are the main challenges
considering the users demands w.r.t. usability.

Acknowledgments We thank Didier Cherix and Lars Wesemann for their valuable support. This work has been
partly supported by the ESF and the Free State of Saxony and by grants from the European Unions 7th Framework Programme provided for the project GeoKnow (GA
no. 318159).
