Web Semantics: Science, Services and Agents

on the World Wide Web 5 (2007) 180194

Variable-strength conditional preferences for

ranking objects in ontologies
Thomas Lukasiewicz a,
, J org Schellhase b

a Dipartimento di Informatica e Sistemistica, Sapienza Universit`a di Roma, Via Ariosto 25, I-00185 Roma, Italy

b Fachgebiet Wirtschaftsinformatik, Universit at Kassel, Nora-Platiel-Strae 4, D-34127 Kassel, Germany

Received 22 April 2007; accepted 27 June 2007

Available online 29 June 2007

Abstract

We introduce conditional preference bases as a means for ranking objects in ontologies. Conditional preference bases consist of a description
logic knowledge base and a finite set of conditional preferences, which are statements of the form generally, in the context , property  is
preferred over property  with strength s. They are inspired by variable-strength defaults in conditional knowledge bases. We define the notion
of consistency for conditional preference bases, and we show how consistent conditional preference bases can be used for ranking objects in
ontologies, where every object represents essentially a set of individuals that are sharing the same ranking-relevant properties. More concretely,
we define two object rankings, denoted sum and lex, which evaluate the strengths of conditional preferences in an additive and a lexicographic
way, respectively. Furthermore, we provide algorithms for the main computational tasks for ranking objects under conditional preference bases,
we analyze the complexity of these tasks, and we delineate a tractable special case. To give evidence of the usefulness of this approach in practice,
we describe two applications in the areas of product and literature search, where it allows especially for a flexible user-defined ranking of the query
results reflecting personal preferences.
 2007 Elsevier B.V. All rights reserved.

Keywords: Variable-strength conditional preference; Ranking; Ontology; Description logic; Semantic Web; Literature search; Algorithms and complexity

1. Introduction

In their seminal works [44,43], Poole and Smyth deal with
the problem of matching instances against models of instances,
which are both described at different levels of abstraction and
at different levels of detail, using qualitative probability theory.
Informally, such problems are as follows. Given an instance I
and a model of instances M, compute the qualitative probability
that the instance I is matching the model M (that is, of I given
M). For example, in a geological exploration domain, we may
want to determine whether there might be gold in an area. In

 This paper is a significantly extended and revised version of a paper that
has appeared in: Proceedings of the 3rd European Semantic Web Conference
(ESWC-2006), pp. 288302, Budva, Montenegro, June 2006, LNCS 4011,
Springer, 2006.

Corresponding author. Alternative address: Institut f ur Informationssysteme,


Technische Universit at Wien, Favoritenstrae 9-11, A-1040 Wien, Austria.

E-mail addresses: lukasiewicz@dis.uniroma1.it,

lukasiewicz@kr.tuwien.ac.at (T. Lukasiewicz),
schellhase@wirtschaft.uni-kassel.de (J. Schellhase).

1570-8268/$  see front matter  2007 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2007.06.001

this case, an instance I may be given by the description of an
area, while a model M may be given by a description of areas
where gold can be found, and the qualitative probability that I is
matching M describes the likelihood that gold may be found in I.
In this paper, we continue this line of research. A serious
drawback of the above works [44,43] on matching instances
against models of instances is that they only allow for expressing simple preferences of the form property  is preferred over
property  with strength s in models of instances. In par-
ticular, they do not allow for conditional preferences such as
generally, in the context , property  is preferred over property  with strength s. In this paper, we aim at filling this
gap. We present a formalism for ranking objects in description
logics that allows for expressing such conditional preferences in
models of instances. In a companion paper [36], we present a
generalization of it for matchmaking in description logics [11].
Like Poole and Smyths work [44,43], the ranking formalism
in this paper is also based on qualitative probabilities. Differently from Poole and Smyths work [44,43], however, it requires
a technically more involved way of computing qualitative prob-
abilities, since our language for encoding models of instances is

more expressive. We especially have to suitably handle variablestrength conditional preferences, which are the above statements
of the form generally, in the context , property  is preferred
over property  with strength s (also called variable-strength
conditional desires [51]). They bear close similarity to variablestrength defaults of the form generally, if  then  with strength
s in conditional knowledge bases [24].

In this paper, we define a formal semantics for variablestrength conditional preferences, which is based on conditional
knowledge bases (see Sections 3 and 10). We focus on the problem of ranking objects against a description of objects. Since
we are especially interested in the Semantic Web as the main
application context, we assume that objects and descriptions of
objects are expressed in the description logics SHIF(D) and
SHOIN(D), which stand behind the web ontology languages
OWL Lite and OWL DL, respectively [26]. We assume that
every object is a finite set of ranking-relevant properties of individuals and so essentially a set of individuals sharing the same
ranking-relevant properties.

The Semantic Web [5,17] aims at an extension of the current World Wide Web by standards and technologies that help
machines to understand the information on the Web so that they
can support richer discovery, data integration, navigation, and
automation of tasks. The main ideas behind it are to add a
machine-readable meaning to Web pages, to use ontologies for
a precise definition of shared terms in Web resources, to make
use of knowledge representation and reasoning technology for
automated reasoning from Web resources, and to apply cooperative agent technology for processing the information of the
Web. The Semantic Web consists of several hierarchical layers,
where the Ontology layer, in form of the OWL Web Ontology Language [54,27] (recommended by the W3C), is currently
the highest layer of sufficient maturity. OWL consists of three
increasingly expressive sublanguages, namely OWL Lite, OWL
DL, and OWL Full. OWL Lite and OWL DL are essentially
expressive description logics with an RDF syntax [27]. Ontology
entailment in OWL Lite (resp., OWL DL) reduces to knowledge
base (un)satisfiability in the description logic SHIF(D) (resp.,
SHOIN(D)) [26].

The main contributions of this paper can be summarized as

follows:
 We introduce conditional preference bases, which consist
of a description logic knowledge base in SHIF(D) or
SHOIN(D), and a finite set of (variable-strength) conditional
preferences. They are inspired by variable-strength defaults
in conditional knowledge bases [24]. We define the notion of
consistency for conditional preference bases, and show how
consistent conditional preference bases can be used for ranking objects in ontologies, where every object is roughly a set
of individuals sharing the same ranking-relevant properties.
More concretely, we define two object rankings, denoted sum
and lex, which evaluate the strengths of conditional preferences in an additive and a lexicographic way, respectively.
 We provide algorithms for the main computational tasks
related to conditional preference bases, namely, (i) for deciding whether a conditional preference base is consistent, (ii)

for computing the z-partition of a consistent conditional preference base, and (iii) for computing the rankings sum and
lex on a set of objects relative to a consistent conditional
preference base. Each of these algorithms is based on a reduction to a polynomial number of tests whether a description
logic knowledge base in SHIF(D) (resp., SHOIN(D)) is
satisfiable.
 We analyze the complexity of the main computational tasks
related to conditional preference bases. For conditional preference bases over SHIF(D), all tasks are complete for EXP
(resp., FEXP), and thus have the same complexity as deciding
knowledge base satisfiability in SHIF(D). For conditional
preference bases over SHOIN(D), deciding consistency is
complete for NEXP, and thus has the same complexity as
deciding knowledge base satisfiability in SHOIN(D), while
all the other tasks are in FPNEXP, and thus can be done in the
same time as the main reasoning tasks in description logic
programs over SHOIN(D) [16].
 Taking inspiration from the recent description logic DL-Lite,
which allows for polynomial-time description logic reasoning
[9], we describe a special case of conditional preference bases
(with concepts in DL-Lite) where the main computational
tasks can all be done in polynomial time.
 We describe two applications of this approach in product
and literature search. In the former, it allows for a flexible user-defined ranking of the query results, which reflects
personal preferences. In the latter, it allows for both expressing sophisticated search strategies and a flexible user-defined
ranking of the query results, which reflects personal preferences and quality measures. More generally, query languages
of current search engines are very restricted in their expressive power. There are scientific search engines on the web,
however, that have valuable metadata about publications,
authors, organizations, and scientific events. We show that
conditional preference bases allow for a more powerful query
language, which can exploit this metadata better than the
current approaches do.

The rest of this paper is organized as follows. In Section 2,
we review the description logics SHIF(D) and SHOIN(D). In
Section 3, we review conditional knowledge bases. Section 4
introduces conditional preference bases and the notions of consistency and z-entailment for conditional preference bases. In
Section 5, we present the two object rankings sum and lex relative to a consistent conditional preference base. In Sections 68,
we provide algorithms for the main computational tasks related
to conditional preference bases, we analyze the complexity of
these tasks, and we delineate tractable special cases. Section 9
describes a sample application in literature search, and Section
10 discusses related work. In Section 11, we summarize the main
results and give an outlook on future research. Note that detailed
proofs of all results in this paper are given in [37].
2. The description logics SHIF(D) and SHOIN(D)

In this section, we review the description logics SHIF(D)
and SHOIN(D), which stand behind the web ontology lan-

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

guages OWL Lite and OWL DL, respectively. See especially
[26] for further details and background. Intuitively, description
logics model a domain of interest in terms of concepts and
roles, which represent classes of individuals and binary relations between classes of individuals, respectively. A description
logic knowledge base encodes in particular subset relationships
between classes of individuals, the membership of individuals
to classes, and the membership of pairs of individuals to binary
relations between classes.

2.1. Syntax


A the set of inverses R

A role is any element of RA  R

We first describe the syntax of SHOIN(D). We assume a set
of elementary datatypes and a set of data values. A datatype is
an elementary datatype or a set of data values (called datatype
oneOf). A datatype theory D = (	D, D) consists of a datatype
domain 	D and a mapping  D that assigns to each elementary
datatype a subset of 	D and to each data value an element of
1 , . . .}. Let
	D. We extend  D to all datatypes by {v1, . . .}D = {vD
A, RA, RD, and I be pairwise disjoint finite nonempty sets of
atomic concepts, abstract roles, datatype roles, and individuals,
respectively. We denote by R
of all
R RA.
 RD. Concepts are inductively defined as follows. Every   A is a concept, and if
o1, . . . , on  I, then {o1, . . . , on} is a concept (called oneOf).

If , 1, and 2 are concepts and if R RA  R
A, then also
, (1  2), and (1  2) are concepts (called negation,
conjunction, and disjunction, respectively), as well as R.,
R.,  nR, and  nR (called exists, value, atleast, and atmost
restriction, respectively) for an integer n  0. If D is a datatype
and U  RD, then U.D, U.D,  nU, and  nU are concepts
(called datatype exists, value, atleast, and atmost restriction,
respectively) for an integer n  0. We use  (resp., ) to
abbreviate    (resp.,   ), and eliminate parentheses as
usual.
An axiom has one of the following forms: (1)    (called
concept inclusion axiom), where  and  are concepts; (2) R 

S (called role inclusion axiom), where either R, S  RA  R
or R, S  RD; (3) Trans(R) (called transitivity axiom), where

R RA; (4) (a) (called concept membership axiom), where 
is a concept and a I; (5) R(a, b) (resp., U(a, v)) (called role
membership axiom), where R RA (resp., U  RD) and a, b I
(resp., a I and v is a data value); and (6) a = b (resp., a = b)
(equality (resp., inequality) axiom), where a, b I. A (descrip-
tion logic) knowledge base KB is a finite set of axioms. For
decidability, number restrictions in KB are restricted to simple
abstract roles (see [28] for details).
is as the above syntax of
SHOIN(D), but without the oneOf constructor and with the
atleast and atmost constructors limited to 0 and 1.

The syntax of SHIF(D)

Example 2.1.
(Products) An online store (such as ama-
zon.com) may use a description logic knowledge base to classify
and characterize its products. For example, assume the following
relationships between products: (1) textbooks are books, (2) personal computers and laptops are mutually exclusive electronic

products, (3) books and electronic products are mutually exclusive products, (4) objects on sale are products, (5) every product
has at least one related product, (6) only products are related
to each other, (7) tb ai and tb lp are textbooks, (8) which are
related to each other, (9) pc ibm and pc hp are personal com-
puters, (10) which are related to each other, and (11) ibm and hp
are providers for pc ibm resp. pc hp. These relationships are
expressed by the following description logic knowledge base
KB:
(1) Textbook  Book;
(2) PC  Laptop  Electronics; PC  Laptop;
(3) Book  Electronics  Product; Book  Electronics;
(4) Sale  Product;
(5) Product  1 related;
(6)  1 related   1 related
(7) Textbook(tb ai); Textbook(tb lp);
(8) related(tb ai, tb lp);
(9) PC(pc ibm); PC(pc hp);
(10) related(pc ibm, pc hp);
(11) provides(ibm, pc ibm); provides(hp, pc hp).

  Product;

2.2. Semantics

, I

, to each abstract role R RA a subset of 	

An interpretation I = (	

) with respect to a datatype
theory D = (	D, D) consists of a nonempty (abstract) domain
disjoint from 	D, and a mapping  I

that assigns to each

, to each individual o I an
atomic concept   A a subset of 	

I  	

element of 	
and to each datatype role U  RD a subset of 	
I  	D. We
extend  I
to all concepts and roles as usual (where #S denotes
the cardinality of a set S):
}; ()
 {o1, . . . , on}I = {o

1, . . . , o
 (1  2)

2; (1  2)
I = 

I|y : (x, y) R
I = {x 	
 (R.)

 (R.)
I|y : (x, y) R
I = {x 	
I = {x 	
I|#({y|(x, y) R
 ( nR)
 ( nR)
I = {x 	
I|#({y|(x, y) R
 (U.D)
I|y : (x, y) U
I = {x 	
 (U.D)
I|y : (x, y) U
I = {x 	
 ( nU)
I = {x 	
I|#({y|(x, y) U
I = {x 	
I|#({y|(x, y) U
 ( nU)

I \ 
I = 	

I = 

2;
I  y  
I};
I  y  
I};
I})  n};
I})  n};
I  y  DD};
I  y  DD};
I})  n};
I})  n}.

, b

The satisfaction of an axiom F in an interpretation I =
), denoted I  F , is defined as follows: (1) I    
(	, I

; (2) I  R  S iff R
I  S
; (3) I  Trans(R) iff

iff 

; (5) I  R(a, b) iff
is transitive; (4) I  (a) iff a

) R
; (7) I  a = b
, vD) U
; (6) I  U(a, v) iff (a

(a
I = b
; and (8) I  a = b iff a
I = b

iff a
. The interpretation
I satisfies the axiom F, or I is a model of F, iff I  F . We say
that I satisfies a knowledge base KB, or I is a model of KB,
denoted I  KB, iff I  F for all F  KB. We say that KB is
satisfiable (resp., unsatisfiable) iff KB has a (resp., no) model.
An axiom F is a logical consequence of KB, denoted KB  F ,
iff each model of KB satisfies F.

(Products contd) The description logic
knowledge base KB given in Example 3.1 is satisfiable,
and some logical consequences of KB are Textbook 
Electronics, PC  Electronics, Electronics(tb lp), and
Electronics(pc ibm).

3. Conditional knowledge bases

In this section, we review conditional knowledge bases and
the notion of -consistency for conditional knowledge bases
[1,22]. Informally, a conditional knowledge base consists of a
set of strict statements in classical logic of the form   ,
which informally read as if  then  and a set of defeasible
rules (or defaults) of the form   , which informally read
as generally, if  then . The latter rules may have exceptions,
which can be handled in different ways (see Section 10.1). Note
that for ease of presentation, we here do not consider variablestrength defaults (which are of the form  s  to express
that generally, if  then  with strength s), but all the concepts
and results revisited below are easily extended to conditional
knowledge bases with variable-strength defaults [24].

3.1. Syntax

We first formally define the syntax of conditional knowledge
bases. We assume a set of basic events 	 = {p1, . . . , pl} with
l  1. We use  and  to denote false and true, respectively.
We define events by induction as follows. Every element of 	 
{,} is an event. If  and  are events, then also  and
(  ). We use (  ) and (  ) to abbreviate the events
(  ) and (  ), respectively, and we adopt the
usual conventions to eliminate parentheses. A logical constraint
is an event of the form   . A conditional rule (or default)
is an expression of the form   , where  and  are events.
A conditional knowledge base KB = (L, D) consists of a finite
set of logical constraints L and a finite set of defaults D. The
following example illustrates conditional knowledge bases.

Example 3.1.
(Penguins) The strict logical knowledge all
penguins are birds and the default logical knowledge gener-
ally, birds fly, generally, penguins do not fly, and generally,
birds have wings is encoded by the conditional knowledge base KB = ({bird  penguin},{fly  bird,fly 
penguin, wings  bird}).

3.2. Semantics

We next define the semantics of conditional knowledge bases
in terms of admissible world rankings. A world I associates with
every basic event in 	 a binary truth value. We extend I by induction to all events as usual. We denote by I	 the set of all worlds
for 	. A world I satisfies an event , or I is a model of , denoted
I  , iff I() = true. A world I satisfies a default   , or
I is a model of   , denoted I    , iff I    .
We say that I verifies    iff I    . We say that I falsifies    iff I     (that is, I |=   ). We say that
I satisfies a set of events and defaults K, or I is a model of K,

z(I) =


1 + max
d  D:I|=d

z(d)

if I |= L
if I  L  D
otherwise.

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

denoted I  K, iff I satisfies every member of K. We say K
is satisfiable iff a model of K exists. A set of defaults D tolerates a default d under a set of logical constraints L, or d is
tolerated under L by D, iff D  L has a model that verifies d. A
set of defaults D is under L in conflict with a default   
iff all models of D  L  {} satisfy . A world ranking
 is a mapping  : I	  {0, 1, . . .}  {} such that (I) = 0
for at least one world I. It is extended to all events  as fol-
lows. If  is satisfiable, then () = min{(I)| I I	, I  };
otherwise, () = . A world ranking  is admissible with a
conditional knowledge base KB = (L, D) iff () =  for all
  L, and () <  and (  ) < (  ) for all defaults
    D.

3.3. -Consistency

The notion of -consistency for conditional knowledge bases
[1,22] is defined as follows. A conditional knowledge base KB is
-consistent (resp., -inconsistent) iff a (resp., no) world ranking
exists that is admissible with KB.
The existence of a world ranking that is admissible with KB =
(L, D) is equivalent to (a) the existence of a default ranking on D
that is admissible with KB, if D = , and to (b) the satisfiability
of D, otherwise. Here, a default ranking  on a set of defaults D
maps each default d  D to a nonnegative integer. We say that 
is admissible with a conditional knowledge base KB = (L, D)
  D that is under L in conflict with some d  D
iff each D
contains a default d

such that (d

) < (d).

Another characterization of the notion of -consistency for
conditional knowledge bases is given as follows. A conditional
knowledge base KB = (L, D) with D =  is -consistent iff
either (a) every Di, 0  i  k, is the set of all d 
there exists an ordered partition (D0, . . . , Dk) of D such that
j=iDj tol-
j=iDj, or (b) for every i, 0  i  k, each
erated under L by
d  Di is tolerated under L by
j=iDj. The unique partition
(D0, . . . , Dk) of D in (a) is called the z-partition of KB.

Example 3.2.
(Penguins contd) The conditional knowledge base KB = (L, D) of Example 3.1 is -consistent. Its
z-partition (P0, P1), which satisfies both (a) and (b) above, is
given by (P0, P1) = ({wings  bird, fly  bird},{fly 
penguin}).

The z-partition (D0, . . . , Dk) of an -consistent conditional
knowledge base KB = (L, D) gives rise to a natural notion of
entailment from KB, called entailment in System Z (due to Pearl
[41,24]), which is based on the following default ranking z
and world ranking z. For every j {0, . . . , k}, each d  Dj is
assigned the value j under z. The world ranking z on all worlds
I I	 is then defined by:

Note that z is a default ranking on KB that is admissible with
KB, and z is a world ranking that is admissible with KB. The

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

notion of entailment in System Z is then defined as follows.
A default    is entailed in System Z by an -consistent
conditional knowledge base KB iff either z() =  or z( 
) < z(  ).
Example 3.3.
(Penguins contd) The conditional knowledge
base KB = (L, D) of Example 3.1 entails in System Z the
defaults fly  bird and fly  penguin.

4. Conditional preference bases

In this section, we first define the syntax of conditional prefer-
ences, which are intuitively statements of the form generally, if
 holds, then  is preferred over  with strength s (which are
inspired by variable-strength defaults in conditional knowledge
bases [24]). We then define their semantics in terms of object
rankings (which is based on conditional knowledge bases; see
Sections 3 and 10), and we introduce the notion of consistency
for conditional preference bases.

4.1. Syntax

We assume a finite set C of concepts in SHIF(D) or
SHOIN(D) such that C. The elements of C are called classification concepts. Note that they are fully general concepts and
not necessarily atomic concepts. Intuitively, they are the relevant
description logic concepts for defining preference relationships.
A conditional preference is of the form (|)[s], where  and 
are concepts from C (called its head and its body, respectively),
and s is an integer from {1, . . . , 100} (called its strength). Infor-
mally, (|)[s] expresses that (i) generally, among the objects
satisfying , the ones satisfying  are preferred over those satis-
fying, and (ii) this preference relationship holds with strength
s. We often write ()[s] to abbreviate (|)[s].
Definition 4.1. A conditional preference base is a triple
PB = (T, A, P), where T is a knowledge base in SHIF(D) or
SHOIN(D), A is a finite set of concepts from C, and P is a finite
set of conditional preferences.

Intuitively, conditional preference bases PB = (T, A, P)
encode rankings on a set of individuals o. Here, intuitively,
T represents background knowledge, and A represents assertional knowledge about each o (that is, A represents the set of all
(o) such that  A), while P represents conditional preferences
about each o (that is, P represents the set of all ((o)|(o))[s]
such that (|)[s] P). Observe also that the statements in T and
A are strict (that is, they must always hold), while the ones in P
are defeasible (that is, they may have exceptions and thus do not
always hold), since P may not always be satisfiable as a whole.

Example 4.2.
(Products contd) The assertional knowledge
either a PC or a laptop and the preference relationships gener-
ally, PCs are preferred over laptops with strength 20, generally,
laptops on sale are preferred over PCs on sale with strength 70,
and generally, inexpensive products are preferred over expensive ones with strength 90 can be encoded by the conditional
preference base PB = (T, A, P), where T is the description logic
knowledge base KB of Example 2.1, A = {PC  Laptop}, and

P = {(PC)[20], (Laptop|Sale)[70], (Inexpensive)[90]}. Note
that, consequently, the set C of classification concepts contains
in particular the description logic concepts PC  Laptop, PC,
Laptop, Sale, and Inexpensive.

4.2. Semantics

We now define some basic semantic concepts, including
objects (which are subsets of C) and object rankings (which
are certain functions that map every object to a rank from
{0, 1, . . .}  {}), and we then associate with every conditional
preference base a set of admissible object rankings as a formal
semantics.
Formally, an object o is a set of concepts from C such that
{(i)|  o}  {(i)| C \ o} is satisfiable, where i is a new
individual. Informally, every object o represents all individuals
i that are fully specified on C in the sense that i belongs (resp.,
does not belong) to every concept   o (resp.,  C \ o). That
is, objects are essentially classifying individuals relative to the
ranking-relevant properties specified in C. We denote by OC the
set of all objects relative to C. An object o satisfies a description
logic knowledge base T, denoted o  T , iff T  {(i)|  o} 
{(i)| C \ o} is satisfiable, where i is a new individual. An
object o satisfies a concept  C, denoted o  , iff   o. An
object o satisfies a set of concepts A  C, denoted o  A, iff o
satisfies all   A. A concept  C is satisfiable iff there exists
an object oOC that satisfies . The satisfaction of concepts by
objects and the satisfiability of concepts are naturally extended to
Boolean combinations of concepts from C. An object o satisfies
a conditional preference (|)[s], denoted o (|)[s], iff o 
  . We say that o satisfies a set of conditional preferences
P, denoted o  P, iff o satisfies all p P. We say that o verifies
(|)[s] iff o    . We say that o falsifies (|)[s], denoted
o |= (|)[s], iff o    . A set of conditional preferences
P tolerates a conditional preference p under a description logic
knowledge base T and a set of classification concepts A  C, or
p is tolerated under T and A by P, iff there exists an object o that
satisfies T  A  P (that is, the object o satisfies T, A, and P)
and verifies p. We say that P is under T and A in conflict with p
iff P does not tolerate p under T and A.
An object ranking  is a mapping  : OC  {0, 1, . . .}  {}
such that (o) = 0 for at least one object oOC. It is extended
to all Boolean combinations  of concepts from C as follows.
If  is satisfiable, then () = min{(o)| oOC, o  }; other-
wise, () = . We say that  is admissible with a description
logic knowledge base T (resp., a set of concepts A) iff (o) = 
for all oOC such that o |= T (resp., o |= A). We say that 
is admissible with a conditional preference (|)[s] iff either
() =  or (  ) < (  ). We say that  is admissible with PB = (T, A, P) iff  is admissible with T, A, and all
p P.

4.3. Consistency

We now define the consistency of conditional preference
bases, which properly generalizes the -consistency of conditional knowledge bases (see Section 3.3).

Definition 4.3. A conditional preference base PB is consistent
(resp., inconsistent) iff an (resp., no) object ranking  exists that
is admissible with PB.

Observe that a conditional preference base PB = (T, A, P)
with P =  is consistent iff T  {(i)| A} is satisfiable. We
now summarize some results that carry over from -consistency
in conditional knowledge bases.
The following result shows that the existence of an object
ranking that is admissible with PB = (T, A, P), where P = ,
is equivalent to the existence of a preference ranking on P that is
admissible with PB. Here, a preference ranking  on P maps each
p P to a nonnegative integer. We say that a preference ranking
 on P is admissible with PB = (T, A, P) iff every P
  P that
is under T and A in conflict with some p P contains some p

such that (p
Theorem 4.4. A conditional preference base PB = (T, A, P)
with P =  is consistent iff there exists a preference ranking 
on P that is admissible with PB.

) < (p).

The next result shows that the consistency of PB = (T, A, P)
is equivalent to the existence of an ordered partition of P with
j=iPj iff there exists an object o that satisfies T  A  

certain properties. Here, recall that p is tolerated under T and A by
j=iPj
and verifies p (see Section 4.2).
Theorem 4.5. A conditional preference base PB = (T, A, P)
with P =  is consistent iff there exists an ordered partition
(P0, . . . , Pk) of P such that either (a) every Pi, 0  i  k, is the
set of all p
j=iPj, or (b)
for every i, 0  i  k, each p Pi is tolerated under T and A by

j=iPj.
We call the unique partition (P0, . . . , Pk) of P in (a) the
z-partition of PB. Note that the notion of a z-partition for conditional preference bases properly generalizes the notion of a
z-partition for conditional knowledge bases (see Section 3.3).

j=iPj tolerated under T and A by

Example 4.6.
(Products contd) It is not difficult to verify that the conditional preference base PB of Example 4.2
is consistent, and that its z-partition is given by (P0, P1) =
({(PC)[20], (Inexpensive)[90]},{(Laptop|Sale)[70]}).
The z-partition (P0, . . . , Pk) of PB = (T, A, P) gives rise to
a natural notion of entailment from PB, called z-entailment,
which properly generalizes the notion of entailment in System
Z for conditional knowledge bases (see Section 3.3). The notion
of z-entailment is based on the following preference ranking z
and object ranking z. For every j {0, . . . , k}, each p Pj is
assigned the value j under z. The object ranking z on all objects
oOC is then defined as follows:

z(o) =


1 + max
p P:o|=p

if o |= T  A
if o  T  A  P

z(p) otherwise.

Note that z is a preference ranking on PB that is admissible with
PB, and z is an object ranking that is admissible with PB. We
define the notion of z-entailment as follows. A conditional pref-

erence p = (|)[s] is a z-consequence of PB, denoted PB| p,
iff either z() =  or z(  ) < z(  ).

Since the notion of z-entailment generalizes the notion of
entailment in System Z, it has similar semantic properties. In
particular, it realizes some inheritance of conditional preferences
along subclass relationships, where conditional preferences of
more specific classes override the ones of less specific classes.

Example 4.7.
(Products contd) Let the conditional preference
base PB be defined as in Example 4.2. Then, it is not difficult
to verify that (PC)[20], (Laptop|Sale)[70], (Inexpensive)[90],
and (Inexpensive|Made By IBM)[90] are z-consequences of
PB.

5. Ranking objects under conditional preference bases

In this section, we define the two object rankings sum and
lex, which reflect the conditional preferences of a consistent
conditional preference base PB = (T, A, P). Informally, every
object o that does not satisfy T  A is associated with the rank
, while every object o that satisfies T  A is associated with
a nonnegative integer as a rank, which depends on how well o
satisfies the conditional preferences in P, where the rank is low
(resp., high) for more (resp., less) desired o relative to P.

The main idea behind the first object ranking can be described
as follows: sum interprets the strengths of the conditional preferences in P as costs (e.g., monetary costs). Intuitively, if an
object o falsifies a conditional preference from P of strength s,
then this produces the cost s, and the overall rank of the object
o is then given by the sum of all these costs. That is, the rank
of every object is given by the sum of the strengths of all falsified conditional preferences in P. For example, when looking
for an apartment, we may rank a given collection of apartments
according to whether they satisfy our conditional preferences,
where every falsified conditional preference produces a degree
of dissatisfaction, and the rank of an apartment is given by the
sum of all such degrees of dissatisfaction.

The second object ranking is based on a different interpretation of the strengths: lex interprets the strengths of the
conditional preferences in P as priorities and not as costs. That
is, falsifying a conditional preference from P of strength s is
always worse than falsifying any set of conditional preferences
from P of strength at most s  1. Thus, falsifying a collection
of conditional preferences from P of low strengths can never be
worse than falsifying even a single conditional preference from
P of high strength. For example, when ranking a set of apartments O relative to a set of conditional preferences P, to obtain
the apartments in O of lowest rank, we first select those in O
that satisfy a maximal set of conditional preferences of highest
strength s, among which we then select the ones that satisfy a
maximal set conditional preferences of strength s  1, and so
on.
If P contains only conditional preferences of the form
(|)[s], then computing the above two object rankings is quite
easy, since sum can be computed by summing up the strengths of
all falsified conditional preferences in P, while lex can be computed by a lexicographic order relative to the strengths. However,

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

if P contains fully general conditional preferences of the form
(|)[s], then computing the above two object rankings is technically much more involved. The main technical difficulty is
roughly that we want any conditional preference in P of the
form (|)[s] to apply on all objects that satisfy  and also on
all objects that satisfy some more specific 
as long as this is
compatible with P (that is, as long as P contains no conditional
] that is incompatible with (|)[s]). That
preference (
is, from another perspective, the set of conditional preferences
P implicitly encodes some exceptions for the bodies of its conditional preferences, which we have to make explicit in order to
correctly compute the above two object rankings. To this end,
we rewrite P from a set of defeasible statements to a set of strict
statements P , which is done by adding exceptions to the bodies
of the conditional preferences in P.

)[s

(Products contd) Consider again PB =
Example 5.1.
(T, A, P) of Example 4.2. Ignoring the strengths, P encodes
that (i) PCs are preferred over laptops (with strength 20),
as long as they are not on sale, because in that case, laptops
are preferred over PCs (with strength 70) and (ii) inexpensive products are preferred over expensive ones (with
strength 90). Hence, for technical reasons, laptops on sale
always falsify the conditional preference p = (PC) [20]. How-
ever, this is not desired. Thus, when computing the rank of
laptops on sale, we have to avoid such falsifications. We
do this by rewriting p and thus PB. The rewritten conditional preference base PB = (T, A, P ) is given by P  =
{(PC|Sale)[20], (Laptop|Sale)[70], (Inexpensive)[90]}. It is
obtained from PB by adding the exception Sale to the body of
the conditional preference (PC)[20].

To make explicit the above exceptions in the bodies of conditional preferences in P, we use a sophisticated and well-explored
machinery from conditional knowledge bases, which is formally described as follows. A conditional preference base PB =
(T, A, P) is flat iff its z-partition is given by (P) and thus consists only of one component. Given a conditional preference base
PB = (T, A, P), a non-defeasible equivalent PB = (T, A, P )
to PB satisfies the properties that (i) PB is flat, (ii) PB| p
for all p P , and (iii) P  = {(|  p)[s]|p = (|)[s] P},
where p is a conjunction of negated bodies that occur in P.
Informally, (iii) says that the rewriting from P to P  adds exceptions to the bodies of conditional preferences in P, (ii) says that
the rewriting does not change the semantic meaning of the set of
conditional preferences P, and (i) says that P  encodes no further
hidden exceptions. In Section 6, we present Algorithm flatten,
which transforms a consistent conditional preference base PB
into a non-defeasible equivalent PB.

We are now ready to define the object rankings sum and lex.
Informally, the object ranking sum associates with every object
the sum of the strengths of all conditional preferences in P  that
are falsified by o. Roughly, objects with smaller values under
sum are those that satisfy more conditional preferences with
larger strengths.
Definition 5.2. Let PB = (T, A, P) be a consistent conditional
preference base, and let PB = (T, A, P ) be its non-defeasible

equivalent (computed by flatten). Then, the object ranking sum
is defined as follows for all objects oOC:

sum(o) =

p=(|)[s] P :o|=p

if o |= T  A
otherwise.

(1)

The object ranking lex, in contrast, is based on a lexicographic order. Roughly, objects with smaller ranks are those that
satisfy more conditional preferences with larger strengths, where
satisfying one conditional preference of strength s is strictly preferred to satisfying any set of conditional preferences of strength
at most s  1.
Definition 5.3. Let PB = (T, A, P) be a consistent conditional
preference base, and let PB = (T, A, P ) be its non-defeasible
equivalent (computed by flatten). Then, the object ranking lex
is defined as follows for all objects oOC (where nj with
j {1, . . . , 100} is the number of all p P  of strength j):

lex(o) =

i=1

if o |= T  A

|{p = (|)[i] P |o |= p}|  	i1

j=1(nj + 1)

otherwise.

(2)

5.4.

given

contd)

Consider

(Products

Example
again
PB = (T, A, P) of Example 2.1. Recall from Example 5.1
that the rewritten conditional preference base PB = (T, A, P )
P  = {(PC|Sale)[20], (Laptop|Sale)[70],
is
(Inexpensive)[90]}. The object rankings sum and lex for PB
are shown in Table 1 (where Inexp abbreviates Inexpensive).
For example, the rank of o3 is , since it does not satisfy A, and
the ranks of o5, o8, and o11 under sum and lex are calculated

by

Table 1
The object rankings sum and lex

false
false
false
false
false
false
false
false
true
true
true
true
true
true
true
true

Laptop

false
false
false
false
true
true
true
true
false
false
false
false
true
true
true
true

Sale

false
false
true
true
false
false
true
true
false
false
true
true
false
false
true
true

Inexp

false
true
false
true
false
true
false
true
false
true
false
true
false
true
false
true

sum

o1
o2
o3
o4
o5
o6
o7
o8
o9
o10
o11
o12
o13
o14
o15
o16

lex

as follows:
sum(o5) = 1  20 + 0  70 + 1  90 = 110,
lex(o5) = 1  1 + 0  (1 + 1) + 1  (1 + 1)  (1 + 1) = 5,
sum(o8) = 0  20 + 0  70 + 0  90 = 0,
lex(o8) = 0  1 + 0  (1 + 1) + 0  (1 + 1)  (1 + 1) = 0,
sum(o11) = 0  20 + 1  70 + 1  90 = 160,
lex(o11) = 0  1 + 1  (1 + 1) + 1  (1 + 1)  (1 + 1) = 6,
o5  PC  Sale,
since
 Laptop  Sale, o5  Inexpensive, o8  PC  Sale, o8
 Laptop  Sale,
o11  PC  Sale,
o11  Laptop  Sale,
(and
so o5 |= (PC|Sale)[20], o5  (Laptop|Sale)[70], o5 |= (Inex-
o8  (Laptop|Sale)
pensive)[90],
o11  (PC|Sale)[20],
[70],
o11 |= (Inexpensive)[90],
o11 |= (Laptop|Sale)[70],
respectively).

o8  (Inexpensive)[90],
and

o8  (PC|Sale)[20],

o5, o8, o11  T  A,

o11 Inexpensive

o8  Inexpensive,

and

and

o5

by

5.5.

We provide another example, which shows that the two object
rankings sum and lex generally indeed produce two different
orderings on the objects.

obtained

(Products

from PB of Example

contd) Let PB = (T, A, P)
Example
be
adding
(Made By IBM)[70] to P. The rewritten conditional preference base PB = (T, A, P ) is obtained from the one in
Example 5.1 by adding (Made By IBM)[70] to P . For
the objects o = {PC  Laptop, PC, Sale, Inexpensive} and
 = {PC  Laptop, Laptop, Sale, Made By IBM},
we
then obtain the ranks sum(o) = 140 > 90 = sum(o
) and
lex(o) = 4 < 6 = lex(o

Summarizing, every object ranking  {sum, lex} of a
conditional preference base PB represents the preference relationships encoded in PB. For every (fully specified) object o,
the rank of o under PB is given by (o). Every object ranking
 {sum, lex} can also be used to compare two (fully spec-
 OC as follows. The distance between the
ified) objects o, o
)|. Furunder PB is defined as |(o)  (o

objects o and o
thermore, the (credulous) rank of a partially specified object
 (which is a Boolean combination of concepts from C) under
PB is defined as minoOC:o(o). Finally, the (credulous) distance between two partially specified objects  and 
is defined
as mino,o

|(o)  (o

 OC:o,o

)|.

).

6. Algorithms

In this section, we formally specify the main computational
tasks related to conditional preference bases, and we provide
algorithms for solving them. This shows in particular that the
tasks are all decidable. The main computational tasks for conditional preference bases are formally given as follows:

Consistency: Given a conditional preference base PB, decide
whether PB is consistent.
z-Partition: Given a conditional preference base PB, compute the z-partition of PB (if it exists).

Fig. 1. Algorithm z-partition.

Flatten:Given a conditional preference base PB, compute a
non-defeasible equivalent PB to PB (if one exists).
s-Ranking:Given a conditional preference base PB and a set
of objects O  OC, compute the ranking s on O for PB (if it
exists), where s{sum, lex}.

The problem of deciding the consistency (and computing the
z-partition) of a conditional preference base PB is solved by
Algorithm z-partition in Fig. 1, which generalizes an algorithm
for deciding the -consistency (and computing the z-partition)
of a conditional knowledge base in default reasoning [22]. The
algorithm takes as input a conditional preference base PB =
(T, A, P), and it returns as output the z-partition of PB, if PB is
consistent, and nil, otherwise. In lines (1) and (2), it deals with
the cases where T  A is unsatisfiable and P = , respectively.
In lines (3)(11), it computes and returns the z-partition of PB
as specified in Theorem 4.5(a).

(Products contd) Consider again PB =
Example 6.1.
(T, A, P) of Example 4.2. Since T  A is satisfiable and P =
, we set H := P and i := 1 in lines (3) and (4), respec-
tively, and enter the loop in lines (5)(9). After the first run
of the loop, i = 0, P0 = {(PC)[20], (Inexpensive)[90]}, and
H = {(Laptop|Sale)[70]}. After the second run, i = 1, P1 =
{(Laptop|Sale)[70]}, and H = . We thus leave the loop, and
return (P0, P1) as the z-partition of PB, which also shows that
PB is consistent.

The problem of rewriting PB to a non-defeasible equivalent
PB (for the object rankings sum and lex in Section 5) is solved
by Algorithm flatten in Fig. 2, which is related to a rewriting algorithm in fuzzy default reasoning [15]. The algorithm
takes as input a conditional preference base PB = (T, A, P), and
it returns as output a non-defeasible equivalent PB to PB, if
PB is consistent, and nil, otherwise. In lines (1)(3), the algorithm handles the cases where PB is inconsistent and P = ,
and it computes the z-partition of PB (if it exists). In lines
(4)(14), it adds for every i{1, . . . , n} to some bodies of conditional preferences in P0    Pi1 negations of bodies from
Pi and returns the thus computed conditional preference base
(see Theorem 6.4 for the correctness of Algorithm flatten).

(Products contd) Consider again PB = (T,
Example 6.2.
A, P) of Example 4.2. We first run Algorithm z-partition to

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

Fig. 2. Algorithm flatten.

Fig. 4. Algorithm lex-ranking.

compute the z-partition (P0, P1) of PB (and thus also to verify
that PB is consistent). Since this is successful (see Example
6.1) and P = , we then set D := P0 in line (4). We then
run once (for i = 1) through the loop in lines (5)(13), where
we set H :=  and run twice (for p1 = (PC)[20] and p2 =
(Inexpensive)[90]) through the loop in lines (7)(11). Here,
= {Sale} and H = {(PC|Sale)[20]} after the first run,
Fp1
=  and H = {(PC|Sale)[20], (Inexpensive)[90]}
and Fp2
after the second run. Hence, D = {(PC|Sale)[20], (Inexpen-
sive)[90], (Laptop|Sale)[70]} after line (12), and we return
(T, A, D) as the result.

Finally, computing the ranking functions sum and lex is done
by Algorithms sum-ranking and lex-ranking in Figs. 3 and 4,
respectively. In lines (1)(4), the two algorithms handle the cases
where PB is inconsistent and P = , and they compute a nondefeasible equivalent PB to PB (if it exists). In lines (5)(7) and
(5)(14), the two algorithms compute (and return) the ranking
functions sum and lex for the case where PB is consistent and
P =  using Eqs. (1) and (2), respectively.
(Products contd) Consider again PB =
Example 6.3.
(T, A, P) of Example 4.2. Suppose we want to rank the objects
o3 = {Sale} and o11 = {PC  Laptop, PC, Sale}. In both sumranking and lex-ranking, we first rewrite PB = (T, A, P) using
Algorithm flatten. Since this is successful, and o3 does not satisfy (resp., o11 satisfies) T  A, we then set the rank of o3 (resp.,
o11) to  (resp., 0) in line (3). Since P =  in line (4), we
continue running once (for o = o11) through the loop starting in line (5). In Algorithm sum-ranking, we then run three

Fig. 3. Algorithm sum-ranking.

times (for p1 = (PC|Sale)[20], p2 = (Laptop|Sale)[70], and
p3 = (Inexpensive)[90]) through the loop in line (6). Since o11
satisfies p1 and falsifies p2 and p3, its rank is 70 + 90 = 160.
Instead, in Algorithm lex-ranking, we set n := 1 and we run 100
times (for i{1, . . . , 100}) through the loop in lines (7)(12).
Here, for i = 20, i = 70, and i = 90, we run once through the
loop in (9), producing h = 0, h = 1, and h = 1. Since at the
same time n = 1, n = 1  2 = 2, and n = 2  2 = 4, respec-
tively, o11s rank is 0  1 + 1  2 + 1  4 = 6. Finally, we return
the ranking on o3 and o11 in line (7).

The following result shows the correctness of all the above

algorithms.

Theorem 6.4. Algorithms z-partition, flatten, sum-ranking,
and lex-ranking are all correct, that is, they solve the problems z-
Partition (and Consistency), Flatten, sum-Ranking, and
lex-Ranking, respectively.

The next result shows that all the above algorithms can be
reduced to a polynomial number of checks whether a description
logic knowledge base is satisfiable.
Theorem 6.5. Given a conditional preference base PB =
(T, A, P), Algorithms z-partition and flatten can be done in
O(|P|2) description logic satisfiability tests. Given additionally a set of objects O  OC, Algorithms sum-ranking and
lex-ranking can be done in O(|P|2 + |O|) description logic satisfiability tests.

Observe here that the O(|P|2 + |O|) description logic satisfiability tests for computing sum and lex are essentially
used to transform the given PB = (T, A, P) into a non-de-
feasible equivalent PB = (T, A, P ), and to decide which of
the objects in the given O satisfy T. That is, the description
logic satisfiability tests are part of a preprocessing step. The
actual computation of sum and lex can then be done in time
O(|O|  |C|  (|A| + |P|)), without further description logic
satisfiability tests.
By Theorem 6.5, under the assumption that |P| is bounded
by a constant (which is a reasonable assumption in the application in literature search in Section 9), deciding whether PB
is consistent, computing the z-partition of PB, and computing

Table 2
Complexity results

Consistency
z-Partition
Flatten
s-Ranking

SHIF(D)
EXP-complete
FEXP-complete
FEXP-complete
FEXP-complete

SHOIN(D)
NEXP-complete
in FP NEXP
in FP NEXP
in FPNEXP

a non-defeasible equivalent to PB can all be done in a constant
number of description logic satisfiability tests. Under the same
assumption, computing the rankings sum and lex can be done
in O(|O|) description logic satisfiability tests.

7. Complexity

In this section, we address the complexity of conditional preference bases. We first recall some necessary complexity classes,
and previous complexity results on description logic satisfiabil-
ity. We then provide our complexity results.

7.1. Complexity classes and previous results

We assume that the reader has some elementary background
in complexity theory, and is familiar with the concepts of Turing machines and oracle calls, polynomial-time transformations
among problems, and the hardness and completeness of a problem for a complexity class [30,31,40]. We now briefly recall the
complexity classes that we encounter in our complexity results
below.

The class EXP (resp., NEXP) contains all decision problems
that can be solved in exponential time on a deterministic (resp.,
nondeterministic) Turing machine. The class PNEXP contains all
problems that are decidable in polynomial time on a deterministic Turing machine with the help of a NEXP oracle. The class

contains the problems in PNEXP that are solvable in such a

way that all oracle calls are done in parallel. The above complexity classes along with their inclusion relationships (all of which
are currently believed to be strict) are summarized as follows:
EXP  NEXP  PNEXP

 PNEXP.

For classifying problems that compute an output value, function classes similar to the classes above have been introduced
[45,30]. In particular, FEXP, FPNEXP
, and FPNEXP are the functional analogs of EXP, PNEXP
Finally, we recall that the problem of deciding whether a
knowledge base L in SHIF(D) (resp., SHOIN(D)) is satisfiable is complete for EXP [52,26] (resp., NEXP, assuming
unary number encoding; see [26] and the NEXP-hardness proof
for ALCQI in [52], which implies the NEXP-hardness of
SHOIN(D)).

, and PNEXP, respectively.

7.2. Complexity results

Our complexity results for the main computational tasks
related to conditional preference bases are compactly summarized in Table 2. More concretely, for conditional preference

bases PB overSHIF(D) (resp.,SHOIN(D)), the decision problem Consistency is complete for EXP (resp., NEXP), while the
computation problems z-Partition, Flatten, and s-Ranking,
where s{sum, lex}, are complete for FEXP (resp., in FPNEXP

FPNEXP, and FPNEXP).

The following theorem formally states the complexity results
for the decision problem Consistency. Hardness for EXP
(resp., NEXP) follows from the hardness for EXP (resp., NEXP)
of deciding description logic satisfiability in SHIF(D) (resp.,
SHOIN(D)), while membership in EXP (resp., NEXP) follows from Theorem 6.5 (resp., 4.5(b)) and the membership in
EXP (resp., NEXP) of deciding description logic satisfiability
in SHIF(D) (resp., SHOIN(D)).
Theorem 7.1. The decision problem Consistency is complete
for EXP (resp., NEXP) when PB is defined overSHIF(D) (resp.,
SHOIN(D)).

The next theorem formally states the complexity results for
z-Partition, Flatten, and s-Ranking. These results follow
from Theorem 6.5 and the complexity of deciding description
logic satisfiability in SHIF(D) (resp., SHOIN(D)).
Theorem 7.2.
The computation problems z-Partition,
Flatten, and s-Ranking, where s{sum, lex}, are complete
for FEXP (resp., in FPNEXP
, FPNEXP, and FPNEXP) when PB is
defined over SHIF(D) (resp., SHOIN(D)).

8. Tractable special case

In this section, we present a special case in which the problems Consistency, z-Partition, Flatten, and s-Ranking,
where s{sum, lex}, can all be solved in polynomial time. The
main idea behind it is to restrict the class of concepts that may
occur in PB in such a way that the description logic satisfiability tests in Algorithms z-partition, flatten, sum-ranking, and
lex-ranking can be done in polynomial time. Here, we take inspiration from the description logic DL-Lite [9] where deciding
whether a knowledge base is satisfiable can be done in polynomial time.

We first recall knowledge bases in DL-Lite [9], which are
a restricted class of description logic knowledge bases. Let A,
RA, and I be pairwise disjoint finite nonempty sets of atomic
concepts, abstract roles, and individuals, respectively. A basic
concept in DL-Lite is either an atomic concept from A or an
exists restriction on roles of the form R. (abbreviated as R),

where R RA  R
A. Concepts in DL-Lite are defined by induction as follows. Every basic concept in DL-Lite is a concept in
DL-Lite. If b is a basic concept in DL-Lite, and 1 and 2 are
concepts in DL-Lite, then b and 1  2 are also concepts in
DL-Lite. An axiom in DL-Lite is either (1) a concept inclusion
axiom of the form b  , where b is a basic concept in DLLite and  is a concept in DL-Lite, or (2) a functionality axiom

(funct R), where R RA  R
A, or (3) a concept membership
axiom b(a), where b is a basic concept in DL-Lite and a I, or
(4) a role membership axiom R(a, c), where R RA and a, c  I.
A knowledge base in DL-Lite is a finite set of axioms in DL-Lite.
We recall the following result from [9], which says that deciding

T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

whether a knowledge base in DL-Lite is satisfiable can be done
in polynomial time.

query results, which reflects personal preferences and quality
measures.

Theorem 8.1.
[see [9]] Given a knowledge base in DL-Lite KB,
deciding whether KB is satisfiable can be done in polynomial
time.

We are now ready to define a similarly restricted class of
conditional preference bases. A literal in DL-Lite is either a
basic concept in DL-Lite b or the negation of a basic concept in
DL-Lite b. A conjunctive concept in DL-Lite is either , or ,
or a conjunction of literals in DL-Lite. A conditional preference
base PB = (T, A, P) is defined over DL-Lite iff T is a description
logic knowledge base in DL-Lite, A is a set of literals in DL-Lite,
and P is a set of conditional preferences of the form (|)[s],
where  and  are conjunctive concepts in DL-Lite. Given a
conditional preference base over DL-Lite PB = (T, A, P), we
say that P is bounded iff the input size of P is bounded by a
constant (which is a reasonable assumption in the application in
literature search in Section 9).

The following theorem shows that for conditional preference
bases over DL-Lite, the problems Consistency, z-Partition,
and Flatten can all be solved in polynomial time when P is
bounded. This result follows from Theorems 6.5 and 8.1, and the
observation that here every description logic satisfiability test in
Algorithms z-partition and flatten can be reduced to a constant
number of description logic satisfiability tests on knowledge
bases in DL-Lite.

Theorem 8.2. Given a conditional preference base over DLLite PB = (T, A, P), where P is bounded, (a) deciding whether
PB is consistent, (b) computing the z-partition of PB (if it exists),
and (c) computing a non-defeasible equivalent PB to PB (if one
exists) can all be done in polynomial time.

The next theorem shows that for conditional preference bases
over DL-Lite, also the problems sum- and lex-Ranking can both
be solved in polynomial time when P is bounded. Thus, for
conditional preference bases over DL-Lite, the problems sumand lex-Ranking have both a polynomial data complexity (where
the input size of the whole conditional preference base PB is
bounded by a constant).

Theorem 8.3. Given a conditional preference base over DLLite PB = (T, A, P), where P is bounded, and a set of objects
O  OC, where C is the set of all concepts that occur in A and
P, computing the object rankings sum and lex on O for PB can
be done in polynomial time (if they exist).

9. Literature search

In the previous sections, we have already described the application of conditional preference bases for a flexible user-defined
ranking of the query results when searching product databases.
In this section, we describe a further application of this approach
in literature search, which shows in particular that the combination of description logics and variable-strength conditional
preferences nicely allows for both expressing sophisticated
search strategies and a flexible user-defined ranking of the

9.1. Background

A very important and time consuming task of researchers
is finding publications. There exist a lot of possibilities to find
relevant research publications over the internet. For instance,
there are portals for research publications, portals for ejournals,
special purpose search engines for researchers (for example,
CiteSeer and Google Scholar), specialized databases, publication databases of institutions, and bibliographic online
catalogues. It seems that there is a trend to more diversity and
quality regarding online search engines. On the other hand, the
tremendous increase in the quantity and diversity of easily
available research publications has exacerbated the problems of
information overload for researchers attempting to keep abreast
of new relevant research, especially in rapidly advancing fields
[6].

There are a lot of good search strategies for the task of finding
relevant scientific publications. Bates [2] has identified the following six important information search strategies:(1) footnote
chasing: following up footnotes (that is, references) found in
publications. This can be done in successive leaps; (2) citation
searching: looking for publications that cite certain publications;
(3) journal run: identification of a central journal in a research
area and then looking up publications in relevant volumes; (4)
area scanning: browsing resources that are physically collocated
with resources that are regarded as relevant. A good example is
a bookshelf in a library. In a digital library, one could exploit
the classification of resources; (5) subject searches: the usage
of subject descriptors such as keywords to find relevant publi-
cations; (6) author searching: to find other publications of an
author, which may have a similar topic as a publication one
already knows of.

It would be helpful if the above search strategies could
be explicitly supported by the query languages of search
engines. Each existing search engine (such as CiteSeer,
Google Scholar, and Google), however, supports only some
of these search strategies, but not all of them. Furthermore,
there is currently no way to exploit
the search strategies
by the formulation of search queries. What is currently also
not supported is the possibility to exploit relationships like
citations or co-authorships by the formulation of queries.
Finally, to date, search query languages of most web search
engines have little expressive power for formulating semantic
queries.

Another limitation of current search engines is that they provide the user only with restricted possibilities to influence the
ranking of the returned query results. For example, Google is
based on the PageRank ranking [8], which is calculated from the
link structure between the objects, and thus somehow reflects
the relative importance of the objects. However, especially in
literature search, the user should be provided with more possibilities to explicitly influence the ranking of the query results, to
express personal preferences and quality measures for the query
results.

query results. Note that further such examples are given in the
ESWC-2006 abstract of this paper.

9.2. Literature search via conditional preference bases

Conference

We express each search query Q by a conditional preference
base PBQ = (T, A, P), where the background knowledge
T is informally described as follows (using self-explaining
names). We assume the concepts Publication, Journal-
Publication, ConfPublication, Person, Publicationmedium,
Journal, Proceedings, Keyword, Event, Conference,
and
Workshop, which are related by the concept inclusion axioms
JournalPublication  Publication, ConfPublication 
 Event, Workshop 
Publication,
Event, Journal  Publicationmedium, and Proceedings 
Publicationmedium. We assume the roles Author (relat-
ing Publication and Person), Coauthor (on Person), Cite
(on Publication), Publishedin (relating Publication and
Publicationmedium), Keywords (relating Publication and
Keyword), hasPublicationmedium (relating Event and Publi-
cationmedium), and in title (relating Publication and string).
Here, in title relates every publication with all substrings of
its title. Finally, the concept Publication has the attributes
year, title, publishedat, and type.
We assume that the standard semantics of PBQ = (T, A, P)
is given by its object ranking sum, and we abbreviate PBQ =
(T, A, P) by the conjunction CQ of all elements in A  P. For
example, consider the following query Q: we are looking for
publications with the keyword Semantic Web; furthermore,
the publications should also contain the keywords OWL and
DAML+OIL with the strengths 70 and 20, respectively. This
query Q is expressed by the following PBQ = (T, A, P):
T as informally described above,
A = {Keywords.{Semantic Web}}, and
P = {(Keywords.{OWL})[70],
(Keywords.{DAML + OIL})[20]},

which is abbreviated by the following conjunction CQ:
Keywords.{Semantic Web}  (Keywords.{OWL})[70]
 (Keywords.{DAML + OIL})[20].

This query also illustrates the use of (user-defined) strengths
in simple conditional preferences: Publications that contain all
the keywords have the rank 0, whereas publications that have
Semantic Web and OWL but not DAML+OIL as keywords
have the rank 20, since they falsify the second conditional prefer-
ence, while those that have Semantic Web and DAML+OIL
but not OWL as keywords have the rank 70, since they falsify
the first conditional preference. Finally, publications that have
Semantic Web but not DAML+OIL and OWL as keywords
have the rank 70 + 20 = 90, since they falsify both conditional
preferences.

We now provide some examples, which show in particular that search queries based on conditional preferences bases
allow for both expressing nearly all the above-mentioned search
strategies and a flexible user-defined ranking of the query results,
which reflects personal preferences and quality measures for the


.(title.{Weaving the Web}

Footnote chasing. A highly relevant publication can be a
very good starting point for the identification of further highly
relevant publications. For example, we may be looking for all
publications cited in Weaving the Web by Tim Berners-Lee:
Cite

Author.{Tim Berners-Lee}).
Citation searching. Suppose we want to know which of the
papers at ISWC-2003 were cited and how the topics of this
conference evolved over time, that is, we may be looking for
publications that cite publications of ISWC-2003:
Cite.(ConfPublication  publishedat.{ISWC}
year.{2003}).
Journal run. Suppose we are looking for conferences that are
relevant to the topics elearning and Semantic Web, that is,
we are looking for conferences that have publications with the
keywords elearning and Semantic Web:
Conference  hasPublicationmedium.Publishedin
(Keywords.{elearning}
Keywords.{Semantic Web}).
Subject searches. Suppose next we are looking for publications
that have the keyword matching, where (i) among the nonjournal publications we prefer the ones that cite at least five
journal publications that are cited at least eight times to those
without this property with strength 40, (ii) among the journal
publications we prefer the ones that cite at least four publications
that are cited at least seven times to those without this poperty
with strength 50, and (iii) we prefer journal publications to nonjournal publications with strength 10:
Keywords.{matching}
 (5Cite.(8Cite
  JournalPublication)|
JournalPublication)[40]  (4Cite.(7Cite
JournalPublication)[50]  (JournalPublication)[10].
Note that the object ranking of this query encodes a (user-
defined) quality measure for the publications. More concretely,
the query ranks the returned publications as follows. First, journal publications that cite at least four publications that are cited
at least seven times have the rank 0. Second, non-journal publications that cite at least five journal publications that are cited
at least eight times have the rank 10. Third, all the other journal
and non-journal publications have the rank 50.


)|

Author searching. One possibility to judge the scientific
famousness of a researcher is to find out how often and from
whom the researcher is cited. For example, we may be looking
for authors that cite publications of Ian Horrocks:
Author

.Cite.Author.{Ian Horrocks}.


T. Lukasiewicz, J. Schellhase / Web Semantics: Science, Services and Agents on the World Wide Web 5 (2007) 180194

10. Related work

In this section, we give a brief overview on the area of
default reasoning from conditional knowledge bases, and we
discuss related work on combining formalisms for reasoning
about uncertainty with description logics and ontologies.

10.1. Default reasoning from conditional knowledge bases

The literature contains several different proposals for default
reasoning from conditional knowledge bases and extensive work
on its desired properties. The core of these properties are the
rationality postulates of System P by Kraus et al. [33], which
constitute a sound and complete axiom system for several
classical model-theoretic entailment relations under uncertainty
measures on worlds. They characterize classical model-theoretic
entailment under preferential structures, infinitesimal probabili-
ties, possibility measures [14], and world rankings [46,23]. They
also characterize an entailment relation based on conditional
objects [13]. A survey of all these relationships is given in [3,19].
Mainly to solve problems with irrelevant information, the notion
of rational closure as a more adventurous notion of entailment
was introduced by Lehmann and Magidor [34]. It is in particular equivalent to entailment in System Z by Pearl [41] (which is
generalized to variable-strength defaults in System Z
by Goldszmidt and Pearl [21,24]) and to the least specific possibility
entailment by Benferhat et al. [4]. Another sophisticated quasiprobabilistic formalism for reasoning about variable-strength
defaults is Weyderts System JLZ [53]. Recently, also generalizations of many of the above approaches to probabilistic and
fuzzy default reasoning have been proposed (see especially [35]
resp. [15]).

10.2. Uncertainty reasoning in description logics and
ontologies

Related formalisms to uncertainty reasoning in description
logics and ontologies can roughly be divided into fuzzy description logics, probabilistic description logics, and probabilistic
web ontology languages. In particular, Straccia [47] presents a
fuzzy extension of the description logic ALC, which is based on
Zadehs fuzzy logic, and which is directed towards applications
in multimedia information retrieval. Recent works by Straccia
also introduce a fuzzy description logic with concrete domains
[48] and a fuzzy description logic for the Semantic Web [49].
Closely related to the latter is the work by Stoilos et al. [50],
which combines the description logic SHIN with fuzzy set theory for the Semantic Web. As for probabilistic description logics,
in [20], Giugno and Lukasiewicz present a probabilistic generalization of the expressive description logicSHOQ(D) that stands
behind DAML+OIL, which is based on lexicographic probabilistic reasoning. In earlier work, Heinsohn [25] and Jaeger
[29] present probabilistic extensions to the description logic
ALC, which are essentially based on probabilistic reasoning
in probabilistic logics. Koller et al. [32] present a probabilistic generalization of the Classic description logic, which uses
Bayesian networks as underlying probabilistic reasoning for-

malism. Finally, as for probabilistic web ontology languages,
there are especially the works by da Costa [10], Pool and Aikin
[42], and Ding and Peng [12], which present probabilistic generalizations of the web ontology language OWL. In particular,
Costas work [10] is semantically based on multi-entity Bayesian
networks, while [12] has a semantics in standard Bayesian net-
works. In closely related work, Fukushige [18] proposes a basic
framework for representing probabilistic relationships in RDF.
Finally, Nottelmann and Fuhr [39] present pDAML+OIL, which
is a probabilistic generalization of the web ontology language
DAML+OIL, along with a mapping to stratified probabilistic
datalog.

11. Conclusion

We have introduced conditional preference bases as a means
for ranking objects in ontologies. Conditional preference bases
consist of a description logic knowledge base and a finite set
of conditional preferences, which are statements of the form
generally, in the context , property  is preferred over property
 with strength s. They are given a qualitative probabilistic
formal semantics that is based on conditional knowledge bases.
We have defined the consistency of conditional preference bases
and shown how consistent conditional preference bases can be
used for defining two object rankings, denoted sum and lex,
which evaluate the strengths of conditional preferences in an
additive and a lexicographic way, respectively. Furthermore, we
have provided algorithms for the main computational tasks for
ranking objects under conditional preference bases, analyzed the
complexity of these tasks, and described tractable special cases.
We have described two applications of the presented approach
in product and literature search. In the former, it allows for a
flexible user-defined ranking of the query results, which reflects
personal preferences. In the latter, it allows for both expressing sophisticated search strategies and a flexible user-defined
ranking of the query results, which reflects personal preferences and quality measures. More generally, query languages
of current search engines are very restricted in their expressive
power. There are scientific search engines on the web, how-
ever, that have valuable metadata about publications, authors,
organizations, and scientific events. We have shown that conditional preference bases allow for a more powerful query
language, which can exploit this metadata better than the current
approaches do.

There are many other applications (especially in the Web),
where ranking a selection of objects relative to personal preferences  as realized by our approach based on conditional
preference bases  plays an important role, such as, e.g., product
configuration, meeting scheduling, and searching for a partner,
a holiday place, a hotel, travel means, a restaurant, an event, a
house, a job, or an employee.

An interesting topic of future research is to explore whether
the presented approach can also be used for personalization tasks
and in recommender systems. Another interesting issue is an
extension in such a way that the user-defined preference ranking
on objects is combined with an importance ranking on objects
(such as PageRank [8]). It would also be interesting to combine

the presented formalism with probabilistic ontologies [32,20,10]
to compute the ranking of incompletely specified objects. A
first effort in the latter two directions is [38]. Finally, it would
be interesting to generalize the formalism to the multi-agent
framework.

Acknowledgments

This work has been partially supported by the German
Research Foundation (DFG) under the Heisenberg Programme.
We would like to thank the reviewers of this paper and its ESWC2006 abstract for their constructive comments, which helped to
improve this work.
