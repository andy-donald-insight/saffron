Logical Foundations of (e)RDF(S): Complexity and

Reasoning

Jos de Bruijn1 and Stijn Heymans2

1 Faculty of Computer Science, Free University of Bozen-Bolzano, Italy

2 Digital Enterprise Research Institute (DERI), University of Innsbruck, Austria

debruijn@inf.unibz.it

stijn.heymans@deri.org

Abstract. An important open question in the semantic Web is the precise relationship between the RDF(S) semantics and the semantics of standard knowledge
representation formalisms such as logic programming and description logics. In
this paper we address this issue by considering embeddings of RDF and RDFS
in logic. Using these embeddings, combined with existing results about various
fragments of logic, we establish several novel complexity results. The embeddings we consider show how techniques from deductive databases and description logics can be used for reasoning with RDF(S). Finally, we consider querying
RDF graphs and establish the data complexity of conjunctive querying for the
various RDF entailment regimes.

1 Introduction

The Resource Description Framework RDF [16], together with its vocabulary description language RDFS [3], constitutes the basic language for the semantic Web. More
expressive semantic Web languages such as the description logic-based OWL DL [19]
and future semantic Web rule languages1 are supposed to extend it. However, certain
properties of the RDF semantics posed layering problems in the definition of OWL
DL [12]; it was decided to extend only a part of RDF. This has led to a situation in
which the user communities of RDF and OWL DL are increasingly diverging, leading
to a fragmentation of the semantic Web. There is a possibility that a similar situation
will occur if a possible future rules language for the semantic Web does not adequately
account for RDF(S).

Research has been done to uncover some of the formal properties of RDF (e.g. [13,
10, 4]). However, so far little research has been done into the formal relationships between RDF and the logical language paradigms of description logics and logic program-
ming.2 Therefore, we deem it worthwhile to investigate these relationships, in order to
facilitate the RDF-compatibility of a future logic-based rules language for the semantic
Web, and to see whether the RDF and description logic worlds can be brought closer

 This work was partially supported by the European Commission under the projects Knowledge

Web (IST-2004-507482) and SUPER (FP6-026850).

1 http://www.w3.org/2005/rules/
2 A notable exception is [4].

K. Aberer et al. (Eds.): ISWC/ASWC 2007, LNCS 4825, pp. 8699, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
together. Additional benefits of such an investigation include the possible use of techniques from logic programming and description logics for reasoning with RDF(S).

The RDF semantics specification [11] defines three increasingly expressive kinds
of entailment, namely simple, RDF and RDFS entailment. Furthermore, it describes
extensional RDFS (eRDFS) entailment as a possible extension of RDFS entailment
which is more in line with description logic-like languages. We refer to these kinds of
entailment as entailment regimes.

To investigate the relationship between RDF and logic we embed the various RDF
entailment regimes in F-Logic [15], which is a syntactic extension of first-order logic
with object oriented modeling constructs. It turns out that the attribute value construct
in F-Logic is exactly equivalent to the triple construct in RDF, and the typing (class
membership) construct in F-Logic is very close in spirit to the one in RDF. Additionally,
F-Logic, like RDFS, allows to use the same identifier as a class, instance, or property
identifier, while still having a standard first-order logic-based semantics.

These embeddings can be used for RDF reasoning using Datalog engines. Further-
more, they lead to several novel complexity results about RDF; see Table 3 on page 96
for an overview of the complexity results for the various entailment regimes.

We then show the embedding of a large subset of extensional RDFS in FOL, and we
show that it can be embedded in the tractable description logic (contextual) DL-LiteR
[7].

Finally, we define a notion of conjunctive queries over RDF graphs, and establish the

data complexity of query answering for the respective entailment regimes.

The structure of the remainder of the paper is as follows. In Section 2 we review
F-Logic, DL-LiteR, and RDF. In Section 3 we define embeddings of RDF in F-Logic
and FOL, and demonstrate the relationship with DL-LiteR. In Section 4 we use these
embeddings and correspondences to obtain several novel complexity results for RDF.
In Section 5 we define conjunctive query answering in RDF and exhibit its complexity.
We discuss some implications of the results in this paper, and compare it with related
work, in Section 6. We conclude the paper and outline future work in Section 7.

This paper is an extended version of [5], adding support for literals and treatment of
RDF querying. Unlike in [5] we do not consider extensions of the embeddings of logical
rules or formulas in this paper; see Section 7 for a discussion about the combination of
RDF graphs with logical rules.

Proofs of all results are available in an extended version of this paper.

2 Preliminaries

F-Logic3 extends first-order logic with constructs for object-oriented modeling (we use
the object typing and attribute value construct), while staying in a first-order semantic
framework.
The signature of an F-language L is of the form  = F,P with F and P disjoint
sets of function and predicate symbols, each with an associated arity n  0. Let V be a
set of variable symbols disjoint from F and P. Terms and atomic formulas are defined
3 Note that F-Logic is also often used as an extension of nonmonotonic logic programming;

however, we follow the original definition which is strictly first-order.
?

?

?
in the usual way;  is an atomic formula. A molecule in F-Logic is one of the following:
(i) an is-a molecule of the form C : D, which states that an individual C is of the type
D, or (ii) a data molecule of the form C[D  E] which states that an individual C has
an attribute D with the value E, where C, D and E terms,. A molecule is ground if it
does not contain variable symbols.
Formulas of an F-language L are either atomic formulas, molecules, or compound
formulas, which are constructed in the usual way from atomic formulas, molecules, the
logical connectives , ,  and , the quantifiers  and , and the auxiliary symbols
) and (. An F-Logic theory   L is a set of formulas.
F-Logic Horn formulas are of the form ()B1  . . . Bn  H, with B1, . . . , Bn, H
atomic formulas or molecules. F-Logic Datalog formulas are F-Logic Horn formulas
with no function symbols of arity higher than 0 such that every variable in H occurs in
some equality-free B1, . . . , Bn. F-Logic Horn and Datalog theories are sets of F-Logic
Horn and Datalog formulas, respectively.
An F-structure is a tuple I = U,U , IF , IP , I, where U is a non-empty, countable set (the domain) and U is a binary relation over U . An n-ary function symbol
f  F is interpreted as a function over the domain U : IF (f) : U n  U . An n-ary
predicate symbol p  P is interpreted as a relation over the domain U : IP (p)  U n.
I associates a binary relation over U with each k  U : I(k)  U  U . Variable
assignments are defined as usual.
Given an F-structure I of an F-language L, a variable assignment B, and a term t of
L, tI,B is defined as: xI,B = xB for x  V and tI,B = IF (f)(tI,B
n ) for t of
the form f(t1, . . . , tn), with f  F an n-ary function symbol and t1, . . . , tn terms.
Satisfaction of atomic formulas and molecules  in I, given the variable assignment B, denoted (I, B) |=f , is defined as: (I, B)|=f , (I, B) |=f p(t1, . . . , tn) iff
, (I, B) |=f t1[t2t3] iff
(tI,B
, . . . , tI,B
tI,B
, tI,B
. This extends to arbitrary formulas in the usual way.
The notion of a model is defined in the usual way. A theory   L F-entails a
formula   L, denoted  |=f , if for all F-structures I such that I |=f , I |=f .
FOL and DL-LiteR. Classical first-order logic (FOL) is F-Logic without molecules.
Contextual first-order logic (contextual FOL) is classical FOL where F and P are not
required to be disjoint, function and predicate symbols do not have associated arities,
and for every structure I = U,U , IF , IP , I it is the case that IF assigns a function
IF (f) : U i  U to every f  F and IP assigns a relation IP (p)  U i to every p  P,
for every nonnegative integer i. We denote satisfaction and entailment in classical and
contextual FOL using the symbols |= and |=c, respectively.

n )  IP (p), (I, B) |=f t1 : t2 iff tI,B
  I(tI,B

), and (I, B) |=f t1 = t2 iff tI,B

1 U tI,B

, . . . , tI,B

1 = tI,B

F-Logic can be straightforwardly embedded in FOL, as shown in the following

proposition.

Proposition 1. Let  and  be an F-Logic theory and formula which do not contain
the binary and ternary predicate symbols isa and data, respectively, and let 
and 
be the FOL theory and formula obtained from  and  by replacing every is-a molecule
a : b with the atomic formula isa(a, b) and every data molecule a[b  c] with the atomic
formula data(a, b, c). Then,
?

?

?
has a model and

  has a model iff 
  |=f  iff  |= 
.
DL-LiteR [7] is a description logic (DL) with certain desirable computational prop-
erties; most reasoning tasks are polynomial, and query answering has LogSpace data
complexity.
A classical (resp., contextual) DL-LiteR language consists of pairwise disjoint
(resp., possibly non-disjoint) sets of concept (C), role (R), and individual (F) iden-
tifiers. Concepts and roles in DL-LiteR are defined as follows:

Cl  A | R
Cr  A | R | A | R
R, R  P | P 

with A  C, P  R, Cl (resp., Cr) a left- (resp., right-)hand side concept, and R, R 
R roles.
A DL-LiteR knowledge base K consists of a TBox T which is a set of inclusion
axioms of the forms Cl  Cr and R  R
, and an ABox A which is a set of concept
and role membership assertions of the forms A(a) and P (a1, a2), with a, a1, a2  F.
We define the semantics of DL-LiteR through a translation to classical (resp., con-
textual) FOL, using the mapping function , which is defined in Table 1;  extends
naturally to sets of axioms and assertions.

Table 1. Mapping DL-LiteR to FOL

(A, X) = A(X)

(P

(P, X, Y ) = P (X, Y )

, X, Y ) = P (Y, X)
(R, X) = y(R(X, y))
(A, X) = (A, X)
(R, X) = y(R(X, y))

y is a new a variable

(Cl  Cr) = x((Cl, x)  (Cr, x))
(R1  R2) = x, y((R1, x, y)  (R2, x, y))

(A(a)) = A(a)

(P (a1, a2)) = P (a1, a2)

Given a classical (resp., contextual) DL-LiteR knowledge base K, the classical
(resp., contextual) FOL equivalent of K is the theory  = (K) = (T )  (A).
RDF is a data language, where the central notion is the graph, which is a set of
triples of the form s, p, o; s is the subject, p is the predicate, and o is the object of the
triple.
A vocabulary V = F,PL,T L,B consists of a set F of URI references, a set PL
of plain literals (i.e. Unicode character strings with an optional language tag), a set T L
of typed literals (i.e. pairs (s, u) of a Unicode string s and a URI u denoting a datatype),
and a set B of blank nodes (i.e. existentially quantified variables); see [16, Sections 6.4,
6.5, 6.6] for more details about the specific form of these symbols. Terms are URI
references, plain or typed literals, or blank nodes. A graph S of a vocabulary V is a set
?

?

?
of triples s, p, o, with s, p, o  F  PL  T L  B.4 With bl(s, p, o) (resp., bl(S))
we denote the set of blank nodes in s, p, o (resp., S). A triple s, p, o (resp., graph S)
is ground if bl(s, p, o) =  (resp., bl(S) = ).
An interpretation of a vocabulary V is a tuple I = U, UP , UL, IF , IL, Iext, where
U is a countable non-empty set, called the domain, UP is a countable set of properties,
UL  U is a countable set of literal values with PL  UL, IF is an interpretation
function for URI references IF : F  U  UP , IL is an interpretation function for
typed literals IL : T L  U , and Iext is an extension function Iext : UP  2(UU).
Given an interpretation I of a vocabulary V and a subset of the blank nodes B  B,
we define a mapping A : B  U which is used to interpret blank nodes. For a term t
we define tI,A as: (a) if t  F, then tI,A = IF (t), (b) if t  PL, then tI,A = t, (c) if
t  T L, then tI,A = IL(t), and (d) if t  B
An interpretation I satisfies a triple s, p, o with respect to a mapping A : B  U ,
with bl(s, p, o)  B
, denoted (I, A) |= s, p, o, if pI,A  UP and sI,A, oI,A 
Iext(pI,A). I satisfies a graph S with respect to a mapping A : bl(S)  U , denoted
(I, A) |= S, if (I, A) |= s, p, o for every s, p, o  S. An interpretation I is a model
of a graph S, denoted I |= S, if (I, A) |= S for some A : bl(S)  U .

, then tI,A = A(t).

Any interpretation is an s-interpretation (simple interpretation). An interpretation
I is an rdf- (resp., rdfs-, erdfs-)interpretation if it interprets the RDF (resp., RDFS)
vocabulary, satisfies the RDF (resp., RDFS) axiomatic triples, and satisfies a number of
conditions, as specified in [11].

An RDF graph S s-(resp., rdf-, rdfs-, or erdfs-)entails an RDF graph E if every s-
(resp., rdf-, rdfs-, or erdfs-)interpretation which is a model of S is also a model of E.
We refer to these kinds of entailment as entailment regimes, and use the symbol |=x,
with x  {s, rdf, rdf s, erdf s}, to denote entailment under the respective regimes.

Intuitively, the difference between the RDFS and eRDFS entailment regimes is that
for the latter, whenever an ontological relation (e.g. subclass or property domain) implicitly holds in an interpretation, the corresponding RDF statement (subClassOf,
domain) must be true, whereas this is not always the case with the RDFS entailment
regime. The following example illustrates this difference.
Example 1. Let S be the following graph: S = {parent, domain, P erson, mother,
subPropertyOf parent which says that the domain of parent is P erson, and the
property mother is a sub-property of parent. Using eRDFS entailment we can conclude from S that the domain of mother is also P erson:

S |=erdf s mother, domain, P erson;

it is always the case that the subject of any mother triple has the type P erson; thus,
mother implicitly has the domain P erson. We cannot draw this conclusion when
using RDFS entailment; in RDFS, only explicitly asserted domain constraints can be
derived.

4 Note that we allow literals in subject (s), and literals and blank nodes in predicate (p) positions,
whereas the RDF specification [16] does not. Nonetheless, our results immediately apply to
standard RDF graphs as defined in [16].
?

?

?
3 RDF(S) Embedding

In this section we first define an embedding of the various entailment regimes in
F-Logic. We then consider an embedding of eRDFS entailment in FOL and DL.

3.1 Embedding RDF in F-Logic

We embed a graph as a conjunction of data molecules; URI references and literals
are treated as constant symbols, and blank nodes are treated as existentially quantified
variables. In the remainder we assume that RDF graphs are finite.
Given a vocabulary V = F,PL,T L,B, an F-language L corresponds to V if it
has a signature of the form  = F  F  PL  T L,P.5
Definition 1. Let S be an RDF graph of a vocabulary V , let s, p, o  S be a triple in
S, and let L be an F-language which corresponds to V . Then,

(tr(s, p, o)  L) = s[p  o] and

(tr(S)  L) = { bl(S)(

{tr(s, p, o) | s, p, o  S})}.

If  is an F-Logic formula or theory in prenex normal form with only existential quanti-
fiers, then sk denotes the Skolemization of , i.e. every existentially quantified variable
is replaced with a globally unique new constant symbol.
We use a set of formulas  x  L, as defined in Table 2, to axiomatize the semantics
of an entailment regime x  {s, rdf, rdf s, erdf s}.
Proposition 2. Let S be an RDF graph of a vocabulary V . Then, tr(S)sk   x, with
x  {s, rdf, rdf s}, can be equivalently rewritten to a set of F-Logic Datalog formulas.
Note that  erdf s cannot be equivalently rewritten to a set of Datalog formulas, because
of the use of universal quantification in the antecedents of some of the implications in
 erdf s.
Theorem 1. Let S and E be RDF graphs of a vocabulary V and let x  {s, rdf, rdf s,
erdf s} be an entailment regime. Then,
S |=x E iff
S is x-satisfiable iff

tr(S)   x |=f tr(E), and
tr(S)   x has a model.

The following corollary follows immediately from Theorem 1 and the classical results
about Skolemization (see e.g. [9]). For the case of s-entailment, the result was implicitly
stated in [11, Skolemization lemma].
Corollary 1. Let S and E be RDF graphs and let x  {s, rdf, rdf s, erdf s} be an
entailment regime. Then,

S |=x E iff

tr(S)sk   x |=f tr(E).

5 Even though typed literals are pairs in RDF, we treat them simply as constant symbols in our

embedding.

J. de Bruijn and S. Heymans

Table 2. Axiomatization of the RDF entailment regimes

 s = 
 rdf =  s  {tr(s, p, o) | s, p, o is an RDF axiomatic triple}
{wellxml(t) | t  T L is a well-typed XML literal}
{illxml(t) | t  T L is an ill-typed XML literal}
{x(y, z(y[x  z])  x[type  Property]),
x(wellxml(x)  x[type  XMLLiteral]),
x(x[type  XMLLiteral]  illxml(x)  )}
 rdf s =  rdf  {tr(s, p, o) | s, p, o is an RDFS axiomatic triple}
{pl(t) | t  PL}
{x, y, z(x[y  z]  x[type  Resource]  z[type  Resource]),
u, v, x, y(x[domain  y]  u[x  v]  u[type  y]),
u, v, x, y(x[range  y]  u[x  v]  v[type  y]),
x(x[type  Property]  x[subPropertyOf  x]),
x, y, z(x[subPropertyOf  y]  y[subPropertyOf  z]  x[subPropertyOf  z]),
x, y(x[subPropertyOf  y]  z1, z2(z1[x  z2]  z1[y  z2])),
x(x[type  Class]  x[subClassOf  Resource]),
x, y(x[subClassOf  y]  z(z[type  x]  z[type  y])),
x(x[type  Class]  x[subClassOf  x]),
x, y, z(x[subClassOf  y]  y[subClassOf  z]  x[subClassOf  z]),
x(x[type  ContainerMembershipProperty]  x[subPropertyOf  member]),
x(x[type  Datatype]  x[subClassOf  Literal]),
x(pl(x)  x[type  Literal]),
x(x[type  Literal]  illxml(x)  )}
 erdf s =  rdf s  {x, y(u, v(u[x  v]  u[type  y])  x[domain  y]),
x, y(u, v(u[x  v]  v[type  y])  x[range  y]),
x, y(x[type  Property]  y[type  Property]  u, v(u[x  v] 
x, y(x[type  Class]  y[type  Class]  u(u[type  x]  u[type  y]) 

u[y  v])  x[subPropertyOf  y]),
x[subClassOf  y])}

Since, by Proposition 2, tr(S)sk, tr(S)sk   rdf and tr(S)sk   rdf s are equivalent
to sets of Datalog formulas, this result implies that simple, RDF, and RDFS entailment
can be computed using existing F-Logic rule reasoners6 such as FLORA-2, and Onto-
broker, as well as any rule reasoners which supports Datalog (see Proposition 1). Notice
that, in the corollary, tr(E) can be seen as a boolean conjunctive query (i.e. a yes/no
query) in which the existentially quantified variables in tr(E) are the non-distinguished
variables.

We now consider an alternative, direct embedding of the extensional RDFS semantics (erdfs-entailment) which eliminates part of the RDFS vocabulary from the embedded graph, yielding a set of Datalog formulas.

We first define the notion of nonstandard use of the RDFS vocabulary, which intuitively corresponds to using the vocabulary in locations where it has not been intended,
6 Note that a Datalog formula with  in the antecedent corresponds to an integrity constraint,
i.e. a query which may not have an answer set.
?

?

?
for example in places where it redefines the semantics of RDF constructs such as in the
triple type, subPropertyOf, a.

We say that a term t occurs in a property position if it occurs as the predicate of a
triple, as the subject or object of a subPropertyOf triple, as the subject of a domain or
range triple, or as the subject of a triple t, type, Property or t, type, Container-
MembershipProperty. A term t occurs in a class position if it occurs as the subject
or object of a subClassOf triple, as the object of a domain, range, or type triple, as
the subject of a triple t, type, Class or t, type, Datatype. Otherwise, we say that
t occurs in an individual position.

Definition 2. Let S be an RDF graph. Then, S has nonstandard use of the RDFS vocabulary if

 type, subClassOf, domain, range or subPropertyOf occurs in the subject or

object position of a triple in S or

 ContainerMembershipProperty, Resource, Class, Datatype or Property

occurs in any position other than the object position of a type-triple in S.

We conjecture that large classes of RDF graphs will not have any nonstandard use of
the RDFS vocabulary. We now proceed to define a direct embedding of the extensional
RDFS entailment regime in F-Logic.
Definition 3. Let s, p, o be an RDF triple. Then,

trerdf s(s, type, Datatype) = x(x : s  x : Literal),
trerdf s(s, subClassOf, o) = x(x : s  x : o),

trerdf s(s, type, o) = s : o,

trerdf s(s, subPropertyOf, o) = x, y(x[s  y]  x[o  y]),
trerdf s(s, domain, o) = x, y(x[s  y]  x : o),
trerdf s(s, range, o) = x, y(x[s  y]  y : o), and

trerdf s(s, p, o) = s[p  o], otherwise.
Let S be an RDF graph of a vocabulary V = F,PL,T L,B. Then,
trerdf s(S) = { bl(S)(
{trerdf s(s, p, o) | s, p, o  S})}, and
 erdf sV = {trerdf s(s, p, o) | s, p, o is an RDF(S) axiomatic triple with no nonstandard use of the RDF(S) vocabulary}  {t : XMLLiteral | t  T L is a welltyped XML literal}  {illxml(t) | t  T L is an ill-typed XML literal}
{t : Literal | t  PL}  {x(x : Literal  illxml(x)  )})

The property (resp., class) vocabulary of an RDF graph S consists of all the symbols
occurring in property (resp., class) positions in S and the RDF(S) axiomatic triples with
no nonstandard use of the RDF(S) vocabulary.
Given two RDF graphs S and E, we write E  S if the property and class vocabularies of E are subsets of the property and class vocabularies of S (modulo blank
node renaming and instantiation, i.e. replacement of blank nodes with URI references
or literals) and Resource, ContainerMembershipProperty, Class, Property and
Datatype do not occur in E.

J. de Bruijn and S. Heymans

Theorem 2. Let S, E be RDF graphs with no nonstandard use of the RDFS vocabulary such that Resource, Class, Property, ContainerMembershipProperty and
Datatype do not occur in E. Then,
 whenever E  S,

S |=erdf s E iff trerdf s(S)   erdf sV |=f trerdf s(E);

 (trerdf s(S))sk is a conjunction of F-Logic Datalog formulas, and whenever E
does not contain the terms subClassOf, domain, range, and subPropertyOf,
trerdf s(E) is a conjunction of atomic molecules prefixed by an existential quantifier and

S |=erdf s E iff (trerdf s(S))sk   erdf sV |=f trerdf s(E).

Since (trerdf s(S))sk   erdf sV is a set of Datalog formulas we have that, if the RDF
graphs fulfill certain conditions, query answering techniques from the area of deductive
databases can be used for checking extensional RDFS entailment.

3.2 Embedding Extensional RDFS in First-Order Logic

We now consider an embedding of extensional RDFS entailment in FOL, based on the
direct embedding of extensional RDFS in F-Logic considered above (Definition 3).
An F-Logic theory or formula is translatable to contextual FOL if for molecules of
the forms t1[t2  t3] and t1 : t2 holds that t2 is a constant symbol (i.e. 0-ary function
symbol).

Let  (resp., ) be an F-Logic theory (resp., formula) which is translatable to contextual FOL, then ()F O (resp, ()F O) is the contextual FOL theory obtained from 
(resp., ) by:

 replacing every data molecule t1[t2  t3] with t2(t1, t3), and
 replacing every is-a molecule t1 : t2 with t2(t1).

The following proposition follows immediately from a result in [6].
Proposition 3. Let ,  be an equality-free F-Logic theory and formula which are
translatable to contextual FOL. Then,

 |=f  iff ()F O |=c ()F O.

An RDF graph S is a non-higher-order RDF graph if S does not contain blank nodes
in class and property positions, and does not contain nonstandard use of the RDFS vo-
cabulary. A non-higher-order RDF graph S is a classical RDF graph if the sets of URIs
occurring in individual, class and property positions in S and its context (e.g. entailing
or entailed graph) are mutually disjoint. Notice that every ground RDF graph which
does not contain nonstandard use of the RDFS vocabulary is a non-higher-order RDF
graph. One can also verify that every OWL DL graph, as defined in [19], is a classical
RDF graph, but there are classical RDF graphs which are not OWL DL graphs.

The following theorem identifies subsets of extensional RDFS which have a natural
correspondence to contextual and classical FOL. Observe that if S is a non-higher-order
RDF graph, then trerdf s(S) is translatable to contextual FOL.
?

?

?
Theorem 3. Let S and E be non-higher-order RDF graphs such that E  S. Then,

S |=erdf s E iff (trerdf s(S))F O |=c (trerdf s(E))F O.

If, additionally, S, E are classical graphs, then (trerdf s(S))F O and (trerdf s(E))F O
are theories of classical first-order logic, and

S |=erdf s E iff (trerdf s(S))F O |= (trerdf s(E))F O.

Proposition 4. Let S be a ground non-higher-order graph7. Then, (trerdf s(S))F O can
be equivalently rewritten to the FOL equivalent  of a contextual DL-LiteR knowledge
base K.

If S is a classical RDF graph, then (trerdf s(S))F O can be equivalently rewritten to

the FOL equivalent  of a classical DL-LiteR knowledge base.

4 Complexity

In this section we review the complexity of the various forms of entailment in RDF
and present several novel results, based on the embeddings presented in the previous
section.

The complexity of simple entailment and RDFS entailment is well known, and the
complexity of RDF entailment follows immediately. Note that, although the set of axiomatic triples is infinite, only a finite subset, linear in the size of the graphs, needs to
be taken into account when checking entailment.

Proposition 5 ( [10, 13, 4]). Let S and E be graphs. Then, the problem of checking
S |=s E, S |=rdf E, or S |=rdf s E is NP-complete in the combined size of the
graphs, and polynomial in the size of S. If E is ground, then the respective problems
are polynomial in the combined size of the graphs.
Additionally, the problem of checking S |=erdf s E is NP-hard in the size of the graphs.

The membership proofs in [10, 13, 4] rely on the fact that the set of all (relevant) entailed triples of a given graph can be computed in polynomial time using the RDFS
entailment rules [13]; the problem can then be reduced to subgraph homeomorphism.
Using Corollary 1 and the fact that the problem of checking ground entailment in Datalog [8] is polynomial in the size of the data (tr(S)) gives to a novel argument for
membership.

NP-hardness can be shown through a reduction from a known NP-hard problem

(e.g. 3SAT).
From the embedding in F-Logic, together with the complexity of nonrecursive Datalog [8], we obtain the following novel characterization of the complexity of simple and
RDF entailment.

7 Note that, when considering a variant of DL-LiteR which allows existentials in the ABox
 also allowed in OWL DL  this restriction could be relaxed to S being a non-higher-order
RDF graph with no blank nodes outside of individual positions.

J. de Bruijn and S. Heymans

Theorem 4. Let S and E be RDF graphs. Then, the problems S |=s E and S |=rdf E
are in LogSpacein the size of S, and in the combined size of the graphs if E is ground.

Using the correspondence of Proposition 4, the results on the complexity of reasoning
in DL-LiteR [7], and the classical results on skolemization [9] we obtain the following
result for extensional RDFS entailment.

Theorem 5. Let S and E be RDF graphs with no nonstandard use of the RDFS vocabulary such that E  S. Then, the problem of deciding S |=erdf s E is NP-completein
the size of the graphs, and polynomial if E is ground.

Table 3. Complexity of Entailment S |=x E in RDF, measured in the size of S, E

Restrictions on S

Restrictions on E

|=s,|=rdf ,|=rdf s

Entailment
|=s,|=rdf
|=rdf s
|=erdf s
|=erdf s
|=erdf s

none
none
none
none

no nonst. RDFS
no nonst. RDFS

none
ground
ground
none

no nonst. RDFS

Complexity
NP-complete

LogSpace

NP-hard

NP-complete

ground, no nonst. RDFS

Table 3 summarizes the complexity of reasoning with the entailment regimes of RDF;
No nonst. RDFS stands for no nonstandard use of the RDFS vocabulary; S and E are
such that the property and class vocabularies of E are subsets of the property and class
vocabularies of S (modulo blank node renaming and instantiation); and Resource,
Class, Property, ContainerMembershipProperty and Datatype do not occur in
E. The results in the first and third line of the table were obtained in [10, 4, 13], and
the fourth line follows immediately. To the best of our knowledge, the other results are
novel.

5 Querying

In this section we consider conjunctive queries over RDF graphs using the RDF entailment regimes we considered throughout this paper.
Given a countable set V of variable symbols, disjoint from the symbols in V , a generalized RDF triple is a tuple of the form s, p, o, with s, p and o terms or variable
symbols. A conjunctive query q(x) over an RDF graph S is a set of generalized RDF
triples q(x) such that x is a vector of variables occurring in q, also called the distinguished variables of q; the blank nodes occurring in q, bl(q), are the non-distinguished
variables of q.
Given an RDF graph S and conjunctive query q(x), then a tuple of terms a is an
answer of a query under x-entailment if S |=x q(a), with x  {s, rdf, rdf s, erdf s}
an entailment regime. The complexity of query answering is related to the complexity
of the corresponding recognition problem: the recognition problem associated with a
query q(x) is the decision problem of checking whether, given an RDF graph S and
?

?

?
a tuple a of terms, the entailment S |=x q(a) holds. The data complexity of query
answering under the x entailment regime corresponds to the complexity of the corresponding recognition problem, in the size of S.

From the preceding results on the complexity of the various entailment regimes we

obtain the following characterization of the complexity of query answering.
Theorem 6. Let S be an RDF graph, let x  {s, rdf, rdf s, erdf s} be an entailment
regime, and let q(x) be a conjunctive query. Then, the data complexity of query answering under the x entailment regime is
 in LogSpace, if x  {s, rdf} and
 polynomial, if x  {rdf s}.

6 Discussion and Related Work

In this section we discuss implications of the results in this paper, and place it in the context of related work. We distinguish between work done on RDF and on RDF querying.

RDF. There have been several investigations [10, 4, 13] into the semantics of RDF.
The investigation in [10] reconstructs the semantics from a graph database perspective,
and the one in [4] reconstructs the semantics from a logical language perspective. The
investigation of the RDF semantics in [13] stays very close to the RDF specification.
Additionally, [13] shows that the entailment rules presented in the original specification [11] are not complete with respect to the semantics. These reconstructions have
led to a number of complexity results for RDF entailment. In this paper, we built upon
these results and complemented them with several novel results for simple, RDF, and
extensional RDFS entailment.

The investigation in [4] is close in spirit to our investigation, albeit that [4] bases its

logical reconstruction on (contextual) first-order logic, rather than F-Logic.

RDFS(FA) [18] defines a new (extensional) semantics for RDFS which is in line with
the semantics of OWL DL, as well as a number of syntactic restrictions to achieve a layered meta-modeling architecture. It is currently not known what the precise relationship
is between RDFS(FA) and the RDFS semantics defined in the standard [11].

Finally, we mention [17], in which the authors identify a syntactic subset of RDFS
which allows for efficient reasoning (O(n log n)), while still being expressive enough
to capture large classes of ontologies.

RDF Querying. SPARQL [22] is a query language for RDF, currently under development at W3C. Of all the RDF entailment regimes, SPARQL currently only considers
simple entailment. However, the use of other regimes is considered a possible future
extension.

The queries we considered in Section 5 are conjunctive queries and correspond to
what are called [SPARLQ] graph pattern expressions constructed by using only AND
in [20]. Therefore, not surprisingly, data complexity of conjunctive query answering
when considering simple entailment corresponds to the data complexity of evaluating
such graph pattern expressions; they are both in LogSpace (cf. Theorem 6 and [20,
Theorem 4]).

J. de Bruijn and S. Heymans

Finally we mention [21], in which a translation from SPARQL queries to Datalog
is described. The combination of such a translation with an embedding of the RDF or
RDFS semantics, as described in Theorem 1, could be used for evaluating SPARQL
queries using the respective entailment regimes.

7 Conclusions and Future Work

We have presented embeddings of the different RDF entailment regimes in F-Logic,
and we have shown how deductive database and description logic technology can be
used for reasoning with RDF. An implementation of answering conjunctive queries
over RDF graphs under the RDF and RDFS entailment regimes, and restricted RDF
graphs under the eRDFS entailment regime, based on the Datalog reasoner IRIS8, can
be found at: http://tools.deri.org/rdfs-reasoner. It is planned to extend this reasoner with support for more expressive query languages, such as SPARQL,
considering the embedding in Datalog presented in [21].

In the course of our investigation we have presented several novel complexity results.
To the best of our knowledge, ours is the first comprehensive investigation of the extensional RDFS entailment regime. These results could be used for, for example, rulebased extensions of RDF, or increasing the alignment between RDF and logic-based
semantic Web languages (e.g. OWL DL).

Our future work includes the extension of the considered embeddings with more extensive treatment of datatypes, in the form of D-entailment [11], and D*-entailment [13],
as well as more expressive query languages such as SPARQL.

Several proposals have been made for rule extensions of RDF graphs (e.g. [2,14,1]),
and several rule-based systems which deal with RDF exist (e.g. Jena, CWM). In an
earlier version of the present paper [5] we considered extensions of RDF graphs with
logical rules and axioms, based on the embeddings we have presented. However, such
extensions are not entirely faithful with respect to the model-theoretic semantics of
RDF. Therefore, our future work includes an investigation of combinations of logical
rules and RDF based on a notion of common models, i.e. an interpretation is a model
of a combination if it is a model of both the logical theory and the RDF graph.

Finally, we plan to investigate the precise relationship between eRDFS and OWL
DL entailment, taking the subset compatible with DL-LiteR (see Proposition 4) as a
starting point.
