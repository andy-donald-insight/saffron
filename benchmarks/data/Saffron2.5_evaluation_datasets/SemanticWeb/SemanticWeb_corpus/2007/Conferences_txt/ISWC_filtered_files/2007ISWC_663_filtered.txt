On the Foundations of Computing Deltas

Between RDF Models

Dimitris Zeginis, Yannis Tzitzikas, and Vassilis Christophides

Computer Science Department, University of Crete, GREECE, and

Institute of Computer Science, FORTH-ICS, Greece

{zeginis,tzitzik,christop}@ics.forth.gr

Abstract. The ability to compute the differences that exist between two RDF
models is an important step to cope with the evolving nature of the Semantic
Web (SW). In particular, RDF Deltas can be employed to reduce the amount of
data that need to be exchanged and managed over the network and hence build
advanced SW synchronization and versioning services. By considering Deltas as
sets of change operations, in this paper we study various RDF comparison functions in conjunction with the semantics of the underlying change operations and
formally analyze their possible combinations in terms of correctness, minimality,
semantic identity and redundancy properties.

1 Introduction

In order to cope with the evolving nature of the Semantic Web (SW) we need effective and efficient support for building advanced SW synchronization and versioning
services. RDF Deltas, reporting the differences that exist between two RDF models
have been proven to be crucial in order to reduce the amount of data that need to be
exchanged and managed over the network in this respect [17,18,3,8].

Although RDF models can be serialized in various text formats (e.g., XML1,
N-Triples2, Trix3), a straightforward application of existing version control systems for
software code, such as RCS [29] and CVS [4], is not a viable solution for computing
RDF Deltas. This is mainly due to the fact that RDF models, essentially represent graphs
which (a) may feature several possible serializations (since there is no notion of edge
ordering in [4]) and (b) are enriched with the semantics of RDFS specification (also
including inferred edges according to [5]). For these reasons, several non text-based
tools have been recently developed for comparing RDF graphs produced autonomously
on the SW, as for example, SemVersion [31], PromptDiff [23], Ontoview [18], [10] and
[3]. In most cases, the output of these tools is exploited by humans, and thus an intuitive
presentation of the comparison results (and other related issues) has received considerable attention. SemVersion [31] proposes two Diff algorithms: (a) one structure-based
which returns a set-based difference of the triples explicitly forming the two graphs, and
(b) one semantic-aware which also takes into account the triples inferred by the associated RDFS schemas. PromptDiff [23,24,22] is an ontology-versioning environment,

1 http://www.w3.org/TR/rdf-syntax-grammar/
2 http://www.w3.org/2001/sw/RDFCore/ntriples/
3 http://www.w3.org/2004/03/trix/

K. Aberer et al. (Eds.): ISWC/ASWC 2007, LNCS 4825, pp. 637651, 2007.
c Springer-Verlag Berlin Heidelberg 2007

D. Zeginis, Y. Tzitzikas, and V. Christophides

that includes a version-comparison algorithm (based on heuristic matchers [23,24]),
while the visualization of the computed difference between two ontologies is discussed
in [22]. Ontoview [18] is an ontology management system, able to compare two ontology versions and highlight their differences. Notably, it allows users to specify the
conceptual relations (i.e. equivalence, subsumption) between the different versions of
an ontology concept. Moreover, [10,13] introduce the notion of RDF molecules as the
finest components to be used when comparing RDF graphs (in the absence of blank
nodes each triple constitutes a molecule). Finally, tracking the evolution of ontologies
when changes are preformed in more controlled environments (e.g. collaborative authoring tools) has been addressed in [19,25,32].

However, existing RDF comparison tools have not yet focused on the size of the produced Deltas, a very important aspect for building versioning services over SW repositories [28]. In this paper we are interested in computing RDF Deltas as sets of change
operations (i.e. SW update programs) that enable us to transform one RDF model into
the other. Consider, for example, the two RDF models K and K
of Figure 1 and their
standard representation as sets of explicitly defined triples [5]: what set of change operations could transform K to K

((K  K)) or vice versa ((K  K))?

To answer this question we need to consider the semantics of the update primitives
such as Add(t) and Del(t) where t is triple involving any RDF predicate. By assuming
a side-effect free semantics for these primitives, i.e. Add(t) (resp. Del(t)) is a straightforward addition (resp. deletion) of t from the set T riples(K), K
can be obtained by
executing the following set e (e stands for explicit) of change operations:

e = {Del(T A subClassOf P erson), Del(Address domain Student),

Del(Jim type Student), Add(T A subClassOf Student),
Add(Address domain P erson), Add(Jim type P erson)}

e is actually composed of update operations over the explicit triples of K and
K
, and it is provided by the majority of existing RDF comparison tools [3,31,10].
However, by assuming side-effects (on the inferred triples not represented in Figure 1)
during the execution of the above update primitives, we can reach K
by applying on
K the following set d (d stands for dense) of change operations:

d = {Del(Jim type Student), Add(T A subClassOf Student),

Add(Address domain P erson)}

As we can easily observe, d has only three change operations in contrast to e that
has six, given that inferred triples are also taken into account for the Delta computation.
For example, Del(T A subClassOf P erson) is not included in d because it can be
inferred from K
. As we can see in Figure 1, this comparison function yields even
smaller in size operation sets than the c (c stands for closure) semantics-aware Delta
of [31]. However, d cannot always successfully transform one RDF model to another.
Returning to our example of Figure 1, d cannot be used to migrate backwards from K
to K since Del(Address domain T A) is an operation not included in d . For this
reason, we need to consider additional RDF comparison functions involving inferred
triples such as dc (dc stands for dense & closure) illustrated in Figure 1. Still the
resulting sets of operations have at most the same size as those returned by c.
?

?

?
: subClassOf

Person

Student

Literal

Address

Triples(K):

Jim

{ (Person type Class),       
(Student type Class),               
(TA type Class),               
(Student subClassOf Person), 
(TA subClassOf Person), 
(Address type Property)      
(Address domain Student),    
(Address range Literal),          
(Jim type Student) }

: property domain/range
K

?

What set of change 
operations could 
transform K to K?

Triples(K):

: type

Literal

Address

Jim

Person

Student

{ (Person type Class),        
(Student type Class),               
(TA type Class),                
(Student subClassOf Person), 
(TA subClassOf Student), 
(Address type Property),      
(Address domain Person),    
(Address range Literal),            
(Jim type Person) }

e

c

?
() =

d, dc

e

d

?
()=

{ Del(TA subClassOf Person), Del(Address domain Student),  Del(Jim type Student), 
Add(TA subClassOf Student), Add(Address domain Person), Add(Jim type Person) }

{Del(Jim type Student), Add(TA subClassOf Student), Add(Address domain Person), 
Add(Address domain TA)}
{Del(Jim type Student),  Add(TA subClassOf Student), Add(Address domain Person) }
{Del(TA subClassOf Student), Del(Address domain Person), Del(Jim type Person), 
Add(TA subClassOf Person), Add(Address domain Student), Add(Jim type Student)}
{ Del(TA subClassOf Student), Del(Address domain Person), Add(Jim type Student) }

c,dc

{ Del(TA subClassOf Student), Del(Address domain Person), Del(Address domain TA), 
Add(Jim type Student) }

Fig. 1. Transforming K to K
?

?

?
and vice versa

RDF comparison functions that yield as less as possible change operations are quite
beneficial for building SW versioning services. In particular, by advocating a changebased versioning framework [9] we can store in a SW repository only the update programs required to migrate (forward or backward) from one version to another rather
than the entire set of triples for each version. In a nutshell, storing (or exchanging)
as less as possible change operations is more space (or time) efficient. In this context,
the main questions addressed by our work are: (a) what semantics of update primitives
would make the above scenario possible (i.e. with what side-effects), and (b) how could
we compute the corresponding set of change operations (i.e. with what comparison
functions)? In response to these questions, the main contributions of this paper are:

(a) We introduce two change operations semantics: one plain set-theoretic (considers
only updates of the explicit triples) denoted by Up, and the other involves inference
and redundancy elimination of updated Knowledge Bases, denoted by Uir.

(b) We analyze four different comparison functions returning sets of changes opera-
tions, namely, explicit (e), closure (c), dense (d), and dense & closure (dc).
(c) We study which combinations of change operation semantics and comparison functions are correct and satisfy properties such as semantic identity and non redun-
dancy. It should be stressed that the combination (dc,Uir) is quite promising: (i)
it returns an empty result if K and K
are semantically equivalent (ii) the knowledge base obtained when applying dc(K  K) on K is redundancy free, and
(iii) if K
is an extension of K then it is guaranteed that the Delta that we get is
smaller than all comparison functions already proposed in the literature [3,31,10].

D. Zeginis, Y. Tzitzikas, and V. Christophides

The rest of this paper is organized as follows. Section 2 provides background information regarding RDF Knowledge Bases (KB). Section 3 introduces four RDF comparison functions, Section 4 elaborates on the change operations and their semantics,
while Section 5 shows the interplay between the two. Finally, Section 6 concludes the
paper and identifies issues for further research.

2 Background: RDF KBs

In general, an RDF Knowledge Base (KB) is defined by a set of triples of the form
(subject, predicate, object). Let T be the set of all possible triples that can be constructed
from an infite set of URIs (for resources, classes and properties) as well as literals [15].
Then a KB can be seen as a finite subset K of T , i.e. K  T . Apart from the explicitly
specified triples of a K, other triples can be inferred based on the semantics of RDF/S
[16]. For this reason, we introduce the notion of closure and reduction of RDF KBs.

The closure of a K, denoted by C(K), contains all the triples that either are explicitly
specified or can be inferred from K by taking in account the semantics of the associated
RDFS schemas. As we can view an RDF model as a graph, we could consider that
C(K) is defined (and computed) by taking the reflexive and transitive closures of binary
relations (subsumption, type)4. If it holds C(K) = K, then we will call K completed.
The elements of K will be called explicit triples, while the elements of C(K)  K will
be called inferred. We can now define an equivalence relation between two knowledge
bases.
Def. 1. Two knowledge bases K and K
C(K) = C(K).
The reduction of a K, denoted by R(K), is the smallest in size set of triples such that
C(R(K)) = C(K). In general, the reduction of a K is not necessarily unique (when
cycles occur in the subsumption relations). Let  denote the set of all knowledge bases
that have a unique reduction. Independently of whether the reduction of a K is unique
or not, we can characterize a K as (semantically) redundancy free, and we can write
RF (K) = T rue (or just RF (K)), if it does not contain explicit triples which can be
inferred from K. Formally, K is redundancy free if there is not any proper subset K
of
K (i.e. K  K) such that K  K

are equivalent, denoted by K  K

, iff

.

3 RDF KBs Deltas

In this section we formally define the four comparison functions of RDF KBs introduced in Figure 1, namely, e, c, d and dc.

e(K  K
c(K  K
d(K  K
dc(K  K
?

?

?
) = {Add(t) | t  K
) = {Add(t) | t  C(K
) = {Add(t) | t  K
) = {Add(t) | t  K

  K}

 {Del(t) | t  K  K

}
?

?

?
)  C(K)}  {Del(t) | t  C(K)  C(K
 {Del(t) | t  K  C(K
)}
 {Del(t) | t  C(K)  C(K

  C(K)}
  C(K)}
?

?

?
)}
?

?

?
)}

4 The consequence operator of logic theories (e.g. see [11]) is out of the scope of this paper.
?

?

?
e (where e stands for explicit) actually returns the triple-set difference over the explicitly specified triples, while c (where c stands for closure) returns the triple-set
difference by also taking into account the inferred triples. As we mentioned in Section
1, existing approaches (e.g. [31]) are based on e and c. However, as we are especially interested in comparison functions that yield smaller in size Deltas, we introduce
two novel comparison functions namely d (where d comes from dense) and dc (dc
comes from dense & closure). It is not hard to see that d yields smaller in size outputs
(in comparison with the previous two). Unfortunately, and as we will see at Section 5,
d cannot be used in general since only for specific cases returns correct results. For
this reason we additionally consider dc which yields smaller in size outputs than c.
This function resembles d regarding additions and c regarding deletions.
Prop. 1. Let |(K  K)| to denote the number of change operations in (K 
K). Then for any pair of valid knowledge bases K and K

it holds:

|d(K  K
|d(K  K
?

?

?
)|
)|  |e(K  K

)|  |dc(K  K
)|  |c(K  K
?

?

?
)|

We have K  C(K)  K  C(K)  K  K (1) and K  C(K)  K 
C(K)  K  K (2). From (1) and (2) it follows that |d|  |e|. The formula
for additions is the same for both d and dc. If we consider deletions we have K 
C(K)  K  C(K)  C(K)  C(K)  |d|  |dc|. Furthermore, we have
K  C(K)  K  C(K)  C(K)  C(K) (3) and K  C(K)  K 
C(K)  C(K)  C(K) (4). From (3) and (4) it follows that |d|  |c|. Finally,
the formula for deletions is the same for both c and dc. If we consider additions we
have K  C(K)  K  C(K)  C(K)  C(K)  |dc|  |c|

In a nutshell d gives always smaller in size Deltas while dc is incomparable to

e (Figure 2 shows the Hasse diagram of the ordering relation).

c

e



dc





d

Fig. 2. Ordering of Comparison Functions with respect to the size of their output

In the next section we will investigate what happens if we execute the Deltas produced by the above comparison functions under different semantics of the change update primitives Add(t) and Del(t).

4 RDF KB Change Operations Semantics

A change operation semantics defines precisely the pre and post-conditions of the operations Add(t), Del(t) where t is a triple involving any RDF predicate. In Table 1

D. Zeginis, Y. Tzitzikas, and V. Christophides

we define two alternative semantics, namely, Up (p comes from plain), and Uir (ir
comes from inference & reduction). Under Up-semantics, the execution of the operations consists of plain set theoretic additions and deletions of triples. This implies that
only the explicit triples are taken into account while inferred ones are ignored. Under Uir-semantics the execution of update primitives incurs also interesting side-effects
such as redundancy elimination and knowledge preservation. This implies that the updated KB will not contain any explicit triple which can be inferred, while preserves as
much of the knowledge expressed in K as possible (reminiscent to the postulates of the
AGM theory [2] regarding contraction, and compliant with the semantics of the RUL
update language [21]).
We first explain Uir using the example of Figure 1. If we apply on K the set d
under Uir-semantics, then we will indeed get K
. The insertion of (T A subClassOf
Student) makes the triple (T A subClassOf P erson) redundant, so the execution of
Add(T A subClassOf Student) will remove (T A subClassOf P erson) from the KB.
Analogously, the insertion of (Address domain P erson) makes the triple (Address
domain Student) redundant, while the deletion of the triple (Jim type Student) will
add the triple (Jim type P erson).
Returning to Table 1, for every operation u (of the form Add(t) or Del(t)) three
different, and mutually exclusive, pre-conditions are examined, namely t  K, t 
C(K)  K and t  C(K). The post-conditions of each case are specified. K (K
)
denotes the knowledge base before (after) the execution of an operation u. Notice that
post-conditions define exactly what K

will be5, unless the reduction is not unique.

Table 1. Two change operation semantics Up and Uir

Operation
Add(t)

Del(t)

Add(t)

Del(t)

Pre-condition

= K
= K  {t}
= K  {t}
= K  {t}
= K
= K

Change Operation Semantics Up
Post-condition
1 t  K

2 t  C(K)  K K
3 t  C(K)

4 t  K

5 t  C(K)  K K
6 t  C(K)

7 t  K

8 t  C(K)  K K
9 t  C(K)

10 t  K

11 t  C(K)  K K
12 t  C(K)

Change Operation Semantics Uir
?

?

?
Comment
void
addition (although already inferred)
addition
deletion
an inferred triple cannot be deleted
void

void
it is already inferred so it is ignored
addition and then reduction

= K
= K
= R(K  {t})
= R(C(K)  {t}) deletion from closure and then reduction
= K
= K

an inferred triple cannot be deleted
void

In particular, let t be the triple whose addition is requested. If t  K, then under
both Up and Uir semantics no change will be made i.e. K = K (recall that K is a set
of triples). If t  C(K)  K, then under Up-semantics, K
will indeed contain that
triple however, under Uir-semantics we will have K = K because every triple that
5 One could consider the rows of Table 1 as ECA rules where the Events correspond to column
Operation, the Conditions correspond to column Pre-Condition and the Actions correspond to column Post-condition.
?

?

?
will not contain t under Up-semantics. Under Uir, K

exists at C(K)  K can be inferred (and Uir aims at redundancy-free KBs). Finally,
when requesting the addition of a triple t  C(K) under Up, K
will contain that triple.
Under Uir, K
will contain the triples that remain after adding t to K and eliminating
the redundant triples (i.e. those that can be inferred).
Let us now consider that the deletion of a triple t is requested. If t belongs to K,
then K
will contain the triples
that remain after deleting t from C(K) and eliminating the redundant triples (note that
C(K) is used in order to preserve as much knowledge as possible). Now if t  C(K)
K, then this request is ignored under both semantics. This means that in both semantics,
only explicit triples can be deleted. This relieves us from having to decide which of the
(possibly several) policies to adopt for reaching a K
whose closure does not contain t.
Finally, if t  C(K), then nothing happens as t is already out of K.
Let S be the set of all possible operations of the form Add(t), Del(t) where t  T .
Let S be a finite subset of S (i.e. S  S). If U is a symbol that denotes the semantics of
a particular change operation (i.e. Up,Uir), then we will use SU(K) to denote the result
of applying S to K under U semantics. Notice that the result of applying an operation
is unique under Up-semantics. This is true also for Uir if we are in  (KBs with unique
reduction).
Two sets of change operations S and S
S U S

Now we introduce some notions regarding sets of change operations (based on [30]).
are universally equivalent under U, denoted by

, iff SU(K)  SU(K) for every possible knowledge base K.

For computing change-based Deltas we need a less strong notion of equivalence

S

are equivalent over a given K under U, denoted by S U

(analogously to transaction equivalence [1]).
Def. 2. S and S
SU(K)  SU (K).
In order to elaborate on cases where the order of execution of the update operations
affects the final result, we introduce the following notion of satisfaction.
Def. 3. We will say that K satisfies: (a) an operation Add(t), iff t  C(K), (b) an
operation Del(t), iff t  C(K) and (c) a set of change operations S (where S  S) if
K satisfies every element of S.
If the resulting KB does not satisfy S, then we will write S(K) = E where E is a special symbol indicating that an error occurred. In the sequel, and for reasons of brevity,
whenever we write S(K) we will also mean that S(K) = E.

, iff

5 Comparison Functions and Change Operation Semantics

In this section we investigate which of the four comparison functions (introduced in
Section 3) and under what semantics of update primitives (presented in Section 4) could
be used for building a change-based versioning system. To this end, we have to define
formally the notions of correctness, semantic identity and redundancy, and then elaborate on the execution of the update programms. Finally, we will identify these pairs that
are correct and the properties that they satisfy.

D. Zeginis, Y. Tzitzikas, and V. Christophides

5.1 Correctness, Semantic Identify and Non Redundancy of RDF Deltas
Let x be a comparison function, and Uy be a change operation semantics.
Def. 4. A pair (x,Uy) is correct if for any pair of knowledge bases K and K
x(K  K)Uy (K)  K
Obviously, a pair (x,Uy) can be used for versioning services only if it is correct. Apart
from correctness, a pair (x,Uy) may also satisfy the following properties.
(P1)

then x(K  K) = 

, it holds

.

If K  K
(semantic identity)
It is desirable to have a comparison function that reports an empty result if its
operands are equivalent.
The resulting KB is always redundancy free (i.e. for any K and K
If K
(P2): if (P2) holds then (P2.1) holds too.

(P2) RF (x(K  K)Uy(K))
(P2.1) If RF (K) then RF (x(K  K)Uy(K))

is RF then the resulting KB is also RF. Note that (P2.1) is weaker than

(non redundancy)

).

5.2 Executing (or Satisfying) RDF Deltas

Def. 4 presupposes that we have at our disposal an appropriate execution mode such
that when we apply x(K  K) in K, and according to the selected semantics,
the resulting KB will satisfy every element of x(K  K). Of course, the above
premise requires that the set S does not contain contradictions i.e. it does not contain both Add(t) and Del(t) for a given t. This is true for the comparison functions
e, c, d, dc. However, this is not the only technical problem we have to address.
The order of execution of the change operations may affect the resulting KB, in
particular the resulting KB may not satisfy all change operations returned by a comparison function (see Def. 3). For instance, for the KBs of Table 2 (d) we get dc(K 
K) = {Del(A subClassOf D), Del(B subClassOf D), Del(C subClassOf D)}. If
the operations are executed in the order Del(A subClassOf D), Del(B subClassOf
D), Del(C subClassOf D) under Uir semantics, then all of them will be satisfied
and the result will be equivalent to K. Now consider the following execution order
Del(B subClassOf D), Del(C subClassOf D), Del(A subClassOf D). In this case
the operation Del(B subClassOf D) does not change the K as it requests the deletion of an inferred triple and according to Uir semantics an inferred triple cant be
deleted. The same will happen with the operation Del(C subClassOf D). Finally, the
operation Del(A subClassOf D) will be executed and will cause the addition of the
triple (B subClassOf D). It is obvious that the operation Del(B subClassOf D) is
not satisfied by the resulting KB because it contains the triple (B subClassOf D)
i.e. dc(K  K)Uir = E. We have just seen an example where the order of execution matters. The same problem occurs when K
contains a redundant triple e.g.
(B subClassOf D). A similar situation is encountered with c and with d when K
and K

are not redundancy free.

To avoid nondeterminism and to ensure correctness, we need an execution semantics
of change operations (comprised in Deltas) that guarantees their satisfaction (if this is
?

?

?
possible). This can be achieved by: (a) defining comparison functions that return sequences (not sets) of change operations which guarantee satisfaction of their elements,
or by (b) using a multi-pass execution mode that guarantees that all change operations
will eventually be satisfied. Below we elaborate on the (b) approach. We could use a
loop-based algorithm which terminates when every operation returned by a comparison
function is satisfied.
Alg 1. Execute(K, M , sem) where M  S, sem  {Up,Uir}
(1) repeat
(2) get an element u  M that is not satisfied by K
(3) Kt = usem(K) // i.e. apply on K the appropriate post-conditions of u wrt sem
(4) K = Kt
(5) until {u  M|u not satisfied by K} = 

In this context, we have to prove that the execution algorithm always terminates (if
M has been derived from one of e, c, d, dc). It is clear that the loop always terminates for the case of (e,Up) because it yields operations that are always satisfiable.
So we only have to study d, c and dc underg Uir-semantics.
Let Y be the satisfiable deletions and Z the unsatisfiable deletions at any point during
the execution of the algorithm. If we prove that whenever |Y | = 0 we also have |Z| = 0
then we prove that our algorithm always terminates since all elements of M are satisfied.
Both c and dc produce the following set of delete statements: X = { Del(t) |
t  C(K)  C(K) }. An element Del(t) will be satisfied if t  R(K). So the set
Y , i.e. the satisfiable deletions of X, is defined as Y = R(K)  (C(K)  C(K)) =
R(K)  C(K). Lets now define Z. Recall that a Del(t), may not be satisfied (when
applied to K) only if t  C(K) R(K). So the set Z, i.e. the unsatisfiable deletions of
X, is defined as Z = (C(K)R(K))(C(K)C(K)) = C(K)(R(K)C(K)).
Lets now investigate whether |Y | = 0  |Z| = 0 holds. At first, notice that Y =
  R(K)  C(K) =   R(K)  C(K). Also note that R(K)  C(K) 
C(K)  C(K). This is based on the properties of the closure operator: if we have two
sets A and B such that A  B and B is closed with respect to the closure operator C
(i.e. C(B) = B), then C(A)  B.
Returning to our problem, if Y =  (that is if R(K)  C(K)), then the formula
Z = C(K)  (R(K)  C(K)) is equivalent to Z = C(K)  C(K). But above we
have seen that Y =   C(K)  C(K) too. It follows that Z = . So the algorithm
always terminates.
The above is actually the proof of the proposition: If |R(K)  C(K)| = 0 then
|C(K)  (R(K)  C(K))| = 0.

The proof for d is similar.

5.3 Identifying the Correct (x, Uy)-pairs
For identifying the pairs that are correct, Table 2 depicts 6 examples. For each example,
it shows the result of applying d, c, e and dc for both K  K
and K  K,
and contains the following columns:
 Up Co: If Y then this means that x(K  K)Up(K)  K
correct. Otherwise the cell is marked with N.

, i.e. the approach is

D. Zeginis, Y. Tzitzikas, and V. Christophides

Table 2. Examples

K

K

(a) Tree and Chain

K

(b) Chain and
Rooted DAG

P1

P1

K

(d) Forest and Chain (e) Chain and Property

Domain

K

(c) Tree and DAG

P1

K

P1

(f) Tree and
Property
Domain

Del(C subClassOf A)}

Del(C subClassOf B)}

Up Up Uir K  K
Co RF Co
Y Y Y {Add(C subClassOf A),

(a) Tree and Chain
Delta K  K
Up Up Uir
Co RF Co
e {Add(C subClassOf B),
Y Y Y
c {Add(C subClassOf B)} Y N Y {Del(C subClassOf B)} N Y Y
d {Add(C subClassOf B)} Y N Y {Del(C subClassOf B)} N Y Y
dc {Add(C subClassOf B)} Y N Y {Del(C subClassOf B)} N Y Y
(b) Chain and Rooted DAG
e {Add(C subClassOf A),
Add(D subClassOf B),
Del(C subClassOf B)}

Y Y Y {Add(C subClassOf B),
Del(C subClassOf A),
Del(D subClassOf B)}

c {Del(C subClassOf B)} N Y Y {Add(C subClassOf B)} Y N Y
d {Del(C subClassOf B)} N Y Y {Add(C subClassOf B)} Y N Y
dc {Del(C subClassOf B)} N Y Y {Add(C subClassOf B)} Y N Y
(c) Tree and DAG
e {Add(C subClassOf D),
c {Del(A subClassOf D),
Y N Y
d {Del(A subClassOf D)} N Y N {Add(A subClassOf D)} Y N Y
dc {Del(A subClassOf D),
N Y Y {Add(A subClassOf D)} Y N Y

Y Y N {Add(A subClassOf D),
Del(C subClassOf D)}
N Y Y {Add(A subClassOf D),
Add(B subClassOf D)}

Del(A subClassOf D)}
Del(B subClassOf D)}

Del(B subClassOf D)}

Y Y Y

Y Y Y

(d) Forest and Chain
e {Add(A subClassOf D)} Y Y Y {Del(A subClassOf D)} Y Y N
c {Add(A subClassOf D),
Y Y Y
Add(B subClassOf D),
Add(C subClassOf D)}

Y N Y {Del(A subClassOf D),
Del(B subClassOf D),
Del(C subClassOf D)}

d {Add(A subClassOf D)} Y Y Y {Del(A subClassOf D)} Y Y N
dc {Add(A subClassOf D)} Y Y Y {Del(A subClassOf D),
Y Y Y
Del(B subClassOf D),
Del(C subClassOf D)}

(e) Chain and Property Domain
e {Add(B, P1, C),
Del(A, P1, C)}
c {Del(A, P1, C)}
d {Del(A, P1, C)}
dc {Del(A, P1, C)}
(f) Tree and Property Domain
e {Add(C, P1, E),
Del(A, P1, E)}
c {Del(A, P1, E),
Del(B, P1, E)}
d {Del(A, P1, E)}
dc {Del(A, P1, E),
Del(B, P1, E)}

Y Y Y {Add(A, P1, C),
Del(B, P1, C)}
N Y Y {Add(A, P1, C)}
N Y Y {Add(A, P1, C)}
N Y Y {Add(A, P1, C)}
Y Y N {Add(A, P1, E),
Del(C, P1, E)}
N Y Y {Add(A, P1, E),
Add(B, P1, E)}
N Y N {Add(A, P1, E)}
N Y Y {Add(A, P1, E)}

Y Y Y

Y N Y
Y N Y
Y N Y

Y Y Y

Y N Y

Y N Y
Y N Y
?

?

?
 Up RF: If Y then this means that the application of these changes results in a redundancy free K. Formally Y iff RF (x(K  K)Up(K))). Otherwise the cell
is marked with N.
 Uir Co: If Y then this means that x(K  K)Uir (K)  K
correct. Otherwise the cell is marked with N.

i.e the approach is

In all cases we assume that the KBs are redundancy free. We do not have a column
Uir RF because by definition the execution of a Uir-operation leaves the knowledge
base in a redundancy free state. Those pairs that have a N in the cells that concern
correctness, constitute a proof (by counterexample) that they are not correct. For the
rest pairs (those with a Y) we have to prove that they are always correct.
Theorem 1. For any pair of valid knowledge bases {K, K}   it holds:

c(K  K

Uir (K)  K
)

is an additional ontology O

Up(K)  dc(K  K
)
iff {K, K}   and either: (a) K is com-

Uir(K)  e(K  K
)
Theorem 2. d(K  K)Uir(K)  K
plete, or (b) C(K)  K  C(K).
Due to space limitations the proof of the above theorems is omitted. An interesting remark regarding Th. 2 is that if C(K)  C(K), then condition (b) holds. This means
that we could use the pair (d,Uir) in cases we know that C(K)  C(K). For example if K is an ontology O and K
that specializes O, then
we are sure that C(K)  C(K). In such cases we can use d (or alternatively dc)
which give the smallest in size Deltas (dc returns the same Deltas).
5.4 Semantic Identify and Non Redundancy Properties of (x, Uy)-Pairs
then d(K  K) = c(K  K) = dc(K  K) = .
Prop. 2. If K  K
This is property (P1) and its proof is trivial. Note that e is not included in Prop. 2
because even if K  K
and K 
K. In the example of Figure 3 (a) we get e(K  K) = {Add(C subClassOf A)}
although K  K
. It should be stressed that most of the existing comparison functions
[3,31,10] actually employ e, so they do not satisfy (P1).
are both redundancy free, and
the knowledge bases considered have always a unique reduction, then K  K 
e(K  K) = . In general, if the transitive closure of a binary relation R is antisymmetric and finite, then the transitive reduction of R is unique. In the problem at

However, one can easily prove that: If K and K

, it may be K = K

, K  K

, K  K, or K  K

K

(a)

K1

K2

(b)

Fig. 3. K, K
?

?

?
D. Zeginis, Y. Tzitzikas, and V. Christophides

hand, if an RDF knowledge base allows forming cycles with subsumption relation-
ships, then the transitive reduction is not unique. For example, in Figure 3 (b) we have
K  K1  K2, moreover RF (K1), RF (K2), but K1 = K2.
Prop. 3. If K  K

, {K, K}   and RF (K), RF (K) then e(K  K) = 

5.5 Summarizing the Results
The pairs that are always correct are: (c,Uir), (e,Up) and (dc,Uir). The pair
(c,Up) is correct if K is complete. The pair (d,Uir) is correct in the cases specified
in Theorem 2. The set of change operations derived from either c or dc need the
multi-pass execution mode while e requires a single pass execution mode. Concerning the size criterion, d produces the smallest in size result. dc produces smaller
results than c. Concluding, we can say that the pairs (dc,Uir) and (e,Up) are the
most appropriate for implementing change-based versioning services: they are always
correct and the size of dc is less than c. We cannot however compare the size of
e with that of dc (in some cases the first is smaller, in others the second). Table 3
synopsizes the results. Concerning the column labeled Execution Mode, S is used to
denote single pass, and M to denote multi pass.
It is worth mentioning that (e,Up) is correct even if we are not in . Moreover,
Theorem 1 holds even if we are not in  but we adopt a batch execution mode for Uir,
where each change operation is not executed independently but all change operations of
the produced Delta are executed as one transaction, i.e. we compute the closure and
the reduction only once.

Table 3. Synopsis

Comp. Sem. Always Correct Exec Mode (P1)
e
c
d
dc
e
c
d
dc

Up
?

?

?
Up
Y if K complete S
Up

Up

Uir N
Uir Y in 
Uir
Uir Y in 

(see Theorem 2) M

(P2) (P2.1)
?

?

?
see (Prop. 3) N Y
?

?

?
see (Prop. 3) Y Y
Y Y

Y Y
?

?

?
Y Y

6 Concluding Remarks

One approach for computing the difference between two RDF models is to take the difference between the sets of triples forming the two models (along with some
refinements such as taking into account blank nodes). Another approach (useful for
?

?

?
versioning) is to identify a set of change operations that will transform one model into
the other. In this paper we investigated the second approach and studied different semantics for this computation as well as properties like minimality and correctness of
the produced Deltas. Most of the existing RDF comparison tools [3,31,10] rely on the
(e,Up) pair. Semversion [31] offers also (c,Up) for the case where the K is complete (we have proved that in such cases this approach yields correct results). None of
the works (theoretical or practical) has used d or dc. Recall that we have shown that
(dc,Uir) is better than (c,Up) not only because (dc,Uir) does not require the KBs
to be complete, but also because it returns smaller in size Deltas. We have identified the
cases where (d,Uir) is beneficial (recall that d gives the minimum in size Deltas).
An issue for further research is to identify the conditions under which e yields smaller
Deltas than dc and vice versa.

In comparison with belief contraction-revision (e.g. [14,20,11]), these theories consider KBs as logic theories and focus on what the result of applying a contraction/
revision operation on a KB should be. In our setting, the destination KB is known, i.e.
it is K

, so the focus is given on the transition from K to K6.

We plan to exploit the properties of the various Delta functions presented in this
paper for building versioning services on top of SW repositories [28]. For reasons of
space, technical details, as well as issues regarding the peculiarities of RDF including
blank nodes identification, and containers (Bag, Sequence, Alternative) are omitted7.
An important implementation issue that is worth mentioning is that the algorithm implementing the Delta functions never computes the closure of a KB. Instead, it constructs
the explicit graph of each KB, and then it checks whether t  C(K) which can be
decided efficiently (in O(1)), thanks to a labeling scheme [7] for subsumption relationships that is supported by RDFSuite [12]. Concerning the execution of Uir operations,
related algorithms include [26], while a similar in spirit approach for RDF has already
been implemented for the RUL language [21].

Acknowledgements. This work was partially supported by the EU projects CASPAR
(FP6-2005-IST-033572) and KP-Lab (FP6-2004-IST-4).
