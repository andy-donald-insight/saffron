Conjunctive Queries for a

Tractable Fragment of OWL 1.1

Markus Krotzsch, Sebastian Rudolph, and Pascal Hitzler

Institut AIFB, Universitat Karlsruhe, Germany

Abstract. Despite the success of the Web Ontology Language OWL, the development of expressive means for querying OWL knowledge bases is still an
open issue. In this paper, we investigate how a very natural and desirable form
of queriesnamely conjunctive onescan be used in conjunction with OWL
such that one of the major design criteria of the latternamely decidabilitycan
be retained. More precisely, we show that querying the tractable fragment 
of OWL 1.1 is decidable. We also provide a complexity analysis and show that
querying unrestricted  is undecidable.

1 Introduction

Conjunctive queries originated from research in relational databases [1], and, more re-
cently, have also been identified as a desirable form of querying expressive description
logics (DLs) that are underlying OWL [2,3,4,5,6]. At the same time, tractable fragments
of OWL are receiving increasing attention as they promise to provide a favourable balance between expressivity and scalability. Such fragments have, in particular, been identified as part of the OWL 1.1 proposal,1 and this raises the question how conjunctive
queries can be combined favourably with the underlying description logics.

In this paper, we thus present the very first algorithm for answering conjunctive
queries in the tractable -fragment of 		 [7,8], and thus of OWL 1.1. The
algorithm is based on an automata-theoretic formulation of complex role inclusion axioms that was also found useful in reasoning with 		 [9,10].

Our algorithm in particular allows us to derive a number of complexity results related to conjunctive query answering in . We first show that conjunctive queries
in  are undecidable in general, and identify the -fragment of 		 as
an appropriate decidable sub-DL. Under some related restrictions of role inclusion ax-
ioms, we show that conjunctive query answering in general is PS-complete. Query
answering for fixed knowledge bases (query complexity) is shown to be NP-complete,
whereas for fixed queries (schema complexity) it is merely P-complete.

2 Preliminaries

We assume the reader to be familiar with the basic notions of description logics (DLs).
The DLs that we will encounter in this paper are  [7] and, marginally, 		

 This work has been supported by the European Commission under contract IST-2006-027595

NeOn, and by the Deutsche Forschungsgemeinschaft (DFG) under the ReaSem project.

1 See 
 for both.

K. Aberer et al. (Eds.): ISWCASWC 2007, LNCS 4825, pp. 310323, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
[10]. A DL signature consists of a finite set of role names R, a finite set of individual
names I, and a finite set of concept names C. We will use this notation throughout the
paper.  supports nominals, which we conveniently represent as follows: for any
a  I, there is a concept a  C such that a	  a	 (for any interpretation 	).
As shown in [7], any  knowledge base is equivalent to one in normal form, only
containing the following axioms:

TBox: A  C
RBox: R  T

A 	 B  C
R  S  T

A  RC

RA  C

where A, B  C  , C  C  , and R, S , T  R. Note that ABox statements of
the forms C(a) and R(a b) are internalised into the TBox. The standard model theoretic
semantics of  can be found in [7]. Unless otherwise specified, the letters C, D, E
in the remainder of this work always denote (arbitrary) concept names, and the letters
R, S denote (arbitrary) role names. We do not consider concrete domains in this paper,
but are confident that our results can be extended accordingly.

For conjunctive queries, we largely adopt the notation of [6] but directly allow for
individuals in queries. Let V be a countable set of variable names. Given elements x,
y  V  I, a concept atom (role atom) is an expression C(x) with C  C (R(x y) with
R  R). A conjunctive query q is a set of concept and role atoms, read as a conjunction
of its elements. By Var(q) we denote the set of variables occurring in q. Consider an
interpretation 	 with domain 		, and a function  : Var(q) I  		 such that (a)  a	
for all a  I. We define

	   C(x) if (x)  C	,

and

	   R(x y) if ((x) (y))  R	.

If there is some  such that 	   A for all atoms A  q, we write 	  q and say that
	 entails q. We say that q is entailed by a knowledge base KB, denoted KB  q, if all
models of KB entail q.

We conclude this section with an important result on conjunctive queries in .

Theorem 1. For an  knowledge base KB and a conjunctive query q, the entailment problem KB  q is undecidable. Likewise, checking class subsumptions in 
extended with inverse roles or role conjunctions is undecidable, even if those operators
occur only in the concepts whose subsumption is checked.

Intuitively, the result holds since RBoxes can encode context-free languages, the intersection of which can then be checked with conjunctive queriesinverse rolesrole con-
junctions. This problem is undecidable (see [11] for a proof). Clearly, arbitrary role
compositions are too expressive when aiming for a decidable (or even tractable) logic
that admits conjunctive queries. We thus restrict our attention to the fragment of 
that is in the (decidable) description logic 		 [10], and investigate its complexity
with respect to conjunctive query answering.

Definition 1. An  RBox in normal form is regular if there is a strict partial order
 on R such that, for all role inclusion axioms R1  S and R1  R2  S , we find Ri  S
or Ri  S (i  1 2). An  knowledge base is regular if it has a regular RBox.

The existence of  ensures that the role hierarchy does not contain cyclic dependencies
other than through direct recursion of a single role.

M. Krotzsch, S. Rudolph, and P. Hitzler

Table 1. Closure rules for an interpretation 	 w.r.t. some knowledge base KB. In general, we
assume that C D  C    and R1 R2 S  R.

(1)

  C 	

KB  C  D

D	  D	  

  C 	

KB  C  RD

(2)

		  		  

R	  R	  ( )

KB  D  a for any a  I
D	  D	  

where   CRD

(3)

  C 	

KB  C  RD

KB  D  a for some a  I

R	  R	  ( a)

(4)

( )  R	

R  S  KB

S 	  S 	  ( )

( )  R	

(5)

( )  R	

S 	  S 	  ( )

R1  R2  S  KB

3 Canonical Models and Reasoning Automata for 

, like all Horn-DLs, allows for the construction of canonical or universal models.
By this we mean an interpretation that is in a sense most general among the models
of a given  knowledge base, satisfying exactly those formulae that are logical
consequences of the knowledge base. This notion could be formalised further (using the
concept of (bi)simulation between models), but we merely require canonical models to
guide us in the development and verification of a query answering algorithm, and hence
we will confine ourselves to directly showing the relevant properties.

Consider a regular consistent  knowledge base KB. Here and in the following,
we assume w.l.o.g. that KB does not entail a  b (i.e. a  b) for any a, b  I. Indeed,
one can just replace all occurrences of b with a in this case, both within KB and within
any query we wish to consider later on (and this case can be detected in polynomial
time). Moreover, we assume that there is at least one individual in the language, i.e.
I  . We now provide an iterative construction of a model 	 of KB. Our goal is to
obtain a concise definition of a suitable canonical model, so it is no matter of concern
that the given construction does not terminate after finitely many steps.

To simplify our arguments, we adopt a naming scheme for potential elements of the
domain of 	. Let 	 be the smallest set such that I  	 and, for any   	, C, D  C,
and R  R, we find that CRD  	. We will define 	 such that 		  	.

For any two interpretations 
1 and 
2 of KB, we say that 
1 is smaller than (or
equal to) 
2 if, for any F  C  R  , F 
1  F 
2. The interpretation 	 is defined to
be the smallest interpretation such that 		  	, a	  a for all a  I, and 	 is closed
under the rules of Table 1. It is easy to see that this smallest interpretation exists.

The rules of Table 1 have the special property that each individual is initialised
with at most one concept name. Formally, we define for each element   		 a concept
name () as follows:

 if   I, ()  ,
 if    CRD for some   		, C, D  C, R  R, then ()  D.

Note that the above cases are indeed exhaustive and mutually exclusive.
?

?

?
Lemma 1. The interpretation 	 as constructed above is a model of KB.

Proof. First note that the domain of 	 is non-empty since we assume the existence of
at least one individual. We have to check that all axioms of KB are indeed satisfied. For
axioms of the form C  RD this is obvious by rules (2) and (3) of Table 1. Similarly,
all role inclusion axioms are directly accounted for by rules (4) and (5).

So it remains to show that axioms  of the forms C  D, RC  D, and C1 	C2  D
are satisfied. Obviously, whenever   C	 (  RC	) for some C  C (and R  R),
we find KB  ()  C (KB  ()  RC). We conclude that, whenever the premise of
some axiom  as above is satisfied for , then it is entailed by (), and so its conclusion
D is a direct consequence of () under KB. Thus  is satisfied by rule (1).
	

We are most interested in the specific structure of the canonical model. Its construction
attempts to preserve a form of tree-likeness, broken only by the potential occurrence of
nominals. Formally, this is expressed through the following property.
Property 1. For any element   		 that is not an individual (  I), there is a unique
chain of elements 0    k   and role names R0, . . . , Rk1  R, such that 0  I and,
for all i  1     k, i  		 is of the form CRD with   i1 and R  Ri1. This
is easily verified by observing that any  of the given form must have been entailed by
rule (2), and by applying a simple induction on the depth of this entailment. In this case,
we say that i generates  via the roles Ri    Rk (i  0     k).
The canonicity of the model 	 manifests itself in the fact that structures in the model
are necessary logical consequences of given axioms.
Property 2. Consider elements ,   		 such that  generates  via the roles R0    Rk.
Then ()  R0(   Rk()   ) is a consequence of KB. This is obvious by another
simple inductive argument that utilises the preconditions of the applications of rule (3).
Property 3. For any ( )  R	, there is a chain of elements   0    k   and role
names Ri (i  0     k  1), such that

 (i i1)  R	
i
 R0      Rk1  R is a consequence of KB.

is directly entailed by one of rules (2) and (3), and

1 and ( j )  R	

We show this by an inductive argument as follows: for the base case, assume that
( )  R	 follows from rule (2) or (3). Then the above condition clearly holds. For the
induction step, assume that ( )  R	 follows by applying rule (5) to R1  R2  R, and
that the claim holds for the statements (  j)  R	
2 . We easily can construct from these assumptions a suitable chain of elements from the chains postulated
for R1 and R2. Similarly, the second condition of the claim follows from the assumption
that R1  R2  R and the induction hypothesis. Rule (4) is treated analogously.
In the remainder of this section, we investigate various means of presenting logical
inferences by means of automata. These encodings will play a major role within our
subsequent query answering algorithm. We describe nondeterministic finite automata
(NFA)  as tuples (Q   i F), where Q is a finite set of states,  is a finite
alphabet,  : Q 
 Q  2 is a transition function that maps pairs of states to sets
of alphabet symbols,2 i is the initial state, and F is a set of final states.
2 A possibly more common definition is to map pairs of states and symbols to sets of states, but

the above is more convenient for our purposes.

M. Krotzsch, S. Rudolph, and P. Hitzler

Table 2. Completion rules for constructing an NFA from an  knowledge base KB

(CR1) If C   (C C), C   D  KB, and D  (C C) then (C C)  (C C)  D.
(CR2) If C1 C2  (C C), C1 	 C2  D  KB, and D  (C C) then (C C)  (C C)  D.
(CR3) If C   (C C), C   RD  KB, and R  (C D) then (C D)  (C D)  R.
(CR4) If R  (C D), D  (D D), RD  E  KB, and E  (C C) then (C C) 

(C C)  E.

(CR5) If R  (C D),   (D D), and   (C C) then (C C)  (C C)  .
(CR6) If a  (C C)  (D D), and there are states C1     Cn such that

 C1  C  A  b  b  I,
 (C j C j1)   for all j  1     n  1,
 Cn  D,

and (D D)  (C C) then (C C)  (C C)  (D D).

(CR7) If R  (C D), R  S , and S  (C D) then (C D)  (C D)  S .
(CR8) If R1  (C D), R2  (D E), R1  R2  S , and S  (C E) then (C E)  (C E)  S .

Proposition 1. Given a regular  RBox, and some role R  R, there is an NFA
(R) over the alphabet R which accepts a word R1    Rn i R1      Rn  R is a
consequence of every  knowledge base with the given RBox.

One possible construction for the required automaton is discussed in [10]. Intuitively,
the RBox can be understood as a grammar for a regular language, for which an automaton can be constructed in a canonical way. The required construction of (R) might
be exponential for some RBoxes. In [9], restrictions have been discussed that prevent
this blow-up, leading to NFA of only polynomial size w.r.t. the RBox. Accordingly, an
RBox is simple whenever, for all axioms of the form R1  S  S , S  R2  S , the RBox
does not contain a common subrole R of R1 and R2 for which there is an axiom of the
form R  S   R or S   R  R. We will usually consider only such simple RBoxes
whenever the size of the constructed automata matters.

Next we describe the construction of a novel kind of automaton that encodes certain concept subsumptions entailed by an  knowledge base. The automaton itself
is closely related to the reasoning algorithm given in [7], but the representation of entailments via nondeterministic finite automata (NFA) will be essential for the query
answering algorithm in the following section.

Consider an  knowledge base KB. Given a concept name A  C, we construct
an NFA KB(A)  (Q   i F) that computes superconcepts of A, where we omit the
subscript if KB is clear from the context. Set Q  F  C  ,   C  R   ,
and i  A. The transition function  is initially defined as (C C)  C  (for all
C  Q) and (C D)   (for all C D  Q with C  D), and extended iteratively by
applying the rules in Table 2. The rules correspond to completion rules in [7, Table 2],
though the conditions for (CR6) are slightly relaxed, fixing a minor glitch in the original
algorithm.

It is easy to see that the rules of Table 2 can be applied at most a polynomial number
of times. The words accepted by (A) are strings of concept and role names. For each
such word w we inductively define a concept expression Cw as follows:
?

?

?
 if w is empty, then Cw  ,
 if w  Rv for some R  R and word v, then Cw  R(Cv),
 if w  Cv for some C  C and word v, then Cw  C 	 Cv.

For instance, the word CRDES translates into CCRDES  C 	 R(D 	 E 	 S ). Based
on the close correspondence of the above rules to the derivation rules in [7], we can
now establish the main correctness result for the automaton (A).

Theorem 2. Consider a knowledge base KB, concept A, and NFA (A) as above, and
let w be some word over the associated alphabet. Then KB  A  Cw i one of the
following holds:

 (A) accepts the word w, or
 there is a transition   (C C) where C  , C  A, or C  a for some

individual a.

In particular, (A) can be used to check all subsumptions between A and some atomic
concept B.

The second item of the theorem addresses the cases where A is inferred to be empty
(i.e. inconsistent) or where the whole knowledge base is inconsistent, from which the
subsumption trivially follows. While the above yields an alternative formulation of the
 reasoning algorithm presented in [7], it has the advantage that it also encodes
all paths within the inferred models. This will be essential for our results in the next
section. The following definition will be most convenient for this purpose.

Definition 2. Consider a knowledge base KB, concepts A, B  C, and the NFA (A) 
(Q   i F). The automaton KB(A B) (or just (A B)) is defined as (Q R  i F )
where F    if   (A A) and F   B otherwise, and  is the restriction of  to R.

The automaton (A B) normally accepts all words of roles R1     Rn such that A 
R1(   RnB   ) is a consequence of KB, with the border case where n  0 and KB 
A  B. Moreover, the language accepted by the NFA is empty whenever A   has
been inferred.

4 Deciding Conjunctive Queries for 

In this section, we present a nondeterministic algorithm that decides the entailment of
a query q with respect to some regular consistent knowledge base KB. The algorithm
constructs a so-called proof graph which establishes, for all interpretations 	 of KB, the
existence of a suitable function  that shows query entailment. Intuitively, a proof graph
encodes a fragment of the canonical model 	 of Section 3.

Formally, a proof graph is a tuple (N L E) consisting of a set of nodes N, a labelling
function L : N  C  , and a partial transition function E : N 
 N  A, where A
is the set of all NFA over the alphabet C     R. A node m  N is reachable if
there is some node n  N such that E(n m) is defined, and unreachable otherwise. The
nodes of the proof graph are abstract representations of elements in the domain of the

M. Krotzsch, S. Rudolph, and P. Hitzler

Table 3. A nondeterministic algorithm for deciding conjunctive queries in 

A. Query

factorisation

1 Select a (possibly empty) set X  Var(q)
2 For each x  X

Select some e  Var(q)  I and replace all occurrences of x in q with e

B. Initialise proof 4 N  I  Var(q), let E be undefined for all arguments

graph (N L E) 5 For each a  I, L(a)  a

6 For each x  Var(q), select L(x)  C  
7 For each n  N, a  I, E(n a)  (L(n) L(a))
8 While there is an unreachable node
?

?

?
11 For each n  N, m  Var(q)

Select some unreachable x  Var(q), select some reachable n  N
E(n x)  (L(n) L(x))

If E(n m) is defined and accepts no word, terminate with failure

C. Check proof

graph

D. Check concept 13 For each concept atom C(n)  q

If not KB  L(n)  C, terminate with failure

entailment
E. Split role
automata

F. Check role
entailment

Compute shortest path n  n0     nk  m from n to m
Split (R) into k automata (R(n m) n0 n1)     (R(n m) nk1 nk)
For each (R(n m) ni1 ni)

If (R(n m) ni1 ni) accepts no word, terminate with failure

15 For each role atom R(n m)  q
?

?

?
20 acc  	
21 For each n, m  N with E(n m) defined
?

?

?
29 If acc is , then terminate with failure
30 Else accept the query

acc  
Else if m  Var(q)

For each split automaton (F n m)

acc  

If m  I

If (F n m) and E(n m) do not accept a common word

If no word is accepted by E(n m) and all split automata (F n m)

canonical model 	 of KB. The labels assign a concept to each node, the intuition being
that this is the main concept () defined in Section 3. Finally, the transition function
encodes role paths in the canonical model, which provide the basis for inferencing about
relationships between elements. It would be possible to adopt a more concrete representation for role paths (e.g. by guessing a single path), but our formulation reduces
nondeterminism and eventually simplifies our investigation of algorithmic complexity.
Our algorithm for deciding conjunctive query entailment is given in Table 3. Any
occurrence of the word select in the description indicates a nondeterministic choice
of the algorithm. Step A is a standard preprocessing step for many query answering
algorithms. Step B initiates the proof graph and ensures that all nodes are reachable.
Variable nodes eventually are reachable through exactly one predecessor node, so the
structure of the proof graph resembles the canonical model (compare Property 1 of
Section 3). Steps C and D verify that the selected proof graph indeed establishes the
existence of the required anonymous elements in the model (C) and the entailment of
?

?

?
the querys concept atoms (D). At this stage, the proof graph still represents many possible fragments of the canonical model: the edge NFA that connect to variable nodes
encode possible generating role paths (in the sense of Property 1 Section 3), each of
which leads to a dierent element in the canonical model. The edges leading to individual nodes have a slightly dierent meaning: all of the paths they represent must
actually exist in any model. Summing up, the proof graph still represents many possible
matches between the query and a model of KB, though a number of basic decisions on
the structure of the considered matches has already been made and it is known that any
such match suces to entail the concept atoms of the query.

Now Step E computes the RBox automata (R) of Section 3 and applies a nondeterministic splitting operation, which we define next. We remark that the required shortest
path exists and is easily found in polynomial time (see [11]).

Definition 3. Consider an NFA   (Q   i  f ). A split of  into k parts is given
by NFA 1     k with  j of the form (Q   q j1 q j) such that q0  i, qk  f , and
q j  Q for all j  1     k  1.
It is easy to see that, if each split automaton  j accepts some word w j, we find that
w1    wk is accepted by . Likewise, any word accepted by  is also accepted in this
sense by some split of . Since the combination of any split in general accepts less
words than , splitting an NFA usually involves some dont-know nondeterminism.

The intuition underlying this split is that each role NFA (R) encodes possible
chains of roles that suce to establish role R. Clearly, one such chain must be found
for every query atom R(n m). But the proof graph already imposes a basic structure
that defines how elements n and m can be connected, and any match with R must be
distributed along the paths of the proof graph. This is implemented by the above split.
Finally, Step F again verifies the earlier choices of the algorithm by comparing the
(logically deducible) role chains given by the edge NFA with the role chains that the
split NFA require to exist for establishing a match. The case distinction reflects the
dierent intention of edges leading to individual or variable nodes. For edges leading
to a variable node, only a single generating role path exists in the canonical model, and
all split automata must match one such path (line 27). For edges leading to nominal
nodes, all of accepted paths exist in every model. Hence line 24 implements pairwise
comparisons of each split NFA with the edge NFA. Concrete implementations for the
checks of lines 24 and 27 are discussed in Section 6.

We conclude this section with a small example. Let KB be the knowledge base con-

sisting of the following axioms:

A  RB

B  S a

T  R  T

a  Tb

b  A

with concept names A and B, role names R, S and T , and individuals a, b. Consider the
query S (x y) T (y x).

In Step A, the algorithm replaces y by a to obtain the query S (x a) T (a x). The
proof graph built in Step B has nodes N  a b x with L(a)  a, L(b)  b and
L(x)  B. Edges are constructed between pairs of elements (a b), (b a), (x a), (x b),
and (b x) (i.e. b generates x). The constructed edge NFA are distinguished only by
their start and end states (as rule (CR6) of Table 2 is not used), and have the following
structure:

M. Krotzsch, S. Rudolph, and P. Hitzler

A

B

bA

a

A

?>=<
89:;A

?>=<
89:;B
@A
8?9

?>=<
89:;
a

:;<

?>=<
89:;

?>=<
89:;
b

Step C succeeds since every edge automaton accepts some word, and Step D is omitted since no concept atoms appear in the query. The only nontrivial role NFA is (T )
which accepts any word that starts with T followed by an arbitrary number of R. Due
to the presence of the query atom T (a x) this NFA must be split along the path from a
over b to x, and there is only one split into two NFA that accept nonempty languages.
Hence (T (a x) a b) accepts the single word T , and (T (a x) b x) accepts any sequence of R. The only other split NFA (S (x a) x a) is directly given by (S ), the
NFA accepting only the word S . Finally in Step F the three existing split automata are
compared to the corresponding edge NFA. (T (a x) a b) and E(a b) accept a common word T , (T (a x) b x) and E(b x) accept a common word R, and (S (x a) x a)
and E(x a) accept a common word S . Hence the query is accepted.

5 Correctness of the Algorithm

Proposition 2. Consider a regular consistent  knowledge base KB and a conjunctive query q. If the algorithm of Section 4 accepts q, then indeed KB  q.

Proof. We use the notation from Section 4 to denote structures computed by the algo-
rithm. When terminating successfully, the algorithm has computed the following:

 A proof graph (N L E),
 For each role atom R(n m)  q, a k-split (R(n m) n0 n1)     (R(n m) nk1 nk)
of the NFA (R), where k is the length of the shortest path from n to m in (N L E).

In the following, let 	 be some model of KB. To show KB  q, we need to provide
a mapping  as in Section 2 for 	. Since 	 is arbitrary, this shows the entailment of
q. We can derive  from the proof graph, and then show its correctness based on the
conditions checked by the algorithm.

In Step A, the algorithm replaces variables by individual names or by other variables.
This is no problem: whenever a query q is obtained from q by uniformly replacing a
variable x  Var(q) by an individual a  I (or variable y  Var(q)), we have that KB  q
implies KB  q. Indeed, any mapping  for q can be extended to a suitable mapping 
for q by setting (x)  a	 ((x)  y	). Thus we can assume w.l.o.g. that all variables
x  Var(q) also occur as nodes in the proof graph, i.e. x  N.

In Step F, the algorithm checks non-emptiness of the intersection languages of the
NFA E(n m), and oneall split NFA (F n m), for each n, m  N with E(n m) defined.
Thus for any pair n  N, m  Var(q), there is some word w accepted by all of the
given NFA. Choose one such word w(n m). By the definition of the split NFA, w(n m)
is a word over R, and we can assume this to be the case even when no split NFA (but
just the single edge automaton) are considered for a given edge. E(n m) is of the form
(L(n) L(m)) (Definition 2) for the selected labels L(n) and L(m) of the proof graph.

/
/
?

?

?
?
?
o
o


o
o




?

?

?
Now by Theorem 2, the construction of Definition 2, and the fact that KB is consis-
tent, it is easy to see that E(n m) accepts the word w(n m)  R1    Rl i KB  L(n) 
R1    RlL(m). We employ this fact to inductively construct a mapping .

In Step B the algorithm has defined labels L(x) for all x  Var(q), and we will
retrace this process to construct . We claim that the following construction ensures
that, whenever a node n  N is reachable, (n) has been assigned a unique value such
that (n)  L(n)	. For starting the induction, set (a)  a	 for each a  I (which is
necessarily reachable and clearly satisfies (a)  L(a)	  a	). Now assume that in one
step the algorithm selected some x  Var(q) that was not reachable yet, and node n  N
which is reachable. As noted above, KB  L(n)  R1    RlL(x) where w(n x) 
R1    Rl, and hence there is an element e  L(x)	 such that ((n) e)  R	
1      R	
l
(where  denotes forward composition of binary relations). Pick one such e and set
(x)  e. It is easy to see that the claim of the induction is satisfied.

In Step D it has been verified that L(n)  C holds for each C(n)  q (using standard polynomial time reasoning for ), so we find (n)  C	. It remains to show
that a similar claim holds for all binary query atoms. Thus consider some role atom
R(n m)  q, and let n  n0     nk  m denote the shortest path in the proof graph used
to split the role automaton. So far, we have defined w(ni ni1) only for cases where
ni1  Var(q). By a slight overloading of notation, we now let w(ni ni1) for ni1  I
denote some word accepted by the intersection of E(ni ni1) and the specific split automaton (R(n m) ni ni1), which must exist as the algorithms must have verified nonemptiness of the intersection language. Assuming that w(ni ni1)  S 1    S l, we note
that this still entails KB  L(n1)  S 1    S lL(ni1) . Since ni1  I, this actually
shows that ((ni) (ni1))  S 	

l .
1      S 	

The word w  w(n0 n1)    w(nk1 nk) is accepted by (R), which is clear from the
construction in Definition 3 as the parts w(ni ni1) are accepted by the respective split
automata. Assume that w  R1    Rk. We conclude ((n) (m))  R	
k from
the construction of  and the above observations for the case of edges connecting to
individual elements. Thus by Proposition 1 we have ((n) (m))  R	 as required. 	

1      R	

It remains to show that the algorithm is also complete. This is done by demonstrating
that there are suitable nondeterministic choices that enable the algorithm to accept a
query whenever it is entailed. To guide those choices, we use the canonical model 	
introduced in Section 3.

Proposition 3. Consider a regular consistent  knowledge base KB and a conjunctive query q. If KB  q, then there is a sequence of nondeterministic choices for the
algorithm of Section 4 such that it accepts q.

Proof. Consider the canonical model 	 as constructed above. Since KB  q and 	 
KB, there is some mapping  such that 	   q. We will use  to guide the algorithm.
In Step A, a variable x  Var(q) is replaced by n  Var(q)  I whenever (x)  (n).
For Step B, we choose the labelling L of the proof graph by setting L(e)  ((e)). As
argued in the proof of Lemma 1,   C	 i KB  ()  C, and hence we conclude that
(e)  C	 implies that KB  L(e)  C for all e  I  Var(q). Thus all unary atoms of q
are accepted by the algorithm.

M. Krotzsch, S. Rudolph, and P. Hitzler

Now in each step of the generation of the edges E of the proof graph, the algorithm
needs to pick some (unreachable) x  Var(q) and some reachable node n. We will utilise
the properties established in Section 3. By Property 1, there is a unique generating chain
for each (x) where x is not reachable within the proof graph yet. Moreover, since
the chain of Property 1 is unique and shortest, it is also acyclic. Hence there is some
unreachable x such that (x) is not generated by any element of the form (y) with y
unreachable. Pick one such element x. Finally select one element n  I  Var(q) such
that (n) generates (x), and such that there is no element m for which (m) generates
(x) and (n) generates (m). Construct an edge E(m x).

Now for any elements n and m of the query, with m  Var(q) and E(n m) defined,
the automaton E(n m) accepts a non-empty language. This is seen by combining Property 2 with Theorem 2, where the second case of the theorem is excluded since KB is
consistent. The algorithms checks in Step C thus succeed.

The algorithm now has completed the proof graph construction, and the selection of
split automata is required next. For all query atoms R(n m), we find that ((n) (m)) 
R	, and thus we can apply Property 3 to obtain a respective chain of elements and role
names, which we denote as 0    k and R0    Rk1 in the remainder of this proof.

Let j  0 denote the largest index of 0    k, such that  j is of the form (e1) for
some e1  I, if any such element exists. Otherwise, let j  0 denote the smallest index
such that i is of the form (e1) for any e1  Var(q). We claim that there is a connection
between n and e1 in the proof graph. Clearly, this is true if e1  I since these edges
were constructed explicitly. Otherwise, Property 1 and our choice of e1 imply that an
edge from n to e1 was constructed by the algorithm. Starting by  j1, find all elements
i of the form (e), e  Var(q), and label them consecutively as e2     el. Note that this
sequence can be empty, in which case we define l  1. Obviously, el  m. We claim
that n  e0    el  m is the shortest path from n to m within the proof graph. We already
showed the connection between n  e0 and e1. The connections between ei and ei1 are
also obvious, since each e1 generates ei1 by definition. Since the latter path is also the
only path from e1 to el, the overall path is clearly the shortest connection.

The algorithm now splits (R) along the path n  e0    el  m. For each ei, there is
an index j(i) such that  j(i)  (ei). Hence, for each pair (ei ei1), there is a corresponding sequence of roles R j(i)1    R j(i1) which we denote by ri (i  0     l  1), and the
concatenation of those sequences yields the original R0    Rk1. By Proposition 1 and
Property 3, the automaton (R) accepts the word R0    Rk1. To split the automaton, we
consider one accepting run and define qi to be the state of the automaton after reading
the partial sequence ri, for each i  0     l  1. The states qi are now used to construct
the split automata i, and it is easy to see that those automata accept the sequences ri.
Now assume that all required split automata have been constructed in this way. Consider any pair of query elements e e  IVar(q) for which a split automaton (F e e)
was constructed using a partial sequence of roles r. We claim that the edge automaton
E(e e) accepts r. Indeed, this follows from Property 2 and Theorem 2. This shows
non-emptiness of intersections between any single split automaton and the corresponding edge automaton in the proof graph, and thus suces for the case where e  I.

Finally, consider the case that e  Var(q), and assume that two split automata
(F e e) and (F  e e) have been constructed for the given pair, based on two
?

?

?
partial role sequences r and r. We claim that r  r. Indeed, this is obvious from
the fact that r and r both correspond to the unique generating sequence of roles for
the elements e and e, which is part of the sequence constructed for Property 1. This
shows that r is accepted both by (F e e) and by (F  e e). We conclude that the
intersection of all split automata and the edge automaton E(e e) is again non-empty.

The algorithm thus has completed all checks successfully and accepts the query. 	

6 Complexity of Query Answering for 

Finally, we harvest a number of complexity results from the algorithm of Section 4.

Lemma 2. Given a regular  knowledge base KB and a conjunctive query q, the
entailment problem KB  q is hard for NP w.r.t. the size of q, hard for P w.r.t. the size
of the ABox of KB, and hard for PS w.r.t. to the combined problem size, even when
restricting to simple RBoxes.

The hardness proofs in [11] apply known hardness results for the data-complexity of
instance checking in fragments of  [12], evaluation of single Datalog clauses (NP-
complete, [13]), and emptiness of NFA intersection languages (PS-complete, [14]).
We remark that the above results are quite generic, and can be established for many
other DLs. Especially, NP-hardness w.r.t. knowledge base size can be shown for any
logic that admits an ABox, whereas PS hardness of the combined problem follows
whenever the DL additionally admits role composition and existential role restrictions.

Lemma 3. Given a regular  knowledge base KB and a conjunctive query q, the
entailment problem KB  q can be decided in P w.r.t. the size of the knowledge base,
in NP w.r.t. the size of the query, and in PS w.r.t. the combined problem size, given
that RBoxes are simple whenever KB is not fixed.

Proof. First consider Step A of Table 3. It clearly can be performed nondeterministically in polynomial time. If the query is fixed, the number of choices is polynomially
bounded, and so the whole step is executable in polynomial time.

Similar observations hold for Step B. Concept names and automata for edges can be
assigned in polynomial time by a nondeterministic algorithm (and thus in polynomial
space). If the query has fixed size, available choices again are polynomial in the size of
KB: the assignment of labels L admits at most CVar(q) dierent choices, and for each
such choice, there are at most n2 possible proof graphs, where n is the number of nodes
in the graph. Since n and Var(q) are considered fixed, this yields a polynomial bound.
Further nondeterminism occurs in Step E. But if the query is fixed, each of the polynomially many proof graphs dictates a number of splits that is bounded by the size of
the query m. Since splitting a role NFA into k parts corresponds to selecting k (not necessarily distinct) states from this NFA, there are Qk dierent ways of splitting .
Since k is bounded by the size of the query m, we obtain an upper bound Qmm that
is still polynomial in the size of KB (which, by our assumptions on simplicity of the
RBox, determines the maximum number of states Q of some role NFA). If the query
is not fixed, splitting can be done nondeterministically in polynomial time.

M. Krotzsch, S. Rudolph, and P. Hitzler

Now for Step F, the algorithm essentially has to check the emptiness of intersection
languages of various automata. Given NFA 1     l, this check can be done in two
ways, each being worst-case optimal for dierent side conditions of the algorithm:

(1) Initialise state variables q1     ql as being the initial states of the involved NFA.
Then nondeterministically select one input symbol and one transition for this symbol in each of the considered NFA, and update the states q j accordingly. The algorithm is successful if at some stage each q j is a final state of the automaton  j. The
algorithm runs in NPS w.r.t. the accumulated size of the input automata.

(2) Iteratively compute the intersection NFA for  j  (Q j   j i j F j) and  j1 
(Q j1   j1 i j1 F j1). This intersection is the NFA (Q j 
Q j1   (i j i j1) F j

F j1), with ((a1 b1) (a2 b2))  (a1 a2)  (b1 b2). The algorithm is successful if
the intersection is non-empty. This construction is polynomial if the number of the
input NFA is known to be bounded.

Method (1) establishes a general (nondeterministic) polynomial space procedure,
which by Savitchs Theorem is also in PS. Method (2) can be used to establish
tighter bounds in special cases: each intersection might cause a quadratic increase of
the size of the NFA, but the number of required intersections is bounded if KB or q are
fixed. Indeed, if the query is fixed, the number of required intersections is bounded by
the overall number of role atoms in the query. If the knowledge base is fixed, the number
of interesting intersections is bounded by the number of split NFA that can be produced
from role NFA constructed from the RBox, which is bounded by a fixed value. In both
cases, checking intersections can be done deterministically in polynomial time.
	

The below table summarises some common complexity measures for the case of conjunctive query answering in regular  knowledge bases. Whenever the RBox is
variable, we assume that it is simple. It should be remarked that TBox and ABox could
always be considered variable without increasing any of the given complexities.

Variable parts:

Query RBox TBox ABox

Complexity

Combined complexity 




Query complexity
Schema complexity

Data complexity














 PS-complete

NP-complete
P-complete
P-complete






7 Conclusion

We have proposed a novel algorithm for answering conjunctive queries in  knowledge bases, which is worst-case optimal under various assumptions. To the best of our
knowledge, this also constitutes the first inference procedure for conjunctive queries in
a DL that supports complex role inclusions (including composition of roles) in the sense
of OWL 1.1. Showing undecidability of conjunctive queries for unrestricted , we
illustrated that the combination of role atoms in queries and complex role inclusion
axioms can indeed make reasoning significantly more dicult.
?

?

?
A compact automata-based representation of role chains and (parts of) models allowed us to establish polynomial bounds for inferencing in various cases, thus identifying querying scenarios that are still tractable for . Conjunctive queries inherently
introduce some nondeterministism, but automata can conveniently represent sets of possible solutions instead of considering each of them separately. We therefore believe that
the presented algorithm can be a basis for actual implementations that introduce additional heuristics to ameliorate nondeterminism.
