History Matters: Incremental Ontology Reasoning

Using Modules

Bernardo Cuenca Grau1, Christian Halaschek-Wiener2, and Yevgeny Kazakov1

1 The University of Manchester, School of Computer Science, Manchester, M13 9PL, UK
2 Department of Computer Science, University of Maryland, College Park, MD 20740, USA

Abstract. The development of ontologies involves continuous but relatively
small modifications. Existing ontology reasoners, however, do not take advantage of the similarities between different versions of an ontology. In this paper,
we propose a technique for incremental reasoningthat is, reasoning that reuses
information obtained from previous versions of an ontologybased on the notion
of a module. Our technique does not depend on a particular reasoning calculus
and thus can be used in combination with any reasoner. We have applied our results to incremental classification of OWL DL ontologies and found significant
improvement over regular classification time on a set of real-world ontologies.

1 Introduction

The design and maintenance of OWL ontologies are highly complex tasks. The support of a reasoner is crucial for detecting modeling errors, which typically manifest
themselves as concept unsatisfiability and unintended subsumption relationships.

The development of ontologies involves continuous but relatively small modifica-
tions. Even after a number of changes, an ontology and its previous version usually
share most of their axioms. Unfortunately, when an ontology evolves, current reasoners
do not take advantage of the similarities between the ontology and its previous version.
That is, when reasoning over the latest version of an ontology, current reasoners do not
reuse existing results already obtained for the previous one and repeat the whole reasoning process. For large and complex ontologies this may require a few minutes, or
even a few hours. If the response of the reasoner is too slow, ontology engineers may
end up not using the reasoner as often as they would wish. For ontology development
and maintenance tasks it is important to detect possible errors as soon as possible; for
such a purpose, the reasoner should be executed often and real time response from the
reasoner becomes an important issue.

In this paper, we propose a technique for incremental ontology reasoningthat is,
reasoning that reuses the results obtained from previous computations. Our technique
is based on the notion of a module and can be applied to arbitrary queries against ontologies expressed in OWL DL. We focus on a particular kind of modules that exhibit
a set of compelling properties and apply our method to incremental classification of
OWL DL ontologies. Our techniques do not depend on a particular reasoner or reasoning method and could be easily implemented in any existing prover, such as Pellet,

K. Aberer et al. (Eds.): ISWC/ASWC 2007, LNCS 4825, pp. 183196, 2007.
c Springer-Verlag Berlin Heidelberg 2007

B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

FaCT++, KAON2 or RACER. Our empirical results using Pellet1 show substantial performance improvements over regular classification time.

2 Preliminaries
We introduce the syntax of the description logic SHOIQ [11], which provides the
logical underpinning for OWL DL.
A SHOIQ-signature is the disjoint union S = R  C  I of sets of atomic roles
(denoted by R, S, ), atomic concept (denoted by A, B, ) and nominals (denoted
with R  R. We
by a, b, c, ). A SHOIQ-role is either R  R or an inverse role R
denote by Rol the set of SHOIQ-roles for the signature S. The set Con of SHOIQconcepts for S is defined by the following grammar:

Con ::=  | a | A | C | C1  C2 | R.C |  n S.C

where a  I, A  C, C(i)  Con, R, S  Rol, with S a simple role,2 and n a positive
integer. We use the following abbreviations: C  D stands for (C  D);  stands
for ; R.C stands for (R.C); and  n S.C stands for ( n+1 S.C).
A SHOIQ ontology O is a finite set of role inclusion axioms (RIs) R1  R2 with
Ri  Rol, transitivity axioms Trans(R) with R  R and general concept inclusion
axioms (GCIs) C1  C2 with Ci  Con.3 The concept definition A  C is an abbreviation for the two GCIs A  C and C  A. The signature Sig() of an axiom  is
the union RN() CN() Ind() of atomic roles, atomic concepts, and nominals that
occur in . The signature Sig(O) of an ontology O is defined analogously.

For the semantics of SHOIQ, we refer the interested reader to [11].

3 The Challenge for Incremental Reasoning in Ontologies
Consider the medical ontology O1 given in Table 1, which consists of three concept
definitions D1  D3 and two inclusion axioms C1  C2. For exposition, suppose that
an ontology engineer in charge of this ontology notices that the definition D1 for the
concept Cystic Fibrosis is incomplete and reformulates it by adding the new conjunct
has Origin.Genetic Origin. As a result, a new version O2 of the ontology is obtained.
In order to ensure that no errors have been introduced by this change, the ontology
engineer uses a reasoner to classify the new ontology O2.
Table 2 shows some subsumption relationships between atomic concepts in O1 and
O2, which should be computed for classification. We can see that some of these subsumption relations have changed as a result of a modification in the ontology: axiom 1
follows from the axioms D3, C2 and D1 in O1, but does not follow from O2 anymore
since D1 has been modified; in contrast, the subsumption 2, which did not follow from
O1, is now a consequence of the modified D1, D2 and C1 in O2. Other subsumptions
1 Pellet Homepage: http://pellet.owldl.com
2 See [11] for a precise definition of simple roles.
3 Note that ABox assertions a : C can be expressed in SHOIQ using GCIs a  C.
?

?

?
Original Ontology O1:

D1 Cystic Fibrosis  Fibrosis 

Table 1. Evolution of a Bio-Medical Ontology O
Modified Ontology O2:
Cystic Fibrosis  Fibrosis 

located In.Pancreas

located In.Pancreas 
has Origin.Genetic Origin

D2 Genetic Fibrosis  Fibrosis 

Genetic Fibrosis  Fibrosis 

has Origin.Genetic Origin

has Origin.Genetic Origin

D3 Pancreatic Fibrosis  Fibrosis 

Pancreatic Disorder

C1 Genetic Fibrosis  Genetic Disorder
C2 Pancreatic Disorder  Disorder 

Pancreatic Fibrosis  Fibrosis 

Pancreatic Disorder

Genetic Fibrosis  Genetic Disorder
Pancreatic Disorder  Disorder 

located In.Pancreas
O = diff(O1,O2) = (O, +O)
O = Cystic Fibrosis  Fibrosis  located In.Pancreas
+O = Cystic Fibrosis  Fibrosis  located In.Pancreas  has Origin.Genetic Origin

located In.Pancreas

Table 2. Subsumption Relations Before and After the Change

Axiom:


1 Pancreatic Fibrosis  Cystic Fibrosis
2 Cystic Fibrosis  Genetic Disorder
3 Pancreatic Fibrosis  Disorder
4 Genetic Fibrosis  Cystic Fibrosis

O1 |=? , follows from: O2 |=? , follows from:

Yes
No
Yes
No

D3, C2, D1



D3, C2



No
Yes
Yes
No



D1, D2, C1

D3, C2



such as 3 and 4 did not change: 3 is a consequence of axioms D3 and C2 which
have not been modified; 4 follows neither from O1 nor from O2.

It is reasonable to expect that small changes in ontologies will not affect many subsumption relations. That is, the number of subsumptions that change their entailment
status w.r.t. the ontology, like, say, 1 or 2 in Table 2, is probably small compared
to the number of subsumptions that do not, like 3 or 4. If so, then many (possibly
expensive) re-computations can be avoided by reusing the subsumption relations computed for the previous version of the ontology. In order to realize this idea, one has to
identify which subsumptions could be affected by a change and which are not.
Suppose we know that a subsumption  holds in O1. Then we can guarantee that
 still holds in O2 provided the axioms from which  follows in O1 have not been
modified. For example, in Table 2, the subsumption 3 is a consequence of axioms
D3 and C2, both of which have not been modified in O2. Hence, we can conclude
that 3 holds in O2 without performing reasoning over O2. In contrast, this test is not
applicable for the subsumption 1, since 1 is a consequence of axioms D3, C2 and D1
in O1, and D1 has been modified in O2. In this case, the status of 1 in O2 has to be
computed by other means, e.g. using a reasoner. Thus, the status of every subsumption
?

?

?
relation  that holds in O1 requires re-computation for O2 only if in every justification
for  (every minimal subset of O1 which implies ) some axiom has been modified.
This approach is reminiscent of the way Truth Maintenance Systems (TMS) maintain
logical dependencies between axioms [6,3]. The notion of justification for an axiom has
also been used for pinpointing the axioms responsible for errors in ontologies, such as
unsatisfiable concepts and unintended subsumptions [14,13].
The situation is principally different in the case of subsumptions  that do not hold in
O1. In this case, if to follow the previous approach, one has to keep track of evidences
for non-entailments of subsumptions in ontologies and verify if at least one such evi-
dence for  in O1 can be reused in O2. Here, the evidence might be, for example, a
(part of a) counter-model for  in O1 that is constructed by tableau-based procedures.
Such techniques based on model caching have been recently proposed in the context
incremental reasoning [8]. These techniques, however, have only been applied so far
to additions and deletions of ABox assertions, since changes in general axioms often
require considerable modifications of the models. Moreover, such techniques require
close interaction with the model construction routine of the tableau reasoner, which
precludes their use in arbitrary off-the-shelf reasoners without considerable modifi-
cations. In particular, these techniques cannot be directly used in reasoners like KAON2,
which are not tableaux-based.

We stress that the challenge for incremental ontology reasoning is mainly to maintain
non-subsumptions since, in typical ontologies, almost 99% of subsumption relations
between atomic concepts do not hold. In other words, the case of axiom 4 in Figure 2
is likely to be the most one after a change in an ontology.4

In this paper we propose an alternative approach for incremental reasoning based on
the module-extraction techniques introduced in [2]. Our technique can be used to keep
track of evidences for both subsumptions and non-subsumptions modulo arbitrary
changes in ontologies, and works in combination with any DL-reasoner providing for
standard reasoning services.

4 Modules and Syntactic Locality

In this section we define the notion of a module [2], which underlies our technique for
incremental reasoning. We also outline the algorithm proposed in [2] for extracting a
particular kind of modules, called locality-based modules.
Definition 1 (Module for an Axiom and a Signature). Let O be an ontology and
O1  O is a (possibly empty) subset of axioms in O. We say that O1 is a module for
for an axiom  in O (or short, an -module in O) if: O1 |=  iff O |= .
We say that O1 is a module for a signature S if for every axiom  with Sig()  S,
we have that O1 is a module for  in O.
Intuitively, a module for an axiom  in an ontology O is a subset O1 of O which
contains the axioms that are relevant for  in O, in the sense that O implies  if and
only if O1 implies . In case O implies , then every module O1 for  should contain
4 In Section 6 we provide empirical evidences confirming our conjectures.
?

?

?
at least one justification for  (that is, a minimal set of axioms which imply ). In case
O does not imply  (that is, there are no justifications for ), O1 can be any subset
of O. Hence, knowing all the justifications for  in O is sufficient for identifying all
modules for  in O.

The notion of module for a signature has been introduced in [2]. Intuitively, a module
for a signature is a subset of the ontology that is a module for every axiom constructed
over this signature. An algorithm for extracting modules based on a notion of syntactic
locality was proposed in [2], and it was empirically verified that this algorithm extracts
reasonably small modules in existing ontologies.
Definition 2 (Syntactic Locality for SHOIQ). Let S be a signature. The following
grammar recursively defines two sets of concepts Con(S) and Con(S) for S:

Con(S) ::= A | (C) | (C  C) | (C  C)
Con(S) ::= (C) | (C

| (R.C) | (R.C) | ( n R.C) | ( n R.C) .

1  C
2 ) .
is (possibly inverse of) an atomic role r / S,
An axiom  is local w.r.t. S if it is of one of the following forms: (1) R  R, or

where A / S is an atomic concept, R
C is any concept, R is any role, and C  Con(S), C
(2) Trans(R), or (3) C  C or (4) C  C.5

 Con(S), i = 1, 2.

(i)

Intuitively, an axiom  is syntactically local w.r.t. S if, by simple syntactical sim-
plifications, one can demonstrate that  is true in every interpretation I = (I ,I)
in which concept and atomic roles not from S are interpreted with the empty set. For
example, the axiom D2 from Table 1 is local w.r.t. S = {Fibrosis, has Origin}: if we
interpret the remaining symbols in this axiom with the empty set, we obtain a model of
the axiom, independently of the interpretation of the symbols in S.

?

?

?

?

?

?
Genetic Origin
?

?

?


Genetic Fibrosis  Fibrosis  has Origin.
?

?

?
If an ontology O can be partitioned as O = O1  Os such that every axiom in Os is
syntactically local w.r.t. S  Sig(O1), then O1 is a module for S in O [2]. Algorithm 1
extracts a module O1 for a signature S from an ontology O using this property. The
procedure first initializes O1 to the empty set and then iteratively moves to O1 those
axioms  from O that are not local w.r.t. S  Sig(O1) until all such axioms have been
moved. We assume that s local(, S) tests for syntactic locality of an axiom  w.r.t.
signature S according to Definition 2. In Table 3 we provide a trace of Algorithm 1 for
the input ontology O1 in Table 1 and signature S = {Pancreatic Fibrosis}.
Proposition 1 (Correctness of Algorithm 1 (see [2]) for details). Given an SHOIQ
ontology O and a signature S, Algorithm 1 terminates in polynomial time in the size of
O and returns a module O1 for S in O.
5 Recall that R.C, ( n R.C) and C1  C2 are expressed using the other constructors, so they
can be used in local axioms as well.

B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

Table 3. An algorithm for extracting syntactic locality-based modules from ontologies

Algorithm 1 extract module(O, S)
Input:O: ontology
S: signature

Output:O1: a module for S in O
1: O1   O2  O
2: while not empty(O2) do
  select axiom(O2)
3:
if
4:
then

s local( , S Sig(O1) )
O2  O2 \ {}
O1  O1  {}
O2  O \ O1

else

5:
6:
7:
8:
end if
9:
10: end while
11: return O1

2 D3

3 D3

4 D3
5 D3
6 D3, C2 D1, D2,

C1,

7 D3, C2 D2, C1
8 D3, C2 C1
9 D3, C2 

A sample trace for the Algorithm 1 for O = O1 from
Table 1 and S = {Pancreatic Fibrosis} :
O1
New X  S Sig(O1)  loc?
Pancreatic Fibrosis D3 No
1 

O2
D1, D2, D3,
C1, C2
D1, D2,
C1, C2
D2,
C1, C2
C1, C2
C2

Fibrosis,
Pancreatic Disorder






Disorder, located In,
Pancreas





D1 Yes

D2 Yes

C1 Yes
C2 No
D1 Yes

D2 Yes
C1 Yes


In order to extract a module for an axiom  in O it is sufficient to run Algorithm 1 for
S = Sig(). However, when  is a subsumption between atomic concepts,  or , it
suffices to extract a module only for S = Sig(X), as given in the following proposition.
Proposition 2 (see [2] for details). Let O be a SHOIQ ontology, X, Y  CN(O) 
{}  {}, and OX the output of Algorithm 1 for input O and S = Sig(X). Then OX
is a module in O for  = (X  Y ).
Finally, we point out that the modules extracted using Algorithm 1 are not necessary
minimal ones. That is, if O |= , the computed module for  might be a strict superset
of a justification for  in O, and if O |=  then the module for Sig() might not necessarily be the empty set. In fact, if  is not a tautology, computing a minimal module
for  in O is at least as hard as checking whether O |=  since O |=  iff the minimal
module for  is empty. The last problem is computationally expensive for many ontology languages, including OWL DL. The advantage of the module-extraction algorithm
described in this section is that, on the one hand, it runs in polynomial and, on the other
hand, it still generates reasonably small modules.

5 Incremental Classification Using Locality-Based Modules

In this section we show how to use then notion of module for incremental reasoning over
ontologies. First, we outline the general idea behind using modules for incrementally
maintaining (non)entailment of axioms and then describe an algorithm for incremental
classification of ontologies using locality-based modules, as described in Section 4.
?

?

?
The following proposition, which is a simple consequence of Definition 1, provides





 respectively mod-

 O2, then O2 |= 
 O1, then O2 |= 

the basic property underlying incremental reasoning using modules:
Proposition 3. Let O1, O2 be ontologies,  an axiom, and O1
, O2
ules for  in O1 and O2. Then:
1. If O1 |=  and O1
2. If O1 |=  and O2
Proposition 3 suggests that, in order to test if the entailment of an axiom  has not
been affected by a change O1  O2, it is sufficient to compute, depending on whether
O1 |=  or O1 |= , a module O1
 for  in O2 respectively.
If the change does not involve any of the axioms in the module, then the status of
the entialment of  also does not change. The converse of this is not necessarily true:
even if the corresponding module has been modified, the status of  might still remain
unaffected. For example, the axiom  = (Cystic Fibrosis  Fibrosis) follows from D1
both before and after the change, even though D1 has been modified. In such a case, the
status of  w.r.t. O2 should be verified using the reasoner. The use of modules, however,
is also valuable in this situation: instead of checking if  follows from O2, one could
equivalently check if  follows from the (hopefully much smaller) module O2
.

 for  in O1, or a moduleO2

 and O2

Note that the sizes of modules O1

Therefore, the use of modules provides two compelling advantages for incremental
reasoning: first, the computation of a given query may be avoided and the answer can be
simply reused from a previous test; second, even if the query needs to be performed, the
use of modules allows for filtering out irrelevant axioms and reduces the search space.
 have a direct impact on the quality of
the incremental entailment test for . The smaller the modules, the more likely it is
that they do not contain the modified axioms. Nevertheless, as pointed out in Section 4,
computing a smallest possible module is computationally expensive: it is at least as hard
as just checking whether O1 |=  (respectively O2 |= ). Thus, there is a trade-off
between the complexity of computing a module on the one hand, and its usefulness for
incremental reasoning on the other hand. Intuitively, the smaller the module, the more
useful and the harder it is to compute. We demonstrate empirically that Algorithm 1
computes small enough modules to be useful for incremental reasoning.

In the remainder of this section we apply the general idea for incremental reasoning
sketched above for incremental classification of ontologies using the module-extraction
procedure given by Algorithm 1. Classification of an ontology O amounts to computing
subsumption relations X  Y where X and Y range over all atomic concepts from O,
, and . The relations are non-trivial when X  CN(O){} and Y  CN(O){}.
As shown in Proposition 2, in order to check incrementally a subsumption relation
 = (X  Y ), it is sufficient to keep track of the modules OX for Sig(X) in O.
Consider the ontologies O1 and O2 in Table 1 and the axioms 14 in Table 2.
Each of these axioms is of the form  = (X  Y ), with X and Y atomic concepts.
Table 4 provides the locality-based modules for 14 in O1 and in O2 computed
using Algorithm 1. Note that the modules are not minimal: in our case, they are strict
supersets of the actual minimal modules from Table 2 where the additional axioms are
underlined. The modules for axioms 13 have been changed, whereas the module
for the axiom 4 has remained unchanged. Hence, the sufficient test for preservation

B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

Table 4. Modules For Subsumptions and Concept Names in Ontologies from Table 1
O2

O1

O2

 Axiom X  Y :
1 Pancreatic Fibrosis
 Cystic Fibrosis

D3,C2,D1

2 Cystic Fibrosis

 Genetic Disorder

D1

3 Pancreatic Fibrosis

 Disorder
4 Genetic Fibrosis

 Cystic Fibrosis

D3,C2,D1

C1

D3,C2

D1,D2,C1

D3,C2

C1

D1,D2,C1

O1

D1


C1


Cystic Fibrosis
Fibrosis
Pancreas
Genetic Fibrosis
Genetic Origin
Pancreatic Fibrosis D3,C2,D1 D3,C2
Pancreatic Disorder
Genetic Disorder
Disorder
?

?

?


C1


C2
C1
C2


C2
C1
C2


of (non)subsumptions using modules gave us only one false positive for subsumption
3, where the subsumption relation did not change, but the modules have been modified.
The right part of Table 4 provides the full picture on the modules and their changes
for our example ontology from Table 1. The only modules that have been changed
are the ones for X = Cystic Fibrosis and X = Pancreatic Fibrosis, where for the
first module axiom D1 has been changed, and for in the second module axiom D1 has
been removed. Applying Proposition 2 and Proposition 3 we can conclude that every
subsumption that dissapears as a the result of the change should be either of the form
 = (Cystic Fibrosis  Y ) or  = (Pancreatic Fibrosis  Y ), and every subsumption
that can appear should be of the form  = (Cystic Fibrosis  Y ).
Algorithm 2 outlines an incremental classification procedure based on the ideas just
discussed. Given an ontology O1 and a change O = (O, +O) consisting of the
sets of removed and added axioms, the algorithm computes the subsumption partial
order 2 for the resulting ontology O2 = (O1 \ O)  +O by reusing the one 1
already computed for O1. In order to perform this operation, the algorithm internally
maintains the modules O1
X for every atomic concept or the top concept X.
We will show that mantaining these additional modules does not involve a significant
overhead in practice. The algorithm consists of the following phases:
1. Process the new symbols (lines 26): The modules O1

X and the subsumption partial
order 1 for O1 are extended for every newly introduced atomic concept A. The
module for A, about which nothing has been said yet, is equivalent to the module
for the empty signaturethat, is the module for . Thus, we have: (i) O1
A = O1,
(ii) O1 |= A  Y iff O1 |=   Y , and (iii) O1 |= X  A iff O1 |= X  .
and M+ contain those
X  CN(O1)  {} for which the corresponding modules must be modified by
removing and/or adding axioms. If  removed from O1 is non-local w.r.t. Sig(O1
X)
then at least  should be removed from O1
X . If  is added to O1 and is non-local
w.r.t. Sig(O1

2. Identifying the affected modules (lines 719): The sets M

X needs to be extended at least with .

X), then the module O1

X and O2



3. Computing new modules and subsumptions (lines 2034): The affected modules
found in the previous phase are re-extracted and those that are not are just copied
?

?

?
Algorithm 2. inc classify(O1, O,1, X  O1
X)
Input:O1: an ontology

O = (
1: subsumption relations in O1
X  O1

O, +O): removed / added axioms
X: a module for every X  CN(O1)  {}

Output:O2: the result of applying the change O to O1

2: subsumption relations in O2
X  O2

X: a module for every X  CN(O2)  {}

X)) then

X)) then

O)  +O

end for
for each   +O do

if not s local(, Sig(O1
M+ M+ {X}

O1
for each  1 Y do A 1 Y  true
for each X 1 do X 1 A  true
   M+  
for each   
 M

end if

1: O2  (O1 \ 
2: for each A  CN(O2) \ CN(O1) do
 O1
3:
4:
5:
6: end for
7: M
8: for each X  CN(O2)  {} do
O do
9:
if not s local(, Sig(O1
10:
 {X}
11:
12:
13:
14:
15:
16:
17:
18:
19: end for
20: for each X  CN(O2)  {} do
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34: end for
35: return O2,2, X  O2

O2
O2

end if
for each Y  CN(O2)  {} do
and X 1 Y ) or
if (X  M
(X  M+ and X 1 Y ) then
X 2 Y  test(O2
X 2 Y  X 1 Y

  M+ then
 extract module(Sig(X),O2)
 O1

if X  M

else

end if

end for

|= X  Y )

else

end if

end for



B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

(lines 2125). Then, every subsumption X  Y , using Proposition 3, is either recomputed against the module O2

X, or is reused from O1 (lines 2633).

In Algorithm 5, the procedure extract module(S, O) refers to Algorithm 1 in Section 4.
The procedure test(O |= X  Y ) uses a reasoner to check if O entails the subsumption
X  Y . The correctness of the algorithm is easy to prove using Proposition 2 and
Proposition 3.

It is worth emphasizing that, in our algorithm, the reasoner is only used as a black
box to answer subsumption queries; this provides two important advantages: on the one
hand, the internals of the reasoner need not be modified and, on the other hand, any
sound and complete reasoner for OWL DL can be plugged in, independently of the
reasoning technique it is based on (e.g. tableaux or resolution).
To conclude, we illustrate the execution of Algorithm 5 on the ontologies O1,O2 in
Table 1, where the sets O and +O of removed and added axioms for our example
are given in the lower part of Table 1. In our case, O2 doesnt introduce new atomic
concepts w.r.t. O1. Thus, Phase 1 in Algorithm 2 can be skipped. The sets M
, M+
= {Cystic Fibrosis, Pancreatic Fibrosis} and
computed in Phase 2 are as follows: M
M+ = {Cystic Fibrosis} since the axiom in O (see Table 1) is not sytactically local
w.r.t. the signature of the module in O1 for Cystic Fibrosis and Pancreatic Fibrosis;
analogously, the axiom in +O is non-local w.r.t. the signature of the module in O2
for Cystic Fibrosis. In Phase 3, the modules for Cystic Fibrosis and Pancreatic Fibrosis
are re-computed. In the former module, the algorithm recomputes only the subsumption
relations between Cystic Fibrosis and Pancreatic Fibrosis and their subsumers in O1;
in the latter one, the only the subsumption relations between the non-subsumers of
Cystic Fibrosis in O1 are computed.



6 Empirical Evaluation

We have implemented Algorithm 2 and used the OWL reasoner Pellet for evaluation.
Our implementation is, however, independent from Pellet, and our results intend to
determine the usefulness of our approach for optimizing any reasoner. Our system implements a slightly more simplistic procedure than the one in Algorithm 2; in particular,
once the affected modules have been identified, our implementation simply reclassifies
the union of these modules using Pellet to determine the new subsumption relations,
instead of using the procedure described in lines 2034 of Algorithm 2.

As a test suite, we have selected a set of well-known ontologies that are currently
being developed. NCI6, and the Gene Ontology7 are expressed in a simple fragment of
OWL DL. In contrast, GALEN8, and NASAs SWEET ontology9 are written in a more
expressive language. Table 5 includes their expressivity, number of atomic concepts and
axioms, total classification time in Pellet, and the percentage of possible subsumption
relations that actually hold between atomic concepts. Note that for large ontologies,

6 http://www.mindswap.org/2003/CancerOntology/nciOncology.owl
7 http://www.geneontology.org
8 http://www.openclinical.org/prj galen.html
9 http://sweet.jpl.nasa.gov/ontology/
?

?

?
Table 5. Test suite ontologies

 Concept
?

?

?
Ontology Logic
SWEET SHOIF

Galen
?

?

?
Class. % Init. Mod. Mod. Size Non-Loc.
Names Axioms Time (s.) Subs Extract (s.) (Avg/Max) Axioms
?

?

?
76 / 420
75 / 530
17.6 / 161
28.9 / 436
?

?

?
1.05
4.8
69.6
76.5

0.37
0.37
0.04
0.03

3.6
15.7

41.1

over 99% of subsumpton relations do not hold. Table 5 also shows the average time to
extract the modules for all atomic concepts, as well as the average and maximum size of
these modules (in terms of the number of axioms). Even if the initial module extraction
may introduce overhead, we argue that this startup-cost is bearable since the set of
all modules needs only be computed once. We observe that, in general, the modules are
very small relative to the size of the ontology.

We have performed the following experiment for each ontology: for various numbers
n, we have 1) removed n random axioms; 2) classified the resulting ontology using
Pellet; then, we have repeated the following two steps 50 times: 3) extracted the minimal
locality-based module for each atomic concept, 4) removed an additional n axioms,
added back the previously removed n axioms, and reclassified the ontology using our
incremental algorithm. Our goal is to simulate the ontology evolution process where n
axioms are changed (which can be viewed as a simultaneous deletion and addition); all
results have been gathered during step 4) of the experiment. We considered different
types of axioms, namely concept definitions, GCIs and role axioms.

Table 6 summarizes the results of the experiments for n = 2. Columns 1 and 2 detail the number of affected modules and their total size respectively. It can be observed
that, in general, only a very small number of the modules are affected for a given up-
date. Column 3 provides the total time to locate and re-extract the affected modules;
Column 4 shows the reclassification time for all the affected modules after they have
been re-extracted. In all cases, the average time is significantly smaller than standard
re-classification. It can be observed that, in the case of Galen, the maximum time to
classify the affected modules actually takes longer than classifying the entire ontology.
While unexpected, this is likely caused as traditional classification optimizations (e.g.,
model merging, top-bottom search, etc.) are not as effective, due to affected modules

Table 6. Results for varying update sizes for class and role axioms. Time in seconds.

1:  Mod. 2:  Axioms 3: Update 4: Re-class. 5. Total
Affected in Aff. Mod. Aff. Mod. Aff. Mod.
Time
(Av / Mx)
(Av / Mx)
545 / 3025
.21 / 1.2
281 / 857 .097 / .929 .182 / 1.4
2.8 / 13
.05 / .47
.07 / .43
.25 / 3.2

2 134 / 1045 1003 / 2907 .833 / 3.6
.24 / 1.4
1 39.2 / 1513 127 / 1896
216 / 1383

46 / 891
.5 / 2.8
4 97 / 1339
474 / 3021 1.4 / 10.1

6:  New 7:  Mod.
(Non)Sub. (Non)Sub
(Av / Mx) (Av / Mx) (Av / Mx)
1.03 / 6.77 54 / 1268 17 / 348
.280 / 2.3
39 / 686 20.1 / 255
3.6 / 16.5 111 / 1594 17 / 158
69 / 2964 33 / 1499
.29 / 1.5
.57 / 3.2
51 / 1079 26 / 775
1.7 / 13.4 94 / 1291 44 / 1034

n (Av / Mx)
?

?

?
67 / 936
SWEET 2 36.9 / 300
Galen
?

?

?
(Av / Mx)
.81 / 5.4

B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

Table 7. Results for varying update sizes for role axiom changes only. Time in seconds.

1:  Mod.
Affected
(Av / Mx)

2:  Axioms 3: Update 4: Re-class. 5. Total
in Aff. Mod. Aff. Mod. Aff. Mod.
Time
(Av / Mx)
(Av / Mx)

6:  New 7:  Mod.
(Non)Sub. (Non)Sub
(Av / Mx) (Av / Mx) (Av / Mx)

(Av / Mx)

n
2 2274 / 10217 12161 / 29091 25.7 / 60.4 10.4 / 30.8 36.2 / 91.3

0 / 0

SWEET 2
Galen

116 / 296
2 524 / 1906

411 / 956
1813 / 3780

.42 / .93
2.1 / 4.7

.6 / 1.4
6.5 / 15.6 8.6 / 20.4

1.03 / 2.33 .56 / 28
3.3 / 82

0 / 0

.28 / 14
2.5 / 37

Table 8. Results for varying update sizes for concept axiom changes only. Time in seconds.

6:  New 7:  Mod.
1:  Mod. 2:  Axioms 3: Update 4: Re-class. 5. Total
(Non)Sub. (Non)Sub
Affected in Aff. Mod. Aff. Mod. Aff. Mod.
Time
(Av / Mx) (Av / Mx) (Av / Mx)
(Av / Mx)
.75 / 11.4 67 / 2228 20 / 610
.15 / 2.6
.07 / .65 .095 / .732 31 / 553
12 / 241
2.6 / 15.4 3.4 / 19.5 69 / 4323 42 / 1178

(Av / Mx)

396 / 5387
SWEET 2 15.2 / 243 276 / 800
2 131 / 1463 913 / 3397
Galen

(Av / Mx)
.59 / 8.7
.02 / .07
.84 / 4.5

n (Av / Mx)
2 33 / 847

containing a subset of the original axioms; therefore, additional subsumption checks
have to be performed. We note, however, that on average this does not occur. Column
5 presents the total time to update the modules, load them into the reasoner, and reclassify them; it can be seen that this outperforms reclassifying from scratch. For future
work, we plan to more tightly integrate the approach into Pellet, as this will avoid the
additional overhead attributed to loading the affected modules into the reasoner for
classification. Column 6 shows the number of new subsumption and non-subsumption
relations (i.e., the sum) for each ontology, and column 7 provides the average number
of modules which have a new subsumption or non-subsumption after a change. The
number of new (non) subsumptions is very small, which supports our initial hypothesis
that changes do not typically affect a large portion of the original ontology. In the case
of SWEET, the ratio of modules with new (non)subsumptions is relatively high when
compared to the average number of modules affected; specifically in these cases, almost
50% of the affected modules actually contains a new subsumption/non-subsumption relation after the update. This empirically demonstrates that locality-based modules can
be very effective for maintaining (non)subsumptions relations as the underlying ontology changes. Finally, the last two rows of the Table show the results for n = 1, 2, 4
in the case of the Gene Ontology. These results suggests that incremental classification
time may grow linearly with the number of modified axioms; similar behavior can be
observed for the remaining ontologies.

Table 7 considers the particular case of changes to role axioms only10. As shown in
Table 7, for SWEET the results are comparable to those presented in Table 6. For NCI
and Galen, changes in role axioms do have a more substantial impact.

The particular case of changes to concept axioms only is provided in Table 811. It
can be observed that the are much better than those when only role axiom changes are

10 GO has not been included in Table 7 as it only contains one role axiom.
11 Again GO has not been included in Table 8 as it only contains one role axiom.
?

?

?
performed. These results confirm that role axioms may cause larger effects than changes
in concept definitions.

7 Related Work

While there has been substantial work on optimizing reasoning services for description
logics (see [10] for an overview), the topic of reasoning through evolving DL knowledge bases remains relatively unaddressed. Notable exceptions include [7,8,9,12]; these
papers, however, investigate the problem of incremental reasoning using model-caching
techniques in application scenarios that involve changes only in the ABox.

There has been substantial work on incremental query and view maintenance in
databases (e.g., [1,15,16]) and rule-based systems (e.g., Datalog [4,5]). While related,
our work addresses a more expressive formalism; further, traditionally in database systems the problem of incremental maintenance is considered with respect to data (corre-
sponding to DL ABoxes) and not with respect to the database schema (corresponding
to DL TBoxes). Our technique, however, focuses on schema reasoning.

There has additionally been extensive work in Truth Maintenance Systems (TMSs)
for logical theories (e.g., [3,6]). As pointed out in Section 3, a justification-based approach would be advantageous for incremental classification only if the number of positive subsumptions was larger than the number of non-subsumptions; that is, if most of
the formulas the justifications keep track of were provable. This is, however, not the
case, as typically there are far more non-subsumptions than subsumptions. Addition-
ally, a TMS system designed to support non-subsumptions (e.g., by caching models)
would most likely be impractical due to the potentially large size of these models and
substantial modifications likely to be caused by changes in general axioms; however, in
our approach, maintaining locality-based modules introduces limited overhead. Finally,
the representation language in practical TMSs is mostly propositional logic, whereas
we focus on much more expressive languages.

8 Conclusion

We have proposed a general technique for incremental reasoning under arbitrary changes
in an ontology. We have used locality-based modules due to their compelling properties
and applied our method to incremental classification of OWL DL ontologies.

For ontology development, it is desirable to re-classify the ontology after a small
number of changes. In this scenario, our results are very promising. Incremental classification using modules is nearly real-time for almost all ontologies and therefore the
reasoner could be working transparently to the user in the background without slowing down the editing of the ontology. There are, however, some disadvantages of our
approach. First, there are cases where a change which does not affect the concept hi-
erarchy, affects a large number of modules; second, for complex ontologies including
nominals, such as the Wine ontology, the modules can be large; third classifying a
(large enough) fragment might be more expensive than classifying the whole ontology.
In most cases, however, our incremental approach provides a substantial speed-up w.r.t.

B. Cuenca Grau, C. Halaschek-Wiener, and Y. Kazakov

regular classification. For future work, we are planning to exploit modules for incremental ABox reasoning tasks, such as query answering.

Acknowledgements. This work is supported by the EU Project TONES (Thinking ON-
tologieES) ref:IST-007603 and by the EPSRC Project REOL (Reasoning in Expressive
Ontology Languages) ref:EP/C537211/1. We would like to acknowledge Evren Sirin
and Mike Smith for their contributions to the empirical evaluation presented here.
