Using Tableau to Decide Expressive Description

Logics with Role Negation

Renate A. Schmidt and Dmitry Tishkovsky

School of Computer Science, The University of Manchester
{renate.schmidt,dmitry.tishkovsky}@manchester.ac.uk

Abstract. This paper presents a tableau approach for deciding description logics outside the scope of OWL DL/1.1 and current state-of-the-art
tableau-based description logic systems. In particular, we define a sound
and complete tableau calculus for the description logic ALBO and show
that it provides a basis for decision procedures for this logic and numerous other description logics with full role negation. ALBO is the extension of ALC with the Boolean role operators, inverse of roles, domain and
range restriction operators and it includes full support for nominals (in-
dividuals). ALBO is a very expressive description logic which subsumes
Boolean modal logic and the two-variable fragment of first-order logic
and reasoning in it is NExpTime-complete. An important novelty is the
use of a generic, unrestricted blocking rule as a replacement for standard
loop checking mechanisms implemented in description logic systems. An
implementation of our approach exists in the MetTeL system.

1 Introduction

Mainstream description logics systems and ontology web languages provide a rich
supply of concept operators, but there is currently little support for complex role
operators. This places significant restrictions on the expressiveness of ontology
languages and the utility of systems. For example, in the description logic ALC
(and other popular extensions of ALC) [1] it is possible to define a spam filter as
a mechanism for filtering out spam emails (i.e. x  spam-filter iff x  mechanism
y . (x, y)  filter-out y  spam-email), and a sound spam filter as a spam filter
which filters out only spam emails (i.e. x  -sound-spam-filter iff x  spam-filter
y . (x, y)  filter-out  y  spam-email), by specifying

()

spam-filter def= mechanism  filter-out.spam-email

sound-spam-filter def= spam-filter  filter-out.spam-email.

But it is not possible to define a complete spam filter as a spam filter which
filters out every spam email, i.e. x  complete-spam-filter iff x  spam-filter 
y . y  spam-email  (x, y)  filter-out. This can be expressed by the following.
()

complete-spam-filter def= spam-filter  filter-out.spam-email

K. Aberer et al. (Eds.): ISWC/ASWC 2007, LNCS 4825, pp. 438451, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
This uses the role negation operator which is not available in ALC or description
logics that form the basis of OWL DL/1.1. Both () and () involve universal
quantification but of a different kind. In () it is the image elements of a role
that are universally quantified, while in () it is the elements in a concept that
are universally quantified. From an applications perspective there is little justification to give preference to one form of universal quantification over the other,
since clearly both are useful. () expresses the necessity of a property and () expresses the sufficiency of a property. Natural examples of both kinds of universal
quantification can be found in many domains and every-day language.

In this paper we are interested in description logics that allow role negation
(and can therefore accommodate examples such as the above), but also provide
a range of other role operators not usually supported. In particular, we focus
on a description logic, called ALBO, which is an extension of the description
logic ALB [6] with singleton concepts, called nominals in modal logic. ALB is
the extension of ALC, in which concepts and roles form a Boolean algebra, and
additional operators include inverse of roles and a domain restriction operator.
ALBO therefore extends ALC by union of roles, negation of roles, inverse of roles,
and domain as well as range restriction. In addition, it provides full support for
ABox individuals and singleton concepts.
None of the current state-of-the-art tableau-based description logic systems
are able to handle ALBO (or ALB). Because ALBO allows full negation of roles,
it is out of the scope of OWL DL, OWL 1.1 and most description logic systems
including Fact++, KAON2, Pellet, and RacerPro. A tableau decision procedure for the description logic ALCQIb which allows for Boolean combinations
of safe occurrences of negated roles is discussed in [14]. Safeness essentially
implies a guardedness property which is violated by unsafe occurrences of role
negation. Description logics with full, i.e. safe and unsafe, role negation can be
decided however by translation to first-order logic and first-order resolution theorem provers such as MSpass, Spass, E and Vampire. The paper [6] shows
that the logic ALB can be decided by translation to first-order logic and ordered resolution. This result is extended in [4] to ALB with positive occurrences
of composition of roles. ALBO can be embedded into the two-variable fragment
of first-order logic with equality which can be decided with first-order resolution methods [3]. This means that ALBO is decidable and can be decided using
first-order resolution methods.
ALBO is a very expressive description logic. It subsumes the Boolean modal
logic and tense, hybrid versions of Boolean modal logic with the @ operator and
nominals. It can also be shown that ALBO subsumes the two-variable fragment
of first-order logic (without equality) [7]. The following constructs and statements can be handled in ALBO.

image operator, cross product, and (left and right) cylindrification.

 Role negation, the universal role, the sufficiency or window operator, the
 Role inclusion axioms and role equivalence axioms in the language of ALBO.
 Role assertions in the language of ALBO.

R.A. Schmidt and D. Tishkovsky

axioms.

assertions.

 Boolean combinations of both concept and role inclusion and equivalence

 Boolean combinations of concept and role assertions, including negated role

 Disjoint roles, symmetric roles and serial roles. (It is not difficult to extend
our method and results to include full equality handling including reflexive
roles, identity and diversity roles, and the test operator.)

ALBO is in fact very close to the brink of undecidability, because we know
that adding (negative occurrences of) role composition to ALB takes us into
undecidable territory [12].
Since ALBO subsumes Boolean modal logic it follows from [9] that the satisfiability problem in ALBO is NExpTime-hard. In [5] it is shown that satisfiability
in the two-variable first-order fragment with equality is NExpTime-complete. It
follows therefore that the computational complexity of ALBO-satisfiability is
NExpTime-complete.

Few tableau calculi or tableau procedures have been described for description
logics with complex role operators, or equivalent dynamic modal logic versions.
Ground semantic tableau calculi and tableau decision procedures are presented
in [4] for the modal versions of ALC(,, 1), i.e. ALC with role union, role
intersection and role inverse. These are extended with the domain restriction
operator, to ALC(,, 1, ), in [11]. A semantic tableau decision procedure for
ALC with role intersection, role inverse, role identity and role composition is
described in [10]. None of these tableaux make provision for the role negation
operator however. In [13] a sound and complete ground semantic tableau calculus
is presented for Peirce logic, which is equivalent to the extension of ALB with role
composition and role identity. However the tableau is not terminating because
reasoning in Peirce logic is not decidable.

In this paper we develop a tableau approach which can decide description
logics with the role negation operator. We present a ground semantic tableau
approach which decides the description logic ALBO. The style of tableau is similar to that of [4,11,13] but a notable difference is that our tableau calculi operate
only on ground labelled concept expressions. This makes it easier in principle to
implement the calculi as extensions of existing tableau-based description logic
systems which can handle singleton concepts.

In order to limit the number of individuals in the tableau we need a mechanism
for detecting periodicity in the underlying interpretations (models). Standard
loop checking mechanisms are based on comparing sets of (labelled or unlabelled)
concept expressions such as subset blocking or equality blocking. Instead of using
the standard loop checking mechanisms, our approach uses a new inference rule,
the unrestricted blocking rule, and equality reasoning. Our approach has the
following advantages over standard loop checking.
 It is conceptually simple and easy to implement.
 It is universal and does not depend on the notion of a type.
 It is versatile and enables more controlled model construction in a tableau
procedure. For instance, it can be used to construct small models for a
?

?

?
satisfiable concept, including domain minimal models. Our tableau approach
has the further advantage that it constructs real models, whereas the tableau
procedures for many OWL DL/1.1 description logics construct only pseudomodels (which are not always real models but can be completed to real
models).

 Our blocking mechanism generalises to other logics, including full first-order

logic.

 It can be simulated in first-order logic provers.

The unrestricted blocking rule corresponds to an unrestricted version of the
first-order blocking rule invented by [2], simply called the blocking rule. The
blocking rule is constrained to individuals  and  such that the individual 
is an ancestor of the individual . I.e. in the common branch of  and , the
individual  is obtained from  as a result of a sequence of applications of the
existential restriction rule. In this form, the rule can be used to simulate standard
loop checking mechanisms such as subset blocking and equality blocking.
The structure of the paper is as follows. The syntax and semantics of ALBO
is defined in Section 2. In Section 3 we define a tableau calculus for ALBO
and prove that it is sound and complete without the unrestricted blocking rule.
Section 4 introduces our blocking mechanism and proves soundness, completeness and termination of the extended tableau calculus. This allows us to define
general criteria for decision procedures for ALBO and its sublogics which are
discussed in Section 5. We conclude in Section 6.
2 Syntax and Semantics of ALBO
The syntax of ALBO is defined over the signature  = (O, C, R) of three disjoint alphabets: O = {0, 1, . . .} the alphabet of individuals (object names),
C = {p0, p1, . . .} the alphabet of concept symbols, and R = {r0, r1, . . .} the alphabet of role symbols. The logical connectives are:  (negation),  (union),  (ex-
istential concept restriction), 1 (role inverse),  (domain restriction),  (range
restriction). Concept expressions (or concepts) and role expressions (or roles)
are defined as follows:

C def= p | {} | C | C  D | R.C,
R def= r | R1 | R | R  S | RC | RC.

p ranges over the set C,  ranges over O, and r ranges over R. The intersection
operator  on concepts and roles is defined as usual in terms of  and , and the
top and bottom concepts are defined by  def= pp and  def= pp, respectively,
for some concept name p. The universal restriction operator  is a dual to the
existential restriction operator , specified by R.C def= R.C.
Next, we define the semantics of ALBO. A model (or an interpretation) I
of ALBO is a tuple I = (I , pI
0 , . . .), where I is a non-empty

0 , . . . , rI

0 , . . . , I
?

?

?
is a subset of I, I

set, pI
0 is a binary relation over I. The
semantics of concepts and roles in the model I, i.e. CI and RI, is specified by:
1 = {(x, y) | (y, x)  RI},
)

 I, and rI

i

i

{}I def= {I},
(C)
(C  D)

I def= I \ CI ,
I def= CI  DI,

(R1)
(R)
(R  S)

I def= (RI
I def= (I  I
def= RI  SI,

) \ RI,

(RC)
(RC)
(R.C)

I def= {(x, y) | x  CI and (x, y)  RI},
I def= {(x, y) | y  CI and (x, y)  RI},
I def= {x | y  CI

(x, y)  RI}.

A TBox (respectively RBox ), is a (finite) set of inclusion statements C  D (re-
spectively R  S) which are interpreted in any model I as subset relationships,
namely CI  DI (respectively RI  SI). An ABox is a (finite) set of statements of the form  : C or (, ) : R, called concept assertions or role assertions.
A knowledge base is a tuple (T, R, A) of a TBox T , an RBox R, and an ABox A.

In ALBO various additional operators can be defined, including:

Top role:
Bottom role:
Universal modality:
Image operator:
Sufficiency, or window, operator:
Left cylindrification:
Right cylindrification:
Cross product:

 def= r  r (for some role symbol r)
 def= 
C def= .C

1R.C def= R1.C
R.C def= R.C

Cc def= C
cC def= C

C  D def= Cc  cD

Concept assertions can be expressed as concept expressions as follows:  : C def=
.({}  C). (It is clear that ( : C)I =  iff I  CI in every model I.)
A role assertion (, ) : R can be expressed as a concept assertion, namely
(, ) : R def=  : R.{}, or by the above as a concept expression. We refer to
 : R.{}, or a role assertion, as a link (between the individuals  and ). In
addition, concept and role inclusion axioms are definable as concept expressions.

C  D def= .(C  D)
R  S def= .(R  S).

Thus, Boolean combinations of inclusion and assertion statements of concepts
and roles are also expressible in ALBO as the corresponding Boolean combinations of the concepts which represent these statements. As usual, concept
satisfiability in ALBO with respect to any knowledge base can be reduced to
concept satisfiability with respect to a knowledge base where all TBox, RBox,
and ABox are empty. Without loss of generality we therefore focus on the problem of concept satisfiability in ALBO.
?

?

?
Often description logics are required to satisfy the unique name assumption.
We do not assume it for ALBO. This is inconsequential, because the unique name
assumption can be enforced by disjointness statements of the form {}{}  
for every distinct pair of nominals that occur in the given knowledge base.

Above we defined the cylindrification operators and cross product in terms
of the domain and range restriction operators. In fact, each of the operators
in {, ,c, c,} are interdefinable. Thus, we could have defined ALBO as an
extension of ALCO(,, 1) with one of these operators. It can be shown that
regardless as to which of these is used to define ALBO, problems in ALBO are
linearly reducible to problems in ALCO(,, 1). For instance, suppose ALBO
is defined as the extension of ALCO(,, 1) with left cylindrification. The satisfiability of a concept C, say, in ALBO can then be encoded in ALCO(,, 1)
by replacing all occurrences of Dc in C by a new role symbol qDc uniquely associated with Dc and adding the definitions D  qDc. and D  qDc .
to the knowledge base. In a similar way, problems involving the other operators from {, ,c, c,} can be linearly encoded in ALCO(,, 1). We leave it
to the reader to make sharper observations concerning the definability of these
operators in description logics.

Let us give our first technical result. The following theorem can be proved

using a filtration argument.
Theorem 1 (Finite Model Property). ALBO has the finite model property,
i.e., if a concept C is satisfiable, then it has a finite model.

3 Tableau Calculus

Let T denote a tableau calculus and C a concept. We denote by T (C) a finished
tableau built using the rules of the calculus T starting with the concept C as
input. I.e. we assume that all branches in the tableau are expanded and all
applicable rules of T have been applied in T (C). As usual we assume that all the
rules of the calculus are applied non-deterministically, to a tableau. A branch of
a tableau is closed if a contradiction has been derived in this branch, otherwise
the branch is called open. The tableau T (C) is closed if all its branches are closed
and T (C) is open otherwise. We say that T is terminating (for satisfiability) iff
for every concept C either T (C) is finite whenever T (C) is closed or T (C) has
a finite open branch if T (C) is open. T is sound iff C is unsatisfiable whenever
T (C) is closed for all concepts C. T is complete iff for any concept C, C is
satisfiable (has a model) whenever T (C) is open.

Let TALBO be the tableau calculus consisting of the rules listed in Figure 1.
Inference steps are performed in the usual way. A rule is applied to a set of
expressions (often just one expression) in a branch of a tableau, if the expressions
are instances of the premises of the rule. Then, in the case of a non-branching
rule, the corresponding instances of the conclusions of the rule are added to the
branch. A branching rule splits the branch into several branches (here two) and
adds the corresponding instances of the conclusions to each branch.

R.A. Schmidt and D. Tishkovsky

Rules for ALCO:

():

():

 : {
}
 : {}
 : R.C
 : R.{},

(sym):

():

 : C,

 : C

 : (C  D)
 : D
 : C,
 : {
}
(sym):
 : {}
is new)

(
?

?

?
 : C

(bridge):

Rules for complex roles:

():

(1):

():

():

():

 : (R  S).{

}

 : R.{} |  : S.{}
 : R
}
1.{
 : R.{}
 : (RC).{
 : C,
 : (RC).{
 : C,
}
 : R.{
 : R.{}

}
 : R.{}
}
 : R.{}

():

 : C
 : C
 : (C  D)
():
 : C |  : D
 : {
},

 : C
 : R.C,
():
}

: C

: {
?

?

?
(refl):

 : R.{

 : C
 : {}
}

 : C

(mon):

 : R.{

},
?

?

?
 : R.{}

: R.{}

():

(1):

():

():

():

 : (R  S).C
 : S.C
 : R.C,
 : R
1.C,
?

?

?
 : C
 : (RC).D
 : C |  : R.D
 : (RC).D
 : R.(C  D)
 : R.C,
: {
}
 : R.{} |  : C
?

?

?
Fig. 1. Tableau calculus TALBO for ALBO

The first group of rules are standard for ALC and reasoning with individuals.
The () rule is the closure rule. The () rule removes occurrences of double
concept negation. (The rule is superfluous if double negations are eliminated
using on-the-fly rewrite rules.) The () and () rules are standard rules for
handling concept disjunctions. The (sym), (mon), (refl), and (bridge) rules are
the equality rules for individuals, which are familiar from hybrid logic tableau
systems, and can be viewed as versions of standard rules for first-order equal-
ity. The (refl) rule is formulated perhaps a bit unusually, but the purpose of
the premise is to ensure that the rule is realised only for individuals actually
occurring in the branch. The (sym) rule is needed to ensure that any negated
singleton concept will eventually appear as a label in a concept assertion. As
usual, and in accordance with the semantics of the existential restriction opera-
tor, for every existentially restricted concept the () rule creates a new individual
with this concept and adds a link to the new individual. It is the only rule which
generates new individuals in the calculus. The () rule is equivalent to the
standard propagation rule for universally restricted concept expressions.
?

?

?
The rules in the second group are rules for decomposing complex role expres-
sions. They can be divided into two subgroups: rules for positive existential role
occurrences and rules for negated existential role occurrences (in the left and
right columns, respectively). Due to the presence of the () rule, the rules for
positive existential roles can be restricted to role assertions. (On the side we
note that the rule () can be replaced by this closure rule:  : R.{},  :
R.{}/.) Among the rules for negated existential roles, the (1) rule and
and the () rule are special. The (1) rule allows the backward propagation of concept expressions along inverted links (ancestor links). The () rule
is the rule for the sufficiency operator. It expands a universally restricted concept in which the role is negated according to the semantics: x  (R.C)I iff
y((x, y)  RI  y  (C)I). That is,  is implicitly quantified by a universal
quantifier. The effect of the second premise,  : {}, is to instantiate  with
individuals that occur in the branch. The remaining rules in this subgroup are
based on obvious logical equivalences in ALBO.
Tableau rules which do not produce new individuals are called type-completing
rules. In the case of TALBO, with the exception of the () rule, all rules are type-
completing.

Now, given an input concept C, a tableau derivation is constructed as follows.
First, preprocessing is performed which pushes the role inverse operators toward
atomic concepts by exhaustively applying the following role equivalences from
left to right.
(R)
(RC)

1 = R1  S1,
1 = R1C,

1 = (R1),
1 = R1C,

(R  S)
(RC)

(R1)

1 = R.

Next, the preprocessed input concept C is tagged with a fresh individual name 
that does not occur in C. Then we build a complete tableau TALBO(C) by
applying the rules of TALBO to the concept assertion  : C as described above.
It is however important to note that  : C and all labelled expressions and
assertions really denote concept expressions.

We turn to proving soundness and completeness of the calculus. Because every
rule preserves the satisfiability of concept assertions, it is easy to see that the
calculus TALBO is sound for ALBO.
For proving completeness, suppose that a tableau TALBO(C) for the given
concept C is open, i.e. it contains an open branch B. We construct a model I
def  : {}  B. It
for the satisfiability of C as follows. By definition, let   
is clear that the rules (sym), (mon), and (refl) ensure that  is an equivalence
relation on individuals. The equivalence class  of a representative  is defined
by:  def= { |   }. We set
I def= { |  : {}  B},
pI def= { |  : p  B},

rI def= {(,) |  : r.{}  B},
I def=

,
 for some   I, otherwise.

if  : {}  B,

R.A. Schmidt and D. Tishkovsky

1. TBox = {r.p}. . . . . . . . . . . . . . . .given
2. 0 : r.p. . . . . . . . . . . . . . . . . . . . .TBox,1
3. 1 : p . . . . . . . . . . . . . . . . . . . . . . . . . . (),2
4. 0 : r.{1} . . . . . . . . . . . . . . . . . . . . (),2
5. 1 : r.p. . . . . . . . . . . . . . . . . . . . .TBox,1

6. 0  1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . .Loop checking: p is a difference
7. 2 : p . . . . . . . . . . . . . . . . . . . . . . . . . . (),5
8. 1 : r.{2} . . . . . . . . . . . . . . . . . . . . (),5
9. 2 : r.p. . . . . . . . . . . . . . . . . . . . .TBox,1
10. 1  2 . . . . . . . . . . . . . . .Loop checking

Fig. 2. Standard loop checking mechanism in ALCO

The rules (sym), (mon), (refl), and (bridge) ensure that the definition of I does
not depend on representatives of the equivalence classes.

The following lemma is proved by induction over the structure C.

Lemma 1.

(1) If  : D  B then   DI for any concept D.

(2) For every role R and every concept D

(2a)  : R.{}  B implies (,)  RI,
(2b) if (,)  RI and  : R.D  B then  : D  B.
A consequence of this lemma is completeness of the tableau calculus.
Theorem 2. TALBO is a sound and complete tableau calculus for satisfiability
in ALBO.

4 Blocking

There are satisfiable concepts which result in an infinite TALBO-tableau, where
all open branches are infinite. The concept (ss).r.p is such an example.
Indeed, since the prefix (s  s). is equivalent to the universal modality,
the concept  : r.p is propagated to every individual  in every branch of the
tableau. The concept  : r.p itself, each time triggers the creation of a new
individual with the () rule. Thus, any branch of the tableau contains infinitely
many individuals. The branches have however a regular structure that can be
detected with loop detection or blocking mechanisms.
Observe that satisfiability of the concept (ss).r.p corresponds to satisfiability of the TBox {r.p} in the description logic ALCO. Figure 2 demonstrates how standard loop checking (subset blocking) for the description logic
ALCO with general TBoxes detects a loop in this example. (In the figure each
line in the derivation is numbered on the left. The rule applied and the number
of the premise(s) to which it was applied to produce the labelled concept expression (assertion) in each line is specified on the right.) Loop checking tests are
performed after all the type-completing rules have been applied to all concept
expressions labelled with a specific individual relative to an ancestor individ-
ual. In the tableau in Figure 2, two loop checking tests are performed, namely
in step 6 and step 10. Take step 10. All the type-completing rules have been
applied to all concept expressions of the form 2 : C and 1 : C. This means
the r.p-types of the individuals 1 and 2, of the partial model constructed so
far, are complete. Comparison of the types shows that they coincide and, conse-
quently, the individuals 1 and 2 can be identified. At step 6 the r.p-types of
?

?

?
1. 0 : r.p. . . . . . . . . . . . . . . . . . . . . . .given
2. 0 : s.p. . . . . . . . . . . . . . . . . . . . . . .given
3. 0 : t.t.s
1.(p  p) . . . . . . given
4. 0 : t.t.s
1.(p  p) . . . given
5. 1 : p . . . . . . . . . . . . . . . . . . . . . . . . . . (),1
6. 0 : r.{1} . . . . . . . . . . . . . . . . . . . . (),1
7. 1 : {1} . . . . . . . . . . . . . . . . . . . . . (refl),5
8. 2 : p . . . . . . . . . . . . . . . . . . . . . . . . . . (),2
9. 0 : s.{2} . . . . . . . . . . . . . . . . . . . . (),2
10. 2 : {2} . . . . . . . . . . . . . . . . . . . . . (refl),8
11. 3 : t.s
1.(p  p) . . . . . . . . . (),3
12. 0 : t.{3} . . . . . . . . . . . . . . . . . . . . (),3

1.(p  p) . . (),4,12
13. 3 : t.s
14. 3 : t.{2} . . . . . . . . . . . (),13,10
2 : s
1.(p  p). . . . . (),11,14
15.
0 : (p  p) . . . . . . . . . (1),15,9
16.
17. Unsatisfiable . . . . . after a few steps
18. 2 : s
1.(p  p). .(),13,10
1.(p  p) . . . . . . . . . (),18
2 : s
19.
20. 3 : t.{1}. . . . . . . . . . .(),13,7
1.(p  p) . . . (),11,20
1 : s
21.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . .
22. 1 : s
1.(p  p) . (),13,7
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . .

Fig. 3. Global effect of the introduction of a new individual

0 and 1 are different because 0 : p is not present in the branch. The derivation
therefore cannot yet stop, but does in step 10.

This example illustrates the simplest form of standard loop checking used in
description and modal logic tableau procedures. This form of loop checking is
too simple to handle role negation though. The problem is that the introduction
of a new individual in a tableau has, in general, a global effect in the provisional model constructed so far. This global effect is illustrated by the example
in Figure 3. (The black triangles in the figure denote branching points in the
derivation. A branch expansion after a branching point is indicated by appropriate indentation.) At step 10 none of the type-completing rules need to be
applied to concepts labelled with 1 and 2. Although at this point 1 and 2
are labels of the same subconcepts of the given concepts, we cannot make them
equal. The reason is that at step 11 a new individual is introduced which causes
a few applications of the () rule, and as a result, at step 21, the types of 1
and 2 are now distinguished by the concept s1.(p  p).
The examples illustrate that the reason for non-termination of TALBO is the
possible infinite generation of labels. The following lemma holds, where #(B)
denotes the number of applications of the () rule in a branch B.
Lemma 2. If #(B) is finite then B is finite.
In order to turn the calculus TALBO into a terminating calculus for ALBO, we
introduce a new, different approach to blocking.

Let < be an ordering on individuals in the branch which is a linear extension
of the order of introduction of the individuals during the derivation. I.e. let
 < , whenever the first appearance of individual  in the branch is strictly
later than the first appearance of individual . We add the following rule, called
the unrestricted blocking rule, to the calculus.

 : {},  : {}
 : {} |  : {}

(ub):

Moreover, we require that the following conditions hold.

R.A. Schmidt and D. Tishkovsky

(c1) Any rule is applied at most once to the same set of premises.
(c2) The () rule is applied only to expressions of the form  : R.C, when C
is not a singleton, i.e. C = {} for some individual .
(c3) If  : {} appears in a branch and  <  then all further applications of
the () rule to expressions of the form  : R.C are not performed within
the branch.
(c4) In every open branch there is some node from which point onwards before
any application of the () rule all possible applications of the (ub) rule
have been performed.

We use the notation TALBO(ub) for the extension of TALBO with this rule

and this blocking mechanism.

The blocking requirements (c1)(c4) are sound in the sense that they cannot
cause an open branch to become closed. The (ub) rule is sound in the usual
sense. Thus, the following theorem holds.
Theorem 3. TALBO(ub) is a sound and complete tableau calculus for ALBO.
Let B be the leftmost open branch with respect to the rule (ub) in the TALBO(ub)
tableau for a given concept C. Assume that I is a model constructed from B as
in Section 3.

It can be shown that the tableau procedure mimics the construction of a finite

model used in the proof of Theorem 1. Thus the following lemma holds.
Lemma 3. I is finite.
For every   I, let #() denote the number of applications of the () rule
to concepts of the form  : R.D with   .
Lemma 4.
(2) #(B) is finite.
Corollary 1. If the leftmost branch with respect to the rule (ub) in a TALBO(ub)
tableau is open then the branch is finite.

(1) #() is finite for every   I.

The termination theorem is an immediate consequence.
Theorem 4 (Termination). TALBO(ub) is a terminating tableau calculus for
satisfiability in ALBO.
Notice that condition (c4) is essential for ensuring termination of a TALBO(ub)
derivation. Indeed, it easy to see that without (c4) the TALBO(ub) tableau for
the concept ((s  s).r.p  (s  s).r.p) would not terminate because
new individuals are generated more often than their equality check is performed
via the rule (ub).

5 Decision Procedures

When turning the presented calculus TALBO(ub) into a deterministic decision
procedure it is crucial that this is done in a fair way. A procedure is fair if, when
?

?

?
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.

1. 0 : C . . . . . . . . . . . . . . . . . . . . . . . . . given
2. 0 : {0} . . . . . . . . . . . . . . . . . . . . . (refl),1
3. 0 : (s  s).r.p . . . . . . . . (),1
4. 0 : t.r.p . . . . . . . . . . . . . . (),1
5. 0 : t.r.p . . . . . . . . . . . . . . . . . (),4
6. 0 : s.r.p . . . . . . . . . . . . . . (),3
7. 0 : s.r.p . . . . . . . . . . . . (),3
8. 0 : s.{0} . . . . . . . . . . . . . (),7,2
0 : r.p . . . . . . . . . . . . . . . (),8,6
9.
0 : r.p . . . . . . . . . . . . . . . . . . . (),9
10.
1 : p . . . . . . . . . . . . . . . . . . . . . . . (),10
11.
0 : r.{1} . . . . . . . . . . . . . . . . . (),10
12.
1 : {1} . . . . . . . . . . . . . . . . . . (refl),11
13.
14. 0 : s.{1} . . . . . . . . . . (),7,13
1 : r.p . . . . . . . . . . . . (),14,6
15.
1 : r.p. . . . . . . . . . . . . . . . .(),15
16.
0 : {1} . . . . . . . . . . . . . . . . . . (ub)
17.
2 : r.p . . . . . . . . . . . . . . . . (),5
18.
0 : t.{2} . . . . . . . . . . . . . . . (),5
19.
2 : {2} . . . . . . . . . . . . . . (refl),18
20.
Fig. 4. An infinite derivation, due to unfair selection of concepts

0 : s.{2} . . . . . . . (),7,20
2 : r.p . . . . . . . . (),6,21
Unsatisfiable. . . . . . .(),18,22
2 : r.p . . . . . . . (),7,20
Unsatisfiable. . . . . . .(),18,24
0 : {1} . . . . . . . . . . . . . . . . (ub)
2 : p . . . . . . . . . . . . . . . . . . . (),16
1 : r.{2} . . . . . . . . . . . . . (),16
2 : {2} . . . . . . . . . . . . . . (refl),27
0 : s.{2} . . . . . . . (),7,29
2 : r.p . . . . . . . . (),30,6
2 : r.p . . . . . . . . . . . . . (),31
Non-terminating . . . . . . . . .
. . . . . . . . . Repetition of 1632
2 : r.p . . . . . . . (),7,29
34.
35.
. . . . . . . . . . Similarly to 3033
36. 1 : r.p. . . . . . . . . . .(),7,13
. . . . . . . . . . . . . . Similarly to 1435
37.
38. 0 : r.p . . . . . . . . . . . . . (),7,2
. . . . . . . . . . . . . . . . . Similarly to 837
39.

an inference is possible forever, then it is performed eventually. This means a
deterministic tableau procedure based on TALBO(ub) may not defer the use of
an applicable rule indefinitely. Note that we understand fairness in a global
sense. That is, a tableau procedure has to be fair not only to expressions in a
particular branch but to expressions in all branches of a tableau. In other words,
a procedure is fair if it is makes both the branch selection, and the selection of
expressions to which to apply a rule to, in a fair way.

Theorem 5. Any fair tableau procedure based on TALBO(ub) is a decision procedure for ALBO and all its sublogics.
Note that we do not assume that the branches are expanded in a depth-first
left-to-right order. Nevertheless, it also follows from our results that:
Theorem 6. Any fair tableau procedure based on TALBO(ub) which uses a depthfirst and left-to-right strategy, with respect to branch selection of the (ub) rule, is
a decision procedure for ALBO and all its sublogics.
To illustrate the importance of fairness we give two examples. The concept

C def=  ((s  s).r.p  t.r.p)

is not satisfiable. Figure 4 gives a depth-first left-to-right derivation which is
unfair and does not terminate. It can be seen that the derivation is infinite
because the application of the () rule to 0 : t.r.p is deferred forever and,
consequently, a contradiction is not found. This illustrates the importance of
fairness for (refutational) completeness.

R.A. Schmidt and D. Tishkovsky

12.
13.
14.
15.

1. 0 : (s  s).r.p . . . . . . . . . . given
2. 0 : {0} . . . . . . . . . . . . . . . . . . . . . (refl),1
3. 0 : s.r.p . . . . . . . . . . . . . . (),1
4. 0 : s.r.p . . . . . . . . . . . . (),1
5. 0 : r.p . . . . . . . . . . . . . (),4,2
0 : r.p . . . . . . . . . . . . . . . . . . . (),5
6.
1 : p . . . . . . . . . . . . . . . . . . . . . . . . (),6
7.
0 : r.{1} . . . . . . . . . . . . . . . . . . (),6
8.
1 : {1} . . . . . . . . . . . . . . . . . . . (refl),7
9.
10. 1 : r.p. . . . . . . . . . . .(),4,9
1 : r.p . . . . . . . . . . . . . . . . . . (),5
11.
Fig. 5. An infinite derivation, due to unfair selection of branches

0 : {1} . . . . . . . . . . . . . (ub),2,9
2 : p . . . . . . . . . . . . . . . . . . . (),11
1 : r.{2} . . . . . . . . . . . . . (),11
Non-terminating . . . . . . . . . . .
. . . . . . . . . . . . Repetition of 714
0 : {1} . . . . . . . . . . . . . . (ub),2,9
16.
17.
. . . . . . . . . . . . . . Never expanded
18. 0 : s.{1} . . . . . . . . . . . (),4,9
. . . . . . . . . . . . . . . . Never expanded
19.
20. 0 : s.{0} . . . . . . . . . . . . . (),4,2
. . . . . . . . . . . . . . . . . . Never expanded
21.

The next example illustrates the importance of fairness for decidability. The
concept (ss).r.p is satisfiable. The derivation in Figure 5 is obtained with
a depth-first right-to-left strategy. However, the repeated selection of the right
branch at (ub) choice points causes all the individuals in the branch to be pairwise non-equal. The concept  : r.p re-appears repeatedly, for every individual
 in the branch. This triggers the repeated generation of a new individual by the
() rule, resulting in an infinite derivation. This strategy is unfair because all
branches except for the rightmost branch get ignored.

In an implemented prover, optimisations, good heuristics and clever backtracking techniques are important. The standard optimisations such as simpli-
fication, backjumping, dynamic backtracking, different heuristics for branch selection and rule selection, lemma generation, et cetera, are all compatible with
the presented calculi and procedures. An obvious simplification, for example, is
the on-the-fly removal of double negations from concepts, and especially from
roles, as this reduces a number of applications of the () rule.

Since the presented tableaux operate only on ground labelled concept expres-
sions, they can in principle be implemented as extensions of existing tableaubased description logic systems which can handle singleton concepts. We have
implemented the unrestricted blocking rule as a plug-in to the MetTeL tableau
prover [8], and tests with various description logics are encouraging.

6 Conclusion

We have presented a new, general tableau approach for deciding expressive description logics with complex role operators, including non-safe occurrences of
role negation. The tableau decision procedures found in the description logic
literature, and implemented in existing tableau-based description logic systems,
can handle a large class of description logics, but cannot currently handle description logics with full role negation such as ALB or ALBO. The present paper
closes this gap. An important novelty of our approach is the use of a blocking
mechanism based on small inference steps rather than big tests performed on
sets of expressions or assertions which are often tailored toward specific logics.
?

?

?
Our techniques are versatile and are not limited to ALBO or its sublogics, but
carry over to all description logics and also other logics including first-order logic.

Acknowledgements. We thank the referees for valuable comments. The work is
supported by EPSRC research grant EP/D056152/1.
