Two-Phase Web Service Discovery Based on Rich

Functional Descriptions

Michael Stollberg, Uwe Keller, Holger Lausen, and Stijn Heymans

Digital Enterprise Research Institute Innsbruck (DERI Austria),

Institute for Computer Science, University of Innsbruck,

Technikerstrasse 21a, A-6020 Innsbruck, Austria

firstname.lastname@deri.org

Abstract. Discovery is a central reasoning task in service-oriented architectures,
concerned with detecting Web services that are usable for solving a given request.
This paper presents two extensions in continuation of previous works towards
goal-based Web service discovery with sophisticated semantic matchmaking. At
first, we distinguish goal templates as generic objective descriptions and goal instances that denote concrete requests as an instantiation of a goal template. Sec-
ondly, we formally describe requested and provided functionalities on the level
of state transitions that denote executions of Web services, respectively solutions
for goals. Upon this, we specify a two-phase discovery procedure along with semantic matchmaking techniques that allow to accurately determine the usability
of a Web service. The techniques are defined in the Abstract State Space model
that supports several languages for describing Web services.

1 Introduction

Discovery is concerned with detecting usable Web services for solving a given request.
This is the first central reasoning task in the context of Semantic Web services, followed
by contracting and behavioral conformance tests [17]. Several research works present
discovery techniques by semantic matchmaking of requested and provided function-
alities, e.g. [16,13,2,7,11]. However, due to deficiencies in the expressiveness and the
formal semantics of functional descriptions most existing approaches lack in the achievable quality of the matchmaking results for Web service discovery.

In this respect, we present the advancements towards a goal-based approach for semantically enabled Web service discovery with sophisticated matchmaking. Initially
presented in [9], the requester and the provider perspective are separated by formally
describing client objectives as goals; a Web service is understood to provide access to
several services by its invocation with concrete input values. We extend this approach
by differentiating two notions of goals. A goal template is a generic objective description that is defined at design time, and a goal instance denotes a concrete client request
that is created at runtime by instantiating a goal template with concrete input values.
Apart from better supporting goal formulation by clients, this allows to realize an efficient two-phase Web service discovery. Usable Web services for goal templates are
determined at design time and kept in the system. At runtime, the discovery for goal

E. Franconi, M. Kifer, and W. May (Eds.): ESWC 2007, LNCS 4519, pp. 99113, 2007.
c Springer-Verlag Berlin Heidelberg 2007

M. Stollberg et al.

instances only needs to investigate those Web services that are usable for the corresponding goal template, so that the number of matchmaking operations necessary at
runtime can be reduced. This paper specifies the semantic matchmaking techniques for
this framework.

In order to properly describe provided and requested functionalities, we consider a
state-based model of the world. Therein, a particular execution of a Web service denotes
a sequence of state transitions; such a sequence is also a solution for a goal if the client
objective is solved in the end-state. The functionality provided by a Web service is a set
of all its possible executions, and a goal template as well as a goal instance describes a
set of possible solutions. We formally describe possible executions and solutions with
respect to the start- and end-states in Abstract State Spaces, a language independent
model that defines precise formal semantics for such functional descriptions [10].

On top of this, we specify semantic matchmaking techniques that allow to precisely
determine the usability of a Web service for solving a goal. In particular, we (1) revise
the definition of previously identified matching degrees and use these to differentiate the
usability of a Web service on the goal template level, (2) present a novel approach for
semantic matchmaking on the goal instance level, and (3) finally integrate the matchmaking techniques for the goal template and the goal instance level. We specify the
techniques in a first-order logic framework and illustrate the definitions by a running
example throughout the paper: a goal specifies the objective of finding the best restaurant in a city, and a Web service provides a search facility for the best French restaurant
in a city. As we shall discuss, this Web service is only usable for specific goal instances
 namely those that specify a city wherein the best restaurant in French.

The paper is structured as follows. Section 2 introduces the concepts of our twophase discovery approach, and Section 3 defines the formal functional descriptions for
Web services and goals. Section 4 specifies the integrated semantic matchmaking techniques for Web service discovery, and Section 5 demonstrates this in the running ex-
ample. Section 6 discusses related work and positions our approach therein. Finally,
Section 7 concludes the paper. A detailed report on this work is provided in [20].

2 Concepts and Approach

The specification of semantic matchmaking techniques for Web service discovery is
strongly dependent on the underlying conception and the formal description of Web
services and goals. This section introduces the relevant concepts and then outlines the
two-phase Web service discovery by discussing the meaning of a match.

2.1 Web Services and Goals

In accordance to the common understanding, we consider a Web service as a computational facility that is invocable over the Internet via an interface [1]. As an abstraction
that is sufficient for our purpose, we define a Web service as a pair W = (IF , ) such
that IF = (i1, . . . , in) is a finite set of names that denotes all inputs required for invoking W , and  is the implementation of W that is executed when W is invoked.

In the Abstract State Space model (ASS, [10]), a particular execution of W denotes
a finite sequence of state transitions  = (s0, . . . , sm), i.e. a change of the world from
?

?

?
Fig. 1. Web Service, Executions, Input Bindings

a start state s0 to an end state sm. Such a  is triggered by invoking W with concrete
input values; we refer to this as an input binding  : {i1, . . . , in}  U, i.e. a total
function that assigns objects of some universe U to the IF -names. In dependence of the
start state, there can be different executions of W for the same input binding. Relevant
for the context of discovery, we understand the overall functionality provided by W
as the set of all its possible executions, denoted by {}W . As illustrated in Figure 1,
this can be further differentiated into the distinct sets of possible executions of W for
{}W () with W () denoting the set of
each valid input binding, such that {}W =
possible executions of W when invoked with a particular input binding .1

Goals in our approach are formally described client objectives. In accordance to related AI research (e.g. [3,15]), we understand a goal as the formal description of the
desire of the client to get from the current state of the world into a state wherein the
objective is satisfied. This abstracts from technical details irrelevant to the client objec-
tive. As promoted by the WSMO framework [12], the overall aim is to enable problemoriented Web service usage: the client merely specifies the objective to be achieved as
a goal, and the system detects and executes suitable Web services for solving this.

We have refined the initial WSMO goal model based on experiences in realizing
respective technologies [21]. The extension relevant in the context of discovery is the
differentiation of goal templates as generic, reusable objective descriptions, and goal
instances that denote concrete client requests as instantiations of a goal template. Inspired by related system implementations such as IRS [4] and SWF [22], this allows
to support goal formulation by client via graphical user interfaces. Instead of requiring
the client to specify potentially complex logical formulae for goal formulation, merely
pre-defined templates are instantiated with concrete inputs. Figure 2 illustrates this.
While we shall specify their formal description in the next section, a goal template G
defines generic constraints on the initial state and the desired final state to be achieved.
In our restaurant search example, the goal template G defines that the best restaurant
1 We consider the functionalities provided by Web services to satisfy two properties: (1) deter-
ministic, i.e. all outputs and effects of an execution are completely dependent on the provided
inputs and the start state; non-deterministic functionalities violate the composability of Web
services [17]; (2) non-adaptive, meaning that in contrast to intelligent software agents a Web
service does not itself change the provided functionality [6].

M. Stollberg et al.

Fig. 2. Goal Templates, Goal Instances, and Web Services

shall be found in a city that is provided as an input by the client. Its meaning in the
ASS model is that G specifies a set of sequences of state transitions {}G as its possible
solutions. For each  = (s0, . . . , sm)  {}G, the start-state s0 satisfies the constraints
on the initial state, and the end-state sm satisfies the constraints on the desired state
of the world. At runtime, a client creates a goal instance GI(G) by defining concrete
values for the inputs specified in G. In the example, this is the concrete city in which
the best restaurant shall be found. We refer to this as an input binding  for G; this also
constitutes the input binding for invoking a Web service to solve GI(G) as discussed
above. Because of this instantiation, the possible solutions for GI(G) are a subset of
those for G, so that {}GI(G)  {}G.

2.2 The Meaning of a Match for Web Service Discovery

:= possible solutions for G
:= possible executions of W

We now turn towards Web service discovery. With respect to the conception of Web
services and goals explained above, the aim is to find a Web service that can provide a
 that is a solution for the goal. Hence, we define the meaning of a match as follows.
Definition 1. Let W be a Web service, G a goal template, and GI(G) a goal instance
that instantiates G with an input binding . Let  = (s0, . . . , sm) be a sequence of
states in an Abstract State Space A. We define the following sets:
{}G
{}W
{}GI(G)  {}G := possible solutions for GI(G) that defines 
{}W ()  {}W := possible executions of W when invoked with 
We define the usability of a Web service for solving a goal as:
(i) match(G, W )
(ii) match(GI(G), W ) : .   ({}GI(G)  {}W ())
This defines the basic matching conditions for Web Service discovery. Clause (i) states
that a Web service W is usable for solving a goal template G if there exists at least one
execution of W that is a possible solution for G. Clause (ii) defines that W is usable
for solving a goal instance GI(G) if there is at least one execution of W that is also a
solution for GI(G) when W is invoked with the inputs defined in GI(G).

: .   ({}G  {}W )
?

?

?
Because of {}GI(G)  {}G it holds that a Web service that is usable for solving
a goal instance is also usable for the corresponding goal template. If W can provide a
  {}GI(G), then this  also is also an element of {}G. Formally, we can express
this as match(GI(G), W )  match(G, W ). As the logical complement, it also holds
that match(G, W )  match(GI(G), W ), i.e. that a Web service that is not usable
for a goal template is also not usable for any of its goal instances.
This constitutes the foundation of our two-phase discovery. Usable Web services for
goal templates G can be determined at design, i.e. when a new goal template is defined.
Web service discovery for concrete goal instances GI(G) is performed at runtime. Because of match(G, W )  match(GI(G), W ), this merely needs to consider the
set of Web services that are usable for the corresponding goal template G. While the
achievable efficiency increase is discussed elsewhere [22], this paper specifies the semantic matchmaking techniques for evaluating the matching conditions on the basis of
formal descriptions. Without such techniques, we would need to perform test runs of
W in order to determine its usability for solving a goal.

3 Formal Functional Descriptions

The following defines functional descriptions for Web services and goals that serve as
the basis for semantic matchmaking techniques for Web service discovery. To properly describe requested and provided functionalities on the level of state transitions, we
apply functional descriptions as defined in the ASS model mentioned above. This section specifies their structure and formal meaning in a first-order logic framework, and
illustrates the definitions in our running example.

3.1 Definition and Semantics

The ASS model describes functionalities in terms of preconditions and effects along
with explicitly defining in- and outputs. Focussing on the formal meaning of functional
descriptions, they are defined independent of the language used for specifying preconditions and effects. The following recalls the definitions, referring to [10] for details.
An Abstract State Space A is defined over a signature  and some domain knowledge . A functional description is described as a 5-tuple (, , IF , pre, eff ). The
signature  differentiates static symbols S that are not changed, dynamic symbols D
that are changed by execution of a Web service, and pre
D that denote the interpretation
of a dynamic symbol in the start state. Preconditions pre and effects eff are defined
as statements in a logic L(). IF = (i1, . . . , in) is a set of variables that denote all
required inputs. To explicitly specify the deterministic dependency between the startand end-states with respect to input values, they can occur as the only free variables in
pre and eff . An input binding  : {i1, . . . , in}  UA is a total function that assigns
objects of the universe of A to each IF -variable. Finally, the symbol out denotes the
computational outputs that are constrained by eff .
The meaning of a functional description is defined with respect to the start- and the
end-state of a sequence of state transitions. Formally, a  = (s0, . . . , sm) in A is considered to satisfy the described functionality if and only if it holds that if s0 |=L() pre

M. Stollberg et al.

then sm |=L() eff . Here, s |=L()  expresses that the formula  is satisfied by the
universe UA in a state s under the logic L(). We refer to this as implication seman-
tics: if the precondition is satisfied in s0, then sm will satisfy the effect; otherwise, we
can not make any statement about the behavior of the described functionality. Because
the IF -variables occur as free variables in both the precondition pre and the effect
eff , the end-state sm is completely dependent on the start-state s0. This reflects the
deterministic nature of functionalities provided by Web services.

While functional descriptions in the ASS model are defined independent of the specification language for preconditions and effects, we use classical first-order logic (FOL,
[19]) for illustration throughout this work. In order to ease the handling of functional
descriptions, we describe them as a first-order logic structure that maintains the formal
semantics as defined in the ASS model.
Definition 2. A functional description is a 4-tuple D = (, , IF , 
(i)  is a signature consisting of S (static symbols), D (dynamic symbols),
(ii)   L() defines consistent domain knowledge
(iii) IF is a set of variables i1, . . . , in that denote all required input values;
an input binding  : {i1, . . . , in}  UA is a total function that assigns
objects of the universe of A to each IF -variable

D

is a FOL formula of the form [pre]pre

D (pre-variants of dynamic symbols)

 eff such that

D) such that:

and pre

(iv) 

- pre is the precondition with IF as the only free variables
- eff is the effect with IF as the only free variables and the

- []pre
?

?

?
D is the formula 

outputs are denoted by the predicate out
symbol   D by its corresponding pre-variant pre  pre
D .

derived from  by replacing every dynamic

Essentially, 
defines a logical implication between the precondition and the effect
formulae. The rewriting function for the precondition handles dynamic symbols. For ex-
ample, consider a functionality for a bank account withdrawal with pre : account(a)
balance(a)  x, eff : account(a)  balance(a) = balancepre(a)  x, and D =
D = (account(a)  balancepre(a)  x)  (account(a) 
balance(a). We obtain 
balance(a) = balancepre(a)  x), so that the relationship between the start- and endstate is specified explicitly. The following specifies the meaning of such a functional
description that formally describes the overall functionality provided by a Web service.
Definition 3. Let W be a Web service with {}W as the set of its possible executions
in an Abstract State Space A. Let D = (, , IF , 
D) be a functional description. Let
A =   []pre
W provides the functionality described by D, denoted by W |=A D, if and only if:
(i) every -interpretation I with I |= A and I,  |= 

binding  : IF  UA represents a   {}W , and
(ii) every   {}W is represented by a -interpretation I with I,  |= 

I |= A under every input binding  : IF  UA.
This defines that a Web service W provides the functionality described by D if and
describes a  = (s0, . . . , sm)
only if every -interpretation I,  that is a model of 

D be the domain knowledge extended with pre  pre
D .

under every input

and
?

?

?
Fig. 3. Illustration of W |=A D

 {}W . Such a -interpretation describes the objects that exists in the end-state sm
if W is executed for a particular input binding  in a specific start state s0. For the
if I,  |=
implication semantics from clause (iv) in Definition 2, it holds that I,  |= 

pre and I,  |= eff ; if I |= pre, we can not make any statement about the endstate of a . Hence, if a   {}W can be described by a -interpretation I with
, then it satisfies the described functionality; if there is a   {}W that
I,  |= 

cannot be described by such a -interpretation, then W does not provide the described
functionality. Figure 3 illustrates this, while we refer to [20] for the formal explanation
of this definition and its relationship to the ASS model.
The meaning of a functional description DG of a goal template G is analogous. Here,
{}G is the set of sequences of state transitions that are solutions for G such that every
  {}G corresponds to a -interpretation that is a model of DG. To precisely evaluate
the usability of a Web service, in some cases we need to consider the concrete value
assignments for the IF -variables. These are provided by the creation of a goal instance
GI(G) that defines an input binding  for the IF -variables in DG of the corresponding
goal template G. Subsequently, this  constitutes the inputs for invoking a Web service
in order to solve GI(G). We shall discuss this in more detail in the context of discovery
on the goal instance level (Section 4.2).

3.2 Illustration in Running Example

In order to illustrate the above definitions, Table 1 shows the formal functional descriptions of the goal template G and the Web service W in our restaurant search example.
The goal describes the objective of finding the best restaurant in a city. The specific
city is an input required for instantiation. Hence, DG specifies one IF -variable that is
constrained in the precondition pre to be a city. The effect eff describes the desired
state of the world to be given if and only if the received output is a restaurant in the
city such that there does not exists any better restaurant in the city. Analogously, DW
describes the functionality provided by the Web service W . The mere difference occurs
in the effect: the output of W is a French restaurant in the city that is provided as input
such that there does not exist any better French restaurant in the city.
We use classical first-order logic (FOL, [19]) as the specification language. The signature  for both DG and DW defines the respective symbols. Here, ?name denotes

M. Stollberg et al.

a variable. The domain knowledge  is defined in the best restaurant ontology. This
contains axioms specifying that the predicate better(,) denotes a partial order, that
any restaurant has exactly one type and that the restaurant types italian and f rench
are distinct from each other, and that restaurants are located in cities. We omit the complete ontology specification due to space limitations. The table shows the functional
in accordance to
descriptions with precondition and effects and the corresponding 
Definition 2.

Table 1. Functional Descriptions DG, DW in Running Example

Goal

find best restaurant in a city
:
best restaurant ontology
IF : {?x}
pre: city(?x)
eff : ?y. out(?y)  (
restaurant(?y)
 in(?y, ?x)
 ?z.(restaurant(?z)
 in(?z, ?x)
 better(?z, ?y) ) ).
DG : city(?x)  (
?y. out(?y)  (
restaurant(?y)
 in(?y, ?x)
 ?z.(restaurant(?z)
 in(?z, ?x)
 better(?z, ?y) ) ) ).



Web Service

best restaurant ontology

provide best French restaurant in a city
:
IF : {?x}
pre: city(?x)
eff : ?y. out(?y)  (
restaurant(?y)
 in(?y, ?x)  type(?y, f rench)
 ?z.(restaurant(?z)
 in(?z, ?x)  type(?z, f rench)
 better(?z, ?y) ) ).
?y. out(?y)  (
restaurant(?y)
 in(?y, ?x)  type(?y, f rench)
 ?z.(restaurant(?z)
 in(?z, ?x)  type(?z, f rench)
 better(?z, ?y) ) ) ).

DW : city(?x)  (



4 Semantic Matchmaking for Web Service Discovery

On the basis of the formal descriptions we now specify the semantic matchmaking techniques for the two-phased Web service discovery introduced in Section 2.2. The aim is
to provide semantic means that allow to precisely determine the usability of a Web service with respect to the matching conditions on the goal template and the goal instance
level from Definition 1. We therefore define matchmaking on functional descriptions
and input bindings as specified above. These provide sufficiently rich descriptions of
possible Web service executions and possible solution for goals. The following first
specifies semantic matchmaking on the goal template level, then on the goal instance
level, and finally integrates the techniques for both levels. We shall demonstrate the
techniques in our running example in Section 5.

4.1 Goal Template Level
We express the usability of a Web service W for solving a goal template G in terms
of matching degrees. Adopting the concept and denotation of the degrees from several
?

?

?
previous works on Web service discovery (e.g. [16,13,8]), we define them over the
functional descriptions of goals and Web services as defined in Section 3.1.
The distinct degrees denote specific relationships between the possible executions
{}W of W and possible solutions {}G for G. Four degrees  exact, plugin, sub-
sume, intersect  denote different situations wherein the matching condition in clause
(i) of Definition 1 is satisfied; the disjoint degree denotes that this is not given. In our
two-phase discovery, these matching degrees serve as a pre-filter for determining the
usability of a Web service W for solving a goal instance GI(G) that instantiates the
goal template G. We shall discuss this in more detail in Section 4.3.
We define the criteria for each degree over DG and DW from Definition 2, along with
an explicit quantification of input bindings . As the condition for the exact degree,
A |= . 
DW defines that every possible execution of W is a solution
for G and vice versa. We assume that all functional descriptions D are consistent, i.e.
that there exists a -interpretation I under a  that is a model of 
. Representing a
refinement of the matching degree definitions from [8], we therewith obtain a precise
means for differentiating the usability of a Web service on the goal template level.
Table 2 provides a concise compilation of the matchmaking degree definitions.

DG  

Table 2. Definition of Matching Degrees for DG, DW

Denotation
DG = (, , IF , 
DW = (, , IF , 

DG )
DW )

exact(DG,DW )
plugin(DG,DW )
subsume(DG,DW )
intersect(DG,DW )
disjoint(DG,DW )



Definition
 : IF  UA

= [pre]pre
D
A =   []pre
A |= . 
A |= . 
A |= . 
A |= . 
A |= . 

 eff
D
DG  

DG  

DG  

DG  

DG  

for {}G, {}W with

Meaning
W |=A DW

then   {}W

if and only if   {}G
if   {}G then   {}W
if   {}W then   {}G
there is a  such that
  {}G and   {}W
there is no  such that
  {}G and   {}W

4.2 Goal Instance Level
A goal instance GI(G) is created by defining an input binding  for the IF -variables in
the functional descriptionDG of the corresponding goal templateG. Recalling from Definition 1, a match on the goal instance level is given if there exists a  = (s0, . . . , sm)
in A that is a solution for GI(G) and can be provided by a Web service W when it
is invoked with the concrete input values defined in GI(G). The following specifies a
general technique for determining this on the basis of the available descriptions, independent of the matching degree between DG and DW .
Formally, an input binding  : {i1, . . . , in}  UA is a total function that defines a
variable assignment over the universe UA for the input variables IF defined in a functional description D (cf. Definition 2). We therewith obtain an assignment of concrete

M. Stollberg et al.

values v for all inputs required in D, i.e.  = {i1|v1, . . . , in|vn}. Given such a , we
can instantiate D by substituting all IF -variables that occur as free variables in pre
and eff by the concrete values defined in . We obtain [D] as the functional description that is instantiated for the context of ; this can be evaluated because it does no
longer contain any free variables. By instantiating the functional descriptions DG of the
corresponding goal template G and DW of the Web service W with the input binding 
defined in GI(G), we obtain [DG] as the functionality requested by GI(G) and [DW ]
as the functionality that can be provided by W when it is invoked with .
For W to be usable for solving GI(G), there must be a  such that   {}GI(G)
and   {}W () (cf. clause (ii) from Definition 1). To determine this on the basis of
the given descriptions, it must hold that  with respect to the domain knowledge  there
DW when both funcexists a -interpretation I that is a common model for 
tional descriptions are instantiated with the input binding  defined in GI(G). Formally,
DW ]} must be satisfiable,
this means that the union of the formulae A  {[
DG], [
i.e. that there exists a -interpretation that is a model for the extended domain knowlDG ] and for the instantiated Web
edge A and for the instantiated goal description [
DW ]. In accordance to Definition 3, this I represents a  that is
service description [
a solution for GI(G) and can be provided by W if it is invoked with .
Definition 4. Let DG = (, , IF G, 
DG ) be a functional description of a goal template G. Let GI(G) be a goal instance that instantiates G with the input binding  :
IF G  UA. Let DW = (, , IF W , 
DW ) be a functional description, and let
W = (IF , ) be a Web service with W |=A DW .
match(GI(G), W ) is given if there exists a -interpretation I such that:

DG and 

I |= A and

I |= [

DG ]

and

I |= [

DW ].

Another requirement for W to be usable for solving GI(G) is that the  defined in
GI(G) provides concrete values for all inputs that are required to invoke W . This is
given if there is a bijection  : IF DG  IF DW such that for every input variable in DW
there is a corresponding input variable in DG, and each i  IF DG is assigned with the
 IFW
concrete value from . Subsequently, if there is a second bijection 2 : IF DW
such that for each input name required by W there is a corresponding input variable in
DW , then there is a concrete value assignment for each input required by W .2

4.3 Integration of Matchmaking Techniques

We complete this section with combing the semantic matchmaking techniques for the
goal template and the goal instance level in order to attain an integrated matchmaking

2 We are aware of that this is requirement is not trivial to realize in practice, as it requires a
semantic mapping between the input variables of functional descriptions and the Web service.
Moreover, this may require mediation between incompatible ontologies used by the requester
and provider [5]. However, to invoke a Web service there must be concrete values for all
required inputs  the two bijections denote the basic requirement therefore. [20] discusses
ways to weaken the requirements for the necessary compatibility, e.g. by creating existentially
quantified ontology instances for input values that are not explicitly defined by the client.
?

?

?
framework for our two-phase Web service discovery. We therefore extend matchmaking
degrees from Table 2 with the matchmaking condition for the goal instance level. Due
to their definition, we can simplify the matching condition from Definition 4 for the
distinct matchmaking degrees as follows.
Theorem 1. Let DG describe the requested functionality in a goal template G. Let
GI(G) be a goal instance of G that defines an input binding . Let W be a Web service,
and let DW be a functional description such that W |=A DW .
W is usable for solving GI(G) if and only if:
(i) exact(DG,DW )
or
(ii) plugin(DG,DW )
or
(iii) subsume(DG,DW ) and
(iv) intersect(DG,DW )and
This specifies the minimal matchmaking conditions for determining the usability of a
Web service for solving a concrete client request that is described by a goal instance.
Under both the exact and the plugin degree, W can be used for solving any goal instance
GI(G) because {}GI(G)  {}G  {}W and   {}GI(G)    {}W (). Under
the subsume degree it holds that {}G  {}W , i.e. every execution of W can solve G
but there can be solutions of G that cannot be provided by W . Hence, W is only usable
for solving GI(G) if the input binding  defined in GI(G) allows to invoke W . This is
DW ] and the conjunction of
given if there is a -interpretation that is a model for [
the axioms in A. Under intersect as the weakest degree, the complete matchmaking
condition for the goal instance level must hold because there can be solutions for G that
can not be provided by W and vice versa. The disjoint degree denotes that W is not
usable for solving the goal template and thus neither for any of its instantiations. We
refer to [20] for the formal proof of this theorem.

DW ] is satisfiable, or
DG ]  [

DW ] is satisfiable.
?

?

?
A  [
A  [

5 Evaluation

In order to demonstrate the precision for Web service discovery that is achievable with
the presented matchmaking techniques, this section discusses them for our restaurant
search example. We have implemented and verified the matchmaking techniques in
VAMPIRE [18], a resolution-based theorem prover for classical first-order logic with
equality that allows to realize matchmaking exactly as we have specified above. Due
to space limitations, we here content ourselves with condensed explanations on the
matchmaking techniques for the goal and the Web service as introduced in Section 3.2.
A more detailed documentation as well as further examples for discovery under other
matchmaking degrees is provided in [20].3

The following discusses the matchmaking techniques for the goal of finding the best
restaurant in a city and a Web service that provides the best French restaurant in a city

3 The VAMPIRE implementation along with installation instructions and the proof obligations for the best restaurant search example are available at: http://members.
deri.at/ michaels/software/best-restaurant-example.zip

M. Stollberg et al.

(cf. functional descriptions in Table 1). This is an example for the intersect degree and
hence requires the full range of the extended matchmaking for the goal instance level.
For illustration, it is sufficient to consider city A wherein the best restaurant is French
and city B wherein the best restaurant is not French. We define two input bindings,
1 = {?x|A} and 2 = {?x|B}, and examine the solutions for G and the executions
of W for each. Table 3 provides a concise overview of the information relevant for our
discussion. The first part shows the description of the three best restaurants in A and B
as background ontologies 1, 2  . The second part shows the goal instances, i.e.
when DG is instantiated with the concrete values defined in the distinct  as explained
in Section 4.2. Analogously, the third part shows the only possible instantiations for W .
Finally, the fourth part identifies common -interpretations that serve as a witness for
a semantic match between the goal instances and the described Web Services.

We can observe that for the input binding 1, there is a -interpretation I1 that is
consistent with the background ontology  and satisfies both the instantiation of the
DW ]1. The
goal template [

DG ]1 as well as the instantiation of the Web service [

Table 3. Relevant Information for Matchmaking Illustration

City A: 1  

1 = {city(A)
restaurant(r1A)
in(r1A, A), type(r1A, f rench)
restaurant(r2A)
in(r2A, A), type(r2A, italian)
restaurant(r3A)
in(r3A, A), type(r3A, f rench)
better(r1A, r2A)
better(r2A, r3A)}

DG ]1 with 1 = {x|A}
[

city(A)  (
?y.(out(?y)  (
restaurant(?y)  in(?y, A)
 ?z.(restaurant(?z)
 in(?z, A)
 better(?z, ?y) ) ) )
DW ]1 with 1 = {x|A}
[

city(A)  (
?y.(out(?y)  (
restaurant(?y)
 in(?y, A)  type(?y, f rench)
 ?z.(restaurant(?z)
 in(?z, A)  type(?z, f rench)
 better(?z, ?y) ) ) )
I1 with I1 |=   {[

DG]1, [
1  2  {out(r1A),

DW ]1
better(r1A, r3A), better(r1B, r3B)}

}

City B: 2  

2 = {city(B)
restaurant(r1B)
in(r1B, B), type(r1B, italian)
restaurant(r2B)
in(r2B, B), type(r2B, f rench)
restaurant(r3B)
in(r3B, B), type(r3B, f rench)
better(r1B, r2B)
better(r2B, r3B)}

DG ]2 with 2 = {x|B}
[

city(B)  (
?y.(out(?y)  (
restaurant(?y)  in(?y, B)
 ?z.(restaurant(?z)
 in(?z, B)
 better(?z, ?y) ) ) )
DW ]2 with 2 = {x|B}
[

city(B)  (
?y.(out(?y)  (
restaurant(?y)
 in(?y, B)  type(?y, f rench)
 ?z.(restaurant(?z)
 in(?z, B)  type(?z, f rench)
 better(?z, ?y) ) ) )
I2 with I2 |=   {[

DG]2, [

DW ]2

}

No such I2 can exist!
?

?

?
DG]2 and [

witnessing execution  corresponds to the pair (I1, 1). Hence, the condition for the intersect match is satisfied (cf. Table 2). Furthermore, we observe that for the input binding 2 there can not exist such a common interpretation. Hence, neither the condition
for the subsumes nor for the plugin is satisfied; thus also not the one for the exact degree.
Assume that there would be such a common interpretation I2, i.e. a -interpretation that
DW ]2. From the second column of Table 3 we can conclude
satisfies , [
that any object ?y that is the best restaurant in city B is a french restaurant. However,
this is not consistent with the background ontology  as described above, since then
restaurant r1B must be at the same time an italian as well as a french restaurant.
Because of the intersect degree on the goal template level, clause (iv) of Theorem 1
must hold for W to be usable for solving a goal instance GI(G) that instantiates G. This
requires that there must be a -interpretation that is (a) consistent with the background
DW ] (cf. Definition 4). Let
ontology  and (b) a common model for [
us consider GI(G)1 as the goal instance that instantiates G with 1, and GI(G)2 as
the goal instance that defines 2. Analyzing the possible solutions and executions in
Table 3 reveals the intuitively expected discovery results: the -interpretation I1 serves
as a witness for a   {}GI(G)1 and   {}W1 . Hence, W is usable for solving
GI(G)1. On the other hand, as discussed above, there can not exist such a witness for
GI(G)2; therefore W can not be used to solve GI(G)2.

DG ] and [

6 Related Work

Due to its relevance for service-oriented architectures, Web service discovery is subject
to several research efforts. We here discuss directly related works with respect to the
quality of matchmaking techniques and the modelling client objectives, referring to
more exhaustive overviews, e.g. in [9,10,20].

As early works, [16] presents matchmaking of in- and outputs in OWL-S, and [13]
defines matchmaking of requested and provided results in a DL framework. Both define
the matching degrees in terms of concept subsumption, and work on OWL-S service advertisements and requests described by inputs, outputs, preconditions, and effects [14].
Although using OWL as an expressive specification language, this description neither
explicates the dependency pre- and post execution descriptions nor defines formal semantics for functional descriptions. Hence, the matchmaking algorithms merely allow
to detect ontological relationships between corresponding description elements  but
not to determine whether the invocation of a Web service in a particular state of the
world will satisfy a client request. We can observe the same deficiencies in [2].

In WSMO, provided and requested capabilities are described by preconditions, as-
sumptions, postconditions, and effects, along with shared variables to define dependencies between the formulae [12]. However, no formal semantics are defined for these
complex functional descriptions  which hampers the specification of accurate matchmaking mechanisms. Our functional descriptions overcome this by explicitly describing dependency of preconditions and effects and defining precise formal semantics. [7]
presents a recent approach with a similar focus. Functionalities are described by inputs,
outputs, and the relationship between them; a match is given if the requester can provide
the input required by the Web service, and the Web service then can provide outputs that

M. Stollberg et al.

satisfy the ones requested. However, this approach is restricted to stateless Web services
and hence only covers a subset of the functionalities supported by our approach.

WSMO is the only framework that promotes a goal-based approach for Semantic
Web services; most other approaches model client requests as queries for specific Web
service descriptions. The differentiation of goal templates and goal instances is a refinement of the WSMO goal model based on experiences in technology realization [21]. A
similar two-phased discovery approach is presented in [11]. However, therein goals are
described by the desired final state only; the input binding for invoking the discovered
Web service is created at runtime. In contrast, we describe the requested functionality
in goal templates by preconditions and effects. The reason is that in service-oriented architectures usually the current state of the world is not explicated or is not accessible to
the interaction partners. Moreover, defining input bindings on the level of goal instances
allows to minimize the client-system interaction as it just needs to be done once.

7 Conclusions

This paper has presented the integrated semantic matchmaking for a two-phased Web
service discovery that distinguishes goal templates and goal instances. Continuing previous work, we have defined matchmaking techniques that work on sufficiently rich
functional descriptions and can precisely determine the usability of a Web service.

To formally describe client requests on the problem layer, we distinguish goal templates as generic objective descriptions and goal instances that denote a concrete client
request as the instantiation of a goal template. We use functional descriptions that precisely describe the start- and end-states of possible executions of Web services as well
as of possible solutions for goals. A match is given if a Web service can provide an
execution that is a solution for the goal. We have specified semantic matchmaking techniques to evaluate this. On the goal template level, we define matching degrees that differentiate the relationship between possible executions of a Web service and solutions.
For a goal instance, a Web service is usable if its execution triggered by the invocation
with the concrete inputs is a solution for the instantiated goal description. We therefore
have presented a novel matchmaking technique and formally integrated this with the
matching degrees on the goal template level. Finally, we have demonstrated that the
matchmaking techniques allow to precisely determine the usability of a Web service for
solving a concrete client request that is described as a goal instance.

The presented techniques denote the formal foundations for semantic matchmaking
in this two-phased discovery approach. We plan to extend this with techniques for efficient management of discovery results, and to continue the integration into frameworks
and system implementations for Semantic Web services.

Acknowledgments. This material is based upon works supported by the EU under the
DIP project (FP6 - 507483) and by the Austrian Federal Ministry for Transport, Inno-
vation, and Technology under the project RW2 (FFG 809250). The authors like to thank
Martin Hepp and Rub en Lara for constructive discussions on the presented work.
?

?

