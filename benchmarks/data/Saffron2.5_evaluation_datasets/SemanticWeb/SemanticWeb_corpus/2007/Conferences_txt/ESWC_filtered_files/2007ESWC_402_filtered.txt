A Novel Combination of Answer Set Programming with

Description Logics for the Semantic Web

Thomas Lukasiewicz 

Dipartimento di Informatica e Sistemistica, Universit`a di Roma La Sapienza

Via Salaria 113, I-00198 Rome, Italy

lukasiewicz@dis.uniroma1.it

Abstract. We present a novel combination of disjunctive logic programs under
the answer set semantics with description logics for the Semantic Web. The combination is based on a well-balanced interface between disjunctive logic programs
and description logics, which guarantees the decidability of the resulting formalism without assuming syntactic restrictions. We show that the new formalism has
very nice semantic properties. In particular, it faithfully extends both disjunctive
programs and description logics. Furthermore, we describe algorithms for reasoning in the new formalism, and we give a precise picture of its computational
complexity. We also provide a special case with polynomial data complexity.

1 Introduction

The Semantic Web [4,14] aims at an extension of the current World Wide Web by standards and technologies that help machines to understand the information on the Web so
that they can support richer discovery, data integration, navigation, and automation of
tasks. The main ideas behind it are to add a machine-readable meaning to Web pages, to
use ontologies for a precise definition of shared terms in Web resources, to use knowledge representation technology for automated reasoning from Web resources, and to
apply cooperative agent technology for processing the information of the Web.

The Semantic Web consists of several hierarchical layers, where the Ontology layer,
in form of the OWL Web Ontology Language [41,22], is currently the highest layer
of sufficient maturity. OWL consists of three increasingly expressive sublanguages,
namely OWL Lite, OWL DL, and OWL Full. OWL Lite and OWL DL are essentially
very expressive description logics with an RDF syntax [22]. As shown in [19], ontology
entailment in OWL Lite (resp., OWL DL) reduces to knowledge base (un)satisfiability
in the description logic SHIF(D) (resp., SHOIN (D)). As a next important step in
the development of the Semantic Web, one aims at sophisticated representation and
reasoning capabilities for the Rules, Logic, and Proof layers of the Semantic Web.

In particular, there is a large body of work on integrating rules and ontologies, which
is a key requirement of the layered architecture of the Semantic Web. Significant research efforts focus on hybrid integrations of rules and ontologies, called description
logic programs1 (or dl-programs), which are of the form KB = (L, P ), where L is a

 Alternate address: Institut f ur Informationssysteme, Technische Universit at Wien, Favoriten-

strae 9-11, A-1040 Vienna, Austria; e-mail: lukasiewicz@kr.tuwien.ac.at.

1 Note that we use the notion of description logic programs in a generic way, that is, to denote

a class of different formalisms, similarly to the notion of description logics.

E. Franconi, M. Kifer, and W. May (Eds.): ESWC 2007, LNCS 4519, pp. 384398, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
description logic knowledge base and P is a finite set of rules involving either queries
to L in a loose integration (see especially [11,12,9,10]) or concepts and roles from L as
unary resp. binary predicates in a tight integration (see especially [36,37]).

However, especially the tight integration of rules and ontologies presents many semantic and computational difficulties [37]. Since many expressive description logics
are very close to the decidability / undecidability frontier (such as SHOIN (D), which
is only decidable when number restrictions are limited to simple abstract roles [23]),
developing decidable extensions of them by rules turns out to be a naturally hard task,
and often comes along with strong syntactic restrictions on the resulting language (such
as syntactic safety conditions and/or syntactic partitionings of the vocabulary).

Nevertheless, in rule-based systems in the Semantic Web, we would like to use vocabulary from formal ontologies, and we would like to do it without syntactic restric-
tions. In this paper, we show that the main difficulties with the above tight integrations
of rules and ontologies lies actually in the perspective of the integration. That is, they
all look from the perspective of description logics at the integration of rules and ontolo-
gies. However, for extending certain kinds of rule-based systems by vocabulary from
formal ontologies, we actually do not need the full power of a rule-based extension of
description logics. This is the main idea behind this paper. More precisely, we look at
the integration of rules and ontologies from the perspective of rule-based systems.

The main contributions of this paper can be summarized as follows:

 We present a new combination of disjunctive logic programs under the answer set
semantics with description logics. In detail, we present a new form of tightly integrated disjunctive dl-programs KB = (L, P ) under the answer set semantics, which
allows for decidable reasoning, without assuming any syntactic restrictions (see
Section 8 for a detailed comparison to previous approaches to dl-programs).

 Intuitively, the main idea behind the semantics of such dl-programs KB = (L, P )
is to interpret P relative to Herbrand interpretations that also satisfy L, while L
is interpreted relative to general interpretations over a first-order domain. That is,
we modularly combine the standard semantics of disjunctive programs P and of
description logics L, via a well-balanced interface between P and L.

 We show that the new approach to disjunctive dl-programs under the answer set
semantics has very nice semantic features. In particular, the cautious answer set
semantics faithfully extends both disjunctive programs and description logics, and
its closed-world property is limited to explicit default-negated atoms in rule bodies.
Furthermore, the new approach does not need the unique name assumption.

 We also analyze the computational aspects of the new formalism. We describe algorithms for deciding answer set existence, brave consequences, and cautious con-
sequences. This shows in particular that these decision problems are all decidable.
We also draw a precise picture of the complexity of all these decision problems.

 Finally, we delineate a special case of stratified normal dl-programs where the

above decision problems all have a polynomial data complexity.

The rest of this paper is organized as follows. Sections 2 and 3 recall disjunctive
programs under the answer set semantics resp. the description logics SHIF(D) and
SHOIN (D). In Section 4, we introduce our novel approach to disjunctive dl-programs
under the answer set semantics, and in Section 5, we analyze its semantic properties.

T. Lukasiewicz

Sections 6 and 7 focus on the computational properties. In Section 8, we discuss related
work in the literature. Section 9 summarizes our main results and gives an outlook
on future research. Some selected proofs are given in the appendix. Note that detailed
proofs of all results are given in the extended report [31].

2 Disjunctive Programs Under the Answer Set Semantics

In this section, we recall disjunctive programs (with default negation) under the answer
set semantics; see especially [26] for further details and background.

Syntax. Let  be a first-order vocabulary with nonempty finite sets of constant and
predicate symbols, but no function symbols. Let X be a set of variables. A term is either
a variable from X or a constant symbol from . An atom is of the form p(t1, . . . , tn),
where p is a predicate symbol of arity n  0 from , and t1, . . . , tn are terms. A literal l
is an atom p or a negated atom not p. A disjunctive rule (or simply rule) r is of the form

1    k  1, . . . , n, not n+1, . . . , not n+m ,

(1)
where 1, . . . , k, 1, . . . , n+m are atoms and k, m, n  0. We call 1    k the
head of r, while the conjunction 1, . . . , n, not n+1, . . . , not n+m is its body. We
define H(r) = {1, . . . , k} and B(r) = B+(r)  B
(r), where B+(r) = {1, . . . ,
n} and B
(r) = {n+1, . . . , n+m}. A disjunctive program P is a finite set of disjunctive rules of the form (1). We say P is positive iff m = 0 for all disjunctive rules (1)
in P . We say P is a normal program iff k  1 for all disjunctive rules (1) in P .

Example 2.1. An online store (such as amazon.com) may use the subsequent set of
rules P to express that (1) pc1 and pc2 are personal computers, and obj3 is either a
personal computer or a laptop, (2) pc1 and obj3 are brand new, (3) dell is the vendor
of pc1 and pc2, (4) a customer avoids all cameras not on offer, (5) all electronic products
that are not brand new are on offer, (6) each vendor of a product is a provider, (7) each
entity providing a product is a provider, (8) all related products are similar, and (9) the
binary similarity relation on products is transitively closed.
(1) pc(pc1); pc(pc2); pc(obj3)  laptop(obj3);
(2) brand new(pc1); brand new(obj3);
vendor(dell, pc1); vendor(dell, pc2);
(3)
(4) avoid(X)  camera(X), not offer(X);
(5) offer(X)  electronics(X), not brand new(X);
(6) provider(V )  vendor(V, X), product(X);
(7) provider(V )  provides(V, X), product(X);
similar(X, Y )  related(X, Y );
(8)
similar(X, Z)  similar(X, Y ), similar(Y, Z).
(9)

Semantics. The answer set semantics of disjunctive programs is defined in terms of fi-
nite sets of ground atoms, which represent Herbrand interpretations. Positive disjunctive
programs are associated with all their minimal satisfying sets of ground atoms, while the
?

?

?
semantics of general disjunctive programs is defined by reduction to the minimal model
semantics of positive disjunctive programs via the Gelfond-Lifschitz reduct [15].

More concretely, the Herbrand universe of a disjunctive program P , denoted HU P ,
is the set of all constant symbols appearing in P . If there is no such constant symbol,
then HU P = {c}, where c is an arbitrary constant symbol from . As usual, terms,
atoms, literals, rules, programs, etc. are ground iff they do not contain any variables. The
Herbrand base of a disjunctive program P , denoted HB P , is the set of all ground atoms
that can be constructed from the predicate symbols appearing in P and the constant
symbols in HU P . Hence, in the standard answer set semantics, the Herbrand base is
constructed from all constant and predicate symbols in a given disjunctive program,
and thus the Herbrand base is finite. A ground instance of a rule r  P is obtained
from r by replacing every variable that occurs in r by a constant symbol from HU P .
We denote by ground(P ) the set of all ground instances of rules in P .
An interpretation I relative to a disjunctive program P is a subset of HB P . Infor-
mally, every such I represents the Herbrand interpretation in which all a I (resp.,
a HB P  I) are true (resp., false). An interpretation I is a model of a ground atom
a HB P , or I satisfies a, denoted I |= a, iff a I. We say I is a model of a ground
rule r, denoted I |= r, iff I |=  for some  H(r) whenever I |= B(r), that is, I |= 
for all   B+(r) and I |=  for all   B
(r). We say I is a model of a disjunctive
program P , denoted I |= P , iff I |= r for every r  ground(P ). An answer set of a
positive disjunctive program P is a minimal model of P relative to set inclusion. The
Gelfond-Lifschitz reduct of a disjunctive program P relative to I  HB P , denoted P I,
is the ground positive disjunctive program obtained from ground(P ) by (i) deleting
(r) I = , and (ii) deleting the negative body from each reevery rule r such that B
maining rule. An answer set of a disjunctive program P is an interpretation I  HB P
such that I is an answer set of P I. A disjunctive program P is consistent iff P has an
answer set.

Hence, under the answer set semantics, every disjunctive program P is interpreted
as its grounding ground(P ). Note that the answer sets of any disjunctive program P
are also minimal models of P . An equivalent definition of the answer set semantics is
based on the so-called FLP-reduct [13]: The FLP-reduct of a disjunctive program P
relative to I  HB P , denoted P I, is the set of all r  ground(P ) such that I |= B(r).
An interpretation I  HB P is an answer set of P iff I is a minimal model of P I.
We finally recall the notions of cautious (resp., brave) reasoning from disjunctive
programs under the answer set semantics. A ground atom a HB P is a cautious (resp.,
brave) consequence of a disjunctive program P under the answer set semantics iff every
(resp., some) answer set of P satisfies a. Observe that for positive disjunctive programs P , since the set of all answer sets of P is given by the set of all minimal models
of P , it holds that a HB P is a cautious consequence of P under the answer set semantics iff a is a logical consequence of the propositional positive disjunctive program
ground(P ). Note that, more generally, this result holds also when a is a ground formula constructed from HB  using the Boolean operators  and . This means that
the closed-world property (that is, the derivation of negative facts from the absence of
derivations of positive facts) of the above notion of cautious reasoning under the answer set semantics is actually limited to the occurrences of default negations in rule
bodies.

T. Lukasiewicz

3 Description Logics
In this section, we recall the description logics SHIF(D) and SHOIN (D), which
stand behind the web ontology languages OWL Lite and OWL DL [19], respectively.
Intuitively, description logics model a domain of interest in terms of concepts and roles,
which represent classes of individuals and binary relations between classes of individ-
uals, respectively. A description logic knowledge base encodes especially subset relationships between concepts, subset relationships between roles, the membership of
individuals to concepts, and the membership of pairs of individuals to roles.
Syntax. We first describe the syntax of SHOIN (D). We assume a set of elementary
datatypes and a set of data values. A datatype is either an elementary datatype or a set
of data values (called datatype oneOf ). A datatype theory D = (D,D) consists of
a datatype domain D and a mapping D that assigns to each elementary datatype a
subset of D and to each data value an element of D. The mapping D is extended
to all datatypes by {v1, . . .}D ={vD
1 , . . .}. Let A, RA, RD, and I be pairwise disjoint
(nonempty) denumerable sets of atomic concepts, abstract roles, datatype roles, and
individuals, respectively. We denote by R
 RD. Concepts are inductively defined as fol-
lows. Every  A is a concept, and if o1, . . . , on  I, then {o1, . . . , on} is a concept
(called oneOf). If , 1, and 2 are concepts and if R  RA  R
A, then also (1  2),
(1  2), and  are concepts (called conjunction, disjunction, and negation, respec-
tively), as well as R., R., nR, and nR (called exists, value, atleast, and atmost restriction, respectively) for an integer n  0. If D is a datatype and U  RD, then
U.D, U.D, nU , and nU are concepts (called datatype exists, value, atleast, and
atmost restriction, respectively) for an integer n  0. We write  and  to abbreviate
the concepts    and   , respectively, and we eliminate parentheses as usual.
An axiom has one of the following forms: (1)   (called concept inclusion axiom),
where  and  are concepts; (2) R  S (called role inclusion axiom), where either
R, S  RA or R, S  RD; (3) Trans(R) (called transitivity axiom), where R  RA;
(4) (a) (called concept membership axiom), where  is a concept and a I; (5) R(a, b)
(resp., U(a, v)) (called role membership axiom), where R RA (resp., U  RD) and
a, b I (resp., a I and v is a data value); and (6) a = b (resp., a= b) (equality (resp.,
inequality) axiom), where a, b I. A knowledge base L is a finite set of axioms. For
decidability, number restrictions in L are restricted to simple abstract roles [23].
The syntax of SHIF(D) is as the above syntax of SHOIN (D), but without the

A role is an element of RA  R

A the set of inverses R



of all R  RA.

oneOf constructor and with the atleast and atmost constructors limited to 0 and 1.

Example 3.1. The subsequent description logic knowledge base L expresses that (1)
textbooks are books, (2) personal computers and laptops are mutually exclusive electronic products, (3) books and electronic products are mutually exclusive products, (4)
objects on offer are products, (5) every product has at least one related product, (6) only
products are related to each other, (7) the relatedness between products is symmetric,
(8) tb ai and tb lp are textbooks, (9) which are related to each other, (10) pc ibm and
pc hp are personal computers, (11) which are related to each other, and (12) ibm and hp
are providers for pc ibm and pc hp, respectively.
?

?

?


; related

  related;

  product;

(1) textbook  book; (2) pc  laptop  electronics; pc  laptop;
(3) book  electronics  product; bookelectronics; (4) offer  product;
(5) product   1 related; (6)  1 related   1 related
(7) related  related
(8) textbook(tb ai); textbook(tb lp); (9) related(tb ai, tb lp);
(10) pc(pc ibm); pc(pc hp); (11) related(pc ibm, pc hp);
(12) provides(ibm, pc ibm); provides(hp, pc hp).
Semantics. An interpretation I = (
,I) w.r.t. a datatype theory D = (D,D) con-
?

?

?
that
sists of a nonempty (abstract) domain 
assigns to each atomic concept  A a subset of 
, to each individual o I an ele-

I  
?

?

?
ment of 
, and to each datatype
I  D. We extend I
role U  RD a subset of 
to all concepts and roles, and we
define the satisfaction of an axiom F in an interpretation I = (
,I), denoted I |= F ,

as usual [19]. We say I satisfies the axiom F , or I is a model of F , iff I |= F . We
say I satisfies a knowledge base L, or I is a model of L, denoted I |= L, iff I |= F for
all F  L. We say L is satisfiable (resp., unsatisfiable) iff L has a (resp., no) model. An
axiom F is a logical consequence of L, denoted L |= F , iff each model of L satisfies F .

, to each abstract role R  RA a subset of 

disjoint from D, and a mapping I

4 Disjunctive DL-Programs Under the Answer Set Semantics

In this section, we present a novel integration between disjunctive programs under the
answer set semantics and description logics. The basic idea behind this integration is as
follows. Suppose that we have a disjunctive program P . Under the answer set seman-
tics, P is equivalent to its grounding ground(P ). Suppose now that some of the ground
atoms in ground(P ) are additionally related to each other by a description logic knowledge base L. That is, some of the ground atoms in ground(P ) actually represent concept and role memberships relative to L. Thus, when processing ground(P ), we also
have to consider L. However, we only want to do it to the extent that we actually need it
for processing ground(P ). Hence, when taking a Herbrand interpretation I  HB , we
have to ensure that the ground atoms of I represent a valid constellation relative to L.
In other words, the main idea behind the semantics is to interpret P relative to
Herbrand interpretations that also satisfy L, while L is interpreted relative to general
interpretations over a first-order domain. Thus, we modularly combine the standard semantics of disjunctive programs and of description logics as in [11,12,10], which allows
for building on the standard techniques and the results of both areas. However, our new
approach here allows for a much tighter integration of L and P .

Syntax. We assume a function-free first-order vocabulary  with nonempty finite sets
of constant and predicate symbols, as in Section 2. We use c to denote the set of all
constant symbols in . We also assume pairwise disjoint (nonempty) denumerable sets
A, RA, RD, and I of atomic concepts, abstract roles, datatype roles, and individu-
als, respectively, as in Section 3. We assume that c is a subset of I. This assumption
guarantees that every ground atom constructed from atomic concepts, abstract roles,

T. Lukasiewicz

datatype roles, and constants in c can be interpreted in the description logic compo-
nent. We do not assume any other restriction on the vocabularies, that is,  and A (resp.,
RA  RD) may have unary (resp., binary) predicate symbols in common.

A disjunctive description logic program (or simply disjunctive dl-program) KB =
(L, P ) consists of a description logic knowledge base L and a disjunctive program P .
It is positive iff P is positive. It is a normal dl-program iff P is a normal program.

Example 4.1. A disjunctive dl-program KB = (L, P ) is given by the description logic
knowledge base L and the disjunctive program P of Examples 2.1 and 3.1, respectively.

) is obtained from KB by adding to L the
Another disjunctive dl-program KB
  product, which expresses that only products are
axiom  1 similar   1 similar
similar. Observe that the predicate symbol similar in P
, and it freely
occurs in both rule bodies and rule heads in P

(which is not possible in [11]).

is also a role in L
?

?

?
= (L

, P
?

?

?
Semantics. We now define the answer set semantics of disjunctive dl-programs via a
generalization of the FLP-reduct of disjunctive programs (see Section 2).
In the sequel, let KB = (L, P ) be a disjunctive dl-program. A ground instance of
a rule r  P is obtained from r by replacing every variable that occurs in r by a constant symbol from c. We denote by ground(P ) the set of all ground instances of
rules in P . The Herbrand base relative to , denoted HB , is the set of all ground
atoms constructed with constant and predicate symbols from . Observe that we now
define the Herbrand base relative to  and not relative to P . This allows for reasoning
about ground atoms from the description logic component that do not necessarily occur
in P . Observe, however, that the extension from P to  is only a notational simpli-
fication, since we can always make constant and predicate symbols from  occur in
P by dummy rules such as constant(c) and p(c) p(c), respectively. We denote
by DL the set of all ground atoms in HB  that are constructed from atomic concepts
in A, abstract roles in RA, concrete roles in RD, and constant symbols in c.
An interpretation I is any subset of HB . We say I is a model of a description
logic knowledge base L, denoted I |= L, iff L  I {a| a HB   I} is satisfiable.
Note that the former defines the truth of description logic knowledge bases L in Herbrand interpretations I  HB  rather than first-order interpretations I. Note also that
a negative concept membership C(a) can be encoded as the positive concept membership (C)(a). The following theorem shows that also negative role memberships
R(b, c) can be reduced to positive concept memberships and concept inclusions.
Theorem 4.1. Let L be a description logic knowledge base, and let R(b, c) be a role
membership axiom. Then, L{R(b, c)} is satisfiable iff L{B(b), C(c),R.C B}
is satisfiable, where B and C are two fresh atomic concepts.
An interpretation I  HB  is a model of a disjunctive dl-program KB = (L, P ), denoted I |= KB, iff I |= L and I |= P . We say KB is satisfiable iff it has a model.
Given a disjunctive dl-program KB = (L, P ), the FLP-reduct of KB relative to
an interpretation I  HB , denoted KB I, is the disjunctive dl-program (L, P I), where
P I is the set of all r  ground(P ) such that I |= B(r). An interpretation I  HB  is
an answer set of KB iff I is a minimal model of KB I. A disjunctive dl-program KB is
consistent (resp., inconsistent) iff it has an (resp., no) answer set.
?

?

?
We finally define the notions of cautious (resp., brave) reasoning from disjunctive
dl-programs under the answer set semantics as follows. A ground atom a HB  is a
cautious (resp., brave) consequence of a disjunctive dl-program KB under the answer
set semantics iff every (resp., some) answer set of KB satisfies a.

5 Semantic Properties

In this section, we summarize some semantic properties (especially those relevant for
the Semantic Web) of disjunctive dl-programs under the above answer set semantics.

Minimal Models. The following theorem shows that, like in the ordinary case (see
Section 2), every answer set of a disjunctive dl-program KB is also a minimal model
of KB, and the answer sets of a positive KB are given by the minimal models of KB.

Theorem 5.1. Let KB = (L, P ) be a disjunctive dl-program. Then, (a) every answer
set of KB is a minimal model of KB, and (b) if KB is positive, then the set of all
answer sets of KB is given by the set of all minimal models of KB.

Faithfulness. An important property of integrations of rules and ontologies is that they
are a faithful [33,34] extension of both rules and ontologies.

The following theorem shows that the answer set semantics of disjunctive dl-pro-
grams faithfully extends its ordinary counterpart. That is, the answer set semantics of
a disjunctive dl-program KB = (L, P ) with empty description logic knowledge base L
coincides with the ordinary answer set semantics of its disjunctive program P .
Theorem 5.2. Let KB = (L, P ) be a disjunctive dl-program such that L =. Then, the
set of all answer sets of KB coincides with the set of all ordinary answer sets of P .

The next theorem shows that the answer set semantics of disjunctive dl-programs also
faithfully extends the first-order semantics of description logic knowledge bases, which
here means that a ground atom a HB  is true in all answer sets of a positive disjunctive dl-program KB = (L, P ) iff a is true in all first-order models of L  ground(P ).
The theorem holds also when a is a ground formula constructed from HB  using 
and . Observe that the theorem does not hold for all first-order formulas a, but we
actually also do not need this, looking from the perspective of answer set programming,
since we actually cannot refer to all general first-order formulas in P .

Theorem 5.3. Let KB = (L, P ) be a positive disjunctive dl-program, and let a be a
ground atom from HB . Then, a is true in all answer sets of KB iff a is true in all
first-order models of L  ground(P ).
As an immediate corollary, we obtain that a HB  is true in all answer sets of a disjunctive dl-program KB = (L,) iff a is true in all first-order models of L.
Corollary 5.1. Let KB = (L, P ) be a disjunctive dl-program with P =, and let a 
HB . Then, a is true in all answer sets of KB iff a is true in all first-order models of L.

T. Lukasiewicz

Closed-World Assumption. It is often argued that the closed-world assumption is not
very desirable in the open environment of the Semantic Web [20]. The notion of cautious reasoning from disjunctive dl-programs under the answer set semantics also has
some closed-world property. However, as also shown by Theorem 5.3, this closed-world
property is actually limited to the explicit use of default negations in rule bodies, and
thus we can actually control very easily its use in disjunctive dl-programs.

Unique Name Assumption. Another aspect that may not be very desirable in the Semantic Web [20] is the unique name assumption (which says that any two distinct constant
symbols in c represent two distinct domain objects). It turns out that we actually do
not have to make this assumption, since the description logic knowledge base of a disjunctive dl-program may very well contain or imply equalities between individuals.
This result is included in the following theorem, which shows an alternative characterization of the satisfaction of L in I  HB : Rather than being enlarged by a set
of axioms of exponential size, L is enlarged by a set of axioms of polynomial size.
This characterization essentially shows that the satisfaction of L in I corresponds to
checking that (i) the ground atoms in I  DL satisfy L, and (ii) the ground atoms
in I  (HB   DL) do not violate any equality axioms that follow from L. Here, an
equivalence relation  on c is admissible with an interpretation I  HB  iff p(c1, . . . ,
cn) I  p(c
n) I for all n-ary predicate symbols p, where n > 0, and con-
?

?

?
1, . . . , c
stant symbols c1, . . . , cn, c
Theorem 5.4. Let L be a description logic knowledge base, and let I  HB . Then,
L  I {b| b HB   I} is satisfiable iff L  (I  DL)  {b| b DL  I} 
} is satisfiable for some equivalence relation  on c admissible with I.
{c= c

i for all i{1, . . . , n}.
?

?

?
 | c c
?

?

?
1, . . . , c
n

 c such that ci  c

Conjunctive Queries. It is often argued that the processing of conjunctive queries is
important for the Semantic Web [37]. As for this issue, observe that (Boolean unions of)
conjunctive queries in our approach can be reduced to atomic queries. A Boolean union
of conjunctive queries Q is of the form x(1(x)    n(x)), where x is a tuple of
variables, n  1, and each i(x) is a conjunction of atoms constructed from predicate
and constant symbols in  and variables in x. We call Q a conjunctive query when
n = 1. If we assume that x ranges over all constant symbols in c (which is sufficient
for our needs, looking from the perspective of answer set programming, since in P we
can refer only through c to elements of a first-order domain), then Q can be expressed
by adding the rules q(x) i(x) with i{1, . . . , n} to P and thereafter computing
the set of all entailed ground instances of q(x) relative to c (see also Section 6).

6 Algorithms and Complexity

In this section, we describe algorithms for deciding whether a disjunctive dl-program
has an answer set, and for deciding brave and cautious consequences from disjunctive
dl-programs under the answer set semantics. Furthermore, we also draw a precise picture of the complexity of all these decision problems.
?

?

?
Algorithm consistency
Input: vocabulary  and disjunctive dl-program KB = (L, P ).
Output: Yes, if KB has an answer set; No, otherwise.
1.
2.
3.

if there exists I  HB  such that I is a minimal model of KB I = (L, P I )
then return Yes;
else return No.

Fig. 1. Algorithm consistency

Algorithms. The problem of deciding whether a disjunctive dl-program KB = (L, P )
has an answer set can be solved by a simple guess-and-check algorithm, which guesses
a subset I of the finite Herbrand base HB , computes the FLP-reduct KB I = (L, P I),
and then checks that I is in fact a minimal model of KB I (see Fig. 1).
The problem of deciding brave and cautious consequences can be reduced to deciding answer set existence (like in the ordinary case), since a ground atom a HB 
is true in some (resp., every) answer set of a disjunctive dl-program KB = (L, P )
iff (L, P  { not a}) (resp., (L, P { a})) has an (resp., no) answer set.

Complexity. We now show that the problems of deciding consistency and brave / cautious consequences have the same complexity in disjunctive dl-programs under the answer set semantics as in ordinary disjunctive programs under the answer set semantics.
The following theorem shows that deciding the consistency of disjunctive dl-pro-
grams is complete for NEXPNP (combined complexity). The lower bound follows from
the NEXPNP-hardness of deciding the consistency of ordinary disjunctive programs
[6]. The upper bound follows from the result that deciding knowledge base satisfiability
in SHIF(D) (resp., SHOIN (D)) is complete for EXP (resp., NEXP) [40,19].
Theorem 6.1. Given  and a disjunctive dl-program KB =(L,P ) with L in SHIF(D)
or SHOIN (D), deciding whether KB has an answer set is complete for NEXPNP.
The next theorem shows that deciding cautious (resp., brave) consequences from disjunctive dl-programs is complete for co-NEXPNP (resp., NEXPNP) in the combined
complexity. This result follows from Theorem 6.1, since the two problems of consistency checking and cautious (resp., brave) reasoning can be reduced to each other.
Theorem 6.2. Given , a disjunctive dl-program KB = (L, P ) with L in SHIF(D)
or SHOIN (D), and a ground atom a HB , deciding whether a holds in every
(resp., some) answer set of KB is complete for co-NEXPNP (resp., NEXPNP).

7 Tractability Results

In this section, we describe a special class of disjunctive dl-programs for which the
problems of deciding consistency and of query processing have both a polynomial data
complexity. These programs are normal, stratified, and defined relative to DL-Lite [5],
which allows for deciding knowledge base satisfiability in polynomial time.

T. Lukasiewicz

We first recall DL-Lite. Let A, RA, and I be pairwise disjoint sets of atomic con-
cepts, abstract roles, and individuals, respectively. A basic concept in DL-Lite is either
an atomic concept from A or an exists restriction on roles R. (abbreviated as R),
where R  RA  R
A. A literal in DL-Lite is either a basic concept b or the negation of a
basic concept b. Concepts in DL-Lite are defined by induction as follows. Every basic
concept in DL-Lite is a concept in DL-Lite. If b is a basic concept in DL-Lite, and 1 and
2 are concepts in DL-Lite, then b and 1  2 are also concepts in DL-Lite. An axiom
in DL-Lite is either (1) a concept inclusion axiom b , where b is a basic concept in
DL-Lite and  is a concept in DL-Lite, or (2) a functionality axiom (funct R), where
R RA  R
A, or (3) a concept membership axiom b(a), where b is a basic concept in
DL-Lite and a I, or (4) a role membership axiom R(a, c), where R RA and a, c I.
A knowledge base in DL-Lite L is a finite set of axioms in DL-Lite.
Every knowledge base in DL-Lite L can be transformed into an equivalent one in DLLite trans(L) in which every concept inclusion axiom is of form b , where b (resp.,
) is a basic concept (resp., literal) in DL-Lite [5]. We then define trans(P ) = P 
(X) b(X)| b b
is a basic concept} {R(X) R(X, Y )| R 
{b
(Y ) R(X, Y )| R RA  }. Intuitively, we make explicit all the
RA  }  {R
rule-based relationships between the predicates in P that are implicitly encoded in L.
We define stratified normal dl-programs as follows. A normal dl-program KB = (L, P )
is stratified iff (i) L is defined in DL-Lite and (ii) trans(P ) is (locally) stratified.

  trans(L), b
?

?

?
It can be shown that stratified normal dl-programs KB = (L, P ) have either no or a
unique answer set, which can be computed by a finite sequence of fixpoint iterations
(relative to trans(P )), as usual. This implies immediately that for such programs consistency checking and query processing have both a polynomial data complexity.

Theorem 7.1. Given  and a stratified normal dl-program KB, (a) deciding whether
KB has an answer set, and (b) deciding whether a given ground atom a HB  is true
in the answer set of KB (if it exists) have both a polynomial data complexity.

8 Related Work

There is a large body of related works on combining rules and ontologies, which can
essentially be divided into the following three lines of research: (a) loose integration
of rules and ontologies, (b) tight integration of rules and ontologies, and (c) reductions
from description logics to logic programming formalisms. In this section, we discuss
only the works that are most closely related to the framework of this paper.

Representatives of the loose integration of rules and ontologies are in particular the
dl-programs in [11,12], their extension to HEX-programs [9,10], to probabilistic dl-pro-
grams [28,29], and to fuzzy dl-programs [30]. The combination of defeasible reasoning
with description logics in [3], the calls to description logic reasoners in TRIPLE [38],
and the hybrid MKNF knowledge bases in [33,34] are also close in spirit. More con-
cretely, compared to the present paper, the dl-programs KB = (L, P ) in [11] also consist of a description logic knowledge base L and a normal program P . However, P may
also contain classical negations, and rather than using concepts and roles from L as
predicates in P , rule bodies in P may only contain queries to L, which may also
contain facts as additional input to L. Like in this paper, P is interpreted relative to
?

?

?
Herbrand interpretations under the answer set semantics, while L is interpreted relative
to first-order interpretations under the classical model-theoretic semantics. However,
differently from the concepts and roles in P here, the queries in P in [11] are evaluated independently from each other. HEX-programs [9,10] extend the approach to
dl-programs in [11] by multiple sources of external knowledge, with possibly different
semantics, while probabilistic dl-programs [28,29] and fuzzy dl-programs [30] are extensions by probabilistic uncertainty and fuzzy vagueness, respectively. Closely related
to the dl-programs in [11] are also the hybrid MKNF knowledge bases in [33,34]. They
essentially allow for querying a description logic knowledge base L via the operators K
and not, which can be used more flexibly than the queries in [11] (the operators can
also occur in rule heads, while the queries are restricted to rule bodies), but which do
not allow for passing facts to L in the form of query arguments. Note that closely related
to the hybrid MKNF knowledge bases in [33,34] is also the embedding of non-ground
logic programs into autoepistemic logic in [7]. The following example shows that our
novel dl-programs here generally do not have the same meaning as the dl-programs
in [11] (note that a similar example can be constructed for the approach in [33,34]).
Example 8.1. The normal dl-program KB = (L, P ), where

implies client(a), while the normal dl-program KB
?

?

?
L = {person(a), person male  female} and
P = {client(X) male(X), client(X) female(X)}
) as in [11]
?

?

?
= (L
, P
 = {person(a), person male  female} and
 = {client(X) DL[male](X), client(X) DL[female](X)}
?

?

?
does not imply client(a), since the two queries are evaluated independently from each
other, and neither male(a) nor female(a) follows from L
. To obtain the conclusion
client(a) in [11], one has to directly use the rule client(X) DL[male  female](X).
Some representatives of tight integrations of rules and ontologies are in particular the
works due to Donini et al. [8], Levy and Rousset [27], Grosof et al. [16], Motik et
al. [35], Heymans et al. [17], and Rosati [36,37]. SWRL [21] and WRL [2] also belong to this category. Closest in spirit to this paper among the above works is perhaps
Rosatis approach [36,37]. Like here, Rosatis hybrid knowledge bases also consist of
a description logic knowledge base L and a disjunctive program (with default nega-
tions) P , where concepts and roles in L may act as predicate symbols in P . However,
differently from this paper, Rosati partitions the predicates of L and P into description
logic predicates and logic program predicates, where the former are interpreted under
the classical model-theoretic semantics, while the latter are interpreted under the answer set semantics (and thus in particular default negations of concepts and roles are
not allowed in P ). Furthermore, differently from this paper, he also assumes a syntactic restriction on rules (called weak safeness) to gain decidability, and he assumes
the standard names assumption, which includes the unique name assumption.

Finally, the works reducing description logics to logic programming are less closely
related to the framework of this paper. Some representatives are in particular the works
by Alsac  and Baral [1], Swift [39], Heymans and Vermeir [18], and Motik et al. [24].

T. Lukasiewicz

9 Summary and Outlook

We have presented a novel combination of disjunctive programs under the answer set
semantics with description logics for the Semantic Web. The combination is based on
a well-balanced interface between disjunctive programs and description logics, which
guarantees the decidability of the resulting formalism without assuming any syntactic
restrictions on the resulting language (such as syntactic safety conditions and/or syntactic partitionings of the vocabulary). We have shown that the new formalism has very
nice semantic properties. In particular, it faithfully extends both disjunctive programs
and description logics. We have also provided algorithms and precise complexity results
for the new formalism, as well as a special case of polynomial data complexity.

The presented mechanism of integrating rules and ontologies is of general impor-
tance, since it can actually also be used for the decidable integration of other reasoning techniques (such as reasoning about defaults, probabilistic uncertainty, and fuzzy
vagueness) with description logics, since it applies to all reasoning techniques that are
based on interpretations over finite Herbrand bases (or also finite sets of propositional
symbols). It thus paves the way for decidable reasoning formalisms on top of description logics for the Semantic Web. Note that a companion paper [32] explores the use of
this novel integration mechanism in fuzzy description logic programs.

An interesting topic of future research is to develop more sophisticated algorithms
for reasoning from the new disjunctive dl-programs, and to implement the approach.
Another interesting issue is to extend disjunctive dl-programs by classical negation.

Acknowledgments. This work has been supported by a Heisenberg Professorship of
the German Research Foundation (DFG). I thank the reviewers for their constructive
comments, which helped to improve this work.
