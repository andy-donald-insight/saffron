Web Service Contracting: Specification and

Reasoning with SCIFF

Marco Alberti1, Federico Chesani2, Marco Gavanelli1, Evelina Lamma1,

Paola Mello2, Marco Montali2, and Paolo Torroni2

1 ENDIF, University of Ferrara

Via Saragat 1, 44100 Ferrara, Italy

Name.Surname@unife.it

2 DEIS, University of Bologna

V.le Risorgimento 2, 40136 Bologna, Italy

Name.Surname@unibo.it

Abstract. The semantic web vision will facilitate automation of many
tasks, including the location and dynamic reconfiguration of web services.
In this article, we are concerned with a specific stage of web service loca-
tion, called, by some authors, contracting. We address contracting both
at the operational level and at the semantic level. We present a framework encompassing communication and reasoning, in which web services
exchange and evaluate goals and policies. Policies represent behavioural
interfaces. The reasoning procedure at the core of the framework is based
on the abductive logic programming SCIFF proof-procedure. We describe the framework, show by examples how to formalise policies in the
declarative language of SCIFF, and give the framework a model-theoretic
and a sound proof-theoretic semantics.

1 Introduction

The Service Oriented Computing (SOC) paradigm, and its practical implementation based on Web Services, are rapidly emerging as standard architectures
for distributed application development. Different service providers, heterogenous in terms of hardware and software settings, can easily inter-operate by
means of communication standards and well-known network protocols. In such
a scenario, the use of off-the-shelf solutions and dynamic reconfiguration becomes attractive, both at design level, as well as at execution (run-time) level.
However, dynamic reconfiguration of services is possible only if supported by a
suitable technology. The Semantic Web vision, based on the idea that adding
machine-understandable semantic information to Web resources will facilitate
automation of many tasks [18,20], including the location of Web Services, is a
promising way to address this issue.

Drawing from [18], we consider a process of searching the right service to
match a request as consisting of two stages. During the first one, called discov-
ery, the requester states only the things that are desired, thus, using an ontology
or other KR formalisms, it seeks for all the services that can potentially satisfy

E. Franconi, M. Kifer, and W. May (Eds.): ESWC 2007, LNCS 4519, pp. 6883, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
a request of such a kind. During the second stage, called contracting, the requester provides in input specific information for an already requested service.
The purpose of this second stage is to verify that the input provided will lead
to a desired state that satisfies the requesters goal.

Many relevant papers are written about web service discovery; some of them
use Logic Programming (LP) techniques. They mostly focus on the discovery
stage. In this article, we are concerned with the contracting stage, which we
address both at the operational level, and at the semantic level. We present a
framework, called SCIFF Reasoning Engine (SRE) encompassing reasoning and
communication in a networked architecture inspired to the model of discovery
engines. We discuss the problem of communicating policies between web ser-
vices, and of determining whether the policies of a provider and a requester are
compatible with each other. We use a mixture of Abductive Logic Programming
(ALP, [17]), and Constraint Logic Programming (CLP, [16]). ALP is used to construct sets of input and output messages, along with assumed data, while CLP
is used to maintain a partial temporal order among them. We chose to adopt a
hypothetical reasoning framework such as ALP because reasoning is made before
execution. A component such as SRE which reasons on possible developments
of the interaction among web services has to come up with hypotheses about
which messages are to be expected in the future. In fact, a similar approach,
also based on hypothetical reasoning, though not on LP, has been followed by
others, notably [18].

In this work we assume that a previous discovery stage has already produced
multiple candidate services. The intended user of SRE will typically be a web
service, although for the sake of presentation we will name the users alice and
eShop. The user query is given in terms of goals and policies. Policies describe
the observable behaviour of users, i.e., their behavioural interface, in terms of
relationships among externally observable events regarding the service. We formalise web services policies in a declarative language derived from the SCIFF
language, born in the context of the EU SOCS project [1]. SCIFF was conceived
to specify and verify social-level agent interaction. In this work, a simplified version of the SCIFF language is adopted for defining policies, by means of social
integrity constraints: a sort of reactive rules used to generate and reason about
possible evolutions of a given interaction instance. Distinguishing features of SRE
are its declarative and operational approaches combined together into a working
framework. Users specify their goals as well as their own policies (related to the
goals) by means of rules; in their turn, service providers publish their service
descriptions, together with their policies about the usage of the services, again
by means of rules. The use of ALP reconciles forward and backward reasoning
in a unified reasoning engine: two aspects that frequently, in the context of web
services, are treated separately from each other. Moreover, while ALP and CLP
have been used to address planning problems before, in this work we want to
show how a mixture of known, but little-used techniques can be used to solve a
real-world problem with a real implementation.

M. Alberti et al.

Policies caching

publish policies

service

query policies

provide policies

service

publish policies

service

query

Discovery Engine

inform
possible
partners

Querying and Discoverying

Fig. 1. The architecture of SRE

In the next section, we show the SRE architecture and introduce informally a
walk through scenario. In Sect. 3 we explain the notation used to write policies in
SRE and in Sect. 4 we present its underlying logic. Sect. 5 develops the scenario
in more detail and shows the reasoning in SRE by example, and Sect. 6 concludes
by discussing related approaches and future work.

2 Architecture

The SRE architecture, shown in Figure 1, is a client-server architecture augmented with a smart discovery engine (which incorporates the SRE itself).
We assume that SRE has information available about web services, either gathered in a previous discovery phase from the Internet (in the style of web spiders),
or because explicitly published to it by web services. So we can safely assume
that the data collected has already been filtered and, if providers refer to different
ontologies, equivalences between concepts have already been established.
At the logical level, the retrieved information consists of triplets in the form
s, ws, (KBws,Pws), where s identifies a service, ws is the name of a web service
that provides s, and (KBws,Pws) are the knowledge base and policies that ws
associates to s. In particular, for a given provider ws providing s, a set of policies
(rules) describes wss behaviour with respect to s, and a knowledge base, in
the form of a logic program, contains information that ws wants to disclose to
potential customers, together with its policies. A sample policy could state that
the service delivers goods only to certain countries, or zones. The list of such
zones could be made available through the knowledge base.

SRE reasons based on a clients query (also called goal, in the LP sense) which
it matches to a service. Such a query will contain the name of the service that
the client (c) needs, a (possibly empty) set of policies Pc and a (possibly empty)
knowledge base KBc. The goal is an expression consisting of a conjunction of
elements, which can represent, for example, events and constraints, like partial
orders among events. The output of SRE is a number of triplets ws,E, , each
one containing the name of a web application which provides the service, plus
?

?

?
some additional information: E, which encodes a possible future interaction, i.e.,
a partially ordered sequence of events, occurring between ws and c and regarding
s, and a set  containing a number of additional validity conditions for E. For
example, ws could be the name of a service that provides a device, E could be
first ws shows evidence of membership to Better Business Bureau (BBB), then
c pays by credit card, and  could be delivery in Europe. These concepts are
better instantiated in the following scenario.

2.1 The alice and eShop Scenario

The scenario we use in this paper is inspired from [11,2]. eShop is a web service
that sells devices, while alice is another web service, which wants to get a device.
alice and eShop describe their behaviour concerning sales/payment/. . . of items
through policies (rules), which they publish using some Rules Interchange For-
mat. These two actors find each other via SRE: in particular, alice submits a
query to the discovery engine, by specifying her policies and the service she is
looking for (e.g., getting device). Once suitable services (e.g., eShop) have been
found, SRE, by checking the satisfiability of alices goal and the compatibility
of the rules describing alices and eShops behaviour, provides back to alice the
list of web services that could satisfy her specific need. SRE also defines the
conditions that must be fulfilled by each web service, in order to reach the goal.

Let eShops policies regarding device be as follows:

(shop1) if a customer wants to get an item, then, (i) if the customer can be
accepted, eShop will request him/her to pay using an acceptable method,
otherwise (ii) eShop will inform the customer of a failure;

(shop2) if an acceptable customer paid the item, using an acceptable method,

(shop3) if a customer requests a certificate about eShops membership to the

then eShop will deliver the item;
BBB, then the shop will send it.
eShop publishes a knowledge base KBeShop, which specifies that a customer
is accepted if it is resident in some zone; it also specifies the accepted payment
methods. SRE retrieves information about eShop in the triplet: sell(device),
eShop, (KBeShop, PeShop), indicating that eShop offers service sell(device), with
a set PeShop of policies defined as PeShop  {(shop1), (shop2), (shop3)} and a
knowledge base KBeShop. We consider three different scenaria for alice:
Scenario 1. alices goal is to obtain device. Her policies are as follows:

(alice1) if a shop requires that alice pays by credit card, alice expects that
the shop provides a certificate to guarantee that it is a BBB member;
(alice2) if a shop requires that alice pays by credit card, and it has proven
its membership to the BBB, then alice will pay by credit card;

(alice3) if a shop requires alice to pay with any other method than credit

card, then alice will pay without any further request;

Besides, alice is based in Europe. However, for privacy reason, alice does not
make this information public. KBalice is an an empty knowledge base.

M. Alberti et al.

Scenario 2. Policies are the same as above. However, alice will not agree to pay
cash, as she specifies in her query to SRE. Moreover, KBalice is not empty,
but instead it contains information about her place of residence and age;
Scenario 3. alice has no policies to express in relation to the query she submits
to SRE. We can imagine here that alice is a human user, and she queries
SRE, using a suitable interface, simply because she wishes to know what
her options are regarding the purchase of device. Later, alice may evaluate
SREs answer and possibly re-submit a refined query.

3 Notation

In SRE, policies describe a web services observable behaviour in terms of events
(e.g., messages). SRE considers two types of events: those that one can directly
control (e.g., if we consider the policies of a web service ws, a message generated
by ws itself) and those that one cannot (e.g., messages that ws receives, or does
not want to receive). Atoms denoted by H denote controllable events, those
denoted by E and EN denote passive events, also named expectations. Since
SRE reasons about possible future courses of events, both controllable events
and expectations represent hypotheses on possible events. We restrict ourselves
to the case of events being messages exchanged between the two parties in play.
The notation is:
 H(ws, ws

, M, T ) denotes a message with sender ws, recipient ws
?

?

?
 at a time T ;

, and con-
, recipient ws, and con-
, recipient ws, and

tent M, which ws expects to be sending to ws

, ws, M, T ) denotes a message with sender ws

tent M, which ws expects ws

 to be sending at a time T ;

 E(ws
?

?

?
 EN(ws
?

?

?
, ws, M, T ) denotes a message with sender ws

content M, which ws expects ws

 not to be sending at a time T ;

Web service specifications in SRE are relations among expected events, expressed by an abductive logic program. This is in general a triplet KB, A, IC,
where KB is a logic program, A (sometimes left implicit) is a set of literals named
abducibles, and IC is a set of integrity constraints. Intuitively, in ALP the role of
KB is to define predicates, the role of A is to fill-in the parts of KB which are un-
known, and the role of IC is to control the ways elements of A are hypothesised,
or abduced. Reasoning in ALP is usually goal-directed. It starts from a goal
G, i.e., an expression which we want to obtain as a logical consequence of the
abductive logic program, and it amounts to finding a set of abduced hypotheses
 built from atoms in A such that KB   |= G and KB   |= IC. Symbol
|= represents logical entailment, which can be associated with one among several semantics. In literature one finds different readings of abduction in LP. 
can be considered as an answer to a query or goal G. In other contexts, one
can interpret G as an observation and  as its explanation. This is for example
the reading of an abductive anwer in abductive reasoning-based diagnosis. In the
?

?

?
domain of web services, we will use ALP as a reasoning paradigm that combines
backward, goal-oriented reasoning with forward, reactive reasoning [19]: two aspects that frequently, in the context of web services, are treated separately from
each other.

Definition 1 (Web Service Behavioural Interface Specification). Given
a web service ws, its web service behavioural interface specification Sws is an
abductive logic program, represented by the triplet Sws  KBws,A,ICws, where
KBws is wss Knowledge Base, A is the set of abducible literals, and ICws is
wss set of Integrity Constraints (ICs).
KBws, which corresponds to KBws of Sect. 2, is a set of clauses which declaratively specifies pieces of knowledge of the web service. Note that the body of
KBwss clauses may contain E/EN expectations about the behaviour of the web
services. A is the set of abducible literals. It includes all possible E/EN expecta-
tions, H events, and predicates left undefined by KBws. It is the set of all possible
unknowns. Note that Ews and  of Sect. 2 are subsets of A. In the following
sometimes we leave A implicit, as we did in Sect. 2. ICws, which corresponds to
Pws of Sect. 2, contains wss policies. In particular, each IC in ICws is a rule in
the form Body  Head. Intuitively, the Body of an IC is a conjunction of events,
literals and CLP constraints; the Head is either a disjunction of conjunctions of
events, literals and CLP constraints, or false. The operational behaviour of ICs
is similar to that of forward rules: whenever the body becomes true, the head
is also made true. The syntax of KBws and ICws is given in Equations (1) and
(2), respectively, where Constr indicates a CLP constraint [16].

KBws::= [ Clause ]
Clause::= Atom  Cond
Cond::= ExtLiteral [  ExtLiteral ]
Expect::= E(Atom, Atom, Atom, Atom)|
EN(Atom, Atom, Atom, Atom)

ExtLiteral::= []Atom | true | Expect | Constr

IC::= Body  Head

ICws::= [ IC ]
Body::= (Event | Expect) [BodyLit]
BodyLit::= Event | Expect | Atom | Constr
Head::= Disjunct [  Disjunct ] | false
Disjunct::= (Expect | Event | Constr)
[  (Expect | Event | Constr)]
Expect::= E(Atom, Atom, Atom, Atom) |
EN(Atom, Atom, Atom, Atom)

Event::= H(Atom, Atom, Atom, Atom)

(1)

(2)

Let us see how we can implement the walk through scenario in SRE. Note that,
following the LP notation, variables (in italics) start with upper-case letters.
Tr, Ta, . . . indicate the (expected) time of events.

M. Alberti et al.

The first IC in ICeShop, corresponding to (shop1), is the following:

H(Customer, eShop, request(Item), Tr)

accepted customer(Customer)

 accepted payment(How)
 H(eShop, Customer, ask(pay(Item, How)), Ta)
 E(Customer, eShop, pay(Item, How), Tp)
 Tp > Ta  Ta > Tr
rejected customer(Customer)
 H(eShop, Customer, inf orm(f ail), Ti)  Ti > Tr.

(shop1)

All accepted payment modalities are listed in eShops knowledge base, KBeShop,
shown in (kb) below. In our example, Customer may pay either by credit card
or cash. The concepts of accepted and rejected customer are defined in
the KBeShop too: a Customer is accepted if the Zone she resides in is a valid
destination for eShop; Customer is rejected otherwise. Both payment modalities
and accepted destinations are listed as facts. In this example, eShop can only
send items to Europe. The next element of eShops policies (shop2) states that
if an accepted Customer pays for an Item using one of the supported payment
modalities, then eShop will deliver the Item to Customer:

H(Customer, eShop, pay(Item, How), Tp)
 accepted customer(Customer)
 accepted payment(How)

H(eShop, Customer, deliver(Item), Td)

 Td > Tp.

(shop2)

Finally, (shop3) states that if a Customer asks it to provide a guarantee (i.e.,
a certificate about its membership to BBB), eShop will send such a guarantee:

H(Customer, eShop, request guar(BBB), Trg)

H(eShop, Customer, give guar(BBB), Tg)

 Tg > Trg.

accepted customer(Customer) resident in(Customer, Zone)

rejected customer(Customer) resident in(Customer, Zone)
 not(accepted dest(Zone)).

 accepted dest(Zone).

(shop3)

(kb)

accepted payment(cc).

accepted payment(cash).

accepted dest(europe).
?

?

?
When a (generic) Shop asks alice to pay an Item with credit card, then alice
will request the Shop to provide a guarantee, and she will expect to receive it:

H(Shop, alice, ask(pay(Item, cc)), Ta)

H(alice, Shop, req guar(BBB), Trg)

 E(Shop, alice, give guar(BBB), Tg)
 Tg > Trg  Trg > Ta.

If Shop provides a guarantee, alice will pay for the requested Item:

H(Shop, alice, ask(pay(Item, cc)), Ta)
 H(Shop, alice, give guar(BBB), Tg)

H(alice, Shop, pay(Item, cc), Tp)

 Tp > TA  Tp > Tg.

(alice1)

(alice2)

When the Shop asks to use a payment modality other than credit card, alice
satisfies eShops request:

H(Shop, alice, ask(pay(Item, How)), Ta)
 How = cc

H(alice, Shop, pay(Item, How), Tp)  Tp > TA.

(alice3)

4 Declarative Semantics and Reasoning
In SRE, a client c specifies a goal G, related to a requested service. G will often
be an expectation, but in general it can be any goal, defined as a conjunction of
expectations, CLP constraints, and any other literals. c also publishes a (possibly
empty) knowledge base KBc, and a (possibly empty) set of policies ICc. The idea
is to obtain, through abductive reasoning made by SRE, a set of expectations E
and validity conditions  about a possible course of events that, together with
KBc and KBws, satisfies ICc ICws and G. Note that we do not assume that all
of wss knowledge base is available to SRE, as it need not be entirely a part of
wss public specifications. KBws can even be the empty set. However, in general,
ICs can involve predicates defined in the KB: such as delivery in Europe.
If the behavioural interface provided by ws involves predicates that have not
been made public through KBws, SRE makes assumptions about such unknown
predicates, and considers unknowns that are neither H nor E/EN expectations
as literals that can be abduced. These are kept then in the set , of a returned
triplet ws,E,  (see Sect. 2), and can be regarded as conditions which must be
met to insure the validity of E as a possible set of expectations achieving a goal.

4.1 Declarative Semantics
We define declaratively the set of abductive answers ws,E,  representing possible ways c and ws can interact to achieve G (we assume that KBc and KBws
are consistent) via the two following equations:
KBc  KBws  E   |= G
KBc  KBws  E   |= ICc  IC ws.

(3)

(4)

M. Alberti et al.

where E is a conjunction of H and E, EN atoms,  is a conjunction of abducible literals, and the notion of entailment is grounded on the possible models
semantics defined for abductive disjunctive logic programs [23]. In the possible
models semantics, a disjunctive program generates several (non-disjunctive) split
programs, obtained by separating the disjuncts in the head of rules. Given a disjunctive logic program P , a split program is defined as a (ground) logic program
obtained from P by replacing every (ground) rule
r : L1    Ll  

from P with the rules in a non-empty subset of Splitr, where

Splitr = {Li   | i = 1, . . . , l}.

By definition, P has in general multiple split programs. A possible model for a
disjunctive logic program P is then defined as an answer set of a split program
of P .

Note that in [23] the possible models semantics was also applied to provide a
model theoretic semantics for Abductive Extended Disjunctive Logic Programs
(AEDP), which is our case. Semantics is given to AEDP in terms of possible
belief sets. Given an AEDP  = P,A, where P is a disjunctive logic program
and A is the set of abducible literals, a possible belief set S of  is a possible
model of the disjunctive program P  E, where P is extended with a set E of
abducible literals (E  A).
Definition 2 (Answer to a goal G). An answer E to a (ground) goal G is a
set E of abducible literals constituting the abductive portion of a possible belief
set S (i.e., E = S  A) that entails G.
We rely upon possible belief set semantics, but we adopt a new notion for minimality with respect to abducible literals. In [23], a possible belief set S is A-
minimal if there is no possible belief set T such that T A  S A. We restate,
then, the notion of A-minimality as follows:
Definition 3 (A-minimal possible belief set). A possible belief set S is A-
minimal iff there is no possible belief set T for the same split program such that
T  A  S  A.
More intuitively, the notion of minimality with respect to hypotheses that we
introduce is checked by considering the same split program, and by checking
whether with a smaller set of abducible literals the same consequences can be
made true, but in the same split program. Finally, we provide a model-theoretic
notion of explanation to an observation, in terms of answer to a goal, as follows.
Definition 4 (A-minimal answer to a goal). E is an A-minimal answer to
a goal G iff E = S  A for some possible A-minimal belief set S that entails G.
Definition 5 (Possible Interaction about G). A possible interaction about
a goal G between a client c and a web service ws is an A-minimal set E   such
that Equations 3 and 4 hold.
?

?

?
Among possible interactions, we identify those which are coherent:1
Definition 6 (Coherent Possible Interaction about G). A possible interaction E   about a goal G is coherent iff:

E |= E(X, Y, Action, T ), EN(X, Y, Action, T )  f alse

(5)

Possible interactions about a goal G generally contain (minimal) sets of events
and expectations about messages raised either by c and ws. Moreover, further
abducible literals in  represent assumptions about unknown predicates (for c
and ws).

SRE selects among coherent possible interactions only those where the course
of events expected by c about wss messages is fulfilled by wss messages, and
vice-versa, i.e., the course of events expected by ws about cs messages is fulfilled
by cs messages:
Definition 7 (Possible Interaction Achieving G). Given a client c, a web
service ws, and a goal G, a possible interaction achieving G is a coherent possible
interaction E   satisfying the following equations:

E |= E(X, Y, Action, T )  H(X, Y, Action, T )

E |= EN(X, Y, Action, T ), H(X, Y, Action, T )  f alse

(6)

(7)

In practice, Definition 7 requires that any positive expectation raised by c or
ws on the behaviour of the other party is fulfilled by an event hypothetically
performed by the other party (Equation 6), and that any negative expectation
raised by c or ws on the behaviour of the other party does not match any event
hypothetically performed by the other party (Equation 7).

4.2 Operational Semantics
The operational semantics of SRE is a modification of the SCIFF proof-procedure
[8], that combines forward, reactive reasoning with backward, goal-oriented rea-
soning, and was originally developed to check compliance of the agent behaviour to
interaction protocols in multi-agent systems. Like the IFF proof procedure [13],
which inspired it, SCIFF is a rewriting system, defined in terms of transitions
which turn a state of the computation into another. Since some of the transitions
open choice points, a computation can be represented as a tree, whose root node
is the initial state and whose leaves can be either the special node fail, or a termination node (i.e., a node to which no transition is applicable), that is considered
as a success node (and, in the original SCIFF setting, represents a response of
compliance of the agent behaviour to the interaction protocols)
SCIFF is sound and complete, under reasonable assumptions [8]; it has been
implemented in SICStus Prolog and Constraint Handling Rules [12] and integrated in the SOCS-SI software component, in order to interface it to several
1 This notion is introduced because of EN expectations in the SRE framework, and
therefore the necessity of stating explicitly the incompatibility between E and EN.

M. Alberti et al.

multi-agent systems [7], and with web services via a RuleML encoding of ICs.
The SCIFF version that acts as the core reasoning engine in SRE is designed to
reason, off-line, about the web service behaviour: a successful leaf node represents
an interaction which achieves the desired goal while respecting the specified poli-
cies. SRE is a conservative modification of the SCIFF proof-procedure, in which
the happened events are abducibles. The proofs of soundness and completeness
can be trivially extended to such a case.

5 The alice and eShop Scenario Revisited

We provide here a sketched demonstration of the operational behaviour of the
SRE engine, by showing how the answers to alices query are generated. Let us
suppose that alice sends a query to SRE containing policies (alice1), (alice2) and
(alice3), an empty knowledge base and the following goal G:

G  H(alice, Shop, request(device), Tr)

 E(Shop, alice, deliver(device), Td)  Td > Tr.

(goal1)

E(eShop, alice, deliver(device), Td), Td > Tr }

which states that alice will send a request to some Shop in order to obtain device
and she expects that Shop will deliver it. SRE starts from alices goal:
E0 = {H(alice, eShop, request(device), Tr),
0 = 
According to (shop1), eShop may react to this expectation in different ways,
depending on whether alice is an accepted customer or not. SRE tries initially
to resolve predicate accepted customer(alice). By unfolding it, SRE finds atom
resident in(alice, Zone), which is not known to SRE and, therefore, is abduced.
Afterwards, based on KBeShop, the eShop public knowledge base, SRE grounds
Zone to europe: the only destination accepted by eShop. As a consequence, hypothesising that alice is resident in europe, eShop would ask alice to pay with
one of the accepted modalities, and it would expect to receive the payment in
response. Moreover, eShop specifies in KBeShop that credit card is an accepted
payment modality.
E1 = {H(alice, eShop, request(device), Tr),
H(eShop, alice, ask(pay(device, cc), Ta),
E(alice, eShop, pay(device, cc), Tp),
E(eShop, alice, deliver(device), Td),
Tp > Ta, Ta > Tr, Td > Tr }
1 = {resident in(alice, europe)}
alice has specified that, in order to perform credit card payments, she requests
a guarantee from the shop (alice2); eShop volunteers to provide such a document,
?

?

?
by (shop3), and alices expectation about the guarantee is then satisfied (SRE
hypothesises that the document is indeed sent):
E2 = {H(alice, eShop, request(device), Tr),
H(eShop, alice, ask(pay(device, cc), Ta),
H(alice, eShop, req guar(BBB), Trg),
H(eShop, alice, give guar(BBB), Tg),
E(alice, eShop, pay(device, cc), Tp),
E(eShop, alice, deliver(device), Td),
Tg > Trg, Trg > Ta, Tp > Ta, Ta > Tr, Td > Tr }

2 = {resident in(alice, europe)}
Upon receipt of the guarantee, alice would proceed with the payment (alice2),
and eShop would deliver the device (shop3). Therefore, the following, (possibly)
fruitful, interaction is found by SRE:
EF = {H(alice, eShop, request(device), Tr),
H(eShop, alice, ask(pay(device, cc), Ta),
H(alice, eShop, req guar(BBB), Trg),
H(eShop, alice, give guar(BBB), Tg),
H(alice, eShop, pay(device, cc), Tp),
H(eShop, alice, deliver(device), Td),
Td > Tp, Tp > Tg, Tg > Trg, Trg > Ta, Ta > Tr }

F = {resident in(alice, europe)}
SRE provides in output also a simpler possible interaction, where instead
of selecting credit card as payment method, cash is now preferred. Policy
(alice3) tells us that, in such a case, alice would proceed straightforward with
the payment, and SRE is indeed able to propose a second fruitful interaction as
answer to alices initial query.

In order to compute these two possibly fruitful interactions, resident in(alice,
europe) has been abduced. This means that if such interactions are really possible
or not, it depends on whether alice resides in europe, and in fact it may well
turn out that such interaction is not possible at all. SRE looks also for other
solutions where this hypothesis is not assumed, but all other interactions do not
satisfy alices goal, and hence they are discarded.

5.1 Refined Query
In the second scenario, alice submits a different goal, and the KB below:

G  H(alice, Shop, request(device), Tr)

 E(Shop, alice, deliver(device), Td)  Td > Tr
 EN(alice, Shop, pay(device, cash), Tp).
resident in(alice, europe). age(alice, 24).

(goal2)

(kb2)
This time, alice explicitly prohibits to pay cash (this is expressed using the EN
notation). Thanks to the piece of knowledge (kb2) that alice provides through her

M. Alberti et al.

KB, SRE knows that alice does indeed resides in the EU, hence this information
does not need to be abduced anymore, but it is simply verified. SRE finds a
solution which is similar to the one above (Scenario 1). However, since this time
the set  is empty, this interaction will surely lead to success, provided that
both alice and eShop behave coherently with respect to their own policies.

5.2 Unconstrained Query

As we have pointed out, alice is able to query SRE without specifying any
policy. In this case, alice only wishes to obtain a list of services that are able to
accommodate her goal. In such a situation, alice only sends the following general
policy:

E(alice, Shop, DoSomething, T )
H(alice, Shop, DoSomething, T )

(r1)

which specifies that alice will perform every action that she is expected to do. If
alice queries SRE by using (r1) and (goal1), the response of SRE will be:
EF = {H(alice, eShop, request(device), Tr),
H(eShop, alice, ask(pay(device, How), Ta),
H(alice, eShop, pay(device, How), Tp),
H(eShop, alice, deliver(device), Td),
Td > Tp, Tp > Ta, Ta > Tr, How :: [cc, cash] }

F = {resident in(alice, europe)}

6 Discussion

We described a reasoning engine, SRE, which considers the policies of two web
services and a goal of one of them. SRE tries to match such policies and find
possible ways the two web services could interact, and eventually achieve the
goal. The output of SRE is a sequence of events, which could be messages to
be exchanged between the web services and lead to a state in which the goal
is achieved. This can be regarded as a possible plan of action. SRE is based
on a mixture of ALP and CLP. ALP is used to construct sets of input and
output messages, along with assumed data, while CLP is used to maintain a
partial temporal order among the plans. In this work we did not address the
issue of efficiency of the reasoning process of SRE, but we are aware that this
may be a drawback, as it is the case with many expressive logics proposed for the
Semantic Web. We intend to evaluate SRE, both as it concerns its complexity
and its efficiency, through an empirical analysis based on case studies.

Another aspect we did not look into in detail is the problem of reasoning
about equivalences of concepts or ontologies, as much related work instead does.
Also our notions of action, such as it could be the delivery of goods, are pretty
much left at the abstract level. Our proposal could be regarded as a functionality
complementary to many proposals, which could further improve the discovery
?

?

?
process. To cite some, [3,22] propose ontology languages to define web services. In
[4], besides proposing a general language for representing semantic web service
specification using logic, a discovery scenario is depicted and an architectural
solution is proposed (we draw inspiration for our scenario from the Discovery
Engine example). A notion of mediator is introduced to overcome differences
between different ontologies, and then a reasoning process is performed over the
user inputs and the hypothetical effects caused by the service execution.

Our work makes explicit reference to [18], in which the authors present a
framework for automated web service discovery which uses the Web Service
Modeling Ontology (WSMO) as the conceptual model for describing web ser-
vices, requester goals and related aspects. Whereas [18] tackles both (mainly)
discovery and contracting stage, in our work we are only concerned with the
contracting stage. In [18] the authors use F-logic and transaction logic as the
underlying formalisms, we rely on extended logic programming. In both the ap-
proaches, however, hypothetical reasoning is used for service contracting. Compare to work by Kifer et al. [18,4], in which only the clients goal is considered,
in our framework the client can specify its policies. In this way, the client could
be considered a web service as well. Therefore, we hope to be able to smoothly
extend SRE to dealing with the problem of inter-operability. A proposal in this
direction is presented in [6].

The outcome of the reasoning process performed by SRE, which we called a
possible plan, could in fact be regarded as a sort of contract agreement between
the client and the discovered service, provided that each party is tightly bounded
to its previously published policies/knowledge bases. For example, the dynamic
agreement about contracts (e-contracting) is addressed in SweetDeal [15,10],
where Situated Courteous Logic (SCL) is adopted for reasoning about rules that
define business provisions policies. The formalism used supports contradicting
rules (by imposing a prioritisation and mutual exclusion between rules), different
ontologies, and effectors as procedures with side effects. However, SweetDeal is
more focussed on establishing the characteristics of a business deal, while our aim
is to address the problem of evaluating the feasibility of an interaction. To this
end, we perform hypothetical reasoning on the possible actions and consequences;
moreover, we hypothesise which condition must hold, in order to inter-operate.
This technique in literature is also known as constructive abduction.

Other authors propose to rules to reason about established contracts: in [14],
for example, Defeasible Deontic Logic of Violation is used to monitor the execution of a previously agreed contract. We have addressed this issue in a companion
paper [9], where integrity constraints have been exploited and conciliated with
the deontic concepts. Among other work in the area of policy specifications and
matching we find PeerTrust [21,5]. Similarly to our work and to SCL, PeerTrust
builds upon an LP foundation to represent policy rules and iterative trust declar-
atively. In PeerTrust, trust is established gradually by disclosing credentials and
requests for credentials by using a process of trust negation. An important difference is in the language used in PeerTrust for specifying policies, which can
be considered as orthogonal to the one described in this paper. While PeerTrust

M. Alberti et al.

represents policies and credentials as guarded distributed logic programs, and
the trust negotiation process consists of evaluating an initial LP query over a
physically distributed logic program, in this work we use ALP, integrity constraints and CLP constraints for expressing policies, perform a local proof and
we use abductive reasoning to formulate hypotheses about unknown external
behaviour. Moreover, while in our current approach reasoning is done in a single
step using SCIFF, an iterative version could be introduced in order to support
trust negotiation.

Acknowledgments

We wish to thank the anonymous reviewers for their comments, constructive
criticisms and valuable suggestions. This work has been partially supported by
the National FIRB project TOCAI.it and by the PRIN projects Nos. 2005011293 and 2005-015491.
