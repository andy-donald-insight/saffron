Vague Knowledge Bases for Matchmaking in P2P

E-Marketplaces

Azzurra Ragone1, Umberto Straccia2, Tommaso Di Noia1,

Eugenio Di Sciascio1, and Francesco M. Donini3

1 SisInf Lab - Politecnico di Bari, Via Re David, 200, I-70125, Bari, Italy

{a.ragone,t.dinoia,disciascio}@poliba.it

2 ISTI - CNR, Via G. Moruzzi 1, 56124 Pisa, Italy

3 Universit`a della Tuscia, via San Carlo, 32, I-01100, Viterbo, Italy

straccia@isti.cnr.it

donini@unitus.it

Abstract. In this paper we propose an approach to semantic matchmaking that
exploits various knowledge representation technologies to find most promising
partners in peer-to-peer e-marketplaces. In particular we mix in a formal and principled way the semantic expressiveness of DLR-lite Logic Programs, fuzzy logic
and utility theory. We adopt DLR-Lite Logic Programs to obtain a reasonable
compromise between expressiveness and complexity to ensure the scalability of
our approach to large e-marketplaces, and Fuzzy Logic to model logical specifications as soft constraints. Furthermore, fully exploiting the peer-to-peer paradigm,
we consider in the matchmaking process preferences and corresponding utilities
of both parties.

1 Introduction

The distinguishing characteristic of a peer-to-peer (P2P) e-marketplace is that basically
peer users  both buyers and sellers  can submit their advertisements, browse through
available ads, and be assisted in finding the best available counterparts to meet their
needs and initiate a commercial transaction. Furthermore, in such marketplaces, there
is often the need to negotiate not only on single numerical features such as price, quan-
tity, etc., but also on some goods characteristics. Then there is the need to represent
advertisements in a machine understandable way, using languages able to model the
background domain knowledge. Also, descriptions could have logical implications, e.g.,
If a car has leather seats then it is also provided with air conditioning or bundles e.g.,
Sports car with optional package including both GPS system and alarm system, and
some kind of logical theory, able to let users express their needs/offers, could surely
help. Finally, while performing a matchmaking process between two peers advertise-
ments, we should take into account user preferences  soft constraints  and distinguish
them from mandatory  hard  ones.

In an e-commerce setting, matchmaking can be defined as the process of finding
good counterparts for a given entry in the marketplace. Of course, the evaluation of
how good a counterpart is constitutes most of the effectiveness of a matchmaking
system. Currently, many commercial sites force the buyer to enter her request browsing

E. Franconi, M. Kifer, and W. May (Eds.): ESWC 2007, LNCS 4519, pp. 414428, 2007.
c Springer-Verlag Berlin Heidelberg 2007
?

?

?
a predefined classification that may be completely unsuitable for the characteristics
the buyer might have in mind e.g., they require to enter a brand first, then a model of
that brand, etc. while a buyer may be not interested in a specific brand, but only on
some limitations on price and color. In this respect, one may say that they provide no
matchmaking assistance: the matchmaker is the buyer herself. Even the use of textual
search engine (as in eBay) does not help a lot, since the result is a (sometimes very long
and tedious) list to browse.

To assist buyers and sellers in marketplaces, several research proposals on matchmaking systems were issued. They either try to compute a score of possible counter-
parts, based on textual information [25], or to compare the logical representations of
supply and demand [10], or combine both scores and logic in some way [7,16]. Our proposal falls in this last category, mixing in a formal way ontologies in DLR-Lite, Datalog
rules, Fuzzy sets, and Utility Theory. While all the above logic-based proposals suffer
on the scalability side, our resort on DLR-Lite and Datalog ensures the scalability of
our approach w.r.t. to large datasets.

Furthermore, following the economical approach to negotiation, the matchmaker
computes a score as the maximum value of the product of the weighted utility of the
buyer u times the weighted utility of the seller u over all possible agreements between the buyer and the seller. In this way both buyers and sellers preferences are taken
into account ruling out of the match list those counteroffers that, although seemingly
appealing for the buyer, would probably lead to failure due to contrasting preferences
of the seller, that we take already into account.

The remaining of the paper is as follows: Section 2 introduces basics of languages
and technologies we adopt. In Section 3 requirements for matchmaking process, including preferences, utility functions are illustrated and vague knowledge bases are
introduced. The description of the matchmaking process over vague knowledge bases
follows in Section 4. Next, in Section 5 rules for item classification in P2P marketplaces
are outlined. An illustrative example is presented in Section 6, discussion about relevant
related work and conclusions close the paper.

2 Basic Technologies

As our representation and query tool, we use a specific combination of Description
Logics [3] (DLs), Logic Programming [6] (LPs) and Fuzzy Theory [26].
A Knowledge Base is a triple K = F,O,P, where F is a set of facts stored
into a relational database, O is the DL component and P is the rule component. The
the intenDL component is used to model the application domains ontology (e.g.,
tional knowledge). Specifically, we use a description logic of the family of DLs, DLRLite [5]. Concerning the rule and query component, we use an extension of Datalog
(cf. [6] among others), in which we allow soft constraint predicates to appear in rules
and queries [22]. Basically, we allow vague/fuzzy predicates to occur in rule bodies,
which have the effect that each tuple in the answer set of a query has now a score in
[0,1]. The main problem to be addressed in the resulting language is the problem to
compute the top-k answers in case the set of facts is huge, without evaluating all the
tuples score. As matching a buyers request with a sellers offer is a matter of degree,
our purpose is to find the top-k matches only, rather than all matches.

A. Ragone et al.

In the following, consider a knowledge base K = F,O,P.

Facts component. Concerning the facts component,F is simply a finite set of formulae
of the form R(c1, . . . , cn), where R is an n-ary predicate and ci are constants. Facts,
representing extensional information, are stored in relational tables of an underlying
database. For instance,

CarT able(544, F iatP unto, 2004, 15000)

I = b

that maps an n-ary predicate R into an n-ary relation R

is a fact stating that item 544 is a Fiat Punto, built in 2004 and having 15000 kilometers.
An interpetation I = ,I consists of a fixed infinite domain  and an interpretation function I
over  and
if a = b (unique name assumpmaps constants into constants of  such that a
tion). We assume to have one object for each constant, denoting exactly that object. In
other words, we have standard names, and we will not distinguish between the alphabet
of constants and the objects in .
DL component. Concerning the DL component, O is a finite set of DLR-Lite axioms 1. A DLR-Lite axiom has the form C1  C2 (concept inclusion) or has the form
(disjoint C1, . . . , Cn) (disjointness axiom), where Ci is a concept expression. Infor-
mally, C1  C2 says that the set denoted by C1 is a subset of the set denoted by
C2, while (disjoint C1, . . . , Cn) declares that the concepts are pairwise disjoint. Concepts expressions are constructed starting from a set of atomic concepts and relations
by applying suitable constructs. In DLR-Lite we distinguish between constructs that
are allowed in the left-hand side (Cl) and those in the right-hand side (Cr) of concept
inclusions, according the following syntax:

Cl  A | i : R | Cl1  Cl2
Cr  A | i : R | Cr1  Cr2

where R is an n-ary predicate and i  {1, . . . , n}.

An interpretation I = ,I maps a concept C into subsets C

of . In the fol-
lowing, R denotes an n-ary predicate, and we use c to denote an n-tuple of constants,
and c[i] to denote the i-th component of c. Then I

has to satisfy:

I  

(C1  C2)
?

?

?
= C1
(C1  C2)
?

?

?
= C1
I}
(i : R)
= {c[i] | c  R

An interpretation satisfies (is a models of ) C1  C2 iff C1
I  C2

tation satisfies (is a models of ) (disjoint C1, . . . , Cn) iff i = j.Ci

I  C2
I  C2

, while an interpre-
I  Cj

= .

1 Here we refer to DLR-Litecore but any DL of the DL-Lite or DLR-Lite family can be as well

considered.
?

?

?
Example 1. The following set of axioms is an excerpt of the encoding for the web
directory behind the car selling site www.autos.com:

Cars  V ehicles
T rucks  V ehicles
V ans  V ehicles
LuxuryCars  Cars
P assengerCars  Cars
(disjoint Cars, T rucks, V ans)

CompactCars  P assengerCars
V ehicles  1 : hasM aker  1 : hasP rice
1 : hasP rice  1 : hasM aker  V ehicles
2 : hasM aker  CarM aker
Cars  1 : hasKmW arranty  1 : hasF uel
2 : hasF uel  F uelT ype

Given a DLR-Lite ontology related to a relation model, in [5] it is shown how to rewrite
a conceptual query over the ontological model in a conjunctive query over the relational
model in the form

q(x)  ybody(x, y)

Here body is the conjunction of n-ary predicates representing the information modeled
by concepts and roles in the DLR-Lite ontology.

Notice that even apparently simple, DLR-Lite family languages are expressive

enough to represent RDFS2 ontologies (at least their DL subset).
LP component. Concerning the rule component of a knowledge base, P is a finite set
of vague Datalog rules[22], which are defined as follows.

A Datalog rule is a Horn clause of the form

P (t0)  R1(t1), . . . , Rn(tn) ,

where P (t0) is the head of the rule, and R1(t1), . . . , Rn(tn) is the body of the rule.
P (t0) and all Ri(ti) are atoms, ti are arrays of terms. A term is either a variable or a
constant. Here we also provide a set of built-in predicates, like +,,, /,,, =, with
(obvious) fixed interpretation, which may appear in a rule body.
head of a Datalog rule in P. For instance,

A Datalog query predicate q is a designated n-ary predicate symbol appearing in the

q(x, p)  Cars(x), hasP rice(x, p), p  15000
is a query asking for cars whose price is less or equal than 15000.

The interpretation of n-ary predicates, terms and the notions of satisfiability (is

model of) and logical consequence are as usual.

Vague Datalog rules are as Datalog rules except that we additionally allow fuzzy
predicates to occur in Datalog rule bodies (see [22]). Specifically, let r be an n-ary
predicate symbol. We add an additional position to r, making it n + 1-ary. Then a vague
Datalog rule is of the form

r(x, s)  ybody(x, y), s = f(p1(z1), . . . , pn(zn))

where
1. x are the n distinguished variables;
2. s is the score variable, taking values in [0, 1], and r is functional on s;

2 http://www.w3.org/TR/rfs-schema/

A. Ragone et al.

(a)

(b)

(c)

(d)

Fig. 1. (a) Trapezoidal function; (b) Triangular function; (c) L-function; (d) R-function

3. y are so-called non-distinguished variables and are distinct from the variables in x;
4. body(x, y) is a conjunction of Datalog atoms;
5. zi are tuples of constants or variables in x or y;
6. pi is an ni-ary fuzzy predicate assigning to each ni-ary tuple ci as score pi(ci) 
7. f is a scoring function f : [0, 1]n  [0, 1], which combines the scores of the n
fuzzy predicates pi into and overall query score to be assigned to the score variable
s. We assume that f is monotone, i.e., , for each v, v  [0, 1]n such that v  v
,
f(v)  f(v) holds, where (v1, . . . , vn)  (v

i for all i; we
assume that the computational cost of f and all fuzzy predicates pi is bounded by a
constant.

n) iff vi  v
?

?

?
[0, 1];
?

?

?
1, . . . , v

We call s = f(p1(z1), . . . , pn(zn)) a scoring atom. For instance,
CheapCar(x, p, s)  N ewCar(x), hasP rice(x, p),
CheapCar(x, p, s)  SecondHandCar(x), hasP rice(x, p),

s = max(0, 1  p/15000)
s = max(0, 1  p/7500)

are vague Datalog rules that can be used to look for cheap cars, assigning to each car
a score depending on its price. If the price of a new car is above 15,000e the car
is not considered as a cheap one, while the scoring function is increased as the price
lowers. Hence, it is quite natural that if we are looking for cheap cars one wants that
the retrieved cars are sorted in decreasing order with respect to its score, i.e., degree of
cheapness. Furthermore, as the database may contain thousands of tuples, one usually
wants to retrieve just the top-k ranked ones.

Concerning fuzzy predicates involved in scoring atoms, we recall that in fuzzy set
theory and practice there are many membership functions for fuzzy sets membership
specification. However, the trapezoidal trz(x; k1, k2, a, b, c, d), the triangular tri(x;
k1, k2, a, b, c), the L-function (left shoulder function) LS(x; k1, k2, a, b) and the R-
function (right shoulder function) RS(x; k1, k2, a, b) are simple, yet most frequently
used to specify membership degrees (see Figure 1) 3.

From a semantics point of view (see [22]), we have to take into account the additional
Informally a vague Datalog rule is interpreted in an interpretation I as the set r

scoring atom s = f(p1(z1), . . . , pn(zn)).
of
tuples c, v, such that when we substitute the variables x and s with the constants c
3 k1, k2 is the domain of the functions.
?

?

?
and the score value v  [0, 1], the formula ybody(x, y), s = f(p1(z1), . . . , pn(zn))
evaluates to true in I.
Due to the existential quantification y, for a fixed c, there may be many substitutions c
for y and, thus, we may have many possible scores for the tuple c. Among all
these scores for c, we select the highest one, i.e., the sup.
?

?

?
Now, let cc

xys = {x/c, y/c

v

In case that the atom r(x, s) is the head of multiple rules, for each tuple c there may
be a score vi computed by each of these rules. In that case, we assume that the overall
score for c is the maximum among the scores vi.
, s/v} be a substitution of the variables x, y and s
and score value v  [0, 1]. Let (x, y, s) be body(x, y), s =
with the tuples c, c

f(p1(z1), . . . , pn(zn)). With (x, y, s)cc
xys we denote the ground formula obtained

by applying the substitution cc
xys evaluates to true in I, i.e., all ground atoms and the grounded scoring atom occurring in

(x, y, s)cc
of a set of rules with same head r = {r1, . . . , rn} in I is

We say that an interpretation I is a model of (x, y, s)cc

xys are true. We will write I |= (x, y, s)cc

Then, the interpretation rI
?

?

?
xys iff (x, y, s)cc

v

xys to (x, y, s).

v

v
?

?

?
v

xys in this case.

v
?

?

?
v

r

= {c, v | v = max(v1, . . . , vn), vi = supc{v

 | I |= i(x, y, s)cc

xys }} ,

v
?

?

?
(1)

Note that some tuples c may not have a score in I and, thus, c, v  rI

where each rule ri  r is of the form r(x, s)  yi(x, y, s), sup is undefined, and
max(v1, . . . , vn) is undefined iff all its arguments are undefined.
for no
v  [0, 1]. Alternatively we may define sup = 0 and, thus, all tuples c have a score in
for some v  [0, 1]. We use the former formulation to distinguish
I, i.e., c, v  rI
the case where a tuple c is retrieved, though the score is 0, from the tuples which do not
satisfy the query and, thus, are not retrieved. Finally, for all c and for all v  [0, 1], we
say that I is a model of r(c, v) (denoted I |= r(c, v)) iff c, v  rI
We say that a vague knowledge base K = F,O,P entails q(c, v), written K |=
q(c, v), iff for all models I of K, I |= q(c, v) holds.
Linking Facts component F, DL component O and LP component P with each
other in K we have that:
 Atoms, representing unary predicates, and predicates occurring in O may appear in
rules in P.
 Predicates occurring in F do not occur in the head of rules in P  essentially, we do
not allow that the fact predicates occurring in F can be redefined by P.

.

2.1 Top-k Retrieval

The basic inference services that concerns us is the top-k retrieval problem, where this
latter is defined as:
Top-k retrieval: Given a vague knowledge base K = F,O,P, retrieve the top-k
ranked tuples c, v that instantiate the query q and rank them in decreasing order w.r.t.
the score v, i.e., find the top-k ranked tuples of the answer set of q, denoted

ansk(K, q) = Topk

{c, v | K |= q(c, v)} .

A. Ragone et al.

For instance,

q(x, p, s)  CheapCar(x, p, s)

is a query asking for cheap cars. The top-k ranked cars, according to the score (that
depends on their price), is obtained by ansk(K, q).

From a reasoning point of view, [23] shows a that the top-k problem for DL-Lite
knowledge bases can be solved in LogSpace data complexity. The result holds also for
the top-k problem in DLR-Lite, using the results described in [5]. On the other hand,
[22] shows that the top-k problem for vague Datalog can also be solved in LogSpace
data complexity, if the set of vague Datalog rules is not recursive. Both solutions rely
on a query rewriting method which is conceptually based on the same idea as for [5]. In
fact, it can be shown that for a vague knowledge base K = F,O,P, where P is not
recursive, the top-k problem can be solved in LogSpace data complexity. Essentially,
we combine [22] and [23] to rewrite a query into a set R of new queries and then we
apply relational top-k database technology (see, e.g., [14]) to solve the queries in R.

3 Matchmaking Scenario

In this section we outline the matchmaking scenario and show how to model it as a top-
k retrieval problem over a vague knowledge base K. Without loss of generality, in the
examples we refer to an automobile marketplace, and motivate our work in this domain.
In such domain features as look, comfort, optionals, type have to be modeled, as well as
numerical features as price, warranty or delivery time. In fact, based on these features
both the buyer is able to formulate her request and the seller to describe the good to
be sold i.e., a buyer can specify conditional preferences, such as If it is a luxury car,
then it has to be provided with leather seats or I want a cheap car, yet if the car has
an alarm system Im ready to pay up to 18,000 e, conversely the seller can offer a
compact car with 4 years warranty or 12,0000 km warranty. Constraints can involve
only numerical features,or non numerical ones, as well as both of them.

Hard and Soft Constraints. In a typical e-marketplace scenario, the issues within both
the buyers request and the sellers offer can be split into strict requirements and prefer-
ences. Strict requirements represent what the buyer and the seller want to be necessarily
satisfied in order to accept the final agreement  in our framework we call strict requirements hard constraints. Preferences denote issues they are willing to negotiate on  this
is what we call soft constraints. Hence, the matchmaker has to be able to handle both
hard and soft specifications of both the buyer and the seller. Let us now introduce an
example request, we will use to explain some aspects of our approach:

Example 2. Suppose to have a buyers request like I want a passenger car black or
gray. Preferably I would like to pay less than 14,000 e furthermore Im willing to pay
up to 17,000 e if warranty is greater or equal than 100000 km. . In this example we
identify:

Hard Constraints. Body Type: Passenger car; Color: Black or Grey.
Soft Constraints. Price:  14, 000; Warranty-Price: if Warranty  100,000 then

Price  17,000 e.
?

?

?
Utility. Given a request and several supplies, in the final agreement, both buyers and
sellers hard constraints have to be satisfied. Nevertheless, how should the matchmaker
find and rank the most suitable or promising agreements to be proposed to both par-
ties? In the ranking process, soft constraints are key information the matchmaker should
use to evaluate the match degree. The final agreement is computed in order to maximize
both buyers and sellers preferences satisfaction. For instance, w.r.t. Example 2 suppose
to have three supplies4:

= Body Type: Compact car; Color: Grey; Price: 16,000 e; Warranty: 200,000 km.

= Body Type: Passenger Car; Color: Black; Price: 13,000 e; Warranty: 50,000 km.

= Body Type: Van; Color: Brown; Price: 19,000 e.
Comparing these supplies with buyers request we note that 




?

?

?
will be discarded

we have
satisfies the preference 2 = {Warranty-Price: if Warranty  100,000 then
the preference 1 = {Price:  14,000}. Now the question is:

because its hard constraints are in conflict with the buyers one. For 
that: 
Price  17,000 e}; 
how to evaluate the best one?

and 
?

?

?
In order to provide an answer to such a question, we take into account utility values assigned by the buyer and representing the preference relevance to sub-parts of
soft constraints. In this case we assume utility values  u(1) and u(2)  both for
1 and 2. 5 Notice that actually the same holds from the sellers side. In a P2P e-
marketplace the seller may express his preferences  soft constraints e.g., on selling
price, warranty, delivery time  with corresponding utilities u(j), as well as his hard
constraints (e.g., color, model, engine fuel, etc.). The only constraint on utility values is
that both sellers and buyers ones are normalized to 1 to eliminate outliers, and make
them comparable [12].
?

?

?
u(i) = 1 ,

u(j) = 1

(2)

Since we assume utilities on preferences as additive, here we can write the global utility
of the buyer u and of the seller u as just a sum of the utilities of preferences satisfied in the agreement. Let si and sj be a score representing the degree of preference
satisfaction, then the global utility will be:

u =
?

?

?
si  u(i) , u =
?

?

?
sj  u(j)

(3)

Matchmaking Steps. Now we can outline the steps of the matchmaking process:

1: Every time a seller enters the marketplace, he proposes his supply expressing both
hard and soft constraints (preferences). Eventually, for each preference j (if any) he
expresses the corresponding utilities u(j).
2: Similarly the buyer who enters the marketplace will express hard and soft constraints
as well as the utility u(i).
4 Without loss of generality, for the sake of simplicity in this example we consider supplies

where only hard constraints have been set.

5 It is not in the scope of this paper to investigate on how to compute u(1) and u(2); we
might assume, without loss of generality, they are determined in advance by means of either
direct assignment methods (Ordering, Simple Assessing or Ratio Comparison) or pairwise
comparison methods (like AHP and Geometric Mean) [20].

A. Ragone et al.

3: Based on buyers and sellers specifications, the matchmaker returns a ranked list of
agreements such that: [a] they satisfy both the hard constraints in the request and conversely their hard constraints are satisfied by the request; [b] the rank is evaluated taking
into account preferences and utility functions u and u as defined by equations (3).

In a P2P e-marketplace, the aim is to maximize both buyers and sellers utilities in
the final agreement, so the matchmaker has to propose agreements mutually beneficial
for both of them. Such agreements are computed considering the higher values of u
and u utilities product [18].

4 Matchmaking with Vague Knowledge Bases

E-Marketplaces are typical systems where the notion of fuzziness is often involved.
It is usual to find, among others, concepts like Cheap or Expensive. Similarly, numerical variables involved in a commercial transaction expose a fuzzy behavior. For
instance, suppose to have a buyer looking for a car provided with a warranty greater
than 100,000 kilometers and a supplier selling his car with a 80,000 kilometers war-
ranty. If the buyers warranty specification is modeled as preference, we can not say
they do not match at all. Instead we can say they match with a certain degree.

Also notice that in both cases  conceptual and numerical information  the fuzziness is: (1) strongly dependent from the user point of view. The idea of cheapness
changes moving from a user to another one; (2) allowed only in soft constraints. If the
user expresses the willingness of selling a car with 80,000 kilometers warranty within
hard constraints, it means that he does not want to negotiate on it at all.
A logical language able to allow the user to express also her fuzzy soft constraints
would be then a good choice to model matchmaking. Given a DLR-Lite ontology O
and a set of facts F we model a vague knowledge base Kmatch = F,O,P for matchmaking in e-marketplaces where:
 P represents users (both buyer and seller) soft constraints. In Ps rules, also roles

and concepts form O can be used.

In this case, F represents the tuples of the relational database storing P2P advertise-
ments. Notice that since we model a P2P marketplace, then advertisements can be either
supplies or demands, depending on the searcher point of view. The former are used in
case a buyer enters the marketplace the latter in case a seller decides to find promising
requests.
To represent requester requirements in a vague knowledge base setting, we model
hard constraints as a conceptual query over O and soft constraints as a query over a
vague Datalog program P.

Hereafter we will use the following notation:

hard constraints =  (x, y) , buyer
s strict requirements

s strict requirements
soft constraints =  i(x, y, s) or i(x, s) , buyer

j(x, y, s) or j(x, s) , seller

(x, y) , seller
?

?

?
s pref erences

s pref erences

x is a single variable. It is usually instantiated with the key value of a database tuple;
?

?

?
y (if present) will be instantiated by numerical values. It is used whenever an agree-

ment on numerical variables (price, km/years warranty, etc.) has to be reached;

s is the score variable as defined in Section 2 [22]. It represents the score associated to

fuzzy predicates involved in the body of the rules;

Notice that since a score is associated to each fuzzy predicate, we can compute the
global utility based on the two utility functions in Section 3. Furthermore, the two
queries  and  model the minimal requirements the buyer and the seller want to be
satisfied in order to accept the final agreement. Notice that, if seller and buyer set hard
constraints in conflict with each other, the corresponding supply will not be retrieved.
Soft constraints are modeled via Datalog predicates i for the buyer and j for the
seller, where each of them represents a sub-part of the buyer/seller preferences.

The use of x, y and s should be clearer looking at how buyers request in Example 2

is formalized:

A(x)  P assengerCars(x)
B (x)  hasColor(x, y), Gray(y)
B (x)  hasColor(x, y), Black(y)
(x)  A(x), B (x)

1(x, p, s)  hasP rice(x, p),

LS(0, 100000, 14000, 16000, p, s)

2(x, p, kmw, s)  KmW arranty(x, kmw), hasP rice(x, p)
RS(0, 400000, 80000, 100000, kmw, s1),
LS(0, 100000, 17000, 19000, p, s2),
s = max(1  s1, s2)

With respect to the previous encoding we notice that defining 1 and 2 here we can
use two different L-functions to specify membership degrees for the variable p.

5 Top-k Retrieval for Matchmaking in Vague Knowledge Bases
Given a DLR-Lite ontology O and a set of facts F in a relational database, we can detail
the matchmaking framework in a vague knowledge base Kmatch = F,O,P. In order
to formulate a query and rank all the retrieved results, what is still missing is how to put
together both buyers and sellers requirements. Then:

1. for each buyers preference i, write the corresponding rule in vague Datalog where
the head contains the predicate i(x, y, s) as shown in Section 4; add the rule to P;
set the utility value u(i) as shown in Section 3; The same is for the seller where the
head of each rule is the predicate j(x, y, s) and for each of them utility values are
u(j)

2. add to P the rules:

Buyer(x, y, u)  1(x, y1, s1), 2(x, y2, s2), . . . , u = u(1)  s1 + u(2)  s2 + . . .
Seller(x, y, u)  1(x, y1, s1), 2(x, y2, s2), . . . , u = u(1)  s1 + u(2)  s2 + . . .
where for each variable in y in the head of one of the two previous rules, the same
variable occurs in at least one of the arrays of the corresponding body: y1, y2, . . .;
?

?

?
3. encode buyers hard constraints requirements as a conceptual query over O. Rewrite
the query as a conjunctive query where the query is denoted with (x, y). The same
is for the seller and his hard constraints (x, y);

4. solve the Top-k retrieval problem:
?

?

?
, u
?

?

?
, u

 |P |= M atch(x, y

{x, y, u | y, u  Top1{x, y

ansk(P, M atch) = Topk
where M atch is the conjunctive query
M atch(x, y, u)  (x, y), Buyer(x, y, u), (x, y), Seller(x, y, u), u = u  u
and for each variable in the array y, the same variable occurs in y, y, y or y.
Basically, for each key value x of the database, we compute the best match y, u for it,
i.e., y, u  Top1
)}, and then rank the top-k key
values.

 | P |= M atch(x, y

{x, y

)}}.

, u

, u

Notice that the rank is computed considering the product of buyers and sellers utilities as stated at the end of Section 3 in order to reach an agreement appealing both for
the buyer and for the seller.

6 An Illustrative Example

Let us better clarify the approach with the aid of a tiny example. In Table 1 two possible
offers stored in an e-marketplace database are presented. We call CarT able the relation
representing Table 1.

Table 1. The CarTable relation with a sample set of offers

ALFA 156

PRICE DISCOUNT KM COLOR AIRBAG INTERIOR TYPE AIR COND ENGINE FUEL
?

?

?
1812 FORD FOCUS StationVagon 13000

25000 Black
20000 Gray

LeatherSeats
LeatherSeats

Diesel
Gasoline

Sedan

20%
20%
?

?

?
Based both on these information and some specific domain knowledge, we will write
the corresponding vague knowledge baseKmatch as explained is Section 4and Section 5.
In Figure 3 tuples related to the relation CarT able are represented together with a DLRLite ontology O extending the one presented in Example 1. Auxiliary rules in Figure 2
are introduced and used only for the sake of clarity and conciseness.
Now, suppose to have the following buyers request:

[Hard Constraint] () I want a sedan or a station wagon.
[Soft Constraint] (1) I would like air conditioning if the car has leather seats. (2)
Preferably I would like to pay less than 11,000 e. (3) The car should have less than
15,000 km.
?

?

?
hasP rice(x, p)  hasP ossibleCarP rice(x, p)

Kilometers(x1, x6),  CarT able(x1, . . . , x11)
CatalogueP rice(x1, x4),  CarT able(x1, . . . , x11)

MinimalP rice(x1 , y),  CarT able(x1, . . . , x11), y = x4  x4  x5

LS(k1, k2, a, b, p, 1)  k1  p  a
LS(k1, k2, a, b, p, 0)  b  p  k2
LS(k1, k2, a, b, p, s)  a < p < b, s = (b  p)/(b  a)
RS(k1, k2, a, b, p, 0)  k1  p  a
RS(k1, k2, a, b, p, 1)  b  p  k2
RS(k1, k2, a, b, p, s)  a < p < b, s = (p  a)/(b  a)

Fig. 2. Auxiliary rules

CarT able(34, ALFA 156, 2002, 12,000, 20%, 25,000, Black, 1, LeatherSeats, 0, Diesel)

CarT able(1812, FORD FOCUS, 2001, 13,000, 20%, 20000, Gray, 1, LeatherSeats, 1, Gasoline)
hasP ossibleP rice(34, p), p  {12000, 11900, 11800, . . . , 9700, 9600}
hasP ossibleP rice(1812, p), p  {13000, 12900, 12800, . . . , 10500, 10400}

1 : CarT able  Cars
Sedan  StationW agon  Cars
9 : CarT able  Seats
Mazda  Alf aRomeo  F ord  CarMake
LeatherSeats  V elvetSeats  Seats

(disjoint Mazda, Alf aRomeo, F ord)
(disjoint Sedan, StationW agon)
(disjoint AirConditioning, N oAirConditioning)
(disjoint LeatherSeats, V elvetSeats)
. . .

Fig. 3. A part of the vague knowledge base Kmatch used in the example

[Preferences Utilities] u(1) = 0.05; u(2) = 0.5; u(3) = 0.45
Then we add to the vague Datalog program P in Kmatch the rules:

A(x)  Sedan(x)
A(x)  StationW agon(x)
(x)  A(x)

1(x, 1)  N oLeatherSeats(x)
1(x, 1)  LeatherSeats(x), AirConditioning(x)
1(x, 0)  LeatherSeats(x), N oAirConditioning(x)

2(x, p, s)  hasP rice(x, p),

LS(0, 100000, 11000, 13000, p, s)

3(x, s)  Kilometers(x, k),

Buyer(x, p, u )  1(x, s1), 2(x, p, s2), 3(x, s3),

LS(0, 400000, 15000, 20000, k, s)

u = 0.05  s1 + 0.5  s2 + 0.45  s3

Since we are in a P2P e-marketplace, also the seller can express hard and soft con-
straints. Looking at the information modeled in Table 1 we see that a soft constraint is
expressed on price: the seller prefers to sell the car at the catalogue price, furthermore
he may apply a discount. In this case also a constraint on price is set; in fact, he does not
want to go down such defined discount (hard constraint). Without loss of generality, for
the sake of clarity in this example we consider the same hard and soft constraints for all

A. Ragone et al.

the sellers within the e-marketplace. Sellers requirements are then encoded in Kmatch
as:

(x, p)  hasP rice(x, p), CatalogueP rice(x, catP ),

MinimalP rice(x, minP ), minP  p  catP

1(x, p, s)  hasP rice(x, p), CatalogueP rice(x, catP ),

MinimalP rice(x, minP ), minP  p  catP,
RS(0, 100000, minP, catP, p, s)

Seller(x, p, u )  (x, p), 1(x, p, s1), u = s1

Notice that, in this particular case, the specification of u(1) is not necessary because
of equation (3).

According to the encoding in Section 5 the query is:
M atch(x, p, u)  (x), Buyer(x, p, u), (x, p), Seller(x, p, u), u = u  u

Solving ans2(Kmatch, M atch) retrieval problem with respect to Kmatch defined in this
example, the ranked list of agreements is:

u

x
p

11300 0.3010
1812 11800 0.1885

the agreement between ALFA 156 and the request

Then,
FORD FOCUS.

is ranked better then

7 Related Work

Recently, the problem of matchmaking has been investigated under different perspectives and many approaches have been proposed. An initial approach to matchmaking
can be dated back to vague query answering [17] where the need to go beyond pure
relational databases was addressed using weights attributed to several search variables.
More recently similar approaches have been proposed extending SQL with preference
clauses, in order to allow relaxed queries in structured databases [11] where only buyers
preferences are taken into account while retrieving promising supplies: no agreement is
proposed as a result of the query process. In our framework we model the matchmaking process in a P2P marketplace, taking into account not only the buyers preferences,
but also the sellers ones, finding the most promising agreements w.r.t. preferences of
them both. Classified-ads matchmaking, at a syntactic level, was proposed in [21] and
[25] to perform a matchmaking between semi-structured descriptions. Approaches to
matchmaking using LOOM as description language can be found, among others, in [2]
and [9]. Due to the growing interest in the Semantic Web initiative many approaches
to matchmaking have been proposed in the framework of DAML+OIL, OWL and their
grounding logical languages in particular Description Logics (DL). Matchmaking as
satisfiability of concept conjunction in DLs was first proposed in [10]. In the framework of Retsina Multiagent infrastructure [24], a specific language was defined for
?

?

?
agent advertisement, and matchmaking engine was developed [19], which carries out
the process on five possible match levels. The approach in [19] was later extended
in [15], where two new levels for matching classification were introduced. A similar classification was proposed  in the same venue  in [8], along with properties
that a matchmaker should have in a DL based framework, and algorithms to classify
and semantically rank matches within classes. An initial DL-based approach, adopting
penalty functions ranking, has been proposed in [4], in the framework of dating sys-
tems. An extended matchmaking approach, with negotiable and strict constraints in a
DL framework has been proposed in [7], using both concept contraction and concept
abduction. The need to work in someway with approximation and ranking in DL-based
approaches to matchmaking has also recently led to adopting fuzzy-DLs, as in sMART
[1] or hybrid approaches, as in the OWLS-MX matchmaker [13]. sMART is a semantic
matchmaking portal, based on fuzzy-DLs, able to deal with approximation in the requests description handled by crisp DL-reasoners. Nevertheless in such approaches the
matchmaking process is defined according to buyers perspective. In [16] a language
able to express conditional preferences is proposed to perform a matchmaking in Description Logics. Also in this case nothing is said on how to compute a agreement 
as needed in P2P scenarios. Furthermore, the notion of fuzzy/vague requirements is not
addressed.

8 Conclusion

In this work we propose a semantic matchmaking approach that mixes various knowledge representation technologies to find the most promising agreements in a P2P e-
marketplace. In particular, by exploiting ontologies in DLR-Lite and fuzzy rules we
are able to model both hard constraints and soft constraints, while taking into account
both buyers and sellers preferences and utilities to find matches mutually beneficial
for them both. The information needed for the P2P matchmaking process are modeled
as a vague knowledge base, taking into account domain knowledge, while keeping the
approach effective and scalable. A prototype is currently being implemented to further
validate the approach through large scale experiments.
