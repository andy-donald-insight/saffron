Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

journal homepage: www.elsevier.com/locate/websem

Temporalizing rewritable query languages over knowledge bases
Stefan Borgwardt, Marcel Lippmann, Veronika Thost

Institute of Theoretical Computer Science, Technische Universitat Dresden, 01062 Dresden, Germany

a r t i c l e

i n f o

a b s t r a c t

Ontology-based data access (OBDA) generalizes query answering in relational databases. It allows to query
a database by using the language of an ontology, abstracting from the actual relations of the database.
OBDA can sometimes be realized by compiling the information of the ontology into the query and the
database. The resulting query is then answered using classical database techniques.

In this paper, we consider a temporal version of OBDA. We propose a generic temporal query language that combines linear temporal logic with queries over ontologies. This language is well-suited for
expressing temporal properties of dynamic systems and is useful in context-aware applications that need
to detect specific situations. We show that, if atemporal queries are rewritable in the sense described
above, then the corresponding temporal queries are also rewritable such that we can answer them over
a temporal database. We present three approaches to answering the resulting queries.

 2014 Elsevier B.V. All rights reserved.

Article history:
Received 30 September 2013
Received in revised form
18 November 2014
Accepted 27 November 2014
Available online 8 December 2014

Keywords:
Ontology-based data access
Linear temporal logic
Query answering
Rewritability
Description logic

1. Introduction

Context-aware applications try to detect specific situations
within a changing environment (e.g., a computer system or air
traffic observed by radar) to be able to react accordingly. To gain
information, the environment is observed by sensors (for a computer system, data about its resources is gathered by the operating system), and the results of sensing are stored in a database. A
context-aware application then detects specific predefined situations based on this data (e.g., a high system load) and reacts accordingly (e.g., by increasing the CPU frequency).

In a simple setting, such an application can be realized by using standard database techniques: the sensor information is stored
in a database, and the situations to be recognized are specified as
database queries [1]. However, we cannot assume that the sensors
provide a complete description of the current state of the environ-
ment. Thus, the closed world assumption employed by database
systems (i.e., facts not present in the database are assumed to be
false) is not appropriate since there may be facts of which the truth
is not known. For example, a sensor for specific information might
not be available for a moment or not even exist.

In addition, though a complete specification of the environment
usually does not exist, some knowledge about its behavior is

 Corresponding author.

E-mail addresses: stefborg@tcs.inf.tu-dresden.de (S. Borgwardt),

lippmann@tcs.inf.tu-dresden.de (M. Lippmann), thost@tcs.inf.tu-dresden.de
(V. Thost).

http://dx.doi.org/10.1016/j.websem.2014.11.007
1570-8268/ 2014 Elsevier B.V. All rights reserved.

often available. This background knowledge could be used to
formulate constraints on the behavior of the real environment.
These constraints help formulate queries to detect more complex
situations.

This information (i.e., the sensor data and the background
knowledge) is stored in so-called knowledge bases, which are sometimes called ontologies. A knowledge base consists of a fact base
and a theory, which store the data in a formally well-understood
way. The fact base contains simple facts (e.g., the concrete values
given by sensors), and is interpreted with the open world assump-
tion, i.e., facts not present are assumed to be unknown rather than
false. The theory contains the additional background knowledge
(e.g., general domain knowledge) stored in a symbolic represen-
tation. The situations to be detected are then specified in an appropriate query language. The resulting queries are then evaluated
w.r.t. the information encoded in the knowledge base. This general approach is often called ontology-based data access (OBDA)
[2,3].

However, since the environment is changing, it is often desirable to specify situations that take into account temporal behavior.
In this setting, we model the incoming information as a sequence
of fact bases, one for each moment in time in which the system
has been observed. To recognize situations, we propose to add a
temporal logical component to atemporal queries over knowledge
bases. We use the operators of the temporal logic LTL, which allows
to reason about a linear and discrete flow of time [4]. Usual temporal operators include next ( ), which asserts that a property 
is true at the next point in time, eventually ( ), which requires 
to be satisfied at some point in the future, and always (), which

forces  to be true at all time points in the future. We also use the
corresponding past operators , , and .

Consider, for example, a distributed video platform providing
several services such as uploading, streaming, and transcoding
(i.e., the conversion of video formats). At any given time point, a
fact base for such a system could contain facts like the following,
which describe that there is a server s with an overutilized CPU c,
which executes an uploading service (ULS) p1 and a transcoding
service (TCS) p2, both of which are active:

CPU(c), Overutilized(c), Server(s), hasCPU(s, c),
ULS(p1), executes(s, p1), Active(p1),
TCS(p2), executes(s, p2), Active(p2).

x.Server(x) y.hasCPU(x, y)  Overutilized(y)

The background theory could contain an axiom such as

Overloaded(x),

t1

if t = 0
if t  1

which states that a server having an overutilized CPU is overloaded.
Given the above fact base, we can conclude that s is currently
overloaded.

Since transcoding is very resource-intensive, it is important to
transcode popular videos preemptively in phases of less utilization
instead of on demand in phases of high utilization. However, the
situation can clearly change after a preemptive transcoding service
has been started. For that reason, one may want to detect critical
situations in which a server of the platform has become overloaded
while executing such a service.

TCS(x)  Server(y)  executes(y, x)  0 NLB(y)S t
t :=Active(x)  Overloaded(y)

The temporal query

with


and t  0 therefore asks for a transcoding service x and a server y
that executes it, where x is active and y is overloaded. The second
part of the query requires that NLB(y) has been true for the whole
time since (S) the subquery t was true. In other words, we are
looking for a time point in the past that satisfies t such that all
time points since then satisfy NLB(y), which expresses that y has
not been affected by a load balancing operation in the meantime.
The subquery t again asks for x to be active and y to be overloaded,
and furthermore that there is a time point after the current one
) satisfying t1. We are thus asking for a series of t+1 critical

time points (not necessarily immediately following each other).
We consider the temporal behavior of this example query in more
detail in Sections 5 and 6.

One might argue that, as we are looking at the time line from
the point of view of the current time point, and nothing is known
about the future, it is sufficient to have only past operators like S
or . We also show that in our setting it is indeed always possible
to construct an equivalent query using only past operators (see
Section 5.3). However, the resulting query is not very concise and
it is not easy to see the situation that is to be recognized. Indeed,
for propositional LTL eliminating the past operators from a formula
results in a blowup that is at least exponential and no constructions
of size less than triply exponential are known [5].

1.1. Related work

In this paper, we consider so-called rewritable query languages,
i.e., query languages for which evaluating a query over a knowledge
base can be reduced to answering a rewritten query (in a
different language) over a database induced by the knowledge
base. Such query languages, especially in the context of Description
Logics (DLs) [6], are covered extensively in the literature (see
Example 2.11).

Investigations of temporal query languages based on combinations of query languages and temporal logics such as LTL [4] have
started only quite recently. Yet, a number of very expressive temporal query languages have been proposed [710].

For rewritable query languages, most research focuses on lightweight languages of the DL-Lite family [11]. However, instead of
temporalizing the query language and evaluating the queries over
a global knowledge base, also temporal knowledge bases are exam-
ined, which allow temporal operators to occur inside axioms. These
approaches are based on research about temporalized description
logics (see [12] for a survey). For example, in [13], various lightweight DLs are extended by allowing the temporal operators to interfere with the DL component. Following the ideas of [13], in [14]
a rewritable temporal query language over temporal knowledge
bases in DL-Lite is proposed.

There is also a lot of closely related work in the field of
temporal databases. In [15], for instance, the authors describe a
temporal extension of the SQL query language that can answer
temporal queries over a temporal database. In [1618], an approach is described that reduces the amount of space needed to
evaluate temporal queries by keeping only the relevant data in the
database instead of keeping track of all the information from the
past.

1.2. Our contribution

In this paper, we consider temporal queries over knowledge
bases in a very general setting that allows us to extend many
existing atemporal query languages by temporal operators (cf. Section 3). In Section 4, we show that the reasoning task of temporal
OBDA in this setting can be reduced to answering queries over temporal databases. The main part of the paper is thus concerned with
what we call the temporal database monitoring problem, where a
fixed temporal query is continuously evaluated over a temporal sequence of databases.

We present three approaches to solving this problem. The first
one employs existing temporal database systems using a translation from our temporal query language into a specialized database
query language [15] (cf. Section 5.1). The second approach again
rewrites the query in order to obtain a query without future op-
erators, which then can be answered using an algorithm from [16]
(cf. Section 5.3). The advantage of this algorithm is that the time required to answer the temporal query at the current time point does
not depend on the total running time of the system; this is called
a bounded history encoding in [16]. In Section 6, we propose a new
algorithm that extends the one from [16] in that it also deals with
future operators directly while guaranteeing a bounded history en-
coding. We also discuss different advantages and drawbacks of the
three approaches.

Sometimes it is desired to state that certain facts do not change
over time, i.e., are rigid. In Section 7, we show how our proposed
algorithm can be extended to deal with a limited form of rigidity
in a specific class of queries.

This paper is an extension of [19], where we have considered only the special case of answering temporal queries over
DL-Litecore-ontologies. In contrast to [19], we also show in this paper that our proposed algorithm preserves the bounded history encoding of [16]. Additionally, this paper contains the full proofs of
our results. To improve readability, some of them are presented in
the Appendix.

2. Preliminaries

As mentioned in the introduction, we consider temporal queries
over knowledge bases in a very general setting. This section

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

describes the logical framework for querying atemporal knowledge bases and basic properties of this framework we require for
the rest of the paper. We also give a wealth of examples of concrete
query formalisms from the literature that satisfy our restrictions.

2.1. Logics

Our basic setting is that of function-free first-order languages.
In any such language, we need to assert the truth of ground facts.

1 , . . . , cI

n )  PI.

n0 Nn

Definition 2.1 (Assertion). Let NC be a set of constants, and let
)n0 be a family of sets of n-ary predicate symbols. An asser-
(Nn
tion is an expression of the form P(c1, . . . , cn) for P  Nn

P and
c1, . . . , cn  NC.
An interpretation is a pair I = (I ,I ), where I is a nonempty set (called the domain of I) and I is an interpretation function that assigns to every P  Nn
P an n-ary relation PI  n, and to
every c  NC an element cI  I. Such an interpretation is called
finite if its domain is finite. Two interpretations are isomorphic if
there is a bijective mapping between their domains that preserves
the interpretations of all constants and predicate symbols.
I |= P(c1, . . . , cn), if (cI
To simplify the presentation of our results, we assume in the
P are non-empty and finite,
i.e., we restrict to finitely many symbols that are relevant for some
domain of interest. We further assume that the sets of constants
and predicate symbols are disjoint.

following that the sets NC and

We say that I is a model of an assertion P(c1, . . . , cn), written

By using axioms that are more expressive than simple asser-
tions, more elaborate properties of interpretations can be stated.
In a logical formalism, theories are usually finite sets of axioms. In
the following, we consider a generic logic, which consists of a set
of theories expressible in it, together with a satisfaction relation.
Definition 2.2 (Logic). A logic is a pair (L,|=L), where L is a set of
L-theories and|=L is a satisfaction relation between interpretations
and L-theories, i.e., |=L  I  L, where I denotes the set of
all interpretations. For an interpretation I and an L-theory T , we
write I |=L T if (I, T )  |=L. In this case, we also say that I is a
model of T .

In many concrete logics, there is a basic satisfaction relation for
axioms that is lifted in a natural way to theories. However, some
logics put further restrictions on the shape of their theories apart
from them being a set of axioms. This is the reason why we choose
to define logics as sets of theories rather than sets of axioms.

In the following, we often refer to a logic by its first component L, which is implicitly associated with an entailment relation
|=L. If the logic is clear from the context, we may also write |= instead of |=L, and simply speak of theories.
Definition 2.3 (Knowledge Base). Given a logic L, a knowledge base
over L is a pair K = A, T , where A is a finite set of assertions,
called fact base, and T is an L-theory.
We write I |= A, and say that I is a model of A, if I is a model
of all assertions in the fact base A. A knowledge base K = A, T 
is consistent if there is an interpretation that is a model of both A
and T .

A basic requirement for the logics considered in this paper is that
consistency should be decidable. The consistency check is the first
step of any reasoning algorithm, as an inconsistent knowledge base
makes most reasoning problems trivial.

Example 2.4. The main instances of our framework we will
describe in more detail are based on Description Logics (DLs) [6].
In these formalisms, the language is restricted to unary and binary
predicates, called concept names and role names, respectively. Socalled concept constructors are used to build more expressive unary
predicates, called concepts, from these basic names. Similarly, more
complex roles, i.e., binary predicates, can be built.
In this setting, theories are made up from axioms like general
concept inclusions (GCIs) of the form C  D, which restrict all
models to interpret C by a subset of the interpretation of D, and
similar axioms between roles. Sometimes additional conditions
are imposed on the left-hand side or the right-hand side of such
inclusions. In DLs, such theories are usually called TBoxes or
ontologies. Often, the axioms of a DL are expressible as sentences
of first-order logic.
The expressivity of DLs ranges from light-weight DLs such
as members of the DL-Lite family [20] and EL [21] to the very
expressive SROIQ, which forms the basis for the standardized
Semantic Web ontology language OWL 2 [22]. However, a major
criterion in their design is that consistency of knowledge bases
should be decidable.

For the purposes of this paper, we are particularly interested
in so-called Horn description logics. They are distinguished by
an inability to express disjunction, which leads to the interesting
property that knowledge bases can often be characterized in terms
of a single canonical model (see Definition 2.8). To this family
belong many members of the DL-Lite family, extensions of EL, and
syntactically restricted forms of more expressive DLs like HornSHIQ [23,24].
A different logical formalism is Datalog [1], which is based on
rules of the form Q  P1    Pm, where each atom is of
the form P(z1, . . . , zn) for P  Nn
P and variables or constants zi,
with the restriction that every variable that occurs in the head Q
must also occur in the body P1    Pm. Thus, rules without
body are simply assertions. Theories are finite sets of such rules and
are called Datalog programs. For the satisfaction relation, the usual
first-order reading of the rules is employed, where all variables
are universally quantified. An interesting property of Datalog is
that every program P has a least Herbrand model, which contains
exactly those assertions that hold in all models of P (similar to
the canonical models of knowledge bases in Horn-DLs). Since we
do not consider function symbols, the Herbrand domain is NC,
and thus this least Herbrand model is finite. There is also linear
Datalog, where the body of any rule may contain at most one
atom that also occurs in the head of a rule. Theories of logics in
the Datalog family [25] consist of tuple-generating dependencies
that generalize Datalog rules in that they allow new (existentially
quantified) variables to occur in the head.

2.2. Queries

We stay just as generic in the description of query languages

over L.
Definition 2.5 (Query Language). Let NV be a set of variables,
disjoint from NC and Nn
P. A variable assignment is a mapping of the
form a: {x1, . . . , xn}  NC with x1, . . . , xn  NV.
A query language is a triple (Q, FVar,|=Q), where Q is a set of
Q-queries, FVar: Q  2NV maps every Q-query to the finite set
of its free variables, and |=Q is a satisfaction relation, denoted as
I |=Q a( ) for an interpretation I, a Q-query , and a variable
assignment a: FVar( )  NC,1 such that

1 We do not consider variable assignments that do not map exactly the free
variables of the query.

(i) for all   Q, a1, a2: {x1, . . . , xn}  NC, and interpretations I
with a1(xi)I = a2(xi)I , 1  i  n, we have I |=Q a1( ) iff
I |=Q a2( ); and
(ii) for all   Q, a: {x1, . . . , xn}  NC, and isomorphic
interpretations I1, I2, we have I1 |=Q a( ) iff I2 |=Q a( ).
If I |=Q a( ), we say that a is an answer to  w.r.t. I.
Conditions (i) and (ii) above are reasonable assumptions for
query languages that express that satisfaction does not depend
on the names of domain elements, only on their interpretation.
We include them in this definition since they are needed in the
proof of Theorems 4.1 and 7.5 to unify the domains of several
interpretations, and at the end of Section 4 to simplify the
presentation of the temporal database monitoring problem.
We adopt the same conventions as for logics and, e.g., refer to
query languages only by their first component and write |= if Q is
clear from the context. We further denote by Ans( , I)  NFVar( )
the set of all answers to a query  w.r.t. an interpretation I. For
convenience, if there is an implicit total order x1 <  < xn on
the elements of FVar( ) = {x1, . . . , xn}, we sometimes denote
variable assignments a: {x1, . . . , xn}  NC by tuples of the form
(a(x1), . . . , a(xn)).
We now lift the semantics of queries to deal with knowledge
bases. The main notion is that of certain answers to a query, which
are variable assignments that satisfy the query in all models of a
given knowledge base.
Definition 2.6 (Certain Answer). Let L be a logic, Q a query lan-
guage, K a knowledge base, and  a query. A variable assignment
a: FVar( )  NC is called a certain answer to  w.r.t. K, written
K |= a( ), if for every model I of K, it holds that a is an answer to
 w.r.t. I.
Similar to before, we denote by Cert( , K)  NFVar( )
the set of
all certain answers to a query  w.r.t. a knowledge base K. The
problem of computing Cert( , K) from  and K is called query
answering.

A special situation arises when the considered queries have no
free variables. Queries of this form are called Boolean queries since
the set Cert( , K) can only be empty or contain the empty variable
assignment as its only element. In the latter case, we say that 
is entailed by K, and write K |= , if Cert( , K) is non-empty.
Similarly, we write I |=  for an interpretation I if Ans( , I) is
non-empty.

Example 2.7. The simplest query language arises from considering
all assertions as Boolean queries, and taking |=Q to be |= (ignoring
the variable assignments). The entailment of an assertion by a
knowledge base is then equivalent to the usual definition.
Similarly, we can consider the Boolean query language Q := L
with |=Q given by |=L,
i.e., we can ask for the entailment
of theories. In the context of Description Logics, an important
such query language is that of subsumptions which ask for the
entailment of single GCIs C  D, i.e., whether the concept C is a
subconcept of D in all models of a given knowledge base.
One step up from assertion queries are so-called instance queries
(IQs) of the form P(z1, . . . , zn), where P  Nn
P and each zi may
be either a constant or a variable. The free variables of this query
are simply the variables among z1, . . . , zn. To compute Cert( , K),
we have to determine all variable assignments that certainly (in
all models of K) make the assertion true when replacing the free
variables accordingly.

For relational databases, an important class of queries are
conjunctive queries (CQs) (also called select-project-join queries) of
the form y1, . . . , ym., where y1, . . . , ym  NV and  is a
conjunction of instance queries [1]. As usual, the free variables of

this CQ are those occurring in it, except y1, . . . , ym. In contrast
to the free variables, which range only over the constants, the
quantified variables y1, . . . , ym range over the whole domain of
a given interpretation. The semantics of CQs is thus obtained by
viewing them as first-order sentences in the obvious way.
In the database setting, one is concerned with computing
Ans( , I) for a conjunctive query  and a finite interpretation I,
which can be seen as a relational database. This can be done by
asking, e.g., an SQL query over this database. The more general
problem of computing certain answers to conjunctive queries
w.r.t. a knowledge base has been investigated for many logical
formalisms, in particular DLs [2629]. To solve it, sometimes
the so-called first-order-rewritability of CQs w.r.t. the logic L is
exploited (see Definition 2.10).

In this approach, so-called first-order queries are used to capture
the answers of a CQ w.r.t. a knowledge base. These queries
allow arbitrary nesting of all usual constructs of first-order logic,
including negation and universal quantification. The essential part
of the reduction is that these first-order queries only have to be
answered over finite interpretations, i.e., databases. In this setting,
first-order-rewritability is actually equivalent to rewritability
into much simpler unions (disjunctions) of conjunctive queries
(UCQs) [30]. Another class of interest between UCQs and arbitrary
first-order queries are positive existential queries (PEQs) of the form
y1, . . . , ym., where  is a positive Boolean combination of
instance queries (i.e., using conjunction and disjunction, but no
negation).

In the context of Description Logics, where the predicates are
restricted to be at most binary, conjunctive regular path queries
(CRPQs) generalize conjunctive queries in a different direction
by allowing conjuncts of the form L(x, y), where L is a regular
expression over the binary predicate symbols [31,32].
In an
interpretation over this signature, which is essentially a labeled
graph, these conjuncts express the existence of a path from x
to y such that the concatenation of its edge labels belongs to the
language generated by L.
We will also consider Datalog queries (P, P), where P is a Datalog program and P is the goal predicate to be answered [1]. The free
variables are x1, . . . , xn, where n is the arity of P. The program P
uses auxiliary predicates that are local to the query and used to
evaluate it. Only auxiliary predicates are allowed to occur in the
heads of rules, and the goal predicate P must be an auxiliary predi-
cate. A variable assignment a is an answer to such a query w.r.t. an
interpretation I if all extensions of I to the auxiliary predicates
that satisfy P also satisfy P(a(x1), . . . , a(xn)). This is equivalent to
the containment of this assertion in the least Herbrand model of
facts(I), P, where facts(I) denotes the (finite) set of all assertions that I is a model of.
In particular, every UCQ can be formulated as a Datalog query
in which the goal predicate is the only auxiliary predicate, which
furthermore does not occur in the body of any rule. Similarly, PEQs
correspond to Datalog queries with nonrecursive programs [1].
In this paper, we assume that every query language contains a
special Boolean query true, which holds in all interpretations.
Likewise, we assume the presence of a Boolean query falsethat
does not hold in any interpretation. It is straightforward to add
these to a query language without affecting any of the properties
or constructions described in the following.

2.3. Canonical models and rewritability

We now come to the first important restriction that we make

on the logics and query languages we consider.
Definition 2.8 (Canonical Model). A logic L has the canonical model
property w.r.t. a query language Q if every consistent knowledge

base K has a countably infinite canonical model IK, which is a
model of K with the property that for all queries , we have
Cert( , K) = Ans( , IK).
Canonical models are sometimes called universal models.

The restriction to countably infinite canonical models is a
technical one, which ensures that all these models have the same
cardinality. This is not a great restriction since canonical models
are often explicitly constructed in a countable way. However, if the
canonical model is finite, one can usually add countably infinitely
many copies of it without changing the answers. We exploit this
to unify the domains of different interpretations for Theorems 4.1
and 7.5.
Example 2.9. The following table lists several DLs L and query
languages Q that have the canonical model property. The canonical
model is usually obtained by applying the axioms of the knowledge
base K = A, T  as completion rules to the facts in A in order to
obtain a model of K (this is also called chase in database theory).
In the case of [33,34], it is constructed from the least Herbrand
model of a Datalog program that depends on A and T .
The result from [34] also holds for Horn-SHIQ w.r.t. CQs that

use only simple roles (i.e., roles without transitive subroles).

EL++
DL-LiteR/F

ELIf
ELHdr
DL-LiteN
horn
DL-Litehorn

Horn-ALCHIQ
Horn-ALCHOIQDisj

Self

subs.

Shown in
[35]
[26, Theorem 29]
[36, Lemma 1]
[37, Lemma 5]
[28, Proposition 4]
[38, Theorem 4]
[39, Theorem 3]
[33, Lemma 10]
[34, Theorem 3], [24]
[40, Theorem 2]

For computing the set of certain answers to a query, an important
approach is to rewrite the query such that it can be evaluated
over a single finite interpretation,
i.e., a database. Generally,
the interpretation and the rewritten query together contain the
information of the theory and the original query, whereas the
knowledge from the fact base only influences the definition of the
interpretation.

This is called the combined approach to rewriting [38,39], in
contrast to the original idea [20,26], where the finite interpretation
is obtained by simply viewing the fact base under the closed
world assumption. There, all necessary information of the theory
and the original query is encoded in the rewritten query. With
both approaches, the rewritten query usually belongs to a more
expressive query language.
Definition 2.10 (Rewritable). Let L be a logic and Q1, Q2 be query
languages. We say that Q1-queries are Q2-rewritable w.r.t. L if one
can compute
 for every theory T , a finite set T that contains NC,
 for every consistent knowledge base K, a finite interpretation DK over the domain T such that cDK = c holds for all
c  NC, and
 for every Q1-query  and theory T , a Q2-query T such that
FVar( ) = FVar(T ),
such that for all consistent knowledge bases K = A, T  and Q1queries , we have Cert( , K) = Ans(T , DK).
To summarize, Q2-rewritability means that finding certain answers to Q1-queries w.r.t. L can be reduced to finding (ordinary)
answers to Q2-queries over finite interpretations, which can be

seen as relational databases. This brings us to our last requirement,
namely that the set of answers to a Q2-query w.r.t. a finite interpretation should be computable. In case of Q2-rewritability of
Q1-queries w.r.t. L, this implies that the set of answers to a
Q1-query w.r.t. a knowledge base is also computable.
In [20], where first-order-rewritability was introduced for
conjunctive queries in DL-Lite, the rewritten first-order query T
was called the perfect reformulation of  (w.r.t. T ). The term
perfect refers to the fact that this query can then be used to
answer the original query over any fact base. Recall that first-
order-rewritability is equivalent to UCQ-rewritability, but firstorder queries can be more concise than UCQs.

The above definition is an extension of this original version
of rewritability that captures more results that have been shown
since then. It contains some technical restrictions that are needed
to lift this to the temporal setting (see Theorem 4.1), but which are
satisfied by all instances described in Example 2.11 below. Most
importantly, the construction of DK is independent of a concrete
query, and likewise, T does not depend on a fact base.
It is clear that finiteness of DK is not sufficient in prac-
tice, where one would additionally like to have small interpretations DK over which Q2-queries can be evaluated efficiently.
Indeed, many rewritability results have subsequently been refined
to improve this behavior. However, we are not so much interested in the theoretical complexity of answering queries as our
approach to temporal queries will anyway always need to compute the whole set Ans(T , DK), which is already exponential
in the cardinality of FVar( ). For details, see the discussion after
Lemma 6.10.

Example 2.11. Below, we list several rewritability results for
different instances of L, Q1, and Q2, where FO= denotes first-order
queries with equality and UCQ+ a combination of a UCQ with a
linear Datalog program.
For the logics of the DL-Lite and EL families, the finite interpretation DK is usually obtained by viewing the fact base under the
closed world assumption, but sometimes additional constant symbols are introduced. In the other cases, DK is based on the least
Herbrand model of a suitable Datalog program constructed from K.
The result of [41] applies only to so-called rooted a-acyclic CQs;
however, the rewriting is more efficient than that of [26] when
measured in combined complexity.

do not contain non-simple roles.

Again, the result from [34] also holds for Horn-SHIQ if the CQs
The constructions for LDL+ and SROEL(,) do not rewrite
the query, and therefore these logics also have the canonical model
property.

To ensure termination of the rewriting algorithm in [42], the
theories have to be restricted, e.g., to linear or sticky sets of tuplegenerating dependencies.
Q1
subs.

EL++
DL-LiteR
ELHdr
DL-LiteN
horn
DL-LiteR
DL-Lite

DL-LiteR
DL-Lite+
Horn-ALCHIQ
LDL+
SROEL(,)
Datalog family

Shown in
[35]
[26, Lemma 39]
[28, Theorem 5]
[38, Theorem 10]
[43, Theorem 2]
[41, Theorem 5]

Q2
subs.

FO=
FO=

Datalog

UCQ+

[34, Theorem 4]
[44, Corollary 11]
[45,46]
[42, Theorem 1]

[33, Theorem 2
and Lemma 16]

It was suggested in [30,47] that one should consider rewritability
as a decision problem, and ask, for a given logic L and a
Q1-query, whether it is Q2-rewritable. In case of decidability, one
can consider instead of Q1 only those elements of Q1 that have this
property, and thus obtain another instance of Definition 2.10.

3. Temporal queries

In the following, let L be a logic and Q a query language.
We now lift the definitions of the previous section to a temporal
setting, where we have a global theory describing the background
knowledge of a domain and a sequence of fact bases that represent
preprocessed sensor data obtained at successive points in time.

Definition 3.1 (Temporal Knowledge Base). Given a logic L, a
temporal knowledge base (TKB) over L is a pair K = (Ai)0in, T 
consisting of a finite sequence of fact bases Ai and an L-theory T .
Let I = (Ii)0in be a finite sequence of interpretations Ii =
(,Ii ) over a fixed non-empty domain . Then, I is a model of K
(written I |= K) if Ii |= Ai and Ii |= T for all i, 0  i  n. A TKB is
consistent if it has a model.

We consider only sequences of interpretations that satisfy the
constant domain assumption, i.e., they are defined over a common
domain. Thus, we assume that the world does not change, only the
predicates defined in it may evolve.

Although similar to what was done in [10,9], our temporal
query language can in principle be based on any atemporal query
language Q. Another difference to those approaches is that we
do not allow negation as this would destroy the rewritability
properties of Q (see Theorem 4.1).

Definition 3.2 (Temporal Query). Given a query language Q,
temporal Q-queries are built from Q-queries as follows:
 every Q-query  is a temporal Q-query; and
 if 1 and 2 are temporal Q-queries, then so are:
 1  2 (conjunction), 1  2 (disjunction),


 1 (always), 1 (always in the past),

 1 U 2 (until), and 1 S 2 (since).

1 (strong next), 1 (weak next),
1 (strong previous), 1 (weak previous),
1 (eventually), 1 (some time in the past),

, ,

, and U are future operators.

The symbols , , , , and S are called past operators, the
symbols
As usual, if Q is clear from the context, we use the term temporal
queries (TQs). The set FVar() of free variables of a TQ  is defined
as the union of the sets FVar( ) of all queries  occurring in . A
TQ  is called Boolean if FVar() = . We further denote by Sub()
the set of all TQs occurring as temporal subqueries in  (including
 itself). For a subquery 1 of , we denote by a1 the restriction of
a variable assignment a: FVar()  NC to FVar(1).
Definition 3.3 (Semantics of TQs). Let  be a TQ, I = (Ii)0in
interpretations over a common domain, a:
a sequence of
FVar()  NC a variable assignment, and i be an integer with
|= a() is defined by
0  i  n. The satisfaction relation I, i
induction on the structure of  as follows:


Q-query 
1  2
1  2

I, i |= a() iff
Ii |= a( )
(1) and I, i |= a2
I, i |= a1
I, i |= a1
(1) or I, i |= a2
i < n and I, i + 1 |= a(1)

(2)

(2)


1 U 2

1 S 2

I, i |= a() iff
i < n implies I, i + 1 |= a(1)
i > 0 and I, i  1 |= a(1)
i > 0 implies I, i  1 |= a(1)
I, k |= a(1) for all k, i  k  n
I, k |= a(1) for all k, 0  k  i
I, k |= a(1) for some k, i  k  n
I, k |= a(1) for some k, 0  k  i
There is k, i  k  n, with I, k |= a2
(1) for all j, i  j < k
and I, j |= a1
There is k, 0  k  i, with I, k |= a2
(1) for all j, k < j  i
and I, j |= a1

(2)

(2)

If I, i |= a(), then a is called an answer to  w.r.t. I at time
point i. Given a TKB K = (Ai)0in, T , we say that a is a certain
answer to  w.r.t. K at time point i, written K, i |= a(), if for all
models I of K, we have I, i |= a().
The set of all answers to  w.r.t. I at time point i is denoted
by Ans(, I, i), and the set of all certain answers to  w.r.t. K
is denoted by Cert(, K, i). Recall that our main interest lies in
finding answers to queries at the last time point, i.e., computing
the sets Ans(, I) := Ans(, I, n) or Cert(, K) := Cert(, K, n).
A Boolean TQ  is entailed by K (at time point i) if the set
Cert(, K) (Cert(, K, i)) is non-empty. In this case, we write K |=
 (K, i |= ), and similarly for I |=  and I, i |= .
Here we assume that there is no time point before 0 or after n,
similar to the temporal semantics used for LTL in [48] or for
temporal query languages for databases [16,49,50]. This semantics
has the effect that the temporal query
true is not entailed at
the last time point. This may seem counterintuitive, but it makes
sense in our scenario since we do not know whether the system
we observe is still running at the next point in time.

Alternatively, we could adopt the more common semantics
based on infinite sequences of interpretations, the first n of which
must be models of the respective fact bases. However, this in turn
has some unintended consequences. Since we want to monitor
systems based on the available facts, it is natural to restrict the
aggregation operators to the time points for which sensor data is
available. For example, if we ask for all processes that have always
been running using the query Process(x)  Running(x), then
time points before the system was started (i < 0) are not relevant.
Likewise, we may want to ask about a property that always held
from a specific time point up to now, regardless of what happens in
the future.

A compromise between our semantics and one based on infinite
sequences of interpretations could be obtained by looping the
last interpretation or fact base infinitely often, which means that
the facts of the last time point stay valid forever. This would make
true equivalent to true, while retaining the spirit of the finite
semantics. However, this semantics also has counterintuitive sideeffects as it makes severe assumptions on the future behavior of
the observed system.
As in classical LTL, one can show that 1 S 2 is equivalent to
2  (1  (1 S 2)), and thus, at the first time point, 1 S 2
is equivalent to 2 since (1 S 2) does not have any answers.
Proposition 3.4. For a: FVar()  NC and 0 < i  n, we have
I, i |= a(1 S 2) iff
 I, i |= a2
(2) or
(1) and I, i  1 |= a(1 S 2).
 I, i |= a1
Furthermore, I, 0 |= a(1 S 2) iff I, 0 |= a2
. To be able to employ
Similar equivalences hold for U,
analogous reductions for  and , we use the operators
and 
that are tautological at the last and first time point, respectively.

(2).

, and

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

4. Rewriting temporal queries

To answer temporal queries, we lift the rewriting approach
introduced in Section 2.3 to the temporal setting. We recall the
basic assumptions we made on the query languages Q1, Q2 and
the logic L:
 Consistency of knowledge bases in L should be decidable. This
is a basic prerequisite for any reasoning procedure, in particular
for query answering.
 The logic L should have the canonical model property w.r.t. Q1
(see Definition 2.8). This property is often a first step towards a
rewritability result. For our temporal setting, it is an important
ingredient to the proof of Theorem 4.1 below.
 Q1-queries should be Q2-rewritable w.r.t. L. In particular, we
will make heavy use of the objects T , DK, and T introduced
in Definition 2.10.
 Last but not least, the set of answers to any Q2-query w.r.t. a
finite interpretation should be computable.

Under all of these assumptions, we can show that temporal
Q1-queries enjoy a similar rewritability property w.r.t. knowledge
bases formulated in L, and thus we can compute the certain
answers to temporal Q1-queries over L.
We first lift the constructions of Definitions 2.8 and 2.10 to the
temporal setting. For this, consider a temporal Q1-query  and
a consistent TKB K = (Ai)0in, T . Obviously, the atemporal
:= Ai, T , 0  i  n, are then also conknowledge bases Ki
sistent, and thus we can define the sequences IK := (IKi
)0in
of canonical models and DK := (DKi
)0in of finite interpreta-
tions. Due to our assumption that each IKi is countably infinite, and
Condition (ii) of Definition 2.5, we can without loss of generality
assume that these canonical models have the same domain. Simi-
larly, the finite interpretations DKi have the common domain T .
Thus, they are valid sequences of interpretations according to our
semantics (see Definition 3.1).
Finally, the temporal Q2-query T is obtained by replacing
every Q1-query  occurring in  by the Q2-query T . We now
obtain the following rewritability result, the proof of which can be
found in Appendix A.
Theorem 4.1. Let Q1, Q2 be query languages and L be a logic that
has the canonical model property w.r.t. Q1 such that Q1-queries
are Q2-rewritable w.r.t. L. Then, for every consistent TKB K =
(Ai)0in, T , every temporal Q1-query , and every i, 0  i  n,
we have
Cert(, K, i) = Ans(, IK, i) = Ans(T , DK, i).
Our approach to answer temporal queries over data gathered while
monitoring a system can thus be summarized as follows. Assume
that we have an infinite TKB K = (Ai)i0, T  that represents the
sensor data coming from our system. At each time point n  0,
we only see the finite prefix K(n) = (Ai)0in, T  of K of length
n + 1. In every step, we gain access to a new fact base An+1
representing the sensor data of the current time point. Recall that
T formalizes the fixed domain knowledge that holds at every time
point. We now want to answer a fixed query , formulated in a
query language Q1, at each time point.
Following the approach detailed above, we rewrite  into a
Q2-query T . This can be done offline, i.e., before the system is
started, since it does not depend on any sensor data. However,
in each step, we have to construct the finite interpretation DKn+1
from An+1 and T in order to extend the sequence DK(n). It now
remains to show how to compute Ans(T , DK(n) ) in each step.
Since from now on we only need to consider the single query
language Q2 and it does not matter how we obtained the query
and the sequence of finite interpretations, we restate the problem
in terms of a generic Q-query and arbitrary finite interpretations.

Definition 4.2. Let I = (Ii)i0 an infinite sequence of interpretations over the finite domain  and  be a temporal Q-query. For
every n  0, we denote by I(n) = (Ii)0in the finite prefix of I
of length n + 1. The temporal database monitoring problem is the
problem of computing the sequence (Ans(, I(n)))n0.
For simplicity, we assume that NC =  and cIi = c for all c  NC,
which can always be accomplished by introducing additional
constants. This does not affect the semantics of the queries due to
Conditions (i) and (ii) of Definition 2.5. Thus, in the following we
regard answers to queries  as mappings from FVar() to . This
is closer to the reading of the interpretations Ii as databases as,
in this setting, one usually queries over all objects present in the
database.

5. Solving the temporal database monitoring problem

We now illustrate two approaches to solving the temporal

database monitoring problem on the small instance

ex := a  b c S( (b 

b))

of the introductory example, using the atemporal queries
a := TCS(x)  Server(y)  executes(y, x);
b := Active(x)  Overloaded(y);
c := NLB(y).
Furthermore, we consider the temporal subqueries 1 := c S 2,
2 := (b  3), and 3 :=
b. Since we have dispensed
with knowledge bases in the previous section, we view ex as
a temporal query whose atoms are simple instance queries over
database relations.
In the following examples, we consider the first five time points
of a sequence I = (Ii)i0 of interpretations over the common
domain  := {s, p1, p2, p3}. We define TCSIi
:= {p1, p2, p3},
ServerIi := {s}, NLBIi := {s}, and executesIi := {(s, p1), (s, p2),
(s, p3)} for all time points i, and thus the sets of answers to c
and a are always{s} and{(p1, s), (p2, s), (p3, s)}, respectively. We
interpret the remaining predicates as in the following table, which
results in the below listed answers to b:

ActiveIi

0 {p1, p2}
1 {p1, p2, p3}
2 {p1, p3}
3 {p2, p3}
4 {p3}

OverloadedIi Ans(b, Ii)

{s}

{s}
{s}


{(p1, s), (p2, s), (p3, s)}

{(p2, s), (p3, s)}
{(p3, s)}

5.1. Temporal database query languages

A first possibility to solve the temporal database monitoring
problem is to cast I as a temporal relational database and rewrite 
into a temporal database query language, in case this is possible.
This works, for example, whenever Q contains only first-order
queries, which can be expressed as SQL queries [1]. We illustrate
this approach on the recursive translation from temporal logic to
ATSQL described in [15]. For details on the syntax of ATSQL and the
formal translation, see [51,15].

ATSQL was developed for data annotated with time periods [51], and the approach from [15] works on valid-time periods that are required to always be coalesced, which means that
they represent maximal, non-overlapping periods of time in which
the data is valid. For example, the relation Active from our example would be represented in such a database by the tuples
(p1,[0, 2]), (p2,[0, 1]), (p2,[3, 3]), and (p3,[1, 4]) consisting of

transcoding services and the periods of time in which they are ac-
tive.

In the following, we denote by Q() the ATSQL translation
of a TQ . The atemporal queries are translated into standard
SQL queries, for which the valid-time periods are automatically
aggregated from the individual database tables by the database
system. Likewise, Q(ex) can be computed as a simple join of
Q(a), Q(b), and Q(1), and similarly for Q(b  3). We now
present the translation of the temporal formulae, which differs
slightly from that in [15] because we use a different temporal
semantics.

The ATSQL query Q(3) is quite simple:

NSEQ VT
SET VT PERIOD (0, END(VTIME(b)) -1)
SELECT x, y FROM Q(b)(VT) as b
WHERE END(VTIME(b)) >= 1
The keyword NSEQ VT (for non-sequential valid-time) indicates
that we want to modify the valid-time periods of the tuples in
Q(b) (via SET VT), in contrast to SEQ VT (sequential valid-time),
which tries to compute them automatically from the input tables.
Consider now any answer tuple (x, y) of Q(b). The associated
valid-time period [i, j] can be accessed in an ATSQL query via the
operator VTIME. The valid-time period of (x, y) in Q(3) is then
computed as [0, j  1] since 3 =
 is true iff there is a
point in the future (different from the current time point) where
 is true. In contrast to [15], where the temporal dimension starts
with , for us the first time point is 0. The keyword (VT) in
the FROM clause enforces the coalescing of the tuples from Q(b).
By likewise coalescing the result of Q(3), we obtain three answer
tuples:


Coalesced
[0, 0]
[0, 2]
[0, 3]

p1
p2
p2
p3
p3

[i, j]
[1, 1]
[1, 1]
[3, 3]
[1, 1]
[3, 4]

[0, j  1]
[0, 0]
[0, 0]
[0, 2]
[0, 0]
[0, 3]

The ATSQL translation of 2 is

END(VTIME(b)) -1)

NSEQ VT
SET VT PERIOD(LAST(0, BEGIN(VTIME(b)) -1),
SELECT x, y FROM Q(b  3)(VT) as b
WHERE END(VTIME(b)) >= 1
This query shifts the answers to Q(b  3) by one time step,
except when this would result in negative time points. We obtain
the tuples (p2, s,[0, 0]), (p3, s,[0, 0]), and (p3, s,[2, 2]).
We next compute the auxiliary query Qaux, which is a join of
Q(c ) and Q(2) that explicitly retains the valid-time periods of
the two subqueries:

NSEQ VT
SELECT b.x, b.y, VTIME(c) as p1 ,

VTIME(b) as p2

FROM Q(c )(VT) as c, Q(2)(VT) as b
WHERE c.y = b.y
The result of this query is now used in Q(1) as follows:
(SET VT PERIOD(END(p2)+1, END(p1))

SELECT x, y FROM Qaux as aux
WHERE END(p2)+1 >= BEGIN(p1)
AND END(p1) >= END(p2)+1)

(SET VT p2

SELECT x, y FROM Qaux as aux)

Intuitively, the query 1 collects, for each combination of the
variables x and y, all periods from Q(2) (since there the S-
formula is immediately satisfied), together with the last part
of those periods from Q(c ) that meet or overlap the end of
a matching period from Q(2). By matching we mean that the
values of the shared variable coincide (c.y
b.y). After
coalescing, the resulting tuples are (p2, s,[0, 4]) and (p3, s,[0, 4]).
Intersecting these with the answers for Q(a  b), we obtain
(p2, s,[1, 1]), (p2, s,[3, 3]), (p3, s,[1, 1]), and (p3, s,[3, 4]).
Since we are only interested in the answers for the last
time point 4 (until new data arrives), this results in a warning
that p3 is currently active while s is overloaded, and this situation
has happened at least once before since the last load balancing
operation. At the previous time point 3, a warning was issued for
both p2 and p3. In contrast, at time point 1 only the data from I0
and I1 was available, and thus no warning was issued.

This translation illustrates the advantage of using valid-time
periods instead of individual time points, as we only have to simply
manipulate the endpoints of the periods. However, since our goal
is to monitor systems that produce new data in very short time
intervals, storing all past data, even compressed into periods, is not
feasible.

5.2. Bounded history encodings

In the remainder of this paper, we describe two different
approaches that reduce the amount of space necessary to compute
Ans(, I(n)). Since we are interested in the answers at the last time
point, the idea is to keep only the past information necessary to
answer the TQ . This is formalized by the notion of a bounded
history encoding in [16,18].

Definition 5.1 (History Encoding). Given a TQ , a history encoding
for  is a tuple (E , IE , E , E ), where E is the set of encodings,
IE  E is the initial encoding, E : E  F  E is the transition
function (where F denotes the set of all finite interpretations), and
E : E  2FVar() is the evaluation function. This tuple defines
an operator E mapping finite sequences I(n) = (Ii)0in of finite
interpretations over the same domain to encodings in E as fol-
lows: E(()) := IE, and E(I(n)) := E (E(I(n1)), In) for all n  0. It
is correct if we have Ans(, I(n)) = E (E(I(n))) for all I(n), n  0.
It is bounded if the size of E(I(n)) does not depend on the length n
of the history.

Note that history encodings are called expiration operators in [18].
Whenever new data arrives in the form of a finite interpretation In,
the previously computed encoding E(I(n1)) is updated via the
function E. Correctness is an obvious requirement for any
encoding since we still want to be able to answer the original TQ
after encoding the data. The boundedness condition ensures that
the space required to answer the query does not depend on the
number n of previous time points; only the relevant data from the
past is retained (in aggregated form).

Note that the approach of Section 5.1 constitutes a history
encoding: the encoding of a sequence of interpretations is the
corresponding temporal database with valid-time periods, and the
evaluation function is given by the translation into ATSQL sketched
above. This history encoding is correct, but obviously not bounded.
In the following, we describe two possible methods to achieve
a bounded history encoding. In the first approach (Section 5.3), we
rewrite  into a TQ  without future operators by employing a
result from [52]. We then compute Ans(, I(n)) via a bounded
history encoding described in [16,18]. In Section 6, we generalize
the algorithm from [16,18] to directly deal with future operators.
The main difference is that we do not consider negation or arbitrary

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

first-order temporal queries. This allows us to circumvent the nonelementary blowup of the formula resulting from the reduction
in [52], while retaining boundedness.

5.3. Eliminating future operators

In this section, we show that we can rewrite every temporal
query  into an equivalent TQ  that does not contain future
operators but may contain negation as in [16]. We then apply
the algorithm described in [16] to iteratively compute the sets
Ans(, I(n)).

The reduction proceeds in the following steps. First, we
transform  into a (temporally) equivalent propositional LTLformula in order to then apply the separation theorem from [52].
This produces a propositional LTL-formula in which no future
operators occur in the scope of past operators and vice versa. Since
we evaluate the query at the current (last) time point, this allows
us to simply remove the future operators. Finally, the resulting
formula is translated back into a TQ extended with negation.

For the first translation, note that our temporal semantics
differs from that in [52], which considers strict versions of U and S
as the only temporal operators. But it is well-known that these
. Moreover, the semantics is
operators can simulate
defined w.r.t. bounded past and unbounded future.

and

Definition 5.2 (Propositional LTL). Let P be a set of propositional
variables. LTL-formulae are built from P using the constructors
1  2, 1  2,1, 1 U< 2 (strict until), and 1 S< 2 (strict
since). An LTL-structure is an infinite sequence J = (wi)i0 of worlds
wi  P, i  0, and it satisfies an LTL-formula  at i  0 if J, i |= 
holds, which is defined inductively:


p  P
1  2
1  2

1 U< 2

1 S< 2

I, i |=  iff
p  wi
J, i |= 1 and J, i |= 2
J, i |= 1 or J, i |= 2
Not J, i |= 1
There is some k > i with J, k |= 2 and
J, j |= 1 for all j, i < j < k
There is some k, 0  k < i, with J, k |= 2
and J, j |= 1 for all j, k < j < i

As usual, we define the constants trueand falseby p  p and
p  p, respectively, for an arbitrary p  P. We also define
first := (true S< true) with the semantics that J, i |= first iff
i = 0, i.e., this formula is satisfied exactly at the first time point.
Let from now on  be an arbitrary but fixed TQ containing only
the Q-queries 1, . . . , m. Let furthermore {p1, . . . , pm, p} be the
set of propositional variables. For a finite sequence I = (Ii)0in of
interpretations and a variable assignment a: FVar()  NC, the
propositional abstraction is the LTL-structure Ia := (wi)i0, where

wi :={pj | Ii |= a(j)}  {p}


if 0  i  n, and
otherwise.

There, the propositional variables pi, 1  i  m, capture whether
a is an answer to i. The additional variable p is used to distinguish
the first n time points. This is necessary since the semantics of TQs
considers only the first n time points whereas in LTL all time points
matter.

The first step of the translation yields an LTL-formula f that
behaves similarly to  w.r.t. the propositional abstractions of
sequences of interpretations I and variable assignments a. The
formal construction is shown in Appendix B; we only illustrate
it here on the example of ex. Assume that the propositional

variables pa, pb, pc are used for a, b, c, respectively. Then, the
corresponding formula fex looks as follows:

fex := pa  pb f2  (pc  pc S< f2
where f2 := false U< (pb  f3  p) and f3 := true U< (pb  p).
The main differences to the temporal structure of ex are that the
non-strict S is simulated using the strict version and the future
operators are simulated via U<.
We now use the separation theorem from [52] to transform f
into an equivalent LTL-formula f 
 that is a Boolean combination
of temporal subformulae containing only S< operators or only
U< operators. In the proof of this theorem, subformulae of f are
copied and rearranged, but no additional propositional variables
are introduced.

In our example, only the subformula pc S< f2 is not yet sepa-
rated. Its separation according to the transformation in [52] is the
disjunction of the following formulae:
 pb  f3  p  false S< true  pc S< true
 pc S< 1  true S< 1  true U< (pb  p)
 pb  p  true S< 1  pc S< 1
 pc S< (pb  p  pc  true S< 1  pc S< 1)
where
1 := pb  p  pc  false S< true  pc S< true.
This is obtained by a case analysis of the possible relations between
the time intervals covered by the S< operator and the two U<
operators in f2.

We simplify this formula for the subsequent constructions. Note

that 1 is equivalent to
2 := pb  p  pc  first
and the first disjunct is equivalent to f32. Since pc S< 1 implies
:= pa  pb f2  (pc  1)
true S< 1, we have

ex
where 1 is the disjunction of the following formulae:
 f3  2
 pc S< 2  true U< (pb  p)
 pb  p  pc S< 2
 pc S< (pb  p  pc  pc S< 2).
Since we are interested in evaluating  (and thus f and f 
) at
time point n, we can now reduce f 
 as follows. First, we replace
all variables that are in the scope of an U< by false. The reason for
this is that such variables are only evaluated at time points after n,
where all variables are false in all propositional abstractions. The
resulting formula is then simplified using standard equivalences as
shown in Appendix B. This yields a formula f 
 that does not contain
any U< operators and is equivalent to f 
 at time point n in every
LTL-structure of the form Ia.
:= pa  pb  pc  2 with
2 := (pb  p  pc S< 2)  (pc S< (pb  p  pc  pc S< 2)).

In our example, we obtain f 

We now translate the LTL-formula f 
 without U< back into a TQ

. Recall that the goal is to use the algorithm presented in [16],
where negation is allowed in the query language. Furthermore, in
that paper, a slightly different operator S is used instead of S. The
semantics of  and S, as employed in [16], is as follows:

ex

1S2

I, i |= a() iff
Not J, i |= a(1)
There is a k, 0  k < i, with J, k |= a2
(1) for all j, k < j  i
and J, j |= a1

(2)

ex

is given in Appendix B.

In our example, we obtain f 

In the following, we call any TQ built using the operators ,,
, , and S a Past-TQ, which is in particular a temporal query
in the sense of [16]. The formal definition of this final translation
to the Past-TQ f 
:= a  b  c  3, where
3 := (b  4)  ((b  c  4)  cS(b  c  4))
and
4 := ((b  c  true)  cS(b  c  true)).
Note that c occurs 13 times in f 
, but only once in the original query ex. While some copies where introduced because of the
different semantics of S, S<, and S, the main problem in this
translation is the separation theorem [52]. In general, the size of the
separated formula may be non-elementary in the size of the original formula; the number of stacked exponents is determined by
the number of alternations between nested S< and U< operators.
Taken together, the illustrated translations yield the following

result, which is proven in Appendix B.
Theorem 5.3. For every TQ , there is a Past-TQ  with FVar() =
FVar( ) such that for all I = (Ii)0in, we have Ans(, I) =
Ans( , I).

ex

The encodings consist of a finite interpretation I

This shows that we can solve the temporal database monitoring
problem using the bounded history encoding from [16], which
works as follows on the TQ  constructed in Theorem 5.3.
i of several
auxiliary predicates. Intuitively, for each subformula  of 
starting with a past operator, it stores the answers Ans(, I(i)) 
FVar() for  at the current time point i. The set Ans( , I(i)) can
then easily be computed from the current interpretation Ii and I
i ,
i.e., the construction yields a correct history encoding. Afterwards,
Ii is disregarded and the information computed in I
i is the only one
kept. On input Ii+1, the previous encoding I
i is updated to a new
interpretation I
i+1, which allows us to compute Ans( , I(i+1)),
and so on.
The size of I
i is bounded polynomially in the size of  and in the
number of past operators occurring in , and exponentially in the
number of free variables occurring below past operators. However,
the memory requirements of this history encoding do not depend
on n, and thus it is bounded.

Note that a formal requirement for the correctness of the
algorithm in [16] is that  is domain-independent, which means
that the answers to  at previous time points do not change if the
domain is changed from the current time point to the next (e.g., by
introducing new constants). Otherwise, the answers to the past
formulae at the current time point could not be compiled into a
single interpretation I
i so easily, but would have to be recomputed
at each time point, and thus the algorithm would have to store the
whole sequence I(i). However, since we are only dealing with the
constant, finite domain T = NC (see Section 4), we do not need
to assume domain-independence of .
The approach presented in this section has the obvious drawback that the reduction in [52] is non-elementary in the size of
the formula. As mentioned before, for propositional LTL, eliminating the past operators from a formula incurs at least an exponential blowup; the best known construction works via translation
through several logics and automata models, and is therefore also
hardly practical [5]. The main advantage arises from the fact that
the approach described in [16] can easily be implemented in a standard database system. No temporal information needs to be stored
and only several auxiliary tables have to be updated after new sensor information becomes available.

6. Bounded history encodings for future operators

In this section, we present an algorithm that solves the temporal
database monitoring problem without the need to eliminate
the future operators from the query, thereby avoiding the nonelementary blowup of the construction described in the previous
section. We further show that this approach also constitutes a
bounded history encoding.
As before, let  be a fixed temporal Q-query over some query
language Q for which answers w.r.t. finite interpretations are com-
putable, and let I = (Ii)i0 be a fixed infinite sequence of interpretations over the same finite domain . For ease of presentation, we
 in this
do not consider the temporal operators ,
section. The constructions and arguments for these operators are
similar to those for U and S.

, , and

The algorithm uses as data structure so-called answer terms,
which represent TQs in which some parts have already been evalu-
ated. In particular, they do not contain atemporal queries anymore,
but rather sets of already computed answers to subqueries. Addi-
tionally, they may contain variables (different from those in NV)
that serve as place-holders for subqueries that have to be evaluated at the next time point.
For simplicity, we assume in the following that NV is finite
and that answers are of the form a: NV   instead of
a: FVar()  . After computing such a mapping, it can
be restricted to FVar() to get the actual answer. In an implemen-
tation, one would of course already restrict the intermediate computations of answers for subqueries   Sub() to FVar( ). But
then one has to be more careful when combining answers to different subqueries. Thus, when we talk about answers, we mean mappings a: NV  , and in particular Ans(, I(n)) refers to a set of
such mappings, i.e., a subset of NV.
The domain of our bounded history encoding essentially

consists of (families of) answer terms, as defined next.

the set of all variables of the form x

Definition 6.1 (Answer Term). Let FSub() denote the set of all
subqueries of  of the form 1, 1, or 1 U 2. For j  0,
we denote by Var
for

  FSub(). The set ATi
 of all answer terms for  at i  0 is
the smallest set satisfying the following conditions:
 Every set A  NV is an answer term for  at i.
 Every variable x
j with j  i is an answer term for  at i.
 If 1 and 2 are answer terms for  at i, then so are 1  2 and
1  2.
Note that every answer term at i is also an answer term at i + 1,
i.e., we have ATi

j  Var

  ATi+1

We now define an evaluation function, mapping answer terms
to sets of answers. Intuitively, it replaces the variables x
in
 by appropriate sets of answers and evaluates  and  as

set intersection and union, respectively. Formally, the functions
evaln: ATn

  2NV , n  0, are defined recursively as follows:

with j < n
with j < n

with j < n


A  NV
x 1

x 1

x1 U 2

x 1

x 1

x1 U 2
1  2

1  2

evaln()

Ans(1, I(n), j + 1)
Ans(1, I(n), j + 1)
Ans(1 U 2, I(n), j + 1)

evaln(1)  evaln(2)
evaln(1)  evaln(2)

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

As mentioned before, our data structure consists of families
 : Sub()  ATi
 of answer terms, one for each subquery of .
This additional information is necessary for the transition function
of our encoding. We would actually only need to store the answer
terms for subqueries that are referred to by past operators, but for
simplicity, we compute them here for all subqueries.

For our proofs, we also need more fine-grained notions of

correctness and boundedness.
Definition 6.2 (Correct, Bounded). Consider a function  :
Sub()  ATi
. This function is correct for i  0 (w.r.t. I) if
for all n  i and for all   Sub(), we have evaln( ( )) =
Ans( , I(n), i). It is i-bounded if for all   Sub(), the answer
term  ( ) contains only variables from Var

In particular, if  : Sub()  ATi
 is correct for i, then we can
compute the desired set Ans(, I(i)) by evaluating evali( ()),
and thus our encoding is valid in the sense of Definition 5.1. More-
over, if  is i-bounded, then evali( ()) can easily be computed
since all variables simply have to be replaced with  or NV.

We now define the initial encoding 0 and prove that it is
correct for 0. Afterwards, we define the transition function that
computes a new encoding i from the previous encoding i1
and the next interpretation Ii, and then prove that it preserves
correctness.


Furthermore, 0 is obviously 0-bounded. Assume now that i > 0
and we are given a function i1: Sub()  ATi1
that is correct
for i  1 and (i  1)-bounded. We now describe the transition
function that computes a new function i that is correct for i and
i-bounded, using the data from the next interpretation Ii.
i : Sub()  ATi

 (similar
to 0) that is correct for i, but may still contain variables with index
i  1. Afterwards, we appropriately replace these variables while
ensuring that correctness for i is preserved.
For i > 0 and given i1: Sub()  ATi1
i : Sub()  ATi
 is defined recursively as follows:

As a first step, we define a function 0

 , the mapping

Atemporal query 1
1  2
1  2


1 U 2
1 S 2

i (2)
i (2)

i ( )
Ans(1, Ii)
i (1)  0

i (1)  0

x 1

i1(1)
x 1

i1(1)
0(2)  (0
i (2)  (0

i (1)  x1 U 2
i (1)  i1(1 S 2))

6.1. Computing the Answer Terms

The answer terms 0( ),   Sub(), are defined by

induction on the structure of TQs as follows:


Atemporal query 1
1  2
1  2


1 U 2
1 S 2

0( )
Ans(1, I0)
0(1)  0(2)
0(1)  0(2)
x 1


x 1

0(2) (0(1) x1 U 2
0(2)

The difference to the definition of 0 is that the answer terms
for past operators are computed using the answer terms for the
previous time point. Correctness of this mapping is shown in
Appendix C.
Lemma 6.4. If i1 is correct for i  1, then 0
In order to remove the variables with index i  1 from 0
i , we can
now substitute them by the values that we have just computed.
For example, since x 
i1 is a place-holder for the answers to 
w.r.t. I(n) at i, we can now replace it by 0
i ( ). The details of this
construction are described in Appendix C.
Lemma 6.5. If i1 is correct for i 1 and (i 1)-bounded, then we
can construct a function i: Sub()  ATi
 that is correct for i and
i-bounded.

is correct for i.

To answer atemporal queries 1, we employ our assumption
that the set Ans(1, I0) is computable since I0 is a finite inter-
pretation. We can thus use any known algorithm to compute this
set, which is then considered as an atom of the answer term 0()
for .

To understand the idea behind the variables x

, consider for
example x 1
, which is the answer term for 1 at time point 0.
This variable serves as a place-holder for the answers to 1 at the
next time point 1, which are not yet known. Thus, according to the
semantics, the set of answers to 1 at time point 0 is , which
is equal to eval0(x 1
). However, once data about time point 1
becomes known, the variable x 1
can be substituted by the actual
answers to 1 at time point 1. For more details on this substitution,
see the proof of Lemma 6.5 in Appendix C.

Similarly, x1 U 2

is a place-holder for the answers to 1 U 1 at
time point 1. This means that we simply evaluate the U operator according to the equivalence of 1 U 2 and 2 (1 (1 U 2))
(cf. Proposition 3.4).

The following result is proven in Appendix C.

Lemma 6.3. The function 0 is correct for 0.

To solve the temporal database monitoring problem on input 
and I, we now iteratively compute the mappings i as described
above, and output evali(i()) for each i  0. By the previous
lemmata, this is a correct history encoding.
If the query  contains no future operators, then the answer
terms contain no variables and can always be fully evaluated to a
subset of NV. In this case, it is easy to see that the size of i() is
independent of i, and thus we have constructed a bounded history
encoding, which can be seen as a variant of the one from [16,18].
If  contains future operators, we still have to show that the
space required to store (a representation of) i does not depend
on i. Unfortunately, the property of i-boundedness alone does not
suffice since the variables from Var
i may still occur several times
in i().

Example 6.6. Consider again the query

ex = a  b NLB(y)S( (b 

b))

from Section 5 and recall the abbreviations 1, 2, and 3 for the
temporal subqueries of ex. The answer terms for each time point i
can be obtained as
i(ex) = Ans(a, Ii)  Ans(b, Ii)  i(1).

i Ans(NLB(y), Ii)  i1(1).

To compute i(1), observe first that, for i > 0,
i (1) = x2

Since we consider all subqueries to have the same variables,
Ans(NLB(y), Ii) evaluates to   {s} for all i  {0, . . . , 4}. Hence,
in our example this set does not affect the computations, and thus
we will omit it and consider 0
i and the
answer term for 1 from the previous time point.

i (1) to be the union of x2

We now describe how the algorithm proceeds in more
detail. A summary of the answer terms (equivalent to) i(1),
i  {0, . . . , 4}, can be found in the following table, where Bi
abbreviates Ans(b, Ii):

i i(1)

x2
1  (B1  x3

x2
1 )
2  (B1  x b
x2

3 B3 (B3x3
x2
4 B3 (B4x3
x2

3 ) (B1x b
4 ) (B1x b

evali(i(ex))


B3
B4

1  x2
0 .
1 (b  3) = B1  x3
0 by 0

To obtain the answer sets evali(i(ex)), observe that by the
definition of evali all variables are replaced by since b is equivalent to true U b. There are no answers to ex at the first three
time points since the combination of S with the two
operators
requires at least three previous time points to exist. However, at
time points 3 and 4, we obtain the sets B3 = {(p2, s), (p3, s)} and
B4 = {(p3, s)}, respectively, as expected.
The computation for i = 0 is straightforward. For i = 1, we first
compute
1  0(1) = x2
1 (1) = x2

Afterwards, we replace x2
since
2 = (b  3), i.e., 2 at time point 0 refers to b  3 at time
point 1 (see the proof of Lemma 6.5 for details). We thus obtain the
1-bounded answer term 1(1) = x2
1 ) listed above.
2  x2
1 ). By replacing
the variables with index 1, we compute
2(1) = x2
Since B2 = , one can obviously simplify this term. For example,
2 cannot evaluate to a non-empty answer set, and   x b
  x3
yields the same results as x b
Without these simplifications, at i = 3, we would compute

1  (B1  x3
2 (1) = x2
1  (B1  x3
).
2 ) B1  (B2  x b

At i = 2, we get 0

2  (B2  x3

itself.

3 ) B2  (B3  x b

3(1) as
B1  (B2  B3  x b
3  (B3  x3
x2

),

twice. In general, in each step we would add
to the answer term, which would result in a cor-

which contains x b

one copy of x b
rect history encoding for  that is, however, not bounded.
Fortunately, by simplifying all answer terms using the properties of  and  and the fact that B4  B3  B1, we can compute
the (i-bounded) answer terms i(1) given in the table above.

This demonstrates that it is important that the computed answer
terms are simplified at each step, while preserving their behavior
under evali.

6.2. Simplifying the answer terms


We show how to automatically simplify every answer term by
rewriting it into a certain normal form. While variables from Var

may still occur several times in this normal form, the number of
their occurrences does not depend on the number n of previous
time points.
Definition 6.7. Two answer terms 1, 2  ATi
 are equivalent
(at i) if evaln(1) = evaln(2) holds for all n  i. An answer term

  ATi

 is in normal form (for i) if it is of the form

XVar
where AX  NV for each X  Var
i .
Note that every i-bounded answer term  can be transformed into
an equivalent one in normal form. To this end, we first transform
it into disjunctive normal form, which may cause an exponential
blowup. We then combine all conjunctions containing the same
combination X of variables from Var
i , and merge the already
computed sets of answers into one set AX. If one combination X
occurs in no conjunction, we set AX := . If X has no associated
sets of answers, we set AX := NV. It is easy to see that the resulting
answer term is equivalent to the original one.

xX


).

x2

 := NV , A

 := B3, and A

 :=
in the normal form of 3(1).

Proposition 6.8. For every i-bounded answer term we can construct
an equivalent answer term that is in normal form for i.
Consider for example the (non-simplified) answer term 3(1)
from Example 6.6 above. An equivalent term in disjunctive normal
form is
3  (B3  x3
3 )  (B2  B3)  (B2  x b
x2
 (B1  B2)  (B1  B3)  (B1  x b
We can compute
A := (B2  B3)  (B1  B2)  (B1  B3) = B3
as the coefficient of   Varex
Similarly, we obtain A
B1  B2 = B1. All other sets of answers AX are empty.
However, in general we need to consider all eight subsets of
Varex
in such a normal form, which is similar to the number

of auxiliary relations needed in Section 5.3 for the formula f 
ex
(determined by the number of past operators). In this example, the
space requirements of the two approaches do not differ much since
the number of alternations between past and future operators
in ex is small.
We can now summarize our history encoding for  as follows.
The set of encodings E consists of all functions of the form
 : Sub()  ATi
 that are i-bounded, together with a distinct
element IE that marks the beginning of the monitoring process. The
transition function E computes, on input  and Ii, the function i
as detailed in Section 6.1, and then transforms all its answer terms
into normal form. Finally, the evaluation function E is given by
E ( ) := evaln( ()), where the time point n is identified by
the (unique) index of the variables in  (). If this answer term
contains no variables, then n is irrelevant since evaln amounts to a
simple computation of unions and intersections of sets of answers.

Lemma 6.9. The history encoding (E , IE , E , E ) for  is correct
and bounded.

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

We assume in this section that there is a set NRP  N1

time would make no sense. The notion of rigidity has been explored
for other temporal formalisms before [53,10].
P of rigid
unary predicates. In this setting, a finite sequence I = (Ii)0in
can only be a model of a TKB K if it fulfills the conditions of
Definition 3.1 and additionally respects the rigid predicates, i.e., it
satisfies PIi = PIj for every P  NRP and all indices i, j between 0
and n.
In this section, we present an approach to deal with these
predicates under two restrictions. First, we consider only the
source query language Q1 of unions (disjunctions) of rooted CQs
(see Example 2.7). Recall that all but one of the rewriting results
in Example 2.11 considered only UCQs or sublanguages (CQs or
instance queries). Since these UCQs are embedded in a temporal
query that allows disjunction, we can without loss of generality
assume that we are dealing only with CQs. We call temporal
queries over this query language temporal conjunctive queries
(TCQs). The second restriction is that the logic L must satisfy the
additional property that the class of models of a given knowledge
base is closed under countable disjoint unions.

We now describe these restrictions in more detail.

7.1. Rooted conjunctive queries

Recall from Example 2.7 that CQs are of the form  =
y1, . . . , ym., where  is a finite conjunction of instance queries,
which are called the atoms of . We denote the set of all
constants occurring in  by Const(), and similarly the variables
by Var() and the free variables by FVar(). Given a variable
assignment a: FVar()  NC, we denote by a() the Boolean CQ
resulting from replacing all free variables in  according to a.
For the definition of the query language, we also need to define
the satisfaction relation |= (cf. Definition 2.5). As usual, it is given
using the notion of a homomorphism [54].
Definition 7.1 (Semantics of CQs). Let  be a CQ, I = (,I ) an
interpretation, and a: FVar()  NC a variable assignment. A
mapping  : Var()  NC   is a homomorphism of  into I
(w.r.t. a) if
  (a) = aI for all a  NC, and
 ( (z1), . . . ,  (zn))  PI for all atoms P(z1, . . . , zn) in a().
We define the satisfaction relation |= by setting I |= a() iff there
is a homomorphism of  into I w.r.t. a.
It is a simple matter to check that this query language satisfies the
conditions of Definition 2.5.

Intuitively, rooted CQs [55,41] are CQs that refer to at least one
constant (either directly or via a free variable); that is, they are
rooted in the named part of an interpretation.
Definition 7.2. A CQ  is called rooted if
(i) it contains at least one free variable or constant, and
(ii) it is connected, i.e., for all x, y  Var()  Const() there is a
sequence x1, . . . , xn  Var()  Const() such that x1 = x,
xn = y, and for all i, 1  i  n, there is an atom of  that
contains both xi and xi+1.

A TCQ is rooted if it contains only rooted CQs.
This makes sense from an application point of view since one
usually does not ask if there is some object with certain properties,
but actually wants to know the names of all objects with these
properties. Note that Condition (ii) on its own does not impose
a restriction since any CQ that is not connected can simply be
replaced by the conjunction of CQs representing its maximal
connected subsets of atoms [56,29].

To specify the second restriction, we first need to define the

countable disjoint union of interpretations.

Proof. By Lemmas 6.3 and 6.5 and Proposition 6.8, we obtain
E (E(I

(n))) = evalnE(I
= evaln(n()) = Ans(, I

(n))()

(n)).

Furthermore, since E(I(n)) always contains only answer terms that
are in normal form, its size is bounded by|Sub()|2|FSub()||NV|,
which is independent of n. 
The factor |NV| arises from the fact that we always deal with
fully evaluated sets of answers. This cannot be avoided since
the temporal database monitoring problem anyway requires to
compute the sets Ans(, I(n))  NV.
We now analyze the overall time and space requirements of our
approach. For this, let s, t: N N  N be two functions such that,
given a finite interpretation I over the domain  and an atemporal
query , we can compute Ans( , I) in time at most t(||,||)
and space at most s(||,||). Note that these functions are at
least exponential in the number of variables in  since Ans( , I)
may contain all possible answer tuples. The proof of the following
lemma can be found in Appendix C.
Lemma 6.10. There is a function f : N  N  N that is exponential
in the first component and polynomial in the second such that we can
compute each set Ans(, I(n)), n  0, in time at most f (||,||)
+ ||  t(||,||) and space at most f (||,||) + s(||,||).
This means that we can solve the temporal database monitoring
problem in exponential time (and space), in addition to whatever
resources we need to answer atemporal queries. The size of the
data domain , however, contributes only polynomially to the
complexity. Furthermore, the exponential factor of |NV| cannot
be avoided.
Consider, for example, a temporal CQ over a temporal DL-LiteR-
knowledge base with fact base Ai. By [26], every atemporal CQ 
can be rewritten into a UCQ for which it suffices to evaluate it
over Ai viewed under the closed world assumption, which means
that T = NC. The rewritten query is of size exponential in
the size of  and polynomial in the size of T , and thus one can
compute Cert( ,Ai, T ) in time exponential in the size of 
and polynomial in the size of K. Note that this runtime already
|  |NVT |, because all answer tuples
contains a factor of |NFVar( )
have to be enumerated. Thus, answering the temporal CQ only
adds another exponential factor in the size of the query (the
number of future operators) to the total effort required to solve the
temporal database monitoring problem. Since we have constructed
a bounded history encoding, this effort is the same regardless of the
current time point.

While we can use more efficient rewriting approaches (e.g.,
[38]), we still need at least exponential time in the number of
variables to evaluate the atemporal queries. Furthermore, the
additional effort required by the temporal operators is completely
independent of this.

7. Rigid unary predicates in UCQs

We now extend our temporal semantics by designating certain
predicates as being rigid, which means that their interpretation is
not allowed to change over time. When considering only databases,
i.e., finite interpretations, such predicates can be expressed by
database tables without explicit time stamps or periods, with the
intention that the contained information is valid at every time
point.

For now, we consider only rigid unary predicates. For example,
the unary predicate Server should be rigid since an application
scenario with a server that stops being a server at some point in

Definition 7.3. Let (Ii)iI be a countable family of interpretations
Ii = (Ii ,Ii ) with disjoint domains. For some distinguished j  I,
over the domain J :=
the disjoint union of this family (with core Ij) is the interpretation J
 PJ :=
 cJ := cIj for all c  NC, and

iI PIi for all n  0 and P  Nn
P.

iI Ii with

In the following, we assume that the class of models of any
knowledge base in L is closed under taking disjoint unions. In
particular, this means that L-theories are not allowed to place
global restrictions on the number of domain elements (of a
particular type).

7.2. Rewriting with rigid unary predicates

|= Ai and Ii

Before we reconsider the temporal database monitoring
problem, we have to verify that Theorem 4.1 remains valid under
the new semantics. The main problem we have to solve is that the
sequence IK of canonical models does not necessarily respect the
rigid predicates. In the following, we make the same assumptions
as in Section 4, but for the special case that Q1 contains only rooted
CQs and models of knowledge bases in L are closed under disjoint
unions. For technical reasons, we also assume that Q1 contains
at least all unary instance queries; again, this is satisfied by most
results listed in Example 2.11.
Let K = (Ai)i0, T  be an infinite TKB that represents the
sensor data from our system. As usual, we assume that this data
is consistent, which in this setting means that there is an infinite
sequence I = (Ii)i0 of interpretations that respect the rigid
|= T for all i  0. The
predicates such that Ii
finite prefixes K(n) are then also consistent. We show how to
construct modified sequences of interpretations (similar to IK(n)
from Theorem 4.1) that respect rigid predicates.
R  {P(c) | P  NRP, c  NC}
that specifies the rigid predicates that the constants are allowed
to satisfy. Note that R is always finite since NRP and NC are
finite. We denote by R the set of all sets of this form.
In
order to answer TCQs over K(n), it suffices to consider the TKB
R := (Ai  R)0in, T  for a suitable R  R. The proof of the
K(n)
following lemma can be found in Appendix D.
Lemma 7.4. Let K = (Ai)i0, T  be a consistent infinite TKB. Then
there is a set R  R such that K(n)
R is consistent for all n  0, and for
every TCQ  and all i and n with 0  i  n, we have
Cert(, K(n), i) = Cert(, K(n)

The first step is to find a set of assertions

R , i).

Given such a set R, we can now construct a sequence of interpretations that respects the rigid predicates and allows us to prove Theorem 4.1 under our new semantics. The details of this construction
can also be found in Appendix D.

Theorem 7.5. Let Q1, Q2 be query languages such that Q1 contains
only rooted CQs and L be a logic that has the canonical model
property w.r.t. Q1 such that Q1-queries are Q2-rewritable w.r.t. L.
Let further K = (Ai)i0, T  be a consistent infinite TKB and R given
by Lemma 7.4.
Then for all n  0 there is a sequence of interpretations IK(n),R =
(Ji)0in such that for every temporal Q1-query , and all i,
0  i  n, we have
Cert(, K(n)

R , i) = Ans(, IK(n),R, i) = Ans(T , DK(n)

, i).

Thus, we have again arrived at the temporal database monitoring problem. In contrast to Theorem 4.1, however, we also have
to find a suitable set R in order to obtain the finite interpretations DAiR,T .

7.3. A modified history encoding

Since at the beginning of the monitoring process we have
no information except for that given by the background theory
about the rigid predicates, we have to consider all sets R  R
as candidates to compute DA0R,T . But we do not only have
to compute 2|NRP||NC| many rewritten interpretations, the effort
required to answer the temporal Q1-query  is also increased by
the same factor.
However, one can clearly eliminate those R  R from consideration for which we find out thatAiR, T  is inconsistent at some
point. Since we have assumed that the sensor and background data
is consistent, this can only happen if the set R is the wrong set,
i.e., not the one whose existence is guaranteed by Lemma 7.4.
More formally, let  be a temporal Q1-query and (E, IE, E, E )
be a history encoding for T (without rigid predicates). We describe an algorithm to deal with rigid unary predicates that is similar to a history encoding, but directly reads the fact bases Ai instead
of the interpretations DAiR,T . Recall that the latter are finite interpretations over the domain T , which we again assume to be
equal to NC in the following.

Algorithm 7.6. The main data structure is a partial function
f : R  E that specifies encodings corresponding to some of
the sets R  R. On input T , the algorithm does the following:
1. For R  R, the value f (R) is initialized to IE whenever R, T 
is consistent, and remains undefined otherwise.
2. Let f contain the current encodings and A be the next fact base.
For every R  R, the new encoding is obtained as f (R) :=
E (f (R), DAR,T ) if f (R) is defined and AR, T  is consis-
tent. All other values f (R) remain undefined.

3. The current encodings are now given by f := f  and the value

E (f (R))

f (R) is defined
is returned. Continue with Step 2.

instances of the original history
Intuitively, we run several
encoding in parallel, with the only difference between them being
that each instance has a different fixed set R of assumptions about
the rigid names. If we discover one of these assumptions to be
inconsistent w.r.t. one of the input fact bases, the corresponding
instance is stopped. Each remaining instance computes the certain
answers to  relative to one set R, and the actual set of certain
answers to  is then computed as their intersection.
The consistency tests for A  R, T  are necessary since
DAR,T  is only defined if the knowledge base is consistent.
Furthermore, this allows us to remove sets R from consideration,
which makes the algorithm more efficient. The hope is that,
over time, more and more sets R are discarded because of new
information until only few of them remain.

We show that this computation preserves correctness and
boundedness of the given history encoding in a sense similar to
that of Definition 5.1.
Theorem 7.7. Let  be a temporal Q1-query. Given a correct history
encoding for T and a consistent infinite TKB K = (Ai)i0, T , Algorithm 7.6 outputs Cert(, K(n)) for each n  0. If the history encoding
is bounded, then the size of

f does not depend on n.

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

times the size of E(DK(n)

is at most
), and both values are

For the correctness, observe first that for every R for which f (R)

Proof. The second claim holds since the size of f
2|NRP||NC|
independent of n.
is defined at time point n  0, we have
E (f (R)) = Ans(T , DK(n)
by Definition 5.1 and Theorem 7.5. This set always contains
Cert(, K(n)) since K(n)
R is more restrictive than K(n). Furthermore,
by Lemma 7.4, we know that there must be at least one R  R
that passes all consistency test such that Cert(, K(n)
R ) is even equal
to Cert(, K(n)). This shows that the intersection in Step 3 yields
Cert(, K(n)). 
Thus, every correct history encoding can be extended to deal with
rigid unary predicates while increasing the time and space requirements by a factor of 2|NRP||NC|. For the bounded history encoding of
Section 6, this means that its total resource consumption at each
|2|NRP||NC|
time point is proportional to|Sub()|2|FSub()||FVar()
plus 2|NRP||NC| times the requirements for answering the rewritten
atemporal Q2-subqueries over finite interpretations over the domain T (cf. Lemma 6.10).

) = Cert(, K(n)
R )

8. Discussion

In this article, we have introduced a generic temporal query
language that combines the well-known temporal logic LTL with
queries over knowledge bases. Further, we have shown how
the reasoning task of temporal OBDA over knowledge bases is
reduced to answering queries over temporal databases, similar to
what was done for the atemporal case (see Example 2.11). We
then presented three approaches that solve the resulting temporal
database monitoring problem and described an approach to extend
any history encoding to deal with rigid unary predicates for the
special case where only rooted conjunctive queries are allowed. In
what follows, we describe advantages and drawbacks of the former
three approaches.

8.1. Comparison

We focus on the required implementation effort, on aspects of
the implementation, as well as on the amount of memory required.
We thus point out characteristics that can guide the choice of a
particular approach for a specific use case.
First approach. The most straightforward option is to evaluate TQs
in a database system that supports dealing with temporal information using a suitable translation (see Section 5.1). The advantage of this is that one can directly exploit database optimization
techniques. However, it requires storing the whole history of past
sensor data (even if only a small part of it is necessary to answer
the query) and re-evaluating the query at each time point using a
temporal database query language like ATSQL [15]. As the length of
the history can get very long, this is not the preferred option. Nev-
ertheless, this approach may still be feasible if the amount of data
can be limited by other means, such as adopting a sliding view
semantics where only a fixed amount of past time points is used to
evaluate temporal queries.
Second approach. The approach described in Section 5.3 is based on
the bounded history encoding from [16,18]. Any implementation
of this approach has to eliminate the future operators in the
query; we described how this elimination can be done. Although
independent of the length of the history, this step involves a
theoretical non-elementary blowup in the size of the query due

to the use of the separation theorem [52]. Even for propositional
LTL, this translation is at least exponential and no approach less
than triply exponential is known [5]. An advantage of the history
encoding from [16,18] is that it can be implemented inside a
database system using views and triggers, which could yield a
good performance in spite of the possibly very large size of the
query. Generally, this option is the best of the three if the TQ
contains no future operators or if one can find a small equivalent
representation without future operators.
Third approach. The most general solution is based on the answer
terms described in Section 6. The presented algorithm is an
adaptation of the one in [16] and works directly with future
operators by introducing place-holder variables for future answers.
We have shown that this also achieves a bounded history encoding
while we can limit the influence of the future operators on the time
and space requirements to a single exponential factor. However,
it is not straightforward how to implement this approach inside
a database system. For that it remains to be investigated how
the implementation inside a database system described in [16]
can be extended to cover answer terms in an efficient way, in
particular in the presence of the place-holder variables. Even using
the normal form described in Definition 6.7, we still need to
store exponentially many sets of answer tuples, and it is not clear
whether they can be accessed through views. While theoretically
the most efficient solution, it remains to be seen how it performs
in practice in an optimized implementation.

8.2. Outlook

In future work, we want to implement our proposed algo-
rithm, and compare the performance of all three described approaches on realistic queries over temporal relational databases to
see which approach best suits context-aware applications. In par-
ticular, it is likely that the approach from Section 5.3 outperforms
the dedicated algorithm from Section 6 on certain kinds of TQs, e.g.,
queries with a small bound on the nesting depth of the temporal
operators.

On the theoretical side, we plan to investigate how to adapt
the algorithm to deal also with rigid n-ary predicates for n > 1.
It would also be interesting to find out whether one can extend
the bounded history encoding from Section 6 to deal with negation
in the query language if queries are assumed to be domain-
independent, which is already possible with the approaches in
[16,15].

Acknowledgments

This work was partially supported by the DFG in the Collaborative Research Center 912 (HAEC) and in the Research Training
Group 1763 (QuantLA). We also thank Franz Baader for helpful
discussions on the topics of temporal logics and monitoring, and
the anonymous reviewers for their suggestions for improving the
paper.

Appendix A. Proof of Theorem 4.1

Let Q1, Q2 be query languages and L be a logic that has the
canonical model property w.r.t. Q1 such that Q1-queries are Q2rewritable w.r.t. L. Then for every consistent TKB K = (Ai)0in, T ,
every temporal Q1-query , and every i, 0  i  n, we have
Cert(, K, i) = Ans(, IK, i) = Ans(T , DK, i).

For

(T

(T

and DK, i|=Q2 a2

It is left to prove the following two claims:

(2). By the induction hypothesis, DK, i|=Q2 a1

Proof. We first prove Cert(, K, i)  Ans(, IK, i). Take
a  Cert(, K, i). Then for every I = (Ii)0in with I |= K, we
have I, i|=Q1 a(). In particular, we get IK, i|=Q1 a(), which is
equivalent to a  Ans(, IK, i).
(1) Ans(, IK, i)  Ans(T , DK, i), and
(2) Ans(T , DK, i)  Cert(, K, i).
We show this by induction on the structure of .
For the base case, consider an atemporal Q1-query . For
(1), take a  Ans(, IK, i). Since  is a Q1-query, the semantics yields that a  Ans(, IKi
). By Q2-rewritability, we obtain
a  Ans(T , DKi
). Finally, the semantics of temporal Q2-queries
yields that a  Ans(T , DK, i).
For (2), take a  Ans(T , DK, i). Since T is a Q2-query, this
implies that a  Ans(T , DKi
). Because of Q2-rewritability, we
have a  Cert(, Ki). This means that for every interpretation I
with I |= Ai and I |= T , we have that I |=Q1 a(). Hence, for every sequence I = (Ii)0in with I |= K, we have Ii |=Q1 a().
Since  is a Q1-query, the latter condition is equivalent to
a  Ans(, I, i), and thus we get a  Cert(, K, i).
Let now  be of the form 1  2. For (1), assume that
IK, i|=Q1 a(), and thus we have IK, i|=Q1 a1
(1) and IK,
i|=Q1 a2
(T
1 )
and DK, i|=Q2 a2
2 ), and thus by the definition of T we get
DK, i|=Q2 a(T ).
(2), assume that DK, i|=Q2 a(T ), and thus DK,
i|=Q2 a1
(T
2 ). Hence, we have
1 )
a  Cert(1, K, i) and a  Cert(2, K, i) by the induction hy-
pothesis. Thus, for every I |= K it holds that I, i|=Q1 a1
(1) and
I, i|=Q1 a2
Let now  be of the form 1. For claim (1), we take IK,
i|=Q1 a( 1). By the temporal semantics, we have i < n and
IK, i + 1|=Q1 a(1). By the induction hypothesis, we get DK,
i + 1|=Q2 a(T
1 ). Since i < n, this implies that DK, i|=Q2 a(T )
by the definition of T .
For (2), let DK, i|=Q2 a(T ). Hence, we have i < n and DK,
i + 1|=Q2 a(T
1 ), which implies a  Cert(1, K, i + 1) by the induction hypothesis. Since i < n, this means that for every I |= K
we have I, i|=Q1 a( 1), which shows that a  Cert(, K, i).
For the next inductive case, let  be of the form 1 U 2.
For (1), assume that IK, i|=Q1 a(1 U 2), and thus there is a k,
i  k  n, such that we have IK, k|=Q1 a2
(2) and IK,
j|=Q1 a1
(1) for all j, i  j < k. By the induction hypothe-
sis, we obtain DK, k|=Q2 a2
2 ) and DK, j|=Q2 a1
(T
1 ) for all j,
i  j < k. The definitions of |=Q2 and T yield that
DK, i|=Q2 a(T ).
For (2), assume that DK, i|=Q2 a(T ). By definition of T , there
is a k, i  k  n, with DK, k|=Q2 a2
(T
1 )
j, i  j < k. The induction hypothesis yields
for all
a  Cert(2, K, k) and a  Cert(1, K, j) for all j, i  j < k. As
a consequence, we have for every I |= K that I, i|=Q1 a(1 U 2).
The remaining cases can be proven in a similar way. For exam-
ple, the case of 1 differs from 1 only in the fact that if i  n,
then the expressions IK, i|=Q1 a() and DK, i|=Q2 a(T ) are triv-

ially satisfied, instead of trivially false. The arguments for
and 1 can be obtained from those of 1 and 1 by replacing
i < n by i > 0 and i+1 by i1, and similarly for 1 S 2 and 1 U 2.
The cases of , ,
, and  follow by similar arguments. 

(2). This is equivalent to a  Cert(1  2, K, i).

2 ) and DK, j|=Q2 a1
(T

(T

Appendix B. Reduction of Section 5.3

In this part of the appendix, we describe how to rewrite a TQ 
into an equivalent temporal query  of the language of [16] in
order to apply the algorithm described in [16].

We first transform the TQ  into an LTL-formula f, which is

defined inductively on the structure of :


Q-query j
1  2
1  2


1 U 2
1 S 2

pj
f1  f2
f1  f2
false U< (f1  p)
false S< f1
false U< (f1  p)
first  false S< f1
f1  f1 U< p
f1  f1 S< (first  f1
f1  true U< (f1  p)
f1  true S< f1
f2  (f1  f1 U< (f2  p))
f2  (f1  f1 S< f2

This yields the following lemma, where Ia is defined as in
Section 5.3.
Lemma B.1. For all I = (Ii)0in, all a: FVar()  NC, and all
i, 0  i  n, we have I, i |= a() iff Ia, i |= f.
Proof. We prove this lemma by induction on the structure of .
For the base case of a Q-query  = j, we have:
I, i |= a(j)
iff Ii |= a(j)
iff pj  wi
iff Ia, i |= fj.
For the case  = 1  2, we have:
iff I, i |= a1
iff Ia1
iff Ia, i |= f1 and Ia, i |= f2
iff Ia, i |= f1  f2.
For the case  = 1, we have:
I, i |= a( 1)
i < n and I, i + 1 |= a(1)

(1) and I, i |= a2
, i |= f2

, i |= f1 and Ia2

I, i |= a(1  2)

(2)

iff
iff Ia, i + 1 |= p and Ia, i + 1 |= f1
iff Ia, i + 1 |= f1  p
iff Ia, i |= false U< (f1  p).
For the case  = 1, we have:
I, i |= a( 1)
i > 0 implies I, i  1 |= a(1)
i = 0 or i > 0 and I, i  1 |= a(1)

I, i |= a(1 U 2)
I, j |= a1

(1) for all j, i  j < k
, j |= f1 for all j, i  j < k

iff
iff
iff Ia, i |= first or i > 0 and Ia, i  1 |= f1
iff Ia, i |= first  false S< f1.
For the case  = 1 U 2, we have:
iff there is some k, i  k  n, such that I, k |= a2
(2) and
iff there is some k, i  k  n, such that Ia2
, k |= f2 and
iff there is some k, i  k  n, such that Ia, k |= f2 and Ia, j |= f1
iff there is some k  i such that Ia, k |= p and Ia, k |= f2 and
iff Ia, i |= f2 or there is some k > i such that Ia, k |= p and
iff Ia, i |= f2 or there is some k > i such that Ia, k |= f2  p and

Ia1
for all j, i  j < k
Ia, j |= f1 for all j, i  j < k
Ia, k |= f2 and Ia, j |= f1 for all j, i  j < k
Ia, j |= f1 for all j, i  j < k

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

 using

Ia, k |= f2  p and Ia, j |= f1 for all j, i < j < k

iff Ia, i |= f2 or Ia, i |= f1 and there is some k > i such that
iff Ia, i |= f2  (f1  f1 U< (f2  p)).
All the other cases can be shown analogously. 
After this, f is transformed into an equivalent LTL-formula f 
the separation theorem from [52].
Proposition B.2 ([52]). There is an LTL-formula f 
 in which no S<
occurs in the scope of an U< and no U< occurs in the scope of an S<
such that for every LTL-structure J and every i  0, we have J, i |= f
iff J, i |= f 

The formula f 
 by
replacing all variables that are in the scope an U< by falseand simplifying the resulting formula using the following equivalences:
true    
true    true
false    false
false    
false  true

true  false
 U< false  false
true U< true  true
false U< true  true

 is in turn transformed into the LTL-formula f 

 iff Ia, n |= f 

This yields the following lemma.
Lemma B.3. For all I = (Ii)0in and a: FVar()  NC, we have
Ia, n |= f 
Proof. According to the semantics of U<, every propositional
variable pj occurring in the scope of any number of nested U<
operators in f 
 is evaluated w.r.t. Ia only at time points n > n.
Thus, all of these occurrences can be replaced by false without
affecting the value of f 
 under Ia at time point n. Furthermore, the
equivalences listed above are clearly valid at any time point, and
thus also do not affect this value. 
Finally, we transform f 
defined recursively as follows:

 back into a TQ f 

. This transformation is

pj for j, 1  j  m

f1  f2
f1  f2
f1
f1 S< f2


true
f1  f2
f1  f2
f1
(f2  f1 S f2


 is satisfied by Ia at i.2

the variable assignment
w.r.t. I at time

As before, we can show that
a: FVar()  NC is an answer to the Past-TQ f 
point i, 0  i  n, if and only if f 
Lemma B.4. For all I = (Ii)0in, all a: FVar()  NC, and all
i, 0  i  n, we have Ia, i |= f 
Proof. We prove this by induction on the structure of f 

For a propositional variable pj, 1  j  m, we have Ia, i |= pj iff
I, i |= a(j) as in the proof of Lemma B.1. For p, we have Ia, i |= p
iff I, i |= true since p  wi holds for all i, 0  i  n.
For the Boolean operators ,, and , the claim follows
similarly as in the proof of Lemma B.1. It thus remains to show the
claim for subformulae of the form f1 S< f2. We have

 iff I, i |= a(f 

).


2 Note that FVar(f 


) = FVar().

Ia, i |= f1 S< f2
for all j, k < j < i

, j |= f1 for all j, k < j < i

iff there is some k, 0  k < i, such that Ia, k |= f2 and Ia, j |= f1
iff there is some k, 0  k < i, such that Iaf2
, k |= f2 and
iff there is some k, 0  k < i, such that I, k |= af2
iff

Iaf1
I, j |= af1
i > 0 and I, i 1 |= af2
(f2
such that we have I, k |= af2
j, k < j  i  1.
i > 0 and I, i  1 |= af2
iff
(f2
iff I, i |= a( (f2  f1 S f2
This finishes the reduction. Theorem 5.3 is now a simple consequence of the previous lemmata and the separation theorem.

) and
) or there is some k, 0  k < i 1
) for all
(f1
(f2
) or I, i  1 |= a(f1 S f2
)). 

) and I, j |= af1

) for all j, k < j < i

(f2

(f1

Appendix C. Proofs for Section 6

If  = 1  2, then

Lemma 6.3. The function 0 is correct for 0.
Proof. We prove by induction on the structure of the subqueries
  Sub() that evaln(0( )) is equal to Ans( , I(n), 0) for
all n  0. If  is an atemporal query, then evaln(0( )) =
Ans( , I0) = Ans( , I(n), 0).
evaln(0( )) = evaln(0(1))  evaln(0(2))
(n), 0)

(n), 0)  Ans(2, I
(n), 0),
and similarly for  = 1  2.
If  = 1, then evaln(0( )) =  = Ans( , I(n), 0); and
evaln(0( 1)) = NV = Ans( 1, I(n), 0).
If  = 1 S 2, then Proposition 3.4 yields that
evaln(0( )) = evaln(0(2))
(n), 0)
(n), 0).

= Ans(1, I
= Ans( , I

= Ans(2, I
= Ans( , I

If  = 1, then
evaln(0( )) = evaln(x
0 )

=Ans(1, I


(n), 1)

= Ans( , I

(n), 0).

If  = 1, then
evaln(0( )) = evaln(x
0 )

=Ans(1, I

(n), 1)

= Ans( , I

(n), 0).


if n > 0
if n = 0


if n > 0
if n = 0

(n), 0) Ans(1, I

If  = 1 U 2, then for n > 0 we have, by Proposition 3.4,
evaln(0( ))

0 )
= evaln(0(2)) evaln(0(1))  evaln(x

= Ans(2, I
= Ans( , I
(n), 0),
and for n = 0 we get

(n), 1)
evaln(0( )) = evaln(0(2)) evaln(0(1))  evaln(x
0 )
(n), 0)  

(n), 0) Ans(1, I

(n), 0)  Ans( , I

= Ans(2, I
= Ans( , I

(n), 0). 

i , which we do by

Since evaln is defined inductively on the structure of answer terms,
it suffices to show that for all n  i, we have evaln(xj
i1) =
evaln(update(xj
i1)). For this, we make a case distinction on the
form of  j.
i1) =
Ans(1, I(n), i). Since j1
is correct for i, this is the same as
evaln(j1

If  j = 1 or  j = 1, by definition we have evaln(xj

(1)) = evaln(update(xj
i1)).
If  j = 1 U 2, we have evaln(xj
i1) = Ans( j, I(n), i). Again,
( j)) =
is correct for i, this is the same set as evaln(j1

since j1
evaln(update(xj

i1)).

It remains to show i-boundedness of i = k

means of the following claim.
Claim 1. For every   Sub(), the answer term j
i1} and Var
only variables from Var

i1  {xj+1

i1 , . . . , xk

i ( ) contains

i1, . . . , xk

i1 by update(xj

i1). Since j1

i1 in the image of j1

i1}, and thus the claim is satisfied.
is obtained from j1

We prove this again by induction on j. For j = 0, we know from
i that for every   Sub() the answer term
the definition of 0
i ( ) contains only variables from Var

i and those occurring in
i1( ). Since i1 is monotone, it contains only variables from
i1  {x1
Var
Let now 0 < j  k and assume that the claim holds
for j  1. The function j
by replac-

ing every occurrence of xj
sat-
isfies the claim, it suffices to consider what happens to the
variable xj
. By assumption, this vari-
( ) if  j  FSub( ). Thus, it is
able can only occur in j1
enough to show that update(xj
i1) contains only variables from
Varj

 If  j =
equal to j1
contains only variables from Var1

Var1
every variable x
  FSub( j) \ { j}, and thus    j.
 If  j = 1 U 2, then update(xj
i1) = j1
j1
the variables with index i  1, we have j1
j1

1 or  j =
i1) is
(1). By the induction hypothesis, this term
i } and
i1}. Note that the second set is empty since
i1 must satisfy   FSub(1), i.e.,

. We prove this by a case distinction on the form of  j.
1, then update(xj
\ {xj

( j). Since
i only in the replacement of some of
( j) =

differs from 0
(2)  (j1
By the induction hypothesis, each j1

(1)  xj
i ).

i1  Var1

i1, . . . , xk

i1{xj

= Varj

(m), m = 1, 2,
i } and
i1}. By similar arguments as above, the sec-

= Varj

\ {xj

contains only variables from Varm
Varm
ond set is actually empty.

i1, . . . , xk

i1{xj

i and Var

This finishes the proof of Claim 1 and implies that for every
  Sub(), the answer term k
i ( ) contains only variables from
i1  , which concludes the proof of the lemma. 
Var
Lemma 6.10. There is a function f : N  N  N that is exponential
in the first component and polynomial in the second such that we can
compute each set Ans(, I(n)), n  0, in time at most f (||,||)
+ ||  t(||,||) and space at most f (||,||) + s(||,||).
Proof. At each time point, we have to compute the sets Ans( , In)
for all atemporal queries  occurring in , each time using
t(||,||) time and s(||,||) space (which can be reused). These

i are computed.

Fig. C.1. The order in which the mappings j
Lemma 6.4. If i1 is correct for i  1, then 0
Proof. We prove by induction on the structure of the subqueries
  Sub() that evaln(0
i ( )) is equal to Ans( , I(n), i) for all
n  i. The proof for most of the cases can easily be obtained from
that of the corresponding cases in Lemma 6.3 by replacing 0 by i, 1
by i + 1, and 0 by 0
i . We need to argue differently only for the
past operators.

is correct for i.

If  = 1 or  = 1, then

i ( )) = evaln(i1(1))

evaln(0

= Ans(1, I
= Ans( , I

(n), i  1)
(n), i)

(n), i). 

(n), i)  Ans( , I

If  = 1 S 2, then Proposition 3.4 yields that

since i1 is correct for i  1 < i  n.
i (2)) evaln(0
(n), i) Ans(1, I

i (1))  evaln(i1( ))
(n), i  1)

evaln(0
i ( ))
= evaln(0
= Ans(2, I
= Ans( , I
Lemma 6.5. If i1 is correct for i 1 and (i 1)-bounded, then we
can construct a function i: Sub()  ATi
 that is correct for i and
i-bounded.
Proof. We substitute all variables from Var
i1 by already computed answer terms of the form 0
i ( ). However, since these may
themselves contain other variables from Var
i1, we have to be careful about the order in which we do these substitutions. Since each

i ( ) can contain only variables that refer to subqueries of , by
replacing the variables for smaller subqueries first, we ensure that
all variables are eliminated.
For this, we consider a total order  1     k on the
set FSub() = { 1, . . . ,  k} with the property that whenever
 j  Sub( j
or
 j   j
. It is clear that such a total order exists and we fix one for
the following considerations.
For 1  j  k and   Sub(), we obtain the answer term

i ( ) by replacing every occurrence of xj

j1
j1
Finally, we set i := k
mapping from Sub() to ATi
which we obtain the families of answer terms j
i .
We now prove by induction on j that each j
i is correct for i.
For j = 0, this is shown in Lemma 6.4. Consider now j > 0.

( ) with
if  j = 1 or  j = 1;
if  j = 1 U 2.

) for j, j  {1, . . . , k}, we have j  j, i.e.,  j =  j

i is indeed a
. Fig. C.1 summarizes the process by

i . It is easy to verify that each j

i1 in j1

 :=

(1)
( j)

update

xj
i1

S. Borgwardt et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 5070

to j

exponentially large sets then become the atoms of the new answer
terms in 0
n . These terms additionally contain answer terms
n1( ) (in normal form) for the previous time point, which are
already exponential in |NV| and |FSub()|.
We have to be careful that the substitution process described
in the proof of Lemma 6.5 does not introduce an additional
exponential blowup in the size of . Each replacement step
from j1
n may replace exponentially many occurrences
of the same variable by exponentially large n-bounded answer
terms. However, by normalizing subterms j
n( ) that are already
n-bounded after every such step, we can ensure that subsequent
replacement steps again have to deal only with exponentially large
replacement terms. This local normalization thus has to be done
only for terms of the form given by the definition of 0
n , where each
component j
n( ) is already in normal form, and each component
n1( ) may contain exponentially many answer terms in normal
form. This can be done in exponential time in 2|FSub()| and
|NV|.

Thus, we can compute (a normal form of) n with exponentially
bounded resources. To compute Ans(, I(n)), by Lemma 6.9 it now
suffices to replace each variable by either  or NV and evaluate
the remaining set intersections and unions. 

Appendix D. Proofs for Section 7

Lemma 7.4. Let K = (Ai)i0, T  be a consistent infinite TKB. Then
there is a set R  R such that K(n)
R is consistent for all n  0, and for
every TCQ  and all i and n with 0  i  n, we have
Cert(, K(n), i) = Cert(, K(n)

R , i).

R is consistent.

:= , as
Proof. We construct R iteratively, starting from R0
follows. In each step, we add to Rj, j  0, all assertions P(c) with
P  NRP that are entailed by the knowledge base Ai  Rj, T  for
some i  0, which results in a new set Rj+1. We iterate this process
until no new assertions are added. Let now R be the final set
computed by this procedure and n  0. Obviously, every certain
answer to  w.r.t. K(n) at some i  0 is also a certain answer to 
w.r.t. K(n)
R at i. We show that all models of K(n) must also satisfy R
at each time point i, which proves the converse direction and the
fact that K(n)
Let I = (Ii)0in be such that I |= K(n) and assume that
there is an index i, 0  i  n, with Ii
|= R. Thus, there is
j > 0 and P(c)  Rj such that Ii
|= P(c). Since I respects the
rigid predicates, this actually holds for all i  0. By construction
of R, there must be an i  0 such that Ai  Rj1, T  entails
|= P(c), there must be an
P(c). Since Ii
assertion Q (d)  Rj1 such that Ii
|= Q (d), which again holds for
all i  0. We can iterate this argument until we arrive at the fact
that there must be an assertion R(e)  R0 such that Ii |= R(e). This
contradicts the fact that R0 = . 
Theorem 7.5. Let Q1, Q2 be query languages such that Q1 contains
only rooted CQs, and L be a logic that has the canonical model
property w.r.t. Q1 such that Q1-queries are Q2-rewritable w.r.t. L.
Let further K = (Ai)i0, T  be a consistent infinite TKB and R given
by Lemma 7.4.
Then for all n  0 there is a sequence of interpretations IK(n),R =
(Ji)0in such that for every temporal Q1-query , and all i,
0  i  n, we have
Cert(, K(n)

R , i) = Ans(, IK(n),R, i) = Ans(T , DK(n)

|= Ai, I |= T , and Ii

, i).

(with core Ii).

Proof. We start the construction of the sequence IK(n),R with the
:= IAiR,T , 1  i  n, employed in
canonical models Ii
Theorem 4.1 (but with Ai  R instead of Ai). By Definition 2.8, the
domains Ii of these canonical models are all countably infinite.
We define the set D  2NRP of subsets of NRP that contains exactly
the sets
(Ii, x) := {P  NRP | x  PIi}
for all i, 0  i  n, and x  Ii. We will now modify each Ii into a
new interpretation Ji such that for each Y  D there are countably
infinitely many individuals x  Ji with Y = (Ji, x).
To this end, consider i, n, 0  i  n, and Y  D. If Ii does
not contain any such individual, then we first have to add one.
Fortunately, from the definition of D we know that there must be
a j, 0  j  n, and x  Ij such that Y = (Ij, x). To be on
the safe side, we therefore construct the disjoint union I
i of all
interpretations in IK(n)

To ensure that there are even countably infinitely many such
individuals, we now define I
i as the countably infinite disjoint
union of I
i with copies of itself (as core we take any of the
copies). Finally, we ensure that all models have the same domain
 := NI (DN) and interpret the constants by the same domain
elements by applying a simple bijection between the domain of
for a  NI is simply
i and . In particular, each aI
each I
mapped to a, and every other element x  I
is mapped to some
i , x), l) with l  N. We denote the resulting interpretation
((I
by Ji and define IK(n),R := (Ji)0in.
We now show that IK(n),R is still a model of K(n)
R . By our closure
assumption on models in L, the interpretations Ji are still models
of T since they are simply (renamed versions of) unions of models
of T . They are also still models of Ai  R since the interpretation
of predicates on the constants was never changed. Furthermore,
the sequence IK(n),R respects the rigid predicates since the elements of D  N always satisfy exactly the rigid predicates given
by their first component, and every c  NC satisfies at least the
rigid predicates P for which P(c)  R. Assume now that we have
cJi  PJi for some P  NRP and c  NC, but P(c)  R. By construction of Ji, we thus also have Ii |= P(c). Since Ii is a canonical model
ofAiR, T  w.r.t. unary instance queries, all models ofAiR, T 
are also models of P(c). But then we must have P(c)  R by construction of R (see the proof of Lemma 7.4), which contradicts the
assumption that P(c)  R. This shows that every c  NC satisfies
exactly the rigid predicates P with P(c)  R in each Ji.
R that respects the rigid
predicates on the whole domain NI  (D  N). This is the
crucial property that allows us to show the first inclusion
R , i)  Ans(, IK(n),R, i) exactly as in the proof of
Cert(, K(n)
Theorem 4.1. Moreover, it directly follows from Theorem 4.1 that
Ans(T , DK(n)

Thus, IK(n),R is a model of K(n)

, i)  Cert(, K(n)

R , i).

For the remaining inclusion, we again employ induction on the
structure of . The only difference to the corresponding induction proof for Theorem 4.1 is the base case of a Q1-query; all the
other cases can be shown as before. But for every Q1-query  ,
Q2-rewritability of Q1-queries w.r.t. L implies that
Ans( , IK(n)

, i) = Ans( , Ii)

= Ans(T , DAiR,T )
= Ans(T , DK(n)
, i),

and thus it suffices to show that Ans( , IK(n),R, i) is a subset of
Ans( , IK(n)
For this, consider any a  Ans( , IK(n),R, i). Thus, there exists

a homomorphism  of a( ) into Ji, which can be used to define a

, i).

homomorphism  of a( ) into I
i by composition with the bijection between I
i and  (cf. Condition (ii) of Definition 2.5). Simi-
larly, we obtain a homomorphism  of a( ) into I
i by taking for
each z  Var()  NC as (z) the original element of I
i that
gave rise to the copy (z)  I
i . Finally, since a( ) is rooted and
the components in a disjoint union are not connected via the interpretation of predicates, the image of  must be contained in the
original domain of Ii. Thus,  is also a homomorphism of a( )
into Ii, i.e., we have a  Ans( , IK(n)

, i). 
