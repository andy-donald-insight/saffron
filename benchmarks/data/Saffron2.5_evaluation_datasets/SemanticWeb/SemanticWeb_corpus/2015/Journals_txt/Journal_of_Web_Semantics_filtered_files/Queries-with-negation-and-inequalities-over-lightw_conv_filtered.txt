Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

journal homepage: www.elsevier.com/locate/websem

Queries with negation and inequalities over lightweight ontologies
Victor Gutierrez-Basulto a, Yazmin Ibanez-Garcia a,b, Roman Kontchakov c,,
Egor V. Kostylev d,e
a Fachbereich Mathematik und Informatik, Universitat Bremen, Germany
b KRDB Research Centre, Free University of Bozen-Bolzano, Italy
c Department of Computer Science and Information Systems, Birkbeck, University of London, UK
d Department of Computer Science, University of Oxford, UK
e School of Informatics, University of Edinburgh, UK

a r t i c l e

i n f o

a b s t r a c t

While the problem of answering positive existential queries, in particular, conjunctive queries (CQs)
and unions of CQs, over description logic ontologies has been studied extensively, there have been few
attempts to analyse queries with negated atoms. Our aim is to sharpen the complexity landscape of the
problem of answering CQs with negation and inequalities in lightweight description logics of the DL-Lite
and EL families. We begin by considering queries with safe negation and show that there is a surprisingly
significant increase in the complexity from AC0 to undecidability (even if the ontology and query are
fixed and only the data is regarded as input). We also investigate the problem of answering queries with
inequalities and show that answering a single CQ with one inequality over DL-Lite with role inclusions is
undecidable. In the light of our undecidability results, we explore syntactic restrictions to attain efficient
query answering with negated atoms. In particular, we identify a novel class of local CQs with inequalities,
for which query answering over DL-Lite is decidable.

 2015 Elsevier B.V. All rights reserved.

Article history:
Received 30 July 2014
Received in revised form
2 June 2015
Accepted 5 June 2015
Available online 17 June 2015

Keywords:
Description logics
Ontological query answering
Conjunctive queries with negation
Inequalities
DL-lite

1. Introduction

In recent years, the use of ontologies to access data has become
one of the most prominent applications of description logic (DL)
technologies in the Semantic Web. In the ontology-based data access
(OBDA) setting, the plain data is enriched with the background domain knowledge, which is represented in the form of a DL ontology.
This distinguishing feature of the OBDA paradigm provides the user
with a friendlier vocabulary for accessing data and extends information systems with a means of querying potentially incomplete
data.

In classical database theory, conjunctive queries (CQs) have
long played a key role due to their attractive theoretical proper-
ties. Following in these footsteps, a vast amount of research on answering CQs in the context of OBDA has been conducted in the
last decade, so that we now have a fairly clear landscape of the

 Corresponding author.

computational complexity of answering CQs over both lightweight
and expressive ontology languages. Moreover, with the aim of
achieving a realistic use of OBDA in data-intensive Web applica-
tions, special efforts have been invested into the design of ontology
languages with the following two desirable properties. First, they
must be expressive enough to capture essential modelling aspects
of the application domain. Second, they must allow OBDA systems
to scale to large amounts of data. The latter can be achieved, for
example, by delegating query evaluation to a relational database
management system (RDBMS) or a datalog engine. DLs in the
DL-Lite [1,2] and EL [3] families were designed to meet these
two requirements and underpin, respectively, the OWL 2 QL and
OWL 2 EL profiles of the OWL 2 ontology language.1 Notably, answering CQs and unions of CQs (UCQs) over OWL 2 QL ontologies
is in AC0 in data complexity, which enables a pure query rewriting approach to query answering in this case. Intuitively, one can
rewrite a given query by including the knowledge provided by the
ontology into an SQL query, which can then be answered by the
RDBMS; see, e.g., [1,4] and references therein. Answering CQs (and

E-mail addresses: victor@informatik.uni-bremen.de (V. Gutierrez-Basulto),

ibanez@uni-bremen.de (Y. Ibanez-Garcia), roman@dcs.bbk.ac.uk (R. Kontchakov),
egor.kostylev@cs.ox.ac.uk (E.V. Kostylev).

1 www.w3.org/TR/owl2-profiles.

http://dx.doi.org/10.1016/j.websem.2015.06.002
1570-8268/ 2015 Elsevier B.V. All rights reserved.

UCQs) over OWL 2 EL ontologies is more complex, P-complete,
and a pure query rewriting approach is not possible anymore.
However, the so-called combined approach [5,6] allows one still to
delegate query evaluation to the RDBMS. Roughly speaking, in the
combined approach, not only the given query is rewritten but also
the data is completed with the knowledge of the ontology. A number of OBDA systems implementing these (and other) ideas have
been developed; see, e.g., [7,8] and references therein.

Conjunctive queries belong to the positive existential fragment
of first-order logic and therefore, lack any means of expressing
complementation or difference. However, some natural queries
require these constructs: for instance, retrieve all staff members
who do not belong to any trade union or retrieve all students whose
month of birth is not (i.e., different from) September. In order to
overcome these shortcomings, extensions of CQs with some form
of negation have been investigated in classical database theory
and in different areas related to management of (incomplete)
information, such as data exchange and reasoning about semistructured data. In particular, the following three forms of negation
have been advocated in the literature as important extensions of
CQs: safe negation (CQs), guarded negation (GNCQ) and inequalities
(CQ=). Recently, the DL community, with a similar motivation,
has also taken a look at extensions of CQs with safe negation and
inequalities [911].

A well-known fact from database theory is that answering CQs
with negated atoms can be much harder than answering plain
CQs; this is the case, for instance, for open-world query answering
under integrity constraints [12], query answering in the context
of data exchange [13] or query answering using materialised
views [14]. Rosati [9] and Gutierrez-Basulto et al. [10] showed
that the increase in the complexity is unfortunately dramatic in
the OBDA setting: in striking contrast to the highly tractable AC0
upper bound for data complexity of unions of CQs, the problems
of answering unions of CQs= and unions of CQss turned out
to be undecidable even over a very basic ontology language of
DL-Litecore. The situation is similar for safe negation over EL:
answering unions of CQss is undecidable. Remarkably, Klenke [15]
showed that in the language of EL extended with the empty
concept () or, alternatively, under the standard unique name
assumption (UNA), answering a single CQ= is also undecidable.
Interestingly, extending CQs and UCQs with negation has an effect
not witnessed before in ontological query answering: there is a
difference in the computational behaviour of unions of CQs and
single CQs. In particular, a proof of undecidability of answering
UCQss (or UCQs=) cannot be straightforwardly adapted to the
case of CQss (respectively, CQs=). The intuitive reason is that,
in the reduction of undecidable problems (such as the N  N-
tiling problem), each component of the union takes care of one
of the several conditions in the undecidable problem (colouring
condition, matching condition, etc.), and it is not entirely obvious
how to obtain a similar effect using a single query instead.

The addition of negation to CQs not only brings an increase in
the computational complexity but also introduces further technical difficulties for the development of algorithmic approaches since
negated atoms are not preserved under homomorphisms [17]. As a
consequence, to devise algorithms for answering CQs= and CQss
over lightweight DLs we cannot directly use techniques based on
the construction of the canonical model or the chase [1,6]. Due to
this reason, up to now, the only known results for answering CQs
with negation over lightweight DLs are coNP-hardness for answering CQs= and CQss over DL-Litecore [9,10], and the remarkable undecidability for CQs= over EL [15]. Hence, the aim of this article is
to sharpen the complexity picture for answering queries with safe
negation and inequalities over lightweight ontologies.

In view of the additional complexity introduced by the presence of negative atoms in CQs, we also explore different syntactic restrictions on CQss and CQs= proposed in the literature. A

robust approach to attain decidability for undecidable logics is to
allow only for guarded quantification; this is the case, for exam-
ple, of the guarded fragment of first-order logic and its extension with fixpoint operators [18,19]. Inspired by these ideas, the
notion of guarded negation was recently introduced in the context of decidable fragments of first-order logic, and later studied
as an extension of positive existential queries [20,16]. In partic-
ular, Barany et al. [16] showed that, under the open-world se-
mantics, answering first-order queries with guarded negation over
frontier-guarded tuple-generating dependencies (fg-tgds) is decid-
able. Using this result as a departure point, we study the impact of
guarded negation on answering CQss over lightweight DLs. In another line, we look at restrictions on inequality atoms. Specifically,
in the spirit of Arenas et al. [21], we investigate possible ways of
limiting the binding of the variables occurring in inequalities. Fi-
nally, it has been observed that the number of negated atoms in a
query can have an impact on the complexity [22,13,21,16]. So, we
analyse the influence of this parameter on the complexity of answering CQs with negated atoms over lightweight DLs.

Summary of the obtained results

Our contributions can roughly be divided according to the two
different forms of negation we explored: safe (including guarded)
negation and inequalities; see Table 1 for a summary.
For CQs with safe negation, we first construct a CQs with
a single negated atom and an ontology in ELI, an expressive
member of the EL family, such that answering the query over
the ontology amounts to checking whether the Turing machine
encoded in the ontology terminates on the input encoded in the
data. It follows that answering CQss over ELI is undecidable
even in the case where only the data is regarded as input (the
ontology and the query are fixed, which corresponds to the
data complexity). Having this result at hand, we describe how
ELI concept inclusions can be translated into a union of CQss
over a DL-Litecore ontology and thereby establish undecidability of
answering unions of CQss over DL-Litecore. We then show that
the union of CQss constructed in our undecidability proof can be
replaced (preserving answers) by a single CQs but at a price of
adding a number of concept and role inclusions to the ontology.
Consequently, answering CQss over DL-LiteH
core is undecidable.
(We note in passing that the transformation, however, is more
general and applicable to a large class of unions of CQss and
CQs= over ontologies in languages with role inclusions). Finally,
we refine the borderline of undecidability for answering unions of
CQss and observe that the result holds for a fixed union of three
CQss over DL-Litecore and a fixed union of two CQss over EL.
In the light of these negative results for safe negation we turn
to a more restricted form of negation, guarded negation. Since
frontier-guarded tuple-generating dependencies subsume ELI
and CQs with guarded negation can express negative constraints
in the ontology (concept and role inclusions with ), the results
by Barany et al. [16] apply to both ELI and DL-LiteH
core: answering
unions of CQs with guarded negation is in coNP in data complexity
and in P if each of the constituent CQs contains at most one negated
atom. We thus concentrate on establishing the matching lower
complexity bounds: we construct an ontology with one negative
concept inclusion (which belongs to all our DLs) and a CQ with
one unary negated atom for P-hardness and a CQ with two unary
negated atoms for coNP-hardness in data complexity.
The second form of negation in CQs we consider is inequalities.
First, we prove that answering CQs= over DL-LiteH
core is undecidable.
This result could be established using the method mentioned
above: since answering unions of CQs= over DL-Litecore
is
undecidable [10], one could use additional concept and role
inclusions to encode the union into a single query. Following

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Table 1
Summary of the data complexity results: C stands for C-complete;  and  with references indicate where the lower and upper complexity bounds are established.

DL-Litecore
undec. [Corollary 5]
coNP-harda
coNP  [Lemma 11]
P  [Lemma 10]

DL-LiteH
core
undec.
undec. [Theorem 8]
coNP

undec. [Theorem 14]
coNP-hardc
coNP-hard [Theorem 16]
in coNExpTime
P-hard [Theorem 15]
in ExpTime

undec. [9]
undec. [Theorem 13]
coNP-hard
in coNExpTime [Theorem 20]
P-hard
in ExpTime

any
 1 inequality

per CQ

UCQs
CQs

UCQ/CQ with guarded
negation

any
1 negation
per CQ

UCQ=
CQ=

UCQ/CQ with local
inequalities

undec. [9]
coNP-hardb
coNP

undec.
undec. [15]
coNP-hard

P-hard

undec.
undec. [Theorem 3]
coNP  [16]
P  [16]

undec.
undec.
coNP-hard

P-hard

a Theorem 9: undecidable for a union of three CQss, each with one negated atom.
b Corollary 6: undecidable for a union of two CQss, each with one negated atom (one of the components has guarded negation).
c Theorem 14: undecidable for a union of three CQs=, each with one inequality (two of the components have local inequalities).

this route we would, however, obtain a query with multiple
inequalities. Instead, we provide a more elaborate but direct proof
using a CQ= with a single inequality. Using the ideas developed for
safe negation, we also establish undecidability of answering unions
with at least three CQs= over DL-Litecore.
As the next step, we consider a restriction on the binding of
variables occurring in inequality atoms and identify a novel class
of CQs=, local CQs=, for which the query answering problem over
DL-LiteH
core ontologies is decidable. We also establish the lower
complexity bounds over DL-Litecore: P-hardness with one local
inequality and coNP-hardness with two local inequalities; only
coNP-hardness over DL-LiteH

core was known [9].

Related work

Inequalities in the OBDA setting were first introduced by Calvanese et al. [23,24], who showed, in particular, that in contrast to
answering CQs, answering CQs= over a very expressive DL DLR
is undecidable. Later, Rosati [9] proved undecidability of answering CQs with safe negation and inequalities over a fairly inexpressive DL AL. As discussed above, lightweight DLs were also analysed
by Rosati [9] and Gutierrez-Basulto et al. [10]. A non-monotonic
epistemic query language, EQL-Lite, was proposed by Calvanese
et al. [25]: it was shown that extensions of a number of query languages with negation over the epistemic S5 modality come with
no increase in the complexity of query answering. In the context
of Datalog, ontology languages with equalities in the head of the
rules have also been considered. Notably, Cali et al. [26] investigated a restriction on the interaction of equalities (in the form
of equality-generating dependencies) with Datalog constraints
that warranties decidability of the query answering problem. Re-
cently, Hernich et al. [27] presented extensions of Datalog with
non-monotonic negation under the well-founded semantics for
normal logic programs.

It is worth noting that other extensions of conjunctive queries
have also been considered in the framework of OBDA.
In
particular, Calvanese et al. [28] and Kostylev and Reutter [29]
studied aggregate queries; Bienvenu et al. [30,31] and Kostylev
et al. [32] explored regular path queries (RPQs) and their further
extensions.

Plan of the article

In Section 2, we introduce the basics of our DLs and
query languages. In Section 3, we focus on queries with safe
negation. We begin by presenting our undecidability results for
answering CQss and then show the lower complexity bounds for
answering CQs with guarded negation. In Section 4, we present

our results on answering queries with inequalities. We first
establish undecidability of answering CQs= with one inequality
over DL-LiteH
core. Then, in order to attain decidability, we introduce
a syntactic restriction on inequalities, show the lower complexity
bounds for this case and develop a decision procedure to prove
decidability of the restricted problem.

This article is an extended and improved version of the
conference paper [11]. Specifically, we extend our results along
two directions: the range of DLs includes ontology languages of
the EL family; the range of query languages includes CQs with
guarded negation (Section 3.3) and local inequalities (which is a
novel class that guarantees decidability, see Section 4.3). We also
improve the presentation of the proofs, establish close connection
between ELI concept inclusions and CQs with safe negation over
DL-LiteH
core ontologies and sharpen the undecidability boundary in
terms of the number and structure of CQs with safe negation over
DL-Litecore and extensions of EL.

2. Preliminaries

2.1. Ontology languages

Ontology languages use a vocabulary that comprises individual
names c1, c2, . . . , concept names A1, A2, . . . , and role names
P1, P2, . . .. Ontologies (TBoxes in the DL parlour) consist of concept
and role inclusions built from concepts and roles using the
constructors available in the ontology language, as described
below.

Roles R and basic concepts B in DL-Lite [2] are defined by the

following grammar:
R ::= Pi
| P
(1)
i ,
| R.
B ::=  | Ai
(2)
Roles of the form P
i are called inverse roles and concepts of the
form R are called unqualified existential restrictions. We identify
R with Pi if R = P
. A TBox in DL-Litecore is a finite set of positive
and negative concept inclusions of the following form, respectively:
B1  B2,
A TBox in DL-LiteH
negative role inclusions of the form
R1  R2,
Concepts in ELI [3] are constructed from concept names by means
of (qualified) existential restrictions and intersection; more precisely,
they are defined by the following grammar:
C ::=  | Ai

core can also contain a finite number of positive and

R1  R2  .

B1  B2  .

| R.C

| C1  C2,

C  .

where R is a role; see (1). An ELI TBox is a finite set of positive and
negative concept inclusions of the form
C1  C2,
An ELI TBox contains only positive inclusions. Existential restrictions of DL-Lite are a particular kind of existential restrictions in
ELI: R is a shortcut for R.. Thus, every concept inclusion in
DL-Lite is also a concept inclusion in ELI.
Concepts in EL are defined in the same way as in ELI except
that they cannot use inverse roles. An EL TBox is a set of positive
and negative inclusions for EL concepts, while an EL TBox contains
only positive inclusions.
An ABox A is a finite set of assertions of the form Ai(cj) and
Pi(cj, ck). A knowledge base (KB) K is a pair (T , A), where T is a
TBox and A an ABox. The size |T | (respectively, |A|) of a TBox T
(respectively, an ABox A) is the number of symbols required to
write it down.
An interpretation I = (I ,I ) is a non-empty domain I with
an interpretation function I that assigns an element cI
i  I to
i  I to each concept name
each individual name ci, a subset AI
Ai, and a binary relation PI

i  I  I to each role name Pi.

= cI

Remark 1. We do not adopt the unique name assumption (UNA),
which requires cI
, for all distinct individual names ci

and cj. Our results on safe and guarded negation in Section 3
clearly do not depend on this choice. For inequalities, the proofs
in Section 4, which concern DL-Lite, are applicable to the case of
UNA as well. Some undecidability and lower complexity bounds
constructions, however, can be streamlined if the UNA is adopted
(possible simplifications are indicated in the proofs). It is of interest
to note that CQ= answering over EL is tractable in general [9] and
undecidable if the UNA is adopted [15]. In the DL-Lite family, on the
other hand, the UNA does not make such a drastic effect because
the languages have negative concept inclusions (which can express
a sort of local UNA).
The interpretation function I is extended to roles and complex
(P

i )I = (d, d)  I  I | (d, d)  PI
(R.C)I = d  I | there is d  CI with (d, d)  RI,

concepts in the standard way:

I = I ,

(C1  C2)I = CI
The satisfaction relation |= is also standard:

1  CI
2 .

iff CI

1  CI
I |= C1  C2
2 ,
I |= C   iff CI = ,
1  RI
I |= R1  R2
iff RI
2 ,
2 = ,
1  RI
I |= R1  R2   iff RI
j  AI
cI
i ,
k )  PI
(cI
j , cI
i .

I |= Ai(cj)
I |= Pi(cj, ck)

iff
iff

A KB K = (T , A) is consistent (satisfiable) if there is an interpretation I satisfying all inclusions in T and assertions in A. In this case
we write I |= K (as well as I |= T and I |= A) and say that I
is a model of K (as well as of T and A). We also write T |=  if
a concept or role inclusion  is satisfied in all models of T ; in this
case we say that  is entailed by T .
Remark 2. In DL-LiteH
core TBoxes, we will often use concept
inclusions of the form B  C, where B is a basic concept and
C an ELI concept. This is justified because, given such a concept
inclusion, one can construct (in polynomial time) a DL-LiteH
core TBox
T which is a model conservative extension of : that is,

 T |=  and,
 conversely, every model of  can be extended to a model of T
by giving an interpretation to the fresh names in T .
Indeed, a concept inclusion of the form B  C1 C2 is equivalent to
two concept inclusions B  Ci, for i = 1, 2; and a concept inclusion
of the form B  R.C can be replaced by two concept inclusions
B  RC, R
C  C and a role inclusion RC  R; for more details
see, e.g., [2]. Therefore, the presence of concept inclusions of the
form B  C does not affect any of our results on DL-LiteH
core.

Note, however, that such a shortcut is not available in DL-Litecore

because it contains no role inclusions.

2.2. Query languages

A conjunctive query (CQ) q(x) is a first-order formula of the
form y (x, y), where x and y are tuples of variables and  is a
conjunction of concept atoms Ai(t) and role atoms Pi(t, t) with
t and t terms, i.e., individual names or variables from x, y. We
call variables in x answer variables and those in y (existentially)
quantified variables.
A conjunctive query with safe negation (CQs) is an expression
of the form y (x, y), where  is a conjunction of literals, that is,
positive (concept and role) atoms and negated atoms, such that
each variable occurs in at least one positive atom. A CQ1s is a CQs
with at most one negative atom. A CQs is said to be a conjunctive
query with guarded negation (GNCQ) if, for each negative atom,
the query contains a positive atom, a guard, containing all the
variables of the negative atom (thus, in contrast to general CQss,
all variables of any negative atom in a GNCQ must occur in the same
positive atom).
A conjunctive query with inequalities (CQ=) is an expression of
the formy (x, y), where  is a conjunction of positive atoms and
inequalities t = t, for terms t and t.
A union of conjunctive queries (UCQ) is a disjunction of CQs
that share the same tuple of answer variables; a UCQs and UCQ=
are defined accordingly. Without loss of generality, in this article
we always assume that the tuples of quantified variables in UCQ
components are pairwise disjoint.
Given a query q(x), we usually write q if x is clear from the
context (or irrelevant). The size |q| of q is the number of symbols
required to write it down.
We will often regard a CQ q (possibly, with negative atoms) as
a set of its atoms and assume that q contains P
i (t, t) if it contains
Pi(t, t) (and similarly for the negative atoms). We extend this
convention to basic concepts and assume that q contains unary
atoms B(t) and B(t) if it contains R(t, t), where B = R and
B = R. We will also associate with q an undirected graph, called
the primal graph of q, whose vertices are the terms of q and which
has an edge between t and t if and only if the query contains a
positive atom of the form R(t, t) (note that the negative atoms are
not taken into account).
A query q(x) is called Boolean if x is empty. A Boolean CQs q is
tree-shaped if does not contain individuals as terms and its primal
graph is a tree (a tree is any connected undirected graph without
simple cycles).
Let q(x) = y (x, y) be a query with x = x1, . . . , xk, I an
interpretation and  a map from the set of terms of q to I with
 (c) = cI, for all individual names c in q. We call  a match
for q in I if I (as a first-order model) satisfies  under a variable
assignment mapping each variable z of  to  (z). A k-tuple of
individual names c = c1, . . . , ck is an answer to q in I if there is
a match for q in I with  (xi) = cI
(in this case  is also a match
for the Boolean query q(c) in I). We say that c is a certain answer
to q over a KB K and write K |= q(c) if c is an answer to q in all
models of K. For a Boolean query q, if there is a match for q in every
model of K, that is, if the empty tuple is a certain answer, then we
say that the certain answer is yes (or that q has a positive answer
over K).

2.3. Canonical interpretation for DL-LiteH
core

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Let K = (T , A) be a DL-LiteH

core knowledge base. We can
consider the ABox A as an interpretation and extend the notation
for the satisfaction relation |= to roles: A |= R(c, c) abbreviates
P(c, c)  A if R = P and P(c, c)  A if R = P. Similarly, for
a basic concept B, we use A |= B(c) as a shortcut for A(c)  A if
B = A and for A |= R(c, c), for some c, if B = R.
The canonical interpretation CK of K is an interpretation with
the domain CK comprising all elements of the form dcR1...Rn, for
an individual name c and roles R1, . . . , Rn, n  0, such that
 if n  1, then there is a basic concept B with A |= B(c)
and T |= B  R1 but A |= R(c, c), for all c and R with
T |= R  R1;
 T |= R
and the interpretation functionCK defined for individual names c,
concept names A and role names P as follows:
cCK = dc ,
ACK = {dc | A |= B(c) and T |= B  A} 
n  A},

i1  Ri, for each i, 1 < i  n,

i1  Ri but T |= R

PCK = {(dc1

{dcR1...Rn | n  1, T |= R
, dc2
{(dcR1...Rn1
{(dcR1...Rn

) | A |= R(c1, c2) and T |= R  P} 
) | n  1, T |= Rn  P} 
, dcR1...Rn
) | n  1, T |= Rn  P}.
, dcR1...Rn1

It is well-known (see e.g., [2]) that a DL-LiteH

core knowledge base
K is consistent if and only if its canonical interpretation satisfies
all negative concept and role inclusions in the TBox. Moreover,
if K is consistent, then the canonical interpretation is a universal
model in the sense that it can be homomorphically mapped to any
other model of K. This means, in particular, that CK provides all the
information required for computing certain answers to any CQ or
UCQ q(x) over K:
K |= q(c)
The analogous claim fails for queries with negative atoms because
only sentences equivalent to positive existential formulas are
preserved under homomorphisms (Homomorphism Preservation
Theorem; for more recent results, see, e.g., [33]). In the sequel we
shall see that it has a dramatic effect on the complexity of query
answering.

iff CK |= q(c).

Finally, we note that canonical interpretations could similarly
be defined in ELI and its fragments but they are not needed in
this article.

2.4. Data complexity

In OBDA scenarios the size of the query and the TBox (ontology)
is usually much smaller than the size of the ABox (data). This is
why we explore the data complexity [34] of the query answering
problem, that is, we assume that only the ABox is considered as part
of the input. Formally, let T be a TBox and q(x) a query in one of the
classes defined above. We are interested in the following family of
problems:

CertainAnswers(q, T )
Input:
Question: Is c a certain answer to q(x) over (T , A)?

An ABox A and a tuple of individuals c.

3. Answering CQs with safe and guarded negation

In this section we study queries with safe and guarded
negation. Rosati [9] established initial results on the complexity of
answering such queries. Specifically, it was shown that answering
CQss over knowledge bases that admit so-called saturated models
(and, in particular, contain no negative inclusions) has the same
complexity as answering CQs; this result thus applies to EL, ELI
and the RDFS fragment of DL-Litecore. It was also shown that,
in contrast, answering unions of CQs with safe negation over
DL-LiteH
core and EL is undecidable. The proofs of the undecidability
results regard, along with the ABox, both the TBox and the
query as part of the problem input, which corresponds to the
combined complexity [34]. We begin this section by a transparent
reduction of the halting problem for deterministic Turing machines
to answering a single fixed Boolean CQ1s over ELI KBs with
a fixed TBox (Theorem 3), which proves undecidability of CQ1s
answering over ELI even in data complexity. Then, in Lemma 4
we establish a close correspondence between ELI TBoxes and
unions of CQs1s over DL-Litecore TBoxes, which in particular implies
undecidability of answering unions of CQs1s over DL-Litecore
in data complexity (Corollary 5). Another result following from
Theorem 3 is undecidability of answering unions of two CQs1s
over EL (Corollary 6); the case of one CQs is, however, left open.
We then proceed to show, in Lemma 7, that the union of treeshaped CQss in the proof of Corollary 5 can be replaced by a
single CQs and a number of role inclusions. Thus, we extend the
undecidability result to the problem of answering CQs with safe
negation over DL-LiteH
core. We point out that the transformation of
Lemma 7 is general and may be of wider interest; in particular, it
is also applicable to plain CQs and CQs with inequalities.
In Theorem 9, we explore the limits of undecidability and prove
that answering unions of three CQs1s over DL-Litecore (without role
inclusions) is undecidable. We leave the case of unions with one or
two disjuncts as an open problem.

Finally, we turn to the problem of answering CQs with guarded
negation, which is known [16] to be decidable and in coNP in
data complexity (in P for GNCQs with one negated atom) over
lightweight DLs, and establish matching lower bounds over a
DL-Litecore TBox with a single negative concept inclusion.

3.1. Safe negation: undecidability over ELI

In order to establish the required two-dimensional grid, we are

Our undecidability results are obtained by reduction of the
halting problem for deterministic Turing machines. The key
observation is that a configuration of a Turing machine (that is,
the content of the tape, the current state and the position of the
head at a particular step of a computation) can be written down
on a sequence of domain elements with a role, T, pointing to the
representation of the next cell of the tape. Then a computation of
the Turing machine can be thought of as a two-dimensional grid,
where another role, S, points to the representation of the cell in the
successive configuration.
going to use the following Boolean CQ1s q1:
x1, y1, z1, u1
(3)
It can be readily seen that in any interpretation I where q1 has a
negative answer, that is, I |= q1, for every four elements forming
the three sides of a square, there is a T-edge that completes the
square, as shown in Fig. 1. This property can also be expressed by
the following first-order sentence:
S(x1, y1)  T (x1, z1)  S(z1, u1)  T (y1, u1),
(3)
where all variables are universally quantified.
Indeed, sentence (3) holds in every model of a KB K if and only if query (3) has

S(x1, y1)  T (x1, z1)  S(z1, u1)  T (y1, u1).

Fig. 1. Completing the square with Boolean CQ1s (3).

a negative answer over K. In other words, sentence (3) is equivalent to the negation of the query. In the sequel, we will often prefer to represent Boolean CQs with safe negation (as well as with
inequalities) in their negated form, that is, as implications with all
variables universally quantified.

Once the grid has been established, we can use the expressive
description logic ELI to ensure that the elements of the grid
encode successive configurations in a computation of a given
deterministic Turing machine. This observation leads us to our first
undecidability result.
Theorem 3. There are a Boolean CQ 1s q and an ELI TBox T such
that the problem CertainAnswers(q, T ) is undecidable.

Proof. Given a deterministic Turing machine M, we construct a
TBox T and a query q such that M does not accept an input w
encoded as an ABox Aw if and only if (T , Aw ) |= q; note that
neither q nor T depends on w. By applying this construction to
a fixed deterministic universal Turing machine, i.e., a machine that
accepts its input w iff the Turing machine encoded by w accepts the
empty input, we shall obtain the required undecidability result.
Let M = ( , Q , q0, q1, ) be a deterministic Turing machine,
where  is an alphabet (containing the blank symbol ), Q is a
set of states, q0  Q and q1  Q are an initial and accepting
state, respectively, and : Q    Q    {1,+1} is
a transition function. Computations of M can be thought of as
sequences of configurations, with each configuration determined
by the content of all (infinitely many) cells of the tape, the state
and the head position. We are going to encode a computation
by domain elements arranged, roughly speaking, into a twodimensional grid.

More precisely, we use the following signature:

 role T points to the representation of the next cell on the
tape (within the same configuration) and role S points to the
representation of the same cell in the successive configuration;
 concepts Ca, for a   , encode the contents of cells in the sense
that a domain element belongs to the interpretation of Ca if the
cell contains symbol a;
 concepts Hq, for q  Q , indicate both the current state and
the position of the head: a domain element belongs to the
interpretation of Hq if the cell is under the head and the machine
is in state q;

are not under the head of the machine);

 concept H marks all other cells on the tape (that is, cells that
 and D , for q  Q and   {1,+1}, propagate
the head and no-head markers backwards and forwards along
the tape, respectively;

 concepts Dq

 concept I is required to ensure that the tape is initially blank

beyond the input word.

The grid is illustrated in Fig. 2, where the nodes are domain
elements and the grey rectangle highlights an initial configuration:
initially, the infinite tape contains the input padded with  and the
head is positioned over the first cell in state q0.

Fig. 2. Encoding computations of a Turing machine.

Cai

I(cn).

(ci) and T (ci, ci+1), for 1  i < n,

for (q, a) = (q, a,  ),
for a   ,
for q  Q ,
for q  Q ,
for q  Q ,

Let q be the Boolean CQ1s given by (3) and let T be an ELI
TBox containing the following concept inclusions:
Hq  Ca  S.(Ca  Dq
 ),
H  Ca  S.Ca,
Hq  D1  D+1,
T .Dq1  Hq,
T.Dq+1  Hq,
T .D1  H  D1,
T.D+1  H  D+1,
I  T .(I  C),
Hq1  .

(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
For every input w = a1 . . . an   , we take the following ABox
Aw with individual names c1, . . . , cn:
Hq0
(c1),
We claim that (T , Aw ) |= q if and only if M does not accept w.
Consider a model I of (T , Aw ) with I |= q. Then, by the definition of the ABox and (11), there exists an infinite sequence of (not
necessarily distinct) domain elements d1, d2, . . . that encode the
initial configuration in the sense that (di, di+1)  T I for all i  1,
d1  HI
q0, di  CI
ai , for each 1  i  n, and di  CI
 for all i > n.
By (6) and (10), di  HI for all i > 1. Then, by (4) and (5), there
i)  SI. Since I |= q, they
exist elements d
1, d
i+1)  T I for
form another T-connected sequence, that is, (d
all i, which represents the second configuration of the computa-
tion. Indeed, by (5), the symbols in the cells not under the head are
preserved by the transition. On the other hand, by (4), the symbol
in the cell under the head is changed according to the transition
function  of M, and the new head position and state are recorded
in the concept Dq
 . By (7) and (8), the recorded head position and
the state are passed onto the correct cell. Then, by (6), the domain
element representing the head, say, d
k, belongs to DI+1, whence,
by (10), all d
i with i > k belong to DI+1 and HI . Similarly, by (6)
i  HI , for all i < k. Therefore, again, all cells that are not
and (9), d
under the head belong to HI . By the same argument, there exists a
respective sequence of elements for each configuration of the com-
putation. Finally, (12) guarantees that the accepting state never occurs in the computation, that is, M does not accept w.

2, . . . such that (di, d

i, d

Conversely, if the computation of M on w is non-accepting, then
we can encode it by an infinite two-dimensional grid interpretation
satisfying (T , Aw ) but not q.

Since the problem of deciding whether a given deterministic
machine accepts a given input is undecidable, we obtain the claim
of the theorem. 

Unlike ELI, DL-Litecore does not have qualified existential
restrictions and so, we cannot propagate information about the
contents of the tape and the position of the head using concept
inclusions (4)(5) and (7)(11). Nevertheless, we show that ELI
concept inclusions can be encoded over DL-Litecore with the help
of additional concept inclusions and unions of CQss.

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

(13)

T (x2, y2)  R(y2, x2),

We illustrate the main idea of our second undecidability result
for answering unions of CQs1s over DL-Litecore on two examples.
Consider first the following Boolean CQ1s q2:
x2, y2
or in negated form:
T (x2, y2)  R(y2, x2).
(13)
It can be easily seen that I |= q2 if and only if I |= T  R,
for any interpretation I. Thus, one can think of a role inclusion
as a negated CQ1s. Then, by Remark 2, we can encode any ELI
concept inclusion of the form B  C, for a basic concept B, as
a DL-Litecore TBox and a Boolean UCQ1s. Note that a set of role
inclusions is true in an interpretation I if and only if none of the
corresponding queries have a positive answer in I, that is, their
union has a negative answer in I.
For our second example, consider an ELI concept inclusion
B1  R.B2  A. Evidently, this concept inclusion is satisfied in
I if and only if the following Boolean CQ1s has a negative answer
in I:

x, yB1(x)  R(x, y)  B2(y)  A(x).

So, we can also think of concept inclusions of the form C  A, for
an ELI concept C and a concept name A, simply as (tree-shaped)
Boolean queries with one safe negation.
Taking stock, any ELI concept inclusion can be encoded as a
DL-Litecore TBox and a Boolean UCQs, and we thus arrive at the
following lemma.

Lemma 4. For any ELI TBox T , one can construct a DL-Litecore TBox
T  and a Boolean UCQ 1s q such that
 every model I of T  with I |= q is also a model of T , and
 every model of T can be extended to a model I of T  with I |= q
by interpreting fresh names in T .

As a corollary of Theorem 3 and Lemma 4 we immediately
obtain undecidability of answering unions of CQs1s over DL-Litecore
KBs.
Corollary 5. There is a Boolean UCQ 1s q and a DL-Litecore TBox T
such that CertainAnswers(q, T ) is undecidable.

Observe that the TBox in the proof of Theorem 3 belongs to EL
except for concept inclusions (8), (10) and (12). Consider now a
UCQ1s comprisingx Hq1
(x) and queries (3) and (13). By replacing
the inverse role T in (8) and (10) by R and removing the negative
concept inclusion (12), we can strengthen the undecidability result
for UCQs over EL KBs established by Rosati [9].

Corollary 6. (i) There are a union q of two Boolean CQs1s and an
EL TBox T such that CertainAnswers(q, T ) is undecidable.
(ii) There are a union q of a Boolean CQ and two CQs1s, and an EL
TBox T such that CertainAnswers(q, T ) is undecidable.
(iii) There are a union q of a Boolean CQ and a CQ 1s, and an ELI
TBox T such that CertainAnswers(q, T ) is undecidable.

The last result is in stark contrast to P-completeness of answering
single CQss [9] and unions of CQs over ELI TBoxes [35].

Fig. 3. Matching CQs q obtained from q1  q2 in the extended model.

3.2. From UCQs to CQs: the case of DL-LiteH
core

T (x2, y2)  R(y2, x2);

(3)

We now proceed to show that under rather mild restrictions,
any union of tree-shaped Boolean CQss can be transformed into a
single Boolean CQs that has the same answers over knowledge
bases with TBoxes extended by a number of concept and role
inclusions. This will allow us to obtain undecidability of answering
a single CQs over DL-LiteH
core (in contrast to Corollary 5, which holds
for the language without role inclusions).
UCQs q comprising the two queries from Section 3.1:
q1 = x1, y1, z1, u1

S(x1, y1)  T (x1, z1)  S(z1, u1)
 T (y1, u1),

We illustrate the transformation by considering a Boolean

q2 = x2, y2
(13)
these queries are also given in negated form by (3) and (13),
respectively. Note first that the sets of variables in q1 and q2 are
disjoint, and therefore, we can merge them into a single CQs
without introducing a connection between the primal graphs of
the constituents. Then, we take a fresh variable x and consider a
Boolean CQs q that consists of all the atoms of q1 and q2 together
with G1(x, x1) and G2(x, x2), where G1 and G2 are fresh role names;
see Fig. 3 on the right.
The resulting CQs q is in general not equivalent to q. However,
we can guarantee that, for any TBox T satisfying some mild
restrictions (to be defined below), there is a TBox T  such that the
union q has the same answer over (T , A) as q over (T  T , A).
The extension TBox T  is constructed in such a way that from any
model I of (T , A) we can obtain a model I of (T  T , A) that
coincides with I on I and satisfies the following properties:
1. the interpretation of a special concept name D contains every
2. for each CQs qi in the union q and every d in the interpretation
of D, there is a map that sends xi to d and matches all atoms
(including the negative ones) of the merged q except, possibly,
the atoms of qi.
For example, consider a model I of T with a single T-edge
(d, d); see the black arrow in Fig. 3 on the left. According to Item 1,
the extended TBox should guarantee that both d and d belong to
the interpretation of D in the model I of T T . By Item 2, it should
also guarantee that d has the dark-grey fragment attached to it to
match all atoms of q but q1 and the light-grey fragment to match
all atoms of q but q2 (d should also be in the interpretation of D
and, hence, have similar fragments in I, but they are not depicted

domain element in I;

2 .G1.Q1,
1 .G2.Q2,

Q1  T .S  S.N1,
Q2  T  N2,

to reduce clutter). Moreover, it should be clear that q has a positive
answer in I if and only if either q1 has a positive answer in I (the
rest of q is matched by the light-grey fragment) or q2 has a positive
answer in I (the rest of q is matched by the dark-grey fragment),
which is the same as their union, q, having a positive answer in I.
The fragments required to match the positive atoms of q1 and
q2 can easily be generated, for example, by the DL-LiteH
core concept
inclusions
D  G
(14)
D  G
(15)
where Q1, N1, Q2 and N2 are fresh concept names (see Fig. 3).
We also need the following negative concept inclusions to ensure
that the negative atoms of q1 and q2 can always be matched in
the respective fragments of the model generated by the positive
inclusions (14)(15):
N1  T   and N2  R  .

(16)
We now generalise the intuition above and show that we can
apply this transformation to a union of an arbitrary number of treeshaped CQss.
It should be clear that any tree-shaped Boolean CQs gives rise
to a DL-LiteH
core TBox similar to (14)(16). To make sure that the
negative concept inclusions of the form (16) are not inconsistent
with the positive inclusions of the form (14)(15), we require an
additional definition. We say that a variable z in a CQs q is T -loose
(or loose, if T is clear from the context) in case T |= B1  B2,
for each pair of atoms B1(z) and B2(z) in q (to simplify notation,
the Bi refer here to basic concepts; similarly to positive atoms, the
query is assumed to contain P(z1) and P(z2) if it contains
P(z1, z2)). For instance, in the example above, variable y1 is loose
in q1 provided that the original TBox does not entail S  T;
in other words, if (the interpretation of)S may contain a domain
element that is not in Totherwise the first negative inclusion
in (16) would imply emptiness of D with the extended TBox
(indeed, the S-successor of an element in Q1 would have to belong
to S and N1, which are subsets of the disjoint T and N1,
respectively). Also, u1 is loose in q1 if the original TBox does not
entailS  T; similarly, both x2 and y2 are loose in q2 provided
that the original TBox does not entail T  R and T  R,
respectively. Note, however, that both of these concept inclusions
will hold in any interpretation I with I |= q2 because the query
encodes the role inclusion T  R. These examples show that
the requirement for each negative atom to have a loose variable
is not particularly restrictive and, in fact, not much stronger than
simply non-entailment of the negation of the constituent CQs by
the original TBox alone.
core TBox and q a Boolean UCQ s such
Lemma 7. Let T be a DL-LiteH
that each component qi of q is tree-shaped and each negative atom in
each qi contains a T -loose variable. Then there exist a DL-LiteH
core TBox
T  and a CQ s q such that
(T , A) |= q iff (T  T , A) |= q, for every ABox A.
Proof. Let qi be of the form yi i(yi), for 1  i  n. Since treeshaped queries contain no individuals, each yi is non-empty and
we can fix a variable, say, yi1, in each yi. Let y be a fresh variable
and, for each 1  i  n, let Gi be a fresh role name. Define
i (y, yi) = Gi(y, yi1)  i(yi), where i is the result of replacing

each concept name A with a fresh A and each role name P with a

fresh P in i. Consider
q = y y1 . . . yn


i (y, yi).

1in

Since each 

Let D be a fresh concept name. Let TD consist of A  A and A  D,
for each concept name A occurring in T or q, and P  P,P  D and
P  D, for each role name P in T or q. Thus, in any model of TD,
the interpretation of D contains the interpretations of all concepts
of T and q, including domains and ranges of its roles.

i (y, yi) is tree-shaped, we can assume that its
primal graph is a rooted tree with root y (so that each edge has
a natural orientation away from the root); by construction, the
root has a single successor, yi1. We write z  z if z is a (unique)
immediate predecessor of z in one of these trees. For each edge
(z, z) with z  z, we take a fresh role Ezz. Let TG contain the
following inclusions, for all 1  i  n:

for 1  j  n with j = i,
for k = 0, 1,

for z  z  z,
for all A(z) in i,
for all R(z, z) in i,
for all A(z) in i,
for all R(z, z) in i with loose z,

D  G
(17)
i,0,
Gi,0  Gj,1,
(18)
Gi,k  Gi,
(19)
Gi,1  Eyyi1
(20)

zz  Ezz ,
(21)
zz  A,

(22)
Ezz  R,
(23)
zz  A  ,

(24)
zz  R  ,

(25)
where Gi,0 and Gi,1 are fresh role names. Let T  = TD  TG. Note
that it is crucial that z is loose in both (24) and (25)for otherwise
T T  would imply emptiness of any interpretation of D. We claim
that T  and q are as required.
Suppose that (T , A) |= q and let I be a model of (T  T , A).
As I |= (T , A), we have I |= q. So, for some i, 1  i  n, there
exists a match  for qi in I. Since the negations in q are safe,  (yi1)
belongs to AI, for some concept name A in T , or to (R)I, for some
role R in T ; whence,  (yi1)  DI. Let q consist of all atoms of q
that are not in i(yi). Since I |= TG, there exists a match  for q
in I with (yi1) =  (yi1). Indeed, by (20)(23), the tree of the
positive atoms of q can be matched in the tree rooted in the G
i,0-
successor of  (yi1); by (24) and (25), the negative atoms are also
matched by . Hence,    is a match for q in I.
Conversely, let I be a model of (T , A) with I |= q. Denote by
I0 an interpretation that coincides with I on all individuals and
concept and role names of T or q, and, additionally, interprets D
by I, and A and P by AI and PI, for each concept name A and
role name P in T or q. By construction, I0 |= (T  TD, A) and
I0 |= q. Denote by Cd the canonical interpretation of (TG,{D(d)}),
for d  I0 (we slightly abuse notation here and treat domain
elements as fresh individual names assuming that dCd = d). By
definition, each Cd is finite and their domains are pairwise disjoint.
Let I be the union of I0 with all Cd, d  I0. Since each negative
atom of q contains a loose variable, I does not violate any negative
|= (T  T , A).
inclusions of TG, that is, (24) and (25). Thus, I
Finally, for the sake of contradiction, suppose I |= q. Then there
is a match  for q in I. By the definition of q,  (y) must be
the element in one of the Cd introduced to witness the existential
restriction in (17). By (18), atoms corresponding to one of the
components, say qi, of q must be matched in the part of the original
model I0, contrary to I0 |= qi, for all i, 1  i  n. 
Consider now the UCQs and the TBox obtained in the proof of
Corollary 5 from the query and the TBox in the proofs of Theorem 3
and Lemma 4. It can be verified that the components of the UCQs
are tree-shaped and satisfy the conditions of Lemma 7. Thus, we
obtain undecidability of CQs answering over DL-LiteH
Theorem 8. There exist a Boolean CQ s q and a DL-LiteH
such that CertainAnswers(q, T ) is undecidable.

core TBox T

core KBs.

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Fig. 4. Quadruples  = (qa, qa, q+a+, qa).

This solves the open problem of decidability of CQs answering
over DL-LiteH
core [9]. However, since role inclusions are required
in the transformation in Lemma 7, the decidability of the CQs
answering problem over DL-Litecore remains open. On the other
hand, by Corollary 5, answering unions of CQss over DL-Litecore is
undecidable. The number of queries in the union constructed in the
proof of Corollary 5 depends, however, on the size of the alphabet
and the number of states of the universal Turing machine (more
precisely, it is (2|Q|+1)| |+4). We can strengthen the negative
result to a union of only three queries.
Theorem 9. There exist a union q of three Boolean CQs1s and a
DL-Litecore TBox T such that CertainAnswers(q, T ) is undecidable.
Proof. The proof again is by reduction of the halting problem for
deterministic Turing machines. Let M = ( , Q , q0, q1, ) be a
deterministic Turing machine; see the proof of Theorem 3.
Similarly to the construction in the proof of Theorem 3, we represent computations of M in a two-dimensional grid, where role T
points to the representation of the next cell on the tape and role S
to the representation of the same cell in the successor configura-
tion. However, we now use a role E to relate the representation of
a cell containing a   in a configuration with state q  Q and
the head positioned over the cell to an individual eqa; if the head is
not over the cell, then its representation is E-related to ea, where
 is a no-head marker; the representation of the cells in the initial
configuration beyond the input word is E-related to a special individual e, where  is a tape initialisation marker. We abbreviate
pairs (q, a)  (Q  {,})   simply as qa and say that a cell
contains such qa if it contains a and either it is under the head in
the state q  Q or it is not under the head and q  {,}.

Consider a set TM of quadruples of the form

(qa, qa, q+a+, qa)
that are defined by the transition function : if cells i1, i and i+1
contain pairs qa, qa and q+a+, respectively, then the cell i contains pair qa in the successive configuration; see Fig. 4. Note that,
since M is deterministic, the pair qa is determined uniquely. We
also include special quadruples in TM for initialisation of the tape
beyond the input word: for a, a   ,
(a,a,,a),
We assume that the input word contains at least three symbols,
and so none of the first three cells of the tape contain .
In addition to individual names eqa for the pairs qa, take an individual name e for each quadruple   TM. Let P, P, P+ and P
be role names and let ABox AM contain assertions
P(eqa , e ), P(eqa, e ), P+(eq+a+ , e ), P(e , eqa ),

(,,,).

(a,,,),

Fig. 5. The last two components of the query in the proof of Theorem 9.

for each quadruple  = (qa, qa, q+a+, qa) in TM. Also, the
ABox AM uses a fresh concept name N to mark all the pairs with
the accepting state q1  Q and contains
N(eq1a),

for all a   .

Another ABox, Aw, encodes an input w = a1, . . . , an    on

T (c0, c1), E(c1, eq0a1
for 1 < i  n,

the tape as follows:
T (c0, c0), E(c0, e),
T (ci1, ci), E(ci, eai
),
T (cn, cn+1), E(cn+1, e), I(e),
where c1, . . . , cn are fresh individual names, corresponding to the
cells of the input, c0 and cn+1 are special individuals placed before
and after the input word in the initial configuration of the tape,
and I is a fresh concept name for initialisation of the tape beyond
the input (note that there is a T-loop in c0).
Consider now a union q of the following three CQs1s given in

),

(27)
(28)

T  T ,

E  N  .

negated form (see Fig. 1 for the first and Fig. 5 for the last two):
S(x, y)  T (x, z)  S(z, u)  T (y, u),
E(x, y)  P(y, z)  S(x, x)  P(z, y) 
T (x, x)  E(x, y)  P(y, z) 
T (x, x+)  E(x+, y+)  P+(y+, z)  E(x, y),
T (x, x+)  E(x, y)  I(y)  E(x+, y).
Let TBox T contain
T  S,
We claim that (T , AMAw ) |= q if and only if M does not accept w.
Consider a model I of (T , AM  Aw ) with I |= q. Then there
exists an infinite sequence of (not necessarily distinct) domain elements d0, d1, d2, . . . that encode the initial configuration in the
sense that (d0, d0)  T I, (di, di+1)  T I for all i  0, and each
element is connected by the interpretation of E to the element of
the corresponding pair, that is, EI contains (d0, eI
),
), for 1 < i  n, and all (di, eI), for i > n. Note that
all (di, eIai
d0 = cI
0 is an auxiliary element before the tape, whose role is to
match the (positive part of the) second component of q for the representation of the first cell, and e serves as a substitute for e,
which is necessary, along with concept I and the third component
of q, to initialise the tape beyond the input. By the first TBox inclu-
sion, there exists a sequence of elements d
2, . . . such that
i)  SI. By the first component of q, they form another T-
(di, d
i+1)  T I for all i. Moreover,
connected sequence, that is, (d
since d0 has a T I-loop, d
0 also has a T I-loop. By AM and the second component of q, the sequence represents the second configuration of the computation in the same way, except that now e is
not used: instead, by the tape initialisation quadruples, all the cells
beyond the working space are EI-connected to e. Note that d

), (d1, eI

1, d

0, d

i, d

(26)

q0a1

abV. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Fig. 6. GNCQs in the proofs of Lemmas 10 and 11.

is also EI-connected to e. By the same argument, there exists a
sequence of elements for each configuration of the computation.
Finally, the negative concept inclusion in T and assertions in AM
guarantee that the accepting state never occurs in the computa-
tion, and so, M does not accept w.

Conversely, if M has a non-accepting computation on w, then it
is routine to construct an infinite two-dimensional grid-like interpretation I satisfying (T , AMAw ) but not q (all domain elements
in the bottom row of the grid have a T I-loop). 

We note in passing that the query q in the proof of Theorem 9

is not tree-shaped, and therefore Lemma 7 is not applicable.

3.3. Guarded negation: decidability

In this section we narrow down the class of CQs with safe
negation and concentrate on guarded negation. As follows from
the results by Barany et al. [16], answering unions of GNCQs over
ontologies in the language of the so-called frontier-guarded tuplegenerating dependencies (fg-tgds) is decidable and in coNP in data
complexity; moreover, it is in P in data complexity if each GNCQ
in the union contains at most one negated atom. Observe that
(i) ELI concept and role inclusions are a particular form of frontierguarded tgds, and that (ii) negative concept and role inclusions can
be viewed as negated CQs. Therefore, the upper complexity bounds
also apply to ELI and DL-LiteH
core KBs. We establish the matching
lower complexity bounds even for a TBox T0 containing a single
negative concept inclusion
V  F  
(by definition, T0 is in both EL and DL-Litecore).
Lemma 10. There exists a Boolean GNCQ q with one negated atom
such that the problem CertainAnswers(q, T0) is P-hard.
Proof. The proof is by reduction of the complement of Horn-
3SAT, the satisfiability problem for Horn clauses with at most three
literals, which is known to be P-complete; see, e.g., [36]. Suppose
we are given a conjunction  of Horn clauses of the form p, p
and p1  p2  p, where p, p1 and p2 are propositional variables.
Consider a Boolean GNCQ q with the following negated form:
N1(x1, y)  V (x1)  N2(x2, y)  V (x2)  R(y, z)  V (z);
see Fig. 6 (a). Note that q does not depend on .
Next, we construct an ABox A such that  is satisfiable iff
(T0, A ) |= q. The ABox A uses an individual name cp for each
variable p in  and an individual name c for each clause  of the
form p1  p2  p in . For every clause  , the ABox A contains
the following assertions:

V (cp),
F (cp),
, c ), R(c , cp),

if  = p,
if  = p,
if  = p1  p2  p.

N1(cp1

, c ), N2(cp2

Suppose first there is a model I of (T0, A ) with I |= q. We
show that  is satisfiable. Observe that, for each clause  of  of
the form p1 p2  p, if both cI
 V I, then cp  V I.
Thus, we can define a satisfying assignment a for  by taking a(p)
true iff cI
a model I of (T0, A ) with I |= q. 

Conversely, if  is satisfiable, then we can evidently construct

 V I and cI

p  V I.

p1

p2

2, where each pi and p

Lemma 11. There exists a Boolean GNCQ q with two negated atoms
such that CertainAnswers(q, T0) is coNP-hard.
Proof. The proof is by reduction of the complement of 2+2SAT,
the satisfiability problem for clauses with two negative and two
positive literals, which is known to be NP-complete [37]. Suppose
we are given a conjunction  of clauses of the form p1  p2 
1  p

i is either a propositional variable or
one of the two propositional constants, true and false. Consider a
Boolean GNCQ q with the following negated form:
N1(x1, y)  V (x1)  N2(x2, y)  V (x2) 
R1(y, z1)  R2(y, z2)  V (z1)  V (z2);
see Fig. 6 (b). Observe that the query is similar to the one in the
proof of Lemma 10 except that now we have two Ri-atoms instead
of one R-atom. Note again that q does not depend on .
Next, we construct an ABox A such that  is satisfiable iff
(T0, A ) |= q. The ABox A uses individual names ctrue and cfalse
for the two constants, an individual name cp for each variable p in
 and an individual name c for each clause  in . It contains
V (ctrue), F (cfalse) and the following assertions, for every clause  of
the form p1  p2  p
N1(cp1
, c ),

2 in :
R1(c , cp

, c ), N2(cp2

R2(c , cp

1  p

2, if both cI
p1

 V I or cI

1p
 V I. Since we have cI

Suppose first there is a model I of (T0, A ) with I |= q. We
show that  is satisfiable. Observe that, for each clause of  of the
formp1p2p
 V I, then either
false  V I, a
cI

satisfying assignment a for  can be defined by taking a(p) true iff
p  V I.
cI
Conversely, if  is satisfiable, then we can evidently construct
a model I of (T0, A ) with I |= q. 

true  V I and cI

 V I and cI

p2

),

).

Summing up, we obtain the following result.

Theorem 12. The problems of answering GNCQs and unions of
GNCQs over DL-Litecore, DL-LiteH
core, EL and ELI KBs are coNPcomplete in data complexity. The problems are P-complete if the GNCQ
and each component in the union, respectively, have at most one
negation.

4. Answering CQs with inequalities

In this section we first prove that CQ= answering over DL-LiteH
core
is undecidable, even if only one inequality may be used. Over
DL-Litecore, we show undecidability for unions of three CQs=, as
well as P- and coNP-hardness for CQs=. We then observe that
one of the reasons for undecidability is applying inequalities to
the non-ABox elements in interpretations and identify a class of
CQs=, local CQs=, that require at least one of the arguments in any
inequality to be an ABox element. We show that this restriction
guarantees decidability of the query answering problem.

4.1. CQs with inequalities over DL-LiteH

core: undecidability

We begin by establishing undecidability of CQ= answering over
DL-LiteH
core. In principle, the technique of Lemma 7 could be adapted
to queries with inequalities and by using, e.g., a modification of
the proof of Theorem 1 in [10], this would prove the claim. The
resulting CQ= would, however, contain many inequalities. Instead,
we substantially rework some ideas of the undecidability proof for
CQ= answering over EL [15] and show that even one inequality
suffices for DL-LiteH
core.

ab194

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Fig. 7. CQ= in the proof of Theorem 13.

Fig. 9. Proof of Claim 13.1.

More formally, the domain elements in the shaded area enjoy

01, d

11), (d

01)  T I and (d

the following property.
Claim 13.1. If I |= TG and I |= q, then for every d  I with an
SI-successor and a T I  SI-successor,
(a) SI is functional in any T I-successor of d,
(b) T I is functional in any SI-successor of d,
(c) all T I  SI- and SI  T I-successors of d coincide,
(d) (T)I is functional in any T I  SI  T I-successor of d,
(e) RI is functional in any T I  SI  (R)I-successor of d.
Proof of Claim. There are domain elements d10, d01, d11 such that
(d, d10)  SI, (d, d01)  T I and (d01, d11)  SI.
11)  SI; see Fig. 9 (a).
(a) Let (d, d
01, d
Since I |= TG, the element d10 has a T I-successor d, which in
turn has a T I-successor too; each of d11, d
11 and d
11 has an RIpredecessor (not shown in Fig. 9 (a)). As I |= q, each of d11, d
11 and

11 coincides with d and thus, SI is functional in any T I-successor
of d.
11)  T I; see Fig. 9 (b).
(b) Let (d, d
Since I |= TG, the element d10 has a T I-successor d, which in turn
has a T I-successor too; also, d11 has an RI-predecessor (not shown
11 have T I-successors. As I |= q,
in Fig. 9 (b)); and both d
each of d, d
11 and d
11 coincides with d11. So, T I is functional in any
SI-successor of d.
(c) Is not difficult to see now that all T I  SI-successors and all
SI  T I-successors coincide. Denote this element by d.
(d) and (e) By item (c), (T)I is functional in any T I-successor of
d and RI is functional in any RI-predecessor of d.

10)  SI and (d

11 and d

11), (d

10, d

10, d

Fig. 8. The grid structure in the proof of Theorem 13.

Theorem 13. There exist a Boolean CQ = q with one inequality and a
DL-LiteH
core TBox T such that CertainAnswers(q, T ) is undecidable.
Proof. Similarly to the proof of Theorem 3, we reduce the halting problem for deterministic Turing machines to CertainAn-
swers(q, T ). We also use a two-dimensional grid formed by roles T
and S. This time, however, the grid is established (along with functionality of certain roles) by means of a Boolean CQ= q with the
following negated form:
S(x, y)  T (x, z)  S(z, v)  T (y, u) 
T (u, w)  T (u, w)  R(t, v)  R(t, v)  (u = v).
Note that this sentence, in fact, implies v = v = u = u; see the
shaded area in Fig. 7.
We present the construction of the TBox T in a series of steps.
As an aid to our explanations, we assume that an interpretation
I with I |= q is given; for each of the building blocks of T we
then show that if I, in addition, is its model, then I enjoys certain
structural properties. We say that the interpretation PI of a role P
is functional in d  I if d = d whenever both (d, d) and (d, d)
are in PI. We also denote the composition of binary relations by ,
for example:

SI  T I =(d, d) | (d, d)  SI , (d, d)  T I.

Let the first part, TG, of the TBox contain the following concept

T  T ,

S  R.

inclusions:
S  T ,
We claim that if I |= TG and I |= T  S, then the fragment
of I rooted in element d11  (S.T)I has a grid structure of
the shaded area in Fig. 8 (each domain element in (S)I also has
an RI-predecessor, which is not shown). Note that TG ensures that
domain elements in (S)I only have T I- and (R)I-successors
but not necessarily SI-successors (existence of SI-successors will
be guaranteed by concept and role inclusions (31)(33), (41), (42)
and TF to be defined below).

So, SI and T I are functional in all domain elements in the
shaded area. However, SI does not have to be functional in the
bottom row and T I in the left column (see Fig. 8); (T)I is
functional in all domain elements in the shaded area except its
bottom row but it does not have to be functional elsewhere; RI
does not have to be functional anywhere but in RI-predecessors of
the domain elements in the shaded area; finally, (S)I and (R)I
do not have to be functional anywhere. For our purposes, however,
it suffices that I has a grid structure starting from d11; moreover,
as we shall see, the non-functionality of (S)I plays a crucial role
in the construction.
In addition to the grid-like structure of SI and T I, we also need
functionality of SI in domain elements outside the grid. Besides
this, we require role R to be functional not only in RI-predecessors
of the grid elements but also in the grid elements themselves. To
this end, we use a technique similar to the proof of Lemma 7.
Claim 13.2. Let I |= TG and I |= q.
(a) If I satisfies
E  T.S,
then SI is functional in every d  EI.

(29)

abV. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

(30)

(b) If I satisfies

D  R.S.T.S,
then RI is functional in every d  DI.

Proof of Claim. (a) Let d  EI have an SI-successor. Then d has
a T I-predecessor d1, which, in turn, has an SI-successor and a
T I  SI-successor (the SI-successor of d). Thus, by Claim 13.1 (a)
applied to d1, we obtain functionality of SI in d.
(b) The argument is essentially the same as in (a) but we apply
Claim 13.1 (e) instead. 
We now describe the part of the TBox that encodes computations of a given Turing machine. Let M = ( , Q , q0, q1, ) be a
deterministic Turing machine (see the proof of Theorem 3) with a
two-symbol tape alphabet  = {1, }.
We use concept Hq, for q  Q , that contains the representations
of all tape cells observed by the head of M (in state q); concept
H represents the cells not observed by the head of M. Role S has
two sub-roles, S and S1, for the two symbols of the alphabet 
to encode cell contents: the range of Sa represents cells containing
a   .
The most natural way of encoding a transition (q, a) =
(q, a,  ) of M would be to use a concept inclusion of the form
a  Sa  Sq , where Sq is also a sub-role of S (recall
Hq  S
that the latter is functional in the grid). Alas, DL-LiteH
core does not
allow conjunction on the left-hand side of concept inclusions. The
following construction simulates the required inclusions by using
functionality of just two roles, R and S. Let TF contain (29), (30) and
the following concept and role inclusions with fresh role names Rq,
La and Pqa, for each q  Q  {} and a   :

a  D,

q  E,

Hq  Rq,
Rq  R,

q  Pq,
Pq  R,
  R,

a  La,
La  R,

q  Pq1,
Pq1  S,
1  S.

a )I ,

d  HI

q  (S

q  (S

qa)I whenever

Claim 13.3. If I |= TG  TF and I |= q, then for each a   and
q  Q  {}, we have
d  (P
for any d such that RI is functional in any RI-predecessor of d.
Proof of Claim. Let d  HI
a )I. Then d has an RI
q -successor
a -successor, which coincide because, by Claim 13.2 (b), RI
and an LI
is functional in d  DI. Let d be the RI-successor of d.
If a = 1, then the inverse of L1 is a sub-role of S, and thus,
(d, d)  SI. On the other hand, d has a PI
q1-successor d, whence
(d, d)  SI. Since d  EI, by Claim 13.2 (a), SI is functional in
d, whence d = d. Therefore, d  (P
q1)I.
If a = , then the argument is similar with R replacing S as
the super-role of both L
 and Pq. As RI is functional in any RIpredecessor of d, in particular in d, we obtain d  (P

q)I. 

We are now in a position to define the representation of Turing
machine computations. Using the roles Pqa from TF , we can encode
transitions:

qa  Sa  Sq ,
(31)
Sa  S,
(32)
Sq  S,
(33)
where Sq,1 and Sq,+1 are fresh role names that are used to
propagate the new state in the next configuration. Recall now that

for (q, a) = (q, a,  ),
for a   ,
for q  Q and   {1,+1},

Fig. 10. (a) ABox Aw and (b) the three-way infinite grid in the proof of Theorem 13.

for q  Q ,

for a   .

for   {1,+1}.

and Hq  T,1,
and T,1  T,

for q  Q and   {1,+1},
for q  Q and   {1,+1},

the ranges of roles Pa identify cells that are not observed by the
head of M; the symbols contained in such cells are then preserved
with the help of concept inclusions

a  Sa,
(34)
The location of the head in the next configuration is ensured by the
following inclusions:

q  Tq ,
(35)

q  Hq,
(36)
Tq,+1  T and Tq,1  T,
(37)
where Tq,+1 and Tq,1 are used to propagate the head in the state
q along the tape (recall that, by Claim 13.1, both T I and (T)I are
functional in the grid); finally, the following concept inclusions are
required to propagate the no-head marker H:
Hq  T,+1
for q  Q ,
(38)
T,+1  T
(39)

  T  H,
(40)
Next, the ABox Aw that encodes an input w = a1, . . . , an    of
M is as follows:
Z (c00, c10),
T (c0(i1), c0i) and Sai
T(c0n, c0(n+1)),
where Z is a fresh role name to start off an infinite sequence of
configurations and T a fresh role name to fill the rest of the tape
in the initial configuration by blanks:
Z  Z ,
(41)

  S  T,
(42)
see Fig. 10 (a). Finally, the following concept inclusion ensures that
the accepting state q1  Q never occurs in a computation:
Hq1  .
(43)
Let TM contain (31)(43) encoding transitions of M and let T =
TG  TF  TM. If (T , Aw ) |= q, then there is a model I of (T , Aw )
with I |= q. It should then be clear that, by Claims 13.1 and 13.3,
we can extract from I a computation of M that does not accept w

(c0i, c1i), for 1  i  n,

Z  S,
T  T;

T (c10, c11),

Hq0

(c11),

ab196

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Fig. 12. CQs= in the proof of Theorem 14.

Proof of Claim. The cases of Pq and Pq1 are illustrated in
Fig. 11 (a) and 11 (b), respectively; some edges are not shown to
avoid clutter: each domain element in (S)I also has an incoming
RI-edge and each T I-edge starts an infinite chain of T I-edges.
The three black (solid, dashed and dotted) patterns of edges in
Fig. 11 (a) correspond to the three sets of positive atoms of q so
that the negated inequality atom, (u = v), identifies certain
domain elements of the pattern. Similarly, the two black (dashed
and dotted) patterns of edges in Fig. 11 (b) correspond to the two
sets of positive atoms of q that identify certain domain elements.
Black nodes are in the domain of J , whereas white nodes are in
the domain of I proper. It can be seen that the domain elements
dij in J are subject only to the following modifications: each dij, for
i > 0, is added to DI and, depending on the a in the role Sa with
dij  (S
q and LI

(which do not occur anywhere but in TF ). 
So, (T , Aw ) |= q iff M does not accept w. Take M to be a fixed
deterministic universal Turing machine, i.e., a machine that accepts
w iff the empty input is accepted by the Turing machine encoded
by w. This finishes the proof of Theorem 13. 

ij) is added to both RI

a )J , either (dij, d

ij) or (dij, d

4.2. Hardness of CQs with inequalities over DL-Litecore

In the previous section we established undecidability of CQ=
answering over DL-LiteH
core. The reduction, however, essentially
uses role inclusions. Leaving decidability of CQ= answering over
DL-Litecore as an open problem, we establish undecidability of
answering unions of three CQs=, as well as P- and coNP-hardness
of answering single CQs=.
Theorem 14. There exist a union of three Boolean CQs= q with
one inequality each and a DL-Litecore TBox T such that the problem
CertainAnswers(q, T ) is undecidable.
Proof. We adapt the ideas of the proof of Theorem 9 to the case
of inequalities and provide here a sketch of the reduction of the
halting problem for deterministic Turing machines.
Let M = ( , Q , q0, q1, ) be a deterministic Turing machine;
see the proof of Theorem 3. Similarly to the proof of Theorem 9,
we associate with a computation a two-dimensional grid on roles
S and T, where representations of the cells on the tape are related
by role E to individuals eqa, for (q, a)  (Q  {,})   (recall
that  is a no-head marker and  is a marker for initialising the
tape beyond the input). We use the same ABox as in Theorem 9,
comprising AM to encode the instructions of M (via quadruples TM)
and Aw to encode an input w = a1, . . . , an   .
Consider a union q of the following three CQs= given in negated
form (see Fig. 12 for the first and the third; the second is similar to
the one in Fig. 5 (a)):
S(x, y)  T (x, z)  S(z, v)  T (y, v)  (y = y),
E(x, y)  P(y, z)  S(x, x)  P(z, y)  E(x, y) 

T (x, x)  E(x, y)  P(y, z) 
T (x, x+)  E(x+, y+)  P+(y+, z)  (y = y),

T (x, x+)  E(x, y)  I(y)  E(x+, y)  (y = y).

Fig. 11. Extending J to I.

(for a similar argument, see the proofs of Theorems 3 and 9).
Conversely, if M does not accept w, then we can construct a
model I of (T , Aw ) with I |= q as follows. First, it is routine to
construct a model J0 of TG such that

J0 =dij | i  0 and j  Z d

| i > 0 and j  Z,

ij, d

ij

ij is an RJ0-predecessor of dij and each d

the dij form a three-way infinite grid structure on roles S and T (see
Fig. 10 (b)), each d
ij is an
SJ0-predecessor of dij (note that if i > 0, then dij has another SJ0-
predecessor, d(i1)j, and it is important that SJ0 is not functional in
dij). The resulting J0 is clearly a model of TG and J0 |= q.
Next, we extend J0 to a model J of TM and Aw by choosing
the interpretation of concepts and roles in TM on the domain of
J0 in such a way that the part of J rooted in d11 encodes the
computation of M on w (which is uniquely defined because M is
ij = dij for all cij in Aw. Role Z
deterministic). Specifically, we set cJ
follows the infinite chain of SJ -successors from d00 and role T the
infinite chain of T J -successors from d0n. Then, the interpretation
of Hq, Sa and Sq , for q  Q , a   and   {1,+1}, is
determined by the computation assuming that the dij with j  0
represent the blank cells (containing ) of the infinite extension
of the tape before the input, which is never visited by the head. It
then should be clear how to interpret H and Tq , for q  Q  {}
and   {1,+1}. As the final step of the construction of J , we
define PJ
ij, dij)  PJ
(d
ij, dij)  PJ
(d
It remains to show that J can be extended by new domain
elements to satisfy TF in such a way that the interpretation of
concepts and roles of TG  TM on the domain of J remains
unchanged.
Claim 13.4. J can be extended to a model I of TF so that
(a) dij  HI
(b) AI  J = AJ for all concept names A other than D;
(c) PI  (J  J ) = PJ for all role names P but Rq and La.

ij)  RJ if dij  HJ
ij)  RJ if dij  HJ

q and (dij, d
q1 and (dij, d

qa and extend RJ as follows:

q  (S
q  (S

a )I if dij  (P

qa)I, for every dij;

)J ,
1 )J .

q  (S

ababV. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

E  N  .

T  E,
T  T ,

Observe that queries (26)(28) from the proof of Theorem 9 are
all similarly transformed as follows: in (26), for example, the
conclusion of the implication, T (y, v), is moved into the premise,
then one of its variables, y, is replaced with a fresh copy, y, and
an equality between the variable and its copy, y = y, is placed in
the conclusion. The resulting queries (if viewed in negated form)
can identify certain points in an interpretation but require an
extended TBox to achieve the effect of queries (26)(28) with safe
negation. To this end, let TBox T contain
S  T,
T  S,
The first two concept inclusions allow the components of query q
to play the role of (26)(28) in Theorem 9: they enforce any model
to contain matches for the atoms moved from the conclusions
to the premises, and then the (negated) inequalities re-connect
the other ends in the model (these atoms are indicated by the
dashed arrows in Fig. 12). Finally, note that the last three concept
inclusions are the same as in the proof of Theorem 9.
It can be verified that (T , AM  Aw ) |= q iff M does not accept
w. We just note that, in any model I with I |= q, the relation (T)I
is functional in all points with an (S)I  T I  SI-predecessor but
T I does not have to be functional anywhere (in fact, c0 has a T-loop
and another T-successor, c1, in AM). 
Theorem 15. There exist a Boolean CQ = q with one inequality and
a DL-Litecore TBox T such that the problem CertainAnswers(q, T ) is
P-hard.
Proof. We first show how the proof of Lemma 10, which shows
P-hardness of answering GNCQs with one negated atom over
DL-Litecore, can be also adapted for the case of inequalities. Recall
that the proof is by reduction of the complement of Horn-3SAT, the
satisfiability problem for Horn clauses with at most three literals.
Suppose we are given a conjunction  of Horn clauses of the
form p, p and p1  p2  p, where p, p1 and p2 are propositional
variables. Consider the following Boolean CQ= q1 in negated form:
N1(x1, y)  E(x1, v)  N2(x2, y)  E(x2, v)  V (v) 
R(y, z)  E(z, v)  (v = v).
This query follows the pattern of the GNCQ in the proof of
Lemma 10, where unary predicate V served as a marker for
variables p that are true in all models of . In this case, we use
binary predicate E to connect all such variables p to a single fixed
domain element in V , which represents truth (as, e.g., in the proof
of Theorem 14). So, we take T1 that contains
R  E and V  F  ,
and let A ,1 consist of F (efalse), V (etrue) and, for each clause  in ,
the following assertions:

E(cp, etrue),
E(cp, efalse),
, c ), R(c , cp),

if  = p,
if  = p,
if  = p1  p2  p,

, c ), N2(cp2

N1(cp1
where cp and c are individual names for every p and  ,
respectively, and etrue and efalse are the individual names for truth
and falsum. (Without loss of generality, we assume that  does not
contain both p and p, for the same variable p.) It can be verified
that (T1, A ,1) |= q1 iff  is satisfiable. Note that, if the UNA is
adopted, then the negative concept inclusion in T1 is not required.
Next, we provide an alternative proof of this theorem, which
uses a shorter query. It is also by reduction of the complement
of Horn-3SAT. Given a conjunction  as above, fix a TBox T
containing
V  E,

V  F  ,

E  V ,

Fig. 13. Proof of Theorem 15.

and a Boolean CQ= q with negated form
V (x)  N(x, y)  R(y, z)  E(y, z)  (z = z).
Note that T and q do not depend on . Next, we construct an ABox
A such that  is satisfiable iff (T , A ) |= q. The ABox A uses an
individual name cp for each variable p in , and individual names
c 1 and c 2 for each clause  of the form p1  p2  p in , and
contains the following assertions, for every clause  in :

V (cp),
F (cp),

, c 1), R(c 1, c 2), V (c 1),

N(cp2

, c 2), R(c 2, cp),

N(cp1

if  = p,
if  = p,
if  = p1  p2  p.

 2 resulting in cI

Suppose first there is a model I of (T , A ) with I |= q. We
show that  is satisfiable. For each clause  of  of the form
p1  p2  p, the model I contains a configuration depicted in
Fig. 13 (the grey nodes represent ABox individuals and the white
 V I,
onesanonymous individuals generated by the TBox). If cI
 2  V I,
p1
then the EI- and RI-successors of cI
 1 coincide, whence cI
which triggers the second application of the query to identify
p  V I but only if
p with the EI-successor of cI
cI
 V I. So, as follows from the argument above, we can define a
cI
p2
satisfying assignment a for  by taking a(p) true iff cI
Conversely, if  is satisfiable, then we can construct a model I
of (T , A ) with I |= q. 
Theorem 16. There exist a Boolean CQ = q with two inequalities and
a DL-Litecore TBox T such that the problem CertainAnswers(q, T ) is
coNP-hard.
Proof. We begin with a remark that we could follow the lines of
the first proof of Theorem 15 and adapt the proof of Lemma 11,
which is by reduction of 2+2SAT, the satisfiability problem for
clauses with two negative and two positive literals. This would
require the following query in negated form:
N1(x1, y)  E(x1, v)  N2(x2, y)  E(x2, v)  V (v) 
R1(y, z1)  E(z1, v1)  R2(y, z2)  E(z2, v2)

p  V I.

 (v = v1)  (v = v2),

and the following TBox:
for i = 1, 2,

i  E,
Instead, we provide an alternative proof with a larger TBox but a
shorter query.

and V  F  .

The proof is by reduction of the complement of 3SAT, which is
known to be coNP-complete; see e.g., [36]. Suppose we are given
a conjunction  of clauses of the form l1  l2  l3, where the lk
are literals, i.e., propositional variables or their negations (we can
assume that all literals in each clause are distinct). Fix a TBox T
containing the following concept inclusions:
V  T  F , T  V , T  F  , A1  A2  ,
and a Boolean CQ= q with the following negated form:
V (x)  R(x, y)  T (x, y1)  F (x, y2)  (y = y1)  (y = y2).

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Fig. 14. Proof of Theorem 16.

Claim 16.1. Let I be a model of T with I |= q. If d  V I and
(d, d1), (d, d2)  RI with d1 = d2, then
 either (d, d1)  FI and (d, d2)  T I,
 or (d, d1)  T I and (d, d2)  FI.
Proof of Claim. Since I |= q, each pair (d, dk) belongs either to T I
or FI. To prove the claim, suppose to the contrary that (d, dk)  T I
for both k = 1, 2 (the other case, with both pairs in FI, is similar).
Consider a map  with  (x) = d,  (y) = d1,  (y1) = d2 and an
FI-successor of d as  (y2). Since  cannot be a match for q in I but
d1 = d2, we must have y = y2, whence (d, d1)  FI contrary to
disjointness of T and F. 
Again, T and q do not depend on . The ABox A is constructed
as follows. Let t and f be two individuals with A1(t) and A1(f )
in A. For each propositional variable p of , take the following
assertions, for k = 1, 2, with five individuals vp, ckp and ck
p:
A2(vp),

Let I be a model of (T , A ) with I |= q. Observe that vI

R(ck
R(ckp, vp), R(ckp, t), T (ckp, t),
p and ckp represent the literals p and p, respectively,
where the ck
see Fig. 14.
p = tI.
By Claim 16.1, if (ckp)I  V I, then vI
p  (F)I, that is, if
the literal p is chosen (by means of V ), then p must be false.
Conversely, if p is not chosen (that is, (ckp)I  V I), then vI
p does
not have to be in (F)I and p can be either true or false. Similarly
p )I with vI
for (ck
Next, for each clause  of the form l1  l2  l3 in , let
A contain the following assertions, where c 1 and c 2 are fresh
individuals:
V (c 1),

p  (T)I.

p , vp), R(ck

p , f ), F (ck

p , f ),

R(c 1, c1
l1
R(c 2, c1
l2

), A1(c1
l1
), A1(c1
l2

), R(c 1, c 2), A2(c 2),
), R(c 2, c2
).
l3

), A2(c2
l3

It can be verified that  is satisfiable iff (T , A ) |= q. Indeed, if
there is a model I of (T , A ) with I |= q, then by Claim 16.1 and
the observation above, we can construct a satisfying assignment a
p  V I. The converse direction is
for  by taking a(p) true iff vI
straightforward.
Note that the construction can be simplified if the UNA is
adopted: in this case, there is no need for A1, A2 and the two copies
of the individuals ck
4.3. Local CQs= over DL-LiteH

l, for k = 1, 2, representing literals. 

core: decidability

Let T be a DL-LiteH

In this section we identify a restriction on CQs= and DL-LiteH
core
TBoxes with decidable query answering problem. In a nutshell,
decidability is attained by ensuring that each inequality has a term
that can only be matched by ABox individuals.
core TBox. A basic concept B is said to be T -local
if there is no existential restriction R occurring on the right-hand
side of a concept inclusion in T such that
T |= R  B.
Intuitively, this condition guarantees that B contains only individuals in the canonical interpretation.

Definition 17. A CQ= q is T -local (or local when T is clear from
the context) if, for each inequality y1 = y2 between existentially
quantified variables y1 and y2 in q, the query also contains either
B(y1) or B(y2) such that B is a T -local basic concept.
Recall that we say that q contains B(y), for B = R, if it contains
R(y, t), for some term t. Remarkably, local CQs= can express quite
complex patterns: see the proofs of Theorems 15 and 16; on
the other hand, the first component of the union in the proof of
Theorem 14 is not local (but the other two components are).
To establish decidability of query answering we require the
following notions. Given two interpretations J and I, we say that
J is a sub-interpretation of I and write J  I if J  I and J
is the restriction of I onto J ; in particular, cJ = cI  J , for
all individuals c.

Let K = (T , A) be a DL-LiteH

core knowledge base. The set of
interpretations dc of individuals c in the canonical interpretation
CK of K is denoted by indK. A branch b is a (finite or infinite)
, . . . of elements in CK such that it cannot
sequence dc , dcR1
be extended to a longer sequence of this form in CK. A trim of the
canonical interpretation CK is an interpretation J  CK whose
domain J is closed in the following sense: dw  J whenever
dwR  J . Observe that, on the one hand, the first element of
every branch is in indK; on the other hand, by the definition of
the sub-interpretation, the domain J contains indK. Hence, the
first element of every branch belongs to J . A branch b is said to
be complete in J if each element of b is in J . The number of
elements of b in J , which may be infinite, is denoted by |b|J ;
if b is complete in J , then |b|J is its length.
The image h(J ) of a trim J under a mapping h from the domain
of J is an interpretation defined by taking

h(J ) =h(d) | d  J,
Ah(J ) =h(d) | d  AJ,
Ph(J ) =(h(d), h(d)) | (d, d)  PJ, for role names P.

for individual names c,
for concept names A,

ch(J ) = h(cJ ),

, dcR1R2

Let I be the image h(J ) of J under a mapping h. By definition, h is
a surjective homomorphism from J onto I, and so we often write
h: J  I to indicate that I is the image of J under h. We say
that h is an identification if each d  I \ h(indK) has at most one
pre-image. Note that only interpretations of individuals, that is, elements in h(indK), can have multiple pre-images in an identification h. It is readily verified that, for every identification h: J  I,
we have the following partial converse of the homomorphism con-
dition:
if (d1, d2)  RI, for a role R, and d1  h(indK), then there
(id)
is a unique dw in J such that either

d1 = h(dw), d2 = h(dwS ) and T |= S  R,
or d1 = h(dwS ), d2 = h(dw) and T |= S  R,
for some role S.

Let k > 0 and h: J  I be an identification for a trim J .
k on elements of J by taking
k dw iff the following two conditions hold for every w with

We define the equivalence relation h
dw h
|w|  k:
(eq-t)
(eq-c)

dww is in J iff dww is in J ;
if dww is in J , then either h(dww) = h(dww)  h(indK)
or h(dww), h(dww)  h(indK).

A pair (dw1

, dw1w2
under h in case dw1 h
proper prefixes w

) of distinct elements in J is called a k-block
k dw1w2 and dw
, for any distinct
1 and w
2 of w1w2. It should be clear that

k dw

1w

1w

Let K = (T , A) be a consistent DL-LiteH

each equivalence class is determined by a tree of depth k and
branching factor of at most |T |, each element of which indicates
that it does not belong to J , or it belongs to J but its h-image is
not in indK, or it belongs to J and its h-image coincides with one of
the indK. This gives rise to at most (2+|A|)|T |k equivalence classes.
Therefore, under any identification, every sufficiently long branch
of the canonical interpretation has a k-block simply because some
equivalence class will have to appear twice on the branch.
core KB and q a T -local
Boolean CQ=. (Recall that queries can contain individual names,
and so, without loss of generality, we may assume that the query
does not have answer variables.) An interpretation I is called a
k-certificate for q and K if
 I |= q,
 I satisfies all negative inclusions in T ,
 there is a trim J of CK and an identification h: J  I such
that, for each branch b in CK,
if b is complete in J and contains a k-block
(b1)
, dw1w2
if b is incomplete in J , then it contains a k-block
, dw1w2

) under h, then |b|J  |w1w2| + k;
) under h and |b|J = |w1w2| + k.

(dw1

(dw1

(b2)

Note that the trim J in the definition is finite because every branch
has a k-block and the trim contains at most |T |k elements beyond
each k-block. It follows that any k-certificate is finite by definition.
Having these definitions at hand, we are ready to state and

prove two key lemmas of this section.
Lemma 18. Let K = (T , A) be a consistent DL-LiteH
core KB, q a
T -local Boolean CQ = and k > 0. If K |= q, then there exists a
k-certificate for q and K.
Proof. Let K |= q. Then there is a model I0 of K such that I0 |= q.
Let h0 be a homomorphism from the canonical interpretation CK
to I0 (without loss of generality we assume that the domain of I0
is disjoint from the domain of CK). The homomorphism h0 can be
represented as a composition h  h of two mappings such that
h agrees with h0 on all elements that are merged with images of
individuals but is the identity on all other elements:

h(d) =h0(d),

d,

if h0(d)  h0(indK),
otherwise;

it follows that h is the identity on the interpretations of individuals
and agrees with h0 on all other elements. Let I = h(CK). By
definition, h and h are homomorphisms from CK to I and from I
to I0, respectively; moreover, h: CK  I is an identification. We
have I |= q for otherwise I |= q would imply I0 |= q because
h is a homomorphism that does not identify anything with the
interpretations of individuals and q is T -local.
Consider the (finite) trim J of CK to all the elements dw such
that |w|  |w1w2| + k for all k-blocks (dw1
) under h with
w1w2 being a prefix of w (in particular, dw is included if there is no
such k-block). Let I = h(J ). We claim that I is a k-certificate for
q and K. Indeed, since I  I, we have I |= q and I satisfies all
negative inclusions in T . On the other hand, all the k-blocks under
h are also k-blocks under the restriction of h onto J : indeed, J
contains all the elements within the distance of k from k-blocks,
therefore satisfying (eq-t) (and (eq-c) is inherited from I). 
Lemma 19. Let K = (T , A) be a consistent DL-LiteH
core KB and
q a T -local Boolean CQ =. Let k be the size of q. If there exists a
k-certificate for q and K, then K |= q.

, dw1w2

Proof. Let I0 be a k-certificate for q and K. Although I0 |= q, the
interpretation I0 may not be a model of K. We show how to extend
I0 to a model of K without introducing a match for q.
Since I0 is a k-certificate, there is a trim J0 of the canonical
interpretation CK and an identification h0: J0  I0 satisfying (b1)
and (b2). In the sequel, for the sake of simplifying the presentation,
we will often refer to k-blocks under h0 simply as k-blocks.
For l > 0, denote by Jl the trim of CK to all the elements dww
such that dw  J0 and |w|  l (the trim Jl extends all branches
of J0 by at most l elements).

, dw

1w

, dw1w2

) be a k-block under h0 and let l > 0. If

) on this branch. We know that (dw1

Claim 19.1. Let (dw1
dw1w2w belongs to Jl, then dw1w belongs to Jl1.
Proof of Claim. By the definition of the canonical interpretation,
since dw1w2w belongs to Jl  CK, the element dw1w also belongs
to CK. If dw1w belongs to J0, then it clearly belongs to Jl1.
Otherwise, all the branches containing dw1w are incomplete in J0.
Consider any of these branches. By (b2), there exists a k-block
(dw
, dw1w2
) is the first
pair with dw1 h0

k dw1w2 on any branch containing dw1w2w and so,
2|. On the
2, whence |w1| < |w
w1 is a proper prefix of w
1w
other hand, dw1w2w belongs to Jl and so, |w|  k + l. Thus,
|w1w| < |w
2| +
(k + l  1). However, by (b1) and (b2), the trim J0 contains all
k-blocks together with all the elements within the distance of k
from the k-blocks. Therefore, Jl1 contains all elements of CK that
are within k + l  1 steps from any k-block. In particular, Jl1
contains dw1w. 

2| + k + l, or equivalently, |w1w|  |w

1w

1w

1w

We construct a sequence of interpretations

I0  I1  . . .  Il  
with identifications hl: Jl  Il and show by induction that, for
all l  0, the interpretation Il satisfies all negative inclusions in T
and Il |= q.
The basis of induction, l = 0, is by the definition of k-certificate:
I0 = h0(J0). Let l > 0, and suppose that Jl1 and Il1 =
hl1(Jl1) have been constructed. To obtain hl, we extend hl1
to the elements dw1w2w in Jl that are not in Jl1 as follows:

hl(dw1w2w) =hl1(dw1w),

a fresh element,

if hl1(dw1w)  hl1(indK),
otherwise.

By Claim 19.1, the definition is correct. It also follows from the
definition that hl(indK) = hl1(indK) and therefore, we will use
h(indK) for this set in the sequel.

iff

, dw1w2

) be a k-block under h0. Then, for every
hl(dw1w2w) = hl1(dw1w).

Claim 19.2. Let (dw1
dw1w2w in Jl, we have
hl(dw1w2w)  h(indK)
Proof of Claim. If |w|  k, then the claim is immediate from
(eq-c) and the definition of h0. If |w| > k, then by (b1)
and (b2), dw1w2w does not belong to J0. By the definition of
hl, either hl(dw1w2w) and hl(dw1w) are equal and in h(indK) or
hl(dw1w2w) is a fresh element, which, in particular, cannot be equal
to hl1(dw1w). 
Let Il = hl(Jl). Clearly, Il1  Il and hl is an identification.
|= q. Suppose for the sake of contradiction
We show that Il
that there is a match  for q in Il. We then construct a match
 for q in Il1. To this end we require a set  of all variables in
sequences x1, . . . , xm, m  1, such that  (xi)  h(indK) for i  m,
Ri(xi+1, xi)  q for i < m and either
  (x1) = hl(d), for some d in Jl but not in Jl1, or

V. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

Case 1.1: s, t  , that is,  (s) = hl(dw1w2w), (s) = hl(dw1w),
2w ) and (t) = hl(dw
 (t) = hl(dw
1w
1w ). By Claim 19.3, both
w and w are non-empty and uniquely defined. Moreover, since
neither  (s) nor  (t) is in h(indK), by (id), we obtain w1 = w
1,
w2 = w
2 and either w = wS with T |= S  R or w = wS
with T |= S  R. By Claim 19.1, both dw1w and dw1w belong
to Jl1, and so, in either case, (dw1w, dw1w )  RJl1, whence
((s), (t))  RIl1.
 , that is,  (s) = hl(dw1w2w) and
Case 1.2: s   and t
(s) = hl1(dw1w) but (t) =  (t). We have  (t)  h(indK),
for otherwise we would include t in  by considering a sequence
ending in t. By Claim 19.3, w is non-empty and uniquely defined
and so, by (id), we have  (t) = hl(dw1w2w ) with either w =
wS and T |= S  R or wS = w and T |= S  R. By
Claim 19.1, both dw1w and dw1w are in Jl1 and so, in either case,
(dw1w, dw1w )  RJl1. By Claim 19.2, (t) = hl1(dw1w ), whence
((s), (t))  RIl1.
Case 1.3: s   and t   is the mirror image of Case 1.2.
Case 1.4: s, t  , that is,  (s) = (s) and  (t) = (t). We have
( (s),  (t))  RIl. Consider first the case when at least one of
these elements is not in h(indK). Suppose that  (s)  h(indK) (the
other case is symmetric). By (id), either  (s) = h(dw) and  (t) =
h(dwS ) with T |= S  R or  (s) = h(dwS ) and  (t) = h(dw)
with T |= S  R. We claim that in either case dwS (and so dw)
belongs to Jl1. Indeed, in the former case dwS =  (t) cannot be
outside Jl1 for otherwise  would contain s. For the same reason,
dwS =  (s) cannot be outside Jl1 in the latter case. So, both  (s)
and  (t) are in Jl1, and we obtain ((s), (t))  RIl1.
Otherwise, both  (s) and  (t) are in h(indK). Suppose for the
sake of contradiction that ((s), (t))  RIl1. Then, since Il =
hl(Jl), Il1 = hl1(Jl1) and both Jl, Jl1 are trims of CK, there
are some dw1w2w and dw1w2w, for a k-block (dw1
), with one
of them in Jl but not in Jl1 such that  (s) = hl(dw1w2w) and
 (t) = hl(dw1w2w ) and either w = wS with T |= S  R
or w = wS with T |= S  R. By Claim 19.1, dw1w and
dw1w are in Jl1, and so, in either case, (dw1w, dw1w )  RJl1,
whence (hl1(dw1w), hl1(dw1w ))  RIl1. By Claim 19.2, we have
hl(dw1w2w) = hl1(dw1w) and hl(dw1w2w ) = hl1(dw1w ). So,
((s), (t))  RIl1 contrary to the assumption.
2. Next, suppose  (s)  AIl. We show (s)  AIl1. There are
two cases.
Case 2.1: s  , that is,  (s) = hl(dw1w2w) and (s) =
hl1(dw1w). By Claim 19.3, dw1w2w is uniquely defined. By the
 h(indK) and so, as hl is an
definition of , hl(dw1w2w)
identification, we obtain dw1w2w  AJl. By Claim 19.1, dw1w
belongs to Jl1, and so, by the definition of the canonical
interpretation, dw1w  AJl1, whence (s)  AIl1.
Case 2.2: s  , that is,  (s) = (s). If  (s)  h(indK), then
since hl is an identification, there is a unique d in Jl such that
 (s) = hl(d). By the first item in the definition of , d is in fact
in Jl1. Since Il1 = hl1(Jl1), we obtain hl1(d)  AIl1,
whence (s)  AIl1. If  (s)  h(indK), then suppose, for the
sake of contradiction, that  (s)  AIl1. As Il = hl(Jl) and
Il1 = hl1(Jl1) and both Jl, Jl1 are trims of CK, there is
), in Jl but not in Jl1 such that
dw1w2w, for a k-block (dw1
 (s) = hl(dw1w2w). By Claim 19.1, dw1w belongs to Jl1, and so,
dw1w  AJl1. Hence,  (s)  AIl1 contrary to the assumption.
3. Finally, suppose  (s) =  (t), for an inequality s = t in q. We
show (s) = (t). Since q is T -local, either  (s) or  (t) must be
in h(indK), and therefore either s or t is not in , which leaves the
following three cases possible.
Case 3.1: s   and t
 , that is,  (s) = hl(dw1w2w) and
(s) = hl1(dw1w) but (t) =  (t). By the definition of ,
 (s)  h(indK), whence, by Claim 19.2, (s)  h(indK). On the

, dw1w2

, dw1w2

Fig. 15. Definition of .

 q contains R0(x1, t0) with  (x1) = hl(dw), T |= S  R0,
 (t0) = hl(dwS )  h(indK) and dwS in Jl but not in Jl1.

Intuitively, the set  contains exactly those variables whose
images under  are reachable from the new part in Il through
anonymous elements by a chain of (images of) atoms in the query;
see Fig. 15 (a) and (b) for the two cases.
Claim 19.3. For each x  , there are a unique k-block (dw1
, dw1w2

under h0 and a unique non-empty w such that dw1w2w is in Jl and
 (x) = hl(dw1w2w).
Proof of Claim. Let x1, . . . , xm be a sequence of elements of 
such that  (xi)  h(indK), Ri(xi+1, xi)  q, for all i, and xm = x.
Suppose first that  (x1) = hl(d1) for some d1 in Jl but not in
Jl1. Since  (x1)  h(indK) and hl is an identification, such a d1 is
uniquely defined. By (b2), there are a unique k-block (dw1
, dw1w2
and a unique w1 such that d1 = dw1w2w1. We show by (finite)
induction that, for each xi, there is a unique wi with
 (xi) = hl(dw1w2wi ) and |wi|  k + l  (i  1).
(44)
Since i ranges from 1 to m, it does not exceed the size of q, which in
turn does not exceed k and thus, i  k. For the basis of induction,
i = 1, the unique w1 is constructed above; moreover, since d1 is in
Jl but not in Jl1, we have |w1| = k + l. For the induction step
suppose that (44) holds for some i < m. As  (xi+1)  h(indK)
and ( (xi+1),  (xi))  RIl
, by (id), there is a unique di+1 with
 (xi+1) = hl(di+1). Since i < m  k, wi is non-empty. Hence,
di+1 = dw1w2wi+1 with either wi+1 = wiS or wi+1S = wi, for some
S. Thus, |wi+1|  |wi|  1 and (44) follows. Finally, we use (44)
with i = m to obtain |wm| > l.
Suppose now that q contains R0(x1, t0) with  (x1) = hl(dw),
 (t0) = hl(dwS )  h(indK) and dwS in Jl but not in Jl1. The
argument and the construction are identical to the case above
except that now |wi|  k + l  i, and thus |wm|  l > 0. 

, dw1w2

The mapping  from the terms t of q to the domain of Il1 is
constructed as follows.
 If t  , then t is a variable. By Claim 19.3, we have
 (t) = hl(dw1w2w), for a k-block (dw1
) and some w. By
Claim 19.1, dw1w is in Jl1; so, let (t) = hl1(dw1w), which is
in Il1.
 If t  , then  (t) is in Il1 (for otherwise t is in ); let
(t) =  (t).
We claim that  is a match for q in Il1 and prove it by showing
that the image of every atom in q under  is true in Il1.
1. Suppose ( (s),  (t))  RIl. We show ((s), (t))  RIl1.
There are four cases, depending on the way (s) and (t) are
constructed.

abV. Gutierrez-Basulto et al. / Web Semantics: Science, Services and Agents on the World Wide Web 35 (2015) 184202

other hand, by the observation above, (t) =  (t)  h(indK). So,
(s) = (t).
Case 3.2: s   and t   is the mirror image of Case 3.1.
Case 3.3: s, t  , that is,  (s) = (s) and  (t) = (t), which,
by the assumption, implies (s) = (t).
By induction hypothesis, Il1 |= q, and so Il |= q. Moreover,
by repeating the same argument, one can show that Il satisfies all
negative inclusions in T (the negation of a negative inclusion can
be regarded as a Boolean CQ with two atoms and at most three
variables, that is, as a T -local CQ= of special form).
To complete the proof, let J be the union of the Jl and h be
the union of the hl. It should be clear that in fact J = CK. Consider
I = h(J ). By definition, I satisfies the assertions of the ABox A and
all positive inclusions in T . Since, by construction, each Il satisfies
all negative inclusions in T , we can conclude that I is a model of
K (note, however, that Il may not necessarily be a model of K, for
any l). Finally, by our inductive argument, I |= q.

Combining Lemmas 18 and 19 and observing that the size of a
k-certificate can be bounded by an exponential function (in |A|),
we obtain the following theorem.

Theorem 20. For any DL-LiteH
problem CertainAnswers(q, T ) is decidable.

core TBox T and any T -local CQ = q, the

The exponential bound on the size of k-certificates means that
the problem CertainAnswers(q, T ) for a DL-LiteH
core TBox T and a
T -local CQ= q is in fact in coNExpTime in data complexity, which
leaves an exponential gap with the coNP-hardness established
in Theorem 16. In case of a single inequality, a k-certificate of
exponential size can be constructed by a deterministic algorithm.
This results in the ExpTime upper data complexity bound, which is
again exponentially harder than the P-hardness in Theorem 15.
Finally, we remark that the arguments in the proofs of
Lemmas 18 and 19 can be transferred to unions of T -local CQs=,
so Theorem 20 also holds for this extended class of queries.

5. Conclusions and future work

Our investigation in the OBDA paradigm has made further
steps towards a clearer understanding of the impact of extending
CQs with different forms of negation. We have shown that in
general these extensions lead to a surprisingly significant increase
even in the data complexity: e.g., from AC0 for answering CQs
to undecidability when safe negations are allowed. In order to
find a way of having efficient query answering in the presence of
negation, we have also explored various syntactic restrictions. For
example, we have identified a novel class of CQs=, local CQs=, with
decidable query answering over DL-LiteH
core.
Our investigation leaves open some important problems for
future work, e.g., decidability of answering CQss and CQs= over
DL-Litecore, as well as of answering CQss and local CQs= over EL.
It also remains open to establish the exact complexity for local
CQs= over DL-LiteH
core.

Another interesting problem is to investigate whether the
notions of guardedness and locality can be relaxed to increase
the expressivity. We note that CQs= are not finite controllable for
ontology languages with inverses, such as DL-Litecore, DL-LiteH
core
and ELI, and that our undecidability proofs rely on the encoding of
infinite structures. Therefore, our techniques do not apply directly
to the finite case. Finally, we believe that other problems, such
as query containment, are also worth studying for the ontology
languages with decidable query answering.

Acknowledgements

The first author was supported by the M8-Project TS-OBDA,
the second author by the SFB/TR8 Spatial Cognition and the fourth
author by the UK EPSRC grant EP/J017728 (SOCIAM project).
