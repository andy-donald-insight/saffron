Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

journal homepage: www.elsevier.com/locate/websem

Complexity of answering counting aggregate queries over DL-Lite
Egor V. Kostylev a,b, Juan L. Reutter c,

a University of Oxford, United Kingdom
b University of Edinburgh, United Kingdom
c Pontificia Universidad Catolica de Chile, Chile

a r t i c l e

i n f o

a b s t r a c t

The ontology based data access model assumes that users access data by means of an ontology, which is
often described in terms of description logics. As a consequence, languages for managing ontologies now
need algorithms not only to decide standard reasoning problems, but also to answer database-like queries.
However, fundamental database aggregate queries, such as the ones using functions COUNT and COUNT
DISTINCT, have received very little attention in this context, and even defining appropriate semantics
for their answers over ontologies appears to be a non-trivial task. Our goal is to study the problem of
answering database queries with aggregation in the context of ontologies. This paper presents an intuitive
semantics for answering counting queries, followed by a comparison with similar approaches that have
been taken in different database contexts. Afterwards, it exhibits a thorough study of the computational
complexity of evaluating counting queries conforming to this semantics.

Our results show that answering such queries over ontologies is decidable, but generally intractable.
However, our semantics promotes awareness on the information that can be obtained by querying
ontologies and raises the need to look for suitable approximations or heuristics in order to allow efficient
evaluation of this widely used class of queries.

 2015 Elsevier B.V. All rights reserved.

Article history:
Received 30 September 2013
Received in revised form
21 April 2015
Accepted 18 May 2015
Available online 29 May 2015

Keywords:
Description logics

DL-Lite
Aggregate queries
Count queries
Complexity

1. Introduction

The growing popularity of ontologies as a paradigm for representing knowledge in the Semantic Web is based on the ability to
describe incomplete information in the domain of interest.

Several variations of the web ontology language (OWL) have been
formalised to manage ontologies. Most of these languages correspond to fragments of first order logic, which are called description logics (DLs) [1]. These fragments allow to define classifications
of objects and formulate complex relationships for such classifi-
cations. Traditionally, literature has considered the decidability of
standard reasoning problems, such as satisfiability, to be the most
essential properties of any DL. In fact, a lot of effort has been made
over last decades to maximise the expressive power of DLs while
still keeping the decidability of these problems [1].

However, it has recently become clear that focusing on the
decidability of satisfiability and related problems is not enough
for practical applications of ontologies. For example, the concept

 Corresponding author.

E-mail addresses: egor.kostylev@cs.ox.ac.uk (E.V. Kostylev), jreutter@ing.puc.cl

(J.L. Reutter).

http://dx.doi.org/10.1016/j.websem.2015.05.003
1570-8268/ 2015 Elsevier B.V. All rights reserved.

of ontology-based data access (OBDA) requires reasoning tasks
that are much more complex. The information system of OBDA
applications consists of two layers: the data layer is formed by
several data sources, whose exact structure is not interesting or
not known to the clients, and a conceptual layer, where the clients
can pose queries, and that is linked to the data layer by logical
mappings [2,3]. Usually, data sources are relational databases, but
the conceptual layer is an ontology formulated in a DL.

Hence, OBDA brings new challenges to system designers. Users
should be able to pose database-style queries over ontologies using a reasonable amount of computational resources: the complexity of query answering should not be much higher than over usual
relational databases. This presents serious restrictions on which
ontology languages can be used in OBDA systems. In fact, this motivates the use of description logics of the DL-Lite family, underlying
OWL 2 QL profile, which have been designed specifically to maximise expressive power while maintaining good query answering properties [4]. In particular, the computational complexity of
answering simple queries such as conjunctive queries (CQ s) and
unions of conjunctive queries (UCQs) over these DLs is the same as
for relational databases [5,6].

It is natural to ask what happens when one moves beyond
conjunctive queries. Recently, some attention has been paid to

the problem of answering various standard extensions of CQs
and UCQs over ontologies. For example, [7,8], and [9] study path
queries over ontologies, while [10,11], and [9] consider adding
some form of negation to these simple queries. The general conclusion from these papers is that the complexity of evaluating such
queries is usually higher than for CQs and UCQs, and even higher
than for similar problems in relational databases. In some cases this
difference in complexity is surprisingly high: e.g., while answering
CQs with inequalities is known to be efficiently computable for relational databases, the problem is undecidable when such queries
are posed over DL-Lite ontologies.

Yet there is another extension of CQs that has received little attention in the context of OBDAaggregate queries. These queries
answer questions such as How many children does Ann have? or
What is the average salary over each department in the Pandidak-
terion? Usually, they combine various aggregation functions, such
as MIN, MAX, SUM, AVERAGE, COUNT, and COUNT DISTINCT [12],
together with a grouping functionality, as in the usual GROUP BY
clause of SQL.

Aggregate queries are an important and heavily used part of
almost every relational database query language, including SQL.
Consequently, in the context of the Semantic Web we expect the
need for answering queries with aggregates in OBDA settings, with
applications such as SPARQL under entailment regimes [13]. But
despite their importance the study of aggregate queries over ontologies has been lacking, save for a few exceptions [14].

The main reason for the lack of research in this direction is the
difficulty of defining a semantics for aggregate queries over on-
tologies. The complication is that, unlike relational databases, in
ontologies one assumes that every knowledge base instance is incomplete and describes a part of the infinite number of models
of the knowledge base (i.e., the open world assumption, or OWA,
is adopted), and a query may have a different answer on each of
these models. For standard queries like CQs and UCQs one usually
looks for the certain answers of queries, that is, the tuples that are
answers in all possible models [5]. This approach, however, is not
suitable for aggregate queries, as the following shows.

Consider a knowledge base where Ann is a parent and the ontology asserts that every parent has at least one child. If nothing else
is assumed then for every positive integer n there exists a model
where Ann has n children. Thus, the answer to the simple query
How many children does Ann have? in different models of the
knowledge base can be any number greater than or equal to 1. The
syntactic intersection of these answers (i.e., applying standard certain answers semantics) trivially gives us the empty set, which is
clearly not satisfactory. As a different approach, Calvanese et al. introduce epistemic semantics for aggregate queries [14]. In a nut-
shell, the idea is to apply the aggregation function only to known
values. For example, the epistemic answer to the query above is 0,
because we do not know anybody who is definitely a child of Ann.
But this is clearly not the desired answer: since Ann is a parent we
know that she has at least one child. Hence, the epistemic semantics does not always give a correct answer to COUNT queries.

We embark on the task of defining a suitable semantics for
answering what we call counting aggregate queries, which are
queries that use COUNT or COUNT DISTINCT functions. Motivated
by the original idea of certain answers, we seek to find the maximal
information that is common in the answers to such a query for all
the models of a knowledge base.

As the first contribution of this paper we develop the notion of
aggregate certain answers that can be explained as follows: a number n is in the aggregate certain answers of a counting query over
a knowledge base if the result of the aggregation function of such
query is not less than n in any possible model of the knowledge
base. We show that this is a natural and useful semantics for ag-

gregate queries that count. For instance, even if we do not know
precisely how many children Ann has in the example above, we
know that she has at least one, and thus 1 is an aggregate certain
answer to the query.

Having established our semantics, we turn to the study of the
algorithmic properties of aggregate certain answers computation
for counting queries. We concentrate on ontologies of the DL-Lite
family, in particular DL-Litecore and DL-LiteR [5]. The choice of
these DLs is twofold: first, as mentioned above, these formalisms
are important in the OBDA settings; second, they are among the
simplest DLs and hence are good candidates to begin with.

We start our study under the assumption that the query and the
terminology (i.e., the TBox) are fixed, and the only input is the assertions (ABox). This corresponds to the data complexity of the problem
in Vardis taxonomy [15]. Somewhat surprisingly, our results show
that the complexity of the problem is resilient to the choice of both
DL and counting function and is coNP-complete in all cases. As far
as we are aware, these are the first tight complexity bounds for answering aggregate queries in the presence of ontologies.

In order to get a further understanding of the computational
properties of the problems we then proceed to the study of the
combined complexity of computing the aggregate certain answers,
that is, assuming that the query, ABox, and TBox form the input.
Here we have an evidence supporting a difference for the choice
of DL, albeit not for the choice of counting function. More pre-
cisely, we are able to show that the problem is coNExpTime-hard
for DL-LiteR and  p
2 -hard for DL-Litecore. Unfortunately, we do not
have matching upper bounds: we show that the problem is in
coN2ExpTime for DL-LiteR and in coNExpTime for DL-Litecore. Note
that the hardness results are significant: they show that the combined complexity of aggregate query answering is higher than of
answering standard conjunctive queries in case of DL-Litecore, and
higher than of answering relational algebra queries over complete
databases in case of DL-LiteR.

This paper is an extended version of [16], but it contains substantial new material, including definitions, examples, full proofs
for all theorems, and additional statements. Furthermore, it contains a revision on the upper bounds for combined complexity of
the problem of computing the aggregate certain answers that were
not correctly stated in [16].
Organisation. We start with an overview of related work in the
following section, and basic background on DL-Lite and CQs in
Section 3. We formally define the semantics of counting aggregate
queries over DL-Litecore and DL-LiteR, and state corresponding
decision problems of answering of these queries in Section 4. We
establish data complexity of these problems in Section 5, and the
bounds for the combined complexity in Section 6. We conclude in
Section 7.

2. Related work

Aggregate queries have been part of most database query
languages, such as SQL, for decades. Their theoretical formalisation
can be found in, for example, [12]. Semantics for aggregate queries
have been already defined for several database settings that feature
incomplete information. For example, an inconsistent database
instance (with respect to a set of constraints) describes a set of
repairs, each of which satisfies the constraints and can be obtained
from the instance by a minimal number of transformations.
Aggregate queries over inconsistent databases were explored in
[17], where the range semantics was defined. Intuitively, this
semantics corresponds to the interval between the minimal and the
maximal possible answers to the query amongst all the repairs of a
given instance. The same semantics was adopted by [18,19] in the
context of data exchange.

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

However, the techniques from these papers cannot be immediately applied to ontologies because of several specific properties.
In particular, these papers consider variations of the closed world
assumption, whereas in ontologies the open world assumption
is assumed. Furthermore, data exchange settings are based on
source-to-target dependencies and weakly acyclic target depen-
dencies. These rules out all types of recursion in ontological knowledge thus simplifying the study to a great extent.

In the context of ontologies aggregate queries were studied
in [14]. In fact, in this work the range semantics itself was claimed
to be trivially meaningless for aggregate queries over ontologies.
For instance, for almost any knowledge base we can construct
a model such that the aggregate value of an AVERAGE query
evaluates to any number. Similar examples can be given for all
other standard aggregation functions except for COUNT and COUNT
DISTINCT, which are precisely the aggregates in the focus of this
paper. As we will show, the computation of the upper bound of the
range is almost trivial in these cases as well. But the lower bound
of the range, that is, the minimal possible value described above,
is completely natural and by no means trivial to compute. In fact,
the lower bound of the range semantics is strongly related to our
notion of aggregate certain answers as follows: a number is in the
aggregate certain answers if and only if it is less than or equal to
the lower bound of the range. Thus, this work on aggregate certain
answers can be seen as an adaptation of the range semantics of [17]
to ontologies.

The solution suggested in [14] is to give epistemic semantics to
aggregate queries over ontologies, that is, to apply the aggregation
function only to whose values which are witnessed in the ABox. We
believe that this semantics is much less intuitive and informative
than the certain answer semantics defined in this paper. Neverthe-
less, one can show that the epistemic semantics never gives more
answers than aggregate certain answer semantics, so the first can
be seen as an under-approximation of the second.

The default language for querying in the Semantic Web is
SPARQL. Its very recent version SPARQL 1.1 includes aggregation
functionalities, which are quite similar to such functionalities in
SQL [20]. It also includes a specification for querying under entailment regimes, in particular, OWL 2 QL, the profile which has
DL-Lite as logical foundation [13]. The specification adopts active
domain semantics even for conjunctive queries, which means that
the query answering process is decoupled in two steps: first fact
entailment is performed with respect to the ontology, and afterwards the query is answered over the resulting set of facts. Unfor-
tunately, fact entailment in OWL 2 QL is very limited. As a result,
even conjunctive query answering in the sense of [5] is not possible
under such semantics, because the anonymous part of the ontology
is essentially ignored. Aggregate queries are to be evaluated using
the same active domain semantics, hence this gives even less information than epistemic semantics. We believe that the certain
answer semantics, which fully take into account the anonymous
part of the ontology, is much more powerful and natural than the
active domain semantics.

It is also worth to note that expressive DLs extended with aggregation functions were studied in [21]. Though, the authors did
not consider any query language but concentrated on incorporating aggregation into the ontology language itself, by means of
special concepts with arguments from so-called concrete domains
(e.g., numbers). In this paper we consider aggregate query answering over less expressive DLs, which makes our settings incomparable with the settings of [21].

After the first publication of the results of this paper several se-
mantics, including certain answer semantics, were independently
defined in [22]. However, no complexity bounds were established.

3. Preliminaries

We start the formal part of this paper with standard notions on

R ::= Pj | P
j ,
E ::= R | R.

the two fragments of DL-Lite and conjunctive queries.
Syntax of DL-Lite. Let A0, A1, . . . be atomic concepts and P0, P1, . . .
be atomic roles. Concepts C and roles E of DL-Lite languages are
formed by the grammar
B ::= Ai | R,
C ::= B | B,
Concepts B and roles R are called positive.
A TBox is a finite set of inclusions. In the language of DL-Litecore
these inclusions are of the form B  C. In DL-LiteR the form R  E
is also allowed.
Let Ind = {a, a1, a2, . . .} be a set of individual names. An ABox is
a set of assertions of the forms Ai(a) and Pj(a1, a2) with a, a1, a2 
Ind. Without loss of generality, in what follows we assume that all
the individual names from Ind appear in A.
A knowledge base (or KB) K = T , A of a DL-Lite language
contains a TBox T of the language and an ABox A.
Semantics of DL-Lite. An interpretation I = (DI,I) contains a
(possibly infinite) domain of elements DI and maps each concept C
to a subset C I of DI and each role E to a binary relation EI over DI
such that
(R)I = {d | d : (d, d)  RI},
j )I = {(d1, d2) | (d2, d1)  P I
j },
(P
(B)I = DI\BI,
(R)I = (DI  DI)\RI,
as well as each individual name a to an element aI  DI such that
1 = aI
aI
An interpretation I is a model of a KB K = T , A (written
I |= K) if
- BI  C I for any inclusion B  C in T ,
- RI  EI for any inclusion R  E in T ,
- aI  AI
- (aI
1, aI
We also use |= as logical implication for (sets of) inclusions and
assertions under the semantics given above. For example, T |=
A1  A2 means that the TBox T implies the inclusion A1  A2.
2 for different individual names a1 and a2 in every interpretation I. By this we
adopt the unique name assumption (UNA), which is conventional
for DL-Lite [5,6]. However, dropping this assumption does not affect any result of this paper, and after each of our proofs we discuss
how to transfer the results if the UNA is not adopted.

i for any assertion Ai(a) in A, and
2)  P I

j for any assertion Pj(a1, a2) in A.

The definitions above require that aI

2 in case of a1 = a2.

1 = aI

Since in this paper we are interested in query answering, in
what follows we usually assume all KBs to be satisfiable, that is,
to have a model. This is justified by the fact that, as we see below,
query answering over unsatisfiable knowledge bases is trivial.
Canonical model. Next we give some standard notions which will
be useful in the proofs of this paper.
The canonical model Can(K) of a satisfiable K = T , A is
an interpretation with the domain DCan(K) of all elements daR1...Rm,
where a is an individual name, m  0, and R1, . . . , Rm are positive
roles such that
- if m  1 then there is a positive concept B with A |= B(a)
and T |= B  R1 but A |= R(a, a), for all a and R with
T |= R  R1;
- T |= R

i1  Ri, for each i, 1 < i  m,

i1  Ri but T |= R

n  A},

, da2

, daR1...Rm
, daR1...Rm1

) | K |= P(a1, a2)}

) | m  1, T |= Rm  P}
) | m  1, T |= Rm  P}.

and the interpretation function defined for individual names a,
atomic concepts A, and atomic roles P as follows:
aCan(K) = da,
ACan(K) = { ac | K |= A(a)}
{daR1...Rm | m  1, T |= R
PCan(K) = {(da1
{(daR1...Rm1
{(daR1...Rm
It is well-known that for any model I there exists a homomor-
: DCan(K)  DI
phism from Can(K) to I, that is, a mapping f
such that f (aCan(K)) = aI for any a  Ind, and d  SCan(K) implies
f (d)  SI for any element or pair of elements d and any atomic
concept or role S [5,6].
Conjunctive queries. The main building blocks of aggregate
queries are the following most simple queries widely studied in
the literature on knowledge bases. Formally, a conjunctive query (or
CQ ) is an expression of the form
q(x) :- y (x, y),
(1)
where x is a tuple of free variables, y is a tuple of existential vari-
ables, and the body (x, y) is a conjunction of atoms of the form
Ai(t) or Pj(t1, t2), where t, t1, t2 are terms, that is, variables from
x  y or individual names from Ind. If the tuple of free variables x
is empty, then the CQ is Boolean. The number of atoms in the body
of q is denoted by |q|.
Semantics of CQs for a single interpretation is given as follows.
Let q(x) be a CQ of the form (1), I an interpretation, and a =
(a1, . . . , an) a tuple of individual names from Ind, such that n
is the size of x. Let also aI be the extension of I to a, that is,
aI = (aI
n). Then a match for q(x) and a in I is a mapping
h : x y  DI, such that h(x) = aI and h(t)  SI for every unary
or binary atom S(t) in (x, y) with h(t) = h(t) for t  x  y and
h(t) = t I for t  Ind. If such a match exists, then we also say that
the CQ holds for I and a, and write I |= q(a).
Of course, we are interested not in a single interpretation but
in all models of a knowledge base. To this end, the following
semantics is usually adopted. A tuple a is in the certain answers
to a CQ (1) over a KB K if and only if I |= q(a) holds for every
model I of K. It is well-known that a tuple a of individual names
is a certain answer to a CQ q(x) over a satisfiable K if and only if
Can(K) |= q(a).

1, . . . , aI

4. Counting queries over ontologies

The ability to evaluate aggregate queries is a default in every
DBMS and is in the standard of SQL. However, as mentioned in the
introduction, little attention to this type of queries has been paid
in the context of ontologies. Starting to fill this gap in this section
we formally define counting aggregate queries over ontologies. We
begin with adapting the notion of aggregate conjunctive queries
from the database settings into our context and define how to
evaluate these queries, first over a particular interpretation and
then over a knowledge base. Then we compare our notion with
range semantics in inconsistent databases. We note that, although
our results in the following sections are limited to ontologies of the
DL-Lite family, our definitions in this section are general and do not
depend on the choice of description logic.

4.1. Syntax and semantics of counting queries

Fig. 1. Example queries q1
variables are depicted by black, white, and big grey nodes respectively.

ex (b): free, existential and aggregation

ex (a) and q2

Definition 1. An aggregate conjunctive query (or ACQ ) is an
expression
q(x, f (z)) :- y (x, y, z),
(2)
where x is a tuple of free variables, y is a tuple of existential variables
and z is a tuple of aggregation variables, the body (x, y, z) is a
conjunction of atoms of the form Ai(t) or Pj(t1, t2) with terms t, t1,
t2 from x y z Ind, and f (z) is an aggregation function. Similarly
to plain CQs, if x is empty, then the ACQ is Boolean.

Amongst typical aggregation functions considered in database
theory and practice we find count Count(), count distinct Cntd(z),
minimum Min(z), maximum Max(z), average Avg(z), and sum
Sum(z). In this paper we concentrate on the first two functions
(note that count is nullary while count distinct is unary). We call
ACQs using these two functions counting ACQs in general, while
count and count distinct ACQs individually. Note that Count() and
Cntd(z) are essentially the only standard counting functions in
SQL:1999 [23] and SPARQL 1.1 [20].

Before proceeding with the formal semantics of counting

aggregate queries, we give a couple of simple examples.

Example 2. Consider a vocabulary with an atomic concept Parent
and role HasChild. The query
ex(x, Count()) :- y Parent(x)  HasChild(x, y)
q1
is a count ACQ that is intended to count the children of each parent.
The query
ex(Cntd(z)) :- y Parent(y)  HasChild(y, z)
q2
is a (Boolean) count distinct ACQ. This query counts all different
children having a parent. The graphical representations of these
queries in the conventional for this paper way are given in Fig. 1.
For the formal semantics we need the following auxiliary no-
tion. The core of an ACQ q of the form (2) is the CQ  q(x 
z) :- y (x, y, z). In other words, the core of a query has the same
body as the original ACQ but considers the aggregation variables
as free. Finally, it will be useful to write N for the set of natural
numbers with 0 and +.
Definition 3. A count ACQ q(x, Count()) holds for an interpretation
I, tuple a of individual names from Ind, and number n  N
(written I |= q(a, n)) iff n is the number of distinct matches for
the core  q and a in I.

Informally, for a tuple of individual names a count query returns
the number of possible matches of the body to the interpretation
which send the free variables to the (interpretations of the)
individual names.

Definition 4. A count distinct ACQ q(x, Cntd(z)) holds for an
interpretation I, tuple a of individual names, and number n  N
(written I |= q(a, n)) iff n is the number of distinct a  Ind such
that I |=  q(a, a) for the core  q of q.

We begin with the syntax of aggregate queries and their semantics with respect to a single interpretation. The last is, essentially,
the semantics in the relational database sense, where only a single
world is considered. We generally follow standard database theory
literature on the topic, such as [12].

The intention of this type of queries is different from count
ACQsthey count the number of different possibilities of mapping
z into the interpretation such that the rest of the query can be properly matched. This difference is illustrated in the following exam-
ple.

ab98

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

Example 5. Coming back to Example 2, consider an interpretation
I which interprets all names by themselves and satisfies
Parent I = {Ann},
HasChildI = {(Ann, Joe)}.
It is not difficult to see that I |= q1
ex(1), that
is, in I Ann has one child, and there is precisely one child with
a parent. For an interpretation J which interprets all names by
themselves, and satisfies
Parent J = {Ann, Peter},
HasChildJ = {(Ann, Joe), (Ann, Rose), (Peter, Joe)},
we have J |= q1

ex(Ann, 1) and I |= q2

ex(Peter, 1), and J |= q2

ex(Ann, 2), J |= q1

ex(2).

Since we concentrate on counting aggregate queries, we do not
give formal semantics for queries with other aggregation functions.
However the intuition behind their semantics is very similar to
count distinct ACQs: a value is an aggregate answer if it is the result
of applying the aggregation function to the multiset of all elements
witnessing the aggregation variable by matches for the core query
in the interpretation.

4.2. Certain answers of counting queries over ontologies

A knowledge base normally describes not a single model but
an infinite number of them. This is why one is typically interested
in computing the certain answers of queries over a KB, which are
usually defined as the intersection of the answers to the query over
all possible models of KB [5,10].

Unfortunately, a definition based on such a syntactical intersection is of little use for ACQs. Indeed, this intersection is almost always empty, as illustrated in the following example.

Example 6. Let Kex be a knowledge base with the TBox consisting
of the inclusion Parent  HasChild, and the ABox consisting of the
assertion Parent(Ann). The interpretations I and J from Example 5
are models of Kex. Also, in this example we listed all the answers
to the queries q1
ex, so it is straightforward to check that
the intersections of the relevant sets for only these two models of
Kex are already empty (of course, there are infinitely many other
models).

ex and q2

This suggests to avoid using syntactic intersection when defining the semantics of ACQs over ontologies. In the context of OBDA
this problem has been identified before by [14]. The proposed solution was to concentrate only on aggregating over epistemic knowl-
edge, that is, over the (interpretations of) individual names which
are explicitly mentioned in the ABox. Such epistemic answers usually have a non-empty intersection over all the models for the standard aggregate queries, including Max and Average. However, for
counting queries such answer may be somehow non-satisfactory.
For example, the epistemic answer to the ACQ q1
ex over Kex from
Example 6 is (Ann, 0), because we do not know any individual who
is definitely a child of Ann, even if we know for sure about the existence of one of them.

In order to define our semantics we come back to the original
intuition behind certain answers: these are the answers that hold
in every possible model. For the case of counting ACQs, we cannot
be certain of the precise result of the count function. But if the result of a query is greater than or equal to a number n in every model
of a knowledge base, then we can say with certainty that the result
of a query is always at least n.

This is why we suggest the following definition of certain answers for counting ACQs over DLs: it is the set of all numbers no
greater than the minimum of the values of the counting function
over all the possible models of the KB.

Definition 7. A non-negative number n  N is in the aggregate
certain answers Cert(q, a, K) to a counting ACQ q and tuple a of
individual names over a KB K iff n  minI|=K{k | I |= q(a, k)}.

The following example illustrates the described intuition.

Example 8. For the KB and queries defined in the previous examples we have that Cert(q1
ex, Ann, Kex) contains 0 and 1, but not 2
or any greater number. This reflects the fact that in any model of
the KB we have at least one child of Ann (and at least 0 as well). By
ex, a, Kex) consists of 0 and 1. (Here and
the same reasons Cert(q2
further in the paper a is the empty tuple of individual names).

Note that under our definition every number that is smaller or
equal than the minimum value over all the models is an aggregate
certain answer. As mentioned above, this is in line with the idea
that certain answers are all those answers that hold in every model:
we cannot ask for the precise value of the counting function, but we
can ask whether such value is always at least n. We focus on the
decision problem of answering this question because it resembles
usual database decision problems. However, the problem of
computing this minimum (and its corresponding decision problem
of asking whether n is the minimum) is also important and needs
to be studied. We comment on this in the conclusion.

Similarly to the case of CQs, if a KB is unsatisfiable, then by this
definition any number is a certain answer to any counting query.
Hence, this case is vacuous, and we assume that all KBs are satisfi-
able.

A definition such as above is non-trivial only for counting standard aggregate queries. Indeed, it relies on their simple property
that the minimum above can potentially be any number greater
than or equal to 0. For other aggregation functions it is not the case:
e.g., such a minimum for Average is trivially almost always .

4.3. Range semantics of aggregate queries

As mentioned in the introduction, aggregate queries have been
explored in other settings which deal with many models. In par-
ticular, here we compare our notion with that of range semantics,
defined in the context of inconsistent databases in [17] and later
adopted in data exchange [18,19]. This semantics focuses on the
interval of possible aggregation values over all models. In the context of counting ACQs over ontologies it can be defined as follows.
The range of answers to a counting ACQ q and a tuple a of individual names over a KB K is the interval[m(q, a, K), M(q, a, K)],
where
m(q, a, K) = min
I|=K
M(q, a, K) = max
I|=K

{k | I |= q(a, k)},
{k | I |= q(a, k)}.

It is easy to see that the lower bound of the range interval coincides with the maximal certain answer according to Definition 7.
Considering the upper bound, let us come back to the examples
in the previous section. We can find a model I of K such that
ex(Ann, n) for any number n  1. Hence, in this case the
I |= q1
upper bound is +. Similar situation is in the case of q2
ex. The following proposition says that this is indeed not unusual.

Proposition 9. Given a counting ACQ q, a tuple a of individual
names, and a satisfiable DL-Lite KB K, the upper endpoint M(q, a, K)
of the range of answers belongs to the set {0, 1,+}, and can be
computed in polynomial time (in the size of q and K).
Proof. Let q(x, f (z)) :- y (x, y, z) and K = T , A.
Let us start by considering situations when the upper endpoint
is 0. According to the definitions, the only possibility for M(q, a, K)
to be 0 is that the core  q does not have a match sending x to a in
any model of K. Next we show that this case is possible and can be
checked in polynomial time. Consider a fresh individual name au

. We claim that  q does

 be a KBT , A  Ag(q(a))

for every existential or aggregate variable u  y z, and a function
g mapping all individual names to themselves, free variables x to a,
and every other variable u of q to au. Let Ag(q(a)) be an ABox, which
contains the assertion S(g(t)) for every (unary or binary) atom S(t)
in (x, y, z), and K

not have a match sending x to a in any model of K if and only if K
 is satisfiable, then every model I of
is not satisfiable. Indeed, if K
 is also a model of K, and the function which maps every term t

to the interpretation of the individual name g(t) under I is such a
match. On the other hand, if there is a model I of K with a match h
for  q and a in I, then it can be extended to a model of K
 by setting
u = h(u) for every u  y  z. Such a situation is clearly possible
aI
and checking satisfiability can be performed in polynomial time.
Let us proceed to situations when the upper endpoint is 1. As-
 is satisfiable, and q is a count ACQ
sume that the extended KB K
without existential variables, that is, z and y are empty. In this case
 (which is also a model of K) has a match for  q and
any model of K
a. On the other hand, none of the models can have more, because of
the lack of existential variables. Hence, we have M(q, a, K) = 1.
Again, such a situation is possible and can be checked in polynomial time.
 is
satisfiable and z  y is not empty, then the upper endpoint is +.
 (which is also a model of K), a match h
Consider a model I of K
for  q and a in I, and a variable u, which is either (the only variable)
from z, if it exists in case of q is count distinct, or from y otherwise.
Construct an interpretation I+ with the domain extending DI by
an infinite number of new elements di, i  1, and interpretation
function extending I for atomic concepts A and roles P as follows:
di  AI+
(di, d)  P I+
(d, di)  P I+
Essentially, I+ extends I by an infinite number of copies of h(u).
 and K. On the other, the
On one hand, I+ is a model for both K
mapping h is still a match for  q and a in I+, and all the mappings
hi, i  1, such that hi(u) = di and hi(u) = h(u) for all u = u are
also matches. Moreover, these matches create new witnesses for
the aggregation variable z in case of q is count distinct. So, we have
that I+ |= q(a,+), as required. 

For the remaining case we show that if the extended KB K

h(u)  AI,
(h(u), d)  P I,
(d, h(u))  P I.

iff
iff
iff

We may thus say that the aggregate certain answers semantics
from Definition 7 is an adaptation of the range semantics of [17] to
ontologies.

5. Data complexity of counting queries

In this section we begin with the data complexity of the problem
of computing aggregate certain answers. We concentrate our study
on the defined above variants of description logics from the DL-Lite
family and counting ACQs. Formally, let X  {core, R}, T be a TBox
over DL-LiteX, and q(x, f (z)) be a counting ACQ. We are interested
in the following family of problems.

f -Aggregate Certain Answers (T , q)

Input:

Question:

ABox A, tuple a,
and number n  N.
Does n  Cert(q, a,T , A)?

The main result of this section is the coNP-completeness of Aggregate Certain Answers for count and count distinct queries
over both DL-LiteR or DL-Litecore knowledge bases. In particu-
lar, this implies a jump from the complexity of answering standard conjunctive queries over knowledge bases, which is in P
(assuming P = NP). So why is answering aggregate queries more

complex? The main reason is that one can no longer compute aggregate certain answers by simply posing queries over the canonical model: a counting query may yield a given number n when
posed over the canonical model, but it is possible to compress the
canonical model by identification of elements and obtain a model
with a smaller number of witnesses for the counting query.
We thus need a much more involved algorithm for computing
these answers. Let q(x, f (z)) be a counting ACQ and K = T , A
a knowledge base. In order to check that n  Cert(q, a,T , A)
for a tuple a of individual names and a number n, we need to
find a counterexample in the form of a model I0 of K such that
I0 |= q(a, n0), for some n0 < n. Hence, the idea of the proofs
below is to show the following small model property: if such
a counterexample exists, then there exists a counterexample of
polynomial size (with respect to |A|). The coNP algorithm then
consists of guessing this small counterexample I0 and evaluate q
over I0 in polynomial time to verify that I0 |= q(a, n0), for some
n0 < n. We also show that the coNP bound is tight.

5.1. Count queries

by introducing the required notation.

We first establish the upper bound for count ACQs. Let us begin
Let I0 be a model of a KB K = T , A and D be a subset
of the domain DI0 of I0 which includes all the interpretations
aI0 of individual names a from Ind. Since I0 is a model, there
exists a homomorphism f from the canonical model Can(K) to I0.
Consider a mapping f  : DCan(K)  (D  DCan(K)) defined as

f (d) =f (d),

d,

if f (d)  D,
otherwise.

(3)

0 of I0 for D is the image of Can(K) under
Then the interleaving I
f , that is the interpretation whose domain is the range of f , the
interpretation of individual names coincides with the one in I0,
and where f (d) is in the interpretation of an atomic concept or
role S and a tuple (an element or a pair of elements) d if and
only if d  SCan(K). Clearly, I

is a model of K. Essentially,

the transformation from I0 to I
0 drops everything which is not
enforced by f and preserves I0 only on D, while replacing the rest
with the corresponding parts of the canonical model.
Next important notion is, essentially, the restriction of the interleaving I
to all the elements which are reachable from a
given element by (undirected) paths through role interpretations
of bounded length and without intermediate nodes from D. For-
mally, let k be a positive number. Then, for every element d in the

0 which is not in D, the k-neighbourhood Nk(d) is the
domain of I
set of all domain elements d such that there exist d0, . . . , di, i  k,
with
- d0 = d, di = d,
- dj  D for all j, 0  j < i, and
- there exists a positive role Rj (that is, an atomic role or its
inverse) such that (dj, dj+1) is in the interpretation of Rj under

Note that according to this definition the last element di can be in
D.

0 which are not in
D are the elements of the canonical model, so they have the form
dw with w = aR1 . . . Rm, m  1. Moreover, by the construction
of the interleaving, for the k-neighbourhood Nk(d) of an element
d there exists an element dw of the canonical model such that
f (dw)  Nk(d) and w is a prefix of w for any element dw with
f (dw )  Nk(d). We call this element the root of Nk(d). Note that
f (dw) can be either in D or dw itself.
We define the following equivalence relation on elements in the
0 which are not in D: dk

D d for d and d with roots

Recall that the elements in the domain of I

for all 0  j < i.

domain of I
dw and d

w if and only if

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

1. for any word w1

)  Nk(d),

)  Nk(d)  D;

)  Nk(d) iff f (dww1
)  Nk(d)  D iff f (dww1

2. |w|  |w| (mod 2k + 1), that is, |w| and |w| are congruent

(a) f (dww1
(b) f (dww1
modulo 2k + 1.
The first requirement essentially says that the neighbourhoods
of equivalent elements are isomorphic. The second one guarantees
that the distance between equivalent elements in the canonical
model is large enough.

Having this definitions at hand we are ready to prove the

following key lemma.
Lemma 10. Let K = T , A be a DL-LiteR KB and q(x, Count()) be
a count ACQ. Then there exists a number l depending only on q and T
such that if there is a model I0 of K with I0 |= q(a, n0) for a tuple a
of individual names and a number n0  (|Ind|+|T |)|q|, then there is a
 |= q(a, n)
model I
for some number n  n0.
Proof. Let q(x, Count()) :- y (x, y).

 of K with domain of O(|Ind|l) elements with I

To complete the proof we need to show that I

Let D be all the elements of DI0 which are either interpretations of individual names from Ind or images of the variables y by
matches for the core  q and a in DI0. Let I
 be the interpretation

0 of I0 for D by identifying all
obtained from the interleaving I
elements d and d such that d|q|
 is indeed a
D d. First, note that I
model of K, because it is an image of a canonical model and satisfy
all negative inclusions of T by the construction of the equivalence
|q|
D. Furthermore, note that the identification does not create new
matches for the core  q and a, since we are identifying elements
with the same |q|-neighbourhood, and they are at sufficient distance from each other.
 has no more
than O(|Ind|l) elements for some l. By definition, every element of
the canonical model Can(K) different from da for a  Ind, has at
most |T | + 1 immediate neighbours (i.e., elements connected by
an atomic role or inverse). Hence, by construction, each element
0 which is not in D also has at most |T | + 1

in the interleaving I
immediate neighbours. It means that the|q|-neighbourhood of any
element cannot have more than (|T | + 1)|q| elements. Moreover,
since the equivalence |q|
D only needs to preserve D, and the
interpretations of concepts and roles in the neighbourhood are
completely defined by its root, the number of different equivalence
classes of |q|-neighbourhoods generated by |q|
D on ID belongs to
). Since |D|  n0|q| + |Ind|, the number of elements in
O(|D||T ||q|
the domain of I
O((|q|  (|Ind| + |T |)|q| + |Ind|)|T ||q|
Since T and q are fixed, we conclude that there exists a number l
as required. 

 belongs to

).

Fig. 2. Query qd-count (Count()). It consists of two disconnected parts, one of
triangular form, which is intended to detect colourings having an edge assigned
with the same colour on both ends, and another being an isolated variable detecting
all the colours used in the colouring.

where dRm for roles Rm in T are fresh elements. There exist at most
(|Ind| + |T |)|q| matches for the core of q in this model. Hence,
without loss of generality, we may assume that n  (|Ind|+|T |)|q|,
because otherwise the answer to our decision problem is trivially
no. Note that this bound is polynomial in the size of the input,
since q is fixed.

By Lemma 10 there exists a number l depending only on q and
T (i.e., fixed in the settings of this lemma), such that if there is a
falsifying model I0, that is a model of K with I0 |= q(a, n0) for
n0 < n, then there is a model I of K over O(|Ind|l) elements with
I |= q(a, n) for some number n  n0. Hence, to verify that n
is a certain answer, we need to check whether J |= K implies
that there are at least n matches for the core of q and a to J in all
interpretations J over O(Ind|l) elements. However, such a check is
in coNP, since a check for a particular J can be done in polynomial
time (recall, that q and T are fixed in this lemma). 

Not that the proof of the upper complexity bound does not
depend on the UNA, so the result also holds if we do not adopt it.
Next we set the matching lower bound.

The proof of the following lemma is by reduction from the
complement of the 3-colouring problem. The input for the 3-
colouring problem is an undirected graph G(V, E ), where V is the
set of vertices and E is the set of edges, and the answer is positive
if and only if the graph has a 3-colouring. This problem is known
to be NP-complete [24]. In this proof, as well as in the proof of the
following Lemma 16 which also makes use of a reduction from the
3-colouring problem, it will be convenient to assume that G does
not have isolated vertices. Clearly, this restriction does not change
the complexity of the problem.

Lemma 12. There exist a DL-Litecore TBox T and a Boolean count ACQ
q such that checking whether n  Cert(q, a,T , A), for an ABox A,
a number n and the empty tuple a, is coNP-hard.
Proof. We begin with the definition of a fixed TBox and count
query, then explain how to construct an ABox on the base of an
instance of the problem, and finally show that number 4 is a certain
answer if and only if the instance has no 3-colouring.

Let Edge and HasCol be atomic roles and Col be an atomic

concept. Fix a DL-Litecore TBox
T = {Edge  HasCol,HasCol  Col},
which is intended to assign a colour to every vertex. Fix also a
Boolean count ACQ
qd-count (Count()) :- yv, yu, yc , y
Edge(yv, yu)  HasCol(yv, yc )  HasCol(yu, yc )  Col(y
c ).
The graphical representation of this query is given in Fig. 2.

Consider now an instance G(V, E ) of the complement of the 3-
colouring problem and construct the ABox on its base as follows.
Let Ind = V  {r, g, b, a}. The ABox A contains
- assertions Edge(v, u) and Edge(u, v) for each edge (v, u)  E,
- assertion Col(c) for each c  {r, g, b},
- assertions Edge(a, a) and HasCol(a, r).

We are ready to state and prove the main result of this section.

Lemma 11. Let T be a fixed DL-LiteR TBox and q(x, Count()) be a
fixed count ACQ. Checking whether n  Cert(q, a,T , A), for an
ABox A, tuple of individual names a, and number n can be done in
coNP.
Proof. The knowledge base K = T , A always has a model with
the domain of the size no greater than |Ind| + |T |. (Recall that we
assume K to be satisfiable.) For example, this is the case for the
model constructed the image of Can(K) under the homomorphism
h defined as
h(da) = da,
h(daR1...Rm

) = dRm

Fig. 3. Part of Can(Kd-count ) related to an edge (v, u) of the graph G with some
matches for the core of qd-count (Count()) highlighted.

The part of the canonical model of K related to an edge in
G is depicted in Fig. 3 (the names of the elements are omitted
for brevity). Intuitively, the individual names r, g and b represent
colours, and the role HasCol is intended to connect a vertex in the
graph with a colour. The individual name a plays an auxiliary role:
it guarantees the count to be at least 3 in every model I of the KB
Kd-count = T , A, that is, I |= qd-count (a, 3).
Indeed, there are three matches for the core of the query to the
part of the canonical model corresponding to the ABox, each of
which mapping yv and yu to da, yc to dr, and y
c to one of dr, dg,
and db. One of these matches, in particular, the match mapping y

to dg is highlighted by light grey lines in the figure. Besides these
three, for each vertex v there is a match for the core of the query
to the canonical model Can(Kd-count ) which maps yv, yu and yc as
above, and y
c to the element connected to dv by HasCol. In search
of a model with the minimal number of matches we may identify
such elements with r, g and b (recall that we generally assume UNA
in this paper, that is, interpretations of individual names, such as
dr , dg, and db, cannot be identified; see the discussion after this
proof). However, if we do it without care we may introduce new
structures which agree with the triangular part of the query, and
increase the number of matches, as highlighted by dark grey lines
in the figure.
Using these observations, next we formally show that G(V, E )
has a 3-colouring iff 4  Cert(qd-count , a, Kd-count ) (i.e., there is at
least four matches for the core query in every model).
() Assume first that 4 does not belong to Cert(qd-count , a,
Kd-count ). Thus there exists a model I of Kd-count such that I |=
qd-count (a, 3) (we know from the observation above that the count
cannot be any number less than 3).
Since ACQs are monotone, it is safe to assume that for every
vertex v  V there exists a single element d  DI such that (dv, d)
in HasColI.
Let us define the following colouring  : V  {red, green,
blue} of G: for each vertex v  V, we set

 (v) = red
 (v) = green
 (v) = blue

(dv, dr )  HasColI,
(dv, dg )  HasColI, and
(dv, db)  HasColI.

iff
iff
iff

means that the pairs (dv, dr ) and (du, dr ) belong to HasColI. We
can then construct a fourth match h for the core of qd-count in DI:
h(yv) = dv, h(yu) = du, h(yc ) = dr, and h(y
c ) = dr, which again
contradicts the fact that I |= qd-count (a, 3).

We obtain that  is a 3-colouring as required.
() Assume that there is a 3-colouring  of G. To make sure
that 4  Cert(qd-count , a, K), consider an interpretation I defined
is as follows:
DI = {dc | c  V  {r, g, b, a}},
cI = dc , for c  V  {r, g, b, a},
ColI = {dr , dg , db};
EdgeI = {(da, da)}
{(dv, du), (du, dv) | (v, u)  E};
HasColI = {(dv, dr ) | v  V,  (v) = red}
{(dv, dg ) | v  V,  (v) = green}
{(dv, db) | v  V,  (v) = blue}.

A direct verification shows that I is a model of Kd-count. Next we
show that I |= qd-count (a, 3). We know that there are 3 matching
for the core of qd-count in DI which map the variables yv, yu to da; the
variable yc to dr; and the variable y
c to either dr, or db, or dg. From
the definition of ColI and HasColI, any other match must send yv
and yu to some dv and du such that EdgeI contains (dv, du), that
is, (v, u) is an edge in G. Hence, if such a fourth match exist, then
there is an element d  {dr , dg , db} such that both (dv, d) and
(du, d) are in HasColI, and, therefore,  (v) =  (u). But the last
contradicts the fact that  is a colouring. Hence, I |= qd-count (a, 3)
as required. 

Before summarising the results of this section, we make few

observations.

First, Lemma 12 continues to hold if one drops the UNA. Indeed,
to make the reduction work for the case without the UNA it suffices
to guarantee that any pair of individual names from{r, g, b} cannot
be interpreted by the same element in any model of Kd-count and
that a cannot be interpreted by the same element as any of v 
V. We can do this by extending the ABox by assertions Red(r),
Green(g), Blue(b), Aux(a), and Vertex(v) for all v  V, as well as
extending the TBox with negative inclusions for disjointness of the
concepts Red, Green, and Blue such as Red  Green, and similar
inclusions Aux  Vertex, Vertex  Aux.

Second, the proof above makes use of the non-connectivity
of the query qd-count (Count()). It is an interesting open problem
whether the result holds for connected queries.

The lower bound was shown for DL-Litecore, while the upper
bound holds for any DL-LiteR KB. Since DL-LiteR is more expressive
than DL-Litecore, the lemmas above give us the following complexity
result.

We now show that  is indeed a proper 3-colouring.
First, we show that  assigns a colour to each vertex in V.
For the sake of contradiction, assume that it does not hold. Then
there must be a vertex v such that HasColI does not contain any of
(dv, dr ), (dv, dg ), and (dv, db). Since we know that there is u  V
such that (dv, du)  EdgeI (recall, that we assume that G does
not have isolated vertices), and since Edge  HasCol, it follows
that there is an element d different from dr, dg, and db, such that
(dv, d)  HasColI. But then also d  ColI since HasCol  Col,
and we can construct a fourth match h for the core of qd-count to DI:
h(yu) = h(yv) = da, h(yc ) = dr and h(y
c ) = d. This contradicts the
fact that I |= qd-count (a, 3).
Next we show that  is indeed a correct colouring. Assume
for the sake of contradiction that this is not the case. Then there
is an edge (u, v)  E such that  (v) =  (u). Without loss of
generality let  (v) =  (u) = red. From the definition of  , it

Theorem 13. The problem Count-Aggregate Certain Answers
(T , q) is coNP-complete in data complexity for DL-LiteX TBoxes T
with X{core,R}.

Thus the data complexity of count query evaluation rises from
P in the relational database case to coNP-complete for DL-Lite
knowledge bases.

5.2. Count distinct queries

In this section we show that the data complexity of computing
aggregate certain answers for count distinct queries is the same as
for count queriesthe problem is coNP-complete.

We again start with the upper bound. The proofs of the
following two lemmas are very similar to the proofs of Lemmas 10
and 11, and thus we only summarise the (very few) differences.

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

Fig. 4. Query qd-cntd(Cntd(z)).

Lemma 14. Let K = T , A be a DL-LiteR KB and q(x, Cntd(z)) be
a count distinct ACQ. Then there exists a number l depending only on
q and T such that if there is a model I0 of K with I0 |= q(a, n0)
for a tuple a of individual names and a number n0  |Ind| + |T |,
 of K with domain of O(|Ind|l) elements with
then there is a model I
 |= q(a, n) for some number n  n0.

The difference between the proof of this lemma and the proof
of Lemma 10 is minor: in this case we include into D the
interpretations of all individual names from Ind and the images
of the aggregation variable z in I0 under the matches of the core
(but not the images of the existential variables). This leads to the
required bound on the size of the domain of I

Lemma 15. Let T be a fixed DL-LiteR TBox and q(x, Cntd(z)) be a
fixed count distinct ACQ. Checking whether n  Cert(q, a,T , A)
for an ABox A, tuple of individual names a, and number n can be done
in coNP.
The proof of this lemma goes along the same lines as the proof of
Lemma 11 except that we bound n by|Ind|+|T | and use Lemma 14
instead of Lemma 10. Similarly to the case of count queries, the
proof does not depend on UNA, so the result holds if we drop it.

Next we establish the matching lower bound. The proof of the
following lemma is again by a reduction from the complement
of the 3-colouring problem. However, the construction is more
intricate and requires a separate description.

Lemma 16. There exist a DL-Litecore TBox T and a Boolean count
distinct ACQ q such that checking whether n  Cert(q, a,T , A)
for an ABox A and a number n is coNP-hard.
Proof. Just as in to the proof of Lemma 12 in the previous section
we first define a fixed TBox and count distinct query, then explain
how to construct an ABox on the base of an instance of the complement of the 3-colouring problem, and finally show that number
4 is a certain answer if and only if the instance has no 3-colouring.
Let Edge, Aux, and HasCol be atomic roles. Fix a DL-Litecore TBox
T = {Edge  HasCol},
intended to assign a colour to every vertex. Fix also a Boolean count
distinct ACQ
qd-cntd(Cntd(z)) :- yv, yu, yc , ya
Edge(yv, yu)  HasCol(yv, yc )  HasCol(yu, yc )
 Aux(ys, yu)  HasCol(ys, z).
The graphical representation of this query is given in Fig. 4. The triangular part plays a similar role as the triangular part in the count
query qd-count in Lemma 12.

Consider the set of individual names

Given an instance G(V, E ) of the complement of coNPcomplete 3-colouring problem, we construct the ABox on its base,
as follows.
Ind = {v, vv, vu, vc , vs, vz | v  V}  {r, g, b, a, av, au, ac}.
Let A contain
- the assertions Edge(v, u) and Edge(u, v) for each (v, u)  E;

Fig. 5. Part of Can(Kd-cntd) related to an edge (v, u) of G with some matches for the
core of qd-cntd highlighted.

- the

assertions Aux(v, vu), HasCol(vu, vc ), HasCol(vv, vc ),

Edge(vv, vu), Aux(vs, v) and HasCol(vs, vz ) for each vertex v;

- the

assertions Aux(a, au), HasCol(au, ac ), HasCol(av, ac ),

Edge(av, au), HasCol(a, r), HasCol(a, g), and HasCol(a, b).
Fig. 5 depicts the part of the canonical model of K that is related to an edge in G. Intuitively, the individual names r, g and b
represent colours, and the role HasCol is intended to connect vertices in the graph with their colours. Other individual names play
auxiliary roles as follows. The individual name a guarantees the
count of the images of z to be at least 3 in every model I of the KB
Kd-cntd = T , A, that is, I |= q(a, 3) by means of matches mapping the aggregation variable z to one of dr , dg, and db, the variable
ys to da, and the variables in the triangular part of the query to the
interpretations of av, au and ac. In Fig. 5 one of these matches (with
z mapped to dr) is highlighted by thin light grey lines on the left.
Besides these three, for each vertex v there is a match from the
core query to the canonical model Can(Kd-cntd) which maps z to
the anonymous element connected to dv by HasCol, ys to dv and
the triangular part to such a part corresponding to dv (this match is
depicted by thick light grey lines in the figure). Hence, each of these
matches maps z to a separate element, thus increasing the aggregate value for the canonical model. In search of a model with the
minimal value we may identify such anonymous elements with dr,
dg, and db. However, if we do not do it with care, we may introduce
new structures which match with the triangular part of the query
by interpretations of some adjacent in G vertices v, u and a colour
vertex, and the rest of the query with, for example, the interpretations of vs and vz. In particular, in this case the aggregation variable
z is mapped to the interpretation of uz, which increases the aggregate value. Such a possible match is highlighted in the figure by
thin dark grey lines, assuming that the white nodes are identified.
Using these observations, it is possible to formally show that
G(V, E ) has no 3-colouring iff 4  Cert(q, t, K) (i.e., for every
model there is at least four different images of z in the domain with
corresponding matches for the rest of the query). This proof goes
the same lines as the second part of the proof of Lemma 12, so we
omit it for brevity. 

This lemma again holds for the case when UNA is dropped, and
the proof can be adopted in the same way as the proof of Lemma 12.
The following theorem summarises the results of this section.

Theorem 17. The problem Cntd-Aggregate Certain Answers
(T , q) is coNP-complete in data complexity for TBoxes T in DL-LiteX
with X  {core, R}.

6. Combined complexity of counting queries

Although data complexity is arguably the most used measure
of algorithms in database settings, combined complexity has its
own value for understanding fundamental properties of problems.
In this section we study the combined complexity of computing
aggregate certain answers. Formally, let X  {core, R} and f be
a counting aggregation function. Now we are interested in the
following family of problems.

DL-LiteX f -Aggregate

Certain Answers

Input:

Question:

DL-LiteX KB K, f ACQ q,
tuple a, and number n  N.
Does n  Cert(q, a, K)?

6.1. Count queries

We start again with count queries. Recall the algorithm to compute the certain answers for count queries explained in the proof
of Lemma 11. Note that if one takes into consideration the size
of the query and the TBox, then this algorithm naturally gives a
coN2ExpTime upper bound; the only difference is that in this case
the number of neighbourhoods is of double exponential size (with
respect to the size of q and T ), and thus the model we need to guess
is of double exponential size.

Unfortunately, for the case of DL-LiteR, we are not able either to
improve this upper bound or to show that this bound is tight. How-
ever, we are able to prove that the problem is coNExpTime-hard.
This lower bound is interesting in its own right, because it coincides with the complexity of answering similar queries in other
database scenarios that feature incomplete information (see, for
example, [25]).

2 -hardness.

As we see later in this section, the situation is different for the
case of DL-Litecore. Again, we cannot establish tight bounds, but can
improve the general algorithm on one exponent, to coNExpTime,
and show  p

We start with the coNExpTime-hardness of Aggregate Certain
Answers for count queries and DL-LiteR ontologies. This lower
bound is established by a reduction from the complement of the
following version of the tiling problem, that we call here the NExptiling problem. Its input is a quadruple (C, H , V, n), where C is a
set of colours, H , V  C C are horizontal and vertical adjacency
relations on the colours, and n is a number given in unary; the
output is positive if there exist a tiling of a 2n  2n square which
use unitary tiles coloured from C in such a way that each pair of
horizontally adjacent tiles satisfies the relation H and each pair of
vertically adjacent tiles satisfies the relation V. This problem was
shown to be NExpTime-complete in [26].

Lemma 18. The decision problem DL-LiteR Count-Aggregate Certain Answers is coNExpTime-hard.
Proof. As mentioned above, the coNExpTime-hardness is established by a reduction from the complement of the NExp-tiling
problem. In what follows we first explain how to, given an instance (C, H , V, n) of this problem, construct in polynomial time a
DL-LiteR knowledge base Kc-count and Boolean count query qc-count,
and then show that |C| + 1  Cert(qc-count , a, Kc-count ) iff the answer for the instance is positive.
Roughly speaking, the idea of the construction is as follows.
Each model of Kc-count represents a possible tiling of the 2n  2n
square, and has at least p matches for the core query  qc-count; in
turn, each violation of the adjacent tiles from H or V increases the
number of matches. In this way, the only possibility for p+ 1 to be

0 , Hn

0 , V n

not a certain answer is the existence of a model that represents a
tiling in which there are no violations.

Let (C, H , V, n) be an instance of the NExp-tiling problem. We
start the construction with the vocabulary. It consists of atomic
roles
- Hn

0 , . . . , H1
1 used to
identify tile positions in the square by horizontal and vertical
coordinates represented in binary (reverse numeration n, . . . , 1
of bits is convenient for representation of such binary numbers
and is used consistently throughout this proof);

1 and V n

1 , . . . , V 1

0 , . . . , V 1

1 , . . . , H1

- H and V subsuming the roles above;
- Bit0 and Bit1 used to identify the bit values in the coordinates;
- Bit subsuming the roles above;
- Tile used to connect a position to a particular colour;
and atomic concepts
- Root to start the construction;
- Zero and One for binary values;
- Colourm for each colour cm in C; and
- Colour subsuming the concepts above.
In what follows we define the set of individual names Ind, ABox
A, TBox T and core query  qc-count simultaneously, splitting the
description in conceptual parts. The (possibly nested) subqueries
of the core query will have form (y) = y  (y, y), and we
assume that variables y are globally existential for the superquery,
but the existential variables y are local for each subquery, that is
in the overall query they should be renamed to names fresh for
this subquery (recall that the overall query is Boolean, so all the
variables are existential in it).

Let the set Ind contain

- individual names 0 and 1 as the binary values for defining the

coordinates of the square,

- all the colours cm in C as individual names,
and let the ABox A contain assertions
- Zero(0) and One(1),
- Colour(cm) for each colour cm in C.
Let the core query  qc-count contain the subquery
() = y0, y1, ycZero(y0)  One(y1)  Colour(yc ).

Note that all the variables in this part of the query are locally
existential. Assuming that the rest of the core query has a match in
some model of Kc-count, then the overall core query has at least p
matches each of which maps y0 to (the interpretation of) 0; y1 to
1; and yc to one of the colours cm. Moreover, if a model contains
some other elements in the interpretations of Zero, One or Colour,
then the number of matches is strictly greater that p. Since we want
to check whether there is a model with only p matches, in what
follows we consider only the models which does not have such
other elements.

Let Ind contain individual name
- r as the root of the construction,
and let the ABox A contain assertions
- Root(r),
- Colourm(cm) for each colour cm in C.
Together with the TBox T given next, the individual name r
generates a tree, each leaf of which represents a position in the
square. For all binary values i, j = 0, 1 for bits, all n > k  1, all
n  l  1, and all 1  m  p the TBox T contains the inclusions
- Root  Hn
i ;
)  Hk
- (Hk+1
j ;
i )  V n
- (H1
j ;

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

Using this property we define the subqueries  k
and sv = sn

where wh is a possibly empty binary word of length n  k  1,
n > k  1, wv is a binary word of length n, and parenthesis
are used to delimit the horizontal and vertical coordinates in the
representation.
h , n > k  1,
which are meant to capture such horizontally adjacent positions,
for tuples of variables sh = sn
h, . . . , sk+1
v, . . . , s1
v:
h (yh, yv, uh, uv, y0, y1) = yr , sh, sv

(yr , yh, yv)  (yr , uh, uv)
 Bit(yn
h)    Bit(yk+1
, sk+1
 Bit(yk
h)    Bit(uk+1
 Bit(un
 Bit(uk
v)    Bit(y1
 Bit(yn
 Bit(un
v)    Bit(u1
The structure of this subquery closely corresponds to the binary
representations (4) of horizontally adjacent positionsthe first n
k  1 variables from yh and uh by means of the Bit role represent
an arbitrary but same word wh (matched by sh), and the rest of
these variables represent 0  1k1 and 1  0k1 respectively (as
we will see, y0 should be mapped to 0 and y1 to 1); similarly,
the variables yv and uv represent a word wv (matched by sv), the
vertical component of the positions.

h, sn
h, y0)  Bit(yk1
h, sn
h, y1)  Bit(uk1
v, sn
v, sn

, y0)    Bit(u1
v, s1
v)
v, s1
v).

, y1)    Bit(y1

, sk+1

h, y0)

h, y1)

v, yc

m, yc

m)  Tile(u1

l) = yh, yv, uh, uv
v, yc
m and yc

The next step is to define subqueries detecting horizontally
adjacent positions in which the tiles are not arranged according
to H. We do this as follows. For each pair (cm, cl)  (C  C) \ H,
that is an incorrect pair, and each n > k  1 we define the query
h,(m,l)(y0, y1, yc

h (yh, yv, uh, uv, y0, y1)  Tile(y1

In this subquery the variables yc
l should be mapped
to the (interpretations of the) corresponding colours cm and cl.
Thus, each  k
h,(m,l) asks for a horizontal violation of tiles coloured
cm and cl in the horizontally adjacent positions identified by

h (yh, yv, uh, uv, y0, y1).
Properties, similar to (4) hold for vertically adjacent positions.
Hence, we also define subqueries  k
for each vertically
incorrect pair of colours (cm, cl)  (C C)\ V and each n > k  1
on the base of  k
h,(m,l) are defined
of the base of the  k
h .
core query  qc-count, for the tuple of variables yc = yc
() = y0, y1, yc

We are now in a position to define the main subquery of the

v exactly in the same way as the  k

1, . . . , yc
p:

v,(m,l)

l).

(cm,cl)(CC)\H


n>k1

h,(m,l)(y0, y1, yc

m, yc
l)

v,(m,l)(y0, y1, yc

m, yc
l)

(cm,cl)(CC)\V

n>k1

 Zero(y0)  One(y1)  Colour1(yc
Finally, the core of query qc-count is

1)    Colourp(yc
p).

 qc-count :- ()  ().
Recall our convention about fresh variable names in different
subqueriesfor example, all yh, yv, uh and uv
in different
subqueries for incorrect pairs are different, as well as y0 and y1 are
different in  and .
To complete the construction, we need to define the part of the
ABox A which has a match for  in any model (this is needed for
 to play its role of sending ends of Biti to 0 and 1 respectively and
ends of Tile to colours). The set Ind contains individual names
- r0, hn, . . . , h1, vn, . . . , v1,

Fig. 6. A model of Kc-count, in which, by means of the subquery , all Bit0 lead to
0, all Bit1 lead to 1, and all Tile lead to one of the colours cm (the ones on the left part
are not determined and just sketched). All the indexes of roles are optional (e.g., V n
represents also V ). The right part is auxiliary and required to guarantee that  has

at least one match in any model.

i )  Biti;
1  One;

)  V k
- (V k+1
j ;
i  V ;
i  H and V l
- H l
i )  Biti and (V l
- (H l
0  Zero and Bit
- Bit
- Biti  Bit;
i )  Tile;
- (V 1
- Tile  Colour.
A (part of a) model of Kc-count, satisfying the aforementioned
restrictions is given on the left of Fig. 6. It consists of a tree with
r as the root and Hs and V s as labels of edges. If the subscript of
such a label is 0 then its end has an outgoing edge labelled with
Bit0, which by inclusion Bit
0  Zero and our assumption leads
to (the interpretation of) 0. If the subscript is 1, then the outgoing
edge is labelled with Bit1 and leads to 1. By this, each leaf in the tree
determines a position in the 2n  2n square, by means of binary
representations of horizontal and vertical coordinates along the
branch going to the leaf. Each leaf is also connected by Tile to one of
the tile colours cm, according to our assumption (these connections
are just sketched).
We continue with the definition of  qc-count. As mentioned
above, its idea is to capture those tilings that have been placed
erroneously. To achieve this we make use of several subqueries. For
their definition it will be convenient to use the following subquery
for variable yr and tuples of variables yh = yn
h and yv =
yn
v, . . . , y1
v:
h)  H(yn
(yr , yh, yv) = H(yr , yn
 V (y1
v)  V (yn
h, yn

h, . . . , y1
)    H(y2
h, y1
h)
)    V (y2
v, y1
The subquery (yr , yh, yv) matches any branch in the tree of a
model of Kc-count, that is a position in the 2n  2n square.
The next step is to relate all those pairs of leaves that represent
horizontally or vertically adjacent positions in the square. In order
to do this, we note that the binary representations of horizontally
adjacent positions have the form
(wh  0  1k1)(wv),
(wh  1  0k1)(wv),

h, yn1
v, yn1

(4)

v).

and the ABox A for each i = 0, 1, each n > k  1, each n  l  1,
and each 1  m  p contains the assertions
- H(r0, hn), H(hk+1, hk),
- V (h1, vn), V (vk+1, vk),
- Bit(hl, i), Bit(vl, i),
- Tile(v1, cm).
The graphical representation of the part of a model corresponding
to this part of ABox is given on the right of Fig. 6. It indeed works
as expected: there are exactly p matches for the overall  qc-count in
any model, all of them mapping  to this part, y0 and y1 from 
to (the interpretations of) 0 and 1 respectively, and yc from  to
one of c1, . . . , cp.
Having the construction of the KB Kc-count and query qc-count
completed, next we formally show the correctness of
the
reduction. Using the intuition of the construction, we need to show
that there is a solution to the instance of the NExp-tiling problem
if and only if there is a model I of Kc-count with no matches from
 qc-count to I, except those p.
() Assume that there is no solution of the instance (C, H , V, n)
of the NExp-tiling problem, but yet, for the sake of contradiction,
there is a model I of Kc-count with only those p matches from  qc-count
to I. Without loss of generality we assume that I is minimal in the
sense that there is no any proper submodel of I with this property.
Note that I possesses the following properties:
1. the interpretations of relations Zero and One contain only the

interpretations of 0 and 1, respectively;
2. interpretations of each Colourm contains only the interpretation
of the individual name cm, for cm  C, and the interpretation of
Colour contains all these elements, but nothing else.
Indeed, by the construction of  qc-count, it is clear that a violation of
any of these properties immediately results in more matches for
this query in I.

Consider the canonical model of Kc-count. As noted, the part
connected to the element dr in the interpretation of Root (we know
there is only one such element because of the minimality of I)
forms a tree on interpretations of the roles H and V , each node of
which, except the root, has a Bit-successor and each leaf has a Tile-
successor. We also know that there is a homomorphism from the
canonical model to I, and, since I is minimal, this homomorphism
is surjective. Hence, in I the ends of Bit0 are (the interpretation
of) 0, the ends of Bit1 are 1, and the ends of Tile are among
colours. We can construct a tiling for a 2n  2n square as follows.
The image of each branch in the tree identifies coordinates of a
position in the square in binary, by means of the ends of the Bit-
connections. In this position the tiling has a tile of the colour cm
whose interpretation is connected by Tile with the homomorphic
image of the leaf of the branch (this cm is unique since I is minimal).
By the construction, it must be the case that this is indeed a correct
tiling, because any violation would result in an additional match
for one of the subqueries  k
v,(m,l), which would lead to
more than p matches for the core query  qc-count in I, contradicting
the assumption.
() Assume that there is a solution to the instance (C, H , V, n).
Consider the model I of Kc-count which is the image of a
homomorphism from the canonical model mapping
- all ends of Bit0 to the interpretation of 0,
- all ends of Bit1 to the interpretation of 1,
- all ends of Tile for the leaf of a branch in the tree to the
interpretation of the colour of the tile in the position identified
in binary by the branch, and

h,(m,l) or  k

- all other elements to themselves.
It follows from the construction of  qc-count that no match exists
which maps the variables of this query to some elements in this
tree, that is there are exactly p matches for  qc-count in I. 

Having the results for count queries over more expressive

DL-LiteR, we proceed to DL-Litecore.

As said in the beginning of this section, in this case we are able to
improve the general algorithm and establish a coNExpTime upper
bound. The proof is an adaptation of the algorithm in the proof
of Lemma 11. Recall that this proof shows that there is always a
model of double-exponential size, with respect to all of TBox, query
and ABox, that witnesses that a certain n belongs to the aggregate
certain answers of a query. For the case of DL-Litecore KBs, we are
able to show that one can always find such a model of exponential
size. This is formalised in the following lemma.

Lemma 19. There exists a fixed polynomial P such that for every
DL-Litecore KB over a set of individual names Ind and count ACQ
q(x, Count()) if there is a model I0 of K with I0 |= q(a, n0) for
a number n0  (|Ind| + |T |)|q|, then there is a model I
 over
O(|Ind|P(|q|)) elements with I
 |= q(a, n) for some number n  n0.
Proof. Let D be all elements of DI0 which are either interpretations of the individual names from Ind or images of variables by

matches for the core of q in DI0. Consider the interleaving I
0 of
I0 for D.
The proof goes along the same lines as the proof for Lemma 10,

as we construct from I
0 a much smaller model by merging elements with similar neighbourhoods. As a base for the neighbourhood for an element d, we could still consider all elements
connected to d by paths of length |q| or less. Though, from the
properties of DL-Litecore one can show that it is safe to consider
the equivalence relation which is much more general than for
DL-LiteR knowledge bases, which ends up in an exponential increase in the number of elements that can be merged. This is justified by the following property.
First, note that since K is a DL-Litecore knowledge base, every element d in the domain of the interleaving that is not in D has the
following property: for any atomic role or inverse of a role R there
exists at most one element d with (d, d) in the interpretation of R.
Consider now the body (x, y) of q, and let d be an element in the domain of the interleaving outside D. For ease of
explanation assume that q is Boolean (i.e., x is empty) and the
|q|-neighbourhood N|q|(d) of d contains only elements outside D.
Further, assume that there is a match h for q in N|q|(d) such that d is
in the image of h, say, d = h(y) for some y from y. By the properties
of canonical models that we have mentioned above, it must be the
case that all matches for q in N|q|(d) mapping y to d (including h)
come from automorphisms in q, that is, are such that the subinterpretations of N|q|(d) induced by them are exactly the same.
Using the property above, we consider the following notion instead of the notion of k-neighbourhood in Lemma 10. A subquery q
of the core  q of q is a CQ whose body is a conjunction of (not necessary all) atoms in the body of  q. Given an element d in the domain of

0 which is not in D, the q-neighbourhood N
q (d) of d is the set of
all domain elements d such that there exist d0, . . . , di, i  k, with
- d0 = d, di = d,
- dj  D for all j, 0  j < i,
- there exists a positive role Rj (that is, an atomic role or its in-

verse) such that (dj, dj+1) is in the interpretation of Rj under I
for all 0  j < i,

- there is a match for a subquery q of  q and a in I
Rj(dj, dj+1) above in the image.
Having this definition, the rest of the proof is the same as the

proof of Lemma 10. In particular, the root of N
q (d) is the element
dw of the canonical model such that f (dw)  N

q (d) and w is a prefix of w for any element dw with f (dw )  N

q (d) (recall that f 
is the function from the definition of the interleaving given in (3)).
Then, exactly the same as before, we define the following equiva-

lence relation on elements in the domain of I
0 which are not in
D: dq
D d for d and d with roots dw and d

w if and only if

that has all

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

2. |w|  |w| (mod 2k + 1), that is, |w| and |w| are congruent

1. for any word w1

)  Nk(d) iff f (dww1
)  Nk(d)  D iff f (dww1

(a) f (dww1
(b) f (dww1
modulo 2k + 1.
Once again the model obtained from I

)  Nk(d),

)  Nk(d)  D;

0 by identifying the elements d, d such that dq
D d does not create new matches for the
core and a in the resulting model I0. Moreover, from the construction of q-neighbourhoods the model I0 has O(D|p(|q|)) underlying
elements. This finishes the proof of the lemma. 

Using this lemma it is now straightforward to show our upper
bound. The idea of the algorithm, once again, is to guess such an
instance I0, and show that the number of matches for  q and a in I0
corresponds to the desired number.

Lemma 20. The problem DL-Litecore Count-Aggregate Certain
Answers is in coNExpTime.

The coNExpTime reduction shown in Lemma 18 uses role
inclusions in the TBox, that is, it is applicable only to DL-LiteR, but
not to DL-Litecore. We can show a  p
2 lower bound using a reduction
that is very similar to that of Lemma 24 in the following section.
Thus, for space reasons we omit the formal proof of this result. We
have the summarising theorem.

Theorem 21. (1) The problem DL-Litecore Count-Aggregate Certain Answers is in coNExpTime and  p
(2) The problem DL-LiteR Count-Aggregate Certain Answers is in
coN2ExpTime and coNP-hard.

2 -hard.

6.2. Count distinct queries

In Section 5 we adapt the algorithm from Lemma 11 on count
queries to an algorithm in Lemma 15 on count distinct queries. This
algorithm naturally gives us a coN2ExpTime upper bound for the
combined complexity of count distinct query answering. Similarly
to the count queries we can neither improve this bound nor show
that it is tight. However, again, we show coNExpTime-hardness of
this problem for DL-LiteR-ontologies. In the case of DL-Litecore the
situation is again similar to count case: we can improve, in exactly
the same way, the algorithm by one exponent to coNExpTime, and
show  p

2 hardness of the problem.

Let us begin with the general case for DL-LiteR knowledge bases.

We use a reduction similar to the one in the proof of Lemma 18.

Lemma 22. The decision problem DL-LiteR Cntd-Aggregate Certain Answers is coNP-hard.
Proof. As mentioned above, the coNExpTime-hardness is established by a reduction from the complement of the NExp-tiling
problem. In what follows, first we explain how to, given an
instance (C, H , V, n) of this problem, construct in polynomial
time a DL-LiteR knowledge base K R
c-cntd and Boolean count dis-
c-cntd; and then we show that p + 3 
tinct aggregate query qR
c-cntd) for the empty tuple a of individual names
Cert(qR
and p = |C| iff the answer to the instance is positive.
The underlying idea of the reduction is the same as in the proof
of Lemma 18. However, this proof is much more technical, since
dealing with count distinct instead of count queries creates a series
of technical complications.

c-cntd, a, K R

More precisely, recall that in the proof of Lemma 18 we built a
knowledge base such that some of its models represent different
possibilities of tiling the 2n  2n square. The knowledge base, and
in particular the ABox, was constructed in a way that its models
contain (a) a tree identifying tile colours in the positions in the
square and (b) a linear structure, which guarantees that every

model has at least p matches for the core query (see Fig. 6). The
query consisted of several disconnected subqueries, which look for
(a) models which are not tilings, that is, for example, models in
which some positions in the square are not defined, or tile colours
are not assigned to some positions, and (b) incorrect tilings, that
is those that have violations of horizontally or vertically adjacent
tiles from H and V. By this, a model representing a tiling which is
correct has exactly p matches for the core query, and otherwise all
the models have at least p + 1 matches.
The main technical difficulty of this reduction is that all conjuncts in the count distinct query qR
c-cntd(z) have to be connected to
the single aggregation variable z which accomplishes all the tasks
above.

i and V l

Let (C, H , V, n) be an instance of the NExp-tiling problem. The
c-cntd slightly extends the vocabulary of Kc-count
vocabulary of K R
for i = 1, 2
from Lemma 18: it contains atomic roles H l
and n  l  1; H and V ; Bit0 and Bit1; Bit; and Tile; as well as
atomic concepts Root; Zero and One; Colourm for 1  m  p; and
Colour, with the same intended meaning as in that proof, and new
atomic roles
- Aux to connect subqueries,
- HV which subsumes H and V , and
- TileBit which subsumes Tile and Bit.
The last two roles are required, because some parts of the query
need to match conceptually different parts of models. We will see
it in more detail later.

In what follows we show how to construct the TBox, query, and
ABox. We do it in this particular order, because the first two have
minor differences with the construction in Lemma 18 and can be
seen as a basis for understanding the construction, but the last one
is more complicated.

So, we start the construction with the TBox T . It is almost the
same as the TBox in the proof of Lemma 18. We recall the common
part here for completeness. For each i, j = 0, 1, each n > k  1,
each n  l  1, and each 1  m  p the TBox T contains the
inclusions
- Root  Hn
i ;
)  Hk
- (Hk+1
j ;
i )  V n
- (H1
j ;
- (V k+1
)  V k
j ;
i  V ;
i  H and V l
- H l
i )  Biti and (V l
- (H l
0  Zero and Bit
- Bit
- Biti  Bit;
i )  Tile;
- (V 1
- Tile  Colour.
In addition, we extend T with
- inclusions Tile  TileBit and Bit  TileBit;
- inclusions H  HV and V  HV ;
- negative inclusions stating that Colour1, . . . , Colourm, Zero and
One are pairwise disjoint;

i )  Biti;
1  One;

- negative inclusions stating that Colour is disjoint from Zero and

One.

The positive inclusions are already announced above. The negative
inclusions guarantee, that each colour element is coloured in only
one colour, that a tiling does not put binary numbers instead of tiles
in square positions and so on.

We continue with the query qR

c-cntd(z) and do it in the same way
as in Lemma 18. In particular, we split it into subqueries, and adopt
the convention on local (listed after  before the body of sub-
query) and global (listed as parameters of subqueries) existential
variables in these subqueriesthe first ones should be renamed to
fresh names when combining the subqueries.

c-cntd consists of two subqueries, 
and , fulfilling the same tasks. However, it is more convenient
to start the definition with the second of them.

The base building block of the query is exactly the same as in
Lemma 18. It is the following subquery, for variable yr and tuples
of variables yh = yn
h)  H(yn
(yr , yh, yv) = H(yr , yn
 V (y1
v)  V (yn
h, yn

v, . . . , y1
v:
)    H(y2
h, y1
h)
)    V (y2
v, y1

h and yv = yn
h, yn1
v, yn1

h, . . . , y1

v).

Its intention is to match any branch in the tree of a model, that is a
position in the 2n  2n square.

h, y0)

h, y1)

, sk+1

v, . . . , s1
v,

h, . . . , sk+1

and sv = sn

, y1)    Bit(y1

, y0)    Bit(u1
v, s1
v)
v, s1
v).

h, sn
h, y0)  Bit(yk1
h, sn
h, y1)  Bit(uk1
v, sn
v, sn

The next level of queries is again very similar to the construction
in Lemma 18. The only difference in the following subqueries  k
h ,
n > k  1, capturing horizontally adjacent positions on the base
of representations (4), is that yr is global. Formally, for n > k  1
and tuples of variables sh = sn
h (yr , yh, yv, uh, uv, y0, y1) = sh, sv

(yr , yh, yv)  (yr , uh, uv)
 Bit(yn
h)    Bit(yk+1
, sk+1
 Bit(yk
 Bit(un
h)    Bit(uk+1
 Bit(uk
v)    Bit(y1
 Bit(yn
 Bit(un
v)    Bit(u1
Similar modification is done to the subqueries matching violations from H. In particular, for each pair (cm, cl)  (C  C) \ H,
that is an incorrect pair of colours, and each n > k  1 we define
the query

h,(m,l)(yaux, y0, y1, yc
Aux(yaux, yr )   k
 Tile(y1
Note that here we use a new global variable yaux to join by role
Aux the roots yr of all such subqueries, as we see below.
v,(m,l) for each vertically incorrect pair of colours (cm, cl)  (C  C) \ V and each n > k  1
on the base of  k
We are now in a position to define the main subquery of the
core query  qR


(yaux) = y0, y1, yc

h,(m,l).
c-cntd(z), for the tuple of variables yc = yc

l) = yr , yh, yv, uh, uv

As before, we define subqueries  k

v exactly in the same way as  k

h (yr , yh, yv, uh, uv, y0, y1)

h,(m,l)(yaux, y0, y1, yc

m)  Tile(u1

(cm,cl)(CC)\H

1, . . . , yc
p:

v,(m,l)(yaux, y0, y1, yc

m, yc
l)

m, yc
l)

n>k1

m, yc

v, yc

l).

v, yc

(cm,cl)(CC)\V

n>k1

 Zero(y0)  One(y1)  Colour1(yc
Finally, the core of the query qR
 qR
c-cntd(z) :- yaux (z, yaux)  (yaux),
where for tuples of variables yh = yn
(z, yaux) = yh, yv
h)  H(yn
h, yn1
H(yaux, yn
v)  HV (yn
 HV (y1
h, yn
 TileBit(y1
v, z).

)    H(y2

v, yn1

h, y1
h)
)    HV (y2
v, y1
v)

1)    Colourp(yc
p).
c-cntd(z) is

h, . . . , y1

h and yv = yn

v, . . . , y1
v,

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

The subquery  is similar to , except that it matches both of the
roles H and V in the second half (by means of the role HV subsuming both H and V ), and requires TileBit in the end. As we see later,
even if  has quite a different form from the one in Lemma 18, it
still accomplishes the same task to guarantee that each branch is
indeed a binary representation of a position in the square and has
an assigned tile colour.

While the query and TBox are almost the same as in the previ-

ous proof, we need to adapt the ABox considerably.
We separate the definition into two conceptual parts. The first
part is required to guarantee that every model has at least p + 2
witnesses of the aggregate variable, which are (the interpretations
of) 0, 1, and the colours, and that every model with just those witnesses must represent a tiling, in the same way as in Lemma 18.
The second part increases the number of witnesses for z in each
tiling violating H or V. So, overall, there is a model with only p+ 2
witnesses if and only if there is a correct tiling.
Part 1. We start this part with assertions identifying binary constants and colours. Let Ind contain
- individual names 0 and 1 for binary coordinates,
- all the colours cm in C as individual names,
and let the ABox A contain assertions
- Zero(0) and One(1),
- Colour(cm) and Colourm(cm) for each colour cm in C.

aux,

aux, vn

aux, . . . , h1

aux, . . . , v1

Next we guarantee that the interpretations of these individual
names witness the aggregate variable z, so in all potential models
with just p+ 2 witnesses all other witnessing elements are identified with these. For example, leaves in the position tree should be
indeed colours. The set Ind contains individual names
- r0, hn, . . . , h1, vn, . . . , v1,
- raux, hn
and the ABox A for each i = 0, 1, each n > k  1, each n  l  1,
and each 1  m  p contains the assertions
- H(r0, hn), H(hk+1, hk),
- V (h1, vn), V (vk+1, vk),
- Bit(hl, i), Bit(vl, i),
- Tile(v1, cm),
- Aux(raux, r0),
- H(raux, hn
aux, vn
- V (h1
- TileBit(v1
- TileBit(v1
This part of ABox indeed performs its taskall subqueries of 
are mapped to (the part of the model corresponding to) the assertions of the first five items, all atoms of  but last mapped to the
next two, but this last atom of , that is TileBit(y1
v, z) has exactly
p + 2 options, mapping z to either binary values or colours. Note
that here we use the fact that by the TBox TileBit matches both Tile
and Bit, as well as HV matches both H and V .

aux), H(hk+1
aux), V (vk+1
aux, cm),
aux, 0), and TileBit(v1

aux , hk
aux , vk

aux),
aux),

aux, 1).

Next step is to generate a tree of positions, same as in Lemma 18.

The set Ind contains
- the root individual name r,
and the ABox A contains assertion
- Root(r).

In the canonical model the Colour-leaves of this tree are anonymous elements. However, we want them to be identified with

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

colours. To this end, we enforce them to match the aggregate variable z, by this guaranteeing that in a potential model with only
p + 2 witnesses they are identified with the (interpretations of)
the colours (note that they cannot be identified with 0 or 1 because
Colour is disjoint with Zero and One). In fact, for each leaf the subquery  is already matched by the branch in the tree ending with
this leaf, and, moreover, all the atoms of the subquery , except
Aux, are matched by the interpretation of the part of the ABox on
hk and vk, constructed above. So we just need to connect these two
parts by the role Aux. The ABox A contains assertion
- Aux(r, r0).

The last thing left in Part 1 is to guarantee that Zero-ends of Bit0
are indeed (the interpretation of) 0 and One-ends of Bit1 are 1 in all
the intermediate nodes of the tree, that is that each branch indeed
represents a position in the square. We can do it in the same way
as for colours, by enforcing them to be witnesses of z. It guarantees
that in a model with p+ 2 witnesses these ends are identified with
appropriate binary constants (note that, due to the disjointness in-
clusions, identifications with colours and wrong constants are not
possible). In fact, the Bits starting in the ends of V 1
i , that is, the last
level of the tree, already have such matches, almost the same as for
colours. However, for other levels we need an extra construction.
The set Ind contains individual names
- r2n, . . . , r1,
and the ABox A for each 2n > k  1 and each 2n  l  1 contains
assertions
- H(rk+1, rk), H(r1, r),
- Aux(r l, r0).
These assertions indeed perform their taskthe  subquery is
matched in the same way as for colours, the lower part of  is
matched by the branch of the tree, but the rest of , depending
on the level checked, is matched by the interpretation of this extra
ABox.
Part 2. The aim of this part of ABox is to check that each model representing a tiling which is incorrect, that is, violates either H or V,
has an element witnessing z, different from the interpretations of
colours and binary constants. The number of assertions in this part
is quite large, so we do not write all of them explicitly, but instead
describe in detail how to construct them.
Each horizontal violation (cm, cl)  H in adjacent square positions identified by a k-bit in the binary representation is witnessed
by the subquery  k
l). This did not require
more construction in the proof of Lemma 18, because this subquery
was essentially disconnected from the rest of the query. However,
now it is not the case, because yaux is a common variable with other
such subqueries. To this end, for each  k
h,(m,l) we may construct
ABox assertions which match all other such subqueries, as well as
the subquery . So, the element witnessing z from  increases
the aggregation value if there is a violation detected by  k
h,(m,l) in
the main tree of positions. In fact, such an independent construction for each  k
h,(m,l) is not necessary, and most of assertions can be
shared among them.

h,(m,l)(yaux, y0, y1, yc

m, yc

We start with the ABox on fresh individual names isomorphic
to the body of the query qR
c-cntd(z). In particular, let Ind contain a
fresh individual name ey for each variable y (including an individual
name ez for the aggregation variable z), and A contain the assertion R(ey, ey ) for each binary atom R(y, y), and the assertion A(ey)
for each unary atom A(y). Next we do several modifications in it.
1. Replace in all the assertions the individual names ey0 and ey1,
that is the names corresponding to variables for binary values,
with 0 and 1, accordingly. Also replace the individual names eyc
m,
corresponding to the colour variables, with the colours cm.

h,(m,l),

3. For each subquery  k

h,(m,l) (or, similarly,  k

2. Remove the individual name eyaux, that corresponds to the common variable yaux of all the subqueries  and , together with
all assertions with this name.
v,(m,l)), detecting horizontal (or vertical) violation, introduce a fresh individual name
e in Ind and add to A the assertions
), where yr is the root variable of  k
- Aux(e, eyr
r of each  k
), for the root variable y
- Aux(e, ey

v,(m,l) different from  k
- H(e, eyn

h,(m,l),
h,(m,l) and each
h is the first local existential variable of .
This modification essentially replaces the individual name for the
common variable yaux of the query with many copies, each of which
corresponding to one of the  subqueries. Each such copy is connected to the parts of the ABox matching all the subqueries of
 qR
c-cntd(z) except the  corresponding to this copy. However, it is
connected by Aux to the main tree, so if there is a match of  in
this tree, then the overall query matches as well, that is z is witnessed by ez. This happens when there is a violation from H or V
witnessed by this particular .

), where yn

So overall, by this construction there is a model of the knowledge base in which all Colour-leaves of the tree identified with
colours cm, all Zero and One nodes identified with 0 and 1 respec-
tively, and there is no match mapping z to ez if and only if there is
a tiling of the square without violating H or V. The formal proof
of the fact that p + 3  Cert(qR
c-cntd) if and only if there
is a correct tiling for the instance (C, H , V, n) of the NExp-tiling
problem, can be done in exactly the same way as such a proof in
Lemma 18. We omit it for brevity. 

c-cntd, a, K R

For DL-LiteR ontologies the combined complexity of count
distinct problem is between coNExpTime and coN2ExpTime, the
same as for count queries. Regarding DL-Litecore, the situation is
again very similar to count case. First, we have the following
lemma.
Lemma 23. The problem DL-Litecore Cntd-Aggregate Certain Answers is in coNP.

The proof of this lemma is exactly the same as the proof of

Lemma 20, so we omit it for brevity.

The last problem in this paper is the lower bound for the
combined complexity of the count distinct problem for the
DL-Litecore case.
We do it by reduction from  3-SAT, the problem of verifying,
given a formula in 3-CNF with variables partitioned into tuples u
and v, whether it is true that for every truth assignment of the
variables u, there exists a truth assignment of the variables v so that
the formula is satisfied with the overall assignment. This problem
is well known to be  p

2 -complete [24].

The proof of the following lemma recalls the proof of Lemma 16,
in the sense that the query and knowledge base are carefully
designed to have possible matches of two different types, and
reducing the number of matches for the aggregate variable for the
first type may cause increasing this number for the second.
Lemma 24. The problem DL-Litecore Cntd-Aggregate Certain Answers is  p
Proof. As it is said above, the proof is by reduction from  3-
SAT. To this end, first we show how to, given a formula  of
the described form, construct in polynomial time a DL-Litecore
knowledge base Kc-cntd = T , A and a Boolean count distinct
ACQ qc-cntd, and then prove that 3  Cert(qc-cntd, a, Kc-cntd) (where
a is the empty tuple), if and only if  is valid.

2 -hard.

Let  be a formula of the form

uv 

k,

1kl

variables u, and the second one for checking whether all such assignments lead to a validation of the existential part of . In fact,
only the second part will depend on .

The subset of Ind corresponding to the first part contains

- individual names true and false, representing the Boolean

values,

- all the variables in u and v of  as individual names,
- individual names aw, aval

w , a , and a, playing auxiliary roles

similar to the roles of names a in Lemma 16.

k (aw), . . . , CVar3

k (aw) for all clauses k;

The ABox of the first part of the KB contains the assertions
- CVar1
- Val(aw, aval
w );
- Asn1(a , aval
w ), . . . , Asn3(a , aval
w );
- Clausek(a , a ) for all clauses k;
- Val(a , true), Val(a , false);
- Clausek(ui, a ) for all clauses k and all ui;
- UVar(ui) for all variables ui;
- Val(vj, true), Val(vj, false) for all vj.

Having the first part of ABox defined, consider the TBox T of

Kc-cntd. It consists of the single inclusion
UVar  Val.
The aim of this inclusion is to assign some value (either true or
false) to each variable ui as we will see next.

to aval

ui and yval
vj

The canonical model of this part of Kc-cntd is depicted in the
upper half of Fig. 8. Note that the interpretations of the individual
names true and false witness the aggregate variable already by
the ABox. The justifying matches for  qc-cntd map y to a, all yk
to a , all yval
w , and, finally, yui and yvj to aw. The one
for true is highlighted in the figure by thin light grey lines. Hence,
2  Cert(qc-cntd, a, Kc-cntd). Besides these two, for each variable
ui there is a match for  qc-cntd in the canonical model which maps
the aggregate variable z to the anonymous element connected to
(the interpretation of) ui by Val, y to ui and all other variables
in the same way as the two matches above. Such a match for u1
is highlighted by thick light grey lines in the figure. In search of
a model with the minimal number of witnesses for z, one needs
to identify these anonymous elements with the interpretations of
true and false. However, such identifications may lead to matches
for the second part of the ABox which we describe next.
k, let  1

k , . . . ,  7

be all the assignments of these variables which satisfy k. The
subset of Ind corresponding to the second part of the ABox A
contains
k , 1  p  7, of all clauses k as
- all satisfying assignments  p

Given a clause k with variables w1

k, and w3

k , w2

individual names,

- auxiliary individual names b and bz.
The second part of ABox contains the assertions
- CVar1

k ), . . . , CVar3

k (w3

k (w1

k ) for all clauses k with variables

- Asn1( p

k )), . . . , Asn3( p

k , . . . , w3
w1
k;
k ,  p
k ,  p
k (w3
k (w1
signments  p
k of all clauses k (here  p
k (wi
is an individual name, but  p
true or false which is the value of  p

k (wi

k )) for all satisfying as-
k) as the first argument
k) is one of the individual names

k as assignment on wi

k);

- Clausek(b ,  p

k ) for all satisfying assignments  p

k of all clauses

k;

- Val(b , bz ).

k, w2

ui and yval

k , . . . , CVar3

k and w3

k which correspond to the variables in k.

Fig. 7. Query qc-cntd(Cntd(z)). The ends of Asn1, . . . , Asn3 starting at each yk , are
those of yval
vj which correspond to the variables in k; and those of yui and
yvj are labelled with CVar1
where each k (1  k  l) is a clause (i.e., disjunction) of
exactly three literals (i.e., variables from u  v or their negations).
We denote the variables of each k by w1
k. Let also
u = u1, . . . , un and v = v1, . . . , vm. Without loss of generality
we assume that every variable appears at least in one clause.
We start the description of the construction with the vocabu-
lary. For every clause k it contains an atomic role Clausek. Each
clause k makes use of three variables, and to indicate them the vocabulary contains atomic concepts CVar1
k . To indicate all the universally qualified variables u it contains an atomic
concept UVar. To connect the (elements representing the) variables
to their values the vocabulary contains an atomic role Val. Finally,
to specify to validating assignments of the three variables of each
clause, the vocabulary contains atomic roles Asn1, Asn2, and Asn3.
Let us begin with defining the Boolean count distinct ACQ as

k and CVar3

k , CVar2

u , yval

v , yu, yv ,

Clausek(y , yk

v = yval

and  is the following conjunction:

un and yval
, . . . , yval
, . . . , yun and yv = yv1


)  Asn2(yk

vm correspond to
, . . . , yvm correspond to these

, . . . , yl correspond to the clauses k,
, . . . , yval
u1

follows:
qc-cntd(Cntd(z)) :- y , y , yval
where
- y corresponds to the overall ,
- y = y1
u = yval
- yval
values of the variables of ,
- yu = yu1
variables,
Val(y , z)  
 Asn1(yk
 CVar1
 Val(yu1
 Val(yv1
The graphical representation of this query is given in Fig. 7. The
concepts CVar and ends of roles Asn depend on , so they are just
sketched. Note that the query mentions the role Val in two different
positions, which allows to have two different types of matches in
the models of the knowledge base, as previously mentioned.
We continue with defining the knowledge base Kc-cntd =
T , A, splitting the description in two conceptual parts. Essen-
tially, the first part is responsible for assignment values to the

1kl
, yval
w1

)  CVar2
)    Val(yun
)    Val(yvm

, yval
w2

)  CVar3
, yval

un
, yval
vm


)  Asn3(yk

, yval
u1
, yval
v1

k (yw3

k (yw1

k (yw2

, yval
w3

).

v1

E.V. Kostylev, J.L. Reutter / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 94111

otherwise. Moreover, for each clause k, it maps each variable yk
to the interpretation of the individual name  p
k such that the p-th
satisfying assignment for k is the one witnessed by uv. Finally,
it maps y to the interpretation of b and z to the interpretation of
bz. It is a matter of technicality to check that h is a match for  qc-cntd
in I, that is the interpretation of bz is the third image of z in I. This
violates our original assumption.
() Let 3  Cert(qc-cntd, a, Kc-cntd), but assume for the sake of
contradiction that there is a truth assignment u for the variables
u such that  is not satisfiable under any assignment for the
variables v.

Construct the following model I for K.

- The interpretation of any individual name a is an element da.
- The interpretation of all atomic roles and concepts except for
Val corresponds precisely to the ABox A. That is, for each atomic
role R different from Val, we have that (da, db)  RI if and only
if R(a, b) is an assertion in A, and likewise for all the atomic
concepts.

- For each ui, the pair (dui

, du(ui)) belongs to ValI. Here we
assume that ui is an individual name in the first argument, but
a variable in the second; also, u(ui) valuates to one of the
individual names true or false.
It is a technicality to check that I is indeed a model of Kc-cntd.
From the assumption that 3  Cert(qc-cntd, a, Kc-cntd) and the
construction of I, it must be the case that  qc-cntd(bz ) holds in
I. It follows that there must be a match h for qc-cntd in I such
that the mapping h sends the variable z to the interpretation of
bz. We can, however, determine more properties of h from the
construction of I and Kc-cntd. In fact, it follows that each variable
yui, is indeed mapped by h to (the interpretation of) ui in I, and
that yval
is mapped to the corresponding valuation of ui according
ui
to u. It follows from the construction of  that the following
assignment v of the variables v is such that u  v satisfies :
v assigns the value true to vj if the variable yvj is mapped to
(the interpretation of) true, according to h, and the value false
otherwise. This contradicts the original assumption and completes
the proof of the lemma. 

Summing up, we have our last theorem.

Theorem 25. (1) The problem DL-Litecore Cntd-Aggregate Certain
Answers is in coNP and  p
(2) The problem DL-LiteR Cntd-Aggregate Certain Answers is in
coN2ExpTime and coNP-hard.

2 -hard.

7. Conclusion

In this paper we have defined an intuitive semantics for counting aggregate queries over ontologies and explored the computational complexity of the corresponding problems. The results,
summarised in Table 1, show that the problems are decidable, but
intractable. Hence, heuristics and approximations for answering
ACQs are on high demand from the practical point of view, with
applications, for instance, in the definition of general aggregation
in SPARQL under entailment regimes. We consider epistemic and
active domain semantics as such approximations, since they have
lower data complexities but do not always provide the desired an-
swer. Our work provides the theoretical foundations for further
discussion.

There are several directions for future work. First, it is important
to close the gaps in the combine complexities. Second, in Section 4
we mentioned the following natural problem closely related to the
problems studied in this paper: for a query, knowledge base, and
a tuple of individual names, how to compute the minimum value
of the counting aggregation function over all the models of the
knowledge base? The corresponding decision problem is whether
a given number n is such a minimum? In fact, we can easily derive a

Fig. 8. Canonical model of Kc-cntd. The ends of Asn1, . . . , Asn3 starting at each  p
k ,
are the Boolean values of the variables in k under  p
k as assignment; and those of ui
and vj are labelled with CVar1
k which correspond to the variables in k.

k , . . . , CVar3

The second part of A is depicted in the lower half of Fig. 8.
Note that it substantially depends on , so some pieces are
just sketched, but described in the caption. This part serves the
following aim. As said above, in search of a model with the minimal
number of witnesses of the aggregation variable z one needs to
identify the anonymous elements corresponding to ui with either
true or false; however, such identification may lead to a match
for the query with bz witnessing the aggregation variable z, by
this increasing the aggregation value. Such a possible match is
highlighted in the figure by thin dark grey lines. Next we will see,
that a possibility to find an identification which does not lead to a
match is equivalent to invalidation of .
Formally, we need to show that 3  Cert(qc-cntd, a, Kc-cntd)
(i.e., that every model of Kc-cntd, which connects each ui to either
true or false by Val, has a match with bz witnessing z) holds for the
empty tuple a if and only if  is valid.
() Let for every truth assignment of the variables u there exist a
truth assignment of the variables v so that each k is satisfied with
the overall assignment, yet assume for the sake of contradiction
that there is a model I of Kc-cntd such that true and false are the
only witnesses for the variable z in the matches from  q to I.
, d) in ValI,
where dui
is the interpretation of ui, it must be the case that
d is either true or false (otherwise it violates the observation
previously mentioned, since this would give an extra witness for
the variable z). Without loss of generality let each ui have only
one such d, since dropping extra Val-connections would not make
I to be not a model. Construct the following valuation u for the
variables u: for each ui, let
if (dui
otherwise,

u(ui) =true,

From the construction of Kc-cntd, for each pair (dui

, dtrue)  ValI, and

false,

where dtrue is the interpretation of true. From the original
assumption, there must be an assignment v of the variables in v
such that u  v satisfies . We show that  qc-cntd(bz ) must hold
in I. To that extent, construct the following mapping h from the
variables of q to elements in I: h maps the variables yui and yvj
to the interpretations of ui and vj respectively, as well as each
to dtrue if u  v assigns the value true to the
of yval
corresponding variable ui or vj, or to the interpretation of false

ui and yval
vj

Table 1
A summary of the complexity results.
Data complexity
Count

Cntd

DL-Litecore
DL-LiteR

coNP-complete
coNP-complete

coNP-complete
coNP-complete

Combined complexity
Count

coNExp-hard and in coN2Exp

2 -hard and in coNExp

Cntd

coNExp-hard and in coN2Exp

2 -hard and in coNExp

DP-upper bound for the data complexity of this problem from the
results of this paper: first one needs to check whether n belongs
to the aggregate certain answers, and then check that n + 1 is not.
However, it remains to see whether the problem is indeed DP-hard.
Similar situation is for combine complexity problems. Finally, in
this paper the count distinct function has exactly one argument,
as it is done in SQL and SPARQL. It is interesting to study the
generalisation of this function to arbitrary number of aggregation
variables.
Acknowledgements

We thank Evgeny Kharlamov and Dmitriy Zheleznyakov for introduction into the area, and Peter Buneman for useful discussions.
This work was funded by the UK EPSRC grants EP/J017728/1 (SO-
CIAM project) and EP/G049165/1 (XML with Incomplete Informa-
tion), and the Chilean Millennium Nucleus Center for Semantic
