Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

journal homepage: www.elsevier.com/locate/websem

Temporal query entailment in the Description Logic SHQ
Franz Baader, Stefan Borgwardt, Marcel Lippmann

Institute of Theoretical Computer Science, Technische Universitat Dresden, 01062 Dresden, Germany

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 28 August 2013
Received in revised form
10 November 2014
Accepted 23 November 2014
Available online 11 December 2014

Keywords:
Description Logic
Ontology-based data access
Linear temporal logic
Complexity
Data complexity

Ontology-based data access (OBDA) generalizes query answering in databases towards deductive
entailment since (i) the fact base is not assumed to contain complete knowledge (i.e., there is no closed
world assumption), and (ii) the interpretation of the predicates occurring in the queries is constrained by
axioms of an ontology. OBDA has been investigated in detail for the case where the ontology is expressed
by an appropriate Description Logic (DL) and the queries are conjunctive queries. Motivated by situation
awareness applications, we investigate an extension of OBDA to the temporal case. As the query language
we consider an extension of the well-known propositional temporal logic LTL where conjunctive queries
can occur in place of propositional variables, and as the ontology language we use the expressive DL SHQ.
For the resulting instance of temporalized OBDA, we investigate both data complexity and combined
complexity of the query entailment problem. In the course of this investigation, we also establish the
complexity of consistency of Boolean knowledge bases in SHQ.

 2014 Elsevier B.V. All rights reserved.

1. Introduction

Situation awareness tools [1,2] try to help the user to detect certain situations within a running system. Here system is seen in a
broad sense: it may be a computer system, air traffic observed by
radar, or a patient in an intensive care unit. From an abstract point
of view, the system is observed by certain sensors (e.g., heart rate
and blood pressure monitors for a patient), and the results of sens-
ing, possibly already preprocessed and aggregated appropriately,
are stored in a fact base. Based on the information available in the
fact base, the situation awareness tool is supposed to detect certain
predefined situations (e.g., heart rate very high and blood pressure
low), which require a reaction (e.g., fetch a doctor or give medica-
tion).

In a simple setting, one could realize such a tool by using
standard database techniques: the information obtained from the
sensors is stored in a relational database, and the situations to be
recognized are specified by queries in an appropriate query language (e.g., conjunctive queries [3]). However, in general we cannot assume that the sensors provide us with a complete description
of the current state of the system, and thus the closed world assumption (CWA) employed by database systems (where facts not

 Corresponding author.

E-mail addresses: baader@tcs.inf.tu-dresden.de (F. Baader),

stefborg@tcs.inf.tu-dresden.de (S. Borgwardt), lippmann@tcs.inf.tu-dresden.de
(M. Lippmann).

http://dx.doi.org/10.1016/j.websem.2014.11.008
1570-8268/ 2014 Elsevier B.V. All rights reserved.

occurring in the database are assumed to be false) is not appropriate (since there may be facts for which it is not known whether they
are true or false). In addition, though one usually does not have a
complete specification of the working of the system (e.g., a complete biological model of a human patient), one has some knowledge about how the system works. This knowledge can be used to
formulate constraints on the interpretation of the predicates used
in the queries, which may cause more answers to be found.

Ontology-based data access [4,5] addresses these requirements.
The fact base is viewed to be a Description Logic ABox (which is
not interpreted with the CWA), and an ontology, also formulated
in an appropriate DL, constrains the interpretations of unary and
binary predicates, called concepts and roles in the DL community.
In OBDA, one usually assumes that the ABox is obtained from external data sources (in the case of situation awareness, the raw sensor
data) through appropriate mappings (which in our case realize the
preprocessing and aggregation of the sensor data), but for the purpose of this paper we abstract from the mapping step, assuming
that the result of the preprocessing is explicitly represented in an
ABox.

As an example, assume that the ABox A contains the following

assertions about patient Bob:
systolic_pressure(BOB, P1),
history(BOB, H1),

High_pressure(P1),
Hypertension(H1), Male(BOB),

which say that Bob has high blood pressure (obtained from sensor
data), and is male and has a history of hypertension (obtained from
the patient records). In addition, we have an ontology that says

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

that patients with high blood pressure have hypertension and that
patients that currently have hypertension and also have a history
of hypertension are at risk of a heart attack:
systolic_pressure.High_pressure  finding.Hypertension
finding.Hypertension  history.Hypertension
 risk.Myocardial_infarction.
The situation we want to recognize for a given patient x is whether
this patient is a male person who is at risk of a heart attack. This
situation can be described by the conjunctive query
y.Male(x)  risk(x, y)  Myocardial_infarction(y).
Given the information in the ABox and the axioms in the ontology,
we can derive that Bob satisfies this query, i.e., he is a certain answer
of the query. Obviously, without the ontology this answer could not
be derived.

The complexity of query entailment w.r.t. an ontology, i.e., the
complexity of checking whether a given tuple of individuals is a
certain answer of a query in an ABox w.r.t. an ontology, has been
investigated in detail for cases where the ontology is expressed in
an appropriate DL and the query is a conjunctive query. One can
either consider the combined complexity, which is measured in the
size of the whole input (consisting of the query, the ontology, and
the ABox), or the data complexity, which is measured in the size of
the ABox only (i.e., the query and the ontology are assumed to be of
constant size). The underlying assumption is that the query and the
ontology are usually relatively small, whereas the size of the data
may be huge. In the database setting (where there is no ontology
and CWA is used), conjunctive query entailment is NP-complete
w.r.t. combined complexity and in AC0 w.r.t. data complexity [6,3].
For expressive DLs, the complexity of checking certain answers is
considerably higher. For instance, for the well-known DL ALC, the
query entailment problem is ExpTime-complete w.r.t. combined
complexity and co-NP-complete w.r.t. data complexity [79]. For
this reason, the more light-weight DLs of the DL-Lite family have
been developed, for which the entailment problem is still in AC0
w.r.t. data complexity, and for which computing certain answers
can be reduced to answering first-order queries in the database
setting [10].

Unfortunately, OBDA as described until now is not sufficient
to achieve situation awareness. The reason is that the situations
we want to recognize may depend on states of the system at
different time points. For example, assume that we want to find
male patients with a history of hypertension, i.e., patients that are
male and at some previous time point had hypertension.1 In order
to express this kind of temporal queries, we propose to extend the
well-known propositional temporal logic LTL [11] by allowing the
use of conjunctive queries in place of propositional variables. For
example, male patients with a history of hypertension can then be
described by the query
Male(x)  (y.finding(x, y)  Hypertension(y)),
 stands for previous and  stands for sometime in
where
the past. We call the queries obtained this way temporal conjunctive queries (TCQs). These queries extend the temporal description logic ALC-LTL introduced and investigated in [12]. In
ALC-LTL, only concept and role assertions (i.e., very restricted conjunctive queries without variables and existential quantification)
can be used in place of propositional variables. As in [12], we also
consider rigid concepts and roles, i.e., concepts and roles whose interpretation does not change over time. For example, we may want

1 Whereas in the previous example we have assumed that a history of
hypertension was explicitly noted in the patient records, we now want to derive
this information from previously stored information about blood pressure, etc.

to assume that the concept Male is rigid, and thus a patient that is
male now also has been male in the past and will stay male in the
future.

Our overall setting for recognizing situations will thus be the
following. In addition to a global ontology T (which describes
properties of the system that hold at every time point, using the
expressive DL SHQ), we have a sequence of ABoxes A0, A1, . . . An,
which (incompletely) describe the states of the system at the previous time points 0, 1, . . . , n 1 and the current time point n. The
situation to be recognized is expressed by a temporal conjunctive
query, as introduced above, which is evaluated w.r.t. the current
time point n.

1.1. Related work

Our work combines results on atemporal conjunctive query answering w.r.t. DL ontologies with LTL as a temporal logic com-
ponent. In the following, we describe relevant work in these two
fields as well as similar approaches to temporal query answering,
which have mainly been developed for the light-weight languages
of the DL-Lite family.

We build on the results about the complexity of conjunctive
query entailment of [13,8,14] (see Sections 2.2 and 3 for details).
Additionally, for our proofs it is not sufficient to use only the re-
sults, but we must also adapt the methods developed in these
papers to show these results. For example, we adapt the constructions involving forest models and equivalence relations over individual names from [14], and we use the results about spoilers in
SHQ from [8].

The temporal component of our query language is LTL [11].
As such, we adapt the automata construction for LTL satisfiability
from [15,16]. Our language also generalizes ALC-LTL [12], which
allows DL axioms in place of propositional variables, and in fact
several constructions in the present paper are adaptations of those
for ALC-LTL, in particular the ones used to show Lemmata 4.3
and 6.4 in [12]. The latter result about the consistency of Boolean
ALC-knowledge bases is in turn an adaptation of Theorem 2.27
from [17]. Our hardness results for combined complexity also
follow easily from the results in [12].

Instead of temporalizing the query language and using a global
(atemporal) ontology, one can also temporalize the ontology
language. Extensions of various description logics with temporal
operators in concepts and axioms have been studied (see for
example [18,17]). A comprehensive survey of temporal description
logics can be found in [19]. In [20], various light-weight DLs
are extended by allowing temporal operators inside concepts. In
addition to complexity results for temporal extensions of DL-Lite,
it is also shown that reasoning easily becomes undecidable already
in a small temporal extension of the description logic EL. Although
the DL-Lite family was developed with mainly query answering in
mind, the complexity results in [20] are concerned with inference
problems not involving queries.

In the literature, one can find several approaches to temporal
query answering in description logics. In [21], temporal query
answering over temporalized RDF triples [22] using an extension
of the SPARQL query language is considered.
In [23], the very expressive temporalized DL DLRUS is intro-
duced, which is an extension of DLR that allows for temporal
operators within concepts and roles. Moreover, the query containment problem of non-recursive Datalog queries under constraints
defined in DLRUS is investigated. It turns out that this problem
is in general undecidable, but becomes decidable in the fragment

US, where no temporal operators are allowed within roles.
The query containment problem is then in 2-ExpTime, whereas satisfiability and subsumption in DLR

US are ExpSpace-complete.

Though our complexity results are the same for ALC and SHQ,
and in principle the approaches used below to prove the upper bounds for SHQ are similar to the ones employed in [34,29]
for ALC, the proof details are considerably more complex for SHQ.
In particular, the proof of Theorem 4.1 uses a construction different
from that of Theorem 3.2 in [34] since in the presence of number restrictions it is not so easy to simply copy elements of a model while
retaining the satisfaction of the knowledge base. Furthermore, the
quasimodel construction in Section 6.3 uses new notions to deal
with role axioms, and systems of linear equations to simulate the
semantics of number restrictions.

For the combined complexity, the results obtained in the
present paper are actually identical to the ones for ALC-LTL [12],
though the upper bounds are considerably harder to show. The
data complexity results in Settings (ii) and (iii) coincide with the
ones for atemporal query entailment, which is co-NP-complete
w.r.t. data complexity. For Setting (i), we can show that the entailment problem is in ExpTime w.r.t. data complexity (in contrast to
2-ExpTime-completeness w.r.t. combined complexity), but we do
not have a matching lower bound. To show the result for combined
complexity in Setting (ii), we additionally establish the complexity of the atemporal problem of consistency of Boolean knowledge
bases in SHQ extended with a limited form of role conjunctions.
Of the other related work mentioned in the previous subsection,
the ones described in [24,25,23,28] are most closely related to our
work. Nevertheless, they differ from our approach in several ways:
 We consider the expressive DL SHQ instead of light-weight DLs
such as DL-Lite [24,25].
 We consider a temporal query language instead of a temporal
ontology language [24,23].
 In contrast to [28], we consider also the case of rigid concept
and role names. In [25,24], rigid names are also used, but in the
context of light-weight DLs.

Following the ideas of [20], in [24] a temporal extension of
DL-Lite is presented, which allows the temporal operators 
and  on the left-hand side of GCIs and role inclusions. In
this logic, first-order rewritability of CQs w.r.t. DL-Lite-knowledge
bases is preserved from the atemporal case. Thus, techniques from
temporal relational databases can be used to answer temporal
queries that can refer to specific points in time.

An approach to temporalize query answering in DL-Lite that
is more similar to the one considered in this paper is presented
in [25]. There, CQs are used as atoms in a temporal formula that
does not use negation. This allows easy reuse of results about atemporal first-order rewritability in DL-Lite. The paper also presents
an algorithm to answer such temporal queries over temporal
databases, which generalizes an algorithm from [26,27].

A similar approach is pursued in [28] to combine a generic DL
query component with a linear temporal dimension. To simplify
the decision procedures, both components are decoupled via an
autoepistemic modal operator. This allows to use atemporal query
answering procedures as a black-box inside a temporal satisfiability algorithm.

1.2. Our contribution

We investigate both the combined and the data complexity
of our temporal extension of OBDA, as sketched above, in three
different settings: (i) both concepts and roles may be rigid; (ii) only
concepts may be rigid; and (iii) neither concepts nor roles are
allowed to be rigid. It is well-known that one can simulate rigid
concept names by rigid role names [12], which is why there are
only three cases to consider.

The complexity results for TCQ entailment obtained in this paper are summarized in Table 1. These results hold for all description
logics between ALC and SHQ. In fact, we show that the hardness
results already hold for ALC and we prove the complexity upper
bounds for the more expressive DL SHQ.
SHQ extends ALC with transitive roles, subroles, and qualified
number restrictions. In the conference paper [29], which is a precursor of the present paper, we showed these results for ALC only.
From a practical point of view, we found the extension to SHQ interesting since the additional means of expressiveness are important for biomedical ontologies. For instance, one usually wants the
part-of role (which is, e.g., extensively used in medical ontologies
to define human anatomy) to be transitive, and it is also useful to
distinguish the proper-part-of role from the part-of role and to declare that the former is a subrole of the latter [30]. Number restrictions can, among other things, be used to express that certain roles
are functional. In our introductory example, it makes sense to require that a patient can have only one systolic blood pressure at
each point in time. More general number restrictions can be used
to express anatomical facts such as that humans have exactly two
kidneys. From a more theoretical point of view, we wanted to know
how far one can extend ALC without increasing the complexity of
query entailment. SHQ is here the limit. If we add inverse roles,
which are also quite useful when defining medical ontologies, then
the combined complexity increases. In fact, for ALCI query entailment is already 2-ExpTime-complete w.r.t. combined complexity
in the atemporal case [8]. For SHOQ (extending SHQ by nominals)
and SROQ (further extending SHOQ by complex role inclusions),
the best known upper bounds are respectively 2-ExpTime and 3-
ExpTime [31,32]. Also, we restrict the query language such that
transitive roles (e.g. the part-of role) and roles having transitive
subroles cannot directly be used in queries. The reason is that otherwise query entailment is known to be co-NExpTime-hard in S and
2-ExpTime-hard in SH even in the atemporal case [33]. Note, how-
ever, that such roles can be used indirectly since concept names
whose definition in the global ontology involves such a role can be
used in queries.

2. Preliminaries

In this section, we introduce the description logics ALC and
SHQ, conjunctive queries, and the temporal logic LTL. These are
the main ingredients for our temporal query language, which will
be defined in Section 3.

2.1. Description logics

Description Logics (DLs) are a family of knowledge representation formalisms (for an introduction, see [35]). While our temporal
query language can be parameterized with any DL, in this paper
we consider the DLs between ALC and SHQ [36]. In the proof of
Theorem 6.3, we additionally use the DL SHQ that extends SHQ
with role conjunctions.
Definition 2.1 (Syntax of SHQ). Let NC, NR, and NI, be sets of
concept names, role names, and individual names, respectively. The
set of SHQ-concepts is the smallest set such that
 all concept names A  NC are SHQ-concepts, and
 if C, D are SHQ-concepts, r, r1, . . . , rl  NR, and n is a
non-negative integer, then C (negation), C  D (conjunction),
(r1    rl).C (existential restriction), and n r.C (at-least
restriction) are also SHQ-concepts.
A general concept inclusion in SHQ (SHQ-GCI) is of the form
C  D, where C, D are SHQ-concepts. A role inclusion is of the
form r  s, and a transitivity axiom is of the form trans(r), where
r and s are role names. An assertion is of the form A(a) (concept
assertion) or r(a, b) (role assertion), where A  NC, r  NR, and

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

Table 1
The complexity of simple TCQ entailment for all DLs between ALC and SHQ.

Without rigid names

Without rigid role names

With rigid names

Data complexity
co-NP-complete
(Corollary 4.2 and Theorem 4.13)

co-NP-complete
(Corollary 4.2 and Theorem 5.2)

co-NP-hard/in ExpTime
(Corollary 4.2 and Theorem 4.15)

Combined complexity
ExpTime-complete
(Theorems 4.3 and 4.13)

co-NExpTime-complete
(Theorems 4.3 and 6.3)

2-ExpTime-complete
(Theorems 4.3 and 4.15)

l }; and

Definition 2.2 (Semantics of SHQ). An interpretation is a pair
I = (I ,I ), consisting of a non-empty set I (called domain)
and an interpretation function I that assigns to every A  NC a set
AI  I, to every r  NR a binary relation rI  I  I, and
to every a  NI an element aI  I such that the unique name
assumption (UNA) is satisfied, i.e., for all a, b  NI with a = b we
have aI = bI. The interpretation function is extended to concepts
as follows:
 (C)I := I \ CI;
 (C  D)I := CI  DI;
 ((r1    rl).C)I := {d  I | there is an e  CI with
(d, e)  rI
1    rI
 (n r.C)I := {d  I | |{e  CI | (d, e)  rI}|  n}.
An interpretation I is a model of an axiom  if
 CI  DI for  = C  D;
 rI  sI for  = r  s;
 rI  rI  rI, i.e., rI is transitive, for  = trans(r);
 aI  AI for  = A(a); and
 (aI , bI )  rI for  = r(a, b).
We say that I is a model of a set of axioms if it is a model of
all axioms contained in it, and I is a model of a knowledge base
K = A, T , R if it is a model of A, T , and R. We write I |=  if
I is a model of the axiom , and similarly for sets of axioms and
knowledge bases.
A knowledge base is consistent if it has a model. An axiom  is
entailed by a knowledge base K (written K |= ) if all models of K
are also models of , and similarly for sets of axioms.
Motivated by the semantics of GCIs, we often use the expression
C  D for two concepts C and D to abbreviate the two GCIs C  D
and D  C, restricting any model to interpret C and D by the same
set.

Recall that, contrary to the usual definition of concept asser-
tions, we only allow concept names to occur in them, but no
complex concepts. One can circumvent this by introducing abbreviations A for complex concepts C via A  C. However, this restriction is useful to separate the influence of the ABox and the TBox on
the complexity of reasoning problems.
If one or more components of a knowledge base A, T , R
are empty, we may also shorten it to, e.g., T , R or R. Given
an RBox R, we say that a role name r is transitive (w.r.t. R) if
R |= trans(r), and r is a subrole of a role name s (w.r.t. R) if
R |= r  s. Furthermore, r is simple (w.r.t. R) if it has no transitive
subrole. Entailments of the form R |= trans(r) and R |= r  s can
be decided in polynomial time in the size of R [36].
Unfortunately, consistency of knowledge bases in SHQ is un-
decidable, even if all at-least restrictions are unqualified, i.e., of the
form n r. [36]. One cause of undecidability is the occurrence of
non-simple role names in such restrictions. To regain decidability,
role names occurring in number restrictions are therefore usually
required to be simple. In the following, we also make this restriction to the syntax of SHQ. We further require that role conjunctions with at least two conjuncts contain only simple roles.

Fig. 1. The relative expressivity of the DLs between ALC and SHQ.

a, b  NI. An SHQ-axiom is either an SHQ-GCI, a role inclusion,
a transitivity axiom, or an assertion.
An SHQ-TBox is a finite set of SHQ-GCIs, an SHQ-RBox is a
finite set of role inclusions and transitivity axioms, and an ABox is
a finite set of assertions. An SHQ-knowledge base K = A, T , R
consists of an ABox A, an SHQ-TBox T , and an SHQ-RBox R.
We denote the set of individual names occurring in an SHQknowledge base K by Ind(K).
Other constructors that are often used in SHQ can be defined as
follows:
  := A  A (top), where A is an arbitrary, but fixed, concept
name;
  :=  (bottom);
 C  D := (C  D) (disjunction);
 (r1  rl).C := ((r1  rl).C) (value restriction);
and
 n r.C := ((n + 1) r.C) (at-most restriction).
As mentioned above, most of the time, we consider the description logic SHQ that does not allow role conjunctions in existential
restrictions, i.e., requires that l = 1. We sometimes restrict the
DL under consideration, e.g., to the sublogic ALC of SHQ which
does not allow role conjunctions, transitivity axioms, role inclu-
sions, or at-least restrictions, and then write, e.g., ALC-knowledge
base instead of SHQ-knowledge base. The extension of ALC with
transitivity axioms is usually denoted by S. The letters H and Q respectively denote the presence of role inclusions and number re-
strictions. In Fig. 1, all relevant DLs and their relations are depicted.
From now on, we consider an arbitrary (but fixed) DL between
ALC and SHQ, and therefore we often drop this prefix. Moreover,
some notions, like interpretations and conjunctive queries, do not
even depend on the DL under consideration.

Under this assumption, the problem of deciding the consistency
of SHQ-knowledge bases is in ExpTime, even if the numbers
occurring in at-least restrictions are given in binary encoding [37].
On the other hand, the problem is ExpTime-hard already in
ALC [35].

The notion of a knowledge base can be generalized to arbitrary

Boolean combinations of axioms.
Definition 2.3 (Boolean Knowledge Base). The pair B =  , R
is called a Boolean knowledge base if R is an RBox and  is a
Boolean axiom formula (w.r.t. R). The set of Boolean axiom formulae
(w.r.t. R) is the smallest set such that
 every assertion is a Boolean axiom formula,
 every GCI in which number restrictions only contain simple role
names (w.r.t. R) is a Boolean axiom formula, and
 if 1 and 2 are Boolean axiom formulae, then so are 1
(negation) and 1  2 (conjunction).

The interpretation I is a model of the Boolean knowledge base
 , R if I |= R and I |=  holds, which is also defined induc-
tively: I |= 1 iff I |= 1, and I |= 1  2 iff I |= 1 and
I |= 2. A Boolean knowledge base is consistent if it has a model.
The reason that role inclusions and transitivity axioms are not included in the Boolean axiom formula is that the notion of simple
role names does not make sense w.r.t. a Boolean combination of
role axioms. Observe that every classical knowledge baseA, T , R
is equivalent to the Boolean knowledge base  , R, where 
is the conjunction of all axioms contained in A and T , and thus
Boolean knowledge bases generalize classical knowledge bases.
We denote by Ind( ) the set of individuals occurring in the
Boolean knowledge base B =  , R.

2.2. Conjunctive queries

In addition to consistency and entailment, there are many
other inference problems relevant for DLs. One such problem is
answering so-called conjunctive queries, which generalizes the
entailment of assertions, e.g., deciding whether K |= r(a, b) holds.
Definition 2.4 (CQ). Let NV be a set of variables. A conjunctive query
(CQ) is of the form  = y1, . . . , ym., where y1, . . . , ym  NV and
 is a (possibly empty) finite conjunction of atoms of the form
 A(z) for A  NC and z  NV  NI (concept atom); or
 r(z1, z2) for r  NR and z1, z2  NV  NI (role atom).
The empty conjunction is denoted by true.
A union of conjunctive queries (UCQ) is of the form 1  n,
where 1, . . . , n, n  1, are CQs.
We denote the set of individual names occurring in a UCQ  by
Ind(), the set of variables occurring in  by Var(), the set of free
variables of  by FVar(), and the set of atoms occurring in  by
At(). A UCQ  with FVar() =  is called Boolean.
Given a UCQ  and a knowledge base K, we want to find all
certain answers to  w.r.t. K, i.e., instantiations of the free variables
in  such that the resulting sentence is satisfied in all models of K.
We first define the semantics for Boolean UCQs, using the notion of
homomorphisms [6]. This is then extended to answering arbitrary
UCQs.
Definition 2.5 (UCQ Answering). Let I = (,I ) be an interpretation and  be a Boolean CQ. A mapping  : Var()  Ind()  
is a homomorphism of  into I if
  (a) = aI for all a  Ind();
  (z)  AI for all concept atoms A(z)  At(); and
 ( (z1),  (z2))  rI for all role atoms r(z1, z2)  At().

We say that I is a model of  (written I |= ) if there is such
a homomorphism. Furthermore, I is a model of a Boolean UCQ
1    n if it is a model of i for some i, 1  i  n.
A Boolean UCQ  is entailed by a knowledge base K (written
K |= ) if every model of K is also a model of . Given a (not
necessarily Boolean) UCQ , a mapping a: FVar()  Ind(K) is a
certain answer to  w.r.t. K if K |= a(), where a() is the Boolean
UCQ obtained from  by replacing the free variables according to a.
For a UCQ  and a knowledge base K, one can compute all certain
answers by enumerating all candidate mappings
a: FVar()  Ind(K) and then solving the entailment problem
K |= a() for each a. Since there are |Ind(K)||FVar()| such
mappings, we have to solve exponentially many such entailment
problems.
To analyze the complexity of deciding K |= a(), it obviously suffices to consider Boolean UCQs only. Usually, two kinds
of complexity measures are considered: combined complexity and
data complexity. For the combined complexity, all parts of the in-
put, i.e., the UCQ  and the knowledge base K, are taken into ac-
count. For the data complexity, the UCQ, the TBox, and the RBox
are assumed to be constant, and the complexity is measured only
w.r.t. the data, i.e., the ABox. For this analysis, we assume in the following that the query does not introduce new names, i.e., it contains only concept and role names that also occur in the TBox or
the RBox. This is without loss of generality since we can always introduce trivial axioms like A  A or r  r into the TBox and RBox
without affecting data complexity or combined complexity.
Regarding data complexity, the entailment problem for concept
assertions in ALC is already co-NP-hard [38], and a matching upper
bound has been established for UCQ entailment in SHQ [14].
The entailment problem for concept assertions in ALC is
ExpTime-hard w.r.t. combined complexity [35], and a matching
upper bound is known for entailment of UCQs in ALCHQ [8]. In
S, the problem is already co-NExpTime-hard, while it becomes
2-ExpTime-hard in SH [33]. In this paper, we focus on a variant
of the UCQ entailment problem that is ExpTime-complete even for
SHQ, namely, we restrict to simple queries, which are only allowed
to use simple role names. Note that this is only a restriction in
extensions of S.

2.3. Linear temporal logic

1 (next),

We now come to the temporal component of our query
language, which is based on propositional linear temporal logic
(LTL) [11].
Definition 2.6 (LTL). Let{p1, . . . , pm} be a finite set of propositional
variables. The set of LTL-formulae is the smallest set such that
 p1, . . . , pm are LTL-formulae, and
 if 1 and 2 are LTL-formulae, then so are 1 (negation),
1  2 (conjunction),
1 (previous), 1 U 2
(until), and 1 S 2 (since).
An LTL-structure is an infinite sequence J = (wi)i0 of worlds
wi  {p1, . . . , pm}. The LTL-structure J is a model of an LTL-formula
 at time point i  0 iff J, i |=  holds, which is defined inductively
as follows:
J, i |= pj
J, i |= 1
J, i |= 1  2
J, i |= 1
J, i |= 1
J, i |= 1 U 2
J, i |= 1 S 2

pj  wi
J, i |= 1
J, i |= 1 and J, i |= 2
J, i + 1 |= 1
i > 0 and J, i  1 |= 1
there is k  i with J, k |= 2
and J, j |= 1 for all j, i  j < k
there is k, 0  k  i with J, k |= 2
and J, j |= 1 for all j, k < j  i.

iff
iff
iff
iff
iff
iff

iff

An LTL-formula  is satisfiable if it has a model at time point 0.

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

iff

Note that what we introduced above would usually be called

Past-LTL, as LTL is normally defined using only the operators
and U [11].

Our temporal query language is based on the temporal DL
ALC-LTL, which extends LTL by allowing GCIs and assertions in
place of propositional variables [12]. The semantics of this logic is
determined by infinite sequences of interpretations, which will be
defined more formally in the next section. It is possible to designate
certain concept and role names as rigid, which means that their
interpretation is not allowed to change over time. Satisfiability
of ALC-LTL-formulae is ExpTime-complete without rigid names,
NExpTime-complete if only concept names are allowed to be rigid,
and 2-ExpTime-complete in general [12].

3. Temporal conjunctive queries

We now combine the notions of (simple) conjunctive queries in
SHQ and ALC-LTL-formulae into a new formalism, called temporal
conjunctive queries.
In the following, we assume (as in [12]) that a subset of the
concept and role names is designated as being rigid. Let NRC  NC
denote the rigid concept names, and NRR  NR the rigid role names.
The names in NC \ NRC and NR \ NRR are called flexible. Individual
names are also rigid, i.e., an individual always keeps its name.
We first extend the notion of knowledge bases and models into
the temporal setting. The idea is that there is a global TBox and a
global RBox that define the terminology, and several ABoxes that
contain information about the state of the world at the time points
we have observed so far.
Definition 3.1 (TKB). A temporal knowledge base (TKB) K =
(Ai)0in, T , R consists of a finite sequence of ABoxes Ai, a TBox
T , and an RBox R.
Let I = (Ii)i0 be an infinite sequence of interpretations Ii =
(,Ii ) over a fixed domain  (constant domain assumption). Then
I is a model of K (written I |= K) if
 Ii |= Ai for all i, 0  i  n,
 Ii |= T and Ii |= R for all i  0, and
 I respects rigid names, i.e., we have xIi = xIj for all
x  NI  NRC  NRR and all time points i, j  0.

As for atemporal knowledge bases, we denote by Ind(K) the set of
all individual names occurring in a TKB K.

Definition 3.2 (TCQ). The set of simple temporal conjunctive queries
(TCQs) is the smallest set such that
 every simple CQ is a simple TCQ, and
 if 1 and 2 are simple TCQs, then so are1 (negation), 12
1 (previous), 1 U 2 (until),
(conjunction),
and 1 S 2 (since).

1 (next),

In the following, we usually drop the qualifier simple. As for conjunctive queries, the sets Ind() and FVar() contain all individuals
and free variables, respectively, of a TCQ , and a Boolean TCQ is a
TCQ without free variables.

As usual in temporal logics, one can define the following
abbreviations:
 1  2 := (1  2) (disjunction);
  := true U  (eventually);
  :=  (always);
  := true S  (once); and
  :=  (historically).
As before, we first define the semantics for Boolean queries,
which is a straightforward extension of the semantics of CQs and

Ii |= y1, . . . , ym.

iff
I, i |= 1
I, i |= 1 and I, i |= 2
I, i + 1 |= 1
i > 0 and I, i  1 |= 1
there is k  i with I, k |= 2
and I, j |= 1 for all j, i  j < k
there is k, 0  k  i with I, k |= 2
and I, j |= 1 for all j, k < j  i.

LTL-formulae. The main difference is that the point of reference is
not the first time point 0, as in LTL, but rather the last time point n
of a given temporal knowledge base. This can be seen as the current
time point, at which we have information (e.g., sensor data) about
the past, but not yet about the future. The notion of certain answers
can then be defined exactly as in the atemporal case.
Definition 3.3 (Semantics of TCQs). An infinite sequence of interpretations I = (Ii)i0 is a model of a Boolean TCQ  at time point
i  0 iff I, i |=  holds, which is defined inductively as follows
(cf. Definition 2.6):
I, i |= y1, . . . , ym.
I, i |= 1
iff
I, i |= 1  2
iff
I, i |= 1
iff
I, i |= 1
iff
I, i |= 1 U 2
iff
I, i |= 1 S 2
Given a TKB K = (Ai)0in, T , R, we say that I is a model of 
w.r.t. K if I |= K and I, n |= . We call  satisfiable w.r.t. K if it has
a model w.r.t. K, and it is entailed by K (written K |= ) if every
model I of K satisfies I, n |= .
a: FVar()  Ind(K) is a certain answer to  w.r.t. K if K |= a(),
where a() is the Boolean TCQ obtained from  by replacing the
free variables according to a.
As in the atemporal case, one can compute all certain answers by
enumerating the (exponentially many) mappings
a: FVar()  Ind(K) and then solving the entailment problem
K |= a() for each a. Therefore, it is enough to consider
the entailment problem. We instead analyze the complexity of
deciding non-entailment K |= . This problem has the same
complexity as the satisfiability problem of  w.r.t. K. In fact, K |= 
iff  has a model w.r.t. K, and conversely  has a model w.r.t. K
iff K |= .
Note that, for the data complexity, we have to measure the
complexity in the size of the sequence of ABoxes in the temporal
knowledge base, instead of just a single ABox. As for the data
complexity of the UCQ entailment problem, we assume that the
ABoxes occurring in a temporal knowledge base and the query
contain only concept and role names that also occur in the global
TBox or the global RBox.

Given a (not necessarily Boolean) TCQ , a mapping

Obviously, TCQ entailment includes as a special case the
entailment of CQs by atemporal knowledge bases, which can be
seen as temporal knowledge bases with a sequence of ABoxes of
length 1, i.e., having n = 0. Although models of such knowledge
bases are formally infinite sequences of interpretations, all but the
first interpretation are irrelevant for CQs.
On the temporal side, the TCQ satisfiability problem generalizes
the satisfiability problem for ALC-LTL-formulae since assertions
are Boolean CQs. Although ALC-LTL-formulae may additionally
contain GCIs, they can equivalently be expressed by negated CQs
(see the proof of Theorem 4.3 for details). On the other hand,
TCQs are more expressive than ALC-LTL-formulae since CQs like
y.r(y, y), which says that there is a loop in the model without
naming the individual which has the loop, can clearly not be
expressed in ALC.

4. Complexity of TCQ entailment

We now analyze the complexity of TCQ entailment in DLs
between ALC and SHQ. We emphasize again that our queries only
use simple role names. Without this restriction, UCQ entailment
is already 2-ExpTime-hard in SH [33]. It is not clear whether

We now show that the existence of an interpretation I with
I |= K for K = A, T , R and I |=  is equivalent to the existence
of an equivalence relation as above and an interpretation I with
I |= A  A, T , R and I |= 1    m.
For the if direction, assume that  is an equivalence relation
on the individual names and I is a model of A, T , R, A, and
1m. By mapping each variable occurring in 1l
to the interpretation of the representative of the equivalence class
of the corresponding fresh individual name, we obtain homomorphisms from i into I, for each i, 1  i  n. This shows that I is
also a model of .
For the only if direction, assume that I |= K and I |= . Thus,
there are homomorphisms from each i, 1  i  n, into I. We define any pair of individual names in A  A equivalent w.r.t.  iff
they are mapped to the same domain element by their respective
homomorphisms or I. The extension of I that maps each representative of its equivalence class to exactly this domain element is obviously a model of A. It still satisfies A, T , R, and1m
since they do not contain the new individual names, and thus it is
of the required form.
The above problem is thus equivalent to finding an equivalence
relation  and an interpretation I with I |= A  A, T , R and
I |= , where  := 1    m is the Boolean UCQ that results
from negating the conjunction of all negated CQs in . This is the
same as asking whether A  A, T , R does not entail .
For the combined complexity, we can enumerate all equivalence relations  in exponential time, and check the above nonentailment for the polynomial-size SHQ-knowledge base and UCQ
resulting from each , which can be done in ExpTime [8]. For the
data complexity, we can guess  in nondeterministic polynomial
time, and check the non-entailment in NP [13].
In the remainder of this paper, we will present several construc-
tions, most of which use the above theorem, to derive the complexity results shown in Table 1 for TCQ entailment in all DLs between
ALC and SHQ. The results depend on which symbols are allowed
to be rigid.

our methods would allow us to show tight upper bounds, as they
presently rely on the fact that UCQ entailment is in ExpTime (see
Theorem 4.1). This allows us to show the same complexity results
for simple TCQ entailment for all logics between ALC and SHQ,
i.e., we show the lower bounds for ALC and the upper bounds for
SHQ.

The restriction that all interpretations satisfy the UNA simplifies
some of the proofs, but does not affect the results in this paper.
More precisely, the complexity lower bounds follow from hardness
results in [38,12], the proofs of which are independent of the
unique name assumption. For the upper bounds, observe that, to
find a model that does not necessarily satisfy the UNA, one can
guess in nondeterministic polynomial time an equivalence relation
on the individual names that collects those names that will be
interpreted as the same domain element, replace all names by a
fixed representative of their equivalence class, and then ask for a
model satisfying the UNA. For details on this construction, see [14]
or the proof of Theorem 4.1, where we need to enforce the UNA on
newly introduced individual names. This additional guessing step
does not affect our complexity results.

We first take a look at the atemporal special case of the satisfiability problem for conjunctions  of CQ-literals, which are either
Boolean CQs or negated Boolean CQs. Since such a Boolean TCQ
 contains no temporal operators, for the satisfiability problem it
suffices to consider a single interpretation instead of an infinite sequence I = (Ii)i0 of interpretations. Extending the notation for
|=  instead of I, i |=  in this case.
UCQs, we often write Ii
Furthermore, it is sufficient to consider TKBs with only one ABox,
which can be viewed as classical knowledge bases. The following
result will prove useful also for analyzing entailment of arbitrary
TCQs.

Theorem 4.1. Deciding satisfiability of a conjunction of CQ-literals
w.r.t. a knowledge base is
 ExpTime-complete w.r.t. combined complexity and
 NP-complete w.r.t. data complexity.
Proof. Deciding CQ entailment in ALC is ExpTime-hard w.r.t.
combined complexity and co-NP-hard w.r.t. data complexity
[35,9,38]. This problem is a special case of the complement of our
problem.
Let now K = A, T , R be an SHQ-knowledge base and
 be a conjunction of CQ-literals. To check whether there is an
interpretation I with I |= K and I |= , we reduce this problem
to a query non-entailment problem of known complexity. Let
 = 1    l  1    m
for Boolean CQs 1, . . . , l, 1, . . . , m. First, we instantiate the
non-negated CQs 1, . . . , l by omitting the existential quantifiers
and replacing the variables by fresh individual names. The set A of
all resulting atoms can thus be viewed as an additional ABox that
restricts the interpretation I.

However, we also have to ensure that the UNA is respected for
the newly introduced individual names. To do this, we employ
a trick from [14], which consists in guessing an equivalence
relation  on Ind(A  A) that specifies which individual names
are allowed to be mapped to the same domain element, with the
additional restriction that each equivalence class can contain at
most one element from Ind(A). For such a relation , we fix a
representative for each equivalence class such that every class that
contains an a  Ind(A) has a as its representative. We denote by
A the ABox resulting from A by replacing each new individual
name by the representative of its equivalence class. Note that there
are exponentially many such equivalence relations, each of which
is of size polynomial in the size of .

4.1. Lower bounds for the entailment problem

For the data complexity, we obtain the lower bounds from

Theorem 4.1.
Corollary 4.2. TCQ entailment is co-NP-hard w.r.t. data complexity.
Proof. Theorem 4.1 states that for conjunctions of CQ-literals 
and atemporal knowledge bases K, deciding whether  has a
model w.r.t. K is NP-complete w.r.t. data complexity. Since  is a
special TCQ and rigid names are irrelevant in the atemporal case,
we obtain co-NP-hardness w.r.t. data complexity for the entailment problem for all the cases in Table 1.
For the combined complexity, we get the lower bounds by a simple
reduction of the satisfiability problem for ALC-LTL [12].
Theorem 4.3. TCQ entailment w.r.t. combined complexity is
 ExpTime-hard if NRC = NRR = ;
 co-NExpTime-hard if NRC =  and NRR = ; and
 2-ExpTime-hard if NRR = .
Proof. We reduce the satisfiability problem of ALC-LTL to the TCQ
non-entailment problem.
Let  be the Boolean TCQ and T be the TBox obtained from an
ALC-LTL-formula  as follows. We replace each GCI C  D in 
by (x.A(x)) and add A  C  D to T , where A is a fresh concept name. Similarly, we replace every complex concept assertion
E(a) in  by B(a) and add B  E to T . Then  is satisfiable iff
, T , |= .
Since satisfiability of ALC-LTL-formulae is ExpTime-complete
without rigid names, NExpTime-complete with rigid concept
names, and 2-ExpTime-complete with rigid concept and role
names [12], this shows the claimed lower bounds.

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

 each Ji, 1  i  k, is a model of

i := 

j; and

pjXi

pjXi

In the following sections, we present the ideas for the upper
bounds w.r.t. combined complexity and data complexity. For the
former, we can match all lower bounds we have from Theorem 4.3.
For the latter, unfortunately we cannot match the lower bound
of co-NP in the case where we have rigid role names. While our
constructions need to deal with CQs and the additional expressivity
of SHQ in an appropriate way, the basic ideas are similar to those
presented for ALC-LTL in [12].

4.2. Upper bounds for the entailment problem

pX

pX


LTL-formula

Note that a formula  is satisfied iff  holds at all time points.

We divide the satisfiability problem of a Boolean TCQ  w.r.t. a
TKB K = (Ai)0in, T , R into two separate satisfiability prob-
lems, similar to what was done for ALC-LTL in Lemma 4.3 of [12].
The t-satisfiability expresses that the temporal structure of  is conWe consider the propositional abstraction of , which is the
sistent, while the r-satisfiability determines whether it is possible
to satisfy the rigidity constraints for the names in NRC and NRR.
CQs occurring in , p1, . . . , pm are the propositional variables of,
propositional LTL-formula built from  by replacing each CQ by a
unique propositional variable. We assume that 1, . . . , m are the
and that each i is replaced by pi for all i, 1  i  m. This LTLformula allows us to analyze the temporal structure of  separately
from the DL query component.
We now consider a set S  2{p1,...,pm}, which intuitively spec-
isfying. To express this restriction, we define the propositional
ifies the worlds that are allowed to occur in an LTL-structure sat-
S :=  
An immediate connection between  andS is formalized in the
next lemma.
2{p1,...,pm} and a propositional LTL-structure that is a model ofS at
Lemma 4.4. If  has a model w.r.t. K, then there is a set S 
time point n.
Proof. Let I = (Ii)i0 be a sequence of interpretations that respects rigid names, is a model of K, and satisfies I, n |= . For each
interpretation Ii of I, we set
Xi := {pj | 1  j  m and Ii satisfies j},
sitional abstractionI = (wi)i0 of I is now defined by wi := Xi for
and then consider the set S := {Xi | i  0} induced by I. The propopoint n implies thatI is a model ofS at time point n.
all i  0. It is easy to check that the fact that I satisfies  at time
LTL-formulaS is has a model at time point n is not sufficient
However, guessing a set S and then testing whether the induced
for checking whether  has a model w.r.t. K. We must also check
whether S can indeed be induced by some sequence of interpretations that is a model of K. In the following, let S = {X1, . . . , Xk} 
2{p1,...,pm}, and : {0, . . . , n}  {1, . . . , k} be a mapping that specifies a set X(i) for each of the ABoxes Ai, 0  i  n.
Definition 4.5 (r-Satisfiability). We call S r-satisfiable w.r.t.  and K
if there exist interpretations J1, . . . , Jk, I0, . . . , In such that
 they share the same domain and respect rigid names;2
 they are models of T and R;

2 This is defined analogously to the case of sequences of interpretations
(Definition 3.1).

Satisfaction of the temporal structure of  by a sequence of in-

 each Ii, 0  i  n, is a model of Ai and (i).
The intuition underlying this definition is the following. The
existence of the interpretation Ji, 1  i  k, ensures that the
conjunction i of the CQ-literals specified by Xi is consistent. In fact,
a set S containing a set Xi for which this does not hold cannot be
induced by a sequence of interpretations. The interpretations Ii,
0  i  n, constitute the first n + 1 interpretations in such a
sequence. In addition to inducing a set X(i)  S and thus satisfying
the corresponding conjunction (i), the interpretation Ii must also
satisfy the ABox Ai. The first and the second condition ensure
that a sequence of interpretations built from J1, . . . , Jk, I0, . . . , In
respects rigid names and satisfies the global TBox T and the global
RBox R. Note that we can use Theorem 4.1 to check whether
interpretations satisfying the last three conditions of Definition 4.5
exist. As we will see below, the difficulty lies in ensuring that they
also satisfy the first condition.

ity w.r.t. a side condition that ensures that the first n worlds are
those chosen by .

terpretations built this way is ensured by testingS for satisfiabilDefinition 4.6 (t-Satisfiability). The LTL-formula is t-satisfiable
w.r.t. S and  if there exists an LTL-structure J = (wi)i0 such that
 J, n |=S and
 wi = X(i) for all i, 0  i  n.
We can now combine these two satisfiability tests to decide
satisfiability of a TCQ w.r.t. a TKB.
Lemma 4.7. The TCQ  is satisfiable w.r.t. the TKB K iff there is a set
S = {X1, . . . , Xk}  2{p1,...,pm} and a mapping
: {0, . . . , n}  {1, . . . , k} such that
 is t-satisfiable w.r.t. S and .
 S is r-satisfiable w.r.t.  and K, and
Proof. For the only if direction, assume that there is a sequence
of interpretations I = (Ii)i0 with I |= K and I, n |= . Re-
S  2{p1,...,pm} such thatS is satisfiable at time point n. Let S =
call that we have already seen in Lemma 4.4 that I induces a set
{X1, . . . , Xk}. For each i  0, there is an index i  {1, . . . , k} such
that Ii induces the set Xi, i.e.,
Xi = {pj | 1  j  m and Ii satisfies j},
and, conversely, for each   {1, . . . , k}, there is an index i  0
all i, 0  i  n. LetI = (wi)i0 be the propositional abstraction of
such that  = i. We define the mapping  as follows: (i) = i for
I. As argued in Lemma 4.4,I is a model ofS at time point n. By
definition of , Xi andI, we also have wi = X(i) for all i, 0  i  n.
For i, 1  i  k, the interpretation Ji is obtained as follows.
Let l1, . . . , lk be such that l1 = 1, . . . , lk = k. Now, if we set
Ji := Ili, then it is clear that Ji is a model of i. It is now easy to
see that the interpretations J1, . . . , Jk, I0, . . . , In satisfy the conditions for r-satisfiability of S w.r.t.  and K.
To show the if direction, assume that there is a set S =
structure J = (wi)i0 such that J is a model ofS at time point
{X1, . . . , Xk}, a mapping : {0, . . . , n}  {1, . . . , k}, an LTL-
n and wi = X(i) for all i, 0  i  n, and models J1, . . . , Jk,
By the definition ofS, for every world wi, there is exactly one
I0, . . . , In of T and R with the properties of Definition 4.5.

index i  {1, . . . , k} such that wi satisfies

p.

pXi

pXi

Since wi, 0  i  n, satisfies exactly the propositional variables
of X(i), we have (i) = i. We can now define a sequence of interpretations I := (Ii)i0 respecting rigid names as follows: we set
CQs specified by the propositional variables in Xi. Since J, n |=S,
Ii := Ji for i > n. By Definition 4.5, each Ii satisfies exactly the
this means that I, n |= . It also follows directly from Definition 4.5 that I |= K. Hence, we have that  has model w.r.t. K. 
Since the overall complexity of the satisfiability problem depends
on which symbols are allowed to be rigid, we obtain the set S and
the function  either by enumeration, guessing, or direct construction (see, e.g., Theorems 4.13 and 4.15). Given S and , it remains
to check the two conditions of Lemma 4.7. For the r-satisfiability
test, we need to use different constructions depending on which
symbols are allowed to be rigid. Using these constructions, we obtain the complexity results for the entailment problem shown in
Table 1. The details can be found in later sections. First, we focus
on the second condition of Lemma 4.7.

4.2.1. An automaton for LTL-satisfiability

We construct a generalized Buchi automaton, similar to the
standard construction for satisfiability of LTL-formulae [15,16],
such that emptiness of this automaton is equivalent to t-

satisfiability of w.r.t. S and .
Definition 4.8 (Generalized Buchi Automaton). A generalized Buchi
automaton G = (Q , , , Q0, F) consists of a finite set of states Q ,
a finite input alphabet , a transition relation   Q    Q ,
a set Q0  Q of initial states, and a set of sets of accepting states
F  2Q .
Given an infinite word w = 012 . . .   , a run of G on
w is an infinite word q0q1q2 . . .  Q  such that q0  Q0 and
(qi, i, qi+1)   for all i  0. This run is accepting if, for every
F  F, there are infinitely many i  0 such that qi  F. The language accepted by G is defined as
L(G) := {w    | there is an accepting run of G on w}.
The emptiness problem for generalized Buchi automata is the problem of deciding, given a generalized Buchi automaton G, whether
L(G) =  or not.
We use generalized Buchi automata rather than normal ones
(where |F| = 1) since this allows for a simpler construction
below. It is well-known that a generalized Buchi automaton can
be transformed into an equivalent normal one in polynomial time
[39,40]. Together with the fact that the emptiness problem for
normal Buchi automata can be solved in polynomial time [16],
this yields a polynomial time bound for the complexity of the
emptiness problem for generalized Buchi automata.

To define our automaton, we need the notion of a type for.
Definition 4.9 (Type). A sub-literal of is a sub-formula of or its
negation. A set T of sub-literals of is a type for iff the following
1. for every sub-formula  of, we have   T iff   T;
2. for every sub-formula 1  2 of, we have 1  2  T iff
{1, 2}  T;
We denote the set of all types for by T. We further define
the set T|S  T that contains all types T for  for which
T  {p1, . . . , pm}  S.
The reason that we use the types for and not forS is that the

properties are satisfied:

latter formula is exponentially larger than the former. To avoid this
exponential blowup in the automaton, we check the additional

if k < n + 1, and
otherwise;

This automaton accepts exactly those sequences of worlds that

condition ofS, namely that each world of a model must occur in
the set S, by restricting the first component of the state set of the
automaton to T|S.
Another difference to the standard construction for LTL is the
additional condition that wi = X(i) should hold for all i, 0  i  n.
We check this by attaching a counter from {0, . . . , n + 1} to the
states of the automaton. Transitions where the counter is i < n+1
counter by 1. At i = n, we ensure that is satisfied.
check if the current world corresponds to X(i) and increase the
Definition 4.10 (Automaton for t-Satisfiability). The generalized
Buchi automaton G = (Q , , , Q0, F) is defined as follows:
 Q := T|S  {0, . . . , n + 1};
  := 2{p1,...,pm};
 ((T , k),  , (T, k))   iff
  = T  {p1, . . . , pm};
   T iff   T;
  T iff   T;

 1 U 2  T iff (i) 2  T or (ii) 1  T and 1 U 2  T;
 1 S 2  T iff (i) 2  T or (ii) 1  T and 1 S 2  T;
 k = n implies  T; and
 k < n + 1 implies  = X(k);
 k =k + 1
 F contains, for each sub-formula of of the form 1 U 2, the
  T}; and
 Q0 := {(T , 0) | 1 S 2  T  2  T and
set F1 U 2  {n + 1}, where
F1 U 2 := {T  T|S | 1 U 2  T  2  T}.
satisfy the conditions for t-satisfiability of w.r.t. S and . The
proof is a straightforward extension of the original proof for LTLsatisfiability [15,16], and can be found in the Appendix.
w  L(G) iff the LTL-structure J := (wi)i0 satisfies J, n |=S and
Lemma 4.11. For every infinite word w = w0w1 . . .   , we have
wi = X(i) for all i, 0  i  n.
This implies that L(G) =  iff is t-satisfiable w.r.t. S and .
Lemma 4.12. Deciding t-satisfiability of w.r.t. S and  can be done
 in ExpTime w.r.t. combined complexity and
 in P w.r.t. data complexity.
types for and exponentially many input symbols in 2{p1,...,pm}.
Proof. For combined complexity, there are exponentially many
The set F contains linearly many sets of size at most exponential,
while the size of Q0 and  is bounded polynomially in the size of Q
(which is exponential). Since all conditions that need to be checked
to construct the components of G can be checked in exponential
time, and the size of G is exponential in the size of K and , the
emptiness test can be done in ExpTime.
For data complexity, the size of G is polynomial in n because of
the following reasons: the size of T|S is constant since the size of
S depends only on the size of , which is constant. Thus, the size
of Q is linear in n. The size of  is constant. Obviously, then the
size of  is polynomial in n. The size of Q0 is linear in n, because
Q0  Q . The size of F is logarithmic in n, because each set F1 U 2
is of constant size, and the number of such sets does not depend
on n. Obviously, G can also be constructed in time polynomial in n.
The data complexity of the emptiness test is thus in P.
However, the complexity of the entailment problem also depends
on the complexity of the r-satisfiability test for S. In the following
sections, we will establish some results as to this complexity in the
cases without rigid names, and with rigid concept and role names.
The most interesting (and most complex) case without rigid role
names, but with rigid concept names, is considered in Section 5 for
data complexity and in Section 6 for combined complexity.

We can thus decide the latter problem by testing G for emptiness,
which yields the following complexity results.

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

4.2.2. The case without rigid names
Assume that a set S = {X1, . . . , Xk}  2{p1,...,pm} and a mapping
: {0, . . . , n}  {1, . . . , k} are given. To check r-satisfiability of S
w.r.t.  and K without rigid names, it clearly suffices to check the
satisfiability of the following conjunctions of CQ-literals w.r.t. the
TBox T and the RBox R individually:
 for each i, 1  i  k, the conjunction i; and

 for each i, 0  i  n, the conjunction (i) 

.3

Ai

Each of these conjunctions of CQ-literals is of polynomial size in
the size of K and . We can now use Theorem 4.1 to establish the
complexity of the entailment problem without rigid names.
Theorem 4.13. If NRC = NRR = , TCQ entailment is
 in ExpTime w.r.t. combined complexity and
 in co-NP w.r.t. data complexity.
Proof. For combined complexity, note that we do not need to
guess the set S. Since the r-satisfiability condition imposes no dependency between the sets X  S, it suffices to define S as the set
of all sets Xi that pass the satisfiability test of the corresponding
conjunction i w.r.t., T , R. Since there are exponentially many
such sets, but each of them is of polynomial size, by Theorem 4.1 we
only have to do exponentially many ExpTime-tests to construct S.
We can further enumerate all possible mappings  in exponential time and check for each  the satisfiability of the conjunctions
 again in ExpTime. For each  that passes these

(i)  
tests, we can check t-satisfiability of w.r.t. S and  in ExpTime by

Lemma 4.12. Lemma 4.7 now yields a total complexity of ExpTime
for the satisfiability problem, and therefore also for the entailment
problem.
For data complexity, note that since S is of constant size
w.r.t. the ABoxes and  is linear in n, guessing S and  can be done
in NP. Since the t-satisfiability test can be done in P (Lemma 4.12)
and the satisfiability tests for r-satisfiability of S can be done in NP
(Theorem 4.1), by Lemma 4.7 the satisfiability problem is also in
NP.

Ai

4.2.3. The case with rigid role names
If the sets NRC and NRR are allowed to be non-empty, the
satisfiability tests for the r-satisfiability of S are not independent
any longer. To make sure that the models respect the rigid symbols,
we use a renaming technique similar to the one used in [12] that
works by introducing enough copies of the flexible symbols.
For every i, 1  i  k + n + 1, and every flexible concept name
A (every flexible role name r) occurring in T or R, we introduce a
copy A(i) (r (i)). We call A(i) (r (i)) the ith copy of A (r). The conjunctive query (i) (the GCI/transitivity axiom/role inclusion  (i)) is obtained from a CQ  (a GCI/transitivity axiom/role inclusion ) by
replacing every occurrence of a flexible name by its ith copy. Sim-
ilarly, for 1  l  k, the conjunction of CQ-literals  (i)
is obtained

from l (see Definition 4.5) by replacing each CQ j by (i)
. Finally,

we define

 (k+i+1)

(i)

(k+i+1)

TS, := { (i) |   T and 1  i  k + n + 1},
RS, := { (i) |   R and 1  i  k + n + 1}.
Note that here it is essential that the ABoxes do not contain complex concepts, otherwise they could not be interpreted as conjunctions of CQ-literals.

S, := 

1ik

 (i)

0in

Ai

3 We can assume that all of these models have the same domain since their
domains can be assumed to be countably infinite by the LowenheimSkolem
theorem, and that all individual names are interpreted by the same domain
elements in all models.

Lemma 4.14. The set S is r-satisfiable w.r.t.  and K iff S, is satisfiable w.r.t. TS,, RS,.
The proof of this lemma can be found in the Appendix. Unfortu-
nately, the data complexity of this approach does not allow us to
match the lower bound of co-NP for the entailment problem we
have from Corollary 4.2. However, for the combined complexity we
obtain containment in 2-ExpTime.
Theorem 4.15. If NRR = , TCQ entailment is
 in 2-ExpTime w.r.t. combined complexity and
 in ExpTime w.r.t. data complexity.
Proof. To check a TCQ  for satisfiability w.r.t. a TKB K, we
first enumerate all possible sets S and mappings , which can be
done in 2-ExpTime w.r.t. combined complexity and in ExpTime
w.r.t. data complexity since S is constant in this case. For each
of these double-exponentially many pairs (S, ), we then check

t-satisfiability of S w.r.t. S and  in exponential time (see

Lemma 4.12) and test S for r-satisfiability w.r.t.  and K. By
Lemma 4.7,  has a model w.r.t. K iff at least one pair passes both
tests.

For the combined complexity of the r-satisfiability test, observe
that the conjunction of CQ-literals S, is of exponential size in the
size of  and K. By Theorem 4.1, the overall combined complexity
of the r-satisfiability test is thus in 2-ExpTime.

For the data complexity of the r-satisfiability test, we know that
S, is of linear size in the size of the input ABoxes. Unfortunately,
by copying each of the types (i) assigned to the ABoxes, we have
introduced linearly many negated CQs, which is why Theorem 4.1
only yields an ExpTime upper bound for the data complexity. Note
that linearly many non-negated CQs in S, are not problematic, as
they can be instantiated and viewed as part of the ABox, as detailed
in the proof of Theorem 4.1.
However, we can match the lower bound of co-NP for the data
complexity in the following special cases.
Lemma 4.16. If NRR = , TCQ entailment is in co-NP w.r.t. data
complexity if any of the following conditions apply:
1. The number n of the input ABoxes is bounded by a constant.
2. The set of individual names allowed to occur in the ABoxes is fixed.
Proof. As in the proof of Theorem 4.13, we can guess the set S
and the mapping  in NP and do the LTL-satisfiability test in P.
Thus, it suffices to show that in the above-mentioned special cases
r-satisfiability of S can be tested in NP.
1. If n is bounded by a constant, then the number of negated CQs
in S, is constant, and thus Theorem 4.1 yields the desired NP
upper bound.

2. If the set of individual names is fixed, then the number of
possible assertions involving concept names occurring in the
TBox is constant. Note that the concept names occurring only
in the ABoxes do not affect the entailment of the TCQ, as they
can only occur in positive assertions, and can thus always be
satisfied by appropriately interpreting the new names.
This allows us to restrict the formula S, to contain at most
one copy of (i) for each distinct combination of (i) and Ai
(ignoring assertions about names that do not occur in the TBox).
Clearly, consistency of each combination of an ABox with a
type needs to be checked only once. Since there are now only
constantly many such combinations, the modified TCQ 
S,
again contains only constantly many negated CQs. As in the
previous case, Theorem 4.1 yields the result.

5. Data complexity for the case of rigid concept names

i := 

S := 

We will now show that the data complexity of TCQ entailment
in the case where NRC =  and NRR =  is in co-NP. As detailed in
the proof of Theorem 4.13, it suffices to show that r-satisfiability of
S w.r.t.  and K can be checked in NP.

Similar to the previous sections, we construct conjunctions of
CQ-literals of which we want to check satisfiability. The approach
is a mixture of those of Sections 4.2.2 and 4.2.3, as we combine
several satisfiability tests required for r-satisfiability, but do not
go as far as compiling all of them into just one conjunction. More
precisely, we consider the conjunctions of CQ-literals
i  S, 0  i  n, w.r.t. TS , RS, where

Ai

((i)),

 (i)

1ik
TS := { (i) |   T and 1  i  k},
RS := { (i) |   R and 1  i  k}.
However, for r-satisfiability we have to make sure that rigid consequences of the form A(a) for a rigid concept name A  NRC and
an individual name a  NI are shared between all of these conjunctions i  S. It suffices to do this for the set RCon(T ) of rigid
concept names occurring in T since those that occur only in ABox
assertions cannot affect the entailment of the TCQ .
Similar to what was done in Lemma 6.3 of [12], we guess a set
D  2RCon(T ) and a function  : Ind()  Ind(K)  D. The idea is
that D fixes the combinations of rigid concept names that occur in
the models of i  S and  assigns to each individual name one
such combination. To express this formally, we extend the TBox by
the axioms in
T := {A (a)  C (a) | a  Ind()  Ind(K)},
where A (a) are fresh rigid concept names and, for every
Y  RCon(T ), the concept CY is defined as


 := 
Correspondingly, we extend the conjunctions i  S by

ARCon(T )\Y

A.

A (a)(a)

aInd()Ind(K)

in order to fix the behavior of the rigid concept names on the
named individuals.

We need one more definition to formulate the main lemma of

this section. We say that an interpretation I respects D if
D = {Y  RCon(T ) | there is a d  I with d  (CY )I},
which means that every combination of rigid concept names in D
is realized by a domain element of I, and conversely, the domain
elements of I may only realize those combinations that occur in D.
Lemma 5.1. If NRC =  and NRR = , then S is r-satisfiable w.r.t. 
and K iff there exist D  2RCon(T ) and  : Ind()Ind(K)  D such
that each i  S   , 0  i  n, has a model w.r.t. TS  T , RS
that respects D.
The proof of this lemma can be found in the Appendix.

Observe now that the restriction imposed by D can equivalently

be expressed as the conjunction of CQ-literals

D := (x.AD(x)) 
adding the axioms AD  U

x.AY (x),

where AY and AD are fresh concept names that are restricted by
YD AY and AY  CY for each Y  D

S , RS.

S the resulting extension of TS  T ,
to the TBox.4 We denote by T 
and have now reduced the r-satisfiability of S w.r.t.  and K to the
consistency of i  S    D w.r.t. T 
Theorem 5.2. If NRC =  and NRR = , TCQ entailment is in co-NP
w.r.t. data complexity.
Proof. Following the reduction described above, we guess a set
D  2RCon(T ) and a function  : Ind()  Ind(K)  D, which can
be done in nondeterministic polynomial time since D only depends
on T and  is of size linear in the size of the input ABoxes. Next,
we check the satisfiability of the polynomially many conjunctions
i  S    D w.r.t. T 
S, and RS
do not depend on the input ABoxes, while i and  are of polynomial size. Furthermore, only S may contain negated CQs, and
thus their number does not depend on the size of the input ABoxes.
Hence, one can see from the proof of Theorem 4.1 that this satisfiability problem can be also be decided in nondeterministic polynomial time in data complexity.

S , RS. Note that S, D, T 

By Lemma 5.1, r-satisfiability of S w.r.t  and K can be decided
in NP, and thus we can obtain the desired complexity upper bound
for TCQ entailment as in the proof of Theorem 4.13.

6. Combined complexity for the case of rigid concept names

Unfortunately, the approach used in the previous section does
not yield a combined complexity of co-NExpTime. The reason is that
the conjunctions S and D are of exponential size in the size of
, and thus Theorem 4.1 only yields an upper bound of 2-ExpTime.
In this section, we describe a different approach with a combined
complexity of co-NExpTime.

As a first step, we rewrite the Boolean TCQ  into a Boolean TCQ
 of polynomial size in the size of  and K such that answering 
at time point n is equivalent to answering  at time point 0 w.r.t. a
trivial sequence of ABoxes. This is done by compiling the ABoxes
into the query and postponing  using the
Lemma 6.1. Let K = (Ai)0in, T , R be a TKB and  be a Boolean
TCQ. Then there is a Boolean TCQ  of size polynomial in the size of
 and K such that K |=  iff , T , R |= .
Proof. We define the Boolean TCQ
 := (0  1    nn)  n,

-operator.

Ai

 and

K |= 

i abbreviates i nested

operators.
Obviously, the size of  is polynomial in the size of  and K. It
remains to prove that K |=  iff K := , T , R |= . We have:
iff (Ai)0in, T , R |= 
iff I, n |=  for all I |= (Ai)0in, T , R
iff I, n |=  for all I |= K with I, 0 |= 0; I, 1 |= 1; ...;
iff I, 0 |= n for all I |= K with I, 0 |= 0; I, 0 |= 1; ...;
iff I, 0 |=  for all I |= K
iff K |= .

I, n |= n
I, 0 |= nn

where i := 

We can thus focus on deciding whether a Boolean TCQ  has a
model w.r.t. a TKB K = , T , R containing only one empty ABox.

4 We did not add all the axioms AY  CY earlier since we reuse Lemma 5.1 in the
following section about combined complexity, and these additional axioms cause
an exponential blowup in the size of the TBox.

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

Note that this compilation does not yield a low data complexity for
the entailment problem since, after encoding the ABoxes into ,
the size of S as well as that of the generalized Buchi automaton G
are exponential in the size of the ABoxes (cf. Sections 4.2.1 and 5).
We now again analyze the two conditions of Lemma 4.7,
this time with the goal of obtaining a combined complexity of
NExpTime for the TCQ satisfiability problem. First, observe that
guessing S = {X1, . . . , Xk}  2{p1,...,pm} and : {0}  {1, . . . , k}
can be done in nondeterministic exponential time in the size
of . Furthermore, by Lemma 4.12, the t-satisfiability test can be
realized in ExpTime. It remains to determine the complexity of
testing r-satisfiability of S w.r.t.  and K = , T , R.

We do this in three steps. First, in Section 6.1 we reduce this
problem to a variant of the satisfiability problem for conjunctions
of CQ-literals w.r.t. a knowledge base and a set D as in Section 5.
This problem is then further reduced in Section 6.2 to the
consistency problem for Boolean SHQ-knowledge bases w.r.t. D.
Finally, the latter problem is shown to be decidable in ExpTime in
Section 6.3.

6.1. Reduction to atemporal queries

As mentioned above, we start the r-satisfiability test as in Section 5 by guessing a set D  2RCon(T ) and a mapping
 : Ind()  D. Since D is of size exponential in T and  is of size
polynomial in the size of  and T , guessing D and  can also be
done in NExpTime. Since 0 = true, by Lemma 5.1 we know that r-
satisfiability of S is independent of  and it suffices to test whether
S   has a model w.r.t.TS T , RS that respects D. Instead of
applying Theorem 4.1 directly to this problem, which would yield
a complexity of 2-ExpTime, we split it into separate sub-problems
for each component i of S. The proof of the next lemma can be
found in the Appendix.
Lemma 6.2. If NRC =  and NRR = , then S is r-satisfiable w.r.t.
that eachi := i   , 1  i  k, has a model w.r.t. T  T , R
K = , T , R iff there exist D  2RCon(T ) and  : Ind()  D such
Note that the size of eachi is polynomial in the size of  and T
that respects D.
i w.r.t. T  T , R that respect D in exponential time in the size
ofi, T , T , and R. This yields the desired complexity result for r-
satisfiability, and thus the last result of Table 1 for TCQ entailment.
Theorem 6.3. If NRC =  and NRR = , TCQ entailment is in coNExpTime w.r.t. combined complexity.
6.2. Reduction to Boolean SHQ-knowledge bases

and the number k of these conjunctions is exponential in the size
of . Moreover, the size of T is polynomial in the size of  and T .
We show in Lemma 6.8 that we can find the required models for

We now show that the problem of checking whether there is
a model of a conjunction  of CQ-literals w.r.t. a knowledge base
T , R that respects a set D  2RCon(T ) can be solved in exponential time in the size of , T , and R. As in the proof of Theorem 4.1, we first reduce this problem to a non-entailment problem
for a union of Boolean CQs: there is a model of  and T , R that
respects D iff there is a model of A, T , R that respects D and
is not a model of  (written A, T , R |=  w.r.t. D), where A
is an ABox obtained by instantiating the non-negated CQs in 
with fresh individual names and  is a UCQ constructed from the
negated CQs in . It thus suffices to show that we can decide query
non-entailment A, T , R |=  w.r.t. D in time exponential in the
size of A, T , R, and .
It is known that A, T , R |=  iff there is a forest model I of
A, T , and R such that I |=  [14,8]. We define here forest models

for the more general case of Boolean SHQ-knowledge bases (recall
Definition 2.3) since we need them for the subsequent reductions
and in the proof of Lemma 6.14.

Definition 6.4 (Forest Model). A tree is a non-empty prefix-closed
subset of N, where N denotes the set of all finite words over the
non-negative integers.
An interpretation I = (I ,I ) is a forest base for a Boolean
SHQ-knowledge base B =  , R if
 I  Ind( )  N such that for all a  Ind( ) the set
{u | (a, u)  I} is a tree;
 if ((a, u), (b, v))  rI, then either u = v = , or a = b and
v = u  c for some c  N, where  denotes concatenation; and
 for every a  Ind( ), we have aI = (a, ).
A model J = (J ,J ) of B is called a forest model of B if there
is a forest base I = (I ,I ) for B such that I = J , for each
A  NC, we have AI = AJ , for each a  NI, we have aI = aJ , and

for each r  NR, we have
rJ = rI 
where + denotes the transitive closure.
Note that B =  , R has a model that respects D iff A(a), R
has a model that respects D, where a is a fresh individual name and
A is a fresh concept name. We thus assume without loss of generality that  always contains at least one individual name. This is
necessary to ensure that there is a non-empty forest base for B.

R|=sr, R|=trans(s)

(sI )+,

As an example of a forest model, consider Fig. 2, where a graphical representation of a forest model is given. It depicts the individual names a, b, and c, which represent the roots (a, ), (b, ), and
(c, ) of three trees. Moreover, s is a simple role name, and r is a
transitive role name. The solid arrows denote the role connections
that are present in the corresponding forest base, and the dashed
arrows denote role connections that are introduced due to transi-
tivity.

The construction in the proof of the following lemma is very
similar to the one in [14], but we extend the previous result to
Boolean knowledge bases, take into account a set D, and provide
a full proof in the Appendix.
Lemma 6.5. Let B be a Boolean SHQ-knowledge base, let
A1, . . . , Ak be concept names occurring in B, and let D  2{A1,...,Ak}.
Then B has a model that respects D iff it has a forest model that
respects D.
We can also extend the mentioned result about non-entailment of
UCQs from [14,8] to our setting. In the following, we assume that
the UCQ  contains only individuals that also occur in the ABox
(or Boolean axiom formula). If this is not the case for an individual
name a, we can simply add A(a) to the ABox, where A is a new
concept name.
Lemma 6.6. We have A, T , R |=  w.r.t. D iff there is a forest
model J of A, T , R that respects D with J |= .
Recall that we want to decide the existence of such a forest model
in time exponential in the size of A, T , R, and . To this purpose, we
further reduce this problem following an idea from [8]. There, the
notion of a spoiler is introduced. A spoiler is an SHQ-knowledge
base A, T , that states properties that must be satisfied such
that a query is not entailed by a knowledge base. The ABox A of
such a spoiler may also contain negated assertions, and can thus
be seen as a Boolean knowledge base, but for simplicity we will
continue to regard it as a set. Furthermore, a spoiler may contain
role conjunctions.

Fig. 2. An example of a forest model.

It is shown in [8] that A, T , R |=  iff there is a spoiler
A, T , for A, T , R such that A  A, T  T , R is consis-
tent. Additionally, all spoilers can be computed in time exponential in the size ofA, T , R and , and each spoiler is of polynomial
size. In the proof of these results, one only has to deal with forest
models, which furthermore do not need to be modified. More for-
mally, for any forest model I of A, T , R that does not satisfy 
there is a spoiler A, T , that also has I as a model and, con-
versely, every forest model of the knowledge base A, T , R that
also satisfies a spoiler A, T , does not satisfy  (see the proof
of Lemma 3 in [41]). This implies the following more general result
that also takes into account the set D.
|=  w.r.t. D iff there is
Proposition 6.7. We have A, T , R
a spoiler A, T , for A, T , R such that there is a model of
A  A, T  T , R that respects D.
It remains to show that the existence of such a model can be
checked in exponential time in the size of A  A, T  T , R,
and therefore in exponential time in the size of , T , and R. We
will show a more general result for Boolean knowledge bases in
the next section (Theorem 6.15). Together with the reductions
described in this section, we obtain the desired complexity result.

Lemma 6.8. The existence of a model of a conjunction of CQliterals  w.r.t. a knowledge base T , R that respects D can be
decided in exponential time in the size of , T , and R.
6.3. Consistency of Boolean SHQ-knowledge bases

For the final result of this paper, we consider a Boolean SHQknowledge base B =  , R, a collection of concept names
A1, . . . , Ak occurring in B, and a subset D of 2{A1,...,Ak}. We assume
here that all GCIs in  are of the form   C; this is without loss
of generality since any GCI C  D is equivalent to   (C D).
We will show that deciding consistency of B w.r.t. D,
i.e., whether B has a model that respects D, can be done in exponential time in the size of B. This complexity result is tight since already for classical SHQ-knowledge bases, the consistency problem (without D) is ExpTime-complete [37,8]. The complexity of this
problem even remains in ExpTime when simple role conjunctions
are allowed to occur in number restrictions and non-simple roles
are allowed in role conjunctions in existential restrictions [42].

The proof is an adaptation of the proof of Lemma 6.4 in [12],
which is again an adaptation of the proof of Theorem 2.27 in [17],
which shows that consistency of Boolean ALC-knowledge bases
can be decided in exponential time. An earlier version of this proof
for ALC can be found in [34,29]. There, for role conjunctions,
additional concept names are introduced that function as so-called
pebbles that mark elements that have specific role predecessors,
an idea borrowed from [4345]. In this paper, we employ instead
systems of equations over non-negative integers to deal with
role conjunctions, transitivity axioms, role inclusions, and number
restrictions simultaneously.

We define Con( ) as the set of all concepts occurring in  , and

For the subsequent construction, we extend the notion of a
quasimodel from [12], which is an abstract description of a model
that characterizes domain elements by the concepts they satisfy.
We first introduce several auxiliary notions.
Con(B) as the closure under negation of the set
Con( )  {r.C | s.C  Con( ),
R |= r  s, and R |= trans(r)}.
The reason that we consider these additional existential restrictions is that they are needed to properly deal with transitive roles
(see Definition 6.9).
Similarly, we denote by Sub( ) the set of all subformulae of  ,
by Rol(B) the set of all role names occurring in B, and by Sub(B)
the closure under negation of the set
Sub( )  {r(a, b) | r  Rol(B), a, b  Ind(B)}.
We include all possible role assertions about individuals and role
names from B since we later want to close sets of role assertions
under R to be able to read off all relevant consequences about
individuals from such a set (see Definition 6.11).
In the following, we identify  with  for all concepts and
Boolean knowledge bases . Thus, all sets introduced above are
polynomial in the size of B.
Definition 6.9 (Concept Type). A concept type for B is a set c 
Con(B)  Ind( ) such that:
 C  D  c iff C, D  c for all C  D  Con(B);
 C  c iff C  c for all C  Con(B); and
 a  c for a  Ind( ) implies b  c for all b  Ind( ) with
b = a.

Given two concept types c, d and a role name r, we say that c and
d are r-compatible (w.r.t. R) (written (c, d)  rR) if the following
conditions are satisfied:
 for all (r.D)  c, we have D  d; and
 for all s  NR with R |= r  s, R |= trans(r), and (s.D)  c,
we have (r.D)  d.

Obviously, the number of concept types is exponential in the size of
 . The r-compatibility of two concept types c, d indicates that it is
possible to connect them via an r-edge without violating the value
restrictions in c. These conditions are very similar to the tableau
rules () and (+) that deal with value restrictions in the presence
of role inclusions and transitivity axioms (see, e.g. [36]).
Definition 6.10 (Role Type). A role type for B is a set r  Rol(B)
such that
 if s  r  R, then s  r implies r  r.
We denote the set of all role types for B by R(B).
For r  R(B), we say that two concept types c, d for B are r-
compatible (w.r.t. R) (written (c, d)  rR) iff they are r-compatible
w.r.t. R for every r  r.
Again, the number of role types for B is exponential in the size
of B.

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

Finally, for each ((r1    rl).C)  c, we use the equation

(M,c,r,C + M,c,r,C ) = 0.

(E4)

Finally, a quasimodel also has to determine which of the axioms
in  it satisfies.
Definition 6.11 (Formula Type). A formula type for B is a set f 
Sub(B) such that:
   f;
   f iff   f for all   Sub(B);
 1  2  f iff {1, 2}  f for all 1  2  Sub(B);
 if r(a, b)  f and R |= r  s, then s(a, b)  f; and
 if r(a, b)  f, r(b, c)  f, and R |= trans(r), then r(a, c)  f.
The number of formula types for B is exponential in the size of B.
Using these definitions, we can now define model candidates, and
later refine this notion to quasimodels.
Definition 6.12 (Model Candidate). A model candidate for B is a
triple M = (S, , f) such that
 S is a set of concept types for B such that for any c, d  S with
c = d, we have c  d  Ind( ) = ;
 : Ind( )  S is a function such that a  (a) for all
a  Ind( ); and
 f is a formula type for B.
Intuitively, the set S determines the behavior of the domain ele-
ments, while  fixes the interpretation of the named domain ele-
ments, and f ensures that B is satisfied. We denote by Su the set
S \ (Ind( )), i.e., the set of all those concept types that do not
contain an individual name. These types represent the unnamed
domain elements of the model candidate. To define quasimodels,
we add to the definition of a model candidate several conditions
that ensure that the concept types can indeed be assembled into a
model of B.
To satisfy the number restrictions in the concept types of a
model candidate M = (S, , f), we introduce, for each c  S,
a system of equations EM,c with variables ranging over the nonnegative integers. Below, we consider mostly inequations, which
can, however, easily be turned into equations by introducing new
slack variables. In EM,c, we use variables of the form xc,r,d that de-
termine, for an individual of type c, the number of unnamed r-
successors of concept type d, where we require that (c, d)  rR
and d  Su, i.e., c and d are r-compatible and d does not represent
a named individual.
Given c  S, C  Con(B), and r  R(B), we can now count
the number of unnamed r-successors of c that satisfy C using the
following expression:
M,c,r,C :=
|{b  Ind( ) | C  (b), and
r(a, b)  f iff r  r}|

To ensure that an at-least restriction n r.C  c is satisfied, we

construct the following inequation:
(M,c,r,C + M,c,r,C )  n.
rrR(B)

Similarly, for each (n r.C)  c, we add
(M,c,r,C + M,c,r,C )  n  1.
(E2)
For an existential restriction E = (r1    rl).C  c, we


To count the named r-successors of c that satisfy C, we define the
constant M,c,r,C as

if c = (a)
otherwise.

introduce the inequation

C  d  Su, (c, d)  rR


(M,c,r,C + M,c,r,C )  1.

rrR(B)

xc,r,d.

(E1)

(E3)

r1,...,rlrR(B)


r1,...,rlrR(B)

This finishes the description of EM,c. Note that this system contains exponentially many variables in the size of B, but only polynomially many equations, and thus it can be solved in exponential
time, even if the numbers are given in binary encoding [46] (for
details, see the proof of Theorem 6.15).

We finally come to the central definition of this section.

Definition 6.13 (Quasimodel). The model candidate M = (S, , f)
for B is a quasimodel for B if it satisfies the following properties:
(a) S is not empty;
(b) for every A(a)  Sub(B), we have A(a)  f iff A  (a);
(c) for every r(a, b)  f, we have ((a), (b))  rR;
(d) for every   C  f and every c  S, we have C  c;
(e) for every (  C)  f, there is a c  S such that C  c; and
(f) for every c  S, the system of equations EM,c has a solution
The quasimodel M = (S, , f) for B respects D if it satisfies:
(g) for every c  S, there is a set Y  D such that
(h) for every Y  D, there is a concept type c  S such that

over the non-negative integers.

Y = c  {A1, . . . , Ak}; and
Y = c  {A1, . . . , Ak}.

We show in the Appendix that to check consistency of B w.r.t. D it
suffices to search for quasimodels for B that respect D.
Lemma 6.14. Let B be a Boolean SHQ-knowledge base,
let
A1, . . . , Ak be concept names occurring in B, and let D  2{A1,...,Ak}.
Then B is consistent w.r.t. D iff it has a quasimodel that respects D.
It remains to show that one can check the existence of a quasimodel
for B that respects D in time exponential in the size of B. For this,
consider the following algorithm. Given B =  , R and D, it
enumerates all model candidates (Su  S, , f) for B, where
 Su is the set of all concept types for B that are subsets of Con(B),
and
 S := {(a) | a  Ind( ), (a) \ {a}  Su}.
We denote these candidates by M1, . . . , MN. Note that each of
them is of size exponential in the size of B. It should be clear that
N  2|Con(B)||Ind( )|  2|Sub(B)|,
and thus the enumeration of M1, . . . , MN can be done in exponential time since Con(B) and Sub(B) are of size polynomial in the
size of B.

Now, set i = 1 and consider Mi = (S, , f).
Step 1. Check whether Mi satisfies (b) and (c).

If it does, continue with Step 2. Otherwise, stop considering Mi and go to Step 5.
Step 2. Check each concept type in S. A concept type c  S is called
defective if it violates (d) for some   C  f or it violates (g).
If a defective c  S \ S is found, then set S := S \ {c}
and continue with Step 2. If a defective c  S is found,
then stop considering Mi and go to Step 5. If no defective
concept types in S are found, continue with Step 3.
Step 3. Consider the model candidate M = (S, , f) obtained
from the previous step. For every c  S, check whether
EM,c has a solution.
u is found such that EM,c has no solution, then
remove c from S and redo Step 3. If a c  S
 is found such
that EM,c has no solution, then go to Step 5. If no such concept type in S is found, continue with Step 4.

If a c  S

from Step 3 satisfies (a), (e), and (h).

Step 4. Check whether the model candidate (S, , f) obtained
If it does, stop with output quasimodel that respects D
found. Otherwise, continue with Step 5.
Step 5. Set i := i + 1. If i  N, continue with Step 1. Otherwise,
stop with output no quasimodel that respects D exists.
We show in the Appendix that the algorithm is sound and complete
and terminates in exponential time. By Lemma 6.14, we get the
following result.
Theorem 6.15. Let B be a Boolean SHQ-knowledge base,
let
A1, . . . , Ak be concept names occurring in B, and let D  2{A1,...,Ak}.
Then consistency of B w.r.t. D can be decided in time exponential in
the size of B.

7. Conclusions

We have introduced a new temporal query language that extends the temporal DL ALC-LTL to SHQ and uses simple conjunctive queries as atoms. Our complexity results on the entailment
problem for such queries w.r.t. temporal knowledge bases are summarized in Table 1. Without any rigid names, we observed that entailment of TCQs is as hard as entailment of CQs w.r.t. atemporal
ALC- and SHQ-knowledge bases, i.e., in this case adding temporal operators to the query language does not increase the com-
plexity. However, if we allow rigid concept names (but no rigid
role names), the picture changes. While the data complexity remains the same as in the atemporal case, the combined complexity
of query entailment increases to co-NExpTime,
i.e., the nonentailment problem is as hard as satisfiability in ALC-LTL. If we
further add rigid role names, the combined complexity (of non-
entailment) again increases in accordance with the complexity of
satisfiability in ALC-LTL. For data complexity, it is still unclear
whether adding rigid role names results in an increase. We have
shown an upper bound of ExpTime (which is one exponential better than the combined complexity), but the only lower bound we
have is the trivial one of co-NP.

Further work will include trying to close this gap. Moreover, it
would be interesting to find out what effect the addition of inverse
roles has on the complexity of query entailment in the temporal
case. Given the results for ALCI and SHIQ in the atemporal case,
where query entailment is 2-ExpTime-complete w.r.t. combined
complexity [8] and co-NP-complete w.r.t. data complexity [13],
there is the possibility that the problem remains co-NP-complete
w.r.t. data complexity also in the temporal case, and 2-ExpTime-
complete w.r.t. combined complexity for all three settings considered in this paper (i.e., without rigid names, without rigid role
names, with rigid names). But showing this will require considerable extensions of the proof techniques employed until now since
the presence of inverse roles creates additional problems. We have
also left open the complexity of the entailment problem for nonsimple TCQs, which is already 2-ExpTime-hard in SH [33].

Acknowledgments

This work was partially supported by the DFG in the Collaborative Research Center 912 (HAEC) and in the Research Training
Group 1763 (QuantLA). We also thank the anonymous reviewers
for their suggestions for improving this paper.

Appendix. Full proofs
w  L(G) iff the LTL-structure J := (wi)i0 satisfies J, n |=S and
Lemma 4.11. For every infinite word w = w0w1 . . .   , we have
wi = X(i) for all i, 0  i  n.

define

S at time point n and we have wi = X(i) for all i, 0  i  n. If we
Proof. Assume that the LTL-structure J := (wi)i0 is a model of
Si := { | J, i |= , and  is a sub-literal of}
for i  0, then
(S0, 0)(S1, 1) (Sn, n)(Sn+1, n + 1)(Sn+2, n + 1)
is a run on G:
 For every sub-formula  of, we have either J, i |=  or
 We have (Si, k)  Q for all i  0 and k, 0  k  n + 1:
 For every sub-formula 1  2 of, we have J, i |= 1  2
J, i |= . Thus, we have   Si iff   Si.
iff J, i |= 1 and J, i |= 2. Thus, we have 1  2  Si iff
 For each world wi, i  0, we have wi  S since J satisfiesS.
{1, 2}  Si.
 of that J, 0 |= ,
Thus, we have Si  {p1, . . . , pm} = wi  S for all i  0.
 We have for every sub-formula
  S0. Additionally, we have for every 1 S 2 
and thus
S0, since J, 0 |= 1 S 2 also J, 0 |= 2. This implies that
(S0, 0)  Q0.
 We have for all i, 0  i  n,
((Si, i), wi, (Si+1, i + 1))  ,
and for all i  n + 1,
((Si, n + 1), wi, (Si+1, n + 1))  ,
 for every sub-formula  of, we have   Si iff
since:
 we have wi = Si  {p1, . . . , pm} by the definition of Si;
 of, we have
J, i |=  iff J, i + 1 |=  iff   Si+1;
  Si+1 iff
 for every sub-formula 1 U 2 of, we have 1 U 2  Si
 for every sub-formula
J, i + 1 |=  iff J, i |=  iff   Si;
|= 1 and
|= 2 or (ii) J, i
iff J, i
J, i + 1 |= 1 U 2 iff (i) 2  Si or (ii) 1  Si and
 for every sub-formula 1 S 2 of, we have 1 S 2  Si+1
1 U 2  Si+1;
iff J, i+ 1 |= 1 S 2 iff (i) J, i+ 1 |= 2 or (ii) J, i+ 1 |= 1
and J, i |= 1 S 2 iff (i) 2  Si+1 or (ii) 1  Si+1 and
1 S 2  Si;
 for i = n we have J, n |=S, which implies J, n |=, and
 i < n + 1 implies wi = X(i) by assumption;
thusS  Sn;
 the condition for incrementing the second component of a
state (until n + 1 is reached) is obviously also satisfied.

diction. Suppose that for some sub-formula 1 U 2 of, the set
Moreover, the above run is accepting. We prove this by contra-
{i  0 | Si  F1 U 2} is finite. Then there exists a k  0 such that
Sl  F1 U 2 for all l  k. This means 1 U 2  Sl and 2  Sl
for all l  k. Hence, I, k |= 1 U 2 and I, l |= 2 for all l  k.
This contradicts the semantics of U .
For the converse direction, assume that w  L(G), i.e., there is

|= 1 U 2 iff (i) J, i

an accepting run
(S0, 0)(S1, 1) (Sn, n)(Sn+1, n + 1)(Sn+2, n + 1)
of G on w.
To show that J := (wi)i0 is a model ofS at time point n, observe
By the definition of , we have wi = X(i) for all i, 0  i  n.
that for each i  0 we have wi = Si{p1, . . . , pm}  S by definition

of the state set Q . Thus, the conjunct

ofS is clearly satisfied by J (at any time point).

pX

pX

and thus it is now enough to show that   Si iff J, i |=  for each
i  0. This can be shown by induction on the structure of .
 If  is a propositional variable, we have   Si iff   wi iff
wi |=  iff J, i |= .
 If  = , we have  Si iff   Si iff J, i |=  iff J, i |= .
 If  = 1  2, we have 1  2  Si iff {1, 2}  Si iff
J, i |= 1 and J, i |= 2 iff J, i |= 1  2.
 If  = , we have
  Si iff   Si+1 iff J, i + 1 |=  iff
J, i |= .
 If  = , we have
  Si iff i > 0 and   Si1 iff i > 0
and J, i  1 |=  iff J, i |= . The first iff holds because of
the definition of Q0.
 If  = 1 U 2, we prove 1 U 2  Si iff J, i |= 1 U 2 as
follows.
(=) Assume J, i |= 1 U 2. Then there exists a k  i such
that J, k |= 2 and J, l |= 1 for all l, i  l < k. We show by
induction on j that 1 U 2  Skj for j  k  i.
For j = 0, we have: J, k |= 2 implies 2  Sk by the outer induction hypothesis, and the definition of  yields 1 U 2  Sk.
For j > 0, we have: J, k  j |= 1 implies 1  Skj by the
outer induction hypothesis. By the inner induction hypothesis,
we have 1 U 2  Skj+1. Thus, by the definition of , it follows
that 1 U 2  Skj.
(=) Assume 1 U 2  Si. Since states of F1 U 2 occur infinitely often among S0, S1, S2 . . . , there is a k  i such that
Sk  F1 U 2. Let k be the smallest index with that property. Then
it follows that 1 U 2  Sl and 2  Sl for all l, i  l < k.
1 U 2  Sl and 2  Sl for all l, i  l < k, yield 1  Sl
because of the definition of . Thus, J, l |= 1 for all l,
i  l < k ().
1 U 2  Sk1 and 2  Sk1 imply 1 U 2  Sk because of the
definition of . This yields 2  Sk since Sk  F1 U 2, and thus
J, k |= 2 ().
() and () yield that J, i |= 1 U 2 by the semantics of U .
 If  = 1 S 2, we prove 1 S 2  Si iff J, i |= 1 S 2 as fol-
lows.
(=) Assume J, i |= 1 S 2. Then there exists a k, 0  k  i
such that J, k |= 2 and J, l |= 1 for all l, k < l  i. We show
by induction on j that 1 S 2  Sk+j for j  i  k.
For j = 0, we have: J, k |= 2 implies 2  Sk by the outer induction hypothesis, and the definition of  yields 1 S 2  Sk.
For j > 0, we have: J, k + j |= 1 1  Sk+j by the outer induction hypothesis. By the inner induction hypothesis, we have
1 S 2  Sk+j1. Thus, by the definition of , it follows that
1 S 2  Sk+j.
(=) Assume 1 S 2  Si. There are two cases: either i = 0 or
i > 0.
For i = 0, we have: 1 S 2  S0 implies 2  S0 by the definition of Q0. This yields J, 0 |= 2, and thus J, 0 |= 1 S 2.
For i > 0, we have again two cases: either 2  Si or 1  Si
and 1 S 2  Si1. For the case where 1  Si, it directly fol-
|= 1 S 2. For the other case where 1  Si
lows that J, i
and 1 S 2  Si1, we have by the inner induction hypothe-
sis: J, i  1 |= 1 S 2. Thus, there is a k, 0  k  i  1, such
that J, k |= 2 and J, j |= 1 for all j, k < j  i  1. Since we
have by the outer induction hypothesis also that J, i |= 1, it
follows that there is a k, 0  k  i, such that J, k |= 2 and
J, j |= 1 for all j, k < j  i. Hence, J, i |= 1 S 2.

Lemma 4.14. The set S is r-satisfiable w.r.t.  and K iff S, is satisfiable w.r.t. TS,, RS,.
Proof. Let J1, . . . , Jk, I0, . . . , In be the interpretations required
by Definition 4.5 for the r-satisfiability of S w.r.t.  and K. We
construct the interpretation J as follows:

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

 the domain of J is the shared domain of the above interpreta-
tions;
 the rigid names are interpreted as in the above interpretations;
 the ith copy, 1  i  k, of each flexible name is interpreted like
the original name in Ji; and
 the ith copy, k + 1  i  k + n + 1, of each flexible name is
interpreted like the original name in Iik1.
It is easy to verify that J is a model of S,, TS,, and RS,.
For the other direction, letJ be a model of S, w.r.t.TS,, RS,.
We obtain the interpretations J1, . . . , Jk, I0, . . . , In by the inverse
construction to the one above:
 the domain of all these interpretations is the domain of J ;
 the rigid names are interpreted by these interpretations as in
J ;
 every flexible name is interpreted in Ji, 1  i  k, as its ith
copy is interpreted in J ; and
 every flexible name is interpreted in Ii, 0  i  n, as its
(k + i + 1)st copy is interpreted in J .

Again, it is easy to verify that these interpretations satisfy the conditions of Definition 4.5.
Lemma 5.1. If NRC =  and NRR = , then S is r-satisfiable w.r.t. 
and K iff there exist D  2RCon(T ) and  : Ind()Ind(K)  D such
that each i  S   , 0  i  n, has a model w.r.t. TS  T , RS
that respects D.
Proof. For the if direction, assume that Ii, 0  i  n, are the
required models for i  S   w.r.t. TS  T , RS. Similar to
the proof of Lemma 6.3 in [12], we can assume w.l.o.g. that their
domains i are countably infinite and for each Y  D there are
countably infinitely many elements d  (CY )Ii. This is a consequence of the LowenheimSkolem theorem and the fact that the
countably infinite disjoint union of Ii with itself is again a model
of i  S   and TS  T , RS. The latter follows from the observation that for any CQ there is a homomorphism into Ii iff there
is a homomorphism into the disjoint union of Ii with itself. One
direction is trivial, while whenever there is a homomorphism into
the disjoint union, we can construct a homomorphism into Ii by
replacing the elements in the image of this homomorphism by the
corresponding elements of i. It is easy to see that the resulting
homomorphism still satisfies all atoms of the CQ.
Consequently, we can partition the domains i into the countably infinite sets i(Y ) := {d  i | d  (CY )Ii} for Y  D. By the
assumptions above and the fact that all Ii satisfy  and T , there
are bijections i: 0  i, 1  i  n, such that
 i(0(Y )) = i(Y ) for all Y  D and
 i(aI0 ) = aIi for all a  Ind()  Ind(K).
Thus, we can assume in the following that the models Ii actually
share the same domain and interpret the rigid names in RCon(T )
and Ind()  Ind(K) in the same way. We can now construct the
models required by Definition 4.5 by appropriately relating the
flexible names and their copies. For example, interpreting the rigid
concept names as in Ii and the flexible names as their (i)th copies
in Ii yields a model of (i) w.r.t. Ai, T , R, and similarly for the
models of j w.r.t. T , R for 1  j  k. These models share
the same domain and respect the rigid names in RCon(T ) and
Ind()  Ind(K). Note that the interpretation of the names in NRC
and NI that occur neither in K nor in  is irrelevant and can be fixed
arbitrarily, as long as the UNA is satisfied.
Thus, it remains to consider those rigid concept names A occurring in (Ai)0in, but not in T . Since they are not constrained by
the TBox, it suffices to interpret them in such a way that they satisfy all ABox assertions. But since these assertions can only occur
positively in the ABoxes, the set {aI0 | A(a)  Ai, 0  i  n}
fulfills this restriction.

J := J , for each A  NC, AJ := AJ , for each a  NI, aJ := aJ ,

and for each r  NR:
r J := rJ 

(sJ )+.

i = (CY )I

For the only if direction, it is easy to see that one can combine
the interpretations Ii, J1, ..., Jk from Definition 4.5 to a model I
i of
i  S w.r.t. TS , RS by interpreting the (i)th copy of a flexible
name as the original name in Ii, and the jth copy of a flexible name
as the original name in Jj, for each j, 1  j  k, with j = (i). Obvi-
ously, the interpretations I
i share the same domain, interpret individual names in the same way, and respect rigid concept names.
For a  Ind()Ind(K), we define  (a) := Y  RCon(T ) iff a 
(CY )I0, which ensures that the interpretations I
i can be extended
to models of  and T by appropriately interpreting the new concept names T (a). Furthermore, we let D contain all those sets Y 
i for some 0  i  n.
RCon(T ) such that there is a d  (CY )I
j for all 0  i, j  n and all
Since we have (CY )I
Y  D, the interpretations I
i respect D. Hence, we obtain models of i  S   w.r.t. TS  T , RS that respect D.
Lemma 6.2. If NRC =  and NRR = , then S is r-satisfiable w.r.t.
that eachi := i   , 1  i  k, has a model w.r.t. T  T , R
K = , T , R iff there exist D  2RCon(T ) and  : Ind()  D such
that respects D.
Proof. By Lemma 5.1, S is r-satisfiable w.r.t. K iff there exist D 
2RCon(T ) and  : Ind()  D such that S   has a model w.r.t.
TS  T , RS that respects D.
For the if direction, let D  2RCon(T ),  : Ind()  D, and
Ii be models of i   and T  T , R that respect D. As in the
proof of Lemma 5.1, we can ensure that they share the same domain and interpret the rigid names in RCon(T ) and Ind() in the
same way. Similar to before, we can construct a model J of S
and TS  T , RS over the shared domain of I1, . . . Ik as follows:
interpret the ith copy of a flexible name as the original name in
Ii, and every rigid name as in I1. Since the interpretations of the
names in RCon(T ) are not changed, J also respects D.
For the only if direction, let J be a model of S   and
TS  T , RS that respects D. As before, a model Ii of i   and
T  T , R can be constructed by interpreting the rigid names as
in J and the flexible names as their ith copies in J . Again, these
models still respect D.
Lemma 6.5. Let B be a Boolean SHQ-knowledge base, let
A1, . . . , Ak be concept names occurring in B, and let D  2{A1,...,Ak}.
Then B has a model that respects D iff it has a forest model that
respects D.
Proof. The if direction is trivial. For the only if direction,
assume that I = (I ,I ) is a model of B = , R that respects
D. Moreover, we assume that I is countable, which is w.l.o.g.
due to the downward LowenheimSkolem theorem. We can thus
assume that I  N. We define now a forest base J = (J ,J )
for B with domain

J :=(a, d1 . . . dm) |a  Ind( ), m  0,

d1, . . . , dm  I, there is no

b  Ind( ) such that d1 = bI

as follows:
 aJ := (a, ) for all a  Ind( );
 bJ for b  NI \ Ind( ) can be fixed arbitrarily, as long as the
UNA is satisfied;
 AJ := {(a, ) | aI  AI}  {(a, d1 . . . dm) | dm  AI}; and

rJ := {((a, ), (b, )) | (aI , bI )  rI} 
{((a, ), (a, d)) | (aI , d)  rI} 
{((a, d1 . . . dm), (a, d1 . . . dmdm+1)) |
m > 0, (dm, dm+1)  rI}.

Obviously, J satisfies the conditions for a forest base for B. We con-

struct now a forest model J = (J ,J ) for B. For that, we define

R|=sr, R|=trans(s)

To prove that this indeed defines a forest model, we first show the
following claim by structural induction.

Claim 1. For every (a, d1 . . . dm)  J and concept C, we have
(a, d1 . . . dm)  C J iff either m = 0 and aI  CI, or dm  CI.

l , or

l = rJ

For the base case, C being a concept name, the claim is directly implied by the definition.

For the case where C is of the form D, we have
(a, d1 . . . dm)  (D)J
iff (a, d1 . . . dm)  DJ
iff either m = 0 and aI  DI, or dm  DI
iff either m = 0 and aI  (D)I, or dm  (D)I.
For the case where C is of the form D  E, we have
(a, d1 . . . dm)  (D  E)J
iff (a, d1 . . . dm)  DJ and (a, d1 . . . dm)  EJ
iff either m = 0 and aI  DI and aI  EI, or dm  DI and
dm  EI
iff either m = 0 and aI  (D  E)I, or dm  (D  E)I.
For the case where C is of the form(r1rl).D with l > 1,
we have r J
1  r J
1  rJ
l since r1, . . . , rl are simple
(a, d1 . . . dm)  ((r1    rl).D)J
role names, and thus
iff either m = 0 and
 there is a (b, )  DJ such that ((a, ), (b, )) is in
1    rJ
rJ
 there is a (a, d)  DJ such that ((a, ), (a, d)) is in
1    rJ
rJ
or there is a (a, d1 . . . dmdm+1)  DJ such that ((a, d1 . . . dm),
l ;
1    rJ
(a, d1 . . . dmdm+1)) is in rJ
iff either m = 0 and there is a d  DI such that
(aI , d)  rI
1    rI
l , or there is a d  DI such that
(dm, d)  rI
1    rI
iff either m = 0 and aI  ((r1    rl).D)I, or
dm  ((r1    rl).D)I.
For the case where C is of the form r.D, we have
(a, d1 . . . dm)  (r.D)J
iff there is x  DJ with either ((a, d1 . . . dm), x)  rJ or there is a
role name s with R |= s  r, R |= trans(s), and
((a, d1 . . . dm), x)  (sJ )+
iff either m = 0 and
 there is a (b, )  DJ with ((a, ), (b, ))  rJ ,
 there is a (a, d)  DJ with ((a, ), (a, d))  rJ , or
 there is a role name s with I |= s  r and I |= trans(s), and a
of elements of J such that a0 = a, (an, e1 . . . ek)  DJ ,
sequence (a0, ), (a1, ), ..., (an, ), (an, e1), ..., (an, e1 . . . ek)
and each two consecutive elements of this sequence are connected via sJ ;
(a, d1 . . . dm+n) of elements of J such that n  1,
(a, d1 . . . dm+n)  DJ , and each two consecutive elements of
this sequence are connected via sJ , where s is a role name such
that either n = 1 and s = r, or I |= s  r and I |= trans(s),
iff either m = 0 and
 there is a d  DI such that (aI , d)  rI, or
 there is s  NR with I |= s  r and I |= trans(s), and an
ek  I such that (aI , ek)  sI  rI and ek  DI;

or there is a sequence (a, d1 . . . dm), (a, d1 . . . dm+1), . . . ,

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

we prove first the following claim by structural induction.

For the first base case, assume that  is of the form A(a) for some

or there is a d  DI such that (dm, d)  sI  rI, where
s is a role name such that either s = r, or I |= s  r and
I |= trans(s),
iff either m = 0 and aI  (r.D)I, or dm  (r.D)I.
For the case where C is of the form n r.D for a simple role name
r, we again have r J = rJ , and thus
(a, d1 . . . dm)  (n r.D)J
iff there is a subset X  DJ with|X| = n such that ((a, ), x)  rJ
for each x  X, and either
 m = 0 and each x  X is either of the form (b, ) or (a, d), or
 each x  X is of the form (a, d1 . . . dmdm+1)
iff there is a subset Y  DI with |Y| = n such that m = 0 and
(aI , y)  rI for each y  Y , or (dm, y)  rI for each y  Y
iff either m = 0 and aI  (n r.D)I, or dm  (n r.D)I.
individual aI is represented by exactly one r J -successor of (a, )
The second equivalence holds since each rI-successor of a named
since domain elements of the form (a, bI ) for b  Ind( ) are not
It remains only to show that J is indeed a model of B. For this,
allowed. This finishes the proof of Claim 1.
Claim 2. For all   Sub( ), we haveJ |=  iff I |= .
A  NC and a  NI. We have aI  AI iff aJ = aJ = (a, )  AJ =
AJ by definition.
For the second base case, assume that  is of the form r(a, b) for
a, b  NI and r  NR. If I |= r(a, b), then (aI , bI )  rI, and thus
(aJ , bJ ) = (aJ , bJ ) = ((a, ), (b, ))  rJ  r J .
Conversely, if ((a, ), (b, ))  r J , then there is a role name s and
a sequence (a0, ), . . . , (an, ), n  1, of elements of J such that
a0 = a, an = b, each two consecutive elements of this sequence
are connected via sJ , and either n = 1 and s = r, or R |= s  r
and R |= trans(s). By definition of sJ , the properties of s, and since
I |= R, we can infer that (aI , bI )  rI, and thus I |= r(a, b).
For the third base case, assume that  is of the form C  D. For
the if direction, assume that I |= C  D and thus CI  DI. Suppose that there is a (a, d1 . . . dm)  C J with (a, d1 . . . dm)  DJ .
By Claim 1, either m = 0 and we have aI  CI and aI  DI, or
dm  CI and dm  DI, which contradicts our assumption that
CI  DI.
For the only if direction, assume that C J  DJ . Suppose that
there is a d  CI with d  DI. By the definition of J , we have
(a, dd)  J for any a  Ind( ) and d  I such that there is
no b  Ind( ) with d = bI. By Claim 1, we get (a, dd)  C J and
(a, dd)  DJ , which again yields a contradiction.
We have that J |=  iff J |=  iff I |=  iff I |= . AsFor the induction step, assume first that  is of the form .
sume now that  is of the form 12. We have thatJ |= 12
iffJ |= 1 andJ |= 2 iff I |= 1 and I |= 2 iff I |= 1  2.
shows that J is indeed a model of  . We show that J is also a
This finishes the proof of the claim. Since   Sub( ), this
Claim 3. For all   R, we haveJ |= .
Assume first that  is of the form r  s. Since I |= R, we have
I |= r  s and thus rI  sI. We first show that rJ  sJ . For this,
take (x, y)  rJ . There are three cases to consider:
 If x = (a, ) and y = (b, ) with a, b  Ind( ), we have
(aI , bI )  rI and thus (aI , bI )  sI. Hence, the definition
of sJ yields that (x, y)  sJ .
 If x = (a, ) and y = (a, d) with a  Ind( ), d  I, we have
(aI , d)  rI and thus (aI , d)  sI. Again, the definition of sJ
yields that (x, y)  sJ .

model of R in the following claim.

respects D.

 If x = (a, d1 . . . dm) and y = (a, d1 . . . dmdm+1) with
a  Ind( ), m > 0, d1, . . . , dm+1  I, we have (dm, dm+1)
 rI and thus (dm, dm+1)  sI. Again, the definition of sJ yields
that (x, y)  sJ .
To show that r J  sJ , take (x, y)  r J . If (x, y)  rJ , we have
(x, y)  sJ and thus (x, y)  sJ . Otherwise, we have that (x, y) 
(tJ )+ with R |= t  r and R |= trans(t). Since r  s  R,
we have obviously R |= r  s. It is easy to see that this implies
R |= t  s. Then the definition of sJ yields that (tJ )+  sJ .
Hence (x, y)  sJ .
Assume now that  is of the form trans(r). Since I |= R, we
have I |= trans(r) and thus rI  rI  rI. By the same arguments
as above, we have that for each t with tI  rI, we have tJ  rJ ,
and thus (tJ )+  (rJ )+ since the transitive closure is monotonic.
Since rI  rI, we have also I |= r  r. The definition of r J yields
now that r J = (rJ )+, and henceJ is a model of trans(r).
Claims 2 and 3 yield thatI is indeed a model of B. It only remains to be shown thatJ respects D. Since I respects D, we have
D = {Y  {A1, . . . , Ak} | d  I with d  (CY )I}.
We now define
D := {Y  {A1, . . . , Ak} | x  J with x  (CY )J}
and show that D = D. Since J respects D, this implies that J
For the direction (), assume that Y  D, and thus there is a
d  (CY )I. By Claim 1 and the definition of J , there is a
(a, dd)  (CY )J , and hence Y  D. For the direction (), assume
that Y  D, i.e., there is a (a, d1 . . . dm)  (CY )J . By Claim 1 and
the definition of J , there is a d  (CY )I, where for m = 0, we can
set d := aI, and for m > 0, we can take d := dm. Hence, Y  D. 
Lemma 6.6. We have A, T , R |=  w.r.t. D iff there is a forest
model J of A, T , R that respects D with J |= .
Proof. The if direction is trivial. For the only if direction, assume that there is a model I = (I ,I ) of A, T , R that respects
transformed into a forest modelJ = (J ,J ) that respects D. As-
D such that I |= . As shown in the proof of Lemma 6.5, I can be
sume that J ,J are obtained from I as in the proof of Lemma 6.5.
It is left to show that thenJ |= .
Assume to the contrary that J |= . Then there is a Boolean
into J . We define a homomorphism  from i into I as follows:
CQ i in the UCQ  such that there is a homomorphism  from i
(a) := aI for all individual names a occurring in the input; and
for all v  Var(i), we define (v) := aI if  (v) = (a, ) for
a  Ind(A), and (v) = dm if  (v) = (a, d1 . . . dm) with m > 0.
We now show that  is indeed a homomorphism from i into I.
Consider first a concept atom A(a)  At(i). Since
(a, ) = aJ  AJ , we get aI  AI by Claim 1.
For an atom A(v)  At(i) with v  Var(i), we get  (v)  AJ ,
and thus (v)  AI again by Claim 1.
For r(a, b)  At(i), we can show (aI , bI )  rI as in the proof
in At(i), i.e., ((a, ),  (v))  r J . If ((a, ),  (v))  rJ , then
Assume now that there is a role atom of the form r(a, v)
(a, (v))  rI by the definitions of J and . Otherwise, there
must be a role name s such that R |= s  r, R |= trans(s), and
((a, ),  (v))  (sJ )+. This implies the existence of a sequence
(a0, ), (a1, ), ..., (an, ), (an, e1), ..., (an, e1 . . . ek) in J such that
a0 = a,  (v) = (an, e1 . . . ek), and each two consecutive elements
of this sequence are connected via sJ . By the definition of sJ , we
get (aI , (v))  sI  rI.

of Claim 2.

For the case that C is of the form D  E, we have by similar arguments that following:
 for all (c, i, r)  Anon, we have (c, i, r)  (D E)I iff D  c and
E  c iff D  E  c; and
 for all a  Ind( ), we have a  (DE)I iff D  (a) and E  (a)
iff D  E  (a).
For the case that C is of the form (r1    rl).D, we have by
similar arguments the following:
((r1    rl).D)I
= {d  I | there is an e  I with
1    rI

l and e  DI}

(d, e)  rI

0 , aI

n )  rI.

For any role atom r(v, a)  At(i), we know that
( (v), (a, ))  r J . By the definition of r J , this implies that
there is a sequence (a0, ), ..., (an, ) in J such that an = a,
 (v) = (a0, ), and each two consecutive elements of this sequence are connected via sJ , where s is a role name such that either
n = 1 and s = r, or R |= s  r and R |= trans(s). By the definition of sJ , the properties of s, and since I |= R, this implies that
((v), aI ) = (aI
Finally, consider a role atom of the form r(v, v) in At(i). We
have ( (v),  (v))  r J . If  (v) = (a, ) for some a  Ind(A),
then we can show as in the case of r(a, v) that ((v), (v)) =
(aI , (v))  rI. Otherwise, we have  (v) = (a, d1 . . . dm) for
(a, d1 . . . dm+n) in J such that n  1,  (v) = (a, d1 . . . dm+n),
m > 0 and there is a sequence (a, d1 . . . dm), (a, d1 . . . dm+1), ...,
and each two consecutive elements of this sequence are connected
via sJ , where s is a role name such that either n = 1 and s = r, or
R |= s  r and R |= trans(s). This implies that ((v), (v)) =
(dm, dm+n)  sI  rI.
Hence, I |= i, and thus I |= , which contradicts our assumption that I |= .

Lemma 6.14. Let B be a Boolean SHQ-knowledge base, let
A1, . . . , Ak be concept names occurring in B, and let D  2{A1,...,Ak}.
Then B is consistent w.r.t. D iff it has a quasimodel that respects D.
Proof. For the if direction, suppose that M = (S, , f) is a quasimodel for B =  , R that respects D. Then by condition (f), for
each c  S, EM,c has a solution c that maps the variables of
EM,c into the non-negative integers. Let zM be the greatest nonnegative integer that occurs in any of these solutions. Let Z denote
the set {1, . . . , zM}.
We define an interpretation J = (J ,J ) as follows:
 J := Anon  Ind( ), where Anon := Su  Z  R(B);
 aJ := a for all a  Ind( )5;
 AJ := {(c, i, r)  Anon | A  c} 
 for all role names r  NR, (c, i, r), (d, j, s)  Anon, and
a, b  Ind( ), we define
 (a, b)  rJ iff r(a, b)  f;
 (a, (d, j, s))  rJ iff r  s, ((a), d)  sR, and
(a)(x(a),s,d)  j;
 ((c, i, r), (d, j, s))  rJ iff r  s, (c, d)  sR, and
c(xc,s,d)  j;
 ((c, i, r), b)  rJ .


Now we construct a model I = (I ,I ) of B by defining
I := J , for each A  NC, AI := AJ , for each a  Ind( ),
aI := aJ , and for each r  NR,
rI := rJ 

{a  Ind( ) | A  (a)} for all A  NC; and

(sJ )+.

R|=sr, R|=trans(s)

We prove the following claim by structural induction.
Claim 4. For all concepts C  Con(B), we have:
CI = {(c, i, r)  Anon | C  c}  {a  Ind( ) | C  (a)}.
For the base case, C being a concept name, the definition of I immediately implies the claim. For the case that C is of the form D,
we have by the semantics of SHQ, the induction hypothesis, the
definition of I, and the definition of concept types that
 for all (c, i, r)  Anon, we have (c, i, r)  (D)I iff D  c iff
D  c; and
 for all a  Ind( ), we have a  (D)I iff D  (a) iff D  (a).

5 We ignore for now the individual names in NI \ Ind( ) since they are irrelevant
when dealing with B. After constructing the model I below, one can ensure that
it respects the UNA by constructing the countably infinite disjoint union of I with
itself to allow for different interpretations of each of these individual names.

(d, (d, j, s))  rI

= {d  I | there is a (d, j, s)  DI with
1    rI
l } 
{a  Ind( ) | there is a b  Ind( ) with
l and b  DI}
1    rI
1    rI
{a  Ind( ) | there is a b  Ind( ) with
1    rI

= {d  I | there is a (d, j, s)  Anon with

l and D  d} 
l and D  (b)}

(d, (d, j, s))  rI

(a, b)  rI

(a, b)  rI

= {(c, i, r)  Anon | (r1    rl).D  c} 

{a  Ind( ) | (r1    rl).D  (a)}.

l  rI

1    rI

1    rI
l .

1    rJ

1 , . . . , rJ
1    rI

= holds due to the following arguments. AsThe starred equality
sume, for the direction (), that (c, i, r)  Anon and
(r1    rl).D  c. Since c solves
(E3), there are
d  Su and s  R(B) such that D  d, r1, . . . , rl  s, (c, d)  sR,
and c(xc,s,d)  1. By definition of rJ
l , we obtain
((c, i, r), (d, 1, s))  rJ
l  rI
l . For the remaining part of the direction (), assume that a  Ind( ) and
(r1    rl).D  (a). Since c is a solution of (E3), there is an
s  R(B) such that r1, . . . , rl  s and
 there is a d  Su with D  d, ((a), d)  sR, and
(a)(x(a),s,d)  1; or
 there is a b  Ind( ) such that D  (b) and
{r1(a, b), . . . , rl(a, b)}  f.
In the first case, we can infer that (a, (d, 1, s))  rI
l as
above. In the second case, by the definition of J , we get (a, b) 
1    rJ
rJ
For the other direction (), consider a d  I and
l and D  d.
1    rI
(d, j, s)  Anon such that (d, (d, j, s))  rI
We consider first the case that d = (c, i, r)  Anon and show that
C = (r1    rl).D  c. Assume to the contrary that C  c, and
thus C  c.
 For the case l > 1, we have that r1, . . . , rl are simple role
names, and thus ((c, i, r), (d, j, s))  rJ
l . By definition
of J , we have r1, . . . , rl  s, (c, d)  sR, and c(xc,s,d)  j  1.
Since c is a solution of (E4), we must have c(xc,s,d) = 0, which
is a contradiction.
 For the case l = 1, by the definition of rI
1 , we have ((c, i, r),
1 or ((c, i, r), (d, j, s))  (sJ )+ for some s  NR
(d, j, s))  rJ
with R |= s  r1 and R |= trans(s). The first case can be handled as in the case for l > 1, while in the second case there is a
sequence (c0, i0, r0), ..., (cn, in, rn) in Anon such that
 n  1;
 (c0, i0, r0) = (c, i, r);
 (cn, in, rn) = (d, j, s); and
 for all k, 0  k  n  1, we have s  rk+1, (ck, ck+1)  rR
k+1,
)  ik+1.
and ck

1 rJ

(xck,rk+1,ck+1

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

1 or

(xck,rk+1,ck+1

)  ik+1.

1  rJ

0 , and s  r0; and

)  i0, ((an), c0)  rR

If n = 1, then c1 = d, r1 = s, and (c, d)  sR. Since s is a role
type, s  s, and R |= s  r1, we also have r1  s. This implies
that (c, d)  sR  rR
1 . Since we assumed that (r1.D)  c,
we obtain D  d, which yields a contradiction.
If n > 1, then, since (r1.D)  c and (c, c1)  sR, we
have (s.D)  c1. By similar arguments, we can infer that
(s.D)  cn1. Since (cn1, d)  sR, we again conclude the
contradictory D  d.
For the second part of the direction (), consider the case that
d = a  Ind( ). We show C = (r1    rl).D  (a) by
similar arguments as above. Assume that C  (a).
 For the case l > 1, we have (a, (d, j, s))  rJ
l . It follows from the definition of J that r1, . . . , rl  s, ((a), d)  sR,
and (a)(x(a),s,d)  j  1. As before, this contradicts the fact
that (a) is a solution of (E4).
 For the case l = 1, we have (a, (d, j, s))  rJ
(a, (d, j, s))  (sJ )+ for some s  NR with R |= s  r1 and
R |= trans(s). The first case is again the same as for the case
l > 1, while in the second case, there is a sequence a0, ..., an,
(c0, i0, r0), ..., (cm, im, rm) in I such that
 n, m  0;
 a0 = a;
 (cm, im, rm) = (d, j, s);
 for all k, 0  k  n  1, we have s(ak, ak+1)  f;
 (an)(x(an),r0,c0
 for all k, 0  k  m  1, we have s  rk+1, (ck, ck+1)  rR
k+1,
and ck
We first consider the case that n = m = 0. Then a = an, c0 = d,
r0 = s, and ((a), d)  sR. Since s is a role type, s  s, and
R |= s  r1, we also have r1  s, and thus ((a), d)  rR
1 . Since
(r1.D)  (a), we obtain D  d, which is a contradiction.
If n = 0 and m > 0, then we have ((a), c0)  sR since s  r0.
Since (r1.D)  (a), we obtain (s.D)  c0, and similarly
(s.D)  cm1, and thus D  cm = d. This is a contradiction.
If n > 0, then s(a, a1)  f. By condition (c), this implies that
((a), (a1))  sR. Since (r1.D)  (a), we obtain (s.D) 
(a1). By similar arguments, we can infer that (s.D)  (an),
and finally D  d, which contradicts our assumption that
D  d.
For the last part of the direction (), let a, b  Ind( ) with (a, b)
 rI
1    rI
l and D  (b). For the last time, we assume that
C = (r1    rl).D  (a) and make a case distinction on l.
 If l > 1, then (a, b)  rJ
{r1(a, b), . . . , rl(a, b)}  f. Since f is a formula type, the set
{r  Rol(B) | r(a, b)  f} is a role type that contains r1, . . . , rl.
Since D  (b), we know that M,(a),r,D  1. This contradicts
our assumption that (E4) has a solution.
 If l = 1, then (a, b)  rJ
1 or (a, b)  (sJ )+ for some s  NR
with R |= s  r1 and R |= trans(s). The first case is impossible
by the same arguments as above, and in the second case, there
is a sequence a0, . . . , an in Ind( ) such that
 n  1;
 a0 = a;
 an = b; and
 for all k, 0  k  n  1, we have s(ak, ak+1)  f.
If n = 1, then s(a, b)  f, and thus ((a), (b))  sR by condition (c). Since (r1.D)  (a), we again obtain D  (b), and
thus a contradiction.
If n > 1, then r1(a, a1)  f since f is a formula type for B and
R |= s  r1. By condition (c), we obtain ((a), (a1))  rR
1 ,
and thus (s.D)  (a1) since (r1.D)  (a). Similarly, we
can infer that (s.D)  (an1), and finally D  (b). This
contradicts our assumption that D  (b).

1    rJ

l , and thus

Finally, consider the case that C is of the formn r.D. Recall that
r must be simple, and thus rI = rJ . We first count, for any element d  I, the number of unnamed rJ -successors that satisfy
D. Let c be a concept type such that either d = (c, i, r)  Anon, or
d = a  Ind( ) and c = (a). For a fixed role type s  R(B) and
concept type d  Su with r  s, D  d, and (c, d)  sR, we have by
definition of J that ((c, i, r), (d, j, s))  rJ iff c(xc,s,d)  j. Thus,
the number of rJ -successors of d that are of the form (d, j, s) is
exactly c(xc,s,d). By induction, we obtain
|{(d, j, s)  Anon | (d, (d, j, s))  rJ , (d, j, s)  DI}|
= |{(d, j, s)  Anon | (d, (d, j, s))  rJ , D  d}|

|{j  Z | (d, (d, j, s))  rJ}|

r  s  R(B)

D  d  Su, (c, d)  sR


r  s  R(B),

D  d  Su, (c, d)  sR

c(xc,s,d)

rsR(B)

c(M,c,s,D).

(1)
To similarly count the named successors of d  I, we only have to
consider the case that d = a  Ind( ) since unnamed domain elements can only have unnamed rJ -successors. By the definitions of
role types and formula types, for every b  Ind( ) there is a unique
role type s  R(B) such that s(a, b)  f iff s  s. By definition of
J , s(a, b)  f is equivalent to (a, b)  sJ , and thus we have
|{b  Ind( ) | (a, b)  rJ , b  DI}|
= |{b  Ind( ) | (a, b)  rJ , D  (b)}|

rsR(B)

|{b  Ind( ) | (a, b)  sJ iff s  s, D  (b)}|
|{b  Ind( ) | s(a, b)  f iff s  s, D  (b)}|


rsR(B)

rsR(B)

M,(a),s,D.

(2)
For every (c, i, r)  Anon, we know that c solves the inequations
in (E1) and (E2). Thus, we have n r.D  c iff the values in (1) are
all  n iff (c, i, r)  (n r.D)I. Similarly, for a  Ind( ) it follows
thatn r.D  (a) iff the sum of (1) and (2) is n iff a  (n r.D)I.
This finishes the proof of Claim 4. To show that I is indeed a
model of B, we first show the following claim by structural induc-
tion.
Claim 5. For all   Sub(B), we have   f iff I |= .
For the first base case, assume that  is of the form A(a) for A  NC
and a  NI. We have A(a)  f iff A  (a) by condition (b). Thus,
A(a)  f iff aI = aJ = a  AJ = AI iff I |= A(a).
For the second base case, assume that  is of the form r(a, b)
for a, b  NI and r  NR. If r(a, b)  f, we have (a, b)  rJ by the
definition of rJ . Since rJ  rI, a = aI, and b = bI, we obtain
(aI , bI )  rI, and thus I |= r(a, b). Conversely, if I |= r(a, b), we
have by the definition of rI that (a, b)  rJ or (a, b)  (sJ )+ for
some s  NR with R |= s  r and R |= trans(s). If (a, b)  rJ ,
the definition of rJ implies that r(a, b)  f. Otherwise, there are
d1, . . . , dm  I such that (a, d1)  sJ , (d1, d2)  sJ , ..., and
(dm, b)  sJ . By the definition of sJ , we know that
d1, . . . , dm  Ind( ), and thus s(a, d1)  f, s(d1, d2)  f, ..., and
s(dm, b)  f. The definition of a formula type yields that s(a, b)  f
and r(a, b)  f.
For the third base case, assume that  is of the form   C.
If   C  f, then for every c  S, we have C  c by condition (d). Claim 4 yields together with the fact that  maps into S

that CI = Anon  Ind( ) = I. For the converse direction, if
  C  f, then by the definition of a formula type,(  C)  f.
Then, by condition (e), there is a c  S such that C  c, which implies C  c, because c is a concept type. Claim 4 yields that either
{c}  Z  R  (C)I or there is an a  Ind( ) such that c = (a)
and a  (C)I. Thus, we have CI = Anon  Ind( ) = I.
For the induction step, assume first that  is of the form .
By induction, we have   f iff 
 f iff I |=  iff I |= .
Similarly, if  is of the form 1  2, then   f iff {1, 2}  f
iff I |= 1 and I |= 2 iff I |= 1  2.
This finishes the proof of Claim 5. Since f is a formula type for  ,
we have   f, and thus together with Claim 5 that I |=  . We
now show that I is also a model of R.
Claim 6. For all   R, we have I |= .
Assume first that  is of the form r  s. We first show that rJ 
sJ . For this, take (x, y)  rJ . There are three cases to consider:
 If x, y  Ind( ), we have r(x, y)  f. Since r  s  R, we have
also R |= r  s, which yields s(x, y)  f since f is a formula
type. The definition of sJ yields that (x, y)  sJ .
 If x  Ind( ) and y = (d, j, s)  Anon, we have
r  s, ((x), d)  sR, and (x)(x(x),s,d)  j. By the definition of
a role type, we have s  s. Hence, (x, (d, j, s))  sJ .
 If x = (c, i, r)  Anon and y = (d, j, s)  Anon, we have r  s,
(c, d)  sR, and c(xc,s,d)  j. By the definition of a role type,
we have s  s. Hence ((c, i, r), (d, j, s))  sJ .
To show that rI  sI, take (x, y)  rI. If (x, y)  rJ , we have
(x, y)  sJ and thus (x, y)  sI. Otherwise, we have (x, y)  (tJ )+
with R |= t  r and R |= trans(t). Since r  s  R, we also have
R |= t  s. The definition of sI yields that (tJ )+  sI, and hence
(x, y)  sI.
Assume now that  is of the form trans(r). Since trans(r)  R,
we have also R |= trans(r), and obviously also R |= r  r. By the
same arguments as above, we have that for each t with R |= t  r
that tJ  rJ , and thus (tJ )+  (rJ )+ since the transitive closure
is monotonic. This yields that rI = (rJ )+, and thus I |= trans(r).
This finishes the proof of Claim 6. Together with Claim 5, this
implies that I is indeed a model of B. It only remains to be shown
that I respects D. By condition (g) and Claim 4, we have for every d  I a set Y  D such that d  (CY )I. By condition (h)
and Claim 4, we also have for every Y  D a d  I such that
d  (CY )I. This shows that I respects D.
This finishes the proof of the if direction of the lemma. For
the only if direction, assume that there is a model I = (I ,I )
of B =  , R that respects D. Due to Lemma 6.5, we can assume w.l.o.g. that I is a forest model. We denote by I
u the set
{d  I | d = aI for all a  NI} of unnamed domain elements,
n the set I \ I
and by I
u of named domain elements. We now
construct a quasimodel for B.
Let  (d) := {C  Con(B) | d  CI} for d  I. We define M =
(S, , f) as follows:
 S := { (d) | d  I
 (a) :=  (aI )  {a} for all a  Ind( ); and
 f := {  Sub(B) | I |= }.
Obviously, S is a set of concept types for B, f is a formula type
for B, and we have also that for any c, d  S with c = d that
c  d  Ind( ) = . By definition, a  (a) for all a  Ind( ).
Hence, M is a model candidate for B. We continue showing the
following claim.
Claim 7. For all d, e  I and r  NR, we have that (d, e)  rI
implies ( (d),  (e))  rR.

u}  { (aI )  {a} | a  Ind( )};

Assume that (d, e)  rI. For the first condition of r-compatibility,
take any (r.D)   (d), which implies that d  (r.D)I. By
the semantics of SHQ, we have e  (D)I, and thus D   (e).
For the second condition of r-compatibility, take any s  NR with
R |= r  s, R |= trans(r), and (s.D)   (d). Since I is a model
of R, we have rI  sI and rI is transitive. Suppose that(r.D) 
 (e), and thus r.D   (e). Then there is an e  I with e  DI
and (e, e)  rI. Since rI is transitive, we have also (d, e)  rI, and
thus (d, e)  sI, which yields a contradiction to (s.D)   (d).
This finishes the proof of Claim 7. We can now use this claim to
show that M is also a quasimodel for B that respects D.
Condition (a) is easily verified, because I =  by definition.
For Condition (b), we have A(a)  f iff I |= A(a) iff aI  AI iff
A   (aI )  {a} = (a).
For Condition (c), assume that r(a, b)  f. Then, I |= r(a, b),
and thus (aI , bI )  rI. Claim 7 yields that ( (aI ),  (bI ))  rR.
Obviously, we also have that ((a), (b))  rR.
For Condition (d), take c  S and   C  f. The definition of
f yields I |=   C, and thus CI = I. Hence, C   (d) for any
d  I, which yields by the definition of S that C  c.
For Condition (e), take (  C)  f. By the definition of f, this
implies I |=   C. Thus, there is a d  I with d  CI. Thus,
we have either C   (d)  S or C   (d)  {a}  S for some
a  Ind( ).
For Condition (f), take any c  S. We construct a solution c
of the system of equations EM,c. Since c  S, there is a d  I
with c =  (d) if d  I
u and c =  (d)  {a} if d = aI for some
a  Ind( ). Let z denote the maximal integer that occurs in any
number restriction in B. We first consider the variables xc,r,d. Take
any r  R(B) and any d  Su such that (c, d)  rR. Then we define

u |  (e) = d,

c(xc,r,d) := minz, |{e  I
(d, e)  sI iff s  r}|.
iff 

n r.C  c

rrR(B)

We set c(xc,r,d) to at most z to ensure that this value is finite.

Consider now any n r.C  Con(B). We show that
(c(M,c,r,C ) + M,c,r,C )  n,

(3)

Assume first that there are d  Su and r  R(B) such that

which implies that the inequations of the form (E1) and (E2) are
satisfied.
C  d, r  r, (c, d)  rR, and c(xc,r,d) = z  n. Then
by definition of c, there are at least n unnamed domain elements e  I
u with C  d =  (e) and (d, e)  rI, which
implies that d  (n r.C)I, and thus n r.C  c. Addition-
ally, c(M,c,r,C )  z  n, which shows that (3) holds. We
assume in the following that for all d  Su and r  R(B)
with C  d, r  r, and (c, d)  rR, we have c(xc,r,d) =
|{e  I

u |  (e) = d, (d, e)  sI iff s  r}|.

It now follows that, for any r  R(B), we have

c(M,c,r,C ) = 

c(xc,r,d)

u |  (e) = d, (d, e)  sI iff s  r}|

CdSu, (c,d)rR
|{e  I
u | (d, e)  sI iff s  r}|,

CdSu, (c,d)rR
= |{e  CI  I

where the third equality follows by Claim 7. Thus,

c(M,c,r,C ) = |{e  CI  I

u | (d, e)  rI}|.

(4)

(5)

rrR(B)

F. Baader et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 7193

n , then d = aI and c =  (aI )  {a} for some a  Ind( ).

If d  I
Thus,

rrR(B)

rrR(B)

M,c,r,C

|{b  Ind( ) | C  (b), s(a, b)  f iff s  r}|

n | (d, e)  rI}|.

= |{b  Ind( ) | C  (b), r(a, b)  f}|
= |{b  Ind( ) | bI  CI , (aI , bI )  rI}|
= |{e  CI  I
(6)
If d  I
u , then c =  (d)  Su, and therefore we have M,c,r,C = 0
for all r  R(B) with r  r. Since I is a forest model, d cannot have
named rI-successors, and thus also
n | (d, e)  rI}| = 0, which shows that (6) holds for
|{e  CI  I
all d  I = I
u  I
n .
Since {I
n} partitions I, we thus have n r.C  c iff
u , I

d  (n r.C)I iff |{e  CI | (d, e)  rI}|  n iff

(c(M,c,r,C ) + M,c,r,C )  n

rrR(B)
by (5) and (6), which shows that (3) holds.
Consider now any E = (r1rl).C  Con(B). As above, the
existence of d  Su and r  R(B) such that C  d, r1, . . . , rl  r,
(c, d)  rR, and c(xc,r,d) = z  1 implies that both E  c and
c(M,c,r,C )  z  1, which shows that the corresponding inequation of the form (E3) is satisfied.
Therefore, in the following we can make the same assumption
as in the previous case, i.e., that none of these variables is assigned
the value z. Then (4) holds as before, and thus

If the algorithm has constructed a model candidate

M = (S, , f) that passed all tests, then M obviously satisfies Conditions (a)(h) of Definition 6.13.
Conversely, if M = (S, , f) is a quasimodel of B that respects D,
then  and f must be enumerated by the algorithm at some point.
Since  and f satisfy Conditions (b) and (c), they pass the tests in
Step 1. In Step 2, a model candidate M := (S, , f) with S  S
is constructed since the concept types in S satisfy (d) and (g) by
assumption. We continue with Step 3, where a model candidate
M := (S, , f) with S  S is constructed. The systems of equations EM,c for c  S have the same solutions as EM,cthe additional variables for the concept types in S \ S can simply be evaluated to 0. Thus, we know that S  S and we continue with Step
4. Finally, observe that the concept types needed to satisfy Conditions (a), (e), and (h) are contained in S, and therefore in S. This
shows that the algorithm detects the existence of a quasimodel of B
that respects D.
To analyze the time complexity of the algorithm, observe first
that r-compatibility w.r.t. R can be checked in polynomial time
since this only involves inclusion tests for sets of polynomial size
and entailment tests of role axioms w.r.t. R.
As mentioned before, the number N of model candidates is at
most exponential, while each model candidate (Su  S, , f) is of
exponential size. For each of these exponentially many model can-
didates, the checks in Step 1 can be done in polynomial time and
the checks in Step 2 are done at most exponentially often since each
time one of the exponentially many concept types in S is removed.
Each of these checks can be done in exponential time since the following conditions are checked for at most exponentially many concept types c:
 for (d) we check for inclusion of polynomially many concepts
in c;
 for (g), we enumerate all (at most exponentially many) elements of D and do a simple check.

By similar arguments as above, Step 3 is executed at most exponentially often. Each time this step is performed, for exponentially
many concept types c  S it must be checked whether EM,c has a
solution. Consider now a concept type c  S, and denote by n the
number of variables and by m the number of equations in EM,c.
Note that n may be exponential in the size of B since there are exponentially many possible concept types and role types. However,
m is polynomial since we have one equation per at-least and existential restriction occurring in  . In [46], it was shown that EM,c
can be solved in time O(n2m+2(ma)(m+1)(2m+1)), where a is the value
of the largest number appearing in the equations. Thus, even if the
numbers in at-least restrictions are given in binary encoding, Condition (f) can also be checked in exponential time in the size of B.
Finally, checking (a), (e), and (h) in Step 4 can be done in expo-

