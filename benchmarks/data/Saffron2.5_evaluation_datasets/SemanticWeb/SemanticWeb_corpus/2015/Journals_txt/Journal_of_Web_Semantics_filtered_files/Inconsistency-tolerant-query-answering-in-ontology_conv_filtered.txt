Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

journal homepage: www.elsevier.com/locate/websem

Inconsistency-tolerant query answering in ontology-based data
access
Domenico Lembo, Maurizio Lenzerini, Riccardo Rosati, Marco Ruzzi,
Domenico Fabio Savo
DIAG, Sapienza Universita di Roma, Italy

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 30 September 2013
Received in revised form
1 April 2015
Accepted 4 April 2015
Available online 1 May 2015

Keywords:
Ontology-based data access
Inconsistency tolerance
DL-Lite
Query rewriting

Ontology-based data access (OBDA) is receiving great attention as a new paradigm for managing
information systems through semantic technologies. According to this paradigm, a Description Logic
ontology provides an abstract and formal representation of the domain of interest to the information
system, and is used as a sophisticated schema for accessing the data and formulating queries over them.
In this paper, we address the problem of dealing with inconsistencies in OBDA. Our general goal is both to
study DL semantical frameworks that are inconsistency-tolerant, and to devise techniques for answering
unions of conjunctive queries under such inconsistency-tolerant semantics. Our work is inspired by
the approaches to consistent query answering in databases, which are based on the idea of living with
inconsistencies in the database, but trying to obtain only consistent information during query answering,
by relying on the notion of database repair. We first adapt the notion of database repair to our context,
and show that, according to such a notion, inconsistency-tolerant query answering is intractable, even
for very simple DLs. Therefore, we propose a different repair-based semantics, with the goal of reaching a
good compromise between the expressive power of the semantics and the computational complexity of
inconsistency-tolerant query answering. Indeed, we show that query answering under the new semantics
is first-order rewritable in OBDA, even if the ontology is expressed in one of the most expressive members
of the DL-Lite family.

 2015 Elsevier B.V. All rights reserved.

1. Introduction

Ontology-based data access [1] (OBDA) is receiving great attention as a new paradigm for managing information systems through
semantic technologies. An OBDA system is structured according to
a three-level architecture, which consists of the ontology, the data
sources, and the mapping between the two. The ontology is an abstract and formal description of the domain of interest, and is used
as a sophisticated schema for accessing the data and formulating
queries over them. The data sources are the repositories storing
the data used in the organization by the various processes and the
various applications. The mapping explicitly specifies the relationships between the domain concepts on the one hand and the data
sources on the other hand. Like in data integration systems [2],
the mapping is crucial for keeping the conceptual representation

 Corresponding author.

E-mail addresses: lembo@dis.uniroma1.it (D. Lembo),

lenzerini@dis.uniroma1.it (M. Lenzerini), rosati@dis.uniroma1.it (R. Rosati),
ruzzi@dis.uniroma1.it (M. Ruzzi), savo@dis.uniroma1.it (D.F. Savo).

http://dx.doi.org/10.1016/j.websem.2015.04.002
1570-8268/ 2015 Elsevier B.V. All rights reserved.

of the domain independent from the implementation issues, and
for masking the user from all the details and the idiosyncrasies of
the data sources.

In most formal approaches to OBDA, the ontology is expressed
in terms of a Description Logic TBox. Description Logics (DLs)
are logics specifically defined for describing knowledge bases in
terms of objects, concepts, representing classes of objects, and
relations between objects represented by roles. A DL knowledge
base consists of two components, called TBox and ABox. A DL TBox
is a set of axioms, typically in the form of universally quantified
statements, describing general properties of the concepts and the
relationships that are relevant in the domain of interest. A DL
ABox is a set of membership assertions stating the instances of
concepts and relations. The most important service provided by an
OBDA system is query answering, which amounts to computing the
answers to a query posed in terms of the ontology.

In order to compute such answers, the system should reason
about the ontology, the mapping, and the data at the source, with
the goal of returning the tuples that satisfy the query in all the
models of the system. Usually, the size of the ontology and the
mapping in an OBDA system is limited with respect to the size of

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

the data stored at the sources. For this reason, the crucial parameter
for measuring the complexity of query answering in OBDA is the
size of the data. Various languages for specifying the ontology in
OBDA have been proposed [36], which are designed with the
goal of allowing for query answering algorithms that scale with
the size of the data, and therefore are tractable with respect to
data complexity, i.e., the complexity measured with respect to the
size of the data only. Among these, the members of the DL-Lite
family of lightweight DLs present the distinguishing feature of firstorder rewritable query answering for unions of conjunctive queries
(UCQs), which means that such a reasoning service can be realized
through the evaluation of a suitable first-order query (called the
rewriting of the original query, and directly translatable into SQL)
over the data sources. We observe that, by virtue of its relevance in
OBDA, the DL-Lite family is at the basis of OWL2 QL [7], one of the
tractable profiles of OWL2.

Query rewriting is indeed the most popular approach to query
answering in OBDA systems. According to this approach, query
answering is divided into three steps:
1. The original query is first rewritten with respect to the ontology
into a new query, again expressed over the ontology; we call
this step the ontology rewriting of the query;

2. The query thus obtained is then rewritten into a source database
query using the mapping assertions; we call this step the
mapping rewriting of the query.

3. The query resulting from mapping rewriting is evaluated over

the data sources.
As observed in [8], when DL-Lite is used for expressing the on-
tology, first-order rewritability of query answering is guaranteed
if the mapping is of type global-as-view, i.e., each mapping assertion maps a query over the sources to a single element of the
ontology. Under this assumption, it is well-known that mapping
rewriting can be based on unfolding, which amounts to substituting every atom of the query with the corresponding query in the
mapping.1 In turn, it is easy to see that the whole query answering
process can be based on the following strategy: (i) use the mapping bottom-up and compute, from the data, an ABox A containing all the instance assertions implied by the mapping; (ii) compute
the answers to the query by evaluating the ontology rewriting on
the computed ABox, seen simply as a relational database. This observation leads to the conclusion that, if we are not interested in
optimizing the mapping rewriting step, we can simply ignore the
mapping. Since the purpose of this paper is to study fundamental
issues in dealing with inconsistencies in OBDA, in what follows we
indeed abstract from the presence of mappings, and we consider
simple DL knowledge bases consisting of a TBox and an ABox.

It is well-known that inconsistency causes severe problems in
logic-based Knowledge Representation. In particular, since an inconsistent logical theory has no classical model, it logically implies
every formula (ex falso quodlibet), and therefore query answering
over an inconsistent knowledge base becomes meaningless under
classical logic semantics. Similarly, when a database does not satisfy the integrity constraints defined on its schema, even the task of
giving a meaning to the answers of queries becomes non-obvious.
There are various approaches for devising inconsistencytolerant inference systems [10], originating from different ar-
eas, including Logic, Artificial Intelligence, and Databases. Roughly
speaking, there are two main strategies behind such approaches.
The most direct strategy is to clean the knowledge base of all contradictions [11,12] so as to restore consistency. Another strategy is

1 Obviously, unfolding might not be the most efficient strategy, and therefore,
more sophisticated techniques for mapping rewriting have been studied (See, for
example, [9]).

to leave the knowledge base unchanged, and to consider inconsistency as a natural phenomenon in realistic settings, which are to be
handled by the logic used to express knowledge [1316]. An important class of such logics are called paraconsistent, and are based on
the use of additional truth values standing, for example, for underdefined (i.e., neither true nor false), or overdefined (or contradictory,
i.e., both true and false). Another class of such logics use the standard Boolean truth values, but tries to obtain only meaningful
answers when evaluating queries. In the context of data and
knowledge bases, this approach has been pursued first in the
Database community and is commonly known as consistent query
answering [17,18].

In this paper, we address the problem of dealing with inconsistencies in OBDA, by starting with the consistent query answering
approach, and adapting it to the context of DL knowledge bases.
Depending on the expressive power of the underlying DL, the TBox
alone might be inconsistent, or the TBox might be consistent, but
the axioms in the ABox might contradict the axioms in the TBox.
Here, we focus on the case where the TBox is consistent, while the
instance-level information in the ABox may contradict the knowledge represented in the TBox. Indeed, in the OBDA scenario, it is
appropriate to assume that the ontology is a high quality representation of the domain, designed in such a way to avoid inconsistencies in the modeling of concepts and relationships. On the contrary,
as we said before, the ABox is defined through the mapping from
the concrete data sources of the information system. Since such
sources are often distributed, autonomous, and independent from
the conceptualization represented by the TBox, they likely contain
data that are not coherent with the TBox. In other words, assuming
a consistent TBox and a possibly contradicting ABox is the appropriate setting for realistic OBDA applications.

In consistent query answering, the fundamental tool for obtaining consistent information from an inconsistent data or knowledge
base, is the notion of repair [10,1719]. A repair of a database contradicting a set of integrity constraints is a database obtained by applying a minimal set of changes that restores consistency. There
are several interpretations of the notion of minimality, and different interpretations give rise to different inconsistency-tolerant
semantics. Under most interpretations of minimality, there are
many possible repairs for the same database, and the approach
sanctions that what is consistently true is simply what is true in
all possible repairs of the database. Thus, inconsistency-tolerant
query answering amounts to computing the tuples that are answers to the query in all possible repairs.

In this paper we use the notion of repair in DL knowledge
bases. Since we accept inconsistencies only in the ABox, we
call this notion ABox repair, and ABox Repair (AR) semantics the
corresponding semantics. For a DL knowledge base constituted
by the TBox T and the ABox A, we define an ABox repair to
be an inclusion-maximal subset of A that is consistent with T .
Unfortunately, we show that, even for what is considered to be the
simplest logic of the DL-Lite family, inconsistency-tolerant query
answering under the AR-semantics is coNP-complete with respect
to data complexity, and therefore can be quite problematic in realworld applications.

To address this problem, we propose a new inconsistencytolerant semantics for DL knowledge bases (KBs), which is the first
contribution of this paper. The basic idea of the new semantics,
called Intersection ABox Repair (IAR) semantics, is simple: instead
of considering all the possible repairs of the KB as relevant
for inconsistency-tolerant query answering, we consider the
intersection of such repairs as the ABox to use in query answering,
in the spirit of the well-known When In Doubt, Throw It Out
principle [20]. Obviously, since all repairs are consistent, their
intersection is also consistent, and query answering over the
intersection can be done by resorting to the classical semantics.

In other words, inconsistency-tolerant query answering in this
new semantics is reduced to classical query answering over the
intersection of all repairs of the original ABox. We show that the
IAR-semantics enjoys several desirable properties. In particular,
we show that this semantics is a sound approximation of the
AR-semantics, and that query answering under the IAR-semantics
is first-order rewritable for unions of conjunctive queries, thus
showing that the problem can be solved in polynomial time, in
fact AC 0, in data complexity. This is the second contribution of this
paper.

The first-order rewritability result concerns one of the most
expressive logics in the DL-Lite family. This logic, called
DL-LiteA,id,den, includes the typical constructs of the DL-Lite fam-
ily, and adds two distinguished features, namely identification
assertions and denial assertions. Identification assertions are mechanisms for specifying a set of properties that can be used to identify
instances of concepts [21]. Such assertions allow for sophisticated
forms of object identification, which may include paths realized
through the chaining of roles, their inverses, and attributes. Denial
assertions are used to impose that the answer to a certain Boolean
conjunctive query over the ontology is false, analogous to negative
constraints in [22], thus forbidding that certain combinations of
facts can occur in an ABox. This is particularly useful for specifying
general forms of disjointness, that, like identification assertions,
are not supported in traditional ontology languages. In all OBDA
projects we have carried out in the last years (see, e.g., [23,24]), the
importance of these two constructs clearly emerged. Therefore, we
believe that showing that these kinds of constraints can be added
to DL-Lite without losing first-order rewritability of conjunctive
queries even under inconsistency-tolerant semantics is crucial for
promoting the adoption of OBDA in real applications.

We have implemented our algorithm and tested it over the
LUBM benchmark ontology. In fact, we had to slightly modify
the LUBM ontology to make it suitable for our testing aims by
introducing in it denial and identification assertions, as well as
some other forms of assertions possibly causing inconsistency. We
made use of the LUBM data generator to obtain ABoxes of various
size, ranging from around 100,000 facts to more than 2.7 million
facts, and manually introduced in such ABoxes various percentages
of inconsistency. We tested several queries, some taken from
the LUBM benchmark, some others specifically defined by us.
Our results, in terms of both rewriting and evaluation times, are
encouraging and support the practical feasibility of inconsistencytolerant query answering in an OBDA scenario.

The paper is organized as follows. In Section 2 we present
the logic DL-LiteA,id,den and provide some preliminaries on query
answering over DL knowledge bases (some details on first-order
rewritability are deferred to Appendix A). In Section 3 we briefly
describe the algorithm for consistency checking in DL-LiteA,id,den
under the classical first-order semantics. The correctness of the
algorithm is proved in Appendix B. In Section 4 we introduce the
AR-semantics and in Section 5 we show that query answering
under such semantics is intractable for both DL-LiteA,id,den and
DL-Litecore, i.e., the simplest DL-Lite logic. In Section 6 we present
the IAR-semantics and in Section 7 we show that query answering
under such semantics for UCQs is first-order rewritable in
DL-LiteA,id,den. In Section 8 we illustrate our experiments with
the LUBM ontology, and in Section 9 we discuss related work.
Section 10 concludes the paper. The results presented in this paper
appeared in preliminary form in [2527].

2. Preliminaries

model the domain of interest in terms of objects, i.e., individuals,
concepts, that are abstractions for sets of objects, and roles, that
denote binary relations between objects. In addition, some DLs
distinguish concepts from value-domains, that denote sets of
values, and roles from attributes, that denote binary relations
between objects and values.

We consider an overall alphabet  , partitioned in two disjoint
alphabets, namely, P, containing symbols for predicates, and C,
containing symbols for individual (object and value) constants.
We further partition P into four disjoint sets containing symbols
denoting atomic concepts, atomic roles, attributes, and value-
domains, respectively, and partition C into two disjoint sets,
called O and V , which are the set of constants denoting objects,
and the set of constants denoting values, respectively. In the rest
of the paper, when it is clear from the context, we often implicitly
refer to  .

Complex concept, role, and attribute expressions are constructed by applying suitable operators to atomic concepts and
roles, attributes, and value-domains. Different DL languages allow
for different operators in the constructs.

Given a DL language L, an L knowledge base, or simply a DL
knowledge base when L is clear from the context, over an alphabet
 is a pair K = T , A, where:
 T , called the TBox of K, is a finite set of intensional assertions
(also called TBox assertions) over  expressed in L;
 A, called the ABox of K, is a finite set of extensional assertions
(also called ABox assertions) over  expressed in L.
Intuitively, T contains axioms specifying general properties of
concepts, roles, and attributes, while A contains axioms about
individual objects, thus specifying extensional knowledge. Again,
different DL languages allow for different forms of TBox and ABox
assertions.

The semantics of a DL knowledge base is given in terms of
FOL interpretations (cf. [28]). Then, the notions of interpretation
satisfying a FOL sentence, and of entailment of a sentence by a KB
are given in the standard way.

In this paper, we consider DL-LiteA,id,den, which is the most
expressive member of the DL-Lite family of lightweight DLs2 [3].
DL-LiteA,id,den has been recently introduced in [27,29] as an
extension with denial assertions of the logic DL-LiteA,id, given
originally in [21]. In the rest of this section, we provide syntax and
semantics of DL-LiteA,id,den. Since some of the hardness complexity
results we give in the next sections hold already for DL-Litecore,
i.e., the least expressive member of the DL-Lite family (which can
be seen as a fragment of DL-LiteA,id,den), we also recall the syntax
of DL-Litecore. Finally, recall the basic notions related to query
answering, and FO-rewritability.

2.1. DL-LiteA,id,den

Concepts, roles, attributes, and value-domains in DL-LiteA,id,den

where A denotes an atomic concept, P an atomic role, P the inverse
of an atomic role P, and U an attribute. B and R denote a basic
concept and a basic role, respectively. The concept R, also called
unqualified existential restriction, denotes the domain of a role R,
i.e., the set of objects that R relates to some object. Similarly, (U)

are formed according to the following syntax:

B  A | R | (U) E  (U)
R  P | P

F  D | T1 |


| Tn

Description Logics [28] are decidable fragments of first-order
logic (FOL) that can be used to represent the knowledge of a domain
of interest in a structured and formally well-understood way. They

2 Not to be confused with the set of DLs studied in [4], which is called the
extendedDL-Lite family.

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

Fig. 1. Semantics of the DL-LiteA,id,den constructs.

denotes the domain of an attribute U, i.e., the set of objects that
U relates to some values. Furthermore, E and F are value-domain
expressions, (U) denotes the range of an attribute U, i.e., the
set of values to which U relates some object, T1, . . . , Tn denote
unbounded pairwise disjoint predefined value-domains, and D is
the universal value-domain. In the following, when R is a basic role,
the expression R stands for P when R is of the form P, while R
stands for P when R is of the form P. The symbols A, P, U, B, R, Ti
will be used throughout the paper with the above meaning.
As stated earlier, the semantics of a DL-LiteA,id,den KB is given in
terms of FOL interpretations. All such interpretations agree on the
semantics assigned to each predefined value-domain Ti and to each
constant in V . More precisely, we assume to have a fixed nonempty domain of values V , and to interpret each value-domain
Ti  {T1, . . . , Tn} as the set val(Ti). Furthermore, we interpret
each constant cv  V as one specific value, denoted val(cv),
and assume that there is exactly one Ti  {T1, . . . , Tn} such that
val(cv)  val(Ti). Also, we denote by type(cv) the Ti such that
val(cv)  val(Ti). As usual in DL-Lite, we also assume that the set
of value-domains T1, . . . , Tn corresponds to any subset of the data
types adopted by the Resource Description Framework (RDF) [30],
having the following characteristics:
(i) the extension of each Ti is unbounded;
(ii) the extensions of value-domains are pairwise disjoint, i.e.,

val(Ti)  val(Tj) =  for each 1  i < j  n;

value-domains is unbounded, i.e., the set V \n

(iii) the extension of the complement in V of the extensions of all
i=1 val(Ti) is

unbounded.

The above assumptions allow us to treat value-domains as atomic
concepts, and attributes as atomic roles when answering queries
posed over DL-LiteA,id,den KBs, as we will discuss later on in this
section.
An interpretation I = (I ,I ) for a DL-LiteA,id,den KB over an
alphabet  consists of an interpretation domain I =  I
O  V ,
where  I
O is a non-empty set, disjoint from V , called the domain of
objects, and an interpretation function I. Such a function coincides
with the function val in the interpretation of value domains and
value constants, while it assigns a subset C I of  I
O to each concept
O  V to
C, a subset RI of  I
O to each constant c  O.
each attribute U, and an element cI of  I
Each such interpretation I respects the Unique Name Assumption
(UNA), i.e., I assigns each constant from O to a distinct element of

O, and each constant from V to a distinct element of V .
Given an interpretation I of the form described above, the
semantics for DL-LiteA,id,den concepts, roles, and attributes is
specified in Fig. 1.

O to each role R, a subset U I of  I

O   I

We now turn to the definition of DL-LiteA,id,den TBox assertions,

which have the following form3:
R1  R2
U1  U2
R1  R2 U1  U2
(funct U)

B1  B2
B1  B2
(funct R)
y.conj(y)  
(id B 1, . . . , n)

E  F

3 In fact, DL-LiteA,id,den also allows for the use of positive qualified existential
restrictions [28] in the right-hand side of inclusions. This, however, can be easily
encoded in DL-LiteA,id,den without qualified existential restrictions (cf. [3]).

Assertions of the first row are called positive inclusion assertions
(or, simply, positive inclusions) specified, from left to right, between concepts, roles, attributes, and value-domains, respectively.
Given a TBox T , we denote with Tinc the set of concept, role, and
attribute positive inclusions occurring in T , and with Ttype the set
of positive inclusions between value-domains occurring in T .

Assertions of the second row are negative inclusion assertions
(or, simply, negative inclusions), also called disjointnesses, spec-
ified, from left to right, between concepts, roles, and attributes, re-
spectively. The set of all negative inclusions in a TBox T is denoted
by Tdisj.

Assertions of the third row, from left to right, are role and
attribute functionality assertions, respectively, which state that a
role or an attribute is functional. We denote with Tfunct the set of
the functional assertions of a TBox T .
The assertion in the fourth row, i.e., y.conj(y)  , is a
denial assertion (or, simply, a denial). In such assertion, conj(y)
denotes a conjunction of atoms of the form A(t1), P(t1, t2), or
U(t1, t3), where t1, t2 are either variables in y or constants in O,
and t3 is either a variable in y or a constant in V . Notice that
such assertions correspond to Horn clauses having a false head.
Intuitively, they allow one to specify that certain patterns of objects
cannot occur as instances of the knowledge base. Interestingly, the
form of these patterns is arbitrary, i.e., they are not limited to be
tree-shaped, as usual in Description Logics. By means of denial
assertions, we enrich DLs of the DL-Lite family with general forms
of disjointnesses, otherwise not expressible in these languages, and
with the ability of specifying irreflexivity of roles. For example,
the denial assertion x.(hasFather(x, x)  ) implies that the
role hasFather is irreflexive, i.e., that a person cannot be father of
himself. In what follows, we denote with Tden the set of the denial
assertions belonging to a TBox T .

The last kind of assertion, i.e., (id B 1, . . . , n), is an identification assertion (or, simply, an identification), stating that a set of
properties identifies the instances of a basic concept B. In an identification assertion, i is a path, i.e., an expression built according
to the following syntax:

  S | D? | 1  2

where S denotes a basic role (i.e., an atomic role or the inverse of
an atomic role), or an attribute, 1  2 denotes the composition
of paths 1 and 2, and D?, called test relation, represents the identity relation on instances of D, which can be a basic concept or a
value-domain expression. Test relations are used to impose that a
path involves instances of a certain concept or value-domain. The
length of a path , denoted length( ), is 0 if  has the form D?, is
1 if  has the form S, and is length(1) + length(2) if  has the
form 1  2. In our logic, identification assertions are local, i.e., at
least one i  {1, . . . , n} is of length 1, i.e., it is an atomic role,
the inverse of an atomic role, or an attribute (possibly composed
only with test relations). The term local emphasizes that at least
one of the paths refers to a local property of B [21]. Intuitively, an
identification assertion of the above form asserts that for any two
different instances o, o of B, there is at least one i such that o and
o differ in the set of their i-fillers, that is the set of objects that are
reachable from o and o by means of i. For example, the identification assertion (id Match homeTeam, visitorTeam) says that there
are not two different matches with the same home team and visiting team (which is indeed what happens, for instance, in a season
schedule of a football league). In what follows, we denote the set
of the identification assertions belonging to a TBox T with Tid.

We are now ready to present the definition of DL-LiteA,id,den KB.
Definition 1. A DL-LiteA,id,den KB is a pair K = T , A, such that:
 the TBox T consists of the finite sets Tinc, Ttype, Tdisj, Tfunct, Tden,
and Tid, as described above;

 the ABox A is a finite set of assertions of the forms A(a), P(a, b)
and U(a, v), where a and b are constants in O, and v is a
constant in V ;
 each role or attribute that either is functional in T , i.e., it occurs
in a functionality assertion in T , or appears (in either direct or
inverse direction) in a path of an identification assertion in T ,
is not specialized, i.e., it does not appear on the right-hand side
of assertions of the form R  R or U  U.
Note that, as shown in [31], the last condition of the above
definition is necessary for keeping query answering first-order
rewritable (see later).

1(o)   I
n(o) =  implies o = o, where  I

To complete the definition of the semantics of a DL-LiteA,id,den
KB, we first define when an interpretation satisfies a TBox
assertion, and then we extend the definition to satisfaction of ABox
assertions. As usual, we denote by I |	  the fact that I satisfies
, where  is either an ABox or a TBox assertion.
Concerning the satisfaction of TBox assertions, we analyze here
the various cases:
 If  is a positive inclusion assertion of the form B1  B2, then
I |	  if BI
1  BI
2. The definition for the other positive inclusions
is analogous.
 If  is a negative inclusion assertion of the form B1  B2, then
1  BI
I |	  if BI
2 = . The definition for the other negative
inclusions is analogous.
 If  is a role functionality assertion of the form (funct R), then
I |	  if for each o1, o2, o3   I
O we have that (o1, o2)  RI
and (o1, o3)  RI implies o2 = o3. The definition for attribute
functionality assertions is analogous.
 If  is a denial assertion of the form y.conj(y), then I |	  if
the FOL sentence y.conj(y) evaluates to false in I (i.e., is not
satisfied by I in the standard FOL sense).
 If  is an identification assertion of the form (id B 1, . . . , n),
1(o) =    
then I |	  if for all o, o  BI,  I
n(o)  I

i (o) denotes the set
i }, with  I
of i-fillers for o in I, i.e.,  I
defined as follows:
 if  = S, then  I = SI,
 if  = D?, then  I = {(o, o) | o  DI},
 if  = 1  2, then  I =  I
1   I
2, where  denotes the
composition operator on relations.
An interpretation I satisfies an ABox assertion A(a) if aI  AI, an
ABox assertion P(a, b) if (aI , bI )  PI, and an ABox assertion U(a, c)
if (aI , val(c))  U I. A model of a DL-LiteA,id,den KB K = T , A
is an interpretation I that satisfies all assertions in T and A. We
denote with I |	 K the fact that I is a model for K, and with
Mod(K) the class of all models of K. A KB is satisfiable if it has
at least one model, i.e., Mod(K) = , unsatisfiable otherwise. For
a KB, we also use the term consistent (resp. inconsistent) to mean
 of ABox assertions is said
satisfiable (resp. unsatisfiable). A set A
 is satisfiable, T -inconsistent
to be T -consistent if the KB T , A
otherwise.
A KB K entails (or logically implies) a FOL sentence , and
therefore a TBox or ABox assertion, written K |	 , if all models
of K are also models of . This notion naturally extends to a set of
sentences. The KB satisfiability problem is defined as follows: given
a DL KB K, verify whether it is satisfiable.

i (o) = {o | (o, o)   I

Example 1. In this example, we present a TBox that models a (very
small portion of) the network managed by a telecommunication
company, extracted from an ontology we developed within a
real-world experimentation [32]. In particular, our KB focuses on
the connections between telecommunication devices (cf. concept
Device in the ontology), which is realized by connecting device
ports (Port). Each port belongs to (of ) exactly one device. Among
various kinds of ports, there are incoming ports (PortIn) and

outgoing ports (PortOut), which are disjoint sets of ports. Each
port is associated with a number (number), and there do not
exist two ports of the same device with the same number. A port
can be connected to (connectedTo) another port, according to the
following rules:
(a) every port is connected to at most one other port;
(b) two ports of the same device cannot be connected to each

(c) there cannot exist an incoming port and an outgoing port of

other;

one device that are connected to ports of the same device.
The following DL-LiteA,id,den TBox T captures our domain:
 the set Tinc consists of the following assertions:
PortOut  Port
PortIn  Port
connectedTo  Port
of  Port
connectedTo  Port
of  Device
Port  (number)
Device  of
(number)  Port
Port  of
 the set Ttype consists of the following assertion:
(number)  xsd:integer
 the set Tdisj consists of the following assertions:
PortIn  PortOut
Port  Device
 the set Tfunct consists of the following assertions:
(funct connectedTo)
(funct of )
(funct connectedTo )
(funct number)
 the set Tid consists of the following assertion:
(id Port number, of )
 the set Tden consists of the following assertions:
 x, y, z.Port(x)  Port(y)  of(x, z)  of(y, z)
 x, y, z, k,w, v.PortOut(x)  of (x, y)  connectedTo(x, z)
 of (z, k)
 PortIn(w)  of (w, y)  connectedTo(w, v)
 of (v, k)  .

 connectedTo(x, y)  

Notice that the identification assertion models the fact that
there do not exist two ports with the same number in the same
device. Moreover, the functionality assertions on both the role
connectedTo and its inverse encode the above rule (a), while the
first denial assertion copes with the above rule (b), and the second
denial assertion formalizes the above rule (c).

2.2. DL-Litecore

DL-Litecore is the least expressive member of the DL-Lite family,
and its constructs are shared among all logics of the family. In
this sense, it can be seen as a fragment of DL-LiteA,id,den, where
denial, identification and functionality assertions are not allowed,
and no distinction is made between roles and attributes. More
precisely, concepts and roles in DL-Litecore are formed according to
the following syntax:

A DL-Litecore TBox T is a finite set of assertions of the form

B  A | R
B1  B2

R  P | P.
B1  B2

that is, it is a finite set of positive and negative inclusions between basic concepts. A DL-Litecore ABox has the same form of a
DL-LiteA,id,den ABox, and a DL-Litecore knowledge base K is simply
a pair T , A where T and A are a TBox and ABox in DL-Litecore,
respectively.
The semantics of a DL-Litecore KB coincides with that of
DL-LiteA,id,den, limited to the constructs and assertions allowed in
DL-Litecore. The notions of model of a KB, KB satisfiability, and
entailment of a sentence by a KB are obviously the same as those
given for DL-LiteA,id,den.

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

2.3. Query answering

A FOL query over a DL KB is a possibly open FOL formula over
the KB alphabet. A conjunctive query (CQ) is a FOL query of the
form y.conj(x,y), where y and x are disjoint sets of variables,
called existential and free variables, respectively, and conj(x,y) is
a conjunction of atoms of the form A(z), Ti(z), P(z, z), U(z, z),
where z, z are either constants or (possibly non-distinct) variables
from x or y. A union of conjunctive queries (UCQ), is a FOL query
i=1 yi.conji(x, yi) such that each yi.conji(x, yi) is
a conjunctive query. With a little abuse of notation, we will
sometime treat a UBCQ (possibly enriched with inequalities) as a
set of CQs.

of the formn

A Boolean FOL query is a FOL query with no free variables, i.e., a
FOL sentence. The notion of satisfaction of a Boolean query q in an
interpretation I and the notion of entailment by a DL KB K are the
usual ones: we write I |	 q when q is satisfied in the interpretation
I, and K |	 q when q is entailed by K, i.e., q is satisfied in
all models of K. For a non-Boolean query q with free variables
x1, . . . , xn, a tuple of constants a1, . . . , an is a certain answer to
q over K if K |	 q[x1/a1, . . . , xn/an], where q[x1/a1, . . . , xn/an]
is the Boolean query obtained by replacing each xi in q with ai.
Query answering for a non-Boolean CQ q over a KB K is the task
of computing all certain answers to q over K, and it is this task that
we aim to study in this paper. As we have just noticed, this task can
be straightforwardly reduced to entailment of Boolean conjunctive
queries. Thus, for ease of exposition, and as usually done in the
studies of query answering over KBs (see, e.g., [33]), we consider in
the following only Boolean conjunctive queries (BCQs) and unions
of Boolean conjunctive queries (UBCQs), and we define the query
answering reasoning service as follows: given a DL KB K and a
Boolean query q (either a BCQ or a UBCQ) over K, verify whether
K |	 q. A simplified form of query answering is instance checking,
defined as follows: given a DL KB K and an ABox assertion , verify
whether K |	 . We notice that, according to what we have said
above, despite the fact that we limit our investigation to Boolean
queries, all the results we achieve on query answering over a DL KB
can be easily extended in the standard way to the presence of free
variables in queries.

In this paper we are interested in the so-called data complexity
of query answering (and of KB satisfiability, as well), which is a
notion borrowed from the database literature [34]. According to
data complexity, both the TBox and the query are not considered
as inputs to the query answering problem, and the complexity
is therefore measured with respect to the size of the ABox only.
This complexity measure is of particular interest in all those cases
where the size of the intensional level of the KB (i.e., the TBox) is
negligible with respect to the size of the data (i.e., the ABox), as in
ontology-based data access [35].

We now introduce some notions related to query answering
that will be used in the rest of the paper. In particular, the following
definition provides a database-like interpretation of an ABox.

 V , where DB(A)

is the set of all object
= val(Ti) for each value-domain Ti  {T1, . . . , Tn}, and

Definition 2. Let A be a set of ABox assertions. The interpretation
DB(A) = DB(A),DB(A) is defined as follows:
 DB(A) = DB(A)
constants occurring in A,
 T DB(A)
cDB(A) = val(c) for each constant c  V ,
 aDB(A) = a, for each object constant a occurring in A,
 ADB(A) = {a | A(a)  A}, for each atomic concept A,
 PDB(A) = {(a1, a2) | P(a1, a2)  A}, for each atomic role P, and
 U DB(A) = {(a, val(c)) | U(a, c)  A}, for each attribute U.

The notion of image of a Boolean conjunctive query in an ABox
is given as follows. For a BCQ q = y. conj(y), we denote with
conj-set(y) the set of atoms occurring in the conjunction conj(y).
Given an ABox A, an image of q in A is a set G  A such that
there exists a substitution  from the variables y in conj-set(y)
to constants in G such that the set of atoms in  (conj-set(y)) is
equal to G and the formula  (conj(y)) evaluates to true in DB(G),
i.e., DB(G) |	  (conj(y)). Obviously, we have that DB(A) |	 q if
and only if there exists an image of q in A. We use images(q, A)
to denote the set of all images of q in A. The notion of image
naturally extends to BCQ with inequalities. More precisely, if q =
y. conj(y)=(y), where variables in y occur also iny and =(y)
contains all inequality predicates of q, and G, conj-set(y), and  are
as above, G is an image of q in A if DB(G) |	  (conj(y)  =(y)).

2.4. The notion of FO-rewritability

In this paper we study the crucial property of first-order
rewritability (FO-rewritability) for both KB satisfiability and query
answering. Intuitively, FO-rewritability of KB satisfiability (resp.,
query answering) captures the property that we can reduce
satisfiability checking (resp., query answering) to evaluating a FOL
query over the ABox A considered as a relational database, i.e., over
DB(A). The definitions follow.

Definition 3. KB satisfiability in a DL L is FO-rewritable if, for every
TBox T expressed in L, one can effectively compute a Boolean
FOL query qs over T such that, for every ABox A, the KB T , A
is satisfiable if and only if DB(A) |	 qs.
Definition 4. Query answering in a DL L is FO-rewritable, if for
every TBox T expressed in L and every query q over T , one can
effectively compute a FOL query qr over T such that for every ABox
A for which T , A is satisfiable, we have that T , A |	 q if and
only if DB(A) |	 qr. We call such qr a perfect FOL rewriting (or
simply perfect rewriting) of q w.r.t. T .

We remark that the FOL query considered in the above
definitions depends only on the TBox (and the query), but not on
the ABox. Since the evaluation of a FOL query over an ABox is in AC0
in data complexity [36], we can state that, both for KB satisfiability
and query answering, the property of FO-rewritability implies that
the problem is in AC0 in data complexity.

FO-rewritability of query answering for various logics of the
DL-Lite family has been shown in [3,37]. In these papers, the algorithm PerfectRef has been presented, which takes as input a
DL-LiteA,id TBox T and a UCQs Q and returns a perfect rewriting of Q w.r.t. T . In this paper, we consider the case in which
PerfectRef takes as input a DL-LiteA,id,den TBox, and acts exactly
as in [3,37]. Then, the following proposition immediately follows
from the analogous result given in [37] for DL-LiteA,id.

Proposition 1. If T be a DL-LiteA,id,den TBox, and Q is a UCQs over
T , then PerfectRef(Q , T ) is a perfect rewriting of Q w.r.t. T .

Instances of execution of PerfectRef can be found in Example 3,

whereas the description of PerfectRef is recalled in Appendix B.

3. Satisfiability of DL-LiteA,id,den KBs

We now deal with KB satisfiability in DL-LiteA,id,den and show
that this problem is FO-rewritable (cf. Definition 3), and thus in
AC0 in data complexity.

We first notice that FO-rewritability of the satisfiability check
for DL-LiteA,id, i.e., DL-LiteA,id,den without denial assertions, has
been already claimed in [37]. In that paper, however, the role

of assertions of the set Ttype has been overlooked, and therefore
the algorithm for KB satisfiability given in [37] does not identify
inconsistencies caused by the value-domain inclusions of the TBox.
Notice that such inconsistencies may arise from the fact that the
extensions of value-domains are pairwise disjoint, as shown in the
following example.
Example 2. The TBox assertion (U)  Ti implies that (U)
is disjoint from every value-domain distinct from Ti. Thus, the
ABox assertion U(a, v) such that v  V and val(v)  val(Tj),
= Ti, is inconsistent with the above TBox assertion, and
with Tj
the KB {(U)  Ti},{U(a, v)} is unsatisfiable. As a further
example, consider the KB {(U1)  Ti, (U2)  Tj, U1 
U2, A  (U1)},{A(d)}. The TBox implies that U1 has an empty
interpretation in every TBox model, and therefore the above KB is
unsatisfiable.

Our algorithm for KB satisfiability makes use of a function
 that associates (unions of) Boolean conjunctive queries with
inequalities to assertions in Ttype  Tdisj  Tfunct  Tid  Tden.
Such a function, which extends to value-domain inclusions and
denial assertions an analogous function given in [37], is defined as
follows.
: x, x1, x2.P(x, x1)  P(x, x2)  x1 = x2
- ((funct P))
: x, x1, x2.P(x1, x)  P(x2, x)  x1 = x2
- ((funct P))
: x, x1, x2.U(x, x1)  U(x, x2)  x1 = x2
- ((funct U))
: x.(B1, x)  (B2, x)
- (B1  B2)
- (R1  R2)
: x1, x2.(R1, x1, x2)  (R2, x1, x2)

: x1, x2.U1(x1, x2)  U2(x1, x2)
- (U1  U2)
j{1,...,n}j=i x1, x2.U(x1, x2)  Tj(x2)
- ((U)  Ti)
- (x.conj(x)  )
: x.conj(x)

- ((id B 1, . . . , m)) : x, x.(B, x)  (B, x)  x = x
1im xi. (i, x, xi)   (i, x, xi)

In the above definition, x, x, x1, x2, . . . , xm are variables andx is
a sequence of variables, and  and  are two functions, that we now
define. In what follows, ynew denotes fresh variable symbol, i.e., a
variable symbol not occurring elsewhere in the query. The function
 takes care of atoms built on basic concepts, whereas the function
 takes care of atoms built on roles:

A(x)
(R, x1, x2) =P(x1, x2)

(B, x) =

P(x2, x1)

ynew.P(x, ynew)
ynew.P(ynew, x)
ynew.U(x, ynew)

if R = P,
if R = P.

if B = A,
if B = P,
if B = P,
if B = (U)

and

The function  takes care of paths  in identification assertions,
and is defined inductively on the structure of .
 if  = R, then  ( , x1, x2) = (R, x1, x2),
 if  = U, then  ( , x1, x2) = U(x1, x2),
 if  = D?, then  ( , x1, x2) = D(x1),
 if  = 1  2, and 1 = D?, then  ( , x1, x2) = D(x1) 
 (2, x1, x2),
 if  = 1  2, and 1 is not of the form D?, then  ( , x1, x2) =
ynew. (1, x1, ynew)   (2, ynew, x2).
Intuitively, if  is an assertion in Tdisj  Tfunct  Tid  Tden,
then the query () encodes the negation of , i.e., searches for
violations of . For example, if  is the identification assertion
(id Port number, of ), then () = x, x, x1, x2.Port(x)Port(x)
x = x  number(x, x1)  number(x, x1)  of (x, x2)  of (x, x2).
Similarly, if  = (U)  Ti, i.e.,   Ttype, then () encodes
the negation of all disjointnesses between the range of U and each
= Ti. We are now ready to present the algorithm UnsatQuery
Tj
(Algorithm 1), which takes as input a DL-LiteA,id,den TBox T , and

Input: DL-LiteA,id,den TBox T
Output: UBCQ with inequalities
begin

return 

T \Tinc

end

PerfectRefIdC((), Tinc  Ttype)

Algorithm 1: UnsatQuery

returns the FOL query (more precisely the UBCQ with inequalities)
that we evaluate over an ABox A, whenever we want to verify the
satisfiability of the KBs K = T , A.
The algorithm UnsatQuery computes the perfect rewriting with
respect to the positive knowledge in T , i.e., Tinc  Ttype, of each
query associated by the function  to the assertions in Tdisj 
Tden  Ttype  Tfunct  Tid. By taking the union of all such perfect
rewritings, UnsatQuery(T ) encodes the negation of all disjoint-
nesses, functionalities, identifications, and denials inferred by (and
not only asserted in) the TBox T . To compute perfect rewritings,
UnsatQuery makes use of the algorithm PerfectRefIdC given in [37],
which rewrites CQs with (limited forms of) inequalities, like those
that  associates to identification assertions and functionalities.
This algorithm is a variant of PerfectRef (algorithm 6). More pre-
cisely, rewriting steps in PerfectRefIdC are exactly as in PerfectRef,
with the proviso that inequality is treated as an atomic role and inequality atoms are never rewritten, since no assertions in the TBox
involve the inequality predicate. Moreover, PerfectRefIdC does not
unify query atoms if the variables involved in the unification occur
also in inequality atoms. Obviously, if q is a CQ without inequal-
ities, then PerfectRefIdC(q, T ) = PerfectRef(q, T ). Observe that
the query returned by PerfectRefIdC is still a UBCQ with inequalities over the alphabet of T .

Termination of the algorithm UnsatQuery follows from termination of PerfectRefIdC, which is shown in [37]. The property of
UnsatQuery established by the following theorem states that satisfiability in DL-LiteA,id,den is FO-rewritable. The proof of the theorem
is given in Appendix B.
Theorem 1. A DL-LiteA,id,den KB K = T , A is unsatisfiable if and
only if DB(A) |	 UnsatQuery(T ).

The following result is then a direct consequence of the above

theorem and of Proposition 1.

Proposition 2. KB satisfiability and query answering in
DL-LiteA,id,den are FO-rewritable, and are therefore in AC0 in data
complexity.
An easy consequence of Theorem 1 is that a DL-LiteA,id,den
KB of the form T , is always consistent. Furthermore, a
T -inconsistent set V  A exists in K = T , A if and only if
DB(A) |	 UnsatQuery(T ). This property leads us to formalize the
notion of K-clash, which will be useful in the following.
Definition 5. If K = T , A is a DL-LiteA,id,den KB, then a set
of ABox assertions V  A is a K-clash if there exists a q 
UnsatQuery(T ) such that V  images(q, A).

We conclude this section with an example illustrating the

whole procedure for checking satisfiability of a DL-LiteA,id,den KB.
Example 3. Let K = T , A be a DL-LiteA,id,den-KB, where T is
the TBox of Example 1, and A is the ABox formed by the following
assertions:

PortIn(p1),

PortOut(p1),

connectedTo(p1, p2).

In words, A states that p1 is both an incoming and an outgoing
port, and that p1 is connected to p2. It is immediate to verify that

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

K is inconsistent, since the assertion PortIn  PortOut in T is
contradicted by the assertions PortIn(p1) and PortOut(p1).
For this example, let us focus only on the following two
assertions in T \ Tinc.
1 = PortIn  PortOut;
2 = x, y, z, k, w, v.PortOut(x)  of (x, y)  connectedTo(x, z)
 of (z, k)
 PortIn(w)  of (w, y)  connectedTo(w, v)
 of (v, k)  .

The queries associated to 1 and 2 by the function  are:
(1) = x.PortIn(x)  PortOut(x);
(2) = x, y, z, k, w, v.PortOut(x)  of (x, y)

 connectedTo(x, z)  of (z, k)
 PortIn(w)  of (w, y)  connectedTo(w, v)
 of (v, k).

UnsatQuery(T ) contains, among others, the following queries:
q1 = x, y, z, k, w, v.PortOut(x)  of (x, y)  connectedTo(x, z)
 of (z, k)  PortIn(w)  of (w, y)  connectedTo(w, v)
 of (v, k);
 PortIn(w)  of(w, y)  connectedTo(w, z);

q2 = x, y, z, w.PortOut(x)  of(x, y)  connectedTo(x, z)
q3 = x, y.PortIn(x)  PortOut(x)  connectedTo(x, z);
q4 = x.PortIn(x)  PortOut(x).
The first three queries come from the rewriting of (2). In
particular,
 q1 coincides with (2).
 q2 is obtained from q1 by various iterations of the algorithm
PerfectRef, which proceeds in this way4: (i) it first unifies
atoms of (z, k) and of (v, k), and thus substitutes v with z
throughout the query, and k with _ , since in the resulting atom
k is unbound; (ii) then, it rewrites the atom of (z, _ ) through
the assertions Port  of , thus obtaining the atom Port(z);
(iii) after, it rewrites Port(z) into connectedTo(_ , z), where _
denotes a new unshared existentially quantified variable in the
query, by applying the assertion connectedTo  Port; (iv)
finally, it unifies connectedTo(_ , z) with connectedTo(w, z), thus
returning q2.
 q3 is obtained from q2 by first unifying atoms of (x, y) and
of (w, y), and then applying Port  of (as in step (ii) above),
and subsequently PortOut  Port, thus returning q3.
The query q4 coincides instead with (1). Such a query is not
touched by the algorithm PerfectRef, since no inclusion assertions
exist in Tinc having PortIn or PortOut in their right-hand side, and
no unifications can be performed on it.

It is easy to verify that, for the queries considered in this

example, we have:

DB(A) |	 q1; DB(A) |	 q2;
DB(A) |	 q3; DB(A) |	 q4.

4. The ABox repair semantics

In this section we present our first proposal of inconsistencytolerant semantics for DL knowledge bases. Our aim here is to allow
a DL KB K to be interpreted with a non-empty set of models even in
the case where K is inconsistent under the classical FOL semantics.
As already said, the inconsistency-tolerant semantics we propose is based on the notion of repair, borrowed from the database
literature [18,38]. Intuitively, given a possibly inconsistent DL KB
K = T , A, a repair Ar for K is an ABox such that the KBT , Ar
is consistent under the FOL semantics, and Ar minimally differs from A. Thus a repair is a T -consistent ABox which is as
close as possible to A. Different notions of minimality may give
rise to different inconsistency-tolerant semantics. Here, we consider as repairs of K the T -consistent ABoxes that can be obtained
by eliminating from A as few assertions as possible in order to
gain consistency. In other terms, a repair is an inclusion-maximal
T -consistent subset of A, as formalized in the following definition.
Definition 6. Let K = T , A be a DL-LiteA,id,den KB. An ABox repair
(AR-repair) of K is a set A

 Mod(T , A
) = .
 no A
It is easy to see that more than one AR-repair of a KB K may exist.
Moreover, there is always a finite number of AR-repairs, and each
AR-repair is finite, since A is finite. In what follows, we denote by
AR-Set(K) the set of AR-repairs of K.

 of ABox assertions such that:

  A, and Mod(T , A

 exists such that A

  A,

) = ,

We now present an example illustrating the notion of AR-repair.
Example 4. Consider K = T , A, where T is the TBox from
Example 1, and A is the ABox formed by the following assertions:

PortIn(p1),
of (p1, p2),

PortOut(p1),
Device(d).

connectedTo(p1, p2),

It is easy to verify that the ABox A is T -inconsistent, as it contains
the following K-clashes (cf. Definition 5):
V1 = {PortIn(p1), PortOut(p1)}
V2 = {connectedTo(p1, p2), of(p1, p2)}
V3 = {PortIn(p1), PortOut(p1), connectedTo(p1, p2)}
where: V1 and V3 are the K-clashes of Example 3, and V2 is
obtained from the query (Port  Device).

According to Definition 6, the set AR-Set(K) consists of the

following T -consistent sets of ABox assertions:
AR-rep1 = {PortIn(p1), connectedTo(p1, p2), Device(d)}
AR-rep2 = {PortOut(p1), connectedTo(p1, p2), Device(d)}
AR-rep3 = {PortIn(p1), of(p1, p2), Device(d)}
AR-rep4 = {PortOut(p1), of(p1, p2), Device(d)}.

Hence, we conclude that the KB K is inconsistent since the
assertions in A violate under T both the negative inclusion 1,
|	 q4, and the denial 2 witnessed by
witnessed by DB(A)
DB(A) |	 q3. Finally, the following sets are two K-clashes:
{PortIn(p1), PortOut(p1)}
{PortIn(p1), PortOut(p1), connectedTo(p1, p2)}.

4 In fact, q2 can be obtained from q1 in various ways, and we just describe here
one of such possible options.

The following proposition immediately follows from the fact
that Mod(T ,) =  for any DL-LiteA,id,den TBox T (cf. Theorem 1).
This implies that the set of (inclusion-maximal) T -consistent
subsets of any ABox is always non-empty.
Proposition 3. If K = T , A is a (possibly inconsistent)
DL-LiteA,id,den KB, then AR-Set(K) = .

With the notion of AR-repair in place, we can present the ABox

Repair semantics (AR-semantics).

Definition 7. Let K = T , A be a possibly inconsistent
DL-LiteA,id,den KB. The set of ABox Repair Models, or simply
AR-models, of K, denoted ModAR(K), is defined as follows:
ModAR(K) = {I | I  Mod(T , Ai), for some Ai  AR-Set(K)}.
The next proposition easily follows from Definitions 6 and 7.
Proposition 4. If T , A is a consistent DL-LiteA,id,den KB, then
ModAR(T , A) = Mod(T , A).

We notice that the AR-semantics coincides with the looselysound semantics studied in [19] in the context of inconsistent and
incomplete databases.

The following notion of consistent entailment is the natural

generalization of classical entailment to the AR-semantics.

Definition 8. Let K be a possibly inconsistent DL-LiteA,id,den KB,
and let  be a first-order sentence. We say that  is AR-consistently
entailed, or simply AR-entailed, by K, written K |	AR , if I |	 
for every I  ModAR(K).
In other words, we say that K |	AR  if for every AR-repair
Ar  AR-Set(K), the consistent KB T , Ar entails .
Example 5. Consider the DL KB K = T , A presented in Example 4, and the following BCQs:

q1 : xPort(p1)  of (p1, x)  Device(x);
q2 : xPort(x)  of (x, d)  Device(d).

q1 asks for the existence of a device to which port p1 belongs, and
q2 asks for the existence of a port which belongs to the device d.
By looking at the set AR-Set(K) presented in Example 4, one can
easily verify that K AR-entails both q1 and q2.

We next introduce the notion of minimal inconsistent set and

provide a theorem characterizing AR-entailment.
Definition 9. Let T , V be a DL-LiteA,id,den KB. We say that V is
minimal T -inconsistent if V is T -inconsistent, and there is no
proper subset V of V such that V is T -inconsistent.
In other words, the above definition says that for each assertion  in a minimal T -inconsistent set V , the ABox V \ {} is
T -consistent. Given a KB K = T , A, we denote by minIncSets
(K) the set of minimal T -inconsistent sets contained in A.
It is worth noticing that minimal inconsistent sets correspond
to justifications (also known as minAs) [3942]: in particular,
a minimal T -inconsistent sets contained in A corresponds to
an explanation (or minimal justification) of the inconsistency of
T , A at the extensional level. We will further analyze this aspect
in Section 9.
Theorem 2. If K = T , A is a possibly inconsistent DL-LiteA,id,den
KB, and   A, then there exists an AR-repair A
 of K such that

 if and only if there exists V  minIncSets(K) such that   V .
Proof. () From Definition 6 it follows that A
  {} is
T -inconsistent. If it is also a minimal T -inconsistent set, then the
{}
claim is directly proved. Otherwise, there must exist V  A
 does not contain  and
that is minimal T -inconsistent. Since A
obviously does not contain any T -inconsistent set, it follows that
V contains , and therefore the claim is shown also in this case.
() Towards a contradiction, suppose that every AR-repair of
K contains . Since V  minIncSets(K), we have that V \ {}
is T -consistent. We have two possible cases: (i) V \ {} is an
AR-repair, but this contradicts the assumption above; or, (ii) there
 contains
exists an AR-repair A
  V , which is a
 by the hypothesis, which means that A
contradiction. 

 such that V \ {}  A

, but A

We point out that, even though in the above definitions,
properties, and theorems we refer to DL-LiteA,id,den, the results of
this section apply also to more general languages. More precisely,
Definitions 69, Proposition 3, and Theorem 2 (limited to KBs
with satisfiable TBoxes), as well as Proposition 4 apply also to KBs
specified in a different DL L, provided that the semantics for L
adopts the unique name assumption.

5. Query answering in DL-LiteA,id,den under the AR-semantics

In this section we deal with the problem of answering UBCQs
posed to DL-LiteA,id,den KBs under the AR-semantics. We first notice
that from the results presented in [43, Theorems 1 and 2], we
know that UBCQ entailment is coNP-complete in data complexity
under the AR-semantics for DL-LiteR and DL-LiteF , two DLs of
the DL-Lite family which extend DL-Litecore respectively with role
hierarchies and functionality assertions [3]. Both such DLs are
indeed subsumed by DL-LiteA,id,den, and therefore the lower bound
for data complexity given in [43] applies also to DL-LiteA,id,den.

Here, we strengthen this result, and show that instance
i.e., answering single-atom ground queries under
checking,
AR-semantics is already coNP-hard in data complexity even if the
KB is expressed in DL-Litecore, i.e., the least expressive logic of the
DL-Lite family.

i , where every lj

Theorem 3. Let K be a DL-Litecore KB and let  be an ABox
assertion. Deciding whether K |	AR  is coNP-hard with respect to
data complexity.
Proof. We exhibit a reduction from unsatisfiability of a 3-CNF to
CQ entailment in DL-Litecore under AR-semantics.
Let  be a 3-CNF of the form c1    cn with ci = l1

i  l3
l2
i is a literal from a set of propositional
variables {x1, . . . , xm}. Given a literal l, let s(l) denote the sign of
l, i.e., s(l) = t if l is a positive literal, and s(l) = f otherwise;
moreover, let v(l) denote the propositional variable occurring in
the literal l.
We define the following DL-Litecore TBox T :
T = {R  Unsat, R  L
t , R  L
and the following ABox A:
A = {R(a, ci) | 1  i  n}  {Ls(lj

i), ci) | 1  i  n, 1  j  3}.
We now prove that T , A|	AR Unsat(a) if and only if  is
unsatisfiable.
First, if  is satisfiable, then there exists an interpretation J for
{x1, . . . , xm} such that J is a model for . Now consider the ABox

f , Lt  Lf}

(v(lj

i)

 = {Lt (xj, ci) | Lt (xj, ci)  A and J(xj) = true}

{Lf (xj, ci) | Lf (xj, ci)  A and J(xj) = false}.

 is satisfiable. Moreover, since J is
It is immediate to see thatT , A
a model for , for every conjunct ci of , there exists a propositional
variable xj such that either the literal xj occurs positively in ci and
J(xj) = true, or xj occurs negatively in ci and J(xj) = false. This
implies that, for every 1  i  n, A
  {R(a, ci)} is T -inconsistent.
Then, due to the presence of Lt  Lf in T , it immediately
follows that, for every assertion  of the form Lt (xj, ci) or Lf (xj, ci)
such that   A \ A
  {} is T -inconsistent. Therefore,
 is an inclusion-maximal T -consistent subset of A. And since

 |	 Unsat(a), it follows that T , A  |	AR Unsat(a).
T , A

Next suppose T , A  |	AR Unsat(a). Then there exists A
 is an inclusion-maximal T -consistent subset of A and
such that A
 |	 Unsat(a). Now let J be the interpretation of{x1, . . . , xn}
T , A
defined as follows: J(xj) = true if there exists Lt (xj, ci)  A
 for
some i, and J(xj) = false if there exists Lf (xj, ci)  A
 for some

, A

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

 |	 Unsat(a), it follows that no assertion
i. Now, since T , A
 is inclusion-maximal
of the form R(xj, ci) is in A
T -consistent, it follows that, for every 1  i  n, there exists an
 for some j. In turn,
assertion of the form Lt (xj, ci) or Lf (xj, ci) in A
this immediately implies that the conjunct ci of  is satisfied in J,
therefore J is a model of , which proves the claim. 

, and since A

We notice that Theorem 3 corrects a wrong result presented
in [43], which asserts tractability of instance checking under
AR-semantics for DL-LiteF and DL-LiteR, both subsuming DL-Litecore.
In fact, the technique presented in [43] is able to properly manage
inconsistencies arising from the presence of functional assertions
only, i.e., it is correct for DL-Litecore without negative inclusions, but
enriched with functionalities on roles.

The following theorem provides a matching upper bound for
DL-LiteA,id,den, thereby establishes the exact complexity of query
answering for this logic under the AR-semantics.
Theorem 4. Let K = T , A be a DL-LiteA,id,den KB, and let Q be a
UBCQ. Deciding whether K |	AR Q is coNP-complete with respect to
data complexity.

Proof. coNP-hardness follows from Theorem 3. To prove membership in coNP we provide the following algorithm
Algorithm AR-Entailment(K, Q )
Input: DL-LiteA,id,den KB K = T , A, UBCQ Q
Output: true or false
begin

  {} is T -inconsistent, and

  A such that

 is T -consistent, and
, A

if there exists A
(1) A
(2) for each   A \ A
 |	 Q
(3) T , A
then return false
else return true

end

By Definition 7, we know that if K |	AR Q , then T , A

and show that AR-Entailment(K, Q ) returns true if and only if
K |	AR Q .
 |	 Q
  AR-Set(K). Since conditions (1) and (2) together
for each A
  AR-Set(K), it is immediate to verify that, if
check that A
K |	AR Q , then AR-Entailment(K, Q ) returns true. Conversely, if
  AR-Set(K) exists
AR-Entailment(K, Q ) returns true, then no A
such that T , A
 |	 Q . By Definition 7 it follows that I |	 Q for
each I  ModAR(K), i.e., K |	AR Q .
From the algorithm AR-Entailment, it directly follows that
the problem of establishing whether K |	AR Q , which is the
complement of our problem, can be carried out by guessing an
  A, and checking conditions (1)(3). Proposition 2
ABox A
implies that steps (1) and (3) can be carried out in polynomial
time (in fact in AC0), and therefore we easily conclude that the
entire check is polynomial. Thus, K |	AR Q can be checked by an
NP algorithm, which proves the claim. 

The computational complexity results given in this section
show that there is no hope of finding interesting cases for which
conjunctive query answering is tractable in data complexity under
the AR-semantics. Indeed, we get intractability even if we reduce
to the least expressive DL-Lite logic, i.e., a very simple DL, and
consider only instance checking,
i.e., a very limited form of
query answering. The only mentioned tractable case, i.e., instance
checking over DL-Litecore KBs without negative inclusions, has very
limited expressivity both in the KB and in the query language, thus
it seems to be not suited for real-world applications.

6. The intersection ABox repair semantics

Towards the definition of practical solutions to the treatment
of inconsistencies in DL KBs, in this section we introduce a new
semantics, called Intersection ABox Repair (IAR) semantics, which
is an approximation of the AR-semantics given in Section 4.

In a nutshell, this semantics is based on a new notion of
repair obtained by following the WIDTIO (When In Doubt Throw It
Out) principle, proposed in the area of belief revision and update
[20,44]. More precisely, it allows us to deal with a single repair, the
intersection of all the AR-repairs of the KB, rather than the multiple
repairs that may exist under the AR-semantics.

At the end of this section we will show that answering unions of
conjunctive queries over a DL-LiteA,id,den KB under such semantics
is tractable in data complexity.
Definition 10. Let K = T , A be a possibly inconsistent
DL-LiteA,id,den KB. The Intersection ABox Repair (or IAR-repair) of K,
denoted by IAR-Repair(K), is defined as

IAR-Repair(K) = 

Ai.

AiAR-Set(K)

Then, the set of IAR-models of K, denoted ModIAR(K), is defined as
follows:

ModIAR(K) = Mod(T , IAR-Repair(K)).

Analogously to what we have done for the AR-semantics, we
give below the notion of consistent entailment under the IAR-
semantics.

Definition 11. Let K be a possibly inconsistent DL-LiteA,id,den KB,
and let  be a first-order sentence. We say that  is IAR-consistently
entailed, or simply IAR-entailed, by K, written K |	IAR , if I |	 
for every I  ModIAR(K).
Example 6. Let K = T , A be the KB presented in Example 4.
According to Definition 10, and considering the set AR-Set(K)
presented in Example 4, we have:
IAR-Repair(K) = {PortIn(p1), connectedTo(p1, p2), Device(d)}

{PortOut(p1), connectedTo(p1, p2), Device(d)}
{PortIn(p1), of (p1, p2), Device(d)}
{PortOut(p1), of (p1, p2), Device(d)}

= {Device(d)}

and then:

ModIAR(K) = Mod(T , IAR-Repair(K))

= Mod(T ,{Device(d)}).

We point out that in computing IAR-Repair(K) all the knowledge
about the fact that p1 and p2 are ports is lost, while we preserve the
knowledge about the device d. Indeed, if we consider the BCQs q1
and q2 of Example 5, we have that K  |	IAR q1 and K |	IAR q2.

Next we discuss three relevant properties of the IAR-semantics.
The first property states that the IAR-semantics is a sound
approximation of the AR-semantics, in the sense that, for any
knowledge base K, every interpretation that is a model of K
according to the AR-semantics is also a model of K according to
the IAR-semantics.
Theorem 5. If K = T , A is a DL-LiteA,id,den KB, then, ModAR(K)
 ModIAR(K).

Proof. As stated by Proposition 3, it holds that AR-Set(K) = .
Since IAR-Repair(K) is the intersection of all Ai  AR-Set(K),
clearly, for each Ai  AR-Set(K) we have that IAR-Repair(K) 
Ai, and since the logic DL-LiteA,id,den is monotonic, we have that for
each Ai  AR-Set(K), Mod(T , Ai)  Mod(T , IAR-Repair(K)).
Finally, since by definition ModIAR(K)=Mod(T , IAR-Repair(K)),
and ModAR(T , A) is the union of all the models of the various
AR-repairs, it follows that ModAR(T , A)  ModIAR(T , A). 
The above theorem clearly implies that the logical consequences of K, and thus also the answer to queries over K, under the IAR-semantics are contained in those obtained under the
AR-semantics. Conversely, as Examples 5 and 6 show (cf. query q1),
there are sentences entailed by a KB K under the AR-semantics
that are not entailed by K under the IAR-semantics.

 |	 ;

  A such that:

The second property of the IAR-semantics that we discuss
characterizes the notion of IAR-entailment, and will be used in the
next sections.
Theorem 6. Let K = T , A be a possibly inconsistent
DL-LiteA,id,den KB, and let  be a first-order sentence. Then K |	IAR 
if and only if there exists A
(i) T , A
V =
(ii) there is no minimal T -inconsistent set V in A such that A
Proof. () Let A
AiAR-Set(K) Ai. Suppose that K |	IAR .
From Definition 11 we have that T , A
. Clearly,
  Ai for each Ai  AR-Set(K). Theorem 2 guarantees that there
is no minimal T -inconsistent set V in A such that   V . This
 is a subset of A for which both condition (i) and (ii)
means that A
holds. () Let A
 |	  and such that for
  A such that T , A
every minimal T -inconsistent set V  A we have that A
V = .
Again, from Theorem 2 we have that A
AiAR-Set(K) Ai. So,
AiAR-Set(K) Ai |	 , which means
since T , A
that K |	IAR . 
 mentioned in Theorem 6, we have
  IAR-Repair(K), and condition (ii) tell us that every 
that A
belonging to the IAR-Repair(K) does not belong to any minimal
T -inconsistent set.

 |	 , then T ,

 |	 . Let   A

Notice that for each A

Moreover, analogously to what we have said at the end of
Section 4 for the AR-semantics, we point out that the definitions
of IAR-repairs and IAR-entailment can be generalized to any DL
language L, and that both Theorems 5 and 6 apply also to KBs
specified in L, provided that the semantics for L adopts the unique
name assumption, and the KBs considered have a satisfiable TBox.
Finally, the third property of the IAR-semantics states that the
IAR-repair of a DL-LiteA,id,den knowledge base can be computed
in polynomial time with respect to the size of the ABox. Indeed,
we conclude this section by presenting a PTIME algorithm for
computing the IAR-repair of a DL-LiteA,id,den knowledge base. In
order to present the algorithm, we need to introduce the notion
of the size of a disjointness, functionality, denial or identification
assertion as follows: (i) the size of every disjointness assertion
is 2; (ii) the size of every functionality assertion is 2; (iii) the
size of a denial assertion  is the number of atoms occurring in
; (iv) the size of an identification assertion  is 2k, where k is
the number of occurrences of atomic concepts, atomic roles, and
attributes in . Intuitively, the size of an assertion  of the above
forms coincides with the number of atoms (excluding inequalities)
occurring in the query () which encodes the negation of 
(cf. Section 3). Given a DL-LiteA,id,den TBox T , we denote by
maxIncSize(T ) the maximum size of a disjointness, functionality,
denial or identification assertion in T . The following lemma states
that maxIncSize(T ) bounds the cardinality of a minimal set of ABox
assertions that are inconsistent with .

Lemma 1. Let K = T , A be a DL-LiteA,id,den KB. For every V 
minIncSets(K) we have that |V|  maxIncSize(T ).
Proof. The property can be easily proved by looking at the algorithm UnsatQuery (Algorithm 1), which makes use of the algorithm
PerfectRefIdC. No conjunctive query in PerfectRefIdC((), Tinc 
Ttype) has a size which is greater than the size of the CQ with inequalities represented by (), for   T \ Tinc. It follows that
the size of every disjunct of UnsatQuery(T ) is not greater than
maxIncSize(T ). Consequently, by Theorem 1, it follows that the
maximum size of every minimal T -inconsistent subset of A is
maxIncSize(T ), which proves the claim. 
We are now ready to present the algorithm Compute-IAR-
Repair (Algorithm 2) that, given a DL-LiteA,id,den KB K = T , A,
computes the IAR-repair of K.

Input: DL-LiteA,id,den KB K = T , A
Output: an ABox
begin

  A;
k = maxIncSize(T );
foreach subset S of A such that |S|  k do

if S is a T -inconsistent set, and every subset of S

obtained by removing one fact from S is T -consistent

 \ S;

then A

return A

end

Algorithm 2: Compute-IAR-Repair

Essentially,

the algorithm deletes from A all assertions
belonging to at least one minimal T -inconsistent set. In order to
single out the minimal T -inconsistent subsets of A, the algorithm
exploits Lemma 1 and only considers the subsets of A whose size
is not greater than maxIncSize(T ).

The following theorem establishes the termination and the
correctness of Compute-IAR-Repair. The proof is omitted since it
directly follows from Theorem 2 and Lemma 1.
Theorem 7. If K = T , A is a DL-LiteA,id,den KB, the Compute-
IAR-Repair(K) is the IAR-repair of K.

As for the data complexity of computing the IAR-repair of a
DL-LiteA,id,den KB, the following theorem states that this is a PTIME
task.
Theorem 8. If K = T , A is a DL-LiteA,id,den KB, then the algorithm
Compute-IAR-Repair on input K runs in polynomial time with
respect to the size of A.
Proof. First, observe that the maximum length k of an identification or denial assertion in T is of course independent of the size of
the ABox. Consequently, the number of subsets of A that are considered by the algorithm is polynomial with respect to data com-
plexity.

By Proposition 2, deciding whether a subset S of A is
T -consistent is in PTIME (in fact in AC0). Moreover, deciding whether a T -inconsistent subset S of A is a minimal
T -inconsistent set can be done by checking whether there is some
  S such that S \{} is T -inconsistent. Therefore, the algorithm
Compute-IAR-Repair on input K runs in polynomial time with respect to A. 

We observe that the above theorem immediately implies
that query answering under the IAR-semantics is also in PTIME
in data complexity.
is the ABox returned by
Indeed,
Compute-IAR-Repair(T , A), Theorem 7 tells us that, for any UBCQ
Q , K |	IAR Q iff T , A

|	 Q , and Theorem 8 together with


if A

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

Proposition 2 tells us that this can be decided in PTIME with respect
to the size of A.

In the next section, we show that we can avoid computing the
IAR-repair in order to answer queries under the IAR-semantics.
Indeed, we present a rewriting technique that shows that
answering UBCQs under the IAR-semantics in DL-LiteA,id,den is in
AC0 in data complexity.

7. Query answering in DL-LiteA,id,den under the IAR-semantics

In this section, we show that conjunctive query answering
under the IAR-semantics in DL-LiteA,id,den is FO-rewritable. We
notice that this property is particularly interesting, since it allows
us to obtain the consistent answers to a query without the need
to compute the IAR-repair of the inconsistent KB over which the
query is issued. Also, by virtue of this result, we can rely on
a framework in which inconsistency-tolerant query answering
in DL-LiteA,id,den has the same complexity as standard query
answering under FOL semantics for this logic.

We start by providing the formal definition of FO-rewritability
of query answering under the IAR-semantics, which is the natural
generalization of the notion of FO-rewritability under classical DL
semantics given in Definition 4.

Definition 12. Query answering in a DL L is FO-rewritable under
IAR-semantics, if for every TBox T expressed in L and every query
q over T , one can effectively compute a FOL query qr over T such
that, for every ABox A,T , A|	IAR q if and only if DB(A) |	 qr. We
call qr the IAR-perfect FOL rewriting (or simply IAR-perfect rewriting)
of q w.r.t. T .

7.1. Overview of the query rewriting technique

Our technique can be summarized as follows. Given a UBCQ
Q over a DL-LiteA,id,den TBox T , we first rewrite Q ignoring
possible inconsistencies. To this aim, we make use of the algorithm
PerfectRef, which allows us to obtain a perfect rewriting Qr of Q
w.r.t. T under the standard FOL semantics (cf. Section 2). We notice
that, by definition of perfect rewriting, and by definition of image
of a query in an ABox (cf. Section 2.3), T , A |	 Q if and only
if DB(A) |	 Qr, i.e., if and only if there is a CQ qr  Qr that has
an image in A, i.e., such that one of the patterns represented by
qr (ground instantiation of qr) appears in A. Thus, T , A|	IAR q
if and only if there is a CQ qr  Qr such that at least one of
the patterns represented by qr appears in the intersection of all
AR-repairs of T , A. Therefore, to properly take inconsistencies
into account, the problem we have to solve is as follows: given a
query qr  Qr, does one of the patterns represented by qr appear in
the intersection of all AR-repairs of T , A? To solve this problem
we need to address two issues:
 How do we filter out patterns that cannot contribute to
answer qr because they do not appear in the intersection of all
AR-repairs of T , A?
 How do we make sure that we consider all the relevant patterns
represented by a query qr  Qr?
To address the first issue, we have to filter out those patterns
that are corrupted by at least one inconsistency. We know
from Theorem 6 that such patterns are those with a non-empty
intersection with a minimal T -inconsistent set in A. This means
that, among the patterns represented by qr  Qr, we have to
  V =  for some
disregard those patterns A
V  minIncSets(T , A). We therefore further rewrite each atom
g of qr into a FOL formula gr such that, for any substitution  from
variables of g to constants in C such that  (g) is an image of
g in A, DB(A) |	  (gr ) if only if  (g) does not belong to any

 such that A

minimal T -inconsistent set in A. To obtain this inconsistencyaware component of the rewriting, we devise an algorithm, called
IncRewrIAR that, given a CQ q, adds to each atom g  q the
rewriting gr.

To address the second issue, since the check that a ground atom
from qr does not belong to a minimal T -inconsistent set in A is
done by checking that the atom does not appear in an image of a
conjunctive query possibly with inequalities (coming from denial
and identification assertions), we have to make sure that the atom
does not have incomplete knowledge about the inequality of its
terms. To this end, instead of computing the perfect rewriting of Q
under the IAR-semantics starting from PerfectRef(Q , T ), we start
from Saturate(PerfectRef(Q , T )), where Saturate is the algorithm
that takes care of this issue. In particular, Saturate takes as input a
UBCQ Q , and rewrites it into the union of all its possible inequalitybased saturations, where a saturation of a query is obtained by
choosing the pairs of variables to equate, and then adding an
inequality atom x = y for each pair of variables that have not been
equated.

In the following we first describe the algorithm Saturate, then
we present the algorithm IncRewrIAR and all the sub-routines
it uses, and finally we illustrate the overall query rewriting
algorithm.

7.1.1. The algorithm Saturate

In this subsection, we illustrate the algorithm Saturate, whose
basic idea is to rewrite a UBCQ into an equivalent UBCQ containing
disjuncts, in which different variables denote different objects or
values. This can be obtained by simply substituting each CQ in the
original query with an equivalent UCQ with inequalities, each one
obtained by equating a subset of variables in q, and imposing that
the remaining variables are not equal. To formalize this process we
need the following preliminary definition.
Given a Boolean query q, we say that a term t occurs in an object
position of q if q contains an atom of the form A(t), P(t, t), P(t, t),
or U(t, t), whereas we say that t occurs in a value position of q if q
contains an atom of the form U(t, t) or Ti(t).

Given two different terms t1 and t2 occurring in a query q, we
say that t1 and t2 are compatible in q if at least one of t1 and t2 is a
variable, and one of the following conditions holds: (i) both t1 and
t2 appear only in object positions of q or, (ii) both t1 and t2 appear
only in value positions of q.

We now present the algorithm Saturate that takes as input a
UBCQ with inequalities Q and returns a UBCQ with inequalities
that we call the inequality saturation of Q . In the algorithm,
we represent a UBCQ with inequalities as a set of BCQs with
inequalities. Saturate(Q ) first computes the set Q  by unifying
compatible terms in each query q  Q in all possible ways; then,
for any query q in Q  and for each pair of terms t1 and t2 in q that
are syntactically different and compatible, it adds the inequality
atom t1 = t2 to q. In the algorithm q[t1/t2] denotes the query
obtained by replacing in q every occurrence of the term t1 with the
term t2.

Example 7. Let T be the DL-LiteA,id,den TBox presented in Example 1. Consider the following queries belonging to UnsatQuery(T ).
q1 = x, y, z.Port(x)  Port(y)  of(x, z)  of(y, z)
 connectedTo(x, y);
q2 = x, y, z.of(x, z)  of(y, z)  connectedTo(x, y);
q3 = x.connectedTo(x, x).

It is easy to see that Saturate(q1  q2  q3) is the disjunction of

the following queries:

Input: a UBCQ with inequalities Q
Output: a UBCQ with inequalities
begin
Q   ;
while Q = Q  do

Q   Q ;
foreach q  Q do

foreach pair of different terms t1 and t2 in q do

if t1 = t2 does not occur in q and
t1 and t2 are compatible in q
then Q  Q  {q[t1/t2]};

Q   ;
foreach q  Q  do

foreach pair of different terms t1 and t2 that are

compatible in q do
q  q  (t1 = t2);

Q   Q   {q};

return Q 

end

Algorithm 3: Saturate

 connectedTo(x, y)  x = y  x = z  y = z;
connectedTo(x, y)  x = y;
 connectedTo(x, y)  x = y;

1 = x, y, z.Port(x)  Port(y)  of(x, z)  of(y, z)
q1
1 = x, y.Port(x)  Port(y)  of(x, y)  of(y, y)
q2
1 = x, y.Port(x)  Port(y)  of(x, x)  of(y, x)
q3
1 = x, z.Port(x)  of(x, z)  connectedTo(x, x)  x = z;
q4
1 = x.Port(x)  of(x, x)  connectedTo(x, x);
q5
2 = x, y, z.of(x, z)  of(y, z)  connectedTo(x, y)
q1
2 = x, y.of(x, y)  of(y, y)  connectedTo(x, y)  x = y;
q2
2 = x, y.of(x, x)  of(y, x)  connectedTo(x, y)  x = y;
q3
2 = x, z.of(x, z)  connectedTo(x, x)  x = z;
q4
2 = x.of(x, x)  connectedTo(x, x)
q5
3 = x.connectedTo(x, x).
q1

 x = y  x = z  y = z;

Termination of Saturate(Q ) is guaranteed by the fact that Q is
a disjunction of a finite number of BCQs with inequalities in which
there is a finite number of atoms and terms. The next lemma shows
that the process applied by Saturate(Q ) to a UBCQ Q does not affect
the result of evaluating Q .

Lemma 2. Let A be an ABox, and let Q be a UBCQ with inequalities.
Then, DB(A) |	 Q if and only if DB(A) |	 Saturate(Q ).
Proof. Let q be a BCQ with inequalities in Q . For each pair of t1 and
t2 terms in Q , the following cases are conceivable:
(i) t1 and t2 are two variables compatible in q. In this case the
algorithm first adds to Q a new query q obtained from q by
unifying t1 and t2, and then transforms the query q into q=
obtained by adding the inequality atom t1 = t2. Since q 
q  q=, the claim follows.
(ii) t1 and t2 are not compatible in q. In this case the algorithm
transforms the query q into q= by adding the inequality atom
t1 = t2 to q. Since t1 and t2 are not compatible in q, it follows
that they are two different constants, or one of the two occurs
in an object position in q and the other one occurs in a value
position in q. Since for every interpretation I we have that: (1)
O  V = ; (2) for every pair of different constants c1 and

c2 in O, cI
2 ; and (3) for every pair of different constants
v1 and v2 in V , val(v1) = val(v2), we conclude that t1 and t2
are always interpreted as different in I. Hence q  q=, and the
claim follows. 

1 = cI

Note that as a consequence of Lemma 2, we have that a
DL-LiteA,id,den KB T , A is unsatisfiable if and only if DB(A) |	
Saturate(UnsatQuery(T )), and DB(A) |	 PerfectRef(Q , T ) if and
only if DB(A) |	 Saturate(PerfectRef(Q , T )).

7.2. The algorithm IncRewrIAR

The goal of this subsection is to present the algorithm
IncRewrIAR. As we said before, given a CQ q, and a TBox T ,
IncRewrIAR adds to each atom g  q the FOL formula gr that ensures that, for any ABox A, such an atom does not belong to any
minimal T -inconsistent set in A.
The basic building block of
IncRewrIAR is the algorithm
MinIncSet, that, given an atom g  q, builds a FOL formula that
checks whether there exists a minimal T -inconsistent set in A
that includes g. Obviously, IncRewrIAR will use the negation of the
formula computed by MinIncSet.

In turn, the algorithm MinIncSet relies on another algorithm,
called MinUnsatQuery, that computes a FOL query whose evaluation over the interpretation DB(A) characterizes all sets of facts
in the ABox A that form a minimal T -inconsistent set. In the fol-
lowing, we first describe the algorithm MinUnsatQuery, and then
we go back to the definition of both MinIncSet and IncRewrIAR.

7.2.1. The algorithm MinUnsatQuery
As shown in Section 3, a DL-LiteA,id,den KB T , A is inconsistent
if and only if there is at least one query q  UnsatQuery(T )
such that DB(A) |	 q (cf. Theorem 1). As already mentioned,
we call every image of each such query q in A a K-clash. Now,
one may wonder whether a K-clash corresponds to a minimal
T -inconsistent set (and vice-versa), so that we can directly
exploit UnsatQuery to obtain the set minIncSets(K). The following
example shows that, in general, this is not the case.

Example 8. Let T be the DL-LiteA,id,den TBox presented in Example 1. We focus on the following denial assertion in T .
x, y, z.(Port(x)  Port(y)  of (x, z)  of (y, z)

 connectedTo(x, y)  ).

Consider the following ABox:
A = {Port(p1), Device(d1), of (p1, d1), connectedTo(p1, p1),

Port(p2), of (p2, d1), Port(p3), of (p3, d1),
connectedTo(p2, p3)}.

It is not difficult to verify that the DL-LiteA,id,den KB K = T , A is
not consistent. Indeed, the set of queries UnsatQuery(T ) contains,
among others, the following Boolean queries:
q1 = x, y, z.Port(x)  Port(y)  of(x, z)  of(y, z)
connectedTo(x, y);
q2 = x, y, z.of(x, z)  of(y, z)  connectedTo(x, y);
q3 = x.connectedTo(x, x)
from which we obtain the following K-clashes:

connectedTo(p2, p3)};

V1 = {Port(p2), of (p2, d1), Port(p3), of (p3, d1),
V2 = {Port(p1), of (p1, d1), connectedTo(p1, p1)};
V3 = {of (p2, d1), of (p3, d1), connectedTo(p2, p3)};
V4 = {of (p1, d1), connectedTo(p1, p1)};
V5 = {connectedTo(p1, p1)}.

It is easy to see that only the sets V3 and V5 are minimal
T -inconsistent sets.

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

The following theorem gives the condition under which a

K-clash is a minimal T -inconsistent in A.
Lemma 3. Let K = T , A be an inconsistent DL-LiteA,id,den KB, and
let V be a K-clash. Then V  minIncSets(K) if and only if for every
proper subset V of V , and every query q  UnsatQuery(T ), we have
that DB(V) |	 q.
Proof. () Let V  minIncSets(K). Suppose, by way of contradic-
tion, that there exists a query q  UnsatQuery(T ) and a proper
subset V of V , such that DB(V) |	 q. From Theorem 1 it follows
that V is a T -inconsistent set, but this contradicts the fact that
V  minIncSets(K).
() Let V be a K-clash such that for every V  V and for
every q  UnsatQuery(T ), DB(V) |	 q. Towards a contradic-
tion, suppose that V  minIncSets(K). Since V is a T -consistent
set, we conclude that there is a proper subset V of V that is
T -inconsistent. From Theorem 1 it follows that there exists a query
q in UnsatQuery(T ) such that DB(V) |	 q. Hence, we have a
contradiction. 

Based on the above results, we present, in this section, the
algorithm MinUnsatQuery which, starting from the set of queries
computed by the algorithm UnsatQuery, computes a new set of
Boolean queries. Intuitively, our goal is to design the algorithm in
such a way that the resulting UBCQ MinUnsatQuery(T ) enjoys the
following properties:
(P1) For every Boolean query q  MinUnsatQuery(T ) and ev-
|	 q if and only if there exists in
ery ABox A, DB(A)
UnsatQuery(T ) a query q such that DB(A) |	 q. This guarantees that Theorem 1 also holds with MinUnsatQuery(T ) in
place of UnsatQuery(T ).
(P2) For every Boolean query q  MinUnsatQuery(T ) and every
ABox A, if DB(A) |	 q, then for every set of ABox assertions
V  images(q, A), and every V such that V  V , we have
that DB(V) |	 q for every q  MinUnsatQuery(T ). This
guarantees that if a query q  MinUnsatQuery(T ) is such
that DB(A) |	 q, then every image of q in A is a minimal
T -inconsistent set.

Intuitively, this is achieved by basing the algorithm on the

following two steps:
(1) executing Saturate(UnsatQuery(T )) to obtain the UBCQ Qstr,

where Qstr characterizes the T -inconsistent sets;

(2) modifying Qstr

in such a way that it characterizes only

T -inconsistent sets that are minimal.

In the next paragraphs, we provide the details of the above step 2.
For ease of exposition, we distinguish between two cases: the case
of KBs without value-domain inclusions, and the case of KBs with
value-domain inclusions.
KBs without value-domain inclusions. For the sake of exposition,
we ignore, for the moment, inconsistencies caused by valuedomain inclusions (cf. Example 2), i.e., we assume Ttype = .
Firstly, we need to introduce the notion of proper syntactical
subset of a query. Let q and q be two Boolean queries. We say that
q is a proper syntactical subset of q, written q q, if there exists
an injective function  from the variables in q to the variables in q,
such that every atom S(t) occurring in (q) occurs also in q, where
(q) denotes the query obtained by replacing every variable x in q
with (x), and an analogous injective function from q to q does not

exist. We denote with Q
str the set of queries obtained by removing
from Qstr every query q such that there exists in Qstr a query q such
that q  q.
The following example illustrates the role of the notion of

proper syntactical subset of a query.

Example 9. Consider the set of queries q1
and call it Qstr. It is easy to verify that the following hold:

3 of Example 7,

1, . . . , q1
2  q3
q3
3  q4
q1
3  q5
q1

str contains the following queries:

2  q1
q1
2  q4
q4
3  q5
q1

2  q2
q2
2  q5
q5
3  q4
q1

 x = y  x = z  y = z;

Hence, Q
2 = x, y, z.of(x, z)  of(y, z)  connectedTo(x, y)
q1
2 = x, y.of(x, y)  of(y, y)  connectedTo(x, y)  x = y;
q2
2 = x, y.of(x, x)  of(y, x)  connectedTo(x, y)  x = y;
q3
3 = x.connectedTo(x, x).
q1
Let A be the ABox of Example 8. We have that the only queries

str that evaluate to true over DB(A) are q1
3. Their images

in Q
in A are:
2 = {of (p2, d1), of (p3, d1), connectedTo(p2, p3)};
V 1
3 = {connectedTo(p1, p1)};
V 1

2 and q1

that coincide respectively with the V3 and V5 minimal
T -inconsistent sets of Example 8.

str .

We now provide a lemma showing that, if T is a TBox expressed

str for

in DL-LiteA,id,den, then, for every ABox A, we can use the set Q
checking the satisfiability of the KB T , A.
Lemma 4. Let T be a DL-LiteA,id,den TBox, and let A be an ABox. Then,
the KB T , A is unsatisfiable if and only if DB(A) |	 Q
Proof. () Since T , A is unsatisfiable, then by Theorem 1 we
get DB(A) |	 UnsatQuery(T ). Then, by Lemma 2 we get that
DB(A) |	 Qstr, where Qstr = Saturate(UnsatQuery(T )). Hence,
there is a query q  Qstr such that DB(A) |	 q. Suppose, by way of

contradiction, that DB(A) |	 Q
str . This means that for every query


str , DB(A) |	 q. It follows that q  Q
q in Q
str . This means that

str a query q such that q  q.
there exists in Q
Since DB(A) |	 q, then there exists a substitution  from
the variables in q to constants in A such that the formula  (q)
evaluates to true in the interpretation DB(A). But this means
that also  ((q)) evaluates to true in DB(A), then we have a
contradiction.


() If DB(A) |	 Q
str , then there is a query q  Q
str such that

DB(A) |	 q. Since Q
str  Qstr, then q  Qstr, and then DB(A) |	
Qstr. Finally, from Theorem 1 and Lemma 2 it follows that DB(A) |	
UnsatQuery(T ), which implies that T , A is unsatisfiable. 
The next lemma guarantees that, given a DL-LiteA,id,den KB K =

str such that DB(A) |	 q,

T , A with Ttype =  and a query q in Q
every image V of q in A is a minimal T -inconsistent set.
Lemma 5. Let K = T , A be a DL-LiteA,id,den KB with Ttype = ,

str . Then, for every V  V , where V 
and let q be a query in Q
images(q, A), and for every q  Q
Proof. Since Ttype = , then every query in q belonging to
i=1 Pi(t2
i ,
i , t5
t3
i=1 Ui(t4
i , where every Ai, Pi, and Ui are
as usual, every te
i is a term (i.e., either a constant or a variable), and
z1, . . . , zk are all the variables appearing in q. In what follows, given
a query q, we denote by atoms(q) the set of atoms occurring in q.
If K is consistent, then Lemma 4 guarantees that for every
|	 q. Hence there is no minimal
query q  Q
T -inconsistent set in A. Let K be inconsistent. The proof proceeds

UnsatQuery(T ) is of the formz1, . . . , zk.n
i ) l


str , DB(V) |	 q.

i ) h

i )m


str , DB(A)

i=1 Ai(t1

= t7

i=1 t6

by contradiction as follows. Let q be a query in Q
str such that
|	 q, and let V  images(q, A). Hence, there is a
DB(A)
substitution  from the variables in q to constants in A such that
the formula  (q) evaluates to true in the interpretation DB(V ).
Obviously, every constant occurring in q occurs also in V . Since

str  Qstr, then we have constrained t1 = t2 for each pair of

terms t1 and t2 in q. Hence, for each pair of different variables x and
y in q,  substitutes the variable x with a constant c1 in V and the
variable y with a constant c2 in V such that c1 = c2. Now, let  1
be the inverse of the function  and suppose that there is a query

q  Q
str such that DB(V) |	 q, where V is a proper subset of V .
Clearly, since  1 essentially performs a renaming of the constants
in V without unifying any constant, we have that DB( 1(V)) |	
q. But this means that there is a substitution   from the variables
in q to the terms in q such that each atom in  (q) is in atoms(q).

Moreover, since q  Q
str , from the observations above, we have
that for each pair of variables x and y in q,   substitutes the
variable x with the term t1 in q and the variable y with the term t2
in q with t1 = t2; and since V  V , then  (q)  atoms(q). Hence,
  constitutes an injective function from the variables in q to the
variables in q, such that every atom occurring in  (q) occurs also
in q and an analogous function from q to q does not exist. This
means that q  q, which contradicts that q  Q
KBs with value-domain inclusions. We now turn our attention
to the case where Ttype may be non-empty, i.e., when the TBox T
contains value-domain inclusion assertions.


str . 

We recall that value-domains are pairwise disjoint, and
inconsistency may arise because data in the ABox together with
the TBox may imply a violation of such disjointnesses. The next
example shows that the technique described in the previous
subsection does not allow us to identify minimal T -inconsistent
sets when Ttype is non-empty. Namely, Lemma 5 no longer holds.
Example 10. Let T be the TBox presented in Example 1. Specifi-
cally, here, we are interested in the following TBox assertions:

Ttype = {(number)  xsd:integer}

= {(id Port number, of )}.

Tid

In words, the assertion in Ttype states that the range of the attribute
number is restricted to be an integer, while the identification
assertion imposes no two different ports of the same device exist
having the same number. For ease of exposition, we assume to have
only xsd:integer, xsd:string, and xsd:dateTime as value-
domains.

The queries in UnsatQuery(T ) originated from the assertions
above are the following (see algorithm UnsatQuery in Section 3).
q1 = x, y, d, n.Port(x)  of(x, d)  number(x, n)
 Port(y)  of(y, d)  number(y, n)  x = y;
q2 = x, y, d, n.of(x, d)  number(x, n)  of(y, d)
 number(y, n)  x = y;
q3 = x, y.number(x, y)  xsd:string(y);
q4 = x, y.number(x, y)  xsd:dateTime(y).
Now consider the following ABox:

A = {Port(p1), of(p1, d1), number(p1, 9XK11),
Port(p2), of(p2, d1), number(p2, 9XK11)}

where 9XK11 is a value of domain xsd:string, and therefore
incoherent with respect to Ttype. Thus, the DL-LiteA,id,den KB K =
T , A is inconsistent, and the following K-clashes can be
pinpointed.

V1 = {Port(p1), of(p1, d1), number(p1, 9XK11),
Port(p2), of(p2, d1), number(p2, 9XK11)}
V2 = {of(p1, d1), number(p1, 9XK11), of(p2, d1),
number(p2, 9XK11)}
V3 = {number(p1, 9XK11)}
V4 = {number(p2, 9XK11)}.

Rn
str

 x = y  x = d  x = n  y = d  y = n  d = n;
 x = y  x = n  y = n;
 x = y  x = n  y = n;

It is easy to see that only V3 and V4 are minimal T -inconsistent
sets. However, if we apply the technique described above, we get
the following set Q
2 = x, y, d, n.of(x, d)  number(x, n)  of(y, d)  number(y, n)
q1
2 = x, y, n.of(x, y)  number(x, n)  of(y, y)  number(y, n)
q2
2 = x, y, n.of(x, x)  number(x, n)  of(y, x)  number(y, n)
q3
3 = x, y.number(x, y)  xsd:string(y);
q1
4 = x, y.number(x, y)  xsd:dateTime(y).
q1
Observe that both q1
as we said before, only for each V  images(q1
is minimal T -inconsistent.

3 evaluate to true over DB(A), although,
3, A) we have that V

2 and q1

Intuitively, in the above example the problem arises since in
q1
2 we do not consider the fact that the range of the attribute
number is xsd:integer, and therefore we single out a violation
of the identification assertion (id Port number, of ) which is not
minimal. The problem can be solved by simply adding to q1
2 an atom
imposing that the variable n is an integer, as shown below:
2 = x, y, d,n.of(x, d)  number(x, n)  of(y, d)  number(y, n)
q1
 x = y  x = d  x = n  y = d  y = n  d = n
 xsd:integer(n).

According to the above considerations, we modify our rewriting
method as follows: for each query q in Saturate(UnsatQuery(T )),
and for each atom U(t1, t2) in q, if T |	 (U)  Ti, and there exists
no atom of the form Tj(t2) in q, then we add the atom Ti(t2) to q.
The definition of MinUnsatQuery. We are now ready to present
the algorithm MinUnsatQuery (Algorithm 4). The algorithm
proceeds as follows. First, it computes the inequality saturation of
UnsatQuery(T ) through the algorithm Saturate (step 1 and step 2),

and calls Qstr the result. Then, in step 3 it computes the set Qstr
by substituting each query q  Qstr with the query obtained as
follows: for each atom U(x, y), where U is an attribute name, if
no atom Tj(y) appears in q, where Tj is a value-domain, then for
each Ti  {T1 . . . Tn}, if T |	 (U)  Ti, the algorithm builds a
new query by substituting the atom U(x, y) with the conjunction of
atoms U(x, y) Ti(y). Note that checking whether T |	 (U)  Ti
can be done through any off-the-shelf DL reasoner. Step 4 is an
optimization step in which some queries which are always false
. Finally, in step 5, the algorithm removes
are removed from Qstr
 every query q such that there exists a query q in Qstr

from Qstr
such that q q, and returns as result the set Qstr
 in step 6. By
analyzing each step of the algorithm, it is immediate to see that
the algorithm terminates when applied to a DL-LiteA,id,den TBox.

Example 11. Let us focus on the same portion of the TBox T of
Example 1 considered in Example 10. The set MinUnsatQuery(T )
contains, among others, the following queries:
2 = x, y, d,n.of(x, d)  number(x, n)  of(y, d)  number(y, n)
q1

 xsd:integer(n)  x = y  x = d  x = n  y = d
 y = n  d = n;

xsd:integer(n)  x = y  x = n  y = n;
xsd:integer(n)  x = y  x = n  y = n;

2 = x, y, n.of(x, y)  number(x, n)  of(y, y)  number(y, n)
q2
2 = x, y, n.of(x, x)  number(x, n)  of(y, x)  number(y, n)
q3
3 = x, y.number(x, y)  xsd:string(y);
q1
4 = x, y.number(x, y)  xsd:dateTime(y).
q1
Note that the above queries are those in Example 10 to which step
3 of the algorithm MinUnsatQuery is applied. 

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

/* step 1 */
/* step 2 */

Input: a DL-LiteA,id,den TBox T
Output: a UBCQ with inequalities
begin

 UnsatQuery(T );
);

Qunsat
Qstr  Saturate(Qunsat

str  Qstr;

foreach q  Q
foreach atom U(t, t) in q do


str do

/* step 3 */
if there exists no atom of the form Tj(t) in q then

foreach value-domain Ti in {T1, . . . , Tn} do
str \ {q})  {q  Ti(t)};


if T |	 (U)  Ti then


str do

str  (Q


/* step 4 */

foreach q  Q

foreach term t occurring in q do

if Ti(t) and Tj(t) occur in q, with i = j then

str  Q
str \ {q};


foreach q and q in Q

str do
if q  q then Q
str  Q

return Q


str

end

Algorithm 4: MinUnsatQuery

str \ {q};


/* step 5 */

/* step 6 */

The following lemmas show that the algorithm MinUnsatQuery
enjoys the properties (P1) and (P2) previously introduced in this
subsection.
Lemma 6. Let K = T , A be a possibly inconsistent DL-LiteA,id,den
KB. Then, DB(A) |	 MinUnsatQuery(T ) if and only if DB(A) |	
UnsatQuery(T ).

Proof. The proof can be straightforwardly derived from the one
of Lemma 4, by simply observing that for each constant c in V ,
the sentence T1(c)    Tn(c) evaluates to true under every
interpretation, and that T1(c)    Tn(c) is a contradiction. 
Note that, from the lemma above, it directly follows that
Theorem 1 also holds with MinUnsatQuery(T ) in place of
UnsatQuery(T ).

The following crucial lemma guarantees that one can use the
queries produced by MinUnsatQuery(T ) in order to compute every
minimal T -inconsistent set in A.
Lemma 7. Let K = T , A be a possibly inconsistent DL-LiteA,id,den
KB, and let q be a query in MinUnsatQuery(T ). If DB(A) |	 q, then
every image of q in A is a minimal T -inconsistent set.

Proof. The proof can be straightforwardly derived from the one
of Lemma 5, by considering Lemma 6 in place of Lemma 4 and
by observing that for each constant c in V , the sentence T1(c) 
  Tn(c) evaluates to true under every interpretation, and that
T1(c)    Tn(c) is a contradiction. 

7.2.2. The algorithm MinIncSet and the definition of IncRewrIAR

Our next goal is to describe the algorithm MinIncSet. To this
aim, we introduce the notion of compatibility between atoms.
Let S(t), S(t) be two atoms, where S is a symbol denoting an
atomic concept, an atomic role, or an attribute. We say that S(t)
is compatible with S(t) if there exists a mapping  from the
variables occurring in S(t) to the terms occurring in S(t) such that
(S(t)) = S(t) (and in this case we denote the above mapping
S(t)/S(t)). Given an atom S(t) and a query q,
 with the symbol 
we denote by CompSet(S(t), q) the set of atoms of q which are
compatible with S(t).

Then, we define MinIncSet as the algorithm that, given a
DL-LiteA,id,den TBox T and an atom S(t), returns the following FOL
query:
MinIncSet(S(t), T )

S(t)/S(t)

(q)

qMinUnsatQuery(T )CompSet(S(t),q)=

S(t)CompSet(S(t),q)

Intuitively, given a possibly inconsistent DL-LiteA,id,den KB T , A,
MinIncSet exploits the ability of MinUnsatQuery(T ) to detect all
the minimal T -inconsistent sets in A so as to compute a rewriting
of the atom S(t) that allows for deciding if there is a minimal
T -inconsistent set V in A such that DB(V ) |	 S(t). The crucial
property of MinIncSet is stated in the following lemma.
Lemma 8. Let T , A be a possibly inconsistent DL-LiteA,id,den KB,
and let S(c) be an ABox assertion. There exists a minimal T -
inconsistent set V in A such that S(c)  V if and only if DB(A) |	
MinIncSet(S(c), T ).
Proof. () Suppose that S(c) belongs to a minimal T -inconsistent
set V  A. Lemmas 6 and 7 guarantee that there exists a
query q in MinUnsatQuery(T ) such that DB(A) |	 q and that
there is an image of q in A to which S(c) belongs. This means
that there is a query q in the set computed by substituting S(c)
|	 q. Hence
to the compatible terms in q such that DB(A)
(q)) and then DB(A) |	
MinIncSet(S(c), T ).
() Let us consider MinIncSet(S(c), T ) as a set of queries. Suppose
that there is query q  MinIncSet(S(c), T ) such that DB(A) |	 q.
Let q  MinUnsatQuery(T ) be the query from which q is obtained
from. From Lemma 7 it directly follows that there exists in A a
minimal T -inconsistent set that contains S(c). 

DB(A) |	 

S(t)CompSet(S(c),q)

S(c)/S(t)

With the algorithm MinIncSet in place, we are ready to provide

the definition of algorithm IncRewrIAR.

Let T be a DL-LiteA,id,den TBox, and let q be a BCQ with

inequalities of the form

i )  m

Ai(t1

i )  h

i=0

i=0
= t8

t7

Ti(t6

z1, . . . , zk.

i )  l

i=0

Pi(t2

i , t3

Ui(t4

i , t5
i )

(1)

i=0

i=0
where every te
is a term (i.e., either a constant or a variable),

z1, . . . , zk are all the variables appearing in q, such that q contains
at least one atom not using inequality, and t7
i for any i appear
also in some atom not using inequality.

i and t8

We denote by IncRewrIAR the algorithm that, given the above q

and T , returns the following FOL query:
IncRewrIAR(q, T )= z1, . . . , zk.

i=1


i=1

i=1

i=1

Ai(t1
i )

Pi(t2

i , t3

Ui(t4

i , t5

Ti(t6
i )

 MinIncSet(Ai(t1
i )  MinIncSet(Pi(t2
i )  MinIncSet(Ui(t4

= t8

t7

i=1

i ), T )


i ), T ) 
i ), T ) 

i , t3

i , t5

Input: UBCQ Q , DL-LiteA,id,den TBox T
Output: a FOL query over T
begin

Q  = PerfectRef(Q , Tinc  Ttype);
return
Q  = Saturate(Q );
qQ IncRewrIAR(q, T )

end

Algorithm 5: IAR-PerfectRef

7.3. The overall query rewriting algorithm

We now have all the ingredients for illustrating the algorithm
IAR-PerfectRef (Algorithm 5), whose goal is to compute the perfect
rewriting of a UBCQ Q w.r.t. a DL-LiteA,id,den TBox T under the
IAR-semantics.
Using PerfectRef, the algorithm first computes the perfect
rewriting Q  of Q with respect to T (cf. Section 2). Then, the
UBCQ Q  is passed to the algorithm Saturate, producing a set Q 
of BCQs with inequalities of the form (1); as explained above, this
step is indispensable for exactly identifying, for each query atom
g, the queries in MinUnsatQuery(T ) whose images correspond to
inconsistent sets containing g. Finally, each query in the set Q  is
passed to the algorithm IncRewrIAR: the disjunction of all the FOL
queries returned by IncRewrIAR is the final FOL query returned by
the algorithm IAR-PerfectRef.

IAR-PerfectRef

Termination of

follows from the following
properties: (i) the algorithm PerfectRef terminates as shown in
[3,37]; (ii) the algorithm Saturate terminates (see Section 7.1.1);
(iii) the algorithm IncRewrIAR terminates; this follows immediately from the termination of the algorithm MinUnsatQuery. Correctness of IAR-PerfectRef is proved in the following theorem.

 |	 q, and (ii) A

) |	 q. Clearly, since A

Theorem 9. Let T be a DL-LiteA,id,den TBox, and let Q be a UBCQ.
Then, IAR-PerfectRef(Q , T ) is a IAR-perfect FOL rewriting of Q with
respect to T .
Proof. We already observed that IAR-PerfectRef(Q , T ) is a FOL
query. It remains to prove that for every ABox A, T , A|	IAR Q
if and only if DB(A) |	 IAR-PerfectRef(Q , T ).
() Let Q be a UBCQ. Suppose T , A|	IAR Q . From Theorem 6,
we have that there exists a query q  Q and a T -consistent ABox
  A, such that: (i) T , A
  V =  for
every V  minIncSets(K). Since A is T -consistent, Proposition 1
guarantees that we can use the PerfectRef algorithm for computing
its perfect FOL rewriting. Let Q  = PerfectRef(q, Tinc  Ttype).
) |	 Q . Let Q  = Saturate(Q ). Lemma 2
We have that DB(A
) |	 Q . Hence, there exists a query q in Q ,
guarantees that DB(A
  A, DB(A) |	 q. Let G be
such that DB(A
V =  for every V  minIncSets(K),
an image of q in A
also G V =  for every V  minIncSets(K). Lemma 8 guarantees
that for every assertion   G, DB(A) |	 MinIncSet(, T ). Let
Sq MinIncSet(S, T ), where S is an
atom in q built over an atomic concept, atomic role, or an attribute.
Since DB(A) |	 q and DB(A) |	 MinIncSet(, T )  G,
then DB(A) |	 IncRewrIAR(q, T ). Hence, one can conclude that
DB(A) |	 IAR-PerfectRef(Q , T ).
() Suppose that DB(A) |	 , where  = IAR-PerfectRef(Q , T ).
Let q be a FOL query corresponding to a disjunct of  such that
DB(A) |	 q (since DB(A) |	  such a query q exists). Let us write

q as follows:
z.
Since DB(A) |	 q, then there is an image of q in A. Let G be
such an image. Let q be the query in Saturate(Q ), where Q  =

Si(ti)  MinIncSet(Si(ti), T )  m

IncRewrIAR(q, T ) = q 

i )  h

. Since A

= t
i .

i=0

Ti(t

i=0

i=0

PerfectRef(Q , Tinc  Ttype), such that q = IncRewrIAR(q, T ). Since
DB(G) |	 q, then DB(G) |	 q. Moreover, from Proposition 1 and
Lemma 2, it directly follows that T , J |	 Q . Since DB(G) |	
MinIncSet(Si(ti), T ) for every atom Si(ti) of q, then from Lemma 8
it follows that G  V =  for every V  minIncSets(K). But this
means that G is a subset of A satisfying both conditions (i) and (ii)
of Theorem 6. Hence, T , A|	IAR Q . 

Finally, the following complexity result is an immediate
consequence of the termination of the algorithm IAR-PerfectRef
and of Theorem 9.

Corollary 1. Let K be a DL-LiteA,id,den KB and let Q be a UBCQ.
Deciding whether K |	IAR Q is in AC 0 in data complexity.
Proof. The proof follows from Theorem 9 and from the fact that
evaluation of FOL queries over relational databases is in AC 0 in data
complexity. 

We conclude the section with an observation on the size of
the rewriting computed by IAR-PerfectRef(Q , T ). It is well-known
that the size of the perfect reformulation of a query q  Q
computed by PerfectRef is polynomial with respect to |T |, and
exponential with respect to |q| [3]. It is easy to see that the size
of Q  = Saturate(PerfectRef(Q , Tinc  Ttype)) remains polynomial
with respect to |T |, and exponential with respect to |Q|. Since
query IncRewrIAR(q, T ) makes use of MinIncSet(S(t), T ) for each
atom S(t) in q  Q , and the size of MinIncSet(S(t), T ) is
exponential with respect to|T | (see Algorithm 1), we can conclude
that the size of the rewriting computed by IAR-PerfectRef(Q , T ) is
exponential with respect to both |T | and |Q|.

8. Experimental evaluation

In this section we illustrate the results of the experiments we
carried out on the query rewriting technique for the IAR-semantics
presented above.5 To test
the technique, we implemented
IAR-PerfectRef through a JAVA program, which produces SQL
encodings of the first-order rewritings computed by the algorithm.
The ABoxes over which we executed such rewritings have been
stored as relational databases under the DBMS PostgreSQL 9.0.
Experiments have been run on a 2.6 GHz quad-core Intel Core i7
MacBook Pro laptop equipped with 8 GB ram.

We used the LUBM benchmark ontology6 as test-bed. The
LUBM TBox contains 43 atomic concepts, 25 atomic roles, 7
attributes, and about 200 assertions. Since its expressivity goes
beyond DL-LiteA,id,den, due to the use of conjunctions and qualified
existential restrictions in the left-hand side of positive inclusion
assertions, we first approximated it in DL-Lite, which in fact
required to eliminate very few inclusion assertions from the TBox.
Then, since the LUBM TBox does not contain axioms that can be
contradicted by ABox assertions, we slightly modified it by adding
some assertions that can cause inconsistency. Namely, we added
10 negative inclusions, 5 identifications, and 3 denials to the TBox.
Turning our attention to data, we initially produced 4 different
ABoxes of increasing size by means of the UBA Data Generator
provided by the LUBM website. Such tool can generate ABoxes of
varying size according to specific input parameters. In particular,
we used the generator to produce ABoxes containing data
regarding 1, 5, 10, and 20 universities, respectively, which we
denote with Ai, where 1  i  5. These ABoxes turned out
to be consistent with the TBox of our experiments. Therefore,

5 More details on the experiments can be found at http://www.dis.uniroma1.it/
ruzzi/JWS/.
6 http://swat.cse.lehigh.edu/projects/lubm/.

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

Fig. 2. Size of the ABoxes used in the experiments (number of ABox assertions).

we modified them to introduce inconsistency, and created
four different versions of each such Ai, containing increasing
percentages of inconsistency.

i and A

More precisely, we created four different inconsistent versions
i, where j  {1, 5, 10, 20}

of each Ai, which we denote with A

indicates the percentage of inconsistency in each A
i. Such ABoxes
i  Aj
are such that Ai  A1
i , for j < j. Furthermore, let
i be a KB where T is our DL-LiteA,id,den version of the
i = T , A

i\Ai are involved in

LUBM TBox, we have that all the assertions in A

i -clash and all the assertions of Ai are not involved in any
some K

i we add only assertions that
i -clash. In other words, in each A

are inconsistent among them, and leave Ai as a consistent nucleus.

We finally notice that all A
i are such that the inconsistency they
generate is uniformly distributed over the axioms that we added
to the original LUBM TBox.

i , A5

Fig. 2 shows the size (number of assertions) of all the ABoxes
we used in the experiments. Every row reports the size of the

ABox Ai and of its modified inconsistent versions A
i, and is labeled
with the number of universities given as input to the UBA Data
Generator used to produce Ai. For each row i, column Cons. shows
the number of assertions in Ai, whereas columns 1, 5, 10, and 20
give the number of assertions of A1
, respectively,
i.e., modified ABox containing respectively the 1%, 5%, 10% and 20%
of assertions involved in some clash with the TBox.

, and A20

i , A10

We then issued 17 conjunctive queries over the test ontolo-
gies, which are taken from the LUBM benchmark query set (con-
taining 14 queries) or adapted from it.7 The first part of the experiments consisted in verifying the effective computability of
the IAR-PerfectRef algorithm, as well as estimating the overhead
it introduces with respect to the PerfectRef algorithm for query
rewriting under the standard FOL semantics. Fig. 3 gives us some
information on the size of the test queries and of their rewritings
obtained through either PerfectRef or IAR-PerfectRef. More pre-
cisely, for each query Qi the table contains the following informa-
tion:
 column Qsize indicates the number of atoms of the conjunctive
query;
 column PRsize reports the number of CQs contained in the
rewriting returned by PerfectRef;
 column MISsize shows the number of disjuncts produced by
all the executions of the MinIncSet algorithm done in the
IncRewrIAR step of the rewriting, which gives us a measure of
how much the processing of the query is affected by possible
inconsistency. Intuitively, large values for MISsize correspond
to queries whose perfect FOL rewriting returned by PerfectRef
contains many atoms with predicates occurring in assertions of
Ttype, Tdisj, Tfunct, Tid, or Tden;
 column IARPRsize reports the size of the binary files storing
the final SQL rewriting produced by our implementation of
IAR-PerfectRef.

As we can notice,
the rewriting produced by
IAR-PerfectRef largely exceeds the one computed by PerfectRef.

the size of

7 All queries are listed at http://www.dis.uniroma1.it/~ruzzi/JWS/.

Fig. 3. Query rewriting sizes.

Fig. 4. Query rewriting times (ms).

This is not surprising, since, as already said, the size of the rewriting
that IAR-PerfectRef returns is exponential in the size of both the
query and the TBox, whereas the size of the rewriting produced
by PerfectRef is exponential only in the size of the query. We also
notice that, as expected, the MISsize can vary a lot for queries
with the same PRsize. For example, queries Q13 and Q15 have the
same PRsize, but the MISsize for Q13 significantly lower than the
analogous value for Q15. Indeed, Q13 is less affected than Q15 by the
inconsistency.

Let us now consider rewriting times, which we give in Fig. 4. For
each query Qi the table contains the following information:
 column T1 indicates the time needed to run PerfectRef;
 column T2 shows the time needed for all the executions of
IncRewrIAR;
 Total indicates the total time that the IAR-PerfectRef algorithm
takes for the input query.

Notice that we do not indicate the time needed for query saturation
(execution of the algorithm Saturate) because it is negligible w.r.t.
T1 and T2.

We recall that to compute the query MinIncSet used in the
IncRewrIAR algorithm, we first need to execute the algorithm
MinUnsatQuery. The result of this last algorithm is independent

Fig. 5.

IAR-perfect rewriting evaluation times (s).

Fig. 6. Perfect rewriting evaluation times (ms).

of the specific query at hand, and therefore we can execute it off-
line, before query rewriting. Therefore, we do not include the time
needed for its execution in the results shown in Fig. 4. According
to our experiments, the total time for executing it is 48,188 ms.
From the figures about rewriting times presented above, we can
conclude that in our experiments the time overhead caused by
the inconsistency treatment proposed in this paper with respect
to the standard query rewriting technique,
i.e., disregarding
inconsistency, is acceptable, and does not constitute a bottleneck
of the approach.

We now turn our attention to the evaluation of the rewriting.
We computed the answers of each IAR-perfect rewriting produced
by IAR-PerfectRef over all 20 test ABoxes described above.
Evaluation times (in seconds) are given in Fig. 5. The results are
grouped according to the number of universities used to generate
the ABoxes through the UBA data generator of the benchmark
(supercolumns 1, 5, 10, and 20). For each such group we provide
five columns, labeled with 0, 1, 5, 10, and 20, respectively, that
indicate the percentage of inconsistency of each ABox in the group
(notice that for group i, column 0 contains results obtained over
Ai). We established a 10 min timeout for every single rewriting
evaluation.

To give an idea of the overhead caused by our inconsistencytolerant query answering approach based on the IAR-semantics,
with respect to standard query answering under FOL semantics, we
also provide the times needed to evaluate the rewriting returned

by PerfectRef over all the 20 test ABoxes. Of course, the answers we
get in this case are not meaningful, since we are disregarding the
inconsistency and naively query the KB as it was consistent. Results
we obtained (in milliseconds) are given in Fig. 6.

Each value given in Figs. 5 and 6 represents the average time
over four evaluations of the same rewriting over the same ABox. To
avoid that possible caching strategies adopted by the underlying
DBMS affected our experiments, we executed four experiment
rounds, and in each round we evaluated each rewriting over all the
ABoxes.

Looking at the IAR-perfect rewriting evaluation times of Fig. 5,
we notice that we could execute successfully almost 90% of the
evaluations, and that we experienced very good performances
(only 3% of the successful cases took more than 4 min). Only 4 out of
17 rewritings reached the timeout, and only for ABoxes containing
high levels of inconsistency or more than one million tuples.

The trend of the evaluation time is essentially constant or
increasing within each group of ABoxes. In some cases (e.g., Q6 or
Q13) it shows an increment when moving from a group containing
smaller ABoxes to one containing larger ABoxes, but the trend
is always increasing for equal percentages of inconsistencies. For
only two cases, involving queries Q4 and Q5, we notice a large
increment in evaluation time when moving from a group to
another, disregarding the percentage of inconsistency. The same
behavior for these two queries can be observer also in Fig. 6,
which indicates that the jump in this case is somehow amplified

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

by the PerfectRef component of the rewriting. This makes us to
conclude that in general the evaluation time is more affected by the
increment of inconsistency in the ABox than by the only increment
of the size of the ABox. We also notice that less performing
rewritings have in general a large number of disjuncts generated by
MinIncSet (cf. column MISsize of Fig. 3). This is however not always
the case, as it can be verified looking at evaluation times for the
rewriting of query Q4, which has a small MISsize. Conversely, query
Q12 has a quite large MISsize but its IAR-perfect rewriting is always
evaluated in less than 30 s. This is not completely surprising, since
evaluation times are also affected by the distribution of data and
the features of the DBMS managing them. On the other hand, for
most of the cases we observed a certain correspondence between
the size of the IAR-perfect reformulation and the evaluation time
of the rewriting (the larger the former the slower the latter).

Comparing the results in Figs. 5 and 6 we notice that using
IAR-PerfectRef for query answering instead of PerfectRef makes
query answering times to increase of some degree of magnitude.
This was expected, because of the complex structure and large
dimension of the former rewriting compared to the latter. On the
other hand, an increase in the computation time is the price to
pay to rely on a principled treatment of the inconsistency rather
than obtaining spurious answers from an inconsistent ontology.
These results, however, clearly call for optimized methods for
query answering under the IAR-semantics. We further notice
that no general correlation exist between the time needed to
answer a query under the standard FOL semantics and what is
needed under the IAR-semantics, by using our query rewriting
techniques. Indeed, even though queries that we tested to be
easy under the FOL semantics have been evaluated quite quickly
also under the IAR-semantics, there are queries, like Q13, which
turned out to be the most difficult under the FOL semantics, but
definitely manageable under the IAR-semantics. In other words, we
experienced that the presence of inconsistency and the way it is
distributed heavily change the query answering performances.

We conclude by noticing that the rewriting technique proposed
in this paper is only the starting point of our investigation on
rewriting methods for inconsistency-tolerant query answering
under the IAR-semantics, which has been mainly devised as a
means to show FO-rewritability of this task for DL-LiteA,id,den. We
are currently working on optimization techniques in order to
obtain more compact rewritings, thus limiting the price to pay for
moving from standard query answering to inconsistency tolerant
processing of queries. Nonetheless, we believe that the results we
obtained in the experiments presented in this section are very
encouraging, and set the stage for applicability of consistent-query
answering technique in real-world OBDA scenarios.

9. Related work

Inconsistency management has been addressed in various
forms in several areas, including Logic, Artificial Intelligence, and
Databases. In Logic, several semantics have been proposed with
the aim of providing more meaningful notions of logical entailment
for classically inconsistent theories. Some notable examples come
from the field of multi-valued and paraconsistent logics [1316].
Each of the proposals has advantages and drawbacks, and the
choice of the paraconsistent logic depends on the requirements of
the application at hand. The techniques adopted in these works
are however quite different from the ones we use in the present
paper, and therefore we do not discuss them further. Instead,
in this section we concentrate on the approaches that are most
related to OBDA, and in particular we consider the studies dealing
with inconsistency handling in ontologies, belief revision, and
databases.

9.1. Inconsistency handling in ontologies

Several works of the Semantic Web community focus on the
issue of dealing with inconsistencies in the knowledge base. In [45],
the authors present a framework for reasoning with inconsistent
KBs. At the basis of such a framework is the notion of selection
function, that allows for choosing some consistent sub-theory
from an inconsistent KB. Standard reasoning is then applied to
the selected sub-theory. An instantiation of the framework, based
on a syntactic relevance-based selection function is also briefly
described. In [46], a more extended framework that generalizes
four approaches to inconsistency handling is presented.
In
particular, consistency of KB evolution, repairing inconsistency,
reasoning with inconsistent KBs, and KB versioning are considered.
In [32], a tool is presented that allows for verifying whether
a KB expressed in DL-Lite is consistent: the check is reduced to
the evaluation of first-order queries over the ABox. However,
the kind of support to inconsistency management provided by
these approach mostly consists of identifying inconsistencies.
Furthermore, with the exception of [32], they are mainly focused
on inconsistencies at the intensional level (or do not distinguish
between intensional and instance level).

The form of inconsistency tolerance studied in this paper is
related to the work on justification and pinpointing in Description
Logic ontologies. In fact, minimal inconsistent subsets of the
ABox can be seen as explanations, or minimal justifications (at
the extensional level) of the inconsistency of the knowledge
base. Given this connection, some computational properties of
pinpointing (e.g., [4042]) are related to the complexity of
reasoning under inconsistency-tolerant semantics, although the
two problems are different and are studied under different
assumptions. Some works have explicitly focused on the problem
of finding justifications for inconsistency. In [47], the authors
present a framework for detecting and diagnosing errors in OWL
ontologies. In [48], the authors discuss a number of alternative
methods to explain incoherence of TBoxes, unsatisfiability of
concepts and concept subsumption, in order to provide support
to knowledge engineers who are building terminologies using
Description Logic reasoners. Then, in [49] a visual tool is presented
that allows the user to check consistency of formal KBs. In [39],
the authors present an algorithm for computing justifications
for inconsistent ontologies in OWL 2. To summarize, none of
the above mentioned works provides concrete techniques, or
complexity results for inconsistency-tolerant query answering in
the framework considered in this paper.

9.2. Belief revision

The form of inconsistency tolerance considered in this work is
deeply connected to the study of update in databases and belief
revision/update. Consider a consistent knowledge base K and a
new piece of information N . Suppose that our intention is to
change K with the insertion of N . If K  N is inconsistent,
then the revision/update semantics assume that the original
knowledge base K has to be modified in order for the result of
the change to be consistent. The studies in belief revision appear
very relevant for reasoning over inconsistent KBs. For instance, if
 = T , A is a possibly inconsistent knowledge base, with

respect to the knowledge base revision/update framework, we
can consider the ABox A as the initial knowledge, whereas the
TBox T represents the incoming knowledge. Based on such a
correspondence, the inconsistency-tolerant semantics presented
in this work are strictly related to the work presented in [5052].
However, none of these papers provides specific techniques for DL
KBs. In [11], an algorithm is proposed for handling inconsistency
in DL KBs based on a revision operator. This approach allows

for resolving conflicts changing the original knowledge base by
weakening both ABox and TBox assertions. Similarly, in [53]
inconsistency is resolved by transforming every concept inclusion
assertion in the TBox into a cardinality restriction. Then, if a
cardinality restriction is involved in a conflict, one weakens it by
relaxing the restrictions of the number of elements it may have. To
the best of our knowledge, the approach studied in this work, based
on instance-level repair only, is novel for Description Logics, and
it is inspired by the work on inconsistency tolerance in Databases
discussed next.

9.3. Inconsistency tolerance in databases

Traditionally, in databases, consistency is preserved by forbidding malicious update operations. Clearly, such an approach is not
applicable in those scenarios where the aim is to merge information coming from different data sources, as in data integration.
Data cleaning techniques provide in this case a classical procedural means for restoring consistency [11,12,54]. These solutions are
procedural in nature and require to collect additional applicationspecific information, which can be a serious drawback in many
contexts.

Besides traditional data cleaning, the research in databases
has also pursued a declarative approach to the problem, concentrating on two main issues: restoring consistency through the
computation of a new consistent database, starting from an inconsistent one, and computing meaningful answers to queries without
necessarily modifying the database in order to resolve inconsis-
tency. The second approach is known under the name of consistent
query answering, following the seminal work of Arenas, Bertossi
and Chomicki [17], and is the approach we explore in this paper
in the context of OBDA.

The main notion at the basis of declarative approaches to
inconsistency tolerance in databases is that of a repair [17]. A
repair for an inconsistent database is defined as a database instance
that satisfies integrity constraints and minimally differs from
the original database. Various criteria of minimality have been
proposed in the literature. In [55], the authors show how the notion
of minimality can be interpreted in different ways, depending on
the kinds of constraints that are considered. Indeed, for the large
class of denial constraints, the only way to restore the integrity
of a database is to retract a part of it. On the other hand, if
the information is both incorrect and incomplete, as in the case
where also inclusion dependencies are considered, both insertions
and deletions of pieces of information should be considered.
Alternatively, some data integration approaches give up the
completeness assumption [56,57], and therefore do not consider
violations of inclusion dependencies by the underlying database
as a real inconsistency. In [58] the authors study inconsistency in
presence of both denial constraints and inclusion dependencies,
and present a semantics in which only tuple elimination is allowed,
and it is therefore used also for repairing violations of inclusions,
differently from [56,57]. In other works, repairs are given in
terms of tuple updates, rather than tuple deletions or insertions
(see, e.g., [59,60]). The papers mentioned so far, as well as the
present paper, adopt a minimality criterion for repairs based on set
containment. An alternative approach is the one in which repairs
are defined through a cardinality-based minimality criterion (see
e.g., [61]).

In the last 15 years, several studies have analyzed the computational complexity of consistent query answering under various inconsistency-tolerant semantics and various classes of
constraints [19,55,62,63], and many algorithms to solve it have
been proposed. Some of such approaches aim at rewriting the
input query into a new query whose evaluation over the inconsistent database returns the consistent answers (similar to the

approach we follow in the present paper). Depending on the complexity of the problem, such rewritings are specified as (possibly
optimized) logic programs allowing for the use of negation or disjunction (as in [57,64,65]), or as first-order logic queries (as in
[17,66,67]). Notice, however, that this last approach can be pursued only in very limited settings, since under the semantics proposed for inconsistency tolerance in databases the problem easily
becomes intractable. Thus, even if relevant for the present paper,
the rewriting techniques proposed in the context of databases cannot be adapted to the setting we consider. For an overview of the
work on consistent query answering, we refer the reader to [18,38].

9.4. Instance-level inconsistency tolerance in DLs

We finally survey some recent works that, similarly to our
approach, are specifically tailored to the study of instance-level
inconsistency-tolerant semantics for DL knowledge bases.

In [43] a repair-based inconsistency-tolerant semantics for
DLs is provided and data complexity of query answering under
such semantics is studied for DL-LiteR and DL-LiteF , two logics
of the DL-Lite family captured by DL-LiteA,id,den. As already said
(cf. Section 5), the notion of repair given in [43] coincides with
our notion of AR-repair, and then, their inconsistency-tolerant
semantics coincides with our AR-semantics. The objective of [43]
was however different from ours, since it aimed at identifying
tractable cases of inconsistency-tolerant query answering under
the AR-semantics, and thus focused on inconsistency-tolerant
instance checking. As noticed, our complexity lower bound for
DL-Litecore given in Theorem 3 corrects the results in [43], asserting
tractability of instance checking under AR-semantics for DL-LiteF
and DL-LiteR. It can be shown that the technique presented in [43] is
in fact correct only for DL-Litecore KBs without negative inclusions,
but enriched with functionalities on roles.

More recently, in [68] the author carries out an investigation for DL-Lite KBs, with the aim of better understanding the
cases in which inconsistency-tolerant query answering under
AR-semantics is feasible, and in particular, can be done using query
rewriting. Specifically, the author formulates some general conditions that can be used to prove that a first-order reformulation
for inconsistency-tolerant query answering does or does not exist for a given DL-Litecore TBox and instance query. Subsequently,
in [69,70], the same author conducts a complexity analysis of
the AR-semantics with the aim of characterizing the complexity
of inconsistency-tolerant query answering based on the properties of the KB and the conjunctive query at hand. In particular,
in [69], by focusing on a very simple language, which is a fragment of DL-Litecore, the author identifies the number of quantified
variables in the query as an important factor in determining the
complexity of inconsistency-tolerant query answering. To be more
precise, it is shown that inconsistency-tolerant query answering
under AR-semantics: (i) is always first-order rewritable for conjunctive queries with at most one quantified variable; (ii) has
polynomial data complexity when the query has two quantified
variables; (iii) is coNP-hard for queries having three (or more)
quantified variables.

is a sound approximation of

In the same paper, the author proposes a novel inconsistencytolerant semantics that
the
AR-semantics. This semantics, named intersection of closed repairs
(ICR), corresponds to closing AR-repairs with respect to the TBox
before intersecting them. The ICR-semantics approximates the
AR-semantics better than the IAR-semantics: however, query answering under the ICR semantics in DL-Lite logics is in general in-
tractable. In particular, [69] shows that first-order rewritability
of inconsistency-tolerant query answering under ICR-semantics is
guaranteed only for DL-Litecore ontologies without inverse roles. For
full DL-Litecore, the problem is instead coNP-hard [69].

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

We observe that the ICR-semantics is similar in spirit to the
ICAR-semantics we investigated in [25,26]. Analogously to the ICR-
semantics, in the ICAR-semantics we close the AR-repairs with
respect to the TBox, but instead of taking their intersection, we
consider the union of such closures and compute the IAR-repair
of this union, which we call the ICAR-repair. We remark that
the rewriting technique presented in this paper can be adapted
to compute perfect rewritings under the ICAR-semantics, thus
showing that inconsistency-tolerant query answering for UBCQs
is first-order rewritable also in this case. To ease readability, we
preferred to not discuss this issue in the present work. Some hints
on how to modify the IAR-PerfectRef algorithm to obtain a query
rewriting procedure for the ICAR-semantics can be found in [26],
where first-order rewritability of query answering for DL-LiteA is
shown for both the IAR- and the ICAR-semantics: we point out,
however, that the technique presented in that paper is different
from the one we present here, which is able to deal also with
identification and denial assertions.

In [71] the author presents a computational analysis of the
problems of instance checking and conjunctive query answering
under AR- and IAR-semantics (and other inconsistency-tolerant
semantics) for a wide spectrum of DLs, ranging from tractable ones
(E L) to very expressive ones (SHIQ), showing that reasoning
under the above semantics is inherently intractable, even for very
simple DLs. In particular, these results imply that the tractability of
query answering under IAR-semantics that we have shown for the
DL-Lite logics does not extend to other tractable DLs like E L.

In addition, [72] presents two parameterized inconsistencytolerant semantics for DLs, called k-support and k-defeater seman-
tics. The k-support semantics can be seen as a generalization of
the IAR-semantics, in the sense that is a sound approximation of
the AR-semantics: it converges to the AR-semantics for k sufficiently large and in the case when k = 1 it coincides with the
IAR-semantics. The k-defeater semantics is a complete approximation of the AR-semantics: in the case when k = 0 it coincides with
the brave version of the AR-semantics, and converges to the ARsemantics in the limit. The authors prove that, in the case of DL-Lite
ontologies, query answering under both semantics is tractable (ac-
tually, first-order rewritable). These results in principle allow for
improving the expressive abilities of the IAR-semantics while keeping its good computational properties. However, the applicability of this approach is still not clear: in particular, practical query
rewriting algorithms for the parameterized semantics have not
been defined yet. This paper also presents a sufficient condition
for the FO-rewritability of conjunctive queries under the above parameterized semantics, which includes, as a special case, query answering in the logic DL-LiteA,id,den under the IAR-semantics.

Then, [73] presents an approach that is also very close to
the present work. In fact, it proposes an application of the IARsemantics to the framework of Datalog+/- [6]. In particular, a
fragment of Datalog+/- is considered that comprises linear tuplegenerating dependencies (TGDs), negative constraints (NCs) and a
restricted form of equality-generating dependencies (EGDs). Then,
a technique for query answering under such dependencies is
presented, which is technically very similar to the one presented in
Section 7. In fact, the dependencies considered in [73] have a tight
connection with the TBox assertions of DL-LiteA,id,den, in particular:
linear TGDs correspond to a generalized form of positive inclusion
assertions, NCs correspond to denial assertions, and EGDs are
related to identification assertions. However, there are two main
differences: first, the framework of [73] does not consider value-
domains, hence many of the issues dealt with by our technique
are not present in the above Datalog+/- framework; moreover,
although identification constraints correspond to EGDs, they are
not captured by the restricted form of EGDs (called non-conflicting
EGDs) considered in [73]. The work of [73] has been further

extended in [74], which presents a set of complexity results about
reasoning in Datalog+/- programs under both the IAR-semantics
and the ICR-semantics.

Furthermore,

in [75] an algorithm for materializing the
IAR-repair of a DL-LiteA KB is defined. This work also presents
an experimental comparison in DL-LiteA of the query rewriting
approach and the materialized approach to query answering under
the IAR semantics. A similar comparison for the framework studied
here, although very interesting in principle, is outside the scope
of the present paper, and is left for future work (cf. Section 10).
We only note that ABox repairs in DL-LiteA appear much easier
to compute than in the case of DL-LiteA,id,den, because minimal
inconsistent subsets have a cardinality of at most 2, which implies
that computing IAR-repairs in DL-LiteA is in PTime with respect
to combined complexity. Conversely, in DL-LiteA,id,den, due to the
presence of denial assertions and identification assertions, the
minimal inconsistent subsets of the ABox may have size larger
than 2 (only bounded by the length of the above assertions). By
virtue of this property, it can easily be shown that computing
IAR-repairs in DL-LiteA,id,den cannot be done in polynomial time
with respect to combined complexity, unless PTime = NP. For
these reasons, the query rewriting techniques considered in [75]
are significantly different from the one presented in this paper.
Finally, as observed in [75], the ABox cleaning approach might
not always be possible or easily realizable in real applications,
especially in OBDA scenarios where the ABox is virtually defined
through views over autonomous databases. In these cases, the
OBDA system can typically only read such databases. Another
reason that may prevent the applicability of the ABox cleaning
approach is that several organizations do not want their data to be
replicated, thus preventing from building a cleaned replica of data.
Indeed, data replication comes with the additional cost due to the
need of keeping the replica up-to-date with respect to the original
copy.

10. Discussion and conclusion

In this paper, we have addressed the problem of inconsistency
tolerance for DLs of the DL-Lite family, particularly suited for
ontology representation in an OBDA scenario, where data at the
sources to be accessed, stored in autonomous and independent
systems, typically contradict the conceptualization provided by
the ontology. We have therefore analyzed inconsistency-tolerant
semantics suited to deal with this situation,
i.e., semantics
that preserve the knowledge provided by the ontology TBox,
considered a faithful representation of the domain, and repair ABox
data to make them consistent with the TBox. We have first studied
query answering under the AR-semantics, a natural adaptation
to DLs of repair-based semantics proposed for incomplete and
inconsistent databases, and have shown that this task is intractable
in data complexity even for very simple queries and DL languages
of limited expressive power. We have therefore proposed an
approximation of the AR-semantics, called IAR-semantics, with
the goal of reaching a compromise between the expressive power
of the semantics, the ontology and the query language, and
the computational complexity of inconsistency-tolerant query
answering. We have then shown that query answering under such
semantics is first-order rewritable for one of the most expressive
logic of the DL-Lite family, and provided some first experiments
involving ontologies with large inconsistent ABoxes, based on an
implementation of our rewriting algorithm.

As for future work, we plan to continue the work on the
IAR-semantics in different ways. First, we have implemented the
query rewriting algorithm presented in Section 7 in the MASTRO
system [32], with the goal of testing the algorithm in real-world
scenarios. Such tests will allow us to investigate in detail suitable

strategies for optimizing the rewritten query produced by the
algorithm.

Also, we plan to experiment our technique in OBDA settings
where the relationship between the ontology and the data sources
is expressed in terms of suitable mappings, rather than a DL ABox.
In this setting, the goal of devising an efficient inconsistencytolerant query answering technique is complicated by the fact that
the rewritten query produced by our algorithm should be the input
to a further rewriting step that takes into account the mappings.

Finally, we would like to investigate approaches that materialize instance-level repairs in DL-LiteA,id,den. In particular, it would
be very interesting to define techniques for ABox cleaning in
DL-LiteA,id,den and to extend the experimental comparison presented in [75] between virtual and materialized approaches to
query answering under the IAR-semantics.

Acknowledgments

This research has been partially supported by the EU under FP7
project Optique  Scalable End-user Access to Big Data (Grant No.
FP7-318338).

Appendix A

In this appendix we recall the algorithm PerfectRef for query
rewriting of UCQs over DL-Lite TBoxes. This algorithm has been
originally presented in [3] for DL-Lite logics without attributes,
and then used as is in [37] for DL-LiteA. Indeed, as clarified
below, by virtue of the assumptions on value-domains adopted in
DL-LiteA (and its variants), for query rewriting it is possible to treat
DL-LiteA TBoxes as DL-Lite TBoxes without attributes, provided
some obvious syntactic transformations. In this paper, we assume
that it takes as input a DL-LiteA,id,den TBox T and a UCQ Q .

PerfectRef returns the perfect rewriting of Q w.r.t. T (cf. Proposition 1). To compute such rewriting, it exploits only the positive
inclusion assertions in the TBox. In a DL-LiteA,id,den TBox, these are
the assertions in Tinc and Ttype. In particular, PerfectRef treats predefined value-domains as atomic concepts, attributes as atomic
roles, and each assertion in Ttype as an inclusion between an unqualified existential restriction over a role and an atomic con-
cept. In other words, in PerfectRef concepts of the form (U) are
seen as concepts of the form U, and value-domains of the form
(U) are seen as concepts of the form U. This is possible by
virtue of the assumptions made on value-domains (cf. Section 2.1),
through which the distinction between objects and values does
not have any impact on query answering. Thus, in PerfectRef we
do not need to introduce any special treatment for attributes and
value-domains. We only notice that, since input queries can contain atoms of the form Ti(t), with Ti value-domain in P and t a
term, we also make use of inclusions of the form (U)  Ti (inter-
preted as U  Ti) to rewrite the query.
PerfectRef (cf. Algorithm 6) consists of two main steps, applied
repeatedly to each q  Q until a fixpoint is reached: step (a)
uses positive inclusions as rewriting rules applied from right to
left, to rewrite query atoms one by one, each time producing a
new conjunctive query to be added to the final rewriting; step
(b) unifies query atoms. The aim of step (b) is to make step (a)
executable over atoms resulting from unification. At the end of the
process, all the knowledge of the TBox that is necessary to answer q
is encoded in the returned rewriting, which can be then evaluated
over the underlying ABox to return the answer.
In the algorithm, q[g/g] denotes the CQ obtained from a CQ q
by replacing the atom g with a new atom g. Also, gr(g, ) denotes
the atom obtained from the atom g by applying the inclusion
. Roughly speaking, an inclusion  is applicable to an atom g

Input: UCQ Q , DL-LiteA,id,den TBox T
Output: UCQ
begin
PR  {Q};
repeat
PR  PR;
for each q  PR do
(a) for each g in q do

for each positive inclusion  in T do
if  is applicable to g
then PR  PR  { q[g/gr(g, )]}
if g1 and g2 unify
then PR  PR  { (reduce(q, g1, g2))};

(b) for each g1, g2 in q do

until PR = PR;
return PR;

end

Algorithm 6: The algorithm PerfectRef

if: (i) the predicate of g is equal to the predicate in the righthand side of ; (ii) in the case when  is an inclusion assertion
between concepts, the atom g has at most one bound argument,
which corresponds to the object that is implicitly referred to by
the inclusion , where an argument is bound if it is a constant
or a variable occurring elsewhere in the query (we refer to [3,37]
for further details). In PerfectRef, we substitute each non-bound
variable with the symbol _ . For example, the inclusion A  P is
not applicable to any of the atoms in x, y.P(x, y)  P(x, y)  x =
x, whereas the inclusion P1  P2 is applicable to the atom
P2(x, z) in the query x.P3(x, _ ), P2(x, _ ). In this case, we have
gr(P2(x, _ ),P1  P2) = P1(x, _ ). Again, we refer to [3,37] for
the exact definition of the function gr. Finally, reduce is a function
that takes as input a conjunctive query q and two atoms g1 and
g2 occurring in the body of q, and returns a conjunctive query q
obtained by applying to q the most general unifier between g1 and
g2, whereas the function  substitutes with the symbol _ each nonbound variable in the query it takes as argument.

Appendix B

The goal of this appendix is to present the proof of Theorem 1.
To show the only-if direction, we construct a DL-LiteR KB that
encodes the positive knowledge specified in a DL-LiteA,id,den KB.
Then we make use of the notions of chase and canonical structure
for DL-LiteR KBs, and exploit some of their basic properties. Such
notions and properties have been originally given in [3]. For the
sake of completeness, we repeat them below.8

The canonical structure for DL-LiteR KBs

We recall that a DL-LiteR KB can be seen as a particular
DL-LiteA,id,den KB without attributes and value-domains, where
functionalities, identifications, and denials are not allowed. We
assume DL-LiteR KBs to be constructed over an overall alphabet of
P =  R
predicates  R
A is the alphabet of atomic
concepts and  R
L is the alphabet of atomic roles, and an alphabet of
A   R
P   R
(object) constants  R
= .

A   R
C , such that with  R

L =  and  R

L , where  R

8 Canonical structures are called canonical interpretations in [3]. Since, as we will
see in the following, they are not interpretations for DL-LiteA,id,den KBs, in this paper
we prefer to use the term structure.

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

First of all we provide the notion of structure induced by a set
of ABox assertions, which in DL-LiteR are only of form A(a) and
P(a, b). Notice that this definition is a specialization to DL-LiteR
of Definition 2, which considers DL-LiteA,id,den ABox assertions.
Differently from Definition 2, below we do not provide any special
interpretation of value constants, value-domains and attributes,
which do not exists in DL-LiteR. For the rest, the two definitions
coincide.

Definition 13. Let S be a set of DL-LiteR ABox assertions. The
structure DBR(S) = DBR(S),DBR(S) is defined as follows:
 DBR(S) coincides with the set of constants occurring in S,
 aDBR(S) = a, for each constant a occurring in S,
 ADBR(S) = {a | A(a)  S}, for each atomic concept A   R
A ,
 PDBR(S) = {(a1, a2) | P(a1, a2)  S}, for each atomic role
P   R
L .
The canonical structure of a KB in DL-LiteR is constructed
according to the chase of the KB [36,76]. We thus first recall the
notion of chase, and to this aim we start by defining the notion of
applicable positive inclusion assertions (PIs), which in DL-LiteR are
only of form B1  B2 and R1  R2. In the following, similar to
Section 3, we make use of the function  that takes as input a basic
role and two constants and returns an ABox assertion, as specified
below

(R, a, b) =R(a, b),

R(b, a),

if R = P
if R = P.

Definition 14. Let S be a set of DL-LiteR ABox assertions, and let Tp
be a set of DL-LiteR PIs. Then, a PI   Tp is applicable in S to an ABox
assertion   S if
  = A1  A2,  = A1(a), and A2(a)  S;
  = A  R,  = A(a), and there does not exist any constant b
such that (R, a, b)  S;
  = R  A,  = (R, a, b), and A(a)  S;
  = R1  R2,  = (R1, a, b), and there does not exist any
constant c such that (R2, a, c)  S;
  = R1  R2,  = (R1, a, b), and (R2, a, b)  S. 
Applicable PIs can be used, i.e., applied, in order to construct the
chase of a KB. In the following we assume to have an infinite set N
of constant symbols disjoint from the alphabets  R
P . Then,
our notion of chase is defined inductively as follows.
Definition 15. Let K = T , A be a DL-LiteR KB. We define
chase0(K) = A. Then, for every non-negative integer i, let  be
an ABox assertion in chasei(K), let  be a PI in T such that 
is applicable to  in chasei(K), and let anew be a fresh constant
from N, i.e., a constant not occurring in chasei(K), we define
chasei+1(K) = chasei(K)  new, where new is an ABox assertion
defined as follows
 if  = A1  A2,  = A1(a) then new = A2(a)
 if  = A  R and  = A(a) then new = (R, a, anew)
 if  = R  A and  = (R, a, b) then new = A(a)
 if  = R1  R2 and  = (R1, a, b) then new =
(R2, a, anew)
 if  = R1  R2 and  = (R1, a, b) then new = (R2, a, b).
Then, we call chase of K, denoted chase(K), the set of ABox

C and  R

assertions obtained as the infinite union of all chasei(K), i.e.,

chase(K) =

iN

chasei(K). 

We notice that, given a DL-LiteR KB K, a number of syntactically
distinct chases for K can be obtained according to the above
definition, depending on the order with which applicable PIs are
applied in each chasei(K). For ease of exposition, in Definition 15
we did not explicitly indicate the ordering to follow in the
application of the PIs, but assume that it is implicitly established
an ordering that guarantees that if a PI  is applicable to an ABox
assertion  in a certain chasei(K), then there exists j > i such that
 is no longer applicable to  in chasej(K). It can be shown that all
chases produced adopting an ordering that guarantees the above
property are unique up to renaming of constants from N (we refer
the reader to [3,76] for more details on these aspects).

With the notion of chase in place, we can define the
canonical structure can(K) of a DL-LiteR KB K as the structure
induced by chase(K) according to Definition 13, i.e., can(K) =
DBR(chase(K)).
The following lemmas adapted from [3] state that can(K)
satisfies all PIs in a DL-LiteR KB K and that can(K) is indeed a
canonical model for query answering.
Lemma 9 (Lemma 7 of [3]). Let K = T , A be a DL-LiteR KB and
let Tp be the set of PIs in T . Then, can(K) is a model of Tp, A.
Lemma 10 (Theorem 29 of [3]). Let K be a satisfiable DL-LiteR KB,
and let Q be a UBCQ over K. Then, K |	 Q if and only if
can(K) |	 Q .

Consider now DL-LiteR KBs equipped also with role functionality assertions, with the proviso that functional roles are not
specialized (i.e., they do not occur in the right-hand side of role
inclusions). Notice that KBs of this form are DL-LiteA KBs without attributes and value-domains (cf. the third condition in Definition 1), and we call them DL-LiteFR KBs. In such KBs, PIs and ABox
assertions are exactly as in DL-LiteR KBs. Therefore, Definitions 13
and 15 apply also to DL-LiteFR KBs. The following lemma, adapted
from [37], will be used in the proof of Theorem 1.
Lemma 11 (Lemma 6 of [37]). Let K = T , A be a DL-LiteFR KB,
and let Tfunct be the set of functionality assertions in T . Then, can(K)
is a model of Tfunct , A if and only if DBR(A) is a model of Tfunct , A.
Similarly to what we have done before, we consider now
DL-LiteR KBs equipped also with identification assertions, with
the proviso that each role appearing (in either direct or inverse
direction) in a path of an identification assertion is not specialized.
Notice that KBs of this form are DL-LiteA,id KBs without attributes,
value-domains and functionalities on roles (cf.
the second
condition in Definition 1), and we call them DL-LiteR,id KBs. Again,
in such KBs, PIs and ABox assertions are exactly as in DL-LiteR KBs.
Therefore, Definitions 13 and 15 apply also to DL-LiteR,id KBs. The
following lemma, adapted from [37], will be used in the proof of
Theorem 1.
Lemma 12 (Lemma 5.19 of [37]). Let K = T , A be a DL-LiteR,id
KB. Then, can(K) is a model of K if and only if K is satisfiable.

Proof of Theorem 1

Before attacking the proof, we first need to mention a property
of the algorithm PerfectRefIdC that has been proved in [37], and
that we specialize below to the case of DL-LiteR,id KBs.
Lemma 13 (Theorem 5.20 of [37]). Let K = T , A be a satisfiable
identification assertions in T , and let qTid = 
DL-LiteR,id KB, let Tp be the set of PIs in T and Tid be the set of
{()}. Then,
K is satisfiable if and only if DBR(A) |	 PerfectRefIdC(qTid
We have now all the ingredients needed for our proof.

, Tp).

Tid

A ,  R

Theorem 1. A DL-LiteA,id,den KB K = T , A is unsatisfiable if and
only if DB(A) |	 UnsatQuery(T ).
Proof. () Let K = T , A be a DL-LiteA,id,den KB and assume that
DB(A) |	 UnsatQuery(T ). To prove the claim we first construct a
DL-LiteR KB KR = T R, AR, with the aim of encoding in KR the
positive knowledge specified in K; then, based on the canonical
structure of KR, we identify a structure I and prove that I is a
model of K.
We start by defining the DL-LiteR KB KR = T R, AR. We call
A, L, T , U, O, and V the pair-wise disjoint alphabets, used
respectively for atomic concepts, atomic roles, value-domains,
attributes, object constants, and value constants, over which the
DL-LiteA,id,den KB K is specified. As said, we instead call  R
L , and

C the pair-wise disjoint alphabets for atomic concepts, atomic
roles, and (object) constants over which the DL-LiteR KB KR is
L = L  U, and
specified, and have that  R
C = O  V . In other terms, in KR we consider predefined

value-domains in K as atomic concepts and attributes in K as
atomic roles. Consequently, inclusions involving attributes and
value-domains in K as treated as concept and role inclusions,
respectively. More precisely, T R contains all the inclusions in the
sets Tinc and Ttype of T provided that each occurrence of (U) is
replaced by U and each occurrence of (U) is replaced by U.
Also, AR contains all the assertions in A, plus an assertion of the
form Ti(v) for each value constant v  V and value-domain
Ti  T such that Ti = type(v).
Consider now the structure DBR(AR) induced by AR according
to Definition 13 and the DL-LiteA,id,den interpretation DB(A)
induced by A according to Definition 2. It is easy to see that
DBR(AR) and DB(A) are two isomorphic structures, since they are
identical, modulo renaming objects interpreting value constants
in V .

A = A  T ,  R

Then, we construct the chase of KR according to Definition 15,
and consider the canonical structure can(KR) induced by the
chase. We remark that can(KR) is an interpretation for KR but it is
not an interpretation of K, since it does not obey the assumptions
on the interpretation of value-domains we impose in DL-LiteA,id,den
KBs (cf. Section 2.1). We will show in the following how to
construct from can(KR) one such interpretation that is a model for
K, thus proving that K is satisfiable.
We first show that the assumption DB(A) |	 UnsatQuery(T )
implies that can(KR) satisfies all the assertions in T . In doing this,
we can disregard for the moment the fact that can(KR) is not an
interpretation for K.
Satisfaction of assertions in Tinc  Ttype by can(KR) follows
from Lemma 9. Indeed, such lemma states that can(KR) satisfies
all PIs in T R, which correspond to those in Tinc  Ttype modulo
the syntactical transformations described above. Notice that above
property implies that KR is satisfiable.
To show satisfaction of functionalities in Tfunct we exploit the
assumption that DB(A) |	 UnsatQuery(T ), which implies that
DB(A) |	 PerfectRefIdC((), Tinc  Ttype) for each   Tfunct.
Since all arguments in the atoms of () are bound, and since
functional roles and attributes are never specialized in T , no PIs
exist in Tinc  Ttype that PerfectRefIdC can apply to atoms in ()
(cf. Section 3). Also, PerfectRefIdC cannot unify atoms, since such
unification would involve terms occurring in an inequality atom.
As a consequence, in this case DB(A) |	 (). By the isomorphism
between DB(A) and DBR(AR) it follows that DBR(AR) |	 () for
each   Tfunct. This means that DBR(AR) is a model of Tfunct , AR,
and thus, since T R  Tfunct , AR is a DL-LiteFR KB, from Lemma 11
it follows that can(KR) satisfies all the functionalities in Tfunct.

We now show that can(KR) satisfies the assertions in Tdisj.
|	 UnsatQuery(T ), and from the fact that, for
From DB(A)
each disjointness , () is a CQ without inequalities, it follows

|	 PerfectRef((), Tinc  Ttype) for each  
that DB(A)
Tdisj. By the isomorphism between DB(A) and DBR(AR) and the
correspondence between T R and Tinc  Ttype, we then have that
|	 PerfectRef((), T R) for each   Tdisj. From
DBR(AR)
Proposition 1 (notice that DL-LiteR KBs are particular DL-LiteA,id,den
KBs, and that KR is satisfiable) we have that KR |	 () for each
  Tdisj. From Lemma 10 it follows that can(KR) |	 () for
each   Tdisj, from which it follows that can(KR) satisfies all the
assertions in Tdisj.
As for denials, which analogously to negative inclusions are
associated to BCQs by the function , we can proceed exactly as
done above for assertions in Tdisj, and thus show that can(KR)
satisfies all the assertions in Tden.

Tid

|	 UnsatQuery(T ) it follows that DB(A)

, T R), where qTid = 

We now prove that can(KR) satisfies the assertions in Tid.
|	
From DB(A)
PerfectRefIdC((), Tinc  Ttype) for each   Tid. By the isomorphism between DB(A) and DBR(AR) and the correspondence between T R and Tinc  Ttype we have that DBR(AR) |	 PerfectRefIdC
{()}. Since KR,id = T R 
(qTid
Tid, AR is a DL-LiteR,id KB, then Lemma 13 states that KR,id is sat-
isfiable. From Lemma 12 it then follows that can(KR) satisfies all
the assertions in Tid (notice that can(KR) = can(KR,id)).
We now turn back to our construction of a model for K. Of
course, we want this model to preserve satisfaction of all assertions
in T proved for can(KR), and at the same time be compliant
with the assumptions of the interpretation of value-constants and
value-domains in a DL-LiteA,id,den KB. We thus construct such a
model starting from can(KR) (and from chase(KR)). Similar to
Section 7.1.1, we say that a constant c occurs in an object position
in chase(KR) if chase(KR) contains an assertion of the form A(c),
P(c, a), P(a, c), or U(c, v), and we say that c occurs in a value
position if chase(KR) contains an assertion of the form U(a, c) or
Ti(c). It is easy to see that, due to the syntactic restrictions on the
form of both ABox assertions and TBox assertions in DL-LiteA,id,den,
in chase(KR) no constant exists that can occur in both an object
and a value position. Then, we define a structure I = I,I as
follows:
 I = O  N  V ,
 aI
o = acan(KR)
 aI
no = acan(KR)
nv = ov, where ov belongs to V \n
an object position in chase(KR),
 aI
v = val(av), for each constant av  V ,
 aI
1=1 val(Ti) and ov is a fresh
object, i.e., it has not been used in I to interpret other constants
occurring in chase(KR), for each constant anv  N occurring in
V \n
a value position such that chase(KR) does not contain an atom
of the form Ti(anv) (notice that one such ov always exists, since
nv = ov, where ov belongs to val(Ti) and is a fresh object,
 aI
i.e., it has not been used in can(KR) to interpret other constants
occurring in chase(KR), for each constant anv  N occurring in
a value position such that Ti(anv)  chase(KR) and Ti precedes
= Ti and
in lexicographic order every other Tj such that Tj
Tj(anv)  chase(KR) (notice that one such ov always exists,
since each val(Ti) is infinite, as stated in Section 2.1),
 AI = Acan(KR), for each atomic concept A,
 P I = Pcan(KR), for each atomic role P,
 U I = {(aI, aI
i = val(Ti), for each value-domain Ti.
 T I
It is easy to see that I is a DL-LiteA,id,den interpretation. Indeed,
its domain is partitioned into two disjoint sets ON and V , used
to interpret object constants and value constants, respectively.
Furthermore, each av  V is such that aI
v = val(av) and each

= ao, for each constant ao  O,
= ano, for each constant ano  N occurring in

v ) | U(a, av)  chase(KR)}, for each attribute U,

1=1 val(Ti) is infinite, as stated in Section 2.1),

no

D. Lembo et al. / Web Semantics: Science, Services and Agents on the World Wide Web 33 (2015) 329

i . Since T I

1 and b = oI

i = val(Ti). However, there
value-domain Ti  T is such that T I
can be assertions of the form Ti(c) in chase(KR) such that cI  T I
i ,
for some value-domain Ti. Therefore, differently from can(KR),
we cannot directly conclude that I satisfies all the assertions in
Ttype. We show below that this cannot happen when DB(A) |	
UnsatQuery(T ), i.e., in this case I is a model of a DL-LiteA,id,den KB
Ttype, A. Let us assume for a contradiction that I |	 Ttype, A.
This means that there exists an assertion  = (U)  Ti, where
U is an attribute and Ti is a value-domain, such that there exist
o1, o2  I such that (o1, o2)  U I and o2  T I
i =
val(Ti), and the interpretations in I of value-domains are pairwise
disjoint, this means that o2  val(Tj) with Ti
= Tj. This implies,
by definition of I, that there is an assertion U(a, b) in chase(KR),
with a = oI
2, such that one of the following conditions
holds:
(i) b  V and val(b)  val(Tj), with Tj = Ti,
(ii) b  N,  = (U)  Tj is in T together with , and Tj precedes
Ti in lexicographic order. This means that chase(KR) contains
both Ti(b) and Tj(b) and I picks from val(Tj) a fresh symbol to
interpret b.
It is easy to see that in both cases can(KR) |	 () (indeed, in
both cases chase(KR) contains both Ti(b) and Tj(b)). Then, from
Lemma 9 it follows that DBR(AR) |	 PerfectRef((), T R), which
in turn implies that DB(A) |	 PerfectRefIdC((), Tinc  Ttype),
which is a contradiction, thus showing that I |	 Ttype, A.
Since I is isomorphic to can(KR) in the interpretation of atomic
concepts, atomic roles, and attributes, and can(KR) satisfies all the
assertions in T , we can then conclude that I is a model for K, and
thus K is satisfiable.
() if DB(A) |	 UnsatQuery(T ), then there exists at least a
query qu = PerfectRefIdC((), Tinc  Ttype) in UnsatQuery(T )
such DB(A) |	 qu. Various cases are possible: (i)  is an assertion
in Tdisj  Ttype  Tden. Since () is a CQ without inequalities, in this
case qu = PerfectRef((), Tinc  Ttype). By Proposition 1, we have
that qu is a perfect rewriting of () with respect to Tinc  Ttype,
and therefore DB(A) |	 qu implies that Tinc  Ttype, A |	 ().
Since () encodes the negation of , it follows that Tinc  Ttype 
{}, A is unsatisfiable, and therefore K is unsatisfiable. (ii)  
Tfunct. As shown during the proof of the other direction of this
theorem, in this case PerfectRefIdC((), Tinc  Ttype) = ().
Then, from DB(A) |	 () it immediately follows that {}, A is
unsatisfiable, and therefore K is unsatisfiable. (iii)   Tid. As done
in the proof of the other direction of this theorem, we construct a
DL-LiteR KB KR = T R, AR where T R encodes the PI knowledge of
K, i.e., Tinc  Ttype, and AR encodes the ABox A. From DB(A) |	 qu
it follows that DBR(AR) |	 qu. From Lemma 13 it follows thatT R
{}, AR is unsatisfiable, which means that Tinc  Ttype  {}, A
is unsatisfiable, and therefore K is unsatisfiable. 
