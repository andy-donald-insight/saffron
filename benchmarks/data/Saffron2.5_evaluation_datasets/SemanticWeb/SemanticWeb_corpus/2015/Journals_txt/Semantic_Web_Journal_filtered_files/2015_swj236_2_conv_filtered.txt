Semantic Web 0 (2013) 10
IOS Press

A Closer Look at the Semantic Relationship
between Datalog and Description Logics

Editor(s): Diego Calvanese, Free University of Bozen-Bolzano, Italy; Thomas Lukasiewicz, University of Oxford, UK
Solicited review(s): Riccardo Rosati, Sapienza Universita di Roma, Italy; Marie-Christine Rousset,University of Grenoble, France; anonymous
reviewer

Markus Krotzsch a, Sebastian Rudolph b Peter H. Schmitt c,
a Department of Computer Science, University of Oxford, UK, e-mail: markus.kroetzsch@cs.ox.ac.uk
b Institute of Artificial Intelligence, Technische Universitat Dresden, DE, e-mail: sebastian.rudolph@tu-dresden.de
c Institute for Theoretical Computer Science, Karlsruhe Institute of Technology, DE, e-mail: pschmitt@ira.uka.de

Abstract. Translations to (first-order) Datalog have been used in a number of inferencing techniques for description logics (DLs),
yet the relationship between the semantic expressivities of function-free Horn logic and DL is understood only poorly. Although
Description Logic Programs (DLP) have been described as DLs in the expressive intersection of DL and Datalog, it is unclear
what an intersection of two syntactically incomparable logics is, even if both have a first-order logic semantics. In this work, we
offer a characterisation for DL fragments that can be expressed, in a concrete sense, in Datalog. We then determine the largest
such fragment for the DL ALC, and provide an outlook on the extension of our methods to more expressive DLs.

Keywords: Description Logic Programs, OWL RL, conservative extension, knowledge representation and reasoning

1. Introduction

Ontologies and rules are two major paradigms of
knowledge representation and reasoning. Both have
been successfully applied in many areas, ranging from
logic programming [5] over databases [1] to the Semantic Web [14]. In spite of conceptual and technical
differences, both areas are overlapping in many places,
and the combination of their respective strengths is a
worthwhile and established field of research.

Ontological approaches are most commonly based
on the logical framework of description logics (DLs)
[3]. In particular,
they are the basis for the Direct Semantics of the OWL ontology language [34].
Technically, DLs are a family of fragments of firstorder logic, with different DLs obtained by includ-

*An earlier version of this paper, entitled On the Semantic Relationship between Datalog and Description Logics, has been published in the proceedings of the 4th International Conference on Web
Reasoning and Rule Systems (RR 2010), Springer 2010.

ing or excluding expressive features in order to obtain favourable decidability or complexity properties
for common reasoning tasks. Formulae of DL (called
axioms) are commonly denoted in a variable-free syn-
tax. For example, the following set of DL axioms expresses that every supervisor of a student is a professor
(1), every professor holds some Ph.D. degree (2), and
all professors are either full or associate professors (3):

Student (cid:118) supervisor.Prof,
Prof (cid:118) hasDegree.PhD,
Prof (cid:118) FullProf (cid:116) AssociateProf.

(1)
(2)
(3)

This example corresponds to the following first-order
logic theory:
x.Student(x)  (y.supervisor(x,y) Prof(y)), (4)
x.Prof(x)  y.hasDegree(x, y)  PhD(y),
(5)
x.Prof(x)  FullProf(x)  AssociateProf(x). (6)

1570-0844/13/$27.50 c 2013  IOS Press and the authors. All rights reserved

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

Rule-based approaches are rooted in deductive
databases [1] and logic programming [5]. The common core of these fields are function-free Horn logic
rules, known as Datalog in the context of deductive
databases. Datalog rules are one of the simplest forms
of logical rules. For example, the following example
states that students are supervised by professors as
above (7), and that a supervisor who reviews a paper
authored by her student has a conflict of interest (8):

Student(x)  supervisor(x, y)  Prof(y),

(7)

hasAuthor(x,y)  hasReviewer(x,z)

 supervisor(y, z)  conflict(z). (8)

Such rules can be interpreted as implications under the
semantics of first-order logic or under a least (Her-
brand) model semantics that can be axiomatised in
second-order logic. Fortunately, both semantics entail the same Datalog formulae [1], and in particular
the same ground facts. In this work, we will therefore study Datalog under a first-order semantics that is
compatible with DLs.

A natural question to ask is how DLs and Datalog
 viewed as decidable fragments of first-order logic 
relate to each other. One direction of research explores
how either formalism could be extended with features
of the other. Approaches to extending the expressivity of DLs with first-order rules include AL-log [9],
CARIN [26], SWRL [15,16], DL+log [35], DL-safe
rules [31], and DL Rules [24,12].1 A dual approach is
to extended Datalog with typical DL features, in particular with existential quantification, which results in
formalisms such as Datalog [6], -rules [4], and various related fragments of existential rules; see [22,32]
for recent overviews.

These manifold research activities are based on the
observation that DL and Datalog have distinct modelling capabilities that are not easily reconciled in a
single formalism without sacrificing useful computational properties. For example, DLs feature existential
quantification (2) and disjunction (3), while Datalog
can capture dependency structures that are not expressible in DL axioms (8). However, DL and Datalog also
have some overlapping expressivity. Formulae (1) and
(7), e.g., are semantically equivalent. DLP (Descrip-
tion Logic Programs) has been proposed as a family

of DLs that can be faithfully expressed in first-order
Horn-logic, and in particular in Datalog [13,36]. This
bears computational advantages since rule-based reasoning methods can be applied, and indeed DLP in its
simplest form became the basis of the W3C standard
OWL RL [28].

This raises the core question of this paper:

What is an appropriate exact definition of the semantic intersection of DL and Datalog, i.e., of a
provably maximal logic that can be expressed in
both?

Unfortunately, this question as such leaves room for in-
terpretation. Due to the incomparable syntax, we cannot consider a syntactic intersection of both logics.
Also when transforming DL syntax to first-order logic,
the result is normally not in the form of Datalog rules,
even for DL axioms that are easily expressible in such
form. Neither (1) nor (4), e.g., are equal to (7) above.
Thus one needs to consider semantic criteria for
defining the intersection of DL and Datalog. This,
however, can lead to a language definition for which
checking membership is of very high computational
complexity. Indeed, every inconsistent ontology is semantically equivalent to an inconsistent set of Datalog
rules.2 So checking whether some DL ontology is semantically equivalent, or even merely equisatisfiable,
to some set of Datalog rules is at least as hard as checking satisfiability for a DL knowledge base, i.e., typically at least ExpTime-hard.

On the other hand, restricting to DL knowledge
bases that are equisatisfiable to some set of Datalog
rules may still be insufficient to characterise the intersection of DL and Datalog. For example, it is wellknown that other tractable DLs such as EL++ can also
be translated into equisatisfiable sets of Datalog rules
[25,18,20]. The union of DLP and EL++ is not a DL
for which standard reasoning tasks are tractable (see
[25] for some discussion), so DLP and EL++ may
merely be two among several tractable subsets of the
expressive intersection of DL and Datalog, without
actually capturing the essence of this slogan. Indeed,
tractability was not among the original design goals of
DLP, although it is now considered a major practical
advantage that motivated the use in OWL RL.
Could the union of DLP and EL++ then be considered as an extended version of DLP? Possibly yes,

1Similar approaches exist for extending DLs with non-monotonic
features from logic programming [11,10,35,29,30] which are interesting in their own right but not closely related to this work.

2We generally allow rules with head , interpreted as false. Thus

Datalog rules can be inconsistent.

since it is contained in the DL Horn-SHIQ and
the even more expressive Horn-SHOIQ for which
satisfiability-preserving Datalog transformations are
known [17,33]. However, for EL++ and DLP there
exist modular (i.e., axiom-by-axiom) translations into
Datalog. Opposed to this, the known Datalog transformation for Horn-SHIQ from [17] needs to process
the whole knowledge base in an exponential compilation process to obtain the Datalog output.
The Horn-SHOIQ transformation described in
[33] is more modular and time polynomial, but
a closer look reveals that the signature used by the
knowledge base needs to be fixed and known before-
hand, whence this translation does not allow for axioms being translated independently from each other if
the signature is not bounded.

How can we be sure that there is no simpler transformation given that both data complexity and combined complexity3 of Datalog, Horn-SHIQ, and
Horn-SHOIQ agree? The answer is given in Proposition 4.4 later on. In any case, it is obvious from this
discussion that the design principles for DLP  but also
for EL and Horn-DLs  are not sufficiently well articulated to clarify the conceptual distinction between
those formalisms.

This paper thus approaches an explicit characterisation of a maximal DLP-type logic. After introducing
our basic definitions for description logics and Datalog
in Section 2, we discuss what it means for a logical theory to be expressible in Datalog. To do this, we first
develop concrete requirements for such a language,
that capture the specifics of the original DLP proposal,
in Section 4. The above discussion indicates that some
care is needed to define such principles. Thereafter, we
ask whether DLP could be defined as a larger, or even
as the largest, DL language that satisfies our design
principles. A positive answer to this question is given
by defining such a largest possible Datalog fragment
DLPALC for the DL ALC in Section 5, and proving
its maximality in Section 6. In Section 7, we consider
the generalisation of this approach to SROIQ, and discuss a related study by Krotzsch and Rudolph [21].

3Recall that data complexity is the complexity of reasoning with
respect to the amount of facts/assertions, while combined complexity
refers to the overall size of the input.

Syntax and semantics of ALC concept expressions

Table 1

Syntax Semantics

Atomic concept
Top
Bottom
Conjunction
Disjunction
Negation
Role restrictions

existential
universal

C (cid:117) D CI  DI
C (cid:116) D CI  DI

I \ CI

R.C
R.C

{x | there is y: (cid:104)x, y(cid:105)  RI and y CI}
{x | for all (cid:104)x, y(cid:105)  RI: y  CI}

2. Description Logic and Datalog

We provide a brief introduction to our notation on
description logics (DLs) [3] and Datalog [1]. We use
FOL= for referring to standard first-order logic with
equality, and we use the term theory for a set of closed
formulae (sentences) of FOL= (or another logic that
can be considered as a fragment thereof).

Description Logics DL knowledge bases are defined
over finite sets of individual names (constants) I, concept names A, and roles R. We call S = (cid:104)I, A, R(cid:105) a
signature. A signature S  = (cid:104)I, A, R(cid:105) is called an
extension of S , in symbols S  S , if I  I and
A  A and R  R.
One of the most expressive DLs considered in the
literature is SROIQ but we will only consider the
simpler logic ALC in detail within this paper. Concept expressions (or simply concepts) of ALC are defined recursively as in Table 1. Terminological axioms
(or TBox axioms) of ALC are general concept inclusions (GCIs) of the form C (cid:118) D where C and D are
ALC concepts. Assertional axioms (or ABox axioms)
of ALC are expressions C(a) or R(a, b) where a, b are
individuals, C is a concept expression, and R is a role.
An ALC knowledge base is a set of (terminological
and assertional) axioms of ALC.
The semantics of DLs are based on a Tarski-style
model theory. An interpretation I over a domain I
assigns a set AI  I to each atomic concept A 
A, a binary relation RI  I  I to each role R 
R, and an element aI  I to each individual a 
I. The interpretation of concept expressions is defined
recursively as in Table 1. A GCI C (cid:118) D is satisfied
by I, written I |= C (cid:118) D, it CI  DI. An assertion
C(a) (R(a, b)) is satisfied by I, written I |= C(a) (I |=
R(a, b)), if aI  CI ((cid:104)aI, bI(cid:105)  RI). A knowledge base
KB is satisfied by I, written I |= KB, if I |=  for

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

Transforming ALC axioms to first-order logic

Table 2

Concept Expressions

(, t) = 
(, t) = 
(A, t) = A(t)
(C, t) = (C, t)

(C (cid:117) D, t) = (C, t)  (D, t)
(C (cid:116) D, t) = (C, t)  (D, t)

(R.C, t) = x.R(t, x)  (C, x)
(R.C, t) = x.R(t, x)  (C, x)

Axioms

(C(a)) = (C, a)
(R(a, b)) = R(a, b)

(C (cid:118) D) = x.(C, x)  (D, x)

all axioms   KB. When an interpretation satisfies an
axiom/a knowledge base, we also say that it is a model
of that axiom/knowledge base.
Entailment is defined as usual. A knowledge base
KB1 entails a knowledge base KB2, written KB1 |=
KB2, if every model of KB1 is a model of KB2. A
knowledge base is unsatisfiable (or inconsistent) if it
has no models, and satisfiable (or consistent) other-
wise. We use the same terminology for axioms, treated
as singleton knowledge bases.

Every DL interpretation as defined above can be
considered as an interpretation of FOL= by considering atomic concepts as unary predicates, roles as binary predicates, and individuals as constant symbols.
Indeed, most description logics can be viewed as fragments of first-order logic. Table 2 defines a standard
mapping  from ALC axioms to first-order logic sen-
tences. For a knowledge base KB, we define (KB) to
KB (). It is easy to see that
KB and (KB) have the same models, and thus also the
same consequences. Knowing this, we sometimes treat
DL axioms like first-order sentences, even without using  explicitly.

be the conjunction

Datalog We use the term Datalog to refer to the
function-free Horn logic fragment of FOL=. A Datalog program is a first-order theory which contains only
formulae of the form x.A1 . . . An  B where Ai, B
are atoms without function symbols of arity greater
than 0, and x contains all variables occurring in these
atoms. We generally omit the quantifier, we simply
write B if n = 0. A special nullary atom  is used to
denote falsity. Rules with head  are sometimes called

(integrity) constraints, and are also written by omitting
the head completely.
The semantics of Datalog is defined as for first-order
logic, where  is interpreted as a nullary atom with
constant value false. Entailment and satisfiability are
defined as usual for FOL=.

Note that we allow rules that contain variables in
the head that do not occur in the body, i.e., rules that
are not safe in the sense of the Datalog literature. Se-
mantically, a rule like  B(x) represents the first-order
formula x.B(x). When considering Datalog as a firstorder language, such rules do not require any special
treatment; all properties of Datalog remain unaffected.
Given a fixed signature, one can transform unsafe Datalog into safe Datalog without affecting ground entail-
ments. For this, one adds facts of the form (c) for every constant c  I, and atoms (x) to the body of every
rule that contains a variable x. In this way, rule engines
that are limited to safe Datalog programs can be used
to compute first-order entailments of unsafe programs.

3. Semantic correspondences between logical

theories

We are generally interested in DL knowledge bases
the semantics of which can be expressed in a Datalog
program. In this section, we introduce the kind of semantic correspondence that we find most appropriate
for this task, and we observe a useful lemma that relates this notion to Datalog.

As discussed above, there are various notions of semantic correspondence that could be considered. For
example, we could restrict to knowledge bases KB
such that (KB) is semantically equivalent to a Datalog program. This, however, leads to a very strong requirement that excludes some interesting cases.
Example 3.1 The following ALC assertion states that
Tom has a supervisor who is a professor:

supervisor.Prof(tom).

(9)

Datalog cannot express existential quantifiers in gen-
eral. But this particular case requires the existence of
only one individual (the supervisor of Tom), and the
claimed existence of this individual can be captured
with two facts using an auxiliary constant:

supervisor(tom, ctomsprof),
Prof(ctomsprof).

(10)
(11)

Then (10) and (11) together are just another way of
writing the Skolemisation of (9) with ctomsprof used as
the nullary Skolem function symbol. Thus both forms
are equisatisfiable, but they are not semantically equiv-
alent.

This shows that semantic equivalence might turn out
to be too restrictive, and that equisatisfiability might
be a more suitable form of semantic correspondence.
However, equisatisfiability is too weak, since it does
not preserve relevant logical entailments. In particular,
every satisfiable DL knowledge base is equisatisfiable
to the empty Datalog program, yet this correspondence
has no practical utility for using Datalog-based reasoning methods.

But Skolemisation actually leads to a stronger form
of semantic correspondence that is certainly more useful as a middle-ground between equivalence and equi-
satisfiability:
Definition 3.2 Consider FOL= theories T and T with
signatures S  S . Then T semantically emulates T
if the following conditions hold:
(1) every model of T becomes a model of T when restricted to the interpretations of symbols from S ,
(2) for every model J of T there is a model I of T
that has the same domain as J, and that agrees
with J on S .
It is usually not necessary to mention the signatures
of T and T explicitly, since it is always possible to find
minimal signatures for T and T that satisfy condition
(1) of Definition 3.2. Intuitively speaking, whenever a
theory T semantically emulates a theory T, we find
that T and T encode the same information about the
symbols in T, and in particular that T cannot be distinguished from T when restricting to those symbols.
The concept of semantic emulation is related to the
notion of conservative extensions [27] which, how-
ever, additionally assumes T  T and hence requires
syntactic compatibility of the involved logics. Another
closely related notion is the model-theoretic version of
S -inseparability [19] which holds between two theories if their model classes coincide after being projected to a given signature S . This justifies to introduce the new notion of semantic emulation for our set-
ting. Also note that, in contrast to equivalence and eq-
uisatisfiability, semantic emulation is not a symmetric
relation, since one of the theories introduces additional
internal symbols to its signature. It is not hard to see
that the Datalog program consisting of (10) and (11)

above semantically emulates the DL fact (9) since we
can always find a suitable interpretation for the fresh
constant ctomsprof.

To understand the consequence of Definition 3.2, we

also consider a slightly weaker notion:
Definition 3.3 Consider FOL= theories T and T with
signatures S  S . Then T syntactically emulates T
if for every first-order formula  over S : T |=  iff
T |= .

Note that syntactic emulation of T by T can equivalently be characterized by the requirement that for every formula  over S the sets T  {} and T  {} be
equisatisfiable. It is easy to see that semantic emulation
implies syntactic emulation. The converse is not true in
general, and indeed it is not hard to show that semantic emulation is equivalent to the condition that one
would obtain when considering second-order logic instead of first-order logic in Definition 3.3. In this work,
we use the stronger notion, since it guarantees a maximal amount of semantic interoperability without depending on a particular logic. However, we conjecture
that our results are not affected by this choice. Some
related discussion can be found in Section 7.

An important goal in this work is to show that
certain DL axioms can be semantically emulated in
Datalog. This can be accomplished by noting modeltheoretic properties of Datalog that are not generally
shared by description logics. To this end, we recall two
simple constructions: intersection and product [7].
Definition 3.4 Let I1 and I2 be interpretations over
the same domain , such that cI1 = cI2 for all constants c. The intersection I1  I2 of I1 and I2 is
the interpretation with domain  that interprets constants c as cI1I2  cI1, and predicates p as pI1I2 
pI1  pI2.
Definition 3.5 Let I1 and I2 be interpretations. The
product I1  I2 of I1 and I2 is the interpretation
with domain I1  I2 that interprets constants c as
cI1I2  (cid:104)cI1 , cI2(cid:105), and predicates p as pI1I2 
pI1  pI2.
Models of Datalog are closed under both operations:
Proposition 3.6 Consider interpretations I1 and I2,
and a Datalog program P with I1 |= P and I2 |= P.
1. If I1  I2 is defined, then I1  I2 |= P.
2. I1  I2 |= P.

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

Proof. The arguments for both cases are similar. We
illustrate the case of , which is the less widely known
construction. Consider an arbitrary rule A1. . .An 
B in P. Assume that there is a variable assignment Z
for I1  I2 such that I1  I2,Z |= A1  . . .  An.
Let Zi be the variable assignment for Ii that maps x to
the ith component of Z(x). By definition of I1  I2,
we find Ii,Zi
|= P, we
obtain Ii,Zi |= B. By definition of I1I2, this implies
I1  I2,Z |= B, as required.

|= A1  . . .  An. Since Ii

4. The DLP fragment of a description logic

In this section, we discuss and motivate a generic
definition for DLP fragments of a description logic.
This will provide a meaningful definition for the intersection of DL and Datalog that we will use in the
rest of this paper.

Since DL and Datalog use a different syntax, this
intersection is necessarily asymmetrical in the sense
that DLP must be a fragment of either DL or of Data-
log. In the tradition of the original DLP proposal, we
choose the former [13]. A second defining property of
DLP is the semantic correspondence with some Datalog program. As discussed in the previous section, the
notion of semantic emulation provides a suitable notion for this correspondence.

These requirements alone, however, do not give rise
to viable language definitions yet. As discussed in
the introduction, deciding whether a knowledge base
meets the semantic criteria of being expressible in Datalog may involve complex reasoning. In particular, every inconsistent knowledge base can be semantically
emulated by some Datalog program. Therefore, some
additional criterion is needed to ensure that containment in the language is easy to check.

A powerful tool for obtaining this criterion is the
construction of variants of logical expressions which
preserve only the logical structure but may modify
concrete signature symbols:

Definition 4.1 Let F be a FOL= formula, a DL ax-
iom, or a DL concept expression, and let S be a
signature. An expression F is a variant of F in S
if F can be obtained from F by replacing each occurrence of a role/concept/individual name with some
role/concept/individual name in S . Multiple occurrences of the same entity name in F need not be replaced by the same entity name of S in this process.

A knowledge base KB is a variant of a knowledge
base KB if it is obtained from KB by replacing each
axiom with a variant.

Note that we do not require all occurrences of an entity name to be renamed together, so it is indeed possible to obtain A (cid:117) B from A (cid:117) A. Considering all
variants of a formula or axiom allows us to study the
semantics and expressivity of formulae based on their
syntactic structure, disregarding any possible interactions between signature symbols. We call a FOL= for-
mula, DL axiom, or DL concept expression F nameseparated if no signature symbol occurs more than
once in F. Intuitively speaking, disallowing symbols
to occur in multiple positions in name-separated axioms prevent most of the complex semantic effects that
could require reasoning, i.e., a name-separated axiom
that can only be expressed in Datalog if its formula
structure can generally be captured using rules.

Combining these ideas, we can formally define DLP

fragments:
Definition 4.2 Given description logics L and D, we
call D a DLP fragment of L if
(1) every axiom of D is an axiom of L,
(2) there is a transformation function datalog that
maps every D axiom  to a Datalog program
datalog() such that datalog() semantically emulates ,
(3) D is closed under variants, i.e., given any axiom 
and an arbitrary variant  of , we find  is in D
iff  is.
As discussed above, item (1) of this definition fixes
the syntactic framework for DLP fragments. Item (2)
states the property that motivates the study of DLP lan-
guages: every axiom of a DLP fragment can be expressed in Datalog. DLP languages as discussed in the
literature may require the use of auxiliary symbols for
the translation to Datalog [36], and the Datalog program can no longer be semantically equivalent to the
original knowledge base in this case, even if all consequences with respect to the original predicates are still
the same. This motivates the use of semantic emulation as introduced in Definition 3.2. Note that we do
not require the transformation function datalog to be
computable, although it will turn out to be computable
rather easily in the case studied in this paper.

Item (3) of Definition 4.2 reflects our desire to obtain fragments that correspond to well-behaved logical
languages as opposed to being arbitrary collections of

axioms. An obvious way to implement this would be
to require DLP fragments to be described by a contextfree grammar. A typical feature of grammars for logical languages is that they are parametrised by a logical
signature that can be modified without changing the
essential structural features of the language. This effect is mirrored by the requirement of item (3) without
introducing detailed requirements on a suitable logical
grammar. We will find grammatical descriptions in the
cases we consider, though item (3) as such does not
imply that this is possible.

The original motive for item (3) in Definition 4.2
was to obtain DLP fragments for which membership
can be checked without complex reasoning. A natural
alternative would thus be to require that membership
in a fragment can be decided efficiently, say in polynomial time. However, Proposition 4.3 below shows that
in this case no maximal DLP fragment can exist. Definition 4.2, in contrast, does not impose any restriction
on the complexity of checking the membership rela-
tion, but it admits a maximal DLP fragment for ALC
that can be described by a context-free language (Sec-
tion 5), and thus is efficiently recognisable.
Proposition 4.3 Given description logics L and D,
we call D a P-DLP fragment of L if items (1) and (2)
of Definition 4.2 are satisfied, and in addition there is
a polynomial procedure for deciding   D for any
DL axiom .
Unless the complexity classes P and PSpace coin-
cide, there is no maximal P-DLP fragment of ALC:
given any P-DLP fragment D of ALC, there is a P-
DLP fragment D of ALC that covers more axioms,
i.e, D  D.
Proof. We start with an auxiliary construction: if the
concept expression C is satisfiable and does not contain the symbols R, A1, A2, and c, then no Datalog
program semantically emulates the expression C 
(C (cid:117) R.(A1 (cid:116) A2))(c). For a contradiction, suppose
that C is semantically emulated by a Datalog theory
datalog(C). By construction, C is satisfiable, and so
is {C, Ai (cid:118) } for each i = 1, 2. By Definition 3.3,
we find that datalog(C)  {Ai (cid:118) } is satisfiable, too.
Thus, there are models Ii of datalog(C) such that
= . Thanks to Proposition 3.6, we find a model
AIi
I = I1I2 of datalog(C) such that AI
= . But
then datalog(C){A1(cid:116)A2 (cid:118) } is satisfiable although
{, A1 (cid:116) A2 (cid:118) } is not, contradicting the supposed
semantic emulation.

= AI

Let us now assume for the sake of a contradiction
that D contains all unsatisfiable ALC axioms of the
form of C. This would give a polynomial decision
procedure for deciding satisfiability of ALC concept
expressions C: construct C from C (clearly polyno-
mial) decide C  D (was assumed to be of polynomial complexity). This contradicts the fact that deciding (un)satisfiability of ALC concept expressions is
PSpace-hard.
Therefore, there is an unsatisfiable expression 
with   D. Now let D be defined as D  {}. The
transformation is given by datalog() = datalog() if
  D, and datalog() = {  A(x), A(x)  } oth-
erwise, where A is a new predicate symbol. It is immediate that D P-DLP fragment of ALC strictly greater
than D.

This proof exemplifies a general problem that occurs when trying to define DLP: the question whether
an axiom is expressible in Datalog is typically computationally harder than one would like to admit for a language definition. This result carries over to more expressive DLs, and remains valid even if requirements
such as closure under common normal form transformations are added to the definition of fragments. The
fact that this problem is avoided by item (3) in Definition 4.2 confirms our intuition that this requirement
closely relates to the possibility of representing DLP
fragments syntactically, i.e., without referring to complex semantic conditions.

Next, we establish an interesting general result on
the complexity of reasoning in DLP fragments. By the
size of an axiom, we mean the number of symbols that
are necessary to write it.

Proposition 4.4 Consider a class K of knowledge
bases that belong to a DLP fragment of some description logic, and such that the maximal size of axioms
in K is bounded. Deciding satisfiability of knowledge
bases in K is possible in polynomial time.

Proof. Let the maximal size of axioms be bounded
by N. Let V be a vocabulary with N concept, role and
constant symbols. By assumption we know that for every of the finitely many axioms  of size less than N
there is a translation datalog(). We will use this as
a (finite) look-up table for finding a Datalog transformation for axioms  in KB  K. Note that we do not
need to specify how the translations datalog() were
computed, since we only need to show that there is a
polynomial time algorithm, not how it can be found.

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

We define a Datalog transformation datalogK() for
all axioms   KB that occur in some knowledge
base KB  K. By the assumption on K, there are at
most N signature symbols in . Hence there some axiom  over the vocabulary of V and a 1-1 renaming
 of symbols in  such that () = . We thus define datalogK()  (datalog()). It is easy to see that
datalogK() still satisfies item (2) of Definition 4.2.
Thus satisfiability of KB  K can be decided by
KB datalogK(). The maximal number of variables occurring within these Datalog programs can be bounded by an integer M. Indeed,
M can be taken to be the (finite) number of variables in
 datalog(), where this is the union over all axioms
 for which datalog() was defined above. Note that
M depends only on the choice of N since we can assume w.l.o.g. that the translations datalog() are such
that M is minimal.

checking satisfiability of

Satisfiability of Datalog with at most M variables
per rule can be decided in time polynomial in 2M [8].
The renamings  can be found in time polynomial in
2N. Since N and M are constants, this yields a polynomial time upper bound for deciding satisfiability of

knowledge bases in K.

It is interesting that the previous result does not
require any assumptions on the computational complexity of recognising or translating DLP axioms. In-
tuitively, Proposition 4.4 states that reasoning in any
DLP language is necessarily almost tractable. In-
deed, many DLs allow complex axioms to be decomposed into a number of simpler normal forms of
bounded size, and in any such case tractability is ob-
tained. Moreover, Proposition 4.4 clarifies why HornSHIQ (and thus also Horn-SHOIQ) cannot be in
DLP: ExpTime worst-case complexity of reasoning can
be proven for a class K of Horn-SHIQ knowledge
bases as in the above proposition (see [23], noting
that remaining complex axioms can be decomposed
in Horn-SHIQ). In fact the same argument already
holds for the much weaker DL Horn-FLE [23].

5. The DLP fragment of ALC

Using Definition 4.2, it is now possible to investigate DLP fragments of relevant description logics. In
this paper, we detail this approach for ALC; some remarks on the more complex case of SROIQ are given
in Section 7 below. It turns out that the largest DLP
fragment of ALC exists, and can be defined as fol-

lows, where we use the negation normal form NNF for
simplifying our presentation.
Definition 5.1 The description logic DLPALC consists of all knowledge bases that contain only ALC
axioms which are

 GCIs C (cid:118) D such that NNF(C (cid:116) D) is an LH

concept as defined in Fig. 1, or

cept as defined in Fig. 1.

 ABox axioms C(a) where NNF(C) is an La con-
 ABox axioms R(a, b) where R  R is a role name.
The headings in Fig. 1 give the basic intuition about
the significance of the various concept languages. The
distinction of head and body concepts is typical for
many works on DLP and Horn DLs, while our use of
additional assertional concepts takes into account that
emulation allows for some forms of Skolemisation.

Example 5.2 Some typical example representatives of
the head, body, and assertion grammars in Fig. 1 are
as follows:

A (cid:117) R.(B (cid:116) C)  LB,
A (cid:116) (B (cid:117) R.C)  LH,
A (cid:116) R.B  La.

(12)

(13)

(14)
Concept (13) corresponds to the DLPALC axiom A (cid:118)
B(cid:117)R.C, while (14) can be used in assertions such as
(A (cid:116) R.B)(c). Typical examples of axioms that are
not in DLPALC include A (cid:118) B(cid:116)C and (B(cid:116)C)(a), and
also A (cid:118) R.B. In contrast, (R.B)(a) is in DLPALC.
Though name separation prevents most forms of semantic interactions within concepts, we still require
grammars for L and L to characterise concepts
all variants of which are equivalent to  and , re-
spectively. This includes concept expressions such as
A (cid:117) R. and B (cid:116) R..

We start with an easy observation on Definition 5.1.
This result will not explicitly be used later on but might
add to the understanding of this definition.
Lemma 5.3 Consider arbitrary ALC concept expressions C that do not contain quantifiers , , and the
symbols  and .
1. If C  LB then C has a conjunctive normal form

j Ci, j with Ci, j a negated atom for all i, j.

Concepts necessarily equivalent to :
Concepts necessarily equivalent to :
Body (C  LB iff C (cid:118) A in DLPALC):
Head (C  LH iff A (cid:118) C in DLPALC):
Assertions (C  La iff C(a) in DLPALC): La  LH | R.La | La (cid:117) La | La (cid:116) LB

L   | R.L | L (cid:117) L | L (cid:116) C
L   | R.L | L (cid:117) C | L (cid:116) L
LB  L | L | A | R.LB | LB (cid:117) LB | LB (cid:116) LB
LH  LB | A | R.LH | LH (cid:117) LH | LH (cid:116) LB

Fig. 1. DLPALC concepts in negation normal form

Fig. 2 and 3. The function dlgB constructs Datalog to
semantically emulate GCIs of the form A (cid:118) C with
C  LB, while dlgH allows us to semantically emulate
GCIs A (cid:118) C with C  LH.
Example 5.4 Let E be the LH concept A(cid:116)(B(cid:117)R.C)
as in (13). The rules of dlgH(D (cid:118) E) are as follows:

D(x)  X1(x)  X2(x)
A(x)  X1(x)
X2(x)  B(x)
X2(x)  R(x, y)  X3(x)
X3(x)  C(x)

Clearly, this rule set could be further simplified to obtain the three rules D(x)  A(x)  X2(x), X2(x) 
B(x), X2(x)  R(x, y)  C(x) which are easily seen to
semantically emulate D (cid:118) E.

The correctness of dlgB and dlgH is shown in the fol-

lowing two lemmas.

Lemma 5.5 Given a concept name A, and a concept
C  LB, Fig. 2 recursively defines a Datalog program
dlgB(A (cid:118) C) that semantically emulates A (cid:118) C.
Proof.
The claim is shown by induction over the
structure of C. We illustrate one case.
Consider the case C = D1 (cid:116) D2. To show Definition 3.2 (1), assume that I |= dlgB(A (cid:118) C). In partic-
ular, I |= dlgB(X1 (cid:118) D1) and I |= dlgB(X2 (cid:118) D2).
By the induction hypothesis, I |= X1 (cid:118) D1 and
I |= X2 (cid:118) D2. Since I |= X1(x)  X2(x)  A(x), for
any   AI, we find that   XI
1 for some i  {1, 2}.
Thus,   DI
i follows from I |= Xi (cid:118) Di. Since  was
arbitrary, I |= A (cid:118) D1 (cid:116) D2.
To show Definition 3.2 (2), assume that I |= A (cid:118)
C. An interpretation I over the extended signature is
for i  {1, 2}. It
defined by setting XI
is easy to see that I
| i  {1, 2}} 
{X1(x)  X2(x)  A(x)}. By the induction hypothesis,
we can find an interpretation I1 that extends I and
such that I1 |= dlgB(X1 (cid:118) D1). Another application

 I \ DI
|= {Xi (cid:118) Di

2. If C  LH or C  La then C has a conjunctive
normal form
j Ci, j with Ci, j negated or nonnegated atoms and for every i there is at most one
j such that Ci, j is an non-negated atom.
(Since the assumptions require that C does not
contain quantifiers there is no difference here between C  LH and C  La.)

Proof. Notice that C  L and C  L since neither
 nor  occur in C. For item (1), note that if C  LB
then either C is a negated atom, or C = C1 (cid:117) C2 or
C = C1 (cid:116) C2 with Ci  LB. The claim now follows
easily from the induction hypothesis on C1, C2.
For item (2), by the assumptions on C we have C 

LH if one of the following cases holds true:
1. C  LB. Then the claim follows from part (1) of

the lemma.

2. C is an atom. Then the claim is obviously true.
3. C = C1 (cid:117) C2 with Ci  LH. If C
i is a conjunctive
1 (cid:117)
normal form of Ci satisfying the claim then C

2 is a conjunctive normal form of C satisfying
the claim.
4. C = C1 (cid:116) C2 with Ci  LH and C1  LB.
m,n be the conjunc-
Let
tive normal forms that exist by induction hypothesis satisfying the respective claims. A conjunctive normal form of C = C1(cid:116)C2 is obtained as the
m,n for all combi-
j C1
i, j contains at most one
m,n contains only negative

conjunction of all
nations of i, m. Since
positive atom and

i, j(cid:116)

atoms we are finished.

j C1

i, j and

n C2

n C2

n C2

j C1

It is obvious that DLPALC satisfies items (1) and
(3) of Definition 4.2, so what remains to show is
that DLPALC knowledge bases can indeed be expressed in Datalog. Following the grammatical structure of DLPALC, we specify various functions for
constructing Datalog programs to semantically emulate a DLPALC knowledge base. GCIs are handled
by the functions dlgB and dlgH, defined recursively in

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

dlgB(A (cid:118) C) =

{}
{A(x)}
{B(x)  A(x)}
dlgB(X (cid:118) D)  {R(x, y)  X(y)  A(x)}
dlgB(A (cid:118) D1)  dlgB(A (cid:118) D2)
dlgB(X1 (cid:118) D1) dlgB(X2 (cid:118) D2)  {X1(x)  X2(x)  A(x)}

if C  L
if C  L
if C = B
if C = R.D
if C = D1 (cid:117) D2  (LB (cid:117) LB)
if C = D1 (cid:116) D2  (LB (cid:116) LB)

Fig. 2. Transforming axioms A (cid:118) C to Datalog, where A  A, C  LB, and X(i) are fresh concept names


dlgH(A (cid:118) C) =

dlgB(X (cid:118) C)  {A(x)  X(x)  }
{A(x)  C(x)}
dlgH(X (cid:118) D)  {A(x)  R(x, y)  X(y)}
dlgH(A (cid:118) D1)  dlgH(A (cid:118) D2)
dlgH(X2 (cid:118) D1)  dlgB(X1 (cid:118) D2)  {A(x)  X1(x)  X2(x)}

if C  LB
if C  A
if C = R.D
if C = D1 (cid:117) D2
if C = D1 (cid:116) D2  (LH (cid:116) LB)

Fig. 3. Transforming axioms A (cid:118) C to Datalog, where A  A, C  LH, and X(i) are fresh concept names

of the hypothesis yields a model I2 |= dlgB(A (cid:118) C)

as required to show the claim.

Lemma 5.6 Given a concept name A, and a concept
C  LH, Fig. 3 recursively defines a Datalog program
dlgH(A (cid:118) C) that semantically emulates A (cid:118) C.
Proof. First note that dlgH(A (cid:118) C) is well-defined.
In particular, programs dlgB(B (cid:118) D) are only used if
D  LB. The inductive proof of the claim is similar to

the proof of Lemma 5.5, so we omit the details.

For translating concept assertions to Datalog, we define a function dlga in Fig. 4. The construction of Fig. 4
uses a guard concept E that is used to defer the encoding of LB disjunctions: dlgH(C(a), E) semantically
emulates (C (cid:116) E)(a). To encode an assertion C(a), the
program dlgH(C(a),) is used. As before, this transformation is designed for a concise definition, not for
optimised output.

Example 5.7 Let E be the La concept A (cid:116) R.B as
in (14). Then dlgH(E(a),) consists of the following
rules (Xi and Y indicating fresh concept names as in
the definition of the transformation):

A(x)  X1(x)
X2(a)  Y(b)
 X3(x)
 X5(b)
X7(x)  B(x)

X2(a)  R(a, b)
X3(x)  X4(x)  X2(x)
X1(x)  X4(x)
X5(x)  X6(x)  X7(x)
Y(x)  X6(x)

As before, this rule set can be simplified significantly
by eliminating most of the introduced auxiliary concept symbols. Doing this, we obtain the three rules
A(x)  X2(x), X2(a)  R(a, b), and X2(a)  B(b),
which again are easily seen to semantically emulate
E(a) as claimed. Here, the fresh constant symbol b acts
as a Skolem constant that represents the individual that
the existential concept expression may require to exist.

Note that some Datalog rules created in Example 5.7
are not safe. As explained in Section 2, this is not a
principal issue.
Lemma 5.8 Given a constant a and a concept C 
La, Fig. 4 recursively defines a Datalog program
dlgH(C(a),) that semantically emulates C(a).
Proof. As before, the proof works by induction. The
induction claim is that, for every E  LB, C  La, and
a  I, the program dlgH(C(a), E) semantically emulates (C (cid:116) E)(a).
The concept E is processed in case C  LH by using
dlgH. Another more interesting case is C = R.D. The

dlga(C(a), E) =

dlgH(X (cid:118) C (cid:116) E)  {X(a)}
dlga(D1(a), E)  dlga(D2(a), E)
dlgB(X (cid:118) D2)  dlga(D1(a), E (cid:116) X)
dlgB(X (cid:118) E)  dlga(D(b),Y)  {X(a)  R(a, b), X(a)  Y(b)} if C = R.D

if C  LH
if C = D1 (cid:117) D2
if C = D1 (cid:116) D2  (La (cid:116) LB)

Fig. 4. Transforming axioms C(a) to Datalog, where C  La, E  LB, X, Y are fresh concept names, and b is a fresh constant

basic encoding works by standard Skolemisation, but
the guard concept is also processed and a new guard
Y is created for the Skolem constant d. It is not hard

to show semantic emulation in all cases.

Combining the previous lemmata, we obtain the em-

ulation theorem for DLPALC.
Theorem 5.9 For every DLPALC axiom  as in Definition 5.1, one can construct a Datalog program dlg()
that semantically emulates .

If  = C (cid:118) D is a TBox axiom, define
Proof.
datalog()  dlgH(A (cid:118) NNF(C (cid:116) D))  {A(x)}. If
 = C(a) is an ABox axiom, define datalog() 
dlga(C(a),). The result then follows by Lemma 5.6

and 5.8.

6. Maximality of DLPALC

It remains to show that DLPALC is indeed the
largest DLP fragment of ALC. In general, Proposition 3.6 can be used to show that a logical theory T
cannot be semantically emulated in Datalog as follows:
based on the assumption that T is semantically emulated by a Datalog program PT , one constructs interpretations I1 and I2 such that I1 |= PT and I2 |= PT
and shows that either I1  I2 |= PT or I1  I2 |= PT ,
contradicting Proposition 3.6. We use I1  I2 to show
that DLP cannot contain existential axioms like R.A
(Lemma 6.7), and I1  I2 to show that it cannot contain disjunctive axioms like A (cid:116) B (Lemma 6.10).

We can simplify our arguments by means of the
following syntactic simplification for concepts of the
form L and L.
Definition 6.1 Let C be an ALC concept expression
in negation normal form, i.e., such that C = NNF(C).
The expression etb(C) (eliminate top and bottom) is

obtained from C by applying exhaustively the following rewrite rules:

 (cid:117) D  D
 (cid:116) D  
D (cid:117)   D
D (cid:116)   
R.  

 (cid:116) D  D
 (cid:117) D  
D (cid:116)   D
D (cid:117)   
R.  

Note, that etb(C) may still contain subexpressions of
the form R. and R.. The next lemma summarises
some easy observations on etb.
Lemma 6.2 For any ALC concept C = NNF(C):
1. etb(C) is logically equivalent to C, i.e., for any
2. for every L  {L, L, La, LB, LH}, we have C 

interpretation I, we have CI = etb(C)I;
L iff etb(C)  L;
3. if C does not contain subexpressions of the form
R. or R. then etb(C) = , or etb(C) = ,
or etb(C) does neither contain  nor .

We now introduce some simple ways of constructing interpretations that assign specific extensions to
name-separated concepts of the form etb(NNF(C)). For
an arbitrary concept C, we write CI  CJ to express
that I is defined for all symbols X that occur in C by
setting XI  XJ. First, we define interpretations that
map concepts to the whole domain and to the empty
set, respectively.

Definition 6.3 Consider a set , and a name-separated
concept C   such that C = etb(NNF(C)). We recursively define an interpretation I(C) over  that is
defined on all signature symbols in C:

 If C = , then I(C) is defined on no symbol.
 If C = A is an atomic concept, then AI(C)  .
 If C = A with A atomic, then AI(C)  .
 If C = C1 (cid:117) C2 or C = C1 (cid:116) C2, then CI(C)
CI(C1)

and CI(C)

 CI(C2)

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

 If C = R.D, then RI(C)  {(cid:104), (cid:105) |   } and
 If C = R.D, then RI(C)   and the interpreta-

DI(C)  DI(D).

tion of symbols in D is arbitrary.

Moreover, for a name-separated concept C  
with C = etb(NNF(C)), we define an interpretation
I(C)  I(NNF(C)).

Note that I(C) is well-defined: the case C = 
cannot occur, and in the cases of C = C1 (cid:117) C2, C =
C1 (cid:116) C2, and C = R.D, we find C1  , C2  , and
D  , respectively, since C = etb(C). The following
is immediate from the definition.

Lemma 6.4 Consider a concept C = etb(NNF(C)). If
C  , then CI(C) = . If C  , then CI(C) = .

Next, we define an interpretation I[C (cid:123) D] that
extends an interpretation I over a concept D to a larger
concept C of which D is a subconcept in such a way
that CI[C(cid:123)D] = DI.

Definition 6.5 Consider a name-separated concept C
with a non-negated occurrence of a subconcept D.
Given an interpretation I that is defined for symbols in
D, we recursively define an interpretation I[C (cid:123) D]
as follows:

 CI(C1)

and CI[C(cid:123)D]

 If C = D, then I[C (cid:123) D]  I.
 If C = C1 (cid:117) C2 and D occurs in C2, then
CI[C(cid:123)D]
 CI[C2(cid:123)D]

The case where D occurs in C1 is analogous.
 If C = C1 (cid:116) C2 and D occurs in C2, then
CI[C(cid:123)D]
 CI[C2(cid:123)D]

The case where D occurs in C1 is analogous.
 If C = R.E or C = R.E, and D occurs in E,
then RI[C(cid:123)D]  {(cid:104), (cid:105) |   I} and EI[C(cid:123)D] 
EI[E(cid:123)D].

and CI[C(cid:123)D]

 CI(C1)

Again, it is easy to see that I[C (cid:123) D] is well-
defined. In particular, the occurrence of D is unique
since C is name-separated. In cases C = C1 (cid:117) C2 and
C = C1 (cid:116) C2, we find that C1, C2  {,} since
C = etb(C). Moreover, the cases C = , C = ,
C = A, and C = A are subsumed by the case C = D.
For C = A, this follows since D does not occur in a
negation.
Lemma 6.6 If C, D, and I are as in Definition 6.5,
then CI[C(cid:123)D] = DI.

Proof. The proof is again immediate in most cases.
For the cases of C = R.E and C = R.E, it is useful
to note:
(R.E)I[C(cid:123)D]
= {a   | b  EI[E(cid:123)D] for all (cid:104)a, b(cid:105)  RI[C(cid:123)D]}
= {a   | a  EI[E(cid:123)D]} = EI[E(cid:123)D],
(R.E)I[C(cid:123)D]
= {a   | there is (cid:104)a, b(cid:105)  RI[C(cid:123)D] with b  EI[E(cid:123)D]}
= {a   | a  EI[E(cid:123)D]} = EI[E(cid:123)D].

In either case, the claim follows by induction.

To show that DLPALC is maximal with respect to
concept inclusions, we first observe that the use of
existential quantification is severely restricted in the
concept inclusions of any DLP fragment of ALC. In
essence, the following lemma states that etb is able to
eliminate all existential quantifiers.

Lemma 6.7 Let C be a name-separated concept with
C = etb(NNF(C)) that contains a subconcept of the
form R.D. Then  (cid:118) C cannot be semantically emulated in Datalog.
Proof. Suppose for a contradiction that  (cid:118) C can be
semantically emulated in Datalog. Let  be an infinite
domain with enumerated elements  = {1, 2, . . .}.
We define an interpretation I over  by setting DI 
DI(D) and RI  {(cid:104)i, i+1(cid:105) | i  1}. We extend I to
C to obtain an interpretation J  I[C (cid:123) R.D]. By
Lemma 6.4, DI = DJ = , and thus also R.DI =
R.DJ = . By Lemma 6.6, CJ = R.DI = .
By assumption,  (cid:118) C can be semantically emulated by some Datalog program PC. Thus there is an
extension J1 of J such that J1 |= PC. By Definition 3.2, CJ1 = CJ and RJ1 = RJ. An element   
is anonymous if no constant (of the extended signature
of PC) is interpreted as . Since  is infinite, there are
infinitely many anonymous elements. Let i and  j be
two anonymous elements for which there are elements
i(cid:105),(cid:104) j, 
i ,  j, 
i and 


are pairwise distinct. Such elements exist by construction of RJ and since  is infinite.
We define an interpretation J2 that agrees with J1
in all aspects, other than the definition of RJ2 which is

j(cid:105)  RJ and i, 

j such that (cid:104)i, 

RJ2  RJ  {(cid:104)i, 
j(cid:105),(cid:104) j, 
i(cid:105)} \ {(cid:104)i, 
i(cid:105),(cid:104) j, 
j(cid:105)}.

It is easy to see that J2 |= PC. Indeed, J1 and J2 cannot be distinguished by any first-order logic formula.
By construction, we still have CJ2 = R.DJ2 = .
By Proposition 3.6, J1  J2 |= PC. Since J1 and
J2 agree on all symbols other than R, we still have
CJ1J2 = R.DJ1J2. However, RJ1J2 does not contain any pair of the form (cid:104)i, 	(cid:105) or (cid:104) j, 	(cid:105). Thus, i,  j 
R.DJ1J2, and hence CJ1J2  . Therefore, J1J2
is a model of PC that is no model of C, which contra-

dicts Definition 3.2.
The previous proof uses the intersection of J1 and
J2 to show that a formula C cannot be semantically
emulated in Datalog. Interpretation J1 is obtained by
semantic emulation from a model J |=  (cid:118) C, while
J2 is constructed by modifying J1. It would be easier
to construct two models I1 and I2 or C such that I1 
I2 |=  (cid:118) C, but this would not show the claim, as
illustrated by the next example.
Example 6.8 The axiom R.(c) is in DLPALC, and
indeed it can be semantically emulated by the Datalog
program R(c, d) where d is a fresh constant. However,
there are models I1 |= R.(c) and I2 |= R.(c)
that agree on constants, whereas I1  I2 |= R.(c).
For example, let   {c, d1, d2}, RI1  {(cid:104)c, d1(cid:105)}, and
RI2  {(cid:104)c, d2(cid:105)}. For both i = 1 and i = 2, Ii extends
to a model Ji of R(c, d) by setting dJi  di. Proposition 3.6 is not applicable since J1 and J2 do not agree
on the interpretation of the constant d.

Lemma 6.7 allows us to exclude existential quantification from DLP. It remains to exclude disjunctive in-
formation. Disjunctions of the form LB (cid:116) LH are not
problematic  they include DLP axioms like A (cid:116) B.
Our interest is is therefore in disjunctions C1 (cid:116) C2
where neither C1 nor C2 is in LB. The next lemma
shows that any such concept contains a positive occurrence of an atomic concept or role.

Lemma 6.9 Let C be a concept with C = etb(NNF(C))
such that C  LB. Then C contains a non-negated subconcept that is either an atomic concept A or of the
form R.D.
Proof. We show the contrapositive: every concept C
with C = etb(NNF(C)) that contains no subconcept as
in the claim is in LB. This follows from an easy induction over the structure of ALC concepts. If C = A is
atomic, then it has a non-negated atomic subconcept,
contradicting our assumption. If C = , C = , or
C = A for an atom A, then the claim holds by defi-

nition of LB. If C is of the form C1 (cid:117) C2, C1 (cid:116) C2, or
R.C1, then the claim holds for C1, C2  LB by induction hypothesis; thus C  LB by definition of LB. If
C = R.D, then it has a non-negated subconcept of the
form R.D, contradicting our assumption.

We can now show that DLP cannot express disjunc-

tions in GCIs or concept assertions.

Lemma 6.10 Let C be a name-separated concept with
C = etb(NNF(C)) that contains a subconcept of the
form C1 (cid:116) C2 with C1, C2  LB. Then neither  (cid:118) C
nor C(a) can be semantically emulated in Datalog.
Proof. By Lemma 6.9, each of the concepts Ci (i 
{1, 2}) contains a non-negated subconcept Di that is either atomic or of the form R.D. In the latter case we
assume without loss of generality, that Di is an outermost existential subconcept in Ci, that is, Di does not
occur in a concept E for which S .E is a subconcept
of Ci. Let  be an arbitrary nonempty domain, and let
Ii  I(Di) (i  {1, 2}). By Lemma 6.4, DIi
= .
We extend Ii to C by defining Ji  I[C (cid:123) Di]. By
= . Clearly Ji |=  (cid:118) C and
Lemma 6.6, CJi = DIi
|= C(a), where the interpretation aJi can be arbi-
Ji
trary.
Suppose for a contradiction that  (cid:118) C can be semantically emulated by a Datalog program PC. Thus
there is an extension J
i of Ji such that J
|= PC.
i = CJi. By Proposition 3.6,
By Definition 3.2, CJ

1  J
= . The definition of I[C (cid:123)
We claim that D
D2] ensures (C1 (cid:116) C2)I[C(cid:123)D2] = DI2
2 ; this is achieved
. We have I(C1) =
 CI(C1)
by setting CI[C(cid:123)D2]
I(NNF(C1)). If D1 is atomic, it occurs as D1 in
NNF(C1), and we find DI(D1)
= . If D1 is of the form R.D, then it
DJ2
leads to a subconcept R.NNF(D) in NNF(C1), and
2 = . Again, we
we find RI(NNF(C1)) = RJ2 = RJ
= .
obtain D
= . By induction
on the structure of Ci and the corresponding cases in
the definition of I[Ci (cid:123) Di], one can show C

1J

1J

Thus, J

2 = . This implies
= . Thus, (C1 (cid:116) C2)J
2 = , again by induction on the structure of C.
2 |= PC but J
2 |=  (cid:118) C, con-
1  J
tradicting the supposed semantic emulation. The proof
for the case of C(a) is similar. In fact, we can use the
same interpretations: clearly J1 |= C(a), J2 |= C(a),
and J

= . Analogously, one can show D

1J
1  J

= DI(NNF(C1))

We thus find D

1  J

2 |= C(a).

2 |= PC.

1J

1J

= D

= D

1J

M. Krotzsch, S. Rudolph, P. H. Schmitt / A Closer Look at the Semantic Relationship between Datalog and Description Logics

The main result of this section can now be established by noting that every ALC axiom that does not
contain either of the problematic cases discussed in
Lemmas 6.7 and 6.10 is an axiom of DLPALC.
Theorem 6.11 DLPALC is the largest DLP fragment
of ALC.
Proof. Let F be an arbitrary DLP fragment of ALC,
and let   F a name-separated axiom of F . In
particular,  can be semantically emulated in Data-
log. We show that   DLPALC. Since  is arbitrary and DLP is closed under variants, this shows that
F  DLPALC.

If  is a GCI, then, by Lemmas 6.7 and 6.10,
etb(NNF()) does not contain an existential quantifier or a subconcept C1 (cid:116) C2 with C1, C2  LB. We
show that this implies etb(NNF())  LH, which implies   LH by Lemma 6.2 and the definition of
DLPALC. The proof is by induction on the structure
of C = etb(NNF()). If C = , C = , C = A, or
C = A for an atomic concept A, then C  LH by the
grammar. If C = C1 (cid:117) C2, then, by the induction hy-
pothesis, C1, C2  LH; hence C  LH. If C = C1 (cid:116) C2,
then again C1, C2  LH by induction. In addition, by
the assumption on C, we have C1  LB or C2  LB;
thus C  LH. If C = R.D, the claim is again immediate by induction. The case C = R.D cannot occur by
our assumption on C.

The proof for the case where  is a concept assertion
C(a) is similar, but using only Lemma 6.10 to ensure
that etb(NNF(C)) does not contain a subconcept C1 (cid:116)
C2 with C1, C2  LB. Then etb(NNF(C))  La follows
again by induction, where the case C = R.D is now
immediate from the definition of La.
clearly in DLPALC, too.

Finally, if  is a role assertion R(a, b), then it is

7. The Datalog fragment of SROIQ

The previous sections showed that syntactic descriptions tend to become rather complex when maximising languages in a canonical way, but the situation is
substantially more intricate when considering SROIQ
instead of ALC as an underlying DL. In this section,
we discuss some of the related problems by means of
examples, and we review related work by Krotzsch
and Rudolph, who have identified a DLP fragment of
SROIQ that is maximal under some additional restrictions [21].

Among the additional features of SROIQ, there are
two that make the relationship to Datalog highly com-
plicated. Nominals are concepts of the form {c} for a
constant c  I, which are interpreted as singleton sets
{c}I = {cI}. Unions of nominals can express concepts
of a certain maximal cardinality. Number restrictions
are concepts of the form n R.C and n R.C, where
n is a non-negative number, and which denote the set
of individuals that have at least n and at most n R-
successors in C, respectively. In particular, one can express R.C as 1 R.C, and R.C as 0 R.C.
Example 7.1 The concept {a} (cid:116) {b} (cid:116) {c} has at most
three instances, possibly less if the interpretations of
two of the constant symbols coincide. Therefore, the
expression 4 R.({a}(cid:116){b}(cid:116){c}) is equivalent to , and
can thus be expressed in Datalog. The negated concept
4 R.({a}(cid:116){b}(cid:116){c}), which is equivalent to 3 R.({a}(cid:116)
{b} (cid:116) {c}), is therefore equivalent to .

Note that all concepts in the previous example are
name-separated. This illustrates that more elaborate
grammars are needed to define classes L and L for
SROIQ.

The interaction of nominals, unions, and number
restrictions becomes more complex in cases where
the cardinality of a nominal equals the cardinality expressed in a restriction.
Example 7.2 The axiom A (cid:118) R.{c} can be expressed
by the Datalog rule A(x)  R(x, c). This case is widely
known  the ontology language OWL RL even includes
a dedicated syntactic construct ObjectHasValue for
concept expressions of the form R.{c} [28].
It is less known that this can be generalised to larger
numbers. For instance, the axiom A (cid:118) 2 R.({c} (cid:116) {d})
can be expressed by the Datalog program
{A(x)  R(x, c), A(x)  R(x, d), A(x)  c  d  },
which uses the equality predicate . It is well-known
that  can easily be axiomatised in Datalog using a
standard equality theory.

Even more intricate types of interaction between
nominals and unions can occur in concept assertions.

Example 7.3 In concept assertions, nominals are not
necessary to express  -restrictions. For example,
(2 R.A)(c) is semantically emulated by the program
{R(c, s1), R(c, s2), A(s1), A(s2), s1  s2  },

where s1 and s2 are fresh Skolem constants. This gen-

eralises the case of  in DLPALC assertions. How-
ever, the filler concept A can be significantly more
complex and even include disjunction. For example,
the assertion (2 R.({a} (cid:116) A (cid:116) B))(c) is expressed by
the following program

{R(c, s1), R(c, s2), s1  s2  ,
a  s1  A(s1), a  s2  B(s2)},

1 and s

which allows limited forms of disjunction by using the
fact that only at most one of the two Skolem constants
can be equal to a. Clearly, there are two distinct R-
successors of c in every model. At most one of them can
be equal to a (and thus fail to be an instance of {a}): if
s1  a, then A(s1); if s2  a, then A(s2). This reasoning
is strictly deterministic, yet it expresses a certain form
of disjunction. By introducing further pairs of distinct
successor constants s
2 (not necessarily distinct
to s1 and s2), one can allow arbitrarily many disjunctive cases, e.g., to encode (2 R.({a}(cid:116) A(cid:116) B(cid:116)C))(c).
The proof of Lemma 6.10 is not applicable to Example 7.3, since we cannot construct an interpretation
I({a}) with {a}I({a}) = . More generally, the
utility of product models is limited when dealing with
nominals. In the above example, I1  I2 |= s1  a
holds only if both I1 |= s1  a and I2 |= s1  a. So
whenever I1  I2 |= s1  a, we find that I1 |= A(s1)
and I2 |= A(s1), and hence I1  I2 |= A(s1).

Krotzsch and Rudolph consider more complex
forms of product constructions to show the limits of
the encoding approach of Example 7.3 [21]. This allows them to show that an expression of the form
(n R.(({a1} (cid:117) . . . (cid:117) {am}) (cid:116) A (cid:116) B))(c) can be semantically emulated in Datalog exactly if m  n2 
n. Moreover, they discover further kinds of encodings that are different from Example 7.3. A consequence of their findings is, for example, that the assertion C(e) can be expressed in Datalog for C =
4 R.(A (cid:116) {a} (cid:116) ({b} (cid:117) 1 S .({c} (cid:116) {d}))) but not for
C = 3 R.(A(cid:116){a}(cid:116)({b}(cid:117)1 S .({c}(cid:116){d}))), although the
two cases only differ in the initial number restriction.
Another special case that needs to be considered occurs when a SROIQ axiom restricts the overall size of
the domain.
Example 7.4 The axiom  (cid:118) {a} can only be satisfied
by models with a domain that has exactly one element,
denoted by a. In such a case, every expression of the
form  (cid:118) n R.C with n  1 is equivalent to . Thus,
the axiom  (cid:118) {a} (cid:117) 3 R.(A (cid:116) B) can be expressed by
the (unsafe) Datalog rule a  x.

Krotzsch and Rudolph systematically study all of
these cases to arrive at a grammatical description of a
DLP fragment of SROIQ [21]. The resulting grammar
is significantly more complicated than in our case. To
curtail this complexity, they additionally require DLP
to be closed under the computation of disjunctive normal forms. Clearly, if an axiom can be semantically
emulated in Datalog, the same is true for its disjunctive
normal form, but not necessarily for all variants (in the
sense of Definition 4.1) of this normal form. It is conjectured that this additional requirement is not essential for the existence of a maximal DLP fragment.

Another difference to our work is that FOL=-
emulation is used instead of semantic emulation as the
main semantic criterion for defining DLP. We conjecture that this does not have any impact on the resulting
fragments. It mainly affects the proofs: instead of comparing models of DL axioms and Datalog, one needs
to compare entailments. Our model-theoretic construc-
tions, such as I(C), are replaced by auxiliary Datalog
programs, such as the program (cid:126)C (cid:118) (cid:127)A that entails
that C is empty.

Besides this, the main difference to our work is the
significant increase in complexity that makes it harder
to follow the essential ideas. The restriction to nameseparated axioms in Definition 4.2 cannot prevent this
complexity, but it still suffices to ensure the existence
of a maximal DLP fragment that can be described by a
context-free grammar.

8. Conclusions and Outlook

DLP provides an interesting example of a general
type of problem: given two knowledge representation
(KR) formalisms that can be translated to first-order
logic, how can we syntactically characterise all theories of the source formalism that can faithfully be represented in the target formalism? In this work, we proposed to interpret faithful representation by means
of semantic emulation (a weaker notion of semantic
equivalence), while syntactic has been realised by
requiring closure under variants (non-uniform renamings of signature symbols). These two simple principles allowed us to show the existence of a largest DLP
fragment for the DL ALC. In this sense, we argue
that our approach introduces a workable definition for
the vague notion of the intersection of two KR for-
malisms.
Our rigorous definition of DLP fragments also clarifies the differences between DLP and the DLs EL and

Horn-SHIQ which can both be expressed in terms
of Datalog as well. Neither EL nor Horn-SHIQ can
be semantically emulated in Datalog but both satisfy
a weaker version of syntactic emulation that is obtained by restricting to variable-free formulae  in Definition 3.3. Under such weaker requirements, a larger
space of possible DL fragments is allowed, but it is
unknown whether (finitely many) maximal languages
exist in this case. There is clearly no largest such lan-
guage, since both EL and DLP abide by the weakened principles whereas their (intractable) union does
not (this follows from Proposition 4.4).
Even when weakening the requirements of DLP
fragments like this, Horn-FLE and thus its prominent super-logics Horn-SHIQ and Horn-SHOIQ are
still excluded by Proposition 4.4, which explains why
Horn-SHIQ cannot be translated to Datalog axiom-
by-axiom. In the presence of transitivity, Horn-SHIQ
also is not really closed under variants, but this problem could be overcome by using distinct signature
sets for simple and non-simple roles. Again, it is open
which results can be established for Horn-SHIQ-like
DLs based on the remaining weakened principles.

This work also explicitly introduces a notion of emulation that appears to be novel, though loosely related
to conservative extensions. In essence, it requires that
a theory can take the place of another theory in all logical contexts, based on a given syntactic interface. Examples given in this paper illustrate that this can be
very different from semantic equivalence. Yet, emulation can be argued to define minimal requirements
for preserving a theorys semantics even in combination with additional information, so it appears to be a
natural tool for enabling information exchange in distributed knowledge systems. We think that the articulation of this notion is useful for studying the semantic
interplay of heterogeneous logical formalisms in gen-
eral.

ments as used for DLP in this work. At the same time,
our study of SROIQ indicates that the required definitions and arguments can become surprisingly complex when dealing with a syntactically rich formalism like description logic. The main reason for this is
that constructs that are usually considered syntactic
sugar have non-trivial semantic effects when considering logical fragments that are closed under variants.
Acknowledgements The first and the second author
have been working at Karlsruhe Institute of Technology when conducting part of the research reported
herein. This work was supported by DFG in project
ExpresST and by EPSRC in projects ConDOR and Ex-
ODA.
