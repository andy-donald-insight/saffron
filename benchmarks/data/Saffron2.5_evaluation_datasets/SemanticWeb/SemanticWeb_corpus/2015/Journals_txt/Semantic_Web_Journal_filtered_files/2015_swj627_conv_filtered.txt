Semantic Web 0 (0) 1
IOS Press

Defeasibility in Answer Set Programs with
Defaults and Argumentation Rules 1

Editor(s): Thomas Lukasiewicz, University of Oxford, Oxford, UK; Diego Calvanese, Free University of Bozen-Bolzano, Bolzano, Italy
Solicited review(s): Guido Governatori, NICTA, Australia; Wolfgang Faber, School of Computing and Engineering, University of
Huddersfield, Huddersfield, UK; One anonymous reviewer

Hui Wan a Michael Kifer b Benjamin Grosof c
a IBM T.J Watson Research Center, USA
E-mail: hwan@us.ibm.com
b Stony Brook University, USA
E-mail: kifer@cs.stonybrook.edu
c Vulcan Inc., USA
E-mail: BenjaminG@vulcan.com

Abstract. Defeasible reasoning has been studied extensively in the last two decades and many different and dissimilar approaches
are currently on the table. This multitude of ideas has made the field hard to navigate and the different techniques hard to
compare. Our earlier work on Logic Programming with Defaults and Argumentation Theories (LPDA) introduced a degree of
unification into the approaches that rely on the well-founded semantics. The present work takes this idea further and introduces
ASPDA (Answer Set Programs via Argumentation Rules)  a unifying framework for defeasibility of disjunctive logic programs
under the Answer Set Programming (ASP). Since the well-founded and the answer set semantics underlie almost all existing
approaches to defeasible reasoning in Logic Programming, LPDA and ASPDA together can be seen as an attempt to unify
most of those approaches. In addition to ASPDA, we obtained a number of interesting and non-trivial results. First, we show
that ASPDA is reducible to ordinary ASP programs. Second, we study reducibility of ASPDA to the non-disjunctive case and
show that head-cycle-free ASPDA programs reduce to the non-disjunctive casesimilarly to head-cycle-free ASP programs, but
through a more complex transformation. We also shed light on the relationship between ASPDA and some of the earlier theories
such as Defeasible Logic and LPDA.

Keywords: Logic Programming, Defeasible Reasoning, Argumentation Theory, Argumentation Rules, Answer Sets, Stable
Model

1. Introduction

Defeasible reasoning is a form of non-monotonic
reasoning where logical axioms are true by default
but their truth status may be undercut or even negated
by other, conflicting axioms. This type of reasoning
has been an important application of logic program-
ming. It was applied to model policies, regulations,

1This work is part of the SILK (Semantic Inference on Large
Knowledge) project sponsored by Vulcan Inc. It was also partially
supported by the NSF grant 0964196.

and law; actions, change, and process causality; Web
services; and aspects of inductive/scientific learning
[38,37,33,23,2,25,26]. However, there is a bewildering
multitude of dissimilar and incompatible approaches
to defeasibility based on a wide variety of intuitions
and techniques. The difficulties in relating and comparing the different approaches have been discussed
in [22,8,12,40] among others. Combining the various
theories of defeasible reasoning with other advances in
logic-based knowledge representation, such as HiLog
[10] and F-logic [29], has also been a problem.

1570-0844/0-1900/$27.50 c 0  IOS Press and the authors. All rights reserved

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

Our earlier work [40] addressed some of these issues by introducing a general framework for defeasible reasoning, called LPDA, which abstracts the intuitions about defeasibility into what we call argumentation theories. In LPDA, an argumentation theory is
a set of logic axioms that express the arguments for or
against defeating various rules in the knowledge base.
These arguments often depend on the particular application domain and user intent. An argumentation theory should be viewed not as part of a knowledge base
but rather of its semantics. This approach enables a
uniform syntax and semantics for a wide variety of defeasible theories, which could be used in harmony and
simultaneously in the same knowledge base. LPDA, as
defined in [40], was developed on the basis of the wellfounded models [18] and was able to unify a number
of approaches to defeasible reasoning that are based
on the well-founded semantics. However, a large number of works on defeasible reasoning are based on the
stable model semantics [20], which has very different
properties and is not capturable by well-founded mod-
els. Furthermore, general defeasible reasoning in the
presence of disjunctive information appears to require
even more general semantics, the answer set semantics [19].

The present work takes the idea of LPDA further
and introduces ASPDAan analogous framework for
defeasibility of disjunctive logic rules through argumentation rules 1 based on Answer Set Programming
(ASP). In this way, LPDA and ASPDA together unify
and extend most of the existing theories of defeasible
reasoning in Logic Programming.

Extension of the semantics of LPDA to ASP with
head-disjunctions turned out to be elegant but not
straightforward. The relationship between ASPDA and
the regular ASP also proved to be non-obvious. First,
we show that ASPDA can be expressed by regular ASP
programs. A polynomial reduction has been recently
given in [16]. Then we study the class of head-cycle-
free programs with disjunctive heads and show that
a related notion exists for ASPDA. By analogy with
the classical case, such programs can be reduced to
non-disjunctive programs under the defeasible stable
model semantics, although the transformation is more
complicated than in the case of the regular ASP. The
blowup in the program size is still linear, however.

1 Earlier [40] we used the term argumentation theories but renamed it to avoid possible confusion with a similar and related term
used in Dung et al. [14].

To avoid possible confusion, we should mention
from the outset that argumentation rules are related to
argumentation theories of Dung et al. [14]. We briefly
discuss the relationship in Section 5.

A preliminary report on this work appeared in [41].
Compared to that earlier paper, the present paper develops the main concepts to a fuller extent, provides all
proofs, and includes extensive examples of instantiations of ASPDA to illustrate the inner workings of the
ASPDA framework.

The rest of this paper is organized as follows.
Section 2 illustrates defeasible reasoning under the
answer-set semantics using the well-known Turkey
Shoot example [32]. Section 3 defines the syntax and
semantics of defeasible disjunctive logic programs
and presents a number of interesting results about reducibility to the regular logic programming and to the
non-disjunctive case. Section 4 gives two examples of
argumentation rulesets for ASPDA. One is an adaptation of GCLP [24,40] to ASPDA, a theory that is used
in all examples throughout this paper. Another is an argumentation ruleset that behaves very similarly to Defeasible Logic [1] except in edge cases. Sections 5 and
6 discuss related work and conclude the paper.

2. Motivating Example

The example in Figure 1 is adapted from the Texas
Turkey Shoot game example in [32]. We use the usual
syntax of logic programming with the only difference
that rules are tagged with @tag symbols and headdisjunctions are allowed. Variables are prefixed with
the symbol ?.

In the scenario described in the example, one of
the guns is known to be loaded initially, but it is not
known which. The objective is to find a plan to kill
the turkey by shooting one or both guns assuming that
the shooter can observe the effects of his actions. Let
g1 and g2 be the constants representing the guns.
Numerals are used in the example to represent time
points, and the initial time point is assumed to be 1. For
instance, shoot(g1,1) and shoot(g1,2) represent the actions of shooting the gun g1 at time points 1
and 2. In the example, some of the rules have tags, e.g.,
kpld and sht1, and the predicate #overrides
specifies priorities among some of these tagged rules.
We distinguish between the classical-logic-like explicit negation neg and the default negation naf (which
in this paper will have the answer-set semantics). Literals L and neg L are assumed to be incompatible and

Fig. 1. Turkey-shoot example

loaded(?Gun,?Time+1) :- loaded(?Gun,?Time). // Frame axiom 1
neg loaded(?Gun,?T+1) :- neg loaded(?Gun,?T). // Frame axiom 2
neg alive(?Time+1) :- neg alive(?Time). // Frame axiom 3
alive(?Time+1) :- alive(?Time). // Frame axiom 4

@kpld
@kpunld
@dd
@liv
// A gun becomes unloaded after being fired
@sht1
// The turkey becomes dead after a loaded gun is fired at it
@sht2
// Axioms for the initial state

neg loaded(?Gun,?Time+1) :- shoot(?Gun,?Time).
neg alive(?Time+1) :- shoot(?Gun,?Time)  loaded(?Gun,?Time).

@unld
@ld

alive(1). // The turkey is alive initially
neg loaded(g1,1)  neg loaded(g2,1). // One gun is unloaded initially
loaded(g1,1)  loaded(g2,1). // One gun is loaded initially
shoot(g1,1). // Fire g1 at time 1
// If g1 is unloaded at time 1, fire g2 at time 2.
shoot(g2,2) :- naf loaded(g1,1).

// axioms for contradiction and rule priorities
#opposes(alive(?Time), neg alive(?Time)).
#overrides(sht1, kpld).
#overrides(sht2, liv).

cannot both appear in a consistent model. The predicate #opposes specifies additional contradictions,
such as the inability for the turkey to be both dead and
alive at the same time.

We can now explain how defeasible reasoning
works in the above example. The rule tagged with
kpld is a frame persistence axiom stating that a
loaded gun stays loaded unless some other action explicitly changes this state of affairs. The rule sht1
states that
if a gun is fired then it becomes unloaded in the next state. This rule has a higher priority than the frame axiom kpld due to the axiom
#overrides(sht1,kpld). The rule that has the tag
liv is another frame axiom stating that a live turkey
remains alive by default. This rule is defeated by the
higher-priority rule tagged with sht2, which says that
if a loaded gun is fired at the turkey, then the turkey is
dead in the next state. Note that our program has disjunctions in the heads of the rules labeled unld and
ld), so the initial state of the game is uncertain.

The problem is to infer that by firing one or both
guns in succession the shooter can kill the turkey despite the uncertainty in the initial state. We will return
to this example in Section 4.3 after the necessary theory is developed.

3. Defeasible Reasoning with Argumentation

Rules

In this section we introduce the syntax and semantics of disjunctive logic programming where defeasibility is controlled by argumentation rules sets of axioms (or arguments) that say when and why any particular rule should be considered as defeated and the
inference it sanctions as null and void. The main syntactic difference from non-defeasible disjunctive logic
programming is that rules now have tags, and the main
semantic difference is that these rules can be defeated.
Let L be a logic language with the usual connectives  for conjunction,  for disjunction, and :-
for rule implication; and two negation operators: neg
for explicit negation and naf for default negation. The
alphabet of the language consists of: an infinite set
of variables, which are shown in the examples as alphanumeric symbols prefixed with the question mark
?; and a set of constant symbols, which can appear
as individuals, function symbols, and predicates. Constants will be shown as alphanumeric symbols that are
not prefixed with a ?. We assume that the language
includes two special propositional constants, t and f,
which stand for true and false, respectively. We also assume the following order on these propositions: f < t.
We use the standard notion of terms in logic pro-
gramming. Atomic formulas, also called atoms, can be
quite general in form: they can be the usual atoms used

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

in ordinary logic programming; or the higher-order expressions of HiLog [10]; or the frames of F-logic [29].
A literal has one of the following forms:

 An atomic formula.
 neg A and naf A, where A is an atomic formula.
 naf neg A, where A is an atomic formula.
 naf naf L and neg neg L, where L is a literal;

these are identified with L.

Let A denote an atom. Literals of the form A or neg A
(or literals that reduce to these forms after elimination of double negation) are called naf -free literals;
literals that reduce to the form naf A are called naf -
literals.

Definition 1 (Tagged rule) A tagged rule in a logic
language L is an expression of the form

@r L1  ...  Lk :- Body

(1)

where r is a term, called the tag of the rule; L1, ...,
Lk (k  0) are naf -free literals in L, called the head
literals of the rule; and Body, called the body of the
rule, is a conjunction of literals in L.2 As is common
in logic programming, we will often write A, B to represent the conjunction A  B. A rule tag is not a rule
identifier: several rules can have the same tag.3

A constraint is a special form of rule where f is a
single head literal. We will usually omit f in such rules.
A formula is a literal, a Boolean combination of literals using conjunction and disjunction, or a rule. 

We will often omit rule tags when they are immaterial.

Definition 2 (Ground terms and rules) A ground term
is a term that contains no variables, a ground literal
is a variable-free literal, and a ground rule is a rule

that has no variables.

Definition 3 (ASPDA) An answer-set program with
defaults and argumentation rules
(an aspda, for
short) in a logic language L is a set of tagged rules
in L, which can be strict or defeasible. Sets or rules
that do not have disjunctions in the head will be called

non-disjunctive aspdas.

Strict rules are used as definite statements about the
world. In contrast, defeasible rules represent defeasible
defaults whose instances can be defeated by other
rules. Inferences produced by the defeated rules are
overridden.

We assume that the distinction between strict and
defeasible rules is specified in some way: either syntactically or by means of a predicate. For instance, in
Section 4, we use the predicate #strict for that pur-
pose.

Aspdas are used in conjunction with argumentation rules, which are sets of rules that define conditions
under which some rule instances may be defeated by
other rules.
Definition 4 (Argumentation ruleset) Let L be a logic
language. An argumentation ruleset is a set, AT, of
strict rules in L of the form (1). We also assume
the language L includes a binary predicate,
that
$defeatedAT, which may appear in the heads of
some rules in AT.4 When confusion does not arise, we
will omit the subscript AT.
An aspda P is said to be compatible with AT if
$defeatedAT does not appear in the rule heads in
P.

In an argumentation ruleset all rules are strict, by
definition.5 The rules in AT will normally contain other
predicates, besides $defeatedAT, that are used to
specify how the rules in P get defeated. We will
see full-fledged examples of argumentation rulesets in
Section 4. Note that an argumentation ruleset is also an
aspda.

Usually argumentation rules employ the concepts
of rule priority and contradictions among facts. Priorities are often specified via predicates, such as
#overrides, which tell that some rules (or rule in-
stances) have higher priorities than other rules (e.g.,
#overrides(rule_tag1, rule_tag2)). Contradictions are commonly expressed via predicates such as
#opposes, which tell that certain facts cannot be true
together (e.g., #opposes(price(ball, 20), price(ball,
30)). The $defeated predicate is then defined in
terms of #overrides, #opposes, and other pred-
icates. In this paper, we adopt the convention that the
predicates defined only by argumentation rules will be

2 This is easy to generalize to allow Lloyd-Topor extensions [31].
3 This makes it easier to specify priorities and conflicts among
groups of rules as opposed to individual rules, as in Figure 3 (look
for the tags move and frame).

4 If $defeated does not occur in the head of any rule then
the semantics of aspdas trivially reduce to ordinary logic program-
ming.

5 In principle, we could allow argumentation rules to be defeasi-

ble, but we will not do so in this paper.

prefixed with the $-sign, such as $conflict, and will
be in normal font, except $defeated, which will
be typeset in bold. The predicates used and/or defined
both by the argumentation rules and user programs will
be prefixed with the #-sign and will be in bold font.
Meta-predicates, such as body, will also be set in bold.
The predicates defined and used only by user programs
will be denoted by alphanumeric symbols and will not
be marked in any special way.

In defining the semantics, we assume that the argumentation rules are ground. A grounded version of
AT with respect to a compatible aspda P is obtained
by appropriately instantiating the variables and meta-
predicates.

Note that the theory developed here permits different subsets of the overall aspda to use different sets
argumentation rules AT with different $defeatedAT
predicates. For instance, our implementation of the
logic programming framework with argumentation
rules for the well-founded semantics in an extended
version of FLORA-2 [28] supports multiple argumentation rulesets.

3.1. Interpretations and Models

Definition 5 (Herbrand universe and Herbrand base)
Let P be an aspda and AT an argumentation ruleset
over language L.

 The Herbrand universe of P, denoted UL, is the
set of all ground terms built using the constants
and function symbols that appear in L. When confusion does not arise, we will simply write U,
omitting the language subscript.
 The Herbrand base of P, denoted BL (or simply B, when no ambiguity arises), is the set of all
ground naf -free literals that can be constructed
using the predicates in L.

Definition 6 (Herbrand interpretation) A Herbrand
interpretation, I, is a subset of B, i.e., a set of ground
naf -free literals. In addition, I must contain t and must
not contain f.
An interpretation is inconsistent relative to an atom A
if both A and neg A are in I. Otherwise, I is consistent relative to A. An interpretation is consistent if it
is consistent relative to every atom and inconsistent if

it is inconsistent relative to some atom.

Next we introduce the notion of satisfaction of de-

feasible rules and strict rules by interpretations.

Definition 7 (Truth valuation) Let I be a Herbrand
interpretation, L a ground naf -free literal, and let F ,
G be ground formulas. We define truth valuations that
map formulas to {t,f} as follows:

 I(L) = t if L  I, I(L) = f otherwise.
 I(naf L) = I(L), where  t = f and  f = t.
 I(F  G) = min(I(F ), I(G)). Recall that f < t.
 I(F  G) = max(I(F ), I(G)).
 For a strict rule @r F :- G, we define I(F :- G) =
t if and only if I(F )  I(G).
Intuitively, a strict rule is true if its head is more
true than the body, i.e., either the head is true or
the body is false.
 For a defeasible rule @r L1  ...  Lk :- G, we
define I(@r L1  ...  Lk :- G) = t
if and only
if I(L1  ... Lk)  min(I(G), V ) where V =
max1ikI(naf $defeated(r, Li)).
the above form
That
is true if either (i) the rule is defeated, i.e.,
$defeated(r, Li) holds for all Li; or (ii) its

body is false; or (iii) if its head is true.

is, a defeasible rule of

Definition 8 (Model of formula and rule) If F is a
ground formula, I an interpretation, and I(F ) = t,
then we write I |= F and say that I is a model of F or
that F is satisfied in I.
If R is a ground rule @r L1  ...  Lk :- G, I an
interpretation, and I(R) = t, then we write I |= R and
say that I is a model of R or that R is satisfied in I.

We write I |= P if I |= R for every R  P.

Definition 9 (Model of aspda w.r.t. argumentation
theory) Given an aspda P, an argumentation ruleset
AT, and an interpretation M, we say that M is a model
of P with respect to the argumentation ruleset AT (or a
model of (P, AT), for short), written as M |= (P, AT),
if M |= P and M |= AT.

Definition 10 (Minimal model) A minimal model of
(P, AT) is a model M of (P, AT) such that no proper
subset of M is a model of (P, AT).

3.2. Stable Model and Answer-set Semantics

Note that all interpretations considered in this paper
are Herbrand, so we will often neglect to mention this
explicitly.

In this section, we extend the stable model semantics
[20] and the answer-set semantics [19] to ASPDA. We
start with non-disjunctive aspdas and stable models.

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

Definition 11 (ASPDA quotient, non-disjunctive case)
Let Q be a non-disjunctive aspda, and let J be a Herbrand interpretation for Q. The ASPDA quotient6 of
Q by J, written as
, is defined by the following sequence of steps:
1. Delete every rule R  Q such that there is a naf -
literal of the form naf A in Rs body and A  J;

2. Delete every defeasible rule of the form

(@r L :- Body)  Q

such that $defeated(r, L)  J.

3. Remove all naf -literals from the remaining rules.
4. Remove all tags from the remaining rules.

Note that
gram without naf .

is a normal (non-defeasible) logic pro-

When dealing with stable models, it is often assumed that interpretations are consistent [19]. All the
definitions and results in this section extend to this case
straightforwardly.
Definition 12 (Stable model) A Herbrand interpretation M is a stable model of a non-disjunctive aspda
P with respect to the argumentation theory AT, if M is
a minimal Herbrand model of PAT
M .
Note that PAT
M is a Horn logic program, so here minimal models are meant in the sense of the regular Horn

logic, not in the sense of Definition 10.

The next theorem shows that non-disjunctive aspdas
can be implemented using ordinary logic programming
systems that support the stable model semantics (e.g.,
DLV [30]).
Theorem 1 (Reduction for stable model semantics)
Let P be a non-disjunctive aspda and AT an argumentation ruleset. Then the following two sets coin-
cide:

 The set of stable models of P with respect to AT.
 The set of stable models of the ordinary logic program P  AT, where P is obtained from P by
converting every defeasible rule

(@r L :- Body)  P

into the plain rule of the form
L :- Body  naf $defeated(r, L)
and removing all the remaining tags; and AT
is obtained from AT by simply removing all the

tags.

6 In regular ASP theory, the term reduct is normally used. We
later use the term reduction in a different sense, so quotient is used
here to avoid confusion.

Proof: Let S be a Herbrand interpretation for P  AT.
is obtained through

According to Definition 11, PAT

the following steps:
1. Delete every rule R  P  AT such that there is
a naf -literal of the form naf A in Rs body and
A  S;

2. Delete every defeasible rule of the form

(@r L :- Body)  P  AT

such that $defeated(r, L)  S.
in P  AT.
in P  AT.

3. Remove all naf -literals from the remaining rules

4. Remove all tags from the remaining tagged rules

Note that this makes PAT
gram.

into an ordinary logic pro-

According to the definition of Quotient in the ordinary stable model semantics [20], the quotient of
P  AT by S, is obtained through the following steps:
1. Delete every rule R  P  AT such that there is
a naf -literal of the form naf A in Rs body and
A  S;
in P  AT.

2. Remove all naf -literals from the remaining rules

From the above it can be safely inferred that the ASPDA quotient PAT
is the same set of ordinary logic
rules as the (ordinary) quotient of PAT by S. For in-
stance, consider a defeasible rule @r L :- Body in P.
If $defeated(r, L)  S, this rule will be deleted by
the process of construction of PAT
S . The corresponding rule

L :- Body  naf $defeated(r, L)

will be deleted by the construction of the (ordinary)
quotient of P  AT by S.

The claim now follows from the above and the definitions of stable models in ASPDA and in the classical

case (Definition 12 and the one in [20]).
For rules with disjunctions in the head, stable models are called answer sets and we will now generalize the above semantics to such rules. In generalizing
aspdas to disjunctive rules, the main difficulty is to
find an analog of the reduction theorem (Theorem 1).

Example 1 Consider a disjunctive program that has
the following defeasible rules:

@r1 a  b  c.
@r2 d  e.

The ordinary stable models of this program are {a, d},
{a, e}, {b, d}, {b, e}, {c, d}, and {c, e}. Suppose now
that the proposition a cannot be true when either d or
e holds, and that b is also incompatible with e. These
constraints are specified as the following facts:

#opposes(a,d).
#opposes(a,e).
#opposes(b,e).

Suppose, in addition, that rule r1 has a higher priority
than r2, which we specify using the fact

#overrides(r1,r2).

Intuitively, {a, d}, {a, e}, and {b, e} can no longer
be models due to the incompatibility constraints, while
the models {b, d}, {c, d}, and {c, e} are still possible.
At the same time, one might feel that {a} is also a suitable model because r1 overrides r2, the proposition a
makes r1 true, and a is incompatible with both heads
in rule r2.
As it turns out, {a} may or may not be a defeasible stable modelit all depends on the associated argumentation rules. It would be a stable model of our
aspda if the argumentation ruleset had the following
rule instances:

$defeated(r2, d) :-

#overrides(r1, r2)  #opposes(a, d)  a.
#overrides(r1, r2)  #opposes(a, e)  a. 

$defeated(r2, e) :-

The following definitions generalize Definition 11
to disjunctive aspdas and make the intuition behind
Example 1 precise.
Definition 13 (ASPDA quotient, disjunctive case) Let
Q be a disjunctive aspda, and let J be a Herbrand
interpretation for Q. We define the ASPDA quotient of
Q by J, written as
, by the following sequence of
steps:
1. Delete every rule R  Q that has a literal of the
form naf A in Rs body where A  J;
2. For every defeasible rule of the form @r L1 
...  Ln :- Body in Q, delete every Li such that
$defeated(r, Li)  J. If all the Lis are
deleted, delete the entire rule.

3. Remove all naf -literals from the remaining rules.
4. Remove all tags from the remaining tagged rules.

Definition 12 is generalized in a natural way:
Definition 14 (Answer set) A Herbrand interpretation M is an answer set of a disjunctive aspda P
with respect to the argumentation ruleset AT, if M is a
minimal Herbrand model of PAT

M .
The analog of Theorem 1 is as follows.
Theorem 2 (Reduction for the answer-set semantics)
Let P be a (disjunctive) aspda and AT an argumentation theory. Then the following two sets coincide:

 The set of answer sets for the aspda P with re-

 The set of answer sets for the ordinary logic pro-

spect to AT.
gram P  AT, where
 P is obtained from P by

 converting every defeasible rule

(@r L1  ...  Ln :- Body)  P

into a collection of plain rules of the form

iK

jNK

iKLi :- Body 

naf $defeated(r, Li)

$defeated(r, Lj)

for each non-empty subset K  N, where
N = {1, ..., n}

 removing all the remaining tags.

 AT is obtained from AT by simply removing all

the tags.

Proof: Let S be a Herbrand interpretation of P  AT.
By Definition 13, PAT
is constructed by the following
steps:
1. Delete every rule R  P  AT that has a literal of
the form naf A in Rs body, where A  S;
2. For every defeasible rule of the form @r L1 
...  Ln :- Body in P  AT, delete every Li such
that $defeated(r, Li)  S. If all the Lis are
deleted, delete the entire rule.

3. Remove all naf -literals from the remaining rules.
4. Remove all tags from the remaining tagged rules.

is an ordinary disjunctive logic pro-

Note that PAT
gram. For future reference, let us denote it Q1.
By definition of the quotient in the ordinary answer
set semantics [19], the quotient of P  AT by S, is
obtained from P  AT by these steps:

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

(i) Delete every rule R  P  AT that has a literal

of the form naf A in Rs body where A  S;

(ii) Remove all naf -literals from the remaining rules.
Let us denote the resulting logic program with Q2. We
will call the rules in Q1 and Q2 the reducts of the original rules in P  AT and P  AT, respectively.
Now consider a rule R (@r L1...Ln :- Body)  P.
 If there is a literal of the form naf A in Rs body
and A  S, R would be deleted and its reduct will
be neither in Q1 nor Q2.

 If no such literal naf A exists in R then Body
of the reduct of R does not contain naf -literals.
Let K0  {1, ..., n} be a subset such that S 
naf $defeated(r, Li), for all i  K0, and S 
$defeated(r, Lj), for all j / K0. Then, if
K0 = {},
 Q1 would contain the rule iK0 Li :- Body 
 P  AT would contain a set of rules of the

the reduct of R.

form
iKLi :- Body 

iK

jNK

naf $defeated(r, Li)

$defeated(r, Lj)

for each non-empty subset K  N = {1, ..., n}.
During the construction of Q2, after step (i) the
only remaining rules will be of the form
iKLi :- Body 

naf $defeated(r, Li)

iK

jNK

$defeated(r, Lj)

for each K such that K  K0. After step (ii),
the reducts of R that will remain in Q2 would
be:
iKLi :- Body

$defeated(r, Lj)

jNK

for each K such that K  K0. Among
these rules, only one rule, iK0 Li :- Body 
jNK0$defeated(r, Lj), can possibly have
a body entailed by S. Furthermore, S entails

this rule if and only if S entails iK0 Li :- Body,
which is a reduct of R in Q1.
If K0 = {} then, for i=1,...,n,
S  $defeated(r, Li). Therefore:
 Q1 has no reducts of R. So, the entire rule is
 P  AT must contain the rules of the form

deleted in step 2 (of ASPDA quotient).

iKLi :- Body 

naf $defeated(r, Li)

$defeated(r, Lj)

iK

jNK

for each non-empty subset K  N = {1, ..., n}.
Each such rule contains at least one literal
naf $defeated(r, Li) in the rule body. Since
K0 = {} implies that all such literals are false
in S, step (i) in the construction of Q2 eliminates all the above rules. So, neither Q1 nor Q2
will have any reducts of R.

It can now be seen that S is a minimal Herbrand
model of Q1 if and only if S is a minimal Herbrand
model of Q2. In other words, S is an answer set for
the aspda P with respect to AT if and only if S is an
answer set for the ordinary logic program PAT. 

With this theorem, it is now straightforward to verify
that the answer sets for the aspda in Example 1 are
precisely as described there.

Theorem 2 shows that a reduction exists from ASPDA to ASP, but that particular reduction is exponential in size with respect to the original program. With
a little more care, a polynomial reduction can be con-
structed, as has been recently shown by Faber [16].

3.3. Reduction to the Non-disjunctive Case

In ordinary answer-set programming, some disjunctive rules can be reduced to the non-disjunctive case
via the so-called shifting transformation. This transformation would replace the rule L1  ...  Ln :- Body
with n new rules

Li :- Body  

naf Lj

(2)

1jn, j=i

where 1  i  n. We will use shif t(P) to denote
such transformation of a (non-defeasible) disjunctive
logic program. For example, consider a program con-

sisting of one rule p  q  s :- body, the shifting of
the program is

p :- body  naf q  naf s.
q :- body  naf p  naf s.
s :- body  naf q  naf p.

Ben-Eliyahu and Dechter [4] have shown that the
above shifting transformation is an equivalence transformation for so called head-cycle free programs.7 We
reproduce that definition below adjusting it for disjunctive aspdas.
Definition 15 [4] The dependency graph GP, of a
ground aspda P, is a directed graph where nodes are
ground literals. An edge going from literal L to literal
L exists if and only if there is a rule in which L appears positively in the body and L is a head literal. An
aspda is head-cycle free if and only if its dependency
graph does not contain directed cycles that connect lit-

erals belonging to the head of the same rule.
In the above example, if p, q, s have only negative
occurrences (or no occurrences at all) in body then the
aspda consisting only of the rule

@r p  q  s :- body

is head-cycle free.
Under certain restrictions, the head-cycle free property for P  AT can be reduced to head-cycle freedom
for P. For example, if the literals that appear in rule
heads in AT do not appear in any rule body in P, and
AT is non-disjunctive, then P  AT is head-cycle free
if and only if P is head-cycle free. This is satisfied in
the argumentation ruleset ATDL in Section 4.2. It is
also satisfied in the argumentation ruleset ATAGCLP in
Section 4.1 if #overrides and #opposes do not
appear in rule bodies in P (which normally is the case).
An interesting question is whether a shifting transformation analogous to ordinary answer-set programming exists, and an equivalence result holds for disjunctive aspdas.
Definition 16 Let P be a disjunctive aspda. We define t-shifting of P, t_shif t(P), as a non-disjunctive
aspda obtained from P by replacing each rule of the
form (@r L1  ... Ln :- Body)  P with n new rules

@r Li :- Body  

naf Lj

1jn, j=i

where 1  i  n.

7 The works [13,21] developed similar shifting techniques.

Surprisingly, it turns out that t_shif t(P) is not equivalent to P even for head-cycle free aspdas. To see
this, consider the following rule set, P ex:

@r1 a  b  c.
@r2 d.
@r3 c.

Suppose that the associated argumentation rules imply $defeated(r1, c) and does not imply any other
$defeated(...) facts involving the above rules. Then
P ex would have the following answer sets: {a, d, c}
and {b, d, c}. In contrast, the above t-shifting transformation yields the following non-disjunctive aspda,
t_shif t(P ex):

@r1 a :- naf b  naf c.
@r1 b :- naf a  naf c.
@r1 c :- naf a  naf b.
@r2 d.
@r3 c.

which has only one answer set: {d, c} with respect to
the argumentation ruleset. This shows that t_shif t is
not an equivalence transformation under ASPDA.

Fortunately, a result similar to Ben-Eliyahu and
Dechters does hold for disjunctive aspdas, but for a
slightly different shifting transformation.
Definition 17 The ASPDA shifting of an aspda P,
written as aspda_shif t(P),
is a non-disjunctive
aspda obtained from P by replacing each strict rule
with its t-shifting and replacing each defeasible rule of
the form (@r L1  ...  Ln :- Body)  P with n new
defeasible rules and 2n new strict rules as follows:

@r Li :- Body  

where 1  i  n. Here lit(r, Li), 1  i  n, are
literals of the form newsymi(Varsi), where newsymi
is a fresh predicate name that depends only on r and
Li, while Varsi, the argument vector of the literal, is
a vector of variables that occur in r and Li. We omit

the rule tags for strict rules here.
Theorem 3 Let P be an aspda and let AT be an argumentation ruleset such that P  AT is head-cycle
free. There is a one-to-one relationship between the
answer sets of P with respect to AT and the answer
sets of aspda_shif t(P) with respect to t_shif t(AT).

lit(r, Lj).

1jn, j=i

lit(r, Li) :- naf Li.
lit(r, Li) :- $defeated(r, Li).

(3)

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

Namely, a Herbrand interpretation S is an answer set
of P with respect to AT if and only if f (S) is an answer
set of aspda_shif t(P) with respect to t_shif t(AT),
where f (S) = S  {lit(r, L) | P contains a rule with
tag r and with L in its head (possibly as a disjunct), so
that either $defeated(r, L)  S or L  S}.

Proof: The proof consists of establishing five equiva-
lences, which we denote 1, ..., 5.

P  AT

is an answer set of P with respect to AT

is a minimal Herbrand model of Q1 =

is an answer set of
Q2 = shif t(Q1) = shif t(

is a minimal Herbrand model of
Q3 =

shif t(PAT
S )

P  AT

Q2

f (S) is a minimal Herbrand model of

aspda_shif t(P)  t_shif t(AT)

Q4 =

f (S)

f (S) is an answer set of aspda_shif t(P) with

respect to t_shif t(AT).

In proving each equivalence, we will choose an arbitrary defeasible rule R of the form @r L1  ... 
Ln :- Body in P and an arbitrary strict rule T  P 
AT, and then look at what happens to these rules after applying the quotient and shifting transformations
to them. As in the proof of Theorem 2, we can assume that the bodies of R and T do not contain naf -
literals (they are evaluated away in the quotients on
both sides).
Let K0 be {k | S  naf $defeated(r, Lk), 1 
k  n} and let K1 be {k | Lk  S, 1  k  n}.
(1): This follows from Definition 14.
(2): By definition, every defeasible rule R  P
gives rise to the following single rule R1 in the quo-

tient Q1:

iK0

Li :- Body

(4)

If |K0| = 0, R gives rise to no rule.

The strict rules T  P  AT give rise to T1 in Q1
where T1 has the same head and body as T but the tag
is stripped off. By definition, all rules in Q1 are either
R1s or T1s and are obtained in the above way. So, Q1
consists of the rules of the form (4) or of the strict rules
from P  AT that lost their tag.
Q2 is constructed from Q1 via shifting of ordinary
(non-defeasible) disjunctive rules. A rule R1 of the
form (4) produces |K0| rules of the form

Li :- Body  

jK0,j=i

naf Lj

(5)

for i  K0. The strict rule T1  Q1 gives rise to the
rules shif t(T1).
Since, by assumption, Q1 does not contain naf -
literals, S is a minimal Herbrand model of Q1 iff S is
an answer set of Q1. Observe that:

 Q1 is an ordinary (non-defeasible) disjunctive
 P AT is head-cycle free, so Q1 = PAT

logic program,

is head-

cycle free,

Therefore, as shown in [4,13,21], S is an answer set of
Q1 iff S is an answer set of Q2 = shif t(Q1).
Q2 contains no rules other than those in (5) and

shif t(T1).
(3): Q3 = Q2
S is constructed according to Definition 13. Strict rules in Q3 all have the form shif t(T1)
and defeasible rules are obtained as follows:
3-a. If |K1  K0|  2, the rules of the form (5) yield
nothing in Q3. Indeed, for each rule in (5), there
must exist at least one j satisfying j  K0, j = i,
and Lj  S, so every such rule will be deleted
after Step 1 in Definition 13.
3-b. If |K1  K0| = 1, (5) yields {Li :- Body |
where i  K1  K0} in Q3. This is because every
rule in (5) such that i  K1 is deleted in Step 1 in
Definition 13, and the rules such that i  K0 are
deleted in Step 2. The naf -literals in the remaining rule are deleted in Step 3.
3-c. If |K1K0| = 0, (5) yields the rules {Li :- Body |
i  K0} in Q3. This is because the rules in (5)
such that i  K0 are deleted in Step 2 of Defi-

4-b. If |K1  K0| = 1, (6) gives rise to a single rule
Li :- Body, where i  K1  K0. Indeed, any rule
in (6) such that i  K1K0 has some body literal
lit(r, Lj) such that f (S) |= lit(r, Lj).
4-c. If |K1  K0| = 0, (6) gives rise to the following
rules {Li :- Body | i  K0}, which is obtained
by the same argument as before.

Every rule in Qdf

4 comes from (6) or (7) or (8) and
all the rules of the form (7) and (8) are satisfied in
f (S). By comparing (3-a),(3-b),(3-c) with (4-a), (4-b),
(4-c), it follows that

f (S) is a Herbrand model of Qdf
S is a Herbrand model of Qdf
3 .

4 iff

From (10) and (9) we obtain

f (S) is a Herbrand model of Q4 iff
S is a Herbrand model of Q3.

(10)

(11)

To complete the proof for the equivalence (4), it
remains to show that f (S) is a minimal model of Q4
if and only if so is S for Q3.
Minimality of f (S): if S is a minimal Herbrand
model of Q3, then A  f (S), f (S)  {A} cannot be
a Herbrand model of Q4 because:

 if A  S, the minimality of S for Q3 implies
that there must be a rule R1 of the form (5) or
shif t(T )
such that S  {A} |= R1. By the previously established correspondence between the
rules in Q3 and Q4, there is a rule R2  Q4 of
the form (6) or t_shif t(T )
which, by construction,
must be such that f (S)  {A} |= R2.

 if A = lit(r, L) for some r and L, there must be
some rule R of the form (4-b) or (4-c) such that
f (S){A} |= R, so f (S) also cannot be a model
of Q4 in this case.

Minimality of S: if f (S) is a minimal Herbrand
model of Q4, then for any A  S, S  {A} cannot be
a Herbrand model of Q3. If it were a model then, by
(11), f (S{A})  f (S) must be a Herbrand model of
Q4, contrary to the assumption that f (S) is a minimal
Herbrand model of Q4.
This concludes the proof of (4) and of the theo-

rem.

4. Examples of Argumentation Rulesets

We will now introduce two very different sets of
argumentation rules and then discuss how the choice

nition 13 while the naf -literals in the remaining
rules are deleted in Step 3.

(5): The fifth equivalence in the proof of the theorem is a direct consequence of Definition 14, so we
dispense with this case before the fourth equivalence.
(4): Q3 is divided into two subsets: Qdf
3 , which consists of rules obtained from the defeasible rules in Q2,
and Qst
3 which consists of rules obtained from the strict
rules in Q2.
4 the same way. Q4
is obtained from aspda_shif t(P)  t_shif t(AT) by
applying the steps in Definition 11. Recall that each
defeasible rule R  P gives rise to a collection of rules
of the form (3) in aspda_shif t(P), which in Q4 be-
come

Q4 is divided into Qdf

4 and Qst

Li :- Body 

1jn,j=i lit(r, Lj).

(6)

(7)

(8)

for each i  K0;

lit(r, Lj) :- $defeated(r, Lj).

for each 1  j  n;

lit(r, Lj).

for each j  K1. All these rules constitute Qdf
4 .
Each strict rule T  P  AT gives rise to the set of
in Q4. These rules constitute Qst
rules t_shif t(T )
4 .
The difference between t_shif t(T ) used in Q4 and
shif t(T1) used in Q3 is just that T has a tag while
T1 does not. The quotient operation removes tags, so
t_shif t(T )
4 is of

for some T and every rule in Qst
the form t_shif t(T )

has the form shif t(T1)
for some T1 (which is obtained
from T by tag removal), we have:

. Because every rule in Qst

= shif t(T1)

f (S) is a Herbrand model of Qst
S is a Herbrand model of Qst
3 .

4 iff

(9)

Now consider the defeasible rules in Qdf

4 . Since (7)
and (8) are the only rules that define lit(r, Lj), it follows that f (S) |= lit(r, Lj), j  K1  K0, and
f (S) |= lit(r, Lj), j  K1  K0. Under f (S),
4-a. If |K1  K0|  2, the rules in (6) yield nothing in Q4, since for each i  K0, every rule (6)
has some body literal lit(r, Lj) such that f (S) |=
lit(r, Lj).

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

of an argumentation ruleset affects the semantics on a
number of simple knowledge bases.

4.1. A-GCLP [24,40]

Our first example is an ASPDA counterpart for the
argumentation theory proposed in [40], which captures
generalized courteous logic programs [24] under the
well-founded semantics [18]. We will call this theory
A-GCLP and will denote it by ATAGCLP . It is this argumentation ruleset that was tacitly assumed in all the
earlier examples in this paper.

In ATAGCLP , the predicate $defeated, which
is
plays a key role in the semantics of aspdas,
defined in terms of the predicates #opposes and
#overrides. These predicates are defined by the
knowledge engineer within the knowledge base via
sets of facts and rules. The argumentation rules only
impose some constraints on #opposes.

The $defeated predicate is defined as follows: A
rule is def eated if it is refuted by some other undefeated rule. In the ATs below, aspda rules are represented by pairs of variables ?T , ?L (possibly with subscripts or primes) where ?T ranges over rule tags and
?L over rule heads.
$defeated(?T, ?L) :- $defeats(?T , ?L, ?T, ?L).

The auxiliary predicate $defeats is defined as follows:

$defeats(?T1, ?L1, ?T2, ?L2) :-

$refutes(?T1, ?L1, ?T2, ?L2)
naf $defeated(?T1, ?L1)
naf #strict(?T2, ?L2).

The predicate #strict is used here to distinguish
strict rules from the defeasible ones. The predicate
$refutes indicates when one rule refutes another.
Refutation of a rule means that a higher-priority rule
implies a conclusion that is incompatible with the conclusion implied by the first rule. This is defined as fol-
lows:

$refutes(?T1, ?L1, ?T2, ?L2) :-

$conflict(?T1, ?L1, ?T2, ?L2)  ?L1
 #overrides(?T1, ?L1, ?T2, ?L2).
The definition of a conflict between two rules, represented by the predicate $conflict above, relies in turn
on the notion of a candidate. A candidate rule-instance
is one whose body is true in the knowledge base:

$candidate(?T, ?L) :- body(?T, ?L, ?B)  ?B.

Here the meta-predicate body binds ?B to the body of
a rule with the tag ?T and head ?L.

Conflicting rules are now defined as follows: rules
are in conflict if they are both candidates and the literals in them are incompatible:

$conflict(?T1, ?L1, ?T2, ?L2) :-
$candidate(?T1, ?L1)  $candidate(?T2, ?L2)
 #opposes(?L1, ?L2).

that

Recall

the #opposes information is supplied by the knowledge engineer. However, argumentation rules may include additional background ax-
ioms. In our case, ATAGCLP supplies the following
background axioms for #opposes:

#opposes(?L1, ?L2) :- #opposes(?L2, ?L1).
#opposes(?L, neg ?L).
:- ?L1  ?L2  #opposes(?L1, ?L2).

The first is a symmetry axiom that states that opposition is a reciprocal relation. The second axiom states
that literals and their negations are in opposition to
each other. The third axiom is a constraint that says
that opposing literals cannot be both true in the same
possible world.

The relation #overrides is also mostly defined
by the knowledge engineer. However, ATAGCLP also
supplies a background axiom that establishes preference for strict rules over defeasible ones:

#overrides(?T1, ?L1, ?T2, ?L2) :-

#strict(?T1, ?L1)  naf #strict(?T2, ?L2).

Overriding is often specified via tags instead of taghead pairs, and this was the form of overriding that we
mostly used in the examples. The relationship between
overriding through tag-head pairs and overriding via
tags is defined by the following rule:

#overrides(?T1, ?L1, ?T2, ?L2) :-

#overrides(?T1, ?T2)
head(?T1, ?L1)  head(?T2, ?L2).

Here head is a meta-predicate that relates tags to the
heads of the rules labeled with those tags. The bodyoccurrence of #overrides is the overriding relation
over tags and the head occurrence is the overriding relation over tag-head pairs.

Similarly, #strict is also often specified over tags
and the following axiom relates that to strictness at the

level of tag-head pairs.

The predicate $definitely is defined as follows:

#strict(?T, ?L) :-

#strict(?T )  head(?T, ?L).

Having defined this argumentation ruleset precisely,
we can now come back to Example 1 and verify that
the aspda there has four answer sets as claimed:
{a},{b, d},{c, d},{c, e}.

4.2. Defeasible Logic [1]

Our second argumentation ruleset was inspired by
a version of Defeasible Logic under the stable model
semantics, as defined in [1],8 and is designed to behave
very similarly except in edge cases.

Defeasible Logic partitions all rules into strict, de-
feasible, and defeaters. The defeater rules are used
only to defeat other rules, but they themselves do not
produce any inferences. In our terms, this means that
defeater rules are defeated defeasible rules whose only
purpose is to block inferences produced by other rules.
Strict and defeater rules are specified via the predicates
#strict and #defeater. Other important restrictions 9 in [1] are that it does not support disjunctions in
the rule heads; opposition among literals is limited to
p and neg p, for each p; it does not use default nega-
tion, so all literals are naf -free; and the rule tags are
also rule identifiers, so no two rules have the same tag.
This implies that rule tags uniquely determine rules
head and body and lets us simplify the argumentation
rules by considering tags only and ignoring rule heads
in most cases.

We can now formulate the argumentation rules,
which we denote as AT DL, for Defeasible Logic under the stable model semantics as defined in [1].

$defeated(?T, ?L) :-

$conflict(?T, ?T )
head(?T , ?L)  $definitely(?L).

$defeated(?T, ?L) :- #defeater(?T ).
$defeated(?T, ?L) :- $overruled(?T ).

Here head is a meta-predicate that binds ?L to the head
of a rule with Id ?S.

8 [1] uses two kinds of semantics for meta rules: the Kunen semantics and the stable model semantics, they yield different results
for programs with cycle in the dependency graph.

9 There are also other variants of Defeasible Logic, e.g., [5],

which include rules with head disjunctions and other features.

$definitely(?L) :-

#strict(?T )  head(?T, ?L) 
body(?T, ?B)  each_definite(?B).

As in A-GCLP, body is a meta-predicate that binds ?B
to the body of a rule with tag ?T ; each_definite(?B)
is a meta predicate; it is true when $definitely(?B) is
true or when ?B is bound to a conjunction, conj, and
$definitely(c) is true for each conjunct c  conj. If t
is a tag corresponding to a fact, then we assume that
this is a rule whose body is an empty conjunct (i.e., (),
which is commonly identified with true in logic), so
body(t,()) holds and each_definite(()) is thus true. In
this way, facts provide the base case for the recursive
definition of $definitely(?L).

The predicate $candidate is defined as before except that it now depends only on rule tags rather than
tags and heads:

$candidate(?T ) :- body(?T, ?B) ?B.

It remains to define $overruled, which relies on the
notion of candidacy and conflict, as in AT AGCLP .

$overruled(?T ) :-

$refuted(?T ) :-

$conflict(?T, ?T )  $candidate(?T )
naf $refuted(?T ).
$conflict(?T, ?T )  $candidate(?T )
#overrides(?T, ?T )  naf #defeater(?T ).
head(?T, ?L)  head(?T , neg ?L).

$conflict(?T, ?T ) :-

At this point it is instructive to retrospect on the
differences between the two sets of argumentation
rules presented here. First, there are differences in how
priorities over the rules are specified. For instance,
ATAGCLP is more general than ATDL in the sense that
tags in user programs are not required to be distinct and
inclusion of variables in the tags provides one more
level of differentiation among rule instances. The other
main difference is in the way $defeated is defined.
In ATAGCLP , a rule ?S is defeated if it is overridden
by another rule ?R such that that ?R conflicts with ?S.
In contrast, in ATDL, a rule ?T is defeated if it conflicts
with a rule that is not overridden. This leads to significant differences in the behavior of the two argumentation rulesets for the examples discussed in Section 4.3.

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

4.3. Examples

We now discuss a number of examples to help better
understand the ASPDA semantics and the differences
between the argumentation rulesets presented earlier.
In all the examples, rules that have explicit tags are
assumed to be defeasible and the rules without the tags
are assumed strict.

Example 2 Consider again the turkey-shoot example
presented in Section 2.

Under the ATAGCLP argumentation rules, this example set has two answer sets. One is
{neg loaded(g1, 1), loaded(g2, 1), neg alive(3)}
and the other is
{loaded(g1, 1), neg loaded(g2, 1), neg alive(3)}.
Thus, ATAGCLP yields the expected result.

As to the ATDL argumentation rules and the logic
in [1], this theory does not support disjunctions in rule
heads directly. However, we can work around this issue
by applying the shifting transformation. Shifting is applicable here because head-disjunctions in the turkeyshoot example are head-cycle-free. Under this trans-
form, ATDL yields the same result as ATAGCLP . 
Example 3 Figure 2 describes a scenario where a
toxic discharge into a river caused massive reduction
in fish population.

Here both AT AGCLP and ATDL lead to the same

conclusion:
{ fishCount(s0+1,Squamish,trout,400),
fishCount(s0+2,Squamish,trout,0) }
This is the expected result, meaning that up to the moment of the toxic discharge, the Squamish river had
400 trouts and then all of them died.

Interestingly, the same conclusion would be reached
under LPDA [40]a sibling of ASPDA developed for
the well-founded semanticsif we use either the very
same argumentation ruleset AT DL, which we used
here, or AT GCLP , a ruleset analogous to AT AGCLP
but designed for the well-founded semantics [40].

Thus, in this example, both AT AGCLP and ATDL
yield the same result and this is also true under the

well-founded semantics.

Example 4 [40] Figure 3 specifies part of a game
where blocks are moved from square to square on a
board.

The argumentation rules AT AGCLP under ASPDA
and AT GCLP under LPDA both give the same expected result in this case:
{loc(0,block4,square7),

loc(1,block4,square7),
loc(2,block4,square7),
loc(3,block4,square3)}.

Again, AT DL does not handle this example directly,
since the syntax in [1] does not include naf . However,
[3] shows that naf can be simulated using a transform
that relies on neg only. Under this transform, AT DL

yields the same result as the other two theories.

Example 5 Figure 4 shows a scenario where a cycle
exists in the #overrides relation between a pair of
opponents.

Under ASPDA, AT DL yields an answer set in which
Indeed, one can verify that

both a and b are true.
the following literals are true
$refuted(r1,a),
$refuted(r2,b),
naf $overruled(r1,a),
naf $overruled(r2,b),
naf $defeated(r1,a), and
naf $defeated(r2,b).
Hence this program has only one answer set, in which
both a and b are true.

The intuition that underlies such a behavior could
be explained as follows. Each of the two rules, tagged
with r1 and r2, has some rule that overrides it, so
both rules are refuted; Since refuted rules cannot be
used to overrule any other rule, none of the rules is
overridden and none is defeated.

In contrast, AT AGCLP does not produce this answer set. Indeed, consider an interpretation in which
both a and b are true. We can infer that
$refutes(r1,a, r2,b), $refutes(r2,b, r1,a)
are true both, but naf $defeated(r1,a) and
naf $defeated(r2,b) cannot both be true. This
shows that a and b cannot both be true. So {a,b} is
not an answer set. Instead, there are two answer sets:
in one a is true and in the other b is true.

The intuition underlying this argumentation ruleset
is that r1 and r2 refute each other, so one cannot decide which rule should defeat the other: in one possible
world r1 defeats r2 and a is true, while in the other
world r2 defeats r1 and b is true.

Which intuition is more suitable depends on the
application domain. For instance,
if higher priority means greater confidence and a cycle in the
#overrides relation is seen as a kind of contradiction then AT DL might be preferable as a way of discarding contradictory priorities. If, however, the intent
is to make use of all statements about rule priorities
and resolve the contradiction by admitting all possible

Fig. 2. Fish die-off example

/* Initial facts, and an exclusion constraint that fish count has a unique value */
occupies(trout,Squamish).
fishCount(s0,Squamish,trout,400).
#opposes(fishCount(?s,?r,?f,?C1), fishCount(?s,?r,?f,?C2)) :- ?C1 != ?C2.
/* Action/event description that specifies causal change, i.e., effect on next state */
@event fishCount(?s+1,?r,?f,0) :- occurs(?s,toxicDischarge,?r)  occupies(?f,?r).
/* Persistence (frame) axiom */
@frame fishCount(?s+1,?r,?f,?C) :- fishCount(?s,?r,?f,?C).
/* Action axiom has higher priority than frame axiom */
#overrides(event,frame).
/* An action instance occurs */
occurs(s0+1,toxicDischarge,Squamish).

/* moving a block from ?from to ?to, if ?to is free; after the move, ?from becomes free */
@move loc(?s+1,?blk,?to) :-

Fig. 3. Block moving example

@move neg loc(?s+1,?blk,?from) :-

move(?s,?blk,?from,?to)  loc(?s,?blk,?from)  naf loc(?s,?,?to).
move(?s,?blk,?from,?to)  loc(?s,?blk,?from)  naf loc(?s,?,?to).

/* frame axioms: location of a block keeps the same */
@frame loc(?s+1,?blk,?pos) :- loc(?s,?blk,?pos).
@frame neg loc(?s+1,?blk,?pos) :- neg loc(?s,?blk,?pos).
/* each location is free, by default */
@dloc neg loc(?s,?blk,?pos).
/* no block can be in two places at once */
#opposes(loc(?s,?blk,?y),loc(?s,?blk,?z)) :- posn(?y)  posn(?z)  ?y != ?z.
/* move-action beats frame axioms; move & initial state beats default location */
#overrides(move,frame).
#overrides(move,dloc).
#overrides(frame,dloc).
/* Facts: 16 squares. */
posn(square1). posn(square2). ... ... ... posn(square16).

/* initial state */
@state loc(0,block4,square7).
#overrides(state,dloc).
/* State 2: block4 moves from square7 to square3 */
move(2,block4,square7,square3).

Fig. 4. Cycle of #overrides
@r1 a.
@r2 b.
#opposes(a,b).
#overrides(r1,r2).
#overrides(r2,r1).

Wan, Kifer and Grosof / Defeasibility in Answer Set Programs with Defaults and Argumentation Rules

worlds, then AT AGCLP might support such an intuition better.

For the reader who might be familiar with LPDA,
which is based on the well-founded semantics, we will
go through the same example under the argumentation
rules AT GCLP , a sibling of AT AGCLP mentioned
earlier. The rules comprising AT GCLP let us draw the
following conclusions:
$refutes(r1,a,r2,b),
$refutes(r2,b,r1,a),
$refuted(r1,a), and
$refuted(r2,b). It now follows that:
$defeats(r1,a,r2,b), $defeats(r2,b,r1,a)
are both true. Consequently, the rules with tag-head
pairs r1,a and r2,b are both defeated, so both a
and b are false in LPDA. This is somewhat in line with
the behavior of AT AGCLP under ASPDA, but differences should have been expected, since there is always

a unique well-founded model under LPDA.

Our last example illustrates the semantics of ASPDA on a number of simple edge cases, which are
unlikely to be found in practice. The example shows
that our semantics is quite reasonable even for such
unusual aspdas.
Example 6 Let an aspda consist of only one rule:

@r

a.

We will look at this aspda under several different argumentation rulesets.

With respect to the argumentation ruleset

$defeated(r, a).

our aspda has one answer set where $defeated(r, a)
is true and a false.

For the argumentation ruleset
$defeated(r, a) :- a.

the above aspda has no answer sets.

Finally, if the argumentation ruleset is

$defeated(r, a) :- naf a.

then there are two answer sets:

 $defeated(r, a) is true and a is false.
 a is true and $defeated(r, a) is false.

5. Comparison with Other Work

Although a great deal of work has been devoted to
various theories of defeasible reasoning, only a few
considered disjunctive information or tried to unify the
different frameworks for such reasoning. The notable
exceptions are the works [22,11,15,6,9], which had

goals similar to ours. Due to the large volume of literature on defeasible reasoning, we will focus on the
above works, since they are related to our work most
closely. We refer the reader to a survey [12] for a discussion of the various individual theories of defeasibil-
ity.

Defeasible reasoning with disjunctive information
in the propositional case was studied in [6]. Buccafurri et al. [9] introduced a variant of disjunctive logic
programning with inheritance, called DLP <. A key
feature in such inheritance systems is overriding of
the inherited information by more specific informa-
tion, which can be viewed as a specialized form of defeasible reasoning. Nonmonotonic inheritance can be
represented by means of argumentation rules, although
we have not studied the extent to which this is possible
in DLP <.

The logic of prioritized defaults [22] also does not
use the notion of argumentation rules, but it allows
for multiple theories of defaults for different application domains. This is analogous to allowing argumentation rulesets to vary. However, defaults are defined
via meta-theories and the semantics in [22] is given by
meta-interpretation. What we call an argumentation
ruleset is implicit in the meta-interpreters, and no independent model theory is given. In contrast, our approach abstracts all the differences between the various
theories for defaults to the notion of an argumentation
ruleset with a simple interface to the user-provided domain description, the predicate $defeated. Our approach is model-theoretic and it covers both the wellfounded semantics [40] and answer sets (the present
paper). It unifies the theories of Courteous Logic Pro-
gramming, Defeasible Logic, Prioritized Defaults, and
more.

Delgrande et al. [11] propose a framework for ordered logic programming, which can use a variety of
preference handling strategies. For each strategy, this
approach devises a transformation from ordered logic
programs to ordinary logic programs. Each transformation is custom-made for the particular preferencehandling strategy, and the approach was illustrated by
showing transformations for several strategies, including two described in earlier works [42,15].

Unlike ASPDA, the framework of Delgrande et al.
does not come with a unifying model-theoretic seman-
tics. Instead, the definition of preferred answer sets differs from one preference-handling strategy to another.
One of the more important conceptual differences between our work and [11] has to do with the nature of
the variable parts of the two approaches. In our case,

the variable part is the argumentation ruleset, which
is a set of definitions for concepts that a human reasoner might use to argue why certain conclusions are
to be defeated. In [11], the variable part is the transfor-
mation, which encodes a fairly low-level mechanism:
the order of rule applications required to generate the
preferred answer set.10 It is also important to note that
each program transformation in [11] needs a compiler
that contains hundreds of lines of Prolog code, while
our approach requires no new software, and each argumentation ruleset typically contains 20-30 rules.

Eiter et. al. [15] set out to unify approaches to defeasible reasoning. Specifically, they present an adaptable meta-interpreter, which can be designed to simulate the approaches described in [8,42] among oth-
ers. This framework is not as flexible as ASPDA and
is fundamentally different from it: while ASPDA captures the essence of other approaches via argumentation rules, [15] captures these approaches in a less direct way, with the help of meta-interpretation.

The term argumentation theory was used to denote concepts that are related but significantly different from those studied in the present paper [7,17,34].
In these works, argumentation theories refer to proofs
or sets of supporting premises rather than to rules that
specify the notion of defeasibility. The focus of [7] is
non-monotonic logic in general, while [17] is a procedural approach to defeasible reasoning. It is unclear
whether these approaches can be captured as argumentation rules in our framework.

Argumentation theories were also used in a number
of more closely related papers [35,36,27,14]. The focus of these works is development of the actual concepts that argumentation theories operate with. For in-
stance, [35] uses Default Logic [39] to formalize the
notions of defeat, defensible arguments, etc. Our work
has a different focus in that we develop a general semantics for defeasible reasoning rather than dwelling
on particular approaches to argumentation. The different argumentation rulesets (such as those in Section 4)
are examples of the application of our general theory of
defeasibility. These examples rely on some of the concepts that are analogous to those developed in [35,14].
For instance, the rulesets presented in Section 4 rely
on the notion of defeated arguments, although those
notions are not exactly the ones in [35,14].

Although defeasibility for disjunctive logic programs has been considered in restricted settings before

10 Note that argumentation rules can also encode rule application

orderings.

[6,9], to the best of our knowledge, the present paper is the only work that studies the semantics of such
logic programs in a general way. Defeasible disjunctive rules should not be confused with disjunctive logic
programs under the answer-set semantics, as the latter
does not explicitly represent defeasibility as a highlevel concept but rather encodes it via default negation,
not unlike the reduction described in Theorem 2.

6. Conclusions

This paper developed a novel theory of defeasible
disjunctive logic programming under the answer-set
semantics. It is a companion to our earlier work which
developed a general theory of defaults and defeasibility through argumentation rules but was based on the
well-founded semantics. Apart from the model theoretic semantics, and the reduction theorems, we have
shown that head-cycle free disjunctive defeasible programs can be reduced to non-disjunctive ones, which
mirrors an analogous result for non-defeasible disjunctive rules with default negation. To illustrate the power
of the proposed framework, we gave two examples of
argumentation rulesets. One is an adaptation for stable
models of generalized courteous argumentation rules
given in [40] for well-founded models. This theory was
used in most of the examples in this paper. The second
argumentation ruleset was intended to show how ASPDA simulates other approaches to defeasible reason-
ing; in this case the defeasible logic of [1]. We gave
a detailed analysis of the behavior of the two argumentation rulesets on a number of interesting examples and compared the results with the behavior that
would have resulted if we used defeasibility under the
well-founded semantics of [40].
