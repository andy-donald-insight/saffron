SPSC: Efficient Composition of Semantic
Services in Unstructured P2P Networks

Xiaoqi Cao(B), Patrick Kapahnke, and Matthias Klusch

German Research Center for Artificial Intelligence (DFKI), Saarbr ucken, Germany

{Xiaoqi.Cao,Patrick.Kapahnke,Klusch}@dfki.de

Abstract. The problem of automated semantic peer-to-peer (P2P) service composition has been addressed in cross-disciplinary research of
semantic web and P2P computing. Solutions for semantic web service
composition in structured P2P networks benefit from the underlying
distributed global index but at the cost of network traffic overhead for
its maintenance. Current solutions to service composition in unstructured P2P networks with selective flooding can be more robust against
changes but suffer from redundant messaging, lack of efficient semanticsempowered search heuristics and proven soundness. In this paper, we
present a novel approach, called SPSC, for efficient semantic service composition planning in unstructured P2P networks. SPSC peers conduct a
guarded heuristics-based composition to jointly plan complex workflows
of semantic services in OWL-S. The semantic service query branching
method based on local observations by peers about the semantic overlay
alleviates the problem of reaching dead-ends in the not fully observable and heuristically pruned search space. We theoretically prove that
the SPSC approach is sound and provide a lower bound of its complete-
ness. Finally, our experimental evaluation shows that SPSC achieves high
cumulative recall with relatively low traffic overhead.

Keywords: Semantic services  Workflow composition  P2P computing

1 Introduction

In the past decade, the challenge of automated centralized and decentralized
composition of semantic web services in OWL-S, SAWSDL or WSML1 has
attracted considerable interest and development of various solutions in the
semantic web and P2P community [21]. In fact, there are quite sophisticated
AI planning based tools for centralized composition of semantic services such
as OWLS-Xplan [14] for OWL-S services [19]. Unlike web service composition,
the automated composition of semantic web services by use of AI planning techniques is inherently supported by their formally grounded semantic descriptions.
However, these semantic service composition planners cannot be used for a distributed composition of semantic services for collaborative applications in P2P
settings. In these cases, any service composition approach has to cope with the
1 For an introduction to semantic web services, we refer to, for example, [16].
c Springer International Publishing Switzerland 2015
F. Gandon et al. (Eds.): ESWC 2015, LNCS 9088, pp. 455470, 2015.
DOI: 10.1007/978-3-319-18818-8 28

X. Cao et al.

lack of a global service directory or dynamic changes of the set of service prosumers and the availability of semantic services to be found and composed for
jointly accomplishing a given task.

For example, approaches to semantic web service composition in structured
or hybrid P2P networks such as [9,20,24] benefit from a distributed, semanticsempowered index, but at the cost of traffic overhead for its maintenance in
dynamic environments. On the other hand, current solutions for semantic service
composition in unstructured P2P networks can be more robust against changes
but suffer from redundant messaging, lack of efficient semantics-empowered
search heuristics and proven soundness of the distributed composition by the
peers. There are a few solutions for this problem. For example, PM4SWS [10,11]
applies classical flooding which causes heavy network traffic for on-line query
answering. Relying on state transition gossiping and query/network status analy-
sis, SCComp [68] enables selective flooding, but still has the risk of one peer
receiving duplicated messages with the same sub-goal. AntAgt [3,4,23] yields
less network traffic by applying a walker-based query routing strategy, but suffers
from its dependence on user specified query plan templates. It does not perform
fully automated service composition. Besides, none of the current approaches
also takes non-functional factors such as quality of service (QoS) and composition plan length into account for the automated semantic services composition.
To this end, we present SPSC (Semantic P2P Service Composition Planning)
for automated and efficient QoS-aware composition of OWL-S services in unstructured P2P networks. The joint generation of complex service workflows by SPSC
peers basically relies on (a) the local matching of the semantic input/output/
preconditions/effects (IOPE) of OWL-S services with variable bindings, and (b)
the memorization of potentially useful services. As a result, SPSC peers jointly
explore a heuristically pruned search space using a walker-based query branching strategy, which mitigates the risk of failure due to dead-ends. SPSC is robust
against network and service dynamics. In contrast to other approaches to the same
problem, we also theoretically prove that SPSC is sound and has a reasonable
lower bound of completeness with respect to the solution existence. Finally, our
preliminary experimental evaluation revealed that SPSC achieves high cumulative
recall with low traffic overhead.

In Sect. 2, we provide preliminaries required to understand the SPSC approach which is detailed in Sect. 3. We then analyze the completeness of SPSC
and prove its soundness in Sect. 4, followed by experimental results in Sect. 5.
A discussion of related work is in Sect. 6 before we conclude in Sect. 7.

2 Preliminaries

In unstructured P2P networks, peers have no global view on network topology or
services provided by other peers. A peer p maintains its limited domain knowledge in its local knowledge base, including an OWL ontology Op and a set of
predicates Ap, based on a shared primitive term vocabulary V . Each   Ap is
the first order logic interpretation of a concept or property in Op [1]. Each peer
?

?

?
can provide atomic OWL-S services. Besides input (I), output (O), precondition
(P) and effect (E), each service has its provider peer id pid and a QoS value
qos  [0, 1], indicating the overall service availability. Each IO parameter contains a variable ?x and its concept type X  Op. P/E is a CNF formula over
predicates in Ap and IO variables. Denote Sp the set of services known by p.
Example 1 : Service S9 (cf. Fig. 1) represents an industrial production process,
which consumes some M aterial ?m and Sof tener ?so to produce P roduct ?pro.
Its precondition P9 = tempLargerT han (?m, 60)  qualityN otBad(?m) 
speedEq(?so, 5), requires the temperature of ?m to be larger than 60, an adequate quality of ?m and the softener ?so to be added at speed 5. The effect

E9 = shaped(?pro) ensures that, after the execution, ?pro is shaped.
In context of SPSC, a request R is defined analogously to a service, containing
IOPE, but without QoS and pid. We assume that a request can typically not be
solved by one atomic service, but a composition, i.e. a workflow. Such a workflow
includes parameter bindings to make up data flows.

Fig. 1. An example workflow with parameter bindings (Color figure online).

Definition 1: Service parameter binding b(?x, ?y).
A binding b(?x, ?y) of service parameters ?x and ?y of services S and respectively
S is a tuple ?x, ?y,  where  is a substitution {?x ?z, ?y ?z}.

That is, if an output ?x of S.O is bound to an input ?y of S.I, the data of ?x can
be transmitted to ?y and used by S as input, which is modeled by introducing
the common substitute ?z.
Definition 2: Workflow wf.
A workflow is an orchestration of semantic services constructed to fulfill a request
R. It consists of a set of services and a set of parameter bindings defining the
data flow among them. Start and end of wf are defined according to R. The
side starting with R.I and R.P (ending with R.O and R.E) is called the left
side L(wf) (right side R(wf)) of wf. wf is correct wrt. R (satisfies R), iff:
(i) All inputs of services S  wf are bound to outputs of other services in wf

or R.I.

(ii) The overall IO signature of wf plugs into request R:

X. Cao et al.

X  X;
?

?

?
S  wf : S  wf : (

S.E)  R.P = S.P ;

S in wf S.E = R.E.

(a) S  wf, ?x : X  S.I : S  (wf\{S})  {R}, ?x : X  S.I :
(b) ?y : Y   R.O : S  wf, ?y : Y  S.O : Y  Y .
S in wf S.E)  R.P ;
(iii) With parameter bindings, no conflicting literals is in (
(iv) With parameter bindings, preconditions of all services in wf are satisfied:
?

?

?
SS
(v) R.E can be implied by wf:
Example 2 : Figure 1 shows a correct workflow wf wrt. (satisfying) R: R.I =
{?m0 : M aterial}, R.O = {?pro0 : P roduct}, R.P = true and R.E = shaped
(?pro0). R asks for some service that produces a shaped product using its source
material. IO (PE) are illustrated with black (red) arrows. Parameter bindings
(implications) are shown as blue dashed (solid) arrows. In brief, wf specifies the
following procedure: a source material ?m0 is applied to a filtering process to
assure some quality requirements. Then it is heated and shaped with additional
softener into a product. wf is correct wrt. R because: (i) each input of any
service in wf has been bound to an output of another service in wf. E.g. the
binding between ?m4 and ?m0; (ii) wf plugs into R, because the type M aterial
of ?m0 is equal to the type of ?m4, and the type P roduct of ?pro in S9 is equal
S in wf S.E)R.P ,
to the type of ?pro0; (iii) there are no conflicting literals in (
given the bindings; (iv) all preconditions in wf hold: S9.P is implied by S6.E,
S5.E and S1.E with b(?m3, ?m1), b(?m1, ?m) and b(?so1, ?so); S5.P is implied
by S6.E with b(?m3, ?m1). (v) R.E is implied by S9.E with b(?pro, ?pro0). 
While the former definitions focus on the workflows and its composition, the
remainder of the section will elaborate on finding such workflows in unstructured
P2P networks under assumptions stated above.
Definition 3: Distributed stateless semantic service composition problem.
The distributed stateless semantic service composition problem is a tuple N ,
S, R, wf. Given request R, the goal is to construct a correct workflow wf
satisfying R. wf is collaboratively composed by peers in an unstructured P2P
network N based on their services S.

In SPSC, a request R to the network is delegated to a walker-based query. Besides
R, a query contains auxiliary fields required by the proposed algorithm.
Definition 4: Semantic query (abbr. query) q for a request R.
q = R, path, psug, T T L, wf, T b, h, where R is the request; path is a sequence
of peer IDs that q has traversed; psug is a path suggestion for this query; T T L
is the time-to-live value of this query; wf is the workflow (initialized as empty)
answering to R; T b is the memo table (initialized as empty), which will be used
by the memorization strategy (cf. Sect. 3.2); h (h  [0, 1]) is the current guard

value of wf (initialized as 0).

3 Distributed Semantic Service Composition

SPSC mainly builds on three aspects: local observations of peers, guarded composition and query routing.
?

?

?
Local Observations of Peers: In SPSC, any peer p is allowed to observe the
entire content of a received query q while it is backtracking. Any unknown service
in q.wf is added to Sp for later use. Once knowing about (not providing) S, p is
called a service signature maintainer of S. Besides, p updates its local view on
the network topology based on the observed query path and path suggestion.
Guarded Composition: A query q in SPSC is an epidemic walker with TTL
limitation. A workflow wf is built collaboratively by peers on the query path
using a bidirectional chaining approach. On receiving q on its forward journey, a
peer p executes the local composition process (cf. Algorithm 1) based on its local
knowledge about services. Once wf is correct or TTL=0, p makes q backtrack.
For composition, p locally checks whether each S  Sp can be chained to the
left or right side of wf. A chaining score (cf. Sect. 3.1) is computed to measure
the chaining quality. If it is larger than a threshold (cf. Sect. 3.2), p considers S
to be potentially useful and temporarily adds it to wf, yielding a new workflow
wf. In order to protect wf from arbitrary augmentation, a guard value h wrt.
wf is computed. If h is larger than the original guard value recorded in q, S
is treated as a useful service wrt. wf, and wf will be fixed. Then, p replaces
q.h with h. In cases that S can (a) be chained but without incrementing the
guard value, or (b) not be chained into a workflow at all, p applies memorization
strategy for carrying the potentially useful service in q. For (a), p adds S into
the memo table of q; for (b), p adds S into the memo table with a rate rm (cf.
Eq. 2). If an alternative service S (cf. Sect. 3.1) of a candidate service S  wf
is found, p issues a sub-query with a new workflow wf using S instead of S.
Query Routing: p routes q, after the local composition process. Instead of an
immediate neighbor, p suggests a path for routing q, based on its local knowledge.
The suggested path traverses multiple key peers and its total inverse importance
score per traffic cost is minimized, under TTL limit (cf. Eq. 3). Once formed,
such a path is set to q.psug (cf. Def.4) and q is routed to the first peer on q.psug.

3.1 Chaining Between Two Services

On receiving a query, each peer checks whether a known service can be chained
to the left or right side of the current workflow. In particular, to chain service S
after S, the following has to be considered: (i) to what extent can the variables of
S.O be accepted by S.I, and (ii) to what extent can the effect S.E imply S.P .
For this, the peer computes chaining scores chIO(S, S) at IO and chP E(S, S)
at PE levels. On top of this, the overall score ch(S, S) is computed:

ch(S, S) = 1
df(t, t) = min{ t

t , t

t }, t, t  (0, 1].

2(chIO(S, S) + chP E(S, S))  df(chIO(S, S), chP E(S, S));

(1)

This valuation considers IO and PE equally, while it further adjusts the overall outcome by including a difference factor df(,). This ensures that low quality results
with large discrepancy between chIO(S, S) and chP E(S, S) are downgraded and
possibly filtered out later. To compute ch(S, S), chIO(S, S) is considered first.

X. Cao et al.

This step determines which parameter in S.O can be used by which parameter in
S.I and yields a set of parameter bindings. By applying the substitutions {?z 
?x, ?z ?y} of bound parameters ?x  S.O and ?y  S.I, the S.E and S.P formulas are adapted, in order to compute chP E(S, S) afterwards. SPSC concerns IO
before PE, because the latter with all possible parameter bindings would introduce
a large computational overhead.
IO Chaining Score. For each concept Y of each variable ?y  S.I, this process
tries to find its best subsumee from the set of variable/concept pairs (?x : X)
of S.O. Such a subsumee yields the largest concept subsumption similarity score
(such as [17]), compared to the others in S.O and additionally exceeds a binding threshold   (0, 1]. Once found, a binding is created. Given the bindings,
chIO(S, S) =
PE Chaining Score. The first step is to apply the substitutions of the bindings
above to S.E and S.P . Subsequently, the implication S.E  cl is checked using
-subsumption [18], for each clause cl in S.P that does not contain unbound
variables. Let SC be the set of satisfied clauses in S.P , |S.P| the total num-
|SC|
ber of clauses S.P : chP E(S, S) =
|S.P|. If there exists a contradiction in

S in wf S.E)  R.P given the variable substitutions, chP E(S, S) is set to 0.
(

|S.I|, where M  S.I is the set of bound parameters in S.I.
|M|

Input: query q; Output: void.

if q.wf is new, queryP rocess(q

);}

succ); if q.wf is new, queryP rocess(q

);} }

else if (ch >  and h  q.h) add S into memo table q.T b; goto line 3;
else add S into q.T b with the rate rm(S); }

;

else update q.T b;

; goto line 3;

ch  bidirectional chaining S into q.wf ;
compute the new guard value h
if h > q.h
if the workflow of q is correct, break;
q.h  h

Algorithm 1. queryP rocess(q).
1: if q is being forwarded
q.T T L  q.T T L  1;
2:
for each S  Sp do {
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22: else q is backtracking, update the local observation;
23:

if q.wf is correct or q.T T L = 0, make q backtrack;
else, make a path suggestion for q and route q;
if q.wf is not correct and q.T T L > 0
for each candidate service S in q.wf do {

q  createSubQuery(q, {S});

Spred  f indAlternativeP redecessorServices(S, wf );
for each S  Spred do {
Ssucc  f indAlternativeSuccessorServices(S, wf );
for each subset S
q  createSubQuery(q, S

succ  2(SsuccS)\{S} do {

if p is not the requester peer of q, force q to backtrack;

endif
?

?

?
3.2 Semantic Composition of Services

Guarded Composition: Each query q in SPSC is a TTL-restricted epidemic
walker starting from the requester peer. The workflow is collaboratively constructed by peers on the query path by means of bidirectional chaining.
On receiving q, each peer p executes queryP rocess(q) (cf. Algorithm 1). Workflow constructions takes places while q is being forwarded. For each S  Sp, p
considers to chain S to both L(wf) and R(wf) (line 4). For this, it computes
ch(L(wf), S) and ch(S, R(wf)), where the output of L(wf) (input of R(wf))
contains all unbound outputs (inputs) of services currently in L(wf) (R(wf)).
If either ch(L(wf), S) or ch(S, R(wf)) is larger than the chaining threshold
  (0, 1], S will be regarded as candidate service. p temporarily makes the
hypothesis that S has been chained to wf, which results in a new hypothetical
workflow wf. Subsequently, p computes the guard value h (line 5), which is
the chaining score (cf. Eq. 1) of L(wf) and R(wf): h = ch(L(wf), R(wf)).
If h > q.h, S is treated as useful service for constructing the workflow and wf
is fixed. q.h is replaced with h (line 8). In case that two observed services have
the same IOPE signature but different QoS values, the one with higher quality
is used.
Memorization Strategy: A query q can encounter some service S that (a)
can be chained to one side but without increasing the guard value or (b) can
not be temporarily chained to any side at all. S potentially would work as a key
predecessor/successor of other useful services at later steps. Please note, that this
situation is considerably different from what is typically assumed for centralized
AI planners such as [14] which can fully observe the problem space. In the P2P
setting considered for SPSC however, this case may appear frequently. To avoid
missing S, a memorization strategy is introduced to carry over information about
those potentially useful services. For this, the memo table T b (cf. Definition 4)
is used. Each row in T b corresponds to a candidate service. It contains 3 entries:
(1) the profile of S; (2) a side flag in {L, R, null}, which indicates whether S
can be chained at the left, right or none of the both sides of the workflow; (3) a
pointer that references another service S in this table, if S can be chained to S
as a direct predecessor or successor. The pointer is null, if the service of this row
can not be chained to any side or its direct predecessor/successor has not been
determined yet. The memorization strategy is as follows: In case (a), p adds S to
q.T b; sets the side flag; and sets the pointer to the direct predecessor/successor
(line 9). In case (b), p adds S to q.T b based on the usefulness rate rm(S) of S
(rm(S)  [0, 1], cf. Eq. 2) (line 10).
Apart from the cases (a) and (b), when the chaining of a useful service S
leads to an increment of guard value, the memo table can also be updated by
removing predecessor and successor services of S. This can happen, when they
do not have unbound inputs or unsatisfied preconditions, due to their chaining
with S. p checks this and updates the memo table if needed (line 8).

To estimate the potential usefulness of an un-chainable service S wrt. wf,
rm(S) is computed by each peer locally, based on a set QS of observed queries
?

?

?
in the past. Let a(S) (a(S)) be the number of (correct) workflows that use S;
b(S) (b(S)) be the number of (correct) workflows that do not use S.


a
(S)
a(S)+1

, if a(S) = 0;
b(S)+1), otherwise.

(S)

 (1  b

(2)
?

?

?
rm(S) =

(S)

(S)

a
a(S)+1 ( b
b(S)+1) is the statistical positive (negative) influence of treating (ignor-
ing) S as candidate.  (  [0, 1],   R) is the default memorization rate.
To choose QS, one option is to collect all the observed queries. It is easy to
be applied, but rather inaccurate due to irrelevant queries. Another option is to
consider only the queries similar to q by applying service matchmakers, like iSeM
[15]. It yields better accuracy, but some computational overhead. A compromise
is to consider the relevant queries observed in a time window.
Query Branching with Alternative Service: Let S1 and S2 be two different services. If they can be chained to the same side of another service S with
the bindings that contain the same subset of variables in S.O (S.I), S1 and S2
are called alternative successors (predecessors) wrt. S. For example, S10 (Shap-
ingSrv1 ) is an alternative predecessor service to the shapingSrv (cf. Fig. 1) wrt.
R.O: I10 = (M aterial ?m); O10 = (P roduct ?pro); P10 = tempLargerT han(?m,
200)  qualityN otBad (?m); E10 = shaped(?pro). Both of S9 and S10 can be
chained to R.O with bindings on the same subset {P roduct ?pro0} of variables.
If a peer p can not find a correct solution locally, p tries to find the alternative predecessor (Spred) / successor (Ssucc) services (lines 15 and 18) for each
hypothetically chained candidate service S in memo table. On top of this, p
determines the possible sub-queries. For each S  Spred, p creates a sub-query
q, in order to investigate the possible workflow with S (line 17): p initializes q
as a copy of q. Then, it replaces S with S in q.T b and unchains those candidate
services that depend on S. Further, p computes q.h by Eq. 1. Finally, p executes
queryP rocess(q), if q.wf has not been processed by p before. If there exists a
non-empty set Ssucc of alternative successor services of S wrt. a service S in
wf, the services in any subset of Ssucc can be chained to S.O at the same time
by sharing the data of bound variables. Namely, after the execution of S, all
services in Ssucc have chance to be executed in one workflow. In this case, p will
issue (line 20) one sub-query for each element in the power set 2SsuccS\{S}.
E.g. if Ssucc = {S}, p issues the sub-queries for {S} and {S, S}.

3.3 Query Routing

A query q is forwarded, if its workflow wf is not correct and q.T T L > 0. For
this, p computes a path suggestion (PS) containing a sequence of key peers, for
which the total inverse importance score per traffic cost is minimized, under the
TTL limit. (line 13 in Algorithm 1). A key peer is either (1) the provider of a
memorized candidate service S in wf, or (2) the signature maintainer peer pm of
S. From pm, a peer p  q.path got to know S and p is the first one (compared
with the others in q.path) that uses S for the building of wf. The reason to
?

?

?
consider key peers is that they have higher chances of knowing about other
services chain-able to S. The creation of PS is modeled as a relaxed variant of
the travelling salesman problem (Eq. 3): (i) no distinct return journey is needed;
(ii) a peer can be traversed by a (sub-)query multiple times, if needed to reach
key peers.
?

?

?
minimize:
pPkey
w(p, q, p) = L(p,p
)
sr(p,S) ;

w(p, q, p);
?

?

?
L(p
s.t.:
sr(p, S) = rm(S) 

p
i, p

i+1

i+1)  q.T T L.
i, p
|wfH|+1dep(S)

qos(S)

.

(3)

i, p

where Pkey is the set of key peers and p  {p}  Pkey; w(p, q, p) is the inverse
importance score per traffic cost of a key peer p, if q is suggested to reach p
from p; L(p
i+1) is the length of the shortest path between the i-the and the
(i+1)-th key peers in PS; sr(p, S) is the importance score of S wrt. wf, which is
determined by the historical usefulness rate value rm(S) and the stability factor
of wf. The latter is estimated based on the service quality and the dependency
relations between S and its predecessors or successors. |wfH| is the total number
of hypothetically chained candidate services; the dependency factor dep(S) is the
number of the necessary predecessors/successors of S in T b.

last, q, p

Inspired by the closest neighbor heuristics [13], p computes an approximately
optimal PS in a greedy manner. Based on ps local knowledge about the network
topology, p iteratively selects the current best key peer p
best that yields the
minimal w(p
last is either the last key peer or p in current PS.
After each iteration, p concatenates the shortest path p
best to the tail of
current PS, considering TTL limitation. When p receives q and q.psug = empty,
p recomputes it if p has made contribution to the building of workflow, i.e. q.T b
has been updated by p; otherwise, p routes q according to q.psug. p routes q to
a random neighbor, if q.psug is empty and p is not able to suggest a path for q.

last  p

best). p

4 Theoretical Analysis
Lower Bound of Completeness wrt. Plan Existence. Let F  N+ be the
initial TTL value of each query. In unstructured P2P, approaches for solving a
query q can only be incomplete in any case, given that there is no guarantee that
peers knowing about services required for the solution can be traversed before
TTL is exceeded. Therefore, the following analysis is focused on solvable cases,
which are characterized as follows: in a connected unstructured P2P network
with N peers, all services S required for the correct solution to q.R are known
by a set P (|P|  F ) of peers that can be traversed in F hops from qs requester.
The collaborative composition process is modeled by a finite Markov process.
Let v (1 v) be the probability of q being (not) forwarded to a peer in P . Once
q.wf is correct (final state), q is not forwarded anymore with probability 1.
If |P|  F , the probability P r of reaching the final state within F hops is:
P r =
In the worst case, |P| = F and each p  P knows at least one service
in S. This yields the generic lower bound v|P|. By memorization strategy and

  v|P|  (1  v)j|P| + v|P|; otherwise, P r = 0.

j1
|P|1

j=|P|+1

F
?

?

?
X. Cao et al.

S dg

 1
dg = n(t)

peers observation, a request then can be solved by less than |P| peers. Namely,
v = n(t)
S is the total number of peers
that know S after the t-th query; dg is the maximum peer connectivity;  is
the average memorization rate wrt. a service S  S. The propagation of the
signature of S can be modeled by a recursive function (cf. Eq. 4) with n(0)
S = 1:

N increases over queries. n(t)

S = n(t1)
n(t)

+

F 2
N 2

  n(t1)

 (N  n(t1)

),

(4)

N 2

N 2

S = n(0)

)t. This indicates that n(t)
).

We investigate the following: (1) Will all N peers eventually know about S or
not? (2) How fast will the epidemic process converge? For (1), it holds that
S = N and moreover v  1 for t  ; For (2), the right-hand part (N 
n()
n(t1)
) of Eq. 4 will eventually reach some fixed  > 0, allowing for the following
S  (1 + F 2
substitution: n(t)
S converges sublinearly to N with the rate (1 + F 2
Proof of Correctness. The correctness of SPSC consists of two aspects: (1)
correctness of the guard heuristics and (2) correctness of the collaborative com-
position. Intuitively, (1) means that a correct workflow is achieved when its guard
value equals to 1 (Theorem 4.1), while (2) indicates that the guard value of a
workflow is monotonically increasing during the distributed composition process
and reaches 1 within a lower bound (Theorem 4.2).
Theorem 4.1. A workflow wfis correct, if h = 1.
Proof: We prove this by contradiction. Assuming that h = 1, but wf is not
correct, it follows that at least one criteria in Def. 4 is not satisfied. By Eq. 1,

the violation of any criterion leads to h < 1. Contradiction.
Lemma 4.1. The guard value of a (sub-)query q is monotonically increasing
during the entire query processing on all its traversed peers.
Proof: According to Algorithm 1, no peer decreases the guard value by its local
composition process. During query routing, no process changes the guard value. 
Inspired by the Floyd-Hoare theory [2] and Polyhedral Compilation Foundations
lecture notes2 of the UCLA, we reduce the joint composition of SPSC into a loop
algorithm, and prove the correctness of it. Consider the whole P2P network as a
huge computer containing lots of processing units (peers). A query is a task that
is processed by peers in turn until TTL=0 or it is resolved (correct workflow
composed). Each unit (peer) executes Algorithm 1 on receiving the query. This
corresponds to an iteration. Following [2], we prove the preservation of evidencing invariants: (a): h of each (sub-)query q is monotonically increasing. This
means that the joint composition process leads any intermediate partial solution
(workflow) strictly towards a better follow-up step; (b): No alternative branch
is missed. This indicates that all possible workflow options will be investigated.

2 http://www.cs.ucla.edu/pouchet/lectures/doc/888.11.algo.6.pdf.
?

?

?
Theorem 4.2. SPSC is correct: Given a query, SPSC returns a correct solution
with lower bound probability, if that solution exists within F hops.
Proof: Initialization: q.h is initialized with 0. Before the composition starts, h
is not decreasing. The workflow container is empty. Hence, no alternative can be
missed. Maintenance: By Lemma 4.1, q.h is monotonically increasing during
local composition. Moreover, Algorithm 1 ensures that it checks all alternative
services for each service in wf. No alternative service is missed at p. Termi-
nation: The entire process terminates, if q.T T L = 0 or h = 1. At this time,
h is not smaller than its initial value. No alternative service for each service in
wf has been missed, as no one was missed in each iteration. Overall, q.h is not
decreasing and has a lower bound probability to reach 1 (q.wf is correct). 
Complexities. Denote N (E): the total number of peers (edges) in an unstructured P2P network; m1: the number of primitive terms in V ; m2 (m3): the maximum number of PE predicates (IO parameters) in a service; lch: the complexity
 mm1
for computing service chaining score: lch = lbp + lsat, where lbp = O(m2
1 )
is the complexity for determining parameter bindings; lsat = O(|Op|m3  m2) is
the complexity for checking whether a service effect is satisfied [18], where |Op|
is the number of concepts in a peers local ontology. O(mm1
1 ) is the cost for
measuring concept similarity; n: the number of services a peer can know about;
F: the initial value of query TTL; lsp = O(E + N logN): the cost for computing
a shortest path [5]; L: the number of services in a workflow.
Computational complexity. In Algorithm 1, p attempts to chain local services
exhaustively to the current workflow. This yields the worst case complexity
O(nn  lch). p also checks alternative services for each candidate service in wf
yielding the process of up to L  2n sub-queries. Thus, the complexity of local
composition is O(L 2n  nn  lch + nn  lch)  O(L (2n)n  lch). To suggest a routing path, p computes the w(,,) value (cf. Eq. 3) for each candidate service S.
rm(S) is computed in O(1) incrementally. The actual workflow size and dependencies can be computed in O(L). For augmenting a suggested path, p selects
the best key peer. This costs at most O(L2  lsp). Further, there can be at most
F augmentations. Overall, the computation complexity for path suggestion at p
is O(L2  F  lsp).
Traffic complexity. For a query, p issues O(L  2n) sub-queries at most, of which
each inherits the current TTL value. Thus, the total number of forwarding messages of a query is 2  F1
Robustness. Unstructured P2P networks are ad hoc environments. SPSC handles the dynamics of the network topology and services. The arrival of a new
service provider or the addition of a new service S matters, if the provider peer
p in the meanwhile processes a query q. In this case, p performs the local composition process against S. If q is backtracking, p issues a sub-query q from itself
when S can work as an alternative service. The departure of a service provider or
the deletion of a service can cause in incorrect path suggestions. In SPSC, peers
react passively in this situation, without extra message exchange. If a departure event is detected (messaging timeout) by another peer p with routing q, p

j=0 ((L  2n + 1)j)  O((L  2n + 1)F ).

X. Cao et al.

deletes the reference of S from Sp and q.wf. Subsequently, p recomputes q.psug.
Service signature update is treated as a sequence of deletion and addition.

5 Experimental Evaluation

Settings. Based on our P2P framework3, we simulated random graph (RG)
and random power law graph (RPLG) based unstructured P2P networks with
1000 peers. Their average connectivity degrees are 10.295 and 4.457, respectively.
To enable large scale evaluation, we disabled peer IP-based communication and
simulated this by using global data structures and function calls. The initial
query TTL is 10.  = 0.3 and  = 1.0. To the best of our knowledge, no test
collection is suited for stateless composition of semantic services with IOPE. The
IPC 20114 test collection is well-known in stateful AI planning. However, the
factual representations of initial and goal states of IPC queries are not suitable
for applying SPSC. The WSC5 test bed supports only IO but not PE. Therefore,
we developed a preliminary test collection6 with 40 IOPE semantic services
and 7 requests. Each request is labeled with one or two correct solutions with
different groups of services. The service and query distributions are random. The
experiments has been done on a PC with Core i7 CPU (2.80 GHz), 8 GB RAM.
Evaluation Measures. Let Q be the set of issued queries. ECm,q  {0, 1}
means whether (or not) there exists a set of services at remote peers reachable
within m hops from the requester. Cm,q  {0, 1} means whether (or not) a correct
solution of q has been composed within m hops. We check: (1) CREm: average
cumulative recall within distance m: CREm = 1|Q|
ECm,q is 0, if
ECm,q = 0. (2) QUR: average QoS rate of resolved queries. Besides the services
in the test collection with their pre-defined QoS, another copy of them with 50 %
lower QoS has been deployed. Let rtquq be the run time quality of a resolved
query q, defined as the average quality of all services used in the result workflow,
and exquq the average quality of the optimal solution wrt. service quality (100 %
rtquq
QoS). QU R = 1|Q|
exquq . (3) #M: average number of forwarded messages
per query. (4) average traffic load size (in KB) of query. (5) total number of
forward messages of each peer. (6) AQRT: average query response time.
Cumulative Recall and Workflow Quality. We compare the average cumulative recall after 1000 queries using different memorization rates , in RG and
RPLG networks (cf Fig. 2a and b). Baseline results for composition without memorization and without guard value mechanism are also shown. As can be seen,
SPSC with memorization largely outperforms the baselines, which either are not
able to keep track of potentially useful services, or perform arbitrary chaining. In
addition, SPSC achieves 10 %  20 % higher cumulative recall in RG compared to
RPLG, as the latter may contain islands, while the RG does not.
3 http://sourceforge.net/p/mymedia-peer/code/HEAD/tree/trunk/.
4 http://www.plg.inf.uc3m.es/ipc2011-deterministic/Resources.html.
5 http://www.ws-challenge.org/.
6 http://sourceforge.net/projects/mymedia-peer/files/.

ECm,q . Cm,q

qQ
?

?

?
Cm,q

qQ
?

?

?
(a) CREm (RG)

(b) CREm (RPLG)

(c) QU R

(d) #P M (RPLG)

(e) #M (RG)

(f) AQRT (RG)

(g) CRM10 (RPLG)

(h) CRM10 (RG)

Fig. 2. Experimental evaluation results of SPSC with different settings.

For both configurations, it holds that higher  values yield better recall. In
RG, more than 90 % of queries are resolved before their TTL limit is reached.
Particularly, the correct solutions for at least 90 % of the queries are composed
at early hops already when the memorization rate was relatively high (  0.6).
This indicates that necessary services for resolving requests are propagated effectively and path suggestions support proper routing. Further, we check the system
evolution speed with the CRE10 value (CRE at 10th hop) over time. After about
(200) 500 queries, more than (60 %) 80 % requests are correctly resolved. This
evidences the effectiveness of peer local observation and memorization mecha-
nism. SPSC query routing also effectively considers QoS (cf. Fig. 2c) as a criterium for path suggestions, ultimately leading to an increase of QUR over time.
Network Traffic Overhead. The average number of messages per query #M
decreases as the number of queries increases, and converges to a value less than
3 for RG (cf. Fig. 2e) and 2 for RPLG. The number of messages for successful
queries #MC also decreases similarly, since the knowledge about services from
observations at peers is enriched over time. The number of messages for unresolved queries #MN C is large and increases over time. However, the #M values
imply that query branching occurs more rarely, since queries are solved in a few
hops. Overall, SPSC in RG costs larger network traffic than with RPLG, since
peers in RG have similar connectivity, while in RPLG, some backbone peers
are better connected. They are easier to observe queries and hence obtain more
knowledge to solve queries. Investigation of the traffic load size per query shows
results in line with the previous observations. The average size of resolved queries
was 60 KB (RPLG) and 75 KB (RG), while for unresolved queries, messages of

X. Cao et al.

about 200 KB (RPLG) and 620 KB (RG) size have been sent on average. Fig. 2d
depicts the number of messages received at each peer of the RPLG network in
descending order. The overall maximum is only 13 without bottleneck problem,
even with RPLG, as peers learn over time and resolve queries in few hops.
Query Response Time. Similar to #M, the overall AQRT in RG (cf. Fig. 2f)
and RPLG decreases over queries, due to the peers increasingly observed knowl-
edge, helping to resolve queries in few hops. Less messaging and query processing
decrease AQRT in the long run for RG and RPLG.
Robustness. We test CRE10 of SPSC in RG and RPLG based configurations
with network topology dynamics. For this, we programmatically force, after each
SR queries (called a stable round), a percentage (F R) of randomly selected peers
to leave off and the departed peers in the last round to re-join the network.
System starts with all peers online and no dynamics event occurs during a stable
round. The results with RPLG (cf. Fig. 2g) and RG networks show that the
system can recover given the network dynamics, since peer observation helps to
repair the semantic overlay. More frequent (SR) or heavier (F R) dynamics yields
stronger impact, but SPSC still gives acceptable performance, as the chance of
losing backbone peers in RPLG is relatively small given the random selection.
To test SPSC performance with service dynamics, we programmatically force a
percentage (P R) of randomly selected peers to forget all their knowledge about
services after each stable round. The results with RG (cf. Fig. 2h) and RPLG
show that the system can recover under service dynamics. The impact is stronger,
if dynamics is more frequent or heavier.

6 Related Work

PM4SWS [10,11] performs IO-level semantic service composition. Each peer
records observed compositions in a lookup table. Given a query, if no correct
solution found in the table, it tries to chain a known service to the current
workflow. Using the classic flooding, it can cause in immense network traffics.
In contrast, SPSC peer issues sub-queries for only the new partial solutions.

In [68], Furno et al. present the probabilistic flooding-based stateful service
composition method SCComp. Peers route queries to a set of selected helpful
neighbors to resolve the sub-goals. Once a sub-goal has been resolved, extra
transitive messages are sent for re-constructing the overall solution. Despite
the selective flooding, network traffic can still be heavy, since a peer still has
chance to receive duplicate queries with the same sub-goal. In contrast, SPSC
uses walker-based routing with search space pruning and memorization strat-
egy. SCComp needs extra messages to adapt to network dynamics, but SPSC
does not.

AntAgt [3,4,23] utilizes an ant-inspired and agend-based approach. Peers
maintain co-use matrices that contain pairs of classified reusable services observed
in historical plans. A composition task is assumed to be pre-configured in terms
of a set of key classes, forming a workflow template. Give a query, a peer selects
?

?

?
its local services matching some keys and forward queries to another peer for the
remaining keys. SPSC does not depend on plan templates but actually finds workflows at runtime. Similar efforts [12,22] also rely on design phase.

Approaches based on (semi-)structured overlay, e.g. DHT [20,24] or super
peers [9], can assure certain completeness. However, to adapt to the network
dynamics, approaches in this kind cost large traffics to maintain overlay. Using
super peers introduces bottlenecks and single points of failure. In contrast, SPSC
operates unstructured and does not require additional coordination effort.

7 Conclusion

The presented SPSC approach solves the problem of efficient and distributed
OWL-S service composition planning in unstructured P2P networks. In contrast to related work, it mitigates composition failures caused by dead-ends and
prunes the search space for efficient joint composition through heuristics-based
semantics-empowered memorization and query branching. SPSC has been theoretically proven to be sound with reasonable lower bound of completeness. The
experiments revealed its high cumulative recall with low network traffic over-
head, and robustness to dynamic changes.

Acknowledgment. This work is supported by the German ministry for education
and research (BMBF) in the projects Collaborate3D and Inversiv under grant numbers
01IW1102 and 01IW14004.
