Towards Defeasible Mappings for Tractable

Description Logics

Kunal Sengupta(B) and Pascal Hitzler

Wright State University, Dayton, OH 45435, USA

{sengupta.4,pascal.hitzler}@wright.edu

Abstract. We present a novel approach to denote mappings between
EL-based ontologies which are defeasible in the sense that such a mapping only applies to individuals if this does not cause an inconsistency.
This provides the advantage of handling exceptions automatically and
thereby avoiding logical inconsistencies that may be caused due to the
traditional type of mappings. We consider the case where mappings from
many possibly heterogeneous ontologies are one-way links towards an
overarching ontology. Questions can then be asked in terms of the concepts in the overarching ontology. We provide the formal semantics for
the defeasible mappings and show that reasoning under such a setting
is decidable even when the defeasible axioms apply to unknowns. Fur-
thermore, we show that this semantics actually is strongly related to the
idea of answer sets for logic programs.

1 Introduction

Description logic (DL) based knowledge representation is gaining in popularity
and with that the number of domain ontologies is also on the rise. Especially
in the medical domain, tractable fragments of DLs are heavily used. For exam-
ple, SNOMED CT is a medical ontology which consists of more than 300,000
concepts, and which can be described in the description logic EL [1]. Smaller
fragments of DLs are especially interesting for application scenarios where fast
and efficient reasoning may be critical.

In this paper, we provide a formal framework for dealing with defeasible
reasoning for smaller fragments of DLs, especially in the context of ontology
alignment. In particular we consider a language ER,O which allows for con-
junction, existentials, role chains, disjointness of concepts and ABox statements
and provide a semantics for one-way (defeasible) alignments from terms in several ontologies to one overarching ontology such that queries can be asked in
terms of this overarching ontology, while answers may contain instances from
several lower level ontologies. For defeasibility we take motivation from default
logic [21] and define the semantics along similar lines. It turns out that combining DLs with default-like semantics is not very straightforward as unrestricted
default applications may result in undecidability [2,23]. Previously, decidability
was usually obtained for such logics by restricting defeasibility to known individ-
uals, i.e. to a finite set of entities. In this paper, we show that the combination
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 237252, 2015.
DOI: 10.1007/978-3-319-25007-6 14

K. Sengupta and P. Hitzler

Veg  NonVeg  

(1)
consumes.EggFood  NonVeg
(2)
contains  consumes  consumes (3)
(4)

{juliet}  Veg

{romeo}  Eggetarian
Eggetarian  Vegetarian
Eggetarian  eats.Egg
Eggetarian  NonVegetarian  

{caesar}  Vegetarian
{caesar}  NotEggetarian
NotEggetarian  Eggetarian  

Vegetarian  Veg

NonVeg  NonVegetarian
EggFood  Egg

eats  consumes

(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)
(15)

Fig. 1. Example mapping with selected axioms.

of defeasible mappings with DLs presented here is decidable even without this
type of restriction. Decidability in our setting results from our restriction to a
tractable language in the EL family, together with the avoidance of recursion
through the defeasible axioms resulting from our specific, but practically important application scenario, namely the one-way alignment of ontologies.

Indeed, similar concepts appear in several ontologies from heterogeneous
domains, but these concepts may slightly differ semantically. The motivation
of using defeasible axioms as alignments stems from the need to handle such
heterogeneity among various data models. As we discuss in our previous work
[23], DL axioms are semantically too rigid to be able to deal with alignments in
such heterogeneous settings, in particular in the light of the fact that ontology
alignment systems mostly rely on string similarity matching [7]. For example, the
concept that represents those human beings who consume only vegetarian food
may be part of two different domain ontologies but the notion of what vegetarian
food means might slightly differ depending on the context, e.g. in some places
eggs might be part of a typical vegetarian diet while in others this may not be
so. Aligning these different world views appropriately cannot be done by simply
mapping the respective concepts representing a vegetarian person in different
ontologies, as claiming that they were equivalent may lead to inconsistencies.

For example consider the axioms in Figure 1 (see section 2 for explanations
of the notation). Axioms 14 represent one ontology and axioms 511 another
ontology. An alignment system may give alignments similar to axioms 1215.
Since romeo is an Eggetarian (axiom 5) he is also a Vegetarian (axiom 6). And
since every Vegetarian is also a Veg as per the mapping axiom 12, romeo is a
Veg. From axioms 5, 7, 14, 15 and 2 we obtain that romeo is also a NonVeg.
But Veg and NonVeg are disjoint classes, so this results in an inconsistency. But
applying the same rules to caesar does not cause an inconsistency. The usual
process of repairing alignments like this is to remove mappings that cause the
?

?

?
inconsistency [13]. But we would then lose the conclusion that caesar is also
a Veg. If we replace the mapping axioms with defeasible axioms as introduced
below, then we could achieve this outcome where we carry over the similarities
while respecting the differences.
The paper is organized as follows. In section 2, we set the preliminaries by
describing the language ER,O. The context of ontology mappings as well as the
syntax and the semantics of defeasible mapping axioms along with the discussion
on decidability is presented in section 3. Section 4 contains a description of the
relation of the semantics of this approach with that of answer set programming
for logic programs. Finally we discuss related work in section 5 and provide
closing remarks in section 6.

2 The Description Logic ER,O
We consider the DL ER,O (see [1] for further background). Let NC be a set of
atomic concepts (or atomic classes), let NR be a set of roles and let NI be a set
of individuals, which contains an element R,D for each pair (R, D)  NR  NC.
These R,D are called auxilliary individuals. Complex class expressions (short,
complex classes) in ER,O are defined using the grammar
C ::= A |  |  | C1  C2 | R.C | {a},
where A  NC, R  NR and C1, C2, C are complex class expressions. Further-
more, a nominal class (short, nominal) is represented as {a}, where a  NI. A
TBox in ER,O is a set of general class inclusion (GCI ) axioms of the form
C  D, where C and D are complex classes. C  D abbreviates two GCIs
C  D and D  C. An RBox in ER,O is a set of role inclusion (RI ) axioms of
the form R1    Rn  R, where R1, . . . , Rn, R  NR. An ABox in ER,O is a
set of GCIs of the form {a}  C and {a}  R.{b} where {a},{b} are nominals
and C is a complex class.
An ER,O knowledge base or ontology is a set of TBox, RBox and ABox
statements which furthermore satisfy the condition that nominals occur only in
ABox statements. This condition is a restriction of ER,O as compared to, e.g.,
the allowed use of nominals in OWL 2 EL: While we allow for a full ABox, the
TBox remains free of nominals. In particular, axioms such as A  R.{a}, with
A an atomic or complex class other than a nominal, are not allowed.
An initial ER,O knowledge base is an ER,O knowledge base which does

not contain any auxiliary individuals.
Example 1. The following is an example of an (initial) ER,O knowledge base.

Bird  F ly
P enguin  Bird

P enguin  F ly  

{tom}  hasP et.P enguin

K. Sengupta and P. Hitzler

Table 1. Semantics of the language ER,O

Concept

Semantics
?

?

?

{a}
C  D
C  D
R.D {x | there exists some y with (x, y)  RI
R1  R2
{a}

I

{aI}
CI  DI
CI  DI
1  RI

{aI}

and y  DI}

Next, we describe the semantics of the language ER,O using the notion
of interpretation. An interpretation I of an ER,O knowledge base KB is a
pair (I, .I) where I is a non-empty set of elements called the domain of
interpretation and .I is the interpretation function that maps every individual
in KB to an element of I, every concept in KB to a subset of I, and every role
to a subset of II. Concept expressions are interepreted as shown in Table 1.
An interpretation I is a model of an ER,O knowledge base KB if it satisfies all
the TBox, RBox and ABox axioms such that if C  D then CI  DI, if R  S
the RI  SI, and {a}  C then aI  CI respectively.

It is well-known that any such knowledge base can be cast into normal form,

as follows.
Definition 1. An initial ER,O knowledge base is in normal form if it contains
axioms of only the following forms, where C, C1, C2, D  NC, R, R1, R2  NR
and a, b  NI
C  D
R.C  D

C  R.D

C1  C2  D
C1  C2  
R1  R

R1  R2  R
{a}  C
{a}  R.{b}
?

?

?
in normal form such that KB |=  A  B if and only if KB

Theorem 1. For every initial ER,O knowledge base KB there exists a knowl-
 |=
edge base KB
 A  B, where  A is a class name or a nominal and B is a class name occurring
in KB.
Definition 2. Given an initial ER,O knowledge base KB in normal form, we
define the following:
1. Completion: the completion comp(KB) of KB is obtained from KB by exhaus-
2. Clash: a completion comp(KB) of KB contains a clash if {a}   

tively applying the completion rules from Figure 2.
comp(KB), for some nominal class {a}.
It is easily verified that repeated applications of completion rules on an initial
ER,O knowledge base produces only axioms which are also in normal form, with
one exception: Axioms of the form {a}  R.D, with R  NR and D  NC, can
also appear.
?

?

?
 A  C, C  D   A  D
 A  C1,  A  C2, C1  C2  D   A  D

 A  C, C  R.D   A  R.D

 A  R.  B,  B  C,R.C  D   A  D
 C  R.  D,  D     C  
 A  R.  B, R  S   A  S.  B
 A  R1.  B,  B  R2.  C, R1  R2  R   A  R.  C

(16)
(17)
(18)
(19)
(20)
(21)
(22)

Fig. 2. ER,O completion rules. New axioms resulting from the rules are added to the
existing axioms in KB . Symbols of the form  A can be either a class name or a nominal
class. We initialize comp(KB ) with KB and C  C,   C,    for all named classes
C  NC .

It is straightforward to show that comp(KB) is well-defined and that the
completion process has a polynomial time complexity. This and the soundness
and completeness results below are adapted from [1]. Since the proofs are relevant
to understanding the discussions in this paper, we include them in the appendix
of the technical report [22] available online.
Theorem 2. (soundness and completeness) Let KB be an initial ER,O knowledge base in normal form. Then every model of KB is a model of comp(KB).
Furthermore, if comp(KB) contains a clash then KB is inconsistent.
Conversely, if A is an atomic class or a nominal and B is an atomic class
such that KB |= A  B, then A  B  comp(KB). Furthermore, if KB is
inconsistent then comp(KB) contains a clash.

Note now that the ER,O knowledge base given in Example 1 is inconsistent.
Central to the proof of Theorem 2 is the following construction, which we
Given an ER,O knowledge base KB, let I = I(KB) be defined as the fol-

will also use later in this paper.

lowing interpretation of comp(KB).

I

= {x{a}, xC | C is a class name in KB and a is an individual in KB}

=


,

{xC | C  A  comp(KB)}  {x{a} | {a}  A  comp(KB)},

if A    comp(KB)
if A    comp(KB)


,
{x{a}},

{a}I

if {a}    comp(KB)
if {a}    comp(KB)

=
= {(xC, xD) | C  R.D  comp(KB)} 

{(x{a}, xD) | {a}  R.D  comp(KB)} 
{(x{a}, x{b}) | {a}  R.{b}  comp(KB)}

K. Sengupta and P. Hitzler

The proof of Theorem 2 shows that I is a model of both comp(KB) and KB.

3 Mapping Ontologies with ER,O-Defaults

We consider a rather specific but fundamentally important scenario, namely the
integration of ontology-based information by means of an overarching ontology,
as laid out and applied e.g. in [14,20]  see also the discussion of this in [23].
One of the central issues related to this type of information integration is how to
obtain the mappings of the to-be-integrated ontologies to the overarching ontol-
ogy, as the manual creation of these mappings is very costly for large ontologies.
However, methods for the automated creation of such mappings  commonly
refered to as ontology alignment  are still rather crude [7,12], and are therefore prone to lead to inconsistencies of the integrated ontologies, as discussed in
section 1. In order to deal with this, we introduce a defeasible mechanism to deal
with such mappings. For simplicity of presentation we consider only two ontolo-
gies, with one taking the role of the overarching ontology. The other ontology
can be considered the disjoint union of the ontologies which are to be integrated.

The following notion is going to be central.

Definition 3. (defeasible axiom) A defeasible axiom is of the form C d D or
R d S, where C, D are class names and R, S are roles.

Intuitively speaking, our intention with defeasible axioms is the following: It
shall function just like a class inclusion axiom, unless it causes an inconsistency,
in which case it should not apply to individuals causing this inconsistency. In a
sense, such defeasible axioms act as a type of semantic debugging of mappings:
The semantics itself encodes the removal of inconsistencies. More specifically
speaking, given a defeasible axiom C d D, instances of C will also be instances
of D, except those instances of C which cause an inconsistency when also an
instance of D. Such Cs are usually known as exceptions. Of course this intuitive
understanding of defeasible axioms is not entirely straightforward to cast into a
formal semantics.1 We will give such a formal semantics in section 3.1 below.
Definition 4. (mappings) Let O1,O2 be two consistent ER,O knowledge bases.
A ( defeasible) mapping from O1 to O2 is a defeasible axiom with the left-hand
side of the axiom a concept or role from O1, and the right-hand side a concept
or role from O2.
Note that here we restrict the mappings to axioms involving roles and atomic
classes. However, we do so without loss of generality as C d D, for complex
classes C, D, can be replaced by adding the axiom C  A to O1 and the axiom
B  D to O2, where A and B are new concept names, and replacing C d D in
 by A d B. Similarly, our approach encompasses the specific case of ontology
population, where O1 is empty and all mappings are of the form {a} d C.
1 Different ways how to do this lead to different non-monotonic logics. This is a well-

studied subfield of artificial intelligence, from which we take inspiration.
?

?

?
Definition 5. (mapped-tuple) Let O1,O2 be two ontologies in ER,O with  the
set of defeasible mappings from O1 to O2. Then the tuple (O1,O2, ) is called a
mapped-tuple.

3.1 Semantics and Decidability
Given a mapped-tuple (O1,O2, ), we define the formal semantics of the mappings following our intuitive reading as discussed above. Informally speaking, the
semantics of C d D is similar to that of normal defaults as in Reiters default
logic [21]: if x is in C, then it can be assumed that x is also in D, unless it causes
an inconsistency with respect to the current knowledge.
We define the semantics formally as follows. For each mapping axiom C d D
in  we define a set Cand that represents the set of axioms that could be possibly
added to the completion of O2 as a result of the mapping axiom.
Cand(C d D) ={{a}  D | {a}  C  comp(O1)}

(23)

Furthermore, we define the set Candn as the power set of Cand for each

mapping axiom.

Candn(C d D) ={X | X  Cand(C d D)}

(24)

Similarly, we define the corresponding sets CandR and CandnR for mapping
axioms involving roles.

CandR(R d S) ={{a}  S.{b} | {a}  R.{b}  comp(O1)}
CandnR(R d S) ={X | X  CandR(R d S)}

(25)
(26)

Note that a and b may be auxiliary individuals.

Definition 6. (mapped ontology) Let (O1,O2, ) be a mapped-tuple. Define
selections and the corresponding mapped ontology as follows:
(i) For each mapping axiom of the form C d D  , a selection for C d D
(ii) For each mapping axiom of the form R d S  , a selection for R d S
(iii) Given selections for all mappings   , we use  to denote their union
 =
2 = comp(O2)  
(iv) O

is any CdD  Candn(C d D).
is any RdS  CandnR(R d S)

 , and call  a selection for the given mapped-tuple.

X X is then called a mapped ontology.
?

?

?
Note that each mapped-tuple (O1,O2, ) can give rise to only a finite number
of corresponding mapped ontologies, and the number is bounded by |Candn(C d
D)||1|  |CandnR(R d S)||2|, where 1 (respectively, 2) is the set of class
(respectively, role) mappings contained in .
Definition 7. (preferred mapping) Let (O1,O2, ) be a mapped-tuple. Then for
any two mapped ontologies Oi
is preferred
over Oj

,Oj
2 , if all of the following hold.

2 we say Oi

or Oi

 Oj

K. Sengupta and P. Hitzler

such that Oi

  j
  j

, for all   
, for some   

- i
- i
Note that  can be of the form C d D or R d S.
The notion of preferred mapping is used to identify the individuals to which the
defeasible axioms maximally apply.
Definition 8. (mapped completion and mapped entailment) Given a mappedtuple (O1,O2, ), let O
2 be a mapped ontology obtained from some selection .
Then the completion comp(O
2 ) obtained by exhaustively applying the rules in
Figure 2 is said to be a mapped completion of (O1,O2, ) if O
2 is consistent
and there is no consistent mapped ontology Oi
 O
Furthermore, let  an axiom of the form {a}  {b} or {a}  R.{b}. Then
 is entailed by (O1,O2, ), written (O1,O2, ) |=d , if   comp(O
2 ) for each
mapped completion O
Lemma 1. A mapped-tuple (O1,O2, ) always has a mapped completion.
Proof. There are two conditions for obtaining a mapped completion comp(O
2 ):
is maximal with respect to . It is clear
(1) O
2 is consistent, namely  = . If this
that there is at least one  such that O
is the only  producing a consistent mapped ontology, then comp(O
2 ) is the
corresponding mapped completion. Now let S be the set of all selections which
produce a consistent mapped ontology. We already know that S is finite, and so
the set of corresponding consistent mapped ontologies is also finite, and therefore
contains maximal elements with respect to the preference relation . Each of
these maximal elements is then a mapped completion of (O1,O2, ).
Theorem 3. The problem of entailment checking for a mapped-tuple (O1,O2, )
is decidable.

is consistent, and (2) O

2 of (O1,O2, ).

2 holds.

Proof. In order to check entailment, it suffices to obtain all the possible mapped
completions as per definition 8. Since there is only a finite number of possible
selections for (O1,O2, ), then as argued in the proof of Lemma 1 there is only
a finite number of corresponding mapped ontologies, and furthermore we know
that exhaustive application of the completion rules terminates. Hence the task

is decidable.

3.2 Applying Defeasible Mappings to Unknowns

So far we have defined the semantics of defeasible mappings and a way to derive
entailments. Using these mappings, queries can be asked in terms of concepts of
the ontology which is being mapped to.

For instance let the ontology O1 have axioms

{john}  USCitizen

USCitizen  hasPassport.USPassport,

{john}  Traveler
?

?

?
let the ontology O2 have axioms

Tourist  hasPP.Passport

hasPP.AmericanPassport  EuVisaNotRequired,

and let  consist of the mappings

Traveler d T ourist

U SP assport d AmericanP assport.

hasP assport d hasP P

We can then ask questions in terms of the concepts and roles of O2 like list all
the tourists, i.e., all instances that belong to the class Tourist, and we would
get the answer john. But if we look carefully, we would also expect john as an
instance of the class EuVisaNotRequired.

However, as per the semantics we have defined in the previous section, we
would not be able to derive this conclusion. This is because the defeasible mappings do not apply to unknowns. In this case the unknown in question is johns
USPassport. We address this issue by modifying the semantics in order to apply
the mappings to unknowns as well.
First of all, recall that the set NI already contains the auxiliary individuals
RC for every R  NR and C  NC  we have not yet made use of them, but
we will do so now. In fact, we now modify the completion rules in Figure 2 by
adding two additional rules as follows, and where a  NI, i.e. a may also be an
auxiliary individual.

{a}  R.D  {a}  R.{RD}
{a}  R.D  {RD}  D

(27)
(28)

Furthermore, we retain all the definitions from section 3.1 starting from Cand,
CandR but using the completion compu(O1) obtained by applying the completion
rules in Figure 2 in conjunction with the new rules when producing selections.
We still use comp, the previous version without the new rules, for all other steps.

Returning to the example above, compu(O1) now becomes

{john}  U SCitizen

U SCitizen  hasP assport.U SP assport

{john}  hasP assport.{hpp,usp},

and from the mappings we obtain

{john}  T raveler

{hpp,usp}  U SP assport

O
2 = comp(O2)  {

{john}  T ourist,

{john}  hasP P.{hpp,usp},

{hpp,usp}  AmericanP assport}

}.

Note, that this O
completion rules of Figure 2 on O
EuVisaNotRequired.

2 is the only maximal mapped ontology. When we apply the
2 , rule 19 will produce the axiom {john} 
We now show that, under this new version, default mappings behave just as
ordinary mappings provided no inconsistencies arise. This is of course exactly
what we would like to obtain, i.e., the new semantics is conservative in this
respect and kicks in only if needed due to inconsistencies.

K. Sengupta and P. Hitzler

2 is consistent.
2 ) of O

2 , defined as at the end of Section

2 which extends I such that I
C and R  NO1
and DI

R , CI

Theorem 4. Let (O1,O2, ) be a mapped-tuple such that for any selection ,
2 is consistent. Let  be an ER,O axiom of the form {a}  C or {a} 
O
R.{b}, where a, b are named individuals from O1 and C, R are class names,
respectively role names, from O2. Then (O1,O2, ) |=  if and only if O1 O2 
  |= , where   is exactly the same as  but with all d replaced by .
Proof. In this case there is only one relevant selection , namely the full selec-
tion, since for every possible , O
Consider an interpretation I = I(O
2, and recall that I |= O
2 .
Let I be an interpretation of O1  O
=
I{xC | C  NO1
C }, and for all C  NO1
are
constructed from compu(O1) exactly as it is done for I from comp(O
2 ). Then
clearly I |= O
 O1. Furthermore, axioms of the form {a}  C, {a}  R.{b}
, C  NO2
where a, b  NO1
R are only produced from the axioms of
O
2 .
Moreover, I |= O1  O2    holds. To prove this it suffices to show that
I satisfies all axioms C  D    and R  S    since we already know that
I |= O1  O2. And indeed, for every axiom C  D    (which also means
C d D  ), we know that if {a}  C  compu(O1) then {a}  D  O
2 .
Hence, by definition of I, a  CIDI
. Similarly, for every axiom R  S   , we
know that whenever {a}  R.{b}  compu(O1), we have {a}  S.{b}  O
2 ,
and by definition of I, we obtain (a, b)  RI
So now, in particular, if O1  O2    |=  then I |= , and therefore I |= ,
since  does not contain any class or role names from O1. By definition of I, we
then obtain   comp(O
Conversely, consider an interpretation I = I(O) of O = O1O2   obtained
as defined at the end of Section 2, and recall that I |= O.
Now consider O = compu(O1)  comp(O2)     and note that O
2 =
comp(O2)    O and also that O  O. Let I = I(O) be obtained as
defined at the end of Section 2, and recall that I |= O. By construction, we
also obtain I |= O
So now, in particular, if (O1,O2, ) |= , for  as in the statement of the
theorem, then I |= , and therefore I |= , and by definition of I we obtain

  comp(O1  O2   ). Consequently, O1  O2    |=  as required.

2 and also that I and I coincide on the signature of O.

2 ) and consequently (O1,O2, ) |=  as required.

C and R  NO2

, SI

.

4 Relationship with Answer sets

The above semantics is inspired by Reiters default logic, as already mentioned.
Formally, we show that it is very closely related with the prominent answer set
semantics from logic programming, which in turn has a well-established relationship to Reiters default logic. We first recall the definition of answer sets
from [10], see [11] for exhaustive background reading.
Definition 9. (answer sets) An extended program is a logic program that contains rules of the form L0  L1, . . . , Lm, not Lm+1, . . . , not Ln where 0  m  n
?

?

?
Table 2. Rewriting of axioms to rules

Axiom
C  D

C  

3 R.C  D
4 C1  C2  D
5 C1  C2   C2(x)  C1(x),C1(x)  C2(x)

7 R1  R2  R

9 {a}  R.{b}

D(x)  R(x, y)  C(y)
D(x)  C1(x)  C2(x)
R(x, y)  R1(x, y)

R(x, z)  R1(x, y)  R2(y, z)

R1  R
{a}  C

Rule

D(x)  C(x)
C(x)  C(x)

C(a) 
R(a, b) 

and each Li is a literal A or A.  denotes so-called classical negation, as
opposed to not which denotes default negation.

For  an extended program that contains no variables and does not contain
not , let Lit be the set of ground literals in the language of . The answer set
() of  is the smallest subset S of Lit such that
1. for any rule L0  L1, . . . , Lm  , if L1, . . . L2  S, then L0  S, and
2. if S contains a pair of complementary literals, then S = Lit.
For  a (general) extended program and Lit the set of all literals in the
language of , define  S, for a set S  Lit, as the extended program obtained
by deleting, from ,
1. each rule that has some not L in its body with L  S, and
2. all expressions of the form not L in the bodies of the remaining rules.
Finally, S is an answer set of  if S = ( S).

Let (O1,O2, ) be a mapped-tuple. We now define an extended program
(O1,O2, ) as follows. For every axiom of the form C d D   and for all
{a}  C  comp(O1), we add rules of the following form to (O1,O2, ).

C(a) 
D(a)  C(a), not D(a)

(29)
(30)

For mapping axioms of the form R d S  , we add the following rules.

R(a, b) 
S(a, b)  R(a, b), not S(a, b)

(31)
(32)
Furthermore, we add to (O1,O2, ) all possible groundings of the rules obtained
by rewriting comp(O2) as per the rules in Table 2, using all the individuals that
occur in O1,O2.
It should be noted that we do not provide a transformation for axioms of the
form C  R.D in Table 2. This is because for representing defeasible axioms
in logic programs we need the classical negation [10] and to represent axioms
with existentials on the right hand side we require existential rules. Although

K. Sengupta and P. Hitzler

{a}  C
{a}  B

(33)
(34)

C d D
B d E

(35)
(36)

D  E  
D  F
E  F

(37)
(38)
(39)

Fig. 3. Example mapping

a stable model semantics for existential rules has been defined in [17], it is not
defined for extended programs with classical negation. Furthermore, it is not
straightforward to extend the approach from [17] to extended programs. So we
restrict ourselves to showing that our reduction works for the case when axioms
of the form C  R.D are not present. This is sufficient to show that our
approach aligns well with the answer set semantics.

Example 2. Consider the axioms listed in Figure 3 where axioms 33, and 34
are from O1, axioms 37, 38, and 39 are from O2 and the axioms 35, and 36
represent the set  of defeasible mappings. The corresponding extended program
(O1,O2, ) is as follows.

E(a)  D(a)
D(a)  E(a)

F (a)  D(a)
F (a)  E(a)

D(a)  C(a)  not D(a)
E(a)  B(a)  not E(a)

C(a) 
B(a) 
Note there are two answer sets, S1 = {C(a), B(a), D(a),E(a), F (a)} and

S2 = {C(a), B(a), E(a),B(a), F (a)}, for (O1,O2, ).
Definition 10. Let O
2 be a mapped ontology for (O1,O2, ), and let comp(O
2 )
be a corresponding mapped completion. Then we define the mapped answer set
S(O

2 ) to be the following set.
{C(a) | C d D   and {a}  C  comp(O1)} 
{R(a, b) | R d S   and {a}  R.{b}  comp(O1) 
{C(a) | {a}  C  comp(O
{D(a) | C d D  ,{a}  C  comp(O1) and {a}  D  comp(O
{R(a, b) | {a}  R.{b}  comp(O
{S(a, b) | R d S  ,{a}  R.{b}  comp(O1) and {a}  S.{b}  comp(O
2 )}
Lemma 2. Let O
2 be a mapped ontology for (O1,O2, ), and let comp(O
2 ) be
a corresponding mapped completion. Then the mapped answer set S(O
2 ) is an
answer set of (O1,O2, ).

2 )} 

2 )} 

2 )} 

The proofs of this lemma and the next have been omitted due to space

restrictions. They can be found in the appendix of the technical report [22].
Lemma 3. Let (O1,O2, ) be a mapped-tuple and let S be an answer set
of (O1,O2, ) = . Then S = S(O
2 of
(O1,O2, ).

2 ) for some mapped ontology O
?

?

?
The following theorem is a now direct consequence of Lemmas 2 and 3.

Theorem 5. Let (O1,O2, ) be a mapped-tuple. Then (O1,O2, ) |=d {a} 
C if, and only if, (O1,O2, ) |=S C(a), where |=S represents stable model
entailment.

5 Related Work

This work is relevant to at least two areas of work, (1) advancing the use of
non-monotonic logics in description logics, and especially in the EL family, and
(2) providing a robust mapping language.

We introduced the use of defeasible semantics to denote mappings in [23],
but therein we had to impose a rather significant restriction that exceptions to
the default rules may occur only in the known individuals, a restriction which
we could completely lift with the approach and setting described in the earlier
sections of this work. Our approach provides a significant result over [23] because
(1) It is not straight forward to obtain this result, (2) this approach can be
applied to any logic in the EL family without any change in the semantics,
(3) It removes the 20 year old road block in the research area of defaults and
description logics due to the results from [2], and (4) all of the previously known
decidability results of defaults + dl combinations placed a some sort of restriction
on the applicability of defaults to the individuals: [2], [23] where [23] improved the
results from [2] but by placing a different restriction on applicability of defaults
to unknowns. Furthermore, the mapping scenario presented in this paper is also
a practical approach to querying heterogeneous datasets using our approach
towards a mapping language. It is also established in this paper that the approach
here is closer to Reiters semantics than in [23] by showing the similarity with
ASP semantics.

With respect to repairing ontology alignments there are approaches like [1,
16,19]. The work in [19] is specifically close in spirit to our approach, though
we provide a much more detailed semantic treatment which is closely related
to Reiters defaults and answer set programming. Furthermore, we also include
defeasible axioms for roles and obtain a mild tractability result. Our approach
also forms a basis for a mapping language rather than focusing on the repairing
of ontology alignments.

In terms of integration of non-monotonic logics with DLs, recent work [46]
has been proposed in integrating the semantics of rational closure and KLM
style semantics to DLs. These are alternative semantics to defaults and thus
give a different perspective for apply defeasible logic to DLs. A plethora of other
proposals have been made for the integration of non-monotonic logics with DLs,
and we refer the reader to [15] which provides pointers to most of the prominent
relevant work.

Similar in spirit to our approach, though on a different logic, is also [3].

K. Sengupta and P. Hitzler

6 Conclusion
In this paper we provide an extension for the description logic ER,O with
the ability to have defeasible mappings between ontologies. This work should
be easily extendable to other logics in the EL family, provided soundness and
completeness proofs can be obtained for the base logic along similar lines. We
show a reduction from our semantics of defeasible mappings to that of answer
set programming. This shows that the approach outlined here is very close to
the original notion of defaults. Furthermore, the application of defaults is not
limited to named individuals but also applies to unknowns that are implicitly
referred to in the knowledge base due to existentials.

Of course, our resulting logic appears to be no longer tractable. However,
it should be remarked that the application of a monotonic semantics is completely impossible in the context of inconsistencies coming from the mappings,
and repair approaches currently require human intervention and are generally
employed at the level of axioms, rather than individuals. Some form of paraconsistent reasoning [18] may be a more efficient contender, but then paraconsistent
approaches such as [18] tend to miss many desired consequences.

As a part of future work we consider a smart algorithmization for entailment
checking that would perform with reasonable efficiency. One possible approach
would be to find a method to generate rules that act as templates which could
be used to check which selections used to create the mapped ontologies would
lead to inconsistencies without actually running the completion algorithm on
the mapped ontologies. We also plan to implement the algorithm and perform
a detailed evaluation of its performance with respect to time when compared
to the monotonic extensions and also with respect to the quality of entailments
obtained by defeasible mappings compared to traditional alignments produced
by automatic alignment systems. We could make use of data made available by
the ontology alignment evaluation initiative [8,9]. Good results would lead to
a solid framework towards a robust mapping language for tractable ontology
languages.

Acknowledgments. This work was supported by the National Science Foundation under award 1017225 III: Small: TROnTractable Reasoning with Ontologies
and award 1440202 EarthCube Building Blocks: Collaborative Proposal: GeoLink
Leveraging Semantics and Linked Data for Data Sharing and Discovery in the Geo-
sciences. The authors also thank an anonymous reviewer of a previous version of this
paper for detecting a flaw in our initial semantics, which has now been removed.
