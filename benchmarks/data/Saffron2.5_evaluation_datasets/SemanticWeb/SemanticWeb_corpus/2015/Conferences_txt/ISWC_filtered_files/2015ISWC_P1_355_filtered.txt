Rewriting-Based Instance Retrieval for Negated

Concepts in Description Logic Ontologies

Jianfeng Du1(B) and Jeff Z. Pan2

1 Guangdong University of Foreign Studies, Guangzhou 510006, China

2 The University of Aberdeen, Aberdeen AB24 3UE, UK

jfdu@gdufs.edu.cn

Abstract. Instance retrieval computes all instances of a given concept
in a consistent description logic (DL) ontology. Although it is a popular task for ontology reasoning, there is no scalable method for instance
retrieval for negated concepts by now. This paper studies a new approach to instance retrieval for negated concepts based on query rewrit-
ing. A class of DL ontologies called the inconsistency-based first-order
rewritable (IFO-rewritable) class is identified. This class guarantees that
instance retrieval for an atomic negation can be reduced to answering
a disjunction of conjunctive queries (CQs) over the ABox. The IFOrewritable class is more expressive than the first-order rewritable class
which guarantees that answering a CQ is reducible to answering a disjunction of CQs over the ABox regardless of the TBox. Two sufficient
conditions are proposed to detect IFO-rewritable ontologies that are not
first-order rewritable. A rewriting-based method for retrieving instances
of a negated concept is proposed for IFO-rewritable ontologies. Preliminary experimental results on retrieving instances of all atomic negations
show that this method is significantly more efficient than existing methods implemented in state-of-the-art DL systems.

1 Introduction

Description logics (DLs) [2] are popular knowledge representation languages
underpinning the Web Ontology Language (OWL). A DL ontology consists of
a TBox and an ABox, where the TBox describes relations between concepts
and roles, and the ABox describes instances of concepts and roles. DLs enable a
number of tasks for ontology reasoning based on the classical first-order seman-
tics. Among these tasks, instance retrieval is a popular one which computes all
individuals in a consistent DL ontology that are instances of a given concept.

Most studies on instance retrieval focus on atomic concepts, namely concept
names. It is well-known that instance retrieval for atomic concepts is tractable
for those DLs that underpin the three profiles QL, EL and RL of OWL 2, the
newest version of OWL. There have also been optimization and approximation
techniques proposed for instance retrieval in expressive DLs [13,17,21]. However,
to the best of our knowledge, there is seldom any dedicated study on instance
retrieval for negated concepts. A negated concept is of the form C where C is
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 339355, 2015.
DOI: 10.1007/978-3-319-25007-6 20

J. Du and J.Z. Pan

a DL concept without the negation symbol . In the reality, it is often required
to compute instances of a negated concept. For example, one may often raise
questions like the following ones upon a DL ontology describing people in uni-
versities: Who is not an undergraduate? Who does not have a friend who is a
professor? Who does not get a PhD degree from a Chinese university?
According to the semantics of DLs, the set of instances of a negated concept
C cannot be returned as the set of those instances explicitly declared in the
given ontology, nor the complement set of the set of instances of C. A common
sound and complete method for instance retrieval for C is to reduce the problem
to instance retrieval for PC, where PC is a fresh atomic concept, by adding
an axiom C  PC to the TBox. This method is commonly implemented in
state-of-the-art DL systems. However, the added axiom C  PC introduces
concept disjunctions and cannot be expressed in DLs that guarantee tractable
instance retrieval. To guarantee tractability, one may apply another method
which retrieves all instances of C by checking if {C(a)} is consistent with the
given ontology for every individual a in the ontology. However, this method is
hardly scalable for large DL ontologies with many individuals.

Inspired by the successful query rewriting approach to ontology reasoning
(see e.g. [5,7]), we solve the problem of instance retrieval for negated concepts
from a new perspective, i.e., by query rewriting. There are some challenges in
making use of query rewriting. First of all, existing query rewriting methods
are designed for conjunctive queries (CQs) but not for negated concepts. It
requires us to establish a connection between negated concepts and CQs. More
importantly, it is required that the applicable DLs be as expressive as possible.
In this paper we tackle all the above challenges and make the following contributions. Firstly, we identify a class of DL ontologies, called the
inconsistency-based first-order rewritable (IFO-rewritable) class, which guarantees that instance retrieval for an atomic negation is reducible to answering a
disjunction of CQs over the ABox. The class is characterized by an inconsistencyrewritten set of Boolean conjunctive queries (BCQs) whose size is finite and
independent of the ABox. From an inconsistency-rewritten set S of BCQs for an
atomic concept A, we can extract a disjunction of CQs QD(x) in time linear in
the size of S such that the set of instances of A is the set of answers of QD(x)
in the ABox.

Secondly, we show that the IFO-rewritable class is more expressive than the
first-order rewritable class, where the latter is commonly used in query rewriting
and guarantees that answering a CQ is reducible to answering a disjunction of
CQs over the ABox. We propose two sufficient conditions for detecting IFOrewritable ontologies that are not first-order rewritable. One condition relies on
extracting first-order rewritable subsets of the given ontology and can be checked
regardless of the ABox in time polynomial in the size of the TBox. The other
condition is applicable to the DL ELR and can be checked in time polynomial
in the size of the ABox by considering certain subgraphs of the ABox graph.

Finally, we conduct experiments on large first-order rewritable ontologies to
demonstrate the advantages of exploiting inconsistency-rewritten sets of BCQs
?

?

?
to retrieve instances of atomic negations. We compare this proposed method
with the two aforementioned methods for instance retrieval for atomic nega-
tions. Experimental results obtained by several state-of-the-art DL systems show
that the proposed method is significantly more efficient than the two aforementioned methods in retrieving instances of all atomic negations. Moreover,
among all compared methods only the proposed one is scalable for large ontologies with tens of millions of assertions. All proofs are available at http://www.
dataminingcenter.net/rebsir/ISWC15-full.pdf.

2 Preliminaries

We assume that the reader is familiar with DLs [2]. A DL ontology consists of a
TBox and an ABox, where the TBox is a finite set of axioms on relations between
concepts and roles, and the ABox is a finite set of assertions declaring instances
of concepts and roles. In this work we only consider normalized ABoxes. An
ABox is said to be normalized if it consists of basic assertions that are concept
assertions of the form A(a) or role assertions of the form r(a, b), where A is an
atomic concept, r is an atomic role, and a and b are individuals. Other concept
assertions and role assertions can be normalized to basic ones in a standard way.
For a normalized ABox A, let Ind(A) denote the set of individuals appearing A
and Cn(A) the set of atomic concepts appearing in A.
The semantics of DLs coincides with the classical first-order semantics. A
DL ontology O is said to be consistent, denoted by O |= , if it has at least
one model, otherwise inconsistent, denoted by O |= . An ABox A is said to be
consistent with a TBox T if T  A is consistent. An individual a is said to be
an instance of a concept C in O if the concept assertion C(a) is satisfied by all
models of O, denoted by O |= C(a). The problem of instance retrieval for C in
O is to compute the set of instances of C in O.
A conjunctive query (CQ) Q(x) is a formula of the form y (x, y), where
(x, y) is a conjunction of atoms over atomic concepts, atomic roles and the
(in)equality predicate, x are answer variables, and y are quantified variables. A
CQ without answer variables is called a Boolean conjunctive query (BCQ). Here
a BCQ is written and treated as a set of atoms. For example, the BCQ x A(x)
B(x) is written as {A(x), B(x)}. A disjunction of CQs, also called a union of
CQs or a UCQ in the literature, is a formula of the form Q1(x)  . . .  Qn(x)
where n  1 and Q1(x), . . . , Qn(x) are CQs. We say a disjunction of BCQs QD
is entailed by O, denoted by O |= QD, if QD is satisfied by all models of O. A
tuple t of individuals is called an answer to a disjunction of CQs QD(x) in an
ontology O if O |= QD(t), where QD(t) is a disjunction of BCQs obtained from
Q(x) by replacing variables in x with corresponding individuals in t. The set of
answers to QD(x) in O is denoted by ans(O, QD(x)). For a disjunction of BCQs
QD, ans(O, QD) = {} if O |= QD, or ans(O, QD) =  otherwise.
Datalog [4] is highly related to DLs. It extends datalog with existential
rules, which are formulae of the form xy (x, y)  z (x, z), where (x, y)
and (x, z) are conjunctions of atoms (often treated as sets of atoms), and x,

J. Du and J.Z. Pan

y and z are pairwise disjoint sets of variables. The part of R at left-hand side
of  is the body of R, whereas the part of R at right-hand side of  is the
head of R. An existential rule R is called an equality generating dependency
(EGD) if the head of R is of the form x1 = x2 where x1 and x2 are different
variables appearing in the body of R; called a constraint if the head of R is
empty; otherwise, called a tuple generating dependency (TGD). A TGD is said
to be linear if its body contains a single atom; multi-linear if all atoms in its
body have the same variables. A linear TGD is also a multi-linear TGD.
A datalog program is a finite set of existential rules, amounting to the
conjunction of all existential rules in it. Since existential rules are formulae in
first-order logic with equality, a TBox expressed in some DLs can be translated
to a datalog program. It follows that an ontology expressed in some DLs can
be translated to the union of a datalog program and a normalized ABox. We
call such an ontology datalog-translatable. For a datalog-translatable ontology
with TBox T , throughout this paper we use S DT to denote the set of TGDs
translated from T , S CT to denote the set of constraints translated from T , and
S ET to denote the set of EGDs translated from T . Since datalog works with
the unique name assumption, this assumption is also adopted in an arbitrary
datalog-translatable ontology, which means that all individuals appearing in
the ontology are interpreted as different in any model of the ontology.
By |S| we denote the cardinality of a set S. A substitution for a first-order
entity (such as atom, formula, etc.) E is a mapping from variables in E to
individuals or variables; it is ground if it maps variables in E to individuals only.
We recall the notions of first-order rewritability and separability in the context of DLs [4]. A set S D of TGDs is said to be first-order rewritable if, for
every conjunctive query Q(x), there exists a finite disjunction of conjunctive
queries QD(x) such that ans(S D  A, Q(x)) = ans(A, QD(x)) for all ABoxes
A. It has been shown [4] that a set S D of TGDs is first-order rewritable if all
TGDs in S D are multi-linear. A set S E of EGDs is said to be separable from
a set S D of TGDs if the following holds for every ABox A: if there exists an
EGD x (x)  x1 = x2 in S E and a ground substitution  for x such that
S D  A |= (x) and x1 = x2, then there is a ground substitution  for
x such that A |= (x) and x1 = x2; otherwise, S D  S E  A |= Q if and
only if S D  A |= Q for all BCQs Q. It has been shown [4] that deciding if
S D  S C  S E  A |= Q for a first-order rewritable set S D of TGDs, a set S C of
constraints, a set S E of EGDs separable from S D, an ABox A and a BCQ Q is
in AC0 in data complexity, the complexity measured in the size of A only.

3 Rewriting-Based Instance Retrieval

Query rewriting is an efficient and scalable approach to reasoning over ontologies
that are expressed in lightweight DLs and have large ABoxes. The idea is to
rewrite a given CQ into a disjunction of CQs or a datalog program such that
the given CQ can be answering by evaluating the rewriting result over the ABox
only. Query rewriting has been implemented in modern DL systems such as
?

?

?
Rapid [7] and MASTRO [5]. To enable query rewriting for all CQs, we require
that the back-end ontology be first-order rewritable based on the first-order
rewritable class of TGDs. We call a DL ontology O with TBox T first-order
rewritable if it is a datalog-translatable ontology such that S DT is first-order
rewritable, S ET is separable from S DT and S CT can be arbitrary. It has been shown
[4] that most DLs in the DL-Lite family [6], such as DL-LiteX and DL-LiteX,
for X  {F,R,A}, express first-order rewritable ontologies, where DL-LiteR
underpins the QL profile of OWL 2.

Inspired by the exciting progress on query rewriting, we intend to solve the
problem of instance retrieval for negated concepts by exploiting query rewriting.
As mentioned in Section 1, there are challenges in making use of query rewriting,
including the establishment of a bridge from negated concepts to CQs and the
guarantee of the expressivity for applicable DLs. To tackle these challenges, we
start with the study on instance retrieval for atomic negations.
Given a consistent DL ontology O with ABox A and an atomic negation A,
the basic idea for instance retrieval for A in O is to compute a disjunction of
CQs QD(x) such that the set of answers to QD(x) in A amounts to the set of
instances of A in O. To compute QD(x), we first compute a set S of BCQs,
each of which is entailed by A  {A(a)} for some instance a of A in O, and
then construct QD(x) from S. We call the set of BCQs computed in the first
step an inconsistency-rewritten set, which is formally defined below.
Definition 1. Given an atomic concept A and a consistent DL ontology O with
ABox A, a set S of BCQs is called an inconsistency-rewritten set for A in O
S, and for all
if S has a finite size that is independent of the size of A, A |=
S. O is said
individuals a in O, O  {A(a)} |=  if and only if A  {A(a)} |=
to be inconsistency-based first-order rewritable (simply IFO-rewritable) for A,
if there is an inconsistency-rewritten set of BCQs for A in O.

The IFO-rewritable class is characterized by inconsistency-rewritten sets of
BCQs. Note that all BCQs considered in this paper do not contain individuals.
After an inconsistency-rewritten set S of BCQs for A is computed, the set of
instances of A in an IFO-rewritable ontology O for A can be computed as
the set of answers to a disjunction of CQs QD(x) in the ABox A of O, where
QD(x) is extracted from S by separating an atom over A from the other atoms
in every BCQ in S. We introduce some notations to explain this method. Given
a set S of BCQs and an atomic concept A, we call the set of BCQs in S that
contain at least one atom over A the A-projection of S, denoted by S|A. For a
BCQ Q that has some atoms over A, we call a pair A(t), Q for t a variable
an A-bipartition of Q if Q  {A(t)} = Q and A(t)  Q. By bipart(Q, A) we
{Q[t/z] | Q  S|A,
denote the set of A-bipartitions of Q. Let 	S,A(z) =
A(t), Q  bipart(Q, A)}, where Q[t/z] denotes the CQ obtained from Q by
renaming t to z, and z does not occur in S and is the unique answer variable in
Q[t/z]. The following theorem shows a method for extracting a disjunction of
CQs from an inconsistency-rewritten set of BCQs.

J. Du and J.Z. Pan

Theorem 1. Let A be an atomic concept, O an IFO-rewritable ontology for A
with TBox T and ABox A, and S an inconsistency-rewritten set of BCQs for A
in O. Then the set of instances of A in O is ans(A, 	S,A(z)).

Note that the disjunction of CQs computed by the above method is independent of the size of the ABox. It follows that checking an instance of a given atomic
negation in an IFO-rewritable ontology can be done in AC0 in data complexity.

Example 1. This example illustrates how to retrieve instances of an atomic negation A in an IFO-rewritable ontology for A after an inconsistency-rewritten set
of BCQs for A is computed. Let O be a consistent DL ontology with TBox T
and ABox A. The TBox T consists of the following three axioms.
Husband  marries.Woman  1 marries. marries.Woman  Woman
The ABox A consists of the following four assertions.

Woman(Ann)

marries(Aba, Bob)

marries(Tom, Ann)
Woman(Aba)
Consider computing all instances of Woman in O. By Definition 1 it can
be checked that S = {Q1, Q2, Q3} is an inconsistency-rewritten set of BCQs
for Woman in O, where Q1 = {marries(x, y), Woman(y), Woman(x)}, Q2 =
{Husband(x), Woman(x)}, and Q3 = {marries(x, y1), marries(x, y2), y1 = y2}.
We have S|Woman = {Q1, Q2}. The disjunction of CQs extracted from S|Woman is
	S,Woman(z) = (y marries(z, y)  Woman(y))  (x marries(x, z)  Woman(x)) 
Husband(z). The set of answers to 	S,Woman(z) in A is S = {Tom, Bob}, which
is the set of instances of Woman in O by Theorem 1.

By (R) we denote the BCQ x (x) if R is a constraint x (x) , or the
BCQ x (x)  x1 = x2 if R is an EGD x (x)  x1 = x2. For a first-order
rewritable set S of TGDs and a BCQ Q, by (Q,S) we denote a set SQ of
SQ for all ABoxes A. The
BCQs such that S  A |= Q if and only if A |=
following theorem shows that a consistent first-order rewritable ontology is an
IFO-rewritable ontology for an arbitrary atomic concept in the ontology.
Theorem 2. Let O be a consistent first-order rewritable ontology with TBox T .
{((R),S DT ) | R  S CT }{(R) | R  S ET } is an inconsistency-rewritten
Then
set of BCQs for an arbitrary atomic concept in O.
Example 2. This example illustrates how to compute an inconsistency-rewritten
set of BCQs from the ontology O given in Example 1, which is also a first-order
rewritable ontology. According to Theorem 2, we first translate T to the union
of a set S DT of TGDs, a set S CT of constraints and a set S ET of EGDs, where

S DT = {x Husband(x)  y marries(x, y)  Woman(y)},
S CT = {x, y marries(x, y)  Woman(y)  Woman(x) },
S ET = {x, y1, y2 marries(x, y1)  marries(x, y2)  y1 = y2}.
?

?

?
S DT contains a linear TGD and is first-order rewritable. S ET is separable from S DT .
Now, we compute ((R),S DT ) for all R  S CT by a query rewriting method such
as the one implemented in Rapid [7], yielding Q1 = {marries(x, y), Woman(y),
Woman(x)} and Q2 = {Husband(x), Woman(x)}. We compute (R) for all R 
S ET , yielding Q3 = {marries(x, y1), marries(x, y2), y1 = y2}. Eventually, we obtain
an inconsistency-rewritten set of BCQs for an arbitrary atomic concept in O,
which is S = {Q1, Q2, Q3}.

The expressivity of the IFO-rewritable class is actually higher than that of the
first-order rewritable class. In the following, we present two sufficient conditions
for detecting IFO-rewritable ontologies that are not first-order rewritable.
A Condition Based on Reachability from Constraints and EGDs. To
facilitate finding inconsistency-responsible subsets of a consistent DL ontology
O, we restrict O to be a datalog-translatable ontology. In such an ontology, the
inconsistencies are caused by constraints or EGDs translated from the TBox and
inconsistency-responsible subsets of the TBox can be found by backward traversal from constraints or EGDs. To explain the method for backward traversal
from constraints or EGDs, we introduce the notion of triggering below.
Definition 2. Given a set S of TGDs, we say a predicate P triggers another
predicate P  in S if either there is a TGD R  S such that P appears in the body
of R and P  appears in the head of R, or there exists a predicate P  such that
P triggers P  and P  triggers P  in S. Moreover, we say a predicate P triggers
a constraint or an EGD R in S if P triggers at least one predicate appearing in
the body of R in S; we say a TGD R  S triggers a constraint or an EGD R
in S if there is a predicate appearing in the head of R triggers R in S.

For a constraint or an EGD R and a set S of TGDs, by trg(R,S) we denote the
set of TGDs in S that trigger R in S. Then trg(R,S) is essentially the unique
maximal subset of S that can be backward traversed from R. By considering
trg(R,S) for all constraints or EGDs R rather than the original TBox, we can
obtain a condition for detecting IFO-rewritable ontologies that are not first-order
rewritable. The following theorem shows this condition and the corresponding
method for computing an inconsistency-rewritten set of BCQs, where pred(S)
denotes the set of predicates appearing in a set S of existential rules.
Theorem 3. Let O be a consistent datalog-translatable ontology with TBox T ,
and A an atomic concept in O. If for all R  S CT , A  pred(trg(R,S DT ){R}) or
trg(R,S DT ) is first-order rewritable, and for all R  S ET , A  pred(trg(R,S DT ) 
{((R), trg(R,S DT )) | R 
{R}) or {R} is separable from trg(R,S DT ), then
S CT , A  pred(trg(R,S DT ))}  {(R) | R  S ET , A  pred(trg(R,S DT ))} is an
inconsistency-rewritten set of BCQs for A in O.

The condition given in the above theorem can be checked regardless of the
ABox in time polynomial in the size of the TBox, because computing trg(R,S DT )
can be done in time polynomial in the size of S DT for every constraint or EGD
R. The following example shows a datalog-translatable ontology that satisfies
this condition for some atomic concept but is not first-order rewritable.

J. Du and J.Z. Pan

Example 3. Let O be a consistent datalog-translatable ontology whose TBox
T consists of the following three axioms.

r.A  A

A  B  

B  C  

Consider computing an inconsistency-rewritten set of BCQs for C in O by the
method in Theorem 3. We first translate T to the union of a set S DT of TGDs, a
set S CT of constraints and a set S ET of EGDs, where S DT = {x, y r(x, y) A(y) 
A(x)}, S CT = {R1 : x A(x)  B(x) , R2 : x B(x)  C(x) }, and S ET = .
Since the CQ A(x) cannot be rewritten to a finite disjunction of CQs QD(x) such
that ans(S DT  A, A(x)) = ans(S, QD(x)) for all ABoxes A, S DT is not first-order
rewritable, and nor is O. But we can show that O is IFO-rewritable for C. Since
trg(R1,S DT ) = S DT and trg(R2,S DT ) = , we have C  pred(trg(R1,S DT )  {R1})
and C  pred(trg(R2,S DT )  {R2}). Moreover, since trg(R2,S DT ) is empty, it is
clearly first-order rewritable. Hence an inconsistency-rewritten set of BCQs for
C in O is ((R2), trg(R2,S DT )) = {(R2)}, where (R2) = {B(x), C(x)}.
A Condition Based on Rooted Subgraphs of the ABox Graph. Let O
be a consistent DL ontology with TBox T and ABox A, and A an atomic concept.
Another condition for guaranteeing the existence of an inconsistency-rewritten
set of BCQs for A in O is that, there is a set S of small subsets of A such that the
number of assertions in any S  S is not greater than a given threshold n and
every instance a of A in O is also an instance of A in T  S for some S  S.
The validness of this condition can be shown as follows. Let SA = {Sa{A(a)} |
O |= A(a)} where Sa is an element in S such that T  Sa |= A(a), then
SA, and for all individuals a in O, O  {A(a)} |=  if and only if
A |=
SA. By lift(S) we denote the set of atoms obtained from a set S
A{A(a)} |=
of assertions by replacing different individuals in S with different variables. Let
A = {lift(S) | S  SA}, then the size of S
A is independent of the size of A and
S
at most polynomial in the size of T with an exponent not greater than n+1. If
T  S |=  implies T  lift(S)  |=  for all ground substitutions  for lift(S), S
will be an inconsistency-rewritten set of BCQs for A.
To satisfy the above condition as possible, we restrict O to be an ELR
ontology made up of an ELR TBox and a normalized ABox. An ELR TBox
consists of role inclusions of the form r1  . . .  rk  s and concept inclusions
of the form C  D, where k  1, r1, . . . , rk, s are atomic roles, and C and D
are EL concepts recursively constructed by , , atomic concepts, existential
restrictions s.C and concept conjunctions C  D. The above condition requires
computing small ABox subsets preserving instances of A in the ontology. In an
ELR ontology, these ABox subsets can be treated as maximal rooted subgraphs
of the ABox graph. Before showing this result, we formally provide the related
notions below.
Definition 3. The ABox graph of a normalized ABox A, denoted by G(A), is
a graph G = (V, E, L) where V = Ind(A) is a set of vertexes, E = {(a, b, r) |
r(a, b)  A} is a set of labeled edges, and L: Ind(A)  2Cn(A) is a label function
such that L(a) = {A | A(a)  A} for all a  V . We say a graph G = (V , E, L)
?

?

?
is a subgraph of G = (V, E, L), wirtten G  G, if V   V , E  E and for all
a  V , L(a)  L(a). We say an individual a has a path to another individual
b in G = (V, E, L), if there is a sequence of labeled edges (a, a1, r0), (a1, a2, r1),
. . . , (an, b, rn) in E. A root a of a graph G = (V, E, L) is an individual in V
such that for all individuals b other than a in V , a has a path to b in G. A rooted
subgraph G of G is a subgraph of G that has at least one root; it is maximal if
there is no rooted subgraph G of G such that G  G and G  G.

Every normalized ABox has a one-to-one mapping to its ABox graph. By
G(G) we denote the unique ABox mapped from an ABox graph G = (V, E, L),
i.e., G(G) = {A(a) | a  V, A  L(a)}  {r(a, b) | (a, b, v)  E}.
Example 4. Suppose an ABox A consists of the following 5+m assertions.
r(cm, b)

r(a2, b) A(b)

r(a2, a1)

r(a1, a2)

r(a1, b)

r(c1, b)

. . .

The ABox graph G(A) of A is shown below. We can see that G({r(a1, a2),
r(a2, a1), r(a1, b), r(a2, b), A(b)}) is a maximal rooted subgraph of G(A) which
has two roots a1 and a2; moreover, for all 1  i  m, G({r(ci, b), A(b)}) is also
a maximal rooted subgraph of G(A) with the unique root ci.

L(a1) = 

a1

c1

L(ci) =  for all 1  i  m

r

r

========

r

r

/ b

								

r

cm

r

L(a2) = 

a2

L(b) = {A}

In general, all maximal rooted subgraphs of an ABox graph can be retrieved
in time polynomial in the size of the ABox, by first identifying all roots of
maximal rooted subgraphs and then computing all full subgraphs led by these
roots. A full subgraph of G = (V, E, L) led by an individual a is a subgraph
G = (V , E, L) of G such that V  = {a}  {b | a has a path to b in G}, E =
{(b, c, r)  E | b  V , c  V } and L(b) = L(b) for all b  V . There is a unique
full subgraph led by a certain individual. The roots of maximal rooted subgraphs
are identified as those individuals a having paths to any individual that has
paths to a in the ABox graph. The maximal rooted subgraph in which a is a
root can be defined as the full subgraph led by a. The following theorem shows
the correctness of this method for computing all maximal rooted subgraphs.
Theorem 4. Let G = (V, E, L) be an ABox graph and a an individual in V .
Then (1) if a is a root of some maximal rooted subgraph of G, then a has paths
to any individual that has paths to a in G; (2) if a has paths to any individual
that has paths to a in G, then the full subgraph of G led by a is a maximal rooted
subgraph of G in which a is a root.

The following lemma shows that the required set of ABox subsets that preserves all instances of A in an ELR ontology can be defined as the set of
G(G) for G a maximal rooted subgraph of the ABox graph.





?

?

?
/
o
o
?

?

?
Algorithm. ComputeInconsistencyRewrittenSet(T , A, A)
Input: An ELR ontology with TBox T and ABox A, and an atomic concept A.
Output: An inconsistency-rewritten set of BCQs for A in T  A.
1: SQ  ;
2: for each G in NonIsomorphicMRS(G(A)) and each individual a in G do
?

?

?
3:
(G)  {A(a)} then
Q  G

if T  G
?

?

?
4:
 Q  lift(G
?

?

?
5:
?

?

?
6:
?

?

?
7:
 SQ  SQ  {Q};

8:
9: return SQ;

if A(a)  A and there is no Q  SQ and ground substitution  for Q such that
?

?

?
for each Q  SQ such that Q  Q

 SQ  SQ \ {Q};

(G) |= A(a) then

(G)  {A(a)}); // replace diff. individuals with diff. variables

for some substitution  for Q do

Fig. 1. The algorithm for computing an inconsistency-rewritten set of BCQs

Lemma 1. Given an atomic concept A and a consistent ELR ontology O with
TBox T and ABox A, if a is an instance of A in O, then there is a maximal
rooted subgraph G of G(A) such that T  G(G) |= A(a).

By the above lemma, we can use an integer threshold n to determine (in
PTime in data complexity) if a consistent ELR ontology has an inconsistencyrewritten set of BCQs for an arbitrary atomic concept. That is, if the number
of assertions in any maximal rooted subgraph of the ABox graph is not greater
than n, then we can find an inconsistency-rewritten set of BCQs for a given
atomic concept by the algorithm shown in Fig. 1.
The resulting set SQ of the algorithm ComputeInconsistencyRewrittenSet(
T , A, A) only keeps the most general BCQs, where a set of atoms (or BCQ)
Q is said to be more general than another set of atoms (or BCQ) Q if there
is a substitution  for Q such that Q  Q. To avoid generating equivalent
BCQs up to renaming of variables, the algorithm only handles non-isomorphic
subgraphs of G(A), where two subgraphs G1 and G2 are said to be isomorphic if lift(G(G1)) and lift(G(G2)) are equivalent up to renaming of variables.
In the algorithm, NonIsomorphicMRS(G(A)) denotes the set of non-isomorphic
maximal rooted subgraphs of G(A), i.e., any two subgraphs in this set are not
isomorphic. The cardinality of this set is at most polynomial in the size of T
with an exponent not greater than n. The algorithm handles all subgraphs G
in NonIsomorphicMRS(G(A)) and all individuals a in G to construct SQ. In case
A(a)  A, since T A is consistent and G(G){A(a)}  A, T G(G){A(a)}
is also consistent, i.e., T  G(G) |= A(a). In case there is some Q  SQ that
is more general than G(G)  {A(a)}, since no individual occurs in Q, the BCQ
lift(G(G)  {A(a)}) is less general than Q and thus is not added to SQ. In
other cases (lines 48), if and only if T  G(G) |= A(a), all BCQs that are
less general than lift(G(G){A(a)}) are removed from SQ, making SQ contain
only the most general BCQs; moreover, lift(G(G)  {A(a)}) is added to SQ.
?

?

?
The algorithm first computes NonIsomorphicMRS(G(A)) regardless of T in
time polynomial in the size of A, and then computes SQ from NonIsomorphic-
MRS(G(A)) regardless of A in time polynomial in the size of T . The correctness
follows from Lemma 1 and the following lemma, as shown in Theorem 5.
Lemma 2. For an ELR TBox T and a set S of assertions such that T  S is
inconsistent, T  lift(S)  is inconsistent for all ground substitutions  for lift(S).
Theorem 5. Given an atomic concept A and a consistent ELR ontology O
with TBox T and ABox A, ComputeInconsistencyRewrittenSet(T , A, A)
returns an inconsistency-rewritten set SQ of BCQs for A in O, when |G(G)| is
not greater than a fixed constant n for all maximal rooted subgraphs G of G(A).
Example 5. Consider the ontology O given by Example 3 where its ABox A is
given by Example 4. O is a consistent ELR ontology, but it is not first-order
rewritable. Suppose the threshold n is 5. We show that there is an inconsistencyrewritten set of BCQs for B in O. The maximal rooted subgraphs of G(A) given
in Example 4 are G0, G1, . . . , Gm, where G(G0) = {r(a1, a2), r(a2, a1), r(a1, b),
r(a2, b), A(b)} and G(Gi) = {r(ci, b), A(b)} for all 1  i  m. Since |G(Gi)| 
n for all 0  i  m, we call ComputeInconsistencyRewrittenSet(T , A, B).
Initially, we have NonIsomorphicMRS(G(A)) = {G0, G1} and set SQ = . For
G(G0) and a1, since B(a1)  A, SQ =  and T  G(G0) |= B(a1), we add
Q1 = {r(x, y), r(y, x), r(x, z), r(y, z), A(z), B(x)} to SQ. For G(G0) and a2,
since Q1  {x/a2, y/a1, z/b} = G(G0)  {B(a2)}, a2 is not handled. For G(G0)
and b, since B(a1)  A, T  G(G0) |= B(b) and Q1 is not more general than
G(G0)  {B(b)}, we add Q2 = {r(x, y), r(y, x), r(x, z), r(y, z), A(z), B(z)} to
SQ. For G(G1) and c1, since B(c1)  A and T  G(G1) |= B(c1), we add
Q3 = {r(x, y), A(y), B(x)} to SQ; moreover, since Q3 is more general than Q1, we
remove Q1 from SQ. For G(G1) and b, since B(b)  A and T G(G1) |= B(b),
we add Q4 = {r(x, y), A(y), B(y)} to SQ; moreover, since Q4 is more general
than Q2, we remove Q2 from SQ. Finally we get SQ = {Q3, Q4}, which is an
inconsistency-rewritten set of BCQs for B in O.

The DL ELR is a core of the EL profile of OWL 2, roughly corresponding to this profile without range restrictions and nominals. However, extending the algorithm in Fig. 1 to deal with range restrictions or nominals is hard
or even impossible. On the one hand, applying the algorithm to ELR plus
range restrictions or inverse roles is incorrect since Lemma 1 does not hold. For
example, consider a consistent ontology O with TBox T = {r.A  B  ,
s.  A} and ABox A = {r(a, b), s(c, b)}, where s.  A says that the
range of s is A. It can be seen that a is an instance of B in O, but it is not an
instance of B in either T  G(G1) or T  G(G2), where G1 = G({r(a, b)})
and G2 = G({s(c, b)}) are the two maximal rooted subgraphs of G(A). To handle range restrictions or inverse roles, we need to consider maximal connected
components of G(A) in which all edges are treated as undirected, but the sizes
of these components can easily be greater than a given threshold. On the other
hand, applying the algorithm to ELR plus nominals is incorrect since Lemma 2

J. Du and J.Z. Pan

does not hold. For example, consider a TBox T = {r.{b}  } and a set of
assertions S = {r(a, b)}. It can be seen that T  S is inconsistent, but since
lift(S) = {r(x, y)}, T  lift(S)  = T  {r(a, a)} is consistent for  = {x/a, y/a}.
To extend the algorithm to handle nominals, we need to keep individuals in the
resulting set of BCQs. But then it is hard to guarantee that the resulting set is
an inconsistency-rewritten set since its size may depend on the size of the ABox.
Handling General Negated Concepts. The proposed method for instance
retrieval for atomic negations can be extended to handle general negated concepts C. It can be seen that the set of instances of C in a DL ontology O
amounts to the set of instances of PC in O  {PC  C}, where PC is a fresh
atomic concept not in O. Therefore, the proposed method still works for retrieving instances of C as long as O  {PC  C} is an IFO-rewritable ontology for
PC.

4 Experimental Evaluation

The goal of our preliminary experiments is to verify if the proposed method
is significantly more efficient and scalable than existing methods in retrieving
instances of all atomic negations. We focused on first-order rewritable ontologies
and implemented the method in JAVA (based on Theorems 1&2), using the
query-rewriting system Rapid [7] to compute inconsistency-rewritten sets and
using the database system MySQL to store and access ABoxes. We call the
implemented system REwriting-Based System for Instance Retrieval (REBSIR).
We collected two groups of ontologies, where one group was from the Lehigh
University Benchmark (LUBM) [11] and the other from DBPedia (version 2014)1
[3]. Since Rapid cannot handle axioms about concrete roles (i.e. datatype prop-
erties), we removed axioms about concrete roles from both the LUBM TBox
and the DBPedia TBox, rendering them first-order rewritable. In addition, since
there is no constraint translated from the LUBM TBox and none of the atomic
negations has instances in LUBM ontologies, we added disjointness axioms to
the LUBM TBox for every two sibling atomic concepts in the concept hierarchy
such that they have no common instances in any original LUBM ontology. At last
we obtained five consistent ontologies named LUBMdn (n = 1, 5, 10, 50, 100) for
the first group, where n is the number of universities. For the second group, we
dumped basic assertions about atomic concepts and abstract roles (i.e. object
properties) in the DBPedia TBox from DBPedia-as-Tables2 to construct the
ABox. Since the downloaded DBPedia TBox and DBPedia-as-Tables were generated separately, our constructed ABox was inconsistent with the TBox. To
restore consistency, we first computed all minimal conflicts (i.e. minimal subsets
of the ABox that are inconsistent with the TBox) by using the rewriting-based
method proposed in [8], then removed from the ABox a small hitting set S for the
set of minimal conflicts. S was iteratively computed by, in each iteration, adding

1 http://downloads.dbpedia.org/2014/dbpedia 2014.owl.bz2
2 http://web.informatik.uni-mannheim.de/DBpediaAsTables/
?

?

?
Table 1. The statistics about test ontologies

Ontology

#C #R #TA

#AA

#I

LUBMd1LUBMd100

158 100,54313,824,437
DBPedia1%DBPedia100% 811 1,309 3,679 141,03914,164,192

17,1742,179,766
116,6833,695,525

Note: #C/#R/#TA/#AA/#I is the number of atomic concepts/abstract roles/
TBox axioms/ABox assertions/individuals.

Table 2. The number of timeout cases (* for running out of memory)

System LUBMd1 LUBMd5 LUBMd10 DBPedia1% DBPedia5% DBPedia10%

FaCT++
KAON2

Pellet
HermiT
?

?

?
*811

to S an assertion that locates in the most minimal conflicts without any element in S. Finally, we kept n% of assertions in the modified ABox and obtained
five consistent ontologies named DBPedian%, where n = 1, 5, 10, 50, 100. The
statistics about all test ontologies are summarized in Table 1.3
We first compared the proposed method with the common method implemented in most state-of-the-art DL systems. For every atomic negation A, the
common method first adds a new axiom A  PA to the TBox and then retrieves
instances of PA, where PA is a fresh atomic concept. Since the performance of
the common method may vary with different DL systems, we compared REBSIR with FaCT++ (version 1.6.3) [19], KAON2 (version 2008-06-29) [14], Pellet
(version 2.3.1) [18] and HermiT (version 1.3.8) [9]. We set a time limit of five
minutes for retrieving instances of a single atomic negation. All experiments
were conducted on a laptop with Intel Dual-Core 2.60GHz CPU and 8GB RAM,
running Windows 7 with the maximum Java heap size set to 8GB.

For the LUBMd (resp. DBPedia) TBox, REBSIR computes an inconsistencyrewritten set made up of 3,178 (resp. 865,437) BCQs in 200 milliseconds (resp.
65 seconds). This computation is done once before retrieving instances of any
atomic negation in a test ontology.

All compared systems except REBSIR run out of memory for LUBMd50,
LUBMd100, DBPedia50% and DBPedia100%, and sometimes exceed the time
limit of five minutes for other ontologies. Table 2 reports the number of timeout cases. REBSIR has no timeout cases, thus it does not appear in the table.
Figure 2 shows the comparison results on the average execution time (in mil-
liseconds) for retrieving instances of an atomic negation. The displayed execution time for REBSIR includes the equally shared time for computing the
inconsistency-rewritten set, while the execution time for other systems excludes

3 All test ontologies and compared systems including REBSIR and others are available

at http://www.dataminingcenter.net/rebsir/.

J. Du and J.Z. Pan

Note: Ln and Dn are respectively short for LUBMdn and DBPedian%. The average
execution time is not shown if the system runs out of memory in a test ontology.

Fig. 2. The average execution time for retrieving instances of an atomic negation

the time for loading the test ontology. Moreover, for all compared systems except
FaCT++, the execution time in a timeout case is approximated as five minutes
since these systems are forced to stop handling the current atomic negation and
start handling the next atomic negation once timeout occurs.

As can be seen in Fig. 2, FaCT++ works much better on DBPedian% than
on LUBMdn. Pellet also works better on DBPedian% than on LUBMdn, except
that for DBPedia10% it runs out of memory. KAON2 works much better on
LUBMdn than on DBPedian%, possibly because the resolution-based method
used in KAON2 works worse with more axioms in the TBox. HermiT works
sightly better on LUBMdn than on DBPedian%. It cannot finish within the time
limit for any atomic negation in any DBPedia ontology. Our system REBSIR
is the best among all compared systems. It is significantly more efficient than
other compared systems and scales to tens of millions of assertions. In particular,
it only spends one minute or so on average to retrieve instances of an atomic
negation in the two largest ontologies that have more than ten million assertions.
We also compared the proposed method with the consistency checking (CC-)
based method under the same test environment. For retrieving instances of an
atomic negation A in a consistent ontology O, the CC-based method retrieves
the set S of instances of A in O, and then for every individual a occurring in
O but not in S, checks if O  {A(a)} |=  to determine instances of A in
O. We implemented the CC-based method in the state-of-the-art DL system
ELK (version 0.4.1) [15], which is highly optimized for DLs in the EL family
[1]. We removed axioms that are not supported by ELK from LUBMdn and
kept DBPedian% intact. In this experiment, REBSIR has a similar performance
on the modified test ontologies, but ELK (with the default four workers) cannot
finish retrieving instances of any atomic negation in any test ontology within the
time limit. Although ELK is highly efficient in performing a consistency check,
it fails to perform tens of thousands of consistency checks within the time limit
and is impractical for instance retrieval for negated concepts.
?

?

?
5 Related Work

In DL systems, instance retrieval for a concept C is often reduced to instance
retrieval for an atomic concept PC by adding C  PC to the TBox and then
solved by certain reasoning methods. Tableau-based methods [2] are common
reasoning methods implemented in state-of-the-art DL systems such as FaCT++
[19], Pellet [18] and HermiT [9]. In [13] existing optimization techniques are
summarized and some new optimization techniques are proposed for instance
retrieval inside tableau-based methods. In [21] a filter-and-refine paradigm is
proposed for optimizing instance retrieval
inside tableau-based methods. It
first computes obvious non-instances and obvious instances and then performs
instance checking for remaining candidate instances. We do not explicitly compare the above optimization techniques with our proposed method because these
techniques have at least partially been implemented in most DL systems. For
reasoning in expressive DLs, resolution-based methods [14] are another popular paradigm, implemented in a modern DL system KAON2. Our experimental
results have shown that our proposed method is more efficient and scalable than
both tableau-based and resolution-based methods in retrieving instances of all
atomic negations.

Instance retrieval is also related to conjunctive query answering (CQA).
There are three efficient approaches to CQA. The first approach is query rewrit-
ing, which has been adapted in this work. The second approach is materializa-
tion, implemented in scalable DL systems such as WebPIE [20]. It computes
an ABox completion containing all ABox consequences wrt the TBox so that
subsequent reasoning can be performed in the ABox completion only. The last
approach (see e.g. [16]) is a combination of query rewriting and materialization,
which first approximates an ABox completion, then rewrites the given query
to another one so as to filter out incorrect answers. Except for a query rewriting method proposed in [10], all the above approaches are only applicable to
Horn fragments of DLs and cannot be applied to instance retrieval for negated
concepts due to the necessity of adding non-Horn features (i.e. concept disjunc-
tions) to the given ontology. The method proposed in [10], however, involves a
rather complicated step for transforming disjunctive datalog to datalog and has
no evaluation result by now. Recently, a hybrid approach to CQA is proposed in
[22]. It first computes a lower bound and an upper bound of the set of answers,
then computes answers between the two bounds. Similarly, it needs to add nonHorn features to the ontology before applied to instance retrieval for negated
concept, making the complexity beyond PTime in data complexity. In [12] the
CQA problem extended by negative atoms is studied for two simple DLs in the
DL-Lite family. However, the study [12] focuses on the computational complexity
and does not provide practical solutions to the extended CQA problem.

J. Du and J.Z. Pan

6 Conclusion and Future Work

In this paper we have studied a new approach to instance retrieval for negated
concepts based on query rewriting. We identified the class of IFO-rewritable
ontologies which guarantees that instance retrieval for an atomic negation can
be reduced to answering a disjunction of CQs over the ABox. To show that
the IFO-rewritable class is more expressive than the first-order rewritable class,
we presented two sufficient conditions for detecting IFO-rewritable ontologies
that are not first-order rewritable. An IFO-rewritable ontology O for an atomic
concept A is characterized by an inconsistency-rewritten set of BCQs for A,
which witnesses the inconsistency of O  {A(a)} for all instances a of A in O.
We empirically showed that using inconsistency-rewritten sets makes instance
retrieval for all atomic negations more efficient and scalable than existing meth-
ods.

For future work, we plan to conduct extensive experiments on more IFOrewritable ontologies. Moreover, we plan to develop incremental methods for
computing inconsistency-rewritten sets. Finally, we intend to discover more sufficient conditions for detecting IFO-rewritable ontologies. In particular, we plan
to relax the second sufficient condition from ELR to more expressive DLs by
considering concept disjunctions and cardinality restrictions.

Acknowledgments. This work is partly supported by NSFC (61375056), Guangdong Natural Science Foundation (S2013010012928) and the EC MSC K-Drive project
(286348).
