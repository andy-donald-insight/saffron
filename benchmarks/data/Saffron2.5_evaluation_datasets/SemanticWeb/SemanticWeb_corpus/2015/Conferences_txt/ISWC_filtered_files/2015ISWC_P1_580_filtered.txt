Next Step for NoHR: OWL 2 QL

Nuno Costa, Matthias Knorr(B), and Jo ao Leite

NOVA LINCS, Departamento de Inform atica, Faculdade de Ciencias E Tecnologia,

Universidade Nova de Lisboa, Caparica, Portugal

mkn@fct.unl.pt

Abstract. The Prot eg e plug-in NoHR allows the user to combine an
OWL 2 EL ontology with a set of non-monotonic (logic programming)
rules  suitable, e.g., to express defaults and exceptions  and query the
combined knowledge base (KB). The formal approach realized in NoHR
is polynomial (w.r.t. data complexity) and it has been shown that even
very large health care ontologies, such as SNOMED CT, can be han-
dled. As each of the tractable OWL profiles is motivated by different
application cases, extending the tool to the other profiles is of particular
interest, also because these preserve the polynomial data complexity of
the combined formalism. Yet, a straightforward adaptation of the existing approach to OWL 2 QL turns out to not be viable. In this paper, we
provide the non-trivial solution for the extension of NoHR to OWL 2 QL
by directly translating the ontology into rules without any prior classi-
fication. We have implemented our approach and our evaluation shows
encouraging results.

1 Introduction

NoHR1 is a plug-in for the ontology editor Prot eg e2 that allows its users to query
combinations of EL+ ontologies and non-monotonic rules in a top-down manner.
Its motivation stems from the fact that many ontologies, such as the very
large health care ontologies widely used in the area of medicine, e.g., SNOMED
CT,3 are expressed in OWL 2 EL, one of the OWL 2 profiles [24], and its underlying description logic (DL) EL++ [4]. Yet, due to their monotonic semantics,
i.e., previously drawn conclusions persist when new additional information is
adopted, DL-based ontology languages [3] are not suitable to model defaults
and exceptions with a closed-world view, a frequently requested feature, e.g.,
when matching patient records to clinical trial criteria [26].

Among the plethora of approaches for extending DLs with non-monotonic
features and deal with this problem (c.f. related work in [9,25]), NoHR builds on
(Hybrid) MKNF KBs [25], which are based on the logic of minimal knowledge
and negation as failure (MKNF) [23], under their well-founded semantics [18],

1 http://centria.di.fct.unl.pt/nohr/
2 http://protege.stanford.edu
3 http://www.ihtsdo.org/snomed-ct/

c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 569586, 2015.
DOI: 10.1007/978-3-319-25007-6 33

N. Costa et al.

a formalism that combines DLs and non-monotonic rules as known from Logic
Programming.

This choice is motivated, on the one hand, by the fact that non-monotonic
logic programming rules are one of the most well-studied formalisms that admit
expressing defaults, exceptions, and also integrity constraints in a declarative
way, and are part of RIF [17], the other expressive language for the Semantic Web
whose standardization is driven by the W3C.4 On the other hand, MKNF KBs
provide a very general and flexible framework for combining DL ontologies and
non-monotonic rules (see [25]). In addition, [18], which is a variant of [25] based
on the well-founded semantics [10] for logic programs, has a (lower) polynomial
data complexity and is amenable for applying top-down query procedures, such
as SLG(O) [1], to answer queries based only on the information relevant for the
query, i.e., without computing the entire model.

NoHR is thus applicable to combinations of non-monotonic rules and OWL
2 EL ontologies. However, other applications (see, e.g., [6,27]) require ontologies
using DL constructors which are not covered by OWL 2 EL, such as concept
and role negation or role inverses  adding these to OWL 2 EL would raise its
polynomial complexity [4].

OWL 2 QL and the DL-Lite family [2,5] to which the DL underneath OWL
2 QL belongs, DL-LiteR, is suitable in these cases and has recently drawn a lot
of attention in research and in applications. Even though a simple language at
first glance, it is expressive enough to capture basic ontology languages, conceptual data models, e.g., Entity-Relationship, and object-oriented formalisms, e.g.,
basic UML class diagrams. Reasoning focuses on answering queries by rewriting
the initial query, with the help of the ontology, into a set of queries that can
be answered using an industry-strength SQL engine over the data. This yields
that query answering in OWL 2 QL is in LOGSPACE (more precisely AC0), but
also links directly to applications in ontology-based data access (OBDA) [6,20].
Altogether, OWL 2 QL is naturally tailored towards huge datasets.

To also provide such OWL 2 QL based applications with the additional expressive power obtained from combining DL ontologies with non-monotonic rules, in
this paper, we extend NoHR to deal with the OWL 2 QL profile. Whereas, at
first sight, this could seem like a routine exercise, to the best of our knowledge,
there is currently no dedicated open-source OWL 2 QL classifier with OWL API
available that also classifies negative concepts (similar to the NI-closure in [5],
but whose direct adaptation would potentially introduce a huge number of additional axioms). Thus, since we cannot simply replace the reasoner ELK [16], used
currently in NoHR for EL, with a correspondent for DL-LiteR, we translate the
ontology directly into rules. This introduces some non-trivial problems such as the
need to capture unsatisfiable concepts and roles, and irreflexive roles (covered in
[5] also by the NI-closure). We solve this problem by introducing an extension of
the graph, used e.g., for classification in OWL QL [22], to negative axioms, which
is already a contribution in its own right. The resulting translation is implemented
as a module of NoHR, and its performance evaluated. Our main contributions are:

4 http://www.w3.org
?

?

?
 A procedure for translating DL-LiteR ontologies into rules which allows
answering queries over MKNF KBs combining such ontologies and nonmonotonic rules;

 A substantial extension of the Prot eg e plug-in NoHR to include OWL 2 QL
ontologies, beyond DL-LiteR via normalizations, including optimizations on
the number of created rules and the use of tabling in the top-down query
engine XSB;5

 An evaluation of our extension that shows that NoHR for OWL 2 QL maintains all positive evaluation results of the OWL 2 EL version [13], and is even
faster during pre-processing, as no classification is necessary, in exchange for
a slightly longer average response time during querying.

The remainder of the paper is structured as follows. In Sect. 2, we briefly
recall DL-LiteR and MKNF KBs as a tight combination of the former DL and
non-monotonic rules, followed, in Sect. 3, by the translation of DL-LiteR ontologies into rules. In Sect. 4, we discuss the changes made in the implementation
for OWL 2 QL including optimizations, and evaluate it in Sect. 5, before we
conclude in Sect. 6.

2 Preliminaries

2.1 DL-LiteR

The description logic underlying OWL QL is DL-LiteR, one language of the
DL-Lite family [2,5], which we recall following the presentation in [19].

The syntax of DL-LiteR is based on three disjoint sets of individual names
NI, concept names NC, and role names NR. Complex concepts and roles can be
formed according to the following grammar

B  A | Q

C  B | B

Q  P | P 

R  Q | Q

where A  NC is a concept name, P  NR a role name, and P  its inverse.
We also call B a basic concept, Q a basic relation, C a general concept and R a
general role.
A DL-LiteR knowledge base O = (T ,A) consists of a TBox T and an ABox
A. The TBox contains general inclusion axioms (GCI) of the form B  C and
role inclusion axioms (RI) of the form Q  R, with B, C, Q, and R defined
as above. We term positive inclusion axioms all GCIs and RIs in O such that
C is a basic concept and R is a basic relation, respectively, and all other GCIs
and RIs negative inclusion axioms. We also assume that Q denotes the role P
if Q = P , and P  if Q = P . The ABox contains assertions of the form A(a)
and P (a, b) where A  NC, P  NR, and a, b  NI. Assertions C(a) for general
concepts C can be included by A  C and A(a) for a new concept name A.

5 http://xsb.sourceforge.net

N. Costa et al.

The semantics of DL-LiteR is based on interpretations I = (I,I) consisting of a nonempty interpretation domain I and an interpretation function I
that assigns to each individual a a distinct6 element aI of I, to each concept
name A a subset AI, and to each role name P a binary relation P I over I. This
can be extended as usual:

(P 

)
(Q)

= {(i2, i1) | (i1, i2)  P I}
= {i | (i, i

)  QI}

(B)

(Q)

= I \ BI
= I  I \ QI

An interpretation I is a model of GCI B  C and of RI Q  R if BI  CI
and QI  RI respectively. I is also a model of an assertion A(a) (P (a, b)) if
aI  AI ((aI, bI)  P I). Given an axiom/assertion  we denote by I |=  that
I is a model of . A model of a DL-LiteR KB O = (T ,A) is an interpretation
I such that I |=  holds for all   T  A, and O is satisfiable if it has at least
one model, and unsatifiable otherwise. Also, O entails axiom , written O |= ,
if every model of O satisfies .

2.2 MKNF Knowledge Bases

MKNF knowledge bases (KBs) build on the logic of minimal knowledge and
negation as failure (MKNF) [23]. Two main different semantics have been defined
[18,25], and we focus on the well-founded version [18], due to its lower computational complexity and amenability to top-down querying without computing
the entire model. Here, we only point out important notions following [13], and
refer to [18] and [1] for the details.

We start by recalling MKNF knowledge bases as presented in [1] to combine
an ontology and a set of non-monotonic rules (similar to a normal logic program).
Definition 1. LetO be an ontology. A function-free first-order atom P (t1, . . . , tn)
s.t. P occurs inO is called DL-atom; otherwise non-DL-atom. A rule r is of the form
(1)
where the head of r, H, and all Ai with 1  i  n and Bj with 1  j  m in
the body of r are atoms. A program P is a finite set of rules, and an MKNF
knowledge base K is a pair (O,P). A rule r is DL-safe if all its variables occur
in at least one non-DL-atom Ai with 1  i  n, and K is DL-safe if all its rules
are DL-safe.

H  A1, . . . , An, not B1, . . . , not Bm.

DL-safety ensures decidability of reasoning with MKNF knowledge bases and can
be achieved by introducing a new predicate o, adding o(i) to P for all constants
i appearing in K and, for each rule r  P, adding o(X) for each variable X
appearing in r to the body of r. Therefore, we only consider DL-safe MKNF
knowledge bases.

6 Hence, the unique name assumption is applied and, as shown in [2], dropping it

would increase significantly the computational complexity of DL-LiteR.
?

?

?
Example 2. Consider the following MKNF knowledge base K for recommending
CDs, adapted from [18] (with some modifications). We denote DL-atoms and
constants with upper-case names and non-DL-atoms and variables with lowercase names.7

HasArtist
HasComposed
HasComposed

  Artist
  Piece
  HasArtist

Piece  HasArtist
Artist  Piece

recommend(x) Piece(x), not owns(x), not lowEval(x), interesting(x).
interesting(x) Piece(x), not owns(x), Piece(y), owns(y),

owns(Summertime).
Piece(Summertime).

Artist(z ), HasArtist(y, z ), HasArtist(x , z ).
HasArtist(Summertime, Gershwin).
HasComposed(Gershwin, RhapsodyInBlue).

This example shows that we can seamlessly express defaults and exceptions,
such as recommending pieces as long as they are not owned or having a low
evaluation, and at the same time taxonomic/ontological knowledge including
information over unknown individuals, such as every piece having at least one
artist without having to specify whom, but also features of DL-LiteR, such as
domain and range restrictions (of roles).

The semantics of MKNF knowledge bases K is usually given by a translation
 into an MKNF formula (K), i.e., a formula over first-order logic extended with
two modal operators K and not. Namely, every rule of the form (1) is translated
into a rule of the form KH  KA1, . . . , KAn, not B1, . . . , not Bm, and (P)
is the conjunction of the translations of its rules, and (K) = K(O)  (P)
where (O) is the first-order translation of O. Reasoning with such MKNF
formulas is then commonly achieved using a partition of modal atoms, i.e., all
expressions of the form K for each K or not  occurring in (K). For [18],
such a partition assigns true, false, or undefined to (modal) atoms, and can be
effectively computed in polynomial time. If K is MKNF-consistent, then this
partition does correspond to the unique model of K [18], and, like in [1], we call
the partition the well-founded MKNF model Mwf(K). Here, K may indeed not be
MKNF-consistent if the ontology alone is unsatisfiable, or by the combination
of appropriate axioms in O and rules in P, e.g., axiom A  B in O, and facts
A(a) and B(a) in P. Strictly speaking, unlike [13], we do not have to make
assumptions on the satisfiability of O as we are not going to use a classifier
when processing DL-LiteR ontologies. Still, for the technical results established
in Sec. 3, we will rely on satisfiability since we are able to entail everything from
an unsatisfiable O, whereas the translation into rules defined in Sec. 3 would
7 To ease readability, we omit the auxiliary atoms that ensure DL-safety and leave
them implicit. Also, whenever the body of a rule is empty, we dub it a fact and omit
the  occasionally.

N. Costa et al.

not permit that. This is why, in the following, we assume that O occurring in
K is satisfiable, which does not truly constitute a restriction as we can always
turn the ABox into rules without any effect on Mwf(K). An alternative approach
would be to use one of the paraconsistent semantics for MKNF knowledge bases
[15], but this is outside the scope of this paper, and an issue for future work, as
no paraconsistent correspondence to the querying procedure SLG(O) used here
currently exists.

2.3 Querying in MKNF Knowledge Bases
In [1], a procedure, called SLG(O), is defined for querying MKNF knowledge
bases under the well-founded MKNF semantics. This procedure extends SLG
resolution with tabling [7] with an oracle to O that handles ground queries to
the DL-part of K by returning (possibly empty) sets of atoms that, together with
O and information already proven true, allows us to derive the queried atom.
We refer to [1] for the full account of SLG(O), and only recall a few crucial
notions necessary in the following.
SLG(O) is based on creating top-down derivation trees with the aim of
answering (DL-safe) conjunctive queries Q = q(X)  A1, . . . , An, not B1, . . . ,
not Bm, where each variable in Q occurs in at least one non-DL atom in Q,
and where X is the (possibly empty) set of requested variables appearing in the
body.
In general, the computation of Mwf(K) uses two different versions of K in
parallel to guarantee that a) coherence is ensured, i.e., if P (a) is derivable,
then not P (a) has to be true as well (cf. also [18]), and b) MKNF-consistency
of K can be verified. For a top-down approach this is impractical, so, instead,
a doubled MKNF knowledge base Kd = (O,Od,P d) is defined in which a copy
of O with new doubled predicates is added, and two rules occur in P d for each
rule in P, intertwining original and doubled predicates (see Def. 3.1 in [1]). It is
shown that an atom A is true in Mwf(K) iff A is true in Mwf(Kd) and A is false
in Mwf(K) iff Ad is false in Mwf(Kd). Note that Kd is necessary in general, but
we can use K here if it contains no negative inclusion axioms.

In [1], the notion of oracle is defined to handle ground queries to the ontology,

but before we recall that notion, we use an example to illustrate the idea.
Example 3. Recall K in Ex. 2. As this suffices for our purposes, we omit Kd
and restrict ourselves to K here. Consider query q = recommend(Summertime).
There is a matching rule head in K, and, by instantiating the rule body with x =
Summertime, we obtain a new set of queries. The first one, Piece(Summertime),
can be answered by means of the rule with matching head. The second,
not owns(Summertime), is handled by querying for owns(Summertime), for
which also exists a corresponding rule, which means that not owns(Summertime)
fails, so q is false.

Consider q1 = recommend(RhapsodyInBlue). We can use the same rule
with matching rule head and, again, obtain four new instantiated queries
from the rule body. Now, Piece(RhapsodyInBlue) cannot be derived from the
?

?

?
rules, but we can query the ontology and the oracle will return, e.g., a query
HasComposed(x1 , RhapsodyInBlue) that if proven true can be added to O,
which would allow us to derive the queried goal. Because of the fact
HasComposed(Gershwin, RhapsodyInBlue), this query succeeds, and so does
Piece(RhapsodyInBlue). Subsequently, neither owns(RhapsodyInBlue) nor
lowEval(RhapsodyInBlue) can be proven, so both fail, and their (default) negated
queries succeed. For the remaining new query interesting(RhapsodyInBlue), the
second rule head matches, which creates a further set of subgoals. The first two
have just been answered, so have the next two with y = Summertime for q, and
it can be verified that the remaining also follow from the interplay of O and P
in K. Thus, q1 succeeds.

We recall the notions of a complete and a (correct) partial oracle from [1].
Definition 4. Let Kd = (O,Od,P d) be a doubled MKNF KB, I a set of ground
atoms (already proven to be true), S a ground query, and L a set of ground
atoms such that each L  L is unifiable with at least one rule head in P d. The
complete oracle for O, denoted compTO, is defined by compTO(I, S,L) iff O 
I L |= S or Od I L |= S. A partial oracle for O, denoted pTO, is a relation
pTO(I, S,L) such that if pTO(I, S,L), then O  I  L |= S or Od  I  L |= S
for consistent O  I  L and Od  I  L, respectively.
A partial oracle pTO is correct w.r.t. compTO iff, for all MKNF-consistent
Kd, replacing compTO in SLG(O) with pTO succeeds for exactly the same set
of queries.
Partial oracles may avoid returning unnecessary answers L, such as non-minimal
answers or those that try to derive an MKNF-inconsistency even though Kd
is MKNF-consistent. Also, correctness of partial oracles is only defined w.r.t
MKNF-consistent K. The rationale is that, when querying top-down, we want
to avoid checking whether the entire KB Kd is MKNF-consistent. This leads to
para-consistent derivations if Kd is not MKNF-consistent, e.g., some atom P is
true, yet P d is false, while other independent atoms are evaluated as if Kd was
MKNF-consistent (see [1]).

3 Translating the Ontology into Rules
As argued for the case of EL+ [13], axioms with  on the right-hand side, e.g.,
Piece  HasArtist, cannot be translated straightforwardly into rules, nor do
they directly contribute to the result when querying for ground instances, e.g., of
HasArtist(x , y). Still, such axioms may contribute to derivations within O, which
is why, in [13], classification using the dedicated and highly efficient EL reasoner
ELK [16] is first applied to derive implicit consequences. These, together with
all axioms in O, are then translated into rules, now discarding certain axioms
with  on the right-hand side.

Since, to the best of our knowledge, no dedicated and open-source OWL 2
QL classifier with OWL API that also classifies negative concepts is currently

N. Costa et al.

available, we translate the ontology directly into rules. This also simplifies and
shortens the preprocessing phase and avoids a priori-classification, but requires
some non-trivial considerations to ensure that no derivations are lost in the
process, which we now explain.
Essentially, axioms, such as Piece  HasArtist, cannot be translated into a
rule HasArtist(x , y)  Piece(x) using a universal variable y, as this would allow us
to derive HasArtist(x , y) for any Piece(x) and y, which is clearly not what the axiom
expresses. Using a new constant c instead of y would not be correct either, as querying for HasArtist(x , y) would return HasArtist(x , c) for any Piece(x) for the same
c. Therefore, we proceed differently by introducing new auxiliary predicates that
intuitively represent the domain and range of roles. For our example, this will yield
the rule DHasArtist(x)  Piece(x) where DHasArtist stands for the domain of
HasArtist (and RHasArtist its range). Using such auxiliary predicates also means
that we have to make sure that, e.g., HasArtist(Summertime, Gershwin) allows us
to derive DHasArtist(Summertime), which can be achieved via an additional rule
DHasArtist(x)  HasArtist(x , y). Moreover, for HasComposed  HasArtist, it
does not suffice to translate the axiom to HasArtist(x , y)  HasComposed(y, x),
but also link the new auxiliary predicates for both roles, through the
addition of the rules DHasArtist(x)  RHasComposed(x) and RHasArtist(x) 
DHasComposed(x).

We now formalize this translation, and start by introducing notation on how
to translate general concepts and roles. For that purpose, we formally introduce
for each role P  NR auxiliary predicates DP and RP with the intuition of
representing the domain and range of P . Also, similar to previous work in [1,13],
we use special atoms N H(ti) in SLG(O) that represent a query H(ti) to the
oracle. These are, of course, only relevant if O contains negative inclusion axioms.
Definition 5. Let C be a concept, R a role, x and y variables, and v a new
(anonymous) variable (disjoint from x and y). We define tr(C, x) and tr(R, x, y)
as follows:

tr(C, x) =




A(x)
DP (x)
RP (x)

N A(x)
tr(Q, x, v)

if C = A
if C = P
if C = P 
if C = A
if C = Q

tr(R, x, y)=





P (x, y)
P (y, x)
N P (x, y)
N P (y, x)

if R = P
if R = P 
if C = P
if C = P 

We obtain trd(C, x) and trd(Q, x, y) from tr(C, x) and tr(Q, x, y) by substituting
all predicates P in tr(C, x) and tr(Q, x, y) with P d, respectively.

This way, tr(C, x) and tr(R, x, y) handle both positive and negative inclusions
and no additional case distinction is necessary.
Before we present the actual translation, we need to introduce one central
notion, namely a graph to represent the axioms in a given TBox T as well as the
implicitly derivable axioms, which will be necessary for defining the translation
itself, but also turn out useful when establishing the correctness of the transla-
tion. Graphs have been used for classification in OWL QL (of positive inclusion
?

?

?
Fig. 1. The digraph GT for Example 2

,Q
,Q
1 ) are in E.

axioms) [22], and we extend the notion here to also take negative inclusion
axioms into account. We thus introduce the digraph (directed graph) of T as
follows.
Definition 6. Let T be a DL-LiteR TBox. The digraph of T , GT = V,E, is
constructively defined as follows.
1. If A  NC, then A and A are in V;
2. If R  NR, then P , P , P , P , P , and P  are in V;
3. If B1  B2  T , then the edges (B1, B2) and (B2,B1) are in E;
4. If Q1  Q2  T , then the edges (Q1, Q2), (Q
2 ), (Q1,Q2), (Q
, Q
1 ) are in E;
1 ), (Q2,Q1) e (Q
5. If B1  B2  T , then the edges (B1,B2) and (B2,B1) are in E;
1 ), (Q1,Q2),
6. If Q1  Q2  T , then the edges (Q1,Q2), (Q

(Q2,Q1),(Q

,Q
2 ),

,Q

,Q

,Q

2 ) and (Q

(Q2,Q1), (Q
Basically, each possible general concept and general role over NC and NR is
a node in GT , and the directed edges represent logical implications that follow
from the axioms. Namely, for items 3. and 5., the subset inclusion itself and its
contrapositive are in E, and this is similar for items 4. and 6., only that the
additional combinations due to inverses, , and  have to be taken into account.
In this sense, the graph can be understood as capturing all subset inclusions
(explicit and implicit) in O, i.e., whenever there is a path from concept C1 to
concept C2 and from role R1 to role R2, then C1  C2 and R1  R2 hold
respectively. An Example of such a digraph is given in Fig. 1 for the TBox T
from Example 2.
One observation w.r.t. Fig. 1, is that HasComposed  HasComposed


,
i.e., HasComposed is irreflexive. Even though this does not entail any asser-
tion, knowing that x.HasComposed(x , x) does hold should be captured in the
translation. We introduce (T ), the set of irreflexive roles in T , to be able to
ensure exactly that.
Definition 7. Let T be a DL-LiteR TBox and GT its digraph. We define (T )
as the smallest set of all P  NR that satisfy at least one of the following condi-
tions:

N. Costa et al.

1. For some B1  B2  T , there exist paths from P to B1 and from P  to B2;
2. For some B1  B2  T , there exist paths from P  to B1 and from P to B2;
3. For some Q1  Q2  T , there exist paths from P to Q1 and from P  to Q2;
4. For some Q1  Q2  T , there exist paths from P  to Q1 and from P to Q2.
This notion builds on GT , which is also required for detecting a further set of
derivations. Imagine we would (wrongfully) add Artist  HasComposed
to
O in Example 2. Then there would be a path from Artist to both Piece and
Piece, i.e., the concept Artist would be unsatisfiable. Note that independently
of whether the MKNF KB is MKNF-inconsistent or not, we need to make sure
that all unsatisfiable concepts and roles are determined, so we introduce (T ),
quite similar in spirit to (T ).
Definition 8. Let T be a DL-LiteR TBox and GT its digraph. We define (T )
as the smallest set of all A  NC such that, for some B1  B2  T , there exist
paths from A to both B1 and B2, and all P  NR that satisfy at least one of the
following conditions:
1. For some B1  B2  T , there exist paths from P to both B1 and B2;
2. For some B1  B2  T , there exist paths from P  to both B1 and B2;
3. For some Q1  Q2  T , there exist paths from P to both Q1 and Q2;
4. For some Q1  Q2  T , there exist paths from P  to both Q1 and Q2.



With all pieces in place, we can introduce the translation of a DL-LiteR

DP d(x)  P d(x, y).
RP d(y)  P d(x, y).
Ad(a)  not N A(a).
P d(a, b)  not N P (a, b).
trd(B2, x)  trd(B1, x), not tr(B2, x).

ontology.
Definition 9. Let O be a DL-LiteR ontology. We define P dO from O, where B1,
B2 are basic concepts, Q1, Q2 basic roles, x, y variables, and a, b individuals,
as the smallest set containing:
(e) for every P  NR:
DP (x)  P (x, y).
RP (y)  P (x, y).
(a1) for every A(a)  O:
A(a)  .
(a2) for every P (a, b)  O:
P (a, b)  .
(s1) for every B1  B2  O:
tr(B2, x)  tr(B1, x).
tr(B1, x)  tr(B2, x).
(s2) for every Q1  Q2  O:
tr(Q2, x, y)  tr(Q1, x, y).
tr(Q2, x)  tr(Q1, x).
tr(Q
, x).
tr(Q1, x, y)  tr(Q2, x, y).
(n1) for every B1  B2  O:
tr(B1, x)  tr(B2, x).
(n2) for every Q1  Q2  O:
tr(Q2, x, y)  tr(Q1, x, y). tr(Q1, x, y)  tr(Q2, x, y).

tr(B2, x)  tr(B1, x).

, x)  tr(Q

trd(Q2, x, y)  trd(Q1, x, y), not tr(Q2, x, y).
trd(Q2, x)  trd(Q1, x), not tr(Q2, x).
trd(Q
, x).

, x), not tr(Q

, x)  trd(Q
?

?

?
N A(x)  .
N P (x, y)  .
N P (x, x)  .

(i1) for every A  (T ):
(i2) for every P  (T ):
(ir) for every P  (T ):
Item (e) ensures that the domain and range of roles is correctly encoded, items
(a1) and (a2) translate the ABox, items (s1) and (s2) the positive inclusions,
items (n1) and (n2) the negative inclusions, and items (i1), (i2), and (ir) introduce the rules representing unsatisfiable concepts and unsatisfiable and irreflexive roles. Note, that P dO contains the rule representation for both O and Od,
which is why items (e)(s2) contain doubled rules. Of course, if O does not
contain negative inclusion axioms, then we can skip all these, as well as items
(n1)(ir) which will not contribute anything anyway in this case. The additional default atoms are added to the doubled rules to be in line with the idea
of the doubling of rules in [1]: whenever, e.g., A(x) is classically false for some
x, i.e., N A(x) holds, then we make sure that Ad(x) is derivable as false for that
same x from the rules, but not necessarily A(x), thus allowing to detect potential
MKNF-inconsistencies. That is also the reason why neither (n1)(ir) nor the
contrapositives in (s1) and (s2) do produce the doubled counterparts: atoms
based on predicates of the forms N C d or N Rd are not used anywhere. Finally,
the doubled rules in (e) do not contain the default negated atom as this case
does really just associate domain and range to a role assertion, either present in
the ABox or derived elsewhere. Additionally, predicates N DP or N RP are not
used anywhere, so such default negated atoms would be of no impact anyway.
We can establish three correspondences between entailment from satisfiable
O and the program resulting from the translation P dO. First, we consider positive
atoms.
Lemma 10. Let O be a DL-LiteR ontology, A a unary and R a binary predi-
cate:
 O |= A(a) iff P dO |= A(a) and O |= R(a, b) iff P dO |= R(a, b).
A similar property holds for (classically) negated atoms.

Lemma 11. Let O be a DL-LiteR ontology, A a unary and R a binary predi-
cate:
 O |= A(a) iff P dO |= N A(a) and O |= R(a, b) iff P dO |= N R(a, b).
We can also show the correspondent to Lemma 10 for the doubled predicates.
Lemma 12. Let O be a DL-LiteR ontology, A a unary and R a binary predi-
cate:
 Od |= Ad(a) iff P dO |= Ad(a) and Od |= Rd(a, b) iff P dO |= Rd(a, b).
Thus, we can define a correct partial oracle based on P dO.

Theorem 13. Let Kd = (O,Od,P d) be a doubled MKNF KB and pT QLO a partial QL oracle such that pT QLO (I, S,L) iff P dO  I  L |= S. Then pT QLO is a
correct partial oracle w.r.t. compTO.

N. Costa et al.

Instead of coupling two rule reasoners that interact with each other using an
oracle, we can integrate both into one rule reasoner. The resulting approach is
polynomial w.r.t. data complexity (as in [1,13], but not in AC0 any longer as for
OWL 2 QL alone).
Theorem 14. Let K = (O,P) be an MKNF KB with O in DL-LiteR. An
SLG(O) evaluation of a query in KQL = (, (P d  P dO)) is decidable with data
complexity in PTIME.

4 System Description

In this section, we briefly describe the changes to the architecture of our plug-in
and discuss some optimizations implemented w.r.t. the translation described in
Sec. 3.

To allow the usage of OWL QL ontologies, changes were essentially made
in the translator. Since NoHR now supports two OWL profiles a switch was
introduced that checks the profile of the loaded/edited ontology. Whenever it
belongs to OWL EL, NoHR behaves as described in [13], i.e., the reasoner ELK
is used to classify the ontology and return the inferred axioms to translator,
which are then translated. Otherwise, we treat O of the hybrid KB based on the
translation described in Sec. 3 for OWL QL.

Notably, in Sec. 3, we only considered DL-LiteR, while OWL QL includes a
number of additional constructs which often can be expressed in DL-LiteR. To
account for that, we first normalize such expressions to axioms in DL-LiteR. This
includes ignoring certain expressions, most of which do not contribute to deriva-
tions, e.g., SubClassOf(B owl:Thing), while others make the ontology unsatisfi-
able, such as ClassAssertion(owl:Nothing a), although, as mentioned before,
with no effect when querying the translated rules.

Subsequently, the graph is constructed, for determining unsatisfiable concepts
and unsatisfiable and irreflexive roles, after which the translation is performed,
which includes a number of optimizations. First, whenever there are no negative
inclusions, the doubled rules are omitted in the cases (e)(s2) of Def. 9. Addi-
tionally, case (e) is limited to those rules whose heads appear in the body of
another rule. Both steps reduce the overall number of rules created during the
translation.

The second group of optimizations is related to tabling in XSB, which contributes to help answering queries very efficiently in a top-down manner, and
avoid infinite loops while querying. However, simply declaring all predicates to
be tabled is very memory-consuming, so we reduced the number of tabled predicates without affecting loop detection. For example, only predicates that appear
in any rule head and under negation in any rule body need to be tabled. In addi-
tion, rules with an empty body (facts) can be ignored in the previous criterion,
as these will never cause infinite loops.
?

?

?
Fig. 2. Query response times for NoHR and Pellet

5 Evaluation

In this section, we evaluate our system and show that a) our system scales reasonably well for OWL query answering (only being considerably slower for memoryintensive cases), b) preprocessing is even faster when compared to NoHRs previous version using a classifier (for EL), which was already capable of preprocessing
large ontologies in a short period of time, c) querying scales well, even for over
a million facts/assertions in the ABox, despite being slightly slower on average
in comparison to EL, and d) adding rules scales linearly for pre-processing and
querying, even for an ontology with many negative inclusions.

All tests were performed on a MacBook Pro (Retina, 13-inch, Early 2015)
under OS X Yosemite 10.10.4 with 2.9 GHz Intel Core i5 processor and 16 GB
of 1867 MHz DDR 3 memory. We ran all tests with a terminal version of NoHR
with max. 8 GB of RAM allocated to Java 8 and we used XSB 3.6.0 for querying
with the remaining RAM. Test results are averages over 5 runs.

We considered LUBM8 [12], a standard benchmark for evaluating queries
over a large data set. The benchmarks ontology contains 43 classes, 25 object
and 7 data properties and 243 axioms, and it comes with a data generator and 14
queries q1q14. First, to test general scalability, we utilized the material9 in [21],
that provides data instances of LUBMn for n = 1, 9, 20, where n specifies the
number of universities and where LUBM is slightly simplified to fall completely
into the QL profile. For our test, we focused on the provided material for Pellet,10
as it worked correctly right away. Regarding pre-processing we observe that
NoHR is slightly slower than Pellet (with the factor varying between 1.6 and
6.2), mainly due to the time of additionally loading the file in XSB, a step not
necessary for Pellet. The results of answering queries q2q10, q13, and q14 can be
found in Fig. 2.11 We observe that NoHR is faster for some queries (q3, q10, q13
 up to factor 16), and slower for others, either below factor 15 (q2, q4, q7), or
with a significant difference (the remainder). The latter occurs due to the huge
amount of data being stored in XSBs tables in the query process, ultimately

8 http://swat.cse.lehigh.edu/projects/lubm/
9 https://github.com/ontop/iswc2014-benchmark
10 https://github.com/complexible/pellet
11 q1 is flawed for Pellet and the other two queries have been omitted here, as the restriction to QL cancels the OWL reasoning capability intended to be tested (transitivity
and realization).

N. Costa et al.

Fig. 3. Preprocessing time for LUBM for the two translation modes
?

?

?
Fig. 4. Query time for three LUBM queries

intended for handling non-monotonic rules that are not even part of Pellet. Yet,
at the same time, tabling enables NoHR to be faster, namely, when an already
computed result can simply be looked up (see the test below on LIPID for further
details).

Next, with the aim of comparing our new approach, based on a direct trans-
lation, with the one using a classifier (for OWL EL), we created instances of
LUBMn with n = 1, 5, 10, 15, 20 using the provided generator, and a restricted
version of LUBM which fits both OWL EL and QL (thus rendering q13 meaning-
less, but now permitting q1 in exchange), with the number of assertions ranging
from roughly 100,000 to over 2,700,000. We performed pre-processing and the
results for both kinds of translators (EL and QL) can be found in Fig. 3. Note
that Initialization includes loading the ontology and for EL also classifying it,
Ontology Processing includes the actual translation, and XSB Processing
the writing of the rule file and loading it in XSB. We observe that QL is considerably faster, indeed up to 80s for LUBM20, which is to a considerable extent
due to avoiding classification and a smaller rule file being created. Besides that,
the preprocessing time increases linearly, and the overall time for preprocessing
is acceptable in our opinion as this is only done once before querying.
?

?

?
)
s
(
 
e
m

i

2.5

1.5

0.5

Query 1

Query 2

Query 3

Query 4

Query 4'
?

?

?
LIPID with 100 rules and 1k*facts

Fig. 5. Query time for LIPID

We also queried in XSB for both versions, EL and QL. Some representative
results are shown in Fig. 4. Basically, for queries q1q5, q7 and q10 the response
time is below 18s, often strictly below 1s, in general slightly in favor of the EL
version (up to factor 8). For the other queries, response time increases more
significantly with huge amounts of data, divided into those slightly in favor of
QL (q6, q8, q14, with a factor below 2, but up to 20s in absolute value), and those
in favor of EL (q9, up to factor 4 and 150s in absolute value). In all cases, the
response time grows linearly w.r.t. the increasing size of data, and querying in QL
is slightly slower on average. Here, EL compensates for the longer preprocessing,
and it thus seems that deciding which of the two forms of translations performs
better depends on the kind (and number) of queries we pose.

Finally, with the aim of also testing a more expressive OWL 2 QL ontology,
we used the LIPID ontology,12 which has, besides 749 subclass axioms, 1, 486
class disjointness axioms and 20 inverse object properties in combination with
non-monotonic rules. The latter were created by means of the rule generator
previously used in [13], containing a fixed number of 100 rules and a number of
facts increasing in steps of 1k, also introducing some new predicates not present
in the ontology itself. We performed the preprocessing step and observed only
small effects due to the increasing amount of rules. The time for processing
the ontology was naturally stable for all steps, and overall processing time was
between 1.4 and 3.3s. Notably, the considerable amount of negative inclusions
had no significant impact on time, e.g., when constructing the graph. Then, we
posed four simple queries (Query14), namely Acyl Ester Chain(X), Lipid(X),
Organic Group(X), and Entity(X) to the resulting rule sets in XSB, with the
position in the concept hierarchy varying from the lowest level (Query 1) to the
topmost below  (Query 4) with 715 subclasses. The results are shown in Fig. 5.
As we can see, the response time is very reasonable, from well below 1s to at
most 2.2s. We also posed Query 4 without posing the three previous queries
beforehand. The result is also included in Fig. 5 as Query 4, and it shows the
speed-up that tabling of prior query results for subclasses has on the response

12 http://bioonto.dcs.aber.ac.uk/ql-ont/

N. Costa et al.

time of Query 4 (up to factor 11.5). Overall, the results somehow also show
the effect of the arbitrary rules in raising the time for query answering, since
they introduce additional non-hierarchical (positive and negative) links within
the ontology. We conclude with noting that performance tests of querying (non-
monotonic) rules and ontologies would considerably benefit from real datasets,
but, unfortunately, to the best of our knowledge, none are currently available.

6 Conclusions

We have extended NoHR, the Prot eg e plug-in that allows to query non-monotonic
rules and ontologies in OWL 2 EL, to also admit ontologies in OWL 2 QL. While
the principal architecture of the tool remains the same, the crucial module that
translates the ontology into rules with the help of a classifier simply cannot be re-
used, which is why we introduced a novel direct translation for OWL 2 QL ontologies to cover this profile. We have implemented this translation and discussed opti-
mizations. The evaluation shows that it maintains all positive evaluation results
of the OWL 2 EL version [13], and is even faster during pre-processing, as no classification is necessary, in exchange for an on average slightly longer response time
during querying.

Besides the OWL 2 EL profile supported by NoHR, and compared to in
Sect. 5, also [11,19] both build on the well-founded MKNF semantics [18]. While
[11] uses the non-standard CDF framework integrated in XSB, which complicates
compatibility to standard OWL tools based on the OWL API, [19] presents
an OWL 2 QL oracle based on common rewritings in the underlying DL DLLiteR [2], but would require constant interaction between a rule reasoner and
a DL reasoner, which is why we believe it is ultimately less efficient than our
approach. Two related tools are DReW [29] and HD Rules [8], but both are
based on different base formalisms to combine ontologies and non-monotonic
rules w.r.t. the way information can flow between its two components and how
flexible the language is [9,25], which considerably complicates comparison.

For future work, the extension to OWL 2 RL seems an obvious next step, but
developing an alternative for OWL 2 QL using the classifier integrated in ontop
[21] or even the general reasoner Konclude [28], could shed more light on whether
classification or direct translation fares better for proper OWL 2 QL ontologies.
The efficiency of the latter reasoner also motivates looking into non-polynomial
DLs, with possible influences from recent work on rewriting disjunctive datalog
programs [14]. Using a relational database for the data as in OBDA would also
be interesting, yet this would require non-trivial theoretical work on rewriting
queries including non-monotonic rules. Finally, we may extend NoHR for OWL
2 QL (and EL) to the paraconsistent semantics [15] that would provide true
support to the paraconsistent behavior already observed .

Acknowledgments. This work was partially supported by Funda c ao para a Ciencia
e a Tecnologia (FCT) under project PTDC/EIA-CCO/121823/2010, strategic project
PEst/UID/CEC/04516/2013, and grant SFRH/BPD/86970/2012 (M. Knorr).
?

?

