Adding DL-Lite TBoxes to Proper

Knowledge Bases

Giuseppe De Giacomo1(B) and Hector Levesque2

1 Sapienza Universit`a di Roma, Rome, Italy

degiacomo@dis.uniroma1.it

2 University of Toronto, Toronto, Canada

hector@cs.toronto.edu

Abstract. Levesques proper knowledge bases (proper KBs) correspond
to infinite sets of ground positive and negative facts, with the notable
property that for FOL formulas in a certain normal form, which includes
conjunctive queries and positive queries possibly extended with a controlled form of negation, entailment reduces to formula evaluation. However proper KBs represent extensional knowledge only. In description
logic terms, they correspond to ABoxes. In this paper, we augment them
with DL-Lite TBoxes, expressing intensional knowledge (i.e., the ontology of the domain). DL-Lite has the notable property that conjunctive
query answering over TBoxes and standard description logic ABoxes is
reducible to formula evaluation over the ABox only. Here, we investigate
whether such a property extends to ABoxes consisting of proper KBs.
Specifically, we consider two DL-Lite variants: DL-Literdfs , roughly corresponding to RDFS, and DL-Litecore , roughly corresponding to OWL 2
QL. We show that when a DL-Literdfs TBox is coupled with a proper KB,
the TBox can be compiled away, reducing query answering to evaluation
on the proper KB alone. But this reduction is no longer possible when
we associate proper KBs with DL-Litecore TBoxes. Indeed, we show that
in the latter case, query answering even for conjunctive queries becomes
coNP-hard in data complexity.

1 Introduction

Many applications involving knowledge representation require an open-world set-
ting, with incomplete information on their domain of interest [2,7,15,16]. In
such conditions, querying a knowledge base is typically based on logical infer-
ence, which is generally computationally infeasible. Indeed, the most successful
applications of logics in Computer Science, namely relational databases [1] and
model checking [5] assume complete information, and are based on the evaluation of logical formulas over a finite model. In particular, evaluating a FOL
formula against a database requires only a simple recursive procedure and is
indeed sub-polynomial (AC 0) in data complexity (i.e., in the computational
complexity measured over the size of the database only). A natural question is
whether there are interesting cases in which logical inference, required to deal
with incomplete information, can be compiled into formula evaluation and hence
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 305321, 2015.
DOI: 10.1007/978-3-319-25007-6 18

G. De Giacomo and H. Levesque

retain the deductive efficiency of database retrieval without requiring complete
knowledge, as with databases.

Based on this idea, Levesque [17] proposes the notion of a proper knowledge
base (proper KB), where incomplete knowledge amounts to a possibly infinite set
of positive or negative ground facts (without disjunctions or existentials), which
allow for selectively making open and close world assumption on (possibly part
of the extension of) single predicates. For this kind of KB he devises a reasoning procedure based on formula evaluation that essentially has the efficiency of
first-order logic evaluation over a finite model (AC 0 in data complexity). This
evaluation procedure is logically sound, and also complete when the formula is
in a special normal form, called NF. This class of formula notably includes conjunctive queries and positive queries, possibly extended with a controlled form
of negation. Proper KBs are further investigated in [12,18,19].

Compiling logical inference into evaluation is also at the base of one of the
most fruitful developments in description logics (DLs) [3] in the last decade, the
introduction of so called ontology-based query answering systems and the DLLite family [9,10]. These logics are designed for retaining the data complexity
of FOL evaluation, while being able to capture most constructs used in UML
Class Diagrams or Entity Relationship Diagrams [6]. They generalize W3C RDF
Schema (RDFS) [8,14], and are at the base of the OWL 2 QL profile of the W3C
standard OWL 2 [20].

DLs consider knowledge divided into intensional knowledge and extensional
knowledge. Intensional knowledge is expressed as a TBox, i.e., a finite set of
universal logical assertions describing the domain of interest in terms of classes
(called concepts), which are unary predicates, and relationships between classes
(called roles), which are binary predicates. Extensional knowledge is expressed
as an ABox, which consist of a finite set of positive facts involving concepts and
roles of the TBox. (Open-world semantics is assumed.) Often the TBox is used to
capture the ontology of the domain, while the ABox is used to capture contingent
knowledge on individuals belonging to the domain. The main reasoning task of
interest for the logics in the DL-Lite family is query answering, that is, computing
substitutions for the open variables in the query for which the resulting formulas
are logically entailed by the TBox and the ABox. The queries typically considered
are conjunctive queries and the union of conjunctive queries. The first are FOL
formulas where only conjunction and existential quantification is allowed, while
the second include also disjunction (but, no forms of negation, nor universal
quantification). The key feature of the DLs belonging to the DL-Lite family
is the so-called first-order rewritability: query answering for a query Q can be
performed in a sound and complete way by compiling away the TBox into a new
FOL query QT that can be evaluated over the ABox, considered as a database.
As the result, query answering in DL-Lite is AC 0 in data complexity like formula
evaluation in a relational DB.

In this paper, we consider knowledge bases constituted by a TBox expressed
in variants of DL-Lite and an ABox consisting of a Levesques proper KB. In
particular we consider two members of the DL-Lite family: DL-Literdfs, which
roughly correspond to RDFS [14], and DL-Litecore, which roughly correspond
?

?

?
to OWL 2 QL [9,10]. The latter is actually the simplest DL-Lite that includes
assertions of the form A  R.

We show that in the case of proper KBs extended with DL-Literdfs TBoxes,
we can compile away the TBox retaining soundness and completeness of rea-
soning, so that when the resulting query is in NF, the proper KB evaluation
procedure is both sound and complete. (In particular, for conjunctive queries and
union of conjunctive queries, this is always be the case.) This theoretical result
has an immediate practical impact: it is possible to build effective ontology-based
query aswering systems where: (i) RDFS is used to express the ontology of the
domain (considering that DL-Literdfs captures the description logic fragment of
RDFS, i.e., the fragment obtained by dropping RDFS meta-modeling features);
(ii) proper KBs are used to express extensional knowledge in a very rich way,
and (iii) SPARQL is used as a concrete query language for expressing (NF)
first-order queries [21].

Then we turn to DL-Litecore and show that, in this case, it is not possible to
reduce query answering to FOL query evaluation. We do so by proving that even
for conjunctive queries, any sound and complete procedure must be coNP-hard,
and hence, the proper KB evaluation procedure remains sound but must necessarily be incomplete. This has the practical impact of ruling out the possibility
of building sound, complete and computationally tractable ontology-based query
answering systems that adopt OWL 2 QL as the ontology language.1

The rest of the paper is organized as follows. In Sections 2 and 3, we
review proper KBs and DL-Lite. In Section 4, we show soundness and completeness results for TBoxes in DL-Literdfs. In Section 5, we show that moving to
TBoxes in DL-Litecore, we lose the required computational tractability. Finally
in Section 6, we draw some conclusions and discuss future work. An appendix
with the detailed proof of the result in Section 4 completes the paper.

2 Proper Knowledge Bases
Standard Names. We use an ordinary first-order logical language L with an
infinite supply of predicate symbols (including =), an infinite supply of constants,
called standard names (which we write as #1, #2, #3, . . .), and no other function
or constant symbols. We denote the set of standard names by N . We use the
notation x
n to mean the result of replacing every free occurrence of variable x
in formula  by standard name n. We adopt the usual Tarski semantics for L,
with |= understood as normal logical entailment. However, we make the unique
name assumption for the standard names. This means that we implicitly assume
a theory of equality E formed by the usual axioms of equality (reflexitivity,
symmetry, transitivity, and substitution of equals for equals) together with { n =
n | n and n are distinct standard names}. A knowledge base (KB) K consists
of a finite set of sentences (closed formulas) belonging to L. To K we will always
implicitly add the equality theory E. The (implicit) adoption of E implies that
1 In fact, our infeasibility result applies also to EL, and hence rules out also OWL 2
EL [4, 20].

G. De Giacomo and H. Levesque

K has a model iff it has a standard model, that is, one where = is interpreted
as identity and the domain is isomorphic to the set of standard names. Hence,
w.l.o.g., we can make domain closure assumption: we can assume that the only
objects in the domain of interpretation are the standard names. A key property
of adopting standard names is the following.
Theorem 1. [17] Suppose that K is a KB (including E) and  a possibly open
formula in L. Let H be the set formed by all the (finitely many) standard names
that appear in K or  and at least one other not occurring in K and . Then

K |= x. iff K |= x

n for every n  H.

This means that we can determine whether x. is entailed by checking whether
a finite set of instances of  are entailed.
Proper KBs. Following [17], a proper knowledge base A is a finite collection of
sentences of L of the form

x.(e  	),

where

is equality, and free variables are among x,

 e is an equality formula, i.e., a quantifier-free formula whose only predicate
 	 is P (x) or P (x), for some predicate P of arity |x| in L,
  is the usual material implication connective.
Proper KBs are required to be consistent (under the implicit equality theory
for standard names E). A proper KB can be seen as a finite representation for
a possibly infinite consistent set of ground literals { 	 | A |= 	 }, where  is
a substitution of free variables by standard names, and 	 denotes 	 after the
substitution.

Proper KBs can play the role of ABoxes typical of description logics (cf. 3),
since they express extensional knowledge as ABox do. Though, they generalize
ABoxes in several ways as exemplified below.

Using proper KBs, we can encode finite sets of positive facts (i.e., standard
ABoxes), saying that objects or tuples belong to predicates, but also we can
encode negative facts saying that objects or tuples do not belong to predicates.
Indeed any finite set of ground literals can be reformulated as a proper KB, by
simply rewriting any ground literal 	 in the set as x. (x = x  	).
We can make the close-world assumption (like in databases) on selected pred-
icates, using assertions {x.(e(x)  P (x)), x.(e(x)  P (x))}. For example,
the following proper KB
{x. (x = #2x = #3x = #5  P (x)), x. (x = #2x = #3x = #5  P (x))}
makes the closed-world assumption on P , saying that the extension of P is
exactly {#2, #3, #5}. This capability can be used, e.g., to describe an authoritative source, which contains exactly all the data about the predicate P .
?

?

?
We can leave the status of some predicate open for some objects only. For

example we can write

x.(x = #0    x = #9  P (x))

saying that only #0, . . . , #9 may belong to P , without saying which. This can be
used to circumscribe the presence of objects in certain data sources. Similarly
we can write

x.(x = #0  x = #1  R(#100, x))

(1)
saying that the object #100 is not linked through R to any object different
from #0 and #1, leaving open whether R(#100, #0) or R(#100, #1) holds. More
generally, proper KBs can capture quite advanced forms of partial knowledge on
the extension of data sources.

Reasoning with Proper KBs. The reasoning task of interest for proper KBs
is query answering. In particular, as in [17], here we focus implicitly on boolean
queries only. A (boolean) query Q is a sentence, i.e., a closed formula, in L.
Answering Q over a proper KB A consists in checking the entailment

A |= Q.

It is in general undecidable to determine whether or not A |= Q. (Consider the
case A = , where we still need to determine whether an arbitrary first order
formula is valid.) As an alternative, Levesque [17] proposes a limited reasoning
procedure V analogous to the evaluation function used for databases under the
closed-world assumption, which, however, may return 1 (known to be true), 0
2 (unknown). Given a proper KB A and a query Q, the
(known to be false), or 1
evaluation procedure V [A, Q] is defined as follows:
1. (Ground atomic fact) if Q = 	 then

V [A, 	] =






1 if there is a x.(e  	)  A s.t. E |= e
0 if there is a x.(e  	)  A s.t. E |= e
2 otherwise

where 	 denotes the result of adding or removing negation from 	.

2. (Ground equality atom) if Q = (n = n) then

V [A, (n = n)] =
?

?

?
3. (Negation) if Q =  then

1 if n and n are the same standard name
0 otherwise

V [A,] = 1  V [A, ]

4. (Disjunction) if Q =    then

V [A, (  )] = max{V [A, ], V [A, ]}

G. De Giacomo and H. Levesque

5. (Conjunction) if Q =    then

V [A, (  )] = min{V [A, ], V [A, ]}

6. (Existential quantification) if Q = x. then
V [A,x.] = max
nH

V [A, x
n]

where H is the set of standard names appearing in A or  plus a new one.

7. (Universal quantification) if Q = x. then
V [A,x.] = min
nH

V [A, x
n]

where again H is the set of standard names appearing in A or  plus a new
one.

Notice that as expected we have that
V [A,   ] = V [A,(  )],

V [A,x.] = V [A,x.].

The evaluation procedure V is tractable in a very strong sense. Analogously to
database evaluation, is is easy to see that V [A, Q] can be computed in AC 0 in
data complexity, i.e., in the number of standard names mentioned in A and Q.
From a more practical point of view we have:
1. If e is a ground equality formula, then E |= e iff V [, e] = 1 and can be
2. V [A, 	] can be determined in time linear in |A|: scan A for x.(e  	) or
3. Overall, computing V [A, Q] can be made as efficient as database retrieval

determined in time linear in |e|.
x.(e  	) and check if E |= e.

[19].

The procedure V is always logically sound:

Theorem 2. [17] For any proper KB A and any query Q in L, we have:
 if V [A, Q] = 1 then A |= Q;
 if V [A, Q] = 0 then A |= Q.
However V is not (and cannot be) logically complete in general. For example:
E |= (p  p) but V [, (p  p)] = 1
2.

In [17] completeness is shown for a semantically defined sublanguage of L,
called NF, for normal form. We say that a set of sentences S is logically
separable iff for every consistent set of ground literals L, if L S has no standard
model, then for some   S, L  { } has no standard model. Then NF 
L is defined as the least set such that: (i) if  is a ground atom or equality
formula, then   NF; (ii) if   NF, then   NF; (iii) if S  NF, S is
S  NF; (iv) if S  NF, S is logically
logically separable, and S is finite, then
separable, and S = { x

n | n is a standard name }, then x.  NF.
?

?

?
Theorem 3. [17] For any proper KB A and any Q in NF, we have:
 if A |= Q then V [A, Q] = 1;
 if A |= Q then V [A, Q] = 0.
Unfortunately NF is a semantical condition and checking if a formula is in
NF is itself undecidable. However an interesting sufficient syntactic condition
for belonging to NF is the following: we say two literals are conflict-free iff either
they have the same polarity, or they use different predicates, or they use different
standard names at some argument position.
Theorem 4. [17] Let Q be a query in L, if all pairs of literals in Q are conflict-
free, then Q in NF.
Notably all positive queries (i.e., without  and ), hence including conjunctive queries (i.e., using only  and ) and union of conjunctive queries (i.e.,
disjunctions of conjunctive queries), are conflict-free.

3 DL-Literdfs and DL-Litecore

Description logics (DLs) [3] describe the domain of interest in terms of individuals denoting objects, concepts, denoting sets of objects, and roles, denoting
binary relations between objects. In DLs, starting from concepts names (denoted
by A) and roles names (denoted by R), we can construct complex concepts C,
D and roles ,  by inductively applying suitable constructors that depend on
the DL in question.
A DL knowledge base K consists of a TBox T , expressing intensional knowl-
edge, and an ABox A, expressing extensional knowledge. TBox T is constituted
by a finite set of concept and role inclusions of the form

C  D,

  

where the form of concepts C, D and roles ,  depend on the specific DL. We
allow inclusions to be cyclic, which is required in virtually all ontology-based
and conceptual modeling applications2. A standard DL ABox A consists of a
finite set of positive ground literals involving concepts and roles of the TBox.

In this paper, we consider DL-Litecore, the simplest language of the DL-Lite
family [9,10]. A TBox in DL-Litecore is a finite set of inclusion assertions of the
form:

C  D,

C  D

where concepts C, D and roles ,  are defined by the following syntax:

C, D ::= A | 

 ::= R | R

where  is the projection of binary role  on the first component and R is the
inverse of role R. TBoxes expressed in DL-Litecore capture a core fragment of

2 When a TBox is acyclic, it can be treated as a set of abbreviations and eliminated

w.l.o.g.

G. De Giacomo and H. Levesque

UML class diagrams: isa between classes (A  B, A and B are concepts names),
typing of roles (R  A, R  B), disjointness between classes (A  B), and
mandatory participation of instances of a class to roles (A  R or B  R),
see [9]. DL-Litecore roughly corresponds to OWL 2 QL profile [20], where we
disallow the use of inclusion assertion on roles   .
Besides DL-Litecore, we consider also DL-Literdfs, which is obtained from
DL-Litecore by dropping the possibility of using  on the right-hand side of
inclusion assertions, but including inclusion assertions on roles of the form:

  

with ,  ::= R | R. Hence, we loose the possibility of expressing mandatory
participation, but we gain the possibility of expressing subproperties through
isas on roles, thus capturing RDFS [8] (without meta-level assertions), interpreted according to the extensional semantics [14].

We give the semantics of DL-Litecore and DL-Literdfs by exhibiting the FOL
formula corresponding to each concept and role expression. In particular, if t
and t are terms, then [t, t] is the first-order formula defined by

R[t, t] = R(t, t)
R[t, t] = R(t, t).

Similarly, C[t] is the first-order formula defined by (below z stands for any variable such that z = t):

A[t] = A(t)
[t] = z.[t, z]
A[t] = A(t)
[t] = z.[t, z].

Assertions of the form C  D and of the form    correspond, respectively, to

x.(C[x]  D[x])

x, y.([x, y]  [x, y])

Typically in DL-Lite, we are interested in query answering, where queries
are conjunctive queries or union of conjunctive queries. These are possibly open
formulas expressed in terms of the concepts (unary predicates) and roles (binary
predicate) of T and A. When such formulas are closed we call such queries
boolean. In particular, in this paper, we focus on boolean queries only. Given a
TBox T and ABox A, and a (boolean) query Q we are interested in checking
whether

T  A |= Q

Notably the DL-Lite variants enjoy the first-order rewritability property, which
in our setting says that for every conjunctive query or union of conjunctive
queries Q:
where QT is a union of conjunctive query obtained by rewriting Q using T , e.g.,
by the reformulation algorithm in [9], so as to compile away the TBox T , and
evaluate QT over the ABox A only, considered as a database (with complete
information, i.e., closed world assumption). As a result, query evaluation in DLLite is AC 0 in data complexity, i.e., in the size of the ABox.

T  A |= Q iff A |= QT
?

?

?
4 Proper KBs with DL-Literdfs TBoxes

The question that this paper addresses is whether something analogous to DLLite first-order rewritability holds also in the case of ABoxes consisting of proper
KBs.
More precisely lets consider KBs formed by a DL-Literdfs TBox T and an
ABox A constituted by an proper KB over the unary and binary predicates
forming the alphabet of the TBox. We restrict our attentions to proper KBs A
that are consistent with the TBox T , i.e., that A |= T where T denotes the
negation of the conjunction of all assertions in the TBox T . On such KBs, we
consider boolean queries Q, i.e., first-order sentences, and we are interested in
query answering, i.e., checking whether:

T  A |= Q

In particular, we want to study whether there exists another FOL query QT
such that

T  A |= Q iff A |= QT

That is, we want to compile away the TBox and obtain another query QT to
ask over the proper KB A alone. Notice that, differently from the case of standard DL-Lite, A cannot be seen as a database, since it still includes incomplete
information and the close world assumption cannot be made. However if we can
reduce T  A |= Q to A |= QT , we can then use the evaluation procedure V
to compute V [A, QT ], which is always sound and complete for queries in NF.
Indeed we are also interested in sufficient conditions for completeness. We show
below that when T is a DL-Literdfs TBox, QT can always be obtained. Moreover
there are interesting class of queries Q (including conjunctive queries, and union
of conjunctive queries) for which the evaluation procedure V applied to QT is
indeed complete.

Without loss of generality we assume the query Q to be in negation normal
form (NNF), i.e., with negation appearing only in literals. We use the following
notation: C denotes the concept that results from adding or removing a negation from C, and  denotes the role that results from adding or removing a
superscript minus from .
Next we define two crucial relations R and C denoting the chain of

asserted inclusions among concepts and roles respectively.
 The R relation holding between pairs of roles is the reflexive transitive

closure of the relation

{ (, ) |     T

or

    T }.

 The C relation holding between pairs of concept is the reflexive transitive

closure of the relation

{ (C, D) | C  D  T

or D  C  T

C = , D = ,  R  }.

or

G. De Giacomo and H. Levesque

With these two relations at hand, we can define the rewriting QT of a query

Note that, if C C D then T |= x.(C[x]  D[x]) and similarly, if  R  then
T |= x, y.([x, y]  [x, y]).
Q wrt a DL-Literdfs TBox T .
Definition 1 (Rewriting). Let T be a DL-Literdfs TBox and query Q in NNF,
we define the rewriting QT of Q wrt T to be Q with every positive A(t) replaced
by
?

?

?
every A(t) replaced by

every positive R(t, t) replaced by

CCA
?

?

?
ACD

C[t],

D[t],
?

?

?
RR

[t, t

],

and every R(t, t) replaced by
[t, t
?

?

?
RR

]  
RCD

D[t]  

RCD

D[t

].

As we show below, the resulting formula enjoys the desired property: it is

the result of compiling away the TBox from Q.
Theorem 5. Let T be a DL-Literdfs TBox, A be a proper KB consistent with
T , Q a boolean query in NNF, and QT its rewriting defined as above. Then

T  A |= Q iff A |= QT

Proof. The proof requires extra machinery and has been moved to the appendix.
?

?

?
In general, Theorem 5 does not induce an analogue of first-order rewritabil-
ity, in the sense that QT cannot be evaluated over the ABox A. However, if
QT is NF, then it does, since the evaluation procedure V becomes sound and
complete and hence it becomes sufficient to check whether V [A, QT ] to know
whether A |= QT . Unfortunately checking whether QT is in NF is in general
undecidable. However we can polynomially check QT for conflict-freeness. We
can exploit this for giving a nice sufficient condition for the completeness of V .
Definition 2 (Conflict-free for a TBox). Let T be a DL-Literdfs TBox, Q a
boolean query in NNF and QT its rewriting defined as above. Q is conflict-free
for a TBox T iff QT is conflict-free.
?

?

?
Note that positive queries are always conflict free for DL-Literdfs TBoxes, including conjunctive queries and union of conjunctive queries. For example, if Q is a
conjunctive query then QT is equivalent to a union of conjunctive queries, and
hence is conflict-free.

For conflict free queries, we can exploit Theorem 5 and the soundness and

completenes results for V to get:
Theorem 6. Let T be a DL-Literdfs TBox, A be a proper KB consistent with
T , Q a boolean query in NNF , and QT its rewriting defined as above. If Q is
conflict-free for T , we have:
 T  A |= Q iff V [A, QT ] = 1;
 T  A |= Q iff V [A, QT ] = 0.
Hence, for queries that are conflict-free for the TBox, query answering reduces to
evaluation and is indeed AC 0 in data complexity (i.e., in the number of standard
names occurring in the ABox and in the query).

5 Proper KBs with DL-Litecore TBoxes
Next we investigate KBs formed by a DL-Litecore TBox T and an ABox A formed
as a proper KB. Unfortunately in this case we have a negative result: query
answering by evaluation is in general unachievable even for queries consisting
of boolean conjunctive queries. Indeed, if query aswering by evaluation were
possible the data complexity of query answering would be AC 0. However we
show that, even with a TBox consisting of a single assertion of the form A  R,
conjunctive query answering in proper KBs is coNP-hard in data complexity,
since proper KB assertions like (1) in Section 2 force reasoning by cases on the
data.
Theorem 7. Conjunctive query answering in proper KBs with TBoxes including assertions of the form

A  R
is coNP-hard with respect to data complexity.

Proof. The proof is based on a reduction from 2 + 2-CNF unsatisfiability, which
is shown to be coNP-complete in [13]. A 2 + 2-CNF formula is a CNF formula in
which each clause has exactly four literals: two positive ones and two negative
ones.
2,
we associate with it the knowledge base K = T ,A. The alphabet of K includes
one concept A and five roles P1, P2, N1, N2 and R with the following intuitive
meaning:

Given a 2+2-CNF formula F = c1cn, where ci = i

i

i

1i

1+

2+

 concept A(x) denotes that x is an atomic proposition;
 role P1(x, y) (resp. P2(x, y)) denotes that the atomic proposition y is in first

(resp. second) positive position of the clause x;

G. De Giacomo and H. Levesque

 role N1(x, y) (resp. N2(x, y)) denotes that the atomic proposition y is in first

(resp. second) negative position of the clause x;

 role R(x, y) denotes that the truth value y is assigned to the atomic propo-

sition x.

The TBox T is simply:
The ABox A is formed by the proper KR equivalent to the following atomic
assertions (see examples in Section 2 for hints on how to represent these finitely
using equality):

A  R

A(1

A(n

1+), A(1

2+), A(1

1), A(1

2),

1+), A(n

2+), A(n

1), A(n

2),

2)

2),

1+), P2(c1, 1

2+), N1(c1, 1

1), N2(c1, 1

1+), P2(cn, n
1+, #2),R(1
2+, #2),R(1
1, #2),R(1
2, #2),R(1
1+, #2),R(n
2+, #2),R(n
1, #2),R(n
2, #2),R(n
1, 1

2+), N1(cn, n
1), N2(cn, n
1+, #3),R(1
1+, #4),
2+, #3),R(1
2+, #4),
1, #3),R(1
1, #4),
2, #3),R(1
2, #4),
1+, #3),R(n
1+, #4),
2+, #3),R(n
2+, #4),
1, #3),R(n
1, #4),
2, #3),R(n
2, #4),
1, n
, n
2, . . . , n
2+

P1(c1, 1

P1(cn, n
R(1
R(1
R(1
R(1

R(n
R(n
R(n
R(n
where, c1, . . . , cn and 1
2 are standard names
1+
chosen to be different from each other. The standard names #0 and #1 are used
to represent the truth values true and f alse respectively. Intuitively the binary
predicates P1 P2, N1, N2 associate to clauses ci their four atomic propositions
i
2 in their respective first/second, positive/negative position. The
1+
binary predicate R associates truth values to atomic propositions, which given
the infinite set of assertions of the from R(, k) can only be either #0 or #1 for
the atomic propositions mentioned in the clauses.

1, i

, n

, i

, 1

2+

, 1

, i

2+

1+

Finally, we consider the following boolean conjunctive query:

Q = x, y1+, y2+, y1, y2.
(P1(x, y1+)  R(y1+, #0)  P2(x, y2+)  R(y2+, #0) 
N1(x, y1)  R(y1, #1)  N2(x, y2)  R(y2, #1))

Intuitively query Q checks if it is possible to assign the wrong truth value to all
propositions y1+, y2+, y1, y2 of some clause x. More precisely, checking whether
T  A |= Q (i.e., whether the query is certainly true in T  A) corresponds to
checking whether in every truth assignment for the formula F there exists a clause
whose positive atomic propositions are interpreted as false and whose negative
atomic propositions are interpreted as true, i.e., a clause that is not satisfied. Next
we show that the formula F is unsatisfiable if and only if T  A |= Q.
?

?

?
, #1) or R(i

, #1) or R(i

1, #0) or R(i

2+

1+

2+

1+

, #0) or R(i

1, #1) or R(i

 Towards contradiction, suppose that the formula F is unsatisfiable
but T  A |= Q. Then there exists a model M such that M |= T  A, but
M |= Q. Notice that the given the assertions in A the only way not to satisfy Q
is that for each i = 1, . . . , n, we have that either R(i
, #0) or
R(i
2, #1). On the other hand for each such i, by the TBox
assertion A  R, there must exists some v such that R(i, v), and because of
the infinite assertions on R(i, #2), R(i, #3), R(i, #4), . . . it must be the
case that v = #0 or v = #1. So we have that for each clause ci we must have
that R(i
2, #0). But this would imply
that the set of clauses F is indeed satisfiable, contradicting the hypotesis.
 Towards contradiction, suppose that T  A |= Q but the formula F is
satisfied by some truth assignment 	 to its atomic propositions. Then, let M	 be
the interpretation for T  A defined as follows:
AM	 = { |  is an atomic proposition in F}
1+) | in F , i
1 = {(ci, i
P M	
2+) | in F , i
2 = {(ci, i
P M	
1) | in F ,i
1 = {(ci, i
N M	
2) | in F ,i
2 = {(ci, i
N M	
RM	 = {(, v) | 	() = v}

1+ is the first positive atomic proposition of ci}
2+ is the second positive atomic proposition of ci}
1 is the first negative atomic proposition of ci}
2 is the second negative atomic proposition of ci}

It is easy to see that M	 is a model of T A. On the other hand, since F is satisfi-
able, for every clause in F there exists a positive atomic proposition interpreted
as true or a negative atomic proposition interpreted as false. It follows that for
every (standard name corresponding to) a clause ci, either P1 or P2 relates ci to
a atomic proposition  such that (, #1)  R and (, #0)  R, or either N1 or N2
relates ci to a to a atomic proposition  such that (, #0)  R and (, #1)  R.
Hence Q evaluates to false in M	, and therefore T  A |= Q, contradicting the

hypothesis.

This theorem rules out DL-Litecore and virtually all variants of DL-Lite,
which allow for expressing A  R, including the two most prominent ones:
DL-LiteR, directly corresponding to OWL 2 QL [20], and DL-LiteA, often used
in ontology-based data access applications [11]. For the same reason, it also rules
out the whole EL family [4].

6 Conclusion

In this paper we have shown that is it feasible to extend Levesques proper KBs
with TBoxes expressed in DL-Literdfs while retaining the ability to reason by
evaluating formulas for first-order queries of certain forms and hence solve query
answering in AC 0 in data complexity as for standard database query evalua-
tion. This result is of practical interest considering that DL-Literdfs captures the
description logic fragment of RDFS (i.e., dropping meta-modeling features) and
that SPARQL can be used as a concrete query language for expressing first-order
queries over RDFS [21].

G. De Giacomo and H. Levesque

We also showed that this result cannot be generalized to TBoxes expressed
in OWL 2 QL or any DL-Lite variant that allows for assertions of the form
A  R [9,10], including DL-Litecore, since when combined with the power of
proper KBs, reasoning by cases become necessary (query answering becomes
coNP-hard). In fact, the result applies also to the DL EL [4] and hence to OWL
2 EL [20] as well.

Our result on proper KBs with DL-Literdfs TBoxes could be slightly gener-
alized. In particular, it would be interesting to extend the TBox language, e.g.,
to deal with assertions of the form    to express disjoint extension of roles,
and getting closer to OWL 2 QL [9,20], or to by considering n-ary roles [10].
Also, the language of proper KBs themselves can be extended, e.g., to deal with
unknown individuals, i.e., nulls, as in [12]. We leave these extensions for future
studies.

A Appendix
In this appendix we prove Theorem 5. As ABox A we consider any set (possibly
infinite) of assertions of the form A(n), R(n, m) and A(n), R(n, m), where
n and m are standard names. Notice that these ABoxes are more general then
proper KBs (which indeed correspond to certain ABoxes of this form). The TBox
T is a standard DL-Literdfs TBox. We assume A to be consistent with T (i.e.,
A |= T .) We use the following notation. If M is a logical interpretation, then
the extension of a concept C and a role  are respectively:

CM = {n | M |= C[n]},

M = {(n, n

) | M |= [n, n

]}.

Note that for any C, CM = CM . For any concept C and role , we define
MIN() = {(n, m) | A |= [n, m]}.

MIN(C) = {n | A |= C[n]},

Note that for any M such that M |= A, MIN(C)  CM and MIN()  M . For
any M and C, we define

F (C) =
?

?

?
DCC

E(D) where E(C) = MIN(C)  
CCD

DM .

Note that for any C, MIN(C)  E(C)  F (C).
Lemma 1. If M |= A then F (C)  F (C) = .
Proof. Suppose not. Then there is n  F (C) and n  F (C). Then for some
D C C, n  E(D) and for some D C C, n  E(D). Since we have D C C
and C C D (which is contrapositive of D C C), we also have D C D.
Now consider the cases for n  E(D). If n  MIN(D), then A |= D[n].
Since A |= T , A |= D[n] and so n  MIN(D). Moreover, since M |= A it
follows n  DM , and hence n  DM . Since by definition D C D, we get
n  

DCE EM . This contradicts n  E(D).
?

?

?
On the other hand, if n  

M |= A, n  MIN(D). Moreover n  
contradicts n  E(D).

DCE EM , then n  DM , so n  DM . Since
DCE EM , since D C D. This again
?

?

?
For any M and , we define

G() =
?

?

?
R

H () where H () = MIN()  [(E()  E(

))  
R

 M ].

Lemma 2. G()  F ()  F ().
Proof. We prove it for  = R. (The case of R is analogous.) If (n, m)  G(R)
then for some  R R, (n, m)  H (). There are two cases: if (n, m)  MIN(),
then n  MIN() and then m  MIN(), in which case, n  E() and m 
E(); if (n, m)  (E(  E()), then again n  E() and m  E().
Since  R R,  C R and  C R. It follows that n  F (R) and
m  F (R).
?

?

?
Given a logical interpretation M , we define a related one M



 by AM



= F (A)

= G(R).

 |= T .

and RM
Lemma 3. If M |= A then M
Proof. First suppose C  D  T . Note that if C C D, then {E | E C C} 
{E | E C D}, and so F (C)  F (D). Because of the restriction on the TBOX
language, C = A or C = . In the case of A, we have AM
= F (A); in the
  F (C).
case of , we have M
Similarly, because of the language restriction, D = A or D = A, and so either
way F (D)  DM
(since F (A)  F (A) by Lemma 1). It then follows that
  F (C)  F (D)  DM
Now suppose     T . As above, we have that if  R , then { |  R
= G()  G() =
?

?

?
}  { |  R }, and so G()  G(). It follows that M

  F () by Lemma 2. In both cases, CM


.







 M


.

Lemma 4. If M |= A then M
Proof. We consider the four cases of assertions in A.

 |= A.

Suppose A(n)  A. Then n  MIN(A), so n  E(A)  F (A). Therefore,
 |= A(n).

Suppose A(n)  A. Then n  MIN(A) and n  AM . Now suppose that
D C A for some D. Then n  MIN(D) since otherwise A |= T . Since n  AM ,
n  E(D). Since this holds for any D C A, n  F (A) and hence M
 |= A(n).
Suppose R(n, m)  A. Then (n, m)  MIN(R), so (n, m)  H (R)  G(R).
Therefore, M
Finally, suppose R(n, m)  A. Then (n, m)  RM . Now suppose that  R
R for some . Then (n, m)  MIN() since otherwise A |= T . Since (n, m) 
RM , (n, m)  H (). Since this holds for any  R R, (n, m)  G(R) and hence
 |= R(n, m).
?

?

?
 |= R(n, m).

G. De Giacomo and H. Levesque

Lemma 5. T |= (QT  Q).
Proof. Assume that M |= T and prove by induction on |Q| that if M |= QT
then M |= Q. Here are the base cases only.
Suppose Q = A(n) and M |= QT . So for some C C A, M |= C[n]. Since
M |= T , M |= A(n).
Suppose Q = A(n) and M |= QT . So for some A C D, M |= D[n]. Since
M |= T , M |= A(n).
Suppose Q = R(n, m) and M |= QT . So for some  R R, M |= [n, m].
Since M |= T , M |= R(n, m).
Suppose Q = R(n, m) and M |= QT . So one of the following: for some
R R , M |= [n, m] or for some R C D, M |= D[n] or for some R C
D, M |= D[m]. In all cases, since M |= T , M |= R(n, m).

Lemma 6. If M |= A and M
Proof. The proof is by induction on |Q|. Here are the base cases only.
 |= A(n). So for some C C A, n  E(C). There are two cases:
n  MIN(C) or n  CM . Either way, since M |= A, M |= C[n]. So M |= QT .
 |= A(n). So for every C C A, n  E(C) and so n  E(A). So
for some A C D, n  DM , and thus M |= D[n]. Therefore M |= QT .
 |= R(n, m). So for some  R R, (n, m)  H (). There are two
Suppose M
cases: (n, m)  MIN() or (n, m)  M . Either way, since M |= A, M |= [n, m].
So M |= QT .
 |= R(n, m). So for every  R R, (n, m)  H () and so
Suppose M
(n, m)  H (R). Then (n, m)  RM  (E(R)  E(R)). There are three cases:
(n, m)  RM , in which case for some R R , M |= [n, m], namely  = R;
or n  E(R) in which case for some R C D, n  DM , and so M |= D[n]; or
m  E(R) in which case for some R C D, m  DM , and so M |= D[m].
In all cases, M |= QT .
?

?

?
 |= Q, then M |= QT .

Suppose M

Suppose M

Finally we are ready to prove the main claim.

Main Claim. T  A |= Q iff A |= QT .
Proof. () Suppose A |= QT . Let M be any logical interpretation such that
M |= T  A. Since, M |= A and A |= QT , M |= QT . Since M |= T , M |= Q by
Lemma 5. Therefore, T  A |= Q.
() Suppose A |= QT . Then, there is an M such that M |= A and M |= QT .
 |= Q.
?

?

?
 |= A. By Lemma 6, M

 |= T . By Lemma 4, M

By Lemma 3, M
Therefore, T  A |= Q.

Acknowledgments. This research has been partially supported by the EU IP project
n. FP7-318338 Optique (Scalable End-user Access to Big Data).
?

?

