Mapping Analysis in Ontology-Based Data

Access: Algorithms and Complexity

Domenico Lembo1(B), Jose Mora1, Riccardo Rosati1, Domenico Fabio Savo1,

and Evgenij Thorstensen2

1 Sapienza Universit`a di Roma, Rome, Italy
{lembo,mora,rosati,savo}@dis.uniroma1.it

2 University of Oslo, Oslo, Norway

evgenit@ifi.uio.no

Abstract. Ontology-based data access (OBDA) is a recent paradigm
for accessing data sources through an ontology that acts as a concep-
tual, integrated view of the data, and declarative mappings that connect the ontology to the data sources. We study the formal analysis of
mappings in OBDA. Specifically, we focus on the problem of identifying mapping inconsistency and redundancy, two of the most important
anomalies for mappings in OBDA. We consider a wide range of ontology
languages that comprises OWL 2 and all its profiles, and examine mapping languages of different expressiveness over relational databases. We
provide algorithms and establish tight complexity bounds for the decision problems associated with mapping inconsistency and redundancy.
Our results prove that, in our general framework, such forms of mapping
analysis enjoy nice computational properties, in the sense that they are
not harder than standard reasoning tasks over the ontology or over the
relational database schema.

1 Introduction

Ontology-based data access (OBDA) [18] is a recent paradigm for accessing
data sources through an ontology (also called TBox) that acts as a conceptual,
integrated view of the data, and declarative mappings that connect the ontology
to the data sources. The framework of OBDA has received a lot of attention in
the last years: many theoretical studies have paved the way for the construction
of OBDA systems (e.g., [6,11,19] and the development of OBDA projects for
enterprise data management in various domains [2,15].

One important aspect in OBDA concerns the construction of a system spec-
ification, i.e., defining the ontology and the mappings over an existing set of
data sources. Mappings are indeed the most complex part of an OBDA specifi-
cation, since they have to capture the semantics of the data sources and express
such semantics in terms of the ontology. More precisely, a mapping is a set
of assertions, each one associating a query (x) over the source schema with
a query (x) over the ontology. The intuitive meaning of a mapping assertion is that all the tuples satisfying the query (x) also satisfy the query
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 217234, 2015.
DOI: 10.1007/978-3-319-25007-6 13

D. Lembo et al.

(x). We write a mapping assertion as (x) ; (x). As an example, consider tabP(x, y, z) ; person(x), name(x, y), which maps the ontology predicates
person and name to the database relation tabP, thus indicating how ontology
instances can be constructed from the data retrieved at the sources.

The first experiences in the application of the OBDA framework in realworld scenarios (e.g., [2,15]) have shown that the semantic distance between the
conceptual and the data layer is often very large, because data sources are mostly
application-oriented: this makes the definition, debugging, and maintenance of
mappings a hard and complex task. Such experiences have clearly shown the
need of tools for supporting the management of mappings.

However, no specific approach (with the exception of [17]) has explicitly dealt
with the problem of mapping analysis in the context of OBDA. The work on
schema mappings in data exchange has considered the problem of analyzing the
formal properties of mappings, although in a different framework. Indeed, in data
exchange the ontology is replaced by a relational schema, called target schema,
possibly equipped with tuple-generating dependencies and equality-generating
dependencies [3,10]. Such kinds of dependencies are not able to capture arbitrary
ontology languages, such as those considered in this paper. Also, in data exchange
suitable conditions are imposed on the interaction among database dependencies
to guarantee that finite instances for the target schema exist that are coherent
with the database at the sources, the mapping, and the target dependencies.
Such conditions are normally not imposed in OBDA, where the focus is not
on moving data from the sources to the target, and indeed we do not adopt
them. Among the works on data exchange, [12] is the closest to our approach: it
proposes techniques for the optimization and normalization of schema mappings,
in particular, finding a global, semantically equivalent transformation of a set of
mappings that is optimal with respect to some minimality criterion.

In a recent paper [17], we started providing a theoretical basis for mapping
management support in OBDA, focusing on the formal analysis of mappings in
ontology-based data access. In particular, in that paper the two most important
semantic anomalies of mappings have been analyzed: inconsistency and redun-
dancy. Roughly speaking, an inconsistent mapping for an ontology and a source
schema is a specification that gives rise to logical contradictions with the ontology and/or the source schema. Then, a mapping M is redundant with respect
to an OBDA specification if adding M to the specification does not change
its semantics. Verifying whether a mapping is affected by these anomalies is a
crucial task in OBDA. A designer that is creating (or modifying) the mapping
needs to know whether the new (or updated) mapping leads to an inconsistency.
Given the complexity of the OBDA specification, this is very hard to check man-
ually. Similarly, a redundant mapping is not wanted, since it is very difficult to
maintain; furthermore, it may affect the performance of query answering [8].

The work presented in [17] has defined both a local notion of mapping inconsistency and redundancy, which focuses on single mapping assertions, and a
global notion, where inconsistency and redundancy is considered with respect
to a whole mapping specification (set of mapping assertions). In this paper,
?

?

?
we study the computational properties of verifying both local and global mapping inconsistency and redundancy in an OBDA specification. We consider a
wide range of ontology languages that comprises the description logics underlying OWL 2 and all its profiles (OWL 2 EL, OWL 2 QL, and OWL 2 RL),1
and examine mapping languages of different expressiveness (the so-called GAV
and GLAV mappings [9]) over sources corresponding to relational databases. We
provide algorithms and establish tight complexity bounds for the decision problems associated with both local and global mapping inconsistency and mapping
redundancy, for both GAV mappings and a large class of GLAV mappings, and
for both combined complexity and TBox complexity (which only considers the
size of the TBox).

The outcome of our analysis is twofold. First, in our framework, it is possible
to define general and modular techniques that are able to reduce the analysis
of mappings to the composition of standard reasoning tasks over the ontology
(inconsistency and instance checking, query answering) and over the data sources
(query answering and containment). This is a non-trivial result, because mappings are formulas combining both ontology and data source elements. Moreover,
the above forms of mapping analysis enjoy nice computational properties, in the
sense that they are not harder than the above mentioned standard reasoning
tasks over the ontology and the data sources (see Figure 1 and Figure 2 at the
end of the paper).

The above results allow us to conclude that, in our OBDA framework, the
formal analysis of mappings is feasible, at least for ontology languages enjoying
nice computational properties, as in the case of the three OWL 2 profiles.

The paper is organized as follows. In Section 2 we recall OBDA specifications
and the formal notions of mapping inconsistency and redundancy in OBDA.
In Section 3 we study the complexity of checking local and global mapping
inconsistency, while in Section 4 we study the complexity of verifying local and
global mapping redundancy. We conclude the paper in Section 5.

2 Preliminaries

In the following, we assume to have three pairwise disjoint, countably infinite
alphabets: an alphabet T of ontology predicates, an alphabet S of source
schema predicates, and an alphabet C of constants.
Source Schemas. A source schema S is a relational schema containing relations in S, possibly equipped with integrity constraints (ICs). A legal instance
D for S is a database for S (i.e., a finite set of ground atoms over S and the
constants in C) that satisfies the ICs of S. We denote by Const(D) the set of
constants occurring in D.

We consider simple schemas, i.e., relational schemas without ICs, and FD
schemas, i.e., simple schemas with functional dependencies (FDs) [1]. We adopt
standard notions for conjunctive queries (CQs) over relational schemas [1], and

1 http://www.w3.org/TR/owl2-profiles/

D. Lembo et al.

by a CQ over a source schema S we mean a CQ over the alphabet of S. With
(x) we denote a CQ with free variables x. The number of variables in x is the
arity of the query. A Boolean CQ is a CQ without free variables. Given a CQ q
over S and a legal instance D for S, eval(q, D) denotes the evaluation of q over
D. Throughout the paper S will always denote a source schema.
Ontologies. We consider ontologies expressed in some Description Logic (DL)
language LO and use standard DL notions [16]. In particular, a DL ontology O
is pair T , A, where T is the TBox and A is the ABox. O, T , and A will
always have the same meaning in the paper. As in the W3C standard OWL,
we do not interpret ontologies under the Unique Name Assumption. We denote
with Mod(O) the set of models of O, and with O |=  the fact that O entails
a sentence . Also, by ontology inconsistency we mean the task of deciding
whether Mod(O) = , and by instance checking the task of deciding whether
O |= , where  is a ground atom. By CQs over O we mean CQs over the
alphabet of the TBox of O, and by CQ entailment the task of checking whether
O |= q, where q is a Boolean CQ. In the following, we consider DLs that are the
logical basis of the W3C standard OWL and of its profiles, i.e., SROIQ [14],
which underpins OWL, DL-LiteR [5], which is the basis of OWL 2 QL, RL [16],
a simplified version of OWL 2 RL, and EL, a slight extension of the DL EL [4],
which is the basis of OWL 2 EL.
Mappings. A mapping assertion m from a source schema S to a TBox T has
the form (x) ; (x), where (x), called the body of m, and (x), called the
head of m, are queries over S and T , respectively, both with free variables x,
which are called the frontier variables. The number of variables in x is the arity
of the mapping assertion. Given a mapping assertion m, we also use FR(m) do
denote the frontier variables x, head(m) to denote the query (x), and body(m)
to denote the query (x). We also remark that queries used in our mappings,
besides variables, may contain constants from C. A mapping M from S to T is
a finite set of mapping assertions from S to T . Hereinafter M will always denote
a mapping.

In principle, (x) and (x) can be specified in generic query languages. The
literature on data integration and OBDA has mainly considered (x) expressed
in a (fragment of) first-order logic, and (x) expressed as a CQ [9,17,18]. In
this paper, we focus on the notable cases in which (x) is a CQ over S and (x)
is as follows:
 (x) is a CQ over T . This is a powerful form of GLAV mapping [9], and is
among the most expressive types of mappings studied in the literature. We
refer to it simply as GLAV.

 (x) is a CQ with a bounded number of existential variables in the head. This

is a practically relevant form of GLAV mappings, which we call GLAVBE.

 (x) is a CQ without existential variables in the head. Such mappings are the
most used in OBDA applications [2,13], and are a special case of the W3C
standard R2RML mappings [7]. According to the data integration literature,
we call them GAV.
?

?

?
We say that a mapping assertion m is active on a source instance D if
eval(body(m), D) is a non-empty set of tuples of constants. A mapping M is
active on D if all its mapping assertions m  M are active on D.

Without loss of generality, we assume that different mapping assertions use
different variable symbols. A freeze of a set of atoms  is a set of ground atoms
obtained from  by replacing every variable with a fresh distinct constant. In
this paper, the freeze is always used in the context of a mapping M, so it suffices
to assume that fresh constants do not appear in M. Different freezes of the same
set of atoms are equal up to renaming of constants. Thus, in the following we
assume, without loss of generality, that the freeze of a set of atoms  is unique
and is obtained by replacing each variable occurrence x with a fresh constant
cx, and we denote it by freeze( ).

Given a mapping assertion m of arity n and an n-tuple of constants t, we
denote by m(t) the mapping assertion obtained by replacing FR(m) in m with
the constants in t.
OBDA Specifications. An OBDA specification is a triple J = T ,S,M.
The semantics of J is given with respect to a database instance D legal for S:
a model for J w.r.t. D is a FOL interpretation I over the alphabet T  C
that satisfies both T and M. Formally, we say that I satisfies the mapping
M if for each assertion m  M and each tuple of constants t such that t 
eval(body(m), D) we have that I |= head(m(t)). The set of models of J w.r.t.
D is denoted with Mod(J , D). Also, we use (J , D) to denote J with source
instance D, say that (J , D) is inconsistent if Mod(J , D) = , and denote with
(J , D) |=  the entailment of a sentence  by (J , D).
Example 1. We consider a source schema S where the plants relation contains
data on extraction facilities, while the eZones relation contains data on the areas
used for oil and gas extraction. Below, the underlined attributes represent the
keys of the relations, which can be expressed by FDs.

plants(id pl,pl typ,id zn)

eZones(id zn,zn typ)

The following RL TBox models a very small portion of the domain of oil and
gas production extracted from an ontology developed within the Optique EU
project2. In particular, the TBox focuses on the facilities (concept Facility) used
in the oil and gas extraction and on the geographical areas (concept Area) in
which they are located (role locatedIn). Facilities that are located in a marine
area (concept MarArea) are platforms (concept Platform).
T = { Platform  Facility,
locatedIn  Area

MarArea  Area,
Facility  Area   locatedIn.MarArea  Platform }

locatedIn  Facility,

An example of a GAV mapping M from S to T follows:
m1 : plants(x, y, z)
m2 : plants(x, pl, y
) ; Platform(x
)
m3 : eZones(z, mz) ; MarArea(z
).
2 http://www.optique-project.eu/

; Facility(x), locatedIn(x, z)

D. Lembo et al.

Mapping Inconsistency and Redundancy. The following definitions are
taken from [17].
In brief, a mapping assertion m from S to T is head-inconsistent or bodyinconsistent if head(m) or body(m) have certainly an empty evaluation in every
model for T or legal instance for S, respectively.
Definition 1 (mapping head-inconsistency). Let T be a TBox, S a source
schema, and m : (x) ; (x) a mapping assertion from S to T . We say that
m is head-inconsistent for T if T |= x.((x)).
Example 2. Let T and S be as in Example 1. Consider the following mapping
assertion:

m : plants(x, pl, z) ; Platform(x), MarArea(x)
Then, m is head-inconsistent for T since T |= Platform  MarArea  .
Definition 2 (mapping body-inconsistency). Let T be a TBox, S a source
schema, and m : (x) ; (x) a mapping assertion from S to T . We say that
m is body-inconsistent for S if S |= x.((x)).
Example 3. Let T and S be as in Example 1. Then, the following mapping
assertion is body-inconsistent for S.
m : plants(x, pl, z), plants(x, ref, k) ; Facility(x)

We extend the inconsistency notions to whole mapping assertions and whole

mappings.
Definition 3 (local mapping inconsistency). Let T be a TBox, S a source
schema, and m : (x) ; (x) a mapping assertion from S to T . We say that
m is inconsistent for T ,S if m is head-inconsistent for T or body-inconsistent
for S.
Definition 4 (global mapping inconsistency). Let J = T ,S,M be an
OBDA specification. We say that M is globally inconsistent for T ,S if there
does not exist a source instance D legal for S such that M is active on D and
Mod(J , D) = .

Intuitively, it is impossible to consistently activate all the assertions of a

globally inconsistent mapping simultaneously.
Example 4. Let J = T ,S,M be an OBDA specification where T and S are
as in Example 1. Suppose that the mapping M contains the following mapping
assertions:

m1 : plants(x, y, z)
m2 : plants(x, pl, z

; Area(x)

) ; Platform(x

), locatedIn(x, z

)
?

?

?
It is easy to see that M is globally inconsistent for T ,S, because T |= Platform
Area   and every activation of m2 also activates m1, thus implying Platform(x)
and Area(x) for the same individual x.

Then, we recall the notion of global mapping redundancy.

Definition 5 (global mapping redundancy). Let J = T ,S,M be an
OBDA specification and let M be a mapping from S to T . We say that M
is globally redundant for J if, for every source instance D that is legal for S,
Mod(T ,S,M, D) = Mod(T ,S,M  M, D).

Informally, a mapping M is redundant for an OBDA specification J if

adding M to J produces a specification equivalent to J .
Example 5. Let T ,S,M be an OBDA specification, where T and S are as in
Example 1, and M is as follows:
; locatedIn(x, z)
m1 : plants(x, y, z), eZones(z, mz)
m2 : eZones(x, mz)
; MarArea(x
m3 : plants(y, pl, z
), eZones(z, mz) ; Platform(y
Then, {m3} is globally redundant for T ,S,{m1, m2}.

)
)

Finally, local mapping redundancy is a special case of global mapping redundancy in which the mappings M and M are both composed of a single assertion.

3 Complexity of Mapping Inconsistency

We now study local and global mapping inconsistency and show that, for every
DL LO, both problems have the same TBox complexity as ontology inconsistency
in LO. We also establish combined complexity results for the DLs considered in
this paper.

We start with some auxiliary definitions.

Definition 6 (minimal instance activating a mapping). Let M be a mapping and let S be a source schema. A minimal instance for S that activates M
is a source instance D legal for S such that M is active on D and, for every
source instance D legal for S such that M is active on D, there exists a homomorphism h from Const(D) to Const(D) that maps constants occurring in M
to themselves and is such that h(D)  D, where h(D) = {r(h(c1), . . . , h(cn)) |
r(c1, . . . , cn)  D}.

Given a GLAV mapping assertion m of arity n, we denote by cvars(m)
the sequence of frontier variables occurring together with an existential variable in an atom of the head of m. Moreover, given an n-tuple of constants t, we denote by cvars(m)[t] the tuple of constants obtained from
cvars(m) by replacing each occurrence of a frontier variable with the corresponding constant of t. For instance,
if m is the assertion (x, w) ;
R(x, y), S(y, z), T (z, w), R(x, z), S(w, x), then cvars(m) is the tuple of variables
x, w, x, and if t = a, b then cvars(m)[t] is the tuple of constants a, b, a.

D. Lembo et al.

Definition 7 (retrieved ABox). Given a mapping M from S to T
the ABox retrieved by M from D,
and an instance D legal
is the ABox defined as follows: Retr(M, D) =
denoted by Retr(M, D),
{freezeH (head(m(t))) | t  eval(body(m), D)}), where freezeH (head(m(t))) is
the set of atoms obtained from head(m(t)) by replacing each occurrence of a
(existential) variable x with the fresh constant cx,cvars(m)[t].

for S,

3.1 Local Mapping Inconsistency

We start from the following property (whose proof is trivial) for the problem of
head inconsistency.
Lemma 1. Let m be a GLAV mapping assertion, T a TBox, and let A =
freeze(head(m)). Then, m is head-inconsistent for T iff T ,A is inconsistent.
Conversely, inconsistency of an ontology T ,A can be immediately reduced
to head inconsistency, considering T as the TBox of the OBDA specification,
and constructing a GAV mapping assertion m (with no frontier variables) whose
head is the conjunction of the ABox assertions in A. Consequently, the following
property holds.
Lemma 2. For both GAV and GLAV mappings and for every ontology language
LO, the combined (resp., TBox) complexity of mapping head inconsistency is the
same as the combined (resp., TBox) complexity of ontology inconsistency in LO.
Now, from the definition of local mapping inconsistency, it follows that the
TBox complexity of local mapping inconsistency is the same as the TBox complexity of mapping head inconsistency. Therefore:
Theorem 1. For both GAV and GLAV mappings and for every ontology language LO, the TBox complexity of local mapping inconsistency is the same as
the TBox complexity of ontology inconsistency in LO.

The above theorem implies row 1 in Figure 1.
Moreover, from the definition of local mapping inconsistency, it follows that,
for simple source schemas, local mapping inconsistency corresponds to mapping
head inconsistency (since all mapping assertions are trivially body-consistent).
Therefore:
Corollary 1. For simple source schemas, for both GAV and GLAV mappings,
and for every ontology language LO, the combined complexity of local mapping
inconsistency is the same as the combined complexity of ontology inconsistency
in LO.

The above result is summarized in row 1 in Figure 2.
Then, we analyze the case of FD schemas. We start by defining the algorithm freezeFD(M,S), which takes as input a mapping M and a source
schema S, and applies the chase procedure [1] to the database instance D =
?

?

?
mM freeze(body(m)) using the functional dependencies of S, and considering
the constants occurring in D but not occurring in M as unifiable terms (since
they act as soft constants differently from the constants occurring in M). Such
a chase procedure runs in PTIME and may end up in two ways: (i) it fails, i.e.,
it derives that two constants occurring in M should be equal (which violates
the Unique Name Assumption of databases); (ii) it returns a database D that
is obtained from D by unifying constants occurring in D but not occurring in
M according to the equalities induced by the functional dependencies.

We are now able to show the following lemma.

Lemma 3. Let S be a source schema and let M be a mapping. Deciding whether
there exists a minimal instance D for S that activates M, and computing such
a D if it exists, can be done: (i) in linear time, if S is a simple schema; (ii) in
PTIME, if S is an FD schema.
Proof. The proof easily follows from the fact that the algorithm freezeFD(M,S)
runs in PTIME, and computes a minimal instance D for S that activates M iff
such an instance exists. In particular, for property (i), it is easy to verify that,
if S is a simple schema, then
mM freeze(body(m)) is a minimal instance for
S that activates M. For property (ii), in the case when S is an FD schema, if
the algorithm freezeFD(M,S) fails, then there exists no legal instance for S that
activates M; otherwise, the algorithm returns a database D that corresponds
to the application of the equalities induced by the functional dependencies over
the constants occurring in D but not occurring in M. Therefore, there exists a
endomorphism h of the constants in D that is the identity for the constants of
M and is such that h(D) = D. Due to the property of the chase, it follows that

such an instance D is a minimal instance for S that activates M.
?

?

?
We can now prove the following property.

Theorem 2. For both GAV and GLAV mappings, and for FD schemas, the
combined complexity of local mapping inconsistency is PTIME-complete for
DL-LiteR, RL, and EL, and is N2EXPTIME-complete for SROIQ.
Proof. To decide local mapping consistency of m, besides head inconsistency we
also have to check body inconsistency of m. This corresponds to decide whether
there exists a minimal instance for S that activates the mapping {m}. By Lemma
3, this can be done in PTIME in the case of FD schemas. Moreover, consistency
of a database D with respect to an FD schema S can be immediately reduced
to mapping body inconsistency, by creating a GAV mapping assertion whose
body contains the conjunction of the facts in D. In the case of FD schemas,
this provides a PTIME lower bound for body inconsistency, and hence for local
mapping inconsistency. The lower bound in the case of SROIQ follows from

the lower bound for head inconsistency.

The above results are summarized in row 1 in Figure 2.

D. Lembo et al.

3.2 Global Mapping Inconsistency

To define a technique for global mapping inconsistency, we start by showing the
following property.
Theorem 3. Let J = T ,S,M be an OBDA specification. Then, M is globally
inconsistent for T ,S iff either freezeFD(M,S) fails or the instance D returned
by freezeFD(M,S) is such that (J , D) is inconsistent.
Proof. The proof of the only-if part is trivial. For the if part, we will prove the
contrapositive: If M is not globally inconsistent for T ,S, then freezeFD(M,S)
returns an instance D such that (J , D) is consistent.
Let D be a source instance legal for S such that M is active on D, and
let I be a model of (J , D). Then, freezeFD(M,S) does not fail and returns
an instance D. Since D is minimal, Definition 6 implies that there exists a
homomorphism h from the constants of D to the constants of D such that
h(D)  D. Now let I be the interpretation obtained from I by changing the
interpretation of constants as follows: If c occurs in D then cI
= h(c)I, otherwise

cI

= cI. It is immediate to verify that I is a model for J w.r.t. D.
The above theorem immediately implies the following algorithm for deciding
the global inconsistency of a GLAV mapping M for a TBox T and a source
schema S.
Algorithm GlobalInconsistency:
Input: OBDA specification T ,S,M

if (a) algorithm freezeFD(M,S) fails
then return true
else

let D be the instance returned by freezeFD(M,S);
if (b) (T ,S,M, D) is inconsistent
then return true else return false

The complexity of step (a) of the algorithm, i.e., deciding the existence and
computing a minimal instance for S that activates M, has been established
by Lemma 3. It remains to analyze the complexity of checking inconsistency of
(T ,S,M, D). To this aim, we present two techniques for deciding the inconsistency of (T ,S,M, D). First, we use the following property, whose proof easily
follows from Definition 7.
Lemma 4. For every model I of (T ,S,M, D) there exists a model I of
T , Retr(M, D) such that I and I coincide except for the interpretation of
the constants in Const(Retr(M, D)) \ Const(D). The converse also holds.

From the above lemma, to decide inconsistency of (T ,S,M, D), we can

compute the ABox A = Retr(M, D) and then check inconsistency of T ,A.
Example 6. Let J = T ,S,M be the OBDA specification of Example 4. We show how algorithm GlobalInconsistency runs on J . First,
?

?

?
that D = {plants(cx, cy, cz), plants(cx, pl, cz)}. The

instance D for S by means of the
the algorithm computes a minimal
algorithm freezeFD (cf. Lemma 3).
In our example, this actually coincides with computing freeze(body(m)) for each mapping m  M. Hence,
sec-
we have
ond step consists in checking if J , D is consistent. To this end, one
can exploit Lemma 4 and: (i) compute the ABox A = Retr(M, D),
{Area(cx), Area(cx), Platform(cx), Platform(cx), locatedIn(cx , cz),
which
locatedIn(cx, cz)} and (ii) check the consistency of the ontology T ,A.
Since, e.g., both Area(cx) and Platform(cx) belong to A, and since
T |= Platform  Area  , the ontology T ,A is inconsistent. Hence,
the algorithm returns true.

is

Now, observe that the cost of computing Retr(M, D) does not depend on
the size of the TBox. This implies that, with respect to TBox complexity, the
complexity of ontology inconsistency is an upper bound for global mapping
inconsistency. Conversely, ontology inconsistency can be easily reduced to global
mapping inconsistency, by creating a GAV mapping assertion (with no frontier
variables) whose head is the conjunction of the ABox assertions in A. Conse-
quently:
Theorem 4. For both simple and FD schemas, for both GAV and GLAV map-
pings, and for every ontology language LO, the TBox complexity of global mapping inconsistency is the same as the TBox complexity of ontology inconsistency
in LO.

The above theorem implies row 2 in Figure 1.
To establish combined complexity, we define a second way to decide incon-

sistency of (T ,S,M, D). We start from the following property.
Lemma 5. Let M be a GLAVBE mapping, and let D be a source instance. Then,
the size of Retr(M, D) is polynomial with respect to the size of M and D.
Proof. When M is a GAV mapping, from Definition 7 it follows that the number
of assertions in Retr(M, D) is bounded by (nc  nv) + (nr  n2
v), where nc is
the number of concepts, nr is the number of roles, and nv is the number of
constants occurring in D and M. When M is a GLAVBE mapping, observe
that, by Definition 7, the number of fresh constants nf occurring in Retr(M, D)
is not greater than m k nk, where m is the number of mapping assertions in M,
n is the number of constants in D, and k is the maximum number of occurrences
of existential variables in the head of a mapping assertion (observe that k is
the maximum length of cvars(m) in the definition of Retr(M, D)). Since k is
bounded in GLAVBE mappings, we derive that such a number of constants nf
is polynomially bounded. And since the number of assertions in Retr(M, D) is
bounded by (nc  nw) + (nr  n2
w), where nc is the number of concepts, nr is the

number of roles, and nw = nv + nf , the thesis follows.

D. Lembo et al.

Notice that the above property does not hold for arbitrary GLAV mappings
(for which Retr(M, D) may be of exponential size), so in the rest of this section
we focus on GLAVBE mappings. Notice also that the above lemma does not
imply that for GLAVBE mappings Retr(M, D) can be computed in polynomial
time with respect to the size of M and D: conversely, it is immediate to verify
that deciding whether an ABox assertion belongs to Retr(M, D) is an NP-hard
problem.
From the above lemma and from Lemma 4, it follows that, in the case of
GLAVBE mappings, inconsistency of (T ,S,M, D) can be decided by checking
the existence of a polynomial subset A of Retr(M, D) such that T ,A is
inconsistent.

Given a mapping assertion m, a grounding for m is the mapping assertion obtained from m by replacing every variable in m with a constant
 m 
symbol. A grounding for a mapping M is a set {mg
M s.t. mg is a grounding for m}. Now let D be a source instance. A grounding
G for M is generated by D if, for every mg  G, every atom in body(mg) occurs
in D. Given a grounding G for M, the ABox induced by G, denoted as A(G), is
defined as the set of atoms occurring in the heads of the mapping assertions of G.
Lemma 6. Let M be a GLAVBE mapping and let D be a source instance. Then:
(i) for every grounding G for M that is generated by D, if T ,A(G) is incon-
sistent, then T , Retr(M, D) is inconsistent; (ii) there exists a grounding G for
M that is generated by D such that G has polynomial size with respect to M and
D, and T ,A(G) is inconsistent iff T , Retr(M, D) is inconsistent.
Proof. The proof of (i) follows from the fact that there exists a homomorphism
h from Const(A(G)) \ Const(D) to Const(Retr(M, D)) such that h(A(G)) 
Retr(M, D). Consequently, if I is a model for T , Retr(M, D), we can immediately derive a model I for T ,A(G)) from I by just changing the interpretation
= h(c)I for every c  Const(A(G)) \ Const(D),
of the constants, defining cI
= cI otherwise. Then, the proof of (ii) easily follows from (i), Lemma 5
and cI
and the fact that, by definition of Retr(M, D), there exists a grounding G for
M such that A(G) is equal to Retr(M, D).
?

?

?
|

Consequently, the following algorithm is able to decide inconsistency of

(T ,S,M, D).

Algorithm OBDAInconsistency:
Input: OBDA specification T ,S,M with M GLAVBE mapping, source instance D

if there exists a polynomial grounding G for M
such that G is generated by D and the ontology T ,A(G) is inconsistent
then return true else return false

We are now able to analyze the combined complexity of the algorithm GlobalInconsistency when step (b) is executed through the algorithm OBDAInconsis-
tency. As shown by Lemma 3, step (a) can always be executed in polynomial
time. Then, if the ontology inconsistency check is in PTIME, check (b) can
?

?

?
be executed in nondeterministic polynomial time. Consequently, the algorithm
GlobalInconsistency provides an NP upper bound for DL-LiteR, RL, and EL,
while it provides a N2EXPTIME upper bound for SROIQ.
Concerning the lower bounds, the one for SROIQ is trivial, while the NP
bound for the other three cases can be proved by an easy reduction of conjunctive
query containment in relational databases. Consequently:
Theorem 5. For both simple and FD schemas, and for both GAV and GLAVBE
mappings: (i) if the ontology language is DL-LiteR, RL, or EL, then the combined complexity of global mapping inconsistency is NP-complete; (ii) if the
ontology language is SROIQ, then the combined complexity of global mapping
inconsistency is N2EXPTIME-complete.

The above results are summarized in row 2 in Fig. 2.

4 Complexity of Mapping Redundancy

We now show that local and global mapping redundancy have the same TBox
complexity as instance checking for GAV mappings and CQ entailment over an
ontology for GLAV mappings. We also study the combined complexity for the
DLs considered in this paper. We focus on the global case only, since as we said,
the local redundancy is a special case of the global one. Also, observe that a
mapping M is globally redundant for an OBDA specification iff each subset of
M is redundant. We thus consider only the case in which M = {m}, and with
a slight abuse of notation, we call such case global redundancy of a mapping
assertion m for J .
From now on, we do not consider the trivial case when m is body-inconsistent
for S. Under this assumption, a minimal instance for S that activates {m} always
exists (and the algorithm freezeFD does never fail for every mapping M and
source schema S as input). We notice, however, that all the complexity results
of this section also hold without this assumption.
Theorem 6. Let J = T ,S,M be an OBDA specification and m a mapping
assertion. Then, m is globally redundant for J iff there exists a minimal instance
D for S that activates {m} such that Mod(J , D) = Mod(T ,S,M  {m}, D).
Proof (sketch). The proof of the only-if part is trivial. As for the if part, since
a minimal instance has a homomorphism to every other instance, the fact that
the models for a minimal instance are the same can be used to show that, for
every legal instance D for S, a model for (T ,S,M, D) has to be a model for

(T ,S,M  {m}, D) too.
Based on the above theorem, below we provide an algorithm that establishes
whether m is globally redundant for J by checking whether a suitable Boolean
CQ is entailed by J coupled with the minimal instance that activates {m}
returned by the algorithm freezeFD(M,S) (cf. Lemma 3). In the following, with
a little abuse of notation, we denote with freeze(FR(m)) the tuple obtained by
freezing the frontier variables of m.

D. Lembo et al.

Algorithm mapRedundancy:
Input: OBDA specification T ,S,M, mapping assertion m
(a) D  freezeFD({m},S);
let  be the substitution derived by freezeFD({m},S);
tF  (freeze(F R(m)));
if (b) (J , D) |= head(m(tF ))
then return true else return false

In the algorithm,  denotes the substitution of terms derived by the application of freezeFD({m},S), i.e.,  = {x1  y1, . . . , xn  yn} where each yi
is a constant (either fresh or non-fresh) and each xi
is a fresh constant in
freeze(body(m));  is applied to the tuple obtained by freezing the frontier variables of m, in order to propagate the term substitutions derived by the chase to
such a tuple. Notice that, for simple source schemas,  is the identity and thus it
has no effect. Finally, mapRedundancy verifies whether the Boolean query corresponding to the head of the mapping m whose frontier variables are substituted
with tF is entailed by (J , D).

The following theorem states that mapRedundancy is sound and complete
with respect to the problem of establishing global mapping redundancy (termi-
nation of the algorithm is straightforward).
Theorem 7. Let J = T ,S,M be an OBDA specification and m a mapping
assertion. Then, m is globally redundant for J iff mapRedundancy(J , m) returns
true.

As shown in Section 3, step (a) can be executed in polynomial time for both
simple schemas and FD schemas. As for step (b), the first technique we present
is tailored to establish TBox complexity of global mapping redundancy. We first
give the following lemma.
Lemma 7. Let J = T ,S,M be and OBDA specification, D a minimal
instance for S that activates M, and q a Boolean CQ. Then, (J , D) |= q iff
T , Retr(M, D) |= q.
According to the above result, step (b) of mapRedundancy can be performed by first computing the ABox Retr(M, D), and then checking whether
(T , Retr(M, D)) |= head(m((freeze(F R(m))))).
Example 7. Consider the OBDA specification J = T ,S,M, where T and S
are as in Example 1, and M is as follows:
m1 : plants(x, y, z), eZones(z, mz) ; locatedIn(x, z)
; MarArea(x
m2 : eZones(x, mz)
).
Moreover, consider the following mapping assertion:
m3 : plants(y, pl, z), eZones(z, mz) ; Platform(y).
?

?

?
The algorithm mapRedundancy first computes D = freezeFD({m},S) =
{plants(cy, pl, cz), eZones(cz, mz)}. Then,
it produces the Boolean CQ
qm3 = head(m(tF )) = Platform(cy). To check whether (J , D) |= qm3 the
algorithm computes Retr(M, D) = {locatedIn(cy, cz), MarArea(cz)}. Since
locatedIn.MarArea  Platform  T , we have that T , Retr(M, D) |= qm3, and
thus mapRedundancy returns true (i.e., m3 is globally redundant for J ).

For TBox complexity, we notice that in mapRedundancy both step (a) and
the size of Retr(M, D) do not depend on the TBox T . In particular, we have
that:

 In the case of GLAV mappings, the check in step (b) corresponds to a single

 In the case of GAV mappings, the check in step (b) corresponds to a linear
number (in the size of head(m)) of instance checking tasks in the language LO
used for T .
Boolean CQ entailment task in LO.
Thus, mapRedundancy together with the techniques for step (a) and (b) discussed above allows us to obtain upper bounds for the TBox complexity of global
mapping redundancy. More precisely, the complexity of instance checking in LO
is an upper bound for GAV mappings, while the complexity of CQ entailment
in LO is an upper bound for GLAV.
As for lower bounds, we notice that both instance checking and CQ entailment in LO can be easily reduced to local mapping redundancy for GAV and
GLAV mappings, respectively, with a technique similar to the one we used for
Lemma 2.

The following theorem sums up the above results.

Theorem 8. For both simple and FD schemas, and for every ontology language
LO, the TBox complexity of both local and global mapping redundancy for GAV
and GLAV mappings is the same as the TBox complexity of instance checking
in LO and TBox complexity of CQ entailment in LO, respectively.

The above theorem implies rows 3 and 4 in Figure 1.
Similarly to the case of global mapping inconsistency, since executing step
(b) by computing the retrieved ABox Retr(M, D) requires exponential time in
combined complexity, to establish combined complexity of the overall problem
we need to resort to a different strategy for step (b). To this aim, we exploit
a property that generalizes Lemma 6 (which focuses on inconsistency) to query
entailment. From this property, it follows that, for every CQ q that does not
mention constants occurring in Const(Retr(M, D)) \ Const(D), and for every
GLAVBE mapping M, T , Retr(M, D) |= q can be decided by checking the
existence of a polynomial grounding G for M that is generated by D such that
T ,A(G) |= q. Therefore, the following algorithm for checking CQ entailment
over an OBDA specification J and a source instance D follows.

D. Lembo et al.

task

DL-LiteR

RL EL

DL-LiteR

RL EL

local inc. =NLOGSPACE =P =P =N2EXPTIME =NLOGSPACE =P =P =N2EXPTIME
global inc. =NLOGSPACE =P =P =N2EXPTIME =NLOGSPACE =P =P =N2EXPTIME
local red. =NLOGSPACE =P =P =N2EXPTIME
global red. =NLOGSPACE =P =P =N2EXPTIME

=NP =NP
=NP =NP

=NP
=NP

open
open

Fig. 1. TBox compl. of mapping inconsistency and redundancy (for both simple and
FD schemas).

task

DL-LiteR
?

?

?
EL

DL-LiteR

local inc. =NLOGSPACE (SI) =P =P =N2EXPTIME =NLOGSPACE (SI)

global inc.
local red.
global red.

=P (FD)

=NP
=NP
=NP

=NP =NP =N2EXPTIME
=NP =NP =N2EXPTIME
=NP =NP =N2EXPTIME

=P (FD)

=NP
=NP
=NP



GLAVBE

RL EL


=P
=P



=N2EXPTIME



=NP =NP =N2EXPTIME
=NP =NP
=NP =NP

open
open

Fig. 2. Combined compl. of mapping inconsistency and redundancy (SI = simple
schemas, FD = FD schemas).

The result also holds for arbitrary GLAV mappings.



Algorithm CQEntailment:
Input: OBDA specification T , S, M with M GLAVBE mapping, source instance D, CQ q

if there exists a polynomial grounding G for M
such that G is generated by D and T , A(G) |= q
then return true else return false

Then, in the case of GLAVBE mappings we can perform step (b) of mapRe-

dundancy by executing CQEntailment(J , D, head(m(freeze(F R(m)))).

As for combined complexity, in the following we consider simple source
schemas for the lower bounds and FD source schemas for the upper bounds.
First, step (b) can be executed through the nondeterministic algorithm CQEn-
tailment. Consequently, this algorithm provides an NP upper bound for the case
of GLAVBE mappings if, for the ontology language LO, CQ entailment is in NP,
i.e., for DL-LiteR, RL, and EL. The matching NP lower bounds can be proved
already for GAV mappings, by an easy reduction of conjunctive query containment in relational databases. In the case of SROIQ, for GLAVBE mappings
we are not able to even prove decidability of global mapping redundancy (since
decidability of CQ entailment in this language is currently an open problem too),
while for the GAV case we can easily derive a N2EXPTIME exact bound.
Theorem 9. For both simple and FD source schemas, global and local mapping
redundancy are: (i) NP-complete w.r.t. combined complexity for both GAV and
GLAVBE mappings, in the case of DL-LiteR, RL, or EL; (ii) N2EXPTIMEcomplete w.r.t. combined complexity for GAV mappings, in the case of SROIQ.

The above theorem implies rows 3 and 4 in Figure 2.

5 Conclusions

The tables in Fig. 1 and Fig. 2 report the results presented in Sec. 3 and 4.
These results clarify the complexity of the fundamental mapping analysis tasks
studied in this paper.
?

?

?
The analysis presented in this paper can be extended in different directions.
First, it would be interesting to establish tight combined complexity bounds
for general GLAV mappings, and extend our study to other forms of mappings
(beyond GLAV), admitting, for instance, forms of negation in the source queries.
Then, it would be interesting to extend our analysis beyond the OWL frame-
work, considering, e.g., DLs interpreted under the Unique Name Assumption, or
languages of the Datalog+/- family. Finally, we believe that the problems and
techniques studied in this paper may constitute the core of practical tools for the
crucial task of constructing, debugging, and maintaining an OBDA specification.
So, an important direction for future work is the implementation and practical
evaluation of techniques for mapping analysis in OBDA.

Acknowledgments. This research has been partially supported by the EU under FP7
project Optique (n. FP7-318338), and by the RCN under project DOIL (n. 213115).
