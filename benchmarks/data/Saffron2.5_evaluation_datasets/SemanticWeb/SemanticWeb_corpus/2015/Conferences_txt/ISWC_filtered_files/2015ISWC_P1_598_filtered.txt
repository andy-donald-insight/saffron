Concept Forgetting in ALCOI-Ontologies

Using an Ackermann Approach

Yizheng Zhao(B) and Renate A. Schmidt

The University of Manchester, Manchester, UK

yizheng.zhao@student.manchester.ac.uk

Abstract. We present a method for forgetting concept symbols in
ontologies specified in the description logic ALCOI. The method is an
adaptation and improvement of a second-order quantifier elimination
method developed for modal logics and used for computing correspondence properties for modal axioms. It follows an approach exploiting a
result of Ackermann adapted to description logics. An important feature
inherited from the modal approach is that the inference rules are guided
by an ordering compatible with the elimination order of the concept sym-
bols. This provides more control over the inference process and reduces
non-determinism, resulting in a smaller search space. The method is
extended with a new case splitting inference rule, and several simplification rules. Compared to related forgetting and uniform interpolation
methods for description logics, the method can handle inverse roles, nominals and ABoxes. Compared to the modal approach on which it is based,
it is more efficient in time and improves the success rates. The method
has been implemented in Java using the OWL API. Experimental results
show that the order in which the concept symbols are eliminated significantly affects the success rate and efficiency.

1 Introduction

Ontology-based technologies provide novel ways of building knowledge processing systems and play an important role in many different areas, both in research
projects but also in industry applications. Big ontologies contain large numbers
of symbols and knowledge modelled in them is rich and inevitably heterogeneous.
There are thus situations, where it is useful to be able to restrict the ontology
to a subset of the signature and forget those symbols that do not belong to
the subset, for example, when an ontology needs to be analysed by an ontology
engineer to gain an understanding of the information represented in it. Other
examples are scenarios where ontologies are located at separate remote sites
and information is exchanged via agents. Since the vocabularies known to the
agents at the different sites will vary, communication between the agents needs
to be limited to using the common language to avoid ambiguity and confusion
caused by mismatches between the vocabularies of the different agents. At this
point, it would be beneficial if the signature symbols in one ontology that are
not known to the other agents can be eliminated without losing information
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 587602, 2015.
DOI: 10.1007/978-3-319-25007-6 34

Y. Zhao and R.A. Schmidt

required for the communication. In other words, signature symbols belonging
to only one of the ontologies are forgotten, and communication is confined to
information expressed in the shared language of the agents ontologies. Another
use of forgetting is restricting the vocabulary of an ontology to more general
concept symbols, and forgetting those that are more specific, to create a summary of the ontology [29]. Situations where ontologies are published, shared, or
disseminated, but some sensitive parts described in terms of particular signature
symbols need to be kept confidential or unseen to the receiver, are some other
potential applications of forgetting [4]. This is relevant for medical and military
uses, and uses in industry to ensure proprietary information can be kept hidden.
The contribution of this paper is the presentation of a method for forgetting
concept symbols in ontologies specified in the description logic ALCOI. ALCOI
extends the description logic ALC with nominals and inverse roles. Forgetting
concept symbols for ALCOI is a topic where no method is available yet, but a
number of related methods exist. Forgetting can be viewed as the problem that is
dual to uniform interpolation. A lot of recent work has been focussed on uniform
interpolation of mainly TBoxes represented in several description logics, ranging
from ones with more limited expressivity, such as DL-Lite [31] and EL [20,22]
and EL-extensions [11], to more expressive ones, such as ALC [13,14,19,21,30],
ALCH [12], SIF [17] and SHQ [15].

Forgetting can also be viewed as a second-order quantification problem, which
is the view we take in this paper. In second-order quantifier elimination, the aim
is to eliminate existentially quantified predicate symbols in order to translate
second-order formulae into equivalent formulae in first-order logic [3,58,23,24,
26,28]. In uniform interpolation the aim is to eliminate symbols too, though it is
not required that the result is logically equivalent to the corresponding formula
in second-order logic, only that all important consequences are preserved.

Our method is adapted from a method, called Msqel, designed for modal
logic to compute first-order frame correspondence properties for modal axioms
and rules [26]. The adaptation exploits the close relationship between description logics and modal logics [25]. Our method contributes three novel aspects.
It is the first method for forgetting concept symbols from ontologies specified
in the description logic ALCOI. It inherits from Msqel the consideration of
elimination orders, which has been shown to improve the success rate and make
it succeed on a wider range for problems in the modal logic corresponding to
ALCOI [26]. The success rate and its scope is further improved by the incorporation of a new case splitting rule and generalised simplification rules. Results
of an empirical evaluation show better success rates and performance for these
techniques.
The rest of the paper is organised as follows. Section 2 defines basic notions of
the problem of concept forgetting, including the syntax and semantics of ALCOI-
ontologies, the language that our proposed method is aimed for. A formal definition of concept forgetting for ALCOI-ontologies follows in Section 3. Section 4
sketches the general method to forget selected concept symbols, and correctness and termination results are stated. The forgetting calculus is introduced in
?

?

?
Section 5, where all the inference rules and two important simplification rules are
presented. Section 6 describes a heuristic method for calculating good forgetting
orders of the concept symbols that need to be eliminated. Results of an empirical
evaluation of the method are presented in Section 7. A brief chronological overview
of the most related work on forgetting and second-order quantifier elimination is
given in Section 8. We conclude in Section 9 with a summary of the work and an
outline of directions of future work.
2 Definition of ALCOI and Other Basic Notions
The basic syntactic elements in the language of ALCOI are the atomic concepts,
atomic roles, and nominals. Together they form the signature of the language of
ALCOI. Let NC and NR be the set of atomic concepts and the set of atomic
roles, respectively, and let NO be the set of nominals. ALCOI-concepts have one
of these forms:

a |  |  | A | C | C  D | C  D | R.C | R.C | R.C | R.C,

where a  NO, A  NC, R  NR, and C and D are arbitrary ALCOI-concepts.
R denotes the inverse of the role R. By definition, R := R.
An ontology usually consists of two parts, namely a TBox and an ABox. A
TBox contains a set of axioms of the form C  D or C  D, where C and D are
concepts. A concept definition C  D can be expressed by two general inclusion
axioms C  D and D  C. In ALCOI, ABox axioms can be expressed as
inclusions in the TBox: a concept assertion C(a) can be expressed as a  C, and
a role assertion R(a, b) as a  R.b. In our considerations ALCOI-ontologies
are therefore assumed to contain TBox axioms only.
We define an interpretation I for ALCOI over the signature (NC, NR, NO)
as a pair I,.I , where I is a non-empty set that represents the interpretation
domain, and .I is the interpretation function that assigns to every nominal a 
NO a singleton set aI  I; to every concept symbol A  NC a subset AI
of I; and to every role symbol R  NR a subset RI of I  I. We specify
the semantics of ALCOI-concepts by extending the interpretation function to
the following:

I
(R.C)

(R.C)
?

?

?
(R
)

(C)

= I\CI

(C  D)
= I

= {x  I | y.(x, y)  RI  y  CI}
= {x  I | y.(x, y)  RI  y  CI}
= {(y, x)  I  I | (x, y)  RI}

= CI  DI

The semantics of the TBox-axioms is defined as follows: an interpretation I
satisfies C  D iff CI  DI, and I satisfies C  D iff CI  DI. If O is a
set of TBox axioms, I is a model of O iff it satisfies every axiom in O, denoted
by I |= O.

Y. Zhao and R.A. Schmidt

avoid sequences of negations.

In the rest of the paper, we also need the following notions. A clause is
a disjunction of ALCOI-concepts. Clauses in our calculus are interpreted as
globally true, i.e., an interpretation I satisfies a clause C iff CI = I.
By definition C = D, if C = D, else C = D. The  operator helps
By R, we denote the composition of a sequence of roles and by R, we
denote the composition of the sequence of inverses of the roles in R with the
order in the sequence reversed.
Let A be a concept symbol and let I and I be interpretations. We say I
and I are equivalent up to A, or A-equivalent, if I and I coincide but differ
possibly in the valuation assigned to A. This means their domains coincide, i.e.,
I = I
. More
generally, suppose  = {A1, . . . , Am}  NC, I and I are equivalent up to ,
or -equivalent, if I and I are the same but differ possibly in the valuations
assigned to the concept symbols in .

, and for each symbol s in the signature, except for A, sI = sI

3 Forgetting as Second-Order Quantifier Elimination
We are interested in forgetting concept symbols in axioms of an ontology O of
TBox axioms. Let sig(O) denote the signature of O.
Definition 1. Let O and O be ALCOI-ontologies and let  = {A1, . . . , Am} be
a set of concept symbols. O is the result of forgetting the symbols in  from O,
if (i) sig(O)  sig(O)\ and (ii) for any interpretation I,

I |= O iff I |= O

for some interpretation I -equivalent to I.

The symbols in  are the symbols to be forgotten. We refer to them as the
non-base symbols and the symbols in sig(O)\ as the base symbols. The result
of forgetting a concept symbol A from O is the result of forgetting {A} from O.
Intuitively, the definition says that the forgetting result O is equivalent to the
given ontology up to the symbols in , for which the truth assignments can
be arbitrary. The result of forgetting a symbol A from an ontology O can be
represented as X OA
X in the extension of the language with existentially quantified concept variables. OA
X is our notation for substituting every occurrence
of A is O by X. In general, in the target language which extends the (source)
language of the logic under consideration with existential quantification of predicate symbols, the result of forgetting always exists. The challenge of forgetting,
as a computational problem, is to find an ontology O in the source language
X (where O is
(without second-order quantification) that is equivalent to X OA
expressed in the source language). Finding such an ontology O that is equivalent to X OA
X is an instance of the second-order quantifier elimination problem.
Forgetting a concept symbol A is thus the problem of eliminating the existential
quantifier X from X OA
X. In the following, we slightly informally say the aim
is to eliminate the symbol A from O. For this we apply second-order quantifier
?

?

?
polarities of A to generate the ordering .

1. Transform ontology O to clausal representation, N := clause(O).
2. Process every concept symbol A in  and check the frequency of the different
3. Guided by , apply the Dsqel to produce the ontology O
4. Apply simplification rules to O

interpreted in the obvious way as inclusions).
If it contains only the symbols in sig(O

(with clauses

, if needed, and return the resultant ontology.

)\ the method was successful.

Fig. 1. The phases in the basic Dsqel routine

elimination techniques [8] to the axioms of O in order to forget A (the nonbase symbol). In particular, we are going to exploit an adaptation of a result of
Ackermann [1], which is known as Ackermanns Lemma in the literature.
Theorem 1 (Ackermanns Lemma for ALCOI). Let O be an ALCOI-
ontology, let C be a concept expression and suppose the concept symbol A does
not occur in C. Let I be an arbitrary ALCOI-interpretation. (i) If A occurs
C iff for some interpretation I A-equivalent
only positively in O, then I |= OA
to I, I |= A  C, O. (ii) If A occurs only negatively in O then I |= OA
C iff for
some interpretation I A-equivalent to I, I |= C  A, O.

4 The DSQEL Forgetting Method

Our forgetting method is called Dsqel, which is short for Description logics
Second-order Quantifier ELimination.
Figure 1 outlines the basic routine of the Dsqel method to forget concept
symbols in ALCOI-ontologies. Once receiving the input ontology O and a set 
of concept symbols to forget, the method proceeds as follows. In Phase 1, a
preprocessing step is performed to transform the axioms into a set N of clauses.
This is done by replacing all inclusions C  D by C  D, and all equivalences
C  D by C  D and D  C. Inexpensive equivalence-preserving syntactic
simplification rules are also applied in this phase to simplify clauses. For example,
C(CD) is simplified to C. Phase 2 counts the number of positive and negative
occurrences of each concept symbol in . Using these counts a forgetting order
 is defined on the symbols in . This ordering determines the order in which
the symbols in  are eliminated in the next phase. Phase 3 applies the Dsqel
calculus described in the next section to the non-base symbols in  one by one,
starting with the symbol A largest in the forgetting order . To forget A the
inference rules of the Dsqel calculus are applied to the axioms containing A.
Then the next largest non-base symbol is eliminated, and so on.

Forgetting a concept symbol may lead to a change of the polarities of the
occurrences of the remaining -symbols, and a new elimination order may have
to be computed based on the refreshed polarity counts, before the forgetting
method continues. This means Phase 2 and Phase 3 will be executed alternately

Y. Zhao and R.A. Schmidt

and repeatedly with recomputed forgetting orders. If the largest current concept symbol to be eliminated could not be completely eliminated by Dsqel,
then a different ordering not attempted before will be used. In the case that all
possible orderings have been tried and every attempt to eliminate all non-base
symbols using Dsqel is not successful, the method returns failure, because it
was unable to solve the problem. On the other hand, when after a call of Dsqel
the set returned does not contain any non-base symbols, then this is the result
of forgetting  from O.

Phase 4 subsequently applies further simplification rules and transforms the

resulting axioms to simpler representations.

Different forgetting orders of concept symbols applied may lead to different
but equivalent results. The intermediary results as well as the final result can
be viewed (when the remaining non-base symbols are existentially quantified) as
equivalent representations of  O.

What is returned by the algorithm, if it terminates successfully, is a (possibly
empty) ontology with all occurrences of the non-base symbols eliminated, i.e.,
the ontology returned is specified in terms of only the symbols in sig(O)\.
There are situations where our method does not succeed, for instance, when
no forgetting result finitely expressible in ALCOI exists. This means the method
is not complete, but since no complete method can exist for forgetting, as considered in this paper with the target language being ALCOI, this is to be expected.
Concept forgetting is already not always computable for the description logic
EL [10]. We also note that when concept symbols cannot be eliminated by our
method this does not necessarily mean that they are ineliminable. It might be
the case that they are eliminable, but simply our method is unable to find a
solution.

We can show Dsqel algorithm is correct and is guaranteed to terminate.
This follows as an adaptation of the correctness and termination results for the
Msqel procedure proved in [26], since the calculus given in the next section is
correct and terminates, and all adaptations of Msqel to Dsqel preserve logical
equivalence.

5 The DSQEL Forgetting Calculus

The order in which the non-base symbols are eliminated is determined by the
forgetting order  computed in Phase 2 of the Dsqel algorithm. (Formally,
 may be any irreflexive, transitive relation on the non-base symbols to be
eliminated; no additional conditions need to be imposed.) We say a concept
symbol A is strictly maximal with respect to a concept C if for any concept
symbol B (= A) in C, A  B.

A concept C is positive (negative) wrt. a concept symbol A iff all occurrences
of A in C are positive (negative). A set N of concepts is positive (negative) with
respect to a concept symbol A iff all occurrences of A in N are positive (negative).
The Ackermann rule and the Purify rule, given in Figure 2, are the forgetting
rules in the Dsqel calculus, which will lead to the elimination of a non-base
?

?

?
Ackermann:

provided:

Purify:

provided:

N, C1  A, . . . , Cn  A

(N AC1...Cn )

C1,...,Cn
C1,...,Cn

(i) A is a non-base symbol,
(ii) A does not occur in any of the Ci,
(iii) A is strictly maximal wrt. each Ci, and
(iv) N is negative wrt. A.


(N A)
?

?

?
(i) A is a non-base symbol in N , and
(ii) N is negative wrt. A.

Fig. 2. The forgetting rules

concept symbol. Both of them have to meet particular requirements on the form
of the concepts to which they apply. N is a set of ALCOI-clauses, and by N D
C ,
we mean the set obtained from N by substituting the expression C for all occurrences of D in N, where C and D are both ALCOI-concepts. Like all other
inference rules in the Dsqel calculus, the Ackermann rule is restricted by a
set of side-conditions. The side-conditions of the Ackermann rule require that
A must be a non-base symbol and does not occur in C1, . . . , Cn, no non-base
symbol occurring in Ci (1  i  n) is larger than A under the ordering , and
every occurrence of A in N must be negative. The Purify rule can be seen as
a special case of the Ackermann rule, since it eliminates the non-base symbols
that occur only negatively, that is, when there are no positive occurrences of A.
The rules in Figures 3 and 4 are used to rewrite the clauses so they can be
transformed into a form where either the Ackermann rule or the Purify rule is
applicable. To apply the Ackermann or Purify rule, the clauses need to be in
A-reduced form, where A is the largest non-base symbol. We say a clause is in
A-reduced form if it is either negative in A or it has the form A  C, where C
does not include any occurrences of A. A set of clauses is in A-reduced form if
every clause is in A reduced form.

A set of clauses is transformed into A-reduced form, by repeatedly applying
the Surfacing rule, the Skolemization rule, the Clausify rule and the Case Splitting rule to clauses containing positive occurrences of A that are not already in
A-reduced form.

The Surfacing rule equivalently transforms a clause where the largest nonbase symbol occurs positively below a universal restriction operator so that these
occurrences pass up to levels closer to the top level of the clause. The Skolemization rule rewrites the existential expression in a clause of the form a  R.C,
where a is a nominal. The implicit existential quantifier in R.C is Skolemized
by introducing a new Skolem constant (nominal) b. The Clausify rule transforms
a concept of the form C (D1 . . . Dn) into a set of clauses. The Sign Switch-

Y. Zhao and R.A. Schmidt

Surfacing:

provided:

Skolemization:

N, C  R.D
N, (R,.C)  D

(i) A is the largest non-base symbol in C  R.D,
(ii) A does not occur in C, and
(iii) A occurs positively in R.D.
N,a  R.C

N,a  R.b,b  C

provided:

(i) A is the largest non-base symbol in a  R.C,
(ii) A occurs positively in R.C, and
(iii) b is a new nominal.

Clausify:

N, C  (D1  . . .  Dn)
N, C  D1, . . . , C  Dn

provided: (i) A is the largest non-base symbol in C  (D1  . . .  Dn), and

(ii) A occurs positively in D1  . . .  Dn.

Sign Switching:

(N AA)

A

provided:

(i) N is closed wrt. the other rules,
(ii) A is the largest non-base symbol in N , and
(iii) Sign switching wrt. A has not been performed before.

Fig. 3. The rewriting rules

ing rule is used to switch the polarity of a non-base symbol. It is applicable only
when no other rules in the calculus are applicable wrt. this non-base symbol and
the Sign Switching rule has not been performed for this non-base symbol before.
A novel aspect of the Dsqel calculus is the Case Splitting rule given in
Figure 4. It splits a clause of the form a C1  . . . Cn into smaller subclauses
a  C1, . . . , a  Cn. A single clause a  Ci, together with N, forms a case.
The original clause means that a belongs to at least one of the disjuncts Ci (1 
i  n). The benefits of the Case Splitting rule are twofold. On the one hand, it
makes up for a limitation of the Skolemization rule, because it splits a disjunction
with more than two disjuncts into several smaller cases, which the Skolemization
rule is then able to handle. On the other hand, our tests show that it reduces
the search space and increases the success rate, because the transformation to
A-reduced form is easier in the cases, in which the clauses are smaller.

As the purpose of the rewriting rules is finding A-reduced forms and letting
the two forgetting rules become applicable, it is not difficult to see that the
rewriting rules, excluding the Sign Switching rule, should be performed before
the forgetting rules. The Sign Switching rule is the exception because, as men-
?

?

?
Case Splitting:

N,a  C1  . . .  Cn

N,a  C1 | . . . | N,a  Cn

provided:

(i) A is the largest non-base symbol in a  C1  . . .  Cn, and
(ii) A occurs positively in C1  . . .  Cn.

Fig. 4. The Case Splitting rule

Condensing I:
?

?

?
C  R1 .R1,. . . .Rn .Rn,.(C  D)
?

?

?
C  D  R1 .

provided:

(i) C and D are arbitrary concepts, and
(ii) i  1 for 1  i  n.
?

?

?
C  R1 .R1,. . . . Rn .Rn,.(C  D)
?

?

?
C  D  Rn .

provided:

(i) C and D are arbitrary concepts, and
(ii) i  n for 1  i  n.

Fig. 5. Sample simplification rule

tioned earlier in this section, it is performed only when no other inference rules
are applicable. Reruns of the rewriting rules, except for Sign Switching, are
required since once a rule is applied, another rule that was previously unable
to be applied may become applicable now. The rerun will continue until the
clauses are not changed by any of the Clausify rule, the Surfacing rule, or the
Skolemization rule. If either of the two forgetting rules becomes applicable, they
are immediately applied.

We also introduced several simplification rules to transform more expressions
so that inference rules become applicable, and in order to keep expressions in
simpler forms for efficiency. Most importantly, they lead to success of forgetting
in more cases. Figure 5 displays two cases of the simplification rules, called Condensing I, with which clauses of a particular pattern can be simplified, which
other forgetting and second-order quantifier elimination methods cannot han-
dle. The rules have the form N[C]/N[D] and have the effect of replacing an
occurrence of a subexpression C in some clause in N by the expression D.

6 Calculating the Forgetting Order

In a forgetting problem, the forgetting order is the order in which the non-base
symbols are forgotten. Given n non-base symbols, in the worst case there are
n! possible orderings for the forgetting procedure to follow. Selecting a good

Y. Zhao and R.A. Schmidt

forgetting order is important for the efficiency of the forgetting method and the
success rate (when a timeout is used). This is best illustrated with an example.
We first show that the forgetting order matters. Consider the following ontology in clause form and suppose the forgetting order is A  B.

 1. (R.a)  (R.A)  B
2. (R.R.a)  (R.A)  B
3. (R.a)  R.R.A

Since A is the largest non-base symbol the initial aim is to bring the clauses
into A-reduced form and then eliminate A with one of the forgetting rules. The
starred clause (Clause 1) is negative wrt. the current non-base symbol A; all
others contain positive occurrences of A. At this point, no rules in the Dsqel
calculus (excluding the Sign Switching rule) can be applied to transform Clause
3 to reduced form wrt. A. The Sign Switching rule is unable to change the
situation either in this case. However, changing the forgetting order to B  A
opens a survival window for the problem.

Assume now the forgetting order is B  A,
1. (R.a)  (R.A)  B
 2. (R.R.a)  (R.A)  B
3. (R.a)  R.R.A

The aim is to eliminate B first. Clause 2 is negative wrt. B and Clause 1 has a
positive occurrence of B. Applying the Ackermann rule to Clauses 1 and 2 leads
to Clause 4, which proves to be a tautology and thus can be deleted.

4. (R.R.a)  (R.A)  (R.a)  (R.A) 1 into 2, Acker.
5. (R.a)  R.R.

3, Sign Sw. & Purify

What remains is Clause 3, from which A can be forgotten by applying the Sign
Switching and Purify rules, which produces Clause 5. The method terminates
successfully, returning a  R.R.R. after simplifying Clause 5.

A good forgetting order allows non-base symbols to be forgotten as quickly
as possible, however it does not generally guarantee success of the procedure.
In this case, another ordering will be used, and the success of forgetting will be
pursued until all possible orderings have been attempted.

Our implementation of the Dsqel calculus involves a heuristic method to
calculate forgetting orders with increased chances of quick and successful elimination of the non-base symbols. The method exploits polarity counts of the
non-base symbols. Given n non-base symbols, we first count the number of positive and negative occurrences of each symbol and represent the results as pairs.
We then choose the smaller value of each pair as their actual counts. These
actual counts are sorted into ascending order, which is then taken as the forgetting order to be used. If the actual counts of some of the non-base symbols
?

?

?
Table 1. Results of polarity counting for each non-base symbol

Non-Base Symbol

No. of Positive Occurrences
No. of Negative Occurrences

A1
?

?

?
A2
?

?

?
A3
?

?

?
A4
?

?

?
A5
?

?

?
A6
?

?

?
are identical, we compare the counts for their opposite polarity. If these are the
same, the positive counts have higher priority than the negative ones. Gener-
ally, symbols with lower counts are selected to be forgotten before symbols with
higher counts. Note that if we fail to forget a symbol in an ordering, we simply
go to the next symbol. Once a symbol has been forgotten, the forgetting order
will be recomputed since the forgetting of a non-base symbol might affect the
occurrences of the remaining non-base symbols. The reason why counting is not
conducted wrt. a particular polarity (either positive or negative) of the non-base
symbols, is the Sign Switching rule, with which we can change the polarity of
the occurrences of a particular non-base symbol.

We use an example to illustrate the operation of this heuristic method. Suppose the frequency analysis of the polarity counting reveals the pairs as listed in
Table 1. The numbers in bold indicate the smaller values of each pair, i.e., the
actual counts. Thus the forgetting order  calculated is A4  A6  A1  A3 
A2  A5.
In the previous example the frequency analysis computes the order B  A,

which immediately leads to success, without requiring another round.

7 Empirical Results

We implemented our forgetting method in Java using the OWL API, fully realising every aspect of the inference rules and the simplification rules in Dsqel. An
important part of the implementation is the calculation of the forgetting order
of the non-base symbols based on a frequency analysis as described in the previous section. In order to evaluate how the Dsqel method behaves on real-life
ontologies, we tested the system on a set of ontologies from the NCBO BioPor-
tal,1 a large repository of biomedical ontologies. The experiments were run on a
machine with an Intel Coretm i7-4790 processor, and four cores running at up
to 3.60 GHz and 8 GB of DDR3-1600 MHz RAM.
Since Dsqel handles expressivity as far as ALCOI, the ontologies for our
evaluation were restricted to their ALCOI-fragments, and axioms outside of the
scope of ALCOI were dropped from the ontologies. Consequently, we used 292
ontologies from the repository for our evaluation. We ran the experiments on
each ontology 100 times and averaged the results to explore how forgetting was
influenced by the number of the concept symbols in an ontology. A timeout of
1000 seconds was used.

To fit with possible needs in applications, we conducted experiments where
10%, 30%, and 50% of the concept symbols in the ontologies were forgotten.

1 http://bioportal.bioontology.org/

Y. Zhao and R.A. Schmidt

Table 2. Forgetting 10%, 30%, and 50% of the concept symbols in ontologies

Experiment
%

Analysis Timeouts Duration Avg. Success Rate

Results

10%

30%

50%











3.8%
1.7%
7.5%
2.2%
13.4%
3.1%

8.2%
2.3%

4.509 sec.
2.404 sec.
8.562 sec.
2.753 sec.
15.068 sec.
3.004 sec.

9.380 sec.
2.720 sec.

90.1%
97.6%
88.4%
95.5%
85.3%
94.9%

87.9%
96.0%

Input

Axioms Avg. Symbols Avg.

Average

The Dsqel algorithm processed each non-base symbol and counted the number
of their positive and negative occurrences. Based on these counts, a forgetting
order was generated by the heuristic algorithm. In order to see how the forgetting
order affected the performance of the method, we ran two sets of experiments,
where we omitted the frequency analysis for determining the forgetting order
for one set, and applied the analysis to the other set. Without the frequency
analysis, the symbols were forgotten in the order as returned by an OWL API
function that gets all concept symbols in the ontology.

The evaluation results obtained from 10%, 30%, 50% of the concept symbols
in the ontologies, without and with the frequency analysis for determining the
forgetting order, are shown in Table 2. It can be seen that, the frequency analysis
led to a decrease in the average duration of the runs of every experiment, which
means that it took less time to complete the same task than when the frequency
analysis was not performed. It is evident from the last two rows in the table
that basing the forgetting order to the frequency analysis has brought a positive
effect on the overall success rate (increase by 8.1%) and the number of timeouts
(decrease by 5.9%).

To show the difficulty of the forgetting problem, and how well our method
behaves, we considered the extreme scenario of forgetting all concept symbols
from each ontology. In this case, the selected ontologies (which were the same as
used in the previous experiment) were divided first into three groups and each
of them contained the ontologies with the numbers of concept symbols ranging
from 1 to 1000, from 1001 to 4000, and more than 4000, respectively, in order
to explore how forgetting was influenced by the number of the concept symbols
that the ontologies contained. The other specifications remained the same, unless
otherwise stated.

The results of the evaluation with and without the frequency analysis are
shown in Tables 3 and 4, respectively. As with the results of the previous eval-
uation, the analysis of the forgetting order made a significant difference to the
overall success rate (increase by 13.7%) and the number of timeouts (decrease by
14%). What can also be observed is that for smaller ontologies with fewer concept
symbols, there were fewer timeouts and the success rate of the method was higher.
?

?

?
Table 3. Forgetting all concept symbols with frequency analysis

Input

Results

Corpora Axioms Avg. Concept Symbols Timeouts Duration Avg. Success Rate

1001  4000

1  1000
 4001
Total
?

?

?
1.3%
3.8%
13.3%

2.4%

0.869 sec.
9.148 sec.
29.898 sec.

4.352 sec.

96.4%
92.5%
86.7%

95.2%

Table 4. Forgetting all concept symbols without frequency analysis

Corpora Axioms Avg. Concept Symbols Timeouts Duration Avg. Success Rate

Input

Results

1001  4000

1  1000
 4001
Total
?

?

?
9.8%
28.3%
60.0%

16.4%

4.589 sec.
51.400 sec.
224.133 sec.

24.363 sec.

87.9%
67.9%
40.0%

81.5%

Evaluations of more aspects are being conducted at the moment. These evaluations are focussed on measuring the difference that case splitting and simplification make to the behaviour of the Dsqel calculus, and how our method
compares to the related methods of Scan [7], Dls [5], Dls
[6], Sqema [3],
Msqel [26], and Lethe [16] in terms of success rate and efficiency (duration
and number of timeouts).

8 Related Work

Probably the most important early work on the elimination of second-order
quantifiers is that of Ackermann [1] in the nineteen-thirties and forties. Only
in 1992, the first practical algorithm, called Scan, was developed by Gabbay
and Ohlbach [7]. Scan is a resolution-based second-order quantifier elimination algorithm and can be used to forget predicate symbols from first-order logic
formulae [24]. It has been shown that the Scan algorithm is complete and terminates for modal axioms belonging to the famous Sahlqvist class [9]. In 1994, the
hierarchical theorem proving method was developed by Bachmair et al. [2] and
it has been shown that it can be used to solve second-order quantification prob-
lems. Around the same time, in 1995, Szalas [27] described a different algorithm
for the second-order quantifier elimination problem, which exploits Ackermanns
Lemma. The method was further extended to the Dls algorithm by Doherty et
al. [5]. Dls uses a generalised version of Ackermanns Lemma and allows the elimination of existential second-order quantifiers from second-order formulae, for
obtaining corresponding first-order equivalents. Nonnengart and Szalas [23] generalised the main result underlying the Dls algorithm to include fixpoints. Based
on this work, Doherty et al. [6] proposed the Dls algorithm, which attempts the
derivation of either an equivalent first-order formula or a fixpoint formula from
?

?

?
the original formula. Dls and Dls are Ackermann-based second-order quantifier elimination methods. Ackermann-based second-order quantifier elimination
was first applied to description logics in [28] by Szalas, where description logics were extended by a form of second-order quantification over concepts. More
recently, Conradie et al. [3] introduced the Sqema algorithm, which is also an
Ackermann-based method but for modal logic formulae. It is specialised to find
correspondences between modal formulae and hybrid modal logic formulae (and
first-order formulae). Schmidt [26] has extended Sqema and developed Msqel
as a refinement, with the use of elimination orders, and the presentation of
second-order quantifier elimination as an abstract calculus, as key novelties.

Investigation of

forgetting as uniform interpolation in more expressive
description logics was started in [29] and [21]. The first approach to compute uniform interpolations for ALC-TBoxes was presented in [29]. It is a tableau-based
approach, where a disjunctive normal form is required for the representation of
the TBox-axioms and the uniform interpolants are incrementally approximated.
It was shown in [21] that deciding the existence of uniform interpolants that
can be finitely represented in ALC without fixpoints is 2ExpTime-complete and
in the worst case, the size of uniform interpolants is triple exponential wrt. the
size of the original TBox. The first goal-oriented method based on resolution
was presented in [19] for computing uniform interpolants of ALC-TBoxes, where
experimental results show the practicality for real-life ontologies. Koopmann and
Schmidt presented another resolution-based method exploiting structural transformation to compute uniform interpolants of ALC-TBoxes, which uses fixpoint
operators to make uniform interpolants finitely representable [14]. The method
has been further extended to handle ALCH [12], SIF [17], SHQ [15], and ALC
with ABoxes [18].

9 Conclusion and Future Work

We have presented a second-order quantifier elimination method, called Dsqel,
for forgetting concept symbols in ontologies specified in the description logic
ALCOI. It is adapted from Msqel, an Ackermann-based second-order quantifier
elimination method for a multi-modal tense logic with second-order quantifica-
tion. The method is enhanced with new inference and simplification rules. The
adaptation was motivated for the purpose of applying second-order quantifier
elimination techniques to the area of knowledge representation, where description logics provide important logical formalisms.

We have implemented a prototype system of our forgetting method, fully
realising the Dsqel calculus. The evaluation results have confirmed that the
success of a forgetting problem is highly dependent on, apart from the calculus
itself, the non-base symbols  to be forgotten, and the forgetting order which
the method follows. Overall, the results showed promising and very good success
rates for concept symbol forgetting for our method.

Optimisations to both the calculus and the implementation are underway.
One optimisation being investigated is the incorporation of more simplification
?

?

?
rules in order to increase the efficiency and success rate further. We are also
currently working on finding better heuristics for computing better forgetting
orders of the non-base symbols.
Extending the method to handle ontologies going expressively further than
ALCOI is a direction of ongoing research. To explore how forgetting of role
symbols can be incorporated into our method is also of interest.
