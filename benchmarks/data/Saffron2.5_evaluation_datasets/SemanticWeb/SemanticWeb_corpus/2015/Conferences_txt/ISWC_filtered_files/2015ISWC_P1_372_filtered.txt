Optimizing the Computation of Overriding

Piero A. Bonatti, Iliana M. Petrova, and Luigi Sauro(B)

Dip. Ing. Elet. e Tecnologie dellInformazione,
Universit`a di Napoli Federico II, Naples, Italy

luigi.sauro74@gmail.com

Abstract. We introduce optimization techniques for reasoning in DLN
a recently introduced family of nonmonotonic description logics whose
characterizing features appear well-suited to model the examples naturally arising in biomedical domains and semantic web access control
policies. Such optimizations are validated experimentally on large KBs
with more than 30K axioms. Speedups exceed 1 order of magnitude. For
the first time, response times compatible with real-time reasoning are
obtained with nonmonotonic KBs of this size.

1 Introduction
Recently, a new family of nonmonotonic Description Logics (DLs), called DLN,
has been introduced [8]. It supports normality concepts NC to denote the nor-
mal/standard/ prototypical instances of a concept C, and prioritized defeasible inclusions (DIs) C n D with the following meaning: by default, the
instances of C satisfy D, unless stated otherwise, that is, unless some higher
priority axioms entail C  D; in that case, C n D is overridden. The nor-
mal/standard/prototypical instances of C are required to satisfy all the DIs that
are not overridden in C.
Given the negligible number of applications based on nonmonotonic logics
deployed so far, DLN has been designed to address real-world problems and concrete knowledge engineering needs. In this regard, the literature provides clear and
articulated discussions of how nonmonotonic reasoning can be of help in important contexts related to the semantic web, such as biomedical ontologies [25,28]
(with several applications, such as literature search) and (semantic web) policy
formulation [29]. These and other applications are extensively discussed in [8].
The distinguishing features in DLNs design are: (i) DLN adopts the simplest possible criterion for overriding, that is, inconsistency with higher priority
axioms; (ii) all the normal instances of a concept C conform to the same set
of default properties, also called prototype in the following; (iii) the conflicts
between DIs that cannot be resolved with priorities are regarded as knowledge
representation errors and are to be fixed by the knowledge engineer (typically,
by adding specific DIs). No traditional nonmonotonic logic satisfies (i), and very
few satisfy (ii) or (iii). DLN behaves very well on application examples due to
the following consequences of (i)(iii) (a comparison with other nonmonotonic
DLs with respect to these features is summarized in Table 1):
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 356372, 2015.
DOI: 10.1007/978-3-319-25007-6 21
?

?

?
No inheritance blocking: In several nonmonotonic logics a concept with exceptional properties inherits none of the default properties of its superclasses. This
undesirable phenomenon is known as inheritance blocking.

specify whether a role should range only over normal individuals or not.

No undesired closed-world assumption (CWA) effects: In some nonmonotonic
DLs, an exceptional concept is shrinked to the individuals that explicitly belong
to it, if any; hence, it may become inconsistent.
Control on role ranges: Unlike most nonmonotonic DLs, DLN axioms can
Detect inconsistent prototypes: DLN facilitates the identification of all conflicts that cannot be resolved with priorities (via consistency checks over normality concepts), because their correct resolution is application dependent and
should require human intervention (cf. [8, Sec. 1] and Example 1 below).
Tractability: DLN is currently the only nonmonotonic DL known to preserve
the tractability of all low-complexity DLs, including EL++ and DL-lite (that
underly the OWL2-EL and OWL2-QL profiles). This opens the way to processing
very large nonmonotonic KBs within these fragments.

Table 1. Partial comparison with other nonmonotonic DLs, cf.[8], where CIRC,
DEF, AEL, TYP, RAT, PR stand, respectively, for Circumscribed DLs, Default DLs,
Autoepistemic DLs, DLs with Typicality, DLs with Rational Closure, and Probabilistic
DLs.

Features

CIRC DEF AEL TYP
[5, 6]
[17, 18]
?

?

?
[1, 2]
?

?

?
[13]
?

?

?
no inheritance blocking
no CWA effects
fine-grained control on role ranges
detects inconsistent prototypes
preserves tractability
(*) It holds for subsumption, assertion checking, concept consistency, KB consistency.

sometimes
sometimes
?

?

?
[10, 11] [12]

[22] DLN
  
?

?

?
 
()

The performance of DLN inference has been experimentally analyzed on large
KBs (with more than 20K concept names and over 30K inclusions). The results
are promising; still, as defeasible inclusions approach 25% of the KB, query
response time slows down enough to call for improvements. In this paper, we
study two optimization techniques to improve DLN query response time:
1. Many of the axioms in a large KB are expected to be irrelevant to the given
query. We investigate the use of module extractors [24,27] to focus reasoning
on relevant axioms only. The approach is not trivial (module extractors are
unsound for most nonmonotonic logics, including circumscription, default
and autoepistemic logics) and requires an articulated correctness proof.

2. We introduce a new algorithm for query answering, that is expected to
exploit incremental reasoners at their best. Incremental reasoning is crucial as DLNs reasoning method iterates consistency tests on a set of KBs
with large intersections. While the assertion of new axioms is processed very

P.A. Bonatti et al.

efficiently, the computational cost of axiom deletion is generally not negligi-
ble. We introduce an optimistic reasoning method that is expected to reduce
the number of deletions.

Both optimizations are validated experimentally. Speedups exceed 1 order of
magnitude. To the best of our knowledge, this is the first time that response
times compatible with real-time reasoning are obtained with nonmonotonic KBs
of this size.
The paper is organized as follows: Sec. 2 provides the basics of DLN and
illustrates its inferences with examples. Sections 3 and 4 introduce the two optimization methods, respectively, and prove their correctness. Their experimental
assessment is in Sec. 5. Proofs have been omitted due to space limitations. They
can be found in [7], together with further explanations and examples. We assume
the reader to be familiar with description logics, see [15] for all details. The code
and test suites are available at: http://goo.gl/KnMO9l.

2 Preliminaries
Let DL be any classical description logic language (see [15] for definitions), and
let DLN be the extension of DL with a new concept name NC for each DL
concept C. The new concepts are called normality concepts.
A DLN knowledge base is a disjoint union KB = S  D where S is a finite
set of DLN inclusions and assertions (called strong or classical axioms) and D is
a finite set of defeasible inclusions (DIs, for short) that are expressions C n D
where C is a DL concept and D a DLN concept. If  = (C n D), then pre()
and con() denote C and D, respectively. Informally speaking, the set of DIs
satisfied by all the instances of a normality concept NC constitute the prototype
associated to C.
DIs are prioritized by a strict partial order . If 1  2, then 1 has higher
priority than 2. DLN solves automatically only the conflicts that can be settled
using ; any other conflict shall be resolved by the knowledge engineer (typically
by adding suitable DIs). Two priority relations have been investigated so far.
Both are based on specificity: the specific default properties of a concept C have
higher priority than the more generic properties of its superconcepts (i.e. those
that subsume C). The priority relation used in most of [8]s examples identifies
those superconcepts with strong axioms only:

1  2 iff pre(1) S pre(2) and pre(2) S pre(1) .1

(1)

The second priority relation investigated in [8] is

1  2 iff rank(1 ) > rank(2 ),

(2)
where rank() is shown in Algorithm 1 and corresponds to the ranking function of
rational closure [11,12]. This relation uses also DIs to determine superconcepts,
1 As usual, C S D means that S |= C  D.
?

?

?
Algorithm 1. Ranking function
Input: Ontology KB = S  D
Output: the function rank ()
i := 1; E0 := {C  D | C n D  D}
repeat

i := i + 1
Ei+1 := {C  D  Ei | S  Ei |= C }
forall C n D s.t. C  D  Ei \ Ei+1 do

assign rank (C n D) := i

until Ei+1 = Ei
forall C n D  Ei+1 do assign rank (C n D) := 
return rank ()

so (roughly speaking) a DI C n Dbesides defining a default property for
Cgives the specific default properties of C higher priority than those of D.
The advantage of this priority relation is that it resolves more conflicts than
(1); the main advantage of (1) is predictability; e.g. the effects of adding default
properties to an existing, classical KB are more predictable, as the hierarchy
used for determining specificity and resolving conflicts is the original, validated
one, and is not affected by the new DIs (see also the related discussion in [3,4],
that adopt (1)).
The expression KB |  means that  is a DLN consequence of KB. Due
to space limitations, we do not report the model-theoretic definition of | and
present only its reduction to classical reasoning [8]. For all subsumptions and
assertions , KB |  holds iff KB |= , where  is the set of normality
concepts that explicitly occur in KB  {}, and KB is a classical knowledge
base obtained as follows (recall that KB = S  D):

First, for all DIs   D and all NC  , let:

NC =
?

?

?
NC  pre()  con()

.

(3)

The informal meaning of NC is: NCs instances satisfy .

Second, let S  denote the result of removing from the axiom set S all

the NC

such that 0  :

S = S \ {NC

| NC    0  } .

Third, let 1, . . . , |D| be any linearization of (D,).2
Finally, let KB = KB|D|, where the sequence KB

i

inductively defined as follows:
0 = S  
NC  C | NC  
 
i = KB
i1
KB
i
i1

NC
i
 {NC

KB
KB

i
?

?

?
| i  KB, NC  , and

} |= NC  

.

2 That is, {1, . . . , |D|} = D and for all i, j = 1, . . . , |D|, if i  j then i < j.

(i = 1, 2, . . . ,|D|) is

(4)

(5)

P.A. Bonatti et al.

In other words, the above sequence starts with KBs strong axioms extended
with the inclusions NC  C, then processes the DIs i in non-increasing priority
order. If i can be consistently added to Cs prototype, given all higher priority
DIs selected so far (which is verified by checking that NC   in line (5)), then
is included in KB (i.e. i enters Cs prototype), otherwise
its translation NC
i is discarded, and we say that i is overridden in NC.

i

2.1 Examples
We start with a brief discussion of DLNs conflict handling. Most other logics
silently neutralize the conflicts between nonmonotonic axioms with the same (or
incomparable) priorities by computing the inferences that are invariant across
all possible ways of resolving the conflict. A knowledge engineer might solve it
in favor of some of its possible resolutions, instead; however, if the logic silently
neutralizes the conflict, then missing knowledge may remain undetected and
unfixed. This approach may cause serious problems in the policy domain:

Example 1. Suppose that project coordinators are both administrative staff and
research staff. By default, administrative staff are allowed to sign payments,
while research staff are not. A conflict arises since both of these default policies
apply to project coordinators. Formally, KB can be formalized with:

Admin n has right.Sign

(6)
Research n has right.Sign (7)

PrjCrd  Admin  Research

(8)

Leaving the conflict unresolved may cause a variety of security problems. If
project coordinators should not sign payments, and the default policy is open
(authorizations are granted by default), then failing to infer has right.Sign
would improperly authorize the signing operation. Conversely, if the authorization is to be granted, then failing to prove has right.Sign causes a denial of
service (the user is unable to complete a legal operation). To prevent these prob-
lems, DLN makes the conflict visible by inferring KB | N PrjCrd   (showing
that PrjCrds prototype is inconsistent). This can be proved by checking that
KB |= N PrjCrd  , where  = {N PrjCrd}. Then KB consists of (8),
N PrjCrd  PrjCrd, and the translation of (6) and (7) (none overrides the other
because none is more specific under any of the two priorities):

N PrjCrd  Admin  has right.Sign,
N PrjCrd  Research  has right.Sign.
?

?

?
Here is another application example from the semantic policy domain, showing
DLNs behavior on multiple exception levels.
Example 2. We are going to axiomatize the following natural language policy: In
general, users cannot access confidential files; Staff can read confidential files; Blacklisted users are not granted any access. This directive cannot be overridden. Note
?

?

?
that each of the above directives contradicts (and is supposed to override) its predecessor in some particular case. Authorizations can be reified as objects with
attributes subject (the access requestor), target (the file to be accessed), and privilege (such as read and write). Then the above policy can be encoded as follows:

Staff  User
Blklst  Staff

UserReqst n privilege
StaffReqst n

privilege.Read

(9)
(10)
(11)
(12)
(13)
.
where BlkReq
=
subj.User. By (9), both the specifity relations (1) and (2) yield (12)  (11),
that is, (12) has higher priority than (11). Let  = {NStaffReqst}; (12) overrides (11) in NStaffReqst (under (1) as well as (2)), so KB consists of: (9),
(10), (13), plus

BlkReq  privilege
= subj.Staff, and UserReqst
.

= subj.Blklst, StaffReqst
.

NStaffReqst  StaffReqst

NStaffReqst  StaffReqst  privilege.Read

Consequently, KB | NStaffReqst  privilege.Read. Similarly, it can be
verified that:

1. Normally, access requests involving confidential files are rejected, if they

come from generic users: KB | NUserReqst  privilege;
2. Blacklisted users cannot do anything by (13), so, in particular:
KB | NBlkReq  privilege.
?

?

?
Some application examples from the biomedical domain can be found in [8]
(see Examples 3, 4, 10, 12, and the drug contraindication example in Appendix
C). Like the above examples, they are all correctly solved by DLN with both
priority notions. Applicative examples hardly exhibit the complicated networks
of dependencies between conflicting defaults that occur in artificial examples.
Nonetheless, we briefly discuss the artificial examples, too, as a means of comparing DLN with other logics such as [5,12,26].
In several cases, e.g. examples B.4 and B.5 in [26], DLN agrees with [5,12,26]
under both priority relations. Due to space limitations, we illustrate only B.4.
Example 3 (Juvenile offender). Let KB consist of axioms (14)(18) where J, G, M,
P abbreviate JuvenileOffender, GuiltyOfCrime, IsMinor and ToBePunished,
respectively.

J  G
J  M
M  G n P
M n P
G n P

(14)
(15)
(16)
(17)
(18)

J  G
J  M
NJ  J
NJ  M  G  P
NJ  M  P

(19)
(20)
(21)
(22)
(23)

P.A. Bonatti et al.

On one hand, criminals have to be punished and, on the other hand, minors
cannot be punished. So, what about juvenile offenders? The defeasible inclusion
(16) breaks the tie in favor of their being underage, hence not punishable. By
setting  = {NJ}, priorities (1) and (2) both return axioms (19)(23) as KB.
Then, clearly, KB |= NJ  P which is DLNs analogue of the inferences of
[5,12,26].

In other cases (e.g. example B.1 in [26]) DLN finds the same conflicts as
[5,12,26]. However, DLNs semantics signals these conflicts to the knowledge
engineer whereas in [5,12,26] they are silently neutralized.
Example 4 (Double Diamond). Let KB be the following set of axioms:

A n T
A n P
T n S
P n S

(24)
(25)
(26)
(27)

S n R
P n Q
Q n R

(28)
(29)
(30)

DIs (26) and (27) have incomparable priority under (1) and (2). Consequently,
it is easy to see that NA  S and NA  S are both implied by KB and hence
the knowledge engineer is warned that NA is inconsistent. The same conflict is
silently neutralized in [5,12,26] (As instances are subsumed by neither S nor S
and no inconsistency arises). Similarly for the incomparable DIs (28) and (30)
and the related conflict.

The third category of examples (e.g. B.2 and B.3 in [26]) presents a more variegated behavior. In particular, [12] and DLN with priority (2) solve all conflicts
and infer the same consequences; [26] solves only some conflicts; [5] is not able
to solve any conflict and yet it does not raise any inconsistency warning; DLN
with priority (1) cannot solve the conflicts but raises an inconsistency warning.
Here, for the sake of simplicity, we discuss in detail a shorter example which has
all relevant ingredients.
Example 5. Let KB be the following defeasible knowledge base:
B n C

A n B

(31)

A n C

(32)

(33)

According to priority (1) all DIs are incomparable. Therefore, DLN warns (by
inferring NA  ) that the conflict between NA  C and NA  C cannot be
solved. Note that [5] adopts priority (1), too, however according to circumscrip-
tion, any interpretation where As instances are either in C  B or in C is a
model, so A is satisfiable (the conflict is silently neutralized). Under priority (2),
instead, axiom (31) gives (31) and (32) higher priority than (33). Consequently,
NA  C prevails over NA  C. In this case, DLN and rational closure infer the
same consequences.
?

?

?
3 Relevance and Modularity
The naive construction of KB must process all the axioms in KB

all = KB
{NC |   D, NC  }. Here we optimize DLN inference by quickly discarding
some of the irrelevant axioms in KB

all using modularization techniques.

Roughly speaking, the problem of module extraction can be expressed as
follows: given a reference vocabulary Sig, a module is a (possibly minimal) subset
M  KB that is relevant for Sig in the sense that it preserves the consequences
of KB that contain only terms in Sig.

The interest in module extraction techniques is motivated by several ontology engineering needs. We are interested in modularization as an optimization
technique for querying large ontologies: the query is evaluated on a (hopefully
much smaller) module of the ontology that preserves the query result (as well
as any inference whose signature is contained in the querys signature).

However, the problem of deciding whether two knowledge bases entail the same
axioms over a given signature is usually harder than standard reasoning tasks.
is a module of KB (for Sig) is computationally
Consequently deciding whether KB
expensive in general. For example, DLLitehorn complexity grows from PTIME
to coNP-TIME-complete [21]; for ALC, complexity is one exponential harder [16],
while for ALCQIO the problem becomes even undecidable [23].
In order to achieve a practical solution, a syntactic approximation has been
adopted in [19,27]. The corrisponding algorithm -Mod(Sig,KB) is defined
in [27, Def. 4] and reported in Algorithm 2 below. It is based on the property of
-locality and -locality of single axioms (line 15). An axiom is local w.r.t. Sig
if the substitution of all non-Sig terms with  (resp. ) turns it into a tautology.
The module extractor identifies a subset M  KB of the knowledge base
and a signature Sig (containing all symbols of interest) such that all axioms in
KB \ M are local w.r.t. Sig. This guarantees that every model of M can be
extended to a model of KB by setting each non-Sig term to either  or . In
turn, this property guarantees that any query whose signature is contained in
Sig has the same answer in M and KB.
The function x-Mod(Sig,KB) (lines 9-19), where x stands for  or ,
describes the procedure for constructing modules of a knowledge base KB for
each notion of locality. Starting with an empty set of axioms (line 11), iteratively,
the axioms  that are non-local are added to the module (line 16) and, in order
to preserve soundness, the signature against which locality is checked is extended
with the terms in  (line 15). Iteration stops when a fixpoint is reached.
Modules based on a single syntactic locality can be further shrinked by iteratively nesting -extraction into -extraction, thus obtaining -Mod(Sig,KB)
modules (lines 1-8).
The notions of module and locality must be extended to handle DIs, before
we can apply them to DLN. Definition 1 generalizes the substitutions operated
by the module extraction algorithm, abstracting away procedural details. As in
[27], both X and sig(X) denote the signature of X.

2 For efficiency, this test is approximated by a matching with a small set of templates.

P.A. Bonatti et al.

Algorithm 2. -Mod(Sig,KB)
Input: Ontology KB,
signature Sig
Output: 

-module M of KB w.r.t. Sig

// main
begin

1 M := KB

repeat
M
M := -Mod(-Mod(M, Sig), Sig)

:= M
until M = M
return M

end
function x-Mod(KB,Sig) //
begin

10 M := , T := KB

x  {,}

repeat

changed = false
forall   T do

if  is not x-local w.r.t. Sig  M then

M := M  {}
T := T \ {}
changed = true

until changed = false
return M

end

Definition 1. (Module, locality) A -substitution for KB and a signature
Sig is a substitution  over KB \ Sig that maps each concept name on  or ,
and every role name on the universal role or the empty role. A strong axiom 
is -local iff () is a tautology. A DI C n D is -local iff C  D is -local.
A set of axioms is -local if all of its members are. We say that an axiom  is
-local (resp. -local ) if  is -local where the substitution  uniformly maps
concept names to  (resp. ).
A (syntactic) module of KB with respect to Sig is a set M  KB such that
KB \ M is -local for some -substitution  for KB and M  Sig.

Let ModDI(Sig,KB) be the variant of -Mod(Sig,KB) where the test in
line 2 is replaced with (the complement of) the  or -locality condition of
Def. 1 (that covers DIs, too). Using the original correctness argument for -
Mod(Sig,KB) cf. [19, Prop.42], it is easy to see that ModDI(Sig,KB) returns a
syntactic module of KB w.r.t. Sig according to Def. 1. If KB contains no DIs
(i.e. it is classical), then Def. 1 is essentially a rephrasing of standard syntactic
notions of modules and locality,3 so
3 Informally, 

-Mods greedy strategy tends to find small Def. 1s modules.
?

?

?
for all queries  such that   Sig, M |=  iff KB |= .

(34)
However, proving that -ModDI(Sig,KB) is correct for full DLN is far
from obvious: removing axioms from KB using module extractors is incorrect
under most nonmonotonic semantics (including circumscription, default logic
and autoepistemic logic). The reason is that nonmonotonic inferences are more
powerful than classical inferences, and the syntactic locality criterions illustrated
above fail to capture some of the dependencies between different symbols.
Example 6. Given the knowledge base {  A B} and Sig = {A}, the module
extractor returns an empty module (because by setting B =  the only axiom
in the KB becomes a tautology). The circumscription of this KB, assuming that
both A and B are minimized, does not entail A  , while the circumscription
of the empty module entails it.

Now we illustrate the correct way of applying -ModDI to a DLN KB =
S  D and a query  (subsumption or assertion). Let  be the union of  and
the set of normality concepts occurring in KB. Let

M0 = ModDI(,KB  N) ,

where N abbreviates {NC  C | NC  }.
Example 7. Let KB be the knowledge base:

B  C  A
F n A

A  B
A n D  E

(35)
(36)

(37)
(38)
and  the query NA  D. M0 is calculated as follows: first, since no normality
concept occurs in KB,  is equal to the signature  = {NA, D}.
Algorithm 2 calls first the function -Mod(KB  N,). Notice that by
replacing C and F with , axioms (37) and (38) become tautologies. Con-
=
sequently,
{(35), (36), NA  A}.
and . Now, replacing B with  makes A  B
= {(36), NA  A}. It is easy
a tautology, so the resulting knowledge base is KB
to see that a fix point is reached and hence KB
is returned.

it is easy to see that the returned knowledge base is KB

Then, -Mod is called on KB

We shall prove that (KB  M0) can be used in place of KB to answer

query . This saves the cost of processing KB

all \ M, where

0  M0)  {NC |   D  M0, NC  }.

M = (KB
all \ M is usually even larger than KB \ M0 because for each DI

Note that KB
  M0, all its translations NC (NC  ) are removed from M.
Lemma 1. M is a module of KB
Lemma 2. If M is a module of KB w.r.t. a signature Sig and KB  KB, then
KB  M is a module of KB

all w.r.t. .

w.r.t. Sig.

P.A. Bonatti et al.

The relationship between (KB  M0) and KB is:
Lemma 3. KB  M  (KB  M0)  KB .
As a consequence, the modularized construction is correct:
Theorem 1. (KB  M0) |=  iff KB |= .
Proof. By Lemmas 1 and 2, and (34), KB |=  iff KBM |= . The Theorem

then follows by Lemma 3.

i

i

4 Optimistic Computation
The construction of KB repeats the concept consistency check (5) over a
}) that share a (possibly large)
 {NC
sequence of knowledge bases (KB
i1
common part KB
0 , so incremental reasoning mechanisms help by avoiding multiple computations of the consequences of KB
0 . On the contrary, the set of NC
may change significantly at each step due to the filtering i. This operation
requires many axiom deletions, which as already highlighted in [20], are less efficient than monotonically increasing changes. The optimistic algorithm introduced
equivalent to KB in a way
here (Algorithm 3) computes a knowledge base KB
that tends to reduce the number of deletions, as it will be assessed in Sec. 5.
Phase 1 optimistically assumes that the DIs with the same priority as NC
do not contribute to entailing NC   in (5), so they are not filtered with i
in line 3. Phase 2 checks whether the DIs discarded during Phase 1 are actually
overridden by applying i (lines 14 and 21). DIs are processed in non-increasing
priority order as much as possible (cf. line 19) so as to exploit monotonic incremental classifications.
The following theorem shows the correctness of Alghorithm 3 in case the
normality concepts do not occur in KB, but only in the queries. We call such
knowledge bases N-free. It is worth noting that the optimistic method is not
generally correct when KB is not N-free and || > 1, yet it may still be applicable
after the module extractor if the latter removes all normality concepts from KB.
Theorem 2. If KB is N-free, then Algorithm 3s output is equivalent to KB.

j

i

5 Experimental Assessment

Currently there are no real KBs encoded in a nonmonotonic DL, because
standard DL technology does not support nonmonotonic reasoning. The nonmonotonic KBs encoded in the hybrid rule+DL system DLV-Hex [14] are not
suited to our purposes because they do not feature default inheritance due to a
restriction of the language: DL predicates cannot occur in rule heads, so rules
cannot be used for encoding default inheritance. Consequently, synthetic test
cases are the only choice for evaluating our algorithms. We start with the two
?

?

?
such that KB  KB

// Phase 1

Algorithm 3. Optimistic-Method
Input: KB = S  D, 
Output: a knowledge base KB
compute a linearization 1, . . . , |D| of D
 :=  //  collects the prototypes
 :=  // ordered list of all discarded NC
for i = 1, 2, . . . , |D| do
:=   {NC
0   |= NC   then
 := 

for NC   do


if KB

}

i

i

else

append NC

i

to 

= KB

// Phase 2
0  
KB
while  =  do

extract from  its first element NC
if (KB
KB
extract all NE

0  ) i {NC
:= KB  {NC  }

k with E = C from 

} |= NC   then

i

i

else

is actually overridden

// NC
i
 := i
while  contains some ND
0  ) j {ND
:= KB  {ND  }

extract from  the first such ND
if (KB
KB
extract all NE
 := j

j

j

k with E = D from 

such that   j do
} |= ND   then

j

test suites introduced in [8] as they have been proved to be nontrivial w.r.t. a
number of structural parameters, including nonclassical features like exception
levels and the amount of overriding. The two test suites are obtained by modifying the popular Gene Ontology (GO)4, which contains 20465 atomic concepts
and 28896 concept inclusions. In one test suite, randomly selected axioms of GO
are turned into DIs, while in the second suite random synthetic DIs are injected
in GO. The amount of strong axioms transformed into DIs is controlled by CI-
to-DI-rate, expressed as the percentage of transformed axioms w.r.t. |GO| while
the amount of additional synthetic DIs is controlled by Synthetic-DI-rate, i.e. the
ratio |D|/|GO|. The number of conflicts between DIs can be increased by adding

4 http://www.geneontology.org

P.A. Bonatti et al.

an amount of random disjointness axioms specified by parameter DA-rate (see
[8] for further details).

The experiments were performed on an Intel Core i7 2,5GHz laptop with 16
GB RAM and OS X 10.10.1, using Java 1.7 configured with 8 GB RAM and
3 GB stack space. Each reported value is the average execution time over ten
nonmonotonic ontologies and fifty queries on each ontology. For each parameter
setting, we report the execution time of: (i) the naive DLN reasoner of [8]; (ii)
the optimistic method introduced in Sec. 4 (Opt); (iii) the module extraction
method of Sec. 3 (Mod) using the module extraction facility of the OWLAPI;
(iv) the sequential execution of Mod and Opt, i.e. Algorithm 3 is applied to
KB  M0. This combined method is correct by Theorem 2 and Theorem 1.

Table 2. Impact of |D| on performance (sec)  DA rate = 15%  priority (1)

CI-to-DI naive opt mod mod+opt

Synth DIs naive opt mod mod+opt

05% 12.91 05.93 00.30
10% 22.37 11.13 00.32
15% 31.50 15.90 00.37
20% 42.97 20.67 00.40
25% 55.22 25.17 00.44

00.25
00.27
00.32
00.33
00.36

05%
10%
15%
20%
25%

11.64 06.94 0.41
21.66 11.21 0.62
32.80 14.90 1.11
41.51 18.82 2.01
51.85 22.33 3.05

0.42
0.67
1.64
1.42
2.09

Table 2 shows the impact of the number of DIs on response time for the two
test suites, as DI rate ranges from 5% to 25%. The methods Mod and Mod+Opt
are slightly less effective in the second suite probably because random defaults
connect unrelated parts of the ontology, thereby hindering module extraction. In
both suites, Opts speedup factor (w.r.t. the naive method) is about two, while
on average Mod is approximately 87 times faster in the first test suite (max.
speedup 125), and 28 times faster in the second (max. speedup 35). On average,
the combined method yields a further 13% improvement over Mod alone; the
maximum reduction is 31% (2nd suite, Synthetic-DI-rate=25%, DA-rate=15%).
The additional conflicts induced by injected disjointness axioms have moderate
effects on response time (cf. Table 3). Mod+Opts average response time across
both test suites is 0.7 sec., and the longest Mod+Opt response time has been
2.09 sec. As a term of comparison, a single classification of the original GO takes
approximately 0.4 seconds.
Table 4 is the analogue of Table 2 given priority (2). With respect to priority (1), the computation time for KB and query answering in the first test
suite grows faster for the naive algorithm, while there are smaller differences
for the optimized approaches (the reponse times of the combined approach are
almost identical). In the second test suite, the performance of the naive algorithms decreases less dramatically, while the optimized methods seem slightly
less effective than in the first test suite. In all cases, the speedups of Mod and
Mod-Opt remain well above one order of magnitude. The performance as DAs
grow has similar features (see Table 5).
?

?

?
Table 3. Impact of DAs on performance (sec)  DI rate = 15%  priority (1)

Test suite 1 (CI-to-DI)

Test suite 2 (Synth. DIs)

DA naive opt mod mod+opt

DA naive opt mod mod+opt

05% 29.88 13.21 0.36
10% 32.96 14.08 0.37
15% 31.50 15.90 0.37
20% 34.23 16.23 0.39
25% 36.47 17.80 0.40
30% 37.71 18.09 0.40

0.31
0.32
0.32
0.33
0.34
0.34

05% 28.20 12.63 0.99
10% 30.18 13.68 1.04
15% 32.80 14.90 1.11
20% 35.68 16.29 1.18
25% 37.46 17.02 1.25
30% 38.37 18.79 1.36

0.84
0.97
1.06
1.10
1.15
1.23

Table 4. Impact of |D| on performance (sec)  DA rate = 15%  priority (2)

CI-to-DI naive

opt mod mod+opt

Synth DIs naive opt mod mod+opt

22.01 05.74 00.30
05%
52.82 11.48 00.32
10%
15%
81.84 16.56 00.34
20% 133.62 20.51 00.38
25% 193.27 26.42 00.41

00.25
00.28
00.31
00.33
00.36

05%
10%
15%
20%
25%

12.76 07.21 0.45
23.72 14.44 0.81
34.53 17.05 1.57
44.92 21.77 2.67
55.92 25.77 3.87

0.46
0.86
1.21
1.96
2.46

Table 5. Impact of DAs on performance (sec)  DI rate = 15%  priority (2)

Test suite 1 (CI-to-DI)

Test suite 2 (Synth. DIs)

DA naive opt mod mod+opt

DA naive opt mod mod+opt

05% 84.53 15.02 0.34
10% 90.38 16.12 0.35
15% 91.84 16.56 0.35
20% 92.93 16.67 0.36
25% 93.54 17.76 0.37
30% 96.37 19.49 0.38

0.29
0.30
0.31
0.31
0.32
0.33

05% 29.55 14.93 1.28
10% 30.81 15.82 1.41
15% 34.54 17.05 1.57
20% 36.79 16.93 1.62
25% 40.86 17.90 1.78
30% 43.35 18.74 1.79

1.07
1.15
1.21
1.27
1.36
1.34

The above test sets are N-free. We carried out a new set of experiments by
randomly introducing normality concepts in DIs, within the scope of quanti-
fiers.5 Specifically, R.C is transformed into R.N C. The response times of the
naive algorithm and Mod6 under priority (1) are listed in Table 6 for increasing values of || (that is directly related to the amount of normality concepts
occurring in KB). We estimate that the values of || considered here are larger
than what should be expected in practice, given the specific role of explicit normality concepts, cf. footnote 5. Such values are also much larger than in N-free

5 So far, all the application examples that are not N-free satisfy this restriction, as
apparently the only purpose of explicit normality concepts is restricting default role
ranges to normal individuals, cf. Ex. 12 and the nomonotonic design pattern in [8,
Sec. 3.3].

6 In this setting Opt and Mod+Opt are not applicable, in general.

P.A. Bonatti et al.

Table 6. Impact of normal roles values (sec)  DI rate = 25% DA rate = 15%

||

Test suite 1

naive 1794.37 >30 min. >30 min. >30 min. >30 min.
mod

39.22

25.32

7.26

2.31

14.77
Test suite 2

naive >30 min. >30 min. >30 min. >30 min. >30 min.
mod

327.4

103.4

211.5

459.2

586.7

experiments, where || is bounded by the query size. Response times increase
accordingly. In most cases, the naive algorithm exceeded the timeout. In the
first test suite, Mod remains well below 1 minute; in the second suite it ranges
between 100 seconds and 10 minutes. The reason of the higher computation
times in the second suite is that the extracted modules are significantly larger,
probably due to the random dependencies between concept names introduced
by fully synthetic DIs.

6 Conclusions

The module-based and optimistic optimizations introduced here are sound and
complete, where the later applies only if the knowledge base is N-free. In our
experiments, the combined method (when applicable) and the module-based
method make DLN reasoning at least one order of magnitude faster (and up to
780 times faster in some case). In most cases, optimized reasoning is compatible
with real time DLN reasoning. This is the first time such performance is reached
over nonmonotonic KBs of this size: more than 20K concept names and over 30K
inclusions.7 Our approach brings technology closer to practical nonmonotonic
reasoning with very large KBs. Only the random dependencies introduced by
synthetic DIs, combined with numerous restrictions of role ranges to normal
individuals, can raise response time over 40 seconds; in most of the other cases,
computation time remains below 2 seconds.

We are currently exploring a more aggressive module extraction approach,
capable of eliminating some of the normality concepts in  and related axioms.
Besides improving performance over non-N-free KBs, a more powerful module
extractor might enable the application of the combined Mod+Opt method to
non-N-free DLN knowledge bases, by removing all normality concepts from KB
before Opt is applied.

We are also planning to adopt a different module extractor [24] that is promis-

ing to be faster than the OWLAPI implementation.

Last but not least, we are progressively extending the set of experiments
by covering the missing cases and by widening the benchmark set, using real
ontologies different from GO as well as thoroughly synthetic ontologies.
7 Good results have been obtained also for KBs with 5200 inclusions under rational
closure semantics [9, 10].
?

?

?
Acknowledgments. The authors would like to thank the reviewers for their valuable
comments and suggestions. This work has been partially supported by the PRIN project
Security Horizons.
