LDQL: A Query Language for the Web

of Linked Data

Olaf Hartig1 and Jorge P erez2(B)

1 Hasso-Plattner-Institute for IT Systems Engineering, Potsdam, Germany

2 Department of Computer Science, Universidad de Chile, Santiago, Chile

http://olafhartig.de/

jperez@dcc.uchile.cl

Abstract. The Web of Linked Data is composed of tons of RDF documents interlinked to each other forming a huge repository of distributed
semantic data. Effectively querying this distributed data source is an
important open problem in the Semantic Web area. In this paper, we propose LDQL, a declarative language to query Linked Data on the Web.
One of the novelties of LDQL is that it expresses separately (i) patterns that describe the expected query result, and (ii)Web navigation
paths that select the data sources to be used for computing the result.
We present a formal syntax and semantics, prove equivalence rules, and
study the expressiveness of the language. In particular, we show that
LDQL is strictly more expressive than the query formalisms that have
been proposed previously for Linked Data on the Web. The high expressiveness allows LDQL to define queries for which a complete execution
is not computationally feasible over the Web. We formally study this
issue and provide a syntactic sufficient condition to avoid this problem;
queries satisfying this condition are ensured to have a procedure to be
effectively evaluated over the Web of Linked Data.

1 Introduction

In recent years an increasing amount of structured data has been published
and interlinked on the World Wide Web (WWW) in adherence to the Linked
Data principles [3]. These principles are based on standard Web technologies. In
particular, (i) the Hypertext Transfer Protocol (HTTP) is used to access data,
(ii) HTTP-based Uniform Resource Identifiers (URIs) are used as identifiers
for entities described in the data, and (iii) the Resource Description Framework (RDF) is used as data model. Then, any HTTP URI in an RDF triple
presents a data link that enables software clients to retrieve more data by looking up the URI with an HTTP request. The adoption of these principles has lead
to the creation of a globally distributed dataspace: the Web of Linked Data.

The emergence of the Web of Linked Data makes possible an online execution of declarative queries over up-to-date data from a virtually unbounded
set of data sources, each of which is readily accessible without any need for
implementing source-specific APIs or wrappers. This possibility has spawned
c Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 7391, 2015.
DOI: 10.1007/978-3-319-25007-6 5

O. Hartig and J. P erez

research interest in approaches to query Linked Data on the WWW as if it was
a single (distributed) database. For an overview on query execution techniques
proposed in this context refer to [12].

The main contribution of this paper is the proposal of LDQL, a novel query
language for the Web of Linked Data. The most important feature of LDQL is
that it clearly separates query components for selecting query-relevant regions
of the Web of Linked Data, from components for specifying the query result
that has to be constructed from the data in the selected regions. The most basic
construction in LDQL are tuples of the form L, Q where L is an expression used
to select a set of relevant documents, and Q is a query intended to be executed
over the data in these documents as if they were a single RDF repository. In
an abstract setting one can use several formalisms to express L and Q. In our
proposal, for the former part we introduce the notion of link path expressions that
are a form of nested regular expressions (with some other important features)
used to navigate the link graph of the Web. For the latter, we use standard
SPARQL graph patterns. To begin evaluating these queries one needs to specify
a set of seed URIs. The language also possesses features to dynamically (at query
time) identify new seed URIs to evaluate portions of a query. Additionally, such
queries can be combined by using conjunctions, disjunctions, and projection. We
present a formal syntax and semantics for LDQL, propose some rewrite rules,
and study its expressive power.

While there does not exist a standard language for expressing queries over
Linked Data on the WWW, a few options have been proposed. In particular, a
first strand of research focuses on extending the scope of SPARQL such that an
evaluation of SPARQL queries over Linked Data has a well-defined semantics [9,
11,14,18]. A second strand of research focuses on navigational languages [7,14].
Although these languages have different motivations, a commonality of all these
proposals is that, in contrast to LDQL, the definition of query-relevant regions
of the Web of Linked Data and the definition of query-relevant data within the
specified regions are mixed.

As our second main contribution we compare LDQL with three previously
proposed formalisms for querying the Web of Linked Data: SPARQL under
reachability-based query semantics [11], NautiLOD [7], and SPARQL Property
Path patterns under context-based semantics [14]. We formally prove that LDQL
is strictly more expressive than every one of these. We show that for every query
Q in the previous languages, one can effectively construct an LDQL query which
is equivalent to Q. Moreover, for every one of the previous languages, there exists
an LDQL query that cannot be expressed in that language. These results show
that LDQL presents an interesting expressive power.

The downside of the expressiveness provided by LDQL is the existence of
queries for which a complete execution is not feasible in practice. To capture
this issue formally, we define a notion of Web-safeness for LDQL queries. Then,
the obvious question that arises is how to identify LDQL queries that are Web-
safe. Our last technical contribution is the identification of a sufficient syntactic
condition for Web-safeness.
?

?

?
The rest of the paper is structured as follows. Section 2 introduces a data
model that provides the basis for defining the semantics of LDQL. In Section 3
we formally define the syntax and semantics of LDQL and show some simple
algebraic properties. In Section 4 we compare LDQL with the three mentioned
languages, and in Section 5 we focus on Web-safeness. Section 6 concludes the
paper and sketches future work. Proofs of the formal results in this paper can
be found in an extended version of the paper [13].

A preliminary version of some of the results in this paper have been presented
in a workshop [10]. This paper is a substantial extension of [10] refining the
definition of LDQL and introducing important changes to the syntax and the
semantics of the language. Moreover, the comparison with previous proposals
was not discussed in [10].

2 Data Model

In this section we introduce a structural data model that captures the concept
of a Web of Linked Data formally. As usual [7,9,11,14,18], for the definitions
and analysis in this paper, we assume that the Web is fixed during the execution
of any single query.
We use the RDF data model [5] as a basis for our model of a Web of Linked
Data. That is, we assume three pairwise disjoint, infinite sets U (URIs), B (blank
nodes), and L (literals). An RDF triple is a tuple s, p, o  T with T = (U 
B)  U  (U  B  L). For any RDF triple t = s, p, o we write uris(t) to denote
the set of all URIs in t.
Additionally, we assume another infinite set D that is disjoint from U, B,
and L, respectively. We refer to elements in this set as documents and use them
to represent the concept of Web documents from which Linked Data can be
extracted. Hence, we assume a function, say data, that maps each document
d  D to a finite set of RDF triples data(d)  T such that the data of each
document uses a unique set of blank nodes.

Given these preliminaries, we are ready to define a Web of Linked Data.

Definition 1. A Web of Linked Data is a tuple W = D, adoc that consists
of a set of documents D  D and a partial function adoc : U  D that is
surjective.

Function adoc of a Web of Linked Data W = D, adoc captures the relationship between the URIs that can be looked up in this Web and the documents
that can be retrieved by such lookups. Since not every URI can be looked up, the
function is partial. For any URI u  U with u  dom(adoc) (i.e., any URI that
can be looked up in W ), document d = adoc(u) can be considered the authoritative source of data for u in W (hence, the name adoc). To accommodate for
documents that are authoritative for multiple URIs, we do not require injectivity for function adoc. However, we require surjectivity because we conceive
documents as irrelevant for a Web of Linked Data if they cannot be retrieved by
any URI lookup in this Web.

O. Hartig and J. P erez

Fig. 1. The link graph GWex of our example Web of Linked Data Wex.

Let W = D, adoc be a Web of Linked Data. W is said to be finite [11]
if its set D of documents is finite. In this paper we assume that every Web of
Linked Data is finite. Given documents d, d  D and a triple t  data(d), we
say that a URI u  uris(t) establishes a data link from d to d, if adoc(u) = d.
As a final concept, we formalize the notion of a link graph associated to W.
This graph has documents in D as nodes, and directed edges representing data
links between documents. Each edge is associated with a label that identifies
both the particular RDF triple and the URI in this triple that establishes the
corresponding data link. These labels shall provide the basis for defining the
navigational component of our query language.
Definition 2. The link graph of a Web of Linked Data W = D, adoc,
is a directed, edge-labeled multigraph, GW = D, EW, with set of edges
dsrc, (t, u), dtgt | t  data(dsrc), u 
EW  D  (T  U)  D defined as EW =

uris(t) and dtgt = adoc(u)

For a link graph edge e = dsrc, (t, u), dtgt, tuple (t, u) is the label of e.
Moreover, we sometimes write e  GW to denote that e is an edge in the link
graph GW .
Example 1. As a running example for this paper assume a simple Web of Linked
Data Wex = Dex, adocex with three documents, dA, dB, and dC (i.e., Dex =
{dA, dB, dC}). The data in these documents are the following sets of RDF triples:

.

data(dA) = {uA, p1, uB,
uB, p2, uC};

data(dB) = {uB, p1, uC};
data(dC) = {uA, p2, uC};

and for function adocex we have: adocex(uA) = dA, adocex(uB) = dB, adocex(uC) =
dC, and adocex(p1) = dA (i.e., dom(adocex)={uA, uB, uC, p1}). This Web contains
10 data links. For instance, URI uA in the RDF triple uA, p2, uC  data(dC)
establishes a data link to document dA. Hence, the corresponding edge in the
. Figure 1 illustrates the link graph
link graph of Wex is
GWex with all 10 edges.

dC, (uA, p2, uC, uA), dA
?

?

?
3 Definition of LDQL

This section defines our Linked Data query language, LDQL. LDQL queries are
meant to be evaluated over a Web of Linked Data and each such query is built
?

?

?
from two types of components: Link path expressions (LPEs) for selecting que-
ry-relevant documents of the queried Web of Linked Data; and SPARQL graph
patterns for specifying the query result that has to be constructed from the
data in the selected documents. For this paper, we assume that the reader is
familiar with the definition of SPARQL [8], including the algebraic formalization introduced in [2,16]. In particular, for SPARQL graph patterns we closely
follow the formalization in [2] considering operators AND, OPT, UNION, FILTER, and
GRAPH, plus the operator BIND defined in [8]. We begin this section by introducing
the most basic concept of our language, the notion of link patterns. We use link
patterns as the basis for navigating the link graph of a Web of Linked Data.

3.1 Link Patterns

U  { , +}  U  { , +}  U  L  { , +}
.
A link pattern is a tuple in
Link patterns are used to match link graph edges in the context of a designated
context URI. The special symbol + denotes a placeholder for the context URI.
denotes a wildcard that will drive the direction of the
The special symbol
navigation. Before formalizing how link graph edges actually match link patterns,
we show some intuition. Consider the link graph of Web Wex in Example 1 (see
. Intuitively, in the context of URI uA, the
Fig. 1), and the link pattern +, p1,
edge with label (uA, p1, uB, uB) from document dA to document dB, matches
. Notice that in the matching, the context URI uA
the link pattern +, p1,
takes the place of symbol +, and uB takes the place of the wildcard symbol
. Notice that uB also denotes the direction of the edge that matches the link
pattern. On the other hand, the edge with label (uA, p1, uB, uA) from dA to
dA, does not match +, p1,
; although uB can take the place of the wildcard
, the direction of the edge is not to uB. That is, when matching an edge
symbol
labeled by (t, u) we require URI u to be taking the place of a wildcard in the link
pattern. When more than one wildcard symbol is used, the link pattern can be
matched by edges pointing to the direction of any of the URIs taking the place
of a wildcard. For instance, in the context of uA, the link pattern 
 is
matched by edges dA, (uB, p2, uC, uB), dB and dA, (uB, p2, uC, uC), dC. The
next definition formalizes this notion of matching.
Definition 3. A link graph edge with label (x1, x2, x3, u) matches a link
pattern y1, y2, y3 in the context of a URI uctx if the following two properties
hold:
1. there exists i  {1, 2, 3} such that yi = and xi = u, and
2. for every i  {1, 2, 3} either yi = + and xi = uctx, or yi = xi, or yi = .

, p2,

One of the rationales for adopting the notion of a context URI and the +
symbol in our definition of link patterns, is to support cases in which link graph
navigation has to be focused solely on data links that are authoritative. A data
link represented by link graph edge dsrc, (t, u), dtgt  GW is authoritative in a
Web of Linked Data W = D, adoc if dsrc = adoc(u) for some URI u  uris(t).
Thus, if we fix a context URI uctx, a link pattern that uses the + symbol allows
us to follow only authoritative data links from document dctx = adoc(uctx).

O. Hartig and J. P erez

3.2 LDQL Queries
The most basic construction in LDQL queries are tuples of the from L, P where
L is an expression used to select a set of documents from the Web of Linked
Data, and P is a SPARQL graph pattern to query these documents as if they
were a single RDF dataset. In an abstract setting, one can use any formalism
to specify L as long as L defines sets of RDF documents. In our proposal we
use what we call link path expressions (LPEs) that are a form of nested regular
expressions [17] over the alphabet of link patterns. Every link path expression
begins its navigation in a context URI, traverses the Web, and returns a set of
URIs; these URIs are used to construct an RDF dataset with all the documents
to be retrieved by looking up the URIs. This dataset is passed to the SPARQL
graph pattern to obtain the final evaluation of the whole query. Besides the
basic constructions of the form L, P, in LDQL one can also use AND, UNION and
projection, to combine them. We also introduce an operator SEED that is used
to dynamically change, at query time, the seed URI from which the navigation
begins. The next definition formalizes the syntax of LDQL queries and LPEs.
Definition 4. The syntax of LDQL is given by the following production rules
in which lp is an arbitrary link pattern, ?v is a variable, P is a SPARQL graph
pattern (as per [2]), V is a finite set of variables, and U is a finite set of URIs:
q := lpe, P | (SEED U q) | (SEED ?v q) | (q AND q) | (q UNION q) | V q
lpe :=  | lp | lpe/lpe | lpe|lpe | lpe

 | [lpe] | ?v, q

Any expression that satisfies the production q is an LDQL query, any expression that satisfies the production lpe is a link path expression (LPE), and
any LDQL query of the form lpe, P is a basic LDQL query.

Before going into the formal semantics of LDQL and LPEs, we give some
more intuition about how these expressions are evaluated in a Web of Linked
Data W. As mentioned before, the most basic expression in LDQL is of the
form lpe, P. To evaluate this expression over W we will need a set S of seed
URIs. When evaluating lpe, P, every one of the seed URIs in S will trigger a
navigation of link graph GW via the link path expression lpe starting on that
seed. That is, the seed URIs are passed to lpe as context URIs in which the LPE
should be evaluated. These evaluations of lpe will result in a set of URIs that
are used to construct a dataset over which P is finally evaluated.
Regarding the navigation of link graph GW, the most basic form of navigation is to follow a single link graph edge that matches a link pattern lp. When
a navigation via a link pattern lp is triggered from a context URI u, we proceed as follows. We first go to the authoritative document for u, that is adoc(u),
and try to find outgoing link graph edges that match lp in the context of u (as
explained in Section 3.1). Every one of these matches defines a new context URI
u from which the navigation can continue. More complex forms of navigation
are obtained by combining link patterns via classical regular expression operators such as concatenation /, disjunction |, and recursive concatenation ().
?

?

?
The nesting operator [] is used to test for existence of paths. When a context
URI u is passed to an expression [lpe], it checks whether GW contains a path from
dctx = adoc(u) that matches lpe. If such a path exists, the navigation can continue from the same context URI u. The most involved form of navigation is by
using the expression ?v, q with q an LDQL query. To evaluate this expression
from context URI u one first has to pass u as a seed URI for q and recursively
evaluate q from that seed. This evaluation generates a set of solution mappings,
and for every one of these mappings its value on variable ?v is used as the new
context URI from which the navigation continues. Finally, note that our notion
of LPEs does not provide an operator for navigating paths in their inverse direc-
tion. The reason for omitting such an operator is that traversing arbitrary data
links backwards is impossible on the WWW.
To formally define the semantics of LDQL we need to introduce some termi-
nology. We first define a function datasetW () that from a set of URIs constructs an RDF dataset with all the documents pointed to by those URIs
in W. Formally, given a Web of Linked Data W = D, adoc and a set U
of URIs, datasetW (U) is an RDF dataset (as per [2,8]) that has the set of
triples {t  data(adoc(u)) | u  U  dom(adoc)} as default graph. Moreover,
for every URI u  U  dom(adoc), datasetW (U) contains the named graph
u, data(adoc(u)).
Example 2. Consider the Web Wex
in Example 1 and the set of URIs
U = {uA, uC}. Then datasetWex(U) has {uA, p1, uB,uB, p2, uC,uA, p2, uC}
as default graph, and two named graphs, uA,{uA, p1, uB,uB, p2, uC} and
uC,{uA, p2, uC}.

In the formalization of the semantics of LDQL, we use the standard join operator  over sets of solution mappings [8,16]. We also make use of the semantics
of SPARQL graph patterns over datasets as defined in [2]. In particular, given
an RDF dataset D, an RDF graph G in D, and a SPARQL graph pattern P , we
denote by [[P ]]D

G the evaluation of P over G in D [2, Definition 13.3].

We are now ready to formally define the semantics of LDQL and LPEs. Given
a Web of Linked Data W and a set S of URIs, we formalize the evaluation of
LDQL queries over W from the seed URIs S, as a function [[]]S
W that given an
LDQL query, produces a set of solution mappings. Similarly, the evaluation of
LPEs over W from a context URI u, is formalized as a function [[]]u
W that given
an LPE, produces a set of URIs.
Definition 5. Given a finite set S  U, the S-based evaluation of LDQL
queries over a Web of Linked Data W =D, adoc, denoted by [[]]S
W , is defined
recursively as follows:

O. Hartig and J. P erez

[[lpe, P]]S
[[(SEED U q)]]S
[[(SEED ?v q)]]S
[[(q1 UNION q2)]]S
[[(q1 AND q2)]]S
[[ V q ]]S
?

?

?
W = [[P ]]
G where D = datasetW
W = [[q]]U
W ,

W  {u}
{u}
[[q]]
uU
W =
W  [[q2]]S
W = [[q1]]S
W ,
W = [[q1]]S
W  [[q2]]S
W ,
W = { | there exists  [[q]]S
?

?

?
uS[[lpe]]u
?

?

?
with default graph G,

where u = {?v  u} for all u  U,

compatible and dom() = dom(

W such that  and 
)  V }.

are

Now for the semantics of LPEs, given a context URI uctx  dom(adoc), the
uctx-based evaluation of LPEs over W, denoted by [[]]uctx
W , is defined recursively
as follows:
?

?

?
,

, p1,

, p2,

},

 ... ,

 [[lpe/lpe/lpe]]uctx

[[  ]]uctx
[[lp]]uctx

 [[lpe/lpe]]uctx
= },

such that (?v) = u}.

{uctx}
W =  for every LPE.
/[

W = {uctx},
W = {u  U | there exist a link graph edge dsrc, (t, u), dtgt  GW , with
dsrc = adoc(uctx), that matches lp in the context of uctx},
W = {u  [[lpe 2]]u
W | u  [[lpe 1]]uctx
[[lpe 1/lpe 2]]uctx
 [[lpe 2]]uctx
[[lpe 1|lpe 2]]uctx
W = [[lpe 1]]uctx
W = {uctx}  [[lpe]]uctx
[[lpe
]]uctx
W = {uctx | [[lpe]]uctx
[[ [lpe] ]]uctx
W = {u  U | there exists   [[q]]
[[?v, q ]]uctx
Moreover, if uctx / dom(adoc), then [[lpe]]uctx
]. This LPE selects docExample 3. Let lpe ex be the LPE 
uments that can be reached via arbitrarily long paths of data links with predicate p1 and, additionally, have some outgoing data link with predicate p2. For
our example Web Wex and context URI uA, the LPE selects documents dA =
= {uA, uC}.
adocex(uA) and dC = adocex(uC). More precisely, we have [[lpe ex]]uA
Wex
Note that document dB can also be reached via a p1path, but it does not pass
the p2related test.
Example 4. Consider a set of URIs Sex = {uA} and a basic LDQL
, Bex whose LPE is lpe ex as introduced in Example 3 and
query lpe ex
whose SPARQL graph pattern is a basic graph pattern that contains
two triple patterns, Bex = {?x, p1, ?y,?x, p2, ?z}. Given that we have
[[lpe ex]]uA
) has the default
graph {uA, p1, uB,uB, p2, uC,uA, p2, uC} (cf. Example 2). Then, according
Wex
to the query semantics, the result of query lpe ex
, Bex over Wex using seeds Sex
consists of a single solution mapping, namely  = {?x  uA, ?y  uB, ?z  uC}.
Example 5. Consider an LDQL query qex =
whose
subquery is a basic LDQL query that has a single triple pattern as its SPARQL
graph pattern. Additionally, let q
be the
basic LDQL query introduced in Example 4, and let q
ex be the conjunction
of these two queries; i.e., q
ex). By Example 4 we know that

,?x, p1, ?w

SEED ?x
,{?x, p1, ?y,?x, p2, ?z}

= {uA, uC} (cf. Example 3), datasetWex([[lpe ex]]uA

ex =

lpe ex
ex = (qex AND q

Wex
?

?

?
= {} with  = {?x  uA, ?y  uB, ?z  uC}. Furthermore, based
[[q
ex]]Sex
= {1, 2} with
Wex
on the data given in Example 1, it is easy to see that [[qex]]Sex
1 = {?x  uA, ?w  uB} and 2 = {?x  uB, ?w  uC}. For the Sex-based
Wex
and [[q
evaluation of q
have to be joined.
Thus, we need to compute {1, 2}  {}, which results in a single mapping
 = 1   = {?x  uA, ?w  uC, ?y  uB, ?z  uC}.

ex over Wex, the result sets [[qex]]Sex
Wex

ex]]Sex
Wex

3.3 Algebraic Properties of LDQL Queries

W = [[q]]S

As a basis for the discussion in the next sections, we show some simple algebraic properties. We say that LDQL queries q and q are semantically equivalent,
denoted by q  q, if [[q]]S
W holds for every Web of Linked Data W and
every finite set S  U.
Lemma 1. The operators AND and UNION are associative and commutative.
Lemma 2. Let q1, q2, q3 be LDQL queries, the following semantic equivalences
hold:

V (q1 UNION q2)  (V q1 UNION V q2)

(q1 AND (q2 UNION q3))  ((q1 AND q2) UNION (q1 AND q3))
(SEED U (q1 UNION q2))  ((SEED U q1) UNION (SEED U q2))
(SEED ?v (q1 UNION q2))  ((SEED ?v q1) UNION (SEED ?v q2))

(1)
(2)
(3)
(4)

Lemma 1 allows us to write sequences of either AND or UNION without paren-
theses. Our next result shows the power of the construction ?v, q. In particular,
it shows the somehow surprising finding that link patterns lp, concatenation /,
disjunction |, and the test [], are just syntactic sugar as they can be simulated
by using , ?v, q and ().
Proposition 1. For every LDQL query q, there exists an LDQL query q s.t.
q  q and every LPE in q consists only of the symbol , the construction ?v, q,
and operator ().
Proof (Sketch). The proof is based on a recursive translation of link path expressions beginning with link patterns. For instance, a link pattern of the form
 is encoded by ?v,, (GRAPH ?u (?u, p, ?v)), and we can similarly
+, p,
encode all types of link patterns. To encode / we make use of ?v, q and the
operator AND inside q as follows. Consider an LPE r = r1/r2. It can be shown
that r is equivalent to ?v, q where q is:

SEED ?x r2, (GRAPH ?v { }) 

 r1, (GRAPH ?x { }) AND

Similarly, to encode | we make use of UNION and to encode [] we use projection.
Although not strictly necessary, we decided to keep link patterns and operators /, |, and [] since they represent a natural and intuitive way of expressing
navigation paths.

.

O. Hartig and J. P erez

4 Comparison with Previous Linked Data Query

Formalisms

In this section, we compare LDQL with alternative formalisms to query Linked
Data on the WWW. There are some general query languages for the WWW (pro-
posed before the advent of Linked Data) that are related to our proposal; in
particular, WebSQL [15], which is similar in spirit to LDQL but different in the
features that the languages posses. Two main novelties of LDQL compared with
WebSQL are the possibility to dynamically select seed URIs at query time, and
the traversal of links according to properties of the queried documents that can
be defined in the same LDQL query. Neither of these are expressible in WebSQL.
While a complete formal comparison between LDQL and WebSQL is certainly
very interesting, we leave it for future work and, instead, focus on three more
recent proposals of query formalisms for the Web of Linked Data [7,11,14]. We
formally show that LDQL is strictly more expressive than every one of them.

4.1 Comparison with Property Paths Under Context-Based Query

Semantics

Property paths (PPs for short) were introduced in SPARQL 1.1 as a way of
adding navigational power to the language [8]. PPs are a form of regular expressions that are evaluated over a single (local) RDF graph; a PP expression is used
to retrieve pairs a, b of nodes in the graph such that there is a path from a
to b whose sequence of edge labels belongs (as a string) to the regular language
defined by the expression. The syntax of PP expressions is given by the following
grammar1, where p, u1, u2, ... , uk are URIs.

pe := p | !(u1|u2||uk) | pe/pe | pe|pe | pe



A PP-pattern is defined as a tuple of the form , pe,  where pe is a PP expres-
sion, and  and  are in U  L  V.

In [14] the authors adapted the semantics of PP-patterns so that they can
be used to query the Web of Linked Data. The proposed query semantics is
called context-based semantics [14]. To define this semantics, the authors first
introduce the notion of a context selector for a Web of Linked Data W. This
context selector is a function CW() that given a URI u  dom(adoc) returns the
RDF triples in data(adoc(u)) that have u in the subject position. Formally, for
every URI u  dom(adoc) we have CW(u) = {s, p, o  data(adoc(u)) | s = u}.
To simplify the exposition, the authors extended the definition of CW() to also
handle URIs not in dom(adoc), and literals and blank nodes. For any such RDF
term a they define CW(a) as the empty set.

1 In [14] the reverse path construction pe is also considered. We do not consider it
here as the form of navigation of these reverse paths does not represent a traversal
of the link graph.
?

?

?
The context-based semantics for PPs over the Web of Linked Data in [14] is
a bag semantics that follows closely the semantics for PPs defined in the normative semantics of SPARQL 1.1 [8]. Hence, both semantics use a procedure, the
ArbitraryLengthPath procedure [8], to define the semantics of the () operator.
It was shown in [1] that for sets semantics, the normative semantics of PPs can
be defined by using standard techniques for regular expressions. To make the
comparison with LDQL, in this paper we adapt the context-based semantics for
PPs presented in [14] by following the techniques in [1], and consider only sets
of mappings. To this end, we define a function [[]]ctxt
W , that given a PP-pattern,
returns its evaluation under context-based semantics over the Web of Linked
Data W. In the definition, for a solution mapping  and an RDF term , we use
the notation [] with the following meaning: [] = () if   dom(), and
[] =  in the other case. Similarly, [s, p, o] = [s], [p], [o].

[[(, p, )]]ctxt
[[(, !(u1||uk), )]]ctxt

W = { | dom() = {, }  V and [, p, ]  CW ([])}
W = { | dom() = {, }  V and exists p s.t.

[, p, ]  CW ([]) and p / {u1, ... , uk}}
?

?

?
[[(, pe1/pe2, )]]ctxt
[[(, pe1|pe2, )]]ctxt
[[(, pe, )]]ctxt
?

?

?
[[(, pe1, ?v)]]ctxt
W  [[(, pe2, )]]ctxt

W  [[(?v, pe2, )]]ctxt

W = {,}V
W = [[(, pe1, )]]ctxt
W = { | dom() ={, }  V, [] = [] and [] terms(W )}
W  

W [[(, pe/pe/pe, )]]ctxt

W [[(, pe/pe, )]]ctxt

[[(, pe, )]]ctxt

A PP-based SPARQL query [14] is an expression formed by combining PPpatterns using the standard SPARQL operators AND, UNION, OPT, FILTER and so
on, following the standard semantics for these operators [2]. Our next results
show that LDQL is strictly more expressive than PP-based SPARQL queries
under context-based semantics.
Theorem 1. There exists an LDQL query that cannot be expressed as a PPbased SPARQL query under context-based semantics.
?

?

?
+, p,
?

?

?
SEED U

,
Proof (Sketch). One can show that LDQL query q =
with U = {u} cannot be expressed by PPs under context-
(?x, ?x, ?x)
based semantics because this semantics is blind to triples that are not author-
itative. For instance, in a Web W = {d, d}, adoc with data(d) = {u, p, u},
data(d) = {u, p, u,u, u, u}, adoc(u) = d and adoc(u) = d, the evaluation of
q is the solution mapping {?x  u}. Notice that the only authoritative triple in
d is u, p, u as d = adoc(u) = adoc(u). Hence, one can prove that PP-based
SPARQL queries under context-based semantics cannot access triple u, u, u in
d, and thus, will never have {?x  u} as solution.
Theorem 2. Let ,   U  L  V. Then, for every PP-pattern , pe, , there
exists an LDQL query q such that [[, pe, ]]ctxt
W for every Web of Linked
Data W.

W = [[q]]

O. Hartig and J. P erez

Proof (Sketch). In the proof we provide a translation scheme from PPs to LDQL.
One major complication is that PPs can retrieve literals and, in general, values
that are not in dom(adoc), which are difficult to handle by LPEs. For every
PP-pattern ?x, pe, ?y we construct an LDQL query Qpe(?x, ?y). For example,
, ?y, our query is {?x,?y}
for ?x, pe1
/pe2
, and for
?x, !(u1||uk), ?y the translation is
(?x, ?p, ?y) FILTER (?p = u1
. To handle pe we need to use the construction ?v, q of LPEs,
 ?p = uk)
plus ().
?

?

?
Qpe1(?x, ?z) AND Qpe2(?z, ?y)
?

?

?
SEED ?x
?

?

?
,
?

?

?
4.2 Comparison with NautiLOD

NautiLOD is a navigation language to traverse Linked Data on the WWW and
to perform actions (such as sending emails) during the traversal [7]. We compare
LDQL with NautiLOD without action rules. The syntax of NautiLOD expressions (without actions) is given by the following grammar (where p  U and P
is a SPARQL graph pattern).
ne := p | p | 

 | ne/ne | ne|ne | ne

 | ne[(ASK P )]

In terms of our data model2, the semantics of NautiLOD expressions over a Web
of Linked Data W = D, adoc from URI u  dom(adoc) is defined recursively
as follows.


?

?

?
[[ ne

W with u dom(adoc)}

W = {u | u, p, u  data(adoc(u))}
[[ p ]]u
W = {u | u, p, u  data(adoc(u))}
[[ p ]]u
[[
 ]]u
W = {u | u, p, u  data(adoc(u)) for some p  U}
W ={u| u[[ ne2 ]]u
[[ ne1/ne2 ]]u
 [[ ne2 ]]u
[[ ne1| ne2 ]]u
W = [[ ne1 ]]u
W = {u}  [[ ne ]]u
]]u
W = {u | u  [[ ne ]]u
[[ ne[(ASK P )] ]]u

W for some u[[ ne1 ]]u
 [[ ne/ne ]]u

 [[ ne/ne/ne ]]u

, u  dom(adoc) and [[P ]]data(adoc(u))

= }
We next show that for every NautiLOD expression there exists an equivalent
LDQL query. Notice that the evaluation of a NautiLOD expression is a set of
URIs, whereas the evaluation of an LDQL query is a set of mappings. Thus, to
formally state our result we compare NautiLOD with LDQL queries that have
a single free variable. Let q(?x) be an LDQL query with ?x as free variable. We
say that q(?x) and a NautiLOD expression ne are equivalent if for every Web of
Linked Data W = D, adoc and URIs u, u with u  dom(adoc) it holds that
u [[ne]]u
Theorem 3. For every NautiLOD expression ne, there exists an LDQL query
q(?x), with ?x a free variable, that is equivalent to ne.

W if and only if {?x  u}  [[q(?x)]]

 

{u}
.

2 In [7], all URIs have an assigned set of RDF triples (which may be empty). In our
data model one can have URIs not in dom(adoc). Hence, to properly capture the
semantics of NautiLOD in terms of our data model we have to introduce conditions
of the form u  dom(adoc).
?

?

?
/+, p2,

. To translate 

2 is translated into +, p1,

Proof (Sketch). The proof begins with a simple translation that replaces every
. For instance, the
p  U in a NautiLOD expression by a link pattern +, p,
 and
expression p1/p
[(ASK P )] we use ?v, q. The complete translation poses several other complications (as described in the extended version [13]). In particular, the last step of
NautiLOD expressions must be translated by using a SPARQL pattern and not
an LPE. For this we use the following property. Given a regular expression r that
does not generate the empty word, one can always write r as r1/a1||rk/ak
where the ais are base symbols of the alphabet. Thus, we can translate r by
using LPEs to translate the ris as outlined above; next, translate the ais by
using a method similar to the proof of Theorem 2, and finally use UNION for |.

Along the same lines of Theorem 1 one can prove the following result.

Theorem 4. There exists an LDQL query q(?x) that cannot be expressed in
NautiLOD.

4.3 Comparison with SPARQL Under Reachability-Based Query

Semantics

In [11] the author introduces a family of reachability-based query semantics based
on which SPARQL graph patterns can be used as a query language for Linked
Data on the WWW. Similar to how the scope of the SPARQL part of a basic
LDQL query is restricted to particular documents, reachability-based semantics
restrict the scope of SPARQL queries to documents that can be reached by
traversing a well-defined set of data links. To specify what data links belong
to such a set, the notion of a reachability criterion is used; that is, a function
c : T  U  P  {true, false} where P denotes the set of all SPARQL graph
patterns. Then, given such a reachability criterion c, a finite set S of URIs and
a SPARQL graph pattern P , a document d  D is (c, S, P )-reachable in a Web
of Linked Data W = D, adoc if any of the following two conditions holds:
1. There exists a URI u  S such that adoc(u) = d; or
2. there exists a link graph edge dsrc, (t, u), dtgt  GW such that (i) dsrc is

(c, S, P )-reachable in W, (ii) c(t, u, P ) = true, and (iii) dtgt = d.

Notice how the second condition restricts the notion of reachability by
ignoring data links that do not satisfy the given reachability criterion c. Concrete examples of reachability criteria are cAll, cNone, and cMatch [11], where cAll
selects all data links, and cNone ignores all data links; i.e., cAll(t, u, P ) = true
and cNone(t, u, P ) = false for all tuples t, u, P  T  U  P. In contrast
to such an all-or-nothing strategy, criterion cMatch returns true for every data
link whose triple matches a triple pattern of the given graph pattern; formally,
cMatch(t, u, P ) = true if and only if there exists some solution mapping  such
that [tp] = t for an arbitrary triple pattern tp that is contained in P .

Given the notion of a reachability criterion, it is possible to define a family
of (reachability-based) query semantics for SPARQL. To this end, let c be a

O. Hartig and J. P erez

reachability criterion, let S be a finite set of URIs, and let P be a SPARQL
graph pattern. Then, for any Web of Linked Data W = D, adoc, the S-based
evaluation of P over W under c-semantics, denoted by [[P ]]R(c,S)
W , is the set of
solution mappings [[P ]]G where G is the RDF graph that consists of all triples
from all documents that are (c, S, P )-reachable in W.

While there exist an infinite number of possible reachability criteria, in this
paper we focus on cAll, cNone, and cMatch. The following two results show that
LDQL is strictly more expressive than SPARQL graph patterns under any of
these three query semantics.
Theorem 5. Let c  {cAll, cNone, cMatch}. For every SPARQL graph pattern P
there exists an LDQL query q such that [[P ]]R(c,S)
W for every Web W and
S  U.
Proof (Sketch). We only sketch the case of cAll-semantics. In this case, one can
prove that the LPE lpe cAll = 
 simulates the reachability criterion cAll,
and, thus, [[P ]]R(cAll,S)
W . One can also find LPEs to simulate cNone
and cMatch.
Theorem 6. Let c  {cAll, cNone, cMatch}. There exists an LDQL query q for
which there does not exist a SPARQL pattern P such that [[P ]]R(c,S)
W for
every W and S  U.

,
= [[lpe cAll , P]]S

= [[q]]S

= [[q]]S

,

5 Web-Safeness of LDQL Queries

In this section we study the Web-safeness of LDQL queries, where, informally,
we call a query Web-safe if a complete execution of the query over the WWW
is possible in practice (which is not the case for all LDQL queries as we shall
see). To provide a more formal definition of this notion of Web-safeness we make
the following observations. While the mathematical structures introduced by
our data model capture the notion of Linked Data on the WWW formally (and,
thus, allow us to provide a formal semantics for LDQL queries), in practice, these
structures are not available completely for the WWW. For instance, given that
an infinite number of strings can be used as HTTP URIs [6], we cannot assume
complete information about which URIs are in the domain of the partial function adoc (i.e., can be looked up to retrieve some document) and which are not;
in fact, disclosing this information would require a process that systematically
tries to look up every possible HTTP URI and, thus, would never terminate.
Therefore, it is also impossible to guarantee the discovery of every document in
the set D (without looking up an infinite number of URIs). Consequently, any
query whose execution requires a complete enumeration of this set is not feasible in practice. Based on these observations, we define Web-safeness of LDQL
queries as follows.
Definition 6. An LDQL query q is Web-safe if there exists an algorithm that,
for any finite Web of Linked Data W = D, adoc and any finite set S of URIs,
?

?

?
SEED ?x
?

?

?
,?x, p1, ?z

ex, and q

ex = lpe ex

W by looking up only a finite number of URIs without assuming

computes [[q]]S
an a priori availability of any information about the sets D and dom(adoc).
Example 6. Recall our example queries qex, q
ex (cf. Example 5). For
, any URI u  U may be used to obtain
query qex =
a nonempty subset of the query result as long as a lookup of u retrieves a
document whose data includes RDF triples that match u, p1, ?z. Therefore,
without access to D or dom(adoc) of the queried Web W = D, adoc, the completeness of the computed query result can be guaranteed only by checking each
of the infinitely many possible HTTP URIs. Hence, query qex is not Web-safe.
In contrast, although it contains qex as a subquery, query q
ex) is
, Bex. Given uA as seed URI, a possible execution
Web-safe, and so is q
algorithm for q
W by traversing the queried Web W
based on lpe ex. Thereafter, the algorithm retrieves documents by looking up all
URIs u  [[lpe ex]]uA
W (or simply keeps these documents after the traversal); and,
finally, the algorithm evaluates pattern Bex over the union of the RDF data in
the retrieved documents. If W is finite (i.e., contains a finite number of docu-
ments), the traversal process requires a finite number of URI lookups only, and
so does the retrieval of documents in the second step; the final step does not
look up any URI. To see that q
ex is also Web-safe we note that after executing
subquery q
ex (e.g., by using the algorithm as outlined before), the execution of
the other (non-Web-safe) subquery qex can be reduced to a finite number of URI
lookups, namely the URIs bound to variable ?x in solution mappings obtained
for subquery q
ex. Although any other URI may also be used to obtain solution mappings for qex, such solution mappings cannot be joined with any of the
solution mappings for q

ex and, thus, are irrelevant for the result of q
ex.

ex may first compute [[lpe ex]]uA

ex = (qex AND q

The example illustrates that there exists an LDQL query that is not Web-
safe. In fact, it is not difficult to see that the argument for the non-Web-safeness
of query qex as made in the example can be applied to any LDQL query of the
form (SEED ?x q) where subquery q is a (satisfiable) basic LDQL query; that
is, none of these queries is Web-safe. However, the example also shows that
more complex queries that contain such non-Web-safe subqueries may still be
Web-safe. Therefore, we now show properties to identify LDQL queries that are
Web-safe even if some of their subqueries are not. We begin with queries of the
forms lpe, P, V q, (SEED U q), and (q1 UNION ... UNION qn).
Proposition 2. An LDQL query q is Web-safe if any of the following properties
holds:
1. Query q is of the form lpe, P and lpe is Web-safe, where we call an LPE
Web-safe if either (i) it is of the form ?v, q and LDQL query q is Web-
safe, or (ii) it is of any form other than ?v, q and all its subexpressions (if
any) are Web-safe LPEs;
2. Query q is of the form V q or (SEED U q), and subquery q is Web-safe; or
3. Query q is of the form (q1 UNION ... UNION qn) and each qi (1  i  n) is

Web-safe.

O. Hartig and J. P erez

It remains to discuss LDQL queries of the form (q1 AND ... AND qm). Our
discussion of query q
ex in Example 6 suggests that such queries can be shown
to be Web-safe if all non-Web-safe subqueries are of the form (SEED ?v q) and
it is possible to execute these subqueries by using variable bindings obtained
from other subqueries. A necessary condition for this execution strategy is that
the variable in question (i.e., ?v) is guaranteed to be bound in every possible
solution mapping obtained from the other subqueries.

To allow for an automated verification of this condition we adopt Buil-Aranda
et al.s notion of strongly bound variables [4]. To this end, for any SPARQL
graph pattern P , let sbvars(P ) denote the set of strongly bound variables in P
as defined by Buil-Aranda et al. [4]. For the sake of space, we do not repeat
the definition here. However, we emphasize that sbvars(P ) can be constructed
recursively, and each variable in sbvars(P ) is guaranteed to be bound in every
possible solution for P [4, Proposition 1]. To carry over these properties to LDQL
queries, we use the notion of strongly bound variables in SPARQL patterns
to define the following notion of strongly bound variables in LDQL queries;
thereafter, in Lemma 3, we show the desired boundedness guarantee.
Definition 7. The set of strongly bound variables in an LDQL query q,
denoted by sbvars(q), is defined recursively as follows:
1. If q is of the form lpe, P, then sbvars(q) = sbvars(P ).
2. If q is of the form (q1 AND q2), then sbvars(q) = sbvars(q1)  sbvars(q2).
3. If q is of the form (q1 UNION q2), then sbvars(q) = sbvars(q1)  sbvars(q2).
4. If q is of the form V q, then sbvars(q) = sbvars(q)  V .
5. If q is of the form (SEED U q), then sbvars(q) = sbvars(q).
6. If q is of the form (SEED ?v q), then sbvars(q) = sbvars(q)  {?v}.
Lemma 3. Let q be an LDQL query. For every finite set S of URIs, every
Web of Linked Data W, and every solution mapping   [[q]]S
W , it holds that
sbvars(q)  dom().

We are now ready to show the following result.

Theorem 7. An LDQL query of the form (q1 AND q2 AND ... AND qm) is Websafe if there exists a total order  over the set of subqueries {q1, q2, ... , qm} such
that for each subquery qi (1  i  m), it holds that either (i) qi is Web-safe or
(ii) qi is of the form (SEED ?v q) where q is Web-safe and ?v  
qjqi sbvars(qj).
Proof (Sketch). We prove Theorem 7 based on an iterative algorithm that generalizes the execution of query q
ex as outlined in Example 6. That is, the algorithm
executes the subqueries q1 ... qm sequentially in the order  such that each iteration executes one of the subqueries by using the solution mappings computed
during the previous iteration.

With the results in this section we have all ingredients to devise a procedure
to show Web-safeness for a large number of queries (including queries that are
arbitrarily nested). However, as a potential limitation of such a procedure we note
?

?

?
q1 AND (q2 UNION (SEED ?x q3))

that Theorem 7 can be applied only in cases in which all non-Web-safe subqueries
are of the form (SEED ?v q). For instance, the theorem cannot be applied to show
is Web-safe
that an LDQL query of the form
if ?x  sbvars(q1) and q1, q2 and q3 are Web-safe. On the other hand, for the
we can
semantically equivalent query
show Web-safeness based on Theorem 7 (and Proposition 2). Fortunately, we may
leverage the following fact to improve the effectiveness of applying Theorem 7
in the procedure that we aim to devise.
Fact 1. If an LDQL query q is Web-safe, then so is any LDQL query q with
q  q.
?

?

?
(q1 AND q2) UNION (q1 AND (SEED ?x q3))
?

?

?
As a consequence of Fact 1, we may use the equivalences in Lemma 2 to
rewrite a given query into an equivalent query that is more suitable for testing
Web-safeness based on our results. To this end, we introduce specific normal
forms for LDQL queries:
Definition 8. An LDQL query is in union-free normal form if it is of the
form (q1 AND ... AND qm) with m  1 and each qi (1  i  m) is either (i) a
basic LDQL query or (ii) of the form V q, (SEED U q) or (SEED ?v q) such that
subquery q is in UNION-free normal form. An LDQL query is in union normal
form if it is of the form (q1 UNION ... UNION qn) with n1 and each qi (1 i n)
is in UNION-free normal form.

The following result is an immediate consequence of Lemma 2.

Corollary 1. Every LDQL query is equivalent to an LDQL query in UNION normal form.

In conjunction with Fact 1, Corollary 1 allows us to focus on LDQL queries
in UNION normal form without losing generality. We are now ready to specify our
procedure that applies the results in this paper to test a given LDQL query q for
Web-safeness: First, by using the equivalences in Lemma 2, the query has to be
rewritten into a semantically equivalent LDQL query qnf =(q1 UNION ... UNION qn)
that is in UNION normal form. Next, the following test has to be repeated for every
subquery qi (1  i  n); recall that each of these subqueries is in UNION-free normal form; i.e., qi = (qi
mi). The test is to find an order for their
mi that satisfies the conditions in Theorem 7. Every top-level
subqueries qi
subquery qi (1  i  n) for which such an order exists, is Web-safe (cf. Theo-

rem 7). If all top-level subqueries are identified to be Web-safe by this test, then
qnf is Web-safe (cf. Proposition 2), and so is q (cf. Fact 1).

1 AND ... AND qi

The given conditions are sufficient to show Web-safeness of LDQL. It remains
open whether there exists a (decidable) sufficient and necessary condition for
Web-safeness.

, ... , qi

O. Hartig and J. P erez

6 Concluding Remarks and Future Work

LDQL, the query language that we introduce in this paper, allows users to
express queries over Linked Data on the WWW. We defined LDQL such that
navigational features for selecting the query-relevant documents on the Web are
separate from patterns that are meant to be evaluated over the data in the
selected documents. This separation distinguishes LDQL from other approaches
to express queries over Linked Data.

We focused on expressiveness, by comparing LDQL with previous formalisms,
and on the notion of Web-safeness. Several topics remain open for future work.
One of them is the complexity of query evaluation. A classical complexity analysis is easy to perform if we assume that all the data and documents are available
as if they were in a centralized repository, and that they can be processed via
a RAM machine model. We conjecture that under this model, the data complexity of evaluating LDQL will be polynomial. Nevertheless, a more interesting
complexity analysis should consider a model that captures the inherent way of
accessing the Web of Linked Data via HTTP requests, the overhead of data communication and transfer, the distribution of data and documents, etc. A more
practical direction for future research on LDQL is the development of approaches
to actually implement LDQL queries efficiently.

Acknowledgments. P erez is supported by the Millennium Nucleus Center for Semantic Web Research, Grant NC120004, and Fondecyt grant 1140790.
