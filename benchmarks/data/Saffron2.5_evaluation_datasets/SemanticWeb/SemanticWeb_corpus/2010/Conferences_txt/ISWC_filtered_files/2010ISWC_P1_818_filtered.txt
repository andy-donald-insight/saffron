Declarative Semantics for the Rule Interchange

Format Production Rule Dialect

Carlos Viegas Dam asio, Jos e J ulio Alferes, and Jo ao Leite

CENTRIA, Dep. Inform atica, FCT/Universidade Nova de Lisboa, Portugal

{cd,jja,jleite}@di.fct.unl.pt

Abstract. The Rule Interchange Format Production Rule Dialect (RIF-
PRD) is a W3C Recommendation to define production rules for the
Semantic Web, whose semantics is defined operationally via labeled terminal transition systems.

In this paper, we introduce a declarative logical characterization of the
full default semantics of RIF-PRD based on Answer Set Programming
(ASP), including matching, conflict resolution and acting.

Our proposal to the semantics of RIF-PRD enjoys several features.
Being based on ASP, it enables a straightforward integration with Logic
Programming rule based technology, namely for reasoning and acting
with ontologies. Then, its full declarative logical character facilitates
the investigation of formal properties of RIF-PRD itself. Furthermore, it
turns out that our characterization based on ASP is flexible enough so
that new conflict resolution semantics for RIF-PRD can easily be defined
and encoded. Finally, it immediately serves as the declarative specification of an implementation, whose prototype we developed.

1 Introduction

In this paper we present a sound and complete declarative semantical characterization of the Production Rule Dialect of the Rule Interchange Format
(RIF-PRD) [6]  including matching, conflict resolution and acting  based on
Answer-Set Programming [11], accompanied by a prototypical implementation.
While contributing to a better understanding of RIF-PRD, our proposal brings
greater flexibility to RIF-PRD as it facilitates integration with other rule based
technologies and is easily extensible e.g. with other conflict resolution strategies.
The W3C Rule Interchange Format (RIF) exists to enable interoperability
among rule languages in general, allowing rules written for one application to
be published, shared, and re-used in other applications and other rule engines.
Whereas the core dialect of RIF [3] is designed to support the interchange of
definite Horn rules without function symbols (Datalog), the Production Rule
Dialect of RIF (RIF-PRD) [6] extends it to deal with production rules, and is
currently a W3C Recommendation. Production rules can be seen as conditionaction rules, and are particularly useful to specify behaviors and support the
separation of business logic from business objects. According to RIF-PRD, the
condition part of production rules is like the condition part of logic rules (as

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 798813, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
covered by RIF-Core and its basic logic dialect extension, RIF-BLD [4]). Actions
can assert facts, modify facts, retract facts, and have other side-effects, unlike
conclusions of logic rules, which contain only a logical statement.

The following are examples of production rules taken from [6], about the

status of customers, and corresponding discounts at checkout:
Gold rule: Silver customers with shopping carts worth at least $2,000 are
awarded the Gold status.
Discount rule: Silver and Gold customers are awarded a 5% discount on
the total worth of their shopping cart.
New customer and widget rule: New customers who buy a widget are
awarded a 10% discount on the total worth of their shopping carts, but loose
any voucher they may have been awarded.
Unknown status rule: a message must be printed, identifying any customer whose status is unknown (that is, neither New, Bronze, Silver
nor Gold), and the customer must be assigned the status New.
RIF-PRD specifies an abstract syntax and associates the abstract constructs
with normative semantics and a normative XML concrete syntax. It also specifies
a presentation syntax that provides a more succinct representation of production
rules. For example, the third rule above can be represented as follows [6]:

Forall ?cust such that (And( ?cust # ex1:Customer

?cust[status->"New"] ) )
(If Exists ?cart ?item ( And ( ?customer[shoppingCart->?cart]

Then Do( (?s ?cust[shoppingCart->?s])

?cart[containsItem->?item]
?item # ex1:Widget ) ) )

Retract( ?voucher )

(?val ?s[value->?val])
(?voucher ?cust[voucher->?voucher])
Retract( ?cust[voucher->?voucher] )
Modify( ?s[value->func:numeric-multiply(?val 0.90)] ) ) ) )
The RIF-PRD operational semantics for production rules and rule sets is based
on labeled terminal transition systems [14] where state transitions result from
executing the action part of instantiated rules, according to the loop: (Match):
the rules are instantiated based on the definition of the rule conditions and the
current state of the data source; (Conflict resolution): a decision algorithm, often called the conflict resolution strategy, is applied to select which rule instance
will be executed; (Act): the state of the data source is changed, by executing
the selected rule instances actions. If a terminal state has not been reached, the
control loops back to the first step (Match).

An important part of the control loop that governs the semantics concerns
the conflict resolution strategy used to select one of the several available rules
for execution. Strategies are denoted by keywords (of type rif:IRI), that are
attached to rule sets permitting that production rule producers and consumers
agree on a different semantics. RIF-PRD also prescribes a normative strategy,
forward chaining denoted by rif:forwardChaining, which eliminates rules from
a conflict set (a set of applicable rules) based on the following ordered criteria:

C. Viegas Dam asio, J.J. Alferes, and J. Leite

1.Refraction: eliminate rules that were already applied and whose conditions
for application havent changed since;
2.Priority: eliminate rules with lower priority;
3.Recency: eliminate rules that have been applicable for longer.
At the end of the application of these criteria, RIF-PRD prescribes that one of
the remaining rules be chosen in some way (e.g. randomly).

The RIF-PRD W3C Recommendation is a crucial and significant step in standardizing the syntax and semantics of production rules, enabling their interoperability among rule languages in general, and not limited to the Web. However,
there are some issues that require further attention, and some steps that need
to be taken, in order to provide a better understanding and greater flexibility of
RIF-PRD. One important component missing in [6] is a purely logical declarative
semantics for RIF-PRD, which would serve as a counterpart to the operational
semantics provided. Such a semantics would provide a better understanding and
further insights into RIF-PRD, while facilitating the integration of production
rules with declarative rules and Logic Programming rule based technology in
general, useful e.g. for reasoning and acting with ontologies.

Another issue that needs further attention is that of providing alternatives to
the default conflict resolution strategy. Though RIF-PRD foresees the specification of different conflict resolution strategies, there is no indication in [6] as to
how such alternative strategies could be specified in a way that facilitates their
shared understanding by document producers and consumers. We believe that
any such strategy, including the one normatively specified by RIF-PRD, should
be defined by a set of rules which precisely defines its meaning. In this case,
the keyword for the strategy could be a URI for the set of rules which precisely
defines the strategy.

In this paper, we present a sound and complete declarative semantical characterization of RIF-PRD  including matching, conflict resolution and acting  based
on Answer-Set Programming (ASP) [11], that addresses these outstanding issues.
As suggested by RIF-PRD designers, we assume RIF-Core strong safeness [3] in
order to guarantee finite grounding in forward chaining mode.

ASP is a form of declarative programming, similar in syntax to traditional
logic programming and close in semantics to non-monotonic logic, that is now
widely recognized as a valuable tool for knowledge representation and reasoning.
On the one hand, ASP is fully declarative in the sense that the program specifications resemble the problem specifications, the semantics is very intuitive,
and there is extensive theoretical work that facilitates proving several properties
of answer-set programs. On the other hand, ASP is very expressive, allowing
for compact representations of all NP and coNP problems, or even more complex ones if disjunctive programs are used [7]. Other important characteristics
of ASP include the use of default negation to allow for reasoning with assumptions and incomplete knowledge, as well as the existence of a number of well
studied extensions such as preferences, revision, abduction, etc. More relevant
for this work, are the recent results on M KN F + hybrid knowledge bases where
a faithful, tight and flexible integration of description logics and rules has been
?

?

?
achieved [13]. The integration of rules with ontologies is also possible with dlprograms [8]. Finally, there are very efficient ASP solvers available (e.g. Clingo,
DLV, Smodels, etc.).

Our proposal enjoys the following features that address the mentioned issues:
 Being based on ASP, it paves the way to a direct integration with Logic
Programming based technology, viz. for reasoning and acting with ontologies;
 Being fully declarative, it facilitates the investigation of further formal prop-

erties of RIF-PRD, e.g. using the approach followed in [5];

 Enjoying the expressivity of ASP, it is flexible enough so that conflict reso-

lution strategies for RIF-PRD are easily defined and encodable;

 Benefiting from the existence of efficient ASP solvers, it can be directly and
efficiently implemented  which we have done using iClingo [9], and is, to
the best of our knowledge, the first implementation of RIF-PRD.

The remainder of this paper is structured as follows: in Sect. 2 we review ASP;
in Sect. 3 we present a sound and complete translation of RIF-PRD rule sets
into ASP; in Sect. 4 we address the specification of conflict resolution strategies
in ASP, illustrating with a sound and complete encoding of forward chaining,
the RIF-PRD normative strategy; we conclude in Sect. 5.

2 Answer Set Programming

In this Section we start by describing the syntax and semantics of Answer-set
Programming, before we introduce iClingo[9], an incremental answer-set system.
We follow the presentation in [9], with some modifications.
The language is built from a set F of constants and function symbols (in-
cluding the natural numbers and usual arithmetic operators), a set V of variable
symbols, and a set P of predicate symbols (including the binary equality and
inequality predicates, and ordinary arithmetic comparison operators). We assume that V contains a distinguished parameter symbol  (varying over natural
numbers). The set T of terms is the smallest set containing V and all expressions
of the form f (t1, ..., tn), where f  F and ti  T for 0  i  n. The set A of
atoms contains all expressions of the form p (t1, ..., tn), where p  P and ti  T
for 1  i  n. A literal is an atom a or its (default) negation not a. Given a set
L of literals, let L+ = {a  A | a  L} and L
 = {a  A | not a  L}. A logic
program over A is a set of rules of the form a0  a1, ..., am, not am+1, ..., not an,
where ai  A for 0  i  n. For a rule r of the form above, let head (r) = a

be the head of r, body (r) = {a1, ..., am, not am+1, ..., not an} be the body of
r, and atom (r) = {head (r)}  body (r)+  body (r)

. For a program P , let
head (P ) = {head (r) | r  P} and atom (P ) =
rP atom (r). Given an expression e  T  A, let var (e) denote the set of all variables occurring in
e, and given a rule r, let var (r) denote the set of all variables occurring in
r. Expression e  T  A is ground if var (e) = . The ground instantiation
of a program P is defined as grd (P ) = {r | r  P,  : var (r)  U} where
U = {t  T | var (t) = }. Similarly, grd (A) = {a  A | var (a) = }.

C. Viegas Dam asio, J.J. Alferes, and J. Leite

A set M  grd (A) is an answer set [11,1] of a program P over A if M
is the -smallest model of {head (r)  body (r)+ | r  grd (P ) , body (r)
 
M = }. The set of answer-sets of P is denoted by AS (P ). The semantics
of integrity constraints is given through a program transformation where an
integrity constraint of the form  a1, ..., am, not am+1, ..., not an is a shorthand
 is a new atom.
for the rule a

  a1, ..., am, not am+1, ..., not an, not a

 where a

2.1 iClingo

Real-world applications such as planning or model checking include a parameter
encoding the size of a solution. In Answer Set Programming (ASP), essentially a
propositional formalism, this is dealt with by considering one problem instance
after another by gradually increasing the bound on the solution size. In most
cases, Answer-Set Programming systems simply produce a ground set of rules
for each problem instance, incurring in a high efficiency cost.

iClingo1[9] is an incremental ASP (iASP) system where both the grounder
as well as the solver are implemented in a stateful way, interleaving grounding
and solving within incremental computations. Both the grounder and the solver
maintain their previous states while increasing an incremental parameter. At
each incremental step, the grounder just produces ground rules generated from
the current program slice, i.e. generated by instantiating the incremental parameter with the current value. Such ground program slices are gradually passed to
the solver that accumulates ground rules and computes answer sets for them.
In the context of iClingo, the concept of a (parametrized) domain description
is introduced, as being a triple B, S [] , Q [] of logic programs where S []
and Q [] contain a (single) parameter  ranging over the natural numbers.
The base program B describes static knowledge, independent of parameter .
Program S [] contains knowledge that accumulates with increasing values of
. Program Q [] contains knowledge that is specific for each value of . Given
a domain description  = B, S [] , Q [] and an integer i  1, let P [i] =
 Q [i], and AS (i) denote AS (P [i]), min () denote the
B 
minimum integer such that AS (i) = , and AS () denote AS
. The
goal is then to determine AS (). iClingo accepts domain descriptions 2 and
computes AS () by incrementally constructing and solving for P [i]. Detailed
information regarding the implementation of iClingo can be found in [9].

1jiS [j]
?

?

?
min()
?

?

?
1 iClingo is part of Potassco, a set of tools for Answer Set Programming developed at

the University of Potsdam, and available at http://potassco.sourceforge.net

2 Function symbols with non-zero arity may lead to logic programs over an infinite
Herbrand base. To maintain decidability at each iteration, it is important to restrict
the language to fragments for which finite equivalent ground programs are guaranteed to exist. Level-restricted (or -restricted) logic programs [10] constitute such a
fragment, where finiteness is guaranteed by the requirement that any variable in a
rule be bound to a finite set of ground terms via a predicate not subject to positive
recursion through that rule.
?

?

?
3 Fact Bases, States, Conditions and Rules

In this Section we synthetically overview some of the main concepts of the Production Rule dialect of RIF [6] and provide a mapping of RIF-PRD initial states
(fact base) and rule sets into iASP which is sound and complete wrt. the possible
traces of execution of the rules on the initial state. For now, we do not consider
the inclusion of a conflict resolution strategy  it will be dealt with in Sect. 4.

RIF-PRD defines rules with action heads for performing changes over a set
of facts (i.e. an extensional logic database) dependent on logical conditions over
a logical state derived from this set of facts. The underlying logical language is
constructed from a first-order alphabet.

3.1 Atomic Formulas and Conditions

RIF-PRD defines the notion of term as in ASP, except for the introduction of
the special list term which, for all purposes in the rest of this paper, can be seen
as an ordinary complex term. Terms are used to construct atomic formulas.

Definition 1 (RIF-PRD term and atomic formulas). A term is either an
arbitrary constant c, an arbitrary variable ?V, a lists of ground terms List(g1
...gn), or a (complex) positional terms f(t1 ...tn) formed from a constant f
and a sequence of arbitrary term arguments t1 . . . tn with n  1.
Given arbitrary terms t, s, and pi, ti where 1  i  n, atomic formulas
are ordinary atoms (i.e. positional terms), equality of terms (t=s), membership
of object t in class s (t#s), subclass relation (t##s), frames (t[p1->t1 ...
pn->tn]), or externally defined terms ( External(t)).
In RIF-PRD, there is no syntactical distinction between positional terms and
ordinary atoms. Equality is used to check if two terms are identical, while membership atomic formulas t#s are used to represent that the object denoted by
term t belongs to the class denoted by s. A subclass atomic formula t##s expresses that t is a subclass of s. A frame term t[p1->t1 ... pn->tn] roughly
states that the object denoted by term t has for each property pi the value ti.
Externally defined terms are used for representing built-in functions, e.g. to perform numerical operations. Condition formulas are to be used in the antecedents
of production rules to define conditions for their applicability, corresponding
syntactically to a fragment of first-order logic without universal quantifiers.

Definition 2 (RIF-PRD condition formulas). Condition formulas are inductively defined from atomic formulas, conjunction And(1 ...n) and disjunction Or(1 ...n) of conditional formulas, negation Not() or existential
quantification Exists ?v1 ...?vm (), where , 1 . . . n are condition formulas and ?v1 ...?vm are variables.

3.2 Fact Bases and States

The knowledge dynamics is captured by a set of ground atomic formulas  the
fact base  which changes through the addition and removal of atomic formulas.

C. Viegas Dam asio, J.J. Alferes, and J. Leite

The execution of a RIF-PRD production rule system starts with an initial fact
base, and proceeds by updating it step by step. At a given step of the execution

 a fact base will be encoded in iASP by a set of facts of the form fact(
, )
where 
Definition 3 (Translation of atomic formulas). An atomic RIF-PRD formula  is translated into the iASP term 

 is the translation of the RIF-PRD ground atomic formula .

 A positional atom, an equality or an externally defined term  is mapped

 as follows:

into itself;

 A membership atomic formula t#s is mapped into term isa(t, s);
 A subclass atomic formula t##s is mapped into term sub(t, s);
 A frame atomic formula s[p->o] is mapped into term f rame(s, p, o).
This representation assumes that a ground frame t[p1->t1 ... pn->tn] is represented by the set of facts f rame(t, p1, t1), . . . , f rame(t, pn, tn). For simplicity
of presentation, externally defined formulas are mapped into themselves. How-
ever, a concrete implementation should implement these resorting to their own
built-ins; this is ignored in the translation.
Definition 4 (Fact bases translation). Consider an initial fact base .
 Program INIT() is formed by f act(, 0), for each   .
 Program FLUENT() is formed by f luent(), for each formula  that may

occur in a fact base.

 Program CHANGE[] is formed by the rules:

f act(F, )  f luent(F ), f act(F,   1), not retract(F,   1).
f act(F, )  f luent(F ), assert(F,   1).

INIT collects the initial fact base which will be updated using the rules in
CHANGE[]. The first rule states that fluents which are not retracted in the previous step remain in the fact base (inertia), while the second states that fluents
asserted in the previous step will be added. Notice that the things which can be
added or deleted are collected in program FLUENT. For simplicity, the definition
of predicate f luent/1 is extensional but could also be defined intensionally by
rules. Also note that by RIF-Core strong safeness at each step there may exist
only a finite number of alternatives which can be dealt with in practice. Another essential use of predicate f luent/1 is to ground variables in the final iASP
domain description.
Definition 5 (States translation). Program STATES[] is formed by the rules:

state(F, )  f act(F, ).
state(F, )  f act(F, 0), not f luent(F ).
state(isa(O1, C2), )  f luent(isa(O1, C1)), f luent(sub(C1, C2)),
state(sub(C1, C3), )  f luent(sub(C1, C2)), f luent(sub(C2, C3)),
state(sub(C1, C2), ), state(sub(C2, C3), ).

state(isa(O1, C1), ), state(sub(C1, C2), ).

The first rule includes in the state of step  the fact base of . The second states
that any non-fluent (static) fact holding at the initial fact base also holds at step
. According to RIF-PRD semantics the set of initial facts can be arbitrarily
ground atomic formula but actions are syntactically limited to specific types of
?

?

?
formula (e.g. it is impossible to change subclass atomic formulas). The third rule
captures class inheritance while the last one expresses transitivity of the subclass
relationship, imposed to any state by the semantics of RIF-PRD.

Conditions are matched to a given state. However, the case of non-atomic

formulas introduces extra complexity:

Definition 6 (Conditions translation). Let  be an arbitrary condition for-
 and program
mula and  an execution step. Define condition iASP formula 

COND[] inductively as follows:

COND[] = {};
[] = state(

 If  is an atomic formula  then 
[]=(
?

?

?
 If =And(1 ...n) then 
COND[];
n) and 
1in i
1, . . . , 
[] = or(X1, . . . , Xm, ) where ?X1, . . . ?Xm,
 If  = Or(1 ...n) then 
COND[] =

are the free variables of  and or is a new predicate symbol, and 

, ) and 
COND[] =
?

?

?
1in

i[]}
COND[]  {or(X1, . . . , Xm, )  

i

;

 If  = Exists ?V1 ...?Vn () then 

[] = exists(X1, . . . , Xm, ) where
?X1, . . . ?Xm, are the free variables of  and exists is a new predicate
COND[]  {exists(X1, . . . , Xm, )  
symbol, and 
[] = not arg(X1, . . . , Xm, ) where ?X1, . . . ?Xm,
COND[] =

are the free variables of  and arg is a new predicate symbol, and 
COND[]  {arg(X1, . . . , Xm, )  


 If  = Not() then 

COND[] = 

[]};

[]};

Basically, this transformation applies Lloyd-Topors transformation [12] to obtain the corresponding normal rules capturing the conditional formula, taking
into account what is true in the current step. Mark that both a (conjunctive)
COND[] is returned for each condition formula .
goal 
Additional details and justification of this process can be found in [1].

[] and a program 

3.3 Actions and Rules
The RIF-PRD language defines several atomic actions for updating the fact base,
and these will be used to define the effects of RIF-PRD production rules.

Definition 7 (RIF-PRD atomic actions). An atomic action is a simple construct that represents an atomic transaction.
1. Assert fact: If  is a positional atom, a frame or a membership atomic
formula in the RIF-PRD condition language, then Assert() is an atomic
action.

2. Retract fact: If  is a positional atom or a frame in the RIF-PRD condition

language, then Retract() is an atomic action.

3. Retract all slot values: If o and s are terms in the RIF-PRD condition lan-

guage, then Retract(o s) is an atomic action.

4. Retract object: If t is a term in the RIF-PRD condition language, then

5. Execute: if  is a positional atom in the RIF-PRD condition language, then

Retract(t) is an atomic action.

Execute() is an atomic action.

The arguments of the action are dubbed the target of the action.

C. Viegas Dam asio, J.J. Alferes, and J. Leite

The effects of RIF-PRD atomic actions are captured by our translation using
the following iASP rules.
Definition 8 (Effects of actions). Program ACTIONS[] is:
assert(F, )  action(assert(F ), ).
retract(F, )  action(retract(F ), ).
retract(isa(O, C), )  action(retract object(O), ), f act(isa(O, C), ).
retract(f rame(O, S, V ), )  action(retract object(O), ), f act(f rame(O, S, V ), ).
retract(f rame(O, S, V ), )  action(retract slots(O, S), ), f act(f rame(O, S, V ), ).
Note that the execute actions do not have an effect in the fact base and should
be interpreted externally. The first two rules of program ACTIONS[] apply when
an assert (resp. retract) action occurs at step , whose effects in the fact base
have been defined previously in program CHANGE. The next two rules translate a
retract object action into a set of simultaneous retracts, while the last one takes
care of the retract all slots action. The interaction of rules with the fact base is
performed via the action/2 predicate to be defined subsequently.

Actions are combined sequentially into action blocks, allowing binding patterns for binding variables occurring in the actions. Additionally, RIF-PRD defines a compound Modify frame action which can be substituted by a sequence
of a retract all slot values followed by an assert; it is assumed that such a replacement has been performed.

Definition 9 (Action variable declaration and action blocks). An action
variable declaration is a pair (?V b) where ?V is a variable and b is binding having one of the forms: New() for generating a new identifier, or a frame o[s->?V]
where o and s are ground terms. If (?V1 b1), ..., (?Vn bn), n  0, are action variable declarations, and if a1, ..., am, m  1, are simple actions, then
Do((?V1 b1) ...(?Vn bn) a1 ...am) denotes an action block.
Finally, the RIF Production Rules are captured by the following definition. Mark
that well-formedness conditions are imposed to rules and conditions, which we
are ignoring in this summary presentation.

Definition 10 (RIF production rule). A rule can be one of:
 An (unconditional) action block Do((?V1 b1)...(?Vn bn) a1. . .am ).
 A conditional action block If  Then Do((?V1 b1)...(?Vn bn) a1. . .am),

where  is a condition formula and the conclusion is an action block.

 A quantified rule Forall ?V1. . .?Vn such that (p1. . .pm) (r), where each

pi is a conditional formula (a pattern) and r is a RIF Production rule.

Without loss of generality we assume that quantified rules have only one level
of universal quantification, i.e. the rule r is limited to be a conditional action
block since it is always possible to write quantified rules in this way, by variable
renaming and appending patterns.

Definition 11 (Translation of a RIF production rule). Let ri be a RIF
production rule and let id be a unique identifier assigned to that rule (i.e. its
name). Program ri

RULE[] is constructed as follows:
?

?

?
 If ri is Do((?V1 b1)...(?Vn bn) a1...am ) then include in ri

RULE[] the

fact f ireable(rule(id, subs), ).

 If ri is If  Then Do( (?V1 b1) ...(?Vn bn) a1 ...am ) then include
RULE[], and the following rule where ?X1, . . . , ?Xl are the free

COND[] in ri

variables of ri: f ireable(rule(id, subs(X1, . . . , Xl), ))  
?

?

?
 If ri is Forall ?V1. . .?Vn such that (p1. . .pm) (If  Then Do(B)) then treat

.

Additionally, from the action block Do((?V1 b1)...(?Vn bn) a1...am ) in the
conclusion of ri add to program ri

this as the conditional action block If And(p1. . .pm ) Then Do(B).
RULE[], for each 1  j  m, the rule:
j,  + j)  instance(id, subs(V1, . . . , Vn, X1, . . . , Xl), ).

Finally, include in ri
RULE[] the rule below, where bindvi is state(f rame(o, s, Vi), )
if bi = o[s->?Vi]. Otherwise bi = New(), and let bindvi be Vi = obj(id, i, ) with
obj an arbitrary but fixed constant symbol.
instance(id, subs(V1, . . . , Vn, X1, . . . , Xl), )  picked(rule(id, subs(X1, . . . , Xl)), ),

action(a

bindV1 , . . . , bindVn .

Predicate f ireable(rule(id, subs(. . .)), ) holds in step  whenever the rule identified by id has a condition true, and thus may be applied. The complex term
sub(. . .) keeps the substitution of variables for which the condition matches state
, and is also used to distinguish between different matching instances of the
same rule. If the rule is picked for execution then picked(rule(id, subs(. . .)), )
will hold and consequently action aj will be executed in step k + j with the
action instance (i.e. substitution of variables) collected in auxiliary predicate
instance/3.
Example 1. Consider the rule presented in the introduction of this paper. Its
encoding into iASP as constructed by RULE transformation is shown below, following the usual answer-set convention of variables beginning with upper-case
and, to simplify the presentation, the constants belonging to namespace ex1 are
represented using CURIE notation:
f ireable(rule(widget, subs(Cust)), )  state(isa(Cust,ex1:Customer), ),
exists1(Cust, )  state(f rame(Cust,shoppingCart, Cart), ),

state(f rame(Cust,status,New), ), exists1(Cust, ).

state(f rame(Cart,containsItem, Item), ), state(isa(Item,ex1:Widget), ).

action(retract(f rame(Cust,voucher, V oucher)),  + 1) 
action(retract object(V oucher)),  + 2) 
action(retract slots(S,value),  + 3) 
action(assert(f rame(S,value, V al  90/100)),  + 4) 

instance(widget, subs(Cust, S, V al, V oucher), ) 

picked(rule(widget, subs(Cust), ), state(f rame(Cust,shoppingCart, S), ),
state(f rame(S,value, V al), ), state(f rame(Cust,voucher, V oucher), ).

instance(widget, subs(Cust, S, V al, V oucher), ).

instance(widget, subs(Cust, S, V al, V oucher), ).

instance(widget, subs(Cust, S, V al, V oucher), ).

instance(widget, subs(Cust, S, V al, V oucher), ).

C. Viegas Dam asio, J.J. Alferes, and J. Leite

It is clear from the example that the fireable conditions are not yet connected to
the rules performing the actions, which will be tackled next. First, it is necessary
to pick one rule for execution from the pickable ones (i.e. the ones which fire and
can be executed). This is straightforward to encode:

Definition 12 (Pick rule). Program PICK[] is formed by:
picked(Rule, )  pickable(Rule, ), not picked other(Rule, ), not transitional(k).
picked other(Rule, )  pickable(Other, ), pickable(Rule, ), Rule! = Other,
picked(Other, ).
transitional()  action(A, ).
picked()  picked(Rule, ).
The execution of RIF-PRD proceeds by first picking one rule, then performing
its actions sequentially, then picking another rule, performing its actions, etc. . . .
The steps in which the fact base is being updated are dubbed transitional in
the RIF-PRD recommendation. The first two rules in PICK[] choose exactly one
alternative (i.e. a rule) from the pickable rules, when  is not a transitional step.
If no strategy is defined, the general operational semantics prescribes that all
fireable rules are pickable, which can be captured by the program ONE[] with
the single rule pickable(Rule, )  f ireable(Rule, ). Computation terminates
in a non-transitional step where no rule is picked. This is captured by HALT[],
which ends our translation of a RIF-PRD rule set, summarized in Def. 14.

Definition 13 (Termination). Program HALT[] is defined by:

 not f inal().
f inal()  not transitional(), not picked().

Definition 14 (Rule set translation). The translation of a RIF-PRD rule set
RS with initial fact base w and set of fluents F is the iASP domain specification
RULESET(RS, w) = BRS(w), SRS(RS) [] , QRS [] where:
BRS(w)

SRS(RS)[] =CHANGE[]STATES[]ACTION[]PICK[]ONE[]

= INIT(w)  FLUENT(F )

riRSri

RULE[]

QRS []

= HALT[]

An advantage of this encoding is that all possible traces of execution can be
generated by the iASP system, where each different trace corresponds to an
answer set. Formally3:

Theorem 1 (Correctness of translation). Let RS be a rule set and w an
initial fact base. Then4:
Soundness: If M  AS (RULESET(RS, w)n) and (c1, . . . , cm) is the increasing
sequence of integers such that transitional(cj)  M, 1  j  m, then, for
every i : 1  i  m  1 (Statei(M), P ickedi(M), Statei+1(M)) P RD,
3 Lack of space prevents us from presenting the proofs of theorems.
4 P RD stands for the transition system which serves as the basis for defining the
semantics of RIF-PRD, Conf lictSet(RS, si) the set of all applicable rules in state
si. Lack of space prevents us from presenting the semantics of RIF-PRD, which is
available in [6].
?

?

?
, ci)  M
?

?

?
where Statei(M) denotes the set of formulae  such that state(
and P ickedi(M) the name of the (only) rule R such that picked(R, ci)  M.
Completeness: If (s1, . . . , sm) is a sequence of non-transitional states such that
w = s1, and for each pair (si, si+1) there exists a rule r  Conf lictSet(RS, si)
such that (si, r, si+1) P RD, then, there exists M  AS (RULESET(RS, w)n) for
some n  m such that the sequence of integers (c1, . . . , cm), constructed from M
as above, is such that Statei(M) = si, for all 1  i  m.

4 Conflict Resolution Strategies

For selecting (ideally one) among these possible executions (or traces), as mentioned in the Introduction RIF-PRD foresees the existence of conflict resolution
strategies. Each of the strategies is denoted by a keyword (of type rif:IRI),
that is attached to the rule set. The current version of RIF-PRD prescribes a
normative strategy, forward chaining, denoted by rif:forwardChaining, and
anticipates the specification of additional keywords, each corresponding to an
additional strategy for selecting rules in conflict. Furthermore, it also allows
for the inclusion of other keywords, not specified in the RIF-PRD specification,
in which case it is the responsibility of the producers and consumers of those
documents to agree on the strategy denoted by the keywords.

Our stance is that any conflict resolution strategy should be defined by a
set of rules, including those normatively specified by RIF-PRD, which precisely
defines its meaning. In this case, the keyword for the strategy could be a URI for
the set of rules which precisely defines the strategy. In this section we show that
iASP, along with the translation defined in the previous section, is expressive
enough to specify conflict resolution strategies. In particular, we show how to
specify conflict resolution strategies, and illustrate by precisely characterizing
the rif:forwardChaining strategy.

4.1 General Definition of Strategies
A conflict resolution strategy is defined in [6] by an algorithm that, in a series
of steps, selects from the set of all fireable rules in some state, a subset of
(pickable) rules from which one is finally picked for execution. For example, the
rif:forwardChaining strategy can be summarized as the following algorithm:
Definition 15 (Forward chaining algorithm). Given a conflict set (i.e. a
set of fireable rules):
1. Remove all rules which where previously applied and, since their last applica-
tion, the conditions that made them applicable havent changed  refraction.
2. The remaining rules are ordered by decreasing priority, and only the rule
instances with the highest priority are kept. Recall that in RIF-PRD every
rule is assigned a priority which is a natural number.

3. The remaining rules are ordered by decreasing recency, and only the most
recent rule instances are kept. Here, a rule is more recent than another if it
is (consecutively) applicable for less prior states than the other.

C. Viegas Dam asio, J.J. Alferes, and J. Leite

Each of these steps applies one strategy element (refraction, priority and re-
cency). In [6], a fourth (tie-break) element is considered, to be applied after
these 3, stating that one of the remaining rules should be picked in some imple-
mentation specific way [6]. Here we do not need to consider this last step. On
the one hand, the translation is such that each answer set is guaranteed to reflect
the application of a single rule at each state. On the other hand, the existence
of more than one answer set reflects the fact that there may be more than one
pickable rule at some state after the application of these 3 strategy elements.
As a result of the translation, each answer set encodes one possible sequence
of application of rules, and one can either consider all resulting answer-sets, or
arbitrarily pick one of them.

For encoding such a strategy in a set of iASP rules, to be added to the domain
description obtained from the translation of the previous section, we first need
to replace the rule of ONE[] which specified that all fireable rules are pickable,
by a set of general rules allowing for restrictions on pickable rules. Accordingly,
a rule is pickable if it is fireable and it is not rejected by one of the strategy
elements:
Definition 16 (Strategy). Program STRATEGY[] is formed by the rules

pickable(Rule, )  f ireable(Rule, ), not rejected(Rule, ).
rejected(Rule, )  rejected(Rule, , S), st element(S).

Note that, without any defined strategy, STRATEGY[] has exactly the same effect
as ONE[]. In fact, if there are no rules for neither rejected/3 nor st element/1,
rejected(Rule, ) is false in all answer-sets for all rules and , and so pickable
is true for all fireable rules, as is the case in ONE[].

Strategy elements are identified by a name. Then, for each strategy, facts to
specify the order of application of the elements must be added. For example, for
rif:forwardChaining the specification of the order of elements is as follows:

st element(ref raction, 1).

st element(priority, 2).

st element(recency, 3).

For referring to the element without its order of application, the following rule
is also needed st element(S)  st element(S, ).

In general, for the definition of conflict resolution strategies, a predicate is
needed to indicate whether a rule is active when a given strategy element is
being applied. For example, in rif:forwardChaining, if a rule is removed by
refraction, then that rule should no longer be available for consideration (i.e.
active) when considering the priority-element. The specification of this predicate
is quite straightforward: a rule is inactive if there is a strategy element prior in
the application order which rejected it, and active otherwise.
Definition 17 (Active Rules). Program ACTIVE[] is defined by

inactive(Rule, , N)  st element( , N), st element(S, N1), N1 < N,
active(Rule, , N)  not inactive(Rule, , N), st element( , N).

rejected(Rule, , S).

The iASP domain description associated with a RIF-PRD rule set becomes:
?

?

?
Definition 18 (RIF-PRD domain description). The RIF-PRD iASP domain description of a rule set RS with initial fact base w and fluents F is
RS(RS, w) = BRS(w), SRS(RS) [] , QRS [] with BRS(w) and QRS as in Def. 14,
and



SRS(RS)[] = CHANGE[]  STATES[]  ACTION[]  PICK[]
RULE[]  STRATEGY[]  ACTIVE[]

riRS ri

Theorem 2. Theorem 1 holds if we replace RULESET(RS, w) with RS(RS, w).

4.2 Defining One Specific Strategy

To completely specify one conflict resolution strategy, we add facts defining the
strategy elements and their application order (as above for rif:forwardChaining)
and define, for each element, which rules are rejected. Below we show how this can
be done for each of the elements in the rif:forwardChaining algorithm.

Refraction. Once a rule is picked at some state, then it is rejected by refraction
from that state onwards, for as long as the rule remains fireable. The test for the
rule being fireable is only done in states when the system is not being updated.
rejected(Rule, , ref raction)  f ireable(Rule, ), picked(Rule,   1).
rejected(Rule, , ref raction)  rejected(Rule,   1, ref raction), transitional().
rejected(Rule, , ref raction)  f ireable(Rule, ), rejected(Rule,   1, ref raction)

not transitional().

Priority. All rules for which there is another (different) active fireable rule with
a strictly higher priority should be rejected. We do not need to test that rejected
rules are active (i.e. not rejected by a previous strategy element), since according
to STRATEGY[] a rejected rule is never pickable.
rejected(rule(Id, V ar), , priority)  f ireable(rule(Id, V ar), ),

f ireable(rule(Id2, V ar2), ), Id! = Id2, priority(Id, P ), priority(Id2, P 2),
P < P 2, active(rule(Id2, V ar2), , N), strategy(priority, N).

Recency. A rule is rejected if there is a more recent one also active and fireable.
We use an auxiliary predicate (recency/3) that, for each rule instance and state
, determines the number of consecutive states before  that the instance has
been fireable. Then, a rule is rejected if there is another one which is more recent.
Predicate state(K) is just used for grounding, and is true for any state K.
rejected(rule(Id, V ar), , recency)  f ireable(Rule, ), f ireable(Other, ),

Rule ! = Other, recency(Rule, T R, ), recency(Other, T O, ), T O < T R,
state(T R), state(T O), active(Other, , N), st element(recency, N).

recency(Rule, , )  f ireable(Rule, ), not f ireable(Rule,   1).
recency(Rule, K, )  recency(Rule, K,   1), transitional(), state(K).
recency(Rule, K, )  f ireable(Rule, ), recency(Rule, K,   1),

not transitional(), state(K).

The set composed by all rules described in this subsection is meant to encode
the rif:forwardChaining, and we denote it by rif:fC[].

C. Viegas Dam asio, J.J. Alferes, and J. Leite

The next theorem shows in which terms the encoding is correct with respect

to the RIF-PRD rif:forwardChaining as described in [6]:

Theorem 3 (Correctness for rif:forwardChaining). Let RS be a rule set,
w an initial fact base, and BRS(w), SRS(RS) [] , QRS [] the corresponding iASP
domain description as in Def. 18. Let LS be the rif:forwardChaining strategy
of definition 15, and H the halting test that halts whenever no rule is picked. Let
rif:fC(RS, w) = BRS(w), SRS(RS) []  rif:fC[], QRS []. Then5:
Soundness: if M  AS (rif:fC(RS, w)), then there exists a state sf such that
Eval(RS, LS, H, w) 
P RD sf and where sf is the set of all formulae  such
, min (rif:fC(RS, w)))  M.

that state(
Completeness: if Eval(RS, LS, H, w) 
M  AS (rif:fC(RS, w)) and   sf , state(

One can impose other conflict resolution strategies, by specifying different rejection rules. For example, rif:forwardChaining behaves in a depth-first manner,
in that it always selects the rule that has been more recently applied. Imposing
a breadth-first strategy can be accomplished by simply changing T O < T R
into T O > T R in the rule defining the rejection by recency, thus obtaining
st:breadth[]. Also note that rif:forwardChaining does not behave in a purely
depth-first manner since it only applies recency after removing rules with less
priority. For a strategy where a depth-first behavior is more important than
complying with the declared priority of rules, one can simply change the facts
that impose the order in the application of strategy elements, e.g. by including
the facts st element(priority, 3) and st element(recency, 2) instead.

P RD sf , then there exists an M such that

, min (rif:fC(RS, w)))  M.

5 Conclusions

In this paper, we presented a declarative logical characterization of RIF-PRD
through a sound and complete transformation into ASP, which can be seen as
an equivalent alternative to the transitional semantics proposed in [6], giving
further insights into RIF-PRD and providing for an immediate implementation
using iASP, which we have developed using iClingo[9]. This transformation considers not only the RIF-PRD rule sets and their transitions, but also the conflict
resolution strategies which are essential to select among applicable rules. We
have illustrated how the default normative strategy  forward chaining  is encodable in ASP, and have shown that ASP provides an appropriate language in
which to precisely define alternative non-standard conflict resolution strategies,
which are also foreseen in [6], facilitating their development and unambiguous
sharing, due to the simple, expressive and well known semantics of ASP. The
work in [2] uses the Situation Calculus, although without handling the idiosyncrasies of RIF-PRD. A Situation Calculus based approach like the one in [2]

5 Eval(RS, LS, H, w) is the input function of the RIF-PRD production rule system
that is responsible for choosing one among the rules in the conflict set and for the
halting conditions. 

P RD is the transitive closure of P RD.
?

?

?
could have been followed, although with extra complexity introduced by the situation terms which would not be easily handled by answer set solvers. A critique
of the Situation Calculus is made in [5], where it is shown how to capture the
semantics of rule production systems in -calculus and FPL. This work captures
a result equivalent to our Theorem 1, thus not handling other conflict resolution strategies. We expect to use the work of [5] to study the formal properties
of our translation. An implementation using an external DL reasoner is underway to assess the practicality of our approach, namely by comparing with more
traditional approaches like CLIPS or JESS.
