Representing and Querying Validity Time in

RDF and OWL: A Logic-Based Approach

Boris Motik

Oxford University Computing Laboratory, Oxford, UK

Abstract. RDF(S) and OWL 2 currently support only static ontologies.
In practice, however, the truth of statements often changes with time,
and Semantic Web applications often need to represent such changes
and reason about them. In this paper we present a logic-based approach
for representing validity time in RDF and OWL. Unlike the existing
proposals, our approach is applicable to entailment relations that are not
deterministic, such as the Direct Semantics or the RDF-Based Semantics
of OWL 2. We also extend SPARQL to temporal RDF graphs and present
a query evaluation algorithm. Finally, we present an optimization of our
algorithm that is applicable to entailment relations characterized by a set
of deterministic rules, such RDF(S) and OWL 2 RL/RDF entailment.

1 Introduction

RDF(S) and OWL 2 currently support only static ontologies. In practice, how-
ever, the truth of statements often changes with time, and Semantic Web applications often need to represent such changes and reason about them. We discuss
these issues on an example derived from the authors collaboration with ExperienceOn (abbreviated EO)an IT start-up company from Barcelona, Spain.

EO aims to improve search in the tourism domain by providing an advanced
system that can answer complex queries such as trips to the second week of
Oktoberfest. Users will input their questions in natural language, and NLP
technology will translate such questions into one or more queries over a knowledge base containing information about flights, lodging, events, geography, and
so on. EOs system must be able to represent statements that are not universally
true, but are associated with validity times. For example, Oktoberfest is being
held in Munich is true only while the festival is being held; similarly, statements describing airline flight schedules are valid only in certain time intervals.
Validity time must be tightly integrated with reasoning; for example, from the
knowledge about Oktoberfest and German geography, EOs system should conclude that Oktoberfest is being held in Bavaria is true for the duration of the
festival. Validity time should also be integrated with a query language, allowing
one to retrieve flights from London to Munich during Oktoberfest. Validity
time thus affects virtually all aspects of knowledge representation and reasoning
in scenarios such as EOs. Some applications also need to represent transaction
times, which specify when facts were added to the database. In this paper we
focus on validity time since it is more relevant to knowledge modeling.

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 550565, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
Validity time has been extensively studied in databases and artificial intelligence [4,19]. Neither RDF nor OWL, however, supports validity time, and
SPARQL does not provide temporal query primitives. These deficiencies have
been recognized by the community, and several proposals have emerged. A comprehensive framework for representing validity time in RDF was presented in [7],
and it encompasses notions of temporal graphs and entailment, a characterization of temporal entailment via closures [6], an encoding of temporal graphs into
regular RDF graphs, and a sketch of a temporal query language. This approach
was extended in [9] with more general temporal constraints. In [15], the authors
extended the approach from [7] with unknown time points, defined a temporal query language based on graph matching, and presented a way for indexing
temporal graphs. A general framework for annotating RDF data was presented
in [17]; the very general notion of annotations can be used to represent validity
time. A temporal extension of SPARQL was presented in [18]. Approaches to
extending description logics (DLs) [3]the family of formalisms underpinning
OWL 2 DLwith temporal features were surveyed in [2]. A temporal extension
of OWL based on concrete domains was presented in [10].

None of these proposals is applicable to all variants of RDF and OWL. For
example, the notion of closures from [7] relies on the fact that the inference rules
of RDF(S) are deterministican assumption that does not hold in expressive
languages such as OWL. In this paper we present a novel approach for representing validity time that is applicable to all Semantic Web languages, including
RDF(S) and all profiles of OWL 2. In particular, in Section 3 we develop a firstorder interpretation of temporal graphs, which we use to define temporal graph
entailment. Our approach coincides with the one from [7] on RDF(S), but it is
applicable to all languages of the RDF and OWL family.

In Section 4, we argue that a temporal query language defined in the obvious
way would allow for queries that have very large and often even infinite answers.
We present a query language whose queries always have finite answers, we integrate our query primitives into the formalization of SPARQL from [14], and
we present a general query evaluation algorithm. In Section 5 we optimize our
general evaluation algorithm for the case of deterministic inference rules.

We implemented our approach in EOs system. Given the nature of EOs busi-
ness, we cannot make the system publicly available; however, EO is successfully
using our approach to answer temporal queries, which we take as indication that
our approach is suitable for practice.

The proofs of all technical results can be found in the extended version of this

paper available from the authors online publication list.

2 Preliminaries

We assume the reader to be familiar with the syntax and semantics of OWL
2 DL [12]; for simplicity, we write OWL 2 DL axioms using the description
logic syntax [3]. We use the standard definitions of constants, variables, terms,
predicates, atoms, multi-sorted first-order logic, and skolemization [5]. For  an

B. Motik

OWL 2 DL axiom or an ontology, let () be the translation of  into a first-order
formula. We assume that the equality predicate  is treated in () as a standard
first-order predicate explicitly axiomatized as a congruence; this does not affect
the consequences of () [5]. Moreover, we assume that  maps the blank nodes
(also called anonymous individuals) in  into free first-order variables, so the
semantics of  is y1, . . . , yn : () where y1, . . . yn are the blank nodes of .
Let U, B, and L be infinite sets of URI references, blank nodes, and literals, re-
spectively, and let UBL = U  B  L. A triple is an assertion of the form s, p, o
with s, p, o  UBL.1 An RDF graph (or just graph) G is a finite set of triples.
The semantics of RDF is determined by entailment relations.

Simple entailment, RDF entailment, RDFS entailment, and D-entailment are
defined in [8], and OWL 2 RL/RDF entailment and OWL 2 RDF-Based entailment are defined in [16]. The logical consequences of each entailment relation
X from this list can be characterized by a (possibly infinite) set of first-order
implications X. For example, for RDF entailment, RDF contains the rules in
[8, Section 7], and for OWL 2 RL/RDF entailment, RL contains the rules in [11,
Section 4.3]. The semantics of a graph G w.r.t. X can be defined by transforming
G into a first-order theory as follows. We assume that each blank node corresponds to a first-order variable (i.e., for simplicity, we do not distinguish blank
nodes from variables). Let bX(G) be the set of all blank nodes in G. For a triple
A = s, p, o, let X(A) = T (s, p, o), where T is a ternary first-order predicate.
For a graph G, let X(G) =
AG X(A). The first-order theory corresponding to G is then X(G) = {bX(G) : X(G)}  X. Let X(G) be obtained from
X(G) by skolemizing the existential quantifiers bX(G)that is, by removing
bX(G) and replacing each blank node in X(G) with a fresh URI reference.
Theory X(G) is equisatisfiable with X(G). A graph G1 X-entails a graph G2,
written G1 |=X G2, if and only if X(G1) |= bX(G2) : X(G2); the latter is the
case if and only if X(G1) |= bX(G2) : X(G2).
?

?

?
We next define OWL 2 Direct entailment (written DL due to its relationship
with description logic). A graph G encodes an OWL 2 DL ontology if G can be
transformed into an OWL 2 DL ontology O(G) as specified in [13]. For such G,
let bDL(G) be the set of blank nodes occurring in O(G); let DL(G) = (O(G));
let DL(G) = bDL(G) : (O(G)); and let DL(G) be obtained from DL(G) by
skolemizing the existential quantifiers bDL(G). Formula DL(G) is equisatisfiable with DL(G). For G1 and G2 graphs that encode OWL 2 DL ontologies,
G1 DL-entails G2, written G1 |=DL G2, iff DL(G1) |= bDL(G2) : DL(G2); the
latter is the case if and only if DL(G1) |= bDL(G2) : DL(G2).

SPARQL is the standard W3C language for querying RDF graphs, and the
1.1 version (currently under development) will support different entailment rela-
tions. In this paper we focus on group patternsthe core of SPARQL that deals
with pattern matching and is largely independent from constructs such as aggregates and sorting. We formalize group patterns as in [14], and we treat answers
as sets rather than multisets as this simplifies the presentation without changing
1 RDF actually requires s  U  B, p  U, and o  UBL, but this is not important in
our framework so we assume s, p, o  UBL for the sake of simplicity.
?

?

?
the nature of our results. Let V be an infinite set of variables disjoint from UBL.
A mapping is a partial function  : V  UBL. The domain (resp. range) of  is
written dm() (resp. rg()). We define (t) = t for t  UBL  V \ dm(). Mappings 1 and 2 are compatible if 1(x) = 2(x) for each x  dm(1)  dm(2);
in such a case, 1  2 is also a mapping. The following algebraic operations on
sets of mappings 1 and 2 are used to define the semantics of group patterns.

1  2 = {1  2 | 1  1, 2  2, and 1 and 2 are compatible}
1 \ 2 = {1  1 | each 2  2 is not compatible with 1}

A built-in expression is constructed using the elements of V  U  L as specified
in [14]; furthermore, for each built-in expression R and each mapping , we
can determine whether R evaluates to true under , written  |= R, as specified
in [14]. A basic graph pattern (BGP) is a set of triples of the form s, p, o
where s, p, o  UBL  V. A group pattern (GP) is an expression of the form B,
P1 and P2, P1 union P2, P1 opt P2, or P1 filter R, where B is a BGP, P1 and P2
are group patterns, and R is a built-in expression. For A a built-in expression
or a group pattern and  a mapping, var(A) is the set of variables occurring in
A, and (A) is the result of replacing each variable x in A with (x).

The answer to a group pattern P on a graph G depends on an entailment
relation X. For each X, we assume that a function exists that maps each graph
G to the set adX(G)  UBL called the answer domain of G; this set determines
the elements of UBL that can occur in answers to group patterns on G under X-
entailment. To see why this is needed, let B = {x, rdf :type, rdf :Property}; due
to the axiomatic triples [8],  |=RDF (B) whenever (x)  {rdf : 1 , rdf : 2 , . . .}.
Without any restrictions, the answer to B under RDF entailment would thus
be infinite even in the empty graph. To prevent this, adRDF (G) excludes rdf : 1 ,
rdf : 2 , . . . that do not occur in G, which makes adRDF (G) finite and thus ensures
finiteness of answers. Similar definitions are used for X other than RDF .
SPARQL treats blank nodes as objects with distinct identity. To understand
this, let G = {a, b, c,d, e, :1} where :1 is a blank node, let P = a, b, x,
and let  = {x ! :1}. Even though G |=RDF (P ), the answer to P on G under
RDF entailment does not contain . Roughly speaking,
:1 is distinct from c even
though :1 is semantically a placeholder for an arbitrary URI reference. We
capture this idea using skolemization: we replace the blank nodes in G with fresh
URI references, thus giving each blank node a unique identity. Our answers are
isomorphic to the answers of the official SPARQL specification, so skolemization
allows us to simplify the technical presentation without losing generality. We
formalize this idea by evaluating group patterns in X(G) instead of X(G).
Table 1 defines the answer PX

G to a group pattern P in a graph G w.r.t. X.

3 Representing Validity Time in RDF and OWL

To incorporate validity time into RDF, one could simply equip each triple with
a validity time instant; however, it would be impractical or even impossible
to explicitly list all such time instants. To this end, Chomicki distinguishes an

B. Motik

Table 1. Semantics of Group Patterns

G = { | dm() = var(B), rg()  adX(G), X(G) |= bX((B)) : X((B))}

BX

P1 and P2X
P1 union P2X
P1 opt P2X
P1 filter RX

G  P2X
G  P2X
G  P2X

G = P1X
G = P1X
G = P1X
G = {  P1X

 P1X

\ P2X

G |  |= R}

abstract from a concrete temporal database [4]. The former is a sequence of
static databases each of which contains the facts true at some time instant.
Since the time line is unbounded, an abstract temporal database is infinite, so
a concrete temporal database is used as a finite specification of one or more
abstract temporal databases. We next apply thus approach to RDF and OWL.
We use a discrete notion of time, since the ability to talk about predeces-
sors/successors of time instants is needed in Section 4. Thus, the set T I of time
instants is the set of all integers,  is the usual total order on T I, and +1 and
1 are the usual successor and predecessor functions on T I. The set of time
constants is T C = T I  {, +}; we assume that UBL  T C = . Time constants  and + are special in that they can occur in first-order formulae
only in atoms of the form   t,   +, and t  + for t a time instant
or a variable; all such atoms are syntactic shortcuts for true. This allows us to
simplify the notation for bounded and unbounded time intervals; for example,
to say that the interval described by formula t1  xt  t2 has no lower bound,
we write t1 = , which makes the formula equivalent to xt  t2.
Definition 1. A temporal triple has the form s, p, o[t] or s, p, o[t1, t2], such
that s, p, o  UBL, t  T I, t1  T I  {}, and t2  T I  {+}. A temporal
graph G is a finite set of temporal triples.

In this work, we focus mainly on the conceptual aspects of temporal graphs
and we do not discuss practical issues such as serialization syntax. We interpret
temporal graphs in multi-sorted first-order logic. Let t be a distinct temporal
sort interpreted over T I; we write xt to stress that a variable x ranges over T I.
For each n-ary predicate P , let P be the n + 1-ary predicate where positions 1n
have the same sort as in P , and position n + 1 is of sort t. For t a term of sort t
and P (u1, . . . , un) an atom, let P (u1, . . . , un)t = P (u1, . . . , un, t), and let t
be obtained by replacing each atom A with At in a first-order formula .
Intuitively, atom P (u1, . . . , un, t) encodes the truth of atom P (u1, . . . , un) at
time instant t: the former is true iff the latter is true at time t, so our approach is
similar to the temporal arguments approach [19]. Similarly, t determines the
truth of  at time instant t. As explained in Section 2,  is an ordinary predicate
with an explicit axiomatization, so  is well defined and it gives us a notion
of equality that changes with time. Finally, to understand why a multi-sorted
interpretation is needed, consider a graph G that encodes the OWL 2 DL axiom
  {c}. Such G is satisfiable only in first-order interpretations consisting of a
?

?

?
single object, which contradicts the requirement that a domain should contain
T I. Multi-sorted logic cleanly separates temporal instants from other objects
in the domain, so axioms such as   {c} do not quantify over time instants,
which solves the problem. We next define the semantics of temporal graphs.

Definition 2. Let X be an entailment relation from Section 2 other than DL,
and let X be the first-order theory that characterizes X. For G a temporal
graph, uX(G), bX(G), and tcX(G) are the subsets of U  L, B, and T C, respec-
tively, that occur in G. Mappings X and X are extended to temporal graphs as
shown below, where O is a fresh unary predicate. Furthermore, X(G) is obtained
from X(G) by skolemizing the existential quantifiers in bX(G), and ubX(G) is
uX(G) extended with the URI references introduced via skolemization.
?

?

?
X(s, p, o[t1, t2]) = xt : (t1  xt  t2)  T (s, p, o, xt)
X(G) =
X(G) = {bX(G) :

X(A)
O(u)  X(G)}  {xt : xt |   X}

ubX(G)

X(s, p, o[t]) = T (s, p, o, t)

O(u)  
?

?

?
AG

uuX (G)

A temporal graph G1 entails a temporal graph G2 under entailment relation X,
written G1 |=X G2, if and only if X(G1) |= bX(G2) : X(G2).
Intuitively, predicate O in X(G) contains all elements of uX(G)  bX(G) that
occur in G, which ensures that, whenever G1 |=X G2, all blank nodes in G2
can be mapped to uX(G1)  bX(G1). We discuss the rationale behind such a
definition at end of this section; for the moment, we just note that, when applied
to RDF(S), our definition of entailment coincides with the one from [7].

We next present a small example. Let G1 be the temporal graph containing
temporal triples (1)(3). Triples in (1) state that there is a flight from LHR
to MUC; this information may have been gathered from two distinct sources,
so validity times of the two triples overlap. Triple (2) states that Munich hosts
Oktoberfest. Finally, triple (3) states that, if x hosts y, then x has y as an
attraction; that this statement is not universally true might be due to the fact
that attractions are relevant only during holiday seasons. One can easily verity
that G1 |=RDFS :Munich, :hasAttraction, :Oktoberfest[130, 180].

:LHR, :flightTo, :MUC[50, 120]

:LHR, :flightTo, :MUC[100, 150]
:Munich, :hosts, :Oktoberfest[80, 180]
:hosts, rdfs:subPropertyOf , :hasAttraction[130, 300]

(1)
(2)
(3)

OWL 2 Direct entailment is not characterized by a fixed set of first-order impli-
cations, so we define temporal OWL 2 Direct entailment separately.

Definition 3. A temporal OWL 2 DL axiom has the form [t] or [t1, t2] for
 an OWL 2 DL axiom, t  T I, t1  T I  {}, and t2  T I  {+}. A
?

?

?
temporal OWL 2 DL ontology O is a finite set of temporal OWL 2 DL axioms.
Temporal axioms and ontologies are mapped into formulae as ([t]) = ()t,
([t1, t2]) = xt : (t1  xt  t2)  ()xt, and (O) =
A temporal graph G encodes a temporal OWL 2 DL ontology O(G) if O(G)

AO (A).
?

?

?
can be extracted from G using the mapping from [13] modified as follows:
 Each s, p, o in Tables 38 and 1015 is replaced with s, p, o[, +].
 Each triple pattern from Tables 16 and 17 without a main triple2 producing
an axiom  is changed as follows: each s, p, o in the pattern is replaced with
s, p, o[, +], and the triple pattern produces [, +].
 Each triple pattern from Tables 16 and 17 with a main triple sm, pm, om
producing an axiom  is replaced with the following two triple patterns.
 The first one is obtained by replacing each triple s, p, o in the pattern
other than the main one with s, p, o[, +], replacing the main triple
with sm, pm, om[t], and making the triple pattern produce [t].
 The second one is obtained by replacing each triple s, p, o in the pattern
other than the main one with s, p, o[, +], replacing the main triple
with sm, pm, om[t1, t2], and making the triple pattern produce [t1, t2].
For G encoding a temporal OWL 2 DL ontology O(G), uDL(G), bDL(G), and
tcDL(G) are the sets of named individuals, blank nodes, and temporal constants,
respectively, in O(G). Mappings, DL and DL are extended to G as shown be-
low, where O is a fresh unary predicate. Furthermore, DL(G) is obtained from
DL(G) by skolemizing the existential quantifiers in bDL(G), and ubDL(G) is
uDL(G) extended with the named individuals introduced via skolemization.
?

?

?
DL(G) =
ubDL(G)
DL(G) = bDL(G) :

O(u)  (O(G))
?

?

?
uuDL(G)

O(u)  DL(G)

For G1 and G2 temporal graphs that encode temporal OWL 2 DL ontologies, we
have G1 |=DL G2 if and only if DL(G1) |=DL bDL(G2) : DL(G2).
Definition 3 allows us to attach validity time to axioms (but not to parts of
axioms such as class expressions), which provides us with a flexible language
that can represent, for example, class hierarchies that change over time.
We next explain the intuition behind the predicate O in Definitions 2 and
3. Note that bX(G) occurs in X before the universal quantifiers over T I,
so blank nodes in G are interpreted rigidlythat is, they represent the same
objects throughout all time. For example, let G2 = {s, p, :1[, +]}, so
DL(G2) =  :1 : O( :1)  xt : p(s, :1, xt); since  :1 comes before xt, blank
node :1 refers to the same object at all time instants. In contrast, the existential quantifiers in xt and (O(G)) are not rigidthat is, they can be satisfied by different objects at different time instants. For example, let G3 be such
that O(G3) = {p.(s)[, +]}, so DL(G3) = xt : y : p(s, y, xt); since y
2 Please refer to [13] for the definition of a main triple.
?

?

?
ubX(G) O(u) and
?

?

?
Representing and Querying Validity Time in RDF and OWL

comes after xt, the value for y can be different at different time instants. Con-
sequently, G2 is not DL-equivalent to G3; in fact, G2 DL-entails G3, but not
vice versa. Blank nodes can thus be understood as unnamed constants, which
we believe to be in the spirit of RDF and OWL. In line with this intuition, con-
uuX(G) O(u) in Definitions 2 and 3 ensure that, if
juncts
G2 |=X G3, then the blank nodes in bX(G3) can be mapped to the rigid objects in
uX(G2), but not to the nonrigid objects whose existence is implied by existential
quantifiers. Without this restriction, G3 would DL-entail G4 = {s, p, :1[1, 1]}
(since the triple in G4 refers only to a single time instant, the nonrigidity of p.
is irrelevant), which seems at odds with the fact that G3 does not DL-entail G2.
Under our semantics, G3 does not DL-entail G4 due to the O predicate, which
seems more intuitive and it is also easier to implement.

4 Querying Temporal Graphs

The first step in designing a query language is to identify the types of questions
that the language should support. The language of first-order logic readily reveals
the following natural types of questions:

Q1. Is BGP B true in G at some time instant t?
Q2. Is BGP B true in G at all time instants between t1 and t2?
Q3. Is BGP B true in G at some time instant between t1 and t2?
Such questions can be easily encoded in first-order formulae, and an answer to a
formula Q over a graph G under entailment relation X can be defined as the set
of mappings  of the free variables of Q such that G |=X (Q). Such an approach,
however, has an important drawback. Let G5 = {a, b, c[5, 12], a, b, c[9, +]}
and let Q(x1, x2) = x : x1  x  x2  a, b, c[x] be a question of type Q2.
Evaluating Q(x1, x2) on G5 is not a problem if x1 and x2 are concrete time
instants. Note, however, that Q(x1, x2) does not ask for maximal x1 and x2 for
which the formula holds. Thus, the answer to Q(x1, x2) on G5 is infinite since it
contains each mapping  such that 5  (x1)  (x2)  +.

One can restrict answers to mappings that refer to time instants explicitly
occurring in G, but this is also problematic. First, answers can contain redundant mappings. For example, 1 = {x1 ! 5, x2 ! +} is the most general mapping in the answer to Q(x1, x2) on G5, but the answer also contains
a less general mapping 2 = {x1 ! 9, x2 ! 12}. Second, answers can differ
on syntactically different but semantically equivalent temporal graphs. For ex-
ample, G6 = {a, b, c[5, 10], a, b, c[7, +]} is equivalent to G5 under simple
entailment; however, 2 is not contained in the answer to Q(x1, x2) on G6,
and 3 = {x1 ! 7, x2 ! 10} is not contained in the answer to Q(x1, x2) on G5.
Third, computing redundant answers can be costly: an answer to a formula such
as Q(x1, x2) in a graph with n overlapping intervals consists of mappings that
refer to any two pairs of interval endpoints, so the number of mappings in the answer is exponential in n. One might try to identify the most general mappings,
but this would be an ad hoc solution without a clear semantic justification.

B. Motik

We deal with these problems in two stages. First, we introduce primitives that
support questions of types Q1Q3, as well as of types Q4Q5, thus explicitly
introducing a notion of maximality into the language.

Q4. Is [t1, t2] the maximal interval such that BGP B holds in G for each time

instant in the interval?

Q5. Is t the smallest/largest instant at which BGP B holds in G?
We define our notion of answers w.r.t. T C, which makes the answers independent
from the syntactic form of temporal graphs. To ensure finiteness, we then define
a syntactic notion of safety, which guarantees that only questions of type Q4
and Q5 can produce a value.

Practical applications will often need to express constraints on time points
and intervals retrieved via Q1Q5. For example, to retrieve hotels with vacancy during Oktoberfest, we must require the duration of Oktoberfest to be
contained in the hotels vacancy period. Such conditions can be expressed, for
example, using Allens interval algebra [1], and they can be integrated into our
query language via built-in expressions; for example, we can provide a built-in
expression that takes two pairs of interval end-points and that is true iff the first
interval is contained in the second. Such extensions of our query language are
straightforward, so we do not discuss them further in the rest of this paper.

Definition 4. A temporal group pattern (TGP) is an expression defined inductively as shown below, where B is a BGP, P1 and P2 are TGPs, R is a built-in
expression, t1  T I  {}  V, t2  T I  {+}  V, and t3  T I  V. TGPs
from the first two lines are called basic.

B at t3
B maxint [t1, t2]
P1 and P2

B during [t1, t2]
B mintime t3
P1 union P2

B occurs [t1, t2]
B maxtime t3
P1 opt P2

P1 filter R

We redefine a mapping as a partial function  : V  UBL  T C. Let X be an
 is
entailment relation and G a temporal graph. Let adX(G) = adX(G
the nontemporal graph obtained by replacing all triples in G of the form s, p, o[u]
and s, p, o[u1, u2] with s, p, o. The answer to a basic TGP P in G under X
is the set of mappings defined as specified below, where X((P )) is a condition
from Table 2. Answers to all other TGP types are defined in Table 1.

), where G

PX

G = { | dm() = var(P ), rg()  adX(G)  T C, and X((P )) holds}

We next present several TGPs that could be used in our running example.
TGP (4) returns the maximal intervals [y, z] during Oktoberfest in which a
flight from airport x to the Munich airport exists; the answer to (4) on G1
is {{x ! LHR, y ! 80, y ! 150}} . TGP (5) retrieves all events z in London
that have at least one time instant in common with Oktoberfest; if occurs were
changed to during, the TGP would retrieve all events z in London whose duration is contained in the duration of Oktoberfest. TGP (6) retrieves the first
time instant at which Munich hosted Oktoberfest; the answer to (6) on G1 is
?

?

?
B at t3
B during [t1, t2]
B occurs [t1, t2]
B maxint [t1, t2]

B mintime t3

B maxtime t3

Table 2. Semantics of Temporal Graph Patterns

X(P )

X(G) |= bX(B) : X(B)t3
X(G) |= bX(B) xt : [t1  xt  t2]  X(B)xt
X(G) |= bX(B) xt : [t1  xt  t2  X(B)xt]
a function  : bX(B)  ubX(G) exists such that
X(G) |= xt : [t1  xt  t2]  X((B))xt, and
t1 =  or
X(G) |= X((B))t1  1, and
t2 = + or
X(G) |= X((B))t2 + 1
a function  : bX(B)  ubX(G) exists such that
X(G) |= X((B))t3 and
X(G) |= X((B))xt for each xt  T I with xt  t3  1
a function  : bX(B)  ubX(G) exists such that
X(G) |= X((B))t3 and
X(G) |= X((B))xt for each xt  T I with t3 + 1  xt

Note: X(P ) does not hold if P is malformed (e.g., if it is of the form B at t3 and
t3  T I); and (B) is the result of replacing each blank node v in B with (v).

{{x ! 80}}. Finally, TGP (7) returns all rooms x that have price y during an
event z in Munich within the time interval [50, 100].

{x, :flightTo, :MUC, :Munich, :hosts, :Oktoberfest} maxint [y, z]
{:Munich, :hosts, :Oktoberfest} maxint [x, y] and
{:Munich, :hosts, :Oktoberfest} mintime x
{x, :hasPrice, y, :Munich, :hosts, z} occurs [50, 100]

{:London, :hosts, z} occurs [x, y]

(4)

(5)

(6)
(7)

We next turn our attention to the formal properties of TGPs. By Definition 4,
adX(G) does not contain time constants occurring in G and answers are defined
w.r.t. T C, which ensures that answers do not depend on the syntactic form of
temporal graphs. For example, temporal graphs G5 and G6 mentioned earlier
are equivalent and adX(G5) = adX(G6), so PX
Proposition 1. Let X be an entailment relation, and let G1 and G2 be temporal
graphs such that G1 |=X G2, G2 |=X G1, and adX(G1) = adX(G2). Then, for
each temporal group pattern P , we have PX
Since the answers are defined w.r.t. the entire set T C, temporal basic graph
patterns can have infinite answers. We next define a notion of safe TGPs and
later show that such group patterns always have finite answers.

G6 for each TGP P .

G5 = PX

G1 = PX
G2.

Definition 5. For P a temporal group pattern, uns(P ) is the set of variables as
shown in Table 3. Pattern P is safe if and only if uns(P ) = .

B. Motik

Table 3. The Definition of Safety

B at t3
B during [t1, t2]
B occurs [t1, t2]
P1 and P2
P1 opt P2

uns(P )
{t3}  V
{t1, t2}  V
{t1, t2}  V

B maxint [t1, t2]
B mintime t3
B maxtime t3
uns(P1)  [uns(P2) \ var(P1)] P1 union P2
uns(P1)  [uns(P2) \ var(P1)] P1 filter R

uns(P )





uns(P1)  uns(P2)

uns(P1)

Intuitively, x  uns(P ) means that there is no guarantee that (x)  T C implies (x)  tcX(G) for each   PX
G . Thus, B at t3, B during [t1, t2], and
B occurs [t1, t2] are safe iff t1, t2, and t3 are not variables: B can hold at potentially infinitely many time intervals, which could give rise to infinite answers
if t1, t2, or t3 were a variable. In contrast, B maxint [t1, t2], B mintime t3,
and B maxtime t3 are always safe as there are finitely many maximal intervals in which B holds. The nontrivial remaining cases are P1 and P2 and
P1 opt P2, in which we assume that P1 is evaluated before P2that is,
that the values for variables obtained by evaluating P1 are used to bind unsafe variables in P2; this will be made precise shortly in our algorithm for TGP
evaluation. Thus, (B1 occurs [x, y]) and (B2 maxint [x, y]) is not safe while
(B2 maxint [x, y]) and (B1 occurs [x, y]) is, which may seem odd given that conjunction is commutative. Without a predefined evaluation order, however, we
would need to examine every possible order of conjuncts in a conjunction to find
an executable one, which could be impractical.

We next present an algorithm for evaluating TGPs. We start by showing how
to decide three types of temporal entailment that are used as basic building
blocks of our evaluation algorithm. We first present some auxiliary definitions.
Let G be a temporal graph and X an entailment relation. A pair of time constants (t1, t2) is consecutive in G if t1, t2  tcX(G), t1 < t2, and no t  tcX(G)
exists with t1 < t < t2. The representative of such (t1, t2) is defined as t1 + 1
if t1 = , t2  1 if t1 =  and t2 = +, and 0 otherwise. Furthermore,

tiX(G)  T I is the smallest set that contains tcX(G)  T I and the representative of each consecutive pair of time constants in G. Finally, note that by
uubX (G) O(u)   and zero or more forDefinitions 2 and 3, X(G) contains
mulae of the form xt : ixt, and that  is a conjunction of formulae of the
form iti and xt : (t1
i )  ixt; then, for t  T I, X(G, t) is the
 xt  t2
set of all O(u), all i such that ti = t, all i such that t1
i , and all i.
i

 t  t2

i

Proposition 2. Let G be a temporal graph, let X be an entailment relation, let
B be a BGP such that var(B) = , and let t1  T I  {}, t2  T I  {+},
and t3  T I. Then, the following claims hold:
1. X(G) is satisfiable iff X(G, t) is satisfiable for each t  tiX(G).
2. X(G) |= bX(B) : X(B)t3 iff X(G) is unsatisfiable or some function

 : bX(B)  ubX(G) exists such that X(G, t3) |= X((B)).
?

?

?
Table 4. Evaluation of Temporal Group Patterns

evalX(P, G) is the set of mappings defined as follows depending on the type of P :

P = B at t3

or P = B during [t1, t2] or P = B occurs [t1, t2] :

{ | dm() = var(B), rg()  adX(G), and X((P )) holds}

P = B maxint [t1, t2] :

{ | dm() = var(P ), rg()  adX(G)  tiX(G)  {, +}, and X((P )) holds}

P = B mintime t3 :

{ | dm() = var(P ), rg()  adX(G)  tiX(G), X((B at t3)) holds, and
  (t3)  1}

)) does not hold for all t

  tiX(G) such that t

X((B at t

{ | dm() = var(P ), rg()  adX(G)  tiX(G), X((B at t3)) holds, and
  tiX(G) such that (t3) + 1  t

)) does not hold for all t

}

P = B maxtime t3 :

X((B at t
P = P1 and P2 :

{1  2 | 1  evalX(P1, G) and 2  evalX(1(P2), G)}

P = P1 union P2 :

evalX(P1, G)  evalX(P2, G)

P = P1 opt P2 :

evalX(P1 and P2, G)  {  evalX(P1, G) | evalX((P2), G) = }

P = P1 filter R :

{  evalX(P1, G) |  |= R}

3. X(G) |= bX(B) xt : [t1  xt  t2]  X(B)xt iff X(G) is unsatisfiable
or some  : bX(G)  ubX(G) exists such that X(G, t) |= X((B)) for
each t  tiX(G) with t1  t  t2.
4. X(G) |= bX(B) xt : [t1  xt  t2  X(B)xt] iff X(G) is unsatisfiable
or some  : bX(B)  ubX(G) exists such that X(G, t) |= X((B)) for
some t  tiX(G) with t1  t  t2.

Proposition 2 reduces temporal entailment to standard entailment problems that
can be solved using any decision procedure available. This provides us with a way
to check conditions X((P )) needed to evaluate safe TGPs. Furthermore, note
that Claim 3 can be straightforwardly extended to general temporal graph en-
tailment. We use these results as building blocks for the function shown in Table
4 that evaluates safe temporal group patterns. For P a basic TGP, evalX(P, G)
can be computed by enumerating all mappings potentially relevant to P and
then eliminating those mappings that do not satisfy the respective conditions;
optimizations can be used to quickly eliminate irrelevant mappings.

Proposition 3. Let G be a temporal graph, let X be an entailment relation
such that adX(G) is finite, and let P be a safe temporal group pattern. Then
evalX(P, G) = PX

G and PX

G is finite.

B. Motik

5 Optimized Query Answering

The algorithm from Table 4 checks temporal entailment using a black box decision procedure, which can be inefficient. In this section we first present an
optimization of this algorithm that is applicable to simple entailment, and then
we extend this approach to any entailment relation that can be characterized by
deterministic rules, such as RDF(S) and OWL 2 RL.

5.1 Simple Entailment

G1

G1

Let G

[t
, o

, p

, p = p

, o = o
?

?

?
1, t
?

?

?
2] overlap if s = s

, and max(t1, t

Simple entailment is the basic entailment relation in which BGPs can be evaluated in nontemporal graphs by simple graph lookup. Such an approach provides the basis of virtually all practical RDF storage systems and has proved
itself in practice, so it would be beneficial if similar approaches were applicable
to TGPs and temporal graphs. As the following example demonstrates, how-
ever, this is not the case. Let P = {:LHR, :flightTo, :MUC} maxint [x, y]; then
Psimple
= {{x ! 50, y ! 150}}. Note, however, that G1 does not contain temporal triple  = :LHR, :flightTo, :MUC[50, 150], so Psimple
cannot be computed via lookup. Temporal graph G1 is, however, equivalent to the normalized
temporal graph nrm(G1) obtained from G1 by replacing (1) with ; then, P can
be evaluated in nrm(G1) via lookup, which simplifies query processing. TGPs of
other types can additionally require adequate interval comparisons.
We next formalize this idea. We say that temporal triples s, p, o[t1, t2] and
s
?

?

?
2);
this definition is extended to triples of the form s, p, o[t1] by treating them as
abbreviations for s, p, o[t1, t1]. Let G be a temporal graph and let A  G be a
temporal triple. The maximal subset of G w.r.t. A is the smallest set GA  G
such that A  GA and, if   GA,   G, and  and  overlap, then   GA
as well. The normalization of G is the temporal graph nrm(G) that, for each
A  G of the form s, p, o[t1, t2] or s, p, o[t1], contains the temporal triple
s, p, o[t
?

?

?
2 are the smallest and the largest temporal con-
1, t
stant, respectively, occurring in the maximal subset GA of G w.r.t. A.
 be the list of the temporal triples in G of the form s, p, o[t1, t2]
and s, p, o[t1] sorted by s, p, o, t1, and t2. For each A  G, the triples that
, so nrm(G)
constitute the maximal subset GA of G occur consecutively in G
.
can be computed by a simple sequential scan through G
We next show how to use nrm(G) to evaluate temporal group patterns.
Let B = {s1, p1, o1, . . . ,sk, pk, ok} be a BGP, let x1, . . . , xk and y1, . . . , yk
be variables not occurring in B, and let G be a temporal graph. Then BG
is the set of all mappings  such that dm() = var(B)  {x1, y1, . . . , xk, yk},
(si, pi, oi[xi, yi])  nrm(G) for each 1  i  k, and 
, where the lat-
 = min{(y1), . . . , (yk)}.
ter are defined as 
Furthermore, |B if the restriction of a mapping  to var(B). Table 5 then shows
how to evaluate basic TGPs under simple entailment in a normalization.

 = max{(x1), . . . , (xk)} and 
?

?

?
2] where t
?

?

?
1 and t

1)  min(t2, t
?

?

?
  
?

?

?
Table 5. Evaluation of Temporal Group Patterns under Simple Entailment

evalsimple(P, G) is the set of mappings defined as follows:

P = B at t3 :

{ | dm() = var(P ) and   BG : |B = |B  

  t3  

}

P = B during [t1, t2] :

{ | dm() = var(P ) and   BG : |B = |B  

  t1  t2  

}

P = B occurs [t1, t2] :

{ | dm() = var(P ) and   BG : |B = |B  max(


, t1)  min(


, t2)}

P = B maxint [t1, t2] :

{ | dm() = var(P ) and   BG : |B = |B  (t1) = 

  (t2) = 

}

P = B mintime t3 :

{ | dm() = var(P ) and   BG :

  T I  |B = |B  (t3) = 


    BG : |B = |B  

  

}

P = B maxtime t3 :

{ | dm() = var(P ) and   BG :

  T I  |B = |B  (t3) = 


    BG : |B = |B  

  

}

.

si, pi, oi[xi, yi] in nrm(G)

Proposition 4. For each temporal graph G and each safe temporal group pattern P , we have evalsimple(P, G) = Psimple
We explain the intuition behind this algorithm for P = B maxint [t1, t2]. First, we
compute BG by evaluating the conjunctive query
via simple lookup. Consider now an arbitrary   BG. By the definition of
normalization, each (xi) and (yi) determine the maximal validity interval of
si, pi, oi so, to answer P , we must intersect all intervals [(xi), (yi)]. Note
 give the lower and the upper limit of the intersection, provided
that 
. Thus, what remains to be done is to convert  into  by setting
that 
(x) = (x) for each x  var(B) and ensuring that (t1) = 
 and (t2) = 
.
Based on these ideas, EOs system translates TGPs into SQL, which allows us
to use a standard database query planner to optimize query execution.

 and 
  

5.2 Entailments Characterized by Deterministic Rules
Let X be an entailment relation that can be characterized by a set X of deterministic rules of the form (8).

A1  . . .  An  B

(8)
To evaluate a SPARQL group pattern in a graph under X-entailment, most
existing (nontemporal) RDF systems first compute the closure of the graph
w.r.t. X. We next show how to compute the temporal closure clsX(G) of a
temporal graph G using the rules from X. After computing the closure, we can
normalize it and then apply the algorithm from Section 5.1.

B. Motik

Definition 6. For X and X as stated above, let X be the set containing the
rule (9) for each rule (8) in X.
A1[x1, y1]  . . .  An[xn, yn]  max(x1, . . . , xn)  min(y1, . . . , yn) 

B[max(x1, . . . , xn), min(y1, . . . , yn)] (9)
Let G be a temporal graph consisting of triples of the form s, p, o[t1, t2].3 The
skolemization of G is a temporal graph obtained from G be replacing each blank
node with a fresh URI reference. Furthermore, the temporal closure of G is the
(possibly infinite) temporal graph clsX(G) obtained by exhaustively applying the
rules in X to the skolemization of G.
By applying this approach to G1 under RDFS entailment, one can see that (2)
and (3) produce :Munich, :hasAttraction, :Oktoberfest[130, 180].

The following proposition shows that, instead of evaluating TGPs in G under

X-entailment, one can evaluate them in clsX(G) under simple entailment.
Proposition 5. Let X and G be as stated in Definition 6. For each temporal
group pattern P , we have PX

 = clsX(G).

, where G

G = Psimple

G

6 Implementation and Outlook

In this paper we presented an approach for representing validity time in RDF
and OWL, an extension of SPARQL that allows for querying temporal graphs,
and two query answering algorithms. We implemented our approach in EOs
knowledge representation system. The system is based on a proprietary extension of RDF that supports n-ary relations; it uses an ontology language based on
OWL 2 RL; and it implements a proprietary query language based on the primitives and the notion of safety outlined in Section 4. The PostgreSQL database
is used for data persistence and query processing. Ontology reasoning is implemented by translating the ontology into a datalog program, which is then
compiled into a plSQL script that implements the semina ve datalog evaluation
strategy. Datalog rules are modified as described in Section 5.2 in order to deal
with validity time; furthermore, the resulting set of facts obtained by applying
the rules is normalized to allow for efficient query answering. Finally, temporal
queries are translated into SQL and then evaluated using PostgreSQLs query
engine; the translation essentially encodes the query evaluation algorithm from
Section 5.1. The source of the system is not open, and EO has no plans for
licensing the system to third-party developers. Therefore, we do not present a
performance evaluation since such results could not be validated by the commu-
nity. We merely note that EO is successfully using our approach with datasets
consisting of tens of millions of triples, which we take as confirmation that our
approach is amenable to practical implementation.

An important open theoretical question is to determine the worst-case complexity bounds of the query answering problem for our query language. Fur-
thermore, one should see whether the general algorithm from Section 4 can be
3 For simplicity we assume that G does not contain triples of the form s, p, o[t1].
?

?

?
successfully used with expressive languages such as OWL 2 DL. We believe this
to be possible provided that the algorithm is adequately optimized.
