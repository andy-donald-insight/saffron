AnQL: SPARQLing Up Annotated RDFS

Nuno Lopes1, Axel Polleres1, Umberto Straccia2, and Antoine Zimmermann1

1 Digital Enterprise Research Institute,

National University of Ireland Galway, Ireland

{nuno.lopes,axel.polleres,antoine.zimmermann}@deri.org
2 Istituto di Scienza e Tecnologie dellInformazione (ISTI - CNR), Pisa, Italy

straccia@isti.cnr.it

Abstract. Starting from the general framework for Annotated RDFS which we
presented in previous work (extending Udrea et als Annotated RDF), we address
the development of a query language  AnQL  that is inspired by SPARQL,
including several features of SPARQL 1.1. As a side effect we propose formal
definitions of the semantics of these features (subqueries, aggregates, assign-
ment, solution modifiers) which could serve as a basis for the ongoing work in
SPARQL 1.1. We demonstrate the value of such a framework by comparing our
approach to previously proposed extensions of SPARQL and show that AnQL
generalises and extends them.

Introduction

RDF (Resource Description Framework) [14] is the widely used representation language for the Semantic Web and the Web of Data. RDF exposes data as triples, consisting of subject, predicate and object, stating that subject is related to object by the
predicate relation. Several extensions to RDF were proposed in order to deal with
time [7,19,24], truth or imprecise information [15,22], trust [10,20] and provenance [4].
All these proposals share a common approach of extending the RDF language by attaching meta-information about the RDF graph or triple. RDF Schema (RDFS) [3] is the
specification of a restricted vocabulary that allows to deduce further information from
existing triples. In our previous work [23], we presented a general extension to RDFS,
improving on Udrea et als Annotated RDF [25], that is capable of encapsulating the
mentioned RDF extensions as specific domains for RDF annotations. For this general
extension, we present a generic RDFS reasoning procedure which can be formulated
independently of the annotation domain by being parameterised with operations any
domain needs to provide. An overview of Annotated RDFS is presented in Sect. 1.

SPARQL [21] is the W3C-standardised query language for RDF. In this paper we
present an extension of SPARQL for querying annotated RDFS. SPARQL shares similarities with SQL although several features, such as aggregates, nested queries and
variable assignments, are still missing from the current SPARQL specification. Our
SPARQL extension presented here also deals with these missing features thus going
beyond the features of SPARQL, heading towards the currently under development
SPARQL 1.1 specification [9]. Our extension of SPARQL, called AnQL, is presented in
Sect. 2. Furthermore, Sect. 3 presents a discussion of some of the most important issues
with the design of our query language along with the comparison to some of the related
works.

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 518533, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
Related Work. The basis for Annotated RDF were first established by Udrea et al. [25,
26], in which their query language is restricted to conjunctive queries. SPARQL is compared to the presented conjunctive queries but excludes the possibility of querying an-
notations. Furthermore, OPTIONAL, UNION and FILTER SPARQL queries are not
considered which results in a subset of SPARQL that can be directly translated into
their previously presented conjunctive query system.

In [7], Guti errez et al. present conjunctive queries with built-in predicates for querying temporal RDF, neither considering full SPARQL. Pugliese et al. [19] also have a
temporal framework where they only define conjunctive queries, thus ignoring some of
the more advanced features of SPARQL. Tappolet and Bernstein [24] present temporal extensions for RDF and SPARQL. A storage format for temporal RDF is presented
where each time interval is stored as a named graph. The -SPARQL query language allows to query the temporal RDF representation using an extended SPARQL syntax that
can match the graph pattern against the snapshot of a temporal graph at any given time
point and allows to query the start and endpoints of a temporal interval, whose values
can then be used in other parts of the query. The RDF extensions towards uncertain or
fuzzy information [15, 22] so far do not address SPARQL, presenting only extensions
for RDFS reasoning but [22] formalises conjunctive queries.

SPARQL extensions towards querying trust have been presented by Hartig [10]. Hartig introduces a trust aware query language, tSPARQL, that includes a new constructor
to access the trust value of a graph pattern. This value can then be used in other statements such as FILTERs or ORDER.

Another extension to query meta-knowledge in RDF, mostly considering provenance
and uncertainty is presented by Dividino et al. [4]. In this work, the meta-information
is stored using named graphs and the syntax and semantics of SPARQL are extended to
consider an additional expression that enables querying the named graphs representing
the meta-information.

Our present work can also be related to annotated relational databases, especially
Green et al. [6] who provides a similar framework for the relational algebra. After
presenting a generic structure for annotations, they focus more specifically on the provenance domain. The specificities of the relation algebra, especially Closed World
Assumption, allows them to define a slightly more general structure for annotation do-
mains, namely semiring (as opposed to residuated lattice in our approach).

1 Annotated RDFS

For the sake of making the paper self-contained, we recap essential parts from [23],
where we only considered ground graphs, while here we do allow blank nodes as well.

1.1 Syntax
Consider pairwise disjoint alphabets U, B, and L denoting, respectively, URI refer-
ences, blank nodes (i.e., variables, denoted x, y, z)1 and Literals.2 We call the elements

1 We will often use the term blank node and variable synonymously in this paper.
2 We assume U, B, and L fixed, and for ease we will denote unions of these sets simply con-

catenating their names.
?

?

?
in UBL (B) terms. An RDF triple is  = (s, p, o)  UBL  U  UBL.3 We call
s the subject, p the predicate, and o the object. An annotated triple is an expression
 : , where  is a triple and  is an annotation value (defined below). An annotated
graph G is a finite set of annotated triples. The universe of G, universe(G), is the set
of elements in UBL that occur in the triples of G. A vocabulary is a subset of UL.

As in our previous work, for presentation purposes, we rely on a fragment of RDFS,
called df [16], that covers essential features of RDFS.4 df is defined as the following
subset of the RDFS vocabulary: df = {sp, sc, type, dom, range}. Informally, (i)
(p, sp, q) means that property p is a subproperty of property q; (ii) (c, sc, d) means
that class c is a subclass of class d; (iii) (a, type, b) means that a is of type b; (iv)
(p, dom, c) means that the domain of property p is c; and (v) (p, range, c) means that
the range of property p is c. Annotations are added to triples to attach meta information
such as temporal validity, trust or fuzzy value, provenance.

Example 1. For instance, the following annotated triple:

(:Alain, :livesIn, :Paris): [1980, 1991]

in a temporal setting [7] has intended meaning Alain lives in Paris from 1980 to 1991,
while in the fuzzy setting [22]:

(audiTT, type, SportsCar): 0.8

has intended meaning AudiTT is a sports car to degree not less than 0.8; considering
provenance as annotations:

(Person, sc, Agent): {http://xmlns.com/foaf/0.1/}

would mean that the subclass relationship between persons and agents is defined by 
or, belongs to  the document http://xmlns.com/foaf/0.1/.

1.2 RDFS Annotation Domains
Consider a lattice L,. Elements in L are our annotation values. The order  is
used to express redundant/entailed/subsumed information. For instance, for temporal
intervals, an annotated triple (s, p, o): [2000,2006] entails (s, p, o): [2003,2004],
as [2003,2004]  [2000,2006] (here,  plays the role of ). Informally, an interpretation will map statements to elements of the annotation domain. Our semantics
generalises the one of standard RDFS by using an algebraic structure that is well-known
for Many-Valued FOL [8]. We say that an annotation domain for RDFS is a residuated
bounded lattice D = L,,,,,,,.5 That is,
1. L,,,,, is a bounded lattice, where  and  are bottom and top ele-
2. L,, is a commutative monoid;
3 As in [16] we allow literals for s.
4 Just as in [16] our annotation framework can be extended to full RDFS, adding additional

ments, and  and  are meet and join operators;

semantic conditions and respective inference rules [13].

5 We correct here an imprecision in the definition given in [23], in which we did not mention

that the structure should be a residuated lattice.
?

?

?
3.  is the so-called residuum of , i.e., for all 1, 2, 3, 1  3  2 iff 3 

(1  2).

Remark 1. Note that 1  2 can be determined uniquely as 1  2 = sup{ |
1    2} (see [11]). Furthermore, in the remaining of this paper, we do not use the
 which is implicitly defined by the order . For these reasons, we represent a domain
succinctly as 6-tuple L,,,,,.
In what follows we define a map as a function  : UBL  UBL preserving URIs
and literals, i.e., (t) = t, for all t  UL. Given a graph G, we define (G) =
{((s), (p), (o)) | (s, p, o)  G}. We speak of a map  from G1 to G2, and write
 : G1  G2, if  is such that (G1)  G2.

1.3 Semantics
Fix an annotation domain D = L,,,,,. Informally, an interpretation I will
assign to a triple  an element of the annotation domain   L, dictating that under I,
the annotation of  is greater or equal than (i.e., ) . Formally, an annotated interpretation I over a vocabulary V is a tuple I = R, P , C , L, P [[]], C[[]],I where
R, P , C , L where R, P , C, L are the interpretation domains of I, which
are the interpretation functions of I. These
are finite non-empty sets, and P [[]], C[[]],I
have to satisfy:
1. R are the resources (the domain or universe of I);
2. P are property names (not necessarily disjoint from R);
3. C  R are the classes;
4. L  R are the literal values and contains L  V ;
5. P [[]] maps each property name p  P into a function P [[p]] : R  R  L, i.e.,
6. C[[]] maps each class c  C into a function C[[c]] : R  L, i.e., assigns an
7. I

I  R  P , and such that I
identity for plain literals and assigns an element in R to each element in L;

annotation value representing class membership in c to every resource.

maps each t  UL  V into a value t

assigns an annotation value to each pair of resources;

is the

Intuitively, a triple (s, p, o):  is satisfied by an annotated interpretation I if (s, o)
belongs to the extension of p to a wider extent than . We formalise this intuition
in terms of semantic conditions on the use of the RDFS vocabulary. That is, an interpretation I is a model of an annotated ground graph G, denoted I |= G, iff I
is an interpretation over the vocabulary df  universe(G) that satisfies the conditions in Table 1. Here, considering a set   R  P , we say that a function
p:     L is sup- transitive (or simply transitive) over  iff for all x, z  ,
supy
Finally, entailment among annotated ground graphs G and H is as usual. Now, G |=
of G there is a
?

?

?
H, where G and H may contain blank nodes, iff for any grounding G
grounding H
6 As  is finite, sup- transitivity is well defined.

7 A grounding G

of graph G is obtained by replacing variables in G with terms in UL.

{p(x, y)  p(y, z)}  p(x, z).6

of H such that G

.7
?

?

?
 |= H
?

?

?
N. Lopes et al.

Table 1. The conditions for annotated interpretations

Simple:

1. (s, p, o) :   G implies p

I  P and P [[p

I]](s

I)  ;
, o

Subproperty:
1. P [[sp
2. P [[sp

Subclass:

1. P [[sc
2. P [[sc

Typing I:

I]] is sup- transitive over P ;
I]](p, q) = inf (x,y)RR P [[p]](x, y)  P [[q]](x, y);
I]] is sup- transitive over C;
I]](c, d) = inf xR C[[c]](x)  C[[d]](x);

I]](p, c) = inf (x,y)RR P [[p]](x, y)  C[[c]](x);
I]](p, c) = inf (x,y)RR P [[p]](x, y)  C[[c]](y);

I]](x, c);

I  P

Typing II:

1. C[[c]](x) = P [[type
2. P [[dom
3. P [[range
1. For each e  df, e
2. P [[dom
3. P [[range
4. P [[type

I]](p, c) is defined only for p  P and c  C
I]](p, c) is defined only for p  P and c  C
I]](s, c) is defined only for c  C.

Remark 2. In [16], the authors define two variants of the semantics of df: the default
one includes reflexivity of the subclass and subproperty relations but in the present
paper, we extend the alternative semantics presented in [16, Definition 4] which omits
this requirement.
Remark 3. Note that we always have that G |=  : . Clearly, triples of the form  : 
are uninteresting and, thus, in the following we not consider them as part of the lan-
guage.

As for the crisp case, it can be shown [23] that any annotated RDFS graph has a finite
model (modulo Remark 3) and, thus, we do not have to care about consistency.

1.4 Deductive System

The important feature of the annotation framework is that we are able to provide a deductive system in the style of the one for classical RDFS. Moreover, the schemata of the
rules are the same for any annotation domain (only support for the domain dependent
 and  operations has to be provided) and, thus, are amenable to an easy implementation on top of existing systems. Specifically, the rule set contains the rules presented
in Table 2. Please note that rule 6 from Table 2 is destructive, i.e., this rule removes the
premises as the conclusion is inferred, intuitively meaning that only maximal annotations are preserved.
Remark 4. We point out that rules 2  5 from Table 2 can be represented concisely
using the following inference rule:

(A) 1 : 1, ..., n : n,{1, . . . n} RDFS 

 :

i i
?

?

?
Table 2. Inference rules for annotated RDFS

1. Simple:
(a) G

G for a map  : G

  G (b) G

G for G

  G

2. Subproperty:

(a) (A, sp, B) : 1,(B, sp, C) : 2

(A, sp, C) : 1  2

3. Subclass:

(a) (A, sc, B) : 1,(B, sc, C) : 2

(A, sc, C) : 1  2

4. Typing:

(b) (D, sp, E) : 1,(X, D, Y ) : 2

(X, E, Y ) : 1  2

(b) (A, sc, B) : 1,(X, type, A) : 2

(X, type, B) : 1  2

(a) (D, dom, B) : 1,(X, D, Y ) : 2

(X, type, B) : 1  2

(b) (D, range, B) : 1,(X, D, Y ) : 2

(Y, type, B) : 1  2

5. Implicit Typing:

(a) (A, dom, B) : 1,(D, sp, A) : 2,(X, D, Y ) : 3
(b) (A, range, B) : 1,(D, sp, A) : 2,(X, D, Y ) : 3

(X, type, B) : 1  2  3
(Y, type, B) : 1  2  3

6. Generalisation:

(X, A, Y ) : 1,(X, A, Y ) : 2

(X, A, Y ) : 1  2
?

?

?
Essentially, this rule says that if a classical RDFS triple  can be inferred by applying a
classical RDFS inference rule to triples 1, . . . n (denoted {1, . . . , n} RDFS ), then
the annotation term of  will be
i i, where i is the annotation of triple i. It follows
immediately that, using rule schema (A), the annotated framework extends to the whole
RDFS rule set as well. We also assume that rule schema (A) or rule 6 of Table 2 are not
applied if the consequence is of the form  :  (see Remark 3).
Finally, like for the classical case, the closure is defined as cl(G) = { :  | G 
 : }, where 
is as  for the annotated framework without rule (1a). Notice that the
size of the closure of G is polynomial in |G| and can be computed in polynomial time,
provided that the computational complexity of operations  and  are polynomially
bounded (from a computational complexity point of view, it is as for the classical case,
plus the cost of the operations  and  in L).
Proposition 1 (Soundness and completeness). For an annotated graph, the proof system  is sound and complete for |=, that is, (1) if G   :  then G |=  :  and (2) if
G |=  :  then there is 

   with G   : 
?

?

?
.

1.5 Examples of Domains

Here, we instantiate the definition with several domains that have been discussed in
the literature. The interested reader can find more details about the temporal and fuzzy
domains in our previous work [23] and additional information in our accompanying
technical report [13]. Furthermore, domains can be combined into a multi-dimensional
annotation domain as explained in [23].

N. Lopes et al.

Crisp. Note that with the domain D01 = {0, 1}, , max, min, 0, 1, Annotated RDFS
turns out to be the same as standard RDFS.

Fuzzy. The fuzzy domain has been presented in [15, 22] and to model fuzzy RDFS
in our framework is easy: the annotation domain is D[0,1] = [0, 1], , max,, 0, 1
where  is any continuous t-norm on [0, 1] and  is max.

Temporal. For modelling the temporal domain we generalise the notions presented
in [7,19,24] and consider that time points are elements of xsd:dateTimeStamp [18] value
space  {, +}.8 A temporal interval is a non-empty interval [1, 2], where i
are time points. An empty interval is denoted as . We define a partial order on intervals
as I1  I2 iff I1  I2 and L as (where  = {}, = {[, +]}). Therefore, a
temporal term is a finite set of pairwise disjoint time intervals. Furthermore, on L we
define the following partial order:

t1  t2 iff I1  t1I2  t2, such that I1  I2 .

The join and t-norm  operators are defined as:

t1  t2 = inf{t | t  ti, i = 1, 2}
t1  t2 = sup{t | t  ti, i = 1, 2} .

Remark 5. Although we represent time points as dateTimeStamps, for presentation purposes in this paper we will only use years.

Provenance. We also generalise the representation of provenance as described, e.g.,
in [4, 5]. In this case, we start from a countably infinite set of atomic provenances P.
We consider the propositional formulae made from symbols in P (atomic propositions),
logical or () and logical and (), for which we have the standard entailment |=. A
provenance value is an equivalent class for the logical equivalence relation, i.e., the
set of annotation values is the quotient set of P by the logical equivalence. The order
relation is |=, t-norm and join are  and  respectively. We set  to true and  to false.

Trust. For the trust domain we rely on previous work by Schenk [20] that defines
a bilattice structure to model some form of trust. We can directly use this algebraic
structure as an annotation domain in our framework.

2 AnQL: Annotated SPARQL

We now present an extension of the SPARQL [21] query language, made for querying
annotated graphs, which we call AnQL. For the rest of this section we fix a specific
annotation domain, D = L,,,,,.

8 Note that we have a continuous set of time points as opposed to Guti errez et al. [7].
?

?

?
2.1 Syntax
A simple AnQL query is defined  analogously to a SPARQL query  as a triple Q =
(P, G, V ) where P is an annotated graph pattern, the dataset G is an annotated graph
and V is a set of variables, called the result form. We restrict ourselves to SELECT
queries in this work so it is sufficient to consider the result form V as a list of variables
to be projected.

Remark 6. Note that, for presentation purposes, we simplify the notion of datasets by
excluding named graphs and thus GRAPH queries. Our definitions can be straightforwardly extended to named graphs and we refer the reader to the SPARQL W3C
specification [21] for details.
Triple patterns in annotated AnQL are defined the same way as in SPARQL. A triple
pattern is a triple (s, p, o) where s, o  UBL and p  UB. We denote variables from
B in triple patterns by ? prefixed names.9 Let V be a distinct set of variables, called
annotation variables. For a triple pattern  and  either an annotation term from D
or an annotation variable, we call  :  an annotated triple pattern; sets of annotated
triple patterns are called basic annotated patterns (BAP). An annotated graph pattern
is defined in a recursive manner: any BAP is an annotated graph pattern; if P and
are annotated graph patterns, R is a filter expression (see [21], and later on), then

), (P FILTER R) are annotated graph
(P AND P
patterns.

), (P OPTIONAL P
?

?

?
), (P UNION P

Example 2. Suppose we are looking for people who live near Paris during some time
period and optionally owned a car during that period. This query can be posed as fol-
lows:

SELECT ?p ?c ?l
WHERE {(?p :basedNear :paris):?l OPTIONAL{(?p :hasCar ?c):?l}}

Assuming the following input data:

(:alain, :livesIn, :paris): [2007, 2010]
(:alain, :hasCar, :peugeot): [2004, 2009]
(:alain, :hasCar, :renault): [2010, 2010]
(:livesIn, sp, :basedNear): [, +]

we will get the following answers:

1 = {?p/:alain, ?l/[2007, 2010]}
2 = {?p/:alain, ?c/:peugeot, ?l/[2007, 2009]}
3 = {?p/:alain, ?c/:renault, ?l/[2010, 2010]} .

The first answer corresponds to the answer in which the OPTIONAL pattern is not
satisfied, so we get the annotation value [2007, 2010] that corresponds to the time Alain
lives in Paris. In the second and third answers, the OPTIONAL pattern is matched and,
in this case, the annotation value is restricted to the time when Alain lives in Paris and
has a car.

9 Note that we do not consider blank nodes in triple patterns separately, since they can be treated

just as other variables.

N. Lopes et al.

Note that  as we will see  this first query will return as a result for the annotation
variable the periods where a car was owned.

Example 3. A slightly different query can be people who lived near Paris during some
time period and optionally owned a car at some point during their stay. This query 
which will rather return the time periods of employment  can be written as follows:
SELECT ?p ?c ?l WHERE {(?p :basedNear :paris):?l

OPTIONAL {(?p :hasCar ?c):?l2 FILTER (?l2  ?l)} }

Using the input data from Example 2, we obtain the following answers:

1 = {?p/:alain, ?l/[2007, 2010]}
2 = {?p/:alain, ?c/:renault, ?l/[2007, 2010]}

In this example the FILTER behaves as in SPARQL by removing from the answer set
the mappings that do not make the FILTER expression true. This query also exposes the
issue of unsafe filters, noted in [2].

2.2 Semantics

We denote by var(P ) the set of variables and annotation variables present in a BAP P .
A substitution  for a BAP P is a mapping with domain var(P ) (annotation) variables
into (annotation) terms occurring in G. We denote the domain of a substitution , i.e.
the variables for which  is defined, by dom(). For convenience, sometimes we will
use the notation  = {x1/t1, . . . , xn/tn} to indicate that (xi) = ti, i.e., variable xi is
assigned to term ti. Note that we do not allow any assignment of an annotation variables
to  (of the domain D). An annotation value of , although it is a valid answer for any
triple, does not provide any additional information and thus is of minor interest.
For a BAP P , and a substitution  we denote by (P ) the triples obtained by replacing the variables in P according to . By G |= (P ) we denote the fact that (P ) is
entailed by G.

For the extension of the SPARQL relational algebra to the annotated case we introduce  inspired by the definitions in [17]  definitions of compatibility and union
of substitutions: given two substitutions 1 and 2, 1 and 2 are -compatible if and
only if (i) 1(x) = 2(x) for any non-annotation variable x  dom(1)  dom(2);
(ii) 1()  2() =  for any annotation variable   dom(1)  dom(2). Fur-
ther, for two -compatible substitutions 1 and 2the -union, denoted 1  2, is as
1  2, with the exception that for any annotation variable   dom(1)  dom(2),
1  2() = 1()  2().

We are now ready to present the notion of evaluation for generic AnQL graph pat-
terns. Let P be a BAP, P1, P2 annotated graph patterns, G an annotated graph and R a
filter expression, then the evaluation [[]]G, i.e., set of answers,10 is recursively defined
as:
10 Strictly speaking, we consider sequences of answers  note that SPARQL allows duplicates
and imposing and order on solutions, cf. Sect. 2.3 below for more discussion  but we stick
with set notation representation here for illustration. Whenever we mean real sets where
duplicates are removed we write {. . .}DISTINCT.
?

?

?
= { | dom() = var(P ) and G |= (P )}
= {1  2 | 1  [[P1]]G, 2  [[P2]]G, 1 and 2 -compatible}
= [[P1]]G  [[P2]]G
= { |   [[P1]]G and R is true}

[[P ]]G
[[P1 AND P2]]G
[[P1 UNION P2]]G
[[P1 FILTER R]]G
[[P1 OPTIONAL P2[R]]]G = { | and  meets one of the following conditions:
1.)  = 1  2 if 1  [[P1]]G, 2  [[P2]]G, 1 and 2 -compatible, and R is true
2.)  = 1  [[P1]]G and 2  [[P2]]G such that 1 and 2 -compatible,

R(1  2) is true, and for all annotation variables  in dom(1)  dom(2),
2()  1()
R(1  2) is false}

3.)  = 1  [[P1]]G and 2  [[P2]]G such that 1 and 2 -compatible,
?

?

?
   iff (i) 

Remark 7. For practical convenience, we retain in [[]]G only domain maximal an-
= ; (ii) dom() = dom(
); (iii)
swers. That is, let us define 
()  () for any annota-
(x) for any non-annotation variable x; and (iv) 
(x) = 
tion variable . Then, for any   [[P ]]G we remove any 
  .
  [[P ]]G such that 
Remark 8. Please note that the cases for the evaluation of the OPTIONAL are compliant with the SPARQL specification [21], covering the notion of unsafe FILTERs as
presented in [2]. However, there are some peculiarities inherent to the annotated case.
More specifically case 2.) introduces the side effect that annotation variables that are
compatible between the mappings may have different values in the answer depending
if the OPTIONAL is matched of not. This is the behaviour demonstrated in Example 2.

The notion of true filter is defined as follows: for a FILTER expression R, the valuation
of R on a substitution , denoted R is true iff:11

(1) R = BOUND(v) with v  dom();
(2) R = isBLANK(v) with v  dom() and (v)  B;
(3) R = isIRI(v) with v  dom() and (v)  U;
(4) R = isLITERAL(v) with v  dom() and (v)  L;
(5) R = (u = v) with u, v  dom()  UBL and (u) = (v);
(6) R = (R1) with (R1) is false;
(7) R = (R1  R2) with (R1) is true or (R2) is true;
(8) R = (R1  R2) with (R1) is true and (R2) is true;
(9) R = (x  y) with x, y  dom()  L and (x)  (y);
(10) R = p( z) with p( z) = true iff p(( z)) = true, where p is a built-in predicate.

In the FILTER expressions above, a built-in predicate p is any n-ary predicate p, where
ps arguments may be variables (annotation and non-annotation ones), domain values
of D, values from UL, p has a fixed interpretation and we assume that the evaluation of
the predicate can be decided in finite time. Annotation domains may define their own
built-in predicates that range over annotation values as in the following query:
Example 4. Consider we want to know where Alain was living before 2009. This query
can be expressed in the following way:

SELECT ?city
WHERE {(:alain :livesIn ?city):?l FILTER(before(?l, [2009]))}

11 We consider a simple evaluation of filter expressions where the error result is ignored,

see [21, Sect. 11.3] for details.

N. Lopes et al.

The following proposition shows that we have a conservative extension of SPARQL:

Proposition 2. Let Q = (P, G, V ) be a SPARQL query over an RDF graph G. Let G
be obtained from G by annotating triples with . Then [[P ]]G under SPARQL semantics
is in one-to-one correspondence to [[P ]]G under AnQL semantics such that for any
  [[P ]]G there is a 

  [[P ]]G with  and 

coinciding on var(P ).
?

?

?
2.3 Further Extensions of AnQL

In this section we include various features from SPARQL 1.112 such as variable as-
signments, projection (i.e. sub-SELECTs), aggregates and solution modifiers to AnQL.
We succinctly present both syntax and semantics of the constructs. The evaluation of a
ASSIGN statement is defined as:

[[P ASSIGN f( z) AS z]]G = { | 1  [[P ]]G,  = 1[z/f(1( z))]} ,
?

?

?
where

[z/t] =

  {z/t}
( \ {z/t

if z  dom()

})  {z/t} otherwise .

Essentially, we assign to the variable z the value f(1( z)), which is the evaluation of
the function f( z) with respect to a substitution 1  [[P ]]G.
Example 5. Using a built-in function we can retrieve for each employee the length of
employment for any company:

SELECT ?x ?y ?z
WHERE {(?x :worksFor :?y):?l ASSIGN length(?l) AS ?z }
Here, the length built-in predicate returns, given a set of temporal intervals, the overall
total length of the intervals.

Remark 9. Note that this definition is more general than SELECT expr AS ?var
project expressions in current SPARQL 1.1 [9] due to not requiring that the assigned
variable be unbound.

We introduce the ORDERBY clause where the evaluation of a [[P ORDERBY ?x]]G
statement is defined as the ordering of the solutions  for any   [[P ]]G  according
to the values of (?x). Ordering for non-annotation variables follows the rules in [21,
Section 9.1]. In case the variable x is an annotation variable, the order is induced by .
In case,  is a partial order then we may use some linearisation method for posets, such
as [12]. Likewise, the SQL-like statement LIMIT(k) can be added straightforwardly.

We can further extend the evaluation of AnQL queries with aggregate functions

@  {SUM, AVG, MAX, MIN, COUNT,,,}
as follows: the evaluation of a GROUPBY statement is defined as:13
12 These features are currently being defined by W3C, see [9] for the latest draft.
13 In the expression,  @ f( z) AS   is a concise representation of n aggregations of the form

@ifi( zi) AS i.
?

?

?
[[P GROUPBY(  w)  @ f( z) AS  ]]G = { | 1 in [[P ]]G,  = 1|  w[i/@ifi(i( zi))]}DISTINCT ,
where the variables i  var(P ),  zi  var(P ) and none of the GROUPBY variables
 w are included in the aggregation function variables  zi. Here, we denote by |  w the restriction of variables in  to variables in  w. Using this notation, we can also straightforwardly introduce projection, i.e., sub-SELECTs as an algebraic operator in the language
covering another new feature of SPARQL 1.1:

[[SELECT  V {P}]]G = { | 1 in [[P ]]G,  = 1| v} .

Remark 10. Please note that the aggregator functions have a domain of definition and
thus can only be applied to values of their respective domain. For example, SUM and
AVG can only be used on numeric values, while MAX, MIN are applicable to any total order. Resolution of type mismatches for aggregates is currently being defined in
SPARQL 1.1 [9] and we aim to follow those, as soon as the language is stable. The
COUNT aggregator can be used for any finite set of values. The last three aggregation
functions, namely , and , are defined by the annotation domain and thus can be
used on any annotation values.

Remark 11. Please note that, unlike the current SPARQL 1.1 syntax, assignment, solution modifiers (ORDER BY, LIMIT) and aggregation are stand-alone operators in our
language and do not need to be tied to a sub-SELECT but can occur nested withinin
any pattern. This may be viewed as syntactic sugar allowing for more concise writing
than the current SPARQL 1.1 [9] draft.

Example 6. Suppose we want to know, for each employee, the average length of their
employments with different employers. Then such a query will be expressed as:

SELECT ?x ?avgL
WHERE{(?x :worksFor :?y):?l GROUPBY(?x) AVG(length(?l)) AS ?avgL}

Essentially, we group by the employee, compute for each employee the time he worked

for a company by means of the built-in function length, and compute the average value
for each group. That is, if g = {t, t1, . . . ,t, tn} is a group of tuples with the same
value t for employee x, and value ti for y, where each length of employment for ti is li
(computed as length()), then the value of avgL for the group g is (

Proposition 3. Assuming the built-in predicates are computable in finite time, the answer set of any AnQL is finite and can also be computed in finite time.

i li)/n.

This proposition can be demonstrated by induction over all the constructs we allow in
AnQL.

3 Twisting AnQL  Issues and Pitfalls

In this section we discuss some practical issues arising in formulating real-life questions
in AnQL like the treatment of non-annotated queries, combination of domains in queries
and some domain specific issues while highlighting problems in some related works.

N. Lopes et al.

3.1 Uniform Treatment of Annotated and Non-annotated Queries

We aim at providing a uniform treatment for queries, i.e., it should be allowed to ask annotated queries against non-annotated graphs and vice-versa. There are two distinct situations where a default value must be determined, viz., in the RDF data or in SPARQL
queries. The treatment of non-annotated triples in the data has been discussed in [23]
and here we just use the meta-variable D to represent the default value for domain
D. We consider a similar solution for evaluating a SPARQL query over an annotated
RDFS dataset. We allow that any non-annotated triple pattern  be considered a BAP
by assigning it a default annotation. We consider that a graph pattern P , is in Annotated
Normal Form (ANF) if it does not contain any non-annotated triple patterns. Any graph
pattern P can be transformed into ANF by replacing each non-annotated triple pattern
i  P by using one of the following approaches:
1. adding a single annotation variable for each triple: i : , where  is a new annota-

tion variable not occurring in P ; or

2. adding a different annotation variable for each non-annotated triple: i : i s.t. each
i is a new annotation variable not occurring in P and different from any other
generated variable; or

3. adding the  element from the domain: i : .
In later discussions, we will use the meta-variable D to represent the default value of
domain D assigned to annotations in the query triples.

Example 7. For instance, if we again consider the query (excluding the annotation vari-
ables) and input data from Example 2, the query would look like:

SELECT ?p ?c
WHERE {(?p :basedNear :paris) OPTIONAL{(?p :hasCar ?c)}}

Now, given the 3 approaches for transforming this query into ANF we would get the
following answers:

Approach 1

Approach 2

Approach 3

?p/:alain
?p/:alain
?p/:alain
?p/:alain
?p/:alain

-

?c/:peugeot
?c/:renault
?c/:peugeot
?c/:renault



3.2 Querying Multi-dimensional Domains

Similarly to the discussion in the previous subsection, we can encounter mismatches
between the Annotated RDFS dataset and the AnQL query. In case the AnQL query
contains only variables for the annotations, the query can be answered on any Annotated RDFS dataset. From a user perspective, the expected answers may differ from the
actual annotation domain in the dataset, e.g., the user may be expecting temporal intervals in the answers when the answers actually contain a fuzzy value. For this reason
some built-in predicates to determine the type of annotation should be introduced, like
isTEMPORAL, isFUZZY, etc.
?

?

?
If the AnQL query contains annotation values and the Annotated RDFS dataset contains annotations from a different domain, one option is to not provide any answers.
Alternatively, we can consider combining the domain of the query with the domain of
the annotation into a multi-dimensional domain, as illustrated in the next example.
Example 8. Assuming the following input data:

(:alain, :livesIn, :paris): {ex.org}

When performing the following query:
SELECT ?p ?c WHERE { (?p :livesIn ?c):[2009, 2010] }
we would interpret the data to the form:

(:alain, :livesIn, :paris): ({ex.org, temporal})

while the query would be interpreted as:
SELECT ?p ?c WHERE (?p :livesIn ?c):(provenance, [2009, 2010])
where temporal and provenance are annotations corresponding to the default values
their respective domains, as discussed in Section 3.1. The semantics of combining different domains into one multi-dimensional domain has been discussed in [23].

3.3 Temporal Issues
Let us highlight some specific issues inherent to the temporal domain. Considering
queries using Allens temporal relations [1] (before, after, overlaps, etc.) as allowed
in [24], we can pose queries like find persons who lived in Paris before Alain. this
query raises some ambiguity when considering that persons may have lived in the same
city at different disjoint intervals. We can model such situations  relying on sets of
temporal intervals modelling the temporal domain. Consider the following input data:

(:betty, :livesIn, :paris): {[1990, 1995]}
(:alain, :livesIn, :paris): {[1980, 2000], [2002, 2010]}

Tappolet and Bernstein [24] consider the latter triple as two triples with disjoint intervals
as annotations. For the following query in their language SPARQL:
SELECT ?p WHERE {
[?s1,?e1] ?p :livesIn :paris . [?s2,?e2] :alain :livesIn :paris .
[?s1,?e1] time:intervalBefore [?s2,?e2] }
we would get :betty as an answer although Alain was already living in Paris when
Betty moved there. This is one possible interpretation of before over a set of inter-
vals. In AnQL we could add different domain specific built-in predicates, representing
different interpretations of before. For instance, we could define binary built-ins (i)
beforeAny(?A1, ?A2) which is true if there exists any interval in annotation ?A1 before an interval in ?A2, or, respectively, a different built-in beforeAll(?A1, ?A2) which
is only true if all intervals in annotation ?A1 are before any interval in ?A2. Using the
latter, an AnQL query would look as follows:
SELECT ?p WHERE {(?p :livesIn :paris):?l1 .

(:alain :livesIn :paris):?l2 . FILTER(beforeAll(?l1,?l2))}

This latter query gives no result, which might comply with peoples understanding of
before in some cases, while we also have the choice to adopt the behaviour of [24] by
use of beforeAny instead. Our report [13] provides more details on this issue.

N. Lopes et al.

3.4 Constraints vs Filters
Considering the previous section, please note that FILTERs do not act as constraints
over the query. It could be expected that, given the data from the previous section, and
for the following query:
SELECT ?l1 ?l2 WHERE {(?p :livesIn :paris):?l1 .

(:alain :livesIn :paris):?l2 }

with an additional constraint that requires ?l1 to be before ?l2. We could expect
the answer {?l1/[1990, 1995], ?l2/[1996, 2000]} that matches the query with regards
to the data and satisfies the proposed constraint. However, we require maximality of
the annotation values in the answers, which in general, do not exist in presence of
constraints. For this reason, we do not allow general constraints.

Conclusions

Based on our previous work on Annotated RDFS [23], we presented a semantics for
an extension of the SPARQL query language, AnQL, that enables querying RDF with
annotations. Queries are specified with regards to a specific domain, from which we
presented some of the more common ones. Queries exemplified in related literature for
specific extensions of SPARQL can be expressed in AnQL.

Noticeably, our semantics goes beyond the expressivity of the current SPARQL specification and includes some features from SPARQL 1.1 such as aggregates, variable
assignments and sub-queries.

A prototype implementation, including the annotated RDFS inferencing and anno-

tated SPARQL query engine is available at http://anql.deri.org.

Acknowledgement. The work presented in this report has been funded in part by Science Foundation Ireland under Grant No. SFI/08/CE/I1380 (L on-2) and supported by
COST Action IC0801 on Agreement Technologies. We thank J urgen Umbrich for his
useful comments.
