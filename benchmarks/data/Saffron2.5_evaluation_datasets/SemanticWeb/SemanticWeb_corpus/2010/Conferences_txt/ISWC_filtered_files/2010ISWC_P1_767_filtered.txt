Completeness Guarantees for Incomplete

Reasoners

Giorgos Stoilos, Bernardo Cuenca Grau, and Ian Horrocks

Oxford University Computing Laboratory
Wolfson Building, Parks Road, Oxford, UK

Abstract. We extend our recent work on evaluating incomplete reasoners by introducing strict testing bases. We show how they can be used in
practice to identify ontologies and queries where applications can exploit
highly scalable incomplete query answering systems while enjoying completeness guarantees normally available only when using computationally
intensive reasoning systems.

1 Introduction

A key application of OWL ontologies is ontology-based data access [12,9,3,2,7,11],
where an ontology is used to support query answering against distributed and/or
heterogeneous data sources. The ontology provides the vocabulary used to formulate queries, and a conceptual model (or schema) that is used in computing
query answers. In a Semantic Web setting, a typical scenario would involve the
use of an OWL ontology to answer SPARQL queries over RDF datasets.

Unfortunately, when using an expressive ontology language such as OWL,
computing query answers can be very costly, and in a (Semantic) Web setting,
datasets may be extremely large. There has therefore been a growing interest in
the development of query answering systems that are highly scalable in practice,
but that are not guaranteed to be complete in all cases; i.e., for some combinations of query, ontology and dataset, they will not compute all query answers.
Most such systems (e.g., Oracles Semantic Data Store, Sesame, Jena, HAWK,
OWLim, Minerva, and Virtuoso) are based on database or RDF triple store
technologies; others are based on approximate reasoning techniques [10,5].

Although the scalability of such systems is attractive, application developers
face two main difficulties when using them. Firstly, incomplete query answers
may not be acceptable in a given application; and secondly, even if some incompleteness is acceptable, it may be important to know just how incomplete
answers are likely to be, and to compare the scalability-completeness trade-off
offered by different systems. One way to address these issues is via empirical
testing, e.g., checking the answers given by query answering systems w.r.t. a
particular ontology, dataset and query, and although primarily intended for performance testing, benchmark suites such as LUBM [4] have sometimes been used
for this purpose. However, this kind of testing has serious limitations: results are
specific to a given query, ontology and dataset, and may tell us nothing about

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 747763, 2010.
c Springer-Verlag Berlin Heidelberg 2010

G. Stoilos, B. Cuenca Grau, and I. Horrocks

the behaviour of the system more generally; and, in order to determine the sys-
tems degree of completeness, we need to already know, or be able to compute,
exact answers to the given queries.

In our recent work [13], we addressed these issues by introducing the notion of a Testing Base (TB). For a given ontology and query, a TB is a set of
datasets such that, for any well behaved query answering system, if the system is complete for each dataset in the TB, then it will be complete for any
dataset. As well as providing a quantitative measure of completeness, which
we call the completeness degree, TBs thus allow us to identify circumstances
under which a completeness guarantee can be provided even when the system
being used is incomplete in general. This is very useful in practice given that in
many applications the ontology and (kinds of) query are fixed at design time, or
change relatively infrequently, whereas the data is typically unknown and/or frequently changing. Unfortunately, we were unable to devise a practical algorithm
for computing TBs; instead, we devised an algorithm that efficiently computes
an approximation of a TB. This algorithm can be used to approximate the completeness degree, but it cannot be used to provide completeness guarantees.

In this paper we extend our previous work in several directions. Most impor-
tantly, we define the notion of a Strict Testing Base; we show that strict TBs
are typically much smaller than TBs, prove that they can be used to provide
the same completeness guarantee as TBs, and present an efficient algorithm for
computing them. This algorithm can thus be used to identify ontologies and
queries where applications can exploit highly scalable incomplete systems while
enjoying completeness guarantees normally available only when using computationally intensive reasoning systemsi.e., they can have the best of both worlds.
Additionally, we propose four properties that any reasonable measure of
completeness should ideally enjoy, and we show that while completeness degree
w.r.t. a TB satisfies all of these properties, completeness degree w.r.t. a strict
TB satisfies only two of them, albeit the most important two.

Finally, our preliminary evaluation, which includes the LUBM ontology and
queries as well as (a version of) the Galen ontology of clinical terms, suggests not
only that strict TBs are easy to compute in practice, but also that completeness
guarantees can often be provided for realistic ontologies and queries.

2 Preliminaries

Description Logics. We assume that the reader is familiar with the basics of
DL syntax, semantics and standard reasoning problems [1], and we use standard
notions of a TBox T (the terminology, or conceptual schema) and an ABox
A (the assertions, or data). In the context of ontology-based data access, the
ontology may be thought of as consisting only of a TBox, with the data being
stored in the sources. From an OWL point of view, however, we can treat the
contents of the sources as ABox assertions, and the ontology as being the union
of the TBox and ABox, i.e., O = T  A. To avoid conflating the schema (TBox)
and the data (ABox), we consider only fragments of the DLs underpinning OWL
?

?

?
DL and OWL 2 that do not provide for nominals (i.e., that do not allow ABox
individuals to be used to define TBox concepts); we also assume (without loss of
generality) that ABoxes contain only atomic assertionsthat is, each assertion
of the form C(a) or R(a, b) in A must be such that C and R are atomic.

Queries. We use the standard notions of term, (function-free) atom and vari-
able. A datalog clause is an expression H  B1  . . .  Bn where H (the head) is
a (possibly empty) atom, B1  . . . Bn (the body) is a conjunction of atoms, and
each variable in the head also occurs in the body. A union of conjunctive queries
(UCQ) is a tuple u = QP , P with QP a query predicate and P a finite set of
datalog clauses such that QP is the only predicate occurring in head position in
P and the body of each clause in P does not contain QP . We denote with var(q)
the set of variables in q and say that a variable is distinguished if it appears in
the head. Finally, q is a conjunctive query (CQ) if it is a UCQ and P has one
clause. If q = QP , P is a CQ, we often abuse notation and write q = P ; if u is
a UCQ with P = {P1, . . . , Pn}, we write u = {q1, . . . , qn} with qi = Pi a CQ.
A tuple of constants  a is a certain answer of a UCQ q = QP , P with respect
to O = T  A iff OP |= QP ( a), where P is seen as a set of universally quantified
implications with first-order semantics. The set of certain answers of q w.r.t.
O = T  A is (equivalently) denoted as either cert(q,T ,A) or cert(q,O). Clearly,
the set of certain answers satisfies the following useful properties:
1. Monotonicity: cert(q,O)  cert(q,O) for each O, O and q with O  O.
2. Invariance under isomorphisms: For each pair of isomorphic ABoxes A
and A (i.e., identical modulo renaming of individuals), cert(q,T ,A) and
cert(q,T , A

) are also identical modulo the same renaming.

UCQ Rewritings. Intuitively, a UCQ rewriting for a TBox T and a CQ q is a
UCQ that extends q with the information from T that is relevant to answering
the query. Formally, a UCQ rewriting for T and q is a UCQ u such that, for
each ABox A where T  A is consistent, the following properties hold:
2. (Completeness:) cert(q,T ,A)  
1. (Soundness:) For each q
qu

  u, we have that cert(q
,,A).

,,A)  cert(q,T ,A).
?

?

?
cert(q

Several well-known techniques can be used to reduce the size of (U)CQs. A CQ
q is reduceable if it contains distinct body atoms that are unifiable. A reduction
 of q is obtained by applying the most general unifier  to the body of q. A
q
condensation reduction cond(u) is a UCQ obtained from u by ensuring that no
 is a reduction of q. Finally,
two queries q, q
a subsumption reduction sub(u) is a UCQ obtained from u by ensuring that no
two queries q, q

 exist such that q
 in the reduction are such that q

 subsumes q and q

 subsumes q.

Justifications. Finally, our framework in [13] relies on the well-established notion of a justification for an entailment (see e.g., [6]). In the case of CQ answering,
a justification for a CQ q and a tuple  a  cert(q,O) in a consistent ontology O is
an ontology J  O such that  a  cert(q, J) and  a  cert(q, J
  J.

) for each J

G. Stoilos, B. Cuenca Grau, and I. Horrocks

3 A Framework for Evaluating Completeness

In this section we present our revised and extended framework for evaluating
the completeness of Semantic Web CQ answering systems.

3.1 CQ Answering Algorithms

Our framework adopts a rather general notion of a CQ answering algorithm. This
allows us to abstract from the specifics of implemented systems and establish
general results that hold for any system satisfying certain basic properties.
Definition 1. A CQ answering algorithm ans for a DL L is a procedure that,
for each L-ontology O = T A and CQ q = QP , P computes in a finite number
of steps a set ans(q,O) of tuples of constants of the same arity as QP .
 It is sound if ans(q,O)  cert(q,O) for each O and q.
 It is complete if cert(q,O)  ans(q,O) for each O and q.
 It is faithful if it satisfies the same monotonicity and invariance under isomorphisms properties as cert.
 It is compact if for each consistent O, each q, and each  a  cert(q,O) 
ans(q,O), there exists a justification J for q,  a in O such that  a  ans(q, J).
Intuitively, ans is faithful if it implements the semantics of CQ answering in a
reasonable way; in particular, the set of computed query answers for a fixed
query can only grow if new axioms are added to the ontology (monotonicity)
and the algorithm should be robust under trivial isomorphic renamings of individuals in the ABox (invariance under isomorphisms). Most of the results in
our framework require ans to be at least sound and faithful, which we believe to
be reasonable requirements that are satisfied by most if not all existing incomplete reasoners. For some of our results, however, compactness is also an issue.
Intuitively, ans is compact if, whenever it correctly computes a certain answer
 a for some query q and ontology O, then it will also compute  a for q and some
minimal subset of O that is sufficient to derive  a.
Consider an (incomplete) algorithm ans that, given O = T A and q, ignores
T and answers q only w.r.t. A. Clearly, ans is sound and faithful. Furthermore,
it is compact since, for each consistent O = T  A and certain answer  a 
ans(q,O), there is a minimal subset A of A (a justification) that is sufficient to
derive  a.1 Suppose, however, that in order to handle atomic implications of the
form A  B, ans is extended as follows: it selects from T the set T  of atomic
implications, extends A to A by adding assertions implied by T  (e.g., adding
B(a) if A(a)  A and A  B  T ), and uses A to answer queries as before.
Assume, however, that ans contains a bug, and only adds B(a) if both A(a) and
C(a) occur in A, for C = A a (fixed) atomic concept. Despite the bug, the
algorithm is still sound and faithful, but it is not compact. To see this, consider
T = {A  B} and q asking for the instances of B. For A = {A(a), C(a)} we have
1 Recall that we are assuming that TBoxes do not contain nominals.
?

?

?
that cert(q,T ,A) = ans(q,T ,A) = {a}. However, the only relevant justification
is J = T  AJ for AJ = {A(a)}; but a / ans(q, J), and thus ans is not compact.
We believe that compactness is also a reasonable property to expect from a
CQ answering algorithm, and that non-compactness is likely to be indicative of
some oddity in the algorithm, as in the above example.

3.2 Testing Bases

Next, we briefly recapitulate from [13] the central notion of a testing base: a
collection of minimal ABoxes (called testing units) which can produce an answer
to q w.r.t. some minimal subset of T . To check completeness, a testing base must
include all relevant testing units.
Definition 2. An ABox A is a testing unit for a CQ q and TBox T if T A is
consistent and there exists a tuple  a  cert(q,T ,A) such that A is the ABox part
of some justification for q,  a in T A. A testing base (TB) for q,T is a finite set
B of testing units for q,T such that for each testing unit A for q and T , there
is some A  B such that A is isomorphic to A. A testing base is minimal if
no two ABoxes in it are isomorphic.
Consider, as a running example, the following TBox T stating that everyone
taking a maths course is a student and every instance of the relation takes
calculus course is also an instance of takes maths course; consider also the
following query q asking for the set of students taking a maths course.

T = {takesMathCo.  St, takesCalcCo  takesMathCo}
q = QP (x)  St(x)  takesMathCo(x, y)

By Definition 2, the following ABoxes are testing units for q,T , and the set
B = {A1, . . . ,A8} is a minimal TB for q,T :

A1 = {takesMathCo(a, b)} A2 = {St(a), takesMathCo(a, b)}
A3 = {takesMathCo(a, a)} A4 = {St(a), takesMathCo(a, a)}
A5 = {takesCalcCo(a, b)} A6 = {St(a), takesCalcCo(a, b)}
A7 = {takesCalcCo(a, a)} A8 = {St(a), takesCalcCo(a, a)}

As shown in [13], TBs provide the following completeness guarantee for any CQ
answering algorithm ans that is sound and faithful: if ans correctly computes
the set of certain answers for each ABox in a TB, then it will also compute the
set of certain answers for any ABox that is consistent with the TBox. In our
example, this means that we only need to check whether ans(q,T ,Ai) = {a}
for each Ai  {A1, . . . ,A8} in order to determine if ans will compute the set of
certain answers of q w.r.t. T and any ABox that is consistent with T .

3.3 Strict Testing Bases
Intuitively, to check whether each Ai in our running example is a testing unit,
one would need to compute all justifications for q and each certain answer a in
?

?

?
T  Ai, and then check whether Ai is the ABox part of one of them. This may
be infeasible in practice, as we may need to consider all possible subsets of T .
In this paper, we address this issue by investigating the notion of a strict
testing unita minimal ABox that can produce an answer to q w.r.t. T .
Definition 3. An ABox A is a strict testing unit for a CQ q and TBox T
if T  A is consistent and there exists a tuple  a  cert(q,T ,A) such that
 a / cert(q,T ,A) for each A  A.
To check whether A is a strict testing unit, we only need to find a certain answer
that is lost when removing any assertion from A. Furthermore, it can be easily
shown that each strict testing unit for q and T is also a testing unit for q and T ,
and in our running example only the testing units A1,A3,A5, and A7 are strict.
The notion of a strict testing unit leads to that of a strict testing base.
Definition 4. A strict testing base Bs for q,T is a finite set of strict testing
units for q,T such that, for each strict testing unit A for q,T , there is some
A  Bs such that A is isomorphic to A. Finally, a strict testing base is minimal
if no two ABoxes in it are isomorphic.

Given any TB B, we can always construct a strict one Bs by removing from B
the testing units that are not strict, and hence Bs is likely to be smaller than B
(in our example, Bs = {A1,A3,A5,A7} is a strict and minimal TB).

We next present our main result in this section: although strict TBs are smaller

than TBs, they provide exactly the same completeness guarantees.
Theorem 1. Let ans be a sound and faithful CQ answering algorithm for L. Let
q be a CQ, T an L-TBox and Bs a strict TB for q, T . The following property ()
holds for any ABox A s.t. T  A is consistent: If ans(q,T ,A) = cert(q,T ,A)
for each A  Bs, then ans(q,T ,A) = cert(q,T ,A).
Proof. By contradiction, let ans(q,T ,A) = cert(q,T ,A) for each A  Bs and
assume there exists A s.t. T A is consistent but ans(q,T ,A) = cert(q,T ,A).
Since ans is sound, ans(q,T ,A) = cert(q,T ,A) iff cert(q,T ,A)  ans(q,T ,A).
Hence, let  a  cert(q,T ,A) be s.t.  a / ans(q,T ,A). Since  a  cert(q,T ,A) and
L does not provide for nominals, there is a minimal (w.r.t. set inclusion), nonempty Amin  A s.t.  a  cert(q,T ,Amin). But then, Amin is a strict testing
 Bs isomorphic
unit by Definition 3. Since Bs is a strict TB, there exists A
to Amin. Finally, since Amin  A and ans is monotonic and invariant under
isomorphisms, we have that  a  ans(q,T ,A), which is a contradiction.
"#
Thus, given our example T and q, to check whether a sound and faithful reasoner
correctly computes cert(q,T ,A) for any ABox A, we only need to check whether
it returns all the certain answers w.r.t. A1, A3, A5 and A7.

min

3.4 Existence and Size of Strict Testing Bases

In [13] we showed that, unfortunately, there exist CQs and ontologies written in
rather simple ontology languages for which a TB does not exist, because infinitely
?

?

?
many testing units would be needed. As already discussed, a strict TB exists
whenever a TB does. The converse, however, may not hold, and hence our nonexistence results from [13] do not transfer directly to strict TBs. The following
example shows a TBox and a CQ for which there is a strict TB containing just
one ABox with a single assertion, but for which no TB exists.

Example 1. Consider the following TBox and query:

T = {A  R.B,R.B  B}; q = QP (x)  A(x)  B(x)

The set Bs = {{A(a)}} is a strict TB. However, for any value of n, the ABox
An = {A(a), R(a, b1), . . . , R(bn1, bn), B(bn)} is a testing unit (it is the ABox
part of a justification J for the certain answer a in T  An, whose TBox part is
TJ = {R.B  B}), and Ai and Aj are non-isomorphic for any i = j. Thus no
TB exists, because from Definition 2 a TB must be a finite set of testing units.

Although a strict TB may exist even if no TB does, it may not be possible in
general to guarantee the existence of one. For instance, if we modify T from
Example 1 to be T = {R.B  B}, no strict TB exists for the same reason that
no TB does. The proof of Theorem 2 is identical to the one in [13] for TBs.
Theorem 2. Let L be EL, or FL0, or a DL allowing for transitivity axioms.
There is a CQ q and a L-TBox T for which no strict testing base exists.
In cases when a TB B does exist (see Section 4), the corresponding strict TB
Bs is likely to be much smaller. A natural question is how small Bs can be in
comparison to B. We next provide an example of an exponential reduction in
size.
Example 2. Consider the following TBox and query:

T = {B  Ai | 1  i  n}  {A1 " . . . " An  C}; q = QP (x)  C(x)

Let Bs and B be as follows, where A = {A1(a), . . . , An(a)}, B = {B(a)}, and
(A) is the power set of A:

Bs = {B,A,{C(a)}}; B = Bs  

{B  A}

A(A)\A

The set Bs with three testing units is a strict and minimal TB for q, T . Also,
given any A  A, we have that B A is a testing unit since it is the ABox of a
justification with T  = {B  Aj | 1  j  n, Aj(a) / A}{A1 " . . ." An  C}.
Therefore, B is a minimal TB containing 2n + 1 testing units.
Although strict TBs can be exponentially smaller than TBs, this is not always
the case. The following example shows that an exponential blowup w.r.t. the size
of the TBox may not be avoidable when computing strict and minimal TBs.
Example 3. For n  1, consider the TBox Tn consisting of the following axioms
for each 0  j < i  n:2
2 A similar TBox was used in [8] for a different purpose.

G. Stoilos, B. Cuenca Grau, and I. Horrocks

X0 " . . . " X n  ;
R.X0  X0;
R.(X i " X0 " . . . " Xi1)  Xi;
R.(X i " X j)  X i;

X0 " . . . " Xn  B;
R.X0  X0;
R.(Xi " X0 " . . . " Xi1)  X i;
R.(Xi " X j)  Xi.

and the query q = QP (x)  B(x). Intuitively, Tn implements the incrementation
of an n-bit counter along an R-chain. For each 1  k < 2n+1, let Zk be of the
form Zk = "
Yi with Yi  {Xi, X i} s.t. the binary number obtained by
replacing each Yi in the chain Y0 . . . Yn with 1 if Yi = Xi and 0 otherwise is
precisely the binary encoding of k. Then, for each 2  j < 2n+1, the following
ABox Aj is a strict testing unit (and is not isomorphic to any Aj with j
 = j):

0in

Aj = {R(a0, a1), . . . , R(aj1, aj), Zj(aj)}

Existence of a strict TB is ensured by the axiom X0 " . . . " X n  , which
precludes the computation of an infinite number of (non-isomorphic) strict testing units by appending relevant R-chains an arbitrary number of times (recall
that a strict testing unit must be consistent with Tn). It can easily be verified
that a strict and minimal TB must contain exponentially many testing units
w.r.t. n.

3.5 Measuring the Degree of Completeness

In this section, we turn our attention to measuring quantitatively how com-
plete a sound and faithful reasoner is for a fixed query q and TBox T , when
completeness guarantees are not provided. To this end, we next introduce the
notion of completeness degree, which in its most general form can be defined as
follows.3
Definition 5. Let ans be a sound and faithful CQ answering algorithm for L a
DL, q a CQ, T an L-TBox and A a non-empty set of ABoxes such that, for
each A  A, T A is consistent and cert(q,T ,A) = . The completeness degree
 of ans for q, T and A is defined as follows (where "S denotes the number of
elements in a set S):

A(ans, q,T ) =



"A

"ans(q,T ,A)
"cert(q,T ,A)
?

?

?
AA

Therefore, A represents the proportion of certain answers w.r.t. ABoxes in A
that ans is able to compute correctly. The specific properties of A, however,
will obviously depend on the particular set of ABoxes under consideration. In-
tuitively, in order to obtain a reasonable measure of completeness for T and q,
the set A should be chosen such that the following basic properties are satisfied:
1. If ans misses a certain answer for some (arbitrary) ABox consistent with the

TBox, then A(ans, q,T ) should be smaller than one.

3 The notion given here slightly differs from the one in our previous work.
?

?

?
consistent with the TBox, then A(ans, q,T ) should be larger than zero.

2. If ans correctly computes some certain answer for some (arbitrary) ABox
, then
3. If each certain answer computed by ans is also computed by ans
4. If Property 3 holds and, in addition, there is an (arbitrary) ABox A con-
 computes a certain answer that ans fails to

, q,T ) should be at least as large as A(ans, q,T ).

A(ans
sistent with T for which ans
compute, then A(ans

, q,T ) should be strictly larger than A(ans, q,T ).
?

?

?
Consider our running example CQ q, TBox T , TB B = {A1, . . . ,A8} and strict
TB Bs = {A1,A3,A5,A7}. An algorithm a1 that ignores T and simply answers
q w.r.t. the data would only compute the correct answers for A2 and A4; hence,
B(a1, q,T ) = 0.25, whereas Bs(a1, q,T ) = 0. An algorithm a2 that handles
role inclusions but not existential quantification would only compute the correct answers for A2, A4, A6 and A8; thus, B(a2, q,T ) = 0.5, but we again
have Bs(a2, q,T ) = 0. Finally, a complete algorithm would compute the correct
answers for all ABoxes; hence, B(a3, q,T ) = Bs(a3, q,T ) = 1, as desired.

Our example suggests that by choosing a (possibly strict) TB, we can guarantee Properties 1 and 3. Indeed, this can be shown in general as a direct consequence of Theorem 1.

 sound and faith-

Proposition 1. The following properties hold for ans and ans
ful, q a CQ, T a TBox and Bs a strict TB for q,T :
1. If cert(q,T ,A) = ans(q,T ,A) for some A s.t. T  A is consistent, then
Bs(ans, q,T ) < 1.
2. If ans(q,T ,A)  ans
, q,T ).
Our running example also illustrates an important advantage of using TBs over
strict TBs for measuring completeness degrees, namely that Properties 2 and 4
fail if  is measured in terms of Bs, but hold if  is measured w.r.t. B. We finally
show that Properties 2 and 4 always hold for TBs provided that the relevant CQ
answering algorithm is also compact.

(q,T ,A) for each A, Bs(ans, q,T )  Bs(ans
?

?

?
 sound, faithful

(q,T ,A) s.t.  a / ans(q,T ,A), then B(ans, q,T ) < B(ans

Proposition 2. The following properties hold for ans and ans
and compact, q a CQ, T a TBox and B a TB for q,T .
1. If  a  ans(q,T ,A) for some tuple  a and some ABox A s.t. T A is consistent,
then B(ans, q,T ) > 0.
2. If ans(q,T ,A)  ans
(q,T ,A) for each ABox A, and there exists A and
, q,T ).
 a  ans
Proof. 1. Suppose that such tuple  a and ABox A exist. Since ans is sound,  a 
cert(q,T ,A). Since ans is also compact, there is a justification J = TJ  AJ
for q,  a in T  A such that  a  ans(q,TJ ,AJ ). But then, AJ is a testing
unit by Definition 2. Since B is a testing base, there exists an ABox A  B
that is isomorphic to AJ with  a
 the tuple obtained after the corresponding renaming of  a. Finally, since ans is invariant under isomorphisms and
) and hence B(ans, q,T ) > 0.
monotonic, we clearly have  a

  ans(q,T , A
?

?

?
2. By Proposition 1, B(ans, q,T )  B(ans
?

?

?
, q,T ). The property then follows
from the following statement, which we show next: there exist Amin  B and
 b  ans
(q,T ,Amin) such that  b / ans(q,T ,Amin). Since ans
 is compact,
there is a justification J = TJ AJ for q,  a in T A s.t.  a  ans
(q,TJ ,AJ).
By definition of a TB, there exists Amin  B isomorphic to AJ with  b
the result of renaming  a accordingly. By monotonicity and invariance under
(q,T ,Amin). But then,  b / ans(q,T ,Amin)
isomorphisms of ans
since otherwise by monotonicity and invariance under isomorphisms of ans
"#
we have  a  ans(q,T ,A), which is a contradiction.

,  b  ans

4 Computing Strict Testing Bases

In our previous work [13], we identified sufficient conditions for a TB to exist.
We showed that it is always possible to construct a TB for T , q whenever there
exists a UCQ rewriting for q and each subset T  of T . The connection between
the existence of UCQ rewritings and of TBs is relevant for practice: on the
one hand, UCQ rewritings are guaranteed to exist if T is expressed in the DLs
underpinning the QL profile of OWL 2, and they may also exist even if T is in
other fragments of OWL 2 (such as the EL profile); on the other hand, there are
currently a number of implemented algorithms for computing UCQ rewritings
(e.g., those implemented in the systems QuOnto and REQUIEM).
Roughly speaking, the algorithm for computing a TB for T and q proceeds as
follows: first, for each subset T  of T it computes a UCQ rewriting uT ; second,
for each such uT  it constructs a fixed set of individuals whose cardinality is
bounded by var(uT ); finally, it computes the required testing units by instantiating each uT  with a valid instantiationa (maximal) subset of the mappings
from the variables of each CQ in uT  to individuals satisfying certain properties.
This naive algorithm is not practical since it may need to examine an exponential number of subsets of T . This is required to ensure, on the one hand, that
a TB exists and, on the other hand, that all relevant testing units are computed
via a valid instantiation. For example, the CQ QP (x)  A(x) is a UCQ rewriting for the query q and TBox T from Example 1, but no TB exists for q,T . The
algorithm from [13] rejects the input q,T because it additionally considers the
subset T  = {R.B  B} of T and finds that no UCQ rewriting exists for q,T .
We next show that a strict TB can be computed solely from a UCQ rewriting u
for T and q, and hence computing a UCQ rewriting for each of the (exponentially
many) subsets of T is no longer required. Indeed, we can compute the strict TB
Bs = {A(a)} for q and T from Example 1 by just computing and instantiating
the UCQ rewriting QP (x)  A(x).

We start by recapitulating the notions from [13] of an instantiation of a CQ

and a valid instantiation for a UCQ.

Definition 6. Let q be a CQ, Bq the body atoms in q, and  a mapping from
all variables of q to individuals. The following ABox is an instantiation of q:

 := {A((x)) | A(x)  Bq}  {R((x), (y)) | R(x, y)  Bq}
Aq
?

?

?
Let u = {q1, . . . , qn} be a UCQ and assume w.l.o.g. that var(qi)  var(qj) =  for
i = j. Let ind = {a1, . . . , am} be a set of individuals s.t. m = "var(u) and let qi
be the set of all mappings from var(qi) to ind. A set u =  u
qn with
. . .qn
q1
 u
qi
with the following property:

 qi is a valid instantiation of u if it is a maximal subset of q1

 . . .   u

(): for each qi, qj  u and    u
map the distinguished variables in qi and qj identically and Aqj

  qj s.t.  and 
  Aqi
 .

qi, there is no 
?

?

?
Intuitively, when instantiating a CQ q in a rewriting u using a valid instantiation,
Property () from Definition 6 ensures that there is no smaller instantiation
 from u. In our running example about students
of a (possibly different) CQ q
and math courses we have that u = {q, q1, q2, q3}, with q1, q2 and q3 given as
follows, is a UCQ rewriting of q and T :

q1 = QP (x1)  St(x1)  takesCalcCo(x1, y1)
q2 = QP (x2)  takesMathCo(x2, y2)
q3 = QP (x3)  takesCalcCo(x3, y3)

For ind = {ai, bi | 0  i  3}, we have that  = {xi ! ai, yi ! bi | 2  i  3}
 = {x1 ! a1, y1 ! b1} is not valid since
is a valid instantiation; in contrast, 
the mapping  = {x3 ! a1, y3 ! b1} leads to a smaller ABox.

qi such that T  Aqi

 is a strict testing unit, it suffices to show that  a  cert(q,T ,Aqi

Our previous example clearly shows that non-valid instantiations can lead to
ABoxes that are not strict testing units. Furthermore, each ABox obtained by
instantiating a CQ in a UCQ rewriting using a valid instantiation is indeed a
strict testing unit, as shown by the following lemma.
Lemma 1. Let u be a UCQ rewriting for T and q, and let u be a valid instan-
tiation. Then, for each qi  u and each    u
 is consistent,
we have that Aqi
 is a strict testing unit for T , q.
Proof. Let  map the distinguished variables of qi to  a. Then,  a  cert(qi,,Aqi
 ).
Since qi  u, soundness of UCQ rewritings implies  a  cert(q,T ,Aqi
 ). To show
that Aqi
\ )
for each   Aqi
 . By the contrapositive of the completeness property of UCQ
rewritings it suffices to show that qj  u,  a  cert(qj ,,Aqi
\ ). But, this is
ensured by Property () of Definition 6, as we show next.
\ ).4 Then,
by the semantics of CQ answering there is a mapping  from the variables in
\  that maps the distinguished variables of qj to  a
qj to the individuals in Aqi
and such that Aqj
  Aqi
\ . Hence, Aqj
 ; however, this contradicts the
assumption that    u
"#
To compute strict TBs, we need to consider in the worst case all the possible
ABoxes that can be obtained by instantiating a given UCQ rewriting using a
given valid instantiation, as shown by the following theorem.

By contradiction. For some qj  u assume that  a  cert(qj,,Aqi

qi, since Property () in Definition 6 would fail.

  Aqi











4 Note that qj could be qi.

G. Stoilos, B. Cuenca Grau, and I. Horrocks

Algorithm 1. Compute a strict testing base
Algorithm: tb(u)
Input: a UCQ rewriting u for T , q
1 Compute u
2 Construct ind := {a1, . . . , an} for n = var(u
)
3 Initialize Out := 
4 For each qi  u
?

?

?
 := sub(cond(u))

If T  Aqi

For each  : var(qi)  ind
 }
Out := Out  {Aqi
For each qj  u
?

?

?
 is consistent then

If Sig(qj)  Sig(qi) and there exists 
distinguished vars. in qi and qj identically and Aqj
 }
Out := Out \ {Aqi

 : var(qj)  ind s.t. , 

  Aqi

 then

 map

3 Return Out

Theorem 3. Let u be a UCQ rewriting for T , q and let u be a valid instanti-
ation. The following set is a strict testig base for T and q.

Bs = {Aqj



| qj  u,    u

qj ,T  Aqj

 consistent}

qj s.t. Aqj

Proof. By Lemma 1, Bs only contains strict testing units. We show that for
each strict testing unit A, there exists qj  u and a mapping    u
 is
isomorphic to A and thus Bs is a strict TB. A being a strict testing unit implies
that T  A is consistent and there exists  a  cert(q,T ,A) s.t.  a / cert(q,T ,A)
for each A  A. Since  a  cert(q,T ,A) and T A is consistent, the completeness
property of rewritings implies that qj  u exists s.t.  a  cert(qj,, A). Hence,
there exists  from var(qj) to individuals in A that maps the distinguished
variables in qj to  a. Since A is minimal, there is no other 
 that maps qj or any
other qi  u to a strict subset of A and s.t. it maps their distinguished variables
to  a. Thus, by maximality, there exists    u
 is isomorphic to A. "#
According to Theorem 3, an algorithm for computing a strict TB for T , q must
use a valid instantiation to compute all testing units. A naive implementation
would check Property () from Definition 6 by performing a number of ABox
containment tests that is exponential in the number of query variables.
We next present a practical algorithm for computing a strict TB. Algorithm 1
takes a UCQ rewriting u for T and q (computed using any state of the art
rewriting algorithm), and implements several optimisations aimed at reducing
the number of ABox containment tests needed to check Property ().

qj s.t. Aqj

First, as in our practical algorithm from [13], Algorithm 1 uses condensation and subsumption to reduce the size of the input rewriting. This can avoid
(possibly exponentially) many tests when checking Property (). For instance,
subsumption would eliminate the queries q and q1 from the rewriting for our
running example, thus discarding each of their instantiations.
?

?

?
Finally, Algorithm 1 only checks the containment of an instantiation of the
 whenever all the body predicates in

form Aqj
qj occur also in qi. For instance, consider the following TBox and CQ:

 in an instantation of the form Aqi

T = {C  R.} q = QP (x)  R(x, y)  R(y, z)

 since q1 mentions the predicate C, which is not mentioned in q.

Given u = {q, q1} with q1 = QP (x)  R(x, y)  C(y), neither cond nor sub
removes any query. Algorithm 1, however, will not perform any test of the form
  Aq
Aq1
As shown by the following theorem, none of these optimisations results in a
loss of relevant strict testing units, and the output of Algorithm 1 is a strict TB.
Theorem 4. Algorithm 1 computes a strict TB for q and T .
Proof. The application of cond and sub on a UCQ rewriting preseves the sound-
 = sub(cond(u)) is also a UCQ rewriting.
ness and completeness properties, and u
We show that each Aqi
 Out is a strict testing unit. To this end, we show that
 w.r.t. ind. This is so un-

qi with u a valid instantiation of u
 belongs to  u
less the following condition holds: there exists qj  u
 with Sig(qj)  Sig(qi)
 map the distinguished variables in qi and
and 
qj identically and Aqj
 . This condition, however, cannot hold: qj has an
atom X not occurring in qi and hence for each 
 has an assertion
involving X which cannot occur in Aqi
 . To show that Out is a strict TB, let u
 w.r.t. ind. By Theorem 3 we show that for arbitrary
be a valid instantiation of u
qi  u
 Out. This is the case because Algorithm
1 considers all possible queries qi, qj and all possible mappings from variables
in those queries to individuals in ind, and it only excludes from Out ABoxes
corresponding to instantiations violating Property () from Definition 6.
"#

 : var(qj) ! ind s.t.  and 

 the ABox Aqj

  Aqi



 and    u
?

?

?
qi , we have Aqi



We conclude by briefly comparing Algorithm 1 with the TB approximation algorithm from our previous work. In [13], we showed that the approximation
algorithm produces only testing units, but not necessarily all those needed to
obtain a TB. In fact, the approximation algorithm produces only strict testing
units, but not necessarily all those needed to obtain a strict TB, and hence it
cannot be used to provide completeness guarantees for sound and faithful CQ
answering algorithms. Algorithm 1, in contrast, produces strict TBs, and so can
be used to provide such guarantees. Furthermore, as we show in the next section,
the computation of strict TBs is computationally feasible in practice.

5 Implementation and Evaluation

We have implemented Algorithm 1 in our prototype tool SyGENiA,5 which uses
REQUIEM6 for the computation of the UCQ rewritings, and used it to evaluate

http://code.google.com/p/sygenia/
http://www.comlab.ox.ac.uk/projects/requiem/home.html

G. Stoilos, B. Cuenca Grau, and I. Horrocks

Table 1. Generation times of strict TBs for each LUBM query (in sec.)

Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
1.3 1.1 0.09 6.3 0.25 2.1 0.6 7 2.7 6 0.06 0.1 0.1 0.05

Table 2. LUBM queries for which completeness can be guaranteed

System
Jena Max
OWLim
Minerva

Completeness Guarantee Completeness w.r.t. LUBM dataset

Q1-Q14

Q1-Q5, Q7, Q9, Q11-Q14

Q1-Q4, Q9, Q11, Q14

Q1-Q14
Q1-Q14
Q1-Q14

Jena Mini/Micro Q1-Q3, Q5, Q11, Q13-Q14

Sesame

Q1, Q3, Q11, Q14

Q1-Q5, Q11, Q13-Q14

Q1-Q5, Q11, Q14

four systems: Sesame 2.3-prl,7 OWLim 2.9.1,8 Minerva v1.5,9 and Jena v2.6.310
in each of its three variants (Micro, Mini and Max).

We first ran SyGENiA over the LUBM TBox and queries and computed a
strict TB for each queryeach LUBM query leads to a UCQ rewriting w.r.t.
the TBox, and hence a strict TB is guaranteed to exist.11 Table 1 presents the
generation time for each of these strict TBs. We then used these strict TBs to
compute the corresponding completeness degrees for each evaluated system.

In contrast to our previous work, Algorithm 1 ensures that each computed
collection of datasets is a strict TB, and hence we can provide completeness
guarantees in practice. This is illustrated in Table 2 where, for each system, we
list the queries for which testing using strict TBs shows that it is complete for
any dataset, and the queries for which it is complete w.r.t. the LUBM dataset.
Our results show that Jena Max is the only system that is guaranteed to be
complete for all 14 LUBM queries regardless of the datasetthat is, it behaves
exactly like a complete OWL reasoner w.r.t. the LUBM queries and TBox. Fur-
thermore, as already noted in our previous work, completeness w.r.t. the LUBM
benchmark is no guarantee of completeness in general; for example, OWLim and
Minerva are both complete w.r.t. LUBM (and even w.r.t. to the more expressive
UOBM benchmark), but for some queries they were found to be incomplete w.r.t.
to our datasets. OWLim is, however, guaranteed to be complete for all LUBM
queries that do not involve reasoning with existential quantifiersa feature not
supported by the system. Minerva, which uses a DL reasoner to classify the ontology and explicate subsumption between atomic concepts, is still guaranteed
to be complete for only 8 queries; this is because our datasets reveal missing
answers that depend on subsumptions between complex concepts that are not

http://www.openrdf.org/
http://www.ontotext.com/owlim/
http://www.alphaworks.ibm.com/tech/semanticstk
http://jena.sourceforge.net/

11 Since REQUIEM does not currently support individuals in the queries or transitivity
in the TBox, we have replaced the individuals in queries by distinguished variables
and dispensed with the only transitivity axiom in the LUBM TBox.
?

?

?
Table 3. Completeness degrees for Jena Mini/Micro

Datasets Q4 Q6 Q7 Q8 Q9 Q10 Q12
LUBM 1 .83 .87 .83 .64 .83

SyGENiA .68 .003 .04 .058 0 .001 .25

Table 4. Completeness analysis on Galen

Sesame OWLim Jena Mini Minerva

Q1 0
.07
Q2
.01
Q3
Q4
.01

.84
.83
.84
.77

0
.07
0
.01

.97
.96
.96

pre-computed by the system. Jena Mini and Micro are guaranteed to be complete
for 7 queries. Surprisingly, Jena Mini behaved exactly like Jena Micro, despite
the fact that, in theory, Jena Mini can handle a larger fragment of OWL; these
differences are, however, not revealed by the structure of the LUBM TBox and
queries. Finally, Sesame is only guaranteed to be complete for 4 of the queries.
Concerning completeness degrees, the values we have obtained using strict
TBs are in line with those from our previous work. However, as discussed in
Section 3.5, a completeness degree value smaller than one should be interpreted
with caution when using strict TBs, especially in the case of very small values.
For instance, consider the values obtained for Jena Mini/Micro given in Table
3. When using strict TBs, the completeness degree for query Q9 is 0%, but the
system is clearly able to correctly compute certain answers for some ABoxes (e.g.,
the LUBM dataset). As already discussed, this is because completeness degree
measures based on strict TBs fail to satisfy properties 2 and 4 of Proposition 2.
Finally, we have considerd a small version of Galen (an expressive ontology
with complex structure used in medical applications) and four queries asking respectively for the instances of the concepts HaemoglobinConcentrationProcedure,
PlateletCountProcedure, LymphocyteCountProcedure, and HollowStructure. Each
of these queries has a UCQ rewriting that can be computed using REQUIEM.
Thus, a strict TB exists for each of them and can be computed in times ranging
from 2 seconds to 1 minute. Our results are summarised in Table 4.

We could not run Jena Max since Galen makes heavy use of existential re-
strictions, which (according to the Jena documentation) might cause problems.
Among the other systems, Minerva exhibited the best behavior: it was the only
one for which completeness could be guaranteed for at least one query, and it
exhibited a high completeness degree for the remaining three queries; this is
because Minerva pre-computes many subsumption relationships between atomic
concepts that depend on existential restrictions, which most other systems do
not handle. Jena Mini and Sesame were surprisingly incomplete, although as
already discussed, values close to zero should be interpreted with caution.

G. Stoilos, B. Cuenca Grau, and I. Horrocks

6 Conclusion and Future Work

In this paper we have extended in several important ways our prior work on
completeness evaluation of Semantic Web reasoners. Most importantly, we have
introduced the notion of a strict testing base, studied its formal properties,
and shown that it can be used to identify circumstances in which completeness
guarantees can be provided for reasoners that are incomplete in general. Finally,
we have proposed a practical algorithm for the generation of strict testing bases,
implemented it in the SyGENiA tool, and used SyGENiA to evaluate several
incomplete reasoners, using both the LUBM benchmark, and the Galen ontology.
Our results suggest not only that strict testing bases are relatively easy to compute in practice, but also that completeness guarantees can often be provided for
realistic ontologies and queries. The main limitation of strict testing bases is that
the associated completeness degree fails to satisfy certain desirable properties. An
interesting problem for future work is to try to design a practical algorithm that
can be used to provide an accurate measure of completeness degree.

Acknowledgments. Supported by the EU project SEALS (FP7-ICT-238975).
B. Cuenca Grau is supported by a Royal Society University Research Fellowship.
