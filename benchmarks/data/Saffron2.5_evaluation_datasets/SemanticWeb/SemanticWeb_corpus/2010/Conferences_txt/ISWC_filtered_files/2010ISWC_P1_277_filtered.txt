Integrated Metamodeling and Diagnosis in OWL 2

Birte Glimm1, Sebastian Rudolph2, and Johanna Volker3

1 Oxford University Computation Laboratory, UK

birte.glimm@comlab.ox.ac.uk

2 Institute AIFB, Karlsruhe Institute of Technology, DE

rudolph@kit.edu

3 KR & KM Research Group, University of Mannheim, DE

voelker@informatik.uni-mannheim.de

Abstract. Ontological metamodeling has a variety of applications yet only very
restricted forms are supported by OWL 2 directly. We propose a novel encoding scheme enabling class-based metamodeling inside the domain ontology with
full reasoning support through standard OWL 2 reasoning systems. We demonstrate the usefulness of our method by applying it to the OntoClean methodology.
En passant, we address performance problems arising from the inconsistency diagnosis strategy originally proposed for OntoClean by introducing an alternative
technique where sources of conflicts are indicated by means of marker predicates.

1 Introduction

Applications of metamodeling in Ontology Engineering are manifold, including the
representation of provenance or versioning information as well as the documentation of
modeling decisions. Roughly speaking, metamodeling allows for referring to predicates
(classes and properties in OWL) as if they were domain individuals. This way it is
possible to assert the membership of classes in metaclasses and interconnect them via
metaroles.

Consider, for example, the following extract of a knowledge base about animals and

the respective species they belong to.

(GoldenEagle  HaastsEagle)(harry) HouseMouse( jerry)

Intuitively, we specify that the individual harry is a golden or a Haasts eagle and jerry
is a common house mouse. Now, assume the knowledge base also expresses taxonomic
relationships assigning species to orders of animals.1

GoldenEagle  Falconiformes HouseMouse  Rodentia
HaastsEagle  Falconiformes

If, additionally, we were to specify which of the zoological terms actually denote
species and which denote orders, we could introduce the classes Species and Order.

1 Species is the most specific level within the biological classification and order is a more general
one, e.g., Golden Eagle (A. chrysaetos) is a species, whereas Falconiformes is the order of
Golden Eagle. In Europe the Falconiformes order is commonly split into Falconiformes and
Accipitriformes, but we neglect that here.

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 257272, 2010.
c Springer-Verlag Berlin Heidelberg 2010

B. Glimm, S. Rudolph, and J. Volker

Treating those classes on a level with Rodentia etc. by subclass statements like
Rodentia  Order leads to consequences that are doubtful (like Order( jerry)) or outright unwanted (like HouseMouse  Order). Therefore, species and order should be
treated as metaclasses the members of which are themselves classes, i.e., we would like
to make statements such as

Species(GoldenEagle)
Species(HaastsEagle)
Species(HouseMouse)

Order(Falconiformes)
Order(Rodentia)

Likewise we may think of metaroles that interrelate classes instead of individuals. In
particular, the subclass relationship between classes can be seen as such a metarole (one
with a built-in meaning instead of one that can be freely defined). In fact, many evaluation or design criteria for ontologies [12,4] directly refer to the hierarchy of classes in
an ontology. Considering our example, one obvious design criterion would be that for A
a species and B an order, B  A must not hold as this would contradict the conventional
organization of zoological taxonomies.

Current ontology languages differ with respect to their support for metamodeling.
While it is supported by OWL Full, this high expressivity leads to undecidability as
shown by Motik [9], who also discusses milder variants of metamodeling. One variant,
which is also supported by OWL 2 DL, is called punning. Punning allows for using
the same identifier, e.g., for an individual and a class. The class and its corresponding individual are, however, treated as entirely independent, which disallows many of
the intended usage scenarios of metamodeling. As another lightweight metamodeling
feature, OWL 2 allows for annotation properties, which may associate information to
classes, roles, and even axioms. In OWL 2 DL and all its subprofiles, these properties
do not carry any semantics and are not used for reasoning.

One way to facilitate more expressive metamodeling while still supporting the use
of off-the-shelf reasoning tools for OWL is to maintain two (or more) ontologies, keeping the basic domain knowledge separate from the meta knowledge. In that case, the
two ontologies must be kept in sync by additional external mechanisms. Thereby, information obtained from reasoning in the basic ontology (like its subclass hierarchy)
is fed into the metaontology as explicit statements. Based on this, reasoning in the enriched metaontology can be carried out. Clearly, this approach comes with increased
maintenance efforts. Examples for this strategy are [10] and [14].

We extend this state of the art in two ways, which are independent from each other,

but can be combined:

1. We introduce a technique that enables class-based metamodeling within one ontol-
ogy. Thereby, subclass relationships between classes are axiomatically synchronized
with role memberships of class-representing individuals. Meta-level constraints on
classes and their subsumption relationships can then be expressed as OWL axioms
in the same ontology as the actual content.

2. We propose a way of expressing meta-level constraints in a way that does not lead
to inconsistency, but rather indicates constraint violations by auxiliary classes or
roles. Thus, the origins of these violations can be localized by comparably cheap
instance retrieval operations instead of costly debugging strategies.
?

?

?
We proceed as follows: The next section introduces the necessary preliminaries of the
description logic SROIQ underlying the OWL 2 standard. We use the DL notation for
its brevity. Section 3 introduces our technique enabling ontology-inherent metamod-
eling. Section 4 sketches the OntoClean methodology as one possible metamodeling
use case. Section 5 describes the original OWL-based OntoClean constraint checking
approach as well as our metamodeling-based modification of it. Section 6 introduces another modification of the methodology by suggesting to use marker predicates instead
of explanations. Finally, Section 7 provides an evaluation of the proposed techniques
before we conclude in Section 8. A more detailed treatise can be found in the extended
version of the paper [3].

2 Preliminaries
We just recall the basic definitions for the description logic SROIQ [6]. For further
details on DLs we refer interested readers to the Description Logic Handbook [1].
As our definitions are based on DLs, we use the terms ontology and knowledge base
interchangeably.2

Definition 1. Let NR, NC, and NI be three disjoint sets of role names containing the
universal role U  NR, class names, and individual names, respectively. A SROIQ
 | R  NR}, where we
RBox for NR is based on a set R of roles defined as R  NR  {R
set Inv(R)  R
)  R to simplify notation. In the sequel, we will use the
symbols R, S , possibly with subscripts, to denote roles.
A generalised role inclusion axiom (RIA) is a statement of the form S 1 . . . S n  R,
and a set of such RIAs is a generalised role hierarchy. A role will be called non-simple
for some role hierarchy if it can be implied by some role chain, otherwise it is simple.
are
simple. A SROIQ RBox is the union of a set of role disjointness assertions together
with a role hierarchy. A SROIQ RBox is regular if its role hierarchy is regular.

A role disjointness assertion is a statement of the form Dis(S , S

), where S and S
?

?

?


and Inv(R


?

?

?
For brevity, we omit a precise definition of simple roles and role hierarchy regularity,
and refer interested readers to [6]. Note that number restrictions (defined below) can
only be formed with simple roles to guarantee the decidability of the standard reasoning
tasks such as checking knowledge base consistency.
Definition 2. Given a SROIQ RBox R, the set of class expressions C is defined as
follows:
 NC  C,   C,   C,
 if C, D  C, R  R, S  R a simple role, a  NI, and n a non-negative integer, then
C, C  D, C  D, {a}, R.C, R.C, S .Self, n S .C, and n S .C are also class
expressions.

2 Moreover, we use the term classes instead of concepts for unary predicates, whereas we refer
to binary predicates as roles instead of properties in order to avoid confusion with the term
metaproperties introduced by OntoClean.

B. Glimm, S. Rudolph, and J. Volker

Table 1. Semantics of class expressions in SROIQ for an interpretation I = (I,I

)

I}



Syntax Semantics
{x, y  I  I | y, x  R

I  I
?

?

?
I


I \ C
C

C  D C
I  D

I  D
C  D C

{a}
{a
I}

Name
inverse role
universal role
top
bottom
negation
conjunction
disjunction
nominals
univ. restriction R.C {x  I | x, y  R
exist. restriction R.C {x  I | for some y  I
S .Self {x  I | x, x  S
Self construct
qualified number n S .C {x  I | #{y  I | x, y  S
n S .C {x  I | #{y  I | x, y  S
restriction

implies y  C
I}
, x, y  R
I}

and y  C
I}
I}  n}
I}  n}
?

?

?
and y  C
and y  C

The function I

, class names to subsets of I

In the remainder, we use C and D to denote class expressions. A SROIQ TBox is a
set of general class inclusion axioms (GCIs) of the form C  D. We use C  D to
abbreviate C  D and D  C. An individual assertion can have the form C(a) or R(a, b)
with a, b  NI individual names. A SROIQ ABox is a set of individual assertions.
A SROIQ ontology O is the union of a regular RBox R, an ABox A and TBox T for
R. The vocabulary of an ontology, denoted voc(O), is a triple (OC, OR, OI) with OC the
set of class names occurring in O, OR the set of role names occurring in O, and OI the
set of individual names occurring in O.
The semantics of SROIQ ontologies is given by means of interpretations.
Definition 3. An interpretation I consists of a set I
it being called individuals) together with a function I
elements of I
Table 1. An interpretation I satisfies an axiom  if we find that I |= :
 I |= S  R if S
 I |= S 1  . . .  S n  R if S
 R
standard composition of binary relations here),
 I |= Dis(R, S ) if R

 I |= C  D if C
An interpretation I satisfies C(a) if a
. An interpretation I satisfies an ontology O (we then also say that I is a model of O and write I |= O)
if it satisfies all axioms of O. An ontology O is satisfiable if it has a model. An ontology
O entails an axiom , if every model of O is a model of .
Further details on SROIQ can be found in [6]. We have omitted here several syntactic
constructs that can be expressed indirectly, especially RBox assertions for transitivity,
reflexivity of simple roles, and symmetry.

, and role names to subsets of I  I

is inductively extended to role and class expressions as shown in

called domain (the elements of
mapping individual names to

( being overloaded to denote the

and R(a, b) if (a

I  D

I, b

)  R

 . . .  S

I  R

,

I  C

are disjoint,

and S

.

n
?

?

?
.
?

?

?
In the remainder, we use the following notational convention: individual names are
written in italic, e.g., jerry. Class names are written in sans serif font, e.g., HouseMouse
and role names are written in normal serif font, e.g., eats, unless they are used to
denote metaclasses or metaroles for which we use typewriter font, e.g., Species or
subClassOf.

3 Ontology-Inherent Metamodeling for Classes
We will now show how to define a metamodeling-enabled version Ometa for a given
ontology O. The converted ontology Ometa will be such that each model of the converted
ontology has two different kinds of individuals: the class individuals are individuals
that represent classes and each such individual is an instance of the newly introduced
metaclass Class. On the other hand, the model also contains proper individuals and all
these are instances of the newly introduced class Inst. Subclass relationships between
a class C and a class D in the given ontology O are materialized as role instances:
the individual that represents the class C, say oC, and the individual that represents D,
say oD, are interconnected by the newly introduced metarole subClassOf. Similarly,
a class membership of an individual a in a class C in the given ontology becomes
manifest in a type relationship between a and oC, for type also a freshly introduced
role in Ometa. We further introduce an auxiliary role RInst, which is used to localize the
universal role. These correspondences can then be used to check for modeling errors
and to examine quality properties of the ontology.
Definition 4. Let O be a domain ontology with vocabulary voc(OC, OR, OI). The vocabulary of the metamodeling-enabled version Ometa of O is:

:= OC  {Inst, Class}
:= OR  {type, subClassOf, RInst}
:= OI  {oC | C  OC}

Ometa
Ometa
Ometa

where all the newly introduced names are fresh, i.e., they are not part of voc(O).
We define the functions bound(), SepDom(), Typing(), and MatSubClass(), which
take an ontology, i.e., a set of axioms, and return a set of axioms. The function bound()
returns its input after rewriting it as follows: first, every occurrence of X having one of
the forms , C, R.C, n R.C, U.Self is substituted by Inst X, where we explicitly
allow for complex classes C. Next, the universal role is localized by substituting every
U.C by U.(Inst  C) and every U occurring on the left hand side of a role chain
axiom by RInst  U  RInst where RInst is axiomatized via RInst.Self  Inst.3 We
extend bound() in the obvious way to also rewrite an axiom or a class expression. The
functions SepDom, Typing, and MatSubClass return a set of axioms as specified in
Table 2. The metamodeling-enabled version Ometa of O is

bound(O)  SepDom(O)  Typing(O)  MatSubClass(O)

3 It is not hard to check that none of these transformations harms the global syntactic constraints.

B. Glimm, S. Rudolph, and J. Volker

SepDom(O): Inst  Class

Table 2. Returned axioms for an ontology O by SepDom, Typing, and MatSubClass
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)

Class(oC)
Inst(i)
R.  Inst
  R.Inst
type.  Inst
  type.Class
subClassOf.  Class
  subClassOf.Class

for all C  OC
for all i  OI
for all R  OR
for all R  OR

Typing(O): C  type.{oC}
MatSubClass(O): Class  type

for all C  OC
.type.{oC}  Class  subClassOf.{oC}
for all C  OC

(10)

(11)

Roughly speaking, given an ontologyO, the function bound(O) ensures that the complete domain of O is squeezed into the class Inst and also class construction is forced
to only involve individuals from Inst. The axioms constructed by SepDom(O) have
the following purpose: Axiom (1) makes sure that the newly established metalayer does
not interfere with the instance layer. Axiom (2) ensures that all class-representative individuals lie in the metalayer. Axiom (3) forces every named individual of the original
ontology to be in the instance layer. Axioms (4) and (5) state that every role of the original ontology is forced to start and end only in the instance layer. Axioms (6) and (7)
stipulate that the type-role starts in the instance layer and ends in the metalayer. Finally,
Axiom (8) and (9) specify that the subClassOf(O) role is allowed to interconnect only
individuals from the metalayer. The axioms from Typing(O) ensure that class members
of C are exactly those domain individuals which are connected to Cs representative
oC via the type role, while axioms from MatSubClass(O) finally synchronize actual
subclass relationships in the instance layer with the subClassOf links between the
corresponding representatives in the metalayer.
Note that the size of Ometa is linearly bounded by the size of O. Intuitively, the conversion from O to Ometa realizes a model conversion: given a model of O, the transformation endows the model with a metalayer containing reified atomic classes oC. As in
RDF, class membership of the original individuals is now indicated by the newly introduced type role and class subsumption by the subClassOf role which is axiomatically
synchronized with the actually valid subclass relation in the considered model. Thereby,
we materialize the hierarchy among classes of a particular model in the metalayer.
Figure 1 depicts the established correspondences in a schematic way.

Note that no original model is ruled out by this process which also ensures that the
conversion does not cause new (unwanted) consequences. In the sequel, we characterize
the above mentioned properties of Ometa more formally:
Theorem 1. Let O be an OWL ontology and Ometa its metamodeling-enabled version
as specified in Definition 4. Then the following properties hold:
?

?

?
 

Class

oC 

subClassOf

oD 

Inst

t

y

p

e
?

?

?
type
?

?

?
e
p
y
t

r
e
y
a
a
t
e
m

l

 
r
e
y
a
l
 
e
c
n
a
t
s
n

i

Model of O.

Corresponding model of Ometa.
Fig. 1. Sketch of the established interdependencies in the models of Ometa

O |= a iff Ometa |= bound(a).
Ometa |= type(i, oC).

1. For any OWL axiom a containing only names from OC, OR and OI, we have that
2. For any class name C  OC and instance name i  OI, we have that O |= C(i) iff
3. For any two named classes C, D  OC, we have that O |= C  D iff Ometa |=

subClassOf(oC, oD).

Proof. For the first claim, given a model I of O, we construct a model meta(I) = J of
Ometa as follows:

J = I  {C | C  OC}
J = I
I}
J = {, C |   C
J = {C | C  OC}

for all   OC  OR  OI

type
Class

Inst
subClassOf

J = I
J = {C, D | C

J = C

I}
I  D
from SepDom(O)  Typing(O) 
By construction J satisfies all axioms
MatSubClass(O). By induction, we obtain, for every class C containing only
names from voc(O), that bound(C)
(claim ). This in turn guarantees that, for
every axiom Ax using only terms from voc(O), we obtain I |= Ax iff J |= bound(Ax).
In particular, J also satisfies bound(O), whence it is a model of Ometa as claimed.
Using this transformation, we can show that Ometa |= bound(Ax) implies O |= Ax. We
demonstrate the case for GCIs. Suppose Ometa |= bound(C)  bound(D) but O |= C  D.
. But then there is a model J = meta(I)
Then there is a model I of O with C
(according to ) contradicting our assumption. For the
with bound(C)
other axiom types, the correspondence can be shown along the same lines.
The other direction (O |= Ax implying Ometa |= bound(Ax)) is shown analogously
using the transformation converting models J of Ometa to models I of O as follows:

J  bound(D)

I = Inst

, whence I is well-defined. Again we can establish bound(C)

Note that the additional axioms of Ometa ensure that only individuals from I
in every J
J = C
induction and use this to show Ometa |= bound(Ax) implying O |= Ax.

for all   OC  OR  OI

I = J

I  D

occur

by

B. Glimm, S. Rudolph, and J. Volker
Table 3. An example ontology O and its metamodeling-enabled version Ometa

.GoldenEagle

Prey  eats

.

Ontology O :
HouseMouse  eats
HouseMouse( jerry)
Metaontology Ometa :
bound(O): HouseMouse  eats
HouseMouse( jerry)

SepDom(O): Inst  Class

(GoldenEagle  HaastsEagle)(harry)
Prey  eats
(GoldenEagle  HaastsEagle)(harry)

.(Inst  GoldenEagle)

.Inst

Class(oHouseMouse) Class(oGoldenEagle) Class(oPrey) Class(oHaastsEagle)
Inst( jerry) Inst(harry)
eats.  Inst   eats.Inst type.  Inst   type.Class
subClassOf.  Class   subClassOf.Class
Typing(O): HouseMouse  type.{oHouseMouse}
GoldenEagle  type.{oGoldenEagle}
MatSubClass(O): Class  type
Class  type
Class  type
Class  type

Prey  type.{oPrey}
HaastsEagle  type.{oHaastsEagle}
.type.{oHouseMouse}  Class  subClassOf.{oHouseMouse}
.type.{oPrey}  Class  subClassOf.{oPrey}
.type.{oGoldenEagle}  Class  subClassOf.{oGoldenEagle}
.type.{oHaastsEagle}  Class  subClassOf.{oHaastsEagle}

. This can be simplified to { | , o

J  D
?

?

?
.type.{oD})
J} which, by Typing(O), coincides with C

For the second claim, given O |= C(i) we can conclude Ometa |= bound(C(i)) and
hence Ometa |= C(i) from which by Typing(O) follows type(i, oC). The argument holds
in both directions.
For the third claim, we have that from O |= C  D follows Ometa |= bound(C) 
|= C  D. Considering a model J of Ometa,
bound(D) and, therefore, Ometa
MatSubClass(O) ensures that J |= subClassOf(oC, oD) iff oC  (Class 
  type
 
type
and is true by assumption.
type

Again, the argument holds in both ways.
As an example, consider the ontology O and its metamodeling-enabled version Ometa
from Table 3. We find that HouseMouse  Prey is a consequence of O, whence Ometa
entails subClassOf(oHouseMouse, oPrey). In Ometa we can further make statements such
as ExtinctSpecies(oHaastsEagle) where ExtinctSpecies is a metaclass used to state
that Haasts eagle is an extinct species. If we then add the axiom ExtinctSpecies 
. to say that extinct species cannot have instances, an OWL 2 DL reasoner can
type
deduce GoldenEagle(harry).

J}  { | , o
?

?

?
In the following, we will illustrate the benefits of our approach on the basis of a
more concrete application scenario: the evaluation of ontologies with respect to the
OntoClean methodology.

4 OntoClean

This section gives a brief introduction to OntoClean (for a more thorough description
refer, e.g., to Guarino and Welty [4]), a methodology developed in order to ensure the
correctness of taxonomies with respect to the philosophical principles of Formal Ontol-
ogy. Central to OntoClean are the notions of rigidity, unity, dependence and identity,
?

?

?
commonly known as metaproperties. Note that in the OntoClean terminology, properties are what is called classes in OWL. Metaproperties are, therefore, properties of
properties. Consequently, OntoClean can be considered a very natural application of
metamodeling in ontology engineering and evaluation.

In the following, we will explain the process of applying the OntoClean methodology
by making reference to the OntoClean example ontology introduced by Guarino and
Welty ([4], Figure 1). This ontology, which consists of 22 classes such as Apple, Food,
Person or Agent, illustrates some of the most frequent modeling errors in terms of
OntoClean.

The process of applying the OntoClean methodology to a given ontology consists of

two essential phases:

Phase 1: First, every single class of the ontology to be evaluated or redesigned is
tagged with respect to the aforementioned metaproperties. This way, every class
gets assigned a particular tagging such as +R-D+I+U, denoting the fact that this
class is rigid (+R), non-dependent (-D), a sortal (+I, i.e. it carries an identity crite-
rion) and that it has unity (+U).

Phase 2: In the second phase, after the metaproperty tagging has been completed, all
the subsumption relationships of the ontology are checked according to a predefined set of OntoClean constraints. Any violation of such a constraint potentially
indicates a fundamental misconceptualization in the subsumption hierarchy.

Hence, after performing the two steps, the result is a tagged ontology and a (potentially
empty) list of misconceptualizations by whose means an ontology engineer can clean
the ontology. In a nutshell, the key idea underlying OntoClean is to constrain the possible taxonomic relationships by disallowing subsumption relations between specific
combinations of tagged classes. Welty et al. [13] show that analyzing and modifying
an ontology according to the quality criteria defined by OntoClean can have a positive
impact on the performance of an ontology-based application.

Metaproperties. As mentioned above, the original version of OntoClean is based on
four metaproperties: rigidity, unity, identity and dependence  abbreviated as R, U, I
and D, respectively. For brevity, we focus on rigidity omitting detailed explanations of
the other metaproperties and referring the interested reader to, e.g., [4].

Rigidity is based on the notion of essence. A class is essential for an individual iff
the individual is necessarily a member of this class, in all worlds and at all times. Iff a
class is essential to all of its individuals, the class is called rigid and is tagged with +R.
Non-rigid classes, i.e., classes which are not essential to some of their individuals, are
tagged with -R. An anti-rigid class is one that is not essential to all of its individuals
and thus tagged with ~R. Hence, every anti-rigid class is also a non-rigid class. Apple is
a typical example for a rigid class, because the property of being an apple is essential
to all of its individuals, or to put it differently: an apple is necessarily an apple and
cannot stop being one. In this respect, Apple differs from classes such as Food which is
mostly considered anti-rigid. Note, however, that the tagging of Food crucially hinges
on the intended semantics of this class. Welty [14] nicely illustrates this by an example:
If Food is the class of all things edible by humans then it should be tagged as rigid (+R).
If, in contrast, Food is a role that can be played by any individual while it is being eaten,

B. Glimm, S. Rudolph, and J. Volker

we must consider it anti-rigid (~R). The latter sense was assumed by Guarino and Welty
when they designed the aforementioned example ontology.

Constraints. The following formulation of the OntoClean constraints is literally taken
from Welty [14]. We adhere to this version rather than to the more stringent formulation
provided by Guarino and Welty [4] as it directly maps to the axiomatization in the
original OntoClean metaontology (cf. Section 5).

1. A rigid class (+R) cannot be a subclass of an anti-rigid class (~R).
2. A class with unity (+U) cannot be a subclass of a class with anti-unity (~U).
3. All subclasses of a sortal are sortals (+I).
4. All subclasses of a dependent class are dependent (+D).

What seems a matter of merely philosophical consideration can in fact have practical implications. Imagine, for instance, that a rigid class Apple is subsumed by Food
which is tagged as anti-rigid. Thus, Apple(a) would imply Food(a). It might also appear
reasonable to model the class Poisoned as disjoint to Food. But now, as the ontology
evolves and further class instantiations are added, we could state, for example, that a has
been poisoned (formally, Poisoned(a))  and the ontology turns logically inconsistent.

5 OWL-Based Constraint Checking

Despite the fact that OntoClean is the single most well-known and theoretically founded
methodology for evaluating the formal correctness of subsumption hierarchies, there
has always been a lot of criticism regarding the high costs for tagging and constraint
checking. To address this criticism and to make the OntoClean methodology more easily applicable in practical ontology engineering settings, Welty suggested an OWLbased formalization of metaproperty assignments and constraints [14], which leverages
logical inconsistencies as indicators of constraint violations. We discuss this framework
next and then introduce our novel metamodeling in this setting.

5.1 The Original OntoClean Metaontology

Weltys formalization, occasionally referred to as OntOWLClean, axiomatizes the
aforementioned OntoClean constraints as domain-range restrictions on a transitive object property subClassOf, which serves as a replacement for the normal subclass relation () and enables a reification of every subsumption relationship in a given domain
ontology. For example, instead of writing Apple  Food to state that Apple is a subclass of Food, we write subClassOf(oApple, oFood) introducing fresh individuals for the
classes (e.g., oApple for Apple). Metaproperty assignments then become class membership assertions, e.g., we write RigidClass(oApple). Similarly, we can state that oApple
is a class by adding the assertion Class(oApple). Note that in order to have true metamodeling one would have to state that subClassOf is the same as  and that Class
really implies that its instances are classes. This is possible in OWL Full, but not in
OWL DL. Since the reasoning support for OWL Full is limited, the axioms required
to equate subClassOf and Class with their OWL modeling constructs are available
?

?

?
Table 4. Fragment of the OntoClean metaontology [14]
RigidClass  Class
NonRigidClass  Class
AntiRigidClass  NonRigidClass

Class  (NonRigidClass  RigidClass)

NonRigidClass  RigidClass  

(NonDependentClass  DependentClass)
(SortalClass  NonSortalClass)
(UnityClass  NonUnityClass)
RigidClass  subClassOf.AntiRigidClass

...

as a complementary OWL Full ontology, which is kept separate from the core of the
OntOWLClean ontology.4 Table 4 shows an excerpt from the OWL DL part of the ontology focussing on the axioms for rigidity.

Note that if we now state that Apple is rigid and Food is anti-rigid the metaontology

becomes inconsistent as witnessed by the following set of axioms:
RigidClass  subClassOf.AntiRigidClass
subClassOf(oApple, oFood)

RigidClass(oApple)
AntiRigidClass(oFood)

OntOWLClean has been a great step forward when it comes to the practical applicability of the OntoClean methodology, because it enables the use of standard DL reasoning for detecting constraint violations (see also [11]). However, the axiomatization of
metaproperty assignments and constraints suggested by Welty has at least two drawbacks which can be overcome now that OWL 2 is available:

First, while syntactically metaproperty assignments and constraints could be part
of the same ontology as classes and subsumption axioms, there is no semantic link
between a class and its corresponding individual (e.g., the class Apple and the individual
oApple being a member of RigidClass in the metaontology). Hence without the OWL
Full part of the axiomatization, OntOWLClean does not allow for integrated reasoning
over classes and their metaproperties. Furthermore, any changes to the subsumption
hierarchy (in case of constraint violations, for example) involve modifications of two
logically unrelated taxonomies, possibly maintained in two different files.

Second, the computational costs of determining the reasons for logical inconsistencies
and thus constraint violations can be very high. The typical way of debugging an inconsistent ontology is to compute minimal subsets of the ontological axioms, which preserve
the inconsistency. These subsets are called explanations, justifications, or minAs. In order to compute the explanations, axioms are removed from the original ontology in a
step by step manner, while after each removal a reasoner is used to check whether the
remaining set of axioms is still inconsistent. This process is repeated until no further
axiom can be removed without turning the ontology consistent. Users presented with

4 Note that the last axiom in Table 4 is specified as an equivalence in http://www.ontoclean.
org/ontoclean-dl-v1.owl. We assumed this to be a mistake as equivalence is not used for
modeling any of the constraints in Weltys paper [14], and corrected the ontology accordingly.

B. Glimm, S. Rudolph, and J. Volker

Table 5. An explanation for the conflict caused by Apple being rigid and Food being anti-rigid

RigidClass  subClassOf.(AntiRigidClass)

Apple  Food
type.  Inst

Apple  type.{oApple}
Food  type.{oFood}

Class  type

.type.{oFood}  Class  subClassOf.{oFood}

RigidClass(oApple)
AntiRigidClass(oFood)
Class(oApple)

the explanations can then decide how to fix the ontology. In particular computing all
such explanations is a computationally hard task. Due to the high costs, only limited
tool support for inconsistency diagnosis in OWL is available.

5.2 Towards OntOWL2Clean
In order to address the first issue, we extend Ometa from Table 3 by a set of classes and
axioms which enable us to express all of the OntoClean metaproperty assignments and
constraints. In particular, we have the following axioms for the constraints:

RigidClass  subClassOf.AntiRigidClass
UnityClass  subClassOf.AntiUnityClass
SortalClass  subClassOf
.SortalClass
DependentClass  subClassOf
.DependentClass

(C1)
(C2)
(C3)
(C4)

We can now add the OntoClean taggings to the classes making use of the class individuals in Ometa. For example, since we assume Food to be anti-rigid while Apple is rigid,
we add the following facts to Ometa:

AntiRigidClass(oFood)

RigidClass(oApple)

Note that we do not have to add subClassOf(oApple, oFood) explicitly since the
subClassOf role between oApple and oFood is implied in Ometa. Since constraint (C1)
prevents an anti-rigid class from being a subclass of a rigid one, the ontology becomes
inconsistent, witnessed by the explanation shown in Table 5.

One should be aware that adding constraints might have a backward impact on
the semantics of the original part of the ontology in that they could rule out certain
models thereby leading to additional consequences. To see this, assume our ontology
has been corrected by removing Apple  Food. Axiom (C1) still enforces that Apple
must not be a subclass of Food and we have as a consequence that the extension of
Apple must be nonempty in every model. This is because the empty set is trivially a
subset of every set and, in particular, a subset of the extension of Food. Depending on
the concrete scenario, these ramifications might be unwanted or intended. They can be
avoided by using the approach based on marker predicates described next.
?

?

?
6 Marker Predicates for Pinpointing Constraint Violations

The above method implements Weltys approach of specifying the constraints in a way
that their violation results in an inconsistent knowledge base. In order to actually find
and identify the reasons for these inconsistencies, diagnosis techniques [7,5] have to be
employed. Typically these diagnosis techniques are rather costly as they require numerous calls to a reasoning system.

Consider a constraint

We argue that in certain cases, an alternative approach can be employed, wherein
violations of OntoClean constraints do not cause the ontology to become inconsistent
but lead to the creation of marker classes or roles that indicate which ontology elements
are involved in a constraint violation. This alternative method can be combined with the
original two-ontology approach as well as with our metamodeling technique.
that prohibits C  D whenever C is endowed with
the metaproperty T1 and D is endowed with T2. By specifying the axiom T1 
subClassOf.T2, we would turn an ontology inconsistent whenever it entails T1(oC),
T2(oD), and subClassOf(oC, oD). Consequently, diagnosis would be required to locate the violated constraint. Instead, we propose to establish an auxiliary marker role
conflictsWith between oC and oD in this case. Thereby, all conflicts can be readily spotted by simply retrieving all entailed conflictsWith role memberships. This
wanted correspondence can be logically enforced in OWL 2 using an encoding introduced independently in [8] and [2] which makes use of additional auxiliary roles t1, t2
as well as some of the advanced features of SROIQ:

T1  t1.Self

T2  t2.Self

t1  subClassOf  t2  conflictsWith

In order to axiomatize the OntoClean constraints, we introduce a fresh role mp for each
OntoClean metaproperty mpClass (e.g., rigid for RigidClass) and an axiom

mpClass  mp.Self

(M1)

where mp is the fresh role associated with mpClass. We can then axiomatize the four
OntoClean constraints (C1) to (C4) with the following role chain axioms, where we use
one marker per conflict type:

rigid  subClassOf  antiRigid  rigidityConflict
unity  subClassOf  antiUnity  unityConflict

nonDependent subClassOf  dependent  dependencyConflict

nonSortal subClassOf  sortal  sortalConflict

For each role r on the right-hand side of Axioms (M2) to (M5)

r  conflictsWith

(M2)
(M3)
(M4)
(M5)

(M6)

Note that for (C3) and (C4) we use an equivalent formulation which is better suited
for using the marker properties. In order to allow for retrieving all conflicts at once, we
further introduce conflictsWith as a superrole of all the roles on the right-hand side
of the above axioms.

B. Glimm, S. Rudolph, and J. Volker

7 Evaluation

We used the OntoClean example ontology [4] to test the different approaches. This
leaves us with four settings: we first test Weltys metamodeling (see Section 5) and
our metamodeling (see Section 3) with Explanations for discovering the modeling mistakes in settings Ex1 and Ex2, then we test the two approaches with the new Marker
predicates (see Section 6) in settings Ma1 and Ma2.

Ex1 Our baseline is the metamodeling part of the example OntoClean ontology, i.e.,
we use the metamodeling as proposed by Welty. It is worth noting that we use the
weakened OWL DL version of the original OWL Full meta ontology to be able to
use OWL DL reasoners. For each axiom, e.g., Apple  Food in the original ontol-
ogy, the meta version contains an assertion subClassOf(oApple, oFood) with oApple
and oFood individuals and subClassOf a role. Furthermore, the meta ontology
contains the taggings such as RigidClass(oApple) and the OntoClean constraints
from Axioms (C1) to (C4).

Ex2 The second ontology is the metamodeling version of the OntoClean ontology
according to our novel metamodeling technique. Since we have no separation
between the metamodeling part and the original axioms, the ontology contains
assertions of either kind: adjusted axioms from the source ontology as well as the
taggings and the OntoClean constraints from Axioms (C1) to (C4).

Ma1 In this setting, we use the marker predicates to manifest modeling errors instead
of inconsistencies. The ontology uses Weltys metamodeling as in setting Ex1
and contains the taggings, but instead of causing inconsistencies by adding Axioms (C1) to (C4), we use marker predicates as described in Section 6 and add
Axioms (M1) to (M6).

Ma2 The last setting uses our novel metamodeling approach in combination with the
marker predicates, i.e., we use an ontology as in setting Ex2, but instead of causing
inconsistencies by adding Axioms (C1) to (C4), we again use marker predicates
and add Axioms (M1) to (M6).

In order to find all potential modeling errors in the settings Ex1 and Ex2, we use the
explanation framework by Horridge et al. [5] and we generate all minimal subsets O
of the ontology such that O
is inconsistent. For the settings Ma1 and Ma2, we retrieve
instances of the roles that indicate a conflict. All tests have been performed using the
OWL 2 DL reasoner HermiT. The ontologies, HermiT 1.2.4, the obtained results, and
the program used to produce the results are available online.5 The tests have been performed on a MacBook Air with Java 1.6, assigning 1GB memory to Java.

Both explanation approaches ran out of memory after 2.5 days, generating 51 explanations for setting Ex1 and 46 explanations for setting Ex2, making the approach
not really feasible in practice. Although the first explanations are generated quickly, the
later ones can take significant time and memory. We repeated the tests of setting Ex1
and Ex2 on a node of the Oxford Supercomputing Centre, assigning 24GB of main
memory to Java. We terminated the programs after one week, getting 53 explanations
for setting Ex1 and 66 for setting Ex2. By analyzing the ontology manually, we find that

5 http://www.hermit-reasoner.com/2010/metamodeling/metamodeling.zip
?

?

?
Table 6. Time in seconds for retrieving instances of the marker properties

setting
Ma1
Ma2

rigidity

< 1

unity
< 1

conflict

dependency

< 1

sortal
< 1

all
< 1

there should be 53 explanations for setting Ex1 and we assume that the code attempted
to find more explanations without success.

There are more explanations for the new metamodeling approach since an explanation might contain the meta axioms for the involved classes only partially. In such a
case, the explanation contains additional axioms that are not directly related to the con-
flict, but which contain enough meta axioms to cause the clash for the only partially
axiomatized real inconsistency cause.

The novel marker approaches (Ma1 and Ma2) both find 40 conflicts: 10 rigidity con-
flicts, 16 unity conflicts, 12 dependency conflicts, and 2 identity conflicts. The timings
are given in Table 6 and were averaged over 3 runs of the reasoner. It can be observed
that the times for our new metamodeling approach are significantly slower than the ones
for the original approach. This is a consequence of the more complex axiomatization
that is required in order to achieve real metamodeling in OWL 2 DL, whereas in setting Ma1, the reasoner only works on a part of the ontology that suffices to detect these
conflicts. Full metamodeling in the settings Ex1 and Ma1 requires an OWL Full reasoner and, as Welty states [14], a satisfactory implementation that can handle the full
meta ontology is not (yet) available.

The number of marker conflicts is lower than the number of explanations because
for several indirect subclass relationships, there are different ways of deriving the sub-
sumption. E.g., the ontology contains:

Organisation  SocialEntity
Organisation  LegalAgent

SocialEntity Agent
LegalAgent Agent

In both cases, we have that Organisation is a subclass of Agent. Since we further have
that Organisation is a rigid class, while Agent is anti-rigid, we have one explanation
using the first set of subclass axioms and another explanation using the second set of
subclass axioms, whereas the marker approach does not distinguish the two cases.

8 Conclusion

We have presented a novel approach to ontology-inherent metamodeling for classes in
OWL based on an axiomatization of class reification. This approach allows for associating information to classes and asserting constraints on the subclass hierarchy in a way
that allows for the usage of standard OWL reasoning tools. We demonstrated our approach by applying it to the OntoClean methodology. We found that the benefits of our
approach in terms of maintenance and tight logical integration may come at the cost of
runtime performance. On the other hand, we showed that performance can be increased
by several orders of magnitude if the explanation-based diagnosis originally proposed

B. Glimm, S. Rudolph, and J. Volker

for OntoClean is substituted by a novel consistency-preserving approach working with
marker predicates that indicate potential modeling flaws in the ontology. The runtime
improvements thus obtained outweigh the metamodeling-induced slowdown by far.

Acknowledgements. Birte Glimm is funded by the EPSRC project HermiT: Reasoning
with Large Ontologies. Sebastian Rudolph is supported by the German Research Foundation (DFG) under the ExpresST project. Johanna Volker is financed by a Margarete-
von-Wrangell scholarship of the European Social Fund (ESF) and the Ministry of
Science, Research and the Arts Baden-Wurttemberg. The evaluation has been performed on computers of the Oxford Supercomputing Centre.
