Adding Integrity Constraints to the Semantic

Web for Instance Data Evaluation

Jiao Tao

Department of Computer Science, Rensselaer Polytechnic Institute,

Troy, NY 12180, USA

Abstract. This paper presents our work on supporting evaluation of
integrity constraint issues in semantic web instance data. We propose
an alternative semantics for the ontology language, i.e., OWL, a decision
procedure for constraint evaluation by query answering, and an approach
of explaining and repairing integrity constraint violations by utilizing the
justifications of conjunctive query answers.

Keywords: Instance Data, Evaluation, Integrity Constraint, OWL.

1 Introduction: Motivation and Challenges

With the rapid growth of semantic web [1] technologies, a lot of semantic web
applications such as Twine, Freebase, TrueKnowledge, Hakia, etc, are emerging
on the web. To consume the data generated by these applications, it is critical
to evaluate the data and ensure it meets the needs of users first. The data on the
semantic web includes the ontologies that describe the schema of the domain,
and the instance data that refers to the ground level data particular to the
applications. There has been a lot of research aimed at ontology evaluation [2] [3]
[4], however there is little, if any, research focusing on instance data evaluation,
even though instance data usually accounts for orders of magnitude more than
ontologies on the web.

We have identified three categories of issues [5] that may occur in instance
data which are syntax errors, logical inconsistencies, and integrity constraint
issues: syntax errors are the issues indicating that the syntax representation
of instance data does not conform to the corresponding syntax specifications
such as RDF/XML, N3, N-Triple, Turtle, etc; logical inconsistencies are the
issues showing that the underlying logical theory of the instance data includes
contradictory axioms; integrity constraint issues are the issues caused by the
failure of the instance data to follow the restrictions that are imposed by the
integrity constraints. While the evaluation of first two categories of issues are
well studied [6] [7] [8] [9] and are being supported by existing tools such as
W3C RDF validation service1, the DL reasoner Pellet2, Chimaera [10], the BBN
validator3, and ODEval [11], evaluation support for integrity constraint issues
in semantic web instance data still remains an open research problem.
1 http://www.w3.org/RDF/Validator/
2 http://clarkparsia.com/pellet/
3 http://projects.semwebcentral.org/projects/vowlidator/

P.F. Patel-Schneider et al.(Eds.): ISWC 2010, Part II, LNCS 6497, pp. 330337, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
The concept of integrity constraint (IC) was invented in the field of relational
databases where ICs are used to ensure data consistency [12]. As an important
functionality, almost all database systems support IC checking. The main approach for checking ICs in databases is to represent ICs as part of the database
schema and translate the constraints to corresponding queries. Whenever there
is an update to the data, the queries are executed first to see if the ICs are
violated, therefore preventing potential constraint violations. One might wonder if similar approach can be used for the task of evaluating IC issues on the
semantic web: modeling ICs as part of the domain knowledge using knowledge
representation languages on the semantic web such as OWL [13] then translating
IC axioms to queries and validating ICs by corresponding query answering. The
standard semantics of OWL is based on Description Logics (DL) which has the
following two characteristics:

 Open World Assumption (OWA): i.e., a statement cannot be inferred to be

false on the basis of failures to prove it.

 Absence of the Unique Name Assumption (UNA): i.e., two different names

may refer to the same object.

Due to the above characteristics, what triggers constraint violations in closed
world systems, such as databases, leads to new inferences in standard OWL
systems. Therefore, it is difficult to use OWL for IC evaluation. In this paper,
we present our work on supporting evaluatin of integrity constraint issues in
semantic web instance data by enabling OWL as an IC language.

2 Related Work

Several existing proposals on enabling OWL as an IC language combine OWL
with different formalisms such as rules, epistemic queries, or epistemic logics.
The rule-based approach [14] [15] expresses ICs as rules with a special predicate
and check ICs by examining if the special predicate is entailed by the hybrid DLrule knowledge base (KB). With this approach the developers need to be familiar
with rules. The epistemic query-based approach [16] expresses ICs as epistemic
queries and evaluates ICs by checking the epistemic query answers. However the
complexity results of this approach in expressive DLs are still unknown. The
epistemic DL-based approach extends DLs with epistemic logics and expresses
ICs with epistemic DL axioms. With this approach, IC evaluation is to determine
if the IC axioms are epistemic-entailed by the DL KB. However, this approach
has two limitations: first, it focuses on less expressive DLs; second, it adopts
the strict UNA which is not compatible with OWL since two different OWL
individual names might refer to the same object.

In this paper, we focus on approaches that reuse OWL as an IC language. Our
closest related work is a minimal Herbrand model-based approach [17]. With this
approach, an OWL IC axiom is satisfied if all minimal Herbrand models of the
KB satisfy it. This approach may result in counterintuitive results or modeling
burden: first, existentially quantified individuals can satisfy ICs, which is not

J. Tao

desirable for IC evaluation; second, with this approach, if an IC needs to be
satisfied only by individual names, then a special concept O has to be added
into the original IC axiom, and every individual name should be asserted as an
instance of O. This adds a significant maintenance burden on ontology developers
while still not capturing the intuition behind ICs; third, the disjunctions and ICs
may interact in unexpected ways.

3 Research Objectives and Plan

This work is aimed to support evaluating IC issues in semantic web instance
data. For this purpose, we identify the following research objectives and plan:

 Enabling OWL as an IC language. Aside from being an ontology language,
OWL is also an IC language that can be used to represent constraints that
the instance data has to satisfy.

 Providing decision procedures for IC evaluation. Given a set of instance data
and IC axioms, the decision procedures decide if the ICs are violated by the
instance data.

 Providing explanation services for IC violations which explain why certain

ICs are violated and recommend how to repair the violations.

 Implementation and Evaluation. Implementing a prototype and evaluating

IC issues in instance data.

4 Research Progress

Until now we have completed the review of the state of the art, and compared
the different approaches of enabling OWL as an IC language. Due to the various
issues of these approaches that we have discussed in Section 2, we decided that
designing an alternative semantics for OWL which supports ICs and correctly
captures the intuitions behind ICs would be a promising solution. The work that
we have done so far includes an IC semantics for OWL, a decision procedure for
IC evaluation, an approach to explain and repair IC violations, and a partial
implementation.

4.1 IC Semantics for OWL

In this section, we will describe an IC semantics [18] that we have proposed for
OWL [19] which is based on DL SROIQ[20].

In the IC semantics, we adopt a weak form of UNA4: two individual names
with different identifiers are assumed to be different by default unless their equality is required to satisfy the axioms in the KB. We formalize this notion of weak
UNA by Minimal Equality (ME) models. Given a SROIQ KB K, I and J are
two SROIQ interpretations of K, we say J = I if: (1)C  NC, J |= C(a)
iff I |= C(a); (2) R  NR, J |= R(a, b) iff I |= R(a, b); (3) EJ  EI where
4 With UNA, two different names always refer to different entities.
?

?

?
EF = {a, b | a, b  NI s.t. F |= a = b}. The Minimal Equality (ME) models,
i.e., M odME(K), are the models of K with minimal equality between individual
names. Formally, we define

M odME(K) = {I  M od(K) | J ,J  M od(K),J = I}

,I) is
First, we define an IC-interpretation I,U = (

a SROIQ interpretation and U is a set of SROIQ interpretations. The ICinterpretation function I,U maps concepts, roles, and individuals as follows:

,I,U) where I = (

J },

= {xI | x  NI s.t. J  U, xJ  Ca
I,U
Ca
= {xI, yI | x, y  NI s.t. J  U, xJ , yJ  RJ},
RI,U
aI,U
= aI,
(C  D)
I,U
( nR.C)
(R.Self)

(R
= CI,U  DI,U ,
I \ CI,U ,
= {xI | x  NI s.t. #{yI | xI, yI  RI,U
I,U
= {xI | x  NI s.t. xI, xI  RI,U},

= {xI, yI | yI, xI  RI,U},

(C)

= (NI)

I,U

)

I,U

I,U

and yI  CI,U}  n},

{a}I,U

= {aI}.

I | x  NI}, Ca  NC (atomic concepts), R  NR (atomic
where (NI)I = {x
roles), a  NI (individual names), C, D are concepts.
Then, the satisfaction of axiom  in an IC-interpretation I,U, denoted as
I,U |= , is defined in Table 1. Note that, there are also four kinds of ABox
axioms (C(a), R(a, b), a = b, a = b). Their semantics is given by encoding them
as TBox axioms ({a}  C, {a}  R.{b}, {a}  {b}, {a}  {b}, resp.).
Given a SROIQ KB K and a SROIQ axiom , we say K IC-satisfies ,
i.e., K |=IC , iff I  U, I,U |= , where U = M odME(K). We define an
extended KB as a pair K,C where K is a SROIQ KB interpreted with the
standard semantics and C is a set of SROIQ axioms interpreted with the IC
semantics. We say that K,C is valid if   C,K |=IC , otherwise there is
an IC violation. Note that, the IC-satisfaction has a closed world flavor: given
an atomic concept C (R resp.), if K |=IC C(a)(R(a, b) resp.) then we conclude
K |=IC C(a) (R(a, b) resp.). We have verified [18] that this CWA5 and the
weak UNA addresses the issues caused by the OWA and absence of UNA of
OWL standard semantics, therefore enabling OWL as an IC language.

Table 1. Axiom satisfactions in IC-interpretation I, U

Type Axiom
C  D
TBox
R1  R2

RBox

Condition on I, U

CI,U  DI,U
1  RI,U
RI,U
 . . .  RI,U

n  RI,U

R1 . . . Rn  R RI,U

Ref(R)
Irr(R)

Dis(R1, R2)

x  NI : xI,U , xI,U  RI,U
x  NI : xI,U , xI,U  RI,U

1  RI,U
RI,U

2 = 

5 With CWA, a statement is inferred to be false if it is not known to be true, which

is the opposite of OWA.

J. Tao

4.2 IC Evaluation

In this section, we describe a decision procedure for IC evaluation. That is,
deciding if a KB IC-satisfies an IC axiom. First, we present the translation rules
from IC axioms to DCQnot queries. Then we show that IC evaluation can be
reduced to corresponding DCQnot query answering. Due to space limitation we
do not introduce DCQnot here. Please refer to [18] for more details.

The translation rules are similar in the spirit to the Lloyd-Topor transformation [21] but instead of rules we generate DCQnot queries. The idea behind the translation is to translate an IC axiom into a query such that when
the IC is violated the query is true. In other words, whenever the answer set
of the query is not empty, we can conclude that the IC is violated. The translation
contains two operators: Tc for translating concepts and T for translating
axioms:
?

?

?
1i<jn

not (yi = yj)

(R(x, yi)  Tc(C, yi))

Tc(Ca, x) := Ca(x)
Tc(C, x) := not Tc(C, x)
Tc(C1  C2, x) := Tc(C1, x)  Tc(C2, x)

Tc( nR.C, x) :=
1in
Tc(R.Self, x) := R(x, x)
Tc({a}, x) := (x = a)
T (C1  C2) := Tc(C1, x)  not Tc(C2, x)
T (R1  R2) := R1(x, y)  not R2(x, y)
T (R1 . . . Rn  R) := R1(x, y1)  . . . Rn(yn1, yn)  not R(x, yn)
T (Ref(R)) := not R(x, x)
T (Irr(R)) := R(x, x)
T (Dis(R1, R2)) := R1(x, y)  R2(x, y)

where Ca is an atomic concept, C(i) is a concept, R(i) is a role, a is an individual
name, x and y(i) are variables.
Example 1. Suppose  : Product  hasProducer.Producer, then we have:

T (Product  hasProducer.Producer)
:= Tc(Product, x)  not Tc(hasProducer.Producer, x)
:= Product(x)  not (hasProducer(x, y)  Tc(Producer, y))
:= Product(x)  not (hasProducer(x, y)  Producer(y))
We now obtain the main decision procedure for IC evaluation:
Theorem 1. Given an extended KB K,C with expressivity SRI,SROIQ
(SROIQ,SROI resp.), K |=IC  iff the query answers A(T (),K) are empty,
i.e., K |= T (), where   C.
?

?

?
We require K,C to be less expressive than SRI,SROIQ or SROIQ,
SROI because, otherwise, the disjunctive individual (in)equivalence axioms in
K and the cardinality restrictions in C will cause some problematic interactions
such that the IC axioms are satisfied in different ways at different interpretations
of K and IC evaluation can not be reduced to query answering. Please refer to
[22] for more details.

4.3 IC Violation Explanation and Repair
By Theorem 1, K violates an IC axiom  if K |= T (). To explain the violations
of , we just need to justify why the query entailment K |= T () holds. In this
section, we present our recent work on justification of conjunctive query answers
[23] and show how to use the justifications to explain and repair IC violations.
Given a DCQnot entailment K |= Q where K is a SROIQ DL KB, Q
is a DCQnot ,  is an assignment mapping query variables to individuals, a
justification for K |= Q is J = J+,J where J+ and J are the positive and
negative justifications respectively such that: (1) J+  K, J+ |= Q; S  K,
J+  S |= Q; J   J+, J  |= Q. (2) K  J is consistent; K  J |= Q;
T  J, K  T |= Q; J   J, K  J  |= Q. That is, the existence of J+
in K and the absence of J from K are sufficient for K |= Q to hold.
Example 2. Suppose we have the following KB K and IC axiom 

K = {Toy  Product, ToyProducer  Producer, Toy(p1), Product(p1),
 : Product  hasProducer.Producer.

hasProducer(p1, s1), hasProducer(p1, s2)}

Then T () is Q  Product(x)  not (hasProducer(x, y)  Producer(y)) and
query answer A(Q,K) = { : x  p1, y  s1, 
 : x 
p1, y  p1} is not empty indicating  is violated.
To explain the violation of , we first compute the justifications for K |= Q.
We have proposed algorithms for justification computation [23]. According to
the algorithms, the justifications for K |= Q w.r.t.  are:
J1 = J1+,J1 = {Product(p1)},{Producer(s1)},
J2 = J2+,J2 = {Toy(p1), Toy  Product},{Producer(s1)}.

 : x  p1, y  s2, 

Since the entailment K |= Q contributes to the non-emptiness of query answers
A(Q,K), the violation of  can be explained by J1 and J2. That is,  is violated
because p1 is a product (by J1+/J2+) and p1 does not have a known producer
(by J1/J2).
To repair the above violations, we need to invalidate K |= Q. According to the
definition of query entailment justification, K |= Q holds because the existence
of positive justifications and the absence of negative justifications. Therefore, we
can either remove a minimal hitting set (mhs)6 of positive justifications from K
6 Given a collection of sets, a set which intersects all sets in the collection in at least
one element is called a hitting set. The minimal hitting set is the hitting set of
smallest size.
