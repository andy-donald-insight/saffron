EL with Default Attributes and Overriding

Piero A. Bonatti, Marco Faella, and Luigi Sauro

Universit`a di Napoli Federico II, Napoli, Italy

{bonatti,mfaella,sauro}@na.infn.it
http://people.na.infn.it/~bonatti

Abstract. Biomedical ontologies and semantic web policy languages
based on description logics (DLs) provide fresh motivations for extending
DLs with nonmonotonic inferencesa topic that has attracted a significant amount of attention along the years. Despite this, nonmonotonic
inferences are not yet supported by the existing DL engines. One reason
is the high computational complexity of the existing decidable fragments
of nonmonotonic DLs. In this paper we identify a fragment of circumscribed EL that supports attribute inheritance with specificity-based
overriding (much like an object-oriented language), and such that reasoning about default attributes is in P.

Keywords: Nonmonotonic description logics, Defeasible inheritance.

1 Introduction

The ontologies at the core of the semantic web  as well as ontology languages
like RDF and OWL  are based on fragments of first-order logic and inherit
strengths and weaknesses of this well-established formalism. Limitations include
monotonicity, and the consequent inability to design knowledge bases (KBs) by
describing prototypes whose general properties can be later refined with suitable
exceptions. This natural approach is commonly used by biologists and calls for
an extension of DLs with defeasible inheritance with overriding (a mechanism
normally supported by object-oriented languages) [18, 19]. Another motivation
for nonmonotonic DLs stems from the recent development of policy languages
based on DLs [21,13,22,17]. DLs nicely capture role-based policies and facilitate
the integration of semantic web policy enforcement with reasoning about semantic metadata (which is typically necessary in order to check policy conditions).
However, in order to formulate standard default policies such as open and closed
policies,1and authorization inheritance with exceptions, it is necessary to adopt
a nonmonotonic semantics (see the survey [9] for more details).

Given the massive size of semantic web ontologies and RDF bases, it is mandatory that reasoning in nonmonotonic DLs be possible in polynomial time. Unfor-
tunately, in general nonmonotonic DL, reasoning can be highly complex [11,12,8];

1 If no explicit authorization has been specified for a given access request, then an

open policy permits the access while a closed policy denies it.

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 6479, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
the best approaches so far belong to the second level of the polynomial hierarchy [10, 7].
In this paper we identify a fragment of circumscribed DLs that extends EL
with default attributes and inheritance with overriding. Informally, the extension allows us to express defeasbile inclusions such as the instances of C are
normally in D, for two concepts C and D. Such axioms can be overridden by
more specific inclusions, according to a priority mechanism. Our strategy is preserving the classical semantics of EL as much as possible, in order to facilitate
the adaptation of the existing monotonic ontologies. Our framework restricts
nonmonotonic inferences to setting the default attributes of normal concept
instances, without changing the extension of atomic concepts. We define two
slightly nonstandard reasoning tasks to query the properties of normal instances.
In general, these reasoning tasks are NP-hard. The main cause of intractability
is the presence of conflicting defeasible inclusions, i.e., inclusions that give rise to
an inconsistency when applied to the same individual. However, if for all pairs
of conflicting inclusions 1 and 2, with non-comparable priority, there exists
a disambiguating, higher priority inclusion that blocks at least one of 1 and
2, then the time complexity of the reasoning tasks becomes polynomial. We
show that the identification of such 1 and 2 can be carried out in polynomial
time; then the disambiguation can be left to the ontology engineer or performed
automatically by generating a default that blocks both 1 and 2.

The paper is organized as follows. In Sec. 2, we recall the basics of circumscribed DLs with defeasible inclusions, using the notation adopted in [7]. In
Sec. 2.1 we motivate and define a new reasoning task, tailored to inferring the
default properties of concepts. Section 3 is devoted to the complexity analysis
of this inference problem for the general case and for the restricted class of KBs
outlined above. In Sec. 4 the new task and complexity results are extended to
instance checking. A section on related work (Sec. 5) and one summarizing our
results and discussing interesting future work (Sec. 6) conclude the paper.

2 Preliminaries

In DLs, concept expressions are inductively defined using a set of constructors
(e.g. , , ), starting with a set NC of concept names, a set NR of role names,
a set NI of individual names, and the constants top  and bottom . In what
follows, we will deal with expressions

C, D ::= A |  || C  D | C | R.C ,

where A is a concept name and R a role name. In particular, the logic EL
supports all of the above expressions except negation (C). Knowledge bases
consist in a (finite) set of concept inclusion assertions of the form C  D (TBox)
and a (finite) set of instance assertions of the form C(a), R(a, b) with a, b  NI
(ABox).
The semantics of the above concepts is defined in terms of interpretations I =
,I). The domain 

I is a non-empty set of individuals and the interpretation
(

P.A. Bonatti, M. Faella, and L. Sauro

Syntax Semantics
C 
C  D C

Name
I \ C

negation
I  D

conjunction
existential restriction R.C {d  
I | (d, e)  R
 I = 

top
 I = 
bottom

I : e  C

I}

Fig. 1. Syntax and semantics of some DL constructs

I  

I  

I on 

function I maps each concept name A  NC to a set A
I, each role name
R  NR to a binary relation R
I, and each individual name a  NI to
I. The interpretation of arbitrary concepts is inductively
an individual a
defined as shown in Figure 1. An interpretation I is called a model of a concept
I = . If I is a model of C, we also say that C is satisfied by I.
C if C
I  D
An interpretation I satisfies (i) an inclusion C  D if C
I, (ii) an
I)  R
I. Then,

I, and (iii) an assertion R(a, b) if (a
assertion C(a) if a
, b
I is a model of a knowledge base S iff I satisfies all the elements of S.
Here we consider defeasible EL knowledge bases KB = (S,D) that consist of
a (finite) set of classical axioms (inclusions and assertions) S and a (finite) set D
of defeasible inclusions (DIs for short). Hereafter, with C KB D we mean that
D classically subsumes C, that is S |= C  D. A classical axiom can be either
a normal form axiom [1] or an inclusion/disjointness of existential restrictions:

I  C

A1  R.A2

A  B
P.A  B R.A1  S.A2 R.A1  R.A2 

A1  A2  B

where letters of type A can be either a concept name or , whereas letters B
either a concept name or . Defeasible axioms take the form A1 n R.A2 and
can be informally be read as the instances of A1 are normally in R.A2.
Example 1. A well-known example of prototypical property in a biomedical domain is reported by Rector [18, 19]: In humans, the heart is usually located on
the left-hand side of the body; in humans with situs inversus, the heart is located on the right-hand side of the body. A possible formalization in the above
language is:

Human n has heart.LHeart
SitusInversus  Human  has heart.RHeart
LHeart  Heart  position.Left
RHeart  Heart  position.Right .

In the absence of functional roles, we prevent humans to have both a LHeart
and a RHeart with the disjointness axiom:

has heart.LHeart  has heart.RHeart   .
?

?

?
The nonmonotonic semantics summarized below follows the circumscriptive approach of [7].
Intuitively, a model of a knowledge base KB is a classical model of S that
maximizes the set of individuals satisfying the defeasible inclusions in D. For-
mally, for all defeasible inclusions  = (A n C) and all interpretations I, the
set of individuals satisfying  is:

I | x  A

I or x  C

satI() = {x  

I} .

How such sets can be maximized depends on what is allowed to vary in an
interpretation. Here we assume that only the extension of roles can vary, whereas
the domain and the extension of concept names are assumed to be fixed. This
semantics is called Circfix.

The reason of this choice is rooted in the goal of having a minimal impact on
the classical semantics of DLs. If a concept name A is allowed to vary and has
exceptional properties, then A may become empty as illustrated in [8]; in most
cases, however, it is undesirable to empty a concept only because it has nonstandard properties. It should be possible to extend an existing ontology with
default attributes without incurring in such side effects. With Circfix, a subsumption A  B where A and B are atomic concepts is nonmonotonically valid iff it
is classically valid. At the same time, it is possible to infer new inclusions like
A  R.B that specify default properties of A. In other words, Circfix supports
default attributes without changing the extension of atomic concepts, as desired.
Maximizing defeasible inclusions may lead to conflicts between defeasible inclusions whose right-hand sides are mutually inconsistent. For this reason, it is
useful to provide a means to say that a defeasible inclusion 1 has higher priority
than another defeasible inclusion 2. This can be in general provided explicitly
by any partial order over D, but here we focus on an implicit way of defining
priorities, namely specificity, which is based on classically valid inclusions.2 For
all DIs 1 = (A1 n C1) and 2 = (A2 n C2), we write

1  2 iff A1 KB A2 and A2 KB A1.

Example 2. Consider the access control policy: Normally users cannot read
project files; staff can read project files; blacklisted staff is not granted any ac-
cess. In circumscribed EL:

Staff  Users
Blacklisted  Staff
UserRequest  subject.Users target.Projects action.Read
StaffRequest  subject.Staff  target.Projects action.Read
UserRequest n decision.Deny
StaffRequest n decision.Grant
subject.Blacklisted  decision.Deny
decision.Grant  decision.Deny   .

2 Since concept names are all fixed and retain their classical semantics, specificity can
be equivalently defined using nonmonotonically valid inclusions instead. The result
is the same, for all priority relations over defeasible inclusions.
?

?

?
As usual, C  D abbreviates C  D and D  C. The two equivalences can
be reformulated using normal form axioms (see Example 5). Clearly the two
defeasible inclusions cannot be simultaneously satisfied for any staff member
(due to the last inclusion above). According to specificity, the second defeasible
inclusion overrides the first one and yields the intuitive inference that non-

blacklisted staff members are indeed allowed to access project files.

and satI(

)  satJ (

I = 
I = a
I = A

(concept name extensions are fixed)

J ;
J , for all a  NI;
J , for all A  NC;
) ;

We are finally ready to formalize the semantics of KBs with defeasible inclusions.
The maximization of the sets satI() is modelled by means of the following
preference relation <D over interpretations. Roughly speaking, I <D J holds
iff I improves J by extending the set of individuals that satisfy some defeasible
inclusions. More precisely, if 1  2 (i.e., 1 has higher priority than 2), then
the set of individuals satisfying 1 may be extended at the cost of restricting
those that satisfy 2.
Definition 1. For all interpretations I and J , let I <D J iff:
1. 
2. a
3. A
4. for all   D, if satI()  satJ () then there exists 
5. there exists a   D such that satI()  satJ ().
The subscript D will be omitted when clear from the context. Now I is a model
of Circfix(KB) iff I is a model of S that cannot be further improved (defeasible
inclusions are satisfied as much as possible).
Definition 2 (Model). Let KB = (S,D), an interpretation I is a model of
Circfix(KB) iff I is a (classical) model of S and for all models J of S, J < I.
Example 3. Let KB be the knowledge base of Example 2. According to condition 2 in Def. 1, model improvements cannot change the extension of atomic con-
cepts;3 therefore, if Grant and Deny are empty in a model, then the two defeasible
inclusions of KB cannot possibly force any request to satisfy decision.Grant
nor decision.Deny. In order to enable the two DIs, it suffices to assert that
Grant and Deny are non-empty, by means of an auxiliary role aux and two simple
inclusions:

  D such that 

  

  aux.Grant

  aux.Deny .4

Now the two DIs can fire and, as a consequence, the models of Circfix(KB) are
all the models of the classical inclusions of KB such that for all individuals x
satisfying target.Projects action.Read,
3 Recall that this is one of our requirements, aimed at controlling the side effects of

adding defeasible inclusions to existing classical ontologies.

4 These axioms are usually harmless and can be inserted with the help of automated
tools, that identify which concepts occurring in the right hand side of a DI can
possibly be empty.

EL with Default Attributes and Overriding
 if x satisfies subject.Blacklisted, then x satisfies decision.Deny;
 otherwise, if x satisfies subject.Staff, then x satisfies decision.Grant;
 otherwise, if x satisfies subject.User, then x satisfies decision.Deny. 
The above example shows the need for declaring the non-emptyness of default
attribute ranges, such as B in A n R.B. In theory, such declarations may be
inconsistent with the knowledge base; however, in practice, concept names are
usually meant to be non-empty and, accordingly, concept consistency checking
is a typical step in ontology validation. In other words, we only need to make
explicit some assumptions that are sometimes left implicit; this can be done
automatically for all default attribute ranges B. These additional axioms can
be easily checked for consistency: In EL, if all non-emptyness statements are
individually consistent with the KB, then also the set of all non-emptyness statements is collectively consistent; consequently, no combinatorial problems arise
and consistency checking remains polynomial. It is not difficult to extend this
framework with nominals and concrete datatypes; when default attributes range
over nominals or concrete domains, non-emptyness is implicit in the logic and
no explicit declarations are needed.

2.1 A New Reasoning Task
Now that we have provided constructs for associating concepts to default prop-
erties, we need a suitable reasoning task to retrieve them. For example, from
the formalization of human heart we would like to infer that typical humans
satisfy has heart.LHeart. Subsumption queries, according to [8], are defined
as follows: Circfix(KB) |= C  D iff for all models I of Circfix(KB), C
I  D
I.
This reasoning method is not completely appropriate for our purposes, because
a standard subsumption query A  R.C considers not only the typical members of A, but also the typical members of As subconcepts, where As default
properties may be overridden. In this way, some of As default properties might
not be included in the answer. For instance, in the context of the situs inversus example, it is generally not possible to entail Humans  has heart.LHeart ,
because the members of Humans comprise all the members of SitusInversus,
too, that are forced to satisfy has heart.RHeart, instead. For this reason, in
this work we consider a slightly modified subsumption problem, according to
which a query A  R.C is interpreted as: Do the individuals belonging to A
and no subconcepts of A satisfy R.C?. This is a sort of closed world assump-
tion. It is equivalent to interpreting A  R.C as CWAKB(A)  R.C, where
CWAKB(A) = A  {B | B  NC and A KB B}. In EL, this closure cannot
introduce any inconsistency:
Theorem 1. For all EL knowledge bases KB, CWAKB(A) is satisfiable w.r.t.
KB iff A is satisfiable w.r.t. KB.
CWAKB(A) can be equivalently defined in purely model theoretic terms not
involving  as the set AI that denotes the set of all individuals d  A
I such
that, for all concept names B, d  B
I holds only if A KB B. Then, we define
the modified entailment problem as follows:
?

?

?
Definition 3. Let Circfix(KB) |=cw A  D hold if and only if for all models I
of Circfix(KB), AI  D
Example 4. Extend the knowledge base of Example 1 with   aux.LHeart,
to ensure that there exists at least one normal heart.5 Note that

I.

CWAKB(Human) =Human  SitusInversus  LHeart  RHeart

Heart  Left  Right.

It is not hard to see that Circfix(KB) |=cw Human  has heart.LHeart and
Circfix(KB) |=cw SitusInversus  has heart.RHeart, as desired.

The reader may wonder whether in general the CWA can be too restrictive
and miss valid default properties. This might happen if a concept As extension
could be completely covered by n subconcepts A1, . . . , An sharing a same default
property R.B. In this case, it would be natural to require As prototypical
members to satisfy R.B, as they must necessarily fall into some Ai. However,
in EL such coverings cannot be defined, i.e. there is always a model I in which
there exists d  A
i . Such d need not satisfy R.B, and hence it would

n
i=1 A
be inappropriate to list R.B among the default properties of A.

I \

3 Complexity

3.1 NP-Hardness of the General Case
In general, deciding whether Circfix(KB) |=cw A  D holds is NP-hard. This
can be proved by reducing SAT to our reasoning task. For each clause ci in the
SAT instance introduce two roles Ci and  Ci. Intuitively, the meaning of Ci
and   Ci is: ci is/is not satisfied, respectively. For each propositional symbol pj
introduce two roles Pj and  Pj. Intuitively, Pj and   Pj represent the truth of
the complementary literals pj and pj, respectively. Then, we need two concept
names B0 and B1, and a role  F . Intuitively,   F represents the falsity of the set
of clauses. The semantics of clauses is axiomatized by adding the inclusions

Pj  Ci ,

  Pk  Ci ,

for all disjuncts pj and pk in ci. The space of possible truth assignments is
generated by the following inclusions:

B0 n Pj , B0 n   Pj ,

Pj    Pj   .

All of the above defaults have the same priority. The defeasible inclusions with
the same index j block each other; we make at least one of them active by
assuming B0; this forces a complete truth assignment. Then we introduce a
defeasible inclusion with lower priority:

B0  B1 , B1 n   Ci .

5 See Example 3 for an explanation of this kind of axioms.
?

?

?
This defeasible inclusion assumes that ci is not satisfied. The first three groups
of axioms may defeat this assumption (if the selected truth assignment entails
Ci) thanks to the following disjointness axiom:
Ci    Ci   .

Finally, we need the inclusions   Ci   F to say that the set of clauses is not
satisfied when at least one of the clauses is false. Now let KB denote the above
set of inclusions. It can be proved that the given set of clauses is unsatisfiable
iff:

Circfix(KB) |=cw B0    F .

Consequently:
Theorem 2. Let KB range over EL knowledge bases. The problem of checking
whether Circfix(KB) |=cw C  D is NP-hard, even if C is a concept name and D
an unqualified existential restriction.

3.2 A Polynomial Case

The above reduction of SAT is based on concepts with equally specific, conflicting default properties. In our reference scenarios, we expect such situations to
be symptoms of representation errors. For instance, in modelling prototypical
entities, equally specific and conflicting default properties constitute a contradictory prototype definition. In the access control domain, a class of requests
associated to conflicting decisions with the same priority constitutes an ambiguous policy, with potentially dangerous consequences. In this section, we focus
on a class of KBs called conflict safe, where this kind of conflicts cannot occur.
This restriction turns out to reduce the computational complexity of reasoning.
Intuitively, the idea is that it is possible to check efficiently whether two
defaults 1 and 2 block each other and none of them is more specific than the
other (as in the reduction from SAT). Such conflicts, that make the search space
grow, can be solved (either manually or automatically) by adding more specific
defaults that determine how to resolve the conflict (either in favor of one of the
is or blocking them both). In the following, let KB = (S,D) be an arbitrary
knowledge base. The next definitions are all relative to KB.

We say that two defeasible inclusions are in conflict when they can be simultaneously activated (their premises are mutually consistent) and their conclusions
are mutually inconsistent. The formal definition follows.
Definition 4. Two defeasible inclusions 1 = A1 n R.A
1 and 2 = A2 n

S.A
1 
2 are in conflict, denoted by 1  2, iff A1  A2 KB and R.A
?

?

?
S.A
2 KB.

Since classical subsumption in EL knowledge bases can be computed in polynomial time [2], we have:
Proposition 1. Given an EL knowledge base KB = (S,D) and two defaults
1 and 2 in D, the problem of checking whether 1  2 is in PTIME.

P.A. Bonatti, M. Faella, and L. Sauro

A naive approach to listing all the conflicting pairs, consists in performing a
quadratic number of EL subsumptions. Better strategies can be obtained by
adapting the ideas behind efficient classification algorithms [6, Chap. 9] to reduce
the number of comparisons (the details lie beyond the scope of this paper). In
this section we assume that KB is conflict safe in the following sense:
Definition 5. KB is conflict safe iff whenever two defeasible inclusions 1 =
A1 n R.A
1 and 2 = A2 n S.A
?

?

?
2 are incomparable and in conflict (i.e.
1  2, 2  1 and 1  2), then (i) A1 KB A2, (ii) there exists a concept
name A3 such that A3 KB A1  A2, and (iii) one of the following sets of
inclusions belongs to KB:
 A3 n R.A

1;
 A3 n S.A

2;

 A3 n T and T  R.A
1  and T  S.A
2 .
?

?

?
Note that the above three DIs (whose priority is higher than 1 and 2) correspond to three possible ways of resolving the conflict between 1 and 2, namely,
supporting the conclusion of 1, supporting the conclusion of 2, or blocking
both 1 and 2 . The third option constitutes a possible default conflict resolution strategy that can be performed automatically by introducing fresh roles
T and the corresponding disjointness axioms. Note also that our two running
examples are conflict safe because all conflicting defaults are comparable and
specificity resolves the conflict.

We proceed towards a PTIME algorithm for reasoning with conflict safe KBs.
We first need some preliminary definitions. Given a concept C, SupCls(C) denotes
the set of superclasses of C:

SupCls(C) = {B | C KB B}  {R.A | C KB R.A}.

We write C ; A if C KB R.A for some R, and we denote by
; the transitive
closure of ;. Given a concept C, the operator NE(C) represents the set of
concepts that are forced to be non-empty whenever C is. Notice that this set
includes some concepts that are forced to be non-empty by the ABox in KB,
independently of C.

NG(C) = {C} 

{A | KB |= (R.A)(a)} (2)

aNI,RNR
?

?

?
{A | KB |= A(a)} 
 | A


; A

}.

aNI
{A

(1)

(3)

NE(C) =

ANG(C)

When trying to satisfy a certain defeasible inclusion A1 n R.A2, we have to
check two forms of consistency. First, the addition of an R edge to A2 should
be possible without modifying the interpretation of the concepts names, that
are fixed. This check is realized by the following function Compfix. Second, the
addition of R.A2 should not lead to classical inconsistencies, also considering
other defeasible inclusions that were previously satisfied. This check is realized
by the function Cons.
?

?

?
Algorithm 1:
Data: C, KB = S,D.
X  SupCls(C);
while D =  do

return X;

remove from D an inclusion  = (A1 n R.A2) with maximal priority;
if A1  SupCls(C) and   Compfix(C)  Cons(X) then

X  X  SupCls(R.A2);

}.

For a concept C, Compfix(C) (for fixed-atoms compatible) is the set of defeasible inclusions whose r.h.s. agree with C on the inferred and non-empty concept
names. That is, a defeasible inclusion A1 n R.A2 is in Compfix(C) if and only
if: (i) NE(R.A2)  NE(C) and (ii) for all concept names A  SupCls(R.A2),
it holds A  SupCls(C).
For a set of concepts X, Cons(X) is the set of defeasible inclusions whose r.h.s.
is logically consistent with X. That is, a defeasible inclusion A1 n R.A2 is in

DX D  (R.A2) KB .
Cons(X) if and only if

We claim that Algorithm 1, when invoked over the concept C, returns the set

 | Circfix(KB) |=cw C  C

 that are implied by C under the closed world assumption.

 is the value of the variable X when C

of all concepts C
Theorem 3. Let X be the result of Algorithm 1 on the concept C. If KB is
conflict safe and assertion-free6 then X = {C
Proof. () Let C
  X. If C
 was inserted in line 1 of the algorithm, then C

), and hence Circfix(KB) |=cw C 
is classically implied by C (i.e., C KB C
 was inserted in line 5. Hence, there is a defeasible inclusion
. Otherwise, C

 = (A1 n R.A2) such that A1  SupCls(C),   Compfix(C)  Cons(X
) and
  SupCls(R.A2), where X
 was inserted.
By applying the definition of Compfix, we obtain that (i) NE(R.A2)  NE(C),
and (ii) for all concept names A
Let I be a model of Circfix(KB) with an individual d  CI, we show that d 
I. Assume by contradiction that d  C
I. Since A1 is a classical consequence

of C, we have d  A
  SupCls(R.A2), we have d  (R.A2)I. We

1 . Since C
show that there exists a classical model J of KB that improves I, i.e., J <D I.
To define J , for all S.A3  SupCls(R.A2) (including R.A2 itself), we add to
I an S-arc from d to an individual x  A

3 . The existence of such an individual
is guaranteed by the fact that NE(R.A2)  NE(C). As a result, we have in
particular that d  (R.A2)J . By (ii), all atomic concepts that are classical
consequences of R.A2 are also consequences of C. This, together with the fact
), ensures that J is a classical model of KB. It remains to prove
that   Cons(X
that J <D I. Since I and J only differ on the arcs outgoing from d, we have
6 In DL jargon: the ABox is empty. The reason for considering ABox assertions in the
definition of NG(C) will be clear in the next section, when we deal with instance
checking.

  SupCls(R.A2), it holds A

  SupCls(C).
?

?

?
satI()  satJ () and for all 
we obtain the thesis.

() Let C

, otherwise C

 =  in D, we have satI(

) = satJ (
 be a concept such that Circfix(KB) |=cw C  C

). Therefore,
. Assume by
 does not belong to the output X of the algorithm. Clearly,
contradiction that C
C KB C
 would have been added to X in step 1 of the algorithm.
, there is a defeasible inclusion A1 n R.A2  D
Since Circfix(KB) |=cw C  C
such that A1  SupCls(C) and R.A2 KB C
 Let   D be a defeasible inclusion
with the above property and maximal priority. At some point,  is extracted from
D at step 3 of the algorithm. Since C
 is never added to X, we have that either
  Compfix(C) or   Cons(X
 is the current value of the variable X.
In both cases, it is possible to define a model I of Circfix(KB) with an individual
I such that d  CI \ C
d  

), where X
I, which is a contradiction.

I = {dC}  {dA | A  NE(C)}  {da | a  NI};

We define I as follows.
 
 for each concept name A, A
 for each role name R, we start by putting all edges that are classically
I = {(dX , dY ) | X KB R.Y }  {(da, db) | R(a, b) 
required, i.e., R
KB}  {(da, dX) | KB |= (R.X)(a)}. Moreover, for each R.Y  X, we
add the edge (dC , dY ) to RI. Extra edges starting from individuals other
than dC are not relevant.

I = {dX | X KB A}  {da | KB |= A(a)};

 such that A

If instead   Cons(X

  X, dC  CI \ C

  SupCls(R.A2) and A

  SupCls(C) (hence, dC  A

By construction, I is a classical model of KB and, as C
I.
It remains to prove that there is no model J that improves I by making dC
satisfy .
If   Compfix(C), then either NE(R.A2)  NE(C) or there exists a concept
I).
name A
Since any model J that is comparable with I has the same interpretation for
the concept names, such model cannot have dC  (R.A2)J .
  R.A2 KB . If this inconsistency derives from classical consequences of C (i.e., R.A2  SupCls(C) KB ),
the thesis is obvious. Otherwise, the inconsistency is due to one or more defeasible
inclusions  that were chosen in the previous iterations of the loop, on line 3. For
each such , either its priority is higher than the one of , or it is incomparable with
it. In the first case, clearly it is not worth modifying  in order to improve . In
the latter case, we employ the assumption that KB is conflict safe. In particular,
we have that  and  are incomparable and in conflict. Let  = (A3 n R.A4).
There is a concept name A5 such that A5 KB A1  A3 and the defeasible inclu-
 is higher than
sion 

both  and . Hence, it is not worth modifying 

 = (A5 n R.A4) belongs to KB. Then, the priority of 
?

?

?
DX D

 to improve .

), we have

Theorem 4. Algorithm 1 runs in polynomial time.

Proof. The main cycle of the algorithm performs as many iterations as the number of defeasible inclusions in KB. The polynomial complexity of the auxiliary
operators NE, SupCls, Compfix and Cons derive from the polynomial complexity
of reasoning in EL.
?

?

?
The following example shows how to apply Algorithm 1 to the KB of Example 2.
Example 5. Assume that KB is the knowledge base of Example 3 and we want to
check whether staff members can read project files. First, we have to reduce the
KB in normal form as follows. We introduce six new concept names  SubUsers,
SubStaff, TargProjects, AuxUsers, AuxStaff and ActRead  together with
the following equivalences.

subject.Users  SubUsers
subject.Staff  SubStaff

target.Projects  TargProjects

action.Read  ActRead
SubUsers  TargProjects  AuxUsers
SubStaff  TargProjects  AuxStaff

AuxUsers  ActRead  UserRequest
StaffUsers  ActRead  StaffRequest

The above equivalences replace the original definitions of UserRequest and
StaffRequest. The other inclusions remain unchanged. Recall that the KB
contains

  aux.Grant
  aux.Deny

Algorithm 1 receives as input

C = subject.Staff target.Projects action.Read.

On line 1, the superclasses of C are computed. At that point, X contains, among
the others, StaffPolicy and NE(C) contains Grant. According to specificity, the
first defeasible inclusion removed from D is StaffPolicy n decision.Grant.
Since decision.Grant has no proper superclasses and NE(decision.Grant)
contains only Grant, the condition on line 4 is satisfied and X becomes X 
{decision.Grant}. Thus, we have that
Circfix(KB) |=cw
subject.Staff  target.Projects action.Read  decision.Grant.
Note that the second defeasible inclusion UsersPolicy n decision.Deny does
not belong to Cons(X) since decision.Grant and decision.Deny are

inconsistent.

4 Reasoning about Individuals

The ideas illustrated so far can be naturally extended to reasoning about indi-
viduals, that is, instance checking. This task suffers from the same problem as

P.A. Bonatti, M. Faella, and L. Sauro

{A | KB |= A(a)}.

subsumption: given an assertion A(a), the individual a might well be a member of any subclass of A, which may prevent the default properties of A from
being inherited by a if the standard definition of instance checking [7] is used.
Therefore, some form of closure similar to CWAKB is needed. The closure, in this
case, applies to the atomic concepts that contain the individuals in the ABox,
as collected by the meta-function AtClsKB(a) =
Definition 6. Let KB be any defeasible EL KB. CWA(KB) denotes the knowledge base obtained from KB by adding the assertions CWAKB(AtClsKB(a))(a),
for all individuals a occurring in KB.
Instance checking Circfix(KB) |=cw C(a) is then defined as Circfix(CWA(KB)) |=
C(a) or, in a model-theoretic view:
Definition 7. Circfix(KB) |=cw C(a) if and only if for all models I of Circfix(KB)
if {A  NC | a
Since Circfix preserves the classical semantics of atomic concepts and EL KBs
behave like Horn theories in many respects, it can be proved that:
Proposition 2. For all defeasible EL knowledge bases KB, and all conjunctions of atomic concepts C, Circfix(KB) |=cw C(a) iff CWA(KB) |= C(a) iff
KB |= C(a) .
In other words, membership to atomic concepts and conjunctions thereof is fully
classical. Therefore, in this paper, we focus on the more interesting problem of
inferring the default properties of individuals. The reasoning task of our interest
is the following: Given an individual a and a concept R.A, decide whether

I} = {A  NC | KB |= A(a)}, then a

I  C

I.

I  A

Circfix(KB) |=cw (R.A)(a) .

The NP-hardness proof for subsumption can be easily adapted to instance checking (using the same reduction plus assertion B0(a) and the query Circfix(KB) |=cw
(  F )(a)). So we get:
Theorem 5. Let KB range over EL knowledge bases. The problem of checking
whether Circfix(KB) |=cw C(a) is NP-hard, even if the existential restriction is
unqualified (i.e., A = ).
For conflict safe knowledge bases, the instance checking problem can be decided
using the same algorithm as for subsumption. What we need is to provide as
input a concept which is the conjunction of all the atomic concepts and existential
restrictions which a is classically an instance of. Let GenClsKB(a) be such a
conjunction:

GenClsKB(a) =

{A | KB |= A(a)} 

{R.A | KB |= (R.A)(a)} .
?

?

?
The proof of the following theorem is analogous to Theorem 3 and is left to the
reader.
?

?

?
Theorem 6. Let X be the result of Algorithm 1 on the concept GenClsKB(a). If
KB is conflict safe then Circfix(KB) |=cw (R.A)(a) iff (R.A)  X.
Example 6. Let KB be a knowledge base obtained by adding to Example 4 the
assertions:

Human(Mary)

SitusInversus(John)
|=cw

We want

to check that Circfix(KB)

Recall that KB contains   aux.LHeart, where aux is a new role name.
(has heart.LHeart)(Mary)
and Circfix(KB) |=cw (has heart.RHeart)(John). Let consider the first query,
the input of Algorithm 1 is the concept C = Human. As Human has no proper
superclasses, at line 1 X = {Human}. The only defeasible inclusion to be checked
in lines 2-5 is Human n has heart.LHeart. The set NE(Human) consists of all
the concept names occurring in the knowledge base, has heart.LHeart is consistent with Human and it does not force other concept names to be locally true.
Therefore, the condition in line 4 is satisfied and has heart.LHeart is added
to X as expected.
For the second query, as seen before has heart.RHeart classically derives from
SitusInversus and hence it is added to X directly in line 1. Note that, even if
Human n has heart.LHeart is activated by the fact that SitusInversus KB
Human, the defeasible inclusion Human n has heart.LHeart is not in Cons(X)
because has heart.LHeart and has heart.RHeart are inconsistent.
?

?

?
5 Related Work

DLs have been extended with nonmonotonic constructs such as default rules [20,
3,4], autoepistemic operators [11,12], and circumscription [10,8,7]. An advantage
of circumscription is that nonmonotonic properties apply to all individuals, while
the other approaches restrict nonmonotonic inferences to the individuals that are
explicitly denoted in the ABox, as observed in [8]. While [8] focusses on expressive
circumscribed description logics whose complexity may reach NEXPTIMENP, [10]
and [7] deal with lower-complexity DLs like ALE, DL-lite, and EL; however, upper complexity bounds are all at the second level of the polynomial hierarchy or
harder, while here we have identified a tractable case. The two works [8, 7] consider more general forms of circumscription (with variable concept names) and
reasoning tasks (satisfiability and KB consistency) that we do not consider here.
However, they do not deal with the modified entailment |=cw on which this paper is
focussed. Another recent attempt at low-complexity, nonmonotonic DL reasoning
is based on a modal typicality operator [15, 14], whose extension is maximized to
achieve nonmonotonic inferences. Unfortunately, reasoning is intractable in this
approach.

6 Conclusions and Perspectives

The need for supporting prototypical reasoning and exceptions in DLs can be addressed by restricting the expressiveness of the underlying DL and by selecting an
?

?

?
appropriate form of inference (|=cw). We have shown how to encode a recurring
example originated by the work on biomedical ontologies, and a representative
example related to semantic web policies. The adoption of Circfix makes it possible to add default attributes to the concepts of a given (classical) ontology in a
controlled way, without affecting the extension of atomic concepts. For conflict
safe KBs, the problem of reasoning about default attributes belongs to P; we provided an algorithm based on EL classification problems that enjoy efficient implementations [5]. This is a promising starting point for addressing the performance
challenges posed by the semantic web.

In the full version of this paper we will provide more details on the strategies
for making KBs conflict safe. We are also going to support more general queries
and more constructs from EL++, identifying the tractability threshold.
of variable concept names on the complexity of |=cw .

An interesting direction for further research consists in studying the impact

Acknowledgements. This work is partially supported by the national project
LoDeN (http://loden.fisica.unina.it/). The authors are grateful to the
anonymous referees for their constructive comments that helped improving the
paper.
