Enabling Ontology-Based Access to Streaming

Data Sources

Jean-Paul Calbimonte1, Oscar Corcho1, and Alasdair J.G. Gray2

1 Ontology Engineering Group, Departamento de Inteligencia Artificial,

Facultad de Inform atica, Universidad Polit ecnica de Madrid,

Campus de Montegancedo s/n 28660, Boadilla del Monte, Spain

jp.calbimonte@upm.es, ocorcho@fi.upm.es

2 School of Computer Science, The University of Manchester,

Oxford Road, Manchester M13 9PL, United Kingdom

a.gray@cs.man.ac.uk

Abstract. The availability of streaming data sources is progressively increasing thanks to the development of ubiquitous data capturing technologies such as sensor networks. The heterogeneity of these sources introduces
the requirement of providing data access in a unified and coherent man-
ner, whilst allowing the user to express their needs at an ontological level.
In this paper we describe an ontology-based streaming data access ser-
vice. Sources link their data content to ontologies through s2o mappings.
Users can query the ontology using sparqlStream, an extension of sparql
for streaming data. A preliminary implementation of the approach is also
presented. With this proposal we expect to set the basis for future efforts
in ontology-based streaming data integration.

1 Introduction

Recent advances in wireless communications and sensor technologies have opened
the way for deploying networks of interconnected sensing devices capable of
ubiquitous data capture, processing and delivery. Sensor network deployments
are expected to increase significantly in the upcoming years because of their
advantages and unique features. Tiny sensors can be installed virtually anywhere
and still be reachable thanks to wireless communications. Moreover, these devices
are inexpensive and can be used for a wide variety of applications including
security surveillance, healthcare provision, and environmental monitoring.

As an example, consider a web application which aids an emergency planner
to detect and co-ordinate the response to a forest fire in Spain. This involves
retrieving relevant data from multiple sources, e.g. weather data from aemet
(Agencia Espa nola de Meteorolog a)1, sensor data from sensor networks deployed
in the region, and any other relevant sources of data such as the esa satellite

http://www.aemet.es accessed 15 September 2010.

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 96111, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
imagery providing fire risks2. Typically sources are managed autonomously and
model their data according to the needs of the deployment. To integrate the
data requires linking the sources to a common data model so that conditions
that are likely to cause a fire can be detected, and presented to the user in terms
of their domain, e.g. fire risk assessment. We propose that ontologies can be used
as such a common model. For the scenario presented here, we use an ontology
that extends ontologies from sweet3 and the W3C incubator groups semantic
sensor network ontology4.

The work presented in this paper considers advances done by the semantic
web and database communities over the last decade. On the one hand, the semantic web research has produced mapping languages and software for enabling
ontology-based access to stored data sources, e.g. r2o [1] and d2rq [2]. These
systems provide semantic access to traditional (stored) data sources by providing mappings between the elements in the relational and ontological models
[3]. However, similar solutions for streaming data mapping and querying using
ontology-based approaches have not been explored yet.

On the other hand, the database research community have investigated data
stream processing where the data is viewed as an append-only sequence of tuples.
Systems such as stream [4] and Borealis [5] have focused on query evaluation
and optimisation over streams with high, variable, data rates. Other systems
such as snee [6] and TinyDB [7], have focused on data generated by sensor net-
works, which tends to be at a lower rate, and query processing in the sensor network where resources are more constrained and energy efficiency is the primary
concern. There have also been proposals for query processing over streaming
rdf data [8,9]. However there is still no bridging solution that connects these
technologies coherently in order to answer the requirements of i) establishing
mappings between ontological models and streaming data source schemas, and
ii) accessing streaming data sources through queries over ontology models.

In this paper we focus on providing ontology-based access to streaming data
sources, including sensor networks, through declarative continuous queries. We
build on the existing work of r2o for enabling ontology-based access to relational data sources, and snee for query evaluation over streaming and stored
data sources. This constitutes a first step towards a framework for the integration
of distributed heterogeneous streaming and stored data sources through ontological models. In Section 2 we provide more detailed descriptions of r2o and
stream query processing in order to present the foundations of our approach in
Section 3. In Section 4 we present the syntactic extensions for sparql to enable
queries over rdf streams, and present s2o for stream-to-ontology mappings. The
semantics of these extensions are detailed in Section 5 and a first implementation
of the execution of the streaming data access approach is explained in Section 6.
Related work is discussed in Section 7 and our conclusions in Section 8.

http://dup.esrin.esa.int/ionia/wfa/index.asp accessed 15 September 2010.
http://sweet.jpl.nasa.gov/ accessed 15 September 2010.
http://www.w3.org/2005/Incubator/ssn/wiki/
Semantic Sensor Network Ontology accessed 15 September 2010.

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

2 Background

This section describes the existing work upon which our approach for enabling
ontology-based access to streaming data sources is based, viz. r2o which provides
ontology-based access to stored relational data, and snee, a query processing
engine over relational data streams. A full discussion of related work can be
found in Section 7.

2.1 Ontology-Based Access to Stored Relational Data

The goal of ontology-based data access is to generate semantic web content
from existing relational data sources available on the web [3]. The objective of
these systems is to allow users to construct queries over an ontology (e.g. in
sparql), which are then rewritten into a set of queries expressed in the query
language of the data source (typically sql), according to the specified mappings.
The query results are then converted back from the relational format into rdf,
which is returned to the user. odemapster is one such system which uses r2o
(Relational-to-Ontology) to express the mappings between the relational data
source and the ontology [1].

The mapping definition language r2o defines relationships between a set of
ontologies and relational schemas [1]. The mappings are expressed in terms of
selections and transformations over database relations following a Global-as-
View (GAV) approach [10], and can be created either manually or with the help
of a mapping tool. The resulting mappings are saved as xml which enables them
to be independent of any specific DBMS or ontology language.

Mapping relations to ontologies often requires performing operations on the

relational sources. Several cases are handled by r2o and detailed below.

Direct Mapping. A single relation maps to an ontology class and the attributes of the relation are used to fill the property values of the ontology instances. Each row in the relation will generate a class instance in the
ontology.

Join/Union. A single relation does not correspond alone to a class, but it has
to be combined with other relations. The result of the join or union of the
relations will generate the corresponding ontology instances.

Projection. Not all the attributes of a relation are always required for the
mapping. The unnecessary attributes can simply be ignored. In order to do
so, a projection on the needed attributes can be performed.

Selection. Not all rows of a relation correspond to instances of the mapped
ontology class. A subset of the rows must be extracted. To do so, selection
conditions can be applied to choose the desired subset for the mapping.

It is possible to combine joins, unions, projections and selections for more complex mapping definitions. r2o also enables the application of functions, e.g. con-
catenation, sub-string, or arithmetic functions, to transform the relational data
into the appropriate form for the ontology.
?

?

?
2.2 Querying Relational Data Streams
A relational data stream is an append only, potentially infinite, sequence of
timestamped tuples [11], examples of which include stock market tickers, heart
rate monitors, and sensor networks deployed to monitor the environment. Data
streams can be classified into two categories:
Event-streams. A tuple is generated each time an event occurs, e.g. the sale

of shares, and can have variable, potentially very high, data rates.

Acquisitional-streams. A tuple is measured at a predefined regular interval,

e.g. the readings made by a sensor network.

Users are typically interested in being informed continuously about the most recent stream values, with older tuples being less relevant. Classical database query
processing is not adequate since data must first be stored and then queried with
one-off evaluation. Hence, query languages [12,13] and data stream management
systems (DSMS) [4,5,6,7] have been developed to process continuous long-lived
queries over data streams as tuples arrive.

One existing approach is sneeql, which has a well defined, unified semantics for declarative expressions of data needs over event-streams, acquisitional-
streams, and stored data [12]. sneeql can be viewed as extending sql for
processing data streams. The additional constructs are explained below.
Window. A window over a data stream transforms the infinite sequence of tuples
into a bounded bag of tuples over which traditional relational operators can
be applied. A window is specified as FROM start TO end [SLIDE int unit],
where start and end are of the form NOW  literal and define the range of
the window with respect to the evaluation time. The optional SLIDE parameter
specifies how often windows are evaluated.

Window-to-Stream. Window-to-stream operators are used to convert a stream
of windows into a stream of tuples. sneeql supports three such operators:
RSTREAM for all tuples appearing in the window, ISTREAM for tuples that
have been added since the last window evaluation, and DSTREAM for tuples
that have been deleted since the last window evaluation.

Queries expressed in the sneeql language are optimized for evaluation within
a sensor network over acquisitional-streams by the snee compiler [6]. snee has
recently been extended to enable query evaluation over event-streams either
within the sensor network (in-network query processing) or on computational
hardware outside of the sensor network.

3 Ontology-Based Streaming Data Access

Our approach to enable ontology-based access to streaming data is depicted in
Fig 1. The service receives queries specified in terms of the classes and properties5 of the ontology using sparqlStream, an extension of sparql that supports operators over rdf streams (see Section 4.1). In order to transform the
5 We use the owl nomenclature of classes, and object and datatype properties for

naming ontology elements.

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

Fig. 1. Ontology-based streaming data access service

sparqlStream query, expressed in terms of the ontology, into queries in terms
of the data sources, a set of mappings must be specified. These mappings are
expressed in s2o, an extension of the r2o mapping language, which supports
streaming queries and data, most notably window and stream operators (see
Section 4.2). This transformation process is called query translation, and the
target is the continuous query language sneeql, which is expressive enough to
deal with both streaming and stored sources.

After the continuous query has been generated, the query processing phase
starts, and the evaluator uses distributed query processing techniques [14] to
extract the relevant data from the sources and perform the required query pro-
cessing, e.g. selection, projection, and joins. Note that query execution in sources
such as sensor networks may include in-network query processing, pull or push
based delivery of data between sources, and other data source specific settings.
The result of the query processing is a set of tuples that the data translation
process transforms into ontology instances.

This approach requires several contributions and extensions to the existing technologies for continuous data querying, ontology-based data access, and
sparql query processing. This paper focuses on a first stage that includes the
process of transforming the sparqlStream queries into queries over the streaming
data sources using sneeql as the target language. The following sections provide
the syntax and semantics for the querying of streaming rdf data and the mappings between streaming sources and an ontology. We will then provide details
of an actual implementation of this approach.

4 Query and Mapping Syntax

In this section we introduce the sparqlStream query language, an extension to
sparql for streaming rdf data, which has been inspired by previous proposals such as c-sparql [9] and sneeql [12]. However, significant improvements
?

?

?
have been made that correct the types supported and the semantics of windowing operations, which can be summarised as: (i) we only support windows
defined in time, (ii) the result of a window operation is a window of triples, not a
stream, over which traditional operators can be applied, as such we have added
window-to-stream operators, and (iii) we have adopted the sparql 1.1 definition for aggregates. We also present s2o for the definition of stream-to-ontology
mappings.

4.1 SPARQLStream

Just as in c-sparql we define an rdf stream as a sequence of pairs (Ti, i)
where Ti is an rdf triple si, pi, oi and i is a timestamp which comes from a
monotonically non-decreasing sequence. An rdf stream is identified by an iri,
which provides the location of the data source6.

Window definitions are of the form FROM Start TO End [STEP] [Literal],
where the Start and End are of the form NOW or NOW  Literal, and Literal
represents some number of time unit (DAYS, HOURS, MINUTES, or SECONDS)7.
The optional STEP indicates the gap between each successive window evaluation.
Note, if the size of the step is smaller than the range of the window, then the
windows will overlap, if it coincides with the size of the window then every triple
will appear in one and only one window, and if the step is larger than the range
then the windows sample the stream. Also note that the definition of a window
can be completely in the past. This is useful for correlating current values on a
stream with values that have previously occurred.

The result of applying a window over a stream is a timestamped bag of triples
over which conjunctions between triple patterns, and other classical operators
can be evaluated. Windows can be converted back into a stream of triples by
applying one of the window-to-stream operators in the SELECT clause: ISTREAM
for returning all newly inserted answers since the last window, DSTREAM for
returning all deleted answers since the last window, and RSTREAM for returning
all answers in the window.

Listing 1 shows a complete sparqlStream query which, every minute, returns
the average of the last 10 minutes of wind speed measurements for each sensor,
if it is higher than the average speed from 2 to 3 hours ago.

Note, sparqlStream only supports time-based windows. c-sparql also has the
notion of a triple-based window. However, such windows are problematic since
the number of triples required to generate an answer may be greater than the
size of the triple window. For example, consider a window size of 1 triple and
the graph pattern from the example query in Listing 1. Only one of the triples
that form the graph pattern would be kept by the window, and hence it would
not be possible to compute the query answer.

6 Note in our work the iris identify virtual rdf streams since they are derived from

7 Note that the parser will also accept the non-plural form of the time units and is

the streaming data sources.

not case sensitive.

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

PREFIX f i r e : <h t t p : / /www . s e m s o r g r i d 4 e n v . eu#>
PREFIX r d f : <h t t p : / /www . w3 . o r g /1999/02/22 r d fs y n t a xn s#>
SELECT RSTREAM ? WindSpeedAvg
FROM STREAM <www . s e m s o r g r i d 4 e n v . eu / S e n s o r R e a d i n g s . s r d f > [FROM NOW  10
FROM STREAM <www . s e m s o r g r i d 4 e n v . eu / S e n s o r A r c h i v e R e a d i n g s . s r d f > [FROM NOW  3
WHERE {

MINUTES TO NOW STEP 1 MINUTE]
HOURS TO NOW 2 HOURS STEP 1 MINUTE]

{

SELECT AVG( ? s p e e d ) AS ? WindSpeedAvg

{

GRAPH <www . s e m s o r g r i d 4 e n v . eu / S e n s o r R e a d i n g s . s r d f > {
? WindSpeed a f i r e : WindSpeedMeasurement ;

f i r e : h a s Sp eed ? s p e e d ; }

} GROUP BY ? WindSpeed

}
{

SELECT AVG( ? a r c h i v e d S p e e d ) AS ? Wi n d Sp eed H i s to r y Av g

{

GRAPH <www . s e m s o r g r i d 4 e n v . eu / S e n s o r A r c h i v e R e a d i n g s . s r d f > {

? ArchWindSpeed a f i r e : WindSpeedMeasurement ;
f i r e : h a s Sp eed ? a r c h i v e d S p e e d ;

}

} GROUP BY ? ArchWindSpeed

}
FILTER ( ? WindSpeedAvg > ? Wi n d Sp eed H i s to r y A v g )

}

Listing 1. An example sparqlStream query which every minute computes the average
wind speed measurement for each sensor over the last 10 minutes if it is higher than
the average of the last 2 to 3 hours

4.2 S2O: Expressing Stream-to-Ontology Mappings

The mapping document that describes how to transform the data source elements
to ontology elements is written in the s2o mapping language, an extended version
of r2o [1]. An r2o mapping document includes a section that describes the
database relations, dbscehma-desc. In order to support data streams, r2o has
been extended to also describe the data stream schema. A new component called
streamschema-desc has been created, as shown in the top part of Listing 2.

The description of the stream is similar to a relation. An additional attribute
streamType has been added, it denotes the kind of stream in terms of data acqui-
sition, i.e. event or acquistional. In the same way as key and non-key attributes
are defined, a new timestamp-desc element has been added to provide support for
declaring the stream timestamp attribute. Since s2o extends r2o, relations can
also be specified using the existing r2o mechanism. For the class and property
mappings, the existing r2o definitions can be used for stream schemas just as
it was for relational schemas. This is specified in the conceptmap-def element as
shown in the bottom part of Listing 2.

In addition, although they are not explicitly mapped, the timestamp attribute
of stream tuples could be used in some of the mapping definitions, for instance in
the uri construction (uri-as element). Finally, a sparqlStream streaming query
requires an rdf stream to have an iri identifier. s2o creates a virtual rdf stream
?

?

?
streamschemad e s c

name M e t e o S e n s o r s
hass tr e a m Sen s o r Wi n d
streamType p u s h ed
d o cu me n ta ti o n Wind m ea s u r em en ts 
k e y c o ld e s c m e a s u r e m e n t I d
timestampd e s c measureTime
n o n k e yco ld e s c m ea s u r eSp eed
n o n k e yco ld e s c m e a s u r e D i r e c t i o n

columnType d a t e t i m e

columnType i n t e g e r

columnType f l o a t

columnType f l o a t

. . .
conceptmapd e f Wind

v i r t u a l S t r e a m <h t t p : / / s e m s o r g r i d 4 e n v . eu / S e n s o r R e a d i n g s . s r d f >
u r i a s
a p p l i e s i f
d e s c r i b e dby

c o n c a t ( Sen s o r Wi n d . m ea s u r em en tID )
<conde x p r>
a t t r i b u t e m a pd e f h a s Sp eed

v i r t u a l S t r e a m h t t p : / / s e m s o r g r i d 4 e n v . eu / S e n s o r R e a d i n g s . s r d f >
o p e r a t i o n c o n s t a n t

hascolumn Sen s o r Wi n d . m ea s u r eSp eed

Listing 2. An example s2o declaration of a data stream schema and mapping from a
stream schema to an ontology concept

and its iri is specified in the s2o mapping using the virtualStream element. It
can be specified at the conceptmap-def level or at the attributemap-def level.

5 Semantics of the Streaming Extensions

Now that the syntax of sparqlStream and s2o have been presented, we define
their semantics.

5.1 SPARQLStream Semantics
The sparql extensions presented here are based on the formalisation of P erez
et al. [15]. An rdf stream S is defined as a sequence of pairs (T, ) where T is
a triple s, p, o and  is a timestamp in the infinite set of timestamps T. More
formally,

S = {(s, p, o, ) | s, p, o  ((I  B)  I  (I  B  L)),   T},

where I, B and L are sets of iris, blank nodes and literals. Each of these pairs
can be called a tagged triple.
We define a stream of windows as a sequence of pairs (, ) where  is a set
of triples, each of the form s, p, o, and  is a timestamp in the infinite set of
timestamps T, and represents when the window was evaluated. More formally,
we define the triples that are contained in a time-based window evaluated at
time   T, denoted  , as

ts,te,(S) = {s, p, o | (s, p, o, i)  S, ts  i  te}


J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

where ts, te define the start and end of the window time range respectively, and
may be defined relative to the evaluation time . Note that the rate at which
windows get evaluated is controlled by the STEP defined in the query, which is
denoted by .

We define the three window-to-stream operators as

RStream(( , )) = {(s, p, o, ) | s, p, o  }

IStream(( , ), (,   )) = {(s, p, o, ) | s, p, o   ,s, p, o / }
DStream(( , ), (,   )) = {(s, p, o, ) | s, p, o /  ,s, p, o  }
where  is the time interval between window evaluations. Note that RStream
does not depend on the previous window evaluation, whereas both IStream and
DStream depend on the contents of the previous window.

We have provided a brief explanation of the semantics of sparqlStream. This
is particularly useful in the sense that users may know what to expect when they
issue a query using these new operators. However, as the actual data source is not
an rdf stream but a sensor network or an event-based stream, e.g. exposed as
a sneeql endpoint, we need to transform the sparqlStream queries into sneeql
queries. The next section describes the semantics of the transformation from
sparqlStream to sneeql using the s2o mappings.

5.2 S2O Semantics
In this section we will present how we can use the s2o mapping definitions
to transform a set of conjunctive queries over an ontological schema, into the
streaming query language sneeql that is used to access the sources. This work
is based on extensions to the odemapster processor [1] and the formalisation
work of Calvanese et al. [16] and Poggi et al. [17].

A conjunctive query q over an ontology O can be expressed as:

q(x)  (x, y)
?

?

?
Pi, with Pi

i=1...k

(x, y) :

Ci(x), C is an atomic class.

Ri(x, y), R is an atomic property.
x = y

x, y are variables either in x, y or constants.

where x is a tuple of distinct distinguished variables, and y a tuple of nondistinguished existentially quantified variables. The answer to this query consists
in the instantiation of the distinguished variables [16]. For instance consider:
q1(x)  W indSpeedM easurement(x)  measuredBy(x, y)  W indSensor(y)
It requires all instances x that are wind speed measurements captured by wind sen-
sors. In this example x is a distinguished variable and y a non-distinguished one.
?

?

?
Concerning the formal definition of the query answering, let I = (

I to each constant, a subset of 

The query has three atoms: W indSpeedM easurement(x), measuredBy(x, y),
and W indSensor(y).
, I) be an
I is the interpretation domain and I the interpretation
interpretation, where 
I to each
function that assigns an element of 
I  
I to each property of the ontology. Given a query
class and a subset of 
q(x)  (x, y) the answer to q is the set q
I that
substituted to x, make the formula y.(x, y) true in I [16,17,18]. Now we can
introduce the definition of the mappings. Let M be a set of mapping assertions
of the form:

x of tuples c  

I    

 ; 

where  is a conjunctive query over the global ontology O, formed by terms of
the form C(x), R(x, y), A(x, z), with C, R, and A being classes, object properties
and datatype properties respectively in O; x, y being object instance variables,
and z being a datatype variable.  is a set of expressions that can be translated
to queries in the target continuous language (e.g. sneeql) over the sources.

A mapping assertion C(f Id

C (x)) ; S1,...,Sn(x) describes how to construct
the concept C from the source streams (or relations) S1, . . . , Sn. The function
C creates an instance of the class C, given the tuple x of variables returned
f Id
by the  expression. More specifically this function will construct the instance
identifier (uri) from a set of attributes from the streams and relations. In this
case the expression  has a declarative representation of the form:

S1,...,Sn(x) = y.pP roj

S1,...,Sn(x)  pJoin

S1,...,Sn(v)  pSel

S1,...,Sn(v)

where v is a tuple of variables in either x, y. The term pJoin denotes a set of join
conditions over the streams and relations Si. Similarly the term pSel represents a
set of condition predicates over the variables v in the streams Si (e.g. conditions
using <,,, >, = operators).
A mapping assertion R(f Id

C2(x2)) ; S1,...,Sn(x1, x2) describes how
to construct instances of the object property R from the source streams and
relations Si. The declarative form of  is:

C1(x1), f Id

S1,...,Sn(x1, x2) = y.S1,...,Sk(x1)  Sk+1,...,Sn(x2)  pJoin

S1,...,Sn(v)

Finally an expression A(f Id

where S1,...,Sk , Sk+1,...,Sn describe how to extract instances of C1 and C2 from
the streams S1, . . . , Sk and Sk+1, . . . , Sn respectively. The term pJoin is the set
of predicates that denotes the join between the streams and relations S1, . . . , Sn.
A (z)) ; S1,...,Sn(x, z) describes how to
construct instances of the datatype property A from the source streams and
relations S1, . . . , Sn. The function f T rf
executes any transformation over the
tuple of variables z to obtain the property value (e.g. arithmetic operations, or
string operations). The declarative form of  in this case is:

C (x), f T rf

S1,...,Sn(x, z) = y.S1,...,Sk(x)  Sk+1,...,Sn(z)  pJoin

S1,...,Sn(v)

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

The definition follows the same idea as the previous one. The variables of z will
contain the actual values that will be used to construct the datatype property
value using the function f T rf
A .

When a conjunctive query is issued against the global ontology, the processor first parses it and transforms it into an abstract syntax tree and then uses
the expansion algorithm described in [1] (that is based on the PerfectRef algorithm of [16]) to produce an expanded conjunctive query based on the TBox of
the ontology. Afterwards the rewritten query can be translated to an extended
relational algebra.

A query QO(x)[ts, te, ] is a conjunctive query with a window operator (where
ts, te are the start and end points of the window range and  is the slide) in
order to narrow the data set according to a given criteria. For a query:

QO(x)[ts, te, ] = (C1(x)  R(x, y)  A(x, z))[ts, te, ]
the translation is given by (), following the mapping definition:

(S1,...,Sn(x)[ts, te, ]) = pP roj (1pJoin (pSel(ts,te,S1), . . .
, pSel(ts,te,Sn)))

The expression denotes first a window operation ts,te, over the relations or
streams S1, . . . , Sn, with ts, te, and  being the time range and slide. A selection pSel is applied over the result, according to the conditions defined in the
mapping. A multi-way join 1pJoin is then applied to the selection, also based
on the corresponding mapping definition. Finally a projection pP roj is applied
over the results. For any conjunctive query with more atoms, the construction
of the algebra expression will follow the same direct translation using the GAV
approach.

6 Implementation and Walkthrough

The presented approach of providing ontology-based access to streaming data
has been implemented as an extension to the odemapster processor [1]. This
implementation generates sneeql queries that can be executed by the streaming
query processor.

w i n d s a m p l e s: ( sensorId INT PK , ts DATETIME PK , speed FLOAT , d i r e c t i o n FLOAT )
sensors : ( sensorId INT PK , s e n s o r N a m e CHAR (45) , lat FLOAT , long FLOAT )

Listing 3. Relational schema of the data source

Consider the motivating example where a sensor network generates a stream
windsamples of wind sensor measurements. The associated stored information
about the sensors, e.g. location and type, are stored in a relation sensors. The
schemas are presented in Listing 3. Also consider the following ontological view:
?

?

?
conceptmapd e f WindSpeedMeasurement

v i r t u a l S t r e a m <h t t p : / / s e m s o r g r i d 4 e n v . eu / S e n s o r R e a d i n g s . s r d f >
u r i a s

c o n c a t (  h t t p : / / s e m s o r g r i d 4 e n v . eu / WindSpeedMeasur ement

 , w i n d s a m p l e s .

s e n s o r I d , w i n d s a m p l e s . t s )

d e s c r i b e dby

a t t r i b u t e m a pd e f h a s Sp eed

o p e r a t i o n c o n s t a n t

hascolumn w i n d s a m p l e s . s p e e d

d b r e l a t i o n m a pd e f

i s P r o d u c e d B y

to C o n ce p t S e n s o r
j o i n s v i a

c o n d i t i o n e q u a l s

hascolumn s e n s o r s . s e n s o r I d
hascolumn w i n d s a m p l e s . s e n s o r I d

conceptmapd e f S e n s o r

u r i a s
d e s c r i b e dby

c o n c a t (  h t t p : / / s e m s o r g r i d 4 e n v . eu / S e n s o r
a t t r i b u t e m a pd e f h a s S e n s o r I d

 , s e n s o r s . s e n s o r I d )

o p e r a t i o n c o n s t a n t

hascolumn s e n s o r s . s e n s o r I d

Listing 4. s2o mapping from the data stream windsamples to the ontology concepts
W indSpeedM easurement

SpeedM easurement  M easurement

W indSpeedM easurement  SpeedM easurement

W indDirectionM easurement  M easurement

SpeedM easurement  hasSpeed

M easurement  isP roducedBy.Sensor

Sensor  hasN ame

We can define an s2o mapping that splits the windsamples stream tuples into instances of two different concepts W indSpeedM easurement and WindDirection-
Measurement. Listing 4 is an extract of the s2o mapping document concerning
the W indSpeedM easurement. The mapping extract defines how to construct
the W indSpeedM easurement and Sensor class instances from the windsamples
stream and the sensors table: W indSpeedMeasurement ; windsamples and
Sensor ; sensors. In the case of the W indSpeedM easurement the function
W indSpeedMeasurement produces the uris of the instances by concatenating the
f Id
sensorId and ts attributes. Now we can pose a query over the ontology using
sparqlStream, for example to obtain the wind speed measurements taken in the
last 10 minutes (See the query in Listing 5).

A class query atom W indSpeedM easurement(x) and a datatype property
atom hasSpeed(x, z) can be extracted from the sparqlStream query. The window specification [ts = NOW  10, te = NOW,  = 1] is also obtained8. The s2o
mapping defines that W indSpeedM easurment instances are generated based on

8 For the simplicity of presentation, we assume that the system rewrites all time
specifications to minutes. The implemented system uses milliseconds as the common
time unit.

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

PREFIX f i r e : <h t t p : / /www . s s g 4 e n v . eu#>
PREFIX r d f : <h t t p : / /www . w3 . o r g /1999/02/22 r d fs y n t a xn s#>
SELECT RSTREAM ? s p e e d
FROM STREAM <www . s s g 4 e n v . eu / S e n s o r R e a d i n g s . s r d f > [FROM NOW  10 MINUTES TO
WHERE {

NOW STEP 1 MINUTE]

? WindSpeed a f i r e : WindSpeedMeasurement ;

f i r e : h a s Sp eed ? s p e e d ;

}

Listing 5. sparqlStream query which every minute returns the wind speed for the last
ten minutes

SELECT RSTREAM concat (  http :// ssg4env . eu # W i n d S p e e d M e a s u r e m e n t , w i n d s a m p l e s.

sensorId , w i n d a m p l e s. ts ) AS id , w i n d s a m p l e s. speed AS speed
FROM w i n d s a m p l e s[ FROM NOW - 10 MINUTES TO NOW SLIDE 1 MINUTE ];

Listing 6. The sneeql query that is generated for the input query in Listing 5

the sensorId and ts attributes of the windsamples stream, using a concatenation function to generate each instance uri. Similarly the s2o mapping defines
that hasSpeed properties are generated from the values of the speed attribute
of the windsamples stream. The processor will evaluate this as:

(windsamples(xsensorId, xts, zspeed)[now  10, now, 1]) =
sensorId,ts,speed(now10,now,1(windsamples))

In this case no joins and other selection conditions are needed, and only one stream
has to be queried to produce the results. The query generated in the sneeql language is shown in Listing 69. The relational answer stream that results from evaluating the query in Listing 6 are transformed by the Data Transformation module
depicted in Figure 1 according to the s2o mappings. This results in a stream of
tagged triples which are instances of the class W indSpeedM easurement.

7 Related Work

Several systems exist to provide ontology-based access to stored data, mainly in
the form of relational databases, as described in [3].

A simple approach is to first generate a syntactical translation of the database
schema to an ontological representation. Although the resulting ontology has no
real semantics, it may be argued that this is a first step through an ontology
model and could later be mapped to a real domain ontology [18]. Virtuoso [19]
and d2rq [2], like r2o, use mappings between the source relational schema to
rdf ontologies enabling users to issues queries over a semantically rich domain
ontology. The expressiveness of the queries supported by these systems is limited
to conjunctive queries, and none of the approaches takes into account streaming
data and continuous queries.

9 Although the current available implementation of the SNEE processor lacks the

concat operator, we include the sample query in its complete form here.
?

?

?
Several stream processing and querying engines have been built in the last
decade and can be grouped in two main areas: event stream systems (e.g. Au-
rora/Borealis [5], stream [4], TelegraphCQ [20]), and acquisitional stream systems (e.g. TinyDB [7], snee [6], Cougar [21]). For the first, the stream system
does not have control over the data arrival rate, which is often potentially high
and usually unknown and the query optimization goal is to minimize latency.
For acquisitional streams, it is possible to control when data is obtained from
the source, typically a sensor network, and the query optimisation goal is to
maximize network lifetime. All these systems have their own continuous query
language, generally based on sql, although most of them share the same fea-
tures. cql (Continuous Query Language) [13] is the best known of these lan-
guages, but there is still no common standard language for stream queries. The
sneeql [12] language for querying streaming data sources is inspired by cql,
but it provides greater expressiveness in queries, including both event and acquisitional streams, and stored extents. Our work does not aim to improve on
relational stream query processing, but to enable these systems to be accessible
via ontology-based querying.

Finally, there are two existing proposals for extending sparql with streambased operators: streamingsparql [8] and c-sparql [9]. Both languages introduce extensions for the support of rdf streams, and both define time-based
and triple-based window operators where the upper bound is fixed to the current evaluation time. The sparqlStream windowing operator enables windows
to be defined in the past so as to support correlation with historic data. We
have not included triple-based windows in sparqlStream due to the problems
with their semantics, discussed in Section 4.1. Window-to-stream operators are
also missing in both existing approaches, which provides ambiguous semantics
for the language. In sparqlStream the result of a window operator is a bag to
triples over which traditional operators can be applied. We have introduced three
window-to-stream operators inspired by sneeql and cql. The aggregate semantics introduced in c-sparql follow an approach of extending the data, which
differs from standard aggregation semantics of summarising the data. We have
opted to support the aggregation semantics being defined for sparql 1.1 [22],
which summarise the data.

Table 1. Summary of key contributions

Extension Base Approach Summary

sparqlStream sparql 1.1 Window definitions with variable upper boundary

s2o

r2o

Window-to-stream operators
Stream definitions in mapping
Streaming data types
Virtual rdf stream iris

odemapster Translation of sparqlStream queries into sneeql

J.-P. Calbimonte, O. Corcho, and A.J.G. Gray

8 Conclusions and Future Work

We have presented an approach for providing ontology-based access to streaming data, which is based on sparqlStream, a sparql extension for rdf streams,
and s2o, an extension to r2o for expressing mappings from streaming sources
to ontologies. We have shown the semantics of the proposed extensions and the
mechanism to generate data source queries from the original ontological queries
using the mappings. The case presented here generated sneeql queries but the
techniques are independent of the target stream query language, although issues of stream data model and language evaluation semantics would need to be
considered for each case. Finally the prototype implementation, which extends
odemapster, has shown the feasibility of the approach. This work constitutes a
first effort towards ontology-based streaming data integration, relevant for supporting the increasing number of sensor network applications being developed
and deployed in the recent years. The extensions presented in this paper can be
summarised in Table 1.

Although we have shown initial results querying the underlying snee engine
with basic queries, we expect to consider in the near future more complex query
expressions including aggregates, and joins involving both streaming and stored
data sources. Another important strand of future work is the optimization of
distributed query processing [14] and the streaming queries [5,6]. It is also our
goal to provide a characterization of our algorithms. In the scope of a larger
streaming and sensor networks integration framework, we intend to achieve the
following goals: i) integrating streaming and stored data sources through an ontological unified view; ii) combining data from event-based and acquisition-based
streams, and stored data sources; iii) considering quality-of-service requirements
for query optimization and source selection during the integration.

Acknowledgments. This work has been supported by the European Commission project SemSorGrid4Env (FP7-223913). We also thank Alvaro A. A.
Fernandes, Ixent Galpin, and Norman W. Paton, from the University of Manch-
ester, for their valuable ideas and suggestions.
