Semantic Recognition of Ontology Refactoring

Gerd Gr oner, Fernando Silva Parreiras, and Steffen Staab

WeST  Institute for Web Science and Technologies

University of Koblenz-Landau

{groener,parreiras,staab}@uni-koblenz.de

Abstract. Ontologies are used for sharing information and are often collaboratively developed. They are adapted for different applications and
domains resulting in multiple versions of an ontology that are caused
by changes and refactorings. Quite often, ontology versions (or parts of
them) are syntactical very different but semantically equivalent. While
there is existing work on detecting syntactical and structural changes
in ontologies, there is still a need in analyzing and recognizing ontology
changes and refactorings by a semantically comparison of ontology ver-
sions. In our approach, we start with a classification of model refactorings
found in software engineering for identifying such refactorings in OWL
ontologies using DL reasoning to recognize these refactorings.

1 Introduction

Ontologies share common knowledge and are often developed in distributed en-
vironments. They are combined, extended and reused by other users and knowledge engineers in different applications. In order to support reuse of existing
ontologies, remodeling and changes are unavoidable and lead to different ontology versions. Quite often, ontology engineers have to compare different versions
and analyze or recognize changes. In order to improve and ease the understandability of changes, it is more beneficial for an engineer to view a more abstract
and high-level change description instead of a large number of changed axioms
(elementary changes) or ontology version logs like in [1]. Combinations of elementary syntactic changes into more intuitive change patterns are described as
refactorings [2] or as composite changes [3].

However, the recognition of refactorings (or changes in general) is difficult due
to the variety of possible changes that may be applied to an ontology. Especially
if the comparison of different ontology versions is not only realized by a pure
syntactical comparison, e.g. a comparison of triples of an ontology, but rather
by a semantic comparison of entities in an ontology and their structure.

The need to detect high-level changes is already stated in [1,4,5]. High-level
understanding of changes provides a foundation for further engineering support
like visualization of changes and extended pinpointing focusing on entailments
of refactorings rather than individual axiom changes. In order to tackle the
described problem, the following issues need to be thoroughly investigated: (i) A
high-level categorization of ontology changes like the well established refactoring

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 273288, 2010.
c Springer-Verlag Berlin Heidelberg 2010

G. Gr oner, F. Silva Parreiras, and S. Staab

patterns in software engineering. (ii) An automatic recognition of refactorings
for OWL ontologies that goes beyond mere syntactic comparisons.

The recognition of refactorings is a challenging task due to the variety of
possible changes and insufficient means for a semantic comparison of ontology
versions. In particular, we identify the issue that we require a semantic comparison of different versions of classes rather than their syntactical comparison.
Semantic comparison allows for taking available background knowledge into account while abstracting from elementary changes.

There are different approaches that detect ontology changes by a syntactical
comparison like in [4,6] or the combination of adding and deleting RDF-triples
to high-level changes in [5]. A structural comparison using matching algorithms
is considered in [7]. More related to our research is the work on version reasoning
for ontologies in [8,9]. However, their focus is on integrity checking, entailment
propagation between versions and consistency checking of ontology mappings.

In this paper, we tackle the problem of refactoring recognition using description logics (DL) reasoning in order to semantically compare different versions of
an OWL DL ontology. We apply the semantic comparison in heuristic algorithms
to recognize refactoring patterns. Extrapolating from [2,3] we have defined different refactoring patterns of how OWL ontologies may evolve.

We organize this paper as follows. Sect. 2 motivates the problem of schema
changes and describes shortcomings of existing approaches. In Sect. 3, we give
an overview of the considered refactoring patterns and describe in detail two of
them. The comparison of ontology versions and the recognition of the refactoring
patterns using DL reasoning is demonstrated in Sect. 4 and 5. The evaluation is
given in Sect. 6. We analyze related work in Sect. 7, followed by the conclusion.

2 An Ontology Refactoring Scenario

In order to clarify the problem we tackle, we start with a motivating example that
highlights the problem followed by some argumentation in favor of a semantic
version comparison for recognizing refactorings.

2.1 Motivating Example
In this section, we consider an ontology change from version V to V ( including
multiple elementary changes. An example is displayed in Fig. 1 and 2. Snippets of
the corresponding ontology versions are depicted below. In order to highlight the
changed axioms in the example, we mark axioms that are deleted from version
V with (d) and axioms that are added are marked with (a) at the end of the line.
P erson, Employee, P roject, ContactData and Department are OWL classes,
Employee is a subclass of P erson. The properties name, SSN, telephone and
address are datatype properties with range string and project, department and
contact are object properties.
We recognize three refactorings from version V to V (. First: the pattern Move
Of Property moves a datatype property restriction SSN from class Employee to
?

?

?
 
?

?

?
Employee  P erson
Employee   project.P roject (d)
Employee   department.Department
Employee  =1 SSN.string (d)

P erson   name.string
P erson   address.string (d)
P erson   telephone.string (d)

Employee  P erson
Employee   department.Department
Employee  1SSN.string (a)

P erson   name.string
P erson  1 SSN.string (a)
P erson   contact.ContactData (a)

ContactData   telephone.string (a)
ContactData   address.string (a)
Department   project.P roject (a)

Fig. 1. Ontology Version V

Fig. 2. Ontology Version V 

its superclass P erson. In version V there are implicitly two cardinality restrictions in the property restriction =1 SSN.string. This is semantically equivalent with the restrictions 1 SSN.string and 1 SSN.string. The datatype
property restriction with the maximal cardinality restriction is moved to the
superclass P erson. Second: Extract Class moves the datatype properties address
and telephone to a newly created class ContactData that does not contain further properties. In version V ( the class P erson has a further object property
restriction on contact with range ContactData. Third: Move Of Property moves
an object property project from the class Employee to the class Department.
As demonstrated in the ontology excerpt below the diagrams, the refactorings are syntactically represented by a number of added and deleted axioms from version V to V (. E.g., the movement of the property SSN from
Employee to its superclass is represented in the ontology by the deleted axiom
Employee  =1 SSN.string and the added axioms P erson  1 SSN.string
and Employee  1 SSN.string. In order to improve the understanding and
recognition of changes between ontology versions, we argue that it is more intuitive for the ontology engineer to characterize changes at a higher abstraction
level like by the recognition of refactorings instead of indicating a large collection of added and deleted axioms. For instance, consider the second mentioned
refactoring which extracts the datatype properties address and telephone to the
newly created class ContactData. Obviously, such a high-level change characterization is more intuitive for an ontology engineer than a listing of changed
axioms. In this refactoring at least two axioms are deleted and three axioms are
added to the ontology.

G. Gr oner, F. Silva Parreiras, and S. Staab

2.2 Discussion of Shortcomings

We already argued for the need of a semantic comparison of the versions rather
than a syntactic or a purely structural comparison. This is mainly due to the
various possibilities of defining classes in OWL compared to RDF(S) like class
definitions using intersection, union or property restrictions. We give two examples of shortcomings for syntactical and structural comparisons.

Consider again the third refactoring (Move Of Property) from Fig. 1 and 2.
Breaking down this refactoring to axiom changes, we would delete the axiom Employee   project.P roject and add the axiom Department 
 project.P roject. Now, we slightly extend this refactoring. Suppose there are
two subclasses of Department, InternalDepartment and ExternalDepartment
and the property restriction  project.P roject is moved to both subclasses
InternalDepartment and ExternalDepartment rather than to the superclass
Department. In this case, the ontology contains two new axioms and one is
still removed. If there is a further axiom in the ontology describing that each
department is either an internal or an external department (Department 
InternalDepartment  ExternalDepartment) and there is no other depart-
ment, we can conclude that after the refactoring project is still a property of
Department. Hence, we identify a refactoring that moves a property (project)
from a class to another class (Department) but without changing an axiom that
contains the class itself.

As a second example, we demonstrate shortcomings of structural (and frame-
based) comparisons which compare classes and their connections, i.e. domain
and range of properties. Consider again the move of the datatype property SSN
with maximal cardinality restriction from the class Employee to P erson. Here,
we compare the class Employee in both versions. The cardinality restriction that
restricts the class Employee to exactly one SSN is explicitly stated in version V .
Semantically, in version V ( the restriction for class Employee is exactly the same
due to inheritance and the conjunction of the minimal and maximal restrictions
which also results in exactly one SSN property. This equivalence of the class
Employee in both versions is not detected by a purely structural comparison.

3 Modeling and Categorizing Refactoring Patterns

A first step towards the recognition of refactoring patterns is the categorization of well-known patterns, adopted from [2] and also presented as composite
changes for ontology evolution in RDF(S) [3]. Hereafter, we demonstrate two
such refactoring patterns in detail.

3.1 Modeling Foundations and Assumptions

For a more compact notation, we describe a class in version V with C and we
use C( to refer to this class in version V (. The class of the range of an object
property restriction is called the referenced class. A refactoring pattern is an
?

?

?
abstract description of an ontology change or evolution that is applied to realize
a certain ontology remodeling. The kind of remodeling is mainly a collection of
best practise ontology remodeling steps. A refactoring is an instantiation of a
refactoring pattern, i.e. a concrete change of an ontology.

Our recognition approach works correctly for a slightly restricted subset of
OWL DL where we add two restrictions (Def. 1). The second restriction is also
known from OWL Lite (cf. [10]). Both restrictions are necessary in order to
avoid exponential computation complexity or even infinite computations in the
proposed algorithms that are used in Sect. 4.2 like the ExtractReferenceClasses-
Algorithm, e.g., if there are further object property restrictions that appear in
the range of another object property restriction.
Definition 1 (Language Restrictions). We restrict OWL DL (SHOIN (D))
by the following additional conditions:
1. In each property restriction p.E and p.E, E is a named class. The same

condition is also required for cardinality restrictions.

2. Individuals are not allowed in class definitions, i.e. no oneOf constructor.

3.2 Overview of Refactoring Pattern

We start with an overview of the analyzed refactoring patterns and describe how
they change an ontology (cf. Table 1). They are adopted from [2,3].

The first group of refactorings (No. 1-6) extract or merge classes and move
properties to or from the extracted or deleted class. Extract Subclass and Extract
Superclass are specializations of Extract Class. The refactorings in the second
group (No. 7-9) move properties between existing classes. In No. 8 and 9, the
properties are moved within a class hierarchy. Finally, the third group collects
refactorings that add, delete or modify object property restrictions. Either the
inverse object property is added or removed to a class description (No. 10, 11)
or in No. 12 cardinality restrictions are modified.

3.3 Detailed Refactoring Descriptions

In this subsection, we give detailed descriptions of two refactoring patterns
(Extract Class and Move of Property) and example representations in OWL in
order to substantiate our approach. The recognition algorithms and the results
for these two examples are given later on in Sect. 4. A comprehensive description of the other considered patterns from Table 1 and the recognition of them
is presented in [11]. A refactoring pattern consists of the following elements:

1. Each pattern has a Name (cf. pattern overview in Table 1).
2. The Problem Description characterizes a modeling structure of an ontology

and indicates when this pattern is applicable.

3. The Solution describes how the problem is (or could be) solved. This contains

the required remodeling steps in order to realize the refactoring.

4. The Example demonstrates the technical details of this refactoring.

G. Gr oner, F. Silva Parreiras, and S. Staab

Table 1. Analyzed Refactoring Patterns

No. Pattern Name

Description
Properties of a class are extracted to a newly created class.
Properties of a class are extracted to a newly created subclass.

1. Extract Class
2. Extract Subclass
3. Extract Superclass Properties of a class are extracted to a newly created superclass.
4. Collapse Hierarchy A subclass and its superclass are merged to one class.
A class is divided into a class hierarchy. Properties are
5. Extract Hierarchy
extracted to the newly created sub- and superclasses.
A class that is referenced by another
class is deleted and all its properties are
moved to the class that had referenced this class.
At least one property is moved from a class
to a referenced class.
At least one property is moved from a class to its superclass.

7. Move Of Property

6. Inline Class

8. Pull-Up Property
9. Push-Down Property At least one property is moved from a class to its subclass.
10. Unidirectional
