Evolution of DL-Lite Knowledge Bases

Diego Calvanese, Evgeny Kharlamov, Werner Nutt, and Dmitriy Zheleznyakov

KRDB Research Centre, Free University of Bozen-Bolzano, Italy

last name@inf.unibz.it

Abstract. We study the problem of evolution for Knowledge Bases (KBs) expressed in Description Logics (DLs) of the DL-Lite family. DL-Lite is at the basis
of OWL 2 QL, one of the tractable fragments of OWL 2, the recently proposed revision of the Web Ontology Language. We propose some fundamental principles
that KB evolution should respect. We review known model and formula-based
approaches for evolution of propositional theories. We exhibit limitations of a
number of model-based approaches: besides the fact that they are either not expressible in DL-Lite or hard to compute, they intrinsically ignore the structural
properties of KBs, which leads to undesired properties of KBs resulting from such
an evolution. We also examine proposals on update and revision of DL KBs that
adopt the model-based approaches and discuss their drawbacks. We show that
known formula-based approaches are also not appropriate for DL-Lite evolution,
either due to high complexity of computation, or because the result of such an action of evolution is not expressible in DL-Lite. Building upon the insights gained,
we propose two novel formula-based approaches that respect our principles and
for which evolution is expressible in DL-Lite. For our approaches we also developed polynomial time algorithms to compute evolution of DL-Lite KBs.

1 Introduction

Description Logics (DLs) provide excellent mechanisms for representing structured
knowledge, and as such they constitute the foundations for the various variants of OWL,
the standard ontology language of the Semantic Web1. DLs have traditionally been used
for modeling at the intensional level the static and structural aspects of application domains [1]. Recently, however, the scope of ontologies has broadened, and they are now
used also for providing support in the maintenance and evolution phase of information
systems. Moreover, ontologies are considered to be the premium mechanism through
which services operating in a Web context can be accessed, both by human users and by
other services. Supporting all these activities, makes it necessary to equip DL systems
with additional kinds of inference tasks that go beyond the traditional ones of satisfiabil-
ity, subsumption, and query answering provided by current DL inference engines. The
most notable one, and the subject of this paper, is that of knowledge base evolution [2],
where the task is to incorporate new knowledge into an existing knowledge base (KB)
so as to take into account changes that occur in the underlying domain of interest. In
general, the new knowledge to incorporate is represented by a set of formulas denoting

 The author is co-affiliated with INRIA Saclay.
1 http://www.w3.org/TR/owl2-overview/

P.F. Patel-Schneider et al. (Eds.): ISWC 2010, Part I, LNCS 6496, pp. 112128, 2010.
c Springer-Verlag Berlin Heidelberg 2010
?

?

?
those properties that should be true after the KB has evolved. In the case where the new
knowledge interacts in an undesirable way with the knowledge in the KB, e.g., by causing the KB or relevant parts of it to become unsatisfiable, the new knowledge cannot
simply be added to the KB. Instead, suitable changes need to be made in the KB so as to
avoid the undesirable interaction, e.g., by deleting parts of the KB that conflict with the
new knowledge. Different choices are possible, corresponding to different semantics
for KB evolution [38].

In the literature, two main types of KB evolution have been considered: namely revision and update [4]. Both have a precise formal grounding in terms of postulates [4, 5]
and a number of update and revision operators were proposed in the literature [5, 6].
This work has been carried out for propositional logic, providing a thorough understanding of the various options, both wrt semantics and wrt computational properties.

Work relevant to KB evolution has been carried out initially in schema evolution
in databases, cf., [9], and more recently for expressive DLs [7, 8]. However, for such
richer representation formalisms, the picture is much less clear, and the various possibilities are far from being completely explored. (i) The fundamental distinction in DLs
between TBox (for terminological, or intensional knowledge) and ABox (for asser-
tional, or extensional knowledge), calls for distinguishing these two components (both
in the existing and in the new knowledge) also in the study of evolution. (ii) Going from
propositional letters to first-order predicates and interpretations, on the one hand calls
for novel principles underlying the semantics of evolution, and on the other hand broadens the spectrum of possibilities for defining such semantics. (iii) The combination of
constructs of the considered DL will obviously affect the complexity of computing the
result of evolution, independently of the chosen semantics. (iv) While in propositional
logic the result of an evolution step is always expressible in the same formalism, this
does not hold in general for DLs [10, 11].

In this paper we address several of the points raised by the above observations, thus

contributing substantially to a clarification of the problem.

In line with Item (i), we carry out our investigation and establish our results by con-

sidering separately the role of the ABox and of the TBox in evolution.

Regarding Item (ii), we propose some fundamental principles that KB evolution
should respect. We review known model and formula-based approaches for evolution
of propositional theories [5, 6], and we lift them to the first-order case in two natural
ways (by considering symmetric difference on symbol interpretations vs. interpretation
atoms). Previous proposals for KB evolution, such as ABox updates under Winsletts
semantics [10, 11], and the approaches proposed in [8], fit nicely into our classification.
Regarding Items (iii) and (iv), we concentrate our technical development on the DLLite family [12], which is at the basis of OWL 2 QL, one of the tractable profiles of
OWL 2. We exhibit limitations of a number of model-based approaches for the logics
of the DL-Lite family: besides the fact that evolution under such approaches is either
not expressible in DL-Lite or hard to compute, they intrinsically ignore the structural
properties of KBs, which leads to undesired properties of KBs resulting from such an
evolution. We also examine proposals on update and revision of DL KBs that adopt the
model-based approaches and discuss their drawbacks. We show that known formulabased approaches are also not appropriate for DL-Lite evolution, either due to high

D. Calvanese et al.

complexity of computation, or because the result of such an action of evolution is not expressible in DL-Lite. Building upon the insights gained, we propose two novel formulabased approaches that respect our principles and for which evolution is expressible in
DL-Lite. For our approaches we also developed polynomial time algorithms to compute
evolution of DL-Lite KBs.

2 Preliminaries and Problem Definition



Description Logics. We introduce some basic notions of Description Logics (DLs),
more details can be found in [13]. A DL knowledge base (KB) K = T  A is the union
of two sets of assertions, those representing the intensional-level of the KB, that is, the
general knowledge, and constituting the TBox T , and those providing information on
the instance-level of the KB, and constituting the ABox A. In our work we consider a
family of DLs, DL-Lite [12], which form a tractable fragment of OWL 2.
All the logics of the DL-Lite family have the following constructs for (complex) concepts and roles: (i) B ::= A | R, (ii) C ::= B | B, (iii) R ::= P | P
, where
A and P stand for an atomic concept and role, respectively, which are just names. A
DL-Litecore TBox consists of concept inclusion assertions B  C. DL-LiteFR extends
DL-Litecore by allowing in a TBox role inclusion assertions R1  R2 and functionality assertions (funct R), in a way that if R1  R2 appears in a TBox, then neither

(funct R2) nor (funct R
2 ) appears in the TBox. This syntactic restriction keeps the
logic tractable. ABoxes in DL-Litecore and DL-LiteFR consist of membership assertions of the form B(a) and P (a, b). When we write in this paper DL-Lite without a
subscript, specifying a concrete language, we mean any language of this family. The
DL-Lite family has nice computational properties, for example, KB satisfiability has
polynomial-time complexity in the size of the TBox and logarithmic-space in the size
of the ABox [14, 15].
The semantics of DL-Lite KBs is given in the standard way, using first order interpre-
tations, all over the same infinite countable domain . An interpretation I is a function
I

that assigns to each concept C a subset C
of , and to each role R a binary relation
over  in such a way that (B)I =  \ B
I}, and
, (R)I = {a | a
?

?

?
I}. We assume that  contains the constants and
)I = {(a2, a1) | (a1, a2)  P
(P
I = c, i.e., we adopt standard names. Alternatively, we view an interpretation as
that c
a set of atoms and say that A(a)  I iff a  A

. An
interpretation I is a model of a membership assertion B(a) if a  B
, and of P (a, b)
if (a, b)  P

2 , and of a functionality
assertion (funct R) if the relation R
As usual, we use I |= F to denote that I is a model of an assertion F , and I |= K
to denote that I |= F for each assertion F in K. We use Mod(K) to denote the set of
all models of K. A KB is satisfiable if it has at least one model and it is coherent2 if for
every concept and role S occurring in K there is an I  Mod(K) such that S
I = . We
in the standard sense. We say that an ABox A T -entails
use entailment on KBs K |= K
an ABox A
, denoted A |=T A
, and A is T -equivalent to A
, if T  A |= A
, denoted
and A |=T A. The deductive closure of a TBox T (of an
A T A
, if A |=T A
2 Coherence is often called full satisfiability.

, of an inclusion assertion D1  D2 if D

1  D

and P (a, b)  I iff (a, b)  P

is a function.
?

?

?
.(a, a

)  R
?

?

?
ABox A), denoted cl(T ) (resp., clT (A)), is the set of all TBox (resp., ABox) assertions
F such that T |= F (resp., T  A |= F ). It is easy to see that in DL-Lite cl(T ) (and
clT (A)) is computable in quadratic time in the size of T (resp., T and A). In our work
we assume that all TBoxes and ABoxes are closed.
Ontology Evolution. Let K = T  A be a DL-Lite KB and N a set of new (TBox
and/or ABox) assertions. We want to study how to incorporate the assertions N into
K, that is, how K evolves [2] under N . More practically, we want to develop evolution
operators that take K and N as input and return, possibly in polynomial time, a DL-Lite
KB K

that captures the evolution, and which we call the evolution of K under N .

In the Semantic Web context, update and revision [4, 5], the two classical understandings of ontology evolution, are too restrictive from the intuitive and formal perspective:
in many applications we know neither the status of the real world, nor how accurate N
is wrt to the world. For example, if in K we store knowledge from Web sources, say,
online newspapers that we collected using RSS feeds or Web crawling, then there is
no chance to say how this information is related to the state of the real world. When a
new portion of knowledge N arrives to K and conflicts with K, then it might be unclear
whether the conflict is due to outdated or wrong information in K. This situation does
not fit in the formalisms of update and revision and, therefore, we propose now some
new postulates to be adopted in the context of evolution in the Semantic Web.

is coherent.

First, we assume that the KBs we are dealing with make sense, that is, they are
coherent (and hence also satisfiable), and we want evolution to preserve this property:
EP1: Evolution should preserve coherence of the KB, that is, K
The same postulate is stipulated in [8]. Notice that in DL-Lite3 coherence can be reduced
to satisfiability. Moreover, when N may contain ABox assertions, one can enforce coherence by adding to N for each atomic concept A an assertion A(dA), and for each
?

?

?
atomic role P an assertion P (dP , d
P ), where dA, dP , d
P are fresh individuals.
For example, if our online newspapers KB K = T A records that John is married to
Mary and that a person can be married to at most one person, and if the new knowledge
N says that John is married to Patty, then K  N is unsatisfiable (and hence incoher-
ent) and does not comply with EP1. This can be resolved by either (i) discarding the
old information about Johns marriage, that is, by changing A, or (ii) weakening the
constraint in K on the number of spouses, that is, by changing T , or (iii) discarding N .
What to do depends on the application. In data-centric applications, the most valuable
information is the (extensional) data and we would have to discard the constraint on
the number of spouses from T . In Web data integration, the constraints of T define the
global schema and the data coming from different Web sources may be contradictive
by nature. Thus, it makes more sense to discard one of the two assertions about Johns
spouses using, for example, the trust we have in the sources of the data. To formalize
this consideration we introduce the notion of protected part of a KB, which is simply
a subset Kpr  K that is preserved by evolution. This is sanctioned by our second
postulate:
EP2: Evolution should entail the new knowledge and preserve the protected part,

that is, K |= Kpr  N .

3 Actually, in all logics enjoying the disjoint-union model property.

D. Calvanese et al.

This postulate is different from the classical ones of update and revision where it is
only required that the new KB K
should entail the new knowledge N . We observe,
however, that evolution of K with a protected part Kpr wrt N is conceptually the same
as evolution of K with the empty protected part wrt Kpr  N .
Another principle that is widely accepted [4, 5] is the one of minimality of change:
EP3: The change to K should be minimal, that is, K
is minimally different from K.
There are different approaches to define minimality, suitable for particular applications,
and the current belief is that there is no general notion of minimality that will do the
right thing under all circumstances [6].

Based on these principles, we will study evolution operators. We will consider the
classical update and revision operators coming from AI [5] and also operators proposed
for DLs [8, 15], and try to adapt them to our needs. In the following we distinguish
three types of evolution: TBox evolution, when N consists of TBox assertions only, and
we denote it NT , ABox evolution, when N consists of ABox assertions only, and we
denote it NA, KB evolution, when N includes both TBox and ABox assertions.
Running Example. In our online-newspapers KB we have structural knowledge that
wives (W ) are exactly those individuals who have husbands (hh) and that some wives
are employed (E ). Singles (S ) cannot be husbands. Priests (P) are clerics (C ) and
clerics are singles. Both clerics and wives are receivers of rent subsidies (R). We also
know that Adam (a) and Bob (b) are priests, Mary (m) is a wife who is employed and
her husband is John (j ). Also, Carl (c) is a catholic minister (M ). This knowledge can
be expressed in DL-Lite by the KB Kex, consisting of the following assertions:
, P  C , C  S , C  R, W  R;
T : W  hh, hh  W , E  W , S  hh
A: P(a), P(b), E(m), hh(m, j ), M (c).
By crawling some Web sources we found out that John is now single (that is, S (j )),
in the Oxford Dictionary we discovered that catholic ministers are superiors of some
religious orders and hence clerics (M  C ), and from economic news we found out that
the current crisis affects people receiving rent subsidies in that subsidies were canceled
for wives (W  R) and for clerics (C  R), since the former may receive support
from their husbands and the latter from their church. In the rest of the paper we will
discuss how to incorporate this new knowledge into our KB.



3 Approaches to Evolution

A number of candidate semantics for evolution operators have been proposed in the literature [3, 6, 8, 15, 16]. They can be divided into two groups, model-based approaches
(MBAs) and formula-based approaches (FBAs).

3.1 Model-Based Approaches
In model-based approaches (MBAs) the result of evolution of a KB K wrt new knowledge N is a set KN of models. The general idea of MBAs is to choose as the result of
evolution some models of N depending on their distance to the models of K. Katsuno
and Mendelzon [4] considered two ways of choosing these models of N .

The idea of the first one, which we call local, is to go over all models I of K and for

each I to take those models J of N that are minimally distant from I. Formally,

Evolution of DL-Lite Knowledge Bases
?

?

?
K  N =

dist(I,J ),

arg min
J Mod(N )

IMod(K)

where dist(,) is a function whose range is a partially ordered domain and arg min
stands for the argument of the minimum, that is, in our case, the set of models J for
which the value of dist(I,J ) reaches its minimum value, given I. The distance function
dist varies from approach to approach and commonly takes as values either numbers or
subsets of some fixed set.
The idea of the second way, called global, is to choose those models J of N that are
minimally distant from the entire set of models of K. Formally,
dist(Mod(K),J ),

(1)

K  N = arg min
J Mod(N )

where dist(Mod(K),J ) = minIMod(K) dist(I,J ).

The classical MBAs were developed for propositional theories. In this context, an
interpretation was identified with the set of propositional atoms that it makes true and
two distance functions were introduced, respectively based on symmetric difference and
on the cardinality of symmetric difference,

dist(I,J ) = I  J

and

dist(I,J ) = |I  J |.

(2)
where the symmetric difference of two sets is defined as IJ = (I\J )(J \I). Distances under dist are sets and are compared by set inclusion, that is, dist(I1,J1) 
dist(I2,J2) iff dist(I1,J1)  dist(I2,J2). Distances under dist are natural numbers and are compared in the standard way.
One can extend these distances to DL interpretations in two different ways. One
way is to consider interpretations I, J as sets of atoms. Then I  J is again a set
of atoms and we can define distances as in Equation (2). We denote these distances as
dista(I,J ) and dista
 (I,J ). While in the propositional case distances are always finite,
this may not be the case for DL interpretations that are infinite. Another way is to define
distances at the level of the concept and role symbols in the underlying signature :
J }|.
dists(I,J ) = {S   | S
Summing up across the different possibilities, we have three dimensions, which give
eight possibilities to define a semantics of evolution according to MBAs by choosing:
(1) the local or the global approach, (2) atoms or symbols for defining distances, and
(3) set inclusion or cardinality to compare symmetric differences.
We denote each of these eight possibilities by a combination of three symbols, indicating the choice in each dimension. By L we denote local and by G global semantics.
We attach the superscripts a or s to indicate whether distances are defined in terms
of atoms or symbols. We use the subscripts  or  to indicate whether distances are
compared in terms of set inclusion or cardinality. For example, La
 denotes the local
semantics where the distances are expressed in terms of cardinality of sets of atoms.

(I,J ) = |{S   | S

and dists

I = S

I = S

J },

D. Calvanese et al.

Considering that in the propositional case a distinction between atom and symbolbased semantics is meaningless, we can also use our notation, without superscripts, to
identify MBAs in that setting. Interestingly, the two classical local MBAs proposed by
Winslett [6] and Forbus [17] correspond, respectively, to L, and L, while the one by
Borgida [18] is a variant of L. The two classical global MBAs proposed by Satoh [5]
and Dalal [19] correspond, respectively, to G, and G.

Under each of our eight semantics, evolution results in a set of interpretations. In the
propositional case each set of interpretations over finitely many symbols can be captured
by a formula whose models are exactly those interpretations. In the case of DLs this is
no more necessarily the case, since on the one hand, interpretations can be infinite and
on the other hand logics may miss some connectives like disjunction or negation.
Let D be a DL and M one of the eight MBAs introduced above. We say D is closed
under evolution wrt M (or evolution wrt M is expressible in D) if for any KBs K and
N written in D, there is a KB K
written in D such that Mod(K) = K  N . We study
now whether the logics of the DL-Lite family are closed under the various semantics.

Global Model-Based Approaches. We start with an example showing that wrt all four
semantics Gs, Gs

 , TBox evolution is not expressible in DL-Lite.

 , Ga and Ga

The observation underlying these results is that on the one hand, the minimality of
change principle introduces implicit disjunction in the evolved KB. On the other hand,
DL-Lite can be embedded into a slight extension of Horn logic [20] and therefore does
not allow one to express genuine disjunction. Technically, this can be expressed by
saying that every DL-Lite KB that entails a disjunction of DL-Lite assertions entails
one of the disjuncts. The lemma gives a contrapositive formulation of this statement.
Although DL-Lite does not have a disjunction operator, by abuse of notation we write
J |=    as a shorthand for J |=  or J |=  for DL-Lite assertions , .
Lemma 1. Let M be a set of interpretations. Suppose there are DL-Lite assertions
,  such that (1) J |=    for every J  M; (2) there are J1, J2  M such that
J1 |=  and J2 |= . Then there is no DL-Lite KB K such that M = Mod(K).
Example 2. Consider the KB Kex of our running example and assume that the new
information NT = {W  R} arrived. We explore evolution wrt the Gs
 semantics of
, which counts for how many symbols the interpretation changes.
Consider three assertions, (derived) from K, that are essential for this example: E 
(I,J ) for I  Mod(K)
W , E  R, and E(m). One can show that the minimum of dists
and J  Mod(NT ) equals 1. Let J  KNT . Then there exists I  Mod(K) such that
(I,J ) = 1. Hence, there is only one symbol S  {E , W , R} whose interpretation
dists
has changed from I to J , that is S
. Observe that S cannot be E . Otherwise,
W and R would be interpreted identically under I and J , and W and R would not be
disjoint under J , since m is an instance of both, thus contradicting NT . Now, assume
that W has not changed. Then J |= E  W , since this held already for I. However,
J |= E  R, since m  EJ
, due to the disjointness of W and
R with respect to J . Similarly, if we assume that R has not changed, it follows that
J |= E  R, but J |= E  W . By Lemma 1 we conclude that K  NT is not
expressible in DL-Lite.

, but m / RJ

I = S
?

?

?
 .

Evolution of DL-Lite Knowledge Bases

 , Ga, and Ga
 .
?

?

?
 semantics are not expressible in DL-Lite.

From the example we conclude our first inexpressibility result.
Theorem 3. DL-Lite is not closed under TBox evolution wrt Gs, Gs
With a similar argument one can show that the operator M of Qi and Du [8] (and its
stratified extension S), is not expressible in DL-Lite. This operator is a variant of Gs
where in Equation (1) one considers only models J  Mod(N ) that satisfy A
J = 
for every A occurring in K  N . The modification does not affect the inexpressibility,
which can again be shown using Example 2. We note that M was developed for KB
revision with empty ABoxes and the inexpressibility comes from the non empty ABox.
Local Model-Based Approaches. We start with an example showing that both ABox
and TBox evolution wrt the La and La
Example 4. We turn again to our KB Kex and consider the scenario where we are informed that John is now a single, formally NA = {S (j )}. Suppose we want to perform
ABox evolution where the TBox of Kex is protected. The TBox assertions essential for
this example are W  hh, hh  W , and P  hh
, that is, an individual is a
wife iff she has a husband, and a priests is not a husband. The essential ABox assertions
are W (m), P(a), and P(b). We show the inexpressibility of evolution wrt La using
Lemma 1.
Under La, in every J  K  NA one of four situations holds: (i) Mary is not a
wife, that is, J |= W (m), and both Adam and Bob are priests, that is, J |= P(a) 
P(b). Hence, J |= P(a)  P(b). (ii) Mary is a wife and her husband is different from
Adam and Bob. Due to minimality of change, both Adam and Bob are still priests, as
in Case (i), and again J |= P(a)  P(b). (iii) Mary is a wife and her husband is Adam.
Then Bob, due to mininality of change, is still a priest. Hence, J |= P(a)  P(b).
Moreover, the new husband cannot stay priest any longer and J |= P(a). (iv) Mary is a
wife and her husband is Bob. Analogously to Case (iii), we have J |= P(a)P(b) and
J |= P(b). We are in the conditions of Lemma 1, that is, for every model J  K  NA
it holds that J |= P(a)  P(b), and there are J   K  N 
|= P(a) and
J   KNA s.t. J  |= P(b). Consequently, the set of models KNA is not expressible
in DL-Lite.
 , we need extra arguments. Intuitively, if
a model I |= Kex contains individuals that are single, but not clerics, then the models
J |= NA closest to I in terms of dist are such that Mary, if she remains a wife, marries
one of these individuals and Adam and Bob remain priests, since this involves the fewest
changes of atoms. However, this is no more the case if we consider a model I0 |= Kex
where everyone, except John, is a priest, that is PI0 =  \ {j}. Reasoning as before,
one can see that among the models J of NA closest to I0, there are some such that
J |= P(a) and others such that J |= P(b), while all of them satisfy J |= P(a) P(b).
Then Lemma 1 implies that K  NA under La
Now, we consider TBox evolution, which means that the ABox of Kex is protected.
Suppose we found out that ministers are clerics, formally NT = {M  C}. The
assertions of Kex essential for this example are C  S and M (c). Assume there is a
representation K
of the Kex  NT under La. Since K1 = Kex  NT is fully satisfiable,

To show that the example works also for La



A s.t. J 

 is not expressible in DL-Lite.

D. Calvanese et al.

, then c / S J 

one might expect that K = K1. It turns out this is not the case. Indeed, since every
model J  Kex  NT is such that J |= NT  {M(c)}, it holds that c  M J  C J
.
Moreover, if I  Mod(K) is such that c / S I
for any J   Mod(NT )
minimally different from I. At the same time K1 |= S (c), hence, such a J 
is not a
model of K1 and K1 cannot be K
. Since the inclusion C  S caused the problem
above, it might be the case that K
is K2 = K1 \ {C  S}. It turns out this is not the
case either, since K2 has models that are not in K  NT . Can we resolve this by adding
some assertion to K2? No, again. If one adds any DL-Lite TBox assertion to K2 that is
not entailed by K2 or not C  S , one gets a KB with models not in K  NT . Hence, no
representation K
of K  NT exists. Analogously, one can show that K  NT under La
is also not expressible in DL-Lite.
?

?

?
This example proves our second inexpressibility result, which follows.
Theorem 5. DL-Lite is not closed under evolution wrt La and La
 . This holds already
for the special cases of TBox evolution and ABox evolution with protected TBox.
De Giacomo et al. [21] considered ABox evolution with protected TBox wrt La seman-
tics. They presented an algorithm to compute DL-LiteFR KBs that represent K  NA
for DL-LiteFR KBs K and NA. As a consequence of Theorem 5, their algorithm is not
complete.

A strange effect of evolution under La

 semantics is that new information may erase
completely the previous KB.
Proposition 6. Let K be a KB with at least one finite model and let N be a satisfiable
KB such that all its models are infinite. Then under La
Since the DL-Lite logics without role functionality have the finite model property, that
is, every satisfiable KB in these logics has a finite model, the above situation cannot
occur for them. At the same time, in every DL-Lite logic with role functionality there
are KBs all of whose models are infinite and such an erasure can take place.

 we have that K  N = N .

The properties of the Ls and Ls

 semantics are still an open problem for us.

We now discuss conceptual problems with all the local semantics. Recall Example 4
for local MBAs La and La
 . We note two problems. First, the divorce of Mary from
John had a strange effect on the priests Bob and Adam. The semantics questions their
celibacy and we have to drop the information that they are priests. This is counterintu-
itive, since Mary and her divorce have nothing to do with any of these priests. Actually,
the semantics also erases from the KB assertions about all other people belonging to
concepts whose instances are not married, since potentially each of them is Marys new
husband. Second, a harmless clarification introduced to the TBox that ministers are in
fact clerics strangely affects the whole class of clerics. The semantics of evolution re-
quires one to allow marriages for clerics. This appears also strange, because intuitively
the clarification on ministers does not contradict by any means the celibacy of clerics.

Also the four global MBAs have conceptual problems that were exhibited in Example 2. The restriction on rent subsidies that cuts the payments for wives introduces a
counterintuitive choice for employed wives. Under the symbol-based global semantics,
they must either collectively get rid of their husbands or collectively lose the subsidy.
Under atom-based semantics the choice is an individual one.
?

?

?
Summing up on both the global and the local MBAs that we have considered, they
focus on minimal change of models of KBs and, hence, introduce choices that cannot
be captured in DL-Lite, which owes its good computational properties to the absence
of disjunction. This mismatch with regard to the structural properties of KBs leads to
counterintuitive and undesired results, like inexpressibility in DL-Lite and erasure of the
entire KB. Therefore, we think that these semantics are not suitable for the evolution of
DL-Lite KBs, whether or not they satisfy EP1-EP3, and now study evolution according
to formula-based approaches.

3.2 Formula-Based Approaches

Under formula-based approaches, the objects of change are sets of formulas. Given a
KB K and new knowledge N , a natural way to define the result of evolution seems to
choose a maximal subset Km of K that is consistent with N . The result of evolution in
this case is a set of formulas K  N = Km N However, a problem with this is that in
general such a Km is not unique.
Let M(K,N ) be the set of all such maximal Km. In the past, researchers have
proposed a number of approaches to combine all elements of M(K,N ) into one set
of formulas, which is then added to N [5, 6]. The two main ones are known as Cross-
Product, or CP for short, and When In Doubt Throw It Out, or WIDTIO for short. The
corresponding sets KCP and KWIDTIO are defined as follows:

 
?

?

?
KCP :=

(
Km
KmM(K,N )

)

.

KWIDTIO :=

Km,

KmM(K,N )

In CP one adds to N the disjunction of all Km, viewing each Km as the conjunction
of its assertions, while in WIDTIO one adds to N those formulas present in all Km. In
terms of models, every model of KWIDTIO is also a model of KCP, whose models are
exactly the interpretations satisfying some of the Km.
Example 7. We consider again our running example. Suppose, we obtain the new information that priests no longer obtain rental subsidies. This can be captured by the
set of TBox assertions NT = {P  R}. We now incorporate this information
into our KB, under both CP and WIDTIO semantics. Clearly, Kex  NT is not coherent and to resolve the conflict one can drop either P  C or C  R. Hence,
M(Kex,NT ) = {K(1)
m = K \ {C  R}.
Consequently, the results of evolving K with respect to NT under the two semantics are
(3)

NT  KCP = NT  ((K \ {P  C})  (K \ {C  R}))

m ,K(2)

m }, where K(1)

m = K \{P  C}, and K(2)

NT  KWIDTIO = NT 

K(1)

m

 K(2)

m

= NT  Kex \ {P  C , C  R},
?

?

?
where in (3) we have combined DL notation with first order logic notation.

Intuitively, CP does not lose information, but the price to pay is that the resulting KB
can be exponentially larger than the original KB, since there can exist exponentially
many Km. In addition, as the example shows, even if K is a DL-Lite KB, the resulting
KCP may not be representable in DL-Lite anymore since it requires disjunction. This
effect is also present if the new knowledge involves only ABox assertions.

D. Calvanese et al.

WIDTIO, on the other extreme, is expressible in DL-Lite. However, it can lose many
assertions, which may be more than one is prepared to tolerate. Even, if one deems
this loss acceptable, one has to cope with the fact that it is generally difficult to decide
whether an assertion belongs to KWIDTIO. This problem is already difficult if our KBs are
TBoxes that are specified in the simplest variant of DL-Lite. We note that the following
theorem can be seen as a sharpening of a result about WIDTIO for propositional Horn
theories in [5], obtained with a different reduction than ours.
Theorem 8. Given DL-Lite TBoxes T and NT and an inclusion assertion A  B,
Km, is coNP-complete. Hardness holds

deciding whether A  B  

KmM(T ,NT )

already for DL-Litecore.

Against this backdrop we conclude that neither CP nor WIDTIO are good for practical
solutions. As a pragmatic alternative we will explore the approach to nondeterministically choose some K(0)

m among the Km. We call this semantics bold semantics.

K b N = N  K(0)
m ,

m ,K(2)
m for some K(0)

m is coherent and such that that K(0)

4 Bold Semantics
We define as bold semantics the approach to evolution where, given a KB K = T  A
m  cl(K), that
and new knowledge N , we add to N a maximal compatible subset K(0)
is, a set such that N  K(0)
m is maximal wrt to this
property. Note that now we choose a subset of the deductive closure of K and not of K
alone. By abuse of notation, we will use a binary operator to denote any result of bold
evolution and write
although K b N is not uniquely defined.
Example 9. Consider the KB and the update request from Example 7. As shown there,
M(Kex,NT ) = {K(1)
m }. According to bold semantics the result of the update is
a KB K = N  K(0)
m  M(Kex,NT ). Thus, the result of the update is
either NT  Kex \ {P  C} or NT  Kex \ {C  R}. Whether to select one or the
other of these two options depends on preferences, which we do not consider here.
Choosing an arbitrary Km has the advantage that K b N can be computed in polynomial time. In Fig. 1 we present a nondeterministic algorithm that, given a KB K and
new knowledge N , returns a set Km  cl(K) that is a maximal compatible set of assertions for K and N . The algorithm loops as many times as there are assertions in cl(K).
The number of such assertions is at most quadratic in the number of constants, atomic
concepts, and roles. The crucial step is the check for coherence, which is performed
once per loop. If this test is polynomial in the size of the input then the entire runtime of
the algorithm is polynomial. For DL-LiteFR TBoxes T , coherence can be checked in
time quadratic in the number of assertions in the TBox, that is, O(|T |2). Satisfiability
of an ABox A with respect to T can be checked in time O(|T |2  |A|), where |A| is
the number of assertions of A. The O(|T |2) complexity can be shown by reduction to
satisfiability of sets of propositional Horn clauses (see [22] for details).
?

?

?
KBs K and N
INPUT:
a set Km  cl (K) of TBox and ABox assertions
OUTPUT:
[1] Km := N ; S := cl(K)
[2]
[3]
[4]
[5]

choose some   S; S := S \ {}
if {}  Km is coherent then Km := Km  {}

repeat

until S = 

Fig. 1. Algorithm BoldEvol(K,N ) for nondeterministic computation of Km

Theorem 10. The algorithm BoldEvol runs in polynomial time and computes evolution
wrt bold semantics, that is, K b N = BoldEvol(K,N ).
This shows that bold semantics has the great advantage that evolution can be computed
in polynomial time. However, its nondeterminism is a disadvantage. Clearly, we can
avoid nondeterminism if we impose a linear order on the assertions in cl(K), and let
BoldEvol choose them in this order. The question how to define such an order depends
on the characteristics of the application, and we cannot discuss it here.
One may wonder whether it is possible to efficiently compute a Km with maximal
cardinality. (Recall that our algorithm is only guaranteed to compute a Km that is maximal wrt set inclusion.) Unfortunately, it turns out, using various reductions from the
Independent Set problem, that under this requirement computation is hard, even for K
and N that consist only of TBox or only of ABox assertions, except when both, K and
N , are ABoxes, in which case no conflicts can arise.
Theorem 11. Given DL-Lite KBs K and N and an integer k > 0, to decide whether
there exists a subset K0  K such that K0N is coherent and |K0|  k is NP-complete.
NP-hardness already holds for DL-Litecore if (1) both K and N are TBoxes, or (2) K
is an ABox and N is a TBox, or (3) K is a TBox and N is an ABox.

In the next section we will see that nondeterminism is not present in ABox evolution
with a protected TBox and that there is always a single maximal compatible ABox.

5 ABox Evolution
We study ABox evolution assuming that the new knowledge NA is satisfiable with the
old TBox T , may only conflict with the old ABox A, and that T is protected.
ABox Evolution under Bold Semantics. In DL-Lite, unsatisfiability of a KB is caused
either by a single ABox assertion, which will be a membership assertion for an unsatisfiable concept or role, or by a pair of assertions contradicting either a disjointness or a
functionality assertion of the TBox.
Lemma 12. Let T A be a DL-Lite KB. If T A is unsatisfiable, then there is a subset
A0  A with at most two elements, such that T  A0 is unsatisfiable.

D. Calvanese et al.

TBox T , and ABoxes A, D, each satisfiable with T
finite set of membership assertions Aw

INPUT:
OUTPUT:
[1] Aw := A
[2] for each B1(c)  D do
[3] Aw := Aw \ {B1(c)} and
[4]
if B2(c) = R(c) then
[5]
[6]
[7] for each R1(a, b)  D do
[8] Aw := Aw \ {R1(a, b)} and
[9]

for each B2  B1  cl(T ) do Aw := Aw \ {B2(c)}
for each R(c, d)  Aw do D := D  {R(c, d)}

for each R2  R1  cl(T ) do Aw := Aw \ {R2(a, b)}
Fig. 2. Algorithm Weeding(T ,A,D) for DL-LiteFR

for each B  B

if {B(c), B

  cl(T ) do
(c)}  A0 then

TBox T , and ABoxes A, NA, each satisfiable with T
INPUT:
finite set of membership assertions Am
OUTPUT:
[1] A0 := clT (A  NA), NA := clT (NA), CA := 
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10] Am := Weeding(T , clT (A), CA)

otherwise CA := CA  {B
if {R(a, b), R(a, c)}  A0 then

if B(c) / NA then CA := CA  {B(c)}

if R(a, b) / NA then CA := CA  {R(a, b)}

otherwise CA := CA  {R(a, c)}

for each (funct R)  T do

(c)}

Fig. 3. Algorithm FastEvol(A, NA,T ) for DL-LiteFR

The lemma implies that if T  NA  A is unsatisfiable, then there are two assertions
  NA and   A such that T  {, } is unsatisfiable. In other words, whether or
not   A needs to be eliminated from A as a result of evolution depends on  alone.
As a consequence, ABox evolution wrt bold semantics is deterministic.
Theorem 13. The result of ABox evolution (T  A) b NA is uniquely defined.
In principle, BoldEvol can be used to compute ABox evolution and regardless of the
order in which it selects the assertions, it will always return the same result, due to
Theorem 13. A drawback of BoldEvol is that it performs a coherence check during each
loop, which is not needed in that form, since ABox evolution does not affect coherence
of the TBox. We exhibit now a new algorithm FastEvol that replaces the coherence
check with implicit satisfiability checks.
The algorithm FastEvol computes the set Am  clT (A) of all assertions that do not
conflict with T and N and is based on Lemma 12. It exploits the algorithm Weeding (see
Fig. 2), which takes as input T , A, and a set D of membership assertions to be deleted
from A. For every assertion   D, Weeding deletes from A  and also all the assertions
that T -entail . The algorithm FastEvol (see Fig. 3) takes as input T , A, and NA. It
?

?

?
detects assertions in the closure of A  NA that conflict with the new data and stores
them in CA. Finally, it resolves the conflicts by deleting CA from A using Weeding.

Theorem 14. The algorithm FastEvol computes ABox evolution wrt bold semantics,
that is, (T  A) b NA = T  NA  FastEvol(K,NA), and runs in polynomial time.

Note that, although FastEvol may look similar to the algorithm ComputeUpdate in
[21], it is actually different. Our algorithm always keeps at least as many assertions as
ComputeUpdate. In some cases, however, ComputeUpdate drops an existential restriction of the form R(a), although it would not cause a contradiction.
Careful Semantics. We start with an example illustrating drawbacks of bold semantics.
Apparently, the drawbacks come from the minimality of evolution principle EP3.
Example 15. Coming back to Kex, consider evolution wrt bold semantics for the news
that John is getting single, formally, NA = {S (j )}. One can see that the only assertion
to be dropped from Kex is that John is the husband of Mary, that is, Kex b NA = Kex 
NA \ {hh(m, j )}. This implies that Kex b NA |= W (m) and, consequently, Mary still
has a husband who is not John, despite the divorce with John, that is, Kex b NA |= ,
where  = x(hh(m, x)  (x = j )). The only option that bold semantics offers to
Mary is to find another husband immediately after the divorce. It does not consider it
an option for her to become single. We are interested in a semantics that allows for both
possibilities. Note that the entailment Kex b NA |=  is unexpected in the sense that
neither Kex nor NA entail , that is, Kex |=  and NA |=  hold.

As the example shows, the situation when the result of evolution entails unexpected
information, that is, information coming neither from the original KB, nor from the new
knowledge, may be counterintuitive. In our example, the unexpected information is the
formula x(hh(m, x)  (x = j )), which has a specific form: it restricts the possible
values in the second component of the role hh. Our next semantics prohibits these role
restrictions from being unexpectedly entailed from the result of evolution.
We say that a formula is role-constraining, or an RCF for short, if it is of the form
x(R(a, x)  (x = c1)    (x = cn)), where a and all ci are constants. Let T
be a TBox, and A, NA be ABoxes. A subset A1  A is careful if for every RCF ,
whenever A1  NA |=T  holds, either A1 |=T  or NA |=T  holds.
Theorem 16. Let T be a DL-Lite TBox and A, NA DL-Lite ABoxes, and suppose that
both T  A and T  NA are satisfiable. Then, the set

{A0  clT (A) | A0 is careful and A0  NA is T -satisfiable}

has a unique maximal element wrt set inclusion.
We can exploit the maximal set Ac
uniqueness is guaranteed by Theorem 16, to define the careful evolution:

m of assertions (where c stands for careful), whose

(T  A) c NA := T  NA  Ac
m.

(4)

D. Calvanese et al.

INPUT:
OUTPUT:
[1] Ac
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12] Ac

TBox T , and ABoxes A, NA, each satisfiable with T
finite set of membership assertions Ac

m

m := FastEvol(T ,A, NA), UF := 
for each R(a)  PreclT (NA) do
if R(a, b)  Ac
m for every b then
for each R
  C  cl(T ) do

for each C(d)  clT (A) \ clT (NA) do

UF := UF  {C(d)}

for each R(a)  Ac

if R(a, b)  Ac

m \ PreclT (NA) do

if there is a concept C in T  A  NA s.t.

m for every b then

(R

  C)  cl(T ) and C(d)  clT (NA) \ clT (A) for some d then
UF := UF  {R(a)}

m := Weeding(T ,Ac

m, UF)

Fig. 4. Algorithm CarefulEvol(T ,A,NA) for DL-LiteFR

One can see that, by its definition, careful semantics satisfies the principles EP1, EP2,
and EP3, where for EP3 the minimality should take into account carefulness. We exhibit now the algorithm CarefulEvol, which computes the uniquely determined set Ac
of Equation (4). The preclosure of A wrt T , denoted PreclT (A), is a subset of clT (A)
obtained as follows: one removes from clT (A) all the assertions of the form R(a),
whenever there is an assertion of the form R(a, c) in clT (A), for some constant c.
The preclosure is needed to detect unexpected RCFs. The algorithm CarefulEvol (see
Fig. 4) takes as input ABoxes A, NA, and a TBox T . It first computes the evolution wrt bold semantics. Then, it computes the set UF of assertions that cause unexpectedness in FastEvol(T ,A,NA) and belong to clT (A). Then it removes UF from
FastEvol(T ,A,NA) by means of Weeding.
Theorem 17. The algorithm CarefulEvol computes ABox evolution wrt careful seman-
tics, that is, (T A)cNA = T NACarefulEvol(T ,A,NA) and runs in polynomial
time.

m

Again, CarefulEvol differs from ComputeUpdate in [21]. Sometimes the first may drop
an existential restriction R(a) and the second keep it, while sometimes it may be the
other way round.

We defer a detailed discussion on how bold and careful semantics are related to the

classical update and revision postulates of [4] to an extended version of this paper.

6 Conclusion

We studied evolution of DL-Lite KBs. There are two main families of approaches to evo-
lution: model-based and formula-based ones. We singled out and investigated a threedimensional space of model-based approaches, and proved that most of them are not
appropriate for DL-Lite due to their counterintuitive behavior and the inexpressibility
of evolution results. Thus, we examined formula-based approaches, showed that the
?

?

?
classical ones are again inappropriate for DL-Lite, and proposed a novel bold semantics.
We showed that this semantics can be computed in polynomial time, but the result is,
in general, non-deterministic. Then, we studied ABox evolution under bold semantics
and showed that the result in this case is unique. We developed a polynomial time algorithm for DL-Lite KB evolution under this semantics, and an alternative optimized
one for ABox evolution. We presented a conceptual drawback of ABox evolution under
bold semantics and introduced careful semantics, which repairs the drawback. For this
approach we proved that the evolution result is unique and developed a polynomial time
algorithm to compute it.

Acknowledgements. The authors are partially supported by the EU projects ACSI (FP7-
ICT-257593) and Ontorule (FP7-ICT-231875). The second author is also supported by
the European Research Council grant Webdam (under FP7), agreement n. 226513.
