Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

nSPARQL: A navigational language for RDF
Jorge Perez a,c,, Marcelo Arenas a,c, Claudio Gutierrez b,c

a Department of Computer Science, Pontificia Universidad Catolica de Chile, Chile
b Department of Computer Science, Universidad de Chile, Chile
c Khipu: South Andean Center for Database Research, Chile

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 20 January 2009
Received in revised form
15 December 2009
Accepted 20 January 2010
Available online 1 February 2010

Keywords:
SPARQL

Nested regular expressions

1. Introduction

Navigational features have been largely recognized as fundamental for graph database query languages.
This fact has motivated several authors to propose RDF query languages with navigational capabilities.
In this paper, we propose the query language nSPARQL that uses nested regular expressions to navigate
RDF data. We study some of the fundamental properties of nSPARQL and nested regular expressions concerning expressiveness and complexity of evaluation. Regarding expressiveness, we show that nSPARQL
is expressive enough to answer queries considering the semantics of the RDFS vocabulary by directly
traversing the input graph. We also show that nesting is necessary in nSPARQL to obtain this last result,
and we study the expressiveness of the combination of nested regular expressions and SPARQL operators.
Regarding complexity of evaluation, we prove that given an RDF graph G and a nested regular expression
E, this problem can be solved in time O(|G|  |E|).

 2010 Elsevier B.V. All rights reserved.

The Resource Description Framework (RDF) [8,18] is the W3C
recommendation data model for the representation of information about resources on the Web. The RDF specification includes
a set of reserved keywords with its own semantics, the RDFS
vocabulary. This vocabulary is designed to describe special relationships between resources like typing and inheritance of classes
and properties [8]. As with any data structure designed to model
information, a natural question that arises is what the desiderata are for an RDF query language. Among the multiple design
issues to be considered, it has been largely recognized that navigational capabilities are of fundamental
importance for data
models with explicit tree or graph structure (like XML and
RDF).

Recently, the W3C Working Group issued the specification of
a query language for RDF, called SPARQL [27], which is a W3C
recommendation since January 2008. SPARQL is designed much
in the spirit of classical relational languages such as SQL. It has
been noted that, although RDF is a directed labeled graph data
format, SPARQL only provides limited navigational functionalities.
This is more notorious when one considers the RDFS vocabulary

 This is an extended and revised version of Refs. [7,26].
 Corresponding author at: Department of Computer Science, Pontificia Universidad Catolica de Chile, Vicu na Mackenna 4860, Macul, Santiago, Chile.

E-mail addresses: jperez@ing.puc.cl (J. Perez), marenas@ing.puc.cl (M. Arenas),

cgutierr@dcc.uchile.cl (C. Gutierrez).

1570-8268/$  see front matter  2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2010.01.002

(which current SPARQL specification does not cover), where testing conditions like being a subclass of or a sub-property of naturally
requires navigating the RDF data. A good illustration of this is shown
by the following query, which cannot be expressed in SPARQL
without some navigational capabilities. Consider the RDF graph
shown in Fig. 1. This graph stores information about cities, transportation services between cities, and further relationships among
those transportation services (in the form of RDFS annotations). For
instance, in the graph we have that a Seafrance service is a subproperty of a ferry service, which in turn is a sub-property of a
general transport service. Assume that we want to test whether a
pair of cities A and B are connected by a sequence of transportation
services, but without knowing in advance what services provide
those connections. We can answer such a query by testing whether
there is a path connecting A and B in the graph, such that every edge
in that path is connected with transport by following a sequence
of sub-property relationships. For instance, for Paris and Calais
the condition holds, since Paris is connected with Calais by an
edge with label TGV, and TGV is a sub-property of train, which
in turn is a sub-property of transport. Notice that the condition
also holds for Paris and Dover.

Driven by these motivations, we introduce a language for
navigating RDF data grounded on paths expressed with regular
expressions, that takes advantage of the special features of RDF.
Besides regular expressions, our proposed language borrows the
notion of branching from XPath [11], to obtain what we call nested
regular expressions. We also introduce the language nSPARQL,
that incorporates these navigational capabilities to a fragment
of SPARQL, and provide formal evidence that the capabilities of

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

Fig. 1. An RDF graph storing information about transportation services between cities.

nSPARQL can be used to pose many interesting and natural queries
over RDF data.

We formally study several fundamental properties of nSPARQL.
The first of these fundamental questions is whether the navigational capabilities of nSPARQL can be implemented efficiently. In
this paper, we show that this is indeed the case. More precisely, we
show that nested regular expressions can be evaluated efficiently;
if the appropriate data structure is used to store RDF graphs, then
given an RDF graph G, a nested regular expression E and nodes A, B
in G, it is possible to check in time O(|G|  |E|) whether B is reachable
from A in G by following a path in E.

The second fundamental question about nSPARQL is how
expressive the language is. We first show that nSPARQL is expressive enough to capture the deductive rules of RDFS. Evaluating
queries which involve the RDFS vocabulary is challenging, and there
is not yet consensus in the Semantic Web community on how to
define a query language for RDFS. In this respect, we show that
the RDFS evaluation of an important fragment of SPARQL can be
obtained by posing nSPARQL queries that directly traverse the input
RDF data. It should be noticed that nested regular expressions are
used in nSPARQL to capture the inference rules of RDFS. Thus, a
second natural question about nSPARQL is whether these expressions are necessary to obtain this result. In this paper, we show that
nesting is indeed necessary in nSPARQL to deal with the semantics
of RDFS. More precisely, we show that regular expressions alone
are not enough in nSPARQL to obtain the RDFS evaluation of some
queries by simply navigating the RDF data.

Finally, we also consider the question of whether the SPARQL
operators add expressive power to nSPARQL. Given that nested regular expressions are a powerful navigational tool, one may wonder
whether the SPARQL operators can be somehow represented by
using these expressions. Or even if this is not the case, one may
wonder whether there exist natural queries that can be expressed
in nSPARQL, which cannot be expressed by using only nested regular expressions. In our last result, we show that this is the case.
More precisely, we prove that there are simple and natural queries
that can be expressed in nSPARQL and cannot be expressed by using
only nested regular expressions.

Organization of the paper. In Section 2, we introduce some
basic notions about RDF, RDFS, and SPARQL. In Section 3, we define
the notion of nested regular expression, and prove that these
expressions can be evaluated efficiently. In Section 4, we define
the language nSPARQL. In Section 5, we show that nSPARQL can
be used to answer RDFS queries. In Section 6, we present some
result regarding the expressiveness of nSPARQL. In particular, we

show that if nesting is disallowed in nSPARQL, then one obtains
an strictly less expressive language that cannot encode the process
of inference in RDFS. Related work is given in Section 7, and the
concluding remarks are given in Section 8.

2. Preliminaries

RDF is a graph data format for the representation of information in the Web. An RDF statement is a subjectpredicateobject
structure, called RDF triple, intended to describe resources and
properties of those resources. For the sake of simplicity, we assume
that RDF data is composed only by elements from an infinite set U of
IRIs. Formally, an RDF triple is a tuple (s, p, o) U  U  U, where s
is the subject, p the predicate and o the object. An RDF graph is a finite
set of RDF triples. Moreover, we denote by voc(G) the elements from
U that are mentioned in G.

In this paper, we do not consider anonymous resources called
blank nodes in the RDF data model, that is, our study focuses on
ground RDF graphs. It should be noticed that SPARQL [27], the W3C
standard query language for RDF, considers blank nodes simply as
constants values without giving them their existential semantics
[18]. Moreover, there is not yet full consensus in the Semantic Web
community on how an RDF query language should deal with the
semantics of blank nodes. Thus, we decide not to make an assumption about this semantics and focus in this paper on the fragment
of RDF consisting of ground graphs, for which the query answering
process has a well-understood semantics.

Fig. 1 shows an RDF graph that stores information about transportation services between cities. In this figure, a triple (s, p, o) is
po, that is, s and o are represented as nodes
depicted as an edge s
and p is represented as an edge label. For example, (Paris, TGV,
Calais) is a triple in the graph that states that TGV provides a transportation service from Paris to Calais. Notice that an RDF graph is
not a standard labeled graph as its set of edge labels may have a
nonempty intersection with its set of nodes. For instance, in the
RDF graph in Fig. 1, TGV is simultaneously acting as a node and as
an edge label.

The RDF specification includes a set of reserved words (reserved
elements from U) with predefined semantics, the RDFS vocabulary
(RDF Schema [8]). This set of reserved words is designed to deal with
inheritance of classes and properties, as well as typing, among other
features [8]. In this paper, we consider the subset of the RDFS vocabulary composed by rdfs:subClassOf, rdfs:subPropertyOf, rdfs:range,
rdfs:domain and rdf:type, which are denoted by sc, sp, range, dom

Table 1
RDFS inference rules.

(1) Sub-property
(a) (A,sp,B) (B,sp,C)
(b) (A,sp,B) (X,A,Y)

(A,sp,C)

(X,B,Y)

(2) Subclass
(a) (A,sc,B) (B,sc,C)
(b) (A,sc,B) (X,type,A)

(A,sc,C)

(X,type,B)

(3) Typing
(a) (A,dom,B) (X,A,Y)
(b) (A,range,B) (X,A,Y)

(X,type,B)

(Y,type,B)

and type, respectively. This fragment of RDFS was considered in
Ref. [23]. In that paper, the authors provide a formal semantics for
it, and also show that this fragment is well-behaved as the remaining RDFS vocabulary does not interfere with the semantics of this
fragment. The semantics proposed in Ref. [23] was shown to be
equivalent to the full RDFS semantics when one focuses on the fragment mentioned above. We further assume in this paper that the
reserved words sc, sp, range, dom and type, can only occur in the
predicate position of RDF triples.

We use the system of rules in Table 1. This system was proved
in Ref. [23] to be sound and complete for the inference problem for
RDFS in the presence of sc, sp, range, dom and type, under some
mild assumptions (see Ref. [23] for further details). In every rule,
letters A, B, C, X, and Y, stand for variables to be replaced by actual
terms. More formally, an instantiation of a rule is a replacement of
the variables occurring in the triples of the rule by elements of U.
An application of a rule to a graph G is defined as follows. Given a
rule r, if there is an instantiation (R/R) of r such that R  G, then
the graph G = G  R is the result of an application of r to G. We
say that a triple t is deduced from G, if either t  G or there exists a
graph G such that t  G and G is obtained from G by successively
applying the rules in Table 1.

Example 2.1.
Let G be the RDF graph in Fig. 1. This graph contains RDFS annotations for transportation services. For instance,

 If P1 and P2 are graph patterns, then (P1 AND P2), (P1 OPT P2), and
(P1 UNION P2) are graph patterns.
 If P is a graph pattern and R is a SPARQL built-in condition, then
the expression (P FILTER R) is a graph pattern.

A SPARQL built-in condition is a Boolean combination of terms
constructed by using equality (=) among elements in U  V, and the
unary predicate bound over variables. Formally,
 if ?X, ?Y  V and c  U, then bound(?X), ?X = c and ?X =?Y are
built-in conditions; and
 if R1 and R2 are built-in conditions, then (R1), (R1  R2) and (R1 
R2) are built-in conditions.

Given a graph pattern P, we denote by var(P) the set of variables
occurring in P. Similarly, for a built-in condition R, var(R) denotes
the set of variables occurring in R. We impose the following safety
condition to graph patterns. A graph pattern Q is safe if for every
sub-pattern (P FILTER R) of Q, it holds that var(R)  var(P). This is a
natural safety condition which is present in most database query
languages. In this paper, we assume that every graph pattern is
safe.

To define the semantics of SPARQL graph patterns, we need to
introduce some terminology. A mapping  from V to U is a partial function  : V  U. For a triple pattern t, we denote by (t)
the triple obtained by replacing the variables in t according to .
The domain of , denoted by dom(), is the subset of V where 
is defined. Two mappings 1 and 2 are compatible if for every
x  dom(1)  dom(2), it is the case that 1(x) = 2(x), i.e. when
1  2 is also a mapping. Let  1 and  2 be sets of mappings. We
define the join, the union, the difference, and the left-outer join
between  1 and  2 as:

(Seafrance, sp, ferry) states that Seafrance is a sub-property of ferry.
Thus, we know that there is a ferry going from Calais to Dover since
(Calais, Seafrance, Dover) is in G. This conclusion can be obtained
by a single application of rule (1b) to triples (Seafrance, sp, ferry)
and (Calais, Seafrance, Dover), from which we deduce triple (Calais,
ferry, Dover). Moreover, by applying the rule (3b) to this last triple
and (ferry, range, coastal city), we deduce triple (Dover, type,
coastal city) and, thus, we conclude that Dover is a coastal city.

2.1. The RDF query language SPARQL

Jointly with the release of RDF in 1999 as Recommendation of
the W3C, the natural problem of querying RDF data was raised.
Since then, several designs and implementations of RDF query languages have been proposed [14]. In 2004, the RDF Data Access
Working Group (part of the Semantic Web Activity) released a first
public working draft of a query language for RDF, called SPARQL
[27]. Currently, SPARQL is a W3C recommendation, and has become
the standard language for querying RDF data.

In this section, we present the query language SPARQL by considering the algebraic formalization introduced in Ref. [25]. Assume
the existence of an infinite set V of variables disjoint from U. A
SPARQL graph pattern is recursively defined as follows:
 A tuple from (U  V)  (U  V)  (U  V) is a graph pattern (a triple
pattern).

The evaluation of a graph pattern over an RDF graph G, denoted by
  , is defined recursively as follows:
 tG = {|dom() = var(t) and (t) G}, where var(t) is the set of
variables occurring in t.
 (P1 AND P2)G = P1G	P2G, (P1 UNION P2)G = P1G  P2G,
and

The semantics of FILTER expressions goes as follows. Given a
mapping  and a built-in condition R, we say that  satisfies R,
denoted by   R, if (we omit the usual rules for Boolean operators):
 R is bound(?X) and ?X  dom();
 R is ?X = c, where c  U, ?X  dom() and (?X) = c;
 R is ?X =?Y, ?X  dom(), ?Y  dom() and (?X) = (?Y).
Then (P FILTER R)G = { PG|  R}.

It was shown in Ref. [25], among other algebraic properties, that
AND and UNION are associative and commutative, thus permitting us to avoid parenthesis when writing sequences of either AND
operators or UNION operators.

2.2. The semantics of SPARQL over RDFS

SPARQL follows a subgraph-matching approach, and thus, a
SPARQL query treats RDFS vocabulary without considering its pre-

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

can be particularly inefficient for queries that do not involve the
RDFS vocabulary and do not need any RDFS inference in order to
be answered. Third, the approach is not goal-oriented. Although in
practice most queries use just a fragment of the RDFS vocabulary
and would need only to scan a small part of the initial data, all the
vocabulary and the data is considered when computing the closure.
Let us present a simple scenario that exemplifies the benefits of a
goal-oriented approach. Consider an RDF graph G and a query Q that
asks whether a resource A is a sub-class of a resource B. Answering Q amounts to check whether the triple (A, sc, B) is implied
by G. The predefined semantics of RDFS states that sc is a transitive relation among resources. Thus, to answer Q, a goal-oriented
approach should not compute the closure of the entire input graph,
but instead it should just verify whether there exist resources R1,
R2, . . ., Rn such that A = R1, B = Rn, and (Ri, sc, Ri+1) is a triple in G
for i = 1, . . . , n  1. That is, one can answer Q by checking the existence of an sc-path from A to B in G, which can be done in linear time
by using a graph reachability algorithm. It should be noticed that
the approach that materializes cl(G) cannot take less than quadratic
time in answering this query, as the size of cl(G) may be quadratic
in the size of G.

It was shown in Ref. [23] that testing whether a triple is implied
by an RDFS graph G can be done without computing the closure of G.
The idea is that the RDFS vocabulary is weak enough to warrant that
one can determine whether a triple is implied by G just by checking
the existence of some paths in G, very much like our simple example above. The good news is that these paths can be specified by
using regular expressions plus some additional features. For exam-
ple, to check whether (A, sc, B) belongs to the closure of a graph G,
we already saw that it is enough to check whether there is a path
from A to B in G where each edge has label sc. This observation
+,
motivates the use of extended triple patterns of the form (A, sc
+ is the regular expression denoting paths of length
B), where sc
at least 1 and where each edge has label sc. Thus, one can readily see that a language for navigating RDFS data would be useful
for answering queries according to the predefined semantics of the
RDFS vocabulary.

Driven by this motivation, in this paper we introduce the query
language nSPARQL that extends SPARQL with navigational capabil-
ities. This language is expressive enough to capture the deductive
rules of RDFS. And not only that, it can be used to pose many
interesting and natural queries over RDF data, which otherwise cannot be expressed. In the rest of this paper, we formally introduce
nSPARQL, and study some of its fundamental properties. We start
this study by introducing the notion of nested regular expression
in the following section, which is the building block of nSPARQL.

3. Nested regular expressions for RDF data

One of our main goals in this paper is to define a query language that allows to pose interesting navigational queries over
an RDF graph. In this section, we define such a navigational language providing a formal syntax and semantics. Our language uses,
as usual for graph query languages [22,5], regular expressions to
define paths on graph structures, but taking advantage of the special features of RDF graphs. We extend classical regular expressions
by borrowing the notion of branching from XPath [11], to obtain the
language of nested regular expressions to navigate RDF data.

The navigation of a graph is usually done by using an operator
next, which allows one to move from one node to an adjacent one
in a graph. In our setting, we have RDF graphs, which are sets of
triples, not classical graphs. In particular, the sets of nodes and edge
labels of an RDF graph can have a nonempty intersection. Hence, a
language for navigating RDF graphs should be able to deal with this
type of objects. In this section, we introduce the notion of nested

Fig. 2. An RDF graph storing information about soccer players.

defined semantics. For example, consider the RDF graph G in Fig. 2,
which stores information about soccer players, and consider the
graph pattern P = (?X, works in, ?C). Note that, although the triples
(Ronaldinho, works in, Barcelona) and (Sorace, works in, Everton)
can be deduced from G, we obtain the empty set as the result of
evaluating P over G as there is no triple in G with works in in the
predicate position.

We are interested in defining the semantics of SPARQL over
RDFS, that is, taking into account not only the explicit RDF triples of
a graph G, but also the triples that can be derived from G according
to the semantics of RDFS. Let the closure of an RDF graph G, denoted
by cl(G), be the graph obtained from G by successively applying
the rules in Table 1 until the graph does not change. For instance,
Fig. 3 shows the closure of the RDF graph of Fig. 2. The solid lines
in Fig. 3 represent the triples in the original graph, and the dashed
lines the additional triples in the closure. The most direct way of
defining a semantics for the RDFS evaluation of SPARQL patterns
is by considering not the original graph but its closure. Thus, if we
now evaluate pattern P = (?X, works in, ?C) over the RDF graph in
Fig. 3, we obtain the mappings {?X  Ronaldinho,?C  Barcelona}
and {?X  Sorace,?C  Everton}. The theoretical formalization of
such an approach was studied in Ref. [15]. The following definition
formalizes this notion.

Definition 2.2. Given a SPARQL graph pattern P, the RDFS evaluation of P over G, denoted by Prdfs
G , is defined as the set of mappings
Pcl(G), that is, as the evaluation of P over the closure of G.

It is important to notice that the previous definition gives a simple algorithm for evaluating SPARQL queries over RDFS data; given a
query Q over an RDF graph G with RDFS vocabulary, the closure cl(G)
of G is materialized first, and then Q is evaluated over cl(G). In par-
ticular, this algorithm has the advantage that if several queries are
to be posed over a fixed RDF graph G, then cl(G) has to be computed
only once in order to answer these queries.

Unfortunately, the approach mentioned in the previous paragraph has some drawbacks that limit their practical applicability,
First, it is known that the closure of a graph G can be of quadratic
size in the size of G [23], making the computation and storage of
the closure too expensive for web-scale applications1. Second, once
the closure has been computed, the queries are evaluated over a
data source which can be much larger than the original one. This

1 Currently, one can find RDF databases of one or more gigabytes of data, whose

closure may need an exabyte of storage.

Fig. 3. The closure of the RDF graph of Fig. 2.

regular expression to navigate through an RDF graph. This notion
takes into account the special features of the RDF data model. In
particular, nested regular expressions use three different naviga-
1 and
tion axes next, edge and node, and their inverses next
1, to move through an RDF triple. These axes are shown in
node
Fig. 4.

1, edge

A navigation axis allows one to move one step forward (or back-
ward) in an RDF graph. Thus, a sequence of these axes defines a path
in an RDF graph. For instance, in the graph of Fig. 5, the sequence
of axes

next/next/edge/next/next

1/node

defines a path between nodes a1 and a6 (the path is shown with
dashed lines in the figure). Moreover, one can use classical regular
expressions over these axes to define a set of paths that can be
used in a query. The language considers an additional axis self
that is used not to actually navigate, but instead to test the label of
a specific node in a path. The language also allows nested expressions
that can be used to test for the existence of certain paths starting
at any axis. The following grammar defines the syntax of nested
regular expressions:
exp := axis| axis::a (a U)| axis::[exp]| exp/exp| exp| exp| exp, (1)
where axis{self, next, next

1, edge, edge

1, node, node

1}.

Fig. 4. Forward and backward axes for an RDF triple (a, p, b).

Before introducing the formal semantics of nested regular
expressions, we give some intuition about how these expressions
are evaluated in an RDF graph. The most natural navigation axis is
next::a, with a an arbitrary element from U. Given an RDF graph G,
the expression next::a is interpreted as the a-neighbor relation in
G, that is, the pairs of nodes (x, y) such that (x, a, y) G. Given that
in the RDF data model a node can also be the label of an edge, the
language allows us to navigate from a node to one of its leaving
edges by using the edge axis. More formally, the interpretation of
edge::a is the pairs of nodes (x, y) such that (x, y, a) G. The nesting construction [exp] is used to check for the existence of a path
defined by expression exp. For instance, when evaluating nested
expression next::[exp] in a graph G, we retrieve the pairs of nodes
(x, y) such that there exists z with (x, z, y) G, and such that there
is a path in G that follows expression exp starting in z.
The evaluation of a nested regular expression exp in a graph G
is formally defined as a binary relation expG, denoting the pairs
of nodes (x, y) such that y is reachable from x in G by following a
path that conforms to exp. The formal semantics of the language is
shown in Table 2. In this table, G is an RDF graph, a U, voc(G) is
the set of all the elements from U that are mentioned in G, and exp,
exp1, exp2 are nested regular expressions.
As is customary for regular expressions, given a nested regular expression exp, we use exp+ as a shorthand for exp/exp. The
following is a simple example of the evaluation of a nested regular
expression. We present more involved examples when introducing
the nSPARQL language.

Example 3.1. Let G be the graph in Fig. 1, and consider expression
exp1 = next::[next::sp/self::train].
The expression next:: sp / self:: train defines the pairs of nodes
(z, w) such that from z one can follow an edge labeled sp and reach
a node w with label train (expression self:: train is used to perform this last test). Thus, the nested expression [next:: sp / self::
train] performs an existential test; it is satisfied by the nodes in
G from which there exists a path that follows an edge labeled sp
and reaches a node labeled train. There is a single such node in G,
namely TGV. Restricted to graph G, expression exp1 is equivalent
to next:: TGV and, thus, it defines the pairs of nodes that are connected by an edge labeled TGV. Hence, the evaluation of exp1 in G
is exp1G = {(Paris,Calais), (Paris,Dijon)}.

Fig. 5. Nodes a1 and a6 are connected by a path that follows the sequence of navigational axes next/next/edge/next/next

1/node.

In the following section, we introduce the language nSPARQL
that combines the operators of SPARQL with the navigational capa-

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

At this point, the reader may wonder why we do not consider the
problem of, giving a nested regular expression exp and an RDF graph
G, listing all the pairs in expG. Notice that any algorithm that solves
this last problem needs at least quadratic time with respect to the
RDF graph G, since just writing down the output needs quadratic
time in the worst case. On the other hand, this lower bound cannot
be directly proved for the two problems considered in this section;
the output of the decision problem is of constant size (it is a no/yes
answer), and the output of the problem of listing the nodes that
are connected to a given node is linear in the size of the input RDF
graph. Thus, it is worth studying whether these two problems can
be solved efficiently (which is by no means trivial).

In this section, we show that the two problems mentioned above
can be solved efficiently (in fact, in linear time with respect to the
size of the input RDF graph). More precisely, we provide algorithms
that solve these problems in time O(|G|  |exp|), where |G| denotes
the size of the input RDF graph and |exp| denotes the size of the
nested regular expression being evaluated.

(edge

1 :: o, s)  (p). Moreover, we

We assume that an RDF graph G is stored as an adjacency
list that makes explicit the navigation axes (and their inverses).
Thus, every u voc(G) is associated with a list of pairs  (u), where
every pair contains a navigation axis and the destination node.
For instance, if (s, p, o) is a triple in G, then (next :: p, o)  (s)
and
that
(self :: u, u)  (u) for every u voc(G). Notice that if the number
of triples in G is N, then the adjacency list representation uses space
O(N). Thus, when measuring the size of G, we use |G| to denote the
size of its adjacency list representation. We further assume that
given an element u voc(G), we can access its associated list  (u) in
time O(1). This is a standard assumption for graph data-structures
in a RAM model [13]. Fig. 6 shows an example of an adjacency-list
representation of an RDF graph. For a nested regular expression
exp, we use |exp| to denote the size of the expression.

assume

1, node, node

1, edge, edge

The idea of the algorithm for the evaluation of nested regular
expressions is motivated by the algorithms for the evaluation of some temporal logics [12] and propositional dynamic
logic [1,16]. We say that expression exp
is a nested subexif the expression axis::[exp] occurs in exp,
pression of exp,
1}. Given
with axis{self, next, next
an RDF graph G and a nested regular expression exp, the algorithm
proceeds by recursively considering the nested subexpressions of
exp, labeling every node u of G with a set label(u) of nested expres-
sions. Initially, label(u) is the empty set. Then at the end of the
execution of the algorithm, it holds that exp label(u) if and only
if there exists z such that (u, z) expG. Before giving any technical details, let us show the general idea of this process with an
example. Fig. 7 exemplifies the process for a graph G and the nested
expression:
 = next::a/(next::[next::b/self::c])

(edge::[next::d]|next::a)

+.

(2)

Table 2
Formal semantics of nested regular expressions.
selfG = {(x, x)| x  voc(G)}
self::aG = {(a, a)}
nextG = {(x, y)| there exists z s.t. (x, z, y) G}
next::aG = {(x, y)| (x, a, y) G}
edgeG = {(x, y)| there exists z s.t. (x, y, z) G}
edge::aG = {(x, y)| (x, y, a) G}
nodeG = {(x, y)| there exists z s.t. (z, x, y) G}
node::aG = {(x, y)| (a, x, y) G}
axis
axis
exp1/exp2G = {(x, y)| there exists z s.t. (x, z)exp1G and (z, y)exp2G}
exp1|exp2G = exp1G  exp2G
expG = selfG  expG  exp/expG  exp/exp/expG  
self::[exp]G = {(x, x)| x  voc(G) and there exists z s.t. (x, z)expG}
next::[exp]G = {(x, y)| there exist z, w s.t. (x, z, y) G and (z, w)expG}
edge::[exp]G = {(x, y)| there exist z, w s.t. (x, y, z) G and (z, w)expG}
node::[exp]G = {(x, y)| there exist z, w s.t. (z, x, y) G and (z, w)expG}
axis

1G = {(x, y)| (y, x)axisG} with axis {next, node, edge}
1::aG = {(x, y)| (y, x)axis::aG} with axis {next, node, edge}

1::[exp]G = {(x, y)|(y, x)axis::[exp]G} with axis {next, node, edge}

bilities of nested regular expressions. But before introducing this
language, we show that nested regular expressions can be evaluated efficiently, which is an essential requirement if one wants to
use nSPARQL for web-scale applications.

3.1. An efficient algorithm for evaluating nested regular
expressions

In this section, we present an algorithm that efficiently solves
the evaluation problem for nested regular expressions over RDF
graphs. More precisely, we consider two problems associated to
nested regular expressions. The first one is the decision problem
of verifying whether a given pair of nodes is in the evaluation of a
nested regular expression over an RDF graph. This decision problem
is formally defined as follows:

Problem: Evaluation problem for nested regular expressions.
Input: An RDF graph G, a nested regular expression exp, and a pair (a, b).
Question: Is (a, b)expG.

It is important to notice that this problem considers the pair of
nodes (a, b) as part of the input. This is the standard decision problem considered when studying the complexity of a query language
[28]. The second problem considered in this paper is the following
computation problem associated to nested regular expressions:

Problem: Computation problem for nested regular expressions.
Input: An RDF graph G, a nested regular expression exp, and a node a.
Output: List all the elements b such that (a, b)expG.

Thus, the problem is to give a list with all the nodes that are
reachable from a fixed node a by following an expression exp in an
RDF graph G.

Fig. 6. Adjacency-list representation (below) of an RDF graph (above).

Notice that a nested regular expression exp can be viewed as a classical regular expression over the alphabet D0(exp). We denote by
Aexp the -NFA that accepts the language generated by the regular
expression exp over the alphabet D0(exp). For example, Fig. 8 shows
an -NFA A that accepts the language generated by expression 
in (2) over the alphabet D0(). As for the case of RDF graphs, we
assume that -NFAs are stored using an adjacency-list representa-
tion.
In the algorithm, we use the product automaton G  Aexp,
which is constructed as follows. Assume that we have the graph
G labeled with respect to the nested subexpressions of exp, that
is, for every node u of G and nested subexpression exp of exp, we
have that exp  label(u) if and only if there exists a node v such
that (u, v) expG. Let Q be the set of states of Aexp, and  : Q 
(D0(exp)  {})  2Q the transition function ofAexp. The set of states
of G  Aexp is voc(G)  Q , and its transition function  : (voc(G) 
Q )  (D0(exp)  {})  2voc(G)Q is defined as follows. For every
(u, p) voc(G)  Q and s D0(exp), we have that (v, q) ((u, p), s)
if and only if q (p, s) and one of the following cases hold:
 s = axis and there exists a such that (axis::a, v)  (u),
 s = axis::a and (axis::a, v)  (u),
 s = axis::[exp] and there exists b such that (axis::b, v)  (u) and
exp label(b),
where axis{self, next, next
1}. Addi-
tionally, if q (p, ) we have that (u, q) ((u, p), ) for every
u voc(G). That is, G  Aexp is the standard product automaton of
G and Aexp if G is viewed as an -NFA over the alphabet D0(exp).
Fig. 8 shows the product automaton G  A for the nested expression  in (2) and the graph G of Fig. 7 (labeled with respect to
the nested subexpressions of ). For space reasons, we have only
depicted the states of G  A that are reachable from the initial
state. For instance, we have that there is a transition from (r2, q1)
to (r4, q1) with symbol next::[next::b/self::c] since: (i) there is a
transition from q1 to q1 with next::[next::b/self::c] in A, and (ii)
(next::r3, r4)  (r2) and  = next::b/self::c  label(r3).

1, edge, edge

1, node, node

There are two key observations about the product automaton
defined above that should be made. Let G be a graph labeled with
respect to the nested subexpressions of exp, and Aexp an -NFA for
exp. Assume that q0 is the initial state of Aexp and qf is one of its

/(edge::|next::a)

/(edge::[next::d]|next::a)

Fig. 7. Example of the labeling process of the RDF graph G according to expression  = next::a/(next::[next::b/self::c])
. First, node r3
is marked with label  = next::b/self::c (since (r3, c)G), and node r6 with
label  = next::d (since (r6, r7)G). Finally, node r1 is labeled with  (since
(r1, r5)G). This last label is obtained by considering the expression  =
next::a/(next::)
The process first considers the nested subexpressions  =
next::b/self::c and  = next::d, and marks the nodes in G according to which ones of these subexpressions they satisfy. Thus,
after this stage we have that   label(r3) since (r3, c) G, and
 label(r6) since (r6, r7) G (see Fig. 7). Using this information,
we mark the nodes according to whether they satisfy , but considering the previously computed labels ( and ) and the expression
 = next::a/(next::)
. In the example of Fig. 7,
we have that (r1, r5) G and, thus,   label(r1).

/(edge::|next::a)

We now explain how to efficiently carry out the labeling process
by using some tools from automata theory (here we assume some
familiarity with this theory).

A key idea in the algorithm is to associate to each nested regular
expression a nondeterministic finite automaton with -transitions
(-NFA). Given a nested regular expression exp, we recursively
define the set of depth-0 terms of exp, denoted by D0(exp), as follows:
 D0(exp) = {exp} if exp is either axis, or axis::a, or axis::[exp],
 D0(exp1/exp2) = D0(exp1|exp2) = D0(exp1)  D0(exp2),
 D0(exp) = D0(exp),
where axis{self, next, next
1, node, node
instance, for the nested expression  in (2), we have that
D0() = {next::a, next::[next::b/self::c], edge::[next::d]}.

1, edge, edge

1}. For

Fig. 8. Automaton A for the nested regular expression  in (2), and product automaton G  A.

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

final states. The first observation is that if there exists two elements
u, v voc(G) such that from (u, q0) one can reach state (v, qf ) in
G  Aexp, then (u, v) expG. In the example of Fig. 8, we have that
(r1, r5) G since we can reach state (r5, qf ) from state (r1, q0)
in G  A. The second observation is that given a nested regular
expression exp, one can construct in linear time an -NFA for exp by
using standard techniques. Thus, given a nested regular expression
exp and an RDF graph G that has been labeled with respect to the
nested subexpressions of exp, it is easy to see that automaton G 
Aexp can be constructed in time O(|G|  |Aexp|).

for each axis::[exp] D0(exp) do
call Label(G, exp)
construct Aexp, and assume that q0 is its initial state and F is its set of final states
construct G  Aexp
for each state (u, q0) that is connected to a state (v, qf ) in G  Aexp, with qf  F do
label(u) := label(u)  {exp}

Now we have all the necessary ingredients to formally present
the algorithm for the evaluation problem for nested regular expres-
sions. This algorithm is split in two procedures: Label labels G
according to the nested subexpressions of exp as explained above,
and Eval returns Yes if (a, b) expG and No otherwise.
Label(G, exp):
1.
2.
3.
4.
5.
6.
Eval(G, exp, (a, b)):
1.
label(u) := 
2.
call Label(G, exp)
3.
construct Aexp, and assume that q0 is its initial state and F is its set of final states
4.
construct G  Aexp
5.
if a state (b, qf ), with qf  F, is reachable from (a, q0) in G  Aexp
6.
then return Yes
7.
else return No
8.

for each u voc(G) do

Procedure Eval solves the evaluation problem for

Theorem 3.2.
nested regular expressions in time O(|G|  |exp|).
Proof. Assume that for every u, it holds that label(u) = . We
argue that after the execution of procedure Label(G, exp), it holds
that exp label(u) if and only if there exists v such that (u, v) expG.
We proceed by induction on the depth in the tree of recursive calls
to Label. The base case is when D0(exp) have no expressions of the
form axis::[exp]. The property in this case follows by the definition of the product automaton G  Aexp. It is easy to see that there
exists a state (u, q0) that is connected to a state (v, qf ) in G  Aexp,
with q0 the initial state of Aexp and qf a final state of Aexp, if and
only if (u, v) expG. Just recall that D0(exp) has no expressions of
the form axis::[exp] and, thus, exp is a standard regular expression
with no nested subexpressions. Now, assume that D0(exp) contains some expression of the form axis::[exp]. At the beginning,
procedure Label is executed for every expression exp such that
axis::[exp] D0(exp). By induction hypothesis, after these calls we
have that if axis::[exp] D0(exp), then exp  label(u) if and only if
there exists v such that (u, v) expG. Again by the definition of
the product automaton G  Aexp, it is easy to see that there exists
a state (u, q0) that is connected to a state (v, qf ) in G  Aexp, with
q0 the initial state of Aexp and qf a final state of Aexp, if and only
if (u, v) expG. The correctness of procedure Eval follows directly
from this property.
It only remains to show that procedure Eval runs in time O(|G| 
|exp|). To prove this, we need some terminology. Define the set of
depth-i terms (i  1) of a nested expression exp by

Di(exp) =

axis::[exp] Di1(exp)

D0(exp

).

For instance, for the nested expression

 = next::a/(next::[next::[edge::b]])

+/next::[(next::b)

/self::d],

we have that
D0() = {next::a, next::[next::[edge::b]], next::[(next::b)
D1() = {next::[edge::b], next::b, self::d},
D2() = {edge::b},
D3() = .
Define the depth of a nested expression exp as the minimum integer
d such that Dd+1(exp) = . For instance, the depth of expression 
above is 2.

/self::d]},

The first important observation is that the total number of recur-

sive calls to Label in the execution of the algorithm is at most:

k =

|Di(exp)|,

i=1

where d is the depth of exp. Notice that k is bounded by |exp|.
The second important observation is that for every nested regular
expression exp, one can construct an automaton Aexp whose size is
linear in the number of occurrences of symbols of D0(exp) in exp.
With these observations, we conclude that the total time spent constructing all the product automata in the entire execution of Label
is O(|G|  |exp|). The final observation is how to efficiently execute
step 5 in each recursive call to Label. Assume that Label has been
called with expression exp. Notice that in step 5 we do not need to
make an iteration over the states of G  Aexp , but just to perform a
depth-first search to find the nodes of the form (u, q0) of G  Aexp ,
with q0 the initial state of Aexp , that reach a node (v, qf ) with qf a
final state of Aexp . This search can be done in time O(|G|  |Aexp|).
With these observations it is easy to conclude that with input exp,
procedure Label runs in time O(|G|  |exp|). Similarly, step 6 of procedure Eval can be carried out in time O(|G|  |exp|) and, thus, Eval
runs in time O(|G|  |exp|). 

The above algorithms can be directly used to efficiently solve
the computation problem of listing all the nodes that are reachable from a fixed node by following a nested regular expression.
As we have shown, after the call to Label(G, exp), we have that
(u, v) expG if and only if there exists a path from a state (u, q0)
to a state (v, qf ) in the automaton G  Aexp, where q0 is the initial state of Aexp and qf is one of its final states. Thus, given an
element a voc(G), one can list all the elements b voc(G) such
that (a, b) expG by performing a depth-first search over G  Aexp
starting at (a, q0). The whole process takes time O(|G|  |exp|). Thus,
we have the following result.

Theorem 3.3. Given an RDF graph G, a nested regular expression exp
and an element a, listing all the elements b such that (a, b) expG can
be done in time O(|G|  |exp|).

4. nSPARQL: an RDF query language with navigational
capabilities

In this section, we introduce the language nested SPARQL (or
just nSPARQL), which is an RDF query language with navigational
capabilities.

The query language nSPARQL is essentially obtained by using
triple patterns with nested regular expressions in the predicate
position, plus SPARQL operators AND, OPT, UNION, and FILTER as
we defined them in Section 2.1. More precisely, a nested regular
expression triple (or just nre-triple) is a tuple t of the form (x, exp, y),
where x, y U  V and exp is a nested regular expression. nSPARQL
graph patterns are then recursively defined from nre-triples:
 An nre-triple is an nSPARQL graph pattern.
 If P1 and P2 are nSPARQL graph patterns and R is a builtin condition, then (P1 AND P2), (P1 OPT P2), (P1 UNION P2), and
(P1 FILTER R) are nSPARQL graph patterns.

It should be noticed that in nSPARQL, we are using the algebraic formalization for SPARQL graph patterns proposed in Ref.
[25]. In particular, we are not considering projection (i.e. the SELECT
operator) in our language. Clearly, projection would add expressive
power to the language, but at the cost of increasing the complexity of the evaluation problem for some fragments of the language
(see Section 7 for a detailed discussion on this topic). Thus, we
have decided to use the core algebraic fragment of SPARQL [25] to
construct our nSPARQL language. As we show in the next sections,
this decision allows us to obtain a language with good properties
regarding expressiveness and complexity of evaluation.

To define the semantics of nSPARQL, we just need to define the
semantics of nre-triples, as the semantics of the operators AND,
OPT, UNION, and FILTER is defined exactly as for the case of SPARQL
(see Section 2.1). The evaluation of an nre-triple t = (?X, exp, ?Y)
over an RDF graph G is defined as the following set of mappings:
tG = {| dom() = {?X, ?Y} and ((?X), (?Y)) expG}.
Similarly, the evaluation of an nre-triple t = (?X, exp, a) over
an RDF graph G, where a U,
is defined as {| dom() =
{?X} and ((?X), a) expG}, and likewise for (a, exp, ?X) and
(a, exp, b) with b U.
Notice that every SPARQL triple (?X, p, ?Y) with p U is equivalent to nSPARQL triple (?X, next::p, ?Y). Also notice that, since
variables are not allowed in nested regular expressions, the occurrence of variables in the predicate position of triple patterns is
forbidden in nSPARQL. Nevertheless, every SPARQL triple of the
form (?X, ?Y, a), with a U, is equivalent to nSPARQL pattern
(?X, edge::a, ?Y). Similarly, the triple (a, ?X, ?Y) is equivalent to
(?X, node::a, ?Y). Thus, what we are losing in nSPARQL is only the
possibility of using variables in the three positions of a triple pat-
tern. We decided not to include this type of triples in nSPARQL
for two reasons: they do not clearly represent the idea of navi-
gation, and they are not needed in nSPARQL to evaluate queries
according to the semantics of RDFS (see Section 5). In fact, a triple
of the form (?X, exp, ?Y) indicates that one has to navigate from
?X to ?Y by following pattern exp, while a navigation criteria
like this cannot be used to evaluate a triple pattern of the form
(?X, ?Y, ?Z).

As pointed out in Section 1, it has been largely recognized
that navigational capabilities are fundamental for graph databases
query languages. However, although RDF is a directed labeled graph
data format, SPARQL only provides limited navigational function-
alities. In this paper, we propose nSPARQL as a way to overcome
this limitation. Moreover, we study some of its fundamental properties in order to provide formal evidence of its usefulness as a
query language for RDF. In particular, we have already shown that
nested regular expressions can be evaluated efficiently, which is an
essential requirement if one wants to use nSPARQL for web-scale
applications. In the following sections, we study some fundamental properties related to the expressiveness of nSPARQL. But before
doing that, we show through some examples how the navigational
capabilities of nSPARQL can be used to express queries that are
likely to occur in the Semantic Web, but cannot be expressed in
SPARQL without using nested regular expressions.

,Dover) AND (?X, next::country,?Y).

Example 4.1. Let G be the RDF graph of Fig. 1 and P1 the following
pattern:
P1 = (?X, (next::TGV| next::Seafrance)

Pattern P1 retrieves cities, and the country where they are located,
such that there is a way to travel from those cities to Dover using
either TGV or Seafrance in every direct trip. The evaluation of P1
over G is {{?X  Paris,?Y  France}}. Notice that although there is
a direct way to travel from Calais to Dover using Seafrance, Calais
does not appear in the result since there is no information in G

about the country where Calais is located. We can relax this last
restriction by using the OPT operator:
P2 = (?X, (next::TGV| next::Seafrance)

,Dover) OPT (?X, next::country,?Y).

P2G = {{?X  Paris,?Y  France},{?X 

Then we have that
Calais}}.
Example 4.2. Assume that we want to obtain the pairs of cities
(?X, ?Y) such that there is a way to travel from ?X to ?Y by using
either Seafrance or NExpress, with an intermediate stop in a city
that has a direct NExpress trip to London. Consider nested expres-
sion:

exp1 = (next::Seafrance| next::NExpress)
self::[next::NExpress/self::London]/
(next::Seafrance| next::NExpress)

+.

+/

Then pattern P = (?X, exp1, ?Y) answers our initial query. Notice
that expression self::[next::NExpress/self::London] is used to
perform the intermediate existential test of having a direct NExpress trip to London.

(3)

/self::transport], ?Y).

Let G be the graph in Fig. 1 and P1 the following

Example 4.3.
pattern:
P1 = (?X, next::[(next::sp)
Pattern P1 defines the pairs of cities (?X, ?Y) such that, there
exists a triple (?X, p, ?Y) in the graph and a path from p to
transport where every edge has label sp. Thus, nested expres-
/self::transport] is used to emulate the process of
sion [(next::sp)
inference in RDFS; it retrieves all the nodes that are sub-properties
of transport (rule (1a) in Table 1). Therefore, pattern P1 retrieves
the pairs of cities that are connected by a direct transportation ser-
vice, which could be a train, ferry, bus, etc. In general, if we want
to obtain the pairs of cities such that there is a way to travel from
one city to the other, we can use the following nSPARQL pattern:
P2 = (?X, (next::[(next::sp)
In the following section, we prove that the navigational capabilities
of nSPARQL can be used to answer queries according to the semantics of RDFS. In particular, we show that the use of [] is essential
for this result, as patterns of the form (3) are used in this proof, and
they cannot be expressed in nSPARQL without using nesting.

/self::transport])

+, ?Y).

(4)

5. On RDFS and nSPARQL

In this section, we formally prove that the language of nested
regular expressions is powerful enough to deal with the predefined
semantics of RDFS. More precisely, we show that if one wants to
compute the answer of a SPARQL graph pattern P according to the
semantics of RDFS, then one can rewrite P into an nSPARQL graph
pattern Q such that Q retrieves the answer to P by directly traversing
the input graph.

Let us show with an example how nSPARQL can be used to obtain
the RDFS evaluation of some patterns by directly traversing the
input graph.

Example 5.1. Let G be the RDF graph in Fig. 2, and assume that we
want to obtain the type information of Ronaldinho. This information
can be obtained by computing the RDFS evaluation of the pattern (Ronaldinho,type, ?C). By simply inspecting the closure of G in
Fig. 3, we obtain that the RDFS evaluation of (Ronaldinho,type, ?C)
is the set of mappings:
{{?C  soccer player},{?C  sportsman},{?C  person}}.

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

, ?C).


However, if we directly evaluate this pattern over G, we obtain a
single mapping {?C  soccer player}. Consider now the nSPARQL
pattern:
P = (Ronaldinho, next::type/(next::sc)
The expression next::type/(next::sc)
is intended to obtain
the pairs of nodes such that there is a path between them
that starts with label type followed by zero or more labels
sc. When evaluating this expression in G, we obtain the
set of pairs {(Ronaldinho,soccer player), (Ronaldinho,sportsman),
(Ronaldinho,person), (Barcelona,soccer team)}. Thus, the evaluation of P results in the set of mappings:
{{?C  soccer player},{?C  sportsman},{?C  person}}.

In this case, pattern P is enough to obtain the type information of
Ronaldinho in G according to the RDFS semantics, that is,

(Ronaldinho,type, ?C)rdfs

G = (Ronaldinho,next::type/

(next::sc)

, ?C)G.


Although the expression next::type/(next::sc)
is enough to obtain
the type information for Ronaldinho in G, it cannot be used in general to obtain the type information of a resource. For instance, in the
same graph, assume that we want to obtain the type information
of Everton. In this case, if we evaluate the pattern (Everton, next::
type / (next:: sc), ?C) over G, we obtain the empty set. Consider
now the nSPARQL pattern:
Q = (Everton, node

/next::range, ?C).

1/(next::sp)

1/(next::sp)

/next::range, we follow a
With the expression node
path that first navigates from a node to one of its incoming edges
1, and then continues with zero or more sp edges
by using node
and a final range edge. The evaluation of this expression over
G results in the set {(Everton,soccer team), (Everton,company),
(Barcelona,soccer team), (Barcelona,company)}. Thus, the evaluation of Q in G is the set of mappings:
{{?C  soccer team},{?C  company}}.

By looking at the closure of G in Fig. 3, we see that pattern
Q obtains exactly the type information of Everton in G, that is,
(Everton,type, ?C)rdfs

G = QG.

Next we show that the ideas of the previous example can be generalized to the entire RDFS vocabulary. More precisely, we show
that if a SPARQL pattern P is constructed by using triple patterns
having at least one position with a non-variable element, then the
RDFS evaluation of P can be obtained by directly traversing the input
graph with an nSPARQL pattern. More precisely, consider the following translation function from elements in U to nested regular
expressions:
trans(sc) = (next::sc)

trans(sp) = (next::sp)

trans(dom) = next::dom
trans(range) = next::range
trans(type) = (next::type/(next::sc)
trans(p) = next::[(next::sp)

/self::p] for p / {sc, sp, range, dom, type}.

/next::range/(next::sc)

|edge/(next::sp)

/next::dom/

(next::sc)

|node

1/(next::sp)


Notice that we have implicitly used this translation function in
Examples 4.3 and 5.1. In the following lemma, we show that given
an RDF graph G and a triple pattern t not containing a variable in
the predicate position, the above translation function can be used
to obtain the RDFS evaluation of t over G by navigating G through a
nested regular expression.

Lemma 5.2. Let (x, p, y) be a SPARQL triple pattern with x, y U  V
G = (x, trans(p), y)G for every RDF graph
and p U. Then (x, p, y)rdfs
G.

Proof. The proof follows by a case by case analysis of the rules
in Table 1. For the cases where p is either sp, sc, dom, or range,
the proof is straightforward. The most complicated case is for the
type keyword. To prove the lemma, it is enough to show that
a triple of the form (a, type, b) can be deduced from G if and
only if (a, b) trans(type)G. We show the only if part of this
property by using an inductive argument. The other direction is
similar. The induction is on the number of rules used in a deduction of a triple of the form (a, type, b). If no rule is used, then
(a, type, b) G. In this case it is clear that (a, b) trans(type)G
G. If (a, type, b) / G then we
since (a, b) next::type/(next::sc)
have to consider three cases, depending on whether rule (2b),
(3a), or (3b) is the last rule used in a deduction of (a, type, b).
Assume first that rule (2b) is the last rule used in a deduction of
(a, type, b). Then we know that there exist triples (a, type, c) and
(c, sc, b) that can be deduced from G. By induction hypothesis we
know that (a, c) trans(type)G. Moreover, (c, sc, b) can only be
generated by using a sequence of (zero or more) applications of
rule (2a), which implies the existence of a path that follows only
G, and then
sc edges between c and b. Thus, (c, b) (next::sc)
G. By the definition of trans(type), it
(a, b) trans(type)/(next::sc)
G = trans(type)G and,
is easy to see that trans(type)/(next::sc)
thus, (a, b) trans(type)G. Assume now that rule (3a) is the last
rule used in a deduction of (a, type, b). Then there must exist
triples (a, q, c) and (q, dom, b) that can be deduced from G. Notice
that we are assuming that RDFS vocabulary only occurs in predicate position of triples. Thus, no rules can be used to deduce a
triple with dom in predicate position. Then we have that (q, dom, b)
belongs to G, and then (q, b) next::domG. Also notice that q /
{sp, sc, dom, range, type}. Thus, given that (a, q, c) is deduced from
G, there exists a triple (a, q, c) in G and a path from q to q that
G,
follows only sp edges. We have that (a, q) edge/(next::sp)
and then (a, b) edge/(next::sp)
since
/next::domG  trans(type)G, we have that
edge/(next::sp)
(a, b) trans(type)G. The analysis for the case of rule (3b) is anal-
ogous.
The only remaining case is when p / {sp, sc, dom, range, type}.
We have to show that (a, p, b) can be deduced from G if and
only if (a, b) trans(p)G. We show the only if direction, as
If (a, p, b) belongs to G, then
the other direction is similar.
we have that (a, b) next::pG = next::[self::pG]. Thus, since
next::[self::p]G  trans(p)G, we have that (a, b) trans(p)G.
Assume now that (a, p, b) / G. It is straightforward to see that
(a, p, b) is deduced from G if and only if there exists a triple
(a, p, b) in G and a path from p to p that follows only sp
+/self::pG and, thus,
edges. Then we have that (p, p) (next::sp)
(a, b) next::[(next::sp)

+/self::p]G  trans(p)G. 

/next::domG. Finally,

Suppose now that we have a SPARQL triple pattern t with a variable in the predicate position, but such that the subject and object
of t are not both variables. We show how to construct an nSPARQL
G = PtG. Assume that t = (x, ?Y, a) with
pattern Pt such that trdfs
x  U  V, ?Y  V, and a U, that is, t does not contain a variable in the
object position. Consider for every p{sc, sp, dom, range, type}, the
pattern Pt,p defined as ((x, trans(p), a) AND (?Y, self::p, ?Y)). Then
define pattern Pt as follows:
Pt = ((x, edge::a/(next::sp)

, ?Y) UNION Pt,sc UNION Pt,sp

UNION Pt,dom UNION Pt,range UNION Pt,type).

We can similarly define pattern Pt for a triple pattern t = (a, ?Y, x),
where a U, ?Y  V and x  U  V. Thus, we have the following
result.

Lemma 5.3. Let t = (x, ?Y, z) be a triple pattern such that ?Y  V and
x / V or z / V. Then trdfs
Proof. The proof follows from Lemma 5.2, and the fact that the
evaluation of nre-triple (?Y, self::p, ?Y) is always a single mapping
 such that dom() = {?Y} and (?Y) = p. 

G = PtG for every RDF graph G.

Let T be the set of triple patterns of the form (x, y, z) such that
x / V or y / V or z / V. We have translated every triple pattern t T
G = PtG. Moreover, for
into an nSPARQL pattern Pt such that trdfs
every triple pattern t, its translation is of size linear in the size of t.
Given that the semantics of SPARQL is defined from the evaluation
of triple patterns, we can state the following result. Its proof follows
directly from Lemmas 5.2 and 5.3.

Theorem 5.4.
Let P be a SPARQL pattern constructed from triple
patterns in T. Then there exists an nSPARQL pattern Q such that
G = QG for every RDF graph G. Moreover, pattern Q can be
Prdfs
automatically constructed from P in linear time.

We conclude this section by pointing out that the combination
of the translation function presented in this section and nested regular expressions can be very useful in practice, as it allows one to
write more expressive queries that need to take into consideration
the semantics of the RDFS vocabulary. In fact, the following example shows a query that needs of this combination in order to be
expressed.

Example 5.5. Let G be the RDF graph shown in Fig. 1. Assume that
one wants to retrieve the pairs of cities such that there is a way
of traveling (by using any transportation service) between those
cities, and such that every stop in the trip is a coastal city. The
following nSPARQL graph pattern expresses this query:
+, ?Y).
P = (?X, (trans(transport)/self::[trans(type)/self::coastal city])

6. On the expressiveness of nSPARQL

A fundamental question about any query language is what are
the relationship between its different elements, and whether some
of these elements are redundant. In this section, we raise this question for the case of nSPARQL. In particular, we consider in Section
6.1 the question of whether the nesting construct [] is necessary in
order to encode the inference process of RDFS, and then we consider
in Section 6.2 the question of whether the SPARQL operators add
expressive power to nSPARQL. In both cases, we obtain a positive
answer.

6.1. Regular expressions alone are not enough

Regular expressions are the most common way of giving navigational capabilities to query languages over graph databases [5],
and recently to query languages over RDF graphs [3,20,6]. Our language not only allows regular expressions over navigational axes
but also nesting of those regular expressions. In our setting, regular
expressions are obtained by forbidding the nesting operator and,
thus, they are generated by the following grammar:
exp := axis|axis::a (a U)|exp/exp|exp|exp|exp,
(5)
where axis{self, next, next
1}. Let
regular SPARQL (or just rSPARQL) be the language obtained from
nSPARQL by restricting nre-triples to contain in the predicate position only regular expressions (generated by grammar (5)). Notice
that rSPARQL is a fragment of nSPARQL and, thus, the semantics for
rSPARQL is inherited from nSPARQL.

1, node, node

1, edge, edge

Next we prove that regular expressions are not enough to obtain
the RDFS evaluation of some simple SPARQL patterns by directly

traversing the RDF graphs. In fact, we actually show that even for
the case of a SPARQL triple pattern, it could be the case that its RDFS
evaluation cannot be obtained by any rSPARQL pattern. But before
formally proving this, let us give some intuition about this failure.

Example 6.1. Assume that we want to obtain the RDFS evaluation
of pattern P = (?X, works in, ?Y) over an RDF graph G. This can be
done by first finding all the properties p that are sub-properties
of works in, and then finding all the resources a and b such that
(a, p, b) is a triple in G. A way to answer P by navigating the graph
would be to find the pairs of nodes (a, b) such that there is a path
from a to b that: (1) goes from a to one of its leaving edges, then
(2) follows a sequence of zero or more sp edges until it reaches a
works in edge, and finally (3) returns to the initial edge and moves
forward to b. If such a path exists, then it is clear that (a, works in, b)
can be deduced from the graph. The following is a natural attempt
to obtain the described path with a regular expression:

edge/(next::sp)

/self::works in/(next

1::sp)

/node.


The problem with the above expression is that, when the path
returns from works in, no information about the path used to reach
works in has been stored. In fact, if we evaluate the pattern:
Q = (?X, edge/(next::sp)
over the graph G in Fig. 2, we obtain the set of mappings:

/self::works in/(next

/node, ?Y)

1::sp)


{?X  Ronaldinho,?Y  Barcelona},{?X  Ronaldinho,?Y
 Everton},{?X  Sorace,?Y
 Barcelona},{?X  Sorace,?Y  Everton}

By simply inspecting the closure of G in Fig. 3, we obtain that:
Prdfs
G = {{?X  Ronaldinho,?Y  Barcelona},{?X  Sorace,?Y  Everton}}

and, thus, we have that Q is not the right representation of P according to the RDFS semantics (since Prdfs

/= QG).

The following theorem shows that the failure in Example 6.1 is
not a coincidence, as there exist SPARQL patterns (in fact, an infinite
number of patterns) that cannot be rewritten into rSPARQL in order
to obtain their RDFS evaluation. Recall that T is defined as the set
of triple patterns (x, y, z) such that x / V or y / V or z / V.
Theorem 6.2. There exists a SPARQL pattern P constructed from triple
G =
patterns in T such that for no rSPARQL pattern Q, it holds that Prdfs
QG for every RDF graph G.

In fact, we prove a stronger result, namely that there even exists
a triple pattern t such that, there is no rSPARQL pattern Q satisfy-
G = QG for every RDF graph G. It should be pointed
ing that trdfs
out that the rSPARQL pattern Q in the above theorem is allowed to
use all the SPARQL operators AND, FILTER, UNION and OPT, besides
regular expressions.

Let P = (?X, p, ?Y), where p U \ {sp, sc, type, dom, range}.
Proof.
G =
Next we show that there is no rSPARQL pattern Q such that Prdfs
QG for every RDF graph G. On the contrary, assume that Q0 is an
G = Q0G for every RDF graph G.
rSPARQL pattern such that Prdfs
Furthermore, assume that a, b, p1 and p2 are elements from U that
are not mentioned in Q0, and let G1 and G2 be the RDF graphs shown
in the following figure:
That is, G1 = {(a, p1, a), (b, p1, b), (a, p2, b), (b, p2, a), (p1, sp, p)}
and G2 = {(a, p2, a), (b, p2, b), (a, p1, b), (b, p1, a), (p1, sp, p)}. We
note that
Prdfs
G1

= {{?X  a, ?Y  a},{?X  b, ?Y  b}},

(6)

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

then

t = (?Z, next

t = (?Z, edge

t = (?Z, node

then tG1 =tG2

= {{?Z  a, ?W 

= {{?Z  p1, ?W 

tG1

= tG2

= {{?Z  a, ?W 

then tG1

= tG2

= {{?Z  p1, ?W 

then tG1

= tG2

To prove that Q0G1

= {{?X  a, ?Y  b},{?X  b, ?Y  a}}.

then tG1 =tG2 = {{?Z  a, ?W 

(7)
= Q0G2 and, thus, we obtain
= Q0G1 and Prdfs

/= Prdfs
G2 .
= Q0G2 , it is enough to show that tG1

Prdfs
G2
In what follows, we show that Q0G1
a contradiction since we assume that Prdfs
G1
Q0G2 , and by (6) and (7) we have that Prdfs
G1

tG2 for every triple mentioned in Q0. Given that Q0 is an rSPARQL
pattern, to prove the previous condition, we need to show that
= tG2 for every triple t of the form (z, exp, w) with z, w  U 
tG1
V and exp a regular expression generated by grammar (5). We show
first that for a pattern t of the form (?Z, exp, ?W) with ?Z, ?W  V, it
= tG2 . In order to prove the latter condition, it is
holds that tG1
enough to show that (?Z, exp, ?W)G1 = (?Z, exp, ?W)G2 with exp
being any of the atomic cases in the definition of regular expressions
(see grammar (5)).
 If
t = (?Z, next, ?W),
a},{?Z  a, ?W  b},{?Z  b, ?W  a},{?Z  b, ?W 
b},{?Z  p1, ?W  p}}.
 If
1, ?W),
a},{?Z  a, ?W  b},{?Z  b, ?W  a},{?Z  b, ?W 
b},{?Z  p, ?W  p1}}.
 If
t = (?Z, edge, ?W),
p1},{?Z  a, ?W  p2},{?Z  b, ?W  p1},{?Z  b, ?W 
p2},{?Z  p1, ?W  sp}}.
 If
1, ?W),
a},{?Z  p2, ?W  a},{?Z  p1, ?W  b},{?Z  p2, ?W 
b},{?Z  sp, ?W  p1}}.
 If
t = (?Z, node, ?W),
a},{?Z  p1, ?W  b},{?Z  p2, ?W  a},{?Z  p2, ?W 
b},{?Z  sp, ?W  p}}.
 If
1, ?W),
p1},{?Z  a, ?W  p2},{?Z  b, ?W  p1},{?Z  b, ?W 
p2},{?Z  p, ?W  sp}}.
 If
t = (?Z, self, ?W),
= tG2
a},{?Z  b, ?W  b},{?Z  p1, ?W  p1},{?Z  p2, ?W 
p2},{?Z  sp, ?W  sp},{?Z  p, ?W  p}}.
 If t = (?Z, next::c, ?W), where c  U \ {a, b, p1, p2} (recall that
a, b, p1, and p2 are not mentioned in Q0), then we have to consider
three sub-cases:
 If c = p, then tG1 = tG2 = .
 If c = sp, then tG1
 If c  U \ {a, b, p1, p2, p, sp}, then tG1
 If t = (?Z, next
have to consider three sub-cases:
 If c = p, then tG1
= .
 If c = sp, then tG1
= {{?Z  p, ?W  p1}}.
 If c  U \ {a, b, p1, p2, p, sp}, then tG1
= .
 If t = (?Z, edge::c, ?W), where c  U \ {a, b, p1, p2}, then we have
to consider three sub-cases:
= tG2
 If c = p, then tG1
= tG2
 If c = sp, then tG1
 If c  U \ {a, b, p1, p2, p, sp}, then tG1
 If t = (?Z, edge
have to consider three sub-cases:
 If c = p, then tG1
= {{?Z  sp, ?W  p1}}.
 If c = sp, then tG1
= .
 If c  U \ {a, b, p1, p2, p, sp}, then tG1
= .
 If t = (?Z, node::c, ?W), where c  U \ {a, b, p1, p2}, then tG1
tG2
 If t = (?Z, node
1::c, ?W), where c  U \ {a, b, p1, p2}, then tG1
tG2

= {{?Z  p1, ?W  sp}}.
= .
= .

1::c, ?W), where c  U \ {a, b, p1, p2}, then we

1::c, ?W), where c  U \ {a, b, p1, p2}, then we

= {{?Z  p1, ?W  p}}.
= .

= tG2

then tG1

= tG2

= tG2

= tG2
= tG2

then

tG1

= {{?Z  a, ?W 

= {{?Z  a, ?W 

= tG2

= tG2

= tG2

= tG2
= tG2

= .

= .

G2

= {{?Z  c, ?W  c}}.

 If t = (?Z, self::c, ?W), where c  U \ {a, b, p1, p2}, then tG1
tG2
Assume now that t is of the form (z, exp, w) with z  U or w  U.
We have that z, w  U \ {a, b, p1, p2} and, thus, the only interesting
case is when z {p, sp} or u{p, sp}. We can use a similar argument
= tG2 . This concludes
to the one shown above to prove that tG1
the proof of the theorem. 

It should be noticed that Theorems 6.2 and 5.4 imply that

nSPARQL is strictly more expressive than rSPARQL.

Corollary 6.3. There exists an nSPARQL pattern that is not equivalent
to any rSPARQL pattern.

6.2. On the expressiveness of the SPARQL operators in nSPARQL

Clearly, nested regular expressions add expressive power to
SPARQL. The opposite question is whether using SPARQL operators in nSPARQL patterns add expressive power to the language.
Next we show that this is indeed the case. In particular, we show
that there are simple and natural queries that can be expressed
by using nSPARQL features and that cannot be simulated by using
only nested regular expressions. Let us present the intuition of this
result with an example.

Example 6.4.
Let G be the RDF graph shown in Fig. 1. Assume
that one wants to retrieve from G the cities ?X such that there
exists exactly one city that can be reached from ?X by using a
direct Seafrance service. The following nSPARQL pattern answers
this query:

(?X, next::Seafrance/next

1, ?X) OPT (((?X, next::Seafrance,?Y)

AND (?X, next::Seafrance,?Z)) FILTER?Y =?Z)]
FILTERbound(?Y).

1, ?X) retrieves the
The first nre-triple (?X, next::Seafrance/next
cities ?X that are connected with some other city by a Seafrance
service. The optional part obtains additional information for those
cities ?X that are connected with at least two different cities by
a Seafrance service. Finally, the pattern filters out those cities for
which no optional information was added (by using bound(?Y)).
That is, only the cities ?X that are connected with exactly one city
by a Seafrance service remains in the evaluation. If we evaluate
the above pattern over G, we obtain a single mapping  such that
dom() = {?X} and (?X) = Calais.

The nSPARQL graph pattern in the above example is essentially
counting (up to a fixed threshold) the cities that are connected
with ?X by a Seafrance service. In the next result, we show that
some counting capabilities cannot be obtained by using nSPARQL
patterns without considering the OPT operator, even if we combine nested regular expressions by using the operators AND, UNION
and FILTER. The graph pattern used in the proof is similar to that of
Example 6.4. It retrieves the nodes ?X for which there exists at least
two different nodes connected with ?X. In particular, we prove a
stronger result stating that the fragment of nSPARQL that do not use
the OPT operator is strictly less expressive than the whole nSPARQL
language.

Theorem 6.5. There is an nSPARQL graph pattern that is not equivalent to any nSPARQL graph pattern that uses only AND, UNION, and
FILTER operators.

Proof. Let P be a query such that, for every RDF graph G, it holds
that  PG if and only if dom() = {?X} and G contains tuples
((?X), p, a), ((?X), p, b), where a and b are distinct elements. For

given that (b0, b0), (b1, b1) and (p, p) belong to axisG2 , we
conclude that the claim holds. If axis = next, then we have that
= {(a0, a1), (a0, a2)}. Thus, by definition of f and given that
axisG1
(b0, b1) axisG2 , we conclude that the claim holds. If axis = edge,
= {(a0, p)}. Thus, by definition of f and
then we have that axisG1
given that (b0, p) axisG2 , we have that the claim holds. Finally,
= {(p, a1), (p, a2)}. Thus,
if axis = node, then we have that axisG1
by definition of f and given that (p, b1) axisG2 , we conclude that
the claim holds.
(2) If axis = self, then we have that the claim trivially holds
= {(c, c)} and f (c) = c (given that c is
since axis::cG1
mentioned in Pk and a0, a1 and a2 are not mentioned in this expres-
sion). Thus, assume that axis{next, edge, node}. If c /= p, then the
=  (given that a0, a1 and a2
claim trivially holds since axis::cG1
are not mentioned in Pk). Thus, we assume that c = p. If axis = edge
or axis = node, then the claim also holds since axis::pG1
= . Thus,

we only need to consider the case axis = next. But next::pG1
{(a0, a1), (a0, a2)} and, therefore, the claim holds by definition of f
= {(b0, b1)}. This concludes the proof of
and given that next::pG2
the claim. 

= axis::cG2

From Claim 6.7, we obtain the following corollary.

Let f : U  U be a function defined as f (a0) = b0,
Corollary 6.8.
f (a1) = f (a2) = b1 and f (d) = d for every d U \ {a0, a1, a2}, and exp
a nested regular expression mentioned in Pk. If (x, y) expG1 , then
(f (x), f (y)) expG2 .
Let 0 be a mapping such dom(0) = {?X} and 0(?X) = b0. We
use Corollary 6.8 to prove that 0  PkG2 . Given that var(Pk) = {?X},
0  PkG1 and Pk is an nSPARQL pattern constructed by using only
the operators AND and FILTER, to prove that 0  PkG2 , it is enough
to show that for every triple pattern t in Pk: (a) if var(t) = , then
t holds in G2, and (b) if var(t) = {?X}, then 0  tG2 . Next we show
that (a) and (b) hold.
 If t = (c1, exp, c2), where c1, c2  U, then given that 0  PkG1 and
Pk is an nSPARQL pattern constructed by using only the operators AND and FILTER, we conclude that (c1, c2) expG1 . Thus,
we have by Corollary 6.8 that (f (c1), f (c2)) expG2 . But we know
that a0, a1 and a2 are not mentioned in Pk and, hence, we have
that f (c1) = c1 and f (c2) = c2. We conclude that (c1, c2) expG2
and, therefore, t holds in G2.
 If t = (c, exp, ?X), where c  U, then given that 0  PkG1 and Pk is
an nSPARQL pattern constructed by using only the operators AND
and FILTER, we conclude that (c, a0) expG1 . Thus, we have by
Corollary 6.8 that (f (c), b0) expG2 . But we know that a0, a1 and
a2 are not mentioned in Pk and, hence, we have that f (c) = c. We
conclude that (c, b0) expG2 and, therefore, 0  tG2 .
 If t = (?X, exp, c), where c  U, then we conclude that 0  tG2 as
 If t = (?X, exp, ?X), then given that 0  PkG1 and Pk is an
nSPARQL pattern constructed by using only the operators AND
and FILTER, we conclude that (a0, a0) expG1 . Thus, we have by
Corollary 6.8 that (b0, b0) expG2 and, hence, 0  tG2 .
Thus, we conclude that 0  PkG2 . But this implies that
= PG2 and

0  QG2 , which leads to a contradiction since QG2
0 / PG2 (by definition of P).
To conclude the proof of the theorem, it only remains to show
that P can be expressed in nSPARQL. Consider first the following
nSPARQL pattern:
Q =

1, ?Y) OPT (((?Y, next::p, ?Z) AND

(?Y, next::p/next

in the previous case.

(?Y, next::p, ?W)) FILTER?Z =?W)] FILTERbound(?Z).

Fig. 9. Two RDF graphs.

example, if G1 is the RDF graph shown in Fig. 9, and 0, 1 are
mappings such that dom(0) = dom(1) = {?X}, 0(?X) = a0 and
1(?X) = a1, then 0  PG1 and 1 / PG1 . In fact, in this case we
= {0}. We start by showing that P is not equivalent
have that PG1
to any nSPARQL pattern constructed by using only the operators
AND, UNION and FILTER. 

On the contrary, assume that Q is an nSPARQL pattern such
that Q does not mention the OPT operator and QG = PG, for
every RDF graph G. It is easy to extend the results of Ref. [25]
to show that the operator UNION is associative in nSPARQL, and
there exist nSPARQL patterns P1, . . ., Pn such that each Pi is constructed by using only the operators AND and FILTER, and QG =
P1 UNION P2 UNION UNION PnG, for every RDF graph G. Without loss of generality, we can assume that each Pi is satisfiable in
the sense that there exists an RDF graph G and a mapping  such
that  PiG. Next we show that for every pattern Pi, it is the case
that var(Pi) = {?X}, where var(Pi) is the set of variables mentioned
in Pi
Claim 6.6. For every i{1, . . . , n}, it holds that var(Pi) = {?X}.
Proof of Claim 6.6. We prove the claim by contradiction. Assume
that for i{1, . . . , n}, it holds that var(Pi) /= {?X}. Then either ?X /
dom(Pi) or there exists ?Y  dom(Pi) such that ?X and ?Y are distinct variables. Given that Pi is satisfiable, we know that there exists
an RDF graph G and a mapping  such that  PiG. Given that
PG = QG, we conclude that  PG. Thus, if we assume that
?X / dom(Pi), we have that ?X / dom(), which contradicts the
definition of P. Moreover, if we assume that ?Y  dom(Pi), with ?X
and ?Y distinct variables, then given that Pi is an nSPARQL expression constructed by using only the operators AND and FILTER, we
conclude that ?Y  dom(), which again contradicts the definition
of P. This concludes the proof of the claim. 

For the rest of the proof, let G1 and G2 be the RDF graphs shown
in Fig. 9, and assume that a0, a1, a2, b0, b1 are elements of U that are
not mentioned in
P1 UNION P2 UNION UNION Pn.
Let 0 be a mapping such that dom(0) = {?X} and 0(?X) = a0. As
we pointed out above, we have that 0  PG1 . Thus, we have that
0  QG1 , which implies that 0  PkG1 , for some k {1, . . . , n}.
f : U  U be a function defined as f (a0) =
Claim 6.7.
f (a1) = f (a2) = b1 and f (d) = d for every d U \ {a0, a1, a2},
b0,
1} and c an ele-
axis{self, next, next
ment of U that is mentioned in Pk.
(1) If (x, y) axisG1 , then (f (x), f (y)) axisG2 .
(2) If (x, y) axis::cG1 , then (f (x), f (y)) axis::cG2 .
Proof of Claim 6.7.
axis{self, next, edge, node}.
{(a0, a0), (a1, a1), (a2, a2), (p, p)}. Thus, by definition of

It is enough to prove the claim for

f and

1, node, node

1, edge, edge

axis = self,

axisG1

then we

(1)

If

Let

have

that

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

As we explained in Example 6.4, given an RDF graph G, a mapping 
is in QG if and only if dom() = {?Y} and there exists exactly one
element b such that ((?Y), p, b) is in G. In fact, if G1 and G2 are the
= {}
graphs shown in Fig. 9, we have that QG1
where  is such that dom() = {?Y} and (?Y) = b0. Consider now
pattern:

(?X, next::p/next
FILTER ?X =?Y)] FILTERbound(?Y).

1, ?X) OPT (((?X, next::p/next

= , while QG2

1, ?X) AND Q )

It is not difficult to see that the above graph pattern is equivalent
to our initial query P. This concludes the proof of the theorem.

7. Related work

The language of nested regular expressions has been motivated
by some features of query languages for graphs and trees, namely,
XPath [11], temporal logics [12] and propositional dynamic logic
[1,16]. In fact, nested regular expressions are constructed by borrowing the notions of branching and navigation axes from XPath
[11], and adding them to regular expressions over RDF graphs. The
algorithm that we present in Section 3.1 is motivated by standard algorithms for some temporal logics [12] and propositional
dynamic logic [1,16].

Regarding languages with navigational capabilities for querying RDF graphs, several proposals can be found in the literature
[24,3,20,6,4,2]. Nevertheless, none of these languages is motivated
by the necessity to evaluate queries over RDFS, and none of them
is comparable in expressiveness and complexity of evaluation with
the language that we study in this paper. Probably the first language
for RDF with navigational capabilities was Versa [24], whose motivation was to use XPath over the XML serialization of RDF graphs.
Kochut et al. [20] propose SPARQLeR, an extension of SPARQL that
works with path variables that represent paths between nodes in
a graph. This language also allows to check whether a path conforms to a regular expression. Anyanwu et al. [6] propose a language
called SPARQ2L. The authors further investigate the implementation of a query evaluation mechanism for SPARQ2L with emphasis
in some secondary memory issues. The language PSPARQL was proposed by Alkhateeb et al. [3]. PSPARQL extends SPARQL by allowing
regular expressions in triple patterns. The same authors propose a
further extension of PSPARQL called CPSPARQL [4] that allows constraints over regular expressions. CPSPARQL also allows variables
inside regular expressions, thus permitting to retrieve data along
the traversed paths. In Refs. [3,4], the authors study some theoretical aspects of (C)PSPARQL. Given the similarities between nSPARQL
and PSPARQL, in the next section we include a detailed comparison
between these two languages.

7.1. nSPARQL and PSPARQL

In this section, we compare our language with the closest proposal in the literature, namely the PSPARQL language proposed by
Alkhateeb et al. [3]. PSPARQL is a language that extends SPARQL by
allowing regular expressions in triple patterns.

Alkhateeb has recently shown [2] that PSPARQL can be used
to answer queries that consider the special semantics of RDFS. As
explained in Ref. [2], this answering process needs the projection
operator over PSPARQL graph patterns, that is, it needs SELECT in
order to accurately capture the RDFS inference rules, and in par-
ticular, it needs extra variables (not needed in the output solution)
appearing in the predicate position of triple patterns.

In this section, we show that these features have an impact
on the complexity of the evaluation problem for PSPARQL, as this
problem becomes NP-complete for the conjunctive fragment of

this language [2]. On the contrary, it is shown in this section that
this problem can be solved in polynomial time for the conjunctive fragment of nSPARQL, since this fragment does not include the
aforementioned features (as they are not needed in nSPARQL to
answer queries with RDFS vocabulary). It is important to notice
that not only the computational complexity is a parameter to be
taken into account when comparing query languages, but also the
expressiveness. In particular, although we show that the conjunctive fragment of nSPARQL can be evaluated more efficiently than
the conjunctive fragment of PSPARQL, it is possible to show that
PSPARQL is strictly more expressive than nSPARQL. We also discuss
this topic in this section.

As mentioned above, PSPARQL [3,2] is a language that extends
SPARQL by allowing regular expressions in triple patterns. More
precisely, a PSPARQL query Q consists of a SPARQL graph pattern P
that may include some regular expressions over the vocabulary U
in some triples, and possibly of a SELECT operator that performs a
projection over a subset of the variables appearing in P.

Example 7.1. Let G be the following RDF graph storing a genealogy
tree:

(Joan, mother,John), (Joan, mother,Peter), (Joan, mother,Mary),

(John, father,Alan), (Mary, mother,Martin), (Martin,

father,Mark)

+, ?Y) returns the pairs
Then PSPARQL query (?X, (mother + father)
(a, b) of nodes such that b is a descendant of a. Furthermore, the
following PSPARQL query returns the pairs (c, d) of distinct nodes
that have a common ancestor:

SELECT ?Y, ?Z

(?X, (mother + father)

(?X, (mother + father)

+, ?Z)

+, ?Y)AND

FILTER(?Y =?Z)

Notice that the SELECT operator is used to indicate that only the
values of ?Y and ?Z should be displayed. Thus, if (c, d) is in the
answer of this query, then the common ancestors of these nodes
are not displayed.

As we have shown in Section 6.1, regular expressions can be used
to obtain the answer to some RDFS queries. For example, consider
the RDF graph:
G = {(a, p, b), (p, sp, c), (c, sp, d), (d, sp, e)}.
To retrieve all the properties ?X that are sub-properties of e, one can
+, e). Suppose now that one wants
use the PSPARQL query (?X, sp
to retrieve the pair of nodes ?X, ?Y that are connected by property
e. To answer this query, we need to consider the semantics of the
RDFS vocabulary. In particular, given that p is a sub-property of
c, c is a sub-property of d, and d is a sub-property of e, we have
that p is a sub-property of e in G. Thus, given that a is connected
with b by property p, we conclude that a is connected with b by
property e. Thus, considering the RDFS semantics, the answer to the
previous query over G should be the mapping {?X  a, ?Y  b}. In
Ref. [2], Alkhateeb proposes to encode the above query by using the
following PSPARQL pattern:
, e).
(?X, ?Z, ?Y) AND (?Z, sp
(8)
Notice that the evaluation of (8) is the mapping {?X  a, ?Z 
p, ?Y  b}. Thus, to actually obtain the desired result, a projection
must be performed over the variables ?X and ?Y, which gives rise
to the following PSPARQL query that retrieves the pair of nodes that
are connected by property e:
SELECT ?X, ?Y [(?X, ?Z, ?Y) AND (?Z, sp

, e)].

(9)

Hence, one needs the SELECT operator in PSPARQL to accurately
answer queries with RDFS vocabulary. On the other hand, the previous query can be answered as follows in nSPARQL:

(?X, next::[(next::sp)

/self::e], ?Y).

In this graph pattern, the use of projection has been replaced by
the nesting construct in nested regular expressions. We observe
that from the results in Section 5, we know that nSPARQL does not
need the SELECT operator in order to answer queries that consider
the special semantics of the RDFS vocabulary.

Next we show that the use of the SELECT operator makes the
complexity of the evaluation problem substantially harder. In order
to prove this, we need to introduce some terminology. Define the
conjunctive fragment of PSPARQL as the set of PSPARQL queries constructed by using only the AND and SELECT operators. Similarly,
define the conjunctive fragment of nSPARQL as the set of nSPARQL
patterns constructed by using only the AND operator. It is important to notice that we have included the SELECT operator in the
conjunctive fragment of PSPARQL as it is needed in this language to
answer queries with RDFS vocabulary. On the other hand, SELECT
is not considered in the conjunctive fragment of nSPARQL as it
is not needed in this language for the encoding of RDFS (in fact,
the entire language nSPARQL is defined without considering the
SELECT operator). Moreover, the evaluation problems for nSPARQL
and PSPARQL are defined as follows. Given a mapping , an RDF
graph G and an nSPARQL graph pattern P (PSPARQL query Q), the
problem is to verify whether  is in the evaluation of P (Q) over G.
Notice that for both PSPARQL and nSPARQL, the evaluation problem
has been defined as a decision problem [28].

Theorem 7.2.

(1) The evaluation problem for the conjunctive fragment of PSPARQL

is NP-complete [2].

(2) The evaluation problem for the conjunctive fragment of nSPARQL

can be solved in polynomial time.

The NP-hardness in the first part of the above theorem can be
proved by a reduction from the evaluation problem for relational
conjunctive queries [10]. The second part of the above theorem
follows from the existence of a polynomial-time algorithm for the
evaluation problem for nested regular expressions (provided in
Section 3.1), and a result in Ref. [25] stating that the complexity
of the evaluation problem for SPARQL graph patterns constructed
by using only the AND operator is polynomial. It should be noticed
that if one adds the SELECT operator to the conjunctive fragment
of the nSPARQL language, then the evaluation problem becomes
NP-complete. Thus, the difference in complexity between the two
fragments mentioned in Theorem 7.2 essentially comes from the
use of the SELECT operator.

It is important to notice that not only the computational complexity is a parameter to be taken into account when comparing
query languages, but also the expressiveness. In this respect, nested
regular expressions can be encoded by using regular expressions
and the SELECT operator and, thus, the functionalities of nSPARQL
can be encoded by using the functionalities of PSPARQL. On the
other hand, nSPARQL does not include the SELECT operator and
does not allow triples of the form (?X, ?Y, ?Z). Thus, as these elements are included in PSPARQL, it is possible to conclude that
PSPARQL is strictly more expressive than nSPARQL.

We conclude this section by pointing out that Theorem 7.2 tells
that the use of projection and extra variables (not mentioned in the
output) makes the evaluation problem considerably harder. In fact,
nSPARQL has been carefully designed not to use these features, as
shown in the following example.

Example 7.3.
Let G be an RDF graph storing genealogical infor-
mation, and assume that we want to retrieve from G the pairs of
distinct people that have a common Italian ancestor. This query can
be expressed in PSPARQL as follows:

SELECT?X, ?Y [((?A,nationality,Italian) AND

(?A, (mother|father)
FILTER(?X =?Y)] .

+, ?X)AND(?A, (mother|father)

+, ?Y)

We note that the SELECT operator is used in this query to filter out
the common ancestor ?A. Interestingly, this query can be expressed
as an nSPARQL graph pattern, without explicitly mentioning the
common ancestor. In fact, let exp be the following nested regular
expression:

(next

1::mother| next

1::father)

/self::[next::nationality/

self::Italian]/(next::mother| next::father)

+.

Then we have that the above query is equivalent to the following
nSPARQL graph pattern expression:
(?X, exp, ?Y) FILTER(?X =?Y).

Example 7.3 shows that some form of projection can be obtained
by using nested regular expressions, without using extra variables.
Nevertheless, this encoding of projection in nSPARQL is not gen-
eral, as one would need extra variables and operator SELECT to fully
obtain projection capabilities. For instance, assume that in an RDF
graph storing genealogical information, one needs to retrieve all the
groups of three people having a common ancestor. It is straightforward to extend the PSPARQL query in Example 7.3 for this purpose,
but it is not clear whether one can obtain the answer to this query
by using only nested regular expressions without adding extra variables and projection.

It should be noticed that other query languages have followed
before the same approach as nSPARQL, and in particular, they have
avoided the use of extra variables. For instance, the XML query language Conditional XPath has the same expressive power over trees
as first-order logic [21], and includes the language XPath. The main
difference between Conditional XPath and first-order logic is the
use of extra variables and quantifiers in the latter. Exactly as for the
case of PSPARQL and nSPARQL, these extra features come with a
severe impact in the complexity of the evaluation problem for these
languages, as this problem can be solved in polynomial time for the
case of Conditional XPath [21] (and also for the case of XPath), while
it is PSPACE-complete for the case of first-order logic over trees (and
NP-complete for the existential fragment of this language).

8. Concluding remarks

In this paper, we have proposed nested regular expressions to
navigate through an RDF graph, and the nSPARQL query language
for RDF that uses nested regular expressions as building blocks.
We also study some of the fundamental properties of nested regular expressions and nSPARQL. We have shown that nested regular
expressions admit a very efficient evaluation method, that justifies
its use in practice. We further showed that the language nSPARQL
is expressive enough to be used for querying and navigating RDF
data. In particular, we proved that besides capturing the semantics
of RDFS, nSPARQL provides some other interesting features that
allows users to pose natural and interesting queries over RDF data.
Evaluating queries which involve RDFS vocabulary is challeng-
ing, and there is not yet consensus in the Semantic Web community
on how to define a query language for RDFS. Nevertheless, there

J. Perez et al. / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 255270

have been several proposals and implementations of query languages for RDF data with RDFS vocabulary (e.g. Refs. [19,9,17,15]).
As future work, it would be interesting to implement nSPARQL, and
to compare it with other implementations of RDFS query languages.
In particular, it would be interesting to see whether in practice the
process of answering a SPARQL query Q under the RDFS semantics can be efficiently done by first transforming Q into an nSPARQL
graph pattern Q, and then answering Q by using the algorithms
developed in this paper.

Acknowledgments

The authors would like to thank the anonymous referees for
their careful reading of the paper, and for providing many useful comments. The authors were supported by: Arenas  Fondecyt
grant 1090565; Gutierrez  Fondecyt grant 1070348; Perez 
Conicyt Ph.D. Scholarship; Arenas, Gutierrez and Perez  grant P04-
067-F from the Millennium Nucleus Center for Web Research.
