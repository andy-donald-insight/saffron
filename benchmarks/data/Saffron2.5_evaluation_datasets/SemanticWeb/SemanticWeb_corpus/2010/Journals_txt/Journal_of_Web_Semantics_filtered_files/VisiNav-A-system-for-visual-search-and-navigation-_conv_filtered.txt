Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 348354

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Invited paper
VisiNav: A system for visual search and navigation on web data

Andreas Harth
Institute AIFB, Karlsruhe Institute of Technology, Germany

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 1 February 2010
Received in revised form 27 June 2010
Accepted 10 August 2010
Available online 19 August 2010

Keywords:
Web data
Exploratory search
Faceted navigation
Semantic search
Visual analytics
Structured data search

Web standards such as RDF (Resource Description Framework) facilitate data integration over large number of sources. The resulting interlinked datasets describe objects, their attributes and links to other
objects. Such datasets are amenable for queries beyond traditional keyword search and for visualisation
beyond a simple list of links to documents. Given that data integrated from the open web exhibits enormous variety in scope and structure, the mechanisms for interacting with such data have to be generic
and agnostic to the vocabularies used. Ideally, a system operating on web data is easy to use without
upfront training. To this end, we present VisiNav, a system based on an interaction model designed to
easily search and navigate large amounts of web data (the current system contains over 18.5m RDF triples
aggregated from 70k sources). In this paper we introduce a formal query model comprising four atomic
operations over object-structured datasets: keyword search, object focus, path traversal, and facet spec-
ification. From these atomic operations, users incrementally assemble complex queries that yield trees
of objects as result. These results can then be either directly visualised or exported to application programs or online services for further processing. The current system provides detail, list, and table views
for arbitrary types of objects; and timeline and map visualisations for temporal and spatial aspects of
objects.

 2010 Elsevier B.V. All rights reserved.

1. Introduction

Keyword search over hypertext documents is an established
technology and is used by a large majority of web users [14]. Search
engines are popular because (i) users are accustomed to the concept of hypertext  documents and links  and (ii) search engines
employ a simple conceptual model: the engines return those documents that match the specified keywords. Search engines operate
over millions of documents which have been collected automati-
cally, however, the functionality is limited: the engine returns only
links to sites but not directly the actual answer or data items sought.
Typical keyword phrases used for search are insufficient to specify
a complex information need since they consist mostly of only a few
words [14]; moreover, information expressed in documents in natural language is ambiguous and thus hard to process automatically.
Standards such as RDF and OWL (Web Ontology Language) provide means of describing objects and integrating data about objects
from large numbers of sources which may only loosely coordi-
nate. However, there is the open question of how end users should
express complex queries over such datasets. A promising approach
is to use a menu-based dialogue system in which users construct
the query incrementally [34,38]. Offering only valid choices ensures
that the user can only pose queries which can be satisfied by the

E-mail addresses: aha@aifb.uni-karlsruhe.de, harth@kit.edu.

1570-8268/$  see front matter  2010 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2010.08.001

available data, preventing empty result sets. Designing an interaction model and developing a useable system for interrogating
collaboratively edited data-sets poses several challenges:

(i) Intuitive use: both occasional users and subject-matter experts
should be able to interact with the data immediately. The user
interface should be consistent and allow for users to quickly
derive results with a few clicks.

(ii) Universality: previous attempts at using structured information have been restricted to manually crafted domain-specific
datasets since the data on the web lacked quantity (no
general-domain information available) and quality (no shared
identifiers, no interlinkage). Users should be constraint as little
as possible in constructing queries while keeping the system
easy to use.

(iii) Zero configuration: data on the web comes in an abundance
of formats and vocabularies. Consequently, manual intervention is a labour intensive task, rendering manual intervention
infeasible.

(iv) Flexibility: web data is often noisy and may contain duplicates,
erroneous items, malformed syntax and incorrect formatting,
so the user interface should be able to deal with irregular data
gracefully. The system has to be flexible enough to deal with
diverse content, both in terms of schema and noisy data.

(v) Scalability: since we target the web as a data source the system
has to scale competently, which has implications on the archi-

tecture and implementation of the system. Also, quick response
times enhance the user experience.

(vi) User satisfaction: the system should be visually appealing and
users should be able to import the results of their information seeking task into application programs to get a sense of
achievement immediately.

In this paper, we describe VisiNav, a fully implemented system1
based on a visual query construction paradigm. Given that VisiNav operates over data rather than documents, operations offered
can go beyond simple keyword searches and result visualisations
can be more elaborate than just showing 10 result documents.
The users of the system can construct complex queries from several atomic operations. Our system is unique in that it is the first
system which offers these features over datasets consisting of millions of RDF triples collected and automatically integrated from the
open web.

The initial step in the proposed interaction model is typically
a keyword search to locate objects, leveraging existing familiarity of users with search engines. In subsequent steps, users refine
their query based on navigation primitives; as such, the interaction model leads to an explorable system that can be learned
through experimentation. Since the system calculates the possible next steps based on the current state, only legal choices are
displayed and thus the user can only compose queries which the
system can answer.

The contribution of this research is two-fold:

 We adapt browsing and interaction mechanisms for schema-less
interlinked datasets collected from the web. Previous work on
visual interfaces either assumes datasets with limited variance in
schemas [32,19], limited expressivity of query operations [24,17],
or a strict partitioning of datasets [18]. VisiNav allows for users
posing expressive query operations over interlinked web datasets
with a large variance in schemas used.
 We introduce the notion of trees (or nested relations) as result
model for web data exploration due to the use of the path traversal operation. Previous work assumes single [38] or multiple sets
[18,22] as result model.

The system satisfies a large fraction of the requirements set
out for the Semantic Web Challenge. The data used in the current VisiNav system is under diverse ownership (data from over
70k sources), the dataset is heterogeneous (more than 21k different vocabulary URIs) and contains substantial quantities of real
world data (more than 18.5m statements). Meaning is represented
and processed using Semantic Web technologies (OWL and reasoning [16]). The system incorporates ranking [12] to prioritise data
and data items, and utilises Web standards such as HTML, CSS and
JavaScript for the user interface.

We provide an overview of the user interface in Section 2,
present and motivate the choice of query operations and formalise
the result model in Section 3, and discuss design choices in Section
4. Section 5 covers related work, and Section 6 concludes.

2. Overview and preliminaries

In the following, we describe the characteristics of the target
dataset collected from the web, present example queries, and introduce the conceptual model and selected tasks carried out over such
datasets.

1 http://visinav.deri.org/.

2.1. Web data

Common to data currently found on the Web in structured formats (microformats, XML, RDF) is that data publishers take a loosely
object-centred view. RDF in particular uses URIs2 as global identifiers for objects, which, if multiple sources reuse identifiers, leads
to an interconnected object space encoded in a graph-structured
data format. Currently, reuse of identifiers is particularly common
in social networking and social media data, expressed in FOAF3 for
people, SIOC4 for online community sites, and DC5 for documents
and other media. While a large number of current RDF files use a
mix of these vocabularies, data publishers use a plethora of other
vocabularies, too.

For example, the most diverse dataset used during our experiments contains data from 70k sources using over 21k different
vocabulary URIs (classes and properties). The amount of variance
in the dataset is enormous; as a result, manual intervention should
be as minimal as possible, and the system should make as little
assumptions as possible about the schema used to arrive at a general and universal method for exploring the dataset.

2.2. Conceptual model

Norman [29] argues that the conceptual model of a system has
to fit the users own conceptual model about it. We therefore introduce first the assumed conceptual model, i.e. what the users have
to know about the system before interacting with the system.

VisiNavs conceptual model for navigation assumes an objectoriented view, describing objects, their attributes and links to other
objects. Attributes of objects are expressed using datatype proper-
ties, and links to other objects are specified using object properties.6
Objects and properties are identified via identifiers (e.g. URIs).
Attributes can have datatypes such as integer or date. Please note
that there is no clear distinction between instance-level objects
and schema-level ones  classes and properties can be instances
themselves.

Users perceive and act on objects, in-line with early graphical user interfaces [25]. In general, there is a 1:1 correspondence
between the objects in the dataset and the objects displayed to the
user, loosely following the naked objects approach [7]. Users are
able to search and navigate the objects in the dataset; a user query
yields objects as a result. Users can choose to display the result set
in detail, list, or table view; optionally, a timeline or map visualisation is available if the result objects contain suitable information.
In addition, users are able to export the results to application programs or services.

2.3. Tasks

In the following, we introduce a set of example queries that
are prototypical for the type of queries a user can pose to the sys-
tem. Given the wide availability of information about people and
communities, we use the social network scenario to study user
interfaces on collaboratively edited datasets. However, the interaction model and the implemented system are domain independent
and thus applicable to any object-structured dataset. We list a
number of example queries  that can be answered with currently
available web data  with increasing complexity in Table 1.7

2 Uniform Resource Identifiers, http://www.rfc-editor.org/rfc/rfc3305.txt.
3 Friend-of-a-Friend, http://foaf-project.org/.
4 Semantically Interlinked Online Communities, http://sioc-project.org/.
5 Dublin Core, http://dublincore.org/.
6 As specified in OWL, Web Ontology Language, http://www.w3.org/2004/OWL/.
7 timbl:i expands to http://www.w3.org/People/Berners-Lee/card#i; throughout the paper we assume the standard namespace prefixes for rdf, rdfs, owl, foaf,
sioc and dc.

A. Harth / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 348354

Table 1
Example queries. Identifiers in typewriter are part of the query.

Query

Description

Objects matching the keyword phrase tim
berners-lee
Information available about timbl:i
Objects foaf:made by timbl:i
sioc:Post s foaf:made by timbl:i
People that timbl:i foaf:knows
Objects foaf:made by people that timbl:i
foaf:knows
Locations where people that timbl:i foaf:knows
are foaf:based near
Objects of rdf:type foaf:Person

Fig. 1. List view of the query people that timbl:i knows (Query 5).

VisiNav supports three generic views for displaying results:
detail, list, and table. The detail view shows all properties pertinent to a single object in a two column-format. The list view shows
a few selected properties in a list of objects of typically 10 objects at
a time, similar to search engine results (Fig. 1). In the list view, users
can choose to download the data in RSS. The table view shows all
datatype properties of the current result in a tabular view, typically
up to hundred at a time, similar to spreadsheets. In the table view,
the users can download a version of the data displayed in comma
separated value (CSV) format for further processing.

VisiNav currently supports visualisations for temporal and spatial aspects of objects. The system renders temporal attributes (i.e.
those with datatype xsd:date or xsd:dateTime) in a SIMILE timeline view.8 In the timeline view, users can choose to download the
data in iCal format and thus import the data into calendaring appli-
cations. Spatial properties (i.e. objects with geo:lat and geo:long
properties) are rendered in a Google map view.9

8 http://www.simile-widgets.org/timeline/.
9 http://maps.google.com/

3. Query operations and result model

In the following we introduce VisiNavs query operations and
describe how to compose complex queries from atomic opera-
tions, and present a mapping of query results encoded as RDF
into a generic (i.e. schema-agnostic) object model for manipulation
within a programming language.

3.1. Query operations

To construct queries, users select operations that are common to
existing faceted browsing and navigation systems. We list the feature matrix of these systems in Section 3.2; we argue that by using a
set of features used in existing systems we capture the community
consensus of operations that are deemed necessary and useful for
interacting with object-structured datasets.

 Keyword Search (K) Users may specify keywords to pinpoint
objects of interest. The operation leads to an initial set of results
based on a broad matching of string literals connected to objects.
We perform matching on keywords without manually extending the query for synonyms or other natural language processing
techniques. Rather, we leverage the noise in web data, i.e. the
fact that the same resource might be annotated using different
spellings or different languages. Keyword search has the interesting property that the users do not need to know the schema of
the data, enabling users to pose queries without previous domain
knowledge.
 Object Focus (O) The operation is similar to following a hypertext link in a web browser. From a set of results or a single result,
the user selects an object which is used to create a new query
and returns a result set containing the object. The result of a
object focus selection operation is always a result set with a single
object.
 Path Traversal (P) Rather than arriving at a single result by selecting a focus object, users are also able to navigate a path along an
object property to establish a new set of results. Users can select
an object property, which allows them to perform a set-based
focus change, i.e. they follow a certain path, either from a single
result or a set of results.
 Facet Selection (F) Another way of manipulating the result set
is via selecting facets. A facet is a combination of a property and
a literal value or an object (distinguishing between datatype and
object properties). Facets are calculated relative to the current
result set. Based on derived facets, the user can reformulate the
query and obtain increasingly specific result sets.

3.2. Feature Survey

Faceted browsing [38] has become popular as an interaction
form for sites which contain structured data, such as Ebay.com and
Yelp.com [13]. In addition, the faceted browsing model has been
adopted in systems which operate over RDF datasets.

Our choice of a few core operations represents a trade-off
decision between complexity of queries and ease of use. Table 2
compares the core features of browsing systems taking an objectoriented perspective. Our system uses the core set of query
primitives common to a range of established browsing and navigation systems for semi-structured data, providing evidence that
the selection of features in our system represents a consensus
in the community. This suggests that a sizeable user community is able to conceptually grasp the query operations offered by
VisiNav.

Table 2
Comparison of query operations (Keyword Search K, Object Focus O, Path Traversal
P, Facet Selection F) of systems operating over object-structured data (x = yes, - =
no, o = only rdf:type facets).

System

Magnet [32]
MuseumFinland [19]
GRQL [2]
SWSE [17]
/facet [15]
BrowseRDF [30]
ESTER [3]
TcruziKB [27]
Tabulator [24]
Falcons [6]
Humboldt [22]
Parallax [18]
ECSSE [8]
VisiNav

Results

Set
Set
Set
Set
Set
Set
Set
Set
Tree
Set
Sets
Sets
Set
Trees

Fig. 3. Partial result tree for query objects foaf:made by people that timbl:i
foaf:knows (Query 6). Labels displayed instead of URIs for clarity.

A query Q expressed over the object set U described by the quad
and text relations returns as result a number of sets R0...n where n is
the number of path traversal operations. The individual operations
are defined in terms of relational algebra [1] as follows:
 Keyword Search: the k operation returns a set of objects which
satisfy the keyword selection criteria, and an empty result if there
is no match. The operation is defined as: k(k0..m) = s(t=k0
text) 
. . .  s(t=km text)
 Object Focus: the o operation returns an object with the specified URI, if the object exists in the dataset, and an empty result
otherwise. The operation is defined as: o(s) = s(s=s quad)
 Path Traversal: the p operation returns a set of objects which satisfy the path selection criteria. p always returns a result, since
the user can only choose valid paths. The operation is defined as:
p(p) = s,o(p=p quad)
 Facet Selection: the f operation returns a set of objects which
satisfy the selection criteria. f always returns a result, since the
user can only choose valid facets. The operation is defined as:
f (p, o) = s(p=po=o quad)

Fig. 2. Interaction flow diagram.

3.4. Result Trees

3.3. Formal query model

An important aspect of usability of user interfaces is consistency
and predictability [28,29]. We present a formalisation of query
operations which are used to implement the system to ensure the
system behaves consistently and predictably, resulting in improved
usability.

We assume a collection of objects U identified via URIs or blank
nodes. Objects are described using datatype properties PD with literal attributes L and object properties PO denoting links to other
objects U. Properties can be objects as well: PD  U and PO  U.
We assume one relation quad(s, p, o, c) = (U PD  PO  L U U),
modelling the source of subject/predicate/object triples as fourth
field. We also assume a relation text(t, s) = (T U) which models an
inverted index over tokens T derived from the literals L using a
string tokenisation method.10

Users start a query building process via specifying a keyword,
and then iteratively refine the query, or start a new query based on
the available choices offered by the result set. Fig. 2 illustrates the
high-level interaction cycle. During each interaction step, the users
select one of the operations, and the system returns with a page
containing a visual representation of the query, state, and query
results. The query results are first displayed in a familiar list view,
but users can choose other views or visualisations depending on
the properties of the objects in the result set.

10 A number of tokenisation methods have been proposed in information retrieval
 our approach is agnostic to the tokenisation method used.

A single result set is sufficient for keyword searches, object focus
(specifying an initial result set), and facet selection (reducing the
size of the result set). The path traversal operation is different:
traversing a path restricts the old result set (to the objects with
the specified property) and generates a new result set (with the
objects that are connected via the specified property). Thus, iterative application of the restriction and navigation operations leads
to sets of focus nodes R0. . .n which are connected to each other via
the specified property in the path traversal operation.

Consider, for example, the query objects foaf:made by people that timbl:i foaf:knows (Query 6). That query yields three
result sets R0, R1, R2. We assume that the query was constructed in
the following way: the user uses object focus operation to specify
the object URI of Tim Berners-Lee R0 =timbl:i, from there performs path traversal along the foaf:knows property R1 = people
that Tim knows, and from there performs another path traversal
along the foaf:made property yielding R2 = things made by people
Tim knows. An example result tree is shown in Fig. 3. An alternative
representation of the result trees is in form of nested relations.

3.5. Topical subgraphs and result objects

To be able to establish the connections between objects shown
in Fig. 3 from R0. . .n, and to be able to render properties of objects
in the result sets, the system requires more information than just
object identifiers. The step involves a number of challenges:
 The dataset contains an RDF graph. For pre-processing and displaying the objects we require to manipulate the objects using a
programming language.

A. Harth / Web Semantics: Science, Services and Agents on the World Wide Web 8 (2010) 348354

 To minimise the amount of data fetched and increase response
time, the system should only fetch additional information about
objects that are ultimately rendered. The result sets may contain
thousands of object identifiers, however, typically only a few are
displayed at once.
 Depending on view or visualisation, only partial sections of the
result object are required. For example, the list view only requires
a few properties of an object.
 Since the data is very diverse and the amount of information available for objects varies enormously, we need to pick the best data
for display. For example, displaying thousands of quads in the
results view will likely overwhelm the users.
 To provide a meaningful display of information, the system
requires data items to be ordered, showing the most important
values first.

To solve the mismatch between RDF graph and objects that
can be manipulated in a programming language, we use a
generic implementation that stores properties of objects similar to
ActiveRDF [31]. We cannot use mapping tools such as RDFReactor11
since objects aggregated from many web sources do not strictly
adhere to the vocabulary specifications. In addition, we require a
way for generic processing of objects regardless of type.

We employ ranking to minimise the amount of data fetched and
therefore reduce response time. We assume a global rank for each
element in U. Full treatment of the ranking procedure is beyond the
scope of this paper (see [12] for details), however, one can assume
the occurrence count of a node as sufficiently useful approximation
for the popularity of the node.

The system first orders the objects in R0. . .n according to their
global rank and then selects the objects in the range that should be
displayed. Depending on the selected view, the system constructs
a topical subgraph with all the information required to display
the object. Given the topical subgraphs adorned with result nodes
of level 0 . . . n in conjunction with the initial query we are able to
construct paths connecting the objects in various layers of R0. . .n.

Once the topical subgraph is parsed into a programming
language object, the system orders the properties, literals and associated objects pertaining to the object according to the global rank.
Thus, the algorithms selecting the pieces of data for display can
retrieve elements of objects in order and more likely display meaningful information than with random order.

4. Discussion

In the following we discuss design decisions that directly follow from the properties of our web dataset. While existing work
on faceted search covers datasets with little variation (e.g. [9] evaluates datasets with 14815 facets), our dataset contains over 21k
different vocabulary URIs (properties and classes) mandating a different approach to faceted navigation.

4.1. Ranking

Throughout the user interface the system has to decide how to
order data items. For example, the set of result objects in the list
view has to be ordered, the predicate/object combinations in the
detail view have to be ordered, and the properties in the table view
have to be ordered. In lieu of a fixed schema to code against, and
given the lack of rendering descriptions in e.g. Fresnel [4], ranking
becomes the method of choice for deciding on how to arrange items
in the visualisations.

4.2. Facets in content

In faceted navigation the facets are aggregated from all available
items in the current result set. Various heuristics are applied to cut
down the amount of processing and the size of facets presented to
the user [9]. For web data on a large scale, these heuristics are currently missing. Without such heuristics, computing an aggregated
view of all facets in a large result set (such as for query 8, rdf:type
foaf:Person) becomes very expensive. In addition, it is not clear
how to visualise the aggregated view consisting of potentially hundreds of facets.

Given these issues, we exploit the fact that the detail view
contains all items required to specify additional facets restriction
or path traversal operations. Hence, the detail view is also used
to specify parameters for additional query operations. Using incontent facets in conjunction with drag-and-drop actions reduces
visual clutter and thus increases the ink-to-data ratio, one of the
tenets of good visual design [35].

Use of in-content facets is also the reason why the interaction
always starts with a keyword query or object focus operation: users
can pick up a facet or path traversal from the initial result set as
input to both the current query or a new query. The alternative of
just using point-and-click actions would require a large number of
buttons cluttering the user interface (for example, the user interface
would require three buttons next to each object to allow for the
object focus, add facet to current result, and use facet to construct
new query operations).

4.3. Evaluation

The system underwent several user tests and expert reviews
during design and development. We used the thinking aloud
method [20] on prototypes using both the Mondial dataset [26]
and a Web dataset, which led to several changes and adaptations
of the system. Complete user tests are subject to future work.

5. Related work

A number of systems exist that operate over RDF data. Broadly
speaking, most of the generic data browsing systems follow
the naked objects approach [7]: objects are displayed directly
without type-specific styling; as a result, user interfaces can be
generated automatically and do not need domain-specific adapta-
tion. Ideally, systems would provide means for styling the display
of objects based on templates (if there exists a template for a specific type of objects) similar to Fresnel [4] or Tal4Rdf,12 however,
declarative templating languages for RDF are still in early stages of
research.

Most of the current RDF browsers implement a series of design
steps that can be described in terms of the Semantic Hypermedia
Design Method [10]. The method describes techniques to perform
requirement analysis, data modelling tasks, defining user interactions and the final display of objects. In a sense, our approach is
a generalised version of the method, where, rather than specifying data and interaction model in concrete terms pertaining to
a schema, we describe our abstract interface  the information
exchange between users and system  in terms of general query
operations, and result pages as generic rendering of trees of objects.
Our concrete interface  the look and feel  is implemented using a
multi-layered rendering pipeline spanning server (RDF, queries and
XML) and client (XSLT and CSS), with only minimal assumptions on
the schema used to describe the objects.

11 http://rdfreactor.semweb4j.org/.

12 http://champin.net/t4r/.

Rather than operating on objects described in RDF documents,
search engines such as Swoogle [11] and Sindice [36] assume a
document-centric model. The main operation of the systems is
to return RDF documents which contain specified keywords. As
a result, the systems do not allow to integrate data about the
same object from different RDF documents; the systems also lack
functionality such as facet selection and path traversal which
require an object-oriented perspective rather than a documentcentric one.

Systems for browsing and displaying semi-structured data
range from quite basic browsing facilities (allowing only to navigate from one object to another) to systems including constructs
such as negation [30] or nested facets [37]. Semantic MediaWiki
[23] allows to embed complex queries into wiki pages, however,
these queries typically represent a once-off query and do not allow
for iteratively refining results. Typical Linked Data browsers fetch
data on demand and thus lack features such as keyword search or
facet selection which require query processing capabilities over the
entire collected and integrated dataset.

The systems most closely related to our system in terms of features are GRQL [2], Humboldt [22] and Parallax [18]. GRQL relies on
schema information rather than automatically deriving the schema
from the data itself, a feature required for web data which does
not necessarily adhere to the vocabulary definitions. GRQL lacks
keyword search, a useful feature when operating on arbitrary data,
since keywords are independent of any schema. Rather than allowing arbitrary facets, GRQL allows to restrict based on the rdf:type
predicate. GRQL is, to our knowledge, the earliest system that provides functionality to perform set-based navigation. Parallax [18]
is a recent system which exhibits browsing features similar to
ours. However, Parallax operates over the Freebase dataset which
is manually curated and requires the user to select one of the
many disparate datasets contained in Freebase; our system operates over a fully integrated RDF dataset collected from the web.
In contrast to Parallax which lacks ranking, VisiNav prioritises the
display of data based on global ranks. Although Parallax uses multiple result sets, the connections between the result sets are not
propagated to the level of the user interface; our system maintains result paths in the results trees. Finally, we provide a set
of export plug-ins which allows to directly load result sets into
application programs and online services for display or further pro-
cessing.

NLMenu [34] is an early system advocating the use of multistep query construction based on menus. Faceted browsing [38],
while less expressive in terms of the complexity of queries, has
become popular and is used on e-commerce sites such as Ebay.com.
Polaris [33] provides complex query and aggregation operations,
however, operates over relational data and thus requires a priori
knowledge about the schema used. Cammarano et al. [5] describe
a method to match data with visualisation specifications based
on schema matching algorithms. However, their method does not
include means for users to graphically construct the visualisation
specification.

While natural

language question answering interfaces are
judged preferable to other interfaces by users [21], they are
not in common use today. Despite user training with regards
to the capabilities and limitations of a natural language system,
users quickly develop negative expectations about the system
due to the relatively high error rates in parsing and interpreting
natural language [34]. Users are unable to understand the limitations of such systems, that is, to distinguish between conceptual
coverage (i.e. does the dataset contain the answer?) and linguistic coverage (i.e. is the system capable of parsing the query?).
One way of reducing the error rate in parsing queries could
be restricting the type of questions a user may ask to the sys-
tem.

6. Conclusion

The ability to integrate hitherto disparate pieces of data and
thus enable applications to re-purpose data in unanticipated ways
enables novel applications, but at the same time introduces new
challenges to the design of user interfaces. In this paper, we introduce a general, formal model for searching and browsing objects,
and present a prototype system implementing these ideas. The
interaction model provides operations that allow users to explore
and visualise data without requiring knowledge about the schema
of the data. Users are able to learn the structure of the domain of
interest while interacting with VisiNav.

The system provides a universal way of interacting with any RDF
dataset, without manual curation of the data or domain-specific
adaptation of the interface, and thus can be directly applied to
data from the open web. In addition, the system allows to rapidly
develop and employ data integration systems in more confined
environments such as intranets where the data is typically domainspecific and comes from a limited number of data sources, which
opens the door for cost-effective manual curation of the data. In
such environments, providing domain-specific widgets for visualising popular types of objects (similar to the current timeline and
map visualisations) is a way to further increase the overall utility
of the system.

Potential areas of future work include to investigate the possibility of mapping the generic query operations to other modalities,
such as natural language or speech input. Also, we would like to
test our system on new hardware such as touch screens, and investigate how groups of users can use VisiNav to collectively explore
and analyse data integrated from vast amounts of sources.

Acknowledgements

I gratefully acknowledge the comments of the participants of
the user studies, and discussions with Paul Buitelaar, Brian Davis,
Stefan Decker, Renaud Delbru, Armin Haller, Aidan Hogan, Sheila
Kinsella, Axel Polleres, Rene Schubotz, and Jurgen Umbrich.

A large portion of this work has been carried out at the Digital Enterprise Research Institute (DERI) in Galway and has been
partially supported by Science Foundation Ireland under Grant No.
SFI/08/CE/I1380 (Lion-2).
