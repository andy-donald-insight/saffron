Web Semantics: Science, Services and Agents

on the World Wide Web 1 (2004) 345357

Reducing OWL entailment to description logic satisfiability

Ian Horrocksa,

, Peter Patel-Schneiderb

a Department of Computer Science, University of Manchester, Kilburn Building, Manchester M13 9PL, UK

b Bell Labs Research, Lucent Technologies, Murray Hill, NJ, USA

Received 11 March 2004; received in revised form 25 June 2004; accepted 28 June 2004

Abstract

We show how to reduce ontology entailment for the OWL DL and OWL Lite ontology languages to knowledge base satisfiability
in (respectively) the SHOIN(D) and SHIF(D) description logics. This is done by first establishing a correspondence between
OWL ontologies and description logic knowledge bases and then by showing how knowledge base entailment can be reduced
to knowledge base satisfiability.
 2004 Elsevier B.V. All rights reserved.

Keywords: OWL Lite; Architecture; Knowledge

1. Introduction

The aim of the Semantic Web is to make web resources (not just HTML pages, but a wide range of web
accessible data and services) more readily accessible to
automated processes. This is to be done by augmenting
existing presentation markup with semantic markup,
i.e., meta-data annotations that describe their content
[2]. According to widely known proposals for a Semantic Web architecture, ontologies will play a key role as

 This is a revised and extended version of a paper of the same
name that was presented at ISWC-2003 in October 2003.


Corresponding author. Tel.: +44 161 275 6133;

fax: +44 161 275 6236/6203.

E-mail addresses: horrocks@cs.man.ac.uk

(I. Horrocks); pfps@research.bell-labs.com
(P. Patel-Schneider).

1570-8268/$  see front matter  2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2004.06.003

they will be used as a source of shared and precisely
defined terms that can be used in such metadata [15].
The importance of ontologies in semantic markup
has prompted the development of several ontology languages specifically designed for this purpose. These
include OIL [7], DAML+OIL [13] and OWL [4,16].
OWL is of particular significance as it has been developed by the W3C Web Ontology Working Group, and
is now an official W3C recommendation.

The OWL recommendation actually consists of
three languages of increasing expressive power: OWL
Lite, OWL DL and OWL Full. Like OWLs predecessor
DAML + OIL, OWL Lite and OWL DL can be viewed
as expressive description logics with an RDF syntax.
They can therefore exploit the considerable existing
body of description logic research. In particular, these
two languages can utilize previous work reported on in
the description logic literature to define their semantics

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

and to understand their formal properties such as the
decidability and complexity of key inference problems
[6]. OWL Full provides a more complete integration
with RDF, but its formal properties are less well under-
stood, and key inference problems would certainly be
much harder to compute.1 This paper, therefore, concentrates on the provision of reasoning services for
OWL Lite and OWL DL, and does not consider reasoning in OWL Full.

1.1. OWL reasoning

Reasoning with ontology languages will be important in the Semantic Web if applications are to exploit
the semantics of ontology based metadata annotations.
For example, if semantic search engines are to find
pages based on the semantics of their annotations rather
than their syntax, then they need to perform semantic reasoning in the language of the annotations. As
well as providing insights into OWLs formal proper-
ties, OWLs relationship to expressive description logics provides a source of algorithms for solving key inference problems, in particular satisfiability. Moreover,
in spite of the high worst case complexity of reasoning
in such description logics, highly optimised implementations of these algorithms are available and have been
shown to work well with realistic problems. Two difficulties arise, however, when attempting to use such implementations to provide reasoning services for OWL:

1. OWLs RDF syntax uses frame-like constructs that
do not correspond directly to description logic ax-
ioms; and

2. as in RDF, OWL inference is defined in terms of ontology entailment rather than ontology satisfiability.

Note that entailment between ontologies (similarly,
entailment between RDF graphs) is a basic inference
task into which most other inference tasks can be trans-
formed: given an ontology O, a class C is subsumed
by a class D with respect to O just in case O entails
the ontology {SubClassOf (C D)}, and i is an instance
of C with respect to O just in case O entails the ontology {Individual(i type(C))}. Moreover, trans-

1 Inference in OWL Full is clearly undecidable as OWL Full does
not include restrictions on the use of transitive properties which are
required in order to maintain decidability [11].

forming these inference tasks into ontology (graph) satisfiability requires full negation, which is not available
in either RDF or RDF Schema, and is not directly supported in OWL Lite.

The obvious solution to the first difficulty is to define a mapping that decomposes OWL axioms into one
or more description logic axioms. It turns out, how-
ever, that the RDF syntax used in OWL cannot be directly translated into any standard description logic
because it allows the use of anonymous individuals in
axioms asserting the types of and relationships between
individuals. The obvious solution to the second difficulty is to reduce entailment to satisfiability. Doing this
naively would, however, require role negation, and this
is not supported in any implemented description logic
reasoner.

In this paper we will show that, in spite of these dif-
ficulties, ontology entailment in OWL DL and OWL
Lite can be reduced to knowledge base satisfiability in
the SHOIN(D) and SHIF(D) description logics re-
spectively. This is achieved by mapping OWL to an
intermediate description logic that includes a novel axiom asserting the non-emptiness of a class, and by using
a more sophisticated reduction to satisfiability that both
eliminates this constructor and avoids the use of role
negation.

This is a significant result from both a theoretical and a practical perspective: it demonstrates that
computing ontology entailment in OWL DL (respec-
tively OWL Lite) has the same complexity as computing knowledge base satisfiability in SHOIN(D)
(SHIF(D) ), and that description logic algorithms and
implementations (such as RACER [8]) can be used
to provide reasoning services for OWL Lite. The design of practical algorithms for SHOIN(D) is still
an open problem, but one that is the subject of active
investigation.

2. The OWL Web ontology language

As mentioned above, OWL [4,16] is an ontology
language that has recently been developed by the W3C
Web Ontology Working Group. OWL is defined as an
extension to RDF in the form of a vocabulary entailment [9], i.e., the syntax of OWL is the syntax of RDF
and the semantics of OWL are an extension of the semantics of RDF.

OWL has many features in common with description logics, but also has some significant differences.
The first difference between OWL and description logics is that the syntax of OWL is the syntax of RDF.
OWL information is thus encoded in RDF/XML documents [1] and parsed into RDF Graphs [14] composed
of triples. Because RDF Graphs are such an impoverished syntax, many description logic constructs in
OWL are encoded into several triples. Because RDF
Graphs are graphs, however, it is possible to create circular syntactic structures in OWL, which are not possible in description logics. Subtle interactions between
OWL and RDF cause problems with some of these circular syntactic structures.

The second difference between OWL and description logics is that OWL contains features that do not fit
within the description logic framework. For example,
OWL classes are objects in the domain of discourse
and can be made instances of other concepts, including
themselves. These two features, also present in RDF,
make a semantic treatment of OWL quite different from
the semantic treatment of description logics.

2.1. OWL DL and OWL Lite

Fortunately for our purpose, there are officiallydefined subsets of OWL that are much closer to description logics.

The larger of these subsets, called OWL DL, restricts
OWL in two ways. First, unusual syntactic constructs,
such as descriptions with syntactic cycles in them, are
not allowed in OWL DL. Second, classes, properties,
and individuals (usually called concepts, roles and individuals in description logics) must be disjoint in the
semantics for OWL DL. These two restrictions make
OWL DL much closer to a description logic.

Because of the syntactic restrictions in OWL DL,
it is possible to develop an abstract syntax for OWL
DL [16] that looks much like an abstract syntax for
a powerful frame language, and is not very different
from description logic syntaxes. This is very similar to
the approach taken in the OIL language [7]. The abstract syntax for OWL DL has classes and data ranges,
which are analogues of concepts and concrete datatypes
in description logics, and axioms and facts, which are
analogues of axioms in description logics.

Axioms and facts are grouped into ontologies, the
analogue of description logic knowledge bases, which

Fig. 1. OWL DL Description Constructors.

are the highest level of OWL DL syntax. Ontologies
can import other ontologies in OWL, but this importing
should be handled outside of the semantics for OWL
and thus does not affect the reduction to description
logics.

The constructors used to form OWL DL descriptions
and data ranges are provided in Fig. 1; in the figure A is a
class name, C (possibly subscripted) is a class, o (possi-
bly subscripted) is an individual name, R (possibly sub-
scripted) is an object property (also called abstract or
individual-valued properties), T (possibly subscripted)
is a datatype property,2 B is a datatype, D (possibly
subscripted) is a data range, v (possibly subscripted) is
a data value, and , m, n are non-negative integers. A
data value is either of the form 
d, where d is the
name of a supported datatype and  is a lexical form in
that datatype, or an untyped string with an optional language tag. For example, 1
xsd:integer denotes the
integer 1, whereas both 1
xsd:string and 1 denote one-character strings. An OWL DL or OWL Lite
reasoner may support many datatypes, but must support at least the XML Schema datatypes xsd:integer
and xsd:string. Data values of the form 
d, where
d is not a supported datatype, are also allowed in OWL
DL and OWL Lite. The denotation of these data values
are unconstrained.


Elements enclosed in braces (i.e., {element}) can be
repeated zero or more times and elements enclosed in

2 An object property is one that associates pairs of individuals; a

datatype property associates an individual with a data value.

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

Fig. 2 ignores annotations and deprecation, which allow uninterpreted information to be associated with
classes and properties, but which are not interesting
from a logical point of view.

Because of the syntactic restrictions in OWL DL,
metaclasses and other notions that do not fit into the
description logic semantic framework can be ignored.
In fact, OWL DL has a semantics that is very much
in the description logic style, and that has been shown
to be equivalent to the RDF-style semantics for all of
OWL [16]. The semantics for OWL DL will be presented below.

There is a subset of OWL DL, called OWL Lite, the
motivation for which is increased ease of implementa-
tion. This is achieved by supporting fewer constructors
than OWL DL, and by limiting the use of some of these
constructors. In particular, OWL Lite does not support
the oneOf constructor (equivalent to description logic
nominals), as this constructor is known to increase theoretical complexity and to lead to difficulties in the design of practical algorithms [10]. In Section 5 we will
examine the differences between OWL DL and OWL
Lite in more detail, and explore their impact on the
reduction from OWL entailment to description logic
satisfiability.

2.2. Semantics for OWL DL

OWL DL has two forms of semantic specifica-
tion: a direct model-theoretic semantics, and an RDFcompatible model-theoretic semantics [16]. The two
are said to have a strong correspondence, but the
specification explicitly states that the direct modeltheoretic semantics takes precedence. We will, there-
fore, only consider the direct model-theoretic seman-
tics, and from now on when we refer to the semantics
for OWL DL (or OWL Lite), this can be taken to mean
the direct model-theoretic semantics.

The semantics for OWL DL is fairly standard by description logic standards. The OWL semantic domain
is a set whose elements can be disjointly divided into
abstract objects (the abstract domain, written I) and
datatype values (the datatype or concrete domain, written I
D and often called concrete objects). Datatypes
in OWL are derived from the built-in XML Schema
datatypes [3], with inappropriate datatypes removed,
although as mentioned in Section 2.1, an OWL DL
or OWL Lite reasoner may not support all of these

Fig. 2. OWL DL Axioms and Facts.

square brackets (i.e., [element]) are optional. A more
leisurely description of these constructors can be found
in the OWL documentation [4,16].

Names in OWL are officially URI references, but all
that matters here is that they are treated in our semantics
as atomic names.

Classes and data ranges can be used in OWL DL
axioms and facts to provide information about classes,
properties, and individuals. Fig. 2 provides the syntax
of these axioms and facts. In this figure, the same conventions are used as in Fig. 1 with the addition that
value(pi xi) is a value condition where pi is either a
datatype property, in which case xi is a data value, or
an object property, in which case xi is either an individual name or an individual fact.

To preserve decidability of reasoning in OWL DL,
complex object properties cannot be specified to be
transitive. An object property is complex if either

1. it

is specified as being functional or inverse-

functional,

2. there is some cardinality restriction that uses it,
3. it has an inverse that is complex, or
4. it has a super-property that is complex.

Again, a more leisurely description of these constructors can be found in the OWL documentation [4,16].

datatypes. Datatype values are denoted by special literal constructs in the syntax, as indicated above.

In order to be closer to the RDF semantics [9], an interpretation in the semantics for OWL DL is officially a
sextuple consisting of the abstract domain, the concrete
domain, a mapping from class names into subsets of the
abstract domain and from datatype names into subsets
of the concrete domain, a mapping from object properties to sets of pairs over the abstract domain and from
datatype properties to sets of pairs from the abstract
domain and the concrete domain,3 a mapping from individual names to values in the abstract domain, and a
mapping from literals to values in the concrete domain.
This does not quite match up with the description logic
method of using a two-tuple consisting of the domain
(written I) and a single mapping (written I) for con-
cepts, properties, and individuals, with datatypes handled as an external parameter. There is, however, an
obvious isomorphism between the two methods, and
so either one can be used for our purposes.

In OWL DL all classes are interpreted as subsets
of the abstract domain, and for each constructor the
semantics of the resulting class is defined in terms of the
semantics of its components. For example, given two
classes C1 and C2, the interpretation of the intersection
of C1 and C2 is defined to be the intersection of the
interpretations of C1 and C2 (i.e., C1

I  C2

I).

OWL DL axioms and facts result in semantic conditions on interpretations. For example, an axiom asserting that D1 is a subclass of D2 results in the semantic
condition that the interpretation of D1 must be a sub-
I),
set of the interpretation of D2, (written D1
while a fact asserting that o has type D results in the
semantic condition that the interpretation of o must be
an element of the set that is the interpretation of D
(written oI  DI), just as happens in description logic
semantics.

I  D2

An OWL DL ontology O is satisfied by an interpretation I just when all of the semantic conditions
resulting from the axioms and facts in O are satisfied
by I, just as is the case in description logic knowledge
bases. Because this part of the semantics for OWL DL
is so close to the semantics of description logics, it will
not be further provided here; instead, we will use the
description logic semantics directly, as we will mainly

be interested in description logic knowledge bases derived from OWL ontologies. More details of OWL DL
semantics can be found in the OWL documentation
[16].

The main semantic relationship in OWL DL is
entailmenta relationship between pairs of OWL on-
tologies. An ontology O1 entails an ontology O2, written O1 |= O2, exactly when all interpretations that satisfy O1 also satisfy O2. This semantic relationship is
different from the standard description logic relation-
ships, such as knowledge base and concept satisfiabil-
ity. The main goal of this paper is to show how OWL
DL entailment can be transformed into DL knowledge
base (un)satisfiability, and that the two problems have
the same complexity.

3. SHOIN(D) and SHIF(D)

The main description logic that we will be using
in this paper is SHOIN(D) , which is similar to the
well known SHOQ(D) description logic [10], but is
extended with inverse roles (I) and restricted to unqualified number restrictions (N).

In description logics, a datatype theory D is a mapping from a set of datatypes to a set of values, e.g., from
xsd:integer to the integers, plus a mapping from data
values to their denotation which must be one of the set
of values, e.g., from l
xsd:integer to the integer 1.
The datatype (or concrete) domain, written I
D, is the
union of the mappings of the datatypes.


Given a datatype theory D, let A , RA, RD, and I be
pairwise disjoint sets of concept names, abstract role
names, datatype (or concrete) role names, and individual names.4 The set of SHOIN(D) -roles is RA 
{R | R  RA}  RD. In order to avoid considering
we will define Inv(R) s.t. Inv(R) =
roles such as R
) = R. The set of SHOIN(D) -
and Inv(R

concepts is the smallest set that can be built using the
constructors in Fig. 3.

Fig. 3 also gives the axiom syntax for SHOIN+

(D),
an extension of SHOIN(D) with the concept existence
axiom (the last axiom in Fig. 3), which is used internally
in our translation. Concept existence axioms will be

3 This mapping is also used to provide meaning for annotations,

4 Datatype roles names are generally referred to as concrete role

which are not considered in this paper.

names in the description logic literature.

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

An

satisfies

The semantics of SHOIN+

(D) is given by means
of an interpretation I = (	I,I) consisting of a nonempty domain I, disjoint from the datatype domain
D, and a mapping I, which interprets atomic and

complex concepts, roles, and nominals according to
Fig. 3. (In Fig. 3,  is set cardinality.)
I = (	I,I)
interpretation

SHOIN+
(D) -axiom under the conditions given
in Fig. 3. An interpretation satisfies a knowledge base
K iff it satisfies each axiom in K; we will often call
such an interpretation a model of K. A knowledge base
K is satisfiable (unsatisfiable) iff there exists (does
not exist) a model of K. A SHOIN+
(D) -concept
C is satisfiable with respect to a knowledge base K
iff there is a model I of K with CI = . A concept
C is subsumed by a concept D with respect to K
iff CI  DI in every model I of K. Two concepts
are said to be equivalent with respect to K iff they
subsume each other with respect to K. A knowledge
base K1 entails a knowledge base K2 iff every model
of K1 is also a model of K2.
Although this is not usually done in description log-
ics, we define a notion of entailment in SHOIN+
(D)
in the same way as it was defined for OWL DL. One
SHOIN+
(D) knowledge base entails another, written K |= K
, if every model of the first knowledge
base, K is also a model of the second, K
. It is easy
to show that K |= K
iff K |= A for every axiom A
in K

The description logic SHIF(D) is just SHOIN(D)
without the oneOf constructor and with the atleast
and atmost constructors limited to 0 and 1. We define
SHIF+
(D) as SHIF(D) extended with the concept
existence axiom.

Fig. 3. Syntax and semantics of SHOIN+

(D) .

A SHOIN+

(D) axioms. We will use

eliminated in the final step of our translation, leaving
only SHOIN(D) axioms.
(D) knowledge base K is a finite set
of SHOIN+
to denote the
transitive reflexive closure of  on roles, i.e., for two
R in K if S = R, S  R  K,
roles S,R in K, S
Inv(S)  Inv(R)  K, or there exists some role Q
such that S Q in K and Q R in K. A role R
is called simple in K if for each role S s.t. S

in K, Trans(S)  K and Trans(Inv(S))  K. To maintain decidability, a knowledge base must have no number restrictions on non-simple roles [11].

4. From OWL DL entailment to SHOIN(D)
unsatisfiability

We will now show how to translate OWL DL entailment into SHOIN(D) unsatisfiability. The first step of
our process is to translate an entailment between OWL
DL ontologies into an entailment between knowledge
bases in SHOIN+
(D) entailment
is transformed into unsatisfiability of SHOIN(D)
knowledge bases. Note that concept existence axioms
are eliminated in this last step, leaving a SHOIN(D)
knowledge base.

(D) . Then SHOIN+

From now on D will be a particular kind of datatype
theory, namely for the well-behaved XML Schema
datatypes [3] plus a datatype for untyped OWL literals plus one other datatype, whose extension is the
entire datatype domain, and using the OWL syntax for
data values. (See the OWL documentation [16] for the
particulars of which XML Schema datatypes are wellbehaved and why.) The extra datatype, which cannot
occur in the ontologies being translated, will be used
as a way to write unknown data values.

It is easy to see that these datatypes comprise a

datatype theory.
4.1. From OWL DL to SHOIN+

(D)

An OWL DL ontology is

translated into a
SHOIN+
(D) knowledge base by taking each axiom
and fact in the ontology and translating it into one or
more axioms in the knowledge base.

For OWL DL axioms, this translation is very natu-
ral, and is almost identical to the translation of OIL described by Decker et al. [5]. For example, the OWL DL
axiom Class(A complete C1. . . Cn) is translated into
(D) axioms A  V(C1)  . . . 
the pair of SHOIN+

V(Cn) and V(C1)  . . .  V(Cn)  A, where V is the
obvious translation from OWL classes to description
logic concepts, again very similar to the transformation
described by Decker et al. [5]. Similarly, an OWL DL
axiom DisjointClasses(C1 . . . Cn) is translated
(D) axioms V(Ci)  V(Cj) for
into the SHOIN+
1  i < j  n. The translation from OWL DL classes
to SHOIN(D) classes is given in Fig. 4 and the translation from OWL DL axioms to SHOIN(D) axioms
is given in Fig. 5.

The translation of OWL DL facts to SHOIN+

(D)
axioms is more complex. This is because facts can be
stated with respect to anonymous individuals, and can
include relationships to other (possibly anonymous)
individuals. For example, the fact Individual(type(C)
value(R Individual(type(D)))) states that there exists an
individual that is an instance of class C and is related
via the property R to an individual that is an instance of
the class D, without naming either of the individuals.
The need to translate this kind of fact is the reason
for introducing the SHOIN+
(D) existence axiom. For
example, the above fact can be translated into the axiom (C  RD), which states that there exists some
instance of the concept C  RD, i.e., an individual

Fig. 4. Translation from OWL classes and names to SHOIN(D) .

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

Fig. 5. Translation from OWL facts to SHOIN+

(D) .

Proof. A simple recursive argument based on the semantics of OWL DL and SHOIN+
(D) shows that the
extension of OWL DL classes, data ranges, and pieces
of Individual facts is maintained in the translation. Sim-
ilarly, a simple semantics based argument shows that
the translation of OWL DL axioms and facts preserves

satisfaction.

The above translation increases the size of an ontology to at most the square of its size. It can easily
be performed in time linear in the size of the resultant
knowledge base.

4.2. From entailment to unsatisfiability

The next

step of our process

is

(D) knowledge base entailment

to transform SHOIN+
to
SHOIN(D) knowledge base unsatisfiability. We do
this to relate our new notion of description logic entailment to the well-known operation of description logic
knowledge base unsatisfiability.
iff K |= A
for every axiom A in K
. We therefore define (in Fig. 7)
a translation, G , such that K |= A iff K  {G(A)} is
unsatisfiable, for K a SHOIN+
(D) knowledge base

We recall from Section 3 that K |= K

Fig. 6. Translation from OWL facts to SHOIN+

(D) .

that is an instance of C and is related via the role R to
an instance of the concept D. Fig. 6 describes a translation F that transforms OWL Individual facts into
SHOIN+
(D) existence axioms (and the other OWL
facts into SHOIN(D) axioms).

Theorem 1.
The translation from OWL DL to
SHOIN+
(D) preserves satisfiability. That is, an OWL
DL axiom or fact is satisfied by an interpretation I if
and only if the translation is satisfied by I.5

5 The statement of the theorem here ignores the minor differences
between OWL DL interpretations and SHOIN+
(D) interpretations.
A stricter account would have to worry about these stylistic differ-
ences.

Given that E(K) |= K

in which 	I = I and I

of K, because for every axiom of the formC  K there
is an axiom a : C  E(K), so aI  CI and #(CI)  1;
a model I of K can be trivially extended to a model of
E(K) by interpreting each fresh individual a in an axiom
a : C in E(K) as an element of CI (such an element must
exist as there is a corresponding axiom C in K).
iff E(K) |= A for every axiom
, we only need to show that E(K) |= A iff E(K) 
A in K
{G(A)} is unsatisfiable for any given axiom A. We can
do this on a case by case basis for the seven kinds of
axiom described in Fig. 7. In most cases the proof is a
trivial consequence of the semantics, and of the fact that
the fresh individuals introduced by the transformation
can be interpreted as any element of I (because they
are not mentioned elsewhere in E(K)). In the following,
c, d are concepts, r, s are roles, a, b are individuals, d
is a data value, x, y are fresh individuals, v, w, z are
elements of I and i is an element of I
D. We will often
refer to an extension of an interpretation I, meaning an
interpretation I
is extended
to interpret fresh individuals.
 E(K) |= c  d iff E(K)  {x : c  d} is not satis-
fiable. If E(K) |= c  d then in every model I of
E(K), cI  dI and (c  d)I = , so I cannot satisfy x : c  d. For the converse, if I is a model
of E(K) in which cI  dI, then there exists some
w  (c  d)I, and I can be extended to I
such
that xI = w. I
therefore satisfies x : c  d, and it
is still a model of E(K) because x is not mentioned
is a model of E(K)  {x : c  d}.
in E(K), so I
 E(K) |= c iff E(K)  {  c} is not satisfiable. If
E(K) |= c, then in every model I of E(K), cI = ,
so (c)I  I and I does not satisfy   c. For
the converse, if E(K)  {  c} is not satisfiable,
then (c)I  I and cI =  in every model I of
E(K).
E(K)  {x : rr.{y} 
r.{y}} is not satisfiable. If E(K) |= Trans(r),
then in every model I of E(K), rI = (rI)
, and
{(xI, w), (w, yI)}  rI implies (xI, yI)  rI, so I
cannot satisfy x : rr.{y}  r.{y}. For the con-
verse, if I is a model of E(K) in which in which for
some v, w, z, {(v, w), (w, z)}  rI but (v, z)  rI,
such that xI = v and
then I can be extended to I
yI = z, so xI  (rr.{y})I
, xI  (r.{y})I
and
xI  (rr.{y}  r.{y})I
. I
therefore satisfies
x : rr.{y}  r.{y}, and it is still a model of

 E(K) |= Trans(r)

iff

Fig. 7. Tanslation from Entailment to Unsatisfiability.

and A a SHOIN+
(D) axiom. In this transformation we
have need of names of various sorts that do not occur
in the knowledge base or axiom; following standard
practice we will call these fresh names. Throughout
the translation, x and y are fresh individual names.

Most of the translations in G are quite standard and
simple. For example, an object role inclusion axiom
r  s is translated into an axiom x : r.{y}  s.{y}
that requires the existence of an individual that is related to some other individual by r but not by s; a knowledge base K  {x : r.{y}  s.{y}} will clearly be unsatisfiable iff K |= r  s. The only unusual translation
is for datatype role inclusions f  g. We have included
an extra datatype, whose semantics are purposely left
underdefined, precisely to serve as a source of fresh
values whose denotation can be arbitrarily adjusted.

The translation G increases the size of an axiom by
at most a constant amount. It can easily be performed
in time linear in the size of the axiom.
The translation G eliminates concept existence axioms from the knowledge base K
on the right-hand side
of the entailment. Our last step is to eliminate concept
existence axioms from the knowledge base K on the
left-hand side of the entailment. We do this by applying
a translation E(K) that replaces each axiom of the form
C  K with an axiom a : C, for a a fresh individual
name. It is obvious that this translation preserves sat-
isfiability, can be easily performed, and only increases
the size of a knowledge base by a linear amount.
be SHOIN+
Theorem 2. Let K and K
(D) knowledge bases. Then K |= K
iff the SHOIN(D) knowledge base E(K)  {G(A)} is unsatisfiable for every axiom A in K
Proof. Firstly, K |= K
. This follows
from the obvious correspondence between models of
K and models of E(K): a model I of E(K) is also a model

iff E(K) |= K

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

E(K) because x is not mentioned in E(K), so I
is a
model of E(K)  {x : rr.{y}  r.{y}}.
 E(K) |= r  s iff E(K)  {x : r.{y}  s.{y}} is
not satisfiable. If E(K) |= r  s,
then in every
model I of E(K), (xI, yI)  rI implies (xI, yI) 
sI, so I cannot satisfy x : r.{y}  s.{y}. For
the converse, if I is a model of E(K) in which
for some v, w, (v, w)  rI but (v, w)  sI, then
such that xI = v and
I can be extended to I
yI = w, so xI  (r.{y})I
, xI  (s.{y})I
and
xI  (r.{y}  s.{y})I
. I
therefore satisfies x :
r.{y}  s.{y}, and it is still a model of E(K) because neither x nor y is mentioned in E(K), so I
is
a model of E(K)  {x : r.{y}  s.{y}}.
 E(K) |= f  g iff E(K)  {x : f.{d}}  g.{d} is
not satisfiable, where d is a fresh data value of
the extra datatype (i.e., a data value not mentioned
in E(K)). If E(K) |= f  g, then in every model
I of E(K), (xI, dI)  f I implies (xI, dI)  gI, so
(f.{d}  g.{d})I =  for any value d, and I cannot satisfy x : f.{d}  g.{d}. For the converse,
if I is a model of E(K) in which for some v, i,
(v, i)  f I but (v, i)  gI, then I can be extended to
such that xI = v and dI = i, so xI  (f.{d})I

xI  (g.{d})I
and xI  (f.{d}  g.{d})I

therefore satisfies x : f.{d}  g.{d}, and it is

still a model of E(K) because neither x nor d is
is a model of E(K)  {x :
mentioned in E(K), so I
f.{d}  g.{d}}.
 E(K) |= a = b iff E(K)  {a = b} is not satisfiable.
If E(K) |= a = b, then in every model I of E(K),
aI = bI, so I cannot satisfy a = b. For the converse,
if E(K)  {a = b} is not satisfiable, then in every
model I of E(K), aI = bI, so E(K) |= a = b.
 E(K) |= a = b iff E(K)  {a = b} is not satisfiable.

This is a trivial variant of the previous case.

Theorems 1 and 2 imply:

Corollary 1. OWL DL entailment can be transformed
into knowledge base unsatisfiability in SHOIN(D) .

4.3. Consequences

The overall translation from OWL DL entailment to
SHOIN(D) can be performed in polynomial time and
results in a polynomial number of knowledge base satisfiability problems each of which is polynomial in the

size of the initial OWL DL entailment. Therefore we
have shown that OWL DL entailment is in the same
complexity class as knowledge base satisfiability in
SHOIN(D) .

Unfortunately, SHOIN(D) is a difficult description logic. Most problems in SHOIN(D) , including
knowledge base satisfiability, are in NexpTime [17].
Further, there are as yet no known optimized inference
algorithms or implemented systems for SHOIN(D) .
The situation is not, however, completely bleak.
There is an inexact translation from SHOIN(D) to
SHIN(D) that turns nominals into atomic concept
names. I.e., for each nominal o, occurrences of o are
replaced by a new concept Po, and an axiom o : Po is
added to the knowledge base; and for each axiom a = b,
the axiom Pa  Pb is added to the knowledge base.
This translation could be used to produce a partial, but
still very capable, reasoner for OWL DL. Moreover, as
is shown in the next section, the situation for OWL Lite
is significantly different.

5. Transforming OWL Lite

OWL Lite is the subset of OWL DL that

1. eliminates the intersectionOf, unionOf,

complementOf, and oneOf constructors;

2. removes the value construct from the restric-

tion constructors;

3. limits cardinalities to 0 and 1;
4. eliminates the enumeratedClass axiom; and
5. requires that description-forming constructors not

occur in other description-forming constructors.

The reason for defining the OWL Lite subset of
OWL DL was to have an easier target for implementa-
tion. This was thought to be mostly easier parsing and
other syntactic manipulations.

As OWL Lite does not have the analogue of nominals it is possible that inference is easier in OWL Lite
than in OWL DL. However, the transformation above
from OWL DL entailment into SHOIN(D) unsatisfiability uses nominals even for OWL Lite constructs. It
is thus worthwhile to devise an alternative translation
that avoids nominals.

There are three places that nominals show up in our

transformation:

be used to simulate a nominal in some cases. In partic-
ular, if B is a fresh concept name, and we assert that a
is an instance of B, then any model I of a knowledge
base K can be extended to a model I
of K in which
BI = {aI}, i.e., a model in which B  {a}. When using this technique, concepts such as B are called pseudo
nominals.

Fig. 8. Translation from OWL Lite facts to SHIF+

(D).

1. translations into SHOIN+

(D) of OWL DL constructs that are not in OWL Lite, in particular the
oneOf constructor;

2. translations into SHOIN+
Individual facts; and
SHOIN+
role inclusion axioms or role transitivity axioms.

3. the transformation to SHOIN(D) unsatisfiability of
(D) entailments whose consequents are

(D) axioms of OWL DL

The first of these, of course, is not a concern when

considering OWL Lite.

from OWL Lite facts to SHIF+

The second place where nominals show up is
in the translation of OWL Individual facts into
SHOIN(D) axioms (Fig. 6). In order to avoid introducing nominals, we can use the alternative translation

(D) given in Fig. 8.
Note that, in this case, the translation V(C) does not introduce any nominals as we are translating OWL Lite
classes.
The new transformation does, however, introduce
axioms of the form a : C, a, b : R and a, v : U that
we will need to deal with when transforming from entailment to satisfiability. We can do this by extending
the transformation G given in Fig. 7 as shown in Fig. 9.
The extension deals with axioms of the form a, v : U
using a datatype derived from the negation of a data
value (written v), and with axioms of the forma, b : R
using a simple transformation, described in more detail
by Horrocks et al. [12]. This transformation exploits the
fact that a fresh concept name (i.e., a concept name that
is not already mentioned in the knowledge base) can

The third and final place where nominals show up
is in the transformation of entailments whose consequents are object role inclusion axioms or role transitivity axioms. Both these cases can also be dealt with
using pseudo nominals. Object role inclusion axioms
can be dealt with using a pseudo nominal transformation similar to those given in Fig. 9. In this transforma-
tion, an axiom of the form r  s is transformed into the
axiom x : B  r(sB), where B is is a fresh concept name. Similarly, transitivity axioms can be dealt
with by transforming an axiom Trans(r) into an axiom
x : B  r(r(rB)).

to denote the transformation described in Figs. 7 and 9 with role inclusion and transitivity transformations modified as described above.

We will use G

Theorem 3.
The translation from OWL Lite to
SHIF+
(D) preserves satisfiability. That is, an OWL
Lite axiom or fact is satisfied by an interpretation I if
and only if the translation is satisfied by I.6
Proof. A simple recursive argument based on the semantics of OWL Lite and SHIF+
(D) shows that the
extension of OWL Lite classes, data ranges, and pieces
of Individual facts is maintained in the translation. Sim-
ilarly, a simple semantics based argument shows that
the translation of OWL Lite axioms and facts preserves

satisfaction.
Theorem 4. Let K and K
(D) knowledge
bases derived from OWL Lite ontologies. Then K |=
(A)} is

unsatisfiable for every axiom A in K
Proof. As a SHIF+
a SHOIN+
sider the new transformations introduced in G
 E(K) |= a : C iff E(K)  {a : C} is not satisfiable.
If E(K) |= a : C then in every model I of E(K), aI 

(D) knowledge base is obviously
(D) knowledge base, we only need to con-

iff the SHIF(D) knowledge base E(K)  {G

be SHIF+

Fig. 9. Extended transformation from entailment to unsatisfiability.

6 This again ignores the minor differences between OWL Lite interpretations and SHIF+

(D) interpretations.

I. Horrocks, P. Patel-Schneider / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 345357

, w  (B)I

CI and I cannot satisfy a : C. For the converse, if
I is a model of E(K) in which aI  CI, then I also
satisfies a : C and E(K)  {a : C} is satisfiable.
 E(K) |= a, b : R iff E(K)  {b : B, a : RB} is
not satisfiable, where B is a concept name not mentioned in E(K). If E(K) |= a, b : R, then in every
model I of E(K), (aI, bI)  RI, and if b : B is satisfied then a : RB is not satisfied. For the con-
verse, if I is a model of E(K) in which (aI, bI)  RI,
such that BI = {bI},
then I can be extended to I
, w)  RI
so for any (aI
, and thus
aI  (RB)I
. I
therefore satisfies both b : B and
a : RB, and it is still a model of E(K) because
B is not mentioned in E(K), so I
is a model of
E(K)  {b : B, a : RB}.
 E(K) |= a, v : U iff E(K)  {a : Uv} is not satis-
fiable, where v is a datatype such that (v)D = I

{vD}. If E(K) |= a, v : U, then in every model I
of E(K), (aI, vD)  UI and a : Uv is not satisfied.
For the converse, if I is a model of E(K) in which
(aI, vD)  UI, then for any (aI, i)  UI, i  (v)D
and aI  (Uv)I. I therefore satisfies a : Uv, and
so it is a model of E(K)  {a : Uv}.
 E(K) |= r  s iff E(K)  {x : B  r(sB)} is
not satisfiable, where B is a concept name not
mentioned in E(K). If E(K) |= r  s, then (v, w) 
rI implies (v, w)  sI and (w, v)  (s
)I, so xI 
(r(sB))I implies xI  (B)I and x : B 
r(sB) is not satisfied. For the converse, if
I is a model of E(K) in which for some v, w,
(v, w)  rI but (v, w)  sI (and so (w, v)  (s
)I),
such that xI = v
then I can be extended to I
and BI = {v}, so xI  BI
, w  (sB)I
and
xI  (r(sB))I
therefore satisfies x : B 
r(sB), and it is still a model of E(K) because
neither x nor B is mentioned in E(K), so I
is a model
of E(K)  {x : B  r(sB)}.
E(K)  {x : B  r(r
(rB))} is not satisfiable, where B is a concept
name not mentioned in E(K). If E(K) |= Trans(r),
then in every model I of E(K),{(xI, w), (w, z)}  rI
implies
so
xI  (r(r(rB)))I implies xI  (B)I and
x : B  r(r(rB)) is not satisfied. For the
converse, if I is a model of E(K) in which for
some v, w, z, {(v, w), (w, z)}  rI but (v, z)  rI
(and so (z, v)  (r
)I), then I can be extended to
such that xI = v and BI = {v}, so xI  BI

 E(K) |= Trans(r)

(xI, z)  rI

(z, xI)  (r

)I,

and

. I

iff

and xI  (r(r(rB)))I

z  (rB)I
. I
therefore satisfies x : B  r(r(rB)), and it
is still a model of E(K) because neither x nor
B is mentioned in E(K), so I
is a model of
E(K)  {x : B  r(r(rB))}.

Theorems 3 and 4 imply:

Corollary 2. OWL Lite entailment can be transformed
into knowledge base unsatisfiability in SHIF(D) .

A simple examination shows that the transformations
can be computed in polynomial time and result in only
a linear increase in size.

As knowledge base satisfiability in SHIF(D) is in
ExpTIme [17], this means that entailment in OWL Lite
can be computed in exponential time. Further, OWL
Lite entailment can be computed by the RACER description logic system [8], a heavily-optimised description logic reasoner, resulting in an effective reasoner for
OWL Lite entailment.

6. Conclusion

Reasoning with ontology languages will be important in the Semantic Web if applications are to exploit
the semantics of ontology based metadata annotations.
We have shown that ontology entailment in the OWL
DL and OWL Lite ontology languages can be reduced
to knowledge base satisfiability in, respectively, the
SHOIN(D) and SHIF(D) description logics. This is
so even though some constructs in these languages go
beyond the standard description logic constructs.

From these mappings, we have determined that
the complexity of ontology entailment in OWL DL
and OWL Lite is in NexpTime and ExpTime respectively (the same as for knowledge base satisfiability
in SHOIN(D) and SHIF(D) respectively). The mapping of OWL Lite to SHIF(D) also means that alreadyknown practical reasoning algorithms for SHIF(D)
can be used to determine ontology entailment in OWL
Lite; in particular, the highly optimised RACER system
[8], which can determine knowledge base satisfaction
in SHIF(D) , can be used to provide efficient reasoning
services for OWL Lite.

The mapping from OWL DL to SHOIN(D) can
also be used to provide complete reasoning services

for a large part of OWL DL, or partial reasoning services for all of OWL DL. Studies directed towards the
development of complete, practical algorithms and systems for all of OWL DL are obviously a high priority
within the description logic and Semantic Web research
communities. If such algorithms cannot be found, it
may be worthwhile to consider revising the specification of OWL DL to eliminate (or at least weaken) one of
the constructors whose interaction causes the difficulty,
i.e., inverse properties, cardinality constraints or oneOf.
