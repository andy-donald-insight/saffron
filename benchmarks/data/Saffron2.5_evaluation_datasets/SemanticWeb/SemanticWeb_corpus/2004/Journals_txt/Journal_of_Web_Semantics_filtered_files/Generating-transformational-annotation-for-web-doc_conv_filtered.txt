Web Semantics: Science, Services and Agents

on the World Wide Web 2 (2004) 118

Generating transformational annotation for web document

adaptation: tool support and empirical evaluation
Masahiro Horia,

, Kouichi Onob, Mari Abeb,c, Teruo Koyanagib

a Faculty of Informatics, Kansai University, 2-1-1 Ryozenji-cho, Takatsuki-shi, Osaka 569-1095, Japan
b IBM Tokyo Research Laboratory, 1623-14 Shimotsuruma, Yamato-shi, Kanagawa 242-8502, Japan

c Graduate School of Science and Technology, Keio University, 3-14-1 Hiyoshi, Kohoku-ku, Yokohama 223-8522, Japan

Received 3 September 2003; received in revised form 12 July 2004; accepted 11 August 2004

Abstract

Web annotation is crucial for providing machine-understandable descriptions of Web resources, and has a number of applications such as discovery, qualification, and adaptation of Web documents. While annotations are often embedded into a Web
document, annotations can be associated externally by means of addressing expressions represented with the XPath language.
However, creation of external annotation solely with a conventional editor is not easy because annotation authoring involves the
maintenance and elaboration of addressing expressions as well as annotation contents. In addition, there has been little empirical
study of robust pointing by XPath expressions, in spite of the increasing prevalence of the XPath language for use in emerging
content adaptation systems. This paper proposes a classification of annotation tool design, taking account of differences in
authoring methods and roles of annotation. On the basis of the classification, tools for generating external annotations are briefly
explained along with applications of Web document adaptation for small-screen devices and portal site development. Robustness
of the addressing expressions is then investigated, and practical implications to the reliable use of external annotation are drawn
from empirical evaluation with evolving real-life Web documents.
 2004 Elsevier B.V. All rights reserved.

Keywords: External annotation; Document adaptation; Annotation tool; XPath; Robust pointing

1. Introduction

An annotation is a remark attached to a particular
portion of a document, and covers a broad range in


Corresponding author. Tel.: +81 72690 2415;

fax: +81 72690 2491.

E-mail addresses: horim@res.kutc.kansai-u.ac.jp (M. Hori),
onono@jp.ibm.com (K. Ono), maria@jp.ibm.com (M. Abe),
teruok@jp.ibm.com (T. Koyanagi).

1570-8268/$  see front matter  2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2004.08.001

the literature. Forms of annotations can be characterized by the dimensions; whether formal or informal,
and whether tacit or explicit [28]. Annotation that allows structural specification resides at the most formal and explicit extreme. Web annotation is crucial for
providing not only human-readable remarks but also
machine-understandable descriptions, and has a number of applications such as discovery, qualification, and
adaptation of Web documents [23].

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

As more and more Web-enabled personal devices
are becoming available for connecting to the Internet,
the same Web documents need to be rendered differently on different client devices. Adaptation of Web
document to delivery context is thus crucial for transparent Web access, which may depend on client capa-
bilities, network connectivity, or user preferences [9].
The long-term goal of our research is to establish technologies of adapting Web documents suitable for delivery context. The document adaptation or customization
requires annotation that indicates the ways of modifying the document at hand because Web documents are
usually created without considering such adaptation,
and are not provided with any additional information
or hint for the adaptation.

Annotations can be embedded into a Web document
as inline annotations, which are often created as extra attributes of document elements. Existing HTML
browsers ignore unknown attributes added to HTML
elements, without being bothered by the proprietary
inline annotations. Because of this simplicity, inline
annotation has been adopted as a way of associating
annotation with HTML documents [12,15,27,32]. An
advantage of the inline approach is the ease of annotation maintenance without the bookkeeping task of associating annotations with their target document. The
inline approach, however, requires annotation authors
or annotators to have document ownership because annotated documents need to be modified whenever inline
annotations are created or revised.

On the other hand, the external annotation approach
[16,17] does not suffer from these issues related to document ownership. In addition, clear distinction between
content and annotation is desirable with regard to the
design guideline that content should be separated from
presentation. Therefore, it is assumed in this study that
annotation is maintained separately from a target doc-
ument, and exploited dynamically at runtime by a document adaptation engine. It is important to note that an
external annotation may point to portions of different
Web documents, if it makes sense to apply the annotation to documents with the same document fragment.
External annotation approach thus provides a promising way of facilitating the sharing and reuse of metadata
for Web document repurposing [19].

An external annotation consists of two items: annotation content and an addressing expression. In partic-
ular, the addressing expressions are represented with

the open standard XPath language [36], which allows
pointing to arbitrary nodes in the document object
model (DOM) [10]. Besides the XPath language, there
is another open standard addressing language called
XPointer [37]. The XPointer language, which is an
extension of the XPath, allows finer-grained pointing
to substrings in character data and flexible pointing
to multiple DOM-tree fragments. Regardless of the
full-featured expressive power of the XPointer lan-
guage, external annotations in this study are used for
the node-level adaptation of Web documents. There-
fore, we adopted the XPath language as a scheme of
addressing expressions in this paper.

When annotations are attached simply as commentary to a target document, browser-based annotation
tools are desirable even if the annotation is externally
maintained. In the case of annotation for Web document adaptation, an addressing expression indicates a
part of the document to be customized, and an annotation content specifies how the indicated portion should
be modified. Therefore, creation of such annotation for
document customization is not easy solely with a conventional editor for commentary annotations, and it is
important to provide an advanced tool support for annotations for Web document adaptation.

In addition to the issues related to the tool sup-
port, robustness of the addressing expressions is crucial
for the use of external annotation. Since Web documents may change over time, it is not always obvious
what kinds of addressing expression keep pointing to
the same target element regardless of the document
changes. It was reported that a key complaint in the
use of electronic annotation was the situation in which
an annotation cannot point any portion of a target document [5]. This is an issue related to robust positioning,
which has been investigated in a couple of empirical
studies [31,4]. However, there has been little study of
robust pointing by XPath expressions, in spite of the
increasing prevalence of the XPath language not only
for use with XSLT [38], but also in emerging content
adaptation systems [17,34,29,3].

The objective of this study is to propose a classification of annotation tools that generate annotations for
Web document adaptation, and to draw implications to
the reliable use of external annotation on the basis of
empirical evaluation with evolving real-life Web doc-
uments. In the next section, we clarify the different
roles of annotations for assertion and transformation,

and then introduce variations in annotation tool design
with distinction of two types of authoring methods:
annotation by selection and by example. Section 3 explains a page-clipping annotation language and tools
for generating the clipping annotation, along with applications of the annotation to document clipping for
small-screen devices and portal site development. In
Section 4, we investigate the robustness of addressing
expressions taking account of the changes in real-life
Web documents. In particular, it was investigated to
what extent the XPath expressions generated by the
tools continued to point to the same nodes in the documents updated during the observation period of 1 year
and 6 months. Finally, we discuss the advantages and
limitations of the XPath expressions for practical use
in external annotation.

2. Variations in annotation tool design

An annotation in general declares properties that
qualify a particular portion of a target document. In
some cases, however, annotations may indicate structural changes for the annotated portion of a target doc-
ument. In order to clarify the distinction of these two
roles, the former is called assertional annotation, while
the latter transformational annotation [18]. Note that
this distinction is not exclusive because every annotation is intrinsically an assertion.

It is simple for annotators to select a location to
be annotated and provide annotation content. This
is an approach what we call annotation by selec-
tion, and is adopted by existing annotation tools
[1,6,17,21,29,33,14]. In contrast to assertional annotation (such as Dublin Core Metadata [8]), transformational annotation has been used for Web content adapta-
tion, in which structural changes of a target document
are needed [17,29,34,38]. In the case of transformational annotation, it is not easy for an annotator to indicate the ways of modifications declaratively as assertional annotation. However, it is straightforward for an
annotator to modify a target document toward the desired result of the customization, and transformational
annotation can be generated on the basis of an example
of document customization. This is a basic idea behind
an approach what we call annotation by example, which
was originally proposed in our previous work on the automatic generation of XSLT scripts by example [22,30].

Table 1
Variations in annotation tools

Roles of annotation

Authoring methods

By selection

By example

Assertion
Transformation

(a)
(b)

N/A
(c)

According to the above-mentioned distinctions of
annotation roles and annotation authoring methods,
Table 1 summarizes variations in annotation tools. Annotators can select a portion of document to be annotated and declare properties on the selected portion
as assertional annotation. This type of annotation tool
corresponds to the assertional annotation by selection
(Table 1(a)), and most of the existing annotation tools
fall into this category. Even when annotations are used
for structural changes of a target document, it is possible for an annotator to create transformational annotations by selecting portions to be changed and declare
instructions of transformations as annotations. This
type of annotation tool is classified as the transformational annotation by selection (Table 1(b)).

In order to create transformational annotations, annotation by example would be easier for annotators because the annotators can work with a concrete example
and create a desired result interactively with the ex-
ample. In particular, the example-based method allows
annotators to generate transformational annotations on
the basis of annotators editing operations conducted
to come up with a desired result. This type of annotation tool falls into the category of transformational annotation by example (Table 1(c)). The example-based
method is particularly useful for the transformational
annotations, and would not make sense for assertional
annotations because it is not intuitive for annotators to
indicate assertional annotations as results of structural
changes of a target document.

The core part of the tool configuration, which is
common to all the three variations, is independent of
any particular views and editors, and consists of two
document object models [10]: one for a target document
and another for an annotation document. It is assumed
here that the creation of an annotation document is a
primary task of annotators, and the annotators are not
allowed to modify a target document. The assertional
annotation by selection is the most typical and provides a comprehensive way of annotation. The details

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

of this type of annotation tool are reported in another
article [1,20]. According to our interests in Web document adaptation, this paper focuses on the transformational annotation, and deals with the two approaches to
generating annotation by selection (Table 1(b)) and by
example (Table 1(c)).

2.1. Transformational annotation by selection

Fig. 1 depicts a configuration for the transformational annotation by selection. This type of annotation
tool relies on a target document viewer because portions of a target document can only be selected without
any modification. With this type of annotation tool, first
an annotator opens a target document to be customized.
The annotator then selects portions of the target document by using a document viewer (Fig. 1(a)), and indicates how each of the selected portion to be modified
(e.g., to be removed and enlarged). The ways of mod-
ification, namely, annotation instructions are usually
specified by using a pup-up menu or a dialog window,
but may be specified implicitly with a default operation
mode as given later in the annotation tool for portal site
development. Transformational annotation can then be
generated (Fig. 1(b)) on the basis of the selected portions of a target document and annotation instructions.

2.2. Transformational annotation by example

Transformational annotation languages such as
XSLT are more like programming languages, and it is
not necessarily easy for an annotator to create transformational annotations merely by using a conventional
editor for Web documents. However, if a person knows
how to perform a task to be executed by a computer,

Fig. 1. Tool configuration for
selection.

transformational annotation by

Fig. 2. Tool configuration for transformational annotation by exam-
ple.

perhaps the persons knowledge can somehow be exploited for the creation of a program to perform the task.
This is the idea behind the programming by example
[24]. Programming by example is a natural approach
to generating transformational annotation for page designers or novice programmers because they need only
work with examples of how to transform a document
at hand, and are given with generated annotations that
can replicate the same transformation.

A configuration of the example-based annotation
tool is depicted in Fig. 2. This type of annotation tool
relies on a target document editor rather than a viewer in
contrast to the annotation by selection (see Fig. 1). With
this type of annotation tool, first an annotator opens
a target document to be customized (e.g., an HTML
page). The annotator then edits the document by using the full capabilities of a WYSIWYG authoring tool
(Fig. 2(a)). Although the annotators editing actions are
recorded into an operation history (Fig. 2(b)), the annotator does not have to care about the recording process
behind the scenes. When the editing is finished, the annotation generator creates transformational annotation
for the document customization (Fig. 2(c)), which can
be used by a runtime engine (e.g., XSLT processor) to
replicate the transformation from the initial document
to the customized document.

3. Annotation tools for web page clipping

Web pages for e-commerce, for example, contain a
lot of information such as product descriptions, product
images, and numerous links to other areas of the site.
Even if the pages were created for the desktop com-
puters, it would be useful to deliver portions of those
pages for users to access through a Web-enabled phone

of a request from a client, a Web document is retrieved
from a content server. Taking account of the capabilities of the client specified in the HTTP request header,
a transcoding proxy selects one or more transcoding
modules. When a selected transcoding module requires
an annotation document, an annotation file is also retrieved from a content server, which may or may not
be the same server that retrieved the Web document.
The transcoding module may simply return the original document, if a client agent has the rendering capabilities compatible with ordinary desktop computers
(Fig. 3(a)). Alternatively, the original document may be
returned with modification, so that the original content
can fit into a small-screen device (Fig. 3(b)). The decisions about the document adaptation are made taking
account of the client capabilities specified in the HTTP
request header.

An annotation-based page-clipping engine [34] provides a way of realizing Web document adaptation. At
content delivery time, the page-clipping engine may
modify the original document with reference to pageclipping annotations and client profiles sent over HTTP.
The main idea in the page-clipping annotation language
is the notion of a clipping state. By using <keep> and
<remove> elements in the annotation descriptions,
an annotator can specify the clipping state to indicate

Fig. 3. Overview of annotation-based Web document adaptation.

rather than a desktop browser. In such a case, the images
and nested HTML tables prepared for a nicely laid out
page are a hindrance rather than help. The sheer amount
of information becomes unwieldy in the small display,
and potentially expensive depending on the users wireless service. In this section, annotation tools for transformational annotation are explained along with applications to page clipping for small-screen devices and
portal site development.

3.1. Page clipping for small-screen devices

An overview of an annotation-based document
adaptation process is depicted in Fig. 3. Upon receipt

Fig. 4. Example of Web document clipping.

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

whether the content being processed should be preserved or removed. For example, a corporate Web page
and its clipped result are shown in Fig. 4. The clipped
page (Fig. 4(b)) preserves areas for the company logo
image, news headlines, and menus in the header and
footer, and all the other portions are removed from
the original page. In the clipped page, the layout of
an HTML table for the header is changed by merging
the first and second rows in the first column and by
deleting the second and third column in the first row.
In addition, width attributes of the header and footer
tables are changed from an absolute pixel value of 760
to a percentage value of 100%, so that the tables can be
adjusted with the available horizontal space of smallscreen devices.

Fig. 5 shows portions of an annotation document
that realizes the page clipping illustrated in Fig. 4.
The <description> element prescribes a unit of
an annotation statement in the annotation language.
The target attribute is set to an XPath expression,
and identifies the node on which the annotation will
be applied, and the take-effect attribute indicates
whether the annotation is applied before or after the target node. By specifying the value of target attribute
as /html [1] /body [1]/*[1] (Fig. 5(a)), the
clipping state is activated after the first element of the
document. The <keep> element in Fig. 5(a) indicates
that all the document elements encountered are pre-
served, until otherwise instructed by another annotation
statement. The clipping state is changed to remove
just before the first <script> element (Fig. 5(b)),
and changed back to keep after the <script> element (Fig. 5(c)). As a result, the first script element
indicated by /html [1] /body [1] /script
[1] is removed while preserving elements just before
and after the removed element.

Since HTML tables can often be complex elements to clip, the annotation language provides specialpurpose elements to make table clipping easier. The
<row> and <column> elements allow user to clip
rows and columns without relying on complicated
XPath expressions. The table-clipping elements are
used in the description shown in Fig. 5(d). This description sets the clipping state to keep just before
the first table element, and also changes the value of
width attribute to 100% by using the <insertat-
tribute> element. The name attribute of <inser-
tattribute> can be specified with an arbitrary at-

Table 2
Vocabulary for page-clipping annotation

Annotation element

Description

<description>

<remove>
<keep>
<table>

<column>
<row>
<field>
<option>
<insertattribute>

<inserthtml>
<replace>

<replacewithhtml>

<setpreference>

<splitpoint>

Prescribe a unit of annotation
instructions
Remove associated HTML element(s)
Keep associated HTML element(s)
Effect overall table, in particular the
heading
Remove a complete table column
Remove a complete table row
Modify fields within a form
Specify a selectable option
Allow insertion of attributes into an
HTML element
Allow insertion of an HTML element
Replace an associated content with another content
Replace an associated HTML tag with
another HTML tag
Set a preference parameter for
transcoding
Indicate a preferred point of document
splitting

tribute name available in a target document. Elements
for the clipping annotation [35] are listed in Table 2.

The description element for the table clipping in
Fig. 5(d) declares that the first column and the first row
are discarded, while all the other columns and rows in
the table are preserved. Note that the wildcard character to indicate multiple columns (index=*). If a
wildcard is specified, all rows (or columns) will be
affected, except for those specifically indicated by a
separate <row> (or <column>) element. This tableclipping description thus indicates the removal of all
rows and columns other than the cell for the header
menu that includes menu items for Home, Products
& Services, and so on. However, this instruction in
itself does not preserve the company logo image appears in the upper left corner of Fig. 4(a). Therefore,
the description for inserting a cell for the logo image
is needed as shown in Fig. 5(e). The CDATA section
included in the <inserthtml> element substitutes
the table cell for the logo.

However, the pair of the two descriptions (Fig. 5(d)
and (e)) would not be easy for annotators to come up
with. The example-based annotation tool explained below significantly assists annotators to create nontrivial
clipping annotations.

Fig. 5. Page-clipping annotation generated by the example-based annotation tool.

Fig. 6 shows an example-based annotation tool,
which is developed as a plug-in module for an open
tool integration platform [11]. This annotation tool allows an annotator to generate page-clipping annotations on the basis of the annotators editing operations
conducted with a WYSIWYG HTML editor (Fig. 6(a)).
Fig. 6(b) shows a generated external annotation, which
is an XML document in the page-clipping annotation
language. The look and feel of this WYSIWYG editor
is exactly the same as in the original HTML editor, ex-

cept for the small views for the generated annotations
and operation history. A recording button (Fig. 6(d))
is used to start and stop recording a users operations.
While the toggle button remains depressed, the users
operations are recorded. When the button returns to its
normal state, the recording stops. An annotation document for the page clipping is created from the recorded
operations by pressing the button to create annotation
(Fig. 6(c)). The example-based annotation tool introduced above has further enhanced for productization,

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

Fig. 6. Example-based annotation tool integrated with a WYSIWYG HTML editor.

and is included in a software product for the multidevice authoring [13].

The page-clipping transformations depicted in
Fig. 4 include removal of HTML elements and modification of element attribute values. All of the transformations can be done easily by using the HTML editor
in a WYSIWYG manner. For example, a table row can
be removed by selecting a cell in the row to be deleted,
and then choosing the menu item Delete Row from
a popup menu (Fig. 6) that appears after clicking the
right mouse button. The width attribute of the table
can also be changed from a dialog window for the table attribute settings. Note that the clipping annotations
for the transformation depicted in Fig. 4 can be

generated1 automatically as results of WYSIWYG
editing by using this example-based annotation tool.

All the editing operations actually modify a target
document by means of DOM manipulation operations,
and can be converted to transformational annotations.
However, there are exceptions that cannot be converted
from DOM manipulation operations on a target docu-
ment, but must be specified directly as a part of an annotation document. A typical example is a feature that
makes a clipping annotation conditionally applicable

1 Comment elements (<! - - . . . - ->) in Figs. 5 and 10 are not included in the generated annotation documents, but added afterwards
for the purpose of explanation.

Fig. 7. Examples of conditional annotations.

depending on profile of a client agent. As shown in
Fig. 7, by adding a condition attribute to a <de-
scription> element, the clipping annotation could
be applied only if the condition is true [35]. In this
example, the first script element indicated by /html
[1]/body [1]/script [1] is removed2 only when a
substring CNF is included as a device type in the
HTTP header. The asterisk (*) here is a wildcard
expression for the string matching. In addition, more
complex conditions can be given by using conjunctive
and/or disjunctive expression.

When an annotator creates a conditional annotation,
first the annotator needs to create a clipping annotation
using the example-based annotation tool, and then add
the condition attribute and its value by using a conventional annotation tool for assertional annotation by
selection (Table 1(a)). Currently, the example-based
approach to generating transformational annotation is
not nicely integrated with the support for creating additional assertional annotation. This is a remaining work
to be done in the near future.

3.2. Page clipping for portal site development

Annotation-based page clipping is a useful technique for the adaptation of existing HTML documents
to small-screen devices, but the advantages are not limited to device adaptation. Another promising application of the page clipping technology is the use in Web
portals. Web portals are becoming an increasingly popular technology, since it can provide a single point of
comprehensive, integrated access to both Web data and

2 <script> elements should be deleted from a clipped page, if
a client browser does not support the script language. However, such
decisions are often conditional depending on user agent profile.

Fig. 8. Creation of a portal page with annotation-based clipping port-
let.

applications. However, most of the Web data or applications are originally provided for the presentation on
a desktop browser, and would be too spacious to fit into
a small area in a portal page.

Page clipping is thus useful for Web pages that are
aggregated into a portal site. Fig. 8 illustrates the process of creating a portal page with an annotation-based
clipping portlet. Portlets are specialized servlets that
plug into and run in portals, and allow to generate dynamic contents. When a portal server receives an HTTP
request, the server dispatches the request to each portlet aggregated in the page, and collects the results into
a portal page to be returned.

Fig. 9(a) shows a screen shot of a selection-based
annotation tool for the clipping portlet. This annotation tool allows an annotator to select portions of
the original page to be preserved in the portal page
(cf., Fig. 1(a)), and the annotation generator creates
page-clipping annotation from the selected nodes (cf.,
Fig. 1(b)). A portal page created including a clipped
page is shown in Fig. 9(b).

Fig. 10 shows an annotation document generated
according to the selection on the annotation tool in
Fig. 9(a). In addition to the statement for setting a default clipping state as remove (Fig. 10(a)), the generated annotation includes the instructions for preserving

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

Fig. 9. Selection-based annotation tool for Web clipping portlet.

an anchor element for the banner image (Fig. 10(b)),
as well as a table for news headlines (Fig. 10(c)). This
clipping annotation simply indicates the portions to be
kept, without any advanced instructions such as table
clipping and attribute value change. However, as mentioned below, such simple annotations were useful in
practice for the development of a large portal site that
aggregates thousands of existing Web pages.

The selection-based approach to annotation generation was adopted for a software product of an annotation tool for a portal server [7], and used in a number of
real cases including a supplier portal in an automotive
company and a retail distribution portal in an insurance company. In the case of a supplier portal, the automotive company extensively used the page-clipping
portlet with the annotation tool solely for the simple
<keep> and <remove> clipping operations. The primary reason for the customers choice was just the
simplicity of the authoring process without advanced
page-clipping constructs. Since the automotive company needs to aggregate six thousands of supplier pages
into the portal site, it was not practical to create sophisticated clipping annotations for page by page, and it was
reasonable to provide just simple clipping capability to
remove headers and side menus from the original pages
created for desktop browsers.

3.3. Underlying model for generating clipping
annotations

A fundamental feature common to the annotation
tools given in Section 2 is that a target document is represented internally with a document object model [10].
The document object model defines a logical structure for documents, and provides ways of accessing
and manipulating XML or well-formed HTML doc-
uments. The DOM represents a document as a hierarchy of node objects, which may be associated with
attributes. DOM trees are changed by node insertion
(insertBefore, replaceChild, appendChild), node removal (removeChild), or attribute change (setAttribute,
removeAttribute).

Since the DOM provides standardized, generalpurpose operations for the transformation of DOM
trees, it is reasonable to capture annotators action conducted on a target document as a sequence of DOM
manipulation operations rather than as primitive op-
erations, such as a sequence of keystrokes and mouse
clicks. Therefore, along with the notion of current node,
which may be either a leaf node or a subtree, we adopted
a model of annotators editing actions consisting of the
four basic operations: insert to add a subtree, remove
to delete a subtree, modify to change an attribute of a

Fig. 10. Page-clipping annotation generated by the selection-based annotation tool.

node, and copy to replicate a subtree. The rationale behind this model of WYSIWYG editing is reported in
our previous work on the XSLT stylesheet generation
tool [22].

In the example-based annotation tool, an annotator
actually modifies a target document using a WYSIWYG HTML editor. Since the WYSIWYG editing for
page clipping is typically done by removing unnecessary portion of the original document, the clipping
state of a generated annotation document begins with
keep as shown in Fig. 5(a). Individual annotation instructions are then created by examining a sequence
of the annotators editing operations recorded behind
the WYSIWYG editor. Further details of the annotation generation procedure are given in another article
[18]. In contrast, a target document is not modified at
all in the selection-based approach. Regions selected
by an annotator are preserved, and all the other uns-

elected portions are removed. Annotation documents
generated by the selection-based approach thus begin
with the remove clipping state as shown in Fig. 10(a).
The selection-based approach is limited in the kinds
of annotation constructs to be generated as compared
with the example-based approach because the expressiveness of the selection on a document viewer is far
more limited than the full editing capability on a document editor. In this paper, we deal with a particular
annotation language for page clipping, consisting of
the application-specific constructs (Table 2). However,
it is important to note that capabilities of the annotation generator are prescribed in terms of the generic
model of document editing. On the basis of the document model, the annotation generator is realized as a
plug-in module for the tool integration platform, and
can be customized for generating different transformational annotation languages (e.g., XSLT).

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

4. Robustness of addressing expressions

This section presents an empirical study that investigates the strength and limitation of a class of
XPath expressions generated by the selection-based
and example-based annotation tools explained in the
previous section. The evaluation method here follows
the procedure proposed in our preliminary work [2]
on the evaluation of robust pointing by the XPath lan-
guage. Although the previous study was done in a
shorter period (120 days), the empirical study presented in this section was conducted during the period of about 1 year and 6 months (540 days) in pursuit of the assessment in more realistic situations. Note
that the number of reference pages used in this study
was small compared with the entire population of Web
pages on the globe. However, besides the sample size,
the observation period is another important factor to
be considered when evaluating the robustness of external annotations over temporal changes in Web docu-
ments.

4.1. Single-node pointing expression

Annotation generators in the annotation tools explained above automatically generate addressing ex-
pressions. The type of XPath expression generated by
the annotation tools is what we call child position sequence (ChildPosSeq) expressions. A ChildPosSeq expression follows the hierarchy of DOM tree from the
root along the child axis, and each location step is given
with a position number predicate. An example of the
ChildPosSeq expression is /html [1] /body [1] /ul
[2] /li [3], which selects the third li of the second
ul of the first body of the first html element in the
document.

A ChildPosSeq expression allows to point to an arbitrary node in a document, and always selects at most
one node. This is a feature desirable for the automatic
generation of XPath expressions, because an expression that points to an arbitrary focal node can be composed with a particular axis without human interven-
tion. We call this type of XPath expression single-node
pointing expression. Among the 13 axes (such as child,
descendant, following, and preceding) in the XPath lan-
guage, there exist only two axes, namely, child and descendant that can constitute single-node pointing expressions using only one axis.

In this paper,

the single-node pointing expressions with a descendant axis are called descendant position (DescendantPos) expressions. An example of the DescendantPos expression is /descen-
dant::table[5], which selects the fifth table element in document order3. DescendantPos expressions
are always represented with a single location step,
and simpler than ChildPosSeq expressions. However,
pointing by a DescendantPos expression could be readily influenced by the addition or deletion of an element
whose tag name is the same as the one used in the ex-
pression. For example, /descendant::table[5]
no longer points to the fifth table originally intended by
an annotator, if the second table is deleted from the doc-
ument. Therefore, among the two kinds of single-node
pointing expressions, we adopted only the ChildPosSeq
expressions in the annotation tools, and did not use DescendantPos expressions at all. The main objective of
this empirical study is to assess the robustness of ChildPosSeq expressions as compared with DescendantPos
expressions.

It is possible for ChildPosSeq expressions to be generalized by leaving out a position number predicate. For
example, when all the third list item of every unordered
list under an HTML body element are customized in
the same manner, it would be reasonable to come up
with a single annotation instruction that covers all the
occurrences of the list item modification. This is an
issue related to guessing users intension in the literature of programming by example [26], and we reported
preliminary investigation in another article [30]. The
generalization of annotation is revealed essentially in
an addressing expression (e.g., /html [1] /body [1]
/ul/li [3]) rather than annotation content. However,
the generalization of addressing expressions is the issue beyond the scope of this paper, and is not dealt with
in this empirical evaluation.

4.2. Evaluation method

Table 3 shows URIs and statistics of the four reference pages used for the evaluation. The pages A and B
are a corporate top page and a product page of the same
company. The pages C and D are, respectively, the top

3 Document order orders element nodes in order of the occurrence

of their start-tag [36].

Table 3
Basic data of the observed HTML pages

Page

Number of nodes per page [ave. (max, min)]

Depth of document tree [ave. (max, min)]

http://www.ibm.com/
http://www.ibm.com/products/
http://www.public.wsj.com/
http://www.java.sun.com/

392.0 (441, 348)
708.7 (750, 623)
952.4 (1333, 433)
908.0 (1311, 325)

21.9 (21, 20)
27.3 (30, 20)
22.0 (24, 21)
21.6 (29, 13)

The number of sample pages is 540 for each reference page with the same URI. Note that a current URI of the page C is http://www.online.wsj.com/.

Fig. 11. Process of node ID insertion.

pages of a news media company and a computer com-
pany. These pages have been saved each day during the
period of 1 year and 6 months, and 540 sample pages
are collected for each reference page.

In order to make sure that an XPath expression actually points to the same node in a reference page, it
is necessary to know the node-to-node mappings from
the reference page to sample pages. For the purpose
of this empirical study, an ID attribute was added to
every DOM node of the reference and sample pages.
Since the most of existing HTML pages are not well-
formed, nodes in HTML pages may not be pointed to
appropriately by XPath expressions. Therefore, it is assumed here that both the reference and sample pages
are parsed by an HTML parser in advance, and converted to DOM trees before node IDs are inserted.

Fig. 11 illustrates the process of node ID insertion,
which consists of the following two steps. The first step
is to add unique identifiers as values of uid attribute
(e.g., uid = N27) to every node in the reference page
(Fig. 11(a)). Note that comment and text nodes are excluded from the ID insertion because an attribute cannot
be added to those nodes. The second step consists of
differencing and patching (Fig. 11(b)). The DOM-tree

differences4 are calculated between a reference page
and sample pages with the same URI. A difference file,
which is an output of the tree difference, consists of a
sequence of edit operations that transform a reference
page into a sample page. The difference files are then
applied to the reference page with IDs. Finally, as a
result of the patching, we can obtain a set of sample
pages with unique identifiers.

Fig. 12 shows the changes in the numbers of nodes
with IDs for each sample page during the entire observation period of 540 days. According to the changes in
Web pages over time, some nodes are inserted into or
deleted from the documents. The newly inserted nodes
do not have any ID attribute because they cannot be
mapped from any node in the reference page. In ad-
dition, like the most tree differencing merging tools,
the algorithm [25] used for this evaluation regards an
attribute-value change as deletion of the modified node
followed by insertion of the same node with updated
attribute value. This means that a node ID disappears

4 The 3DM [25] was used as a tool for document differencing and

merging.

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

Fig. 12. Changes in the number of nodes with IDs during the entire observation period of 540 days.

when a node is updated as result of an attribute-value
change.

As shown in Fig. 12, there is a sudden decrease in
the number of nodes with IDs for the pages A and B,
respectively, on the 59th and 62nd days due to the small
style changes. In addition, since site design has been
changed for each of the pages C and D, the numbers of
nodes with IDs were suddenly decreased in the page C
on the 229th day and the page D on the 365th day. The
numbers in the page D tentatively decreased during
the 10 days from the 271st day. This is because the
site design was temporally changed due to the annual
developer conference5 held by that company.

The number of nodes with IDs decreases as a result
of the deletion, insertion, and update of DOM nodes.
Note here that the differencing algorithm was always
applied to obtain node-to-node mappings from a reference page to sample pages. Therefore, the difference
from the reference page would not necessarily increase
monotonically, but may be reduced later if the page
were modified again to be closer to the reference page.
This is why the number of nodes with IDs increases at
some points in Fig. 12.

Every DOM node with a unique identifier in a reference page is regarded as a reference node. For each
reference node, ChildPosSeq and DescendantPos expressions are created, so that they can point to a cor-

5 The JavaOne Conference.

responding reference node. These XPath expressions
constitute a test set, and each expression is then applied to sample pages with IDs. Pointing by an XPath
expression is regarded as correct in a sample page, if
the expression points to a node with the same ID as
the reference node, and does not point to any other
nodes in the sample page. Although an XPath expression may point to multiple nodes in a target document,
this investigation only deals with single-node pointing
expressions. Therefore, correct pointing designates the
only one node with the same ID.

4.3. Empirical results and discussions

Fig. 13 shows the percentage of correct pointing for
each type of expression during the entire observation
period. In the figure, ChildPosSeq scores higher percentage than DescendantPos. Especially for the pages
C and D, the percentages of correct pointing by ChildPosSeq is more than 70%, while the ratio by DescendantPos is less than 50%. As mentioned earlier, the
DescendantPos expressions are likely to be influenced
by the addition and deletion of elements with the same
tag name as the initial target node. Therefore, the larger
the number of nodes included in a document, the more
difficult for a DescendantPos to keep pointing to the initially pointed node. Since the pages C and D actually
consists of more than 900 nodes (see Table 3), which
is largely surpassing the numbers of node in the pages

Fig. 13. Percentage of correct pointing during the entire observation
period of 540 days.

A and B, it is probable for DescendantPos expressions
to fail to point to target nodes as compared with the
ChildPosSeq expressions for the pages C and D.

As for the pages A and B in Fig. 13, the percentages
of correct pointing are less than 50% for both ChildPosSeq and DescendantPos. This result can be further
elaborated with regard to the ratio of node ID inser-
tion. As shown in Fig. 12, the numbers of nodes with
IDs suddenly decreased shortly after the 50th day for
the pages A and B. Therefore, if we consider the period from the beginning until the day before the sharp
decline, it is possible to compare the two types of expressions without the influence of the decreased ratio
of ID insertion. In order to eliminate a period of observation with a threshold independent of individual page
contents, we used a ratio of nodes with IDs to all the
nodes within the same page.

Fig. 14 shows the percentage of correct pointing for
each type of expression during the period beginning

Fig. 14. Percentage of correct pointing during the period while the
ratio of nodes IDs is greater than 0.7.

Fig. 15. Changes in the percentage of nodes with IDs during the first
100 days.

from the 1st day while the percentage of nodes with
IDs is greater than 70%. The eliminated observation
periods begin with the 1st day and continue for 58 days
in the page A, 61 days in the page B, 121 days in the
page C, and 3 days in the page D. A remarkable feature
in Fig. 14 is that ChildPosSeq expressions scored fairly
high percentage of correct pointing, in particular it was
99.9%, 93.9%, and 96.4%, respectively for the pages
A, B, and C. In the page D, however, only 79% of nodes
was correctly pointed by ChildPosSeq expressions, and
the eliminated observation period was only the first 3
days. This situation can be clarified by investigating
the changes in the ratio of node ID insertion at the
beginning of the observation period.

Fig. 15 shows the changes in the percentage of nodes
with IDs during the first 100 days. It can be seen from
the figure that the page D varies frequently from the
beginning, and the percentage of node ID insertion has
been fluctuated around the 70% immediately after the
1st day. Therefore, if the reference page is changed to
one of the following pages, the differences between
the reference page and sample pages could be reduced,
and the ratio of node ID insertion would increase ac-
cordingly. It is then expected that the ratio of correct
pointing by ChildPosSeq will be improved for the page
D due to the increase in the number of nodes with IDs.
Note here that the ratio of node ID insertion is a
kind of similarity measure between a sample page and
its reference page because node IDs are inserted into a
sample page on the basis of a difference file consisting
of operations to transform from a reference page to the
sample page (see Fig. 11). The important point here
is that the robustness of the ChildPosSeq expressions

M. Hori et al. / Web Semantics: Science, Services and Agents on the World Wide Web 2 (2004) 118

lion (1,280,880 nodes) counting all the HTML elements included in the four reference pages and their
sample pages throughout the observation period of
540 days. In addition to the two types of single-node
pointing expressions (ChildPosSeq and Descendant-
Pos), Fig. 16 includes the other type of XPath expression what we call ID value match (IDValueMatch). An
IDValueMatch expression points to a target node with
reference to an ID attribute. An example of the IDValueMatch expression is //*[@uid=N35], where
the uid is the name of an ID attribute created during
the node ID insertion process (Fig. 11). Although the
attribute name uid might be accidentally duplicated in
some sample pages, no duplication was found within
the pages examined for this study.

One of the notable feature in Fig. 16 is that the large
number of the exclusive pointing errors occurred in
the DescendantPos expressions. An exclusive pointing error means that an XPath expression points to a
node or a set of nodes that does not include the target node at all. A practical implication of this result
is as follows. When a DescendantPos expression is
used, we cannot distinguish if the pointing status is
either exact or exclusive simply from the situation of
the expression pointing a single node. Therefore, an
annotation instruction associated with a DescendantPos expression may be applied to a node different
from the one assumed when the annotation was initially created. The large amount of the exclusive pointing in the DescendantPos expressions thus may produce unexpected results of document adaptation. This
is a risk of relying on the DescendantPos expressions
in the external annotation for Web document adapta-
tion.

On the other hand, IDValueMatch expressions rely
on unique identifiers added to each node, and it is obvious that the IDValueMatch would work for the static
Web documents. However, as shown in Fig. 16, the
IDValueMatch expressions include a large number of
nonexistent pointing, which is more than 50% of the
total number of tested nodes. This means the amount
of dynamic changes in real-life is substantial and not so
small. Although we inserted the node IDs afterwards
for this empirical study, it would be possible to reduce the number of nonexistent pointing if node IDs
are inserted in parallel with the creation of the original
document because the document creator can adjust the
node identity in a more precise manner than DOM-tree

Fig. 16. Number of tested nodes with distinction of pointing status.

can be further improved if we consider to rehash the
XPath expressions when the distance between a sample
page at hand and its reference page exceeds a certain
threshold value. There exists a research on a reattachment algorithm that allows pointing expressions to be
adjusted dynamically in response to the changes in a
target document [31]. However, existing studies on robust pointing, including the work on the reattachment
algorithm, use a proprietary addressing schema rather
than the open standard XPath language. The empirical results of this study will be the first step toward the
further elaboration of addressing by XPath expressions
with dynamic adjustment.

A correctly pointing expression designates the only
node with the same ID as the one originally pointed
to in a reference page. Here we call this pointing exact
pointing. When an XPath expression does not correctly
point to a target node, the ways of incorrect pointing can
be categorized into three types: nonexistent, inclusive,
and exclusive. Nonexistent pointing is when an XPath
expression points to nothing. Inclusive pointing is when
an expression points to a node set that includes not only
the target node but also nodes other than the target6.
Exclusive pointing is when an expression points to a
node or a set of nodes that does not include the target
node at all.

Fig. 16 divides the nodes up by pointing status. The
total number of tested nodes was more than a mil-

6 The inclusive pointing does not occur in cases of the single-node

pointing expressions.

difference algorithms. It is still impossible, however, to
avoid insertion of new nodes and deletion of existing
nodes from Web documents in the course of longer life
cycle of the document maintenance and deployment. It
is important to note that this is not the limitation of the
addressing expressions, but an issue of providing additional annotations for the content that was not included
in the original document.

5. Concluding remarks

In this paper, we presented variations in annotation
tool design, and explained the two types of tools that
generate transformational annotation for Web document clipping. Transformational annotations are descriptions of the ways of modifying the document at
hand, which can easily be indicated through annotators
editing actions to obtain the desired result of adapta-
tion. Although the example-based annotation tool is
the most sophisticated approach to creating transformational annotation, it may suffer from difficulties in
inferring the annotators intension behind the editing
process. On the other hand, the selection-based annotation is a simpler approach, and limited in the capabilities of annotation generation. However, it is noteworthy that the simplicity was a real advantage for use in
the development of clipping portlet because it was not
practical to create sophisticated clipping annotations
for several thousands of pages to be aggregated into a
real-life supplier portal.

In addition to the tool support for the external anno-
tation, we investigated the issue of robust pointing by
the two types of single-node pointing XPath expres-
sions. Through the empirical evaluation with evolving real-life Web documents, it was assessed that the
ChildPosSeq expressions adopted for the annotation
tools were highly reliable as compared with the DescendantPos expressions, especially when the period
of estimation was eliminated while the percentage of
nodes with IDs was greater than 70%. Regardless of
the robustness of the ChildPosSeq expressions, it was
observed that frequent changes in the target document
disrupt the reliability of addressing expressions. This
result implies the limitation of static addressing for the
external annotation, and the need for adjusting addressing expressions dynamically taking account of the differences between a target document and its reference

document in which the original addressing expressions
are created.

The empirical study presented in this paper is tightly
bound to the HTML pages investigated, and the sample
size is not enough for statistical validation. However,
this empirical study is an important step toward establishing hypotheses regarding phenomenon that may
hinder the practical use of external annotation that exploits XPath expressions. On the basis of this study, we
are going to further elaborate the work on robust pointing for Web documents in pursuit of the development
of reattachment algorithm for the XPath language.
