Web Semantics: Science, Services and Agents

on the World Wide Web 1 (2004) 377396

HTN planning for Web Service composition using SHOP2

Evren Sirina,

, Bijan Parsiab, Dan Wua, James Hendlera, Dana Naua

a Computer Science Department, University of Maryland, College Park, MD 20742, USA

b MIND Lab, University of Maryland, 8400 Baltimore Avenue, College Park, MD 20742, USA

Received 11 March 2003; received in revised form 29 June 2004; accepted 29 June 2004

Abstract

Automated composition of Web Services can be achieved by using AI planning techniques. Hierarchical Task Network (HTN)
planning is especially well-suited for this task. In this paper, we describe how HTN planning system SHOP2 can be used
with OWL-S Web Service descriptions. We provide a sound and complete algorithm to translate OWL-S service descriptions
to a SHOP2 domain. We prove the correctness of the algorithm by showing the correspondence to the situation calculus
semantics of OWL-S. We implemented a system that plans over sets of OWL-S descriptions using SHOP2 and then executes the
resulting plans over the Web. The system is also capable of executing information-providing Web Services during the planning
process. We discuss the challenges and difficulties of using planning in the information-rich and human-oriented context of
Web Services.
 2004 Elsevier B.V. All rights reserved.

Keywords: Web Services; Web Service composition; OWL-S; HTN planning; SHOP2

1. Introduction

As Web Servicesthat is, programs and devices accessible via standard Web protocolsproliferate, it becomes more difficult to find the specific service that
can perform the task at hand. It becomes even more
difficult when there is no single service capable of performing that task, but there are combinations of ex-


Corresponding author. Tel.: +1 301 405 2696;

fax: +1 301 405 6707.

E-mail addresses: evren@cs.umd.edu (E. Sirin),

bparsia@isr.umd.edu (B. Parsia), dandan@cs.umd.edu (D. Wu),
hendler@cs.umd.edu (J. Hendler), nau@cs.umd.edu (D. Nau).

isting services that could. Sufficiently rich, machinereadable descriptions of Web Services would allow the
creation of novel, compound Web Services with little
or no direct human intervention. Semantic Web lan-
guages, such as the Web Ontology Language (OWL)
[1] or its predecessor DAML + OIL [2], provide the
foundations for such sufficiently rich descriptions.

The OWL-services language [3] (OWL-S),1 is a set
of ontologies for describing the properties and capabilities of Web Services. The OWL-S is designed to
support effective automation of various Web Services

1 The previous version of OWL-S was called DAML-S and was

based on DAML + OIL.

1570-8268/$  see front matter  2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2004.06.005

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

related activities including service discovery, compo-
sition, execution, and monitoring.

For our work, we are motivated by issues related
to automated Web Service composition. The OWL-S
process ontology provides a vocabulary for describing
the composition of Web Services. This ontology uses
an action or process metaphor for describing Web
Service behaviorthat is, primitive and complex actions with preconditions and effects.

Given a representation of services as actions, we
can exploit AI planning techniques for automatic service composition by treating service composition as
a planning problem. Ideally, given a users objective
and a set of Web Services, a planner would find a collection of Web Services requests that achieves the ob-
jective. We believe that HTN planning is especially
promising for this purpose, because the concept of
task decomposition in HTN planning is very similar to the concept of composite process decomposition in OWL-S process ontology. In this paper, we
explore how to use the SHOP2 HTN planning system [4,5] to do automatic composition of OWL-S Web
Services.

In Section 2, we describe a sample scenario for our
research. In Section 3, we give the background knowledge about OWL-S process ontology and SHOP2. In
Section 5, we present our approach for automatic Web
Services composition. In Section 4, we describe why
we think HTN planning is suitable for Web Service
composition. In Section 6, we describe the implemen-
tation. In Section 7, we discuss the challenges and difficulties of using planning for composing Web Services
on Semantic Web. In Section 8, we summarize some
related work. And finally, in Section 9, we conclude
our work and present some future research directions.
Throughout this paper, we use the example we described in Section 2 to illustrate our approach. But our
work is designed to be domain-independent and is not
restricted to this example.

2. Motivating example

The example we describe here is based loosely on
a scenario described in the Scientific American article
about the Semantic Web [6]. Suppose Bill and Joans
mother goes to her physician complaining of pain and
tingling in her legs and the physician proposes the fol-

drug;

lowing sequence of activities:
 a prescription for Relafen, an anti-inflammatory
 an MRI scan and an electromyography, both of
these are diagnostic tests to try to determine possible
causes for the symptoms;
 a follow-up appointment with the physician to dis-

cuss the results of the diagnostic tests.

Bill and Joan need to do the following things for

their mother:
 fill the prescription at a pharmacy;
 make appointments to take their mother to the two
 make an appointment for the doctors follow-up

treatments;

meeting.

For the three appointment times, there are the fol-

lowing preferences and constraints:
 For the two treatments:

 Bill and Joan would prefer two appointment times
that are close together scheduled at one or two
nearby places, so that only one person needs to
drive, and that person drives only once.
 Otherwise, they would prefer two appointment
times on different days, so that each person needs
to drive once.
 The appointment time for doctors follow-up check
must be later that the appointment times for the two
treatments.
 An appointment time must fit the schedule of the

person that will drive to the appointment.

Assume that there are the requisite Web Services for
finding appointment times and making appointments at
the relevant clinics, Bill and Joan could use those services to schedule their mothers appointments. It would
be difficult for Bill and Joan to finish their task with an
optimal plan by consulting the Web Services manually,
because:
 They may have to try every available pair of close appointment times at any two nearby treatment centers
in order to find one that fits their schedules.
 Furthermore, if they first choose an appointment
time for one treatment and then find they have to
use this same time for the other treatment, then they
will have to reschedule the first appointment.

Instead, suppose we use the OWL-S process ontology to encode a description of how to use Web Services
to accomplish tasks such as the one faced by Bill and
Joan. If we have an automated system which can find
an execution path based on these predefined task de-
compositions, then we can perform Bill and Joans Web
Services composition task automatically.

3. Background

3.1. OWL-S

In the OWL-S process ontology, operations are
modeled as processes. There are three kinds of

(conditional) outputs and (conditional) effects. Preconditions specify things that must be true of the world in
order for an agent to execute a service. Effects characterize the physical side-effects that execution of a
Web-Service has on the world. Inputs and Outputs correspond to knowledge preconditions and effects. That
is, necessary states of our knowledge base before execution and modifications to our knowledge base as a
result of the execution. Note that not all services have
significant side-effects, in particular, services that are
strictly information-providing do not. Here is part of the
OWL-S (Version 0.9) definition of an atomic process
called PharmacyLocator used in our treatment scheduling example:

processes: atomic processes, composite processes and
simple processes. In OWL-S, an atomic process is a
model of a single step (from the point of view of
the client) Web Service that is directly executed to accomplish some task. Executing an atomic process consists of calling the corresponding Web-accessible program with its input parameters bound to particular val-
ues. A composite process represents a compound Web
Service, i.e., it can be decomposed into other atomic,
simple or composite processes. The decomposition of
a composite process is specified through its control
constructs. The set of control constructs includes: Se-
quence, Unordered, Choice, IfThenElse, Iterate,
Repeat-Until, Repeat-While, Split and Split + Join.
A simple process is an abstraction of an atomic or composite process (or of a possibly empty set of these). It
is not considered to be directly executable, but provides an abstract view of an action. Like atomic pro-
cesses, simple processes are, themselves, single-step,
but unlike atomic processes, its possible to peek at
the internal structure of a simple process (if available)
or to replace the simple process with an expansion
of it.

In the process ontology, each process has several
properties, including, (optional)input, preconditions,

The process model of a compound Web Service includes the designation of the top-level composite process corresponding to that service plus a decomposition
of that composite process into a structured collection
of (perhaps further decomposed) subprocesses.2 Web
Services composition is sometimes thought of as the
process of generating a (potentially) complexly structured composite process description which is subsequently executed. On this model, composite processes
are the output of composition. In this paper, we take
composite processes as input to a planner, that is, as
descriptions of how to compose a sequence of single
step actions. Thus, for us, the goal of automated Web
Services composition is find a collection of atomic processes instances which form an execution path for some
top-level composite process.

3.2. SHOP2

SHOP2 is a domain-independent HTN planning sys-
tem, which won one of the top four awards out of the 14

2 Here, we assume that a compound Web Service always has a
complete decomposition bottoming out in atomic processes. Such a
composite process is executable.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

planners that competed in the 2002 International Planning Competition. HTN planning is an AI planning
methodology that creates plans by task decomposition.
HTN planners differ from classical AI planners in what
they plan for, and how they plan for it. The objective
of an HTN planner is to produce a sequence of actions
that perform some activity or task. The description of a
planning domain includes a set of operators similar to
those of classical planning, and also a set of methods,
each of which is a prescription for how to decompose
a task into subtasks. Planning proceeds by using methods to decompose tasks recursively into smaller and
smaller subtasks, until the planner reaches primitive
tasks that can be performed directly using the planning
operators.

One difference between SHOP2 and most other
HTN planning systems is that SHOP2 plans for tasks in
the same order that they will later be executed. Planning
for tasks in the order that those tasks will be performed
makes it possible to know the current state of the world
at each step in the planning process, which makes it
possible for SHOP2s precondition-evaluation mechanism to incorporate significant reasoning power and the
ability to call external programs. This makes SHOP2
ideal as a basis for integrating planning with external
information sources, including Web based ones.

In order to do planning in a given planning domain,
SHOP2 needs to be given knowledge about that do-
main. A SHOP2 knowledge base consists of operators
and methods (plus, various non-action related facts and
axioms). Each operator is a description of what needs
to be done to accomplish some primitive task, and each
method tells how to decompose some compound task
into a set of partially ordered subtasks.

Definition 1 (Operator). A SHOP2 operator is an expression of the form (h(v

) Pre Del Add) where

eters v

) is a primitive task with a list of input param-

 h(v
 Pre represents the operators preconditions.
 Del represents the operators delete list which includes the list of things that will become false after
operators execution.
 Add represents the operators add list which includes
the list of things that will become true after operators
execution.

The expressivity of SHOP2 preconditions and effects are similar to those found in Planning Domain
Definition Language (PDDL) [7]. Preconditions contain logical atoms with variables that are either defined
in h or existentially quantified. Logical atoms can be
combined using the logical connectives such as con-
junction, disjunction, negation, implication and universal quantification. Add and Del lists are generally
defined to be a conjunction of logical atoms but conditional expressions and universally quantified expressions can also be used.

) Pre1 T1 Pre2T2 ) where

Definition 2 (Method). A SHOP2 method is an expression of the form (h(v
 h(v
 Each Prei is a precondition expression
 Each Ti is a partially ordered set of subtasks.

) is a compound task with a list of input param-

eters (v

).

The meaning of this is analogous to a conditional
expression: it tells SHOP2 that if Pre1 is satisfied then
T1 should be used, otherwise if Pre2 is satisfied then
T2 should be used, and so forth. A task list consists
of task atoms and other task lists. A task list can be
defined as ordered or unordered. The tasks in an ordered list must be achieved sequentially whereas tasks
in an unordered list can be achieved in any order. Nesting of ordered and unordered task lists can be used to
achieve more complex ordering restrictions. A task itself represents an activity to perform and may be either
primitive or compound. A primitive task is supposed to
be accomplished by a planning operator. A compound
task needs to be decomposed into smaller tasks using
a method. There may be multiple methods that match
a given task so SHOP2 will try each possible decomposition and backtrack if the decomposition ultimately
fails.

In addition to the usual logical atoms, preconditions
of SHOP2 methods and operators may also contain
calls to external programs and assignments to variables.
These are useful for integrating planning with queries
to information sources on the Web. For example, the
following expression
assign v(call f t1t2  tn)
will bind the variable symbol v with the result of calling
external procedure f with arguments t1t2  tn.

Definition 3 (Planning problem). A planning problem
for SHOP2 is a triple (S, T, D), where S is initial state,
T is a task list, and D is a domain description. By taking (S, T, D) as input, SHOP2 will return aplan P =
(p1p2pn), that is, a sequence of instantiated operators that will achieve T from S in D.

4. Why HTN planning is suitable for Web
Service composition?

There is a clear point where the composition as
planning and composition as building up, i.e., com-
posing, CompositeProcesses intersect: when the plan
itself is a CompositeProcess. This is always trivially
the case as a standard SHOP2 plan is a sequence of
operators. Furthermore, it is straightforward to extend
SHOP2 to generate conditional plans which begin to
look like more interesting CompositeProcesses. How-
ever, the generation of CompositeProcesses by planning is better viewed as the specialization of prewritten CompositeProcesses than the authoring of complex,
entirely novel programs.

There are several ways in which the HTN approach

is promising for service composition:
 HTN encourages modularity. Methods can be written without consideration of how its subtasks will
decompose or what compound tasks it decomposes.
The method author is encouraged to focus on the
particular level of decomposition at hand.
 This modularity fits in well with Web Services.
Methods correspond to recursively composable
workflows. These workflows can come from diverse
independent sources and then integrated by the planner to produce situation specific, instantiated work-
flows.
 Since the planner considers the entire execution path,
it has opportunities to minimize various sorts of failures or costs. Most obviously, if the planner finds a
plan, one knows that the top level task is achievable
with the resources at hand. If the granularity of the
services is large enough then it can be considerably
easier for a human being to inspect and understand
the plan.
 HTN planning scales well to large numbers of meth-

ods and operators.

 Some HTN planners (e.g., SHOP2) support complex precondition reasoning, and even the evaluation
of arbitrary code at plan time. These features make
it straightforward to, integrate existing knowledge
bases on the Semantic Web as well as the information supplying Web Services.
 HTN planning provides natural places for human
intervention at plan time. The two obvious examples
are first, that in preconditions, a code or service call
can query a person for special input, and second,
if the planner hits a point where it cannot continue
de composition, it can request a decomposition of
that step from another person, or even a software
agent.3

5. From OWL-S to SHOP2

The execution of an atomic process is a call to the
corresponding Web accessible program with its input
parameters instantiated.4 The execution of a composite process ultimately consists in the execution of a
collection of specific atomic processes. Instead of directly executing the composite process as a program
on an OWL-S interpreter, we can treat the composite
process as specification for how to compose a sequence
of atomic process executions. In this section, we will
show how to encode a composite process composition
problem as a SHOP2 planning problem, so SHOP2 can
be used with OWL-S Web Services descriptions to automatically generate a composition of Web Services
calls.

5.1. Encoding OWL-S process models as SHOP2
domains

In this section, we introduce an algorithm for translating a collection of OWL-S process models K into
a SHOP2 domain D. In our translation, we make the
following assumption:

Assumption 1. Given a collection of OWL-S process
models K = {K1, K2, . . ., Kn}, we assume:

3 For example, the HiCAP [8] system employed SHOP as a com-

ponent of a mixed initiative system.

4 Here, we assume that before the execution of an atomic process the preconditions for executing the atomic process have been
satisfied.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

 All atomic processes defined in K can either have effects or outputs, but not both. According to the situation calculus based semantics of OWL-S [9], outputs
characterize knowledge effects of executing Web
Services and effects characterize physical effects for
executing Web Services. An atomic process with
only outputs models a strictly information-providing
Web Service. And an atomic process with only effects models a world-altering Web Service. In gen-
eral, we do not want to actually affect the world during planning. However, we do want to gather certain
information from information-providing Web Ser-
vices, which entails executing them at plan time. To
enable information gathering from Web Services at
planning time, we require that the atomic processes
to be either exclusively information-providing or exclusively world-altering.
 There is no composite process in K with OWL-Ss
Split and Split + Join control constructs. SHOP2
currently does not handle concurrency. Therefore in
our translation, we only consider OWL-S process
models that have no composite process using Split
and Split + Join control construct. We also assume
only a non-concurrent interpretation of Unordered
(as permitted by OWL-S). We intend to address how
to extend SHOP2 to handle concurrency in the future
work.

We encode a collection of OWL-S process defini-

tions K into a SHOP2 domain D as follows:
 For each atomic process with effects in K, we encode
it as a SHOP2 operator that simulates the effects of
the world-altering Web Service.
 For each atomic process with output in K, we encode
it as a SHOP2 operator whose precondition include
a call to the information-providing Web Service.
 For each simple or composite process in K, we encode it as one or more SHOP2 methods. These methods will tell how to decompose an HTN task that
represents the simple or composite process.

The following algorithm shows how to translate an
OWL-S definition of an atomic process with only effects into a SHOP2 operator.5

5 Conditional effects can be easily encoded into SHOP2 opera-
tors. Here, for simplicity, we assume that effects (and outputs) are
not conditional.

5.1.1. Translate-atomic-process-effect (Q)

Input: a OWL-S definition Q of an atomic process

A with only effects.

Output: a SHOP2 operator O.
Procedure:

= the list of input parameters defined for A in

(1) v
Q.

(2) Pre = conjunct of all preconditions of A, as defined

in Q.

(3) Add = collection of all positive effects of A, as

defined in Q.

(4) Del = collection of all negative effects of A, as
(5) Return O = (A(v

) Pre Del Add).

defined in Q.

The above algorithm translates each atomic OWL-S
definition into a SHOP2 operator that will simulate the
effects of a world-altering Web Service by changing
its local state via an operator. Such Web Services will
never be executed at planning time, for obvious reasons.
The following algorithm shows how to translate a
OWL-S definition of an atomic process with only outputs into a SHOP2 operator.

5.1.2. Translate-atomic-process-output (Q)

Input: a OWL-S definition Q of an atomic process

A with only outputs.

Output: a SHOP2 operator O.
Procedure:

= the list of input parameters defined for A as

(1) v
in Q.

(2) Pre = a conjunct of all the preconditions of A, as
defined in Q, plus one more pre condition of the
form (assign y (call Monitor A if)), where Monitor
is a procedure which will handle SHOP2s call to
Web Services.

(3) Add = y.
(4) Del = .
(5) Return O = (A(v

) Pre Del Add).

The above algorithm translates each atomic OWL-
S definition into a SHOP2 operator that will call the
information-providing Web Service in its precondition.
In this way, the information-providing Web Service is
executed during the planning process. The operator for
these atomic processes are entirely book-keeping,
thus none of these operators will appear in the final
plan.

The following algorithm shows how to translate a
OWL-S definition of a simple process into SHOP2
method(s).

5.1.3. Translate-simple-process(Q)

Input: a OWL-S definition Q of a simple process S.
Output: a collection of SHOP2 methods M.
Procedure:

= the list of input parameters defined for S as

(1) v
in Q.

(2) Pre = conjunct of all preconditions of S as defined

in Q.

(3) (b1, . . ., bm) = the list of atomic and composite
processes that realizes or collapse into S as defined
in Q.
(4) for i = 1, . . ., m.
 Mi = (S(v

) Pre bi).

(5) return M = {M1, . . ., Mm}.

The following algorithm shows how to translate a
OWL-S definition of a composite process with Sequence control construct into a SHOP2 method.

5.1.4. Translate-Sequence-Process(Q)

Input: a OWL-S definition Q of a composite process

C with Sequence control construct.

Output: a SHOP2 method M.
Procedure:

(1) (v

) = the list of input parameters defined for C

as in Q.

(2) if = conjunct of all preconditions of C as defined

in Q.

(3) Pre1 = Sequence control construct of C as defined

in Q.

(4) (b1, . . ., bm) = the sequence of component pro-

cesses of B as defined in Q.

(5) T = ordered task list of (b1, . . ., bm).
(6) Return M = (C(v

) Pre T).

The following algorithm shows how to translate
a OWL-S definition of a composite process with
IfThenElse control construct into a SHOP2 method.

5.1.5. Translate-IfThenElseProcess(Q)

(1) v
in Q.

= the list of input parameters defined for C as

(2) if = conditions for If as defined in Q.
(3) Pre1 = conjunct of all preconditions of C as defined

in Q and if .

(4) Pre2 is conjunct of all preconditions of C as defined

in Q.

(5) b1 = process for Then as defined in Q.
(6) b2 = process for Else as defined in Q.
(7) Return M = (C(v
) Pre1 b1 Pre2 b2).
The following algorithm translates a OWL-S definition of a composite process with Repeat-While control
construct into SHOP2 methods.

5.1.6. Translate-Repeat-While-Process(Q)

Input: a OWL-S definition Q of a composite process

C with Repeat-While control construct.

Output: a collection of SHOP2 methods M.
Procedure:

= the list of input parameters defined for C as

(1) v
in Q.

(2) while = conditions for While as defined in Q.
(3) Pre = conjunct of all preconditions of C as defined

in Q.

(4) b1 = process for Repeat as defined in Q.
(5) M1=(C(v
)  ).
(6) M2 = (C1(v
(7) Return M = {M1, M2}.

) Pre C1(v
) While (b1C1(v

)).

has

Note

definition

that M2 method

two
conditiontask list pairs. The first condition and
task list pair ensures that the process inside the loop
is iterated as long as the condition is true. When
this condition becomes false, SHOP2 will check the
second condition which is empty (denoted by ) thus
always true. The task list for this condition is also
empty so nothing will be added to the resulting plan.
This second pair is just needed to make sure that plan
will not fail when the loop condition becomes false.

The following algorithm translates a OWL-S definition of a composite process with Repeat-Until control
construct into SHOP2 methods.

Input: a OWL-S definition Q of a composite process

5.1.7. Translate-Repeat-Until-process(Q)

C with IfThenElse control construct.

Output: a SHOP2 method M.
Procedure:

Input: a OWL-S definition Q of a composite process

C with Repeat-Until control construct.

Output: a collection of SHOP2 methods M.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

Procedure:

(1) v
in Q.

= the list of input parameters defined for C as

(2) Until = conditions for Until as defined in Q.
(3) Pre = conjunct of all preconditions of C as defined

in Q.

(4) b1 = process for Repeat as defined in Q.
) Pre C1(v
(5) M1 = (C(v
(6) M2 = (C1(v
) (not(Until)) (b1C1(v
(7) Return M = {M1, M2}.

)).

)  ).

The following algorithm translates a OWL-S definition of a composite process with Choice control construct into a collection of SHOP2 methods.

5.1.8. Translate-Choice-process(Q)

Input: a OWL-S definition Q of a composite process

C with Choice control construct.

Output: a collection of SHOP2 methods M.
Procedure:

(1) v
in Q.

= the list of input parameters defined for C as

(2) Pre = conjunct of all preconditions of C as defined

in Q.

(3) B = Choice control construct of C as defined in Q.
(4) (b1, . . ., bm) = the bag of component processes of

B as defined in Q.
(5) for i = 1, . . ., m.
 Mi = (C(v

) Pre bi).

(6) return M = {M1, . . ., Mm}.

The following algorithm translates a OWL-S definition of a composite process with Unordered control
construct into a SHOP2 method.

5.1.9. Translate-Unordered-process(Q)

Input: a OWL-S definition Q of a composite process

C with Unordered control construct.

Output: a SHOP2 method M.
Procedure:

(1) v
in Q.

= the list of input parameters defined for C as

(2) Pre = conjunct of all preconditions of C as defined

in Q.

(3) B = Unordered control construct of C as defined

(4) (b1, . . ., bm) = the bag of component processes of

B as defined in Q.
(5) T = unordered task list of (b1, . . ., bm).
(6) Return M = (C(v

) Pre T).

The following algorithm translates a collection of

OWL-S process models into a SHOP2 domain.

5.1.10. Translate-Process-Model (K)

Input: a collection of OWL-S process models K.
Output: a SHOP2 domain D.
Procedure:

(1) D = .
(2) For each atomic process definition Q in K:
 If this atomic process has only outputs:

 O = TRANSLATE-ATOMIC-PROCESS-

OUTPUT (Q).

 If this atomic process has only effects:

 O = TRANSLATE-ATOMIC-PROCESS-

(3) For each simple process definition Q in K:

(4) For each composite process definition Q in K:

EFFECT (Q).

 Add O to D.
 M = TRANSLATE-SIMPLE-PROCESS (Q).
 Add M to D.
 If the process has a Sequence control construct
 M = TRANSLATE-Sequence-PROCESS
 If the process has a IfThenElse control con-
struct
 M = TRANSLATE-IfThenElse-PROCESS

(Q).

(Q).

 If the process has a Choice control construct
 M = TRANSLATE-Choice-PROCESS (Q)
 If the process has a Repeat-While control con-

struct

PROCESS (Q).

TRANSLATE-Repeat-While-
 If the process has a Repeat-Until control con-
struct
 M = TRANSLATE-Repeat-Until-PROCESS
 If the process has a Unordered control construct
TRANSLATE-Unordered-

(Q).

 Add M to D.

PROCESS(Q).

in Q.

(5) Return D.

To keep the above pseudocode simple, we did not
specify the recursive translations within a composite
process, e.g., what happens if we have a Sequence of
IfThenElse or further nestings? Our way for handling this problem is to treat each control construct
within a composite process as a composite process.
For above example, in our translation, we will have
a SHOP2 method for the composite process with Sequence control construct and a method for each nested
IfThenElse control construct.

Also we did not explicitly describe how our algorithm handles processes with dataflow specification. In
OWL-S, a composite process can specify that an output of a composite process is equal to an output of
one of its subprocesses whenever the composite process is instantiated. Also, for a composite process with
a Sequence control construct, one can specify that the
output of one subprocess is an input to another subpro-
cesses. SHOP2 does not have the concept of an output
and we simply treat outputs as knowledge effects. The
output results of a service are recorded in the current
state using a special predicate and by assigning a unique
number to each instance of a SHOP2 domains methods
and operators. The predicate (Output Instance Value)
indicates a method or operator instance Instance has
the value Value for the particular output Output.

The other aspect of the translation we omitted in the
algorithm is the translation of preconditions and ef-
fects. The current OWL-S specification (Version 1.0)
does not have a concrete syntax for precondition spec-
ification. OWL-S 1.1 will support the description of
the preconditions and effects of services using OWL
statements with variables similar to atoms in the Semantic Web Rule Language (SWRL). These atoms will
be combined with logical connectives that are already
supported in SHOP2. The translation of such expressions would be syntactically straight-forward but it is
also important to preserve the semantics of OWLa
much more challenging task (see Section 7.1).

5.2. Encoding OWL-S Web Services composition
problem as SHOP2 planning problem

Narayanan and McIlraith [9] give a formal semantics for OWL-S in terms of the situation calculus [10]
and Golog [11]. The situation calculus in a first-order
language for reasoning about action and change. In the
situation calculus, the state of the world is described by

Fig. 1. A subset of Golog constructs to create complex actions that
are relevant to OWL-S constructs.

functions and relations (fluents) relativized to a situation s, e.g., f(x, s). The function do(a, s) maps a situation
s and an action a into a new situation. A situation is simply a history of the primitive actions performed from
an initial, distinguished situation S0.

Golog is a high-level logic programming language
based on the situation calculus, that enables the representation of complex actions. It builds on top of the
situation calculus by providing a set of extralogical
constructs (Fig. 1) for assembling primitive actions,
defined in the situation calculus, into complex actions
that collectively comprise a program, . Given a domain theory, D and a Golog program , program exe-
, such that D |= Do(,
cution must find a sequence a
S0, do(a
, S0)) denotes that
Golog program  starting at S0 will legally terminate
in situation do(a
, S0)) is used to
abbreviate the expression do(an, do(an1, . . ., do(a1,
S0)). Thus, a1, . . ., an are the actions that realize Golog
program , starting in the initial situation, S0.

, S0)). Do(, S0, do(a

, S0)) where do(a

The semantics given in [9] and [12] maps an OWL-S
process to a Golog program where atomic processes in
OWL-S are mapped to primitive actions in Golog and
composite processes in OWL-S are mapped to corresponding complex Golog actions. Using these seman-
tics, we can define the OWL-S service composition
problem as follows:

Definition 4 (OWL-S Service composition). Let K =
{K1, K2, . . ., Km} be a collection of OWLS process
models satisfying Assumption 1 (from Section 5.1), C
be a possibly composite process defined in K, S0 be the
initial state, and P = (p1, p2, . . ., pn) be a sequence of
atomic processes defined in K. Then P is a composition
for C with respect to K in S0 if in action theory, we can
prove:
| = Do


a , S0

C, S0, do

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

where
  is the axiomatization of K and S0 as defined in
action theory;
 C is the complex action defined for C as defined in
 ai is the primitive action defined for pi as defined in

action theory;

action theory;

Note that this definition is for offline planning, i.e.,
there is no execution of information-providing Web
Services during planning. This definition assumes that
the initial state contains the complete information for
the domain. In reality, this is not the case as we interleave the execution of information-providing services
with the simulation of world-altering ones to complete
the information in the initial state. Information gathering is done with respect to the initial state so the
planning process would yield the same results if all
the information-providing Web Services were executed
prior to planning. There are some conditions (similar
to the IRP assumption [12]) that needs to hold in order
to extend this theorem for interleaved execution. We
will discuss these conditions at the end of this section.
We will now prove that the plans SHOP2 finds for
the OWL-S service composition problem are equivalent to the action sequences found in situation calculus.

We will use the simplified version of SHOP2 algorithm
(Fig. 2) during the proof. Since Golog does not provide
an Unordered construct we will not consider this construct in our proof and in the SHOP2 algorithm we have
omitted the details related to unordered tasks. It is possible to define Unordered construct in ConGolog (Con-
current Golog) [13] which is an extension to Golog that
allows concurrent execution. But since SHOP2 does
not allow concurrent processes we cannot use this ex-
tension. Also note that in the original Golog formalism
complex actions are defined as macro definitions [11]
so complex actions do not have preconditions. In our
proof, we will show the correspondence to the original
Golog approach and assume that in the given OWL-S
process model only atomic processes have precondi-
tions.

Theorem 5. Let K = {K1, K2, . . ., Km} be a collection of OWL-S process models satisfying Assumption
1 (from Section 5.1), C be a possibly composite process defined in K, S0 be the initial state, and P = (p1,
p2, . . ., pn) be a sequence of atomic processes defined
in K. Let D = TRANSLATE-PROCESS-MODEL (K).
Then P is a composition for C with respect to K in S0
if P is a plan for planning problem (S0, MC, D) where
MC is the SHOP translation for process C.

Fig. 2. A simplified version of the SHOP2 planning procedure.

PROOF. Before giving the proof we should note
that there is a representational difference between how
SHOP2 and situation calculus describes the state of the
world. SHOP2 represents state by a set of ground atoms
whereas in the situation calculus, the state of the world
is described by relations (fluents) relativized to a situ-
ation. For example, f(x
) is true at some point in the
planning process when that atom occurs in SHOP2s
state (e.g., the set of ground atoms). In the situation
calculus, truth value for that relation is relative to a
specific situation argument, e.g., f(x
, s). The changes
to the state in SHOP2 is done by adding or deleting
atoms from the state whereas situation calculus defines
successor state axioms to define the truth values for the
fluents in different situations. Apart from this representational difference, there is an equivalence between
SHOP2 state and situations, e.g., f(x
) is true in the
initial state of SHOP2 if f(x
, S0) is true in situation
calculus. Applying the effects of an operator will also
preserve this equivalence. It is easy to verify that the
truth value for the predicate f(x
) after applying the
effects of an operator will be equal to the truth value of
f(x
, do(a, s)) when a is the corresponding situation
calculus action and the starting states are equivalent. In
general, when the same sequence of actions/operators
are applied to a situation/state, the state of the world
in the final situation/state will be the same. Throughout the proof, we will use this equivalence and use the
same name to denote world states in both notations
when the meaning is clear. The proof of the theorem is

by induction.

Hypothesis. For a given OWL-S process C, P is a
plan for the planning problem (S0, MC, D) if | =
Do(C, S0, do(a
= [a1, a2, . . .] is
the sequence of primitive actions in situation calculus
that corresponds to the sequence of SHOP2 operators
in P.

, S0))) where a

Base Case: Suppose A is an atomic OWL-S process
and a is the corresponding primitive action in situation
calculus and oA is the corresponding SHOP2 operator.
Then in Golog it is defined that

It means when the preconditions for the process is
satisfied with respect to situation s then the primitive
action sequence we will get for this simple program

will have only one element, namely a
= [a]. As seen
in line 9 of SHOP2 algorithm, the plan for a primitive
task will return the plan that includes the operator instance when the preconditions of that operator are satisfied (the recursive call will return empty list as there
are no more tasks in the list). Thus, the plan returned
by SHOP2 is [oA] which is equivalent to the situation
calculus result.

Inductive Step: We will do a case by case analysis
for each of the control constructs in the process model
to show that our translation and resulting plans SHOP2
finds are correct.

Choice: Suppose C is a composite OWL-S process
defined as a Choice of two6 other processes C1 and C2.
The SHOP2 translation for C will yield two methods
M1 = (C  MC1) and M2 = (C  MC2). Note that the
SHOP2 methods have no preconditions ( is used for
preconditions) because we have assumed that composite processes cannot have preconditions. Correspond-
|C2 and the seing Golog program for C is C = C1
mantics is defined as

The disjunction means any a

that is a valid action
sequence for either C1 or C2 will also be a valid sequence for C. From our hypothesis we know for each
action sequence a
that satisfies C1 (or C2) we have
a valid SHOP2 plan PC1 (or PC2). The nondeterministic choice in SHOP2 algorithm (line 11) shows that
when a plan is being sought for C, the solution for any
matching method instance, in this case M1 and M2, will
be returned as a result. This ensures that when SHOP2
is asked to find all the plans for C, both PC1 and PC2
will be returned proving the equivalence to the answer
in situation calculus.

Sequence: Suppose C is a composite OWL-S process defined as a Sequence of two other processes C1
and C2. The SHOP2 translation for C will yield one
method MC = (C  (MC1
MC2)). Corresponding Golog
program for C is C = C1; C2 and the semantics is
defined as

the action sequence a1

Suppose that situation s


represents a history of
. If the action sequence
6 Golog choice operator | is defined for two operands. A choice
of more operands could be done by nested | operators which would
not effect our proof here.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

recorded between situations s

the final situation s
quence a = [a1
, a2

then
represents the concatenated se-

]. Calling SHOP2(s, MC1, D)

and s

is a2

will return PC1 and from our hypothesis we know that
it is equivalent to the action sequence a1
. We also

, MC2, D) will return a
know that calling SHOP2(s

plan PC2 that is equivalent to the action sequence a1

SHOP2 algorithm shows that (line 14) when a task (in
this case MC) is removed from the input task network
T, it is replaced with its sub-elements (in this case MC1
and MC2). The tasks to solve are selected from T in the
order they were added (line 3) so the resulting plan for
SHOP2(s, MC, D) will actually be the concatenation of

PC1 and PC2 which is equivalent to the sequence a1
IfThenElse: Suppose C is a composite OWL-S
process defined with a IfThenElse control construct
and cond is the condition for the if statement, C1 is
the process in the then part and C2 is the process in
the else part. The SHOP2 translation for C will yield
 MC2). Corresponding
one method MC = (C cond MC1
Golog program for C is C = (if cond then C1 else C2
endIf) and the semantics is defined as


The expression cond [s] evaluates to true whenever
the fluent cond is true in situation s. Suppose a1
is
the action sequence for the situation C1 and a2
is
the action sequence for the situation C2. If s satisfies
cond then the result for C will be a1
otherwise re-

. From our hypothesis we know for
sult will be a2

any possible a1
) we have a valid SHOP2
plan PC1 (or PC2). When we call SHOP2(s, MC, D),
the algorithm will check the conditions in the method
definition (line 12), cond and  in this translation. If
cond is satisfied algorithm returns PC1 and otherwise
returns PC2 which is equivalent to the result in situation
calculus.

(or a2


Repeat-While: Suppose C is a composite OWL-S
process defined with a Repeat-While control construct
and cond is the condition for the while statement and C1
is the process in the loop body. As we have assumed
that composite processes do not have preconditions,
without losing generality, we can simplify the SHOP2

translation to be MC = (C cond (C1 C)  ). Corresponding Golog program for C is C = (while cond do
C1 endWhile) and the semantics is defined as

This definition includes the nondeterministic iteration operation * which has a second-order semantics [11]. We will use the restricted version of Golog
as defined in [12] where the iterations has a limit k.
This restriction eliminates the problems caused by unlimited looping and enables us to define a first-order
semantics.
Assume the iteration runs k times. When k = 0, the
above formula will simplify to Do(cond?, s, s
) which
returns an empty action sequence in situation calculus.
This new formula also implies condition cond is false
in the initial situation s. When SHOP2 is trying to solve
MC, since cond is false the algorithm will choose (line
12) the second conditiontask list pair (note that the
second condition in MC is  which is always true). The
second task list is  so SHOP2 will return an empty
plan as well. Suppose a
is a valid action sequence
for C1. From our hypothesis we know for each action sequence a
that satisfies C1 we have a valid
SHOP2 plan PC1. In the general case, when k > 0,
the Golog formula becomes Do([cond?; (C1)1; . . .;
cond?; (C1)k;cond?], s, s
) hence the action sequence
will be [a1
]. Note that action sequence for
each step of iteration may be different, for example
when C1 contains nondeterministic choices. We also
know that cond will be true in situations s, s1, . . ., sk1
and false in situation Sk. When SHOP2 is searching
a plan for MC, the first condition (cond) will evaluate to true and SHOP2 will chose the first task list
(C1 C). Solving the first task C1 will add P1 to the
plan and solving second task C will recursively continue until cond fails. Since, initial states are equal and
plan prefixes are same, cond will not hold after kth it-
eration. At this point, algorithm will chose the second
conditiontask list pair (empty task list) which will conclude the recursion and the plan returned will be [P1,
. . ., Pk]. At each step of the iteration we will have the
equivalent world states so the action sequence ai and
plan Pi will be equivalent due to our hypothesis. There-
fore, the final plan and the final action sequence will be
equivalent.

, . . . , ak

Repeat-Until: The proof for this case will be very
similar to the above proof for Repeat-While construct.
Our proof did not include the effects of executing
information-providing services during planning. Information gathering during planning is equivalent to the
Middle Ground execution (MG) for sensing actions in
the Golog approach [12]. In both cases, planning starts
with an incomplete initial state and executing sensing
actions adds new knowledge to the state. As long as
the information retrieved from the services does not
change over the course of planning, we would still have
the equivalence of world states in both representations
and it would be straight-forward to extend the proof for
this case.

The correctness of MG depends on the Invocation
and Reasonable Persistence (IRP) assumption [12]. In-
tuitively, IRP assumption says that (1) informationproviding services should be executable in the initial
state, and (2) information gathered from these services
cannot be changed by external or subsequent actions.
The first condition follows from the fact that information gathering is done with respect to the initial state.
The second condition assumes no external source will
change the gathered information during the planning
process but also prohibits the planner from changing
the gathered information as well. This is to prevent
problems such as this one: in our example domain (see
Section 2), a Web Service is executed to get the available appointment times from a hospital. Then planner simulates scheduling an appointment at one of the
available time slots. If the information-providing service is executed again and the available appointment
times (which have not yet been changed) are added
to the knowledge base then there would be a problem because planner would be able to schedule another
appointment in the same time slot. The IRP prohibits
the second step (changing the information retrieved)
to overcome this problem. This solution is certainly
very restrictive and obviously our example domain violates this assumption. For this reason, our solution is
to prohibit the last step where the same informationproviding service is executed more than once.

To establish the soundness and completeness of our
approach we have the following assumptions about the
information-providing Web Services:
 executable (in the initial state with all parameters

grounded);

 terminable (with finite computation);
 repeatable (with same result for the same call during

the planning process).

We also assume that the information that is returned
from different Web Services are disjoint, i.e., no two
services return the same information. These assumptions guarantee that gathered information can only be
changed by the actions planner simulates. Also there is
no way that this simulated change will be undone by
another information gathering step as long as we execute each information-providing Web Service at most
once. Note that we do not need to run the same service
twice since the information is guaranteed to be same
each time due to repeatability assumption.

One other thing to note is that, different from the
Golog approach, we do not allow the informationproviding services to appear in the final plan since our
translation methodology maps them to book-keeping
operators. However, this is just a style difference as
in the Golog approach a post-processing step is suggested to find the world-altering services for the execution of the resulting plan. In some situations, it could
still be valuable to include the information-providing
services in the plan so a prudent action could verify if the information-providing services still return
same information. This could be easily achieved in
our system by changing the TRANSLATE-ATOMIC-
PROCESS-OUTPUT procedure to generate a standard
operator rather than a book-keeping operator (trans-
lation rules for precondition and effect).

6. Implementation

To realize our ideas, we started with an implementation of a OWL-S to SHOP2 translator. This translator
is a Java program that reads in a collection of OWL-S
process definitions and outputs a SHOP2 domain. As
shown in the translation algorithm in Section 5.1, when
planning for any problem in this domain, SHOP2 will
actually call the information-providing Web Services
to collect information while maintaining the ability of
backtrack by merely simulating the effect of worldaltering Web Services. The output of SHOP2 is a sequence of world-altering Web Services calls that can
be subsequently executed.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

We built a monitor which handles SHOP2s calls
to external information-providing Web Services during planning (Fig. 3). We wrote a OWL-S Web Services
executor which communicates with SOAP based Web
Services described by OWL-S groundings to WSDL
descriptions of those Web Services. Upon SHOP2s re-
quest, the monitor will call this OWL-S Web Services
executor to execute the corresponding Web Service.
Since the information-providing services are always
defined as atomic processes, the service is executed
by invoking the WSDL service in the grounding. The
monitor also caches the responses of the informationproviding Web Services to avoid invoking a Web Service with same parameters more than once during plan-
ning. This will save the network communication times
and improve planning efficiency, and establishes the
repeatability condition required for proving SHOP2s
soundness and completeness. Also information can
only be added into the current state if it has not been
changed by the planner. We assume that the cached information will not be changed by other agents during
planning and we will generalize this in our future work.
We also built a SHOP2 to OWL-S plan converter,
which will convert the plan produced by SHOP2 to
OWL-S format which can be directly executed by the
OWL-S executor.

We ran our scenario from Section 2 on this system.

In doing so:
 Our system communicated with real Web Services.
Unfortunately, the current Web Services available on
the Web have only WSDL descriptions without any
semantic mark-up. Therefore, we created OWL-S
mark-up for the WSDL descriptions of these online
ser vices. For some services it was necessary to create even the WSDL description, e.g., for CVS Online
Pharmacy Store. It was not possible to use real services for some of the ser vices either because none
was available as Web Services, e.g., a doctors agent
providing the patients prescription, or it was infeasible to use a real Web Service for the demo, e.g.,
making an appointment with a doctor each time the
program is executed. For these services, we implemented Web Services to simulate these functionali-
ties.
 We built Web Services that allow the access to users
personal information sources. For example, it is necessary to learn the users schedule to be able to generate a plan for the example task in our demo. It
is possible to get this information from the sources
available on the users machine such as a Personal
Information Manager like Microsofts Outlook. We

Fig. 3. System Architecture.

Fig. 4. Example running result.

have implemented local SOAP based services that
will retrieve this kind of information. WSDL and
OWL-S descriptions are also generated for these local services so that they can be composed and executed in the same way as other remotely available
services.

Finally, some information gathering services were
implemented as direct Java calls from SHOP2 over a
Java/SHOP2 bridge. For example, we have a service
which asks the user for acceptable distances to the treatment center by popping up a window on the users client
to accept input. Changing the data entered at this point
will possibly yield a different plan to be generated allowing the planner produce custom plans depending on
personal preferences.
 We also encoded a description of how to compose
Web Services for tasks such as the one faced by Bill
and Joan in section 2 in OWL-S. The description is
given as a OWL-S composite process that is composed of several other composite processes that are
defined as sequence, choice or unordered processes.
This OWL-S description constitutes the top level
composite process described in Section 5.1 and is
translated into a SHOP2 domain for planning. We en-

code most of the constraints mentioned in Section 2
as Web Service preconditions. Right now, there is no
standard process modeling language for specifying
Web Service preconditions. Therefore, we directly
encode the Web Services preconditions in SHOP2
format.
Fig. 4 shows the various components of the system7
and the results achieved from a sample run of the example domain. The user starts with a simple user interface
where an OWL-S service description for any desired
task can be loaded. When the service description for
the example domain is selected, a form to enter the required parameters for the task is presented to the user.
This form is generated based on the ontologies used
to describe the input parameters of the service. The UI
will also automatically fill out some of the fields such
as the home address from a user specified knowledge
base.

Once all the input parameters are provided SHOP2
starts the planning process using the domain description obtained from the translation of the OWL-S files.
Note that the service selected in the UI is specified by

7 This system was demonstrated in the Developers Day of the

12th WWW conference in Budapest, Hungary.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

an abstract task list, that is, a set of tasks which can
be achieved in a variety of ways. In order to execute
(it would be better to say, perform, or achieve) this
service we must decompose these abstract tasks into
actions (services) that we can actually invoke. SHOP2
decomposes the top level task into smaller subtasks,
and of course there may be multiple different decompositions for any given task. For example, one decomposition for the top level task yields a task to schedule
two appointments on the same day for the same person whereas another decomposition will yield a task
to schedule two appointments on two different days
for two different drivers (see Section 2 for more information on domain characteristics). Another example
abstract task is to find the availability of the prescribed
medicine in an online pharmacy store. A decomposition for this task will include all the different Web Services for different online stores. These decompositions
are statically given in the OWL-S service descriptions
but one can imagine a more dynamic setting where a
Web Service repository is queried for possible decom-
positions.

The SHOP2 planner will execute the informationproviding Web Services to gather the necessary information for plan generation, e.g., get the available
appointment times from hospitals. Based on the collected information the planner will, if possible, produce a plan that is a valid decomposition of the top
level task. This plan is simply a sequence of atomic,
directly executable Web Services such as order the
medicine from the online pharmacy store, make the
appointment in the hospital for the treatment, and update my personal calendar with the appointment info.
User has the option to view the details of the plan, reject the plan if desired, and re-plan with a new set of
constraints.

To test the effectiveness of our approach, we have
run SHOP2 on several instances of the example prob-
lem. These problem instances varied from cases where
it was easy to schedule satisfactory appointments to a
case in which no nearby treatment centers had treatment time slots that were close together, so that Bill
and Joan would both have to drive Mom for treatments on separate days. In all of these cases, SHOP2
was easily able to find the best possible solution.
Fig. 4 shows a snapshot of the running system and
the interaction between different components of the
system.

7. Discussion

7.1. Using Semantic Web knowledge bases

SHOP2 represents the state of the world as a set
of ground logical atoms. SHOP2 uses axioms which
are generalized versions of Horn clauses to infer conditions that are not explicitly asserted in the current
state. SHOP2s theorem prover makes a closed-world
assumption. In contrast, Semantic Web, and particularly OWL, has an open-world assumption. The inferences in OWL are done with respect to the OWL Semantics [14]. OWL DL species of the language can
be directly mapped to SHION (D) Description Logic
(DL) [15] which itself is a decidable subset of firstorder logic.

Unfortunately, it is not possible to directly express the semantics of OWL DL using SHOP2 ax-
ioms. Therefore using SHOP2s theorem prover directly causes us to lose the inferencing capability normally an OWL reasoner possesses. Furthermore, the
size of the data involved in the planning process over
Semantic Web will be much bigger than the ones encountered in classical planning problems. The state of
the world consists of all the information coming from
ontologies either stored locally or found remotely on
the Web. Therefore, the theorem prover should be able
to work in Web scale, with thousands or maybe hundreds of thousands of facts and axioms. SHOP2s inferencing capabilities are not satisfactory for the expressivity and the scalability needed to deal with knowledge
bases found on Semantic Web.

It is possible to completely replace the theorem
prover SHOP2 uses with a new one. As long as the
theorem proving is decidable and the theorem prover
is sound and complete then the soundness and completeness of the planner is ensured. So, we can use an
OWL reasoner to reason about the state of the world.
On this model, the state will be simply represented as
an OWL knowledge base. The precondition checking
is equivalent to querying the knowledge base and applying effects is equivalent to adding and deleting facts
from the knowledge base. If we restrict ourselves to the
OWL DL language then we can use sound and complete DL reasoners for this purpose. Also there exists
DL reasoners specialized to handle very large knowledge bases [16]. Therefore, we can solve both the expressivity and scalability problems.

Using a DL reasoner inside SHOP2 planner brings
out some issues that classical planning theory has not
addressed thoroughly. In general, classical planners do
not let axiomatic inference at all or only allow a restricted form of inference. For example, secondary re-
lations, relations whose values can be deduced from
other relations, are allowed to appear only in preconditions but not in effects to avoid certain complications
[p. 42, 17]. Any property in OWL that is defined to have
an inverse property can be seen as a secondary relation
because the value for that property can be deduced from
its inverse property. Either the planner should not accept operator descriptions that use these properties in
effects or it should define the semantics associated with
it. The semantics may require that if a relation is in the
delete list and the property used in the relation has an
inverse property then the inverse relation will also be
deleted.

As an initial attempt to investigate the applicability
of the idea, we have incorporated the OWL DL reasoner
Pellet [18] into SHOP2. To avoid the problems mentioned above we have considered only a restricted set
of process definitions where preconditions and effects
consist of ABox expressions and effects do not mention secondary relations. It was possible to represent
the process descriptions used in the example defined
in Section 2 with these restrictions. Our initial observations showed that using a DL reasoner increased the
amount of time required for planning but overall planning time was still dominated by the time spent for remote Web Service execution. Of course, the reasoning
time is related to the structures of the ontologies used
and having very complex definitions could effect the
reasoner performance significantly. As a future work
we are continuing to investigate this in detail along with
the effects of allowing more expressive DL constructs
in operator definitions.

7.2. Information gathering during planning

There is a fundamental difference between exclusively information-providing and possibly worldaltering atomic processes. We typically want to execute information-providing atomic processes at various
points in the planning process, while we never want to
execute world-altering ones. Contrariwise, at composition execution time, the primary interest is in the execution of world-altering processes. Indeed, in our sys-

tem we do not include any information-providing processes in compositions. Furthermore, currently we do
not permit world-altering processes to be information-
providing, at least in the sense that they must have
no outputs. This simplification made the system fairly
easy to implement without substantial modification of
SHOP2.

However, mapping information-gathering processes
to so-called book-keeping operators is somewhat un-
aesthetic. In the translation algorithm we described, for
each atomic process that does not have any effects a
book-keeping operator is created with a precondition
that contains the external call to execute the service
and an effect to assert the output results as knowledge effects. The book-keeping operator appears as a
subtask in the method definition that uses the result
of that service. But, these operators are treated specially by SHOP2 and they never appear in the resulting
plans.

It is also possible to directly encode the informationproviding operators in the preconditions of the calling
methods. The external call to service execution would
be put into the methods precondition instead of the
intermediate book-keeping operator. The output of the
information-providing service would be stored in a local variable using SHOP2s assign feature. We dont
need to store results globally since by definition only
the enclosing process should be able to access the results of a subprocess. Using local variables proves to be
a more efficient way to handle outputs since the overall number of facts stored in the current state are not
effected by the information gathering services.

This different encoding technique has some conse-
quences. For example, normally it is possible to define preconditions for information-providing services.
While the book-keeping operators can be used to represent these conditions, the new encoding method does
not keep this information. As far as the correctness
of the plan is concerned, this is not really a prob-
lem. We can directly execute information-providing
services and if the precondition of that service is not satisfied the service will simply fail to execute. Checking
preconditions is more efficient than trying to execute
the service. For typical public information-providing
services, there are no adverse consequences to trying
to execute the services. In a situation where attempting
a information Web Service call was expensive or harm-
ful, we would have to fall back on our prior encoding.

E. Sirin et al. / Web Semantics: Science, Services and Agents on the World Wide Web 1 (2004) 377396

Another issue related to the performance arises
when information gathering and world altering services
are used together inside sequences. For example, an information gathering service may be defined in between
two world altering actions. When this information providing service is encoded in the precondition of the
method it will be evaluated before both of the world
altering services. This will not effect the resulting plan
in any way but may have some impact on the perfor-
mance. If during planning process it turns out that the
first world altering action is not applicable in the current state then the time spent to execute the information
gathering service is wasted.

So far we have only considered the cases where we
explicitly know which services will provide the information needed for the given task. But actually information gathering itself can be seen as another planning
problem [19]. As discussed in the previous section, precondition checking is reduced to query answering on
Semantic Web. If the information required to answer
the query is not present then we can search for the
services who can supply the necessary data. This process can be done as a goal oriented planning process
[19] and SHOP2 could call another planner for this
purpose. It is also possible that information providing services have a hierarchical structure similar to the
world altering ones. Then we can use SHOP2 recursively to first generate a plan for information gathering step, execute this plan to get the information and
then use this information to solve the initial planning
problem.

8. Related work

McIlarith and coworkers [9,12] proposed an approach to building agent technology based on the notion of generic procedures and customizing user con-
straints. They adapt and extend the Golog language
to enable programs that are generic, customizable and
usable in the context of the Web. They augment a ConGolog interpreter that combines online execution of
information-providing services with offline simulation
of world altering services. Our approach is very similar
to this. A general logic-based system has the ability to
do arbitrary reasoning about the theory but in general
we suspect that a logic based approach will not be as
efficient as an HTN planner.

Matskin and Rao [20] applies software synthesis
and composition methods to Web Services composi-
tion. Their work is based on similarities between Web
Service composition and component-based system development in software engineering. They use OWL-S
for service descriptions and adopt Structural Synthesis
Program (SSP) method for automated service composi-
tion. Service composition is based on the inputoutput
information of services components and requires little domain knowledge. This approach treats each service as an atomic entity without inspecting the internal
process model and therefore lacks the ability to reason
about different decompositions in a composite process.
RETSINA [21] is an open multi-agent system that
provides infrastructure for different types of delib-
erative, goal directed agents. RETSINA system includes a planner based on the HTN planning paradigm.
The RETSINA planner also extends HTN planning by
adding interleaving of planning and execution which
basically allows the actions execute before a plan is
completely formed, similar to our approach. Paolucci
et al. [22] describes using RETSINA planner in the
context of creating autonomous Web Services that can
automatically interact with each other. However, authors do not give details about how HTN planning is
employed in the system. It is not clear whether OWL-S
Process Model was used or planning domain was given
a priori to the planner agent. For this reason, we cannot
make a comparison with our approach.

9. Conclusion

In this paper, we have defined a translation from
OWL-S process models to the SHOP2 domains, and
from OWL-S composition tasks to SHOP2 planning
problems. We have described our implemented system which performs this translation, uses an extended
SHOP2 implementation to plan with and over the translated domain, and then executes the resulting plans. In
the process of defining the translation and building the
system, we observed that:
 In our current approach, the planner always executes
output producing actions as it plans. While this is
fine for many situations, it may not always be ap-
propriate. For example, the execution of some Web
Services may take a very long time. It would be better

if the planner could continue to plan while waiting
for this information.
 In our paper, we assume that all effects are physical.
In complex situations, there may be other changes,
such as in the mental states of the agents involved,
that are not modeled. We will explore this problem
in our future work.
 Information providing (whether exclusively so, or
not) is likely to be a significant fraction of the available and salient Web Services. Many Web contexts
seem to be information rich but action poor. In
such environments, we would want to reconsider
the strict partition of services into exclusively information providing and output free. For example,
world-altering services with outputs might supply
information needed to decide subsequent courses of
action. Clearly, such a service should not be executed at planning time, which suggests that we will
need to investigate generating conditional plans by
SHOP2 style HTN planning.

Conditional plans will also help mitigate the constraint on information change during planning. Cur-
rently, both for theoretical and practical reasons, we
only execute an information providing process once
during planning for any given input, and subsequently
retrieve a cached result. Given SHOPs speed, this is
not that unreasonable a restriction for many cases, but
conditional plans would permit planning for various
contingencies.

These considerations raise a host of issues regarding
plan time versus composition execution time execution
of information providing processes, including those of
deciding which such processes to execute only during
planning, only during plan execution, and during both.
Furthermore, in complex, long running planning ses-
sions, it might make sense to refresh the monitors cache
for certain services at intervals. Presumably, OWL-S
descriptions will be enriched to help support the requisite analysis. We intend to explore these issues in future
work.
 Compared the complexities raised above, composite processes raise no additional or special
problemsencoding them as SHOP2 methods
seems correct and straightforward, modulo the need
to extend SHOP2 to handle concurrency.
 Simple processes are the odd duck of the lot. Though
various members of the OWL-S coalition have sug-

gested, in conversation, that simple processes were
intended to sup port HTN planning, we found them
neither necessary, nor convenient, nor useful. In part,
their lack of a clear semantics, particularly with
regard to the relationship of their inputs, outputs,
preconditions, and effects to those of their corresponding atomic or composite processes. Further-
more, while the language of the technical overview
[3] suggests that a given simple process can be a view
of one atomic process or one composite process,
but not both, neither the language nor the ontology
actually require this restriction. We speculated that
this would make simple processes useful for specifying a range of alternative composition paths, but it
was not clear that this was really more convenient
(for our purposes) than using the Choice control
construct.

Acknowledgments

The authors would like to thank Sheila McIlraith
for her insightful comments about the paper. This work
was supported in part by Air Force Research Laboratory grant F30602-00-2-0505. This work was also supported in part by the Army Research Laboratory, the
Defense Advanced Research Projects Agency, Fujitsu
Laboratory of America College Park, Lockheed Martin
Advanced Technology Laboratories, the National Science Foundation, the National Institute of Standards
and Technology, and NTT Corp.
