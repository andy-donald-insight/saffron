Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Distributed reasoning with ontologies and rules in order-sorted logic
programming
Ken Kaneiwa a,, Riichiro Mizoguchi b

a National Institute of Information and Communications Technology, 3-5 Hikaridai, Seika, Soraku, Kyoto 619-0289, Japan
b Osaka University, 8-1 Mihogaoka, Ibaraki, Osaka 567-0047, Japan

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 24 June 2008
Received in revised form 9 May 2009
Accepted 26 May 2009
Available online 6 June 2009

Keywords:
Distributed reasoning
Ontologies and rules
Order-sorted logic
Rigidity
Linear resolution system

Integrating ontologies and rules on the Semantic Web enables software agents to interoperate between
them; however, this leads to two problems. First, reasoning services in SWRL (a combination of OWL
and RuleML) are not decidable. Second, no studies have focused on distributed reasoning services for
integrating ontologies and rules in multiple knowledge bases. In order to address these problems, we
consider distributed reasoning services for ontologies and rules with decidable and effective computation.
In this paper, we describe multiple order-sorted logic programming that transfers rigid properties from
knowledge bases. Our order-sorted logic contains types (rigid sorts), non-rigid sorts, and unary predicates
that distinctly express essential sorts, non-essential sorts, and non-sortal properties. We formalize the
order-sorted Horn-clause calculus for such properties in a single knowledge base. This calculus is extended
by embedding rigid-property derivation for multiple knowledge bases, each of which can transfer rigidproperty information from other knowledge bases. In order to enable the reasoning to be effective and
decidable, we design a query-answering system that combines order-sorted linear resolution and rigidproperty resolution as top-down algorithms.

 2009 Elsevier B.V. All rights reserved.

1. Introduction

Ontologies and rules play an important role in the Semantic Web; they ensure that information available on the World
Wide Web is machine-readable. Markup languages such as RDF
(Resource Description Framework [33]), OWL (Web Ontology Language [41]), and RuleML (Rule Markup Language [1]) have been
developed to model ontologies and rules on the Semantic Web.
Description Logics [5] and DATALOG provide formal semantics
and decidable reasoning services for OWL and RuleML. In partic-
ular, SWRL (Semantic Web Rule Language [26]), a combination of
OWL and RuleML has been proposed to enable software agents
to interoperate between ontologies and rules. However, because
of the expressive power of SWRL, its reasoning services tend to
become undecidable, as shown by Horrocks and Patel-Schneider
[25].

In the Semantic Web context, knowledge bases consisting of
ontologies and rules are widely distributed across multiple sites,
contexts, and domains. To address distributed ontologies, C-OWL
(Context OWL [8]) is used; C-OWL localizes ontologies and allows

 Corresponding author.
E-mail addresses: kaneiwa@nict.go.jp (K. Kaneiwa), miz@ei.sanken.osaka-u.ac.jp

(R. Mizoguchi).

1570-8268/$  see front matter  2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2009.05.003

explicit mappings between two ontologies. However, to the best
of our knowledge, distributed reasoning services for integrating
ontologies and rules have not been developed, although software
agents have their own facts and rules in knowledge bases. To
address these problems, it is necessary to study distributed reasoning services for ontologies and rules to achieve decidable reasoning
through effective computation. In other words, decidability must
be retained even if reasoning for integrated ontologies and rules is
further extended by distributed reasoning services. This is because
a combination of different reasoning services often gives rise to
undecidability or difficulties similar to those observed when using
SWRL.

As an alternative, order-sorted logic [39,12,53,54,3,31,46], which
is an extension of first-order predicate logic, involves many sorts
and their hierarchy (called sort hierarchy). Order-sorted logic has
three advantages: (i) reduction in search space through restrictions
on the domains and ranges of functions, predicates, and variables [5153]; (ii) structural knowledge representation by means
of partially ordered sorts [13]; and (iii) detection of sort errors
in well-sorted formulas [40]. General logical languages represent all formulas, even if some of them contain expressions not
relevant to ontology and knowledge representation. We believe
that well-sorted formulas based on formal ontology ensure that
knowledge bases are as reliable similar to type-checked pro-
grams.

Fig. 1. Ontological property classification.

Table 1
An overview of our algorithms

In formal ontology, entities are essentially classified into prop-
erties, events, processes, objects, and parts; entity relationships
are also formally defined (parthood, dependence, connection, etc.)
[7,45,44]. Upper ontologies that classify properties on the basis of
sortality, rigidity, and identity have been developed by Guarino and
Welty [22]. In Fig. 1[20], properties are subdivided into two cate-
gories: sortal and non-sortal [48,37]. Sortal properties are further
subdivided into essential and non-essential properties.1 Essential
properties are sortal and rigid. Rigidity implies that if an entity
has an essential property, it must have that property in any possible world. For example, if John has the essential property person,
he is always a person. Therefore, every individual with the property person continues to have the essential property. On the other
hand, non-essential properties are sortal and non-rigid. Thus, if an
entity has a non-essential property, it may not have the property at
certain times or in certain situations. For example, if John has the
non-essential property student, he may cease to be a student at any
time in the future even if he is a student at present; i.e., the nonessential property can be regarded as the role of an individual. Such
property classifications [10,30,18] take into account the differences
between sorts and unary predicates in logic. The rigidity of essential
and non-essential properties can be interpreted in terms of possible
worlds; i.e., a property is characterized by whether or not it holds in
a possible world. In this context, we can model properties for different knowledge bases. If a knowledge base is updated, another
property model can exist at that given point of time. Moreover,
if two software agents possess different knowledge bases through
their interoperation between ontologies and rules, there can be two
property models for different beliefs.

In this study, we propose a framework for multiple order-sorted
logic programming where a sort hierarchy corresponds to an ontol-
ogy, and we use property classification (as in formal ontology) to
distinguish rigid properties among knowledge bases. We refine the
syntax and semantics of order-sorted logic by combining it with
the notions of essential sorts, non-essential sorts, and non-sortal
properties [21]. We describe the order-sorted Horn-clause calculus and a linear resolution system for such properties in a single
knowledge base. For multiple knowledge bases, each knowledge
base can extract rigid-property information from other knowledge
bases; this phenomenon is called rigid-property derivation.

Table 1 lists two reasons for the development of the Horn-clause
calculus and the linear resolution system. First, we need to design
both bottom-up and top-down algorithms because each has a distinct advantage. The Horn-clause calculus follows the bottom-up
algorithm, which is easy to design and implement because it uses
intuitive inference rules without unification. However, it is not efficient because the truth of a goal is verified by deriving all the ground
formulas for the worst case. Second, we prove the completeness of
the linear resolution system on the basis of the completeness of the
bottom-up algorithm. The Horn-clause calculus easily generates a
canonical model that proves its completeness; that is, all derivable
formulas correspond to the model. However, the linear resolution
system does not easily generate a canonical model because the resolution steps skip some reasoning redundancies through unification
of terms, i.e., all the ground formulas are not necessary as long as
a goal is derived. As a result, the linear resolution system is more
effective than the Horn-clause calculus.

For the same reasons, a rigid-property resolution system is
designed as an effective top-down algorithm; this algorithm
enables rigid-property derivation for multiple knowledge bases.
To implement the algorithm on a computer, we design a queryanswering algorithm that uses a decidable strategy. This algorithm
terminates under SLD-resolution (selection-rule driven linear resolution for definite clauses) when the Horn-clauses are function-free
(although they can be recursive2).

This paper is organized as follows. In Section 2, we list the
examples that motivated us to present the syntax and semantics
of refined order-sorted logic and reasoning services among multiple knowledge bases. In Section 3, we formalize order-sorted logic
with types, non-rigid sorts, and sort predicates. In Section 4, we
describe the development of the Horn-clause calculus, which we
extend using sorted and unsorted substitutions and inference rules
for sort predicates. We then present a system for the derivation
of rigid properties for multiple knowledge bases. In Section 5, we
describe a decidable query-answering system that incorporates the
resolution systems of order-sorted reasoning and rigid-property
derivation in multiple knowledge bases. In Section 6, we discuss
related research and the contributions of our study to the Semantic Web. Finally, we conclude with a short summary and our future
prospects in Section 7.

1 Guarino and Welty called them s ubstantial properties and non-substantial properties [21]; we use essential instead of substantial in order to avoid evoking the
property possessed by substances.

2 As defined in [35], a predicate p is said to depend on a predicate q if q appears in
the body of a clause whose head is p. A set of clauses is recursive if there is a cycle
in the dependency relation among predicates.

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

Table 2
Rigidity of types, sorts, and unary predicates

To appropriately formalize these notions in logic, we use ordersorted logic with sort predicates [6,28] as a basic language. The
sorted logic contains sort predicates in addition to sorted terms and
formulas, which are useful for expressing the unary predicates p
and p of types  and non-rigid sorts .4 In standard order-sorted
logic, a variable x of sort s is denoted by x : s and a constant c of
sort s is denoted by c : s. Furthermore, we carefully address the
rigidity of types, non-rigid sorts, and unary predicates in sorted
expressions of the logic. In particular, the sorted expressions x : ,
x : , and c :  are allowed, while the sorted expression c :  is not.
For example, x1 : person and x2 : customer are variables of the type
(rigid sort) person and the non-rigid sort customer, respectively, and
john : person is a constant of the type person. However, constants of
non-rigid sorts c : , such as john : customer and john : US-citizen
are meaningless since customer and US-citizen are not rigid for some
humans. In other words, since the elements of non-rigid sorts are
not fixed, an element may not belong to a non-rigid sort in a particular situation. Thus, we are required to use such a non-rigid sort
as a sort of variables x :  and a sort predicate (t) (or p(t)). For
example, we can describe the formulas as
(x : customer)(excellent(x : customer)
 obtaining a discount(x : customer))

and customer(john).

2.2. Reasoning among multiple knowledge bases

Let us consider multi-agent reasoning [16], where multiple
knowledge bases can be assigned to agents. For example, in Fig. 3,
each agent has its own knowledge base as a set of sorted formulas;
all agents also possess and access common taxonomic knowledge
as a conceptual hierarchy of sorts and types. In other words, facts
and rules in each knowledge base represent assertional knowledge
in an agent, context, or application domain; on the other hand, a
sort hierarchy expresses taxonomic knowledge commonly used in
different situations.

In multi-agent reasoning, each agent may be able to transfer
rigid-property information from other agents. As an illustrative
example, we consider the following knowledge bases with the sort
and type hierarchies shown in Fig. 4:

Knowledge base 1:
(1a) male customer(john : person),
(1b) excellent(john : person),
(1c) (x : customer)(excellent(x : customer) 

obtaining a discount(x : customer))

Knowledge base 2:
(2a) pet seller(mary : person),
(2b) (x : customer)(cares about(mary : person, x : customer)),
(2c) (x : bird)(cares about(mary : person, x : bird))
Knowledge base 3:
(3a) canary(peter : animal),
(3b) (x : animal)(bird(x : animal)  canfly(x : animal))

Fig. 2. A sort hierarchy.

2. Motivating examples

2.1. Rigidity of types, sorts, and unary predicates

In a sorted first-order language, each sort hierarchy is constructed as a pair (S,) of a set S of sorts and a subsort relation 
over S. For example, we can define the subsort declarations person 
animal, bird  animal, father  person, and woman  person, which
describe the sort hierarchy in Fig. 2. By using sorts in a hierarchy,
each variable can be restricted by sort s as a subset of the universe.
For example, the domain of the sorted variable x : person is the
set of persons. In sort theory [6,17] and constraint logic [9], the
sorted constant c : s is equivalent to the sort predicate formula s(c),
and the subsort relation s  s
 in a sort hierarchy is represented by
its equivalent implication form x(s(x)  s
(x)) in first-order logic.
This translation motivated us to consider whether sorts and unary
predicates are logically and semantically identical.

Table 2 shows that essential sorts, non-essential sorts, and nonsortal properties correspond to types  [21], non-rigid sorts , and
unary predicates p, respectively. This distinction between properties changes the meaning of instantiation of properties (i.e., term t
is an instance of a property if p(t) is true where p denotes the prop-
erty). From the semantic viewpoint, the instantiation of type (t)
implies that t forever belongs to  since all types are rigid. In con-
trast, the instantiation of a non-rigid sort (t) and unary predicate
p(t) is not always true since non-rigid sorts and unary predicates
are not rigid. For example, let person be a type, student be a nonrigid sort, and happy be a unary predicate. Then, person(john) can
be true at all times, but the truth of student(john) and happy(john)
is variable and depends on the situation. By using our logic, s
ubsumption between properties (i.e., a property subsumes another
property) can be expressed using either of two forms: subsort and

implication. The subsort relations 1 < 2, 1 < 2, and 1 < 2
are declared to be true in all situations, while some of the implication forms x(p1(x)  p2(x)) hold only in some situations. For
example, student < person is true in any situation, but the truth of
x(rich(x)  happy(x)) depends on the situation. Hence, we should
select a subsort relation s1 < s2 if a sort s1 always subsumes another
sort s2. In addition, any relation of the form 1 < 2 (i.e., a type is a
subsort of a non-rigid sort) is not allowed as a subsumption due to
the consideration of rigid and non-rigid properties [22].

3 Let s1, s2 be sorts. s1 < s2 holds if s1 /= s2 and s1 is a subsort of s2.

4 A sort predicate ps is simply denoted by s when this will not cause confusion.

Fig. 3. Multiple knowledge bases with sort and type hierarchies.

only in knowledge base 1 because customer is not rigid. Hence,
(2b) does not lead to cares about(mary : person, john : customer) in
knowledge base 3.

3. Order-sorted logic with rigidity and sort predicates

First, we introduce three classified property expressions: types,
non-rigid sorts, and unary predicates in the syntax and semantics
of order-sorted logic with sort predicates based on [47,43,38].

3.1. Syntax

Definition 1. The alphabet of a sorted first-order language L with
rigidity and sort predicates contains the following symbols:

1. T: a countable set of type symbols 1, 2, . . . including the great-
2. N: a countable set of non-rigid sort symbols 1, 2, . . . with T 

est type 
N = 

3. C: a countable set of constant symbols
4. Fn: a countable set of n-ary function symbols
5. Pn: a countable set of n-ary predicate symbols
6. ,, (, ): the connective and auxiliary symbols
7. Vs: an infinite set of variables x : s, y : s, z : s, . . . of sort s.

We generally call type symbols (denoted , 1, 2, . . .) or nonrigid sort symbols (denoted , 1, 2, . . .) sort symbols (denoted
s, s1, s2, . . .). Namely, T  N is the set of sort symbols. The set of vari-
s TNVs. For all sorts s T  N,
ables of all sorts is denoted by V =
the unary predicates ps  P1 indexed by the sorts s (called sort pred-
icates) are introduced, and the set of sort predicates is denoted by
PTN = {ps|s T  N}. In particular, the predicate p indexed by a
type  is called a type predicate, and the predicate p indexed by
a non-rigid sort  is called an non-rigid sort predicate. In what fol-
lows, we assume that the language L contains all the sort predicates
in PTN.

Definition 2 (Sorted signatures with rigidity). A signature of a sorted
first-order language L with rigidity and sort predicates (called
sorted signature) is a tuple 	 = (T, N,  ,) such that:
1. (T  N,) is a partially ordered set of sorts (called a sort hierar-
chy) where
(a) T  N is the union of the set of type symbols and the set of
(b) each ordered pair is not of the form    (i.e., it is of the form

non-rigid sort symbols in L, and
i  j,   , or k  l);

2.   is a finite set of constant, function, and predicate declarations
such that
(a) if c  C, then there is a unique constant declaration of the form

c :     (which means c :      );

Fig. 4. Sort and type hierarchies in a sorted signature.

Knowledge base 4:
(4a) father(tony : animal, peter : animal),
(4b) (y : animal)(x : animal)(father(y : animal, x :
bird(x : animal)  bird(y : animal))

animal)

Fact (3a) is true in knowledge base 3, and if the subsumption canary < bird holds in the sort and type hierarchies, then
bird(peter : animal) can be derived in knowledge base 3. This is
also true in any other knowledge base since the evaluation of
the type bird does not depend on a particular situation, i.e., it is
rigid. In other words, the elements of the type bird can be propagated (Peter is forever a bird), unlike the elements of the non-rigid
sort customer. Hence, since instantiation as rigid-property information must be true in all situations, we conclude that the fact
bird(peter : animal) is true in knowledge bases 1, 2, and 4. On
the basis of this additional information, knowledge base 2 derives
the new fact cares about(mary : person, peter : animal) from (2c),
which cannot be derived without importing the rigid-property
information. Moreover, from the fact father(tony : animal, peter :
animal) in knowledge base 4, we cannot normally derive whether
Tony is a bird. By transferring the fact bird(peter : animal), we
can use knowledge base 4 to derive bird(tony : animal) (Tony is
a bird) from fact (4a) and rule (4b)5. Therefore, the rigid fact
bird(tony : animal) recursively results in canfly(tony : animal) in
knowledge base 3 and cares about(mary : person, tony : animal)
in knowledge base 2.6 However, when fact (1a) and subsumption male customer < customer hold, customer(john : person) is true

5 In order to guarantee safe reasoning, we assume that rules whose conclusion is a
rigid assertion only contain rigid assertions in their conditions. This holds for unary
and n-ary predicates.

6 First, knowledge base 3 exports rigid-property information to knowledge base 4.
A new fact can then be derived in knowledge base 4; knowledge base 3 then imports
the new fact as rigid-property information from knowledge base 4.

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

(b) if f  Fn, then there is a unique function declaration of the
form f : 1    n     ;
(c) if p Pn, then there is a unique predicate declaration of the
form p : s1    sn    (in particular, for all sort predicates
ps  PTN, ps :   ).

The declarations in   determine the domains and ranges of
constants, functions, and predicates. The domains and ranges of
constants and functions are required to be rigidly sorted. Specif-
ically, constant and function declarations are defined by types i
in order to avoid the non-rigid domains and ranges of constants
and functions. In contrast, predicate declarations are defined by any
sorts si (types or non-rigid sorts) since the domains of predicates
can be non-rigid. In the following example, we will show constant
and function declarations that are defined by types and non-rigid
sorts.

Example 1 (Rigidity of constants and functions). Consider a sorted
signature that contains the subsort relation student  person, the
constant and function declarations:
john : person  
father : person  person  
for john C, father  F1, and person T, and the predicate declara-
tion:
getting a scholarship : student   
for getting a scholarship P1 and student  N. The sorted signatures
exclude the following declarations of unrigidly sorted constants and
functions as sort errors:
john : student   
father : person  teacher   
for student, teacher  N give rise to the sorted terms7:
john: student
father (john: student): teacher.

The first expresses the constant john of the non-rigid sort student,
and the second represents the function father with the argument
john : student the range of which is the non-rigid sort teacher. These
expressions contain ill-sorted errors because the sorts student and
teacher are not rigid for some humans.

The restriction of a sort hierarchy to types is a partially ordered
set of types and called a type hierarchy. The type hierarchy in a
sorted signature corresponds to the backbone taxonomy consisting
only of rigid properties [55]. Based on the definition of subsumption relation in [22], any relation of the form    is not allowed in
the sort hierarchy, since although types  are rigid, non-rigid sorts
 are not rigid. It should be noted that Kaplan [30] pointed out
that Guarino and Weltys formulation of subsumption was incorrect or inconsistent. More precisely, he proved that it is possible
for a non-rigid property to subsume a rigid one, given Guarino and
Weltys definitions of rigid, non-rigid, and subsumption. If p subsumes q is formalized by x(q(x)  p(x)), this undesired analysis
is derived. However, as mentioned by Kaplan, if the subsumption
is formalized by (x)(q(x)  p(x)), the condition that an non-rigid
property cannot subsume a rigid one necessarily is correct. There-
fore, we support the necessary subsumption in the semantics that
will be defined latter (in Definition 9).

7 Note that if john : student is declared in  , john : student is a term of the sort
person because student is a subsort of person (i.e., student  person).

Next, we define terms, atoms (atomic formulas), goals, and
clauses of a sorted first-order language with rigidity and sort pred-
icates.
Definition 3 (Sorted terms). Let 	 = (T, N,  ,) be a sorted signa-
ture. The set Ts of terms of sort s is defined by the following:

  Vs and s

  s, then x : sTs.

 of sort s if s

1. If x : s
2. If c  C, c :    , and   s, then c :  Ts.
3. If t1 T1 , . . . , tn Tn , f  Fn, f : 1    n     , and   s,

then f (t1, . . . , tn) :  Ts.
Note that Ts contains not only terms of sort s but also terms of
  s. For example, let person, animal be types
subsorts s
and let person  animal   . Then, john : person belongs to the set
Tanimal of terms of the sort animal and its subsorts. The set of terms of
all sorts is denoted by T =
Ts. The function sort is a mapping
from sorted terms to their sorts, defined by (i) sort(x : s) = s, (ii)
sort(c : ) = , and (iii) sort(f (t1, . . . , tn) : ) = .
Definition 4. The function Var : T  2V is defined by the follow-
ing:
1. Var(x : s) = {x : s},
2. Var(c : ) =  for c  C,
3. Var(f (t1, . . . , tn) : ) = Var(t1)    Var(tn) for f  Fn.

s TN

A sorted term is called ground if its set of variables is empty. T0 =
{t T|Var(t) = } is the set of sorted ground terms. The set of ground
terms of sort s is denoted by T0,s = T0  Ts. In order to provide a rule
language, we restrict the set of possible formulas to Horn-clauses
[36,14] but it can be extended by full formulas.
Definition 5 (Sorted formulas). Let 	 = (T, N,  ,) be a sorted sig-
nature. The set A of atoms, the set G of goals, and the set C of clauses
are defined by the following:

t1 Ts1 , . . . , tn Tsn , p Pn, and p : s1    sn   ,

p(t1, . . . , tn)A.

1. If
2. If L1, . . . , Ln A(n  0), then {L1, . . . , Ln}G.
3. If G G and L A, then L  G C.

then

An atom ps(t) with a sort predicate is simply denoted by s(t)
when this will not cause confusion. A clause L  G is denoted by
L  if G = . The function Var is extended to atoms, goals, and
clauses, i.e., for each eA  G  C, Var(e) denotes the set of variables
occurring in e.
Example 2. Let us consider the sorted signature 	 = (T, N,  ,)
such that
T = {male, person, canary, bird, animal,},
N = {pet seller, customer, male customer},
  = {john : person, mary : person, peter : animal, tony :

 animal, excellent : person, cares about : animal  ,
obtaining a discount : customer, father :   ,
canfly : }  {ps : |s T  N},

<= {(canary, bird), (bird, animal), (animal,), (person, animal),
(male, animal), (male customer, male), (pet seller, person),
(customer, person), (male customer, customer)},
and  is the reflexive and transitive closure of <. This sorted signature declares the sort and type hierarchies in Fig. 4. The expressions:

customer(john : person) ,
canfly(x : animal)  {bird(x : animal)}
are clauses in the sorted first-order language.

We define a sorted substitution such that each sorted variable

x : s is replaced with a well-sorted term in Ts.
Definition 6 (Sorted substitution). A sorted substitution is a partial function 
 : V  T such that 
(x : s)Ts  {x : s} and Dom(
) is
finite.

Moreover, an unsorted substitution is defined as a substitution
that operationally ignores the sort of each variable, which may lead
to ill-sorted terms.

Definition 7 (Unsorted substitution). An unsorted substitution is a
partial function 
u : V  T such that if 
u(x : s) is defined then it
belongs to Ts  {x : s}, and Dom(
) is finite.

For example, for customer  person, 
u(x : customer) = john :
person is an unsorted substitution, but not a sorted substitution.
Each of the sorted and unsorted substitutions can be represented
by {x1 : s1/t1, . . . , xn : sn/tn}. Let 
 be a sorted substitution. 
 is said
to be a sorted ground substitution if for every variable x : s Dom(
),

(x : s) is a sorted ground term. Similarly, these notions are defined
for unsorted substitutions 
u.

Definition 8. Let  be a sorted substitution 
 or an unsorted substitution 
u. The term t is defined by the following:
1. x : s = (x : s) if x : s Dom(),
2. x : s = x : s if x : s / Dom(),
3. c :  = c : ,
4. (f (t1, . . . , tn) : ) = f (t1, . . . , tn) : ,

Note that the substitution  in statements 2 and 3 does not anything for the term t because the sorted variable x : s does not belong
to the domain Dom() or the term t is a sorted constant. More-
over, the substitution  in statement 4 is inductively defined for the
sorted variables occurring in the functional term f (t1, . . . , tn) : .
For instance, let  be a sorted substitution with (x : s) = c2 : s1 and
s1  s. The functional term (f (x : s, c2 : s2) : 1) can be substituted
with f (c1 : s1, c2 : s2) : 1 if x : s Dom() (but there is no condition
for 1). In the usual manner of first-order logic, sorted and unsorted
substitutions are extended to atoms, goals, and clauses. Let E be an
expression, 
 be a sorted substitution, and 
u be an unsorted sub-
stitution. The application of a sorted (unsorted) substitution to E is
denoted by E
 (E
u).
Let t be a sorted term. The substituted term t
u is an ill-sorted
term if t
u / T. If t

u is
also an ill-sorted term. The ill-sorted expressions are more generally
defined as follows. Let E T  A  G  C. The substituted expression
E
u is an ill-sorted expression if E
u / T  A  G  C. If E
 is an ill-

u is an ill-sorted
sorted expression and E
expression. The set of sorted and ill-sorted terms, the set of sorted
and ill-sorted atoms, the set of sorted and ill-sorted goals, and the
set of sorted and ill-sorted clauses are denoted by T+, A+, G+, and
C+, respectively.

 is an ill-sorted term and t


u / T  A  G  C, then E


u / T, then t

Definition 9 (	-model). Let 	 be a sorted signature. A 	-model M
is a tuple (W, U, I) such that

1. W is a non-empty set of worlds,
2. U is a non-empty set of individuals,
3. I = {Iw|w  W} is the set of functions Iw for all worlds w  W with

the following conditions:
(a) if s T  N, then Iw(s)  U (in particular, Iw() = U),
(b) if si  sj for si, sj  T  N, then Iw(si)  Iw(sj),
(c) if c  C and c :    , then Iw(c) Iw(),
(d) if f  Fn and f : 1    n     , then Iw(f ) : Iw(1) 
(e) if p Pn and p : s1    sn   , then Iw(p)  Iw(s1)   

  Iw(n)  Iw(),

Iw(sn).

In the semantics, statement 3-(b) (i.e., Iw(si)  Iw(sj) holds
for all worlds w  W) corresponds to the necessary subsumption
(x)(q(x)  p(x)), whose validity was proven by Kaplan [30].

Moreover, by restricting 	-models, we give the class of rigid

	-models as follows.

Definition 10 (Rigid 	-model). Let 	 be a sorted signature. A rigid
	-model is a 	-model M = (W, U, I) such that for all wi, wj  W,
  T, c  C, and f  F, Iwi () = Iwj (), Iwi (c) = Iwj (c), and Iwi (f ) =
Iwj (f ).
In what follows, we will deal with rigid 	-models M = (W, U, I)

that satisfy the following condition:
 If s T  N, then Iw(s) = Iw(ps).

This condition drives that if si  sj, then Iw(psi )  Iw(psj ). In the
	-models, the interpretation of sorts s is equivalent to the interpretation of the sort predicates ps.

Definition 11 (Variable assignment). Let 	 be a sorted signature. A
variable assignment on a rigid 	-model M = (W, U, I) is a function
 w : V  U where  w(x : s) Iw(s).

We define an interpretation of sorted and ill-sorted terms (in

We define  w[x : s/d] by ( w  {(x : s,  w(x : s))})  {(x : s, d)}.
In other words, if v = x : s, then  w[x : s/d](v) = d, and otherwise
 w[x : s/d](v) =  w(v). A rigid 	-interpretation I is a pair (M,  ) of
a rigid 	-model M and a set of variable assignments   = { w|w  W}
on M. Let I = (M,  ). The rigid 	-interpretation (M,    { w} 
{ w[x : s/d]}) is denoted by I w[x : s/d].
T+) as follows.
Definition 12.
denotation function 
=  w(x : s),
1. x : s
= Iw(c),
2. c : 
3. f (t1, . . . , tn) : 

Let I = (M,  ) be a rigid 	-interpretation. The

w,  : T+  U is defined by the following:

w, 

w, 

w, 

Let E be a sorted or ill-sorted expression. The substitution 

(resp. 
u) is a sorted ground substitution (resp. unsorted ground
substitution) for E if E
 (resp. E
u) is ground and dom(
) = Var(E)
(resp. dom(
u) = Var(E)). The composition 
1
2 of sorted substitutions 
1 and 
2 (resp. unsorted substitutions 
u
2) is defined
by (x : s)
1
2 = ((x : s)
1)
2 (resp. (x : s)
u
1)
u
2).

1 and 
u
= ((x : s)
u

1
u


Iw(f )(t1

w, , . . . , tn

w, )


w, 

t1

 Iw(1), . . . ,

 Iw(n) and

if
tn
f : 1    n     
otherwise.

w, 

3.2. Semantics

The semantics of order-sorted logic with rigidity and sort
predicates is defined over possible worlds. This characterizes the
rigidity of types and non-rigid sorts by interpreting them in each
world.

The satisfiability of sorted and ill-sorted atoms, goals, and
clauses are defined for a rigid 	-interpretation I and a world w  W.
Definition 13 (Rigid 	-satisfaction relation). Let I = (M,  ) with
M = (W, U, I) be a rigid 	-interpretation, let F A+  G+  C+, and
let w  W. The rigid 	-satisfaction relationI, w  F is defined inductively as follows:

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

w, ) Iw(p).

w, , . . . , tn

1. I, w  p(t1, . . . , tn) iff (t1
2. I, w  {L1, . . . , Ln} iff I, w  L1, . . . ,I, w  Ln.
3. I, w  L  G iff

for all d1  Iw(s1), . . . , dn  Iw(sn), I w[x1 :
I w[x1 : s1/d1, . . . , xn :

s1/d1, . . . , xn : sn/dn], w  G implies
sn/dn], w  L where Var(L  G) = {x1 : s1, . . . , xn : sn}.
Let  be a set of formulas in A+  G+  C+. We write I, w   if,
for every formula F   , I, w  F. A formula F is said to be rigid 	-
satisfiable if for some rigid 	-interpretationI and world w,I, w  F.
Otherwise, it is rigid 	-unsatisfiable. F is a consequence of  in the
class of rigid 	-interpretations (denoted   F) if for each rigid
	-interpretation I and w  W, I, w   implies I, w  F.
Let I = (M,  ) with M = (W, U, I) be a rigid 	-
Lemma 1.
interpretation, L  G be a clause in C+, 
 be a sorted substitution, and
let w  W. If I, w  L  G, then I, w  (L  G)
.
Var(L  G) = {x1 : s1, . . . , xn : sn}.
Proof.
By
d1  Iw(s1), . . . , dn  Iw(sn),
I w[x1 :
Definition
all
I w[x1 : s1/d1, . . . , xn :
s1/d1, . . . , xn : sn/dn], w  G
implies
 Iw(s

sn/dn], w  L.
where
Let
1), . . . , d

Var((L  G)
) = {y1 : s
}.

have
1, . . . , ym : s
Then,

w,   Iw(s1), . . . , 
(xn : sn)
w,   Iw(sn)

(x1 : s1)

   { w}  { w[y1 : s
m]}


(x1 :
1, . . . , ym : s
m/d
1/d
s1), . . . , 
(xn : sn) are well-sorted terms of sorts s1, . . . , sn. This
derives I, w  (L  G)
. 
Example 3. Given the sorted signature 	 = (T, N,  ,) of
Example 2, we consider a rigid 	-model M = (W, U, I) such that

m)
we
for

 Iw(s

because

Let

13,

for

W = {w1, w2, w3, w4},
U = {j, m, t, p},
I = {Iw1 , Iw2 , Iw3 , Iw4

where for i  i  4,
Iwi (tony) = t,
Iwi (peter) = j, Iwi (person) = {j, m}, Iwi (animal) = {j, m, t, p}, for each
sj  sk, Iwi (sj)  Iwi (sk), and Iw1 (male customer) = Iw1 (excellent) =
Iw1 (customer) = Iw1 (obtaining a discount) = {j}.

Iwi (mary) = m,

Iwi (john) = j,

Then, we have the following rigid 	-satisfaction relation.

Definition 14 (Knowledge base). Let 	 = (T, N,  ,) be a sorted
signature. A knowledge base K is a finite set of sorted clauses
in 	.

Let 
u be an unsorted substitution. We define the function
(
u) = {x : s/t  
u|t / Ts} in order to obtain the ill-sorted operations from 
u.

In the following, we define inference rules for Hornclause calculus with sorted and unsorted substitutions. This
extended calculus can derive syntactically ill-sorted expressions by applying unsorted substitutions, but
the derived
ill-sorted expressions are semantically well-sorted in the rigid
	-models.

Definition 15 (Sorted Horn-clause calculus). Let C be a sorted or
ill-sorted ground clause and K be a knowledge base. A derivation
of C from K (denoted K  C) in the sorted Horn-clause calculus is
defined as follows:

  {L}, then K  L

 Sorted substitution rule: Let L  G K and 
 be a sorted ground
substitution for L  G. Then, K  (L  G)
.
 Cut rule: Let L  G and L
  {L} be ground clauses. If K  L 
G and K  L
  G  G

 Subsort rule: Let ps(t)  G and ps (t)  G be ground clauses. If
K  ps(t)  G and s  s
, then K  ps (t)  G.
 Type predicate rule: Let t be a sorted ground term in T. If sort(t) 
, then K  p(t) .
 Unsorted type predicate rule: Let t be a sorted term in T, let

u be an unsorted ground substitution for t where (
u) = {x1 :
s1/t1, . . . , xn : sn/tn}, and let psi (ti)  Gi be a ground clause. If
sort(t)   and K  ps1 (t1)  G1, . . . ,K  psn (tn)  Gn, then K 
p(t
u)  G1    Gn.
 Unsorted substitution rule: Let L  G K, let 
u be an unsorted
ground substitution for L  G where (
u) = {x1 : s1/t1, . . . , xn :
sn/tn}, and let psi (ti)  Gi be a ground clause. If K  ps1 (t1) 
G1, . . . ,K  psn (tn)  Gn, then K  (L  G  G1    Gn)
u.

I, w1  obtaining a discount(x : customer)
 {excellent(x : customer)}
I, w1  obtaining a discount(john : person)
I, w2  animal(john : person)

4. Knowledge base reasoning with rigid properties

This section develops two knowledge base reasoning systems for
our order-sorted logic. We first extend the Horn-clause calculus [23]
for a single knowledge base by incorporating sorted and unsorted
substitutions and inference rules of type predicates. Second, using
the calculus, we develop a rigid-property derivation system for
many separated knowledge bases.

4.1. Extended Horn-clause calculus

Each knowledge base is constructed by a finite set of sorted

clauses (i.e., ill-sorted expressions are excluded) as follows.

We write K  L if K  L . The sorted substitution rule and the
cut rule serve as sorted inference rules in ordinary order-sorted
logic. The subsort rule actualizes an inference of the implication form ps(t)  ps (t) with respect to the subsort relation s <
. The type predicate rule derives axioms p(t) of type predi-

cates with sort(t)  . For example, animal(john : person) is valid
if person  animal. Furthermore, the unsorted type predicate and
unsorted substitution rules are unsorted variants of the type
predicate and sorted substitution rule respectively. These inference rules are based on the sorted resolution system with sort
predicates in [6]. In order to deal with the rigidity of sorts, we
distinguish types and non-rigid sorts in the calculus. In partic-
ular, the unsorted type predicate rule and unsorted substitution
rule are necessary for reasoning over non-rigid sorted terms. For
a non-rigid sort customer  N, if customer(john : person) is true,
then x : customer can be unsortedly substituted with a sorted term
john : person, while the sort of john : person is not a subsort of cus-
tomer.

Suppose we have the sorted signature 	 =
Example 4.
(T, N,  ,) of Example 2. Consider the following knowledge bases
K1,K2,K3, and K4:

K1 = {male customer(john : person) , excellent(john : person) , obtaining a discount(x : customer)  {excellent(x : customer)}}
K2 = {pet seller(mary : person) , cares about(mary : person, x : customer) , cares about(mary : person, x : bird) }
K3 = {canary(peter : animal) , canfly(x : animal)  {bird(x : animal)}}
K4 = {father(tony : animal, peter : animal) , bird(y : animal)  {bird(x : animal), father(y : animal, x : animal)}}

Fig. 5. An example of derivations.

Fig. 5 shows derivations from K1 and K3 in the sorted Horn-clause
calculus. In the first, we can derive the ill-sorted expression

obtaining a discount(john : person)
where for person T,
customer  N, person / customer, and
obtaining a discount : customer   . This conclusion is obtained by
an application of the unsorted substitution rule to the clauses
customer(john : person) ,
obtaining a discount(x : customer)  {excellent(x : customer)}
with the unsorted substitution

u = {x : customer/john : person}.

We show the soundness and completeness of the Horn-clause

calculus as follows.
Theorem 1 (Soundness of Horn-clause calculus). Let K be a knowledge base and L be a sorted or ill-sorted ground atom. If K  L, then
K  L.
Proof. This is proven by induction on the height n of a derivation tree of K  L. Let I = (M,  ) with M = (W, U, I) be a rigid
	-interpretation and let w be a world in W.
Base case: n = 0. We have K  L if L  K. So, I, w  K implies
I, w  L.

Induction step: n > 0. The ground atom L is derived by some

w, 


applications of inference rules.
 Sorted substitution rule. We have L  G K and 
 be a sorted
ground substitution for L  G. So, I, w  L  G. By Lemma 1,
I, w  (L  G)
.
 Type predicate rule. We have sort(t)   where t is a sorted ground
 Iw() because t is a well-sorted term in T. So,
term. So, t
I, w  p(t).
 Cut rule. Because K  L  G and K  L
  {L}, by induction
hypothesis, I, w  L  G and I, w  L
  {L}. Hence, I, w 
L  G  G
 Subsort rule. Because K  ps(t)  G and s < s
, by induction
hypothesis, I, w  ps(t)  G where Iw(s)  Iw(s
). Thus, I, w 
ps (t)  G.
 Unsorted
sort(t)  
and
K  ps1 (t1)  G1, . . . ,K  psn (tn)  Gn, by induction hypoth-
I, w 
esis,
G1    Gn,
then I, w  ps1 (t1), . . . ,I, w  psn (tn). Now we
want to show I, w  p(t
u) where 
u is an unsorted ground
If
substitution for
t = c : s,
then t
If
t = x : s and x : s / {x1 : s1, . . . , xn : sn}, then t
u
 Iw().
Iw(s)  Iw().
then
so
If

u(xi : si)
Then,
If
 where f : 1    r  
t = f (a1, . . . , ar) : 
, by Definition

t and (
u) = {x1 : s1/t1, . . . , xn : sn/tn}.
 Iw(). This is because sort(t)  .
sort(t) = s  
= ti

I, w  ps1 (t1)  G1, . . . ,I, w  psn (tn)  Gn.

 Iw(s)  Iw()  Iw(p).

t = xi : si,

predicate

Since

rule.

type

and

w, 

w, 

w, 

w, 

If


w, 

w, 

w, 

By

a1

 Iw(

f (a1, . . . , ar) : 

 Iw(1), . . . , ar

 Iw(r). By Definition 9-3-
12,
)  Iw()  Iw(p).
Hence,
(d),
I, w  p(t
u). Therefore, I, w  p(t
u)  G1    Gn.
 Unsorted substitution rule. We have K  ps1 (t1)  G1, . . . ,K 
psn (tn)  Gn.
I, w  ps1 (t1) 
G1, . . . ,I, w  psn (tn)  Gn. If I, w  (G  G1    Gn)
u, then
I, w  ps1 (t1), . . . ,I, w  psn (tn). L  G K implies I, w  L  G.
1), . . . , dk  Iw(s
k), I w[y1 : s

So,
1/d1, . . . , yk :
I w[y1 : s

k/dk], w  L
k/dk], w  G
1/d1, . . . , yk : s

where Var(L  G) = {y1 : s
}. Similar to the proof

1, . . . , yk : s
of the unsorted type predicate rule, I, w  (L  G  G1  

 Gn)
u. 

for all d1  Iw(s

hypothesis,

induction

implies

s TN

s TN

Let 
 be a sorted substitution and C be a sorted clause. C

is called a sorted instance of C. The set of all sorted ground

instances of C is denoted by ground(C). We write ground(K) for
C Kground(C). The set of derivable sorted and ill-sorted terms
for sort s in K is defined as {t|K  ps(t)}. We define the set of deriv-
{t|K  ps(t)}. The set of rigid
able terms for all sorts in K by
derivable sorted and ill-sorted terms for sort s in K is defined
as {t|KSps(t)}. We define the set of rigid derivable terms for all
{t|KSps(t)}. To prove the completeness of
sorts in K by
the Horn-clause calculus and the rigid-property derivation sys-
tem, we construct a Herbrand model for a finite set of knowledge
bases.
Definition 16 (Herbrand model). Let S = {K1, . . . ,Km} be a finite
set of knowledge bases. A Herbrand model (resp. rigid Herbrand
model) MH for S is a tuple (WS, UH, IH) such that
1. WS = {wK1 , . . . , wKm
2. UH = {t|Ki  ps(t)
3. IH = {IwK

{t|KiSps(t)
|wK
the following conditions:
(s) = {t|Ki  ps(t)} (resp. IwK
(a) IwK
(b) if c  C and c :    , then IwK

(c) if

(resp.
for Ki S, s T  N}),
 WS} is the set of functions for all wK
(s) = {t|KSps(t)}),
(c) = c : ,
f : 1    n     ,

},
for Ki S, s T  N}

UH =
 WS with

and

(f )(t1, . . . , tn) = f (t1, . . . , tn) :  where

tk  IwK

f  Fn
IwK
for 1  k  n,

p Pn

(d) if

then
(k)

then

and

(p) = {(t1, . . . , tn) IwK

IwK
p(t1, . . . , tn) (resp.KiSp(t1, . . . , tn))}.

p : s1    sn   ,
(sn)|Ki 

(s1)    IwK

A (rigid) Herbrand interpretation IH for S is a pair (MH,  ) such
that MH is a (rigid) Herbrand model for S and   is a set of variable
assignments on MH. Let L  G be a clause with Var(L  G) = {x1 :
s1, . . . , xn : sn}. We define ground
(L  G) as the set of sorted and

ill-sorted ground clauses (L  G)
u with 
u = {x1 : s1/t1, . . . , xn :

sn/tn} where Ki  psk (tk) for 1  k  n.

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

Note that many worlds wK1 , . . . , wKm in the Herbrand model are
not necessary to show the completeness of the Horn-clause calculus for a single knowledge base K, but they are used to prove
the completeness of rigid-property derivation for a finite set S =
{K1, . . . ,Kn} of knowledge bases. To avoid introducing additional
semantics, the Herbrand model with many worlds is employed as
a unified model in the proofs of completeness for both. We show
that a (rigid) Herbrand interpretation is a rigid 	-interpretation for
each knowledge base Ki in S.
Let S = {K1, . . . ,Kn} be a finite set of knowledge bases.
Lemma 2.
Let IS be a Herbrand interpretation for S and L  G be a clause. Then,
IS has the following properties:

1. IS, wK
 ground

2. IS is a rigid 	-i nterpretation such that IS, wK

 L  G if and only if IS, wK

(L  G).
 Ki.

Proof.

(L  G), IS, wK

1. () Let L  G be a clause with Var(L  G) = {x1 : s1, . . . , xn :
sn}. Let 
u = {x1 : s1/t1, . . . , xn : sn/tn} be a sorted or illsorted substitution such that (L  G)
u  ground
(L  G). By

Definition 16, we have t1  IwK
(s1), . . . , tn  IwK

(sn). Hence,
 (L  G)
u. () Let 
 be a sorted ground substitution
IS, wK
for Var(L  G). So, (L  G)
  ground(L  G). By the assumption and ground(L  G)  ground
 (L  G)
.
 L  G.
By Definition 16, IS, wK
2. We show that IS is a rigid 	-interpretation. By Definition 16, the
conditions 1,2,3-(a) and 3-(e) of rigid 	-models (Definition 9)
hold. The condition 3-(c) is shown by the following. If c  C and
c :    , then we have IwK
(c) = c :  (by Definition 163-(b)).
By the type predicate rule in the Horn-clause calculus, Ki  p(c :
). So, by Definition 163-(a), c :   IwK
().
The conditions 3-(b) and 3-(d) can be shown by the subsort rule
and unsorted type predicate rule. Furthermore, by the definition of T0,s and Definition 16, we can derive that IS is a rigid
	-interpretation.

(). Thus, IwK

(c) IwK

  ground

Next, we prove that IS, wK

(L  G). Let L

. By definition of ground

 Ki. Let L  G Ki where
Var(L  G) = {x1 : s1, . . . , xn : sn}. So we want to show IS, wK

(L  G). So, there is an

ground
unsorted ground substitution 
u = {x1 : s1/t1, . . . , xn : sn/tn} such

(L  G), Ki 
that (L  G)
u = L
psk (tk) for 1  k  n. Suppose IS, wK
 {L1, . . . , Ln}
u where G =
{L1, . . . , Ln}. By Definition 16, Ki  L1
u, . . . ,Ki  Ln
u. Then, Ki 
(L  {L1, . . . , Ln})
u (by the unsorted substitution rule and Ki 
psk (tk) for 1  k  n). By the cut rule, Ki  L
u. Hence, by Definition
 (L  G)
u. By the first state-
16, IS, wK
 L
u. Therefore, IS, wK
 L  G. 
ment in Lemma 2, we obtain IS, wK

The Herbrand model and the above lemma will be used to show

the completeness of the Horn-clause calculus as follows.
Theorem 2 (Completeness of Horn-clause calculus). Let K be a
knowledge base and L be a sorted or ill-sorted ground atom. If K  L,
then K  L.

Assume that K is a particular knowledge base in a
Proof.
finite set S = {K1, . . . ,Kn} of knowledge bases. So, by Definition
16, a Herbrand Model can be constructed for S in order to
obtain a rigid 	-interpretation such that IS, wK  K. By Lemma
2, IS, wK  K. Hence, we have IS, wK  L. If L = p(t1, . . . , tn), then
(t1, . . . , tn) IwK
(p). Therefore, K  p(t1, . . . , tn) by the condition
3-(a) of Definition 16. 

4.2. Rigid-property derivation in knowledge bases

 K1, . . . ,I, wKn

In general, the conclusions in each knowledge base are not
derivable from another knowledge base since knowledge bases are
separately constructed for their respective situations. Nevertheless,
each knowledge base can derive something from the rigid-property
information in other knowledge bases. In order to elaborate on
this idea, we present a derivation system of rigid properties in a
finite set of knowledge bases called a rigid-property derivation sys-
tem.
Let S = {K1, . . . ,Kn} be a finite set of knowledge bases, where
K1, . . . ,Kn have the same sorted signature 	. A rigid 	-model M =
(WS, U, I) is said to be a rigid 	-model for S if WS = {wK1 , . . . , wKn

is the set of knowledge base worlds of K1, . . . ,Kn. When we determine the consequence Ki  L, we will consider only rigid 	-models
having one world for each Ki in S. We denote KiSF if for every
rigid 	-interpretation I for S, I, wK1
 Kn imply
I, wK
 F. Let us denote the set of sorted and ill-sorted ground
|K  L}.
atoms by A+
In order to define rigid-property derivation, an expansion of
knowledge bases is introduced. The expansion of each knowledge
base is obtained from other knowledge bases by propagating rigidproperty information.
Definition 17 (Expansion of knowledge bases). Let S = {K1, . . . ,Kn}
be a finite set of knowledge bases. The expanded knowledge bases
i of Ki in S are defined by the following:
Km
= Ki
K0
Km+1
where 	(X) = {p(t)A+

0 . We define the theory of K as Th(K) = {L A+

and p(t) X}
Each knowledge base Ki is expanded to K0

i , . . . by adding
rigid atomic formulas p(t) derivable in one of the knowledge
basesK1, . . . ,Kn S. Using this expansion, we define rigid-property
derivation in a finite set of knowledge bases.
Definition 18 (Rigid-property derivation in S). Let S = {K1, . . . ,Kn}
be a finite set of knowledge bases. A ground clause L  G is derivable from Ki in S (denoted KiSL  G) if there exists an expanded
knowledge base Km

1 )    Th(Km
n ))

i of Ki such that Km

 	(Th(Km

 L  G.

i ,K1

|  T

= Km

We will show the soundness and completeness of the rigid-

 Km

 Km+1

, . . . ,I, wKn

1 , . . . ,I, wKn

property derivation system as follows.
Lemma 3. LetS = {K1, . . . ,Kn} be a finite set of knowledge bases and
I be a rigid 	-interpretation for S. If I, wK1
 Km
n ,
 Km+1
then I, wK1
Let I = (M,  ) be a rigid 	-interpretation for S.
Proof.
Let x {1, . . . , n}. By Definition 17, Km+1
= Km
1 ) 
 	(Th(Km
  Th(Km
 L}, I, wK1
x ) = {L|Km
n )). By Theorem 1 and Th(Km

n ). Let p(t) 	(Th(Km
1 )    Th(Km
Th(Km
n )).
such that p(t) Th(Km
Then, there exists Km
l ). By assumption
and the soundness of the Horn-clause calculus, I, wK
 p(t). So,
() because I is a rigid 	-interpretation. Then, by

Definition 10(saying that for all wi, wj  W, Iwi () = Iwj (), Iwi (c) =
Iwj (c), and Iwi (f ) = Iwj (f )), t
 p(t).
Therefore, we have I, wKx

 IwKx (). Hence, I, wKx

1 ), . . . ,I, wKn

wKx , 
 Km+1

 Th(Km

 IwK

wK

The soundness of the rigid-property derivation system can be

derived by Lemma 3.
Theorem 3 (Soundness of rigid-property derivation). Let S =
{K1, . . . ,Kn} be a finite set of knowledge bases and L be a sorted or
ill-sorted ground atom. If KiSL, then KiSL.
Proof.
base Km

By Definition 18, there exists an expanded knowledge
i of Ki such that Km
 L (by Theorem

 L. So we have Km

 Km

 Kn(= K0

n). By Lemma 3, I, wK1

 K1(=
1 , . . . ,I, wKn

 L. Therefore, we obtain the conclusion. 

1). Let I be a rigid 	-interpretation for S. Assume I, wK1
1), . . . ,I, wKn
K0
Km
n . Hence, I, wK
Let L  G be a clause with Var(L  G) = {x1 : s1, . . . , xn : sn}.
(L  G) as the set of sorted and

We now define rigid- ground

ill-sorted ground clauses (L  G)
u with 
u = {x1 : s1/t1, . . . , xn :

sn/tn} where KiSpsk (tk) for 1  k  n.
Let S = {K1, . . . ,Kn} be a finite set of knowledge bases.
Lemma 4.
Let IS be a rigid Herbrand interpretation for S and L  G be a clause.
Then, the following statements hold:

 L  G if and only if IS, wK

1. IS, wK
2. IS is a rigid 	-interpretation of Ki such that IS, wK

 rigid  ground

 Ki.

(L  G).

Proof.

can be shown in the similar way to the proof of Lemma 2.

(L  G), this

1. By Definition 16 and the definition of rigid- ground

2. First of all, we have to show that the derivation  in the
Horn-clause calculus can be applied to the rigid-property derivation S. Namely, if Ki  A1, . . . ,Ki  An derives Ki  B in an
inference rule, then KiSA1, . . . ,KiSAn derives KiSB. Suppose
KiSA1, . . . ,KiSAn. For each Al, there exists an expanded knowl-
 Al (by Definition 18). Thus, if
edge base Kml
mk  mj for 1  j  n, thenKmk

B. Therefore, KiSB.

i of Ki such that Kml

 An. Hence,Kmk

 A1, . . . ,Kmk

(c) = IwK

() = IwK

(), (2) IwK

(c) and (3) IwK

 p(t) where Km

By the above claim and the same way of the proof of
Lemma 2, we can show that IS is a rigid 	-interpretation such
 Ki. Furthermore, we have to prove that IS is a
that IS, wK
rigid rigid 	-interpretation, i.e., for each two worlds wK
i , wK
j ,
(f ) = IwK
(1) IwK
(f ).
(1) let t  IwK
(). By definition, KiSp(t). So, by Definition 18,

Km
is an expanded knowledge base of Ki.
This derives p(t) Th(Km
i ). By Definition 17, p(t)Km+1
. Then,
()(= {t|KiSp(t)}). (2) let c :
Km+1
   . Then,
(c) (by Definition 16). (3) let
f : 1    n     . Because Iwi () = IwK
() for each   T,
(f )(t1, . . . , tn)
we have IwK
where tk  IwK

 p(t). Therefore, t  IwK
Iwi (c) = c :  = IwK
(f )(t1, . . . , tn) = f (t1, . . . , tn) :  = IwK
(k) for 1  k  n (by Definition 16). 

Finally, we prove the completeness of the rigid-property deriva-

tion system as follows.
Theorem 4 (Completeness of rigid-property derivation). Let S =
{K1, . . . ,Kn} be a finite set of knowledge bases and L be a sorted or
ill-sorted ground atom. If KiSL, then KiSL.
Proof. By Lemma 4, IS, wK1
assumption, IS, wK

 L. Therefore, KiSL (by Definition 16). 

 K1, . . . ,IS, wKn

 Kn. Hence, by

5. Query-answering system with rigid properties

In this section, we provide a query-answering system equipped
with rigid-property derivation. If a user inputs a query (denoted by
goal G) into a knowledge base, the system returns the instances
G
 of the goal. In other words, the instances G
, which are
regarded as the answers of the query, are true in the knowledge
base. In order to embody a top-down reasoning mechanism, the
query-answering system is implemented using a linear resolution
system.

5.1. Linear resolution

Here, we develop a linear resolution system for our proposed
order-sorted logic that includes sort predicates and rigidity. We
extend the standard linear resolution system by incorporating additional resolution rules corresponding to the inference rules of the
proposed Horn-clause calculus.

The extended linear resolution system consists of the following

inference rules.

Definition 19 (Linear resolution system).
 Sorted resolution rule: Let L
, then (G  {L})
  G

L and L
written by


 is a goal derived from L and L

 K and L  G. If 
 is a unifier of


R1(G  {L})
  G

 Subsort resolution rule: Let ps(t) G and ps (t
s and 
 is a unifier of t and t
, written by
derived from ps(t) and ps (t

)  G
, then (G  {ps(t)})
  G

)  G

 K. If s


 is a goal


R2(G  {ps(t)})
  G

 Type-predicate resolution rule: Let p(t) G and let 
 be a sorted
substitution. If sort(t
)  , then (G  {p(t)})
 is a goal derived
from p(t), written by


R3(G  {p(t)})


 Unsorted type-predicate resolution rule: Let p(t) G and let

u be an unsorted substitution. If (
u) = {x1 : s1/t1, . . . , xn :
sn/tn}, sort(t)  , and K : {ps1 (t1)}  G1, . . . ,K : {psn (tn)}  Gn,
then (G  {p(t)})
u  (G1    Gn)
u is a goal derived from p(t),
written by


uR4(G  {p(t)})
u  (G1    Gn)
u

 Unsorted resolution rule: Let L
 K and L  G,
let 
u

be an unsorted substitution, and let 
 be a sorted sub-
stitution. If K : {ps1 (t1)}  G1, . . . ,K : {psn (tn)}  Gn, 
u
= {x1 :
s1/t1, . . . , xn : sn/tn}, and there is a unifier 
 of L
u

u
0 and L
0,

u  (G1    Gn)
u with 
u = 
u
 
 is a goal
then (G  {L})
u  G

derived from L and L

, written by


uR5(G  {L})
u  G


u  (G1    Gn)
u

For ensuring soundness of rules, they are applied up to variable
renaming (like in classical resolution), so a clause and the goal in
which it is resolved do not share free variables.

, . . . , G

R5G

We generally write  for a sorted substitution 
 or unsorted
substitution 
u. We use the abbreviation G
for each of
R1G
. An unrestricted resolvent is a resolvent if

the unifier  is most general. Let K be a knowledge base. A finite
sequence
1G1
K : G0
is an unrestricted resolution of G0 with respect to K (n  0). We
denote it by K : G0
Gn is called
successful if Gn = . We write G0  fail if there exists no successful resolution of G0. We write G0  Gn when we do not need

Gn with  = 1n. K : G0

3nGn

2G2

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

is a resolution of G1(= (G  {p(t)})
1) where p(t) G and 
1
is an unsorted substitution. By induction hypothesis, I, w 
(G  {p(t)})
1 with  = 2n. By the proof of Theorem 1,
t
1

 Iw(). It follows K  p(t
1), and so K  G
1.

w, 

Gn. An unrestricted resto emphasize the substitution  in G0
olution is called a resolution if the unrestricted resolvents are
resolvents. The composition (1n)  Var(G0) of the substitutions to the variables in the initial goal G0 is called a computed
answer substitution. For 1  i  n, the restriction of i to the goal
Gi1 (i.e. i  Var(Gi1)) is denoted by i

. Moreover, we write 
for 1
. The following theorem guarantees the soundness of
the linear resolution system.
Theorem 5 (Soundness of linear resolution). Let K be a knowledge
base and G be a goal. If there exists a successful resolution K : G

then K  G.
Proof. This theorem is proven by induction on the length n of a
successful resolution of G. Let K be a knowledge base and let
K : G
with  = 1n be a successful resolution of G. Suppose that
I, w  K.

3n

2G2

1G1

Base case: n = 1.

 K and L(= G), i.e., L


1R1, then 
1 is a unifier of L

1. Therefore K  G
1 since L

1R2, then 
1 is a unifier of t and t

1 where


1) since
)  Iw(s) (by Definition 9).

1R3, then G = p(t). The substitution 
1 is well-sorted. So,


1 = L
1(= G
1).

, i.e., t
1 = t

)  K. So, we can get I, w  ps (t


1 = L
1.

 Iw(). This follows K  p(t
1).

1. If G

Then I, w  L

2. If G

ps(t)(= G) and ps (t
Iw(s
3. If G
t
1
4. If G

w, 

u

1R4,

then G = p(t)

and K : {ps1 (t1)}  , . . . ,K :
{psr (tr)}  . By induction hypothesis, we have I, w 
ps1 (t1), . . . ,I, w  psr (tr). These imply K  p(t
u
1) by the
proof of Theorem 1.

1R5, then 
u

u
5. If G
1, and G = p(t) and K : {ps1 (t1)}  , . . . ,K : {psr (tr)}  .

L
u
By induction hypothesis, I, w  ps1 (t1), . . . ,I, w  psr (tr). Hence,
I, w  L
1 since


u

1 by the proof of Theorem 1. Therefore, K  G
u


u
1(= G
u
= L
u
1).

 K and L(= G), i.e., L

1 is a unifier of L


u

Induction step: n > 1.

1. If G

2G2

3n


1  (G  {L})
1) where L  G, L


1  (G 

1(= L
1) since K 

)
1. Therefore K  G
1.


1 = L
1. By induction hypothesis, K  (G


1R1G1, then

1  (G  {L})
1

is a resolution of G1(= G
 K, and L

{L})
1) with  = 2n. Then, K  L

(L

1R2G1, then

1  (G  {ps(t)})
1
2G2

is a resolution of G1(= G

, i.e., t
1 = t
)  G
fier of t and t
induction hypothesis, I, w  G
2n. By Definition 9, I, w  ps(t
1) since I, w  ps (t
and Iw(s

)  Iw(s). Hence, K  G
1.


1  (G  {ps(t)})
1) where 
1 is a uni-

1, ps(t) G, and ps (t
 K. By


1  (G  {ps(t)})
1 with  =
)  G

3n

2. If G

3. If G


1R3G1, then
(G  {p(t)})
1

2G2

3n

4. If G


1R4G1, then
(G  {p(t)})
u

 (G

r)
u

3n

2G2
is a resolution of G1(= (G  {p(t)})
u
1) where
p(t) G and 
u is an unsorted substitution. By induction hypoth-
1 with  =
esis,
2n. By definition, K : {ps1 (t1)}  G
1, . . . ,K : {psr (tr)}  G

r.
I, w  ps1 (t1), . . . ,I, w  psr (tr).
By
Therefore, by the proof of Theorem 1, K  p(t
). So, K  G
1.

I, w  (G  {p(t)})
u

r)
u

 (G

1  (G

hypothesis,

induction

r)
u

5. If G


1R5G1, then
(G  {L})
u  G


u

 (G

r)
u

3n

 K, L  G, and 
u

2G2

is a resolution of G1(= (G  {L})
u


u
r)
u
1)

1 is an unsorted substitution. By
where L
induction hypothesis, I, w  (G  {L})
u
1  G

1  (G


u
1 with  = 2n. By definition, 
u

 and L,
r)
u
1 is a unifier of L

1, . . . ,K : {psr (tr)}  G


u
i.e., L
r. By
induction hypothesis, I, w  ps1 (t1), . . . ,I, w  psr (tr). Then, by

the proof of Theorem 1, I, w  L
1 since


u

1, and K : {ps1 (t1)}  G
1. Therefore, K  G
u

u

 (G

1. 

= L
u

= L
u

Lemma 5. Let K be a knowledge base and L  G be a ground clause.
If K  L  G, then K : G   implies K : L  .

, t

, i.e., (L


u = t, and sort(t

Proof. We show the lemma by induction on the length n of a
derivation tree of L  G from K.
n = 1: If L  G is derived by the sorted substitution rule in the

 K where L  G is a ground
)
 = L  G. Suppose K : G  . By


R1G  .
If p(t)  is derived by the type predicate rule,

Horn-clause calculus, then L

instance of L
the sorted resolution rule, it is easy to derive K : L
then
sort(t)  , and so K : p(t) R3 (by the type-predicate resolution
rule).
If p(t)  G is derived by the unsorted type predicate rule,
then there exists an unsorted substitution 
u such that for some
)  . Let (
u) = {x1 : s1/t1, . . . , xn :
term t
sn/tn}. Then, we have K  ps1 (t1)  G1, . . . ,K  psn (tn)  Gn and
G = G1    Gn. Hence, K : {ps1 (t1)}  G1, . . . ,K : {psn (tn)}  Gn.
Therefore, if K : G  , then K : p(t) 
uR4G  .
If L  G is derived by the unsorted substitution rule, then L

  G1    Gn.

 K where L  G is a ground instance of L

That is, there exists an unsorted substitution 
u such that (L
  G1    Gn)
u = L  G. Let (
u) = {x1 : s1/t1, . . . , xn : sn/tn}.

So, we have K  ps1 (t1)  G1, . . . ,K  psn (tn)  Gn. By induction
hypothesis, K : {ps1 (t1)}  G1, . . . ,K : {psn (tn)}  Gn. Therefore, if

uR5G   (by the unsorted type-predicate
K : G  , then K : L
resolution).
n > 1: If L  G is derived by the cut rule, by induction hypoth-
. So, K :
esis, there are subsets G
  {L

Hence if K : G  , then K : L  .
If ps (t)  G is derived by the subsort rule, then K  ps(t)  G
  s. By induction hypothesis, if K : G  , then K : ps(t)  .
In the case n > 1, the other rules cannot derive L  G because

and s
Therefore, K : ps(t) R2ps (t)  .
they have no antecedent. So, the proof has been done. 

}   implies K : L  , and K : G

 of G such that G = G

   implies K : L

 and G

Theorem 6 (Ground completeness of linear resolution). Let K be a
knowledge base and G be a ground goal. If K  G, then there exists a
resolution K : G
Let I, w  K. By assumption, I, w  G. Let S be a finite set
Proof.
of knowledge bases including K. Then IS, wK  G by Lemma 2. By
Definition 16, K  L in K for all L  G. Hence, K : L   by Lemma 5.
Therefore, we can obtain K : G
Lemma 6 (Lifting). LetK be a knowledge base. IfK has an unrestricted
resolution
K : G00
then K has a resolution
K : G0

and the following holds.
ii and Gi =
(i) 0 = 0, and for 1  i  n, (i1  Var(Gi1))i = 


n with G001

nG

2nGn,

ii, and

substitution 

1G1

1G

(ii) there

G0

exists

n.

Proof. We show the lemma by induction on the length n of a res-
olution. The proof is based on Lemmas 5.33 and Theorem 5.37 in
[14]. 

We will show the completeness of the linear resolution system

corresponding to the extended Horn-clause calculus.
Theorem 7 (Completeness of linear resolution). Let K be a knowledge base, G be a goal, and  be a sorted or unsorted substitution. If

K  G, then there exists a successful resolution K : G
 s uch that


G = G
Proof. We first introduce a new constant ci : si for every xi :
si  Var(G). Let  be a sorted substitution defined by Dom() =
Var(G) and (xi : si) = ci : si. By definition, K  G leads to
K  G. By Theorem 6, there exists a resolution K : G


By Lemma 6, we have a resolution K : G
0 with G


. Due to Var(G) = , G = G
does not
. So, G

include the new constants ci : si. Thus, (yi : si) = ci : si holds for
a variable yi : si (the sort of which is the same as of xi : si).
If (yi : si)0 = xi : si and 
 = {(a, b) |a /= yi : si}  0, then G

= G

5.2. Rigid-property resolution for multiple knowledge bases

We develop an extended linear resolution system (called a rigidproperty resolution system) that is more effective than the
rigid-property derivation system. To be precise, the three linear
resolution rules (sorted resolution, unsorted type-predicate res-
olution, and unsorted resolution) are extended to deal with the
extraction of rigid-property information in multiple knowledge
bases.

The rigid-property resolution system contains the following res-

olution rules.
Definition 20 (Rigid-property resolution system). Let S be a finite
set of knowledge bases and let KS.
 Sorted resolution rule with rigidity: Let p(t
)  G
K S/{K} and p(t) G. If 
 is a unifier of t and t
{p(t)})
 and G

 K with
, then (G 
)  G


 are goals derived from p(t) and p(t

written by

: G


R1+ (G  {p(t)})
 and K

K : G
 Unsorted type-predicate resolution rule with rigidity: Let
p(t) G and let 
u be an unsorted substitution. If (
u) = {x1 :
s1/t1, . . . , xn : sn/tn}, sort(t)  , and K : {ps1 (t1)}  G1, . . . ,K :
{psm (tm)}  Gm,
then (G  {p(t)})
u  (G1    Gm)
u, and
Gm+1
u, . . . , Gn
u are goals derived from p(t), written by

S/{K}.

m+1, . . . ,K

n : {psn (tn)}  Gn
u


uR4+ (G  {p(t)})
u  (G1    Gm)
u

K : G
m+1 : {psm+1 (tm+1)}  Gm+1
u, . . . ,K

where K
 Unsorted resolution rule with rigidity: Let L
 K and
L  G and let 
u be an unsorted substitution. If (
u) = {x1 :
s1/t1, . . . , xn : sn/tn}, 
u is a unifier of L and L
 and K : {ps1 (t1)} 

u  (G1   
G1, . . . ,K : {psm (tm)}  Gm, then (G  {L})
u  G

Gm)
u, and Gm+1
u, . . . , Gn
u are goals derived from L and L
written by


u  (G1    Gm)
u


uR5+ (G  {L})
u  G

K : G
m+1 : {psm+1 (tm+1)}  Gm+1
u, . . . ,K

where K

S/{K}.

m+1, . . . ,K

n : {psn (tn)}  Gn
u

+G

 for each of G

R4+ G
. We denote a rigid-property resolution by K : G0

With respect to the resolution rules with rigidity, we use the
, and
abbreviation G
R5+ G
+Gn.

We can say that there exists a successful rigid-property resolution
of G in K if one of the following conditions holds:

R1+ G

, G

, G

 of G.

+G

1. There exists a successful resolution K : G
2. There exists a rigid-property resolution K : G

 of G such that
 =  and, whenever a resolution rule with rigidity (R1+, R4+, or

R5+) is applied, there exist successful rigid-property resolutions
of its newly created goals in the other knowledge bases (K or
m+1, . . . ,K

n).
Suppose we have the sorted signature 	 =
Example 5.
(T, N,  ,) of Example 2 and the knowledge bases K1,K2,K3,
and K4 of Example 4. Consider a rigid-property resolution K3 :
{canfly(z : animal)} + of the goal {canfly(z : animal)}.
knowledge base K3.
K3 : {canfly(z : animal)} 
1R1{bird(z1 : animal)}
where 
1 = {z : animal/z1 : animal, x : animal/z1 : animal}.

First, the sorted resolution rule is applied to the goal in the

Second, the subgoal {bird(z1 : animal)} derives the empty clause
if the sorted resolution rule with rigidity is successfully applied to
another knowledge base K4.
K3 : {bird(z1 : animal)} 
2R1+ 
K4 : {bird(tony : animal)} 
3R1{bird(peter : animal),
father(peter : animal, tony : animal)}

where 
2 = {z1 : animal/tony : animal} and 
3 = . To obtain the
rigid-property information tony is a bird from the knowledge base
K4, the new goal {bird(tony : animal)} is resolved by deriving the
subgoal {bird(peter : animal), father(peter : animal, tony : animal)}
by applying the sorted resolution rule.

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

Moreover, the subgoal is resolved by applying the sorted resolution rule with rigidity if there is a successful resolution of the goal
{bird(peter : animal)} in another knowledge base K3.
K4 : {bird(peter : animal)} 
4R1+ 
K3 : {bird(peter : animal)} 
5R2
where 
4 =  and 
5 = .
goal {canfly(z : animal)} in K3.

Therefore, there is a successful rigid-property resolution of the

We show the soundness of the rigid-property resolution system

as follows.
Theorem 8 (Soundness of rigid-property resolution). Let S =
{K1, . . . ,Kn} be a finite set of knowledge bases and G be a goal. If
there exists a successful rigid-property resolutionKi : G
+ of G, then
KiSG.
Proof. This theorem is proven by induction on the length n of a
successful rigid-property resolution of G. Let K be a knowledge base
and let
Ki : G
with  = 1n be a successful rigid-property resolution of G.
Base case: n = 1. The resolution rules with rigidity (R1+, R4+,
and R5+) are the same as the corresponding linear resolution rules
(R1, R4, and R5).
rules with rigidity (R1+, R4+, and R5+) are applied as follows.

Induction step: n > 1. We show only the cases where resolution

3n

2G2

1G1

2G

2G2

3n


1  (G  {p(t)})
1


1


1R1+ G1, then
1. If G
K : G

K : G
is a resolution of G1(= G
)  G
 K, and t
p(t
 with  = 2n and KSG
{p(t)})
1

r. On the other hand, KSp(t

)  G
KS(p(t
. Therefore KSp(t
1

KSp(t
1

), and so KSG
1


1  (G  {p(t)})
1) where p(t) G,

1 = t
1. By induction hypothesis, KS(G 


1
)) since
). By Definition 9,

)(= p(t
1

 with 

)
1


1

2. If G


uR4+ G1, then
K : (G  {p(t)})
u  (G

m+1 : {psm+1 (tm+1)}  G

m)
u2G2

m+1
u(m+1,2) G(m+1,2)

3n

(m+1,3) (m+1,km+1 ) ,

. . . ,
r : {psr (tr)}  G

r 
u(r,2) G(r,2)

(r,3) (r,kr ) 

hypothesis,

m+1
= (m+1,2)(m+1,km+1), . . . ,K

resolution of G1(= (G  {p(t)})
u  (G
KS(G  {p(t)})
u  (G

m+1
u
m+1

r
u

m)
u)
is
where p(t) G and 
u is an unsorted substitution. By induc-

m)
u
tion
with  = 2n,
with

with
m+1

= (r,2)(r,kr ). By definition, K : {ps1 (t1)}  G1, . . . ,K :

{psm (tm)}  G

For
Then,
m,
m + 1  j  r, K
j), and by Definition 9, KSpsj (tj


Spsj (tj

j).

According to the proof of Theorem 1, KSp(t
). Hence,
KSG
u.

KSps1 (t1), . . . ,KSpsm (tm).

and

3. If G


uR5+ G1, then


u  (G

is a resolution of G1(= (G  {L})
u  G

m)
u)
 K, L  G, and 
u is an unsorted substitution.
where L
induction hypothesis, KS(G  {L})
u  G

u  (G

By

m)
u with  = 2r, and K

m+1
u
m+1
m+1
= (m+1,2)(m+1,km+1), . . . ,K

r
u
with 
r with
m+1
= (r,2)(r,kr ). By definition, 
u is a unifier of L

 and L, i.e.,


u = L
u, and K : {ps1 (t1)}  G1, . . . ,K : {psm (tm)}  G

m. For

m + 1  j  r, K
j), and by Definition 9, KSpsj (tj


Spsj (tj

j).
Then, by the proof of Theorem 1, KSL

u. Hence, KSG
u.


u = L
u. 
Therefore, KSG
u since L

Let S = {K1, . . . ,Kn} be a finite set of knowledge bases
Lemma 7.
and L  G be a ground clause. If KiSL  G, t hen Ki : G+ implies
Ki : L+.
Proof. We show the lemma by induction on the length n of a
derivation tree of L  G from Ki.

in

in

: psn (tn)

i : L  .

: psk+1 (tk+1)

uR5+ (G

i : G   implies K0

< m and i /= j. By Theorem 4, Km

 psk (tk)  Gk, and Kmk+1
ik+1

 L  G. By Lemma 5, K0
 L  G (m > 0).

 Let K0
 Let Km
n = 1:
 [1.] If L  G is derived by the sorted substitution rule, then L 

 ps(t) with 0 
G has the form ps(t)   and by definition Km

: ps(t)  . By the sorted

resolution rule with rigidity, we can to derive Ki : ps(t) R1+ .
 [2.] If L  G is derived by the unsorted substitution rule, then

 Ki and there exists an unsorted substitution
we have L
  G1    Gk)
u = L  G. Let (
u) = {x1 :


u such that (L
 ps1 (t1) 
s1/t1, . . . , xn : sn/tn} with k  n. So, we have K0
 psk+1 (tk+1), . . . ,Kmn

G1, . . . ,K0
psn (tn) where for k + 1  j  n, mj > 0 and ij /= i. By induction hypothesis, Ki : {ps1 (t1)}  G1, . . . ,Ki : {psk (tk)}  Gn, and
by Theorem 4, Kmk+1
k+1 , . . . ,Kmn
n.
ik+1
  G1    Gk)
u   (by the
If Ki : G+, then Ki : L
unsorted substitution resolution rule with rigidity).
 [3.] If p(t)  G is derived by the unsorted type-predicate
rule, where G = G1    Gk, then there exists an unsorted

u = t, and
, t
substitution 
u such that for some term t
)  . Let (
u) = {x1 : s1/t1, . . . , xn : sn/tn} with k  n.
sort(t
 ps1 (t1)  G1, . . . ,K0
 psk (tk)  Gk,
So, we
 psn (tn)
and
for
where
k + 1  j  n, mj > 0 and ij /= i. By induction hypothesis,
Ki : {ps1 (t1)}  G1, . . . ,Ki : {psk (tk)}  Gn, and by Theorem 4,
Kmk+1
If Ki : G+,
ik+1
then Ki : p(t) 
uR4+ (G1    Gk)
u   (by the unsorted
type-predicate resolution rule with rigidity).
n > 1:
 [1.] If L  G is derived by the cut rule, then Km

 and
}. By induction hypothesis, there are subsets
 L  G
Km
  {L
}+ implies
 and G
: G

Km
: L+, and Km
+. Hence Km

: L
G+ implies Km
 [2.] If ps (t)  G is derived by the subsort rule, then, Km

ps(t)  G and s
: G+,
: ps(t) R2ps (t)+. 
then Km

  s. By the induction hypothesis, if Km

have
 psk+1 (tk+1), . . . ,Kmn

, Km
+ implies Km

: ps(t)+. Therefore, Km

 of G such that G = G

k+1 , . . . ,Kmn

: G
: L+.

: psk+1 (tk+1)

Kmk+1
ik+1

: psn (tn)

  {L

n.

K0

in

in

K : (G  {L})
u  G


u  (G
m)
u2G2

m+1
u(m+1,2) G(m+1,2)
m+1 : {psm+1 (tm+1)}  G

. . . ,
r : {psr (tr)}  G
(r,3) (r,kr ) 

r 
u(r,2) G(r,2)

3n
(m+1,3) (m+1,km+1 ) ,

Theorem 9 (Ground completeness of rigid-property resolution).
Let S = {K1, . . . ,Kn} be a finite set of knowledge bases and G be a
ground goal. If KiSG, then there exists a rigid-property resolution
Ki : G

+.

By

 Kn.

1+G1

 K1, . . . ,I, wKn

I, wK1
SG. Then IS, wK

Let

+. 

2+ n+Gn,

Proof.
assumption,
I, wK
 G by Lemma 2. By Definition 16,
KiSL for all L  G. Hence, Ki : L+ by Lemma 7. Therefore, we
can obtain Ki : G
Lemma 8 (Lifting). Let S = {K1, . . . ,Kn} be a finite set of knowledge
bases. If Ki has an unrestricted rigid-property resolution
Ki : G00
then Ki has a rigid-property resolution

n+G
2+ 
Ki : G0
and the following holds.
(i) 0 = 0, and for 1  i  n, (i1  Var(Gi1))i = 
ii and Gi =


n with G001

ii, and

substitution 

1+G

(ii) there

G0

exists

n.

Proof. Similar to Lemma 6. 

Using the above theorems and lemmas, the completeness
the rigid-property resolution system can be proven as

of
follows.
Theorem 10 (Completeness of rigid-property resolution). Let S =
{K1, . . . ,Kn} be a finite set of knowledge bases, G be a goal, and  be
a sorted or unsorted substitution. If KiSG, then there exists a successful rigid-property resolution Ki : G

Proof. Theorem 9 and Lemma 8 derive the completeness similar
to Theorem 7. 


+ such that G = G

5.3. Query-answering algorithm

The purpose of this subsection is to develop a query-answering
algorithm of the rigid-property resolution. We focus on function-
free, recursive knowledge bases because the elimination of n-ary
functions (n  1) results in a decidable algorithm by means of the
techniques for deductive databases [50,11]. The linear resolution
and rigid-property resolution systems do not contain any inference
strategy since a detailed procedure on how to select inference rules
and clauses has not been described.

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

In the query-answering algorithm, the subroutine select(G) as
a selection function selects the leftmost atom in the goal G. The
function instance(	K) denotes the set of sorted instances of clauses
) returns the most genin 	K. Moreover, the subroutine unify(L, L
 if they are unifiable, otherwise, it returns .
eral unifier for L and L

The unification can be implemented by the order-sorted unification
algorithm in [27]. When we apply a resolution rule to a selected
atom in a goal, the following subroutine apply rule(L, C, G, r) is
called, where L is an atom, C is a clause, G is a goal, and r is a
resolution rule.

We consider a search strategy of the rigid-property resolution,

1G1

2G2

3nGn

i.e., a selection function is fixed in a resolution of a goal G0:
K : G0
where one of the atoms in each goal Gi is selected when a resolution
rule is applied to the goal. We denote a sequence K1 : G1, . . . ,Kk :
Gk (k  0) of pairs of knowledge bases and goals by Seq and denote a
sequence K1 : , . . . ,Kl :  (l  0) of pairs of knowledge bases and
the empty set by ESeq.

We define an SLD-tree that is a derivation tree of SLD-resolution
(selection-rule driven linear resolution for definite clauses). If a
selection function is added to a linear resolution system, then we
obtain an SLD-resolution system. As one of the techniques of automated reasoning, the truth of a goal in a set of clauses can be
checked to terminate under SLD-resolution. We make use of this
technique in order to develop a decidable goal-oriented reasoning
algorithm for our proposed order-sorted logic (logic programming
with tabling [49] is an alternative decidable technique).
Let S be a finite set of knowledge bases, K be a knowledge base
in S, and G0 be a goal. A leftmost rigid-property SLD-tree for G0 is a
tree such that
(i) the root is labeled with (K : G0);
(ii) if a node d is labeled with (ESeq,K : G,Seq) and a resolution rule
(either of R1 to R5) is applicable to G in K (i.e., K : G
 for
some {1, . . . , 5}), the node d has a child node d
 labeled with
(ESeq,K : G
) is labeled with 
;
(iii) if a node d is labeled with (ESeq,K : G,Seq) and the sorted resolution rule with rigidity (R1+) is applicable to G in K (i.e.,
K : G
 labeled
with (ESeq,K : G
) is labeled
with 
;
(iv) if a node d is labeled with (ESeq,K : G,Seq) and the unsorted
type-predicate resolution rule with rigidity or unsorted resolution rule with rigidity (R4+ or R5+) is applicable to G in K (i.e.,
K : G

m), the
node d has a child node d
m :
m,K : G

1, . . . ,K

m : G
1, . . . ,K

1 : G
) is labeled with 
.

), the node d has a child node d
,Seq) and the edge (d, d

 for some {4, 5} and K

,Seq) and the edge (d, d

,Seq) and the edge (d, d

 labeled with (ESeq,K

 and K : G
,K : G


R1+ G


uR+ G


RG

1 : G

A SLD-tree contains a success if there exists a leaf node labeled

with ESeq = K1 : , . . . ,Kl :  in it.
Let S = {K1, . . . ,Kn} be a finite set of knowledge bases
Lemma 9.
and G0 be a goal. Every leftmost rigid-property SLD-tree contains a
success with a computed answer substitution  if and only if there
exists a substitution  in{1, . . . , m} such that solve(Ki, G0,S, ) =
{1, . . . , m}.
() Let us assume solve(Ki, G0,S, ) = {1, . . . , m}. In
Proof.
the process of solve(Ki, G0,S, ), we can construct a tree for G in
the following operations:
 Create the root d0 labeled with (Ki : G0).
 Create a new node d
) under conditions
(ii)(iv) of leftmost rigid-property SLD trees if a node d labeled
with (ESeq,K : G,Seq) is created and apply rule(L, C, G, r) is called
where L = select(G), C K, and r {R1, . . . , R5, R1+
 Add the proof segment of L
 to the node if a node d labeled with
(ESeq,K : G,Seq) is created, L = select(G), L  instance(	K), L
  	K,
), and 
 /= .

 = unify(L, L

 and the edge (d, d

, R5+}.

, R4+

The trees constructed by these operations satisfy the conditions
of leftmost rigid-property SLD trees, where for each substitution
{1, . . . , m}, there exists a leaf node of the form ESeq with
the computed answer substitution .

1, . . . , G

1, . . . ,K

1, . . . ,K

1 : , . . . ,K

r are added in front of the goal K : G

() Let T be a leftmost rigid-property SLD-tree for G0 that
contains a success with a computed answer substitution . By def-
inition, T has a leaf node labeled with ESeq = K
m : 
}  S. This implies that we have a path from
where {K
(Ki : G0) to ESeq as follows:
(Ki : G0)  (ESeq1, Seq1)    (ESeqk, Seqk)  (ESeq)
This sequence generates a successful rigid-property resolution of
G0. By the definition of leftmost rigid-property SLD-trees, the leftmost atom of each goal is selected when a resolution rule is

r in other knowledge
applied to a node, and the goals G
bases K
 containing the selected atom (i.e., (ESeq,K
,Seq))
after one of the rigid-property resolution rules is applied to a
node.
The applications of resolution rules are performed in the query
answering algorithm solve(Ki, G,S, ). Note that if L  instance(	K)
where L is selected by L = select(G), then the resolution process of
the atom L is skipped. It indicates that the atom L has been already
resolved successfully in the former processes and there is no need
to repeat the same resolution steps because resolution rules are
identically applied. Therefore, the algorithm derives the empty goal
}  S.
 for the knowledge bases K
It returns a set of substitutions {1, . . . , m} that contains the
computed answer substitution  in the successful rigid-property
resolution of G0. 

m where {K

1, . . . ,K

1, . . . ,K

1, . . . ,K

r ,K : G

1 : G

r : G

The completeness of the algorithm solve is given as follows.

Theorem 11 (Completeness of solve). Let S = {K1, . . . ,Kn} be a
finite set of knowledge bases, G be a goal, and  be a sorted or
unsorted substitution. If KiSG, then there exists a substitution

 in {1, . . . , m} such that G = G
 and solve(Ki, G,S, ) =
{1, . . . , m}.
Proof. By Theorem 10, we have a successful rigid-property resolution Ki : G
. Hence, we can construct
a leftmost rigid-property SLD-tree containing a success. Therefore,
by Lemma 9, this theorem can be proven. 


+ such that G = G

The decidability of the algorithm solve is guaranteed if the

inputted knowledge bases are function-free as follows.

Theorem 12 (Termination of solve). The query-answering algorithm
solve terminates.

Proof. Each selected atom L in line 8 of the algorithm is added to
	K if L is not an instance of each atom in 	K. So, the number of
recursive calls depends on the number of elements of 	K because
lines 1016 are the only routine to decrease the elements of next
goal each atom of which recursively calls the algorithm. If every
knowledge base contains no functions, the set 	K is limited to finite.
Therefore, it terminates. 

6. Discussion

Prominent languages such as RDF [33], OWL [41], and RuleML
[1] have been designed for modeling ontologies and rules for the
Semantic Web; sound and complete decidable reasoning services
for these languages are provided by Description Logics [5] and DAT-
ALOG. Moreover, SWRL [26], a combination of OWL and RuleML,
corresponds to a combination of Description Logics and DATALOG.
However, SWRL becomes undecidable even when the rules are
function-free [25]. In order to make it decidable, the rules must
be non-recursive [35,15], DL-safe [24,42], or Description Logic Programs (DLP) [19]; however, these restrictions result in the loss
of expressive power for the rules. Recently, as discussed in [32],

K. Kaneiwa, R. Mizoguchi / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 252270

the new OWL 2 [2] has provided us the tractable language profile OWL 2 EL with DL-rules, which are based on the Description
Logic EL++. The rule-based language ELP [32], which extends EL++
using local reflexivity, concept products, and the conjunctions of
simple roles, preserves tractability. These sophisticated proposals enable low complexities but restrict the expressive power of
rules.

A solution to the problem of undecidability or limited rule
expressions is the use of order-sorted logic programming, which
is a combination of sort hierarchy and logic programming [36,4].
Sort hierarchy provides a simple ontology of partially ordered
sorts that does not include negation, disjunction, or quantification.
Our approach is an extension of order-sorted logic programming that preserves decidability in function-free, recursive rules.
In addition to decidability, we present effective reasoning services in an order-sorted linear resolution system. In previous
studies, researchers had proposed many refinements to inference
systems for automated reasoning. For example, hyperresolution
reduces a sequence of resolution steps into a single inference
step [34]. Hyperresolution is an efficient method for reducing
general clauses since it helps resolve more than two clauses in
a single step. We use linear resolution as a refinement because
it is useful for combining Horn-clauses and goal-oriented reasoning (i.e., only inference steps that are related to a goal are
generated).

In the Semantic Web context, multiple software agents access
distributed ontologies and rules on the Web. In multi-agent reasoning [16], multiple knowledge bases can be assigned to agents.
In other words, each agent should have its own knowledge base
because it updates knowledge through its experience by communicating with other agents. Researchers have previously modified
the OWL global semantics and proposed C-OWL (Context OWL
[8]) for distributed OWL ontologies. In C-OWL, the semantics of
a set of distributed ontologies i, Oi is defined in local domains
and valuations; context mappings among different ontologies are
represented by a set of bridge rules.

In comparison, our order-sorted logic programming handles
distributed facts and rules with a common ontology. In partic-
ular, logic programming with a sort hierarchy can be used to
propagate rigid properties from multiple knowledge bases. Each
knowledge base indirectly and safely accesses facts and rules
available in other knowledge bases. Rigid-property derivation
makes use of the fact that rigid-property assertions are unconditionally true for any other agent since they are true even if
the situation or time changes. This derivation is computationally improved by developing a rigid-property resolution system
as a top-down algorithm. The top-down algorithm is important
for rigid-property derivation in multiple knowledge bases. In the
bottom-up algorithm, mutualizing all the rigid-property assertions would lead to a result identical to that obtained when each
rigid property is transferred from other knowledge bases; how-
ever, mutualization is ineffective because the dynamically extended
set of rigid assertions becomes very large (unlike ontologies that
are more easily shared than the assertions). The top-down linear resolution system is effective for multiple knowledge bases
because of the goal-oriented reasoning method. In other words,
global accesses are limited to some rigid properties in a limited number of other knowledge bases, as shown in Example
5.

In addition to the proposed reasoning system, the axiomatic
approach, which involves axioms of ontological considerations,
can be used to realize the abovementioned rigid-property reason-
ing. Both approaches are closely related; however, the axiomatic
approach may lead to ineffective bottom-up reasoning by instantiating the general axioms because of its inability to control the
reasoning strategy, unlike the linear resolution system.

7. Conclusion and future work

In this paper, we described an effective framework for ordersorted logic programming for multiple knowledge bases. In our
study, the order-sorted language was extended to contain three
types of property expressions (types, non-rigid sorts, and unary
predicates) so that sorted terms and formulas adhere to the rigidity of properties. We also developed a query-answering algorithm
equipped with rigid-property resolution that is decidable and effective for function-free, recursive knowledge bases. The algorithm
provides new reasoning services for multiple knowledge bases
so that each knowledge base can extract rigid properties from
other knowledge bases. The feasibility of these reasoning services
is guaranteed by the fact that the truth of rigid-property assertions is independent of the situation in which each knowledge
base is built. From a technical perspective, after developing the
bottom-up algorithms (the order-sorted Horn-clause calculus and
the rigid-property derivation system), the decidable and effective query-answering algorithm is obtained from the top-down
algorithms (the linear resolution and rigid-property resolution sys-
tems).

In future studies, we intend to further refine the rigid-property
derivation to establish structural relationships among multiple
knowledge bases. We plan to extend distributed reasoning services
to facts and rules by exploiting inclusion, equation, and disjoint
relations among contexts, similar to the context mapping in C-OWL.
Furthermore, we can effectively obtain reliable results if knowledge
bases are authorized to be trustworthy.

Acknowledgment

This research has been partially supported by the Japanese Ministry of Education, Science, Sports and Culture, Grant-in-Aid for
Scientific Research (20700147).

Appendix A. An example of reasoning

Let us consider rigid-property derivation in the knowledge bases

K1,K2,K3, and K4 of Example 4.
Suppose that we have the sorted signature 	 =
Example 6.
(T, N,  ,) of Example 2 and knowledge bases K1,K2,K3, and K4
of Example 4. By using the expanded knowledge bases K0
i , . . .
of each Ki in S = {K1,K2,K3,K4}, the following derivations can be
obtained. At the beginning, for K1,K2,K3, and K4, we have the
following theories:
Th(K1) =   {excellent(john : person),

i ,K1

obtaining a discount(john : person),
male customer(john : person), customer(john : person),
male(john : person)}

Th(K2) =   {pet seller(mary : person)}
Th(K3) =   {canfly(peter : animal), bird(peter : animal),
Th(K4) =   {father(tony : animal, peter : animal)}

canary(peter : animal)}

 = {person(john : person), animal(john : person), person

where
(mary : person), animal(mary : person), animal(peter :
animal), animal(tony : animal)}.

It should be noted that theories Th(K1) and Th(K3) contain
the rigid atomic formulas male(john : person); and bird(peter :
animal), canary(peter : animal) respectively. In the following steps,
K0
1,K0
4 are expanded by adding these rigid atomic for-
mulas:

3, and K0

2,K0

Step 1: We set the initial values of K0

1,K0

2,K0

3, and K0
4.

K0

= Ki(1  i  4)

Step 2: Each K0

i is expanded to K1
i .
 	(T 0)(1  i  4) where
1)  Th(K0
canary(peter : animal)}

2)  Th(K0

= K0

K1
T 0 = Th(K0
	(T 0) =   {male(john : person), bird(peter : animal),

3)  Th(K0

4) and

the new conclu-
2) and
4) can be derived in the Horn-clause

in Th(K1

the expansion,

Step 3: As a result of
sions cares about(mary : person, peter : animal)
bird(tony : animal) in Th(K1
calculus.
Th(K1
Th(K1
Th(K1
Th(K1

1)  	(T 0)
2)  	(T 0)  {cares about(mary : person,
peter : animal)}
3)  	(T 0)
4)  	(T 0)  {bird(tony : animal)}

1) = Th(K0
2) = Th(K0
3) = Th(K0
4) = Th(K0

Step 4: The rigid atomic formula bird(tony : animal) expands
2,K1
1,K1
K1
= K1
K2
T 1 = Th(K1
3)  Th(K1
	(T 1) = 	(T 0)  {bird(tony : animal)}

3, and K1
4.
 	(T 1)(1  i  4) where
1)  Th(K1

2)  Th(K1

4) and

Step 5: We can obtain additional results cares about(mary :
person, tony : animal) in Th(K2
2) and canfly(tony : animal) in Th(K2
3)
that are generated from K2
2,K2
1,K2

3, and K2
4.

Th(K2
Th(K2

Th(K2
Th(K2

1) = Th(K1
2) = Th(K1
3) = Th(K1
4) = Th(K1

1)  	(T 1)
2)  	(T 1)  {cares about(mary : person,
tony : animal)}
3)  	(T 1)  {canfly(tony : animal)}
4)  	(T 1)

Step 6: The derivation terminates because K2
no longer be expanded.
K3
T 2 = Th(K2
	(T 2) = 	(T 1).

 	(T 2)(1  i  4) where
1)  Th(K2

2)  Th(K2

3)  Th(K2

4) and

= K2

1,K2

2,K2

3, and K2

4 can

In this example, the following conclusion holds.

K1Scustomer(john : person)
K2 / Scares about(mary : person, john : person)
However,K2 cannot extract the fact customer(john : person) fromK1
because the sort customer is not rigid. This means that we cannot
determine whether John is a customer with respect to K2.
K2Scares about(mary : person, peter : animal)
(butK2 / cares about(mary : person, peter : animal))
K2Scares about(mary : person, tony : animal)
(butK2 / cares about(mary : person, tony : animal))
K3Scanfly(tony : animal)
(butK3 / canfly(tony : animal))
These were not derivable in the Horn-clause calculus without rigid
property derivation (as denoted by / ). However, by using our
method, they can be derived from K2
3 expanded by means of
extracting the rigid-property information that Tony and Peter are
birds:
K4Sbird(tony : animal)
K3Sbird(peter : animal).

2 and K2
