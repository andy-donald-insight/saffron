Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Extending SPARQL with regular expression patterns (for querying RDF)
Faisal Alkhateeb a,, Jean-Franc  ois Baget b, Jerome Euzenat c

a Yarmouk University, Irbid, Jordan
b INRIA Sophia-Antipolis Mediteranee and LIRMM, Montpellier, France
c INRIA Grenoble Rhone-Alpes and LIG, Montbonnot, France

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 23 November 2006
Received in revised form 22 July 2008
Accepted 23 February 2009
Available online 21 March 2009

Keywords:
Semantic web
Query language

SPARQL
Regular expression patterns

RDF is a knowledge representation language dedicated to the annotation of resources within the framework of the semantic web. Among the query languages for RDF, SPARQL allows querying RDF through
graph patterns, i.e., RDF graphs involving variables. Other languages, inspired by the work in databases,
use regular expressions for searching paths in RDF graphs. Each approach can express queries that are out
of reach of the other one. Hence, we aim at combining these two approaches. For that purpose, we define
a language, called PRDF (for Path RDF) which extends RDF such that the arcs of a graph can be labeled
by regular expression patterns. We provide PRDF with a semantics extending that of RDF, and propose
a correct and complete algorithm which, by computing a particular graph homomorphism, decides the
consequence between an RDF graph and a PRDF graph. We then define the PSPARQL query language,
extending SPARQL with PRDF graph patterns and complying with RDF model theoretic semantics. PRDF
thus offers both graph patterns and path expressions. We show that this extension does not increase
the computational complexity of SPARQL and, based on the proposed algorithm, we have implemented
a correct and complete PSPARQL query engine.

 2009 Elsevier B.V. All rights reserved.

1. Introduction

Resource Description Framework (RDF [49]) is a knowledge representation language dedicated to the annotation of documents and
more generally of resources within the semantic web. It represents
knowledge as a graph relating resources (see Fig. 1). Nowadays,
more resources are annotated via RDF due to its simple data model,
formal semantics, and a sound and complete inference mechanism.
A query language that provides a range of querying paradigms is
therefore needed.

Several languages have been developed for querying RDF (cf.
Ref. [37] for a comparison of query languages for RDF). Among
them, SPARQL [56] is a W3C recommendation for querying RDF.
Answers to SPARQL queries can be computed by a kind of graph
homomorphisms known as projection in conceptual graphs [50].
More precisely, the answer to a SPARQL query Q relies on calculating the set of possible homomorphisms from the basic graph
pattern(s) of Q into the RDF graph representing the knowledge base

 This work has been partially supported by the Knowledge Web network of excellence (IST-2004-507482). This work has been done while the authors are working
in the EXMO team.
 Corresponding author.
E-mail addresses: alkhateebf@yu.edu.jo (F. Alkhateeb),

Jean-Francois.Baget@inria.fr (J.-F. Baget), Jerome.Euzenat@inrialpes.fr (J. Euzenat).

1570-8268/$  see front matter  2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2009.02.002

(see Example 1). Unfortunately, SPARQL lacks the ability of expressing paths, which is necessary for many applications (see Example
2).

Example 1. SPARQL graph patterns allow to match a query graph
against an actual RDF graph. Fig. 1(a) presents such a graph pat-
tern. It can be used for finding the name and email address of any
one related in any way, i.e., not family restricted, to a daughter of
a person named Faisal. If this pattern is used in a SPARQL query
against the graph G of Fig. 1, it will return Natasha (with email
natasha@example.org).

Another approach, that has been successfully used in databases
[25,28,48,59,62] but little in the context of the semantic web, uses
path queries, i.e., regular expressions, for finding regular paths in
a database graph. The answer to a path query R over a database
graph G, is the set of all pairs of nodes in G satisfying the language
denoted by R, i.e., all pairs connected by a directed path such that
the concatenation of the labels of the arcs along the path forms a
word that belongs to the language denoted by R (see Example 2).

Example 2. Assuming an RDF graph representing a social network,
i.e., a graph representing relations between people, like the graph

G of Fig. 1, the regular expression (ex : son|ex : daughter)
?b4,
when used as a query, searches all pairs of nodes connected by
paths with a sequence of son and daughter relations followed by
any relation (not restricted to family relation). Applied to node

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

Fig. 1. An RDF graph.

ex:c1of G, it should match the paths leading to ex:Person1,
ex:Person2, ex:Person3and ex:c3. This query, as it represents
paths of unknown length, cannot be expressed in SPARQL. On the
other hand, the graph of Fig. 1(a), which represents a basic graph
pattern of a SPARQL query, cannot be expressed by a regular expres-
sion.

None of these approaches can be reduced to the other, i.e., some
queries that can be expressed in one approach cannot be expressed
in the other. As shown in Fig. 1(a), a query whose homomorphic
image in the database is not a path cannot be expressed by a regular
expression, while RDF does not allow expressing paths of undetermined length. Furthermore, regular expressions provide a simple
way to capture additional information along paths that is not be
provided by SPARQL graph patterns, but they are not powerful
enough as a query language.

Therefore, an approach that combines the advantages of both
SPARQL and path queries is herein investigated. This combined
approach, in which the arcs of the SPARQL graph patterns may be
labeled with regular expression patterns, supports path queries (see
Example 3).

Example 3. Assuming that we are interested in finding, among
the persons related in any way, i.e., not family restricted, to Faisals
descendants, people who know Faisal, and we want to know their
names and email addresses. This query can be expressed using
graph patterns labeled with regular expression patterns, as shown
graphically in Fig. 2(b).

In order to formally define that language, we first introduce Path
RDF (PRDF) as an extension of RDF in which arcs of the graphs can be
labeled by regular expression patterns. Because we want to ground
the definition of our language on the semantics of RDF, and we
want to leave the door open to further extensions, we define the
semantics of PRDF on top of RDF semantics and we provide a sound
and complete algorithm for checking if a PRDF graph is entailed by
some RDF graph. However, those readers who are not interested in
the semantic justification of this extension, and only require syntactic definitions, can skip Sections 2.2 and 4.2 (GRDF and PRDF
semantics) and trust Theorems 1 and 3 for grounding our language
semantically (see Appendix A).

PRDF graphs are then used to define an extension to SPARQL,
called PSPARQL, that replaces RDF graph patterns used in SPARQL
by PRDF graph patterns, i.e., graph patterns with regular expression
patterns. We present the syntax and the semantics of PSPARQL. We
provide algorithms, which are sound and complete for evaluating
PSPARQL graph patterns over RDF graphs. We establish complexity
results on evaluating PSPARQL graph patterns over RDF graphs. We
have implemented a PSPARQL query engine.

1.1. Paper outline

This paper is organized as follows: we introduce simple RDF in
Section 2. Section 3 presents the two approaches mentioned so far
for querying RDF graphs. In Section 4, we give the syntax and the
semantics of PRDF, as well as a sound and complete inference mechanism for querying RDF graphs with PRDF queries. Section 5 defines
the syntax of the PSPARQL language and establishes the complexity results of PSPARQL query evaluation. Section 6 presents sound
and complete algorithms for answering a PSPARQL query, i.e., for
enumerating the set of all answers to a PSPARQL query. We provide
the first experimental results with an implementation of a PSPARQL
query evaluator (Section 7). After a review of related work (Section
8), we conclude in Section 9. The proof of the most important results
are given in Appendix A.

2. Simple RDF

This section is devoted to the presentation of the Simple RDF
knowledge representation language. We first recall (Section 2.1) its
abstract syntax [23], its semantics (Section 2.2), using the notions of
simple interpretations, models, simple entailment of Ref. [39]), then
Section 2.3 uses homomorphisms to characterize simple RDF entailment (as done in Ref. [15] for a graph-theoretic encoding of RDF,
and in Ref. [36] for a database encoding), instead of the equivalent
interpolation lemma of Ref. [39].

2.1. RDF syntax

To define the syntax of RDF, we need to introduce the terminology

over which RDF graphs are constructed.

2.1.1. Terminology
The RDF terminology T is the union of three pairwise disjoint
infinite sets of terms [39]: the set U of urirefs, the set L of literals
(itself partitioned into two sets, the set Lp of p lain literals and the
set Lt of typed literals), and the set B of variables. The set V = U  L
of names is called the v ocabulary. From now on, we use different
notations for the elements of these sets: a variable will be prefixed
by ? (like ?b1), a literal will be between quotation marks (like 27),
and the rest will be urirefs (like foaf:Person  foaf: is the prefix
used for identifying the Friend of a friend name space used for
representing personal information  or ex:friend).

RDF graphs are usually constructed over the set of urirefs, blanks,
and literals [23]. Blanks is a vocabulary specific to RDF. Because
we want to stress the compatibility of the RDF structure with
classical logic, we will use the term v ariable instead. The specificity of a blank with regard to variables is their quantification.
Indeed, a blank in RDF is an existentially quantified variable. We
prefer to retain this classical interpretation which is useful when
an RDF graph is put in a different context. When switching to
SPARQL, variables and blanks have different behaviors in complex
cases. For example, a blank shared in different simple patterns of a
group query pattern has a local scope which is easier to describe
as changing the quantification scope of a variable than changing a blank into a variable. So, for the purpose of this paper and
without loss of generality, we have chosen to follow [54] to not

Fig. 2. A SPARQL graph pattern (a) and a PSPARQL graph pattern (b).

Fig. 3. A GRDF graph.

distinguish between variables and blanks, and speak of variables
instead.
Definition 1 (RDF graph). An RDF triple is an element of (U  B) 
U  T. An RDF graph is a finite set of RDF triples.

Excluding variables as predicates and literals as subject was an
unnecessary restriction in the RDF design, that has been relaxed
in many RDF extensions. Relaxing these constraints simplifies the
syntax specification and neither changes RDF semantics nor the
computational properties of reasoning. In consequence, we adopt
such an extension introduced in Ref. [41] and called generalized RDF
graphs, or simply GRDF graphs.
Definition 2 (GRDF graph). A GRDF triple is an element of T  (U 
B)  T. A GRDF graph is a finite set of GRDF triples.

2.1.2. Notations
If s, p, o is a GRDF triple, s is called its s ubject, p its predicate,
and o its object. We denote by subj(G) the set {s|s, p, o G} the
set of elements appearing as a subject in a triple of a GRDF graph
G. pred(G) and obj(G) are defined in the same way for predicates
and objects. We call nodes(G) the nodes of G, the set of elements
appearing either as subject or object in a triple of G, i.e., subj(G) 
obj(G). A term of G is an element of term(G) = subj(G)  pred(G) 
obj(G). If Y  T is a set of terms, we denote Y  term(G) by Y(G). For
instance, V(G) is the set of names appearing in G.
term(G)  V.

A ground GRDF graph G is a GRDF graph with no variable, i.e.,

2.1.3. GRDF graphs as graphs
A simple GRDF graph can be represented graphically as a directed
labeled multigraph N, E, ,  where the set of nodes N is the set
of terms appearing as a subject or object in at least one triple of G,
the set of arcs E is the set of triples of G,  associates to each arc
a pair of nodes (its extremities) (e) = 1(e), 2(e) where 1(e) is
the source of the arc e and 2(e) its target; finally,  labels the nodes
and the arcs of the graph: if s is a node of N, i.e., a term, then (s) = s,
and if e is an arc of E, i.e., a triple s, p, o, then (e) = p. When drawing such graphs, the nodes resulting from literals are represented
by rectangles while the others are represented by rectangles with
rounded corners. In what follows, we do not distinguish between
the two views of the RDF syntax (as sets of triples or directed
labeled multigraphs). We will then speak interchangeably about
their nodes, their arcs, or the triples which make it up.
Example 4. The GRDF graph defined by the set of triples {?b1,
foaf : name, Faisal,?b1, ex : daughter, ?b2,?b2, ?b4, ?b3,?b3,
foaf : knows, ?b1,?b3, foaf : name, ?name} is represented graphically in Fig. 3. Intuitively, this GRDF graph means that there
exists an entity named (foaf:name) Faisalthat has a daughter
(ex:daughter) that has some relation with another entity whose
name is non-determined, and that knows (foaf:knows) the entity
named Faisal.

2.2. Simple RDF semantics

entailment via RDF or RDFS rules [36,39,41], we are only interested in the simple semantics without RDF/RDFS vocabulary [18].
The definitions of interpretations, models, satisfiability, and entailment correspond to the simple interpretations, simple models, simple
satisfiability, and simple entailments of Ref. [39].
Definition 3 (Interpretation of a vocabulary). Let V  V be a vocabu-
lary. An interpretation of V is a 5-tuple I = IR, IP, IEXT , IS, IL, where:
 IR is a set of resources containing plain literals of Lp;
 IP  IR is a set of properties;
 IS : U  IR, maps each uriref to a resource;
 IL : Lt  IR, maps each typed literal to a resource;
 IEXT : IP  2(IRIR), maps each property p to a set of pairs of
resources called the extension of p.

In order to simplify the notations, and without loss of generality,
we assume that IP  IR, which is true for RDF, but not necessarily for Simple RDF. If I = IR, IP, IEXT , IS, IL is an interpretation of a
vocabulary V, we also denote by I the mapping defined by:
 x U, I(x) = IS(x);
 x Lt, I(x) = IL(x);
 x Lp, I(x) = x.

We have defined the interpretation of a vocabulary. Now, we
want to specify the conditions under which an interpretation I is
a model for a GRDF graph G, i.e., G is satisfied by the interpretation I. For that matter, we need to extend the interpretations of a
vocabulary to interpret the variables in G.

Definition 4 (Extension to variables). Let I be an interpretation of a
vocabulary V  V, and B  B a set of variables. An extension of I to
B is a mapping I

 : V  B  IR such that x  V, I

(x) = I(x).

This definition implies that a variable can be interpreted (or

mapped) to any resource of IR.

Definition 5 (Model of a GRDF graph). Let G be a GRDF graph. An
interpretation I = IR, IP, IEXT , IS, IL of a vocabulary V  V(G) is a
 of I to B(G) such
model of G if and only if there exists an extension I
that for each triple s, p, o G, I
(o) IEXT (I
(p)). The mapping
 is called a proof of G.

(s), I

This definition is necessary for GRDF graphs having variables as
predicates [41], and PRDF graphs (cf Section 4). It is equivalent to
(o) IEXT (I(p)), in the case
the standard definition [39], i.e., I
of RDF graphs.

(s), I

The notions of satisfiability and entailment are then defined as

usual.

Definition 6 (Satisfiability). A GRDF graph G is satisfiable iff there
exists a model of G.

Definition 7 (Entailment). Let G and H be two GRDF graphs. Then
G entails H (denoted by GRDF H) iff every model of G is also a model
of H.

The definitions of satisfiability and entailment will be the same
when we extend the syntax and the semantics of GRDF. Two GRDF
graphs G, H are said equivalent if and only if GRDF H and HRDF G.
We associate to this semantics the decision problem called SIMPLE
RDF ENTAILMENT:

SIMPLE RDF ENTAILMENT
Instance: two GRDF graphs G and H.
Question: Does GRDF H?

Ref. [39] introduces different semantics for RDF graphs. Since
RDF and RDFS entailments can be polynomially reduced to simple

SIMPLE RDF ENTAILMENT is an NP-complete problem for RDF
graphs [36]. For GRDF graphs, its complexity remains unchanged.

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

entailment and maps. A proof is provided in Ref. [15] also for RDF
graphs, but the homomorphism involved is a mapping from nodes
to nodes, and not from terms to terms. In RDF, the two definitions
are equivalent. However, the terms-to-terms version is necessary to
extend the theorem of RDF (Theorem 1) to the PRDF graphs studied
in Section 3.1. The proof of Theorem 1 will be a particular case of
the proof of Theorem 3 for PRDF graphs.

This equivalence between the semantic notion of entailment and
the syntactic notion of homomorphism is the ground by which a
correct and complete query answering procedure can be designed.

3. Querying RDF graphs

This section presents two approaches for querying RDF graphs.
In Section 3.1, a simplified version of the SPARQL query language,
insisting on its development on top of RDF, is given. Section 3.2
shows how path queries developed in databases, and which use
regular expression patterns, can be used to query RDF knowledge
bases. Lastly, in Section 3.3, we discuss the significance of the combined approach which will be the goal of this paper.

3.1. The SPARQL query language

SPARQL is the RDF query language developed by the W3C [56].
SPARQL query answering is characterized by defining a mapping
from the query to the queried RDF graph.

We think that query languages for a semantically defined language like RDF should be defined semantically. This ensures the
correct interpretation of the queried database, e.g., guaranteeing
that querying two semantically equivalent graphs will yield the
same result in the sense that the application of the variable assignments to the graph patterns would return equivalent sets of graphs.
This also preserves the opportunity to extend this language beyond
what can be defined through simple maps or even homomor-
phisms, e.g., querying modulo an OWL ontology.

Hence, we ground the definition of answers to a (P)SPARQL query
on consequence, i.e., we show that a GRDF graph G contains an
answer  to a (P/G)RDF graph H if and only if G entails (H).

In this section we first define SPARQL semantically, i.e., we characterize SPARQL answers with regard to entailment. Theorem 1
shows that this definition is conform to the classical definition of
SPARQL. As a benefit, this provides a standard way to extend SPARQL
 by changing the entailment relation  and to define new query
evaluation mechanisms  by proving them sound and complete
with regard to the definition. This is what we will do in Section 5.
The basic building blocks of SPARQL queries are graph patterns
which are shared by all SPARQL query forms. Informally, a graph
pattern can be a triple pattern, i.e., a GRDF triple, a basic graph pat-
tern, i.e., a GRDF graph, the union of graph patterns, an optional
graph pattern, or a constraint (cf. Ref. [56] for more details).

Definition 10 (SPARQL graph pattern). A SPARQL graph pattern is
defined inductively in the following way:
 every GRDF graph is a SPARQL graph pattern;
 if P, P
then (PANDP
graph patterns.

 are SPARQL graph patterns and R is a SPARQL constraint,
), and (PFILTERR) are SPARQL

), (PUNIONP

), (POPTP

Our proposal is based upon extending these graph patterns, and
leaving the remainder of the query forms unchanged. So, we illustrate our extension using the SELECT query form.1 For a complete

1 SPARQL provides several result forms that can be used for formatting the query
results. For example, CONSTRUCT that can be used for building an RDF graph from

Fig. 4. An RDF homomorphism  from Q into G.

Polynomial subclasses of the problem have been exhibited based
upon the structure or labeling of the query:
 when the query is ground [40], or more generally when it has a
bounded number of variables,
 when the query is a tree or admits a bounded decompositions
into a tree, according to the methods in Ref. [35] as shown in Ref.
[15].

2.3. Simple RDF entailment as a graph homomorphism

SIMPLE RDF ENTAILMENT[39] can be characterized as a kind of graph
homomorphism. A graph homomorphism from an RDF graph H into
an RDF graph G, as defined in Refs. [15,36], is a mapping  from the
nodes of H into the nodes of G preserving the arc structure, i.e., for
each node x  H, if (x)U  L then ((x)) = (x); and each arc x
py
is mapped to (x)(p) (y). This definition is similar to the projection
used to characterize entailment of conceptual graphs (CGs) [50](cf.
Ref. [26] for precise relationship between RDF and CGs). We modify
this definition to the following equivalent one that maps term(H)
into term(G).
Definition 8 (Map). Let V1  T, and V2  T be two sets of terms. A
map from V1 to V2 is a mapping  : V1  V2 such that x  (V1  V),
(x) = x.

The map defined in Refs. [36,54] is a particular case of Definition
8. An RDF homomorphism is a map preserving some structure (here,
the arc structure).

Definition 9 (RDF homomorphism). Let G and H be two GRDF
graphs. An RDF homomorphism from H into G is a map  from
term(H) to term(G) such that s, p, o H, (s), (p), (o) G.
Example 5 (RDF homomorphism). Fig. 4 shows two GRDF graphs
Q and G (note that the graph Q is the graph P of Fig. 3, to which
the following triple is added ?b3, foaf : mbox, ?mbox. The map 1
defined by {Faisal , Faisal ,?b1, ex : c1,?name, Natasha ,
?mbox, natasha@example.org,?b2, ex : c2,?b4, ex : friend,
?b3, ex : Person1} is an RDF homomorphism from Q into G.
And the map 2 defined by {Faisal , Faisal ,?b1, ex : c1,
?name, Deema ,?b3, ex : Person2,?b4, ex : friend,?b2, ex :
c2} is an RDF homomorphism from P into G. Note that 2 cannot
be extended to an RDF homomorphism from Q into G since there
is no mailbox for Deema in G.

Theorem 1.
only if there is an RDF homomorphism from H into G.

Let G and H be two GRDF graphs, then GRDF H if and

The definition of RDF homomorphisms (Definition 9) is similar
to the map defined in Ref. [36] for RDF graphs. Ref. [36] provides
without proof an equivalence theorem (Theorem 3) between RDF

version of SPARQL, the reader is referred to the SPARQL specification
[56] or to Refs. [54,55] for formal semantics of SPARQL.
A SPARQL SELECT query is of the form SELECTBFROMuWHEREP
where u is the URL of an RDF graph G, P is a SPARQL graph pattern
and B is a tuple of variables appearing in P. Intuitively, an answer to
a SPARQL query is an instantiation  of the variables of B by terms
of the RDF graph G.

Such an instantiation, called a variable assignment, is a map from
a set of variables to terms. Any homomorphism is a map too (the
converse is not true). Hence, we can define operations on maps that
will be used for maps, assignments and homomorphisms.

3.1.1. Operations on maps
If  is a map, then the domain of , denoted by dom(), is the
subset of T where  is defined. The restriction of  to a set of terms X
is defined by |X = {x, y |x  X} and the completion of  to a set
of terms X is defined by |X =   {x, null|x  X and x / dom()}.
If P is a graph pattern, then (P) is the graph pattern obtained
by the substitution of (b) to each variable bB(P). Two maps
1 and 2 are compatible when x  dom(1)  dom(2), 1(x) =
2(x). If 1 and 2 are two compatible maps, then we denote
by  = 1  2 : T1  T2  T the map defined by: x  T1, (x) =
1(x) and x  T2, (x) = 2(x). Analogously to Ref. [54] we define
the join of two sets of maps 1 and 2 as follows:
 (join) 1	2 = {1  2|1  1, 2  2 are compatible};
 (difference)
compatible}.

1 \ 2 = {1  1|2  2, 1 and 2 are not

Ref. [55] defines different semantics for the join operation when
the maps contain null value, and their effects in the answers are
outlined.

Definition 11 (Answers to a SPARQL graph pattern). Let P be a
SPARQL graph pattern and G be an RDF graph. The set S(P, G) of
answers to P in G is defined inductively in the following way:
S(P, G) = {|B(P)|G  (P)} if P is a GRDF graph
S((PANDP

S(PUNIONP
S(POPTP

S(PFILTERR, G) = { S(P, G)|(R) = }

), G) = S(P, G)	S(P

, G) = S(P, G)  S(P

, G) = (S(P, G)	S(P

, G)

, G)
, G))  (S(P, G) \ S(P

, G))

(4)

(2)

(5)

(1)

(3)

As usual for this kind of query languages, an answer to a query
is an assignment of distinguished variables (those variables in the
SELECT part of the query). Such an assignment is a map from variables in the query to nodes of the graph. The defined answers
may assign only one part of the variables, those sufficient to prove
entailment. The answers are these assignments extended to all distinguished variables.

to

SPARQL

(Answers

query). Let Q =
Definition 12
B FROM u WHERE P be a SPARQL query, G be the RDF
SELECT
graph identified by the URL u, and S(P, G) is the set of answers
to P in G, then the answers to the query Q are the restriction and
completion to B of answers to P in G, i.e., ANS(Q ) = {|BB
| S(P, G)}.
From Theorem 1, this definition corresponds to the definition

given in Ref. [54]:

Consequence 1 (Answers to SPARQL graph patterns and homo-
morphisms).
Let P be a GRDF graph and G be an RDF graph. The

the set of answers, ASK that returns TRUE if there is a answer to a given query and
FALSE otherwise, and DESCRIBE that can be used for describing a resource RDF graph.

set S(P, G) of answers to P in G is
S(P, G) = {|B(P)| is an RDF homomorphism from P into G}

Example 6. Consider the following SPARQL query Q:

SELECT ?name?mbox
FROM <http://example.org/index1.ttl>
WHERE {P OPT{(?b2, foaf : mbox, ?mbox)}}

such that P is the GRDF graph of Fig. 3, and the RDF graph identified by the uriref of the FROM clause is the graph G of Fig. 4. We
construct the answer to the query by taking the join of homomorphism Q into G and the homomorphism from the optional triple
into G; i.e., the homomorphisms from Q into G, e.g., the homomorphism 1 of Example 5, and the homomorphisms from P into G that
cannot be extended to include the optional triple, e.g., the homomorphism 2 of Example 5. There are therefore two answers to the
query:

?name

Deema
Natasha

?mbox

null
natasha@example.org

Hence, what we have done so far is only to provide a semantic definition of answers to SPARQL queries (through Definitions
11 and 12) and to show that this definition exactly corresponds to
the original SPARQL definition (though Consequence 1). We have
gained two benefits in doing this:
 Finding an RDF homomorphism is now one way to find SPARQL
answers which is complete and correct; other ways may be
designed.
 Extensions of SPARQL can be defined semantically and the proposed evaluation strategies, like finding a particular kind of
homomorphism, can be compared with this definition. So extensions can be defined in the same way as SPARQL.

This is what we will do in the next sections.

3.1.2. SPARQL complexity

To evaluate the complexity of SPARQL, we consider the decision problem which consists of checking if a given assignment is an
answer and is called SPARQL QUERY EVALUATION:

SPARQL QUERY EVALUATION[54]
Instance: an RDF graph G, a graph pattern P and an assignment .
Question: Is  S(P, G)?

SPARQL QUERY EVALUATIONis shown to be PSPACE-complete for
SPARQL graph patterns [54]. Restricting the graph pattern constructs to the AND, FILTER and UNION operators makes it
NP-complete. This problem is equivalent to that of checking the
existence of a solution.

3.2. Regular expression patterns for path queries

Regular expressions are the usual way for expressing path
queries [27,28,21,2,31,46]. Informally, the set of answers to a path
query R over a database graph G is the set of all pairs of nodes in
G connected by a directed path such that the concatenation of the
labels of the arcs along the path forms a word that belongs to the
language denoted by R.

3.2.1. Languages and regular expression patterns

Let 	 be an alphabet. A language over 	 is a subset of 	

: its
elements are sequences of elements of 	 called words. A (non-

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

empty) word (a1, . . . , ak) is denoted by a1    ak. If A = a1    ak
et B = b1    bq are two words over 	, then A  B is the word over 	
defined by A  B = a1    ak  b1    bq. Regular expressions can
be used for defining languages over 	.

Definition 13 (Regular expression). Let 	 be an alphabet, the set
R(	) of regular expressions is inductively defined by:
 a 	, aR(	) and !aR(	);
 R(	);
 If AR(	) and BR(	) then A|B, A  B, A

+ R(	).

, A

such that !a is the complement of a over 	, A|B denotes the
 the

disjunction of A and B, A  B the concatenation of A and B, A
Kleene closure, and A

+ the positive closure.

We have restricted regular expressions to atomic negation in
order to have a reasonable time complexity in the query language
that we are building. However, the semantics, soundness and completeness results as well as the algorithms defined throughout this
paper still work with non-atomic regular expressions [12].

3.2.1.1. Introduction of variables. More general forms of regular
expressions are the ones that include variables, we call them regular
expression patterns. Their combined power and simplicity contribute to their wide use in different fields. For example, in Ref.
[31], in which they are called universal regular expressions, they are
used for compiler optimizations. In Ref. [46], they are called p arametric regular expressions, and are used for program analysis and
model checking. The use of variables in regular expression patterns
is different from the use of variables in Unix (regular expressions
with back referencing in Ref. [4]). A variable appearing in a regular
expression pattern matches any symbol of the alphabet or any vari-
able, while a variable in regular expressions with back referencing
can match strings. Matching strings with regular expressions with
back referencing has been shown to be NP-complete [4].

Definition 14 (Regular expression pattern). Let 	 be an alphabet, X
be a set of variables, the set R(	, X) of regular expression patterns
is inductively defined by:
 a 	, aR(	, X) and !aR(	, X);
 x  X, x R(	, X);
 R(	, X);
 If AR(	, X) and BR(	, X) then A|B, A  B, A

+ R(	, X).

, A

The language generated by a regular expression pattern R,

(R), is given in the following definition.

denoted by L

Definition 15 (Language defined by a regular expression pattern). Let
 R(	, X) be
	 be an alphabet, X be a set of variables, and R, R

(R) is the set of words of (	  X)
regular expression patterns. L
defined by:
() = {};
(a) = {a};
(!a) = 	 \ {a};
(x) = 	  X;
(R|R
(R  R
(R
(R

) = {w|w  L
) = {w  w

+) = {w1    wk|i [1 . . . k], wi  L
) = {}  L
(R

(R)  L
|w  L
+).

(R) and w

)};
(R
(R)};

(R

)};

With regard to a more traditional definition of the language generated by a regular expression, our definition ranges over 	  X.
This is necessary because variables may match variables in GRDF
graphs.

3.2.2. Paths in graphs and languages

Informally, a pair of nodes x, y in a given graph satisfies a lan-
(R) if there exists a directed path from x to y in the graph
guage L
such that the word obtained from the concatenation of arc labels
(R). We define this notion more precisely. First
along the path is in L
we define the notion of a path in a graph and the word associated
to this path.
Definition 16 (Path in a directed graph). Let G = N, E, ,  be a
directed labeled graph, let x and y be two nodes of N, a path from x
to y is a non-empty list of arcs (a1, . . . , ak) of E such that 1(a1) = x,
2(ak) = y, and for all 1  i < k, 2(ai) = 1(ai+1).
Definition 17 (Word associated to a path). Let G = N, E, ,  be
a labeled directed graph, whose arcs are labeled over an alphabet
	  X, the word (P) = (a1)    (ak) over (	  X)
is associated
to the path P = (a1, . . . , ak) of G.


Then, we establish when a path satisfies a regular expression

patterns as defined above.
Definition 18 (Satisfaction of a regular expression pattern). Let G =
N, E, ,  be a directed labeled graph where the arcs are labeled
by elements of an alphabet 	 and X a set of variables, a pair x, y
of nodes of G satisfies a regular expression pattern over 	 and X, if
one of the following conditions is satisfied:

 there exists a path P from x to y in G and a map  from 	  X to
term(G) such that (P) L

(R) and x = y; or

((R)).

The definition involves a map  which ensures that variables
which are matched against several arcs in the path  because of
multiple occurrences in the regular expression pattern or because
+  match the same label (predicate or variof repetitions like in x
able) in G. In fact, the same definition without the introduction of 
would treat variables in regular expression patterns as wildcards,
i.e., each occurrence of a variable would behave independently of
the other ones, e.g., x  a  x would behave exactly like x  a  y. Our
definition of regular expression patterns is thus more powerful than
regular expression with wildcards which is more powerful than
simple regular expressions.

3.2.3. Regular expression patterns as queries

Let G be an RDF graph, and R be a regular expression pattern over
	 and X. An answer to R in G is a triple (x, y, ) (where x et y are two
nodes and  is a map from terms of R to terms of G) such that there
exists a path P from x to y and a word w  L
(R) with (P) = (w).
Example 7. Consider the RDF graph G of Fig. 4, and the regular
+  ?b5. Intuitively,
expression pattern R = (ex : son|ex : daughter)
this regular expression pattern encodes the paths from the entity
x to the entity y such that y has a relation, by any predicate, with a
descendant of x. The answers to R are:
{ex : c1, ex : c3,{?b5, ex : son},
ex : c1, ex : Person1,{?b5, ex : friend},
ex : c1, ex : Person2,{?b5, ex : friend},
ex : c1, ex : Person3,{?b5, ex : friend}}

The decision problem for the satisfiability of regular expression

patterns is defined as follows:

PATH SATISFIABILITY[61]
Instance: a directed labeled graph G, two nodes x, y of G, and a
regular expression pattern RR(	, X), where 	  V(G).
Question: Is there a map  from 	  X to term(G) such that the
pair x, y satisfies L

((R))?

We have established the complexity results for two classes of
regular expression patterns. First, when paths are reduced to regular expressions, they satisfiability can be checked efficiently.

PATH SATISFIABILITYin which X =  (RR is a regProposition 1.
ular expression that does not contain variables) can be decided
inNLOGSPACEin G and R.

Then, when paths contain variables, checking satisfiability
requires to find a map from the regular expression pattern to the
graph. This increases complexity.

Proposition 2.

PATH SATISFIABILITYis inNP.

3.3. Discussion

We have presented in this section the SPARQL query language
and we have provided its semantics with regard to RDF entailment.
We have also presented regular expression patterns. Although regular expression patterns can easily capture information along paths
in a graph (they are good for graph traversals), they are not powerful enough as a query language for RDF and for processing queried
information. Furthermore, both approaches are incomparable, i.e.,
there are some queries that can be expressed by one approach and
cannot be expressed by the other (cf. Section 1).

In order to benefit from the query capabilities of both query
frameworks, we will extend SPARQL with regular expression pat-
terns. To that extent, we will replace the graph patterns of SPARQL
queries with graph patterns embedding regular expression patterns
that we call Path RDF graphs or simply PRDF graphs. This will require
extending RDF syntax, semantics, and the inference mechanism
used for SPARQL, i.e., RDF homomorphism, with path semantics as
we will see in the following section.

4. Path RDF graphs: syntax, semantics, and inference
mechanism

PRDF graphs are GRDF graphs where predicates in the triples
are regular expression patterns constructed over the set of urirefs
and the set of variables. We extend the RDF semantics to take into
account these constructs. Section 4.1 presents its abstract syntax,
and its semantics is presented in Section 4.2. Section 4.3 presents an
inference mechanism for checking if a PRDF graph is a consequence
of a GRDF graph. This mechanism will be used for calculating the
set of answers to a PRDF graph over a GRDF graph when using PRDF
graphs for constructing PSPARQL graph patterns.

4.1. PRDF syntax

Since arcs in GRDF graphs are labeled by the elements of U  B,
path queries will be defined by regular expression patterns over U
and B.

We denote by Path RDF, or PRDF, the extension to GRDF with
regular expression patterns used in the predicate position of PRDF
triples.
Definition 19 (PRDF graph). A PRDF triple is an element of T 
R(U,B)  T. A PRDF graph is a set of PRDF triples.

All PRDF graphs with atomic predicates are not necessarily RDF
graphs, but they are GRDF graphs [41]. A PRDF graph can be represented graphically in the same way as a GRDF graph in which arcs
can be labeled by elements of R(U,B).

4.1.1. Notations
Let R be a regular expression patterns, uU(R) if u U and U is
the smallest set such that RR(U,B). In the same way, bB(R) if
b B and B is the smallest set such that RR(U, B). Let G be a PRDF

Fig. 5. A PRDF homomorphism from a PRDF graph to a GRDF graph represented in
dashed lines.

graph, pred(G) is the set of regular expression patterns appearing
as a predicate in a triple of G. Let UB(R) = U(R)  B(R), R pred(G).
Then term(G) = subj(G)  UB(R)  obj(G).

For example, the graph P of Fig. 5 searches among any related one
to Faisals descendants, the names and email addresses of people
who know Faisal.

4.2. PRDF semantics: interpretations and models

Since the terminology of RDF is the one used for PRDF, RDF
interpretations remain unchanged in the case of PRDF. However,
an RDF interpretation has specific conditions to be a model for a
PRDF graph. These conditions are the transposition of the classical
path semantics within the RDF semantics.
Definition 20 (Support of a regular expression pattern). Let I =
IR, IP, IEXT , IS, IL be an interpretation of a vocabulary V = U  L, I

be an extension of I to B  B, and RR(U, B), a pair x, y of (IR  IR)
 if and only if one of the two following conditions is
supports R in I
satisfied:
(i) the empty word  L
(ii) there exists a word of length n  1w = w1    wn where
(R) and wi  U  B (1  i  n), and a sequence of resources
(wi)), 1  i  n.

w  L
of IRx = r0, . . . , rn = y such that ri1, ri IEXT (I

(R) and x = y;

Instead of considering paths in RDF graphs, Definition 20 considers paths in the interpretations of PRDF graphs, i.e., paths are now
relating resources. This definition is the semantic substitute for the
satisfaction of a regular expression pattern by two nodes (Definition
18). It has the same function: ensuring that variables have only one
) which
image. This is achieved by the extension to variables (I
plays the same role as  in Definition 18.

It is used in the following definition of PRDF models in which it
replaces the direct correspondences that exists in RDF between a
relation and its interpretation (see Definition 5), by a correspondence between a regular expression pattern and a sequence of
relation interpretations. This allows to match regular expression
patterns, e.g., r

+, with variable length paths.

Definition 21 (Model of a PRDF graph). Let G be a PRDF graph, and
I = IR, IP, IEXT , IS, IL be an interpretation of a vocabulary V  V(G).
 of I
I is a PRDF model of G if and only if there exists an extension I
(o) supports R
to B(G) such that for every triple s, R, o G, I
in I

This definition extends the definition of RDF models (Definition
5), and they are equivalent when all regular expression patterns

(s), I

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

Example 8.
Fig. 5 shows a PRDF homomorphism from the PRDF
graph P into the RDF graph G. Note that the path satisfying the regular expression pattern of P is one of those given in Example 7.

The existence of a PRDF homomorphism is exactly what is
needed for deciding entailment between GRDF and PRDF graphs:

Theorem 3.
there is a PRDF homomorphism from H into G iff GPRDF H.

Let G be a GRDF graph, and H be a PRDF graph, then

This result, which proof is in appendix, shows that, as for RDF,
there is an equivalence between PRDF homomorphisms and entailment of a PRDF graph by a GRDF graph. So, testing the entailment
between PRDF graphs and RDF graphs, can be reduced to the
PRDFGRDF HOMOMORPHISM problem.

PRDFGRDF HOMOMORPHISM
Instance: a PRDF graph H and a GRDF graph G.
Question: Is there a PRDF homomorphism from H into G?

Since any solution can be checked by checking as many times
as there are edges in the query an instance of the PATH SATISFIABILITY
problem, the problem is subject to its satisfaction checking. Since
PATH SATISFIABILITY is in NP and PRDFGRDF HOMOMORPHISM contains RDF
HOMOMORPHISM which is equivalent to SIMPLE RDF ENTAILMENT, an NPcomplete problem, then PRDFGRDF HOMOMORPHISM is NP-complete.
The next section presents how this framework is used to extend
the SPARQL query language, and Section 6 presents algorithms for
enumerating the answers to such queries, i.e., computing PRDF
homomorphisms.

5. The PSPARQL query language

We have defined, in the previous section, the syntax and the
semantics of PRDF, where regular expression patterns can be used
in the predicate position of PRDF graphs. The PSPARQL query language is built on top of PRDF in the same way that SPARQL is built
on top of RDF. Section 5.1 presents the syntax of PSPARQL. Section 5.2 defines the answer to a given PSPARQL query following the
framework of Ref. [54], as well as an evaluation algorithm. Finally,
Section 5.3 presents the complexity study of evaluating PSPARQL
graph patterns.

5.1. PSPARQL syntax

PSPARQL graph patterns are built on top of PRDF in the same way
that SPARQL graph patterns are built on top of RDF, by building on
basic graph patterns which are here PRDF graphs instead of GRDF
graphs.

Definition 23 (PSPARQL graph patterns). A PSPARQL graph pattern
is defined inductively in the following way:
 every PRDF graph is a PSPARQL graph pattern;
 if P, P
then (PANDP
graph patterns.

 are PSPARQL graph patterns and R is a SPARQL constraint,
), and (PFILTERR) are PSPARQL

), (PUNIONP

), (POPTP

Example 9. The following PSPARQL graph pattern P

R are reduced to atomic terms, i.e., urirefs or variables. Moreover,
GRDF graphs are PRDF graphs with the regular expression patterns
used to label the arcs restricted to atomic regular expression pat-
terns.

If G is a PRDF graph with pred(G)  U  B, i.e., G is
Proposition 3.
a GRDF graph, and I be an interpretation of a vocabulary V  V(G),
then I is an RDF model of G (Definition 5) iff I is a PRDF model of G
(Definition 21).

4.2.1. Complexity of PRDFGRDF entailment

We associate the following decision problems to the entailment

between PRDF graphs.

PRDF ENTAILMENT
Instance: a PRDF graph G and a PRDF graph H.
Question: Does GPRDF H?

We have studied independently the PRDF ENTAILMENT problem [8]
which is useful if one wants to consider query containment for
instance. For the purpose of defining a query language, we will only
deal with the simpler PRDFGRDF ENTAILMENT problem:

PRDFGRDF ENTAILMENT
Instance: a GRDF graph G and a PRDF graph H.
Question: Does GPRDF H?

This problem is at least NP-hard, since it contains SIMPLE RDF
ENTAILMENT, an NP-complete problem. However, when the entailed
graph, i.e., the query, is ground, this problem can be decided in
NLOGSPACE.

Theorem 2.
thenPRDFGRDF ENTAILMENTis inNLOGSPACE.

Let G be a GRDF graph and H be a ground PRDF graph,

The following section shows the complexity of the latter problem through the equivalence between PRDFGRDF ENTAILMENT and
PRDFGRDF HOMOMORPHISM.

4.3. PRDF homomorphisms

In order to answer queries, it is necessary to find homomorphisms between PRDF graph patterns and the database. We
consider that the database is made of simple GRDF graphs, so we
only investigate homomorphisms between PRDF graphs and GRDF
graphs.

This section presents a restriction of PRDF homomorphism
for checking if a PRDF graph is a consequence of an RDF graph.
It extends RDF homomorphisms to deal with nodes connected
with regular expression patterns, that can be mapped to nodes
connected by paths. PRDF homomorphism will then be used for
answering PRDF graphs over RDF graphs.

(R) and (s) = (o); or

Definition 22 (PRDF homomorphism). Let G be a GRDF graph, and
H be a PRDF graph. A PRDF homomorphism from H into G is a map
 from term(H) into term(G) such that: s, R, o H, either
(i) the empty word  L
(ii) n0, p1, n1, . . . ,nk1, pk, nk in G such that n0 = (s), nk =

(o), and p1    pk  L
Definition 22 is equivalent to s, R, o H, (s), (o) satisfies
(R) in G (Definition 18). This means that we can reformulate the
definition using Definition 18. If R is a regular expression pattern,
then (R) is the regular expression pattern obtained by substituting
(x) to each atom x in R. Also (thanks to Definition 8), (x) = x where
x U: no mapping is needed in that case.

((R)).

Table 1
PSPARQL graph pattern grammar.
[21]

[30.1]

[31.1]
[32.1]
[33.1]
[34.1]
[35.1]

[36.1]
[37.1]
[38.1]

[39.1]
[39.2]
[39.3]

TriplesBlock : :=PathTriples1
|( . PathTriples1?)
PathTriples1 : :=VarOrTermPathPropLNE
|PathTripleNodePathPropL
PathPropL : :=PathPropLNE?
PathPropLNE : :=PathVerbPathObL( ; PathPropL)?
PathObL : :=PathGraphNode( , PathObL)?
PathVerb : :=RegularExp
PathTripleNode : :=PathCollection
|PathBNodePropL
PathBNodePropL : := [ PathPropLNE ]
PathCollection : := ( PathGraphNode +  )
PathGraphNode : :=VarOrTerm
|PathTripleNode
RegularExp : :=Rexp(( | |   )Rexp)
Rexp : :=( +  |   )?Atom
Atom : := ! IRIref 
|VarOrIRIref 
| ( RegularExp )

consists of the following basic graph patterns, i.e., PRDF graphs,

and constraint:
P = (P1AND (P2UNION (P3FILTERR))), where
P1 = {ex : Paris(ex : train|ex : plane)+?City.}
reachable from Paris by a sequence of trains or planes;
P2 = {?Cityex : capitalOf?Country.}
that finds capital cities
together with their countries;
P3 = {?Cityex : populationSize?Population.} that finds cities and
their population size;
R = Filter(?Population > 200,000) is a constraint that restricts
the values of the variable ?Population to be greater than 200,000.

that finds cities

5.1.1. PSPARQL query

A PSPARQL query is of the form SELECTBFROMuWHEREP. The only
difference with a SPARQL query is that, this time, P is a PSPARQL
graph pattern, i.e., a PRDF graph. The use of variables in PRDF regular
expression patterns is a generalization of the use of variables as
predicates in the basic graph patterns of SPARQL.

As PSPARQL introduces PRDF graph patterns, we give in Table 1
the necessary modifications to the SPARQL grammar [56] in the
extended BackusNaur form, where the production rule [21]
replaces [21] in SPARQL, and all other rules are added to SPARQL
grammar to have a complete grammar for PSPARQL (see also
psparql.inrialpes.fr).

Example 10. The following PSPARQL query:

searches the first element of a collection (a list) containing
an element X. For instance, if queried against an RDF graph
reduced to the list [A B X C ], it will return the answers
{?First, A ,?First, B ,?First, X }. However, if we use +
instead of *, then X is not an answer.

5.2. Evaluating PSPARQL queries

As in the case of GRDF, the answer to a query reduced to a PRDF
graph is also given by an assignment to distinguished variables.
The definition of an answer to a PSPARQL query will thus be identical to that given for SPARQL in Section 3.1 (but it will use PRDF
entailment).

Definition 24 (Answers to a PSPARQL graph pattern). Let P be a
PSPARQL graph pattern and G be an RDF graph, the set S(P, G) of
answers to P in G is defined inductively in the following way:

 if P is a PRDF graph, S(P, G) = {|B(P)|GPRDF (P)};
 (2,3,4,5) are the rules used to define answers to SPARQL graph
patterns of Definition 11.

The answers to a PSPARQL query are defined from the answers
to PSPARQL graph patterns, exactly like answers to a SPARQL query
in Definition 12.

As a consequence of Theorem 3, PSPARQL answers can be computed through PRDF homomorphisms because they corresponds to
PRDFGRDF ENTAILMENT.

Consequence 2 (Answers to PSPARQL graph patterns and PRDF
homomorphisms). Let P be a PRDF graph and G be an RDF graph,
the set S(P, G) of answers to P in G is

S(P, G) = {|B(P)| is a PRDF homomorphism from P into G}

This means that it is possible to obtain answers to PSARQL

queries by computing PRDF homomorphisms.

Example 11. According to Consequence 2, the set of answers to
the PSPARQL graph pattern P of Example 9 in a given RDF graph G
is defined as:

P = (S(P1, G)	(S(P2, G)  ({ S(P3, G)|(R) = })))

In words, the set of maps, i.e., PRDF homomorphisms, from P1
into G joined with the union of that from P2 into G and those from
P3 into G that satisfy the constraint R.

Example 12. The following PSPARQL query that uses the graph
pattern P of Example 9:

returns in an ascending order the set of cities reachable from
Paris by a sequence of trains and planes, which are either capital
cities or have a population size greater than 200,000.

5.3. PSPARQL complexity

We define the PSPARQL QUERY EVALUATIONdecision problems for
PSPARQL in the same way as for SPARQL. This problem depends on
calculating PRDF homomorphisms, and hence it is parameterized
by the PRDF HOMOMORPHISM problem.

PSPARQL QUERY EVALUATION
Instance: an RDF graph G, a PSPARQL graph pattern P and a assignment .
Question: Is  S(P, G)?

We have studied the PSPARQL QUERY EVALUATION problem for basic
graph patterns. We have first considered ground graph patterns,
which is reduced to checking if a given map is a PRDF homomor-
phism. So there is no need to seek such a map, and the REGULAR PATH
problem is considered in this case (see Appendix). Theorem 4 shows
that PSPARQL QUERY EVALUATION for ground basic graph patterns is no
more difficult than REGULAR PATH (defined in Appendix).

Theorem 4.
graph patterns andNP-complete for basic graph patterns.

PSPARQL QUERY EVALUATIONis inNLOGSPACEfor ground basic

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

The complexity of PSPARQL QUERY EVALUATION for basic graph patterns is thus the same as SPARQL QUERY EVALUATION for basic graph
patterns [36]. Since PSPARQL queries are the same as SPARQL
queries with the difference of the kind of basic graph patterns and
since PSPARQL QUERY EVALUATIONfor PRDF graphs is in NP, our extension does not increase the worst case complexity of SPARQL, i.e.,
PSPACE-complete [54].

6. Answering PSPARQL queries: algorithms for PRDF
homomorphism

To answer a PSPARQL query Q involving PRDF graphs as basic
graph patterns, mandates to enumerate all PRDF homomorphisms
from the graph pattern(s) of Q into the data RDF graph of Q. So, we
are interested in an algorithm which, given a PRDF graph H and an
RDF graph G, answers the following problems:

Table 2
Notations for complexity analysis.

Name

vars
predicateSize

maps

Meaning

the number of variables.
the maximum predicate size appearing in G or as a term in
R.
the number of possible maps from variables and variables
of R into terms of G that match some path in G with some
path in R; the worst case is pred(G)vars(R).

successive joins in the algorithm Eval (Algorithm 2), whose initial
call will be Eval(P, G,{}), where  is the map with the empty
domain.

The Eval algorithm is given for evaluating PRDF graphs, and can
be extended to evaluate PSPARQL graph patterns following the Eval
algorithm for evaluating SPARQL graph patterns [54].

Algorithm 1. Evaluate(t, G).

(1) Is there a PRDF homomorphism from H into G? (PRDFGRDF

HOMOMORPHISM).

(2) Exhibit, if it exists, a PRDF homomorphism from H into G.
(3) Enumerate all PRDF homomorphisms from H into G.

Two possible methods can be used for solving these problems: a
method based on evaluating the PRDF graph triple-by-triple is presented in Section 6.1; a backtracking method based on the standard
backtrack techniques is presented in Section 6.2.

6.1. Triple-by-triple evaluation

One possible method to enumerate all PRDF homomorphisms
from a given PRDF graph H into an RDF graph G is to evaluate
the graph H triple-by-triple and take the join of the intermediate results. This method is similar to the edge-by-edge evaluation
method presented in Ref. [28].

Refs. [46,31] present the algorithm Reach(G, R, s, i) (see also
Appendix B), where G is a graph (for us, an RDF graph), R is a regular
expression patterns, and s is a node of G. This algorithm calculates
the set of triples s, o, , where o is a node of G and  is a map from
terms of R into terms of G such that there exists a path P from s to
o in G and a word w  L
(R) with (P) = (w) and i is compatible
with .

The Reach(G, R, s, i) algorithm is used by the algorithm E valuate (Algorithm 1), which, given an RDF graph G and a PRDF triple
x, R, y, calculates the set of maps  such that (x), (y) satisfies
R in G with the map  (it is said that  satisfies x, R, y in G).

The results of the algorithm Evaluate are used to calculate the
PRDF homomorphisms of a PRDF graph P into an RDF graph G by

Algorithm 2. Eval(P, G, ).

6.1.1. Algorithmic time complexity
The Reach algorithm has worst-case time complexity O(|G| 
|Ri|  maps  (predicateSize + vars(Ri)))
(the notations used in
Table 2 are reformulated from Ref. [46] and adapted to our problem).
Now, for each triple x, Ri, y in P, the Reach algorithm is called by
the Evaluate algorithm once if x is a constant, i.e., a uriref or a literal
if it is allowed in the subject position; otherwise it is called for each
node in G multiplied by the number of variables in P in the subject
position. So, the E valuate algorithm has overall worst-case time
complexity O((varss(P)  subj(G) + consts(P))  |G|  |Ri|  maps 
(predicateSize + vars(Ri))), where varss(P) (respectively, consts(P)) is
the number of variables (respectively, constants) appearing in the
subject position in a triple of P.

This result shows an exponential complexity with respect to the
number of variables in the regular expression patterns of the PRDF
graph representing the query (O(pred(G)vars(R)))). However, the size
of the query, and in particular, the number of variables is usually
considered very small with regards to the knowledge base. Hence,
the number of variables in each regular expression pattern can be

Fig. 6. A case in which the path closure method is not efficient.

assumed a constant. With this assumption, the data complexity,
which is defined as the complexity of query evaluation for a fixed
query [60], is O(|G|2), i.e., not much worse than the one of SPARQL
[54].

Though the above method is correct and complete, it is not
efficient, in particular, for testing the existence of a PRDF homomorphism which is sufficient for checking if a PRDF graph is a
consequence of an RDF graph. Using this method, we need to perform the join operation for all PRDF triples to have the set of PRDF
homomorphism, while we need to test the existence of one PRDF
homomorphisms. Consider the PRDF graph P and the RDF graph of
Fig. 6. To test if there exists a PRDF homomorphism from P into G,
we need to solve PATH SATISFIABILITYN2 times for the regular expression pattern R in P, where N is the number of nodes of G. However,
we need to solve PATH SATISFIABILITY only once as it appears in Fig. 6.
More precisely, since the extremities of the regular expression R are
variables (namely, ?b6and ?b7), we need to check for each pair of
nodes x, y of G if they satisfy R in G while, in this example, ?b6 and
?b7 can be only mapped to ex:c1 and ex:c2, respectively. In such
a case, it is sufficient to determine whether the pair ex : c1, ex : c2
satisfies R in G.

The next section presents a backtracking algorithm for calculating the set of PRDF homomorphisms from PRDF graph into an RDF
graph. This algorithm has the same worst-case time as the triple-
by-triple method, but it is more efficient in practice since in some
cases there is no need to traverse all the backtrack tree to find the
first PRDF homomorphism.

Algorithm 3. Extendhomomorphism(H, G, partialProj).

complete(partialProj) checks if each term x  nodes(H) is mapped to
a term in G. It returns TRUE if all x  nodes(H) are mapped, and FALSE
otherwise.
chooseTerm(nodes(H)) chooses a term x  nodes(H).
candidates(partialProj, x, G) calculates all possible candidate images
in G for the current term x satisfying the partial map partialProj. It
returns all sets of pairs y, 
 such that y is a possible image of x,
and 
 is the possible map from the terms of each regular expression pattern Ri appearing in a triple with x and one of the terms
in nodes(H) already mapped in p artialProj. That is, if there is no
term in nodes(H) involved in a triple with x, then the possible candidate images of x are all y in nodes(G) such that x can be mapped
to y (cf. the definition of mapping Definition 8). Otherwise, there
exists a set of terms z1, . . . , zk  nodes(H) involved in a triple with x,
which are already mapped in partialProj. In this case, image(zi) and
y satisfies 
(Ri), where Ri is the regular expression pattern appearing in the predicate position of the triple between zi and x. The
order in which the two nodes image(zi) and y satisfy 
(Ri) depends
on the order in which x and zi appear in the triple, that is, if the
triple is zi, Ri, x then image(zi), y satisfies 
(Ri) in G, otherwise
y, image(zi) satisfies 
(Ri) in G. 
 maps the terms appearing in the
regular expression patterns of H into the terms appearing along
the paths in G with respect to partialProj, that is, 
 is a possible
map such that 
 and partialProj are compatible.

Then the algorithm takes each candidate y of the current term
x  nodes(H) and the possible map 
, put y in the image(x), and
tries to generate the possible candidates of y with the current map
partialProj	{x, y}	
 (note that partialProj, {x, y} and 
 are com-
patible, since the set y, 
 is calculated with respect to partialProj).
This is done recursively in a depth-first manner through the call
of Extendhomomorphism(H, G, partialProj	{x, y}	
). At the end of
the algorithm, we have a tree that contains one level with a term
from H, i.e., a node from H, and one level with the possible images
of that term in G. The input to each node of each level is the current
map. Each possible path in the tree from the root to a leaf labeled
by a term of G represents a possible PRDF homomorphism.

6.2. A backtrack algorithm for calculating PRDF homomorphisms

An alternative method for evaluating PSPARQL graph patterns,
i.e., enumerating all PRDF homomorphisms from the PRDF graph of
a given PSPARQL query into the data graph, is based on a backtracking technique that generates each possible map from the current
one by traversing the parse tree in a depth-first manner and using
the intermediate results to avoid unnecessary computations.

Algorithm 3 is a simple recursive version of the basic Backtrack
algorithm [34]. The input of this algorithm is: a PRDF graph, an RDF
graph, and a partial map, denoted by partialProj. partialProj includes
a set of pairs {xi, yi} such that xi is a term of H, i.e., xi  term(H), and
yi is the image of xi in G, i.e., yi  term(G).

The other parts of the algorithm perform as follows (see Ref. [10]

for a full description of the algorithm):

If we call Extendhomomorphism(H, G, partialProj) where
partialProj denotes the empty map, then at the end of the algorithm we have all PRDF homomorphisms from the PRDF graph H
into the RDF graph G.

Proposition 4. Algorithm 3 is correct and complete for enumerating
all PRDF homomorphisms from a given PRDF graph into an RDF graph.

This can be proved inductively because, at the beginning, the set
of all homomorphisms is complete for the empty set, and at each
step the partial homomorphism, i.e., partialProj, are completely
extended for the current node if Algorithm 4[46] is complete, and
the number of nodes being finite. The procedure ends having a
homomorphic image for each node in H.

In our case, we do not need to enumerate all paths but instead we
search the existence of paths satisfying (C)PRDF homomorphisms.

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

Fig. 7. An RDF graph and a NDFA. (a) An RDF graph with cycles. (b) A NDFA of
(?Trip)+.

Example 13. Consider the following PSPARQL query:

and the RDF graph of Fig. 7(a). As it is shown in this graph,
there are several cycles (going through Amman and Geneve) that
can generate an infinite number of paths. For example, considering
non-simple paths, we can generate:
{ex : Paris,ex : plane, ex : Amman, ex : plane, ex : Paris}
{ex : Paris,ex : plane, ex : Amman, ex : plane, ex : Paris, ex : plane, ex : Amman, ex : plane, ex : Paris}
etc.

8. Related work

Fig. 8. A G+ query to find common ancestor.

of Ref. [46]. They are used for calculating the satisfiability set of a
given regular expression pattern, to take into account the multiple
appearances of a given variable in different places of the query, i.e.,
to take into account the current mappings.

This evaluator successfully passed all test cases designed by Data
Access Working Group (DAWG) for the SPARQL query language3
except the ones that concern the DESCRIBE query format. In addi-
tion, the evaluator can parse PRDF graphs and evaluate PSPARQL
queries. It is currently being thoroughly tested for performances
and practical hard problem detection [10] as well as for the test
suite.4

We divide related works in four areas: graph query languages
with path expressions, RDF structural query languages, extensions
of SPARQL and work on defining RDF query language semantics.

8.1. (Semi)-structured query languages

Semi-structured data models [20,1] deal with data whose structure is irregular, implicit, and partial, and with schema contained
in the data.

Query languages for structured graph data models can be used
for querying RDF viewing RDF data as a graph that may contain
transitive or repetitive patterns of relations. Among them, G [27]
and its extension G+ [28] are two languages for querying structured databases. A simple G+ query has two elements, a query graph
that specifies the pattern to be matched and a summary graph that
defines graphically how the answers are to be structured and then
presented to the user

Example 14. Given a graph that represents relations between peo-
ple, the G+ query of Fig. 8 finds pairs of people who share a common
ancestor.

The left hand side of the bold arrow is the pattern to be matched
in the knowledge base while the right hand side is the summary
graph.

Graphlog  a visual query language which has been proven
equivalent to linear Datalog [25] extends G+ by combining it with
the Datalog notation. It has been designed for querying hypertext.
A Graphlog query is only a graph pattern containing a distinguished
edge or arc, i.e., it is a restructuring edge, which corresponds to the
summary graph in G+.

Example 15.
Fig. 9 shows a Graphlog query: dashed lines represent edge labels with the positive closure, a crossed dashed line
represents a negated label, e.g., !descendant+ between ?person2
and ?person3, person is a unary predicate, and finally a bold line
represents a distinguished edge that must be labeled with a positive label. The effects of this query is to find all instances of the
pattern that occur in the database, i.e., finding descendant of ?per-
son1 which are not descendant of ?person2. Then, for each one of
them, define a virtual link represented by the distinguished edge.

To overcome this problem, i.e., to cut cycles, our evaluation algorithm calculates all possible finite maps (or homomorphisms in the
case of (C)PRDF graphs).

To this end, we can go from Paris with a state 0 of the automata
corresponding to the regular expression (see Fig. 7(b)) to Amman
with a state 1 and a map {?Trip,ex : plane}, then we can return to
Paris since the state is different from the first visit to Paris (with a
state 1). A possible answer therefore is:
?Trip  {ex : plane}

A second answer is to go from Paris to Geneve through Grenoble,
and then Paris with a map {?Trip,ex : train} (we can take Paris
since the map is different from the first answer):
?Trip  {ex : train}
Now, we can also go from Paris to Geneve, through Grenoble, Lyon
and then Paris. However, this path is not explored since Paris is
already visited with the same map and state (second answer). Sim-
ilarly, when we arrive at Geneve or Amman for the second time,
we cut the cycles since they are already visited with the same map
and/or state.

For illustrating non-simple paths, consider the following

PSPARQL query:

In simple paths, nodes must not be visited more than once. If
we consider simple paths in this example, then we cannot retrieve
Amman since we cannot go through the path Paris, Geneve, Greno-
ble, Paris, and then Amman (Paris has been visited twice).

7. Implementation and experiments

We have implemented in Java a PSPARQL query evaluator.2 It is
provided with two parsers: one for parsing PSPARQL queries based
upon the syntax of PSPARQL, and the second one for parsing RDF
graphs (documents) written in the Turtle language [17].

The algorithm follows the backtrack technique presented before
and the evaluation of regular expression patterns generalizes those

2 http://psparql.inrialpes.fr/.

3 http://www.w3.org/2001/sw/DataAccess/tests/.
4 http://www.w3.org/2001/sw/DataAccess/tests/r2.

There are many real-world applications, inside and outside the
domain of the semantic web, requiring data representation that
are inherently recursive. For that reason, there has been several
attempts to extend relational algebra to express complex query
modeling. Outside the domain of the semantic web, Ref. [3] extends
the relational algebra to represent transitive closure and [42] to
represent query hierarchies. In the domain of RDF, some query languages such as RQL [43] attempt to combine the relational algebra
with some special class hierarchies. It supports a form of transitive expressions over RDFS transitive properties, i.e., subPropertyOf
and subClassOf, for navigating through class and property hierar-
chies. Versa [52], RxPath [58] and PRDF [11,9,47] are all path-based
query languages for RDF that are well suited for graph traversal but do not support SQL-like functionalities. WILBUR [45] is a
toolkit that incorporates path expressions for navigation in RDF
graphs.

SQL-like query languages for RDF include SeRQL [19], RDQL [57]

and its current successor, the SPARQL recommendation [56].

In contrast to all the above mentioned languages, PSPARQL uses
regular expression patterns, i.e., regular expressions with variables,
and is not restricted to finding simple paths. This provides polynomial classes of the satisfiability problem of regular expressions,
e.g., when they do not contain variables. The originality of our
proposal lies in our adaptation of RDF model-theoretic semantics to take into account regular expression patterns, effectively
combining the expressiveness of these two languages. In addition,
the integration of this combination on top of SPARQL provides a
wider range of querying paradigms than the above mentioned lan-
guages.

8.3. SPARQL extensions

Two extensions of SPARQL, which are closely similar to PSPARQL,
have been recently defined after our initial proposal [11]: SPARQLeR
and SPARQ2L.

SPARQLeR [44] extends SPARQL by allowing query graph patterns involving path variables. Each path variable is used to capture
simple, i.e., acyclic, paths in RDF graphs, and is matched against any
arbitrary composition of RDF triples between given two nodes. This
extension offers good functionalities like testing the length of paths
and testing if a given node is in the found paths. Since SPARQLeR is
not defined with a formal semantics, its use of path variables in the
subject position is unclear, in particular, when they are not bound.
Even when this is the case, multiple uses of the same path variable
is not fully defined: it is not specified which path is to be returned
or if the variable occurrences have to match the same path.

SPARQ2L [14] also allows using path variables in graph patterns
and offers good features like constraints in nodes and edges, i.e.,
testing the presence or absence of nodes and/or edges; constraints
in paths, e.g., simple or non-simple paths, presence of a pattern
in a path. This extension is also not described semantically. One
can only try to guess what is the intuitive semantics of the con-
structs. It seems that the algorithms are not complete with regard to
their intuitive semantics, since the set of answers can be infinite in
absence of constraints for using shortest or acyclic paths. Moreover,
this extension is quite restricted: it does not allow using more than
one triple pattern having a path variable. Relaxing this restriction
requires adapting radically the evaluation algorithm which otherwise is inoperative. This occurs due to the compatibility function
that does not take into account the use of the same path variable in
multiple triple patterns.

In both cases, the proposal adds expressivity to PSPARQL, in
particular due to the use of path variables. However, the lack of a
clearly defined semantics raises questions about what should be the
returned answers and this does not allow to assess the correctness
and completeness of proposed procedures.

Fig. 9. A Graphlog query.

These query languages (namely G, G+ and Graphlog) support
only graphical queries similar to PRDF queries. In contrast to PRDF,
they are limited to finding simple paths (cycle-free paths). The main
problem with finding only simple paths, is that there are situations
in which answers to such queries are all non-simple, e.g., if the only
paths matching a regular expression pattern have cycles (see end of
Example 13 or the example of non-simple paths in Ref. [14]). In addi-
tion, the complexity of finding simple paths problem is NP-complete
even without variables in regular expressions [61]. Moreover, they
do not provide complex functionalities, for example, for filtering,
ordering, projection, union of graph patterns, optional graph patterns and other useful features (see SPARQL features and examples
below).

Lorel [2] is an OEM-based language for querying semi-structured
documents. Object Exchange Model (OEM) [53] is based on objects
that have unique identifiers, and property value that can be simple
types or references to objects. However, labels in the OEM model
cannot occur in both nodes (objects) and edges (properties). Lorel
is a powerful query language which uses regular expression patterns for traversing object hierarchy paths, restricted to simple
path semantics (or acyclic paths; see why this matters in Example
13). UnQL [21] is a language closely related to Lorel for querying
semi-structured data. It is based on a data model similar to OEM
[22]. A particular aspect of the language is that it allows some
form of restructuring even for cyclic structures. A traverse construct
allows one to transform a database graph while traversing it, e.g.,
by replacing all labels A by the label A0. This powerful operation
combines tree rewriting techniques with some control obtained by
a guided traversal of the graph. For instance, one could specify that
the replacement occurs only if a particular edge is encountered on
the way from the root. STRUQL [32], a query language for a website management system, incorporates regular expressions and has
precisely the same expressive power as stratified linear Datalog.

As stated in Ref. [43], these query languages are not well suited
for RDF because they do not take into account its specific semantics.
This is not a real problem for RDF itself: the semantics being simple
enough this roughly manifests only in the lack of blank interpretation and the enforcing of strict typing constraints. However, this
prevents to extend further the query language towards ontology
languages such as RDFS or OWL.

8.2. RDF query languages

Several query languages have been proposed for RDF [37]. Most
of them use a query model based on relational algebra [24], where
RDF graphs are viewed as a collection of triples and the queries are
triple-based formulas expressed over a single relation. In spite of
the benefits gained from the existing relational database systems
such as indexing mechanisms, underlying storage of triples as relations [38], query optimization techniques, and others; relational
queries cannot express recursive relations and even the most simple form, the transitive closure of a relation [6], directly inherited
from the graph nature of RDF triples.

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

8.4. Work on SPARQL

Ref. [29] presents a relational model of SPARQL, in which relational algebra operators (join, left outer join, projection, selection,
etc.) are used to model SPARQL SELECT clauses. The authors propose
a translation system between SPARQL and SQL to make a correspondence between SPARQL queries and relational algebra queries over
a single relation. Ref. [38] presents an implementation of SPARQL
queries in a relational database engine, in which relational algebra
operators similar to Ref. [3] are used. Ref. [30] addresses the definition of mapping for SPARQL from a logical point of view. Ref. [33],
in which we can find a preliminary formalization of the semantics
of SPARQL, defines an answer set to a basic graph pattern query
using partial functions. The authors use high level operators (Join,
Optional, etc.) from sets of mappings to sets of mappings, but currently they do not have formal definitions for them, stating only
their types. Ref. [55] provides translations from SPARQL to Datalog
with negation as failure, some useful extensions of SPARQL, like set
difference and nested queries, are proposed. Finally, Ref. [54] presents
the semantics of SPARQL using traditional algebra, and gives complexity bounds for evaluating SPARQL queries. The authors use the
graph pattern facility to capture the core semantics and complexities of the language, and discussed their benefits. We followed their
framework to define the answer set to PSPARQL queries.

9. Conclusion and future work

In this paper, we have extended SPARQL with regular expressions patterns allowing path queries. In order to achieve this goal,
we have provided an extension of RDF graphs, called PRDF, in
which regular expression patterns are used as predicates. We provided the syntax and semantics of PRDF and proved the validity of
the homomorphism approach for finding entailment. Then PRDF
graphs have been used as graph patterns in SPARQL queries yielding the PSPARQL query language. We have defined semantically
SPARQL and shown that PSPARQL is an actual extension of SPARQL
replacing RDF entailment by PRDF entailment. We have shown that
finding PRDF homomorphism is a sound and complete approach for
answering PSPARQL queries over RDF graphs and we have provided
algorithms for calculating these answers. Finally, we proved that
the problem of PRDFGRDF entailment is NP-complete, as is RDF
entailment, and thus answering PSPARQL queries over RDF graphs,
remains PSPACE-complete.

This work, because it is grounded on a semantic redefinition of
SPARQL, is the first stone on which further extensions can be safely
built. Indeed, the semantic definition of the query language allows
to define simply new query languages either by changing data and
query languages or by changing the entailment regime of the query
language. The query answering procedure can also change and is
not restricted to simple homomorphisms. This approach is worth
because regular expression patterns are not the only extension that
could be considered for SPARQL. We mention below some work
that we have already done and other work that would be worth
pursuing.

We have shown here that using PRDF homomorphisms, which
are more complex than simple graph homomorphisms, works
for PSPARQL. We have also investigated various possible regular
expression pattern generators [12] and considered PRDF ENTAILMENT
with regard to these generators [8,10]. We have also been able to
add constraints to PSPARQL in CPSPARQL [13]. However, for dealing with queries against df (a subset of RDFS introduced in Ref.
[51]), we have found a procedure finding (C)PRDF homomorphisms
between a transformed query and the queried graph [10]. But when
considering expressive ontology languages, allowing the use of disjunction and negation in class definitions, the procedure will have
to go beyond homomorphisms.

Finally, PSPARQL itself has been extended with path variables
following SPARQ2L and SPARQLeR but providing a clear semantics
for the path variables [13]. This extension is implemented in the
PSPARQL prototype.

Appendix A. Proofs

Proof of Theorem 1. Let G and H be two GRDF graphs, then GRDF H
if and only if there is an RDF homomorphism from H into G. 
Proof. The proof of this theorem is an immediate consequence
of the proof of Theorem 3, since each GRDF graph is a PRDF
graph. Moreover, any PRDF homomorphism between GRDF graphs
is an RDF homomorphism and, by Proposition 3, PRDF entailment
applied to GRDF graphs is equivalent to RDF entailment. 
Proof of Consequence 1. Let P be a GRDF graph and G be an RDF
graph. The set S(P, G) of answers to P in G is
S(P, G) = {|B(P)| is an RDF homomorphism from P into G} 

Proof. We must show that to each RDF homomorphism  corresponds an assignment  such that GRDF (P) coinciding on B(P)
assignments and vice versa.
() Let G and P be two GRDF graphs and  be an RDF homomorphism from P into G. We want to show that there exists an
assignment  from X  B to T(G) such that GRDF (P) and |B(P) =
|B(P).

Assume an RDF homomorphism  from P into G. Since, 
preserves constants, its application is equivalent to that of the
assignment  = |B(P). Then, there exists the identity RDF homomorphism from (P) into G, then, by Theorem 1, GRDF (P).
() Let G and P be two GRDF graphs and  be an assignment from
X  B toT(G) such that GRDF (P). We want to show that there exists
an RDF homomorphism  from P to G such that |B(P) = |B(P).
Let  : X  T(G) be an assignment such that GRDF (P). According to Theorem 1, there exists an RDF homomorphism 1 from
(P) into G. Consider the map 2 from P to (P), such that if
x  dom(), then 2(x) = (x), otherwise, 2(x) = x. It is clear that
2 is an RDF homomorphism from P into (P) since s, p, o P,
2(s), 2(p), 2(o) (P). Now, the map defined by  = 1  2 is
an RDF homomorphism from P into G. 
PATH SATISFIABILITY in which X =  (RR is
Proof of Proposition 1.
a regular expression that does not contain variables) is in NLOGSPACE
in G and R. 
Proof. The labels of paths between x and y form a regular language Px,y [62]. So, construct a non-deterministic finite automaton
AG accepting the regular language Px,y with initial state x and final
state y (G can be transformed to an equivalent NDFA in NLOGSPACE).
(R), the language generated by
Constructing a NDFA M accepting L
R, can be done in NLOGSPACE. Constructing the product automaton
P, that is, the intersection of G and M, can be done in NLOGSPACE.
Checking if the pairs x, y satisfies L
(R) is equivalent to checking
(P) is not empty, and each of these operations can be
whether L
done in NLOGSPACE in P [48,7] (with the fact that the class of Logspace
transformations is closed under composition [16]). An automaton
(R) with M is constructed by taking the
for the intersection of L
product of the automaton for the two languages. That is, the states
of the product automaton are of the form s, u such that s is a
state of M and u is a node of G; and there exists a transition on
letter a (respectively, letter b) from a state s, u to another state
t, v if M has a transition on a (respectively, on letter !a 5) from s

5 !a is an atomic negation, i.e., a negated uriref.

to t and u, a, v G (respectively, u, b, v G and b /= a). The construction is similar to the one presented in Ref. [62] without atomic
negation. 

When regular expressions do not contain variables, there is no
need to guess a map and the problem is reduced to the following
decision problem [48,7]:

Lemma (Satisfiability lemma [40]). Each GRDF graph is satisfiable.

Proof. To each GRDF graph G we associate an interpretation of
V(G), noted ISO(G), called an isomorphic model of G. We prove that
ISO(G) is a model of G. It follows that every GRDF graph admits a
model, so it is satisfiable.

REGULAR PATH[48]
Instance: a directed labeled graph G, two nodes x, y of G, a map ,
and a regular expression pattern RR(U, B).
Question: Does the pair x, y satisfies L
Proof of Proposition 2.

PATH SATISFIABILITY is in NP. 

((R))?

Proof.
PATH SATISFIABILITY is in NP, since each variable in the regular
expression pattern R can be mapped (assigned) to p terms, where
p denotes the number of terms appearing as predicates in G. If the
number of variables in R is n, then there are (pn) possible assignments (mappings) in all. Once an assignment of terms to variables
is fixed, the problem is reduced to Path satisfiability (	  U), which
is in NLOGSPACE.
It follows that a non-deterministic algorithm needs to guess a
map  and check in NLOGSPACE if the pair x, y satisfies L
((R)). 
If G is a PRDF graph with pred(G)  U  B,
Proof of Proposition 3.
i.e., G is a GRDF graph, and I be an interpretation of a vocabulary
V  V(G), then I is an RDF model of G (Definition 5) iff I is a PRDF
model of G (Definition 21). 
Proof. We prove both directions of the proposition.
is an RDF model of G,

 of I to B(G) such that s, p, o G, I
 (Definition 21). Since pred(G)  U  B,  / L

() Assume that
then there

to B(G) such that s, p, o G,
 of
exists an extension I

Since pred(G)  U  B,
(o) IEXT (I
(s), I
(p))
(Definition 5).

 (Definition 20) (with a word w = p), i.e.,
(o) supports p in I
(s), I
I is also a PRDF model (Definition 21).
() Assume that I is a PRDF model of G, then there exists an
(o) sup-
(s), I
(p). So there
(p), w = p, and a sequence
(w))
(o) IEXT (I
(p)) (by replac-
(o), and w with p). So I is also an RDF model

extension I
ports p in I
exists a word of length = 1 where w  L
of resources of IR I
(Definition 20). So s, p, o G, I
(s), I
ing r0 with I
(Definition 5). 
Proof of Theorem 2.
PRDF graph, then PRDFGRDF ENTAILMENT is in NLOGSPACE. 
Proof. We prove first that the PRDFGRDF HOMOMORPHISM problem is in NLOGSPACE. If H is ground, for each node x in H, (x) is
determined in G. Then it remains to verify independently, for each
triple s, R, o in H, if (s), (o)= s, o satisfies (R) = R. Since
each of these operations corresponds to the case of PATH SATISFIA-
BILITY, in which 	  U and X = , the complexity of each of them is
NLOGSPACE (see Proposition 1) (Since H is ground, R does not contain
variables). So, the total time is also NLOGSPACE. Given the equivalence between PRDGGRDF ENTAILMENT and checking the existence
of PRDF homomorphism (Theorem 3), PRDFGRDF ENTAILMENTis thus
in NLOGSPACE. 
Proof of Theorem 3. Let G be a GRDF graph, and H be a PRDF graph,
then there is a PRDF homomorphism from H into G iff GPRDF H. 
We have proven Theorem 3 via a transformation to hypergraphs
following the proof framework in Ref. [15]. Since this requires a long
introduction to hypergraphs, we prefer here to give a simple direct
proof to Theorem 3.

(o) = r1 such that r0, r1 IEXT (I

Let G be a GRDF graph and H be a ground

(s), r1 with I

(s) = r0, I

(1) Construction of ISO(G).

term(G) and IR;

To each term x  term(G), we associate a distinct resource (x)
(if x  Lp, (x) = x) :
(i) IR = {(x)|x  term(G)}, note that  is a bijection between
(ii) IP = {(x)|x  pred(G)};
(iii) x U(G)  Lt(G), I(x) = (x);
(iv) p IP, IEXT (p) = {x, y IR  IR|
1(p), 
(2) Let us prove that ISO(G) is a model of G.
(a) ISO(G) is an interpretation of V(G) (Definition 3).
(b)  is an extension of ISO to B(G) (Definition 4).
(c) It remains to prove (Definition 5), that for all s, p, o G,
(s), (o) IEXT ((p)).
then (p) IP (1.ii).
Then IEXT ((p)) = {x, y IR  IR|s, o term(G) with (s) =
x, (o) = y ands, p, o G} (1.iv), i.e., (s), (o) IEXT ((p)).

s, p, o G,

1(y) G}.

1(x), 

If

If I is a model of G, then there exists an extension I

Proof. We prove both directions of Theorem 1.
() Assume that there exists a PRDF homomorphism  from H
into G ( : term(H)  term(G)). We want to prove that GPRDF H, i.e.,
that every model of G is a model of H. Consider the interpretation I
of a vocabulary V = U  L.
 of I to
B(G) such that s, p, o G, I
(p)) (Definition 5).
We want to prove that I is also a model of H, i.e., that there exists an
(o) supports
(s), I
extension I
R in I

(o) IEXT (I
 of I to B(H) such thats, R, o H,I

(s), I

 be the map defined by:
(x) =

  )(x),
(I
x,

if  is defined;
otherwise.

Let I
x T, I

We show that I

 verifies the following properties:
is an interpretation of V(H) (in particular,

(x) = I(x),

x  (V(H)  nodes(H))).6
 is an extension to variables of H, i.e., x V(H), I
(x) = I(x)
(Definition 4).
 satisfies the conditions of PRDF models (Definition 21), i.e.,
for every triple s, R, o H, the pair of resources I
(o)
supports R in I

(s), I

(1) I

(2) I

(3) I

Now, we prove the satisfaction of these properties:

, I

(x) = I

(x) = I(x).

(1) From the definition of I

  )(x) (definition of I

 interprets all x V(H). Moreover,
since each term x  (V(H)  nodes(H)) is mapped by  to a term
x V(G) and (x) = x, I
). Now, if (x) is
(x) (since (x) = x by Definition 22). Since
(x) = I(x). Otherwise,

(3) It remains to prove that for every triple s, R, o H, the pair of
 (by Definition 20):
(R) and (s) = (o) = y (y term(G),

(s) = (I
(y), and I

(2) x V(H), I
defined, I
(x) = I(x) (x V(H), Definition 4),

(x) = I

resources I
(i) If the empty word  L
Definition 22), then I

(x) = (I
(x) = I
(x) = I(x) (x V(H), definition of I
((o)) supports R in I
  )(s) = I

((s)), I

(o) = (I

The following lemma (called satisfiability lemma) will be used
to prove the theorem. We prove it through the construction of the
isomorphic model. A similar proof can be found in Ref. [40].

6 An interpretation can be a model of a PRDF graph H even if it does not interpret
all terms of H. This is due to the disjunction operator that occurs inside constrained
regular expressions.

F. Alkhateeb et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 5773

PSPARQL QUERY EVALUATION is true when there exist a PRDF homomorphism between P and G. On the other way, PRDFGRDF EVALUATION
is reduced to PRDFGRDF HOMOMORPHISM between G and (P). Since
PRDFGRDF HOMOMORPHISM is NP-complete, then PSPARQL QUERY EVALUATION is NP-complete for PRDF graphs. 

Appendix B. Reach algorithm

Algorithm 4 reuses the definition of matching two regular

expression patterns found in Ref. [46].

Matching. Let R1 and R2 be two regular expression patterns, then
R2 matches R1 under the mapping , denoted by match(R2, R1, ),
if one of the following conditions holds: (1) R1 = (R2); (2) R2 B
and R2 / dom(); (3) R1, R2 B and ((R2) = R1 or R2 / dom());
(4) R2 = #; (5) R2 =!R3, and recursively, R1 does not match R3; (6)
R1 = (e1, . . . , ek), R2 = (a1, . . . , ak), and recursively ei matches ai,
1  i  k, where ei, ai are the atomic elements of R1, R2, respec-
tively. For example, the regular expression pattern (?z  ?y) matches
the regular expression pattern (ex : train  ex : plane) with the
mapping {?z, ex : train,?y, ex : plane}.

Algorithm 4 uses a non deterministic finite automaton, denoted
by NDFA, that recognizes a language equivalent to a given regular
expression pattern. It can be constructed in the usual way (cf. [5]).

Algorithm 4. Reach(G, R, v0, i)

and

(s), I

((R))

(s) = I

(o) = I

(y). So I

(y). Hence, I

 (Definition 21).

(o) sup-
)(o) = I
ports R in I
(ii) If n0, p1, n1, . . . ,nk1, pk, nk in G such that n0 = (s),
nk = (o),
p1    pk  L
(cf. Definition
(p1)),. . .,
that
22).
It
follows

((o)) IEXT (I
(nk1), I
So the
two resources I

((s)), I
in I

  ),
((o)) supports (R) in I
((s)), I
we have x  term(H), I
((x)) and (x) term(G).
Moreover, we can choose every variable b appearing in H to
(o)
be interpreted by the resource of (b)). Hence, I
supports R in I

(n1) IEXT (I
((s)), I
(pk))
(Definition 5).
((o)) supports (R)
 = (I
 (since I

(s), I
 (since for every word w  (R), w  R).

(x) = I

() Assume that GPRDF H. We need to prove that there is a PRDF
homomorphism from H into G. Every model of G is also a model
of H. In particular, the isomorphic model ISO = IR, IP, IEXT , IS, IL
of G, where there exists a bijection  between term(G) and IR (cf.
the satisfiability lemma).  is an extension of ISO to B(G) such
that s, p, o G, (s), (o) IEXT ((p)) (Definition 5). Since ISO is
 of ISO to B(H) such that
a model of H, there exists an extension I
s, R, o, I
 (Definition 21). Let us consider
the function  = (
). To prove that  is a PRDF homomorphism
from H into G, we must prove that:

(o) supports R in I

1  I

(s), I

(1)  is a map from term(H) into term(G);
(2) x V(H), (x) = x;
(3) s, R, o H, either

(i) the empty word  L
(ii) n0, p1, n1, . . . ,nk1, pk, nk in G such that n0 = (s), nk =

(R) and (s) = (o); or

(o), and p1    pk  L

((R)).

(1) Since I

 is a map from term(H) into IR and 

1 is a map from IR
) is clearly a map from term(H) into

1  I
1term(G)).

1  )(x) = x.
1  I

into term(G),  = (

term(G) (term(H) I
(2) x V(H), I
(x) = (x) (Definition 4 and the satisfiability lemma.
x V(H), (
1  I
)(x) = (
(3i) If  L
(o) = r  IR (Definition 20), then (s) =
(s) = I
(R) and I
1  I
)(s) = 
1(r), and (o) = (
1(r). So (s) =
(
(o) = 
1(r).
(3ii) If there exists a word of length n  1w = a1    an where
(R) and ai  U  B(G) (1  i  k), and there exists a
w  L
(o) such that
sequence of resources of IRI
ri1, ri IEXT (I
(ai)), 1  i  k (Definition 20). It follows that
ni1, pi, ni G with ni = 
)(ai) (con-

ISO(G),
struction of
the satisfiability lemma). So (
1(r0) = n0, (
1(rk) = nk, and p1   
)(s) = 
1  I

1  I
pk  L
)(R)). 
((

(s) = r0, . . . , rk = I
1(ri), and pi = (
)(o) = 

)(o) = 

1  I

Proof of Consequence 2. Let P be a PRDF graph and G be an RDF
graph. The set S(P, G) of answers to P in G is
S(P, G) = {|B(P)| is a PRDF homomorphism from P into G} 

Proof. The proof is exactly the same as that of Consequence 3.1.1
by replacing RDF by PRDF , RDF homomorphisms by PRDF homomorphisms and Theorem 1 by Theorem 3. 
Proof of Theorem 4.
PSPARQL QUERY EVALUATIONis in NLOGSPACEfor
ground basic graph patterns and NP-complete for basic graph pat-
terns. 
Proof.
The first assertion (NLOGSPACE for ground PRDF graphs)
follows directly from Theorem 2. For the second assertion
(NP-complete), when reduced to PRDF graphs, PSPARQL QUERY EVALUATIONis equivalent to PRDFGRDF HOMOMORPHISM(Definition 12).
Indeed, PRDFGRDF HOMOMORPHISMcan be reduced to PSPARQL QUERY
