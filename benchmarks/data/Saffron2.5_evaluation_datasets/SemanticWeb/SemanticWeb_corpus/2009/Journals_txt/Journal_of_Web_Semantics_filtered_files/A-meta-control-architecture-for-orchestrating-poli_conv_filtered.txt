Available online at www.sciencedirect.com

Web Semantics: Science, Services and Agents

on the World Wide Web 7 (2009) 4056

A meta-control architecture for orchestrating policy enforcement

across heterogeneous information sources

Jinghai Rao, Alberto Sardinha, Norman Sadeh


School of Computer Science, Carnegie Mellon University, 5000 Forbes Avenue, Pittsburgh, PA 15213, USA

Received 18 August 2007; accepted 25 October 2007

Available online 3 December 2007

Abstract

There is increasing demand from both organizations and individuals for technology capable of enforcing sophisticated, context-sensitive policies,
whether security and privacy policies, corporate policies or policies reflecting various regulatory requirements. In open environments, enforcing
such policies requires the ability to reason about the policies themselves as well as the ability to dynamically identify and access heterogeneous
sources of information. This article introduces a semantic web framework and a meta-control model to orchestrate policy reasoning with the
identification and access of relevant sources of information. Specifically, sources of information are modeled as web services with rich semantic
profiles. Policy Enforcing Agents rely on meta-control strategies to dynamically interleave semantic web reasoning and service discovery and
access. Meta-control rules can be customized to best capture the requirements associated with different domains and different sets of policies. This
architecture has been validated in the context of different environments, including a collaborative enterprise domain as well as several mobile and
pervasive computing applications deployed on Carnegie Mellons campus. We show that, in the particular instance of access control policies, the
proposed framework can be viewed as an extension of the XACML architecture, in which Policy Enforcing Agents offer a particularly powerful
way of implementing XACMLs Policy Information Point (PIP) and Context Handler functionality. At the same time, our proposed architecture
extends to a much wider range of policies and regulations. Empirical results suggest that the semantic framework introduced in this article scales
favorably on problems with up to hundreds of services and tens of service directories.
 2007 Elsevier B.V. All rights reserved.

Keywords: Semantic web; Context-sensitive policies; Web services; Security and privacy

1. Introduction

The increasing reliance of individuals and organizations on
the Web to help mediate a variety of activities is giving rise
to a demand for richer policies (e.g. security and privacy policies as well as other corporate or regulatory policies) and more
flexible mechanisms to enforce these policies. People may want
to selectively expose sensitive information to others based on
the evolving nature of their relationships, or share information about their activities under particular conditions. This trend
requires context-sensitive security and privacy policies, namely
policies whose conditions are not tied to static considerations but
rather conditions whose satisfaction, given the very same actors
(or principals), will likely fluctuate over time. Enforcing such
policies in open environments is particularly challenging for
several reasons:


Corresponding author.
E-mail addresses: jinghai@cs.cmu.edu (J. Rao), alberto@cs.cmu.edu

(A. Sardinha), sadeh@cs.cmu.edu (N. Sadeh).

1570-8268/$  see front matter  2007 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2007.10.001

- sources of information available to verify these policies may
vary from one principal to another (e.g. different users may
have different sources of location tracking information made
available through different cell phone operators);

- available sources of information for the same principal may
vary over time (e.g. when a user is on company premises her
location may be obtained from the wireless LAN location
tracking functionality operated by her company, but, when
she is not, this information can possibly be obtained via her
cell phone operator);

- available sources of information may not be known ahead of
time (e.g. new location tracking functionality may be installed
or the user may roam into a new area).

Accordingly, enforcing context-sensitive policies in open
domains requires the ability to opportunistically interleave
policy reasoning with the dynamic identification, selection
and access of relevant sources of contextual information. This
requirement, which is not unique to domains with context-

sensitive policies, exceeds the capability of decentralized trust
management
infrastructures proposed so far and calls for
policy enforcing mechanisms capable of operating according
to significantly less scripted scenarios than is the case today. It
also calls for much richer service profiles than those found in
early web service standards.

We introduce a semantic web framework and a meta-control
model for dynamically interleaving policy reasoning and external service identification, selection and access. Within this
framework, external sources of information are wrapped as web
services with rich semantic profiles allowing for the dynamic
discovery and comparison of relevant sources of information.
The framework is applicable to a number of domains where policy reasoning requires the automatic discovery and access of
external sources of information. This is illustrated by drawing
on examples from our work on collaborative enterprise scenarios
as well as on mobile and pervasive computing applications we
have deployed at Carnegie Mellon University. Independently of
the particular domain, our framework relies on Policy Enforcing Agents (PEAs) to enforce one or more types of policies.
The range of the policies can be broad, and may include access
control policies, privacy policies or regulations such as export
control policies, HIPPA policies or US Safe Harbor policies.
We show that, in the case of access control policies, our framework can be viewed as an extension of XACML by providing
a practical and particularly powerful implementation of what
the XACML architecture refers to as Policy Information Points
(PIP) and Context Handler functionality [25]. We proceed to
show that our framework extends to a broader class of corporate
and regulatory policies and provide empirical evidence that our
architecture scales favorably to problems with up to hundreds
of sources of information and tens of service directories.

The remainder of this paper is organized as follows. Section 2
provides a brief overview of relevant work in decentralized trust
management and semantic web technologies. Section 3 introduces a particular instantiation of a Policy Enforcing Agent
developed to enforce access control policies and obfuscation
policies (namely policies that manipulate the level of accuracy
or inaccuracy at which information or services can be accessed).
We refer to this particular class of PEAs as information disclosure agents (IDA). This section further details the different
modules of an IDA and how their operations are opportunistically orchestrated by meta-control strategies in response to
incoming requests. Section 4 details how IDAs can be viewed
as extensions of the XACML architecture. Section 5 discusses
the application of PEAs to a broader range of context-sensitive
policies. Additional implementation details along with empirical results are presented in Section 6. Section 7 contains some
concluding remarks.

2. Related work

The work presented in this paper builds on concepts of
decentralized trust management developed over the past decade
(see [4] as well as more recent research such as [2,3,14]).
Most recently, a number of researchers have started to explore
opportunities for leveraging the openness and expressive power

associated with semantic web frameworks in support of decentralized trust management (e.g. [1,7,8,14,15,35,41,42] to name
just a few) and policy aware web information sharing scenarios
[21,22]. Our earlier work in this area involved the development
of semantic web reasoning engines (or Semantic e-Wallets)
that enforce context-sensitive privacy and security policies in
response to requests from context-aware applications implemented as intelligent agents [10,11]. Semantic e-Wallets played
a dual role of gatekeeper and clearinghouse for sources of
information about a given entity (e.g. user, device, service or
organization). In this paper, we introduce a more decentralized
framework, where policies can be distributed across any number of agents and web services. The main contribution of the
work discussed here is in the development and initial evaluation of a semantic web framework and a meta-control model
for opportunistically interleaving policy reasoning and web service discovery to enforce context-sensitive policies (e.g. privacy
and security policies). This contrasts with the more scripted
approaches to interleaving these two processes adopted in our
earlier work on Semantic e-Wallets.

Our research builds on recent work on semantic web service languages, (e.g. OWL-S [28], WSMO [44], SAWSDL [37])
and semantic web service discovery functionality. Early work in
this area by Paolucci et al. [30] focused on matching semantic
descriptions of services being sought with semantic profiles of
services being offered, using service profiles that include input,
output, preconditions and effects (see also our own work in this
area [32]). More recently discovery functionality has also been
proposed that takes into account security annotations [19].

Other relevant work includes languages for capturing user privacy preferences such as P3Ps APPEL language [29], and for
capturing access control privileges such as the Security Assertion Markup Language (SAML) [26], the XML Access Control
Markup Language (XACML) [25] and the Enterprise Privacy
Authorization Language (EPAL) [16]. These languages do not
take advantage of semantic web concepts and do not attempt
to solve the problem of identifying and gathering information
required to enforce policies. In contrast, Rein [17,18] is another
semantic web framework for modeling and reasoning over policies that has been developed concurrently with our work. While
the objectives of Rein are generally similar to ours, the work
presented in this paper focuses specifically on the process of
orchestrating policy reasoning with the identification and access
of relevant sources of information required to verify policies.
KAoS is another semantic web framework that has looked at
integrating semantic web service concepts with policy reasoning [42]. Our Semantic e-Wallets as well as research described
herein has relied on an extension of OWL Lite known as ROWL
to represent policies that refer to concepts defined with respect to
ontologies [1012]. While ROWL has been a convenient extension of OWL to represent and reason about rules, it is by no
means the only available option. In fact, ROWL shares many
traits with several other languages. One better known language
in this area is RuleML [34], a proposed standard for a rule lan-
guage, based on declarative logic programs. Another is SWRL
[13], which uses OWL-DL to describe a subset of RuleML. The
focus of the present paper is not on semantic web rule languages

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Fig. 1. Information disclosure agents: overall architecture.

but rather on a semantic web framework and a meta-control
model for enforcing context-sensitive policies. For the purpose
of this paper, the reader can simply assume that the expressiveness of our own ROWL language is by and large similar to that of
a language like SWRL, with both languages capable of capturing
Horn-like rules and facts in one or more OWL knowledge bases.
Another relevant line of research involves work on trust
negotiation, namely the development of interactive protocols
to incrementally establish trust through the dynamic exchange
of credentials. In particular, PeerTrust [24] uses logic programming to represent and reason about access control policies. This
includes the delegation of terms in a Horn clause to other peers
for evaluation. An extension of PeerTrust has also been developed by the European REWERSE project [5]. Another example
of work in this area is Trust-Serv [38], a model-driven trust negotiation framework for Web services. While in these systems, the
process of identifying sources of information to enforce policies is encoded in the form of rules, the framework presented
in this article also allows for the dynamic discovery of relevant
sources of information (in addition to being able to model rules
such as those described in the trust negotiation literature). This
additional flexibility makes it possible to support significantly
more open environments, where one is not required to anticipate
all possible sources of relevant information ahead of time.

3. Information disclosure agents

This section introduces a particular type of Policy Enforcing Agent responsible for controlling access to an information
service. We refer to this type of agent as an information disclosure agent and use it to illustrate our architecture for Policy
Enforcing Agents. Specifically, consider an environment where
sources of information are all modeled as services that can be
automatically discovered based on rich ontology-based profiles
advertised in service directories. Each service has an owner,
whether an individual or an organization, which is responsible

for setting policies for it, with policies represented as rules. Policies include both access control policies (e.g. who has the right
to access a service and under which particular conditions) and
obfuscation policies (i.e. policies that manipulate the level of
accuracy or inaccuracy of information being disclosed) (Fig. 1).
An information disclosure agent receives requests for information or service access. In processing these requests, it is
responsible for enforcing access control and obfuscation polices
specified by its owner and captured in the form of rules. As it
processes incoming queries (or, more generally, requests), the
agent records status information that helps it monitor its own
progress in enforcing its policies and in obtaining the necessary
information to satisfy the request. This typically involves submitting multiple requests to a policy reasoner module and an
information collector module. The latter can draw on both local
knowledge as well as external sources of information  including possible interactions with users. All communication with the
outside is assumed to be encrypted and digitally signed.

Meta-control rules support the implementation of different
orchestration strategies, from simple sequential control flows to
more sophisticated processes capable of automatically accessing
directories and concurrently collecting information from multiple sources. Strategies are executed by selectively activating
different IDA modules (e.g. policy reasoning modules, local
information reasoner, service invocation module, etc.). This is
further detailed later in this and other Sections.

In our current implementation, the meta-controller and information collector are rule-based engines implemented in Jess [9].
For efficiency reasons they are implemented as separate modules within the same Jess reasoning engine (i.e. each module
comes with its own set of rules and control can be passed back
and forth between the modules). In some domains, we have also
relied on Jess to implement the policy reasoner module, while
in others we have wrapped legacy policy reasoners (e.g. Suns
XACML policy decision point used for the work described in
Section 4).

3.1. Meta-controller

A PEAs meta-controller consists of a meta-control submod-
ule, a Housekeeping submodule, and a Query Status Information
knowledge base. As the PEA processes incoming queries, its
meta-controller monitors progress and determines what to do
next. Specifically, it continuously cycles through the following
three basic steps:

1. The meta-control submodule analyzes the latest query status information and decides which of the PEAs module(s)
to invoke next to perform particular tasks (e.g. obtaining
information required to evaluate a policy or invoking the policy reasoner). As it invokes these modules the meta-control

submodule updates relevant query status information (e.g.
updating the status of a query from not yet processed to
being processed, identifying query elements that still need
to be evaluated, etc.).

2. Modules complete their tasks (whether successfully or not)
and report back to the meta-controller  occasionally modules
may also report on their ongoing progress in handling a task.
3. The housekeeping submodule updates detailed status information based on information received from other modules
and performs additional housekeeping activities (e.g., cleaning up status information that has become obsolete, caching
the results of recent requests for possible re-use and to mitigate the effects of possible denial of service attacks, etc.)

Table 1
Sample list of status predicates

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Query status information helps the PEA monitor how far
along it is in processing individual requests, namely determining whether the request (or query) complies with relevant access
control policies, gathering the requested information and applying relevant obfuscation rules, if any, to sanitize information
before it is returned to the requester. It is expressed according
to a taxonomy of predicates intended to keep track of different activities typically involved in processing a query. This
includes the status of individual queries as well as the status
of query elements they give rise to. Examples of query elements
include the evaluation of particular rules (e.g. If the requester
is a preferred supplier, it can have access to our component
requirements forecast). Query elements are also used to model
the need to obtain information required to evaluate individual
rules (e.g. is this particular company a preferred supplier?, or
which department does this employee work for?). Processing
query elements may in turn generate new query elements, whose
statuses also need to be tracked. Accordingly, query status information includes whether a query (or query element) has been or
is being processed, what individual query elements it has given
rise to, whether these elements have been processed, etc. All
status information is annotated with time stamps.

Query status information is updated by asserting new facts
(in the query status information knowledge base), with old
statuses being cleaned up. As query updates come in, they
trigger one or more meta-control rules, which in turn result in
additional query status information updates and the invocation
of one or more modules (e.g. policy reasoning module, local
information reasoner, etc.).

An IDAs meta controller relies on meta-control rules to analyze query status information and determine which module(s) to
activate next. Meta-control rules are modeled as if-then clauses,
with left hand sides (LHSs) specifying their premises and right
hand sides (RHSs) their conclusions. LHS elements refer to
query status information, while RHS elements contain facts that
result in module activations. Query status information helps keep
track of how far along the IDA is in obtaining the information
required by each query and in enforcing relevant policies. Query
status information in the LHS of meta-control rules is expressed
according to a taxonomy of predicates that helps the agent keep
track of queries and query elements  e.g., whether a query has
been or is being processed, what individual query elements it has
given rise to, whether these elements have been cleared by relevant access control policies and sanitized according to relevant
obfuscation control policies, etc. All status information is annotated with time stamps. Specifically, query status information
includes:

- A query status ID.
- Status predicates to describe the status of a query or query

element.

- A query ID and query element ID to which the predicate refers.
- A parent query status ID to help keep track of dependencies
(e.g. a query element may be needed to help check whether
another query element is consistent with a context-sensitive
access control policy). These dependencies, if passed between
IDA agents, can also help detect deadlocks (e.g. two IDA

agents each waiting for information from the other to enforce
their policies).

- A time stamp that describes when the status information was
generated or updated. This information is critical when it
comes to determining how much time has elapsed since a
particular module or external service was invoked. It can help
the agent look for alternative external services or decide when
to prompt the user (e.g. to decide whether to wait any longer).

A sample of query status predicates is provided in Table 1.
Clearly, different taxonomies of predicates can lead to more or
less sophisticated meta-control strategies. For the sake of clarity,
status predicates in Table 1 are organized in seven categories:
(1) communication; (2) query; (3) query elements; (4) access
control; (5) obfuscation; (6) service discovery and (7) service
invocation.

Meta status is updated by asserting new facts into the working
context (with old statuses being cleaned up). As query updates
come in, they trigger one or more meta-control rules, which in
turn result in additional query status information updates and
possibly additional actions. Below is an example of a metacontrol rule that invokes a service after it is identified. Depending
on the invocation result, the current meta-status gets updated to
waiting-for-service-response or failed-service-invocation.
The rule is written in Jess. Below, for the sake of readability,
we use a slight variant of the Jess syntax (e.g. we avoid using
the Jess bind and eq operators).

Meta-control rules can also be defined to consult with users,
whether to ask for a particular piece of information (i.e. using a
user as an external source of information) or to decide what to do
next (e.g. to decide whether or not to abandon a particular course
of action in situations that are taking longer than expected).

In general, different collections of query status predicates and
meta-control rules will result in different behaviors. Accord-

Fig. 2. Example of meta-control rules.

ingly, our meta-control architecture enables one to tailor Policy
Enforcing Agents to the particular policies and scenarios associated with a given domain, with simpler domains giving rise to
simpler sets of behaviors and more complex ones allowing for
more sophisticated logic to handle a wider range of situations.
Fig. 2 provides a synthetic view of the different possible workflows associated with a relatively simple set of status predicates
and meta-control rules. In this particular case, upon receiving
a request, the IDA generates an information status update indicating that a new query has been received. This information is
expressed as a tuple of the form (statusID predicate queryID

elementID parentID timestamp) such as (status1 query-received
query1 nil nil time1). Because receiving a query is the first step,
there is no parent ID and no query element so their values are nil.
Next, the meta-controller generates a new status update indicating that the request has to be run against relevant access control
rules,  e.g. (status2 clearance-needed query1 element1 status1
time2). This status update in turn results in the meta-controller
invoking the policy reasoner, which in turn can lead to the creation of one or more query elements. Given this particular set
of meta-control rules, the IDA first tries to find the information required for each query element in its local knowledge.

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

If this does not work, the IDA creates an element-not-known-
locally status predicate, which in turn leads to the creation of
an element-need-service status predicate. This status predicate
later triggers a service identification step. This will typically be
followed by the actual identification of a service and its invo-
cation. Eventually the IDA obtains the information required to
determine whether its policy is satisfied.

While this section focuses on information disclosure agents,
it is easy to see that context-sensitive policies other than access
control policies and obfuscation policies can easily be enforced
with agents built around a similar architecture with status predicates and meta-control modules used to orchestrate policy
reasoning and the collection of relevant information. In the
remainder of this paper, we generically refer to these agents
as Policy Enforcing Agents.

3.2. Policy reasoner

The PEAs policy reasoning engine is responsible for evaluating relevant policies and returning policy decisions. For the
sake of simplicity, we assume that all relevant policies are stored
within the policy reasoner or in a centralized knowledge base (or
database) accessible to the policy reasoner. In general, policies
may come from multiple sources (e.g. combination of department policies, corporate policies and government regulations). If
this is the case, a more general policy collection module similar
to the PEAs information collector might be required to identify all relevant policies. Some policies could also be embedded
in other PEAs, which could themselves be modeled as external sources of information. For example, checking whether an
employee has departmental approval to request a vacation could
be performed by querying a departmental service, which could
evaluate corresponding policies on the fly. This latter configuration is covered by the architecture presented in this paper.

In general, the policy reasoner includes the following mod-

ules:

1. Query Decomposition Module takes as input a particular
query and breaks it down into elementary needs for informa-
tion, which can each be thought of as subgoals or sub-queries.
We refer to these as Query Elements. The value of a Query
Element can be obtained just based on facts contained in the
agents local knowledge base, or by invoking both local and
remote services.

2. Access Control Module is responsible for determining
whether a particular query or sub-query is consistent with
relevant access control policies  modeled as access control rules. While some policies can be checked just based
on facts contained in the agents local knowledge base, many
policies require obtaining information from a combination of
both local and external sources. When this is the case, rather
than immediately deciding whether or not to grant access to a
query, the Access Control Module needs to request additional
facts  also modeled as Query Elements.

3. Obfuscation Module sanitizes information requested in a
query according to relevant obfuscation policies  also modeled as rules. As it evaluates relevant obfuscation policies,

this module too can post requests for additional Query Ele-
ments.

It should be emphasized that our architecture is not tied to
a particular policy reasoner. Instead, different policy reasoning
engines can be plugged in to support reasoning about different
types of policies. This is illustrated in this paper by presenting
examples and results obtained with two different families of
policy reasoners:

1. A family of Jess-based policy reasoners capable of enforcing
a broad range of policies. Policies are expressed as ROWL
rules [12] that refer to concepts specified in domain-specific
ontologies written in W3Cs OWL language [43]. ROWL
has been used to specify a number of policies, from access
control policies, to obfuscation policies, to message processing policies, etc. Instantiations of this engine have been
deployed in the context of several mobile and pervasive computing applications piloted on Carnegie Mellons campus
(e.g. MyCampus [36] and PeopleFinder [6,31] application)
as well as in the context of enterprise collaboration scenarios.
2. Suns XACML policy decision point implementation, which
evaluates XACML decision requests against XACML access
control policies. In this configuration, the Sun PDP engine
is wrapped to interoperate with our PEA architecture. This
includes translating output from the Sun PDP engine into
query status information. This is further detailed in Section 4.

3.3. Information collector

The Information Collector is responsible for gathering facts
(or information) required to evaluate a given decision request.
It works under the supervision of the meta-controller, which
orchestrates policy reasoning and information collection. Facts
required for evaluating policy decision requests may be known
locally or may have to be obtained from other sources of informa-
tion. Accordingly, the Information Collector comprises a Local
Information Reasoner, a Service Discovery submodule, a Service Invocation submodule. Note that users themselves could be
modeled as services that can be queried for missing information.
The Local Information Reasoner corresponds to domain knowledge (facts and rules) known locally to the PEA. The Service
Discovery submodule helps the PEA identify potential sources
of information to complement its local knowledge.

In our current implementation, knowledge in the Local Information Reasoner is represented using RDF/OWL and ROWL
(for domain rules). Specifically, we use an OWL meta-model,
equivalent to OWL-Lite to interpret and reason about OWL state-
ments. Ontologies and annotations are translated into Jess facts,
while inference rules are translated into Jess rules through a combination of both forward and backward chaining, with backward
chaining used to express the need for facts and help identify
sources of information (or services) that are likely to provide
these facts. For instance, a rule that specifies that two persons
are colleagues if they have the same employer may trigger one
or more backward chaining rules to determine each persons
employer, e.g. first looking for local information and, if this

fails, possibly looking for external services that can provide this
information.

External services can be either pre-identified (using service
identification rules such as When checking if someone is a company employee, ask the companys HR service) or found with
the help of directories (e.g. find services that provide supplier
ratings), whether internal to a given organization or external
to it. Clearly, service identification rules that map information needs onto specific services can yield significant speedups.
At the same time, the ability to rely on more general service
discovery processes that involve querying service directories
and identifying matches based on rich service annotations can
provide a significantly greater level of openness. By allowing
service discovery rules to include both direct service identification rules and more complex discovery and comparison rules,
PEAs allow policy developers to selectively choose between
both options.

As already indicated, PEAs can possibly treat users as sources
of additional domain knowledge. It is worth noting that users can
also serve as potential sources of meta-control knowledge (e.g.
if a particular query element proves too difficult to locate, the
user may be asked whether to give up).

3.4. Service discovery and invocation

A central element of our framework is the ability of PEA
agents to dynamically identify sources of information needed to
process queries. Sources of information are modeled as semantic web services and may operate subject to their own policies
enforced by their own PEA agents. Accordingly service invocation is itself implemented in the form of queries sent to a
services PEA agent.

In our system, we use WOWL (Web services in OWL)
to annotate services, as this language has the merit of being
fairly compact. We have also implemented variations of our
architecture using the OWL-S language [33] and could readily adopt other equivalent frameworks (e.g. WSMO [44] or
SAWSDL[37]). A WOWL service description includes:

1. The services output.
2. Its conditions and constraints.
3. Relevant non-functional attributes [27], if any.
4. A description of how to invoke the service, including the

services endpoints and its input.

In our current implementation, we use an XSLT transformation to convert WOWL service profiles into service discovery
rules expressed in Jess. Like the meta-control rules, the discovery rules are also expressed as if-then clauses - or left hand
side (LHS) implies right hand side (RHS). The LHS refers
to the types of facts a given service can provide (as specified in
its output) together with a set of conditions and constraints. The
RHS creates a matching service-identified status predicate. In
other words, given an element-need-service status predicate
indicating that one is looking for a service that can provide a
particular type of fact, some service profiles are triggered as
service discovery rules. As they are triggered, these rules will

in turn result in the creation of matching service identified
status predicates indicating that any of these services can possibly yield the desired information. The meta-controller can later
decide which one(s) of the services to actually query  depending
on its particular meta-control rules.

Given that PEAs can look for and query external sources of
information, whose access may in turn be control by other PEAs,
it is entirely possible to run into deadlocks, e.g. two PEAs, each
waiting for a response from the other before they can proceed
with a given query. A simple solution to this problem involves
using time-outs, which can themselves be implemented in the
form of meta-control rules. Specifically, in our current imple-
mentation, time-outs can be specified in the form of independent
threads that periodically check the timestamps of the pending
queries. Queries that are too old can be considered to have failed
or the user can be asked whether to allocate more time to them.
In our implementation, all status information is annotated with
time stamps.

An alternative approach is to use circular analysis. This has
also been implemented. This is done using query dependency
graphs, in which each query is represented as a node containing
information about its sender, recipient and query element and is
connected by a directed edge to its parent query (if it has one).
Queries are sent with their dependency graphs. If they result in
additional queries, each new query is sent with a dependency
graph obtained by adding a node for the new query to the dependency graph inherited from the parent query. If two queries that
depend on each other have the same sender, the same recipient
and the same query element, they are in a deadlock situation. The
agent that receives a query is responsible for detecting the deadlock and can either respond with a query-failed response or ask
the sender to notify the user that a deadlock has been detected.
Note however that by sharing query dependency graphs, nodes
end up disclosing elements of their own policies, which may not
always be acceptable. In other words, while this can help detect
deadlocks, there are situations in which agents may not want to
share this information.

4. Access Control Agents based on XACML

One particular instance of an IDA is an Access Control Agent
(ACA) which only implements access control policies. Given
the amount of effort invested by industry over the past few years
to define a standard for such agents, it makes sense to look at
how our PEA architecture relates to the architecture developed
as part of the XACML standard [25]. As it turns out, our PEA
architecture can be viewed as an extension of this standard and
it is possible to build instantiations of our PEAs that rely on
XACML Policy Decision Points and on the XACML language
to express and enforce access control policies. This is illustrated
in Fig. 3, which shows the architecture of an ACA agent we
have implemented including a Suns XACML policy decision
point (PDP) engine [40] as the access control module. Incoming decision requests (or queries) are directed to the agents
meta-controller which doubles as an XACML Policy Enforcing
Point (PEP). This does not require a formalization of XACML
like [20] did. Instead, queries are converted from their native

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Fig. 3. PEA instantiated as an access control agent using Suns XACML policy decision point engine.

format to XACML, using a language adaptor, which essentially
subsumes part of the XACML Context Handler functionality,
with the other part being handled by the meta-controller. Missing information is dynamically identified through interactions
between the meta-controller and the Information Collector, the
latter playing the role of XACML Policy Information Point (PIP).
In addition, the language adaptor also stores annotations that
map XML-based XACML attributes onto semantic web con-
cepts, e.g. OWL classes.

4.1. An aerospace contractor scenario

The ACA agent depicted in Fig. 1 has been implemented to
support the access control requirements associated with a fictitious aerospace contractor, which we refer to as United GenSat
Corporation. United GenSat is a California-based manufacturer
of geostationary satellites. It builds two lines of communications satellites: the SAT 666 and the SAT 777. These two lines
of satellites are designed to support mobile communications,
and a series of global positioning and military communications
applications.

Due to the sensitive nature of its activities and products,
United GenSat is particularly concerned about maintaining tight
control over who accesses what information both within its
organization as well as in the context of interactions with its trading partners. These interactions include the selective exchange
of scheduling information to ensure close coordination with
key suppliers. Policies to control access to this information are
expressed in XACML. An example of one such policy is provided in Fig. 4. The policy only permits authorized employees
(attribute of subject) of pre-approved suppliers (attribute of sub-
ject) to query (attribute of action) the production schedule of
products it is contributing to (attribute of resource).

Consider Bob, an employee at SATElectronics Corporation,
a United GenSat supplier pre-approved to access production
schedule information of products it contributes to. Bob sends
a request to United GenSat, requesting next months production

schedule for the SAT 777. His request, which includes the identity of his company, is forwarded to the appropriate United GenSat Access Control Agent (ACA). To determine whether to grant
access to the requested information, the ACA needs additional
information, namely (i) whether SATElectronics is pre-approved
to obtain this information  for the sake of simplicity we will just
assume that this information is maintained in the ACAs local
knowledge base, and (ii) whether Bob is an authorized SATElectronics employee when it comes to accessing production
schedule information. To answer this latter question, the ACA
needs to identify a service at SATElectronics and send it a query.
Upon receiving the request, United GenSats ACA generates
an information status update indicating that a new query has
been received. This is expressed as a collection of triples of the
form (predicate subject object), such as (sender query1 Bob),
(ask query1 element1), etc. Next, the meta-controller generates
a new status update indicating that the request has to be cleared
based on applicable policies. The required element to be cleared
is also presented as a triple, like (schedule SAT777 ?s). Here ?s
represents a variable whose value is unknown. This status update
in turn results in the meta-controller invoking the policy rea-
soner, which in turn leads to the creation of two query elements
 one requiring to check whether Bobs company, SATElectron-
ics, is pre-approved to access production schedule information
and the other to check whether Bob is an authorized employee.
The meta-control rules are assumed to first check the ACAs
local knowledge base and find that SATElectronics is indeed pre-
approved. On the other hand, Bobs authorized employee status
cannot be determined locally. This results in the creation of an
element-not-known-locally status predicate, which in turn leads
to the creation of an element-need-service status predicate, followed by a service identification step. A SATElectronics service
is identified and a response eventually provided indicating that
Bob is an authorized employee. As a result, a status predicate is
created indicating that Bobs request has now been cleared.

A particularly interesting step in this scenario is the one
through which the ACA identifies a SATElectronics service

Fig. 4. Sample XACML policy limiting access to Production Schedule information to authorized employees at pre-approved subcontractors.

capable of identifying whether Bob is an authorized employee.
Different processing flows are possible here, depending on
the particular meta-control rules and service discovery rules
implemented in the ACA. In this particular example, the metacontroller first checks whether missing knowledge is available
locally. If that fails (as in this case), it turns to the service discovery module. The service discovery module includes a number of
rules aimed at making service identification as efficient as pos-
sible, as well as extremely general fall-back rules in case none
of the more specialized rules produce results. In this example,
we rely on a service identification rule for checking attributes of
employees of other companies. In this scenario, the rule just tells
the ACA to check the companys directory for a service capable

of providing the necessary query element (i.e. whether Bob is
an authorized employee). The directory is assumed to include a
simple service called AuthorizedEmpService, whose service
profile indicates it can provide the missing information - namely
whether the employee (whose name is provided as input) is an
authorized employee of SATElectronics. Fig. 5 shows such a
service discovery rule written in the Jess syntax. We use XSLT
to translate the WOWL service profile into a Jess rule.

Admittedly, this scenario takes some shortcuts. A more realistic variation would have to do a better job at dealing with
confidentiality considerations and would likely involve multiple
levels of indirection, with some service discovery performed
by United GenSats ACA and some performed locally by SAT-

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Fig. 5. A service profile captured as a Jess rule.

Electronics in response to a more general query from United
GenSat. Nevertheless, once a service such as SATElectronicsEmpService has been identified, its profile can be used
to automatically generate an access request intended to verify
whether Bob is an authorized employee. This step is performed
by the ACAs service invocation module. It includes automatically generating the necessary service query along with
additional facts required by the service as indicated in its input

and precondition profile. In this particular case, the query is of
the form:

Based on the services input profile, the following fact is sent

along with the query:

Clearly, this assumes that both the service provider and
service requester share a common ontology. If not, semantic
reasoning rules may be needed to establish a mapping between
their respective ontologies.

4.2. Updating query status information

The following illustrates the processing of a query by an
IDA, using the scenario introduced above. Bobs query about the
production schedule of SAT777 is first processed by the IDAs
Communication Gateway, resulting in a query information status update indicating that a new query has been received. This
information is expressed as a query status tuple together with a
collection of (predicate subject object) triples of the form:

Next, the meta-controller activates the Query Decomposition
Module, resulting in the creation of two query elements: one
query element to establish whether this request is compatible
with United GenSats access control policies and the other to
obtain the production schedule of SAT777:

Let us assume that the meta-controller decides to first focus
on the clearance-needed query element and invokes the Access
Control Module which is actually an XACML PDP. This module
determines that two conditions need to be checked and accordingly creates two new query elements (element-needed). One
condition requires checking whether Bob is an authorized SATElectronics employee:

This condition in turn requires a series of information collection steps that are orchestrated by the meta-control rules in
United GenSats IDA. In this example, we assume that the IDAs
local knowledge base does not know Bobs employment infor-
mation. Accordingly, the following query status information
update is eventually generated:

United GenSats IDA has a meta-control rule to initiate service discovery when a query element can not be found locally.
The rule, expressed in Jess is of the form:

Using this rule, the meta-controller now activates the Service
Discovery Module. A service to find Bobs employment information is identified. This results in a query status update of the
type service-identified.

Note that, if there are multiple matching services, the service

discovery module needs rules to help select among them.

Let us assume that the service discovery module identifies
that Bobs employer, SATElectronics is a trustful information source to answer if Bob is an authorized employee. The
Housekeeping module updates the necessary Query Status Infor-
mation, indicating among other things that information about
Bobs information has been found (element-available) and
cleaning old status information. This is done using a rule of
the type:

The scenario continues through several similar steps. A full
flow diagram is shown in Fig. 6. For better readability, we do
not restrict the syntax of the meta statuses shown in this figure.

5. Beyond access control policies

PEAs are not limited to information disclosure and enforcing
access control policies. The same meta-control architecture can
be used to support more flexible processing flows when it comes
to enforcing a broad range of policies. This is illustrated in this
section by examining a scenario where United GenSat undertakes to develop a new satellite model, SAT 888, for a client in
the UK. As it works on the design of the SAT 888 in collaboration
with both current and prospective suppliers, the company needs
to ensure compliance with a variety of policies. This includes
compliance with corporate supplier selection policies as well as
with US export control regulations (e.g. the US International
Traffic in Arms Regulations, ITAR).

United GenSat relies on a specialized PEA to help it ensure
compliance with these policies (Fig. 7). As employees working on the SAT 888 refine their design and evaluate different
options, they submit policy conformance requests to the PEA.
This includes checking for compliance of sourcing decisions
with both export control regulations and corporate supplier
selection policies. These policies are expressed in ROWL [12]
and require accessing a combination of corporate and external
services to obtain up-to-date supply ratings and export restric-
tions. In Fig. 8, we present an example of such a policy, written
in Jess. It specifies that, when a product is to be exported (i.e. its
country of destination is not equal to USA), it is approved for
export if its country of destination and its Export Control Classification Number (ECCN) are not on the Bureau of Industry
and Security (BIS) Commerce Control List. If the combination
of the products ECCN and export country appears in the list
(in the form of a CCLStatement), an export license has to be
obtained.

As before, the PEAs meta-control module orchestrates the
evaluation of these policies, looking for information in its local
knowledge base and, when necessary, looking for services that

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Fig. 6. Query status updates for a fragment of the scenario.

can provide missing information. This latter step is performed
with the help of the PEAs service discovery module. In this
simple example, it is assumed that the required services are
known ahead of time. In other words, the PEA can rely on
simple service identification rules such as When looking for
a CCLStatement, issue a query to the BIS Commerce Control
List and Chart Service.

Because the BIS, ITAR and OFAC services used in this scenario do not exist at this time (i.e. the current websites are
not implemented as web services), our implementation of this
scenario currently relies on stubs.

Going back to the policy listed in Fig. 8, if there is a CCL
Statement indicating that the products ECCN and its export
country are incompatible with export restrictions, the policy will

Fig. 7. Using a PEA to check for compliance with supplier selection policies, including supplier scoring requirements and government export controls.

result in the creation of an Element-Needed status predicate
with attribute has license. In other words, the policy reasoner
will let the meta-controller know that the only remaining option
to satisfy this policy is to obtain an export license. This in turn
could prompt the launch of a process to obtain such a license
or it could lead the United SatGen employee who submitted
the validation request to look for a different design. This shows
how PEAs could also be integrated into workflow management
functionality.

6. Current implementation: evaluation and discussion

Our Policy Enforcing Agents are currently implemented in
Jess, a high-performance Java-based rule engine [9]. Domain
knowledge, including service profiles, ontologies, annotations
and semantic inference rules are expressed in OWL [43]. We
have implemented multiple instances of PEAs, including PEAs
relying on different policy languages and reasoning capabilities.
This includes multiple instances of ROWL policy reasoners and
Suns more specialized PDP reasoner to enforce XACML poli-
cies. As already indicated earlier ROWL could easily be replaced
with languages such as RuleML, SWRL or some similar lan-
guage. XSLT transformations are used to translate OWL facts
and extensions of OWL (e.g. to model rules and queries) into the
Jess language. Agent modules are implemented as Jess modules.
Experiments conducted with different policies (i.e., different
sets of rules) show that the CPU time required to process a
query does not change significantly with the number of rules.
Instead, performance is largely determined by the number of
facts. Accordingly, scalability results reported below focus on
the size of the ontologies and service repositories.

We have evaluated our solution on an IBM server with 2
Intel Xeon 3.0 GHz CPU and 3GB of RAM. The server was

running Windows XP Professional OS, Java SDK 1.4.2 and Jess
6.1. Below we report empirical results obtained to evaluate the
scalability of our PEA implementation.

Specifically, the first table below reports results obtained
using ontologies from the Lehigh University Benchmark
(LUBM) [23]. The results are based on an OWL university
ontology with around 10000 triples after translation. Results
are reported for repositories containing 100, 200 and 500 randomly generated semantic web services. The input and output
parameter types were randomly selected from the classes in the
domain ontology. CPU times are in milliseconds. We report the
total time required to process a query as well as the amount of
processing required by individual modules, namely the meta-
controller, access control reasoning module, local knowledge
reasoner and service discovery module.

Meta-controller
Access-controller
Local knowledge
Service discovery

Total

Number of services

The results show that query processing time increases nearly
linearly with the size of the service repository. A second set
of experiments involved distributing services across multiple
repositories by controlling the number of services listed in each
repository (or directory). Each directory had its own PEA agent
with scenarios typically requiring multiple directory queries
before an adequate service could be identified. In these experi-
ments, each repository agent had a lighter ontology with about
1000 triples and 100 registered services. The table below reports

J. Rao et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 4056

Fig. 8. An export control compliance policy.

overall processing times in milliseconds (ms) along with a breakdown for individual PEA modules.

Number of service repositories

Meta-controller
Access-controller
Local knowledge
Service discovery

Total

A Policy Enforcing Agent is also used to enforce peoples
location privacy policies in a PeopleFinder application we have
deployed on Carnegie Mellons campus [6,31]. A typical PeopleFinder PEA contains 500 triples. In experiments involving
200 users, each with their own PEAs to enforce their privacy
policies, a typical request for a users location can be processed
against the users policies within 100 ms.

These results suggest that the computational requirements of
our solution are acceptable and that our solution scales to practical problems. A more careful implementation is also likely
to yield significant speedups. At the same time, a significant
number of experiments still need to be conducted to gain a
more comprehensive understanding of the scalability of our
approach. Differentiating between situations where a policy has
been shown not to be satisfied and situations where the agent
has not yet been able to determine whether a policy is satisfied
will likely call for differentiating between classical negation and
negation as failure. One possible solution here would be to use
a framework such as SweetRules as an add-on to our semantic
web reasoner [39]

7. Concluding remarks

In this paper, we presented a semantic web framework for
dynamically interleaving policy reasoning and external service
discovery and access. Within this framework, external sources
of information are wrapped as web services with rich semantic profiles allowing for the dynamic discovery and comparison
of relevant sources of information. Each entity (e.g. user, sen-
sor, application, or organization) relies on one or more Policy
Enforcing Agents responsible for enforcing relevant policies
in response to incoming requests. These agents implement
meta-control strategies to dynamically interleave semantic web
reasoning, service discovery and access. These meta-control
strategies can also be extended to treat the user as another source
of information, e.g. to confirm whether a given fact holds or to
provide meta-control guidance such as deciding when to abandon trying to determine whether a policy is satisfied.

We have shown that our architecture for Policy Enforcing
Agents can be implemented as an extension to XACMLs PIP
and context handler functionality. We proceeded to also show
that it extends to a much broader class of corporate and regulatory policies and presented an example where a PEA is used
to enforce sourcing policies, both corporate supplier selection
policies and export control regulations. PEAs to enforce different types of policies or to operate on similar policies in different

domains will rely on slightly different sets of modules and different meta-control strategies, yet they can all be implemented
using the same meta-control architecture and many of the same
principles presented in this paper. Specifically, PEAs rely on a
taxonomy of query information status predicates to monitor their
own progress in processing incoming queries and enforcing relevant security and privacy policies. They use meta-control rules
to decide which action to take next (e.g. decomposing queries,
seeking local or external information, etc.).

We have implemented several instances of our PEAs in the
context of collaborative enterprise scenarios as well as in the
context of several mobile and pervasive computing applications piloted on Carnegie Mellons campus. Empirical results
presented in this paper indicate that our existing implementation scales favorably on scenarios involving up to hundreds of
sources of information and tens of service directories. Future
work will focus on further exploring scalability issues, evaluating tradeoffs between the expressiveness of meta-control rules
and efficiency. Other issues of particular interest include studying opportunities for concurrency (e.g. simultaneously accessing
multiple web services), dealing with real-time meta-control
issues (e.g. deciding when to give up or when to look for
additional sources of information/web services), and developing technologies that better support system administrators and
users in their interactions with our system [6,31].

Acknowledgements

The work reported herein has been supported in part by the
National Science Foundation under ITR grant 0205435 (Mul-
tiattribute Negotiation in Dynamic Supply Chains), including
a supplement to collaborate with the EU IST TrustCom project.
Support has also been provided under the Cyber Trust Grant
CNS-0627513 (User-Controllable Security and Privacy for
Pervasive Computing) and by ARO under research grant
DAAD19-02-1-0389 (Perpetually Available and Secure Information Systems). Additional support has also been provided
by SAP, France Telecom, Nokia, HP, IBM, Fujitsu, and Boeing.
