Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Simple and Efficient Minimal RDFS
Sergio Mu noz a,, Jorge Perez b,d, Claudio Gutierrez c,d

a Department of Mathematics, Universidad Chile, Chile
b Department of Computer Science, Pontificia Universidad Catolica de Chile, Chile
c Department of Computer Science, Universidad Chile, Chile
d Khipu: South Andean Center for Database Research, Chile

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 22 January 2009
Received in revised form 26 May 2009
Accepted 13 July 2009
Available online 24 July 2009

Efficient entailment
Semantic Web

1. Introduction

The original RDFS language design includes several features that hinder the task of developers and the-
oreticians. This paper has two main contributions in the direction of simplifying the language. First, it
introduces a small fragment which, preserving the normative semantics and the core functionalities,
avoids the complexities of the original specification, and captures the main semantic functionalities of
RDFS. Second, it introduces a minimalist deduction system over this fragment, which by avoiding certain
rare cases, obtains a simple deductive system and a computationally efficient entailment checking.

 2009 Elsevier B.V. All rights reserved.

The Resource Description Framework (RDF) is the W3C standard for representing information in the Web [12]. The motivation
behind the development of RDF by the W3C was to have a common
and minimal language to enable to map large quantities of existing
data onto it so that the data can be analyzed in ways never dreamed
of by its creators [3]. Bringing this vision to reality amounts to make
the processing of RDF data at big scale viable.

Efficient processing of any kind of data relies on a compromise
between the size of the data and the expressiveness of the language
describing it. As we already pointed out, in the RDF case the size of
the data to be processed will be enormous, as current developments
show (e.g. DBpedia [8], FOAF [7], Gene Ontology [13], etc. For studies
on data sets see [19]).

Hence, a program to make RDF processing scalable has to
consider necessarily the compromise between complexity and
expressiveness. Such a program amounts essentially to look for
fragments of RDF with good behavior with respect to complexity
of processing. This is the broad goal of the present paper.

The RDF specification is given in [11] and its semantics is defined
in [17] and has been studied from several points of view [16,9,20,24].
Essentially, an RDF statement is a subjectpredicateobject struc-
ture, called an RDF triple, intended to describe resources and
properties of those resources. Subject and object of an RDF triple can

be anonymous resources, known as blank nodes. An RDF graph (or
simply a graph) is a set of RDF triples. In addition to this basic struc-
ture, the RDF specification includes a built-in vocabulary, the RDFS
vocabulary, that deal with inheritance of classes and properties,
as well as typing, among other features [11].1 The first observation that arises when dealing with RDFS vocabulary is the difficulty
to work with it. An example of this fact is that even the rules of
deduction presented in the normative RDF Semantics specification
were not complete [20,24]. A second empirical observation is that
several parts of the RDFS vocabulary have been deprecated, and
practice shows that there are others that are hardly used or not
being used at all. This makes it very hard for developers to build
and optimize sound implementations and algorithms, and for theoreticians to work on this specification. These and other concerns
have led researchers to formulate different proposals of interesting
fragments or closely related specifications [25,22,15,4] improving
diverse aspects of the language (we will discuss them in the section of related work). Another example where this type of issues
arises is the SPARQL query language specification [23], that currently does not support RDFS entailment. In practice, each query
will use just a small fragment of the RDFS vocabulary. For reasoning and optimization purposes, it would be useful to have a sound
and complete theory of each such fragment which preserves the
semantics of RDFS, and to know exactly what are the minimal portions of the whole vocabulary that interplay in the entailment of
every specific fragment. In this paper we address these issues.

 This is an extended and revised version of [21].
 Corresponding author.
E-mail addresses: smunozv@uchile.cl (S. Mu noz), jperez@ing.puc.cl (J. Perez),

1 In this paper we call RDFS vocabulary to the set all URIs under the prefixes

cgutierr@dcc.uchile.cl (C. Gutierrez).

(namespaces) rdf: and rdfs: in [17].

1570-8268/$  see front matter  2009 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2009.07.003

Among the most important directions of a program to develop

solutions to the above mentioned problems are:

(i) To identify a fragment which encompasses the essential features of RDFS, which preserves the original semantics, be easy
to formalize and can serve to prove results about its properties.
(ii) To point out features that the groups involved in the development and standardization of RDFS and its query language
should take a more careful look at, and suggest directions for
improvements.

(iii) To study the complexity of entailment for the vocabulary in
general and in these fragments in particular, and to develop
efficient algorithms for testing entailment.

As for the first point, in this paper we isolate a fragment of RDFS
that covers the most relevant vocabulary, prove that it preserves
the original RDFS semantics, and avoids vocabulary and axiomatic
information that only serves to reason about the structure of the
language itself and not about the data it describes. It is composed of
the reserved vocabulary rdfs:subClassOf, rdfs:subPropertyOf, rdf:type,
rdfs:domain and rdfs:range. The rest of the RDFS vocabulary has
either light or no semantics at all, and much of it plays the role
of structural information about the internals of the language itself.
A good example of this latter function is the keyword rdfs:Resource.
An exception is rdfs:Class, which is important for the ontological
level of the Semantic Web, but, as we show in this paper, in the
frame of RDFS deductions does not play any relevant role. We lift
this structural information into the semantics of the language, hiding it from developers and users, and present a complete and sound
deduction system for the fragment.

Furthermore, we study the subfragments of the core fragment,
prove that they retain the original RDFS semantics, and present
results that identify the minimal parts of the vocabulary needed
in the deductions of every subfragment.

Regarding the second point, we study possible refinements of
the fragment presented in the first item. In particular, we show that
reflexivity of rdfs:subClassOf and rdfs:subPropertyOf included in the
official RDF specification [17], play no relevant role in the semantics
and thus can be avoided without having side-effects. This greatly
simplifies the deductive system. A more delicate issue we address is
the occurrence of RDFS vocabulary in subject and object positions.
These occurrences rarely occur in practice and from a theoretical
point of view are re-definitions of the original semantics.

Considering the above arguments (and some complexity issues
discussed below) we introduce a fragment, which we call minimal RDFS, based on the restricted vocabulary mentioned above,
avoiding reflexivity of rdfs:subClassOf and rdfs:subPropertyOf, not
having distinguished vocabulary in subject nor object positions, and
including only ground triples, that is, triples without blank nodes.
We show that this fragment behaves semantically well; in fact,
we give a semantics for it, and present a simple deductive system
sound and complete. Our goal is that this fragment should work
as an essential minimal and efficient floor from where to extend
the language in different directions. For example, in this paper we
show a general result that states that deductions can be normalized
into a ground and a non-ground part. Thus, deductions that need
blank nodes semantics, can be modularly composed with deductions for our minimal fragment. This result is also the theoretical
basis of why we consider only ground triples in the minimal RDFS
fragment.

Concerning the third item, complexity of entailment, the minimal RDFS system has several good properties. For testing RDFS
entailment in the ground case even current known bounds seems
totally impractical. For example, the naive approach would use closure of graphs. The closure is a completion of the graph obtained
by adding all the triples that are entailed by the graph. Estimates

for the size of the closure are high: we show that the size of the
closure is quadratic in the worst case. This bound is impractical
from a database point of view. In this paper we present an algorithm for entailment which shows that, testing whether a ground
triple is entailed by a graph G, can be decided in time O(|G| log |G|)
in the worst case, where |G| stands for the number of triples of G.
We also prove that this is a tight bound for the complexity of ground
entailment.

Finally, we extend the previous result to a large family of nonground graphs of practical significance. In fact, we prove that for
graphs G and H with H containing at most one blank node per
triple, testing whether H is entailed by G can be done in time
O(|H||G| log |G|).

The rest of the paper is organized as follows. Section presents
preliminary material. In Section we introduce the fragment df
of RDFS, which is the base for further developments, and prove
that it is self-contained and preserves the original semantics of
RDFS. We present a notion of proof which is sound and complete
for the semantics. Section introduces minimal RDFS, a minimal
fragment based on a small vocabulary, which avoids reflexivity
constraints, RDFS vocabulary in subject and object positions, and
consider only ground triples. We present arguments showing that
this system behaves computationally well and has very simple
entailment rules. We present an algorithm which performs entailment efficiently on this fragment. In order to easy the reading of
the paper, proofs of results in Sections and which are long and not
necessary to follow the main arguments of the paper are placed in
Appendix. For the sake of completeness, Appendix also includes
parts of the official RDF specification that are relevant to this
work.

2. Preliminaries

We remark that this work is an extended and revised version of

[21].

Assume there are pairwise disjoint infinite sets U (RDF URI
references), B (Blank nodes), and L (Literals). Through the paper
we assume U, B, and L fixed, and for simplicity we denote
unions of these sets simply concatenating their names. A tuple
(s, p, o) UBL  U  UBL is called an RDF triple. In this tuple, s is
the subject, p the p redicate, and o the object. Note that  following
recent developments [5,23]  we are omitting the usual restriction
stating that literals cannot be in subject position.

Definition 1. An RDF graph (or simply a graph) is a set of RDF
triples. A subgraph is a subset of a graph. The set of terms of a graph
G, denoted by terms(G) is the set of elements of UBL that occur in
the triples of G. The vocabulary of G, denoted by voc(G) is the set
terms(G)  UL. A graph is g round if it has no blank nodes.

A vocabulary is a subset of UL. Given a vocabulary V and an RDF

graph G, we say that G is a graph over V whenever voc(G)  V.
In what follows we need some technical notions. A map is a
function  : UBL  UBL preserving URIs and literals, i.e., (u) =
u for all u UL. Given a graph G, we define (G) as the set of all
((s), (p), (o)) such that (s, p, o) G. We overload the meaning
of map and speak of a map  from G1 to G2, and write  : G1  G2,
if the map  is such that (G1) is a subgraph of G2.

The RDF specification [17] includes a set of reserved names,
the RDFS vocabulary (RDF Schema [11]) designed to describe relationships between resources as well as to describe properties like
attributes of resources (traditional attribute-value pairs). Table A.1
(in Appendix) shows the full RDFS vocabulary [17], and (in brack-
ets) the shortcuts that we use in this paper. We assume that the
set U includes the RDFS vocabulary. Also notice that we call RDFS
vocabulary to all the URIs under the prefixes (namespaces) rdf:
and rdfs: in [17] (that is, we assume in this paper that the RDFS

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

vocabulary already contains the RDF vocabulary [17]). Notice that
our definition of the RDFS vocabulary also contains the keyword
rdf:XMLLiteral, and thus, we consider XML typed literals part of the
RDFS vocabulary.

2.1. Interpretations and RDFS semantics

The normative semantics for RDF graphs given in [17] follows standard classical treatment in logic defining the notions of
model, interpretation, entailment, and so on. The RDFS theory is
built incrementally from Simple interpretations, to RDF interpre-
tations, and to RDFS interpretations [17]. In this paper we use a
single notion of interpretation which summarizes Simple, RDF, and
RDFS interpretations in one step. In order to concentrate on the
core semantics, we do not include Datatyped interpretations in this
work.

Definition 2. An interpretation over a vocabulary V is a tuple
I = (Res, Prop, Class, Ext, CExt, Lit, Int)

such that: (1) Res is a nonempty set of resources, called the domain
or universe of I; (2) Prop is a set of property names (not necessarily disjoint from Res); (3) Class  Res is a distinguished subset
of Res identifying if a resource denotes a class of resources; (4)
Ext : Prop  2ResRes, a mapping that assigns an e xtension to each
property name; (5) CExt : Class  2Res a mapping that assigns a
set of resources to every resource denoting a class; (6) Lit  Res
the set of literal values that contains all the plain literals in L  V;
(7) Int : UL  V  Res  Prop, the interpretation mapping, a mapping
that assigns a resource or a property name to each element of UL in
V, and such that Int is the identity for plain literals and assigns an
element in Res to elements in L.

In [17] the semantics of RDF graphs is defined by using the notion
of entailment based on the idea of satisfaction of a graph under a
given interpretation. Intuitively, given a vocabulary V and an interpretation I over V, a ground triple (s, p, o) over V is true under I
if:
- I interprets p as a property name, and thus, I assigns an extension
(a set of pairs of resources) to the interpretation of p, and

- the interpretation of the pair (s, o) belongs to the extension of the

interpretation of p.

Notice that, since the set of resources and the set of property
names of an interpretation are not necessarily disjoint, an element
in V can be simultaneously interpreted as a resource and as a property name. This feature reflects the capability of RDF of stating a
predicate about properties, that is, properties may occur as subjects
or objects in triples.
In RDF, blank nodes work as existential variables. Intuitively
the triple (X, p, o) with X  B would be true under I if there exists
an element s such that (s, p, o) is true under I. When interpreting blank nodes, an arbitrary resource can be chosen, taking into
account that the same blank node must always be interpreted as
the same resource. To formally deal with blank nodes, an extension
of the interpretation map Int is used. Let A : B  Res be a function
from blank nodes to resources. We denote by IntA the extension
of Int that includes blanks as part of its domain and is defined
by IntA(X) = A(X) when X  B. The function A captures the idea of
existentiality.

The formal definition of model and entailment for graphs that
includes RDFS vocabulary relies on a set of semantics restrictions
imposed to interpretations in order to model the vocabulary, and
the a priori satisfaction of a set of axiomatic triples. We refer the
reader to Appendix A for a formal definition of the normative

semantics of RDFS using the notion of interpretation given in
Definition 2.

3. The df fragment of RDFS

In this section we define the fragment of RDFS that we study in
this paper. We define a semantics and a set of inference rules for
this fragment, proving completeness and soundness, and proving
that these rules captures the RDFS semantics for the fragment.

The fragment to be considered comprises the RDFS keywords
(with shortcuts in brackets) rdfs:subPropertyOf [sp], rdfs:subClassOf
[sc], rdfs:domain [dom], rdfs:range [range] and rdf:type [type]. This
fragment is relevant for several reasons. The intended meaning
of the fragment is non-trivial and is designed to relate individual
pieces of data external to the vocabulary of the language, thus having a deep semantical role in RDFS. Their semantics can be defined
by rules which involve variables (to be instantiated by real data).
For example, sc is a binary property reflexive and transitive; when
combined with type, it specifies that the type of an individual (a
class) can be lifted to that of a superclass. Moreover, as we show
in this section, the above fragment is self-contained: the entailment
relation between RDFS graphs that only mention vocabulary of this
fragment does not rely on vocabulary outside the fragment (see
Theorem 5). As our results show, there are theoretical reasons that
support the convenience of the choice of the fragment.

On the other hand, the predicates left out have a light semantics
essentially describing its internal function in the ontological design
of the system of classes of RDFS. Most of their semantics is defined
by axiomatic triples [17] (see Table A.2 in Appendix B), which are
relationships among these reserved words. Note that all axiomatic
triples are structural, in the sense that do not refer to external
data but talk about themselves. Much of this semantics correspond
to what in standard languages is captured via typing. From a theoretical and practical point of view it is inconvenient to expose it
to users of the language because it makes the language more difficult to understand and use, and for the criteria of simplicity in the
design of the language.

Definition 3. Define df vocabulary2 to be the following subset of
the RDFS vocabulary:
df = {sp, sc, type, dom, range}.
An RDFS triple is called a df-triple if all the RDFS vocabulary that
is mentioned in the triple belongs to df. A df-graph is defined as
a set of df-triples.

3.1. Semantics for df

Let G be a df-graph. An interpretation I =
Definition 4.
(Res, Prop, Class, Ext, CExt, Lit, Int) is a model of G under df (df-
model for short), denoted I df G, iff I is an interpretation over
df  terms(G) that satisfies the following conditions:

(i) Simple:

it holds

that

(a) there exists a function A : B  Res

for
each (s, p, o) G,
and
(IntA(s), IntA(o)) Ext(Int(p)), where IntA is the extension
of Int using A.

such that
Int(p) Prop

(ii) Subproperty:

(a) Ext(Int(sp)) is transitive and reflexive over Prop
(b) if (x, y) Ext(Int(sp)) then x, y Prop and Ext(x)  Ext(y)

(iii) Subclass:

2 Read rho-df, the  from restricted rdf.

(iv) Typing I:

(a) Ext(Int(sc)) is transitive and reflexive over Class
(b) if (x, y) Ext(Int(sc)) then x, y Class and CExt(x)  CExt(y)
(a) x  CExt(y) iff (x, y) Ext(Int(type))
(b) if (x, y) Ext(Int(dom)) and (u, v) Ext(x) then u CExt(y)
(c) if (x, y) Ext(Int(range)) and (u, v) Ext(x) then v CExt(y)
(a) For each e df, Int(e) Prop.
(b) if (x, y) Ext(Int(dom)) then x  Prop and y Class.
(c) if (x, y) Ext(Int(range)) then x  Prop and y Class.
(d) if (x, y) Ext(Int(type)) then y Class.

(v) Typing II:

We define G entails H under df (df-entailment for short),
denoted G df H, iff every model under df of G is also a model
under df of H.

Notice that in df-models we do not impose the a priori satisfaction of any axiomatic triple. Indeed, df-models do not satisfy
any of the RDFS axiomatic triples given in [17] because all of
them mention RDFS vocabulary outside df. This is also the reason for the inclusion of conditions (4) in df models because
they capture semantically the restrictions imposed syntactically
by the RDFS axiomatic triples (dom, dom, prop), (dom, range, class),
(range, dom, prop), (range, range, class), and (type, range, class),
and the fact that every element in df must be interpreted as a
property.

The next theorem shows that this definition retains the norma-

tive RDFS semantics for the df vocabulary.
Theorem 5. Let  be the RDFS entailment defined in [17], and let
G and H be df-graphs. Then
G  H iff G df H.

Proof. We present a brief sketch of the proof. The complete proof
can be found in Appendix B.3 In [17], the RDFS entailment relation
is defined by using the notion of RDFS-model: given G and H, it holds
that G  H if every RDFS-model of G is also an RDFS-model of H (see
Definition 30 in Appendix A). An RDFS-model must satisfy several
semantics conditions imposed to properly interpret the RDFS vocabulary (see Definition 30 in Appendix A). It is straightforward to show
that ifI is an RDFS-model of a df graph G, thenI is also a df-model
of G. The crucial property is that if I is a df-model of a df-graph G
and I satisfies all the semantic conditions imposed to interpret the
RDFS vocabulary, then I is also an RDFS-model of G. The if part
of the theorem follows from this last fact. Assume that G df H
and that I is an RDFS-model of G. We need to prove that I is an
RDFS-model of H. Since I is an RDFS-model of G, we know that I
is also a df-model of G and, therefore, from G df H we obtain
that I is a df-model of H. Finally, I is a df-model of H that satisfies
the semantic conditions imposed to RDFS-models, and thus, I is an
RDFS-model of H.
The proof of the only if part is more involved and relies on the
fact that given an interpretationI one can build a new interpretation
I that satisfies the following property: given a df-graph G, the
interpretation I is a df-model of G if and only if I is an RDFSmodel of G. Thus, assume that G  H and let I be a df-model of G.
We need to prove that I is a df-model of H. Since I is a df-model
of G, we know that I is an RDFS-model of G, and thus, from G  H
we obtain that I is an RDFS-model of H. Finally by the properties
of I and I, we know that I is a df-model of H which was to be
proved. 

3 To give continuity of reading to the main results of the paper, we send proofs of

theorems (when long and technical) to Appendix B.

Table 1
Deductive rules for the fragment df

(B,sc,C)

(A,sc,C)

for a map  : G  G

(1) Simple:
(a) G

(2) Subproperty:
(B,sp,C)
(a) (A,sp,B)
(A,sp,C)
(3) Subclass:
(a) (A,sc,B)
(4) Typing:
(a) (A,dom,B)
(5) Implicit Typing:
(C,sp,A)
(a) (A,dom,B)
(X,type,B)
(6) Subproperty Reflexivity:
(a) (X,A,Y)
(A,sp,A)

(X,type,B)

(X,A,Y)

(X,C,Y)

(b)

(A,sp,B)

(A,sp,A)

(B,sp,B)

(7) Subclass Reflexivity:

(a)

(A,sc,B)

(A,sc,A)

(B,sc,B)

(b) G

for G  G

(b) (A,sp,B)

(X,B,Y)

(X,A,Y)

(b) (A,sc,B)

(X,type,A)

(X,type,B)

(b) (A,range,B)

(Y,type,B)

(X,A,Y)

(b) (A,range,B)

(C,sp,A)
(Y,type,B)

(X,C,Y)

(c) (p,sp,p)
(d) (A,p,X)
(A,sp,A)

for p df
for p{dom, range}

(b) (X,p,A)
(A,sc,A)

for p{dom, range, type}

3.2. A deductive system for the df fragment

Now we present a deductive system for df based on a system
of rules for RDFS entailment defined in the W3C Recommendation [17]. Loosely speaking, we work with those rules in [17] which
only involves df vocabulary, and that do not involve allocation
of blanks to literals nor datatypes. We prove later that the deductive system defined for the df fragment is sound and complete for
df-entailment. Table 1 shows the rules for the fragment df.

It is worth mentioning that, as noted in [20,24], the set of rules
presented in [17] is not complete for RDFS entailment. The problem
with the system proposed in [17] is that a blank node X can be
implicitly used as a property in triples like (a, sp, X), (X, dom, b), and
(X, range, c). In this paper we follow the solution proposed by Marin
[20]. In fact, the rules (5a)(5b) were added in [20] to the system
given in [17] to deal with this problem.
Now we formalize deductions made with rules (1)(7). In every
rule letters A, B, C, X, and Y, stand for variables to be replaced by
actual terms. More formally, an instantiation of a rule is a uniform
replacement of the variables occurring in the triples of the rule by
elements of UBL, such that all the triples obtained after the replacement are well formed RDF triples. For example, if a, b U, N  B and
y L, then R/R with R = {(a, sp, b), (N, a, y)} and R = {(N, b, y)}, is
an instantiation of rule (2b).

Definition 6 (Proof). Let G and H be RDFS graphs. Define
G df H iff there exists a sequence of graphs P1, P2, . . . , Pk, with
P1 = G and Pk = H, and for each j (2  j  k) one of the following
cases hold:
- there exists a map  : Pj  Pj1 (rule (1a)),
- Pj  Pj1 (rule (1b)),
- there is an instantiation R/R of one of the rules (2)(7), such that
R  Pj1 and Pj = Pj1  R.
Such sequence of graphs is called a proof of G df H. Whenever G df H, we say that the graph H is derived from the graph
G. Each pair (Pj1, Pj), 1  j  k is called a step of the proof which
is labeled by the respective instantiation R/R of the rule applied at
the step.

The relation df is well defined for df-graphs in the sense that
from a df-graph G only df-graphs can be proved by using rules
(1)(7):

Proposition 7.
Assume G df H. Then H is a dfgraph.

Let G be a dfgraph and let H be an RDFS graph.

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

Proof.
Suppose the assertion of the proposition is false. Thus
there are some triples in H with RDFS vocabulary not included
in df occurring as subject or object. Let P1, P2, . . . , Pk be a proof
of G df H, with P1 = G and Pk = H. Since G is a df-graph, it
follows recursively that exists j with 1 < j  k such that Pj1 is a
df-graph and there is some RDFS vocabulary occurring in Pj that
does not belong to df.

As the application of rule (1) at most adds to Pj1, if adds any, only
triples with some URIs replaced by blank nodes, we have that the
occurrence of RDFS vocabulary either does not change, or decrease.
Therefore rule (1) was not applied to the step (Pj1, Pj) of the proof.
Hence there is an instance R/R of a rule (2)(7) that was applied to
the step (Pj1, Pj) of the proof. Thus Pj = Pj1  R with R  Pj1 and
with some RDFS vocabulary out of df occurring in triples of R. But
a simple inspection of these rules shows that R must have also some
RDFS vocabulary out of df occurring in its triples. As R  Pj1, we
have that Pj1 is not a df graph, a contradiction. 
Theorem 8 (Soundness and completeness). Let G and H be df
graphs. Then
G df H iff GdfH.

The proof of the above theorem is a long list of checkings and it
is given in Appendix B. From Theorems 5 and 8 we get the following
corollary.

Let  be the RDFS entailment defined in [17], and let G

Corollary 9.
and H be df graphs. Then
G  H iff G df H.

Thus, the set of rules (1)(7) captures RDFS entailment when

restricted to df vocabulary.

The following result follows from the proof of Theorem 8. Its

proof is given in Appendix B.
Theorem 10 (Normal form for proofs). Let G and H be dfgraphs
and assume that G df H. Then there is a proof of H from G (in the
sense of Definition 6) such that rule (1a) is used at most once and at
the last step of the proof.

Notice that rule (1a) captures the semantics of blank nodes. Thus,
Theorem 10 essentially states that the inference regarding blank
nodes can always be postponed to the last step in a proof of entail-
ment. We use this result in Section 4 when proposing a minimalist
inference system for RDFS graphs.

3.3. The role of reflexivity

Note that although in df-models we do not impose the a priori satisfaction of any triple, there are triples that are entailed
by all graphs, for example the triples (sp, sp, sp), (sc, sp, sc),
(type, sp, type), (dom, sp, dom), and (range, sp, range). These triples
are true under every df model since sp must be interpreted as a
reflexive relation. Moreover, since blank nodes work as existential
variables, the triples above with their subject or object positions
replaced by blank nodes, are also true in every df-model. The good
news is that these are the only triples in the df fragment that are
satisfied by every model as the following proposition shows.

Let t be an RDF triple such that dft. Then, either
Proposition 11.
t {(sp, sp, sp), (sc, sp, sc), (type, sp, type), (dom, sp, dom), (range,
sp, range)}, or t is obtained from these triples replacing the subject
or/and the object by blank nodes.

It is not difficult to see that the triples in the set A =
Proof.
{(sp, sp, sp), (sc, sp, sc), (type, sp, type), (dom, sp, dom), (range, sp,
range)} together with their existential versions obtained by replacing subject or predicate by blank nodes, are satisfied by every df

model, and so they are dfentailed by every graph G. The rest of
the proof follows by a case by case analysis, taking into account
that, for a ground triple to be satisfied by every model, all its
components must be elements in df. 

We show next that this is part of a more general phenomena,
namely the presence of reflexivity for sp and sc. In fact, we prove
that reflexivity for sp and sc is orthogonal to the rest of the seman-
tics.
Definition 12. An interpretation I is a reflexiverelaxed model
G, iff I is an interunder df of a graph G, denoted by I nrx
df
pretation that satisfies the conditions in Definition 4 for G with the
exception that I does not necessarily satisfy the restrictions stating
that Ext(Int(sp)) and Ext(Int(sc)) are reflexive relations over Prop
and Class, respectively.

For graphs G and H we write G nrx
df

H, iff every reflexive-

relaxed model of G is also a reflexive-relaxed model of H.

Let G and H be df graphs. Assume that H does not
Theorem 13.
contain triples of the form (x, sp, x) nor (x, sc, x) for x  UL, nor triples
obtained from them by replacing the subject and/or the object by blank
nodes. Then
G df H iff G nrx
df

H.

H and let I = (Res, Prop, Class, Ext,
Proof. Assume that G nrx
df
CExt, Lit, Int) be a df model of G. We need to show that I is a df
model of H. Since I is a df model of G, by definition we know that
I is also a reflexiverelaxed df model of G. Now, since G nrx
H,
df
we have that I is also a reflexiverelaxed df model for H. Now, I is
an interpretation that satisfies the conditions of Definition 12 for H,
and is such that Ext(Int(sp)) and Ext(Int(sc)) are reflexive relations.
Hence, I satisfies all the conditions of Definition 4 for H and so I is
a model under df for H, completing this part of the proof.
Assume that G df H and let I = (Res, Prop, Class, Ext,
CExt, Lit, Int) be a reflexive-relaxed df model of G. We need to
show that I is a reflexive-relaxed df model of H. Let I be the
model obtained from I by taking the reflexive closure of the relations Ext(Int(sp)) over Prop, and Ext(Int(sc)) over Class. Thus I is a
df model of G (it satisfies all the conditions in Definition 4 for G).
Since G df H, we have that I is a df model for H. Now we show
that I satisfies all triples (s, p, o) H. Let A be the extension function that I use in modeling H. Thus (IntA(s), IntA(p)) Ext(Int(p))
for every (s, p, o) H. We also know that I and I differ only in
the reflexive pairs of Ext(Int(sp)) and Ext(Int(sc)). Now, because
H does not contain triples of the form (x, sp, x) nor (x, sc, x) nor
their existential versions replacing subject or object by blank nodes,
the same extension function A is such that in I it holds that
(IntA(s), IntA(p)) Ext(Int(p)) for every (s, p, o) H, hence it satisfies
all the conditions of Definition 12, and finallyI is a reflexiverelaxed
model for H, completing this part of the proof. 

Essentially the above theorem states that the only use of reflexive restrictions in RDFS models is the entailment of triples of the
form (x, sp, x), (x, sc, x) (or their existential versions).

Another property of nrx

df is that it does not entail axiomatic

triples:

Corollary 14. There is no triple t such that
nrx
df

t.

Proof.
It is evident that, as the interpretation of sp is not necessarily reflexive over property names, we see that none of the triples
A = {(sp, sp, sp), (sc, sp, sc), (type, sp, type), (dom, sp, dom),
in
(range, sp, range)} are axiomatic for nrx
df. Finally, the fact that
 df completes the proof. 
nrx
df

4. Minimal RDFS

Our main goal in this work is to study the core process of
entailment in RDFS. Towards our goal we have presented the df
fragment, and we have formally proved that the normative RDFS
entailment restricted to this fragment is captured by the inference
rules (1)(7). In this section we take a step forward in our investigation defining the fragment of minimal RDFS. We present a system
of rules for this fragment proving that, avoiding reflexivity, the system is sound and complete for RDFS entailment for minimal RDFS
graphs. We also prove tight complexity bounds for the problem of
testing entailment, and provide an algorithm that is asymptotically
optimal to test entailment in the fragment.

The refinement of df involves restricting graphs to be ground,
and rejecting the presence of df vocabulary as subject or object
of the triples. Avoiding the presence of df vocabulary as subject
or object of triples implies that we avoid the redefinition of RDFS
vocabulary. In [10] the presence of RDFS vocabulary as subject or
object of triples was called non-standard use of RDFS vocabulary.
We agree with [10] conjecturing that, in practice, large classes of
RDFS graphs will not have RDFS vocabulary occurring as subject
or object in their triples. On the other hand, ground restriction is
formally supported by Theorem 10 that states that the application of rule (1a) can be made at the final step of proofs, thus the
introduction of blank nodes is not crucial for proofs.

We show in this section that the two above mentioned restrictions considerably simplify the set of inference rules for RDFS. In
fact, we consider the set of rules (1b), (2), (3) and (4), and we
prove that these rules define a sound and complete system for RDFS
entailment under the above mentioned restrictions.

We start by defining the notions of minimal RDFS triple and minimal RDFS graph, and the system of rules that we use for inference.

Definition 15 (Minimal RDFS). A minimal RDFS triple (mrdftriple
for short) is a ground dftriple having no df vocabulary as subject
or object. A mrdf-graph is a set of mrdf-triples.
For G and H mrdf-graphs, define G mrdf H iff there is proof
of H form G (in the sense of Definition 6) involving solely the rules
(1b), (2), (3) and (4).

This refinement is well behaved, indeed using a similar argu-

ment as in the proof of Proposition 7 it can be shown:

Proposition 16.
Assume that G mrdf H. Then H is a mrdfgraph.

Let G be a mrdfgraph and let H be an RDFS graph.

The following result proves that mrdf is sound and complete
df (see Definition

with respect to the reflexive-relaxed entailment nrx
12) for mrdf-graphs.

Proposition 17.
G mrdf H iff G nrx

df

H.

Let G and H be mrdfgraphs. Then

The proof of the proposition follows from the proof of Theorem
8. Notice that the mrdf fragment considers only ground graphs and
that any ground application of rule (5) reduces to the application of
rules (2b) plus rule (4), thus, we do not need rule (5) for nrx
df. Also
notice that, since nrx
df does not force the reflexivity constrains over
sp and sc, we can avoid rules (6) and (7). The details of the proof
can be found in Appendix.

The following result (that follows from Corollary 9, Theorem 13,
and Proposition 17) states that the normative semantics of RDFS [17]
is captured by the deductive system mrdf for those mrdf-graphs
that do not mention triples of the form (x, sp, x) nor (x, sc, x) for
x  UL.
Corollary 18. Let  be the RDFS entailment defined in [17], and let
G and H be mrdf-graphs. Assume that H does not contain triples of

the form (x, sp, x) nor (x, sc, x) for x  UL. Then
G  H iff G mrdf H.

Thus, by considering rules (1b), (2)(4). we have obtained a very
simple deductive system that preserves the normative RDFS semantics for a large class of graphs.

4.1. Complexity

In this section, we study the complexity of entailment for mrdf.
We prove a lower bound for testing entailment and provide an algorithm that matches this bound. We assume that the data structure
used to store RDF graphs is a set of triples, thus, the input of our
algorithm is a set.

Let us introduce some notation. For a mrdf-graph G and a predicate p, define Gp as the subgraph of G consisting of the triples of
the form (x, p, y) of G, and define G as the subgraph consisting
of triples without df vocabulary. Let G(sp) be the directed graph
whose vertices are all the elements v which occur as subject or
objects in the triples of G, and in which (u, v) is an edge if and only
if (u, sp, v) G. Define G(sc) similarly. Let V be the vocabulary that
is not RDFS vocabulary.
The naive approach to test the entailment G mrdf H in the
ground case would be to consider the closure of G, that is the graph
obtained by adding to G all triples that are derivable from G using
rules (2), (3) and (4), and check if H is included in that closure. The
following results show that this procedure would take time 	(|H| 
|G|2) in the worst case, which is too expensive from a database point
of view in the worst case:

Theorem 19 (Size of closure). Let G be a mrdfgraph.
(i) The size of the closure of G is O(|G|2).
(ii) The size of the closure of G is, in the worst case, no smaller than

 (|G|2).

For the upper bound, the result follows by an analysis of the
rules. The most important point is the propagation  when applicable  of the triples of the form (x, a, y) through the transitive closure
of the G(sp) graph by the usage of rule (2b): it can be shown that this
gives at most |G|  |Gsp| triples. For triples having a fixed predicate
in df the quadratic bound is trivial. The lower bound follows from
the example below.

Example 20 (Lower bound for the closure). Consider the graph
{(a1, sp, a2), . . . , (an, sp, an+1)}.
The number of triples of the closure of the graph is
order  (n2).

k=1

k that is

The algorithm in Table 2 presents a much better procedure to
check ground entailment in this fragment as next theorem states.

Theorem 21. Let (a, b, c) be a mrdftriple and let G be a mrdfgraph.
Then the algorithm in Table 2 can be used to test the entailment
G mrdf

(a, b, c) in time O(|G| log |G|).

The proof of the theorem rests in the following interpolation
lemmas that state which specific subgraph of G is relevant when
deriving triples containing df vocabulary as predicate, or having no
df vocabulary at all. Let us denote by G|S the subgraph of G induced
by vocabulary S, i.e. those triples of G having subject, predicate, or
object in S.

Lemma 22.
and G a
mrdfgraph. Assume that b does not belong to df. Then
G mrdf

iff G|{sp,a,b,c}mrdf(a, b, c).

a mrdftriple

(a, b, c)

(a, b, c)

Let

be

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

Table 2
Algorithm for checking entailment for minimal RDFS

Algorithm (minimal RDFS entailment)

1.
2.
3.
4.

5.

6.

if there is a path from a vertex marked with (a, b) which

be the graph G(sp) with the following marks:

be the graph G(sp) with the following marks:

IF p{dom, range} THEN check if (a, p, b) G.
IF p = sp, a /= b, THEN check if there is a path from a to b in G(sp).
IF p = sc, a /= b, THEN check if there is a path from a to b in G(sc).
IF p / df THEN check if (a, p, b) G; if it is not:
LET G(sp)
For each (u, v, w) G, if v G(sp) then mark v with (u, w).
IN Check in G(sp)
reaches p.
IF p = type THEN
LET G(sp)
- -For each triple (u, dom, v) G, mark the vertex u in G(sp) with d(v).
- -For each triple (z, e, y) G, if e G(sp), mark the node e with s(z).
LET Ld be the ordered list of elements d(v) such that there is a path from v
to b in G(sc)
LET Ls be the ordered list of elements s(z) such that either:
(1) in G(sp)
an element in Ld, or
(2) there is (z, type, v) G, for d(v) Ld.
IN Check if s(a) is in Ls.
Repeat point 5 symmetrically for range instead of dom. (making the
corresponding changes)

there is a path from a node marked s(z) to a node marked with

Proof. We only need to prove G|{sp,a,b,c}mrdf(a, b, c) under
the assumption G mrdf
(a, b, c) (the other direction is trivial).
Assume G mrdf
(a, b, c). Thus a proof sequence P1, . . . Pk1, Pk
exists with Pk = {(a, b, c)}.
Since (a, b, c) is ground, there is an instance S/S of a rule among
(2)(4) with S = {(a, b, c)}. Given that b / df, the only rule that
were applied is (2b), with S = {(B, sp, b), (a,B, c)}. We assume B /= b
to avoid a trivial and unnecessary application of the rule. Note that
by Proposition 16 and the assumption about G, B / df.
Thus we need to show that G |{sp,a,b,c} mrdf
(B, sp, b)
and G |{sp,a,b,c} mrdf
(a,B, c). We can apply the same argument again to (a,B, c), avoiding trivial applications of rule
(2b). For (B, sp, b) we only need to observe that any instance
R/R of a rule among (2)(4) having R = {(B, sp, b)} with B /= b
must be an instance of rule (2a), thus having as premises R =
{(B, sp,C), (C, sp, b)}. We can observe that, if B = C or C = b, thus
the application of the rule can be avoided. In any case only triples
of the form (a,D, c) or (C, sp,E), with C /= D, are needed. 

The next lemma characterizes mrdf-entailment of triples with

dom and range predicates:

Lemma 23.
do not belong to df. Then

Let G be a mrdfgraph. Let a, b UBL and assume a, b

(i) G mrdf
(ii) G mrdf

(a, dom, b)
(a, range, b)

iff

iff

(a, dom, b) G,

(a, range, b) G.

Proof.

(i) We only need to prove that (a, dom, b) G under the assumption
G mrdf
(a, dom, b) (the other direction is trivial). So assume
G mrdf
(a, dom, b). Thus a proof sequence P1, . . . Pk1, Pk
exists with Pk = {(a, dom, b)}. Thus (a, dom, b) Pj for some j  k.
Assume j is the least index with this property. As we only concern with rules (2)(4), we have that (a, dom, b) G or there
exists an instance R/R of these rules such that (a, dom, b) R.
But this happens only for rule (2b), which forces a triple of the
form (A, sp, dom) R. By Proposition 16, this fact contradicts the
assumption about G. Therefore (a, dom, b) G.
(a, range, b) iff (a, range, b) G is similar
to the previous proof, replacing dom by range. 

(ii) The proof of G mrdf

The next lemma characterizes mrdf-entailment of non-reflexive

triples with sc and sp predicates:

Let G be a mrdfgraph. Let a, b UBL and assume a, b

Lemma 24.
do not belong to df and that a /= b. Then
(i) G mrdf
(ii) G mrdf

(a, sc, b)
(a, sp, b)

iff G|{sc}mrdf(a, sc, b).
iff G|{sp}mrdf(a, sp, b).

Proof.
(i) We only need to prove that G|sc mrdf

(a, sc, b) under
(a, sc, b) (the other direction is
(a, sc, b). Thus a proof sequence

the assumption G mrdf
trivial). Assume G mrdf
P1, . . . Pk1, Pk exists with Pk = {(a, sc, b)}.
As (a, sc, b) is ground, it may be in G, in which case it is true
that G |sc mrdf
(a, sc, b), or it was obtained at some step
by the application of an instance of a rule among (2)(4). In
this last case, let i be the step (Pi1, Pi) where (a, sc, b) was
introduced, by means of the instance R/R of a rule among
(2)(4); we can assume that i is the least index with this prop-
erty. But as a /= b, the rule must be (3a), with premises R =
{(a, sc,C), (C, sc, b)}. If a = C or C = b, then (a, sc, b) R  Pi1
contradicting the assumption about i. Thus a /= C and C /= b.
We can now apply the same argument again to (a, sp,C) and
(C, sc, b).
(a, sp, b) iff G|spmrdf(a, sp, b) is
similar to the used above for the proof of G mrdf
(a, sc, b) iff
G |scmrdf(a, sc, b), replacing sp by sc and (3a) by (2a). 

(ii) The argument for G mrdf

It turns out that type is the most complex to deal with, as next

lemma shows:

Let G and H be mrdfgraphs. Assume G mrdf H.

Lemma 25.
Then:
(i) If type / voc(H) then

G |voc(H){sp} mrdf H.

(ii) If type voc(H) then

G |voc(H){dom,range,sp,sc} mrdf H.

Proof.
The first statement of the lemma follows directly from
Lemmas 2224. The second statement of the lemma follows from
the observation that there are two cases for deriving (x, type, b)
using rules (2)(4):

- It can be derived applying rule (3b) from triples (x, type, a) and
(a, sc, b), thus, the statement follows recursively from Lemma 24;
or

- it can be derived applying rule (4) from triples (a, dom, b) or
(a, range, b), plus a triple (x, a, y), thus, the statement follows
recursively from Lemmas 23 and 22. 

Correctness and completeness of the algorithm follows from an
inspection of the rules and from the previous interpolation lem-
mas. The algorithm uses the rules in a bottom-up fashion. There
are some subtleties in points 4 and 5. Point 4 follows from Lemma
22, which states that the deduction of a triple (a, b, c) with b not
belonging to df depends only on the subgraph of G generated by
the vocabulary {a, b, c, sp}. Hence rules (2a) and (2b) are the only
relevant: (2a) constructs the graph G(sp) and (2b) puts the marks.
can be done in |G| log |G| steps: order G
The construction of G(sp)
and then while traversing G(sp) do binary search on G.

In spite of the above apparently bad complexity behavior, polynomial bounds for the problem can be derived from well-known
databases and constraint satisfaction results [6,9,1,14], by considering special forms of interaction between blank nodes and applying
Theorem 10.

For the purposed uses of RDFS, the whole Web, polynomial
bounds are still not satisfactory. In the next result we provide a
tight bound for entailment for a big class of RDFS graphs containing
blank nodes, that are likely to occur in practice. Indeed the theorem
shows that for that class, testing df entailment in general can be
done asymptotically as fast as for the ground case.

Theorem 29.
Let G and H be graphs in minimal RDFS extended by
allowing that each triple in H has at most one blank node. Then deciding
whether G df H can be done in time O(|H||G| log |G|).
Proof. Let H0 be the subset of ground triples of H. We already know
that checking G df H0 can be done in time O(|H0||G| log |G|). For
the non-ground part, let H = H\H0, and assume that k blank nodes
occur in H. For each such blank node Xj (1  j  k) in H consider the
graph Hj consisting of all triples of H in which Xj occurs. Because
each triple has at most one blank node, H is the disjoint union of the
Hj for j = 1, . . . k, and, if G df H then the map of the last step in
Theorem 10 is as well a disjoint union of the maps j which witness
each G df Hj. Hence, it is enough to check if G df Hj for
each j = 1, . . . , k.
Now, for each graph Hj with j = 1, . . . , k do the following: For
each triple t  Hj build a list Lt with all instantiations v of Xj for which
G df
t[v/Xj]. Each such list has at most voc(G) elements, and
then each list is of size at most |G|. Using the algorithm for ground
entailment, it is not difficult to check that this list can be built in
time O(|G| log |G|). In fact, for the cases (1)(3) in the algorithm, the

result is trivial. For (4), expand the graph G(sp)
from p looking for
nodes marked (x, b) (resp. (a, x)) and each time one is found, include
the value x is the list. For (5), and (Xj, type, b) note that the list Ls
gives all the solutions. For (6) and triple of the form (a, type, Xj),
the list Ld should include all nodes reachable from any d(v). Finally,
let L1, . . . , L|Hj| be the lists obtained. Order each of them, and then,
compute the intersection of L1, L2, compute the intersection of this
list with L3 and so inductively, and test if the result is non-empty.
This process takes timeO(|Hj||G| log |G|), and then the whole process
takes O(|H||G| log |G|). 

5. Related work and concluding remarks

The normative semantics of RDFS [17] has two drawbacks: it is
formulated in highly non-standard fashion and is complex to read,
which makes it difficult to deal with for the common database, logician or even developers. Several works have dealt with the problem
of providing a more clean (or standard) semantics for the normative
RDFS semantics. Among them, the first formalizations we can mention is Mendelzon and co-workers [16] which emphasizes database
features, the formalization by Marin [20], and the formalization by
ter Horst [24], the last two providing a formal semantics for the
whole language, but deviating little from the normative approach.
A further discussion on the logical foundations of the RDF specification was done by de Bruijn et al [9].

There are other approaches to define a semantics for RDFS which
definitively depart from the normative approach. Although, the
focus in our work is not to provide a standard semantic definition for RDFS, but to study fragments of the normative semantics
with a good compromise between expressiveness and computational complexity, some of our results have a close relationship with
these works.

In RDFS(FA) [22], the authors are motivated by the problem
of RDFS having a non-standard meta-modelling architecture. The

Fig. 1. Point 5 of the algorithm for checking entailment for minimal df.

For point 5 we are checking (a, type, b) (see Fig. 1). The crucial observation is that in G(sp)
, if there is a path from a vertex
marked s(z) to a vertex u marked d(v), then G mrdf
(z, u, y) for
some y, and hence G mrdf
(z, type, v) using rule (4a) (or rule
(4b)). From here it follows that if there is a path in G(sc) from a
node v (with d(v) Ld) to b, then using iteratively the rule (3b) we
get G mrdf
(z, type, b). Hence a check in the list Ls for s(a) will
determine if G  (a, type, b) or not.

Now it rest to check if all this can be done efficiently. First, it

is no difficult to see that the construction of G(sp)
can be done in
time |G| log |G|. The construction of the list Ld takes time |G| log |G|:
List all d(v), order them, and then expand the graph G(sc) from b
each time looking at Ld to mark the corresponding element. At the
end, delete unmarked elements. The construction of Ls takes time
|G| log |G| as well: First list all elements s(z) (no more than |G|) in
a list L
, mark green each node
marked with an element of Ld. Now recursively do the following:
(1) if a node green is marked with an s(z0), mark that element in L
s;
(2) Expand the green nodes. At the end of the process, delete from

s all non-marked elements to get Ls. This completes the proof of
Theorem 21.

s. Then in the directed graph G(sp)

The next result shows that the above algorithm cannot be essentially improved, in the sense that, any other algorithm for testing
the ground entailment Gmrdft would take time proportional to
|G| log |G| in the worst case.
Theorem 26. Let t be a mrdftriple and let G be a mrdfgraph. Then
testing Gmrdft uses  (|G| log |G|) comparisons between RDF terms in
the worst case.

Proof. The bound is obtained by coding the problem of determining whether two sets are disjoint, which is a well known problem
that needs  (n log n) comparisons in the worst case [2]. Given the
sets A = {a1, . . . , an} and B = {b1, . . . , bn}, construct a graph G as
follows:
G = {(ai1, sp, ai)}
Then, we have that Gmrdf(x, an, y) iff A  B /= . 

2in  {(x, bj, y)}

Finally, we can state a bound for deciding G mrdf H.

1jn

Corollary 27.
G mrdf H can be done in time O(|H||G| log |G|).

Let G and H be mrdfgraphs. Then deciding if

4.2. An extension with blank nodes

For the sake of completeness, we state here the complexity of
deduction for graphs including blank nodes. The hardness part of
the following complexity result has appeared in several papers
in different formulations and for different fragments of RDFS (for
example [17], [16], [1], [24], and [9]), that is, it belongs to the f olklore
of RDF.

Theorem 28 (Folklore). Given (not necessarily ground) graphs G and
H, deciding if G df H is NP-complete.

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

paper is mostly focused in describing the RDFS(FA) semantics for
RDFS, a semantics that can interoperate with conventional firstorder languages like DAML + OIL and OWL. The central idea is to
have a f ixed-layer architecture for RDFS, in order to clear possible confusions in the usage of the same term for multiple roles. The
authors claim that these confusions may arise in RDFS, for example,
when the same name is used as standing for an object, a predicate,
a class, etc. in a single ontology. RDFS(FA) is a sublanguage of RDFS,
and its semantics explicitly divides the set of discourse in strata or
layers. The authors came up with a semantics that has clear differences with the normative RDFS semantics. In our work, although we
have different motivations, we tackle the same problem but from
a completely different perspective. We keep the normative RDFS
semantics and show that, in an fragment of the language that comprises the core functionalities, a standard semantics, equivalent to
the normative one, can be developed, and moreover, show that the
remaining ones can be safely avoided.

In RDF-F-Logic [25] the authors propose a semantics for RDFS
using an extension of the F-Logic formalism [18]. This extension is
expressive enough to deal with anonymous resources (blank nodes)
and reification. With the F-Logic formalism for RDFS the authors
obtain by free an expressive framework for modeling ontologies,
and a powerful deductive system. The authors claim that an important advantage of their approach is that F-Logic would gave RDFS a
standard (second order) logical semantics. As we have mentioned,
instead of extending the expressive power of RDFS, our main interest have been to study fragments with less but enough expressive
capabilities for most uses, yet having an efficient reasoning system.
A third group of proposals deal with the relationship/interplay
of RDFS and ontology languages, namely OWL and the family of
description logics known as DL-Lite. Grau [15] proposes RDFS(DL),
a sublanguage of the RDFS(FA) discussed above. RDF-Schema(DL)
essentially amount to suppress the meta-modelling architecture of
RDFS(FA) and takes advantage of developments in description log-
ics, particularly OWL-Lite. The motivation for this design decision
is that this meta-modelling feature in RDFS(FA) does not seem to
increase the expressive power of the language. A relevant development for the RDFS(DL) proposal is a family of description logics,
DL-Lite that was introduced to deal with the complexity concerns
while keeping as much expressive power as possible, and improving on some database aspects like querying [4]. The RDFS(DL)
approach differs from ours in that its main goal is more directed
to compatibility with OWL and upper layers than to design a minimalist sublanguage of RDFS with low complexity directly oriented
to database processing.

Concluding remarks: We presented a streamlined fragment of
RDFS which includes the most important and used vocabulary for
describing data, avoiding vocabulary and semantics that ideally
should be part of the structure of the language. We gave a semantics and a set of rules that captures for this fragment precisely the
standard semantics of RDF as defined in the W3C Recommendation.

Based on this fragment, we isolated a minimal system for RDFS.
This fragment avoids features that are rarely used such as reflexivity
and distinguished vocabulary in object and subject positions. We
have presented a very simple deductive system for this fragment,
we have proved some complexity bounds for the entailment prob-
lem, and we have provided an algorithm to test entailment that is
asymptotically optimal. This fragment should work as an essential
minimal and efficient floor from where to extend the language in
different directions.

We think that the minimal RDFS deductive system that we have
presented in this paper, by their simplicity and efficiency, could be
of help for developers, designers, and theoreticians that work at the
data level in the Semantic Web.

Acknowledgments

The authors would like to thank the anonymous referees for
their careful reading of the paper, and for providing many useful
comments. The authors were supported by: Gutierrez - Fondecyt grant 1070348; Perez - Conicyt Ph.D. Scholarship; Gutierrez,
Munoz-Venegas, and Perez - grant P04-067-F from the Millennium
Nucleus Center for Web Research.

Appendix A. RDFS definitions

In this and the following section we denote by rdfsV the RDFS
vocabulary (as shown in Table A.1). Recall that we assume that the
RDFS vocabulary already contains the RDF vocabulary [17].

(cf.

[17,20].

I =
Definition
(Res, Prop, Class, Ext, CExt, Lit, Int) is an RDFS model for an RDF
graph G, denoted by I  G, iff I is an interpretation over vocabulary
rdfsV  terms(G) that satisfies the RDFS axiomatic triples [17] (see
Table A.2) and the following semantic conditions:

interpretation

The

(i) Simple:

(ii) RDF:

(a) there exists a function A : B  Res such that for each
(s, p, o) G, Int(p) Prop and (IntA(s), IntA(o)) Ext(Int(p)),
where IntA is the extension of Int using A.
(a) x  Prop iff (x, Int(prop)) Ext(Int(type))
(b) If l  terms(G) is a well-typed XML literal [17] with lexical form w, then Int(l) is the XML literal value of w,
Int(l) Lit, and (Int(l), Int(xmlLit)) Ext(Int(type)). Other-
wise, if l is an ill-typed XML literal [17] then Int(l) / Lit and
(Int(l), Int(xmlLit)) / Ext(Int(type)).

(iii) RDFS Classes:

(a) x  Res iff x  CExt(Int(res))
(b) x  Class iff x  CExt(Int(class))
(c) x  Lit iff x  CExt(Int(literal))

(iv) RDFS Subproperty:

Table A.1
RDFS vocabulary [17], with shortcuts in brackets

rdfs:Resource [res]
rdf:Property [prop]
rdfs:Class [class]
rdfs:Literal [literal]
rdfs:Datatype [datatype]
rdf:XMLLiteral [xmlLit]
rdfs:Container [cont]
rdf:Statement [stat]
rdf:List [list]
rdf:Alt [alt]
rdf:Bag [bag]
rdf:Seq [seq]
rdfs:ContainerMembershipProperty [contMP]

rdf:type [type]
rdfs:domain [dom]
rdfs:range [range]
rdfs:subClassOf [sc]
rdfs:subPropertyOf [sp]
rdf:subject [subj]
rdf:predicate [pred]
rdf:object [obj]
rdfs:member [member]
rdf:first [first]
rdf:rest [rest]
rdfs:seeAlso [seeAlso]

rdfs:isDefinedBy [isDefined]
rdfs:comment [comment]
rdfs:label [label]
rdf:value [value]
rdf:nil [nil]
rdf: 1 [ 1]
rdf: 2 [ 2]
. . .
rdf: i [ i]
. . .

Table A.2
RDFS axiomatic triples [17,20]

(1) Type

(2) Domain

(3) Range

(4) Subclass

(5) Subproperty

(isDefined, sp, seeAlso)

(alt, sc, cont)
(bag, sc, cont)
(seq, sc, cont)
(contMP, sc, prop)
(xmlLit, sc, literal)
(datatype, sc, class)

(type, type, prop)
(subj, type, prop)
(pred, type, prop)
(obj, type, prop)
(first, type, prop)
(rest, type, prop)
(value, type, prop)
( 1, type, prop)
( 1, type, contMP)
( 2, type, prop)
( 2, type, contMP)
. . .
( i, type, prop)
( i, type, contMP)
. . .
(nil, type, prop)
(xmlLit, type, datatype)

(type, dom, res)
(dom, dom, prop)
(range, dom, prop)
(sp, dom, prop)
(sc, dom, class)
(subj, dom, stat)
(pred, dom, stat)
(obj, dom, stat)
(member, dom, res)
(first, dom, list)
(rest, dom, list)
(seeAlso, dom, res)
(isDefined, dom, res)
(comment, dom, res)
(label, dom, res)
(value, dom, res)
( 1, dom, res)
( 2, dom, res)
. . .
( i, dom, res)
. . .

(type, range, class)
(dom, range, class)
(range, range, class)
(sp, range, prop)
(sc, range, class)
(subj, range, res)
(pred, range, res)
(obj, range, res)
(member, range, res)
(first, range, res)
(rest, range, list)
(seeAlso, range, res)
(isDefined, range, res)
(comment, range, literal)
(label, range, literal)
(value, range, res)
( 1, range, res)
( 2, range, res)
. . .
( i, range, res)
. . .

(a) Ext(Int(sp)) is transitive and reflexive over Prop
(b) if (x, y) Ext(Int(sp)) then x, y Prop and Ext(x)  Ext(y)

(v) RDFS Subclass:

(vi) RDFS Typing:

(a) Ext(Int(sc)) is transitive and reflexive over Class
(b) if (x, y) Ext(Int(sc)) then x, y Class and CExt(x)  CExt(y)
(a) x  CExt(y) iff (x, y) Ext(Int(type))
(b) if (x, y) Ext(Int(dom)) and (u, v) Ext(x) then u CExt(y)
(c) if (x, y) Ext(Int(range)) and (u, v) Ext(x) then v CExt(y)
(a) if x  Class then (x, Int(res)) Ext(Int(sc)).
(b) if
then
(c) if x  CExt(Int(contMP)) then (x, Int(member)) Ext(Int(sp))

(x, Int(literal)) Ext(Int(sc))

x  CExt(Int(datatype))

(vii) RDFS Additionals:

Now, given two graphs G and H we say that G RDFS entails H and
write G  H, iff every RDFS model of G is also an RDFS model of H.

Appendix B. Proofs

Proof of Theorem 5.
Definition 30 of Appendix A for RDFS models.

In the proof of this Theorem we use
Assume that GdfH and let I be an RDFS model of G, that is, I
satisfies all the conditions in Definition 30 for G. We need to show
that I is an RDFS model of H.
As I satisfies conditions (i), (iv)(vi) of Definition 30, we have
that I interprets every element in df as a property name, and it
also satisfies the axiomatic triples

(dom, dom, prop), (dom, range, class), (range, dom, prop),

(range, range, class),and(type, range, class)

Thus I also satisfies all conditions in Definition 4 and so I is also
a df model for G. Now I is a df model for H that satisfies all the
conditions of Definition 30 and then I is also an RDFS model for H,
completing this part of the proof.
Assume that G  H, and let I = (Res, Prop, Class, Ext, CExt, Lit,
Int) be a df-model of G. We need to show that I is a df-model
of H. To prove this property, we first construct an RDFS model I of
G from I.
First, we assume that for each e rdfsV there is an element xe
that is used to interpret e in I. Further assume that Int(e) = xe for

every e df in I. Since I is an interpretation under df, it follows
that Int(e) is not defined for each e rdfsV  df (the set differ-
ence). Now, let Ax be the set of all RDFS axiomatic triples [17] (see
Table A.2). With the above observation we construct the interpretation I as follows. Let I = (Res, Prop, Class, Ext, CExt, Lit, Int)
be the interpretation defined on the top of I by:

- Res = Res  Prop  {xe|e rdfsV}.
- Prop = Prop  {xe|e df}  {xe|(e, type, prop) Ax} 
{xe|(e, sp, y), (z, sp, e), (e, dom, u),or(e, range, v) Ax} 
{x|(x, y) Ext(xsp), (z, x) Ext(xsp), (x, u) Ext(xdom),or(x, v)
Ext(xrange)}.
- Class = Class  {xe|(y, type, e) Ax} 
{xe|(e, sc, y), (z, sc, e), (u, dom, e),or(v, range, e) Ax} 
{x|(y, x) Ext(xtype)}  {x|(x, y) Ext(xsc), (z, x) Ext(xsc), (u, x)
Ext(xdom),or(v, x) Ext(xrange)}.
- Lit = Lit.
- Int is such that Int(e) = xe for each e rdfsV, and Int(x) = Int(x)
in other case.
- Ext is an extension function such that:
 Ext(xtype) = Ext(xtype)  {(xs, xo)|(s, type, o) Ax} 
{(y, xres)|y Res}  {(y, xprop)|y Prop} 
{(y, xclass)|y Class}  {(y, xliteral)|y Lit} 
{(x, y)|x  Res, (xe, y) Ext(xdom)  Ext(xrange) with e df}.
 Ext(xdom) = Ext(xdom)  {(xs, xo)|(s, dom, o) Ax}.
 Ext(xrange) = Ext(xrange)  {(xs, xo)|(s, range, o) Ax}.
 Ext(xsc) = Ext(xsc)  {(xs, xo)|(s, sc, o) Ax} 
{(x, x)|x  Class}  {(y, xres) | y Class}.
 Ext(xsp) = Ext(xsp)  {(xs, xo)|(s, sp, o) Ax} 
{(x, x)|x  Prop}  {(x 1, xmember), (x 2, xmember), . . .}.
 Ext(xe) =  for every xe  Prop such that e rdfsV  df.
 Ext(x) = Ext(x) in all other cases.
- CExt is such that:
 CExt(xres) = Res.
 CExt(xprop) = Prop.
 CExt(xclass) = Class.
 CExt(xliteral) = Lit.
 CExt(xcontMP) = {x 1, x 2, . . .}.
 CExt(xdatatype) = {xxmlLit}.
 CExt(xe) =  for e{xmlLit, cont, alt, bag, seq, list, stat}.
 CExt(x) = CExt(x)  Res
(xe, x) Ext(xdom)  Ext(xrange)
e df.
 CExt(x) = CExt(x) in all other cases.

for

if

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

Note that I is well defined in the sense that every one of its
components is defined in terms of notions defined before.
Now we prove that I is an RDFS model of G. First note that
for every RDFS axiomatic triple (s, p, o) we have that p df. From
the construction of Prop, Int, and Ext, we have that Int(p) =
xp  Prop and (Int(s), Int(o)) = (xs, xo) Ext(xp) = Ext(Int(p)) for
every RDFS axiomatic triple (s, p, o). Thus I satisfies all RDFS
axiomatic triples.
Now we prove that I satisfies all the conditions en Definition
30. First observe that I satisfies conditions (i), (iv), (v), and (vi) of
Definition 30 for G, because I is a df model for G. Now for I:

(i) Simple:

(a) For every e df we have that Int(e) = xe = Int(e) and
Ext(xe)  Ext(xe), and Int and Ext are defined exactly
as Int and Ext in all other cases. Note also that G does
not mention RDFS vocabulary outside df. Hence for
every triple (s, p, o) G we have that (Int(s), Int(o)) =
(Int(s), Int(o)) Ext(Int(p))  Ext(Int(p)) = Ext(Int(p)).
Therefore I satisfies this condition for G.

(ii) RDF:

(iii) RDFS classes:

(iv) RDFS subproperty:

(a) We have that G does not mention prop, so I does
not interpret prop and thus there is no y such that
(y, xprop) Ext(xtype) in I. By definition of Ext(xtype) in I,
we have that (y, xprop) Ext(xtype) iff y Prop, and so I
satisfies this condition for G.
(b) Since G is a df-graph we have that there is no XML
typed literal in G. Thus, by the definition of Ext(xtype) and
CExt(xxmlLit), we have that I satisfies this condition for G.

(a) By the construction of I we have CExt(xres) = Res.
(b) By the construction of I we have CExt(xclass) = Class.
(c) By the construction of I we have CExt(xliteral) = Lit.
(a) By the construction of I we have that Ext(xsp) is
reflexive over Prop. Now, note that the only axiomatic
triple that mention sp in its predicate position is
(isDefined, sp, seeAlso). Thus we must only prove that
Ext(xsp)  {(xisDefined, xseeAlso), (x 1, xmember), (x 2, xmember), . . .}
is a transitive relation, which is a direct consequence of the
fact that Ext(xsp) is transitive and that G does not mention
isDefined, nor seeAlso, nor i for any i.
(x, y) Ext(xsp) = Ext(xsp)  {(xisDefined, xseeAlso)} 
{(x, x) | x  Prop}  {(x 1, xmember), (x 2, xmember), . . .}.
For
(x, y) Ext(xsp)
the condition holds because I satisfies this condition. For (xisDefined, xseeAlso) we have
Ext(xisDefined) =
that
  Ext(xseeAlso).
that
x i, xmember  Prop and Ext(x i) =   Ext(xmember). Finally,
for (x, x) Ext(xsp) we have x  Prop and so the condition
holds.

xisDefined, xseeAlso  Prop

(x i, xmember) we

(b) Let

have

and

For

(v) RDFS subclass:

(a) By the construction of I we have that Ext(xsc) is reflexive over Class. Note that (c3, sc, c4) for every pair of
axiomatic triples (c1, sc, c2), so we have that c2 /= c3, and
also that c1, c2, c3, c4  rdfsV  df (see Table A.2). Consider (x, y), (y, z) Ext(xsc): if x = y or y = z, we have
(x, z) Ext(xsc); if x /= y and y /= z, by the previous observation and the fact that G does not mention RDFS vocabulary
outside df, we have that (x, y), (y, z) Ext(xsc) and then
by transitivity of Ext(xsc) we have that (x, z) Ext(xsc) 
Ext(xsc). Finally Ext(xsc) is a transitive relation.
(x, y) Ext(xsc) = Ext(xsc)  {(xs, xo)|(s, sc, o) Ax} 
{(x, x)|x  Class}  {(y, xres)| for everyy Class}.
For
(x, y) Ext(xsc), the condition holds because I satisfies this condition. Now, note that for every axiomatic

(b) Let

xc1

, xc2

 Class

and CExt(xc1 ) =  except
x /= xcontMP

triple (c1, sc, c2), by the construction of I we have
that
for
the case when c1 is contMP or datatype. Thus, for
(x, y){(xs, xo)|(s, sc, o) Ax} with
and
x /= xdatatype, we have that x, y Class and CExt(x) =
  CExt(y). For the case in which x = xcontMP we have
y = xprop, and by the construction of I we have CExt(x) =
{x 1, x 2, . . .}  Prop = CExt(xprop) = CExt(y). For the case
in which x = xdatatype we have y = xclass, and by the
construction of I we have CExt(x) = {xxmlLit}  Class =
CExt(xclass) = CExt(y).
(x, y){(y, xres) | y Class}
we have that x, y = xres  Class, and by the construction of I, CExt(x)  Res = CExt(xres) = CExt(y) (note
that Res
is a superset of Prop, Class, and Lit, and
that in I for every x  Class we have CExt(x)  Res).
Finally, if (x, y){(x, x)|x  Class} then x = y Class and
CExt(x)  CExt(y), completing the proof of this condition
for I.

If

(vi) RDFS typing:

some

If y = xdatatype

for
an axiomatic
(x, y) Ext(xtype).

(a) Let x  CExt(y), we have several cases: First note that
y /= xe for every e{xmlLit, cont, alt, bag, seq, list, stat}
because in these cases CExt(y) = .
If y = xe
for
e{res, prop, class, literal}, we have (x, y) Ext(xtype)
If y = xcontMP
by the construction of Ext(xtype) in I.
then x = x i
i, and because for every
triple ( i, type, contMP),
there is

we have that
then
x = xxmlLit, and because there is an axiomatic triple
(xmlLit, type, datatype), we have that (x, y) Ext(xtype).
Now if y is such that (xe, y) Ext(xdom)  Ext(xrange) for
e df, we get x  CExt(y) = Res and therefore by the
construction of Ext(xtype) we have (x, y) Ext(xtype). In
other case CExt(y) = CExt(y) and so, as I satisfies this
condition, we have that (x, y) Ext(xtype)  Ext(xtype).
Now, if we consider (x, y) Ext(xtype), we have several
cases. If (x, y){(y, xres)|y Res}  {(y, xclass)|y Class} 
{(y, xprop)| y Prop}  {(y, xliteral)|y Lit}, by the construction of I we have x  CExt(y). If (x, y) Ext(xtype), as
I satisfies this condition and G does not mentions RDFS
vocabulary outside df we have x  CExt(y)  CExt(y).
If (x, y){(xs, xo)|(s, type, o) Ax}, by the construction of
Prop, CExt(xprop), CExt(xcontMP), and CExt(xxmlLit), and the
specific axiomatic triples that have type as predicate
(see Table A.2), we have x  CExt(y). If (x, y) is such that
(xe, y) Ext(xdom)  Ext(xrange) with e df, we have by construction of CExt that CExt(y) = Res and then because
x  Res we have x  CExt(y), completing the proof of this
part.
(b) Let (x, y) Ext(xdom) and (u, v) Ext(x). First note that
x /= xe for every e rdfsV  df with xe  Prop, because in
these cases Ext(x) = . Also note that if (x, y) Ext(xdom)
and (u, v) Ext(x) then, because I satisfies this condition
we have that u CExt(y). Additionally note that Ext is
different to Ext only in elements xe with e df, so all
remaining cases that left to be checked are the ones in
which (u, v) Ext(xe) with e df. We consider now all the
remaining cases.
and
Case
(u, v) Ext(xtype) we must prove that u CExt(y). First,
(xtype, y) Ext(xdom) we have (xtype, y) Ext(xdom)
for
or y = xres by the axiomatic triple (type, dom, res).
If y = xres and (u, v) Ext(xtype), the condition holds
because u Res = CExt(xres) = CExt(y). Assuming that
(xtype, y) Ext(xdom), by the construction of CExt we have
that CExt(y) = CExt(y)  Res and from u Res we obtain
u CExt(y).

(xtype, y) Ext(xdom),

x = xtype:

If

that

get

x = xrange:

u CExt(y).

(xrange, y) Ext(xdom),

(u, v){(xs, xo)|(s, dom, o) Ax},

Case x = xdom: If (xdom, y) Ext(xdom), and (u, v) Ext(xdom)
we must
for
First,
(xdom, y) Ext(xdom) we
(xdom, y) Ext(xdom)
or
y = xprop by the axiomatic triple (dom, dom, prop).
If
y = xprop and (u, v) Ext(xdom), we have two cases: if
(u, v){(xs, xo)|(s, dom, o) Ax}, by the construction ofI we
have u Prop = CExt(xprop) = CExt(y); if (u, v) Ext(xdom),
by the construction of Prop we have u Prop. Now for
(xdom, y) Ext(xdom), by the construction of CExt we have
that CExt(y) = CExt(y)  Res and as u Res we obtain
u CExt(y).
Case
and
(u, v) Ext(xrange) we must prove that u CExt(y). First,
for (xrange, y) Ext(xdom), we have (xrange, y) Ext(xdom)
or y = xprop by the axiomatic triple (range, dom, prop).
If y = xprop and (u, v) Ext(xrange), we have two cases:
if
construc-
tion of I we have u Prop = CExt(xprop) = CExt(y); if
(u, v) Ext(xrange), by the construction of Prop we have
u Prop. Now for (xrange, y) Ext(xdom), by the construction
of CExt we have that CExt(y) = CExt(y)  Res and as
u Res we obtain u CExt(y).
Case x = xsp: If (xsp, y) Ext(xdom), and (u, v) Ext(xsp)
we must prove that u CExt(y). First, for (xsp, y) Ext(xdom)
we get (xsp, y) Ext(xdom) or y = xprop by the axiomatic triple
(sp, dom, prop). If y = xprop and (u, v) Ext(xsp), we have
several cases: if (u, v){(xs, xo)|(s, sp, o) Ax}, by the construction of I we have u Prop = CExt(xprop) = CExt(y);
if (u, v){(x, x)|x  Prop}, we get u Prop = CExt(xprop) =
CExt(y);
i, we get
we have u Prop, because there is an axiomatic triple
( i, type, prop) for every i and by the construction of Prop;
and if (u, v) Ext(xprop), by the construction of Prop we
have u Prop. Now for (xprop, y) Ext(xdom), by the construction of CExt we have that CExt(y) = CExt(y)  Res and
so, since u Res, we obtain u CExt(y).
Case x = xsc: If (xsc, y) Ext(xdom), and (u, v) Ext(xsc)
we must prove that u CExt(y). First, for (xsc, y) Ext(xdom)
the
by
we have
y = xclass
axiomatic
(u, v) Ext(xsc), we
if
cases:
and
have
(u, v){(xs, xo)|(s, sc, o) Ax},
construction
by
u Class = CExt(xclass) = CExt(y);
I we
of
u Class = CExt(xclass) =
(u, v){(x, x)|x  Class},
if
u Class =
CExt(y);
(u, v) Ext(xclass), by
CExt(xclass) = CExt(y);
the construction of Class we have u Class. Now if
(xclass, y) Ext(xdom), by the construction of CExt we have
that CExt(y) = CExt(y)  Res and as u Res, we obtain
u CExt(y).

have
(u, v){(x, xres)|x  Class},

(xsc, y) Ext(xdom)
triple

(u, v) = (x i, xmember)

If
several
the

(sc, dom, class).

or

y = xclass

if

for some

if

and if

Then, in all cases I satisfies this condition for G.
(c) Let (x, y) Ext(xrange) and (u, v) Ext(x), we must prove
that v CExt(y). The same observations for the previous
case hold here, so we must concentrate in cases in which
(u, v) Ext(xe) with e df.
Case x = xtype: the same proof for xtype in the previous
condition works here considering v instead of u and changing xdom with xrange.
x = xdom:
Case
and
(u, v) Ext(xdom) we must prove that v CExt(y). First,
for (xdom, y) Ext(xrange) we get (xdom, y) Ext(xrange) or
y = xclass by the axiomatic triple (dom, range, class).
If y = xclass and (u, v) Ext(xdom), we have two cases:
(u, v){(xs, xo)|(s, range, o) Ax}, by the construc-
if
tion of I we have v Class = CExt(xclass) = CExt(y); if
(u, v) Ext(xrange), by the construction of Class we have

(xdom, y) Ext(xrange),

If

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

If

by

the

If

x = xrange:

(xrange, y) Ext(xrange),

v Class. Now if (xdom, y) Ext(xrange), by the construction
of CExt we have that CExt(y) = CExt(y)  Res and as
v Res, we obtain v CExt(y).
and
Case
(u, v) Ext(xrange) we must prove that v CExt(y). First,
for (xrange, y) Ext(xrange) we have (xrange, y) Ext(xrange)
or y = xclass by the axiomatic triple (range, range, class).
If y = xclass and (u, v) Ext(xrange), we have two cases:
(u, v){(xs, xo)|(s, range, o) Ax}, by the construc-
if
tion of I we have v Class = CExt(xclass) = CExt(y); if
(u, v) Ext(xrange), by the construction of Class we have
v Class. Now if (xrange, y) Ext(xrange), by the construction of CExt we have that CExt(y) = CExt(y)  Res and as
v Res, we obtain u CExt(y).
Case x = xsp: Almost the same proof for xsp in the previous condition works here considering v instead of u and
changing xdom with xrange, because, by the construction of
I, xmember  Prop (axiomatic triple (member, dom, res)).
Case x = xsc: Almost the same proof for xsc in the previous condition works here considering v instead of u and
changing xdom with xrange, because, by the construction of
I, xres  Class (axiomatic triple (type, dom, res)).
Then, in all cases I satisfies this condition for G.
x  Class, by the construction of I we have
(a) If
(x, xres) Ext(xsc).
(b) If x  CExt(xdatatype), we have x = xxmlLit and, by the construction of I and as (xmlLit, sc, literal) is an axiomatic
triple, we have (x, xliteral) Ext(xsc).
(c) If x  CExt(xcontMP), we get x = x i
for some i, and
by the construction of Ext(xsp) in I, we have that
(x, xmember) Ext(xsp).
Now, what we have shown is that I  G, and from G  H we
obtain that I  H. Note that if we restrict I to vocabulary df
we obtain the initial interpretation I that satisfies all conditions that have to do with df for H and then IdfH, and so
GdfH, completing the proof. 

(vii) RDFS additionals:

Proof of Theorem 8. First, in the definition of df models for RDF
graphs (Definition 4), the only condition that involves the graph
being modeled is condition (i) (Simple). The other conditions involve
the interpretation itself. It follows that, for an interpretationI that is
a df model for a graph G, testing if it is also a df model for a graph
H, we only have to test if I satisfies condition (i) for H, because
I already satisfies all other conditions (it is already a df model
for G).

We split the proof of Theorem 8 in two parts. We first prove
the following lemma stating the soundness of the set of rules for
df. 

Lemma 31.
Let G and H be graphs that do not mention RDFS
vocabulary outside df. Assume H  G, or H  G, or there is an instan-
R of a rule (2)(7) such that R  G and H = G  R. Then
tiation R
GdfH.
Proof. Let I = (Res, Prop, Class, Ext, CExt, Int) be an interpretation
such that IdfG, i.e. I satisfies all the conditions in Definition 4.
We know that I satisfies condition (i) for G. Let A : B  Res be a
function such that Int(p) Prop and (IntA(s), IntA(o)) Ext(Int(p)) for
every triple (s, p, o) G, We split the proof in cases for every set of
rules from (1) to (7).

(1) Simple:

(a) We must show that GdfH when H  G. Let  be a
map such that (H)  G. Consider the function A : B  Res

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

A((x))
Int((x))

if (x) B
if (x) / B

defined as
(x) =

Note that: (1) if x  B and (x) B we get IntA((x)) =
A((x)) = A(x) = IntA (x), (2) if x  B but (x) / B we get
IntA((x)) = Int((x)) = A(x) = IntA (x), and (3) if x / B,
we obtain (x) = x and IntA((x)) = Int(x) = IntA (x). Thus
IntA((x)) = IntA (x) for all x  UB. Let (s, p, o) H. Hence
((s), (p), (o)) = ((s), p, (o)) G. By IdfG we have
that Int(p) Prop and (IntA((s)), IntA((o))) Ext(Int(p)),
and finally (IntA (s), IntA (o)) Ext(Int(p)), obtaining I satisfies condition (i) of Definition 4 for H (with function A) and
also satisfies all other conditions of Definition 4. So IdfH.

(b) If H  G, we obtain H  G and so GdfH.
(a) Let (a, sp, b), (b, sp, c) G. It follows that (IntA(a), IntA(b))
 Ext(Int(sp)) and (IntA(b), IntA(c)) Ext(Int(sp)). As I satisfies condition (iv) we have that IntA(a), IntA(c) Prop. By
transitivity (IntA(a), IntA(c)) Ext(Int(sp)), I satisfies condition (i) for G  {(a, sp, c)} = H and so IdfH.
First note that we need
that a, b U for this rule to be applicable. We have
(IntA(x), IntA(y)) Ext(Int(a)),
that
and
(iv),
Int(b) Prop
so
(IntA(x), IntA(y)) Ext(Int(b)). Hence I satisfies condition (i)
for G  {(x, b, y)} = H and thus IdfH.

Int(a) Prop
(Int(a), Int(b)) Ext(Int(sp)).

and
Ext(Int(a))  Ext(Int(b))

(a, sp, b), (x, a, y) G.

condition
and

(b) Let

and

By

(2) Subproperty:

(7) Subclass reflexivity:

(b) Let

(Int(a), Int(a)) Ext(Int(sp)), and so I satisfies condition (i)
for G  {(a, sp, a)} = H. Thus IdfH.
(a, sp, b) G. By condition (iv) we have that
Int(a), Int(b) Prop and the proof
follows the same
argument as for rule (6a).
(c) The triples (p, sp, p) with p df are satisfied by any interpretation (see Proposition 11), and so IdfG  {(p, sp, p)}
for every p df.
(d) Let (a, p, x) G with p{dom, range}. By the new conditions
of df models, we have that Int(a) Prop and the proof follows the same argument as for rule (6a).

(a) Let

(a, sc, b) G. By condition (v) we have

that
Int(a), Int(b) Class and so, by the reflexivity of Ext(Int(sc))
over Class, we obtain that
(IntA(a), IntA(a)), (IntA(b), IntA(b)) Ext(Int(sc))
ThusI satisfies condition (i) for G  {(a, sc, a), (b, sc, b)} = H
and so IdfH.
(b) Assume p{dom, range, type}. Let (x, p, a) G. By the new
condition of df models, we have that Int(a) Class and the
proof follows the same argument as for rule (7a).
Finally because we choose an arbitrary model I we have that

GdfH. 

To state the completeness of the set of rules, we must introduce
the following notion of df closure of a graph. Define the graph
df  cl(G) as the closure of G under the application of rules (2)(7).
Note that df  cl(G) is an RDF graph over terms(G)  df, that is a
superset of G, and that is obtained after a finite number of application of rules.

the

df,

define

outside

interpretation

Given a graph G that do not mention RDFS
IG =

Lemma 32.
vocabulary
(Res, Prop, Class, Ext, CExt, Lit, Int) such that:
- Res = terms(G)  df.
- Prop = {p voc(G)|(s, p, o) df  cl(G)}  df 
{p terms(G)|(p, sp, x), (y, sp, p), (p, dom, z), or (p, range, v) G}.
- Class = {c  terms(G)|(x, type, c) G} 
{c  terms(G)|(c, sc, x), (y, sc, c), (z, dom, c), or (v, range, c) G}.
- Ext : Prop  2ResRes the extension function such that:
 if p U  Prop then Ext(p) = {(s, o)|(s, p, o) df  cl(G)}
 if p B  Prop then Ext(p) = {(s, o)|(p, sp, p), (s, p, o) df 
cl(G)}.
- CExt : Class  2Res
CExt(c) =
{x  terms(G)|(x, type, c) df  cl(G)}.
- Lit = terms(G)  L.
- Int the identity function over terms(G)  df.

function

such

that

Then for every RDF graph G, we have that IGdfG.

Proof. We must show that IG satisfies all the conditions of Definition
4 for G.

(i) Simple:

(a) First note that by construction of df  cl(G), Res =
terms(df  cl(G)) = terms(G)  df. Take the function A :
B  terms(G)  df such that its restriction to the set of
blanks nodes of G results in the identity function. Now let
(s, p, o) G, then p U and Int(p) = p Prop by construction of Prop because G  df  cl(G). We also have that
(IntA(s), IntA(o)) = (s, o) Ext(Int(p)) = Ext(p) by the definition of Ext because G  df  cl(G). Finally we have that IG
satisfies condition (i) for G.

(ii) Subproperty:

(a) Let (a, b), (b, c) Ext(Int(sp)) = Ext(sp). By construction of
IG (because sp / B) we have that (a, sp, b), (b, sp, c) df 

(3) Subclass:

(b) Let

(a, sc, b), (x, type, a) G. Hence

(a) The same proof for rule (2a) works changing sp by sc and
Prop by Class.
(IntA(x), IntA(a))
Ext(Int(type)), and (IntA(a), IntA(b)) Ext(Int(sc)). By condition (vi) we have IntA(a) Class and IntA(x) CExt(IntA(a)).
By condition (v), we get IntA(b) Class and CExt(Int(a)) 
CExt(Int(b)), so IntA(x) CExt(IntA(b)). By condition (vi) we
get (IntA(x), IntA(b)) Ext(Int(type)). We have that I satisfies
condition (i) for G  {(x, type, b)} = H and so IdfH.

(a) Let (a, dom, b), (x, a, y) G. First note that we need that
a U for this rule to be applicable. Now, we have that
(1) (Int(a), IntA(b)) Ext(Int(dom)), and (2) Int(a) Prop and
(IntA(x), IntA(y)) Ext(Int(a)). From condition (vi) we obtain
IntA(x) CExt(IntA(b)), and by condition (vi) again we have
that (IntA(x), IntA(b)) Ext(Int(type)). Hence I satisfies condition (i) for G  {(x, type, b)} = H and so IdfH.

(b) The same proof for rule (4a) works changing dom by range

(4) Typing:

and x by y.

(5) Implicit typing:

(a) Let

(1)

(IntA(a), IntA(b)) Ext(Int(dom)),

(a, dom, b), (c, sp, a), (x, c, y) G. First note that we
need that c  U for this rule to be applicable. Now,
we have that
(2)
(Int(c), IntA(a)) Ext(Int(sp)), and (3)
Int(c) Prop and
(IntA(x), IntA(y)) Ext(Int(c)). From (2) and condition (iv) we
have Int(c), IntA(a) Prop and Ext(Int(c))  Ext(IntA(a)), and
so from (3) we obtain that (IntA(x), IntA(y)) Ext(IntA(a)).
(1), and condition (vi) we
From this
and IntA(x) CExt(IntA(b)).
obtain that
Finally applying condition (vi) again we have that
(IntA(x), IntA(b)) Ext(Int(type)), and so I satisfies condition
(i) for G  {(x, type, b)} = H and then IdfH.

last
IntA(b) Class

result,

(b) The same proof for rule (5a) works changing dom by range

and x by y.

(6) Subproperty reflexivity:

(a) Let (x, a, y) G. First note that we need that a U for
this rule to be applicable. Thus Int(a) Prop, and by
the reflexivity of Ext(Int(sp)) over Prop, we obtain that

(c) Suppose

- if a U, by the construction ofIG, (x, a, y) df  cl(G) and
as df  cl(G) is closed under application of rule (4a), we
have that (x, type, b) df  cl(G), and by construction of
CExt(b) we get x  CExt(b).
- if a B, as we have (x, y) Ext(a), by construction of IG
there exists a such that (a, sp, a), (x, a, y) df  cl(G),
and as df  cl(G) is closed under application of rule (5a),
we have that (x, type, b) df  cl(G), and by construction of CExt(b), we get x  CExt(b).
We have shown that in any case x  CExt(b).

(a, b) Ext(Int(range)) = Ext(range)

and
(x, y) Ext(a), we must show that y CExt(b). First, by
construction of IG, (a, dom, b) df  cl(G), we have two
cases:
- if a U we have (x, a, y) df  cl(G) and as df  cl(G)
is closed under application of rule (4b), we have that
(y, type, b) df  cl(G), and by construction of CExt(b)
we get y CExt(b).
- if a B, as we have (x, y) Ext(a), by construction of IG
there exists a such that (a, sp, a), (x, a, y) df  cl(G),
and as df  cl(G) is closed under application of rule (5b)
we have that (y, type, b) df  cl(G), and by construction of CExt(b) we get y CExt(b).
We have shown that in any case y CExt(b).

that

cl(G). thus a, b, c  Prop. As df  cl(G) is closed under
application of rule (2a), we have that (a, sp, c) df 
cl(G) and so (a, c) Ext(sp) = Ext(Int(sp)). We conclude
that Ext(Int(sp)) is a transitive relation. We must show
that Ext(Int(sp)) is also reflexive over Prop. Let a Prop.
By the definition of Prop we have three cases: (1)
(x, a, y) df  cl(G); (2) a df; (3) (a, sp, b), (b, sp, a),
(a, dom, x), or (a, range, x) df  cl(G). Because df  cl(G)
is closed under application of rules (6) we obtain that
in any case (a, sp, a) df  cl(G) and so (a, a) Ext(sp) =
Ext(Int(sp)) and hence Ext(Int(sp))
is reflexive over
Prop.
(b) Let (a, b) Ext(Int(sp)) = Ext(sp), then by construction ofIG
we have that (a, sp, b) df  cl(G), and we also have that
a, b Prop. We must show that Ext(a)  Ext(b). If Ext(a) = 
the condition holds. Assuming that (x, y) Ext(a), we have
two cases:
- If a U, by definition (x, a, y) df  cl(G). Now,
if
b U because df  cl(G) is closed under application of
rule (2b) we have that (x, b, y) df  cl(G) and then
(x, y) Ext(b). If b B, as (a, sp, b), (x, a, y) df  cl(G) by
the construction of IG we have that (x, y) Ext(b).
- If a B, by the construction of IG there exists a such that
(a, sp, a), (x, a, y) df  cl(G). As df  cl(G) is closed
under application of rule (2a), we have (a, sp, b) df 
If b U, as (a, sp, b), (x, a, y) df  cl(G) and
cl(G).
df  cl(G) is closed under application of rule (2b), we
have that (x, b, y) df  cl(G) and then (x, y) Ext(b). If
b B, as (a, sp, b), (x, a, y) df  cl(G) by the construction of IG, we have that (x, y) Ext(b).
We have shown that in any case (x, y) Ext(b) and so
Ext(a)  Ext(b).

(iii) Subclass:

(a) Let (a, b), (b, c) Ext(Int(sc)) = Ext(sc). By the construction
of IG we have that (a, sc, b), (b, sc, c) df  cl(G). Hence
a, b, c  Class. As df  cl(G) is closed under application
of rule (3a), we have that (a, sc, c) df  cl(G) and so
(a, c) Ext(sc) = Ext(Int(sc)). We conclude that Ext(Int(sc))
is a transitive relation. We must show that Ext(Int(sc)) is
also reflexive over Class. Let a Class, by the definition of
Class we have two cases: (1) (x, type, a) df  cl(G); (2)
(a, sc, b), (b, sc, a), (x, dom, a), or (x, range, a) df  cl(G).
Because df  cl(G) is closed under application of rules (7)
we obtain that in any case (a, sc, a) df  cl(G), hence
(a, a) Ext(sc) = Ext(Int(sc)) and so Ext(Int(sc)) is reflexive
over Class.
(b) Let (a, b) Ext(Int(sc)) = Ext(sc). By the construction of IG
we have that (a, sc, b) df  cl(G), and we also have that
a, b Class. We must show that CExt(a)  CExt(b). First, note
that the property holds for CExt(a) = . If x  CExt(a), by
definition we get (x, type, a) df  cl(G). Now, since df 
cl(G) is closed under application of rule (3b) we have that
(x, type, b) df  cl(G) and by the construction of IG we
have x  CExt(b).

(iv) Typing I:

(a) Let (x, a) Ext(Int(type)) = Ext(type), by the construction
of IG we have that a Class and (x, type, a) df  cl(G),
and so by construction of CExt(a) we have that x  CExt(a).
Suppose now that a Class and x  CExt(a). By construction of CExt(a) we have that (x, type, a) df  cl(G) and
so (x, a) Ext(type) = Ext(Int(type)). We have shown that
(x, a) Ext(Int(type)) iff x  CExt(a).
and
(x, y) Ext(a), we must show that x  CExt(b). First, by
the construction of IG, (a, dom, b) df  cl(G), we have
two cases:

(a, b) Ext(Int(dom)) = Ext(dom)

(b) Suppose

that

(v) Typing II: all this condition hold by definition of Prop and Class.
We have shown that IG, satisfies all the conditions of
Definition 4 for G. Therefore IGdfG. 

Lemma 33. Let G, H be RDF graphs that do not mention RDFS vocabulary outside df. If GdfH then there is a map H  df  cl(G).
Proof. Consider the interpretation,
IG = (Res, Prop, Ext, Int, Class, CExt)
thus IGdfG and as GdfH,
as defined in Lemma 32.
we have IGdfH. We know that IG
condition
for H, hence there exists a function A : B 
(i)
terms(G)  df
Int(p) Prop
and (IntA(s), IntA(o)) Ext(Int(p)). Now because p U (p is the
predicate in a triple in H), we know that Int(p) = IntA(p) =
Ext(Int(p)) = Ext(p) = {(s, o)|(s, p, o) df  cl(G)}.
p,
(IntA(s), IntA(o)) Ext(Int(p)), we
Finally,
that
(IntA(s), IntA(p), IntA(o)) df  cl(G)
for each (s, p, o) H Thus
IntA : H  df  cl(G) is a map such that IntA(H)  df  cl(G), that
is, a map H  df  cl(G). 

for each (s, p, o) H,

such that

satisfies

(Simple)

since

have

and

From the above lemma it follows that since GdfH, then H
can be obtained from df  cl(G) by using rule (1), and thus, since
Gdfdf  cl(G), it holds that GdfH. Therefore Theorem 8 follows
directly from Lemmas 31 and 33.

It follows directly from Lemma 33 and the

Proof of Theorem 10.
fact that Gdfdf  cl(G) for every G. 
Proof of Proposition 17. As in the proof of Theorem 8, we split
the proof in two parts. We first prove the following lemma stating
the soundness of rules (1b), (2)(4) for nrx

df. 

Let G and H be mrdf-graphs. If H  G, or if there is an
R of a rule (2)(4) such that R  G and H = G  R, then

Lemma 34.
instantiation R
Gnrx
df

H.

Proof. Follows from the proof of Lemma 31 in Appendix B as the
simple observation that reflexivity of the interpretations of sp and
sc are necessary only for proving that rules (6) and (7) are sound,
which are not part of the rules in the statement of the lemma. 
Similarly as we define df  cl(G), define nrx  df  cl(G) but
using only rules from (2)(4). We now have the following Lemma.

S. Mu noz et al. / Web Semantics: Science, Services and Agents on the World Wide Web 7 (2009) 220234

G.

For a mrdf-graph G, consider the interpretation IG as
Lemma 35.
in Lemma 32 but using nrx  df  cl(G) instead of df  cl(G). Then
IGnrx
df
Proof.
Follows from the simple observation that, in the proof of
Lemma 32, only rules (b) and (7) are needed to show the reflexivity
of the interpretations of sp and of sc. 

Proposition 17 follows from Lemmas 34 and 35.
