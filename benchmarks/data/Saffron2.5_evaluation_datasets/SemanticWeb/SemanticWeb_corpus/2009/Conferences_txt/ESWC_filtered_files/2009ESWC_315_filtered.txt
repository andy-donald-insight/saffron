Representing, Querying and Transforming Social

Networks with RDF/SPARQL

Mauro San Martin1,2 and Claudio Gutierrez2

1 Departamento de Matematicas, Universidad de La Serena

2 Computer Science Department, Universidad de Chile

{msanmart,cgutierr}@dcc.uchile.cl

Abstract. As social networks are becoming ubiquitous on the Web,
the Semantic Web goals indicate that it is critical to have a standard
model allowing exchange, interoperability, transformation, and querying
of social network data.

In this paper we show that RDF/SPARQL meet this desiderata. Building on developments of social network analysis, graph databases and Semantic Web, we present a social networks data model based on RDF,
and a query and transformation language based on SPARQL meeting
the above requirements. We study its expressive power and complexity
showing that it behaves well, and present an illustrative prototype.

1 Introduction

The recording of social interactions over the Web, and the tagging and annotation of data are creating networks of data with the structure of what is classically known as social networks [1,2,3]. Examples include Wikipedia, del.icio.us,
YouTube, DBLP, Flickr, Facebook, and the blogosphere. In all these services, each
time a user sends a message, chooses a tag or annotates a resource, one or multiple
relations are recorded. Researchers, developers, and users have realized that there
is useful information in these underlying networks [1], consequently some sort of
structural analysis is performed over them [3,4]. Many of the techniques used come
from the established area of social networks analysis (SNA), which Breiger [5] defines as the disciplined inquiry into the patterning of relations among social actors
of different kinds and at different levels (see also [6,7,8]).

Nevertheless, the processing and managing of this huge amount of data is
still an unsolved problem for the common user and developer. The problem is
not only the format (today ranging from spreadsheets to files in proprietary for-
mats), but also the means of querying, mixing and transforming such data with
standard models. Furthermore, most data formats currently in use do not have
explicit semantics nor support for provenance [1]. Advances have been done in
the field of Social Network Analysis, e.g. Pajek [9], Ucinet [10], and network
and sna packages of R [11,12]. These tools are focused in implementing techniques and algorithms for data previously prepared and formated to fit their

 This research was supported by Fondecyt 1070348, RDF Databases.

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 293307, 2009.
c Springer-Verlag Berlin Heidelberg 2009

M. San Martin and C. Gutierrez

Fig. 1. Data Management Needs for Social Networks. Each social application is a con-
sumer/producer of social networks, producing and/or collecting network data, and consuming data produced by other applications. The need for a standard representation
and query language follows.

proprietary formats [10]. Another group of developments in these lines, proposals using RDF for covering different applications of the social Web, currently
are focused only on the representational aspects of the problem (FOAF, XFN,
RELATIONSHIP, etc.) This amounts to the definition of custom vocabularies
and ontologies tailored for specific applications. The question remains how they
may work together, and at what level of abstraction [13].

Thus a basic desiderata for managing social network data should include at
least the following: 1) to be able to represent and store any kind of social network,
including provenance information; 2) to be able to share and mix social networks
(or parts of them) among users and applications; 3) to have a set of standard
operations over these social networks, to query, transform and update them (a
query language). We show in this paper that it is possible to fulfill such desiderata
based on the experiences of social networks and database communities, and that
of RDF/SPARQL.

The strategy to reach this goal is as follows. In the first place, we use the
fact that all social networks of data have a stable common underlying model
given by a characteristic practice of the SNA community, which is based in well
developed methodologies and techniques (see Freeman [14] and [8, ch.1]). From
here, and based on the Semantic Web practice, we abstract a model of data
management for social networks based in consumers and producers of networks.
It provides data management services to each consumer/producer: query, transform and update their own data; and between pair of consumers/producers:
porting and sharing of data (see Fig. 1). For instance, SNA can be viewed as a
consumer of social networks to be analyzed; annotators and users are producing and updating social networks; developers of applications are consuming and
producing networks, etc. Finally, using the findings of database modeling [15], a
graph structure emerges as the natural choice for such data model. In particu-
lar, RDF offers a standard model and SPARQL can be used as an off-the-shelf
language. SPARQL fulfills almost all query and transformation requirements for
social networks except for aggregation. Note also that relational model by itself
does not intrinsically support a graph data structure, and consequently it is not
straightforward to define relevant social network queries in SQL.
?

?

?
In this paper we show that RDF/SPARQL are excellent data
Contributions.
model/query language candidates for data processing social networks on the Web
and cope with their basic requirements. First, we gather and study SN requirements of representation and storage, manipulation (querying, transforming and
updating), and sharing/porting. Based on them, we define a conceptual graph
data model for social networks. Second, we show that RDF/SPARQL fulfill these
requirements and model, by mapping the conceptual data model data structure
to RDF, and the conceptual query language to a composition of SPARQL and
basic SQL queries (essentially used to provide aggregation which is currently
missing in SPARQL). Third, we study the expressive power and the complexity of the query language showing that the model scales in the database sense.
Finally, we provide a formal and practical bridge between Semantic Web framework and Social networks applications (which are key consumers/producers of
social network data). We sketch a prototype implementation of a DBMS for
social networks over RDF/SPARQL.
Related Work. There are three main areas related to our research:
1. Networks and Social Network Analysis. The closest development to our work
are SNA software tools. One of the most popular and complete is Pajek [9],
which offers an extensive set of analysis algorithms and visualization options.
It has basic elements of data manipulation, for instance to filter out nodes and
edges. The R statistical software also has packages to deal with network data
[11]. In all these SNA tools, data storage is based on text files in various formats,
which limits the data managing options available to the user, and in the long
term sensibly rises the costs of network data curation. Low level storage restrictions are exposed to the user complicating unnecessarily the data manipulation.
None of these tools provide the required data management services. There are
many custom made applications that solve specific problems, for instance Klink
et al. [16] use explicit social network data to improve DBLP navigation.
2. Network Data Models and Databases. Although there is an increasing awareness of the need of data management support in several fields which deal with
networks[17,18,19], to the best of our knowledge there are no works discussing
systematically data models for social networks. Jensen and Neville [20] propose
Proximity, a data mining tool that supports statistical models over network data,
which in turn uses MonetDB, a database management system (DBMS) able to
store network data at low level, but lacking the appropriate level of abstraction
for SNA use. Proximity uses a graph query language called QGraph [21]. Tsvetovat et al. [22] propose a specific application based on the relational data model,
and also propose DyNetML [23] , an XML based format, to store rich social
network data. No query or transformation issues are addressed in these works.
In this area representational aspects present in our work
3. Semantic Web.
have been addressed for specific applications with several standards, like for instance FOAF. How to integrate these standards and at which abstraction level
remains an open question [13]. Mika [1, ch. 5] discusses several possible representation models, tools and standards from database, SNA, and Semantic Web

M. San Martin and C. Gutierrez

communities, and reaches the same conclusion as us: current tools and data formats do not solve data representation and aggregation requirements. However,
he proposes a solution based on ontologies and automated reasoning, whereas
we propose a data model and the corresponding querying and transformation
language. We show that having explicit metadata and a query language suffices
for most data management requirements. Ereteo et al. [4] present a framework to
provide semantic aware social network analysis. Jung and Euzenat [2] propose
a three layer model to represent and extract information from social networks.
In terms of data management as previously defined, none of these models cope
with the requirements. Producer/consumer has been addressed in other works,
for instance, Polleres et al. propose XSPARQL [24] as a standard query language
for lifting and lowering between XML and RDF data sources. Finally there are
many works that extract, model, manipulate, and analyze social networks in the
Semantic Web for specific applications, see for example: Aleman-Meza et al. [25],
Kinsella et al. [26], and Mika [27].

The paper is organized as follows: In Section 2 the data structure of the data
model is presented; Section 3 studies the corresponding query language, and
discusses implementation issues; Section 4 presents conclusions.

2 Representing Social Networks over RDF

Social Networks data management requirements have come to the foreground
with the advent of the Social Web [13], particularly due to the needs of interoperability of SN data (weak or inexistent in applications like Flickr, Delicious,
etc.) Some applications like DBLP and FOAF have data available in several
formats (particularly XML and RDF). Nevertheless, they have different vocabularies and model design, making interoperability non automatic. The core of
these applications are their social network characteristic. Thus a natural source
to look for requirements is the work that the SN community has done.
Example 1 (The KHTM Network). To illustrate the ideas we will use the Krack-
hardts High-tech Managers (KHTM) network, a well known data set in the field
of SNA. We use the version provided by Wasserman and Faust [7] of the data
gathered by Krackhardts in 1987 in a small manufacturing organization on the
west coast of the U.S. The KHTM data set is a one mode network, with three
kinds of relations (friendship, advice, reports_to) collected among the twenty
one managers of the organization. For each manager are also recorded four at-
tributes: age, tenure, level in corporate hierarchy, and the department in which
the manager works (see Fig. 2). A total of 624 ties were recorded.

Requirements for a Social Networks Data Model. An appropriate departure point for SNA model requirements is Freemans maximal structure experiment [8, ch.1]: one or more kinds of relations; one or more types or levels of
social units; structures that change through time; sets of social units that grow
or shrink; attributes of social units, and attributes that change. Two elements
should be added to this model: attributes of relations, and n-ary relations, i.e.
relations linking more than two actors [28].
?

?

?
Actors and Relationships

Attributes

M1

namer

Manager

M1

seeker

Manager

M1

subordinate

Manager

F1

Friendship

A1
Advice

R1

Reports_to

named

M2

Manager

advisor

M2

Manager

boss

M2

Manager

age

dept.

level

tenure

M1

Fig. 2. Schema of the KHTM data set. Left hand side shows the three types of binary
relations (rectangular nodes) between pairs of distinct managers (round nodes) in the
original network data set. Note that relations are also represented as nodes, and arcs
labels represent the role that an actor perform in the relation. On the right hand side,
attributes are represented as part of the graph.

In addition, the SN data model must fulfill the requirements that arise from current practices in the SN community (see [7], [6] and [29]), for instance, it must provide data management support to extract input data sets for popular SNA tools,
e.g. Pajek [9], as a recurrent stage in the workflow depicted in the Fig. 1.

The implemented model must also address the problems that arise in the
long term scientific data curation, e.g. provenance, reuse, and archiving [19].
Portability is another crucial requirement, particularly for the Semantic Web,
from user profiles to more recently reuse of whole networks (e.g., in eScience).
This is achieved via a standard underlying data structure and data manipulation
language. Time is another important parameter to be included as desired. It can
be added as metadata to actors or relations, although there are subtleties that
have to be considered [30].

The requirements discussed above demand representations more elaborate
than the simple graphs (or matrices) of the SNA classical modeling. This challenge is not exclusive of the domain of SN and has been explored extensively in
other contexts [31,21,15]. From this background and trends in information exchange indicating that all the information should be in the same data structure
and that it should support the addition of arbitrary metadata (e.g. provenance),
basic requirements for such a model emerge. First, attributes values should be
part of the graph, and second, relations should be represented as nodes instead
of edges or arcs, allowing the seamlessly representation of n-ary relations and
attributes on relations over the same data structure (see Fig. 2 and 3). Formally
a social network can be represented by a special type of directed labeled graph.

Definition 1 (Social Network Data model). A social network is a triple
S = (V, E, L) where (V, E) is a directed graph and L a set of labels (and labeling
functions), specified as follows:
 The set of nodes V = A  R  C is a disjoint union of the set A of actors,

R of relations and C of attributes.

M. San Martin and C. Gutierrez

Manager

age

boss

seeker

Reports_to

Advice

seeker

boss

advisor

Advice

advisor

Reports_to

subordinate

subordinate

age

advisor

seeker

Manager

Advice

Manager

advisor

age

seeker

Advice

Fig. 3. Subnetwork of KHTM data set: A view of a subnetwork of all relations among
members of Department 3. Actors are round nodes (black outline), and relations are
square nodes. Attributes are small round nodes (grey outline). Labels indicate participation roles and meanings (attributes). To keep the diagram clean, only age attribute
is shown and family belonging is depicted as a second label with grey background in
each node (instead of the corresponding node and arc). Note that this is already an
RDF graph. Arrows go from subject to objects and are labeled with predicates.
?

?

?
i Ai, where Ai defines a family of actors. Relation set R =

Each of this set is partitioned in families (or types) as follows: Actor set
i Ri,
A =
where Ri defines a family of relations. Attribute set C is usually as well
partitioned into different data types.
 The set of edges E = EAR  EAC  ERC is a disjoint union of the following
types of edges:
 EAR is a multiset of elements of A  R, the participation edges (i.e. we
allow multiple edges between an actor and a relation.)
 EAC  A  C and ERC  R  C are the set of meaning edges.

 The set L of labels is the union of sets of labels for the different types of
edges: LP (participation) for labels on EAR, and LM (meanings) for EAC
and ERC, with their corresponding labeling functions.

This model can be naturally viewed as a set of triples in the style of RDF. The
triples corresponding to the view in Fig. 3 are shown in the Fig. 4. The formal
specification is as follows.

Definition 2 (Social Network Triple Representation). Consider the vocabulary  = A  R  C  {isA, isR}  LP  LM. Then define the following:
1. List of Nodes and Family Belonging triple set:

NA  A  {isA}  {A1, . . . , AmA},
NR  R  {isR}  {R1, . . . , RmR}.

2. Participation triple set: P  A  LP  R.
3. Meanings (attributes) triple set: M  (A  R)  LM  C.
?

?

?
(10, age, 37)
(11, age, 46)
(18, age, 33)

(10, isA, Manager)
(11, isA, Manager)
(18, isA, Manager)

(102, isR, Advice)
(103, isR, Advice)
(104, isR, Advice)
(106, isR, Advice)

(101, isR, Reports to)
(105, isR, Reports to)

(10, seeker, 103)
(10, seeker, 104)
(10, advisor, 102)

(10, subordinate, 101)

(11, advisor, 104)
(11, advisor, 106)

(11, subordinate, 105)

(18, advisor, 103)
(18, seeker, 102)
(18, seeker, 106)
(18, boss, 101)
(18, boss, 105)

Fig. 4. KHTM - Department 3 subnetwork (Fig. 3) as triples. The separation in four
groups (tables) of triples represents the social structure of the RDF graph. Tables
P and M represent the node-edge-node triples shown in Fig. 3. Tables NA and NR
represent the typing of each node (actors and relations respectively).

From the definitions above it is not difficult to show:
Lemma 1. A social network can be represented by four sets of
(NA, NR, P, M).
In what follows, we will associate social networks with their triple representation.
Regarding the RDF implementation, the vocabulary, that is, actors and relations
and the sets LP and LM , are implemented as URIs, and attributes values as
literals. The predicates isA and isR can be either implemented as predicates or
replaced by the RDF keyword rdf:type. Then the set of triples is precisely the
union of the sets NA, NR, P and M.

triples

3 Transforming Social Networks with SPARQL
Query and Transformation Requirements. Querying and transforming social networks turns out to be a non-trivial task due to the intrinsic complexity
of the networked data [15]. The good news is that the requirements are uniform,
as shown by use cases collected from bibliographic sources [7,6,9], the papers
from last three years of the Social Networks Journal and current software tools
for SNA, particularly Pajek and its reference book Exploratory Social Network
Analysis with Pajek [9] (see Table 1).

The range of queries that SN practitioners need are diverse, and can be roughly
analyzed along two axis. First, queries that return values or measures of the
whole input network or of some subnetwork (e.g. centrality, diameter, etc.) They
fall into structural analysis and can be more properly treated by analysis-tools
for final users. The second axis regards queries and transformations which output networks and constitutes properly the data management part of processing
SN. (cf. Table 1). We focused on this latter group, which is the one currently
missing from the applications and corresponds properly to data management
needs discussed above.

M. San Martin and C. Gutierrez

Table 1. Archetypical social network data management operations from the book
Exploratory Social Network Analysis with Pajek [9], which also recurrently appear in
literature (see [7,6,9])

Chapter Title Use Case
Looking
Social
ture

for
Struc-

(remove

Directed to undirected Binary Relations (arcs to edges
in Pajek)
Remove relations
edges in Pajek)
Extract a subnetwork based
on attributes
Group actors based on attributes (shrink network in
Pajek)

Query Description (see Definition 3)
In PI both participation roles have different
participation roles, in PO both roles are the
same.
Some relation nodes matched by PI are not
replicated in PO
PI include triples from M with fixed literals,
or with filters on the corresponding variables.
PI matches a subnetwork, including at least
one actor attribute, PO produces only one actor per value of the attribute. Aggregate functions may be required to count the size of the
groups or summarize other attributes.
A variant of the previous, here some portion
of the subnetwork matched is not grouped

Attributes and
Relations

Cohesive Sub-
groups
Sentiments
and
ship
Affiliations

Friend-

Center and Pe-
riphery

Brokers
Bridges

and

Diffusion

Prestige
Ranking

PI is the desired clique for a fixed n, PO = PI

Two-mode network to onemode network

Selective grouping of actors
based on attributes (contex-
tual view in Pajek)
Extract the subnetwork induced by cliques of size n
Extract subnetwork by time Time is represented by an attribute. M triples
in PI have fixed literals or filters on the corresponding variables.
PI represents a transitive relation, PO eliminates the actor in the middle. It may need a
function to generate ids for the new relation.
PI selects all the required binary relations. PO
groups and typically counts them by pair of
actors.
PI selects all relations and neighbors, and the
relations involving those. PO = PI. Requires
OPTIONAL or UNION. Each radius requires
different set of patterns.
Requires that the groups are represented as attributes first. PI selects the network except the
relations between actors of different groups.
PI selects the neighbors given certain condi-
tion. PO requires aggregate functions.
Requires functions over literals in PO.

Group multiple binary relations (remove multiple lines
in Pajek)
Extract egonetwork of an ac-
tor

Remove relations between
groups
(remove lines between clusters in Pajek)
Selective counting of neigh-
bors
Operations between attribs.
(divide vectors in Pajek)
Change
based on attributes
Discretize an attribute
Find triads by type

relation direction

PI selects the required network, PO swaps labels of participation roles.
Requires functions over literals in PO.
PI is a three actor pattern, a triad. In each
triad some relations are allowed and some are
forbidden. Requires negation.
PI selects all relations except those with arity
equals to 1.

Genealogies
and Citations

Loop removal
?

?

?
Query Language Definition. The ideal design is to have a set of simple
primitives from where to compose by simple operations all needed queries. In
our case, pattern matching fulfills this need. Informally speaking, the language
consists of three parts: an input pattern PI, which identifies (matches) all pieces
of information needed and extracts the corresponding values; a transformation
T of values, which updates and aggregates the values obtained in the previous
step; and finally, an output pattern PO, which defines the form of the data that
will constitute the social network to be outputted.
Definition 3. Let X =   X be the extension of the alphabet  with the set
of variables X (disjoint of ).
 A basic pattern P is a social network over the vocabulary X.
 A composite pattern is defined by the following grammar:

P ::= P AND P | P OR P | P MINUS P | P (E),

where E is a Boolean expression of atoms of the form (x op y) or (x op c),
where x, y  X, c is a constant, and op is in the set {=,,}.

A query is a triple of the form ((PI , XI), T, (PO, XO)), where
1. (PI , XI) is a pattern over XI (the input pattern). (Note that we write

explicitly in the query the set of variables XI occurring in the pattern.)

2. T is a basic SQL query from a table with attributes XI which outputs a table
with attributes XO. A basic SQL means here single table, no nesting; the
selected attributes Aj could be functions of the attributes of XI.

3. (PO, XO) is a basic pattern over XO (the output pattern).

Query Language Semantics. We will give an operational semantics described
by the following query evaluation procedure using SPARQL and SQL. PI and PO
will be SPARQL patterns, and PO a basic graph pattern that may also contains
filters. The procedure is composed by three stages:
Stage 1: Extraction. This corresponds to a SPARQL query that captures
the values of the input pattern. The output is a solution sequence (a table).

SELECT X_I FROM G

WHERE P_I

The result of this query is a table R(XI) containing all the bindings of the
variables in XI.
Stage 2: Transformation. The table obtained in the previous step is transformed by an SQL query (representing T ) to output another table, whose attributes correspond to the values fi(XI) for certain functions fj.

SELECT f1(X_I) AS att1,...,fk(X_I) AS attk
FROM R(X_I) WHERE C_1
GROUP BY <...> HAVING C_2

where C_1 and C_2 are conditions. From this table the final graph will be constructed in the next step. Note that this transformation is currently not expressible in SPARQL (even if there are no aggregate functions).

M. San Martin and C. Gutierrez

INPUT PATTERN

A1

seeker

subordinate

R1

Advice

R2

Reports_to

advisor
boss

A2

OUTPUT PATTERN

A3

seeker

R3

advisor

A4

Advice

T: A3  A1, A4  A2, R3  R1

Query
Result

seeker

Manager

Advice

advisor

Manager

Fig. 5. Query and Result: Find all managers that seek advice with their bosses. The
query is composed by the input and output patterns, and the transformation T . The
result network when applied to network in Fig. 3 is depicted below.

Stage 3: Construction. Here the CONSTRUCT query form of SPARQL is used.
The idea is to create an RDF graph which is the union of the instantiations
of the output pattern PO for each tuple of values of the table produced in the
previous step.

Note that we cannot input a table to a SPARQL query. To handle this
problem, we need to construct an auxiliary RDF graph H. Assuming XO =
{X 1

}, the specification of the final query is:

O, . . . , X k

CONSTRUCT P_O FROM H
WHERE {(att1, ?Tuple, ?X_O^1). ... (attk, ?Tuple, ?X_O^k)}

where the graph H is defined as follows: For each tuple tj = (v1j, . . . , vkj) in the
output table in the previous step, the following set of triples Tj will be produced,
Tj =

{(atti, tuplej, vij)}. Then H =

j Tj.

k
i=1
?

?

?
Example 2 (Simple Case). Figure 5 graphically represents the query: extract
the subnetwork of relations seeker-advisor, where the actor A, seeking advise
with B, have also the relation subordinate-boss with B. In this query XI =
{A1, A2, R1, R2}, PI = {(A1, seeker, R1), (A2, advisor, R1), (A1, subordinate,
R2), (A2, boss, R2)}, T = {A3  A1, A4  A2, R3  R1}, XO ={A3, R3, A4},
and PO = {(A3, seeker, R3), (A4, advisor, R3)}. In this and the following examples we assume, for the sake of clarity, that the types of the actors and relations
are implicit in the pattern (grey labels in Fig. 5), i.e., all the triples of the form
(a, isA, X) and (r, isR, Y ) for a and r in the pattern are implicit in the pattern and are carried as needed to the output following the transformation. The
SPARQL query is:

Construct {?A1 KHTM:seeker ?R1. ?A2 KHTM:advisor ?R1}
From G
Where

{?A1 KHTM:seeker ?R1. ?A2 KHTM:advisor ?R1.
?A1 KHTM:subordinate ?R2. ?A2 KHTM:boss ?R2 }

If G is the network data set in Fig. 3, the result is the following set of triples
(namespace KHTM omitted): {(10, seeker, 103), (18, advisor, 103)} (See Fig. 5).
?

?

?
However, in the general case T is not a simple renaming mapping, the variables
XO are functions of XI, and T may include aggregate functions. The following
example covers this.
Example 3 (Filtering and Counting). Extract the subnetwork of relations
seeker-advisor for those advisors which have at least 2 advisees and add the
number of advisees as an attribute to the advisors. G is again the data in
Fig. 3.
Stage 1. First SPARQL query (SELECT)
SELECT ?A1, ?R1, ?A2
FROM G
WHERE {?A1 KHTM:seeker ?R1.
?A2 KHTM:advisor ?R1}

Result: table R

A1
?

?

?
R1
?

?

?
A2
?

?

?
Stage 2. SQL query
SELECT A1 as att1, R1 as att2,

A2 as att3, COUNT(*) as att4

FROM R
GROUP BY A2 HAVING COUNT(*) >= 2

att1
?

?

?
Result: table S

att2
?

?

?
att3
?

?

?
att4
?

?

?
Stage 3. Second SPARQL query (CONSTRUCT)
CONSTRUCT {?A1 KHTM:seeker ?R1. ?A2 KHTM:advisor ?R1.

?A2 KHTM:numAdv ?N}

FROM H
WHERE {att1 ?T ?A1. att2 ?T ?R1. att3 ?T ?A2. att4 ?T ?N }
Where H is the set of triples { (att1, t1, 10), (att2, t1, 104), (att3, t1, 11), (att4,
t1, 2), (att1, t2, 18), (att2, t2, 106), (att3, t2, 11), (att4, t2, 2) }, which is simply
a coding of Table S as a set of triples.
Example 4 (Queries expressible in the language). Table 1 describes typical data
management queries in SNA. All of them are expressible in the language (indi-
cations given in the table). Note that some of them require negation of patterns,
which can be expressed in SPARQL, despite not being explicit in its syntax [32].

3.1 Expressive Power and Complexity of the Language
Is the language rich enough for performing the usual queries in the area? Does
the language have an efficient evaluation? These are two key questions we must
answer to prove that the language works in general. We will see that while the
latter can be answered in the positive, the answer for the first is a yes/no. Using
the result in Angles [32] which shows that SPARQL has the same expressive
power as Relational Algebra, it is not difficult to prove the following result:
Theorem 1 (Expressive Power). The expressive power of the query language
defined above in this section (see Definition 3) contains Relational Algebra and
is contained in Relational Algebra plus aggregation.

M. San Martin and C. Gutierrez

Pajek (.paj)

Import/Export

SN Editor

Query Editor

Social Network (Data Model Implementation)

Social Network Repository

SESAME

Fig. 6. Prototype Architecture. The figure shows the packages that form the SNDB.

This result shows that the language is expressive enough to make all sensible
transformations of networks (see Table 1).

On the negative aspects, it shows that global queries cannot be expressed in
it. These are queries found in SNA practice ([7,6,9]) corresponding to analytical
measures of the network as a whole (i.e. they are attributes of the entire network):
density, balance theory (based in paths and cycles), betweenness centrality (de-
pends on paths), exposure/ threshold, critical mass (diffusion), etc. Technically
they are not expressible in relational algebra, see e.g. [33]. There is work both
on trying to incorporate some features for retrieving paths in SPARQL [34,35],
and also on retrieving paths in the spirit of SNA [4].

Complexity. The cost in time of the evaluation of a query of the language, based
on the translation to relational algebra we provided, is as follows:

1. First part: relational algebra. Essentially has the same cost as evaluating
relational algebra. Note that the size of the output table RI(XI) is, in the
worst case, O(|SN|XI ), where XI is the number of variables of the input
pattern of the query.

2. Second part, the SQL transformation T . The complexity of evaluating this
transformation is linear in the number of rows of RI(XI) once it is ordered
by the GROUP-BY condition.

3. Third part: construction of the output network. The cost is asymptotically
linear in the size of (PO, XO) times the size of the output of the table in (2).

3.2 A Prototype  Implementation Remarks

To illustrate the model, we built a proof of concept prototype of DBMS for the
social network data model: SNDB. This prototype has two versions, one maps the
conceptual model to the relational model, using as data back-end an RDBMS; and
the other maps the model to RDF/SPARQL. The latter is described in this section.
The central module is Social Network (see Fig. 6) which implements the model
and the query language, and handles main memory data structures needed to
interact with upper layers. SocialNetwork Repository module works as an interface between SocialNetwork and the data services provider, in this case Sesame.
Here model structures are translated to RDF, and model operations and queries
are translated to Sesame update methods and SPARQL queries. Network Import
?

?

?
Fig. 7. Protoype Query Editor. Query editor snapshot showing query in Example 2.

and Export is composed by several modules, each one translating to and from
an external format. Currently there are two modules implemented: XML, which
handles the serialization and reading of social networks and queries to and from
XML files (under a predefined schema); and Pajek, which imports and exports
networks from and to Pajek files. The Social Networks Editor is a basic graphic
social network editor which provides an interface to insert, delete and update
individual social network components. Finally, the Query Editor (see Fig. 7) implements a graphical query editor, where it is also possible to execute the query
over a given social network, and inspect the result.

The SNDB prototype was implemented using Java 1.5. It uses JUNG 1.7.6
network library to implement the GUI (analysis features are not used). Sesame
2.2.2 is used to implement the triple store. The choice of using SPARQL as the
query language limits the queries that can be executed in the triple store to
those that do not require aggregated functions. Figure 7 shows the query editor
with the query in the Example 2.

The prototype has shown the advantages of having an abstract SNA model
intuitive language, and a friendly query editor and processor. The problems we
faced deal with the current lack of aggregation in SPARQL, and scalability,
both at the visualization and response time level for big RDF graphs. There is
plenty of optimizations to be done. For example, preliminary trials over a data
set containing part of current DBLP (aprox. 100.000 records) in an average PC
shows great flexibility for querying, however response times for complex queries
are far from being satisfactory..

Overall, the prototype pinpoint several advantages of the approach: to interactively build networks and queries, to import and export data sets, and to
execute queries and inspect results. Certainly it is mandatory to address the
issues of optimization and aggregation in SPARQL.

4 Conclusions

We presented a data model and a query language for social networks data over
RDF/SPARQL. This model provides a common data structure which support
data interoperation, and the query language support the separation between
data management tasks and application logic.

M. San Martin and C. Gutierrez

This query language formalizes requirements; hence, it may work as an implementation guide. These requirements where collected from SNA community
practice, including published research, SNA software tools, and well known
bibliographic sources, and are coincident with the main ideas suggested by
other authors in the context of Semantic Web [1]. Finally we show that the
RDF/SPARQL technology presents excellent features (except for the missing
one of aggregation in SPARQL) for processing social networks.

Given that the implementation of the model may rest over the RDF/SPARQL
stack, it can be almost seamlessly integrated with existing and new vocabularies,
ontologies and their applications, leveraging the efforts to handle the enormous
amount of heterogeneous social network data becoming available. Having a transformation and query language that has the flexibility and expressive power of
relational algebra, clearly the main efforts should be directed to optimizations
for big data sets.
