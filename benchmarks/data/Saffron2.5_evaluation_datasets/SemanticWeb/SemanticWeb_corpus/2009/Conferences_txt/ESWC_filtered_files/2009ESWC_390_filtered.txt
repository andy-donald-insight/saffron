Decidability of SHI with Transitive Closure of

Roles

Chan Le Duc

INRIA Grenoble Rhone-Alpes - LIG

Chan.Leduc@inrialpes.fr

Abstract. This paper investigates a Description Logic, namely SHI+,
which extends SHI by adding transitive closure of roles. The resulting
logic SHI+ allows transitive closure of roles to occur not only in concept
inclusion axioms but also in role inclusion axioms. We show that SHI +
is decidable by devising a terminating, sound and complete algorithm
for deciding satisfiability of concepts in SHI + with respect to a set of
concept and role inclusion axioms.

Keywords: OWL, Description Logics, Tableaux, Decidability.

1 Introduction

The ontology language OWL-DL [10] is widely used for formalizing resources on
Semantic Web. This language is mainly based on the description logic SHOIN
which is known to be decidable [12]. Although SHOIN is expressive and provides transitive roles to model transitivity of relations, we can find several applications in which the transitive closure of roles, that is more expressive than
transitive roles, is necessary. An example in [11] describes two categories of
devices as follows: (1) Devices have as their direct part a battery: Device 
hasPart.Battery, (2) Devices have at some level of decomposition a battery:
Device  hasPart+.Battery. However, if we now define hasPart a transitive role,
the concept DevicehasPart.Battery does not represent the devices as described
above since it does not allow one to distinguish these two categories of devices.
We now consider a more specific example in which we need the transitive

closure of roles to occur in role inclusion axioms.

Example 1. Let us consider a LOTOS description [9] (producer/consumer):

P[put, get] := put; ( (get; stop) ||| P[put, get] )

Signs ; and ||| represent sequential and parallel operators respectively. An
execution trace of P can be generated by executing an action put, and then the
parallel block (get; stop) ||| P[put, get]. This block can be started by executing
either action get or a recursive call P. The special action stop will be performed
if no action of the description can be executed, which is never the case in this
example because, according to the semantics of parallel operator, following a
get a recursive call P can be invoked. This means that execution traces of P

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 368383, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
are infinite and their prefixes verify the following property: if n1 and n2 are
the number of put and get in a given prefix, n1  n2 always holds i.e. the
intersection of the execution traces with the language put
.get is the irregular
language {putn1 .getn2 | n1  n2}.
If one uses a DL to describe these execution traces then roles put, get and
disjoint concepts put, put
, get would be needed. A role next subsuming put, get
would be used to impose general properties on both of them. In addition, an

artificial concept gstart and role
gstart subsumed by next can be added for the sake
of axiom construction.

An expected model of concept gstart w.r.t. a set of DL axioms is depicted in

Fig. 1.

Fig. 1. A model of gstart to represent an execution trace

The essential point is that each execution of the parallel block leads to two
executions corresponding to blocks (get; stop) and P[put, get]. Since only one
action can be executed at one moment, the non-consumed execution must be
memorized and will be performed in the future. This characteristic of execution
traces is expressed by a role inclusion axiom   next+: relation  memorizes
the non-consumed execution which is initialized by the execution of the parallel
block. A sequence of next, i.e. next+, starts from this point of execution and
joints to the memorized non-consumed execution at some moment in the future.
For instance, the following axioms:
(1)   next+; gstart  
(2) put  (put.put  .get)  (put.get  .put);
(3) put  (put.put  .get)  (put.get  .put);
(4) ...

gstart.put; next, next

: functional

, , 

describe a trace as a model of gstart. Since individuals are distinct it holds that
the number of instances put from put to put equals to the number of instances
 from put to get. Note that if we replace the term .get in (2) by next+.get
then this property no longer holds.
Such examples motivate the study of the logic SHI+ which is obtained by
allowing the transitive closure of roles to occur in both concept and role inclusion axioms in SHI. To the best of our knowledge, the decidability of SHI+

C. Le Duc

is unknown. In the literature, many decidability results in Description Logics
(DL) can be obtained from their counterparts in modal logics (see [4], [5], [6]).
However, these counterparts do not take into account expressive role inclusion
axioms. In particular, [5] has shown decidability of a very expressive DL, so-called
CAT S, including SHIQ with the transitive closure of roles but not allowing it
to occur in role hierarchies.
In addition, tableaux-based algorithms for expressive DLs like SHIQ [8] and
SHOIQ [7] result in efficient implementations. This kind of algorithms relies
on two structures, so-called tableau and completion graph. Roughly speaking,
a tableau for a concept represents a model for the concept and it is possibly
infinite. A tableau translates satisfiability of all given concept and role inclusion
axioms into local satisfiability of semantic constraints imposed on each individual
of the tableau. This characteristic of tableaux will be called local satisfiability
property. In turn, a completion graph for a concept is a finite representation
from which a tableau can be built. To check satisfiability of a concept, tableauxbased algorithms try to build a completion graph whose finiteness is ensured by
a technique, so-called blocking technique. It provides a termination condition by
guaranteeing soundness and completeness. The underlying idea of the blocking
mechanism is to detect loops which are repeated pieces of a completion graph.
The algorithm in [2] for satisfiability in ALCreg (including the transitive closure
of roles and other role operators) introduced a method to deal with loops which
can hide unsatisfiable nodes.
The contribution of the present paper is to propose an algorithm for concept
satisfiability in SHI+. Reasoning in SHI+ is harder than in SHI because of
the two following reasons: (i) adding to a logic transitive closure brings this logic
beyond first order logic. This is so because [1] has shown that the transitive
closure of roles cannot be expressed in first-order predicate logic, (ii) the presence
of the transitive closure of roles in role inclusion axioms, such as   a+, leads
to the loss of the tree model property.

2 The Logic SHI +
In this section, we present the syntax and semantics of the logic SHI+. This
includes the definitions of inference problems and how they are interrelated. The
definitions reuse notation introduced in [8].

Definition 1. Let C and R be sets of concept and role names, respectively.
 The set of SHI+-roles is R  {R
 | R  R} with R = R  {P + | P  R}.
A role inclusion axiom is of the form R  S for two SHI+-roles R and S. A
role hierarchy R is a finite set of role inclusion axioms. A role R  R is called
transitive if R+  R  R.

 Function Inv returns the inverse of a role as follows:

Inv(R):=

 if R  R  {P + | P  R}

S if R = S

 where S  R  {P + | P  R}
?

?

?
 A relation  is defined as the transitive-reflexive closure of  on
R  {Inv(R)  Inv(S) | R  S  R}  {P  P + | P  R}. We denote S  R iff
RS and S R.
 Function Trans is defined as follows:

if there is some S such that S  R and
{S, Inv(S)}  {{R | R+  R  R}  {P + | P  R}} = 

 true

Trans(R):=

f alse , otherwise

I},

I\C

I,

, (x, z  (P n1)I

I
?

?

?
(P n)

n>0

I, (C  D)I = C

I  D
I | y  

I | y  

I and
,z, y  P

I)}

 The set of SHI+-concepts is inductively defined as the smallest set containing
all C in C, , C  D, C  D, C, R.C and R.C where C and D are SHI+-
concepts and R is an SHI+-role. We denote  for .
 An interpretation I = (

I (domain) and
a function I which maps each role R to a subset of 
I such that, for
R, P  R,

,I) consists of a non empty set 
I  

I, (C  D)I = C
, (x, y  R
, (x, y  R

= {x, y  (
I)2 | y, x  R
I, (P n)I = (P n1)I  P
with (P 1)I = P
I)2 | z  
?

?

?
P +I
=
I = {x, y  (
(P n1)I  P
 The function I maps also each concept to a subset of 
I such that
I  D
I, (C)I = 
I = 
(R.C)I = {x  
I)},
I  y  C
I)}
I  y  C
(R.C)I = {x  
I for each R  S 
I  S
 An interpretation I satisfies a role hierarchy R iff R
R. Such an interpretation is called a model of R, denoted by I |= R.
 C  D is called a general concept inclusion (GCI) where C, D are SHI+-
concepts (possibly complex), and a finite set of GCIs is called a terminology
I and I satisfies a
T . An interpretation I satisfies a GCI C  D if C
terminology T if I satisfies each GCI in T . Such an interpretation is called a
model of T , denoted by I |= T .
 A concept C is called satisfiable w.r.t. a role hierarchy R and a terminology
T iff there is some interpretation I such that I |= R, I |= T and C
I = . Such
an interpretation is called a model of C w.r.t. R and T . A pair (T ,R) is called
an SHI+ ontology and said to be consistent if there is a model of (T ,R).
 A concept D subsumes a concept C w.r.t. R and T , denoted by C  D, if
I  D

Since negation is allowed in the logic SHI+, unsatisfiability and subsumption
w.r.t. (T ,R) can be reduced each other: C  D iff C  D is unsatisfiable.
In addition, we can reduce ontology consistency to concept satisfiability w.r.t.
an ontology: (T ,R) is consistent if A  A is satisfiable w.r.t. (T ,R) for some
concept name A.
For the ease of construction, we assume all concepts to be in negation normal
form (NNF) i.e. negation occurs only in front of concept names. Any SHI+-
concept can be transformed to an equivalent one in NNF by using DeMorgans

I holds in each model I of (T ,R).

I  D

C. Le Duc

laws and some equivalences as presented in [8]. For a concept C, we denote the
nnf of C by nnf(C) and the nnf of C by .C.
Let D be an SHI+-concept in NNF w.r.t. an ontology (T ,R). We define
sub(D) to be the smallest set that contains all sub-concepts of D including D.
For an ontology (T ,R), we define the set of all sub-concepts sub(T ,R) as follows:
?

?

?
sub(T , R) :=
sub(E, R) := sub(E)  { .C | C  sub(E)} 

sub(nnf(C  D),R)

CDT
{S.C | (R.C  sub(E), S R)  ( .R.C  sub(E), S R)
and S occurs in T or R}

For the sake of simplicity, for each concept D w.r.t. (T ,R) we denote sub(T ,R, D)
for sub(T ,R)sub(D), and R(T ,R,D) for the set of roles occurring in T ,R, D with
their inverse and transitive closure. If it is clear from the context we use R instead
of R(T ,R,D).
3 Deciding Satisfiability in SHI +
In this section, we establish decidability of SHI+ by devising an algorithm for
checking satisfiability of SHI+ concepts w.r.t. a terminology and role hierarchy.
In our approach, we first extend the tableau definition presented in [8] by
adding a global property for expressing the transitive closure of roles. This causes
the tableaux to lose the local satisfiability property. Next, we define a substructure of graphs, called neighborhood, which consists of a node together with
its neighbors. Such a neighborhood captures all semantic constraints imposed
by the logic constructors of SHI. A tree-like structure obtained by tiling
neighborhoods together allows us to represent in some way a model for a concept
in SHI+. In fact, we embed in this tree-like structure another structure, called
cyclic path, to express the transitive closure of roles. Since all expansion rules for
SHI can be translated into building neighborhoods, the algorithm presented in
this paper focuses on defining cyclic paths over such a tree-like structure. By this
way, the non-determinism resulting from satisfying the transitive closure of roles
can be translated into the search in a space of all possible tree-like structures
obtained from tiling neighborhoods.
3.1 SHI+-Tableau
Tableau structure is introduced to describe a model of a concept w.r.t. a terminology and role hierarchy. Properties in the tableau definition express semantic
constraints resulting directly from the logic constructors in SHI+.
Considering the tableau definition for SHIQ presented in [8], the following
definition adopts an additional property, namely P9, that imposes a global constraint on a set of individuals of a tableau.
Definition 2. Let (T ,R) be an SHI+ ontology. A tableau T for a concept D
w.r.t (T ,R) is defined to be a triplet (S,L,E) such that S is a set of individuals,
?

?

?
L: S  2sub(T ,R,D) and E: R  2SS, and there is some individual s  S such
that D  L(s). For all s  S, C, C1, C2  sub(T ,R, D), and R, S, P +  R, T
satisfies the following properties:
P1 if C1  C2  T and s  S then nnf(C1  C2)  L(s)
P2 if C  L(s), then C / L(s)
P3 if C1  C2  L(s), then C1  L(s) and C2  L(s)
P4 if C1  C2  L(s), then C1  L(s) or C2  L(s)
P5 if S.C  L(s) and s, t  E(S), then C  L(t)
P6 if S.C  L(s), there is t  S such that s, t  E(S) and C  L(t)
P7 if S.C  L(s) and s, t  E(R) for RS and Trans(R), then R.C  L(t)
P8 s, t  E(R) iff t, s  E(Inv(R))
P9 if s, t  E(P +) then either s, t  E(P ), or
P10 if s, t  E(R), RS then s, t  E(S)
Note that when only transitive roles are added without transitive closure, the local satisfiability property of tableaux can be preserved by the property P7 which
was already introduced in [8]. The property P9 in Def. 2 expresses explicitly a
cycle for each transitive closure occurring in the label of an edge s, t. A tableau
for a concept represents exactly a model for the concept, that is affirmed by the
following lemma.
Lemma 1. An SHI+-concept D is satisfiable w.r.t. (T ,R) iff D has a tableau.
Lemma 1 is obvious since the properties of tableaux represent directly semantic
constraints imposed by the logic constructors in SHI+.

there exist t1, , tn  S such that s, t1, ,tn, t  E(P )

3.2 Neighborhood

Tableau-based algorithms, as presented in [8], use expansion rules to build a
completion tree. Applying expansion rules makes all nodes of a completion tree
satisfy semantic constraints imposed by concept definitions in the label associated with each node. This means that local satisfiability in such completion trees
is sufficient to ensure global satisfiability. The notion of neighborhood introduced
in Def. 3 expresses exactly the expansion rules for SHI, consequently, guarantees local satisfiability. Therefore, a completion tree built by a tableau-based
algorithm can be considered as set of neighborhoods which are tiled together. In
other terms, building a completion tree by applying expansion rules is equivalent
to the search of a tiling of neighborhoods.
Definition 3 (Neighborhood). Let D be an SHI+ concept w.r.t. (T ,R). Let
R be the set of roles occurring in D and T ,R together with their inverse and
transitive closure. A neighborhood, denoted (vB, NB, l), for D w.r.t. (T ,R) is
formed from a core node vB, a set of neighbor nodes NB, edges vB, v with
v  NB and a labelling function l such that l(u)  2sub(T ,R,D) with u  {vB}NB
and l(vB, v)  2R with v  NB.
?

?

?
1. A node v is valid w.r.t. D and (T ,R) iff

(a) tbox-rule: If C  D  T then nnf(C  D)  l(v), and
(b) clash-rule: {A,A}  l(v) with any concept name A, and
(c) -rule: If C1  C2  l(v) then {C1, C2}  l(v), and
(d) -rule: If C1  C2  l(v) then {C1, C2}  l(v) = .

2. A neighborhood B = (vB, NB, l) is valid iff all nodes {vB}  NB are valid
and the following conditions are satisfied:
(a) -rule: If R.C  l(vB) then there is a neighbor v  NB such that
C  lB(v) and R  l(vB, v);
(b) rbox-rule: For each v  NB, if R  l(vB, v) and RS then S 
l(vB, v);
(c) -rule: For each v  NB, if R  l(vB, v) (resp. R  Inv(l(vB, v)))
and R.C  l(vB) (resp. R.C  l(v)) then C  l(v) (resp. C  l(vB));
(d) +-rule: For each v  NB, if R  l(vB, v) (resp. R  Inv(lB(vB, v))),
S R, Trans(S), R.D  l(vB) (resp. Inv(R).D  l(vB)) then S.D 
lB(v) (resp. Inv(S).D  l(vB));
) and
l(vB, v) = l(vB, v

  NB such that l(v) = l(v

(e) There are at most two nodes v, v

).

We denote B(T ,R,D) for a set of all valid neighborhoods for D w.r.t. (T ,R).
The condition 2e in Def. 3 ensures that any neighborhood has a finite number
of neighbors. Moreover, we could replace at most two nodes by at most one
node since SHI+ does not allow for qualifying number restrictions but the
former can simplify some constructions later on (Def. 5 and Rem. 1).

A valid neighborhood as presented in Def. 3 captures all necessary information
related to an individual of a tableau. When a global property like P9 is added
to tableaux, it imposes just a relationship on a set of individuals of the tableau
but each individual is still characterized by a neighborhood which is built from
its neighbors and itself. For this reason, neighborhoods can be still used to tile
a completion tree for SHI+ without taking care of expansion rules for SHI.
In other terms, the neighbourhood notion expresses the local satisfiability in a
sufficient way for being used in a global context.
Lemma 2. Let D be an SHI+ concept w.r.t. (T ,R). Let (vB, NB, l), (vB , NB, l)
be two valid neighborhoods with l(vB) = l(vB). If there is v  NB such that there
)
does not exist any v
then the neighborhood (vB , NB{u}, l) is valid where l(u) = l(v) and l(vB, u) =
l(vB, v).
This lemma holds due to the facts that (i) a valid neighbor in a valid neighbor-
 if the labels
hood B is also a valid neighbor in another valid neighborhood B
 are identical, (ii) since SHI+ does not allow for
of two core nodes of B and B
qualifying number restrictions hence Def. 3 has no restriction on the number of
neighbors of a core node.

) = l(v) and l(vB, v) = l(vB , v

  NB satisfying l(v
?

?

?
3.3 Completion Tree with Cyclic Paths

As discussed in [3], the blocking technique fails in treating DLs with the transitive
closure of roles. It works correctly only if satisfiability of a node in completion
tree can be decided from its neighbors and itself i.e. local satisfiability must be
sufficient for such completion graphs. However, the presence of the transitive
closure of roles makes satisfiability of a node depend on further nodes which can
be arbitrarily far from it.
More precisely, satisfying the transitive closure P + in an edge x, y (i.e.
P +  L(x, y)) is related to a set of nodes on a path rather than a node with its
neighbors i.e. it imposes a semantic constraint on a set of nodes x, x1, , xn, y
such that they are connected together by P -edges. In general, satisfying the
transitive closure is quite non-deterministic since the semantic constraint can
lead to apply to an arbitrary number of nodes. In addition, the presence of the
transitive closure of roles in a role hierarchy makes this difficulty worse. For
instance, if P  Q+, Q  S+ are axioms in a role hierarchy then each Q-edge
generated for satisfying Q+ may lead to generate an arbitrary number of S-edges
for satisfying S+.

The most common way for dealing with a new logic constructor is to add a
new expansion rule for satisfying the semantic constraint imposed by the new
constructor. Such an expansion rule for the transitive closure of roles must:

1. find or create a set of P -edges forming a path for each occurrence of P + in

the label of edges,

2. deal with non-deterministic behaviours of the expansion rule resulting from

the semantics of the transitive closure of roles,

3. enable to control the expansion of completion trees by a new blocking technique which has to take into account the fact that satisfying the transitive
closure of a role may add an arbitrary number of new transitive closures to
be satisfied.

To avoid these difficulties, our approach does not aim to directly extend the
construction of completion trees by using a new expansion rule, but to translate
this construction into selecting a good normalization tree, namely completion
tree with cyclic paths, from a finite set of completion trees without taking into
account the semantic constraint imposed by the transitive closure of roles. The
process of selecting a good normalization tree is guided by finding in this tree
a cyclic path for each occurrence of the transitive closure of a role.

Summing up, a completion tree with cyclic paths will be built in two stages.
The first one consists of tiling valid neighborhoods together such that two neighborhoods are tiled if they have compatible neighbors. This stage yields a normalization tree as described in Def. 4. The second stage given in Def. 5 deals with
the transitive closure of roles by defining cyclic paths over normalization trees.
Definition 4 (Normalization tree). Let D be an SHI+ concept w.r.t. (T ,R).
Let B(T ,R,D) be the set of all valid neighborhoods for D w.r.t. (T ,R). A normalization tree T = (V, E, L) for D w.r.t. (T ,R) is built from B(T ,R,D) as follows:
?

?

?
 For each node x  V with its predecessor x
,

 A root node x0 of T is built from a valid neighborhood (v0, N0, l)  B(T ,R,D)
such that L(x0) = l(v0) with D  l(v0). Additionally, for each v  N0 a
successor x of x0 is added to V with L(x) = l(v) and L(x0, x) = l(v0, v),
 If there are ancestors y, y
 of x
 is the predecessor of y and
 such that y
), L(y
, y) = L(x
, x), then x is blocked by
?

?

?
) = L(x
L(y) = L(x), L(y
y. In this case, x is a leaf node;
 Otherwise, we find a neighborhood Bx = (vBx , NBx, l) from B(T ,R,D)
, x) for
such that l(vBx) = L(x), l(v) = L(x
some v  NBx, and build a successor y for each u  NBx \ {v} such that
L(y) = l(u) and L(x, y) = l(vBx , u).

), Inv( l(vBx, v) ) = L(x
?

?

?
We say a node x is a R-successor of x
a R-neighbor of x

 if x is a R-successor of x

 or x

  V if R  L(x
?

?

?
, x). A node x is called
 is a Inv(R)-successor of x.

Note that the construction of normalization trees uses the blocking technique
for termination condition. The following definition embeds cyclic paths into normalization trees for satisfying the semantic constraint imposed by the transitive
closure of roles.
Definition 5 (Completion tree with cyclic paths). Let D be an SHI+
concept w.r.t. (T ,R). Let T = (V, E, L) be a normalization tree for D w.r.t.
(T ,R).
 A path, denoted  = x0, , xk, , xn+1, is formed from nodes xi  V if

 xi is not blocked for all i  {0, , n + 1};
 xi+1 is a successor of xi or blocks a successor of xi for all k  i  n;
 xi1 is a successor of xi or blocks a successor of xi for all 1  i  k.
{0, , n} with j > i such that L
L(xj), L(xi+1) = L(xj+1);

 A path x0, , xn+1 is called non-duplicated if there do not exist i, j 
(xj , xj+1) and L(xi) =
 A path x0, , xk, , xn+1 is cyclic if L(x1, x0) = Inv( L(xn, xn+1) )

(xi, xi+1) = L

and L(x0) = L(xn), L(x1) = L(xn+1).

T = (V, E, L) is called a completion tree with cyclic paths if for each u, v  E
such that Q+  L(u, v) and Q / L(u, v) with Q  R{Inv(P ) | P  R} there
exists a cyclic non-duplicated path  = x0, , xk, , xn+1 which satisfies:
 u = xk, and xk1 = v if v is not blocked or xk1 = z if z blocks v;
 Inv(Q)  L
 Q  L
where L
if x is a successor of y, and L

(xi, xi+1) for all k  i  n.
(x, y) = L(x, y) if y is a successor of x, L

(x, y) = Inv( L(y, x) )
(x, y) = L(x, z) if y blocks a successor z of x.

(xki, xki1) for all 1  i  k  1;

In this case,  is called a cyclic Q-path and denoted by Qu,v.

By its name, we mean that each cyclic path x0, , xn+1 becomes a cycle if
x1 and x0 are respectively pasted to xn+1 and xn.
?

?

?
Remark 1. From Def. 5, each node xi of a cyclic non-duplicated path Qu,v =
x0, , xk, , xn+1 with xk = u can be reached through a path which only
goes down either from u to a blocked node, or from a blocking to blocked node.
This ensures that for any occurrence of u, v with Q+  L(u, v) in a possibly
infinite path crossing blocked, blocking nodes, we can define a cyclic Q-path in a
tableau for satisfying this occurrence. This property guarantees the soundness of
Alg. 1. For the completeness, when building a cyclic Q-path as down-going one
from a Q-path in a tableau, we need to add a successor which is identical to the
predecessor of a node. This is allowed by Def. 3 which accepts a neighborhood
with two identical neighbors.
A completion tree with cyclic paths encapsulates the following notions: neighbor-
hood, blocking condition and cyclic path. The first one captures the semantics
of all logic constructors except for the transitive closure of roles. The second one
which was introduced in [8] is crucial for obtaining a finite representation of a
possibly infinite model. The third one represents the transitive closure of roles.
Lemma 3 (Soundness and completeness). Let D be an SHI+-concept. Let
T and R be a terminology and role hierarchy.
1. If there exists a completion tree with cyclic paths for D w.r.t. (T ,R) then D
2. If D has a tableau w.r.t. (T ,R) then there exists a completion tree with cyclic

has a tableau.

paths.

To prove the soundness (1.), we define a quasi-tableau for D from a set of Paths
in a given completion tree with cyclic paths. This technique is already used in
[8]. Next, in order to introduce cycles to the quasi-tableau from cyclic paths of
the completion tree, we use a function which performs a contraction of the set of
paths by unifying the ending points of cyclic paths Paths. Since qualifying number restrictions are not allowed in SHI+, such a contraction function preserves
all properties of the quasi-tableau. For the completeness (2.), we define directly
neighborhoods from individuals of a given tableau and build a normalization
tree from them. Next, cyclic paths are embedded into the normalization tree by
devising non-duplicated paths from finite cycles for the transitive closure of roles
in the tableau. A more complete proof of Lem. 3 can be found in Appendix.
From the construction of completion trees with cyclic paths according to Def. 5
and Lem. 3 we can devise immediately Alg. 1 for concept satisfiability in SHI+.
Lemma 4 (Termination). Algorithm 1 terminates.

Termination of Alg. 1 is a consequence of the following facts: (i) the number of
neighborhoods is bounded, (ii) the size of normalization trees which are tiled
from neighbourhoods is bounded.

Alg. 1 is highly complex since it is not a goal-directed decision procedure at
all. Such an exhaustive behaviour is very different from that of tableaux-based
algorithms in which the construction of a completion tree is inherited from step
to step. In Alg. 1, when a normalization tree cannot satisfy an occurrence of the

C. Le Duc

: Concept D, terminology T and role hierarchy R

Input
Output: IsSatisfiable(D)
foreach Normalization tree T = (V, E, L) do

if For each x, y  E with Q+  L(x, y), Q / L(x, y), T has a Qx,y

then

return true;

return false;
?

?

?
Algorithm 1. Deciding concept satisfiability in SHI+

transitive closure of a role (after satisfying others), a new normalization tree will
be picked and embedding cyclic paths into this one has to restart. The following
theorem is a direct consequence of Lem. 3 and 4.
Theorem 1. Algorithm 1 decides the satisfiability of SHI+-concepts w.r.t. a
terminology and role hierarchy.

4 Conclusion
We have proved decidability of the concept satisfiability in SHI+ by providing a
sound and complete algorithm. The establishment of the algorithm relies on the
neighborhood notion which is an abstraction of the local satisfiability property
of tableaux. This abstraction enables us to encapsulate all semantic constraints
imposed by the logic constructors in SHI, and thus to deal with the transitive
closure of roles independently from the other constructors.

This work is a first step toward an empirical algorithm whose behaviour is
more goal-directed i.e. the construction of a completion tree would be refined
along with satisfying the transitive closure of roles, e.g., the non-impacted parts
of the tree when rebuilding it would be reused.

Acknowledgements. This work has been partially supported by the European
integrated project NeOn (IST-2005-027595). Thanks to Sophie Coudert and Ludovic Apvrille for the motivating example, to J erome Euzenat, Marie-Christine
Rousset and the anonymous reviewers for their comments.
