A Tableau Algorithm for Handling Inconsistency in

OWL

Xiaowang Zhang1,2, Guohui Xiao1, and Zuoquan Lin1

1 School of Mathematical Sciences, Peking University, Beijing, China
2 School of Mathematical Sciences, Anhui University, Hefei, China

{zxw,xgh,lzq}@is.pku.edu.cn

Abstract. In Semantic Web, the knowledge sources usually contain inconsistency because they are constantly changing and from different view points. As
is well known, as based on the description logic, OWL is lack of the ability of
tolerating inconsistent or incomplete data. Recently, the research in handling inconsistency in OWL becomes more and more important. In this paper, we present
a paraconsistent OWL called quasi-classical OWL to handle inconsistency with
holding important inference rules such as modus tollens, modus ponens, and
disjunctive syllogism. We propose a terminable, sound and complete tableau algorithm to implement paraconsistent reasoning in quasi-classical OWL. In comparison with other approaches to handle inconsistency in OWL, our approach
enhances the ability of reasoning by integrating paraconsistent reasoning with
important classical inference rules.

1 Introduction

In recent years, the problem of inconsistency handling in OWL is attracting a lot of
attention in logics and Semantic Web. Many reasons cause the occurrence of inconsistency such as modeling errors, migration from other formalisms, merging ontologies,
and ontology evolution [1]. In practical reasoning, it is common to have too much
information about some situation. In other words, it is common for there to be classically inconsistent information in practical reasoning ontologies [2]. According the fact
ex contradictione quodlibet in classical logic, if ontologies contain inconsistencies
then the classical entailment in logics is explosive. That is to say, any formula is a logical consequence of a contradiction. Therefore, conclusions drawn from an inconsistent
knowledge base may be completely meaningless [3]. This is particularly important if the
full power of logic-based approaches like the Web Ontology Language (short OWL) [4]
shall be employed, as classical logic breaks down in the presence of inconsistent knowl-
edge. Not surprisingly, the study of handling inconsistency in OWL becomes more and
more important.

There are serval approaches to handling inconsistency in OWL, which can be generally divided into two fundamentally different approaches. The first is based on the
assumption that inconsistencies indicate erroneous data which are to be repaired in order to obtain a consistent knowledge base, e.g. by selecting consistent subsets for the

 We acknowledge support by Major Program of National Natural Science Foundation of China

(NSFC) (No. 60496322).

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 399413, 2009.
c Springer-Verlag Berlin Heidelberg 2009

X. Zhang, G. Xiao, and Z. Lin

reasoning process [3,5,6]. Another approach, called paraconsistent approach, is not to
simply avoid the inconsistency but to apply a non-standard reasoning method to obtain meaningful answers [7,8,9,10,11]. In the paraconsistent approach, inconsistencies
are treated as a natural phenomenon in realistic data and are tolerated in reasoning.
Compared with the former, the latter acknowledges and distinguishes the different epistemic statuses between the assertion is true and the assertion is true with conflict.
So far, the main idea of paraconsistent approach of handling inconsistency in OWL is
borrowing Belnaps four-valued semantics [12] for OWL. The most prominent of them
are based on the use of additional truth values standing for underdef ined (i.e. neither
true nor false) and overdef ined (or contradictory, i.e, both true and false). Fourvalued semantics proves useful for measuring inconsistency of ontologies [13], which
can provide context information for facilitating inconsistency handling. To a certain
extent four-valued semantics handles inconsistency, however the capability of reasoning is weaker than classical OWL because four-valued OWL doesnt hold three basic
inference rules such as modus ponens, disjunctive syllogism, modus tollens or intuitive equivalences. In [8,9], a total negation is introduced to strengthen the capability of
paraconsistent reasoning in four-valued OWL by applying resolution principles. How-
ever, four-valued OWL with the total negation dont hold intuitive equivalences. These
shortcomings are inherent limitations of four-valued semantics in reasoning.

Naturally, we expect that there is a paraconsistent logic which has the same capability
of reasoning in classical logics to handle inconsistency in OWL. However, it is still an
open problem now. Motivation of this paper is to find a paraconsistent approach to OWL
with three basic inference rules and intuitive equivalences.
OWL is based on description logics and the description logic ALCNQ is considered
to be the most foundational one and comprises a large fragment of OWL. In this paper,
based on [14], we study a description logic ALCNQ version of paraconsistent logic,
called quasi-classical (or QC) ALCNQ, which is an extension of quasi-classical logic
[15,16] and a paraconsistent version of ALCNQ. We contribute to the inconsistency
handling for ALCNQ in terms of the QC semantics in the following aspects.
 A new semantics called QC semantics including two semantics QC weak seman-
tics and QC strong semantics is introduced to description logic ALCNQ in this
paper. QC weak semantics inherits the characters from four-valued semantics in order to reason paraconsistently, while QC strong semantics is introduced to strengthen
the capability of reasoning in ontologies. Compared to QC weak semantics, QC
strong semantics refines the disjunction of concepts in order to hold three basic inference rules. Moreover, concept subsumption redefined in QC strong semantics is
different from four-valued description logic in order to hold intuitive equivalences,
i.e., C  D iff C  D(a) for any individual a occurring in ontologies.
 A QC entailment (written by |=Q) between an ontology and an axiom is presented by applying QC semantics in this paper. |=Q is a nontrivial entailment,
i.e., {C(a),C(a)} |=Q  for any axiom . Compared with four-valued description logic, QC entailment holds three basic inference rules such as modus ponens:
{C(a), C  D} |=Q D(a), modus tollens: {D(a), C  D} |=Q C(a) and disjunctive syllogism: {C(a), C  D} |=Q D(a). So as a paraconsistent description
?

?

?
logic, QC description logic based on QC entailment has the approximate ability of
classical description logic in reasoning.

 A complement of concept is defined to QC semantics in order to reverse both the
information of being true and of being false. The complement of concept plays the
same role as negation in classical description logics.
 A tableau algorithm for QC ALCNQ called QC tableau algorithm based on the
complement of concept is proposed to implement paraconsistent reasoning in on-
tologies. QC transformation rules are developed from transformation rules in classical description logics by modifying them moderately. Furthermore, we prove that
QC tableau algorithm for QC ALCNQ is terminable, sound and complete. Finally,
we show that the complexity of QC tableau algorithm for QC ALCNQ is not
higher than the complexity of tableau algorithms for ALCNQ.
The paper is structured as follows. In Section 2, description logic ALCNQ as basic
knowledge is briefly reviewed. In Section 3, we introduce QC semantics including QC
weak semantics and QC strong semantics for description logic ALCNQ and define
the QC entailment relationship. In Section 4, a terminable, sound and complete QC
tableau algorithm with blocking technique to implement the querying. In Section 5,
some related works on comparing the QC description logic to four-valued description
logic are discussed. In Section 6, we conclude the main contributions in this paper and
discuss the future work. Due to paper space limitations, proofs are absent, and detailed
proofs are available in an Online Appendix.1

2 Preliminaries

In this section, we briefly review notation and terminology of the description logic
ALCNQ, but we basically assume that the reader is familiar with description logics.
For comprehensive background reading, please refer to [17].

We assume that we are given a set of atomic concepts (or concept names), denoted by
NC, a set of roles (or role names), denoted by NR and a set of individuals, denoted by
NI. With the symbols  and , we furthermore denote the top concept and the bottom
concept, respectively.
Complex concepts in ALCNQ can be formed from these inductively as follows.
 , , and each atomic concept are concepts;
 If C, D are concepts, then C  D, C  D, and C are concepts;
 If C is a concept and R is a role, then R.C, R.C,  nR.C and  nR.C with n
a non-negative integer are concepts.
Let C, D be concepts, a, b individuals and R a role. In description logic ALCNQ,
an ontology O is a pair T ,A, where T is called the T Box (or terminology) of the
ontology and A is called the ABox of the ontology. Assertions are of the form C(a) or
R(a, b). Inclusion axioms are of the form C  D which is called a general concept
inclusion (or GCI) axiom. Informally, an axiom C(a) means that the individual a is
an instance of concept C, and an axiom R(a, b) means that individual a is related with
individual b via the property R. The inclusion axiom C  D means that each individual
of C is an individual of D.
1 http://www.is.pku.edu.cn/ zxw/QCALCNQAppendix.pdf

X. Zhang, G. Xiao, and Z. Lin

Table 1. Syntax and semantics of concept constructors and axioms in ALCNQ

Constructor Name
atomic concept A
abstract role R
individuals I
inverse role
top concept

Semantics
I  
?

?

?
I  
I  

I  

o
)I  I  I

(R

Syntax
?

?

?
o

?

?

?


bottom concept

conjunction
disjunction
negation

C1  C2
C1  C2
C
R.C
R.C
number atleast restriction  nR
number atmost restriction  nR
qualifying atleast restriction  nR.C {x | ({y.(x, y)  RI} and y  C
qualifying atmost restriction  nR.C {x | ({y.(x, y)  RI} and y  C

I

1  C
?

?

?
1  C
?

?

?
I \ C I

I}
{x | y, (x, y)  R
and y  C

I}
implies y  C
{x | y, (x, y)  R

{x | ({y.(x, y)  RI})  n}
{x | ({y.(x, y)  RI})  n}

exists restriction
value restriction

I)  n}
I)  n}

Axiom Name

concept assertion

role assertion

concept inclusion
individual equality
individual inequality

Syntax
C(a)
R(a, b)
C1  C2
a = b
a = b

(a

Semantics
I  C

a
I)  R

, b
1  C
?

?

?
I = b
a
I = b

a

,I) consisting of a non-empty domain 

Remark 1. In Table 1, number restrictions can be taken as qualifying restrictions, i.e., 
nR  nR. and  nR  nR., where  is the logically equivalent relationship.
The formal definition of the (model-theoretic) semantics of ALCNQ is given by means
of interpretations I = (

and a mapping
I
satisfying the conditions in Table 1 where M denotes the cardinality of a set M ,
interpreting concepts as subsets of the domain and roles as binary relations on the do-
main. An interpretation I satisfies C  D (written I |= C  D) iff C
and it
satisfies a T Box T if it satisfies every assertion in T . Such an interpretation is called a
model of T (written I |= T ). A concept C is called satisf iable w.r.t. a terminology T
I = . A concept D subsumes a concept C w.r.t T
iff there is a model I of T with C
I  

iff C
. An interpretation I satisf ies C(a)
is called an instance of a concept C iff a
and it satisf ies an ABox A (written
iff a
, b
I |= A) if it satisfies every assertion in A. An interpretation I satisf ies an ALCNQ
ontology (i.e. is a model of the ontology) (written I |= O) iff it satisfies each axiom in
both the ABox and the TBox.

holds for each model I of T . For an interpretation I, an element a

I  D
I  C

, it satisfies R(a, b) iff (a

I  C

I)  R

I  D

An ontology is called satisf iable (unsatisf iable) iff there exists (does not exist)
such a model. An ABox is consistent iff it has a model; and inconsistent otherwise.
Using the definition of satisfiability, an assertion  is said to be a logical consequence
?

?

?
of an ontology O ( written O |=  ) iff  is satisfied by every interpretation that satisfies
O. In ALCNQ, reasoning tasks, i.e. the derivation of logical consequences, can be reduced to check satisfiability of ontologies. Tableau algorithms can implement checking
satisfiability of ABox. Ian Horrocks et al [18] have developed an algorithm for combined TBox and ABox reasoning in description logic based on the following lemma.
Lemma 1. Let C, D be concepts, A an ABox, T a TBox. We define

CT := CiDiT Ci  Di.

Then the following properties hold.
1. C is satisfiable w.r.t. T iff C  CT is satisfiable.
2. D subsumes C w.r.t. T iff C  D  CT is unsatisfiable.
3. A is consistent w.r.t. T iff A  {a : CT | a occurs in A} is consistent.
3 Quasi-Classical Description Logic ALCNQ

Quasi-classical description logic is a development of quasi-classical logic as defined in
[15]. We assume that the language of QC description logic ALCNQ is L.

3.1 Basic Definitions
Let A be an atomic concept and R be a role. A and A are concept literals. A concept
C is in N N F , i.e., negation () occurs only in front of concept names. A role literal
has the form R.C, R.C,  nR,  nR,  nR.C or  nR.C with C a concept in
NNF. A literal is either a concept literal or a role literal, written by L. A clause is the
disjunction of finite literals. Let L1 Ln be a clause, then Lit(L1 Ln) is the
set of literals {L1, . . . , Ln} that are in the clause. A clause is empty clause, denoted
by , if it has no literals. We define  be a complementation operation such that
 A is A and  (A) is A. The  operator is used to make some definitions clearer.
Definition 1. Let L1    Ln be a clause that includes a literal disjunct Li. The
f ocus of L1    Ln by Li, denoted (L1    Ln, Li), is defined as the clause
obtained by removing Li from Lit(L1    Ln). In the case of a clause with just one
disjunct, we assume (L, L) = .
Example 1. Given a clause L1  L2  L3, (L1  L2  L3, L2) = L1  L3.
In the following, we define strong interpretation and weak interpretation over domain
by assigning to each concept C a pair+C,C of (not necessarily disjoint) subsets



. Intuitively, +C is the set of elements known to belong to the extension of C, while
of C
C is the set of elements known to be not contained in the extension of C. +C and C
are not necessarily disjoint and mutual complemental with respect to the domain. The
I \ S.
complemental set of a set S w.r.t. an interpretation I, denoted by S, if S = 
Definition 2. Let I be a pair I = (

is a function
to concepts. I is a

assigning elements of 
weak interpretation in QC ALCNQ if the conditions in Table 2 are satisfied.

as domain, where I

,I) with 

to individuals, and subsets of 

I  

X. Zhang, G. Xiao, and Z. Lin

Table 2. Weak Semantics of QC ALCNQ

Constructor Syntax
?

?

?
o



C1  C2
C1  C2
C
R.C
R.C
 nR
 nR
 nR.C

 nR.C

Weak Semantics

I = +A,A, where +A,A  

I = +R,R, where +R,R  

I  

I  I
o
I ,
, I
i = +Ci,Ci for i = 1, 2
+C1  +C2,C1  C2,if C

+C1  +C2,C1  C2,if C
i = +Ci,Ci for i = 1, 2

(C)I = C, +C, if C
{x | y, (x, y)  +R and y  +C}, {x | y, (x, y)  +R
implies y  C}, if C
I = +R,R
{x | y, (x, y)  +R implies y  +C}, {x | y, (x, y)  +R
I = +R,R
and y  C}, if C
{x | ({y.(x, y)  +R})  n}, {x | ({y.(x, y)  +R}) < n},
{x | ({y.(x, y)  +R})  n}, {x | ({y.(x, y)  +R}) > n},

I = +C,C and R
I = +C,C and R

I = +C,C

if R

I = +R,R
I = +R,R

if R

I = +C,C and R

{x | ({y.(x, y)  +R} and y  +C)  n},
{x | ({y.(x, y)  +R} and y  C) < n}
I = +R,R
if C
{x | ({y.(x, y)  +R} and y  C)  n},
{x | ({y.(x, y)  +R} and y  +C) > n}
I = +R,R
if C

I = +C,C and R

I  +C, C

I = +C,C;

I = +R,R;

I)  +R, R
, b

I = b
I = b

Definition 3. Let |=w be a satisfiability relation called weak satisfaction. For a weak
interpretation I, we define |=w as follows:
 I |=w C(a) iff a
 I |=w R(a, b) iff (a
 I |=w C1  C2 iff +C1  +C2, for i = 1, 2, C
 I |=w a = b iff a
 I |=w a = b iff a
where C, C1, C2 are concepts, R is a role and a is an individual.
A weak interpretation I satisf ies a terminology T iff I |=w C  D for each GCI
C  D in T . Such a weak interpretation is called a QC weak model of T ( written
I |=w T ). A weak interpretation I satisf ies an ABox A iff I |=w  for each assertion
 in A, where   {C(a), R(a, b), a = b, a = b}. Such a weak interpretation is called
a QC weak model of A (written I |=w A).

i = +Ci,Ci;

;
;

The definition of strong interpretation is similar to weak interpretation. The main
difference is that the definition for disjunction of concept in strong interpretation is
more restricted.
Definition 4. Let I be a pair I = (
?

?

?
assigning elements of 

is a function
to concepts. I is a

as domain, where I

to individuals, and subsets of 

,I) with 

I  
?

?

?
strong interpretation in QC ALCNQ if the conditions in Table 2, except conjunction
concept and disjunction concept, are satisfied and I satisfies as follows:
 conjunction of concept C1  C2: (C1  C2) under strong interpretation I is defined as +C1  +C2, (C1  C2)  (C1  +C2) (+C1  C2), if C

i =
+Ci,Ci for i = 1, 2;
 disjunction of concept C1  C2: (C1  C2) under strong interpretation I is defined
as (+C1+C2)(C1+C2)(+C1C2), C1C2, if C
i = +Ci,Ci

for i = 1, 2.

, b

I = +C,C;

I  +C where C

I)  +R where R

Remark 2. In Definition 4, the disjunction of concept under strong interpretation is defined in order to hold three inference rules and the conjunction of concept under strong
interpretation is defined in order to hold De Morgan law with disjunction of concept.
Definition 5. Let |=s be a satisfiability relation called strong satisf action. For a
strong interpretation I, we define |=s as follows:
 I |=s C(a) iff a
 I |=s R(a, b) iff (a

 I |=s C1  C2 iff C1  +C2, +C1  +C2 and C2  C1, for i = 1, 2,
i = +Ci,Ci;

 I |=s a = b iff a
I = b
 I |=s a = b iff a
I = b
where C, C1, C2 are concepts, R is a role and a is an individual.
A strong interpretation I satisf ies a terminology T iff I |=s C  D for each GCI
C  D in T . Such a strong interpretation is called a QC strong model of T ( written
I |=s T ). A strong interpretation I satisf ies an ABox A iff I |=s  for each assertion
 in A, where   {C(a), R(a, b), a = b, a = b}. Such a strong interpretation is called
a QC strong model of A ( written I |=s A).

I = +R,R;
?

?

?
;
;

By Definition 4 and Definition 5, we conclude several properties in the following

I  +Li and a

I  Li; where L

I  +Li and a
i = +Li,Li.

theorems.
Theorem 1. Let L1Ln be a clause and a be an individual.I |=s L1Ln(a)
iff for some Li  Lit(L1    Ln), a
I  Li; or for all Li 
Lit(L1    Ln), a
Theorem 2. Let C be a concept and R be a role. For any weak ( or strong) interpretation I defined in Definition 2 (or Definition 4), we have
1. (( nR.C))I = (> nR.C)I
2. (R.C)I = ( 1R.C)I
Theorem 3. Let I and  be an interpretation and a formula in ALCNQ respectively.

and (( nR.C))I = (< nR.C)I

and (R.C)I = (< 1R.C)I

;

.

If I |=s  then I |=w .

Theorem 3 shows that a strong model is a weak model but not vice versa.
?

?

?
I  C where C

Example 2. Given an ABox A = {C(a),C(a)}. We assume that there exists an interpretation I such that a
I  +C and a
I = +C,C. Clearly,
I |=w C  D(a) while I |=s C  D(a).
Definition 6. Given a set of formula K and an axiom  in ALCNQ, K QC entails
, denoted by K |=Q , iff for every interpretation I, if I is a strong model of every
formula of K then I is a weak model of . In this case, |=Q is a QC entailment
(relation) between K and .
That |=Q is non-trivializable in the sense that when an ontology O is classically incon-
sistent, it is not the case that any axiom is entailed by O in QC ALCNQ.
Example 3. Given an ABox A = {B(a),B(a)} and an atomic concept A in QC
ALCNQ. So {B(a),B(a)} is classically inconsistent. However it is not the case that
A |=Q C(a) holds, since there exists an interpretation I such that a
I  +B and
I = +B,B. So I |=s B  B(a), but I |=w A(a) since A(a)
I  B where B
a
does not occur in A.
Example 4. Let an ABox A = {B  C(a),B(a)}. For all interpretations I such that
I  B, if I |=s B  C(a) and I |=s B(a) then
I  +B or a
(a
I |=w C(a). Hence, A |=Q B  C(a), A |=Q B(a), and A |=Q C(a).
Example 5. Suppose an ABox A is empty. Now consider the classical  = A  A.
Here A |=Q A  A(a) does not hold. Since A strongly satisfies every formula in A,
but A does not weakly satisfy A  A(a).
Example 5 shows that QC description logic is weaker than description logic in ability
of reasoning.

I  +C) and a

= +C,C if C

I =
Definition 7. A complement of a concept C is defined by C
+C,C where I is a (strong or weak) interpretation of C, denoted by C. We call C
is the complement of C.
Remark 3. The intuition behind complement of concepts is to reverse both the information of being true and of being false. And any ALCNQ ABox doesnt contain complement concepts.
In QC ALCNQ, the set of signed formulae of L is denoted L
and is defined as
L  {C|C  L}. In the following, we discuss the QC tableau algorithm based on
the language L
Theorem 4. For concept name A, concepts C, D in NC, individuals a, b in NI and a
role R in NR in QC ALCNQ.
(7) I |=x (R.C)(a) iff I |=x R.C(a)
(1) I |=x A(a) iff I |=x A(a)
(8) I |=x (R.C)(a) iff I |=x R.C(a)
(2) I |=x A(a) iff I |=x A(a)
(9) I |=x ( nR)(a) iff I |=x n  1R(a)
(3) I |=x A(a) iff I |=x A(a)
(4) I |=w C  D(a) iff I |=w C  D(a) (10) I |=x ( nR)(a) iff I |=x n + 1R(a)
(5) I |=w C  D(a) iff I |=w C  D(a) (11) I |=x ( nR.C)(a) iff I |=x n  1R.C(a)
(6) I |=x (a) iff I |=x (a)
(12) I |=x ( nR.C)(a) iff I |=x n + 1R.C(a)
Here |=x is a place-holder for both |=w and |=s.

.
?

?

?
Theorem 5. Let I be an interpretation and let C, D be concepts.
1. I |=s C  D iff for any individual a  NI, I |=s C  D(a).
2. I |=w C  D iff for any individual a  NI, I |=w C  D(a).
In QC ALCNQ, a QC ABox (QC T Box) is a set whose axioms (concept inclusions)
are formulae in L
. A concept C is QC satisf iable w.r.t. a QC ABox A if there exists
an individual a such that A |=Q C(a), and QC unsatisf iable w.r.t. A otherwise. A
concept C is QC satisf iable w.r.t. a QC ABox A and a QC TBox T if there exists
an individual a such that T  A |=Q C(a), and QC unsatisf iable w.r.t. T and A
otherwise. A QC ABox A is QC consistent if each concept occurring in A is QC
satisfiable w.r.t. A, and QC inconsistent otherwise. A QC ABox A is QC consistent
w.r.t. a QC TBox T if each concept occurring in A is QC satisfiable w.r.t. T and A, and
QC inconsistent w.r.t. T otherwise. A set of QC ABoxes S is QC consistent iff there
is a QC satisfiable QC ABox in S, QC inconsistent otherwise. A set of QC ABoxes
S is QC satisf iable iff there is a QC satisfiable QC ABox in S, QC unsatisf iable
otherwise.
A concept C is in QC N N F , i.e., iff complement only occurs over concept names.
By Theorem 4, for any concept C  L
, C can be transformed into its QC NNF.

For a concept, we define clos(C) as the smallest set that contains C and is closed
under sub-concepts, its NNF and QC NNF of its complement. We denote clos(A) =
CA clos(C). Clearly, the size of clos(A) is polynomial in the size of A.
Theorem 6. Let O = (T ,A) be an ALCNQ ontology, a be a individual and  be a
new individual not occurring in O. Then the following hold.
1. A |=Q C(a) iff A  {C(a)} is QC unsatisfiable.
2. A |=Q C  D iff A  {C  D()} is QC unsatisfiable.
4 QC Tableau Algorithm for ALCNQ

In this section, we develop a tableau algorithm called by QC tableau algorithm for
reasoning with inconsistency in QC ALCNQ. RA denotes the set of roles occurring in
A, and UA denotes the set of individuals occurring in A.

4.1 QC Tableau
Definition 8. Given a QC ABox A, T = (S,L,E,J ) is a QC tableau for A iff
 S is a non-empty set;
 L : S  2clos(A) maps each element in S to a set of concepts;
 E : RA  2SS maps each role to a set of pairs of elements in S;
 J : UA  S maps individuals occurring in A to elements in S.
Furthermore, for all s, t  S, C, C1, C2  clos(A) and T satisfies:
(P1) if C  L(s), then C  L(s),
(P2) if C1  C2  L(s), then C1  L(s) and C2  L(s),

X. Zhang, G. Xiao, and Z. Lin

(P3) if C1  C2  L(s), then

(a) if  Ci  L(s) for some (i  {1, 2}), then (C1  C2, Ci)  L(s),
(b) else C1  L(s) or C2  L(s),

(P4) if R.C  L(s) and s, t  E(R), then C  L(t),
(P5) if R.C  L(s), then there is some t  S such that s, t  E(R) and C  L(t),
(P6) if  nR.C  L(s), then RT (s, C)  n,
(P7) if  nR.C  L(s), then RT (s, C)  n,
(P8) if ( nR.C)  L(s) and s, t  E(R) then C  L(t) or C  L(t),
(P9) if a : C  A, then C  L(J (a)),
(P10) if (a, b) : R  A, then J (a),J (b)  E(R),
(P11) if a = b  A, then J (a) = J (b),
where  is a place-holder for both  and , and RT (s, C) = {t  S | s, t  E(R)
and C  L(t)}.
Theorem 7. A QC ABox A is QC satisfiable iff there is a QC tableau for A.

4.2 QC Tableau Algorithm

In this subsection, we develop a QC tableau algorithm based on QC transformation
rules which are obtained by modifying the expansion rules in [18] in order to obtain
a QC tableau for a QC ABox A. In the following, we borrow the reasoning technique
from Horrocks [18,19] to implement paraconsistent reasoning under QC semantics.
In QC ALCNQ, a completion forest F for a QC ABox A is a collection of trees
whose distinguished root nodes are possibly connected by edges in an arbitrary way.
Moreover, each node x is labeled with a set L(x)  clos(A) and each edge x, y is
labeled with a set L(x, y)  R of (possibly inverse) roles occurring in A. Finally,
completion forests come with an explicit inequality relation = on nodes and an explicit
equality relation = which are implicitly assumed to be symmetric.
If nodes x and y are connected by an edge x, y with R  L(x, y), then y is called
an R-successor of x and x is called an R-predecessor of y. If y is an R-successor of
x, then y is called an R-neighbor of x. A node y is a successor (resp. predecessor
or neighbor) of y if it is an R-successor (resp. R-predecessor or R-neighbor) of y for
some role R. Finally, ancestor is the transitive closure of predecessor.
F(x, C) :=
{y | y is R-neighbor of x and C  L(y)}. A node is blocked iff it is not a root node
and it is either directly or indirectly blocked. A node x is directly blocked iff none of

its ancestors are blocked, and it has ancestors x

For a role R, a concept C and a node x in F we define R

F(x, C) by R

such that

, y and y
?

?

?
;

);

 y is not a root node;

 x is a successor of x
and y is a successor of y
 L(x) = L(y) and L(x
) = L(y
 L(x
, y).
, x) = L(y
?

?

?
In QC ALCNQ, given a QC ABox A and a role R, the algorithm initializes a completion forest FA consisting only of root nodes. More precisely, FA contains a root
0 if A contains an assertion
node xi
(ai, aj) : R for some R. The labels of these nodes and edges and the relations = and =
are initialized as follows:

0 for each individual ai  UA, and an edge xi

0, xj
?

?

?
(1) L(x0
(2) L(xi

i ) := {C | ai : C  A}, and
0, xj

0) := {R | (ai, aj) : R  A}, xi

0 = xj

0 iff ai = aj  A, and the =

-relation is initialized to be empty.
FA is then expanded by repeatedly applying the rules from Table 3.

Definition 9. Let O = (T ,A) be an ontology, C1, C2, C concepts, R a role and x, y, z
individuals in QC ALCNQ. We define QC transf ormation rules in Table 3.
For a node x, L(x) is said to contain a clash if {A, A}  L(x) for some concept name
A  NC, or if there is some concept  nR.C  L(x) and x has n + 1 R-neighbors
y0, . . . , yn with C  L(yi) and yi = yj for all 0  i < j  n. A completion forest is
clash-f ree if none of its nodes contains a clash, and it is complete if no QC transformation rule from Table 3 can be applied to it. For a QC ABox A, the algorithm starts
with the completion forest FA. It applies the QC transformation rules in Table 3, stopping when a clash occurs, and answers  A is QC satisfiable  iff the QC transformation
rules can be applied in such a way that they yield a complete and clash-free completion
forest; and answering  A is QC unsatisfiable  otherwise.
Theorem 8. Let A be a QC ABox in QC ALCNQ.
1. The QC tableau algorithm terminates when started for A.
2. If the QC transformation rules can be applied to A such that they yield a complete
and clash-free completion forest, then A has a QC tableau.
3. If A has a QC tableau, then the QC transformation rules can be applied to A such

that they yield a complete and clash-free completion forest.

4. The QC tableau algorithm is a decision procedure for the consistency of QC ABoxes

and the satisfiability and subsumption of concepts with respect to terminologies.

Theorem 9. Satisfiability of QC ABoxes is PSPACE-complete in ALCNQ.

5 Related Work

In this section, we compare QC description logic with four-valued description logic
[7,9,20] which is a paraconsistent logic by integrating description logic with Belanps
four-valued logic [12]. The similarities and differences between QC logic and fourvalued logic still exist between QC DLs and four-valued DLs.

In QC DLs, the weak semantics is analogous to the four-valued semantics in fourvalued DLs. In fact, inconsistent or incomplete can be tolerated under two semantics
and the contradiction can be taken as a part of ontologies. Below we give a presentation
of the definition 4-model of four-valued DL which was proposed in [7,9,20].
Definition 10 (Ma [9]). Let C, D be concepts and a be an individual in four-valued
DLs. An interpretation I is a 4-model of an axiom C(a) (written by I |=4 C(a))
I); I is a 4-model of a material inclusion C  D (written by
iff a
I |=4 C  D) iff proj(CI)  proj+(D
I); I is a 4-model of an internal inclusion
I) and I is a 4-model
C  D (written by I |=4 C  D) iff proj+(C
of a strong inclusion C  D (written by I |=4 C  D) iff proj+(C
I)  proj+(D
I)
and proj

I)  proj+(D

I  proj+(C

I)  proj

(D

(C

I).

X. Zhang, G. Xiao, and Z. Lin

Table 3. QC Transformation Rules in QC ALCNQ

y

y

1. The -rule
Condition: C1  C2  L(x), x is not indirectly blocked, and {C1, C2}  L(x).
Action: L(x) := L(x)  {C1(x), C2(x)}.
2. The -rule
Condition: C1  C2  L(x), x is not indirectly blocked, and {C1, C2,  C1,  C2}  L(x) = .
Action: L(x) := L(x)  {E} for some E  {C1, C2}.
3.The QC-rule
Condition: C1  C2  L(x), x is not indirectly blocked, and  Ci  L(x)(for some i  {1, 2}).
Action: L(x) := L(x)  {(C1  C2, Ci)}.
4. The -rule
Condition: R.C  L(x), x is not blocked, and x has no R-neighbor y with C  L(y).
Action: create a new node y with L(x, y) := {R} and L(y) := {C}.
5. The -rule
Condition:
(1) R.C  L(x), x is not indirectly blocked, and
(2) there is an R-neighbor y of x with C  L(y).
Action: L( ) := L(y)  {C}.
6. The choose-rule
Condition: ( nR.C)  L(x), x is not indirectly blocked, and there is an R-neighbor y of x
with {C, C}  L(y) = .
Action: L( ) := L(y)  {E} for some E  {C, C}.
7. The -rule
Condition:
(1) nR.C  L(x), x is not blocked, and
(2) there are no n R-neighbors y1, . . . , yn such that C  L(yi)
and yi = yj for 1  i < j  n.
Action: create n new nodes y1, . . . , yn with L(x, yi) := {R}, L(yi) := {C}, and yi = yj.
8. The -rule
Condition:
(1)  nR.C  L(x), x is not indirectly blocked, and R
(2) there are R-neighbors y, z of x with not y = z, y is neither a root node nor an ancestor of z,
and C  L(y)  L(z).
Action:
(1)L(z) := L(z)  L(y); and
(2)if z is an ancestor of x then L(z, x) := L(z, x) else L(x, z) := L(x, z)  L(x, y)
(3) L(x, y) := ;
(4) set u = z for all u with u = y.
9. The r -rule
Condition:
(1) nR.C  L(x), and R
(2) there are two R-neighbors y, z of x which are both root nodes,
C  L(y)  L(z), and not y = z.
Action:
(1) L(z) := L(z)  L(y);
(2) for all edges y, w:

F (x, C) > n and

F (x, C) > n,

(3) for all edges w, y:

(a) if the edge z, w does not exist, create it with L(z, w) :=  and
(b) L(z, w) := L(z, w)  L(y, w);
(a) if the edge w, z does not exist, create it with L(w, z) :=  and
(b) L(w, z) := L(w, z)  L(w, y);

(4) set L(y) :=  and remove all edges to/from y;
(5) set u = z for all u with u = y and set y = z.
?

?

?
Definition 11 (Ma [9]). Let O be an ontology and  be an axiom in four-valued DL.
O entails  under four semantics, denoted by O |=4 , iff for any model I of O,2 I is
a 4-model of .

The follow property shows that there exists a close relationship between weak models
and 4-models in description logic.
Theorem 10. Let C, D be concepts, a be an individual and I be an interpretation in
description logic.

1. I |=w C(a) iff I |=4 C(a); 2. I |=w C  D iff I |=4 C  D.

The follow property shows that strong models is stronger than 4-models in description
logic.
Theorem 11. Let C, D be concepts, a be an individual and I be an interpretation in
description logic.
1. I |=4 C(a) if I |=s C(a);
2. I |=4 C  D, where  {, ,} if I |=s C  D.
Theorem 12. Let O be an ontology and  be a query in ALC. If O |=4  then
O |=Q .
Theorem 12 shows that QC entailment is stronger than four-valued entailment because
QC entailment holds modus ponens, modus tollens, hypothetical syllogism and disjunctive syllogism which four-valued entailment does hold.

6 Conclusions

In this paper, we present QC OWL to handle inconsistency with holding three inference
rules and intuitive equivalences. For the aim of paraconsistent reasoning, QC weak semantics is similar to four-valued semantics for OWL. In order to hold three inference
rules, QC strong semantics is introduced by restricting disjunction of concepts in description logic. Compared with four-valued OWL, we redefine concept inclusion (or
subsumption) in QC OWL to follow intuitive equivalences. For this purpose, concept
inclusion under QC weak semantics is defined by internal inclusion of four-valued OWL
and concept inclusion under QC strong semantics is defined by hybrid of three inclusions (material inclusion, internal inclusion and strong inclusion) of four-valued OWL.
In order to find suitable for implementation of paraconsistent reasoning in QC OWL, we
propose the QC tableau algorithm with technique of blocking for checking satisfiability
of QC ALCNQ ABox. Technique of blocking is introduced to hold the terminability
of QC tableau algorithm. Moreover, we conclude the terminability, soundness and completeness of the algorithm. The complexity of QC tableau algorithm is not more than
the complexity of classical tableau algorithm for an ALCNQ ABox. Complement of
2 An interpretation is a 4-models of an ontology iff it satisfies each assertion and each inclusion

axiom in the ontology [9].

X. Zhang, G. Xiao, and Z. Lin

concept is introduced to QC semantics in order to build reasoning system of QC OWL
by not rebuilding whole new reasoning system but borrowing from classical reasoning systems of OWL. It is quite easy to show that the QC tableau algorithm, which is
presented in this paper, is obtained by modifying classical reasoning systems of OWL
[18]. In the future, we will further study the similar paraconsistent approach for more
complex DLs such as OWL Lite and OWL DL.
