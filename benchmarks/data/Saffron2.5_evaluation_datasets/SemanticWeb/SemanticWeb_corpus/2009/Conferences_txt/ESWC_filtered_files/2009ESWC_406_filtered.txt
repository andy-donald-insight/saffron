FO(ID) as an Extension of DL with Rules

Joost Vennekens and Marc Denecker

Dept. of Computer Science, K.U. Leuven, Belgium
{joost.vennekens,marc.denecker}@cs.kuleuven.be

Abstract. There are many interesting Knowledge Representation questions surrounding rule languages for the Semantic Web. The most basic
one is of course: which kind of rules should be used and how do they integrate with existing Description Logics? Similar questions have already
been addressed in the field of Logic Programming, where one particular
answer has been provided by the language of FO(ID). FO(ID) is an extension of first-order logic with a rule-based representation for inductive
definitions. By offering a general integration of first-order logic and Logic
Programs, it also induces a particular way of extending Description Logics with rules. The goal of this paper is to investigate this integration
and discover whether there are interesting extensions of DL with rules
that can be arrived at by imposing appropriate restrictions on the highly
expressive FO(ID).

1 Introduction

Over the past decades, Description Logics (DL) have emerged as an important
Knowledge Representation (KR) technology. More recently, they have also had a
significant impact on industry, most notably with the adoption of OWL as a W3C
standard. In current research, we find a trend to investigate extensions of OWL
with rules (e.g. [11]), and, in fact, the hierarchical Semantic Web architecture
already prescribes a rule layer on top of the ontology layer formed by OWL.
There are a number of interesting KR questions surrounding this topic:

 Which kind of rules are to be used? There are numerous kinds of rules known
in the literature (inference rules, rewrite rules, . . . ), with subtle differences
between them.

 What precisely do this kind of rules mean? It should be possible to explain
exactly the information content of such a rule and, obviously, this explanation should be consistent with the formal semantics of the rules.

 How do the rules complement DL? We should be able to clearly indicate how
the rules extend the class of knowledge that can be represented by the logic.

In this paper, we will present an answer to these questions based on the
language of FO(ID), a general integration of classical first-order logic (FO) and
Logic Programming (LP). Conceptually, FO(ID) is an extension of FO with

 Joost Vennekens is a postdoctoral researcher of the FWO.

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 384398, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
inductive definitions. To explain, let us consider the following example of an
inductive definition, taken from the wikipedia page on the topic1:

The prime numbers can be defined as consisting of:

 2, the smallest prime;
 each positive integer which is not evenly divisible by any of the primes

smaller than itself.
?

?

?
FO(ID) offers a formal syntax for representing such an inductive definition as a
set of definitional rules:
P rime(2) 
?

?

?
x P rime(x)  x > 0  y y < x  P rime(y)  Divisible(x, y)

In natural language, an inductive definition consists of a set of cases in which
the defined relation, P rime in this case, holds. Each of these cases corresponds
to a definitional rule in the formal syntax of FO(ID). We remark that the -
symbol in the above expression therefore conveys more meaning than the normal
material implication of FO: it not only states that certain numbers are prime,
but also that no number can be prime unless its primeness can be constructively derived by applying the two rules. This additional meaning of such a rule
is formalized in FO(ID) using the (parameterized) well-founded model construction from Logic Programming. It was argued in [5] that this formal construction
correctly captures the common-sense meaning of such a definition, as it is understood throughout mathematics.

The job of an inductive definition is, obviously, to define certain relation(s)
(e.g., P rime/1) in terms of some other relation(s) (e.g., < /2 and Divisible/2).
In this sense, it has the same semantic status as an FO formula: it expresses a
relation between a number of predicates, which may or may not be satisfied by
a given interpretation for these predicates. Based on this observation, FO(ID)
now integrates inductive definitions into FO: a formula of FO(ID) is either a
regular FO formula or an inductive definition. In this way, FO is extended with
a particular form of rules, namely, definitional rules, whose meaning is that each
such rule represent a case of a particular inductive definition. This enlarges
the expressive power of the logic: it is well-known that inductive definitions, such
as that of transitive closure, cannot be expressed in FO.

The integration of FO and LP offered by FO(ID) has a number of properties

that are quite appealing from the point-of-view of extending DL with rules:

 As opposed to the many hybrid approaches that exist, FO(ID) offers a strong

semantic integration of FO and LP.

 In this integration, both components have a clear knowledge representation
task: the LP component is to be used to define concepts, whereas the FO
component can be used to assert additional properties of both the defined
concepts and concepts for which no definition is provided.

http://wikipedia.org/wiki/Inductive definition

J. Vennekens and M. Denecker

 FO(ID) is particularly natural from a DL perspective: the ability to properly
define concepts is already considered to be an important and characteristic
feature of DL2, and FO(ID) essentially just extends it to definitions that
cannot be represented by a normal FO equivalence.

 FO(ID) does not impose any arbitrary restrictions on expressivity: it contains
full FO and allows general FO formulas in the bodies of its definitional rules.
These properties suggest that FO(ID) is well-suited to serve as a kind of
upperbound, from which we can derive meaningful extensions of DL with rules,
by imposing suitable restrictions on it. We believe that, in general, this is better
than the opposite approach of gradually extending a small tractable language
into a more expressive one, since it allows the trade-off between expressivity
and complexity to be made more consciously and informedly, which reduces
the risk of creating an ad hoc language, whose boundaries are decided more by
coincidence than design. In the rest of this paper, we will try to make these
claims more concrete, by defining two fragments of FO(ID), that seem to be
interesting DL rule languages.

2 Preliminaries: FO(ID)

This section summarizes the definition of FO(ID) as found in [5]. Syntactically,
a definition in FO(ID) is a set of definitional rules, which are of the form:

x P (x)  (x).

Here, (x) is an FO formula whose free variables are x, and  is a new sym-
bol, the definitional implication, which is to be distinguished from the material
implication of FO, which we denote by . We refer to P (x) as the head of the
rule r, denoted head(r), and to the formula  as its body, denoted body(r).

An FO(ID) formula is any expression that can be formed by combining atoms
and definitions, using the standard FO connectives and quantifiers. The meaning
of the FO formulas and boolean connectives is standard; we therefore only need
to define the semantics of a definition in order to define that of FO(ID).
Let us first introduce some semantical concepts. An interpretation S for a
vocabulary  consists of a non-empty domain D, a mapping from each function
symbol f /n to an n-ary function on D, and a mapping from each predicate
symbol P/n to a relation R  Dn. A three-valued interpretation  is the same as
a two-valued one, except that it maps each predicate symbol P/n to a function
P  from Dn to the set of truth values {t, f , u}. Such a  assigns a truth value to
each logical atom P (c), namely P (c
n). This assignment can be extended
to an assignment () of a truth value to each formula , using the standard
Kleene truth tables for the logical connectives:
2 For instance, the DL handbook [1] has the following to say about DLs -connective:
This form of definition is much stronger than the ones used in other kinds of representations of knowledge, which typically impose only necessary conditions; the
strength of this kind of declaration is usually considered a characteristic feature of
DL knowledge bases.

1 , . . . , c
?

?

?
,  t, t t, f t, u u, f u, u f, f
   t
f

u

u

t

t

 t u f
 f u t
?

?

?
(d).

 to P (d

maps d to v and all other tuples d

 if for each predicate P/n and tuple d  Dn, P (d) p P 

valued interpretation 
and for which P 
this notation to sets {(P1(d1), . . . , Pn(dn)} of such pairs.

and so on. The three truth values can be partially ordered according to precision:
u p t and u p f. This order induces a precision order p on interpretations:
 p 
For a predicate P/n and a tuple d  Dn, we denote by [P (d)/v] the three-
 that coincides with  on all symbols apart from P/n,
). We also extend
Our goal is to define when a (two-valued) interpretation S is a model of a
definition . We call the predicates that appear in the head of a rule of  its
defined predicates and we denote the set of all these by Def(); all other symbols
are called open and the set of open symbols is written Op(). The purpose of
 is now to define the predicates Def() in terms of the symbols Op(), i.e.,
we should assume the interpretation of Op() as given and try to construct a
corresponding interpretation for Def(). Let O be the restriction S|Op() of S
to the open symbols. We are now going to construct a sequence of three-valued
 )0, each of which extends O; we will use the limit of this
interpretations (O
sequence to interpret Def().
0 assigns O(P (d))  {t, f} to P (d) if P  Op() and u if P  Def();
i+1 is related to O
in one of two ways:
 Either O
i [P (d)/t], such that  contains a rule x P (x)  (x)
i+1 = O
with O
i ([d]) = t
 Or O
i [U/f], where U is any unfounded set, meaning that it
i+1 = O
consists of pairs of predicates P/n and tuples d  Dn for which P O
i (d) =
u, and for each rule x P (x)  (x), we have that O
i+1([d]) = f.
 is the least upper bound w.r.t. p of all O

 For each limit ordinal , O

 O
 O

 for
?

?

?
i

which  < .

We call such a sequence a well-founded induction of  in O. Each such sequence
 . It was shown in [5] that all sequences reach the
eventually reaches a limit O
 that tell us how to interpret the defined predicates.
same limit. It is now this O
To be more precise, we define that:

S |=  iff S|Def() = O

|Def(), with O = S|Op().



This tells us when a definition  is satisfied in a structure S. The semantics of full
FO(ID), in which definitions and atoms can be combined using the standard FO
connectives, is now simply that which is obtained by adding the usual recursive
cases for the connectives (e.g., S |=    if S |=  and S |= , and so). Note
that if there is some predicate P/n and d  Dn such that  still assigns u
to P (d), then the definition has no models extending O. Intuitively, this means
that, for this particular interpretation of its open symbols,  does not manage
to unambiguously define the predicates Def(), due to some non well-founded
use of negation.

J. Vennekens and M. Denecker

In the rest of this paper, we will only consider relational vocabularies, that is,

there will be no function symbols of arity > 0.

3 From FO(ID) to DL(ID)

As a language that extends full FO, FO(ID) is too expressive to serve as a DL
itself. In this section, we discuss the problem of restricting FO(ID) to a smaller,
more DL-like language. In doing this, it is important to be clear about the goals
we are trying to achieve. DLs themselves are fragments of FO that are interesting
for essentially two reasons:

 They are decidable;
 They are tailored towards a concept-centric modeling style, which they support by means of an intuitive syntax sugar that hides away many of the
complexities of FO.

The first of these properties is only relevant for computation, whereas the second concerns knowledge representation. To a certain extent, they are therefore
orthogonal concerns.

Most of our attention in this paper will go to the knowledge representation
issue, simply because we feel that it comes first. If a logic is to be used at all, for
whatever purpose, then theories will have to be written in it. If this is difficult,
for instance because the language is too complex or because the meaning of
its statements is unclear, then it is unlikely the language will enjoy enduring
success, no matter how efficient certain inference task for it might be. Therefore,
a primary goal of designing a rule language for DL should be to ensure that
it provides a clean and coherent integration of rules into DL, which is easy to
understand for those with a working knowledge of DL.

This does not mean that decidability is unimportant, but in the end it is of
secondary nature, since also undecidable languages can have interesting uses.
Indeed, decidability is only relevant if the goal is to perform deductive inference
(i.e., to decide whether, for formulas  and , it is the case that  |= , in
the sense that each model of  is also a model of ) in an unknown or infinite
domain. Formally, we know that:

 Given an FO theory T and an FO formula , it is undecidable whether for

all structures S, it holds that S |= T implies S |= ;

 However, given a finite set D, an FO theory T and an FO formula , it is
decidable (and in co-NP) whether for all structures S such that the domain
of S is D, it holds that S |= T implies S |= ;

When we go from FO to FO(ID), both of these theorems still hold. This is impor-
tant, because the second situation arizes in numerous interesting applications.
For instance, when reasoning in the context of a particular database, we only
want to consider the domain D consisting of all the objects in the database.
Similarly, if the goal is to query some data from Semantic Web sites, we should
?

?

?
only consider the domain D of objects about which we are able to retrieve infor-
mation. A second example is that for many combinatorial problems, the domain
is given as part of the specific problem instance that is to be solved; e.g., in
graph colouring, D would be the set of nodes, which is fixed once we get a
specific graph to colour. Moreover, even when the domain is not known, there
might still be approximate algorithms, that are able to derive useful information
without guarantees of completeness.

We will therefore now first present a fragment of FO(ID) that allows a DL-like
syntactic sugar and offers a DL-like modeling methodology. Only afterwards will
we (more briefly) turn to the topic of inference.
4 A Fragment of FO(ID): ALCI(ID)
The goal of this section is to present a fragment of FO(ID), that supports a DLlike modeling style. This will be an extension of the Description Logic ALCI.
More expressive logics, such as SHOIN (D) which underlies OWL-DL, can be
extended in the same way; we restrict to ALCI merely for simplicity.
Let us first briefly recall ALCI. We start from a set of unary predicates
{A1, A2, . . .} called (atomic) concepts and a set of binary predicates {B1, B2, . . .}
called (atomic) roles. From the atomic concepts, we build more complex ones
using the connectives , , ,  and ; their meaning can be inductively defined
by the mapping to FO given in Fig. 1. A role is either an atomic role B or
, as in Fig. 2. A TBox then consists of a set of inclusions and
its inverse B
equivalences as in Fig. 3.
?

?

?
C(x)
A(x)

C(x)

with A an atomic concept

C1(x)  C2(x) with C1, C2 concepts
C1(x)  C2(x) with C1, C2 concepts

C1  C2
C1  C2
C
R.C y R(x, y)  C(y) with R a role and C a concept
R.C y R(x, y)  C(y) with R a role and C a concept

with C a concept

Fig. 1. A concept C of ALCI represents a unary formula C(x) of FO

R R(x, y)
B B(x, y) with B an atomic role

B(y, x) with B an atomic role

Fig. 2. A role R of ALCI represents a binary formula R(x, y) of FO





C1  C2 x C1(x)  C2(x) with C1, C2 concepts
C1  C2 x C1(x)  C2(x) with C1, C2 concepts

Fig. 3. A statement  in a TBox correspond to an FO sentence 

J. Vennekens and M. Denecker

We now form the language ALCI(ID) by extending ALCI. First, we add the
connectives in Fig. 1 for constructing more complex roles: The first three are the
obvious analogues of the connectives for concepts, the fourth takes the join of
two roles, and the last one takes the Cartesian product of two concepts. Second,
and more importantly, we add two new connectives for representing inductive
definitions. The first is the symbol  .=, which is conceptually the same as ,
with the difference that it also works for inductive definitions. Formally, it is
defined as an abbreviation for an FO(ID) definition containing a single rule, as
shown in the first two entries of Fig. 5.

R(x, y)

R1  R2
R1(x, y)  R2(x, y) with R1, R2 roles
R1  R2
R1(x, y)  R2(x, y) with R1, R2 roles
R
R1.R2 z R1(x, z)  R2(z, y) with R1, R2 roles
C1  C2

R(x, y)
C1(x)  C2(y)

with R a role

with C1, C2 concepts

Fig. 4. Additional ways of constructing roles

For instance, we can define the concept of an uncle as the brother of a parent:

U ncle

.= Brother.P arent

This abbreviates the FO(ID) definition:

{x, y U ncle(x, y)  z Brother(x, z)  P arent(z, y)}

Such a non-inductive definition (i.e., the role/concept on the left-hand side does
not appear in the right-hand side) is equivalent to a regular FO equivalence:

x, y U ncle(x, y)  z Brother(x, z)  P arent(z, y).

However,  .= can also correctly represent inductive definitions. For instance, we
can define the role Ancestor as the transitive closure of P arent, by saying that
an Ancestor is either a P arent or the P arent of an Ancestor:

Ancestor

.= P arent  P arent.Ancestor

Because of the translation to FO(ID), this too has the correct semantics. There-
fore,  .= can be used instead of a transitive closure construct such as + or the
reflexive-transitive closure  of e.g. [12]; it can also replace non-nested uses of
the explicit least fixpoint operator .
In addition to .=, we also add the new connective  to represent a definitional
rule and allow sets of such rules as statements in our language; this is shown in
Fig. 5. For instance, extending the notion of an uncle to also include uncles-by-
marriage, we could then define this concept by saying that an uncle is
?

?

?

.= R2
R1
.= C2
C1
{1, . . . , n}



{x, y R1(x, y)  R2(x, y)} with R1, R2 roles
with C1, C2 roles
with 1, . . . , n definitional rules (Fig.6)

{x C1(x)  C2(x)}

{1, . . . ,n}

Fig. 5. A definition  in ALCI(ID) corresponds to a definition  in FO(ID)





R1  R2 x, y R1(x, y)  R1(x, y) with R1, R2 roles
C1  C2

x C1(x)  C2(x)

with C1, C2 concepts

Fig. 6. A definitional rule  in ALCI(ID) corresponds to a definitional rule  in
FO(ID)

 Either a brother of a parent;
 Or a husband of an aunt.
We can write this down in ALCI(ID) as:
?

?

?
U ncle  Brother.P arent
U ncle  Husband.Aunt

This abbreviates the following definition in FO(ID):
?

?

?
x, y U ncle(x, y)  z Brother(x, z)  P arent(z, y)
x, y U ncle(x, y)  z Husband(x, z)  Aunt(z, y)

In general, if a definition contains multiple rules with the same predicate
in the head, these can always be replaced by a single rule whose body is the
disjunction of the bodies of the original rules. Therefore, we could rephrase the
above definition of U ncle as

U ncle

.= Brother.P arent  Husband.Aunt

However, this loses the natural case-based structure of the definition, i.e., it
makes it more difficult to see that there are actually two separate sufficient
conditions, which together also form a necessary condition. Moreover, the rulebased format is also more elaboration tolerant, since rules can more easily be
added or removed. For instance, a bank might define the class of persons eligible
for a loan as consisting of people with a large income, people who own a house
and people with a good credit history; each time the bank now tightens or relaxes
its policy, certain rules would have to be removed or added to this definition.

The rule-based representation is also more general than  .=, since it allows
definitions by simultaneous induction as well. For instance, given a two-player
game whose move tree is described by the role Successor, we can define the nodes
in which I move and the nodes in which my opponent moves by the following
simultaneous induction (assuming I start):

J. Vennekens and M. Denecker

 HisM ove Successor.M yM ove

M yM ove Successor.HisM ove
M yM ove Successor.



Here,  denotes the empty concept.

5 An Example
In this section, we will illustrate the language ALCI(ID) by means of a simple
game. The player is presented a grid of coloured balls. He makes a move by
selecting one of these balls. The effect of this is that the entire colour-group to
which the ball belongs disappears; the remaining balls then fall down, yielding
the next position of the game, as depicted in Fig. 7. The goal of the game is
to remove all balls from the grid in such a way as to score as many points as
possible. What we will do here is construct an ALCI(ID) theory that describes
the effect of a single move of this game.

Fig. 7. The result of selecting ball 2

To make things more concrete, let us fix a representation for a state of the
game. We represent the grid by roles U p and Lef t, both with the obvious mean-
ing. The starting grid in Fig. 7, for instance, would correspond to the following
interpretations:

U p ={(5, 1), (9, 5), (6, 2), (10, 6), (7, 3),

(11, 7), (8, 4), (12, 8)};

Lef t ={(1, 2), (2, 3), (3, 4), (5, 6), (6, 7),
(7, 8), (9, 10), (10, 11), (11, 12)}.

We represent the players move by a concept Chosen; the move made in Fig. 7
would correspond to Chosen = {2}. Our goal is now to define roles U p
 and
Lef t

, representing the next state of the game.

We first define some useful auxiliary relations. We begin by defining Above as
the transitive closure of U p. One ball is above another if it is either directly on
top of it, or on top of a ball that is already above it:
.= U p  U p.Above

Above
?

?

?
A ball is next to another ball if it is either to the left, to the right, underneath,
or on top of it:

N extT o

.= Lef t  Right  U p  Down

Of course, Right and Down are the inverses of, respectively Lef t and U p:

Right


.= Lef t

Down



.= U p

We remark that of these four definitions, Above is defined inductively, while the
others are not. However, in ALCI(ID) this difference hardly matters: all four
definitions have the same look and feel.

The balls that disappear after the move are the chosen ball itself and all balls

belonging to the same colour-group:

Disappears

.= Chosen  InColourGroup.Chosen

Being in the same colour group means being connected through a sequence of
balls of the same colour:
?

?

?
InColourGroup  SameColour  N extT o
InColourGroup  InColourGroup.InColourGroup

Here, we use the  connective to separate the base case and the inductive step
of this definition; the same could be done with our earlier definition of Above.
Two balls have the same colour if the colour of one is also that of the other:

SameColour

.= HasColour.HasColour



Having now defined which balls disappear, we define the remaining balls as the
complement thereof:

Remains

.= Disappears

, i.e., the above-relation as it will be in the
We now define the relation Above
next state. This will hold for any two remaining balls that were originally above
each other:
?

?

?
.= Above  (Remains  Remains)

Above

 as the intransitive relation of which Above
?

?

?
We can now define the relation U p
is the transitive closure:
?

?

?
U p

.= Above

  (Above
?

?

?
.Above
?

?

?
)

We define an auxiliary concept OnGround
form the bottom row in the new situation:

 as consisting of those balls that will
?

?

?
OnGround

.= Remains  Above



.Remains

. Let us first define when a ball x is in
All that remains now is to define Lef t
the column to the left of some other ball y. For those y that are on a height not
greater than that of x, this is the case if x is either directly to the left of y, or

J. Vennekens and M. Denecker

below a ball directly to the left of y, or above a ball directly to the left of y. To
cover that situation that y is heigher than xs, we also add the recursive case
that y is above a ball for which we already know that x is in its left column.

InLef tColumn Lef t
InLef tColumn Above.Lef t
InLef tColumn Above
.Lef t
InLef tColumn Lef tColumn.Above


?

?

?




"#

We now define Lef t

 as consisting of all pairs of balls such that (1) one ball
is in the column to the left of the other, and (2) both are on the same height:
?

?

?
Lef t

.= InLef tColumn

!

$

!
 ((OnGround

"#
  OnGround
?

?

?
)  U p
?

?

?
.(Lef t

.U p



$

))

(1)

(2)

Note that this too is an inductive definition, which proceeds along the rows of
the grid: the base case is the bottom row, whereas the inductive case defines
that x is to the left of y in the following situation:

x

y

This concludes our representation of the game. As this example shows,
ALCI(ID) can represent many different kinds of definitions (case based defini-
tions, non-inductive definitions, monotone inductive definitions, non-monotone
inductive definitions) in a uniform way in, leading to a clean and coherent
language.
6 Inference in ALCI(ID)
We lack space for a proof, but it is not hard to show that ALCI(ID) is undecid-
able. However, this does not mean that is cannot be used in practice.

6.1 Model Expansion

[13] considered the inference task of model expansion for FO(ID): given an interpretation S for some subset 0 of the alphabet  of a theory T , extend S
with an interpretation for the remaining symbols  \ 0, such that the resulting
interpretation is a model of T . Here, S is required to have a finite domain. Note
that, in general, a model expansion problem may have many different solutions,
because even though S has to fix the domain of discourse, it does not fix the
interpretation of  \ 0 in this domain, but only restrains it to satisfy T . This
form of inference is decidable for full FO(ID) and in fact captures the complexity
class NP.
?

?

?
To illustrate the usefulness of this inference task, let us consider again the

example of the previous section. Here, we defined the next state of a game (Lef t
) in terms of its old state (Lef t and U p) and a given move (Chosen). We
and U p
can therefore compute a new state of the game by performing model expansion
on the structure S for the alphabet 0 = {Lef t, U p, Chosen}. Because our
representation of the game defines all of its predicates except the ones in 0,
this computation can actually be done in polynomial times.
The IDP-system3 implements the task of model generation of FO(ID). A
program transforming ALCI(ID) syntax to input for this system is available.4
Together, these two programs are able to, for instance, use our formalizaton of
Section 5 to compute state transitions for this game.
6.2 Guarded ALCI(ID)
As discussed, there are interesting applications, that only require reasoning in a
fixed, finite domain and for which the undecidability of FO(ID) is therefore not
a problem. However, because there are of course also other cases, this section
will develop a decidable fragment of FO(ID).

This fragment is based on the guarded fragment of FO. We recall that an FO
formula  is guarded if every one of its quantified subformulas is either of the
form x G(x, y)  (x, y) or x G(x, y)  (x, y), where G(x, y) is an atom,
called the guard, such that the free variables f ree((x, y))  f ree(G(x, y)).

We now define a similar guarded fragment of FO(ID). This fragment allows
only theories consisting of precisely one definition and precisely one FO formula.

Definition 1. Let T be an FO(ID) theory, consisting of precisely one definition
 and one FO formula . T is guarded if

  is a guarded formula;
 for each rule x P (x)  , it holds that  is a guarded formula and x 

f ree();

 none of the guards is defined by .

Exploiting a theorem from [8], we can prove the following result.

Theorem 1. The guarded fragment of FO(ID) is decidable. More precisely, deductive reasoning for FO(ID) is 2exptime-complete.

Proof. Omitted for space.

This of course raises the question of how this guarded fragment of FO(ID) relates
to ALCI(ID). It is easy to see that neither is subsumed by the other. For instance,

.= P.P translates to

{x, y P (x, y)  z P (x, z)  P (z, y).},
http://www.cs.kuleuven.be/dtai/krr/software/idp.html
http://www.cs.kuleuven.be/joost/alc id.tar.gz

J. Vennekens and M. Denecker

which is not guarded. Conversely, the guarded fragment is not subsumed by
ALCI(ID) either, since, for instance, the latter only allows unary and binary
predicates, while the former allows arbitrary arities.
The two fragments do, however, have a significant intersection. Let us consider
a theory T in ALCI(ID) and examine which additional conditions can ensure
that its translation is guarded.
The guarded fragment of FO(ID) only allows theories to contain a single
definition, whereas an ALCI(ID) theory can have multiple definitions. In [17],
we examined when a set of definitions (i)1in can be merged into a single
equivalent definition ii. We showed that the following condition is sufficient.
Condition 1. There exists a preorder  on the predicates of the theory, such
that for all i and P  Def(i):
 if Q  Def(i) then P  Q;
 if Q appears in i but does not belong to Def(i), then P > Q (i.e., P  Q

and P  Q).

.=  or any definitions in which a rule R   appears.

By imposing this condition, we can merge all definitions into a single definition,
thus already satisfying that particular requirement of our guarded fragment.
Looking at the translation of ALCI(ID) into FO(ID), it is quite clear that the
only other cause for falling outside of the guarded fragment is the fact that
defined predicates might be used as guards.
Condition 2. For every construct R.C, R.C or R.S that appears in T , it
must be the case that R is not defined, i.e., T does not contain any formulas of
the form R
We will say that an ALCI(ID) theory is guarded if it satisfies both Condition 1
and Condition 2.
Theorem 2. Let T be a guarded ALCI(ID) theory and let T
merging all definitions in T into a single definition. Then T
T itself and belongs the guarded fragment of FO(ID).
We remark that our Condition 2 has a somewhat similar flavour to the decidable
fragment of SWRL that is formed by (strongly) safe rules [15]: a SWRL-rule
(i.e., Horn clause) is safe if every one of its variables appears in an atom whose
predicate is not used anywhere in the TBox (i.e., it may only appear in other
rules or in the ABox). This too requires that variables are guarded by atoms
about which there is not too much information present in the theory.

 be the result of
 is equivalent to

7 Related Work

The most widely known DL rule-language is currently that of SWRL [11], which
extends OWL with Horn clauses. Since its rules only state sufficient conditions,
and cannot express necessary ones, they cannot be used to define concepts.
Because definitions are an important feature of DL (see footnote on p.386),
?

?

?
this is a curious lack. ALCI(ID), by contrast, also allows the definitional rule
construct , in addition to . Moreover, it also allows more that just Horn
clauses, since the body of a rule may contain negation and quantifiers.

In [6], a combination of DL and LP under the well-founded semantics is in-
vestigated, while [7] presents an integration of DL and ASP. Unlike FO(ID)s
semantic integration of LP and DL, these two approaches foster a strong separation between the two components: essentially, they allow a logic program to
pose queries to a description logic theory, with the latter acting more-or-less as
a black box towards the former. In contrast, FO(ID) provides a full semantic
integration in which both both logic programs and description logic axioms are
first-class citizens.
Description logic programs [9] and DL+log [16] are two strong integrations,
which both consider only a quite restricted language, with Grosof et al. focusing
on the intersection, rather than the union, of DL and LP, and Rosati only considering Datalog. By contrast, FO(ID) allows full first-order logic in the body
of rules, using the machinery of the well-founded semantics to properly handle
negation.

[3], [14] and [10] both provide strong semantic integrations for a more general
kind of rules, with [10] also defining a guarded fragment that, like ours, can
be mapped into guarded fixpoint logic. The main feature that distinguishes our
approach from these is of a KR nature. We offer rules that have a clear and
intuitive interpretation as definitional rules. On the one hand, this means that it
easy to explain the total information content of such a rule: it represents a case
of an (inductive) definition. On the other hand, we also have clear guidelines as
to what they should be used for: the definitional rules should be used to define
concepts, and other statements (regular inclusions) can serve to state additional
properties, such conditions that are only sufficient. The KR picture for the other
approaches is less clear.

8 Conclusions and Future Work

In this paper, we have investigated the extension of DL with rules that is induced
by FO(ID). We first argued that this is quite natural for the following reasons:

 There is an appealing match between the intuitive notion of a case in an
inductive definition and the formal construct of a definitional rule in FO(ID);
 Since non-inductive definitions are already a key feature of DL, it makes
sense to exploit this match by adding definitional rules to DL, in order to
extend the class of definitions that can be represented.

Motivated by these arguments, we have defined a fragment ALCI(ID) of FO(ID),
which offers a DL-like syntax for representing (inductive) definitions. For FO(ID),
and therefore also for ALCI(ID), there exist useful inference tasks, such as model
expansion, that can be performed efficiently (see Section 6. This is despite the fact
that the language as a whole is undecidable for deductive inference. We have defined a decidable guarded fragment of ALCI(ID). A more comprehensive analysis

J. Vennekens and M. Denecker

of this and other decidable fragments of FO(ID) is left for future work. The goal
of the current paper is not to present a single DL rule-language that is suitable
for all purposes, but rather to point towards FO(ID) in general as an interesting
foundation from which such languages can be derived.
