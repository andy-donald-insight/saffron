Hybrid Reasoning with Forest Logic Programs

Cristina Feier and Stijn Heymans

Knowledge-Based Systems Group, Institute of Information Systems

Favoritenstrasse 9-11, A-1040 Vienna, Austria

Vienna University of Technology
{feier,heymans}@kr.tuwien.ac.at

Abstract. Open Answer Set Programming (OASP) is an attractive
framework for integrating ontologies and rules. Although several decidable fragments of OASP have been identified, few reasoning procedures
exist. In this paper, we provide a sound, complete, and terminating algorithm for satisfiability checking w.r.t. forest logic programs, a fragment
where rules have a tree shape and allow for inequality atoms and con-
stants. We further introduce f-hybrid knowledge bases, a hybrid framework where SHOQ knowledge bases and forest logic programs co-exist,
and we show that reasoning with such knowledge bases can be reduced to
reasoning with forest logic programs only. We note that f-hybrid knowledge bases do not require the usual (weakly) DL-safety of the rule compo-
nent, providing thus a genuine alternative approach to hybrid reasoning.

1 Introduction

Integrating Description Logics (DLs) with rules for the Semantic Web has received considerable attention with approaches such as Description Logic Programs [7], DL-safe rules [17], DL+log [19], dl-programs [3], Description Logic
Rules [13], and Open Answer Set Programming (OASP) [11]. OASP combines
attractive features from the DL and the Logic Programming (LP) world: an
open domain semantics from the DL side allows for stating generic knowledge,
without the need to mention actual constants, and a rule-based syntax from the
LP side supports nonmonotonic reasoning via negation as failure.

Several decidable fragments of OASP were identified by syntactically restricting the shape of logic programs, while carefully safe-guarding enough expressiveness for integrating rule- and ontology-based knowledge. Notable fragments
are Conceptual Logic Programs (CoLPs) [9] that are able to simulate reasoning
in the DL SHIQ and Forest Logic Programs (FoLPs) [10] that are expressive
enough to deal with SHOQ. Note that both SHOQ and SHIQ are close family
of SHOIN (D), the DL underlying the Web Ontology language OWL-DL [21].
A serious shortcoming of these decidable fragments is their lack of effective reasoning procedures. In [5], we took a first step in mending this by providing a

 This work is partially supported by the Austrian Science Fund (FWF) under the
projects P20305 and P20840, and by the European Commission under the project
OntoRule (IST-2009-231875).

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 338352, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
sound and complete algorithm for simple CoLPs. Simple CoLPs restrict CoLPs
by disallowing the use of inverse predicates, inequality and restricting the literal
cyclity, but that are still expressive enough to simulate the DL ALCH.

In this paper, we extend the algorithm of [5] to Forest Logic Programs, an
extension of simple CoLPs with constants and inequality and no cyclicity re-
striction. FoLPs are able to simulate the DL SHOQ. They serve as well as an
underlying integration vehicle for ontologies and rules. In order to illustrate this,
we define f-hybrid knowledge bases (fKBs), consisting of a SHOQ knowledge base
and a rule component that is a FoLP, with a nonmonotonic semantics similar to
the semantics of g-hybrid knowledge bases [8], r-hybrid knowledge bases [20], and
DL+log [19]. Our approach differs in two points with current other proposals:
(1) In contrast with Description Logic Programs, DL-safe rules, and Description
Logic Rules, fKBs have, in line with traditional logic programming, a minimal
model semantics for the rule component, thus allowing for nonmonotonic reason-
ing. (2) To ensure effective reasoning, we do not rely on a (weakly) DL-safeness
condition such as [17,19,20], which restricts the interaction of the rule component
with the DL component. Instead, we rely on a translation to FoLPs.

The major contributions of the paper can be summarized as follows:

 We define in Section 4 a nondeterministic algorithm for deciding satisfiability
w.r.t. FoLPs, inspired by tableaux-based methods from DLs. We show that
this algorithm is terminating, sound, complete, and runs in 2-nexptime.
The algorithm is non-trivial from two perspectives: both the minimal model
semantics of OASP, compared to the model semantics of DLs, as well as
the open domain assumption, compared to the closed domain assumption of
ASP [6], pose specific challenges.
 We show in Section 5 that FoLPs are expressive enough to simulate the DL
SHOQ with fKBs, an alternative characterization for hybrid representation
and (nonmonotonic) reasoning of knowledge, that supports a tight integration of ontologies and rules.

Extended examples, explanations, and detailed proofs, can be found in [4].

2 Preliminaries

We recall the open answer set semantics [11]. Constants a, b, c, . . ., variables
x, y, . . ., terms s, t, . . ., and atoms p(t1, . . . , tn) are as usual. We allow for equality
atoms s = t. A literal is an atom L or a negated atom not L. An inequality literal
not (s = t) will often be denoted with s = t. An atom (literal) that is not an
equality atom (inequality literal) will be called a regular atom (literal). For a set
 of literals or (possibly negated) predicates, + = {l | l  } and 
 = {l |
not l  }. For a set X of atoms, not X = {not l | l  X}. For a set of (possibly
negated) predicates , (x) = {a(x) | a  } and (x, y) = {a(x, y) | a  }.
A program is a countable set of rules   , where  is a finite set of regular
literals and  is a finite set of literals. The set  is the head and represents
a disjunction, while  is the body and represents a conjunction. If  = , the
?

?

?
rule is called a constraint. Free rules are rules q(t1, . . . , tn)  not q(t1, . . . , tn) 
for terms t1, . . . , tn; they enable a choice for the inclusion of atoms. We call a
predicate q free if there is a q(x1, . . . , xn)  not q(x1, . . . , xn) , with variables
x1, . . . , xn. Atoms, literals, rules, and programs that do not contain variables are
ground. For a rule or a program X, let cts(X) be the constants in X, vars(X) its
variables, and preds(X) its predicates with upreds(X) the unary and bpreds(X)
the binary predicates. A universe U for P is a non-empty countable superset of
the constants in P : cts(P )  U. We call PU the ground program obtained from
P by substituting every variable in P by every element in U. Let BP (LP ) be
the set of regular atoms (literals) that can be formed from a ground program P .
An interpretation I of a ground P is a subset of BP . We write I |= p(t1, . . . , tn)
if p(t1, . . . , tn)  I and I |= not p(t1, . . . , tn) if I |= p(t1, . . . , tn). Also, for ground
terms s, t, we write I |= s = t if s = t and I |= not s = t or I |= s = t if s = t.
For a set of ground literals X, I |= X if I |= l for every l  X. A ground rule
r :    is satisfied w.r.t. I, denoted I |= r, if I |= l for some l   whenever
I |= . A ground constraint   is satisfied w.r.t. I if I |= .

For a ground program P without not, an interpretation I of P is a model of
P if I satisfies every rule in P ; it is an answer set of P if it is a subset minimal
model of P . For ground programs P containing not, the GL-reduct [6] w.r.t. I
is defined as P I, where P I contains +  + for    in P , I |= not 
 and
I |= 

. I is an answer set of a ground P if I is an answer set of P I.

Below, a program is assumed to be a finite set of rules; infinite programs only
appear as byproducts of grounding with an infinite universe. An open interpretation of a program P is a pair (U, M) where U is a universe for P and M is an
interpretation of PU . An open answer set of P is an open interpretation (U, M)
of P with M an answer set of PU. An n-ary predicate p in P is satisfiable if
there is an open answer set (U, M) of P s. t. p(x1, . . . , xn)  M.
We introduce notation for trees which extend those in [23]. Let  be a concatenation operator between sequences of constants or natural numbers. A tree
T with root c (Tc), where c is a specially designated constant, has as nodes
sequences of the form c  s, where s is a (possibly empty) sequence of positive
integers formed with the concatenation operator; for x  d  T , d  N, we have
that x  T . For x  T , we call succT (x) = {x  n  T | n  N
}1, successors of
x. The set AT = {(x, y) | x, y  T,n  N : y = x n} is the set of arcs of a tree
T . For x, y  T , we say that x <T y iff x is a prefix of y and x = y.
A forest F is a set of trees {Tc | c  C}, where C is a set of distinguished
constants. NF = TF T and AF = TF AT are the set of nodes and the set of
arcs of a forest F . For x  F , its successors in F are succF (x) = succT (x) for
x  T . Let <F be a strict partial order relationship on the set of nodes NF of a
forest F where x <F y iff x <T y for some tree T in F . An extended forest EF
is a tuple (F, ES ) where F = {Tc | c  C} is a forest and ES  NF  C. ES
extends the successor relation: succEF (x) = {y | y  succF (x) or (x, y)  ES}.
A path in EF is a sequence of nodes linked by the successor relation. We denote
by NEF = NF the nodes of EF and by AEF = AF  ES its arcs.

 is the set of positive integers.
?

?

?
Finally, for a directed graph G, pathsG is the set of pairs of nodes for which

there exists a path in G from the first node in the pair to the second one.

3 Forest Logic Programs

Forest Logic Programs (FoLPs) were introduced in [10] as a syntactical fragment
of OASP. FoLPs are a generalization of Conceptual Logic Programs [9] which
are logic programs with tree-shaped rules for which satisfiability checking under
the open answer set semantics is decidable. FoLPs impose the same structure
for rules as CoLPs, but also allow for constants.

Definition 1. A forest logic program (FoLP) is a program with only unary and
binary predicates, and such that a rule is either a free rule a(s)  not a(s) 
or f (s, t)  not f (s, t)  , where s and t are terms such that if s and t are both
variables, they are different 2, a unary rule

r : a(s)  (s), (m(s, tm), m(tm))1mk , 

(1)
where s and tm, 1  m  k, are terms (again, if both s and tm are variables,
they are different; similarly for ti and tj), where

{ti = tj} and {=}  m =  for 1  m  k,

= , i.e., for variables ti there is a positive atom that

1.  

1i=jk

2. ti  vars(r) : +
i
connects s and ti,

or a binary rule

f (s, t)  (s), (s, t), (t)

(2)
with {=}   =  and + =  if t is a variable (s and t are different if both are
variables), or a constraint  a(s) or  f (s, t) where s and t are different if
both are variables).
Constraints can be left out without losing expressiveness:  body can be replaced by a rule of the form co(x )  not co(x ), body, for a new predicate co. As
their name suggests FoLPs have the forest model property:
Definition 2. Let P be a program. A predicate p  upreds(P ) is forest satisfiable w.r.t. P if there is an open answer set (U, M) of P and there is an extended
forest EF  ({T}  {Ta | a  cts(P )}, ES), where  is a constant, possibly one
of the constants appearing in P 3, and a labeling function L : {T}  {Ta | a 
cts(P )}  AEF  2preds(P ) s. t.
 U = NEF , and
 p  L(),
2 A rule f(X, X)  not f(X, X)  is not allowed.
3 Note that in this case T  {Ta | a  cts(P )}. Thus, the extended forest contains for
every constant from P a tree which has as root that specific constant and possibly,
but not necessarily, an extra tree with unidentified root node.
?

?

?
 z  i  T  EF , i > 0, iff there is some f(z, z  i)  M, z  Tx, and
 for y  T  EF , q  upreds(P ), f  bpreds(P ), we have that

 q(y)  M iff q  L(y), and
 f(y, u)  M iff (u = y  i  u  cts(P ))  f  L(y, u).

We call such a (U, M) a forest model and a program P has the forest model
property if the following property holds: if p  upreds(P ) is satisfiable w.r.t. P
then p is forest satisfiable w.r.t. P .

Proposition 1. FoLPs have the forest model property.

In [5], we introduced the class of simple Conceptual Logic Programs. It is easy
to see that every simple CoLP is an FoLP. As satisfiability checking w.r.t. simple
Conceptual Logic Programs is exptime-hard, the following property follows:

Proposition 2. Satisfiability checking w.r.t. FoLPs is exptime-hard.

4 An Algorithm for Forest Logic Programs

In this section, we define a sound, complete, and terminating algorithm for satisfiability checking w.r.t. FoLPs. In [10] it has been shown that several restrictions
of FoLPs which have the finite model property are decidable, but there was no
result so far regarding the whole fragment. Thus, the algorithm described in this
section also establishes a decidability result for FoLPs. The algorithm also relies
on the finite model property of FoLPs the proof of which is one of the main steps
of the completeness proof.
For every non-free predicate q and a FoLP P , let Pq be the rules of P that have
q as a head predicate. For a predicate p, p denotes p or not p, whereby multiple
occurrences of p in the same context will refer to the same symbol (either p
or not p). The negation of p (in a given context) is p, that is, p = not p if
p = p and p = p if p = not p.

The basic data structure for our algorithm is a completion structure.

Definition 3. A completion structure for a FoLP P is a tuple EF , G, ct, st,
bl where EF = (F, ES ) is an extended forest which together with the labeling
functions ct and st and the set bl of blocking nodes is used to represent/construct
a tentative forest model. G = N, A is a directed graph with nodes N  BPNEF
and edges A  N  N which is used to keep track of dependencies between
elements of the constructed model (the positive atom dependency graph of PNEF ):
N represents the tentative model, while NEF represents the tentative universe.
The content function ct : NEF  AEF  2preds(P )not (preds(P )) maps a node
to a set of (possibly negated) unary predicates and an arc to a set of (possibly
negated) binary predicates such that ct(x)  2upreds(P )not(upreds(P )) if x  NEF ,
and ct(x)  2bpreds(P )not(bpreds(P )) if x  AEF . Every presence of a non-negated
predicate symbol p in the content of some node/arc x of EF indicates that p(x)
is part of the tentative model represented by EF .
?

?

?
The status function st : {(x, q) | q  ct(x), x  NEF  AEF}  {(x, q) |
not q  ct(x), x  AEF}  {(x, not q, r) | not q  ct(x), x  NEF , r  Pq} 
{exp, unexp} attaches to every (possibly negated) predicate which appears in the
content of a node/arc x of EF a status value which indicates whether the predicate has already been expanded in that node/edge. As it will be indicated later,
the completion structure is evolved such that the presence/absence of any predicate symbol in the content of some node/arc is justified, so it is necessary to
keep track which predicate symbols have already been justified in every node/arc
of EF . As negative unary predicates have to be justified by showing that no rule
which defines them can be applied and this can be done in several steps, the
function takes as an argument also a rule for such negated predicate symbols.
An initial completion structure for checking satisfiability of a unary predicate
p w.r.t. a FoLP P is a completion structure EF , G, ct, st, bl with EF =
(F, ES ), F = {T}{Ta | a  cts(P )}, where  is a constant, possibly in cts(P ),
Tx = {x}, for x  {}  cts(P ), ES = , G = V, E, V = {p()}, E = , and
ct() = {p}, st(, p) = unexp, bl = .
The forest is initialized with single-node trees with roots constants from P and,
possibly, a new single-node tree with an anonymous root. The anonymous root,
in case it exists, contains p, the predicate to satisfy. Otherwise the root of one
of the other trees contains p. G is a graph with a single vertex p().

Next, we will show how to evolve an initial completion structure for checking
the satisfiability of a unary predicate p w.r.t. a FoLP P by means of expansion
rules to a complete clash-free structure that corresponds to a finite representation of an open answer set in case p is satisfiable w.r.t. P . Applicability rules
state the necessary conditions to apply these expansion rules.

4.1 Expansion Rules

The expansion rules update the completion structure whenever justifying a literal
l in the current model leads to the presence of new literal p(z) in the model.
Thus, p is inserted in the content of z if it is not already there and marked
as unexpanded (w.r.t. all rules which define p in case it is a negative instance
and z is a node in EF ). Also, in case p(z) is an atom, it is ensured that it is a
node in G; moreover, if l is also an atom, a new arc from l to p(z) is created
to indicate the dependency between l and p(z) in the model. Formally:
 if p / ct(z), then ct(z) = ct(z)  {p} and st(z,p) = unexp in case
p = p or b  bpreds(()P ) and st(z,p, r) = unexp, for all r  Pp in case
p = not p and p  upreds(()P ),
 if p = p and p(z) / V , then V = V  {p(x)},
 if l  BPNEF and p = p, then E = E  {(l,p(z))}.
As a shorthand, we denote this sequence of operations as update(l,p, z); more
general, update(l, , z) for a set of (possibly negated) predicates , denotes a 
, update(l,a, z).
In the following, for a completion structure EF , G, ct, st, bl, let x  NEF
and (x, y)  AEF be the node, resp. arc, under consideration.
?

?

?
(i) Expand unary positive. For a unary positive (non-free) p  ct(x) s. t.
st(x, p) = unexp,
 nondeterministically choose a rule r  Pp of the form (1) s. t. s unifies with

x. The rule will motivate p(x) in the tentative open answer set.

 for the  in the body of r, update(p(x), , x),
 pick up (or define when needed) k successors for x, (ym)1mk, s. t.:

 for every 1  i, j  k s. t. ti = tj  : yi = yj;
 for every 1  m  k: ym  succEF (x) or ym is a new EF -successor of x:
 ym = x  n, n  N and x  n / succEF (x). Update Tc, where x  Tc:
Tc = Tc  {ym}, or
 ym = a, where a  cts(P ) and a / succEF (x); ES = ES  (x, a).

 for every successor ym of x, 1  m  k: update(p(x), m, (x, ym)) and
 set st(x, p) = exp.
(ii) Expand unary negative. Justifying a negative unary predicate not p 
ct(x) (the absence of p(x) in the constructed model) means refuting the body
of every ground rule which defines p(x). The body of such a rule is refuted either

update(p(x), m, ym).

 locally: a literal from (x) has to be refuted which amounts to a certain

q   not appearing in ct(x), or
 depending on the particular grounding of the rule, in an outgoing arc of x,
or in a successor of x: thus, some f  m should not appear in ct(x, yj)
or some q  m should not appear in ct(yj), where yj  succF (x), or

 if there is no valid assignment of successors of x to successors of s in the rule

which fulfill the inequalities in the rule.

Formally, for a unary negative (non-free) not p  ct(x) and a rule r  Pp of
the form (1) s. t. x unifies with s (s is the term from the head of the rule) and
st(x, not p, r) = unexp do one of:
 choose a q  , update(not p(x),q, x), and set st(x, not p, r) = exp, or
 if for all p  upreds(P ), p  ct(x) or not p  ct(x), and for all p  ct(x),
st(p, x) = exp, then for all yi1, . . . , yik s. t. (1  ij  n)1jk, where
succEF (x) = {y1, . . . yn}: if for all 1  j, l  k, tj = tl    yij = yil, then
do one of the following:
 for some m, 1  m  k, pick up a binary (possibly negated) predicate
symbol f from m and update(not p(x),f, (x, yim)), or
 for some m, 1  m  k, pick up a unary negated predicate symbol not q
Set st(x, not p, r) = exp.

from m and update(not p(x), q, yim).

One can see that once the body of a ground version of a unary rule r  Pp, for
which the head term s is substituted with the current node x, is locally refuted,
the bodies of all ground versions of this rule, for which s is substituted with x are
locally refuted, too. For the other two refutation cases all possible groundings
of a rule have to be considered and this is not possible until all the successors
?

?

?
of x are known. This is the case when all positive predicates in the content of
the current node have been expanded and no positive predicate will be further
inserted in ct(x):then, an iteration over all possible groundings of the rule r is
triggered. For every grounding if the inequality constraints are violated the body
of that particular instantiation of the rule is already refuted; otherwise, one of
the body literals from the non-local part of the rule (s or s) has to be refuted.
(iii) Choose a unary predicate. If for all a  ct(x), st(x, a) = exp or a is free,
and for all (x, y)  AEF , and for all f  ct(x, y), st((x, y),f) = exp or f is
free, and there is a p  upreds(P ) s. t. p / ct(x) and not p / ct(x), then add p to
ct(x) with st(x, p) = unexp or add not p to ct(x) with st(x, not p, r) = unexp,
for every rule r  Pp.

In other words, if there is a node x for which all positive predicates in its
content and all predicates in the contents of its outgoing arcs are free or have already been expanded and if there are still unary predicates which do not appear
in ct(x), one has to pick such a unary predicate symbol p and inject either p or
not p in ct(x). This is needed for consistency: it does not suffice to find a justification for the predicate to satisfy, but one also has to show that this justification
is part of an actual open answer set, which is done by effectively constructing
it. We do not impose that all negative predicate symbols are expanded as that
would constrain all the ensuing literals to be locally refuted.

Similarly to rules (i), (ii), and (iii) we define the expansion rules for binary
predicates: (iv) Expand binary positive, (v) Expand binary negative, and (vi)
Choose binary.

4.2 Applicability Rules

The applicability rules restrict the use of the expansion rules.
(vii) Saturation. A node x  NEF is saturated if for all p  upreds(P ), p 
ct(x) or not p  ct(x), and no q  ct(x) can be expanded with rules (i-iii),
and for all (x, y)  AEF and p  bpreds(P ), p  ct(x, y) or not p  ct(x, y),
and no f  ct(x, y) can be expanded with (iv-vi). No expansions should
be performed on a node from NEF which does not belong to cts(P ) until its
predecessor is saturated (constants can have more than one predecessor in the
completion, including themselves).
(viii) Blocking. A node x  NEF is blocked if there is an ancestor y of x in
F , y <F x, y  cts(P ), s.t. ct(x)  ct(y) and the set pathsG(x, y) = {(p, q) |
(p(x), q(y))  pathsG} is empty. We call (y, x) a blocking pair and update bl:
bl = bl{(y, x)}. No expansions can be performed on a blocked node. Intuitively,
if there is an ancestor y of x which is not a constant, whose content includes the
content of x, and there are no paths in G from a positive literal p(x) to another
positive literal q(y) one could reuse the justification for x when dealing with y.
(ix) Redundancy. A node x  NEF is redundant if it is saturated and there
2  1), and p = |upreds(P )|,
are k ancestors of x in F , (yi)1ik, where k = 2p(2p
s. t. ct(x) = ct(yi) and (yi, x) is not a blocking pair for every 1  i  n. In

C. Feier and S. Heymans

other words, a node is redundant if there are other k nodes on the same branch
with the current node which all have content equal to the content of the current
node. The presence of a redundant node stops the expansion process. In the
completeness proof we show that any forest model of a FoLP P which satisfies p
can be reduced to another forest model which satisfies p and has at most k + 1
nodes with equal content on any branch of a tree from the forest model, and
furthermore the (k + 1)st node, in case it exists, is blocked. One can thus search
for forest models only of the latter type. This rule exploits that result: we discard
models which are not in this shrunk search space.

4.3 Termination, Soundness, and Completeness
A completion structure is contradictory if for some x  NEF and a  upreds(P ),
{a, not a}  ct(x) or for some (x, y)  AEF and f  bpreds(P ), {f, not f} 
ct(x, y). A complete completion structure for a FoLP P and a p  upreds(P ),
is a completion structure that results from applying the expansion rules to the
initial completion structure for p and P , taking into account the applicability
rules, s. t. no expansion rules can be further applied. Also, a complete completion
structure CS = EF , G, ct, st, bl is clash-free if: (1) CS is not contradictory
(2) EF does not contain redundant nodes (3) G does not contain cycles.

We show that an initial completion structure for a unary predicate p and a
FoLP P can always be expanded to a complete completion structure (termina-
tion), that, if p is satisfiable w.r.t. P , there is a clash-free complete completion
structure (soundness), and, finally, that, if there is a clash-free complete completion structure, p is satisfiable w.r.t. P (completeness).
Proposition 3 (termination). Let P be FoLP and p  upreds(P ). Then, one
can construct a finite complete completion structure by a finite number of applications of the expansion rules to the initial completion structure for p w.r.t. P ,
taking into account the applicability rules.

Proof Sketch. One cannot introduce infinitely many successors to a node, as the
arity of the trees in the completion structure is bound by the number of unary
predicates in P and the number of variables in unary rules. Also, every infinite
path in the extended forest eventually contains |k + 1| saturated nodes with
equal content, where k is as in the redundancy rule, and thus either a blocked

or a redundant node, which is not further expanded.
Proposition 4 (soundness). Let P be a FoLP and p  upreds(P ). If there is
a clash-free complete completion structure for p w.r.t. P , then p is satisfiable
w.r.t. P .
Proposition 5 (completeness). Let P be a FoLP and p  upreds(P ). If p is
satisfiable w.r.t. P , then there exists a clash-free complete completion structure
for p w.r.t. P .
?

?

?
4.4 Complexity Results
Let CS = EF , G, ct, st, bl be a complete completion structure. Every path
of a tree in EF contains at most k + 1 nodes with equal content (as suggested by
the applicability rules (viii) and (ix)), where k is as defined in the redundancy
rule; thus, there are at most (k + 1)2n nodes on every such path, where n =
|upreds(P )|. The branching of every tree is bound by a constant q which is a
linear function of the number of variables in unary rules from P . Thus, there are
at most q(k+1)2n nodes in a tree, and at most (c+ 1)q(k+1)2n nodes in EF , where
c is the number of constants present in the program at hand. So the amount of
nodes in CS is double exponential in the size of P , and the algorithm runs in
2-nexptime.

Note that such a high complexity is expected when dealing with tableaux-like
algorithms. For example in Description Logics, although satisfiability checking
in SHIQ is exptime-complete, practical algorithms run in 2-nexptime [22].

5 F-Hybrid Knowledge Bases

Note that we assume the unique name assumption by imposing that o

In this section, we introduce f-hybrid knowledge bases (fKBs), a formalism that
combines KBs expressed in the Description Logic SHOQ with FoLPs. We assume
the reader is familiar with SHOQ; details can be found in [4].
I = o
for individuals o  I. Individuals are thus assumed to be part of any domain 
I.
OWL does not have the unique name assumption [21], and thus different individuals can point to the same resource. However, the open answer set semantics
gives a Herbrand interpretation to constants and for consistency we assume that
also DL nominals are interpreted this way.
Example 1. Consider the SHOQ KB  with Father  child .Human  Female
and {john}  ( 2child .Human) as axioms. Intuitively, the first terminological
axiom says that fathers have a human child and are not female. The second axiom
says that john has not more than 2 human children.
Definition 4. An f-hybrid knowledge base (fKB) is a pair , P where  is a
SHOQ KB and P is a FoLP.
The predicate symbols in P can be concept or role names from , in which
case the corresponding atoms/literals are called DL atoms/literals, but w.l.o.g.
we assume they do not coincide with complex concept or role descriptions. Note
that we do not impose Datalog safeness or (weakly) DL safeness [18,20,19] for the
rule component. Intuitively, the restricted shape of FoLPs suffices to guarantee
decidability; FoLPs are in general neither Datalog safe nor weakly DL-safe; we
discuss the relation with weakly DL-safeness in detail in Section 6.
Example 2. An fKB , P, with  as in Ex. 1 and P the FoLP unhappy(X ) 
not Father(X ) indicates that persons that are not fathers are unhappy, where
Father(X ) is a DL literal.
?

?

?
(a) if there exists a DL literal in the head of the form A(t1, . . . , tn) with

I, or not A(t1, . . . , tn) with (t1, . . . , tn)  A
I, or not A(t1, . . . , tn) with (t1, . . . , tn)  A

Similarly as in [8], we define, given a DL interpretation I = (
,I) and a

ground program P , the projection (P,I) of P with respect to I, as follows: for
every rule r in P ,
(t1, . . . , tn)  A
I, then delete r,
(b) if there exists a DL literal in the body of the form A(t1, . . . , tn) with
(t1, . . . , tn)  A
I, then delete r, (c)
Intuitively, the projection evaluates
otherwise, delete all DL literals from r.
the program with respect to I by removing (evaluating) rules and DL literals
consistently with I; conceptually this is similar to the reduct, which removes
rules and negative literals consistently with an interpretation of the program.
Definition 5. Let , P be an fKB. An interpretation of , P is a tuple
(U,I, M) s. t. U is a universe for P , I = (U,I) is an interpretation of ,
and M is an interpretation of (PU ,I). Then, (U,I, M) is a model of an fKB
, P if I is a model of  and M is an answer set of (PU ,I).
The semantics of a fKB , P is s. t. if  = , a model of , P corresponds
to an open answer set of P , and if P = , a model of , P corresponds to a
DL model of . In this way, the semantics of fKBs is nicely layered on top of
both the DL semantics and the open answer set semantics.
Example 3. For the fKB , P in Example 2, take a universe U = {john, x}
and I s. t. Father
= {(x, john)}, Female
= U,
= john. It is easy to see that I = (U,I) is indeed a model of . With
and john
M = {unhappy(john)}, one can check that (U,I, M) is a model of , P.
For p a concept expression from  or a predicate from P , we say that p is satisfiable w.r.t. (, P ) if there is a model (U,I, M) s. t. p
I =  or p(x1, . . . , xn)  M
for some x1, . . . , xn in U, resp.

= , Human

We can reduce satisfiability checking w.r.t. fKBs to satisfiability checking of
FoLPs only. Roughly, for each concept expression one introduces a new predicate
together with rules that define the semantics of the corresponding DL construct.
Constraints then encode the axioms, and the first-order interpretation of DL
concept expressions is simulated using free rules.
For the formal translation, we define the closure clos() of a SHOQ KB 
as the smallest set satisfying the following conditions:
 for each C  D an axiom in  (role or terminological), {C, D}  clos(),
 for each Trans(R) in , {R}  clos(),
 for every D in clos(), we have
 if D = D1, then {D1}  clos(),
 if D = D1  D2, then {D1, D2}  clos(),
 if D = D1  D2, then {D1, D2}  clos(),
 if D = R.D1, then {R, D1}  {S.D1 | S R, S = R, Trans(S)  } 
clos(),
 if D = R.D1, then {R.D1}  clos(),
 if D = ( n Q.D1), then {( n + 1 Q.D1)}  clos(),
 if D = ( n Q.D1), then {Q, D1}  clos().

= {x}, child
?

?

?
, . . . , (un, y)  S

Hybrid Reasoning with Forest Logic Programs

Concerning the addition of the extra S.D1 for R.D1 in the closure, note that
x  (R.D1)I holds if there is some (x, y)  R

1 , i.e., there is
some S R with S transitive (or S = R) s. t. (x, u0)  S
I with
1 . This amounts to x  (S.D1)I. Thus, in the open answer set setting,
y  D

we have that R.D1(x) is in the open answer set if R(x, y) and D1(y) hold or
S.D1(x) holds for some transitive subrole S of R. The predicate S.D1 will be
defined by adding recursive rules, hence the inclusion of such predicates in the
closure. Furthermore, for a ( n Q.D1) in the closure, we add {( n + 1 Q.D1)},
since we will base our definition of the former predicate on the DL equivalence
( n Q.D1)  ( n + 1 Q.D1).

We define the FoLP (), obtained from the SHOQ KB , as follows:
 For each terminological axiom C  D  , add  C (X ), not D(X ).
 For each role axiom R  S  , add  R(X , Y ), not S (X , Y ).
 Next, we distinguish between the types of concept expressions that appear

in clos(). For each D  clos():
 if D is a concept name, add D(X )  not D(X )  ,
 if D is a role name, add D(X , Y )  not D(X , Y )  ,
 if D = {o}, add D(o)  ,
 if D = E, add D(X )  not E(X ),
 if D = E  F , add D(X )  E(X ), F (X ),
 if D = E  F , add D(X )  E(X ) and D(X )  F (X ),
 if D = Q.E, add D(X )  Q(X , Y ), E(Y ) (5), and for all S Q, S = R,
with Trans(S)  , add rules D(X )  (S .E)(X ) (6). If Trans(Q)  ,
we further add the rule D(X )  Q(X , Y ), D(Y ) (7),

 if D = R.E, add D(X )  not (R.E)(X )
 if D = ( n Q.E), add D(X )  not ( n + 1 Q .E)(X ),
 if D = ( n Q.E), add
D(X )  Q(X , Y1 ), . . . ,Q(X , Yn), E(Y1 ), . . . ,E(Yn), (Yi =Yj )1i=jn
Rule (5) is what one would intuitively expect for the exists restriction. How-
ever, in case Q is transitive this rule is not enough. Indeed, if Q(x, y), Q(y, z),
E(z) are in an open answer set, one expects (Q.E)(x) to be in it as well if
Q is transitive. However, we have no rules enforcing Q(x, z) to be in the open
answer set without violating the FoLP restrictions. We can solve this by adding
to (5) rule (6) s. t. the chain Q(x, y), Q(y, z), with E(z) in the open answer set
correctly deduces D(x). It may still be that there are transitive subroles of Q
that need the same recursive treatment as above. To this end, we introduce rule
(7). We do not need such a trick with the number restrictions since the roles Q in
a number restriction are required to be simple, i.e., without transitive subroles.
Proposition 6. Let , P be a SHOQ KB. Then, ()  P is a FoLP, and
has a size that is polynomial in the size of .
Proposition 7. A predicate p is satisfiable w.r.t. a fKB , P iff p is satisfiable w.r.t. ()  P .

C. Feier and S. Heymans

Proposition 7 also holds for satisfiability checking of concept expressions C:
introduce a rule p(X)  C(X) in P and check satisfiability of p.

Using the translation from fKBs to FoLPs in Proposition 7 and the polynomiality of this translation (Proposition 6), together with the complexity of the
algorithm for satisfiability checking w.r.t. FoLPs, we have the following result:
Proposition 8. Satisfiability checking w.r.t. fKBs is in 2-nexptime.
As satisfiability checking of ALC concepts w.r.t. an ALC TBox (note that ALC
is a fragment of SHOQ) is exptime-complete ([1, Chapter 3]), we have that
satisfiability checking w.r.t. fKBs is exptime-hard.
Proposition 9. Satisfiability checking w.r.t. fKBs is exptime-hard.

6 Discussion and Outlook
We compare fKBs to the r-hybrid KBs from [20], which extends DL+log from
[19] with inequalities and negated DL atoms.

In [20], a r-hybrid KB consists of a DL knowledge base and a disjunctive
Datalog program where each rule is weakly DL-safe: (a) every variable in the
rule appears in a positive atom in the body of the rule (Datalog safeness), and
(b) every variable either occurs in a positive non-DL atom in the body of the
rule, or it only occurs in positive DL atoms in the body of the rule.

The semantics of r-hybrid and fKBs correspond to a large extent. A main
difference is that fKBs do not make the standard names assumption, in which
basically the domain of every interpretation is the same infinitely countable set
of constants. Some more key differences to note:

 We do not require Datalog safeness neither do we require weakly DL-safeness.
Indeed, fKBs may have a rule component that is not weakly DL-safe. Take
the fKB , P from Example 2 with P . The atom Father(X ) is a DLatom s. t. the rule is neither Datalog safe nor weakly DL-safe. Modifying the
program to unhappy(X )  Human(X ), not Father(X ) leads to a Datalog
safe program, however, it is still not weakly DL-safe as X is not appearing
only in positive DL-atoms. On the other hand, both the above rules are
FoLPs and thus constitute a valid component of an fKB.

 For r-hybrid KBs, due to the safeness conditions, it suffices for satisfiability
checking to ground the rule component with the constants appearing explicitly in the KB.4 One does not have such a property for fKBs. Consider the
fKB , P with  =  and the program P with rules a(X )  not b(X )
and b(0 )  . This program is a FoLP, but it is not Datalog safe nor is it
weakly DL-safe. Grounding only with the constants in the program yields
that a is not satisfiable; however, grounding with, e.g., {0, x}, makes a
satisfiable.

4 [20,19] considers checking satisfiability of KBs rather than satisfiability of predicates.

However, the former can easily be reduced to the latter.
?

?

?
 Decidability for satisfiability checking of r-hybrid KBs is guaranteed if decidability of the conjunctive query containment problem is guaranteed for
the DL at hand. In contrast, we relied on a translation of DLs to FoLPs
for establishing decidability, and not all DLs can be translated this way; we
illustrated the translation for SHOQ.
Hybrid MKNF KBs [16,15] consist of a DL component and a component of
so-called MKNF rules. Such MKNF rules allow for modal operators K and not
in front of atoms; for a detailed definition, we refer the reader to [16]. Hybrid
MKNF KBs generalize approaches to integrating ontologies and rules such as
CARIN [14], A-log [2], DL-safe rules [17], and the Semantic Web Rule Language
(SWRL) [12], as well as r-hybrid KBs [20]. In particular, one can write the latter
as equisatisfiable hybrid MKNF KBs [16, Theorem 4.8].

In contrast with fKBs, hybrid MKNF KBs, like r-hybrid KBs, make the standard names assumption. Every variable in a rule has to appear in a non-DL
atom of the body of the rule. As with r-hybrid KBs, our fKBs do not have
such a restriction of the interaction between the structural DL component and
the rule component, but rely instead on the existence of an integrating framework (FoLPs under an open answer set semantics) that has reasoning support;
reasoning support that we provided in this paper.

A formalism related to FoLPs is FDNC [24]. FDNC is an extension of ASP with
function symbols where rules are syntactically restricted in order to maintain
decidability. While the syntactical restriction is similar to the one imposed on
FoLP rules, predicates having arity maximum two, and the terms in a binary
literal can be seen as arcs in a forest (imposing the Forest Model Property),
the direction of deduction is different: while for FoLPs, all binary literals in a
rule body have an identical first term which is also the term which appears in
the head, for FDNC (with the exception of one rule type) the second term is
the one which also appears in the head. FDNC rules are required to be safe
unlike FoLP ones. The complexity for standard reasoning tasks for FDNC is
exptime-complete and worst-case optimal algorithms are provided.
For the future, we intend to look into an extension of f-hybrid knowledge
bases and its reasoning algorithm, from SHOQ towards SROIQ(D) the DL
underlying OWL-DL in OWL 25. A prototype implementation of the algorithm
is planned, and will feed the need for optimization strategies.
