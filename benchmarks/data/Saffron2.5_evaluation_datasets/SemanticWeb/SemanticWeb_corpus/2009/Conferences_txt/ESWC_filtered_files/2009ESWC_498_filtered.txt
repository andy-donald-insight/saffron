Middleware for Automated Implementation of

Security Protocols

B ela Genge and Piroska Haller

Petru Maior University of Targu Mure s, Department of Electrical Engineering,

N. Iorga Str., No. 1, (540088) Targu Mure s, Romania

{bgenge,phaller}@engineering.upm.ro

http://www.upm.ro

Abstract. We propose a middleware for automated implementation of
security protocols for Web services. The proposed middleware consists
of two main layers: the communication layer and the service layer. The
communication layer is built on the SOAP layer and ensures the implementation of security and service protocols. The service layer provides
the discovery of services and the authorization of client applications. In
order to provide automated access to the platform services we propose a
novel specification of security protocols, consisting of a sequential compo-
nent, implemented as a WSDL-S specification, and an ontology compo-
nent, implemented as an OWL specification. Specifications are generated
using a set of rules, where information related to the implementation of
properties such as cryptographic algorithms or key sizes, are provided by
the user. The applicability of the proposed middleware is validated by
implementing a video surveillance system.

Keywords: Middleware, Web services, security protocols, automated
execution, ontologies.

1 Introduction

In order to ensure security properties such as confidentiality, integrity or avail-
ability, Web services use technologies such as the Security Assertions Markup
Language [19] (i.e. SAML) or WS-Security [20], providing a unifying solution
for the authentication and authorization issues. The security tokens defined by
WS-Security have been extended with additional ones and a set of new primitives in WS-Trust [21] allowing inter-domain authentication and authorization.
The primitives defined by WS-Trust correspond to security protocols, denoting
communication protocols dedicated to achieving security goals (C.J.F. Cremers and S. Mauw) [1]. The security protocols defined by WS-Trust consist of
request-response messages with flexible message components.

Despite its flexibility, WS-Trust does not define the operations that must be
executed for each message that is constructed or processed. By defining these
operations, services can execute new protocols without relying on predefined
protocols.

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 476490, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
Based on these observations we propose a middleware for automated implementation of security protocols in Web services. The proposed middleware consists of two layers: the service layer and the communication layer. The service
layer consists of several services providing the discovery of services and the authorization of client applications. We define four types of services: name services,
specification services, authorization services and resource services. The communication layer is built on the SOAP layer and ensures the implementation of
security protocols and the implementation of service protocols. By using these
protocols we provide a secure communication channel for the service protocols
implemented above.

Each system implementing the proposed platform defines a single name ser-
vice, a single specification service, a single authorization service and multiple
resource services. Services are accessed dynamically by using service protocol
and security protocol specifications. For the automated execution of security
protocol specifications we propose a semantic security protocol model (SSPM).
The SSPM has two components: a sequential model and an ontology model. The
first component is implemented as a WSDL-S [4] specification while the second
component is implemented as an OWL [15] specification. The role of the WSDL-
S implementation is to describe the message sequences and directions that must
be executed by protocol participants. The role of the OWL implementation is to
provide semantic information such as the construction, processing and implementation of cryptographic operations (e.g. encryption algorithm, encryption mode,
key). The SSPM is constructed from a given security protocol model (SPM) and
it must maintain the protocols security properties. For this we propose several
generating rules and algorithms that generate the SSPM.

The paper is structured as follows. In section 2 we present the architecture of
the proposed middleware. We continue with the construction of the specification
model in section 3. Based on the proposed middleware, in section 4 we exemplify the construction of specifications and we present a Web service-based video
surveillance system, where video capturing resources can be accessed by automatically executing security protocols. We relate our work to others in section
5. We end with a conclusion and future work in section 6.

2 Middleware Architecture

2.1 Service Oriented Architecture

Client applications are able to access resources by first locating them, followed
by the download of the service and security protocol specifications and by the
execution of an authentication sequence. The services provided by the platform
must provide a way to publish, locate and automatically access resource ser-
vices. In addition, in order to face the challenges of rapidly changing protocol
specifications, the protocol implementations must provide flexible and extensible
components.

Based on these requirements, we define four types of services: name services,
specification services, authorization services and resource services. Name services

B. Genge and P. Haller

Fig. 1. Accessing services by client applications

(NAME-S) are implemented through UDDI [22] registries and are used to regis-
ter, identify or locate existing services. Specifications are stored and managed by
specification services (SPEC-S). Specifications are implemented using Web service technologies such as SAWSDL [12], WSDL-S [4] and OWL [15]. Authorization services (AUT-S) implement the verification mechanisms of client credentials
and provide accessing mechanisms to the requested resources. Finally, the resource
services (RES-S) implement a set of capabilities provided for client applications.
Accessing resources by a client application is done in several steps, as shown
in figure 1. First, the client must establish the set of services implemented by the
system (step 1). In order to access a resource, the client must be authenticated
and its rights must be verified. This is done by accessing the AUT-S service,
for which the specifications must be first downloaded. The client requests the
location of AUT-S and SPEC-S (step 2) from NAME-S, followed by the request
of the specifications for AUT-S (step 3). The request for accessing RES-S is sent
to AUT-S (step 4), containing the user credentials. These are verified (step 5)
and a security token is generated by AUT-S that is sent to RES-S (steps 6, 7,
8). The client receives the generated token and sends it to RES-S (steps 9, 10,
11), after which it is able to access the capabilities provided by the resource.

2.2 Software Architecture

The architecture of the software stack is given in figure 2. We identified two main
layers: the communication layer and the service layer, given in figure 2.

The communication layer provides the implementation of the service and
security protocols needed to access service capabilities. It is built on existing
?

?

?
Fig. 2. Software stack

network and XML message-based protocols. Security protocols are implemented
using extensions of the WS-Security standard, provided in our previous work
[14]. The extensions consist of XML constructions for user names and binary
keys required by key exchange and authentication protocols. The automated execution of security protocols is based on specifications developed using existing
Web service technologies such as WSDL-S [4] and OWL [15], presented in the
following sections. Service protocols are described by SAWSDL [12] specifications and are specific to each service. Name services define a set of messages
for interrogating service registry, while specification services define messages for
downloading specifications. Authorization services define messages for requesting access to services and to send security tokens. Resource services provide
two types of specifications, for each external entity accessing them. The AUT-S
specifications provide messages for setting user security tokens, while the client
specifications provide client access messages.

The service layer provides the implementation of service capabilities. The capabilities of NAME-S, SPEC-S and AUT-S have already been discussed before.
The capabilities of RES-S are specific to each implementation, ranging from
video image capabilities to data storage capabilities. In order to implement new
resource services, the only components that require change are the capabilities
and the service protocol specifications. The security properties of communications with new resources are ensured by the underlying communication layer
that remains unchanged.

3 Constructing Security Protocol Specifications

In order to provide an automated implementation of security protocols we need
to construct a detailed specification model that includes sufficient information for
protocol participants to generate and process messages. Specification models are
generated from protocol models that contain a limited number of information.
Based on the protocol model, we provide several rules and algorithms to generate
specification models. However, this process is not entirely automated. The user

B. Genge and P. Haller

must select parameters of cryptographic algorithms such as generated key and
random number sizes.

3.1 Protocol Model

Protocol participants communicate by exchanging terms constructed from elements belonging to the following basic sets: P, denoting the set of role names;
N, denoting the set of random numbers or nonces (i.e. number once used); K,
denoting the set of cryptographic keys; C, denoting the set of certificates and M,
denoting the set of user-defined message components.

In order for the protocol model to capture the message component types found
in security protocol implementations [19], [20] we specialize the basic sets with
the following subsets:
 PDN  P, denoting the set of distinguished names; PUD  P, denoting
the set of user-domain names; PIP  P, denoting the set of user-ip names;
PU = {P \ {PDN  PUD  PIP}}, denoting the set of names that do not
belong to the previous subsets;
 NT , denoting the set of timestamps; NDH, denoting the set of random numbers specific to the Diffie-Hellman key exchange; NA = {N \ {NDH  NT}},
denoting the set of random numbers;
 KS  K, denoting the set of symmetric keys; KDH  K, denoting the set
of keys generated from a Diffie-Hellman key exchange; KP UB  K, denoting
the set of public keys; KP RV  K, denoting the set of private keys;
To denote the encryption type used to create cryptographic terms, we define

the following function names:

F uncN ame ::= sk
| pk
| h
| hmac

(symmetric f unction)
(asymmetric f unction)
(hash f unction)
(keyed hash f unction)

The encryption and decryption process makes use of cryptographic keys. Decrypting an encrypted term is only possible if participants are in the possession
of the decryption key pair. In case of symmetric cryptography, the decryption
key is the same as the encryption key. In case of asymmetric cryptography, there
is a public-private key pair. Determining the corresponding key pair is done using
the function 1 : K  K.

The above-defined basic sets and function names are used in the definition of

terms, where we also introduce constructors for pairing and encryption:

T ::= . | P | N | K | C | M | (T, T) | {T}F uncN ame(T),

where the . symbol is used to denote an empty term.

Having defined the terms exchanged by participants, we can proceed with
the definition of a node and a participant chain. To capture the sending and
?

?

?
receiving of terms, the definition of nodes uses signed terms. The occurrence of
a term with a positive sign denotes transmission, while the occurrence of a term
with a negative sign denotes reception.
Definition 1. A node is any transmission or reception of a term denoted as
, t, with t  T and  one of the symbols +,. A node is written as t or
+t. We use (T) to denote a set of nodes. Let n  (T), then we define the
function sign(n) to map the sign and the function term(n) to map the term
corresponding to a given node.
Definition 2. A participant chain is a sequence of nodes. We use (T) to
denote the set of finite sequences of nodes and t1,t2, . . . ,ti to denote an
element of (T).
In order to define a participant model we also need to define the preconditions
that must be met such that a participant is able to execute a given protocol. In
addition, we also need to define the effects resulting from a participant executing
a protocol.

Preconditions and effects are defined using predicates applied on terms:
CON TERM : T, denoting a generated term; CON PARTAUTH : T, denoting participant authentication; CON CONF : T, denoting the confidentiality
of a given term); CON INTEG : T, denoting the integrity of a given term;
CON NONREP : T, denoting the non-repudiation property for a given term;
CON KEYEX : T, denoting a key exchange protocol.

The set of precondition-effect predicates is denoted by PR CC and the set of

precondition-effect predicate subsets is denoted by PR CC
. The types attached
to each protocol term are modeled using the following predicates: TYPE DN : T
to denote distinguished names, TYPE UD : T to denote user-domain names,
TYPE NT : T to denote timestamps, TYPE NDH : T to denote DiffieHellman random numbers, TYPE NA : T to denote other random numbers,
TYPE NDH : T  T  T  P  P to denote Diffie-Hellman symmetric keys,
TYPE KSYM : T  P  P to denote symmetric keys, TYPE KPUB : T  P
to denote public keys, TYPE KPRV : T  P to denote private keys, and
TYPE CERT : T  P do denote certificate terms.

is a set of precondition predicates, eff  PR CC


The set of type predicates is denoted by PR TYPE and the set of type predicate

subsets is denoted by PR TYPE
. Based on the defined sets and predicates we
are now ready to define the participant and protocol models.
Definition 3. A participant model is a tuple prec, eff , type, gen, part, chain,
where prec  PR CC

is a set
of effect predicates, type  PR TYPE is a set of type predicates, gen  T

is a
set of generated terms, part  P is a participant name and chain  (T) is a
participant chain. We use the MPART symbol to denote the set of all participant
models.
Definition 4. A security protocol model is a collection of participant models
such that for each positive node n1 there is exactly one negative node n2 with
term(n1) = term(n2). We use the MPROT symbol to denote the set of all security protocol models.

B. Genge and P. Haller

3.2 Semantic Security Protocol Model

In this section we propose a new semantic security protocol model (SSPM) based
on which we construct security protocol specifications that can be automatically
executed by protocol participants. Protocols are given using their SPM model
described in the previous section. Based on this model we generate the corresponding SSPM that has two components: the sequential model (SEQM) and
the ontology model (ONTM). The first component is implemented as a WSDL-S
specification while the second component is implemented as an OWL specifica-
tion. In the remaining of this section we provide a description of each component
and we provide a set of rules to generate SSPM from a given SPM.

We use the symbol URI to denote the set of Uniform Resource Identifiers,
to denote the set of subsets


CONC to denote the set of all concepts and CONC
with elements from CONC.
Definition 5. An annotation is a pair uri, c, where uri  URI and c  CONC.
The set corresponding to a SSPM is denoted by ANNOT and the set of subsets
with elements from ANNOT is denoted by ANNOT



.

By consulting the WSDL-S specification we define a message as a pair consisting
of the message direction and an annotation.
Definition 6. A message is a pair d, a, where d  {in, out} and a  ANNOT.

to denote the set of
We define MSG to denote a set of messages and MSG
subsets with elements from MSG.



Next, we define the sequential model as a collection of preconditions, effects and
messages, based on the previous definitions.

is a triplet s prec, s eff , s msg, where
is a set of effects

is a set of preconditions, s eff  ANNOT
is a set of messages.

Definition 7. A sequential model
s prec  ANNOT

and s msg  MSG

The ontology model follows the description of OWL.
Definition 8. An ontology model is a triplet conc, propr, inst, where conc 
CONC is a set of concepts, propr  PROPR is a set of properties and inst  INST
is a set of instances. An element from propr is a pair , , where  is a unique
id and  is a syntactic construction denoting the property name.
Let pr1 = 1, 1 and pr2 = 2, 2. Then pr1 = pr2 iff 1 = 2 and
1 = 2. We define the function ( )id to map the  component and the function
( )nm to map the  component of a given property.

We use PROPR to denote the set of all properties and INST to denote the set
to denote the set of all subsets with elements
to denote the set of all subsets with elements from INST.


of all instances. We use PROPR
from PROPR and INST



In order to handle the previously defined ontology model we define the function
( )d : PROPR  CONC to map the domain concept of a given property, ( )c :
PROPR  CONC to map the category concept of a given property, ( , )ci :
CONCPROPR  INST to map the instance corresponding to a domain concept
?

?

?
e : CONC  CONC

and property, ( )s
given concept is parent, ( )p : CONC  PROPR

for which the given concept is domain.

to map the set of concepts for which the
to map the set of properties

3.3 Generating the Semantic Security Protocol Model

In order to generate the SSPM for a given SPM, we start with a core ontology
model (OM) (figure 3) that contains concepts found in classical security pro-
tocols. The core OM was constructed by consulting security protocols found in
open libraries such as SPORE [18] or the library published by John Clark [5].

The core ontology is constructed from 7 sub-ontologies. The sub-ontologies
that must be extended with new concepts for each SSPM are denoted in figure 3 by interrupted lines, while the permanent sub-ontologies are denoted by
continuous lines.

The SecurityProperty sub-ontology contains concepts such as Authentication,
Confidentiality or Session key exchange. The TermType sub-ontology includes
concepts related to term types used in security protocol messages such as Sym-
metricKey, PublicKey or ParticipantName. Concepts related to cryptographic
specifications such as encryption algorithms or encryption modes are found in
the sub-ontology CryptoSpec. In order to model modules needed to extract keys,
names or certificates we use the LoadingModule sub-ontology. The ParticipantRole sub-ontology defines concepts modeling roles handled by protocol participants such as Initiator, Respondent and Third Party.

The Knowledge sub-ontology contains 5 concepts: PreviousTerm, Accessed-
Module, InitialTerm, GeneratedTerm and DiscoveredTerm. Each concept defines
a class of terms specific to security protocols: terms from previous executions,
modules, initial terms, generated terms and discovered terms.

The last sub-ontology is CommunicationTerm, which defines two concepts:
SentTerm and ReceivedTerm. This sub-ontology is extended for each SEM-S
with concepts that are sent or received. For each concept, functional properties
are defined denoting the operations performed on the terms corresponding to
concepts. The concepts used to extend the core ontology are specific to each
protocol, however, the defined properties are applied on all constructions. From
these properties we mention: hasKey, isStored, isVerified.

Fig. 3. Core ontology of SSPM
?

?

?
e r {c}msg tx,

n  chain sign(n) = +

n  chain sign(n) = 

B. Genge and P. Haller

operator to denote a value transfer.

Next, we define a set of rules and algorithms to generate the SSPM for a given
SPM. The developed rules use the r operator to denote set reunion and the
a
The first two rules generate the predicate concepts corresponding to preconditions prec from a SPM, where the function gc : T  CONC is used to generate the
concept corresponding to a given term and the function gcc : PR CC  CONC
is used to generate the concept corresponding to a given precondition predicate:

pr  prec pr = CON TERM (t)

c a gc(t) s prec r {uri, c} (InitialT erm)s

e r {c}pr term,

pr  prec pr = CON TERM (t)

s prec r {uri, gcc(pr),uri, gc(t)} pr propr.

The rules generating the effects have a similar structure because of the eff
set. For each positive or negative node there is a corresponding concept in the
SentTerm and ReceivedTerm sub-ontologies, generated by the following rules:

e r {c}msg rx.

c a grx(term(n)) s msg r {in, c} (ReceivedT erm)s
The concatenated terms corresponding to each transmitted or received term
are modeled using similar rules. For each sent term the SSPM must provide the
construction operations and for each received term the SSPM must provide processing operations. Sub-concepts of SentTerm are connected to sub-concepts of
Knowledge through the isExtracted property, generated according to the follow-
  ID to generate a new property
ing rule, where we used the function PR CC
id:
c  (SentT erm)s

p a gid(propr), isExtracted (c)p r {p} (p)c  (Knowledge)s
Processing of received terms is done according to the type of the given term
and to the knowledge available to the user. The modeled operations introduce
constraints on the type and location of knowledge through the following rules,
where we used the E SYM : CONC predicate to denote symmetric encryption:

con extr.

e

e

c  (ReceivedT erm)s

e p  (c)p (p)nm = isDecrypted

c a (p)c E SYM (c)  E SYM (c) (c)  (DiscoveredT erm)s

e

con decr,

c  (ReceivedT erm)s

c a (p)c (c)  (DiscoveredT erm)s

e p  (c)p (p)nm = isStored
e p  (c)p (p)nm = isV erif ied

c  (ReceivedT erm)s

e

con stored,

c a (p)c (c)  {(DiscoveredT erm)s
In the Knowledge sub-ontology, each concept has an isOfType property attached based on which participants can decide on the operations to execute. For

e \ (AccessedM odule)s

e} con verif.
?

?

?
each type, additional properties are defined such as the hasSymmAlg or hasKey
properties for symmetric encrypted terms. The rules based on which these properties are generated are specific to each type. For example, the following rules
define the algorithm type and key for an encrypted term that must be processed
or constructed:

p a gid(propr), hasSymmAlg (c)p r {p} (c, p)ci  (Symmetric)s

e

sim alg,

c  (Knowledge)s

e E SYM (c)

c  (Knowledge)s

e E SYM (c)

p a gid(propr), hasKey (c)p r {p} (p)c  (Knowledge)s
The rules presented above are executed by algorithms. For example, modeling
positive nodes in SSPM is done through the use of algorithm 1. Here, the set of
knowledge KNOW corresponding to each executing participant grows with the
construction and reception of each new term. We used the function mpart : T 

to map the set of concatenated terms and the keyword Exec to denote the

execution of sub-algorithms.

sim key.

e

Algorithm 1. Model positive and negative nodes
Require: n  (T), sign(n) = +
for all t  mpart(term(n)) do

Let c = gc(t)
Let p  @con extr(c)
if t  KNOW then
(p)c a c
else if t = {t

}f (k) then

e r {c}

(GeneratedT erm)s
Exec M odelEncryptedGenerated(t)
else if t  gen then
(GeneratedT erm)s
Exec M odelP lainGenerated(t)

e r {c}

else

(DiscoveredT erm)s
Exec M odelDiscoveredLoaded(t)

e r {c}

end if
KNOW r t

end for

4 Experimental Results

In this section we exemplify the construction of a SSPM from a given SPM and
provide a few experimental result from implementing several generated SSPM.

4.1 Constructing the SSPM for the BAN Protocol

In order to provide an example for constructing an SSPM for a given SPM, we
use the well-known BAN Concrete Secure Andrew RPC protocol [18]. This is

B. Genge and P. Haller

a two-party protocol providing a session key exchange using symmetric cryptog-
raphy. The protocol assumes that participants are already in the possession of a
long-term key Kab.

Because of space considerations, we only provide the construction of the SSPM
for the A participant. Based on this, the construction of the SSPM for the second
participant is straight-forward.
The precondition set precA for participant A is precA = {CON TERM (A),
CON TERM (B), CON TERM (Kab)} and the effect set eff A for the same participant is eff A = {CON KEYEX (Kab)}. The set typeA = {TYPE UD (A),
TYPE UD(B), TYPE KSYM (A, B, Kab), TYPE KSYM (A, B, K), TYPE NA
(Na), TYPE NA(Nb)} defines the type corresponding to each term and the set
genA = {Na} defines the terms generated by participant A. The participant
name is partA = A and the participant chain is chainA = +(A, Na),{Na, K,
B}sk(Kab), +{Na}sk(K),Nb.

By applying the rules and algorithms described in the previous sections we
generate the SSPM model. Due to space considerations, instead of describing
the actual SSPM we describe the implementation of the model. The sequential
model is implemented as a WSDL-S specification, while the ontology model is
implemented as a OWL specification.

Part of the resulted WSDL-S specification is given in figure 4 and part of the

graphical representation of the OWL specification is given in figure 5.

...

<xsd:element name="Msg1Request">

<xsd:complexType>

<xsd:sequence>

<xsd:element name="Term1" type="xsd:base64Binary"

wssem:modelReference=".../SecProt.owl#SentTerm1">

</xsd:sequence>

</xsd:complexType>

</xsd:element>
...
<wsdl:operation name="Msg1">

<wsdl:output message="tns:Msg1Request"/>

</wsdl:operation>
<wssem:effect name="SessionKeyExchange"

...

wssem:modelReference=".../SecProt.owl#SessionKey"/>

Fig. 4. Part of the sequential models implementation

4.2 Case Study

We have generated several security protocol specifications corresponding to protocols such as ISO9798 and Kerberos V5. These specifications were stored by
the SPEC-S and were downloaded and automatically executed by client test
applications and the services provided by the platform.

Based on these specifications and the proposed middleware, we implemented
a video surveillance system. The basic requirements of these systems include
real time image transfer, low bandwidth consumption and access control procedures [13]. To these, we add another requirement: automated security protocol
execution in heterogeneous environments.
?

?

?
Fig. 5. Part of the ontology models implementation

(a)

(b)

Fig. 6. Performance of the communication layer: (a) Symmetrical encryption (b) Asymmetrical encryption

Our middleware satisfies all of the above formulated requirements. In figure 6
we have illustrated the performance of the communication layer. In the first case,
we illustrated the performance overhead of using symmetric key-based protocols
against the case when no cryptography is used. In the second case we illustrated
the performance overhead of using security protocols based on asymmetric cryp-
tography.

In order to provide automated access to resources we used asymmetric algorithms for key exchange protocols and symmetric algorithms for data transfer
protocols. The keys exchanged using the first protocol types were used by the
second protocols to encode data. All security protocol implementations were
done using SOAP protocol header, according to the WS-Security standard.

Based on our experimental results, the time needed for a client application to
access a service resource is around 520ms, as shown in figure 7, if the specifications are not cached. In case caching mechanisms are used, the time reduces to
around 375ms. In both cases, if the specifications for the requested resources are

B. Genge and P. Haller

Fig. 7. Accessing system resources

not cached by AUT-S, the accessing time is much higher, as illustrated by the
spikes from figure 7.

5 Related Work

An approach that aims at the automatic implementation of security protocols
is given in [2]. This approach uses a formal description as a specification which
is executed by participants. The proposed specification does not make use of
Web service technologies, because of which inter-operability and extendability
of systems executing the given specifications becomes a real issue.

Abdullah and Menasc propose in [3] a specification that is constructed as
an XML document from which code is generated. The resulted code is then
compiled and executed by participants. Because of this aspect, our proposal is
more dynamic in the sense that applications can download and execute new
protocols based on the developed specifications automatically, without having
to stop program execution.

The authors from [8] propose a security ontology for resource annotation. The
proposed ontology defines concepts for security and authorization, for cryptographic algorithms and for credentials. This proposal was designed to be used in
the process of security protocol description and selection based on several crite-
ria. In contrast, our ontologies, have a more detailed construction. For example,
the ontology from [8] defines a collection of cryptographic algorithms, however,
it does not define the algorithm mode, which is an implementation-specific in-
formation.

There have been several other security ontologies proposed [9], [10] which can
be used to complete our core ontology with additional concepts and properties,
for generating more complex protocol models.

6 Conclusion and Future Work

We developed a middleware for the automated execution of security protocols.
The proposed middleware makes use of specifications generated from a semantic
?

?

?
security protocol model. The sequential component of the proposed model is
implemented as a WSDL-S specification while the ontology component is implemented as an OWL specification.

Constructing the SSPM model is not a trivial task and can induce new flaws
in correct protocols that can lead to attacks. In order to ensure a correct construction process, we developed several generating rules and algorithms that map
each component from the input protocol model to a component in the SSPM
model. The resulted specifications were automatically executed by client applications and services implemented in a proposed video surveillance system. The
experimental results have shown that the proposed middleware can be used in
a wide variety of applications ranging from multimedia to eCommerce.

The proposed specification model encapsulates cryptographic properties that
must be met by services and clients executing them. As future work we intend to
develop a negotiation mechanism of such properties between RES-S and AUT-
S as well as between client applications and AUT-S. These mechanisms can be
implemented using the proposed communication layer enhanced with negotiation
protocols.
