Ranking Approximate Answers to Semantic Web

Queries

Carlos A. Hurtado1, Alexandra Poulovassilis2, and Peter T. Wood2

1 Faculty of Engineering and Sciences

Universidad Adolfo Ib a nez, Chile

2 School of Computer Science and Information Systems

carlos.hurtado@uai.cl

Birkbeck, University of London, UK

{ap,ptw}@dcs.bbk.ac.uk

Abstract. We consider the problem of a user querying semistructured
data such as RDF without knowing its structure. In these circumstances,
it is helpful if the querying system can perform an approximate matching
of the users query to the data and can rank the answers in terms of how
closely they match the original query. Our approximate matching framework allows us to incorporate standard notions of approximation such
as edit distance as well as certain RDFS inference rules, thereby capturing semantic as well as syntactic approximations. The query language
we adopt comprises conjunctions of regular path queries, thus including
extensions proposed for SPARQL to allow for querying paths using regular expressions. We provide an incremental query evaluation algorithm
which runs in polynomial time and returns answers to the user in ranked
order.

1 Introduction

The volume of semistructured data available to users on the web continues to
grow significantly. In particular, there has recently been a substantial increase
in the amount of RDF data being generated and made available, often in the
form of linked data [1]. Given the volume and heterogeneity of this data, users
are frequently unaware of the structure of the data. This has given rise to linked
data browsers such as Tabulator [1]. However, users may also wish to query
such large repositories of linked data and so there is a need to assist them by
providing querying systems which do not require that users queries necessarily
match exactly the data structures being queried.

In this paper we consider general semistructured data modelled as a graph
structure, with RDF linked data being a particular application of this model.
Our data model is that of a directed graph G = (V, E), where each node in V
is labelled with a constant and each edge e is labelled with a symbol l(e) drawn
from a finite alphabet . Such a model does not allow for the representation of
RDF blank nodes, e.g., but these are specifically discouraged for linked data [2].
We are interested in developing efficient algorithms which allow for the approximate matching of users queries on such data, with the answers to queries

L. Aroyo et al. (Eds.): ESWC 2009, LNCS 5554, pp. 263277, 2009.
c Springer-Verlag Berlin Heidelberg 2009

C.A. Hurtado, A. Poulovassilis, and P.T. Wood

being returned to users in ranked order. In order to achieve this, we restrict our
query language to that of conjunctive regular path queries [3]. A conjunctive
regular path query Q consisting of n query triples (or conjuncts) is the form

(Z1, . . . , Zm)  (X1, R1, Y1), . . . , (Xn, Rn, Yn)

in which each Xi and Yi, 1  i  n, is a variable or constant, each Zi, 1  i  m,
is a variable appearing in the body of Q, and each Ri, 1  i  n, is a regular
expression over .

The idea of using regular expressions to specify paths through graphs has been
around for a long time (e.g. [4]), having been taken up by the semistructured
data community (e.g. [3]), and more recently by the RDF community (e.g. [5,6])
in proposed extensions to SPARQL [7].
The exact answer to a conjunctive regular path query Q on a graph G is
specified as follows. We first find, for each 1  i  n, a relation ri over the
scheme (Xi, Yi) such that tuple t  ri iff there is a path from t[Xi] to t[Yi] in
G that satisfies Ri, that is, whose concatenation of edge labels is in L(Ri). We
then form the natural join of relations r1, . . . , rn and project over Z1 to Zm.

Example 1. As an example, consider an RDF graph G involving information
about a transport network (Fig. 1). Some nodes represent cities (denoted by
URIs) and others represent names of cities. Edges state that we can travel from
one city to another city by train, bus, or by airplane.

airplane

airplane

train

u2

train

u4

bus

u1

name

Santiago

Valparaiso

name

bus

airplane

u3

name

Talca

name

Chillan

Temuco

name

u7

bus

u5

name

bus

Concepcion

u6

name

Los Angeles

Fig. 1. An RDF graph of a basic transport network

Suppose that we want to find the cities from which we can travel to city u5
using only airplanes as well as to city u6 using only trains or busses. This can
be expressed by the following conjunctive regular path query1 Q:
?X  (?X, (airplane)+, u5), (?X, (train|bus)+, u6)

1 In the concrete syntax of queries, we precede variable names with ? as in SPARQL.
?

?

?
When Q is evaluated on G, the set of bindings for ?X generated by the first
conjunct is {u1, u4}, while that for the second conjunct is {u1, u2, u4}. Hence

the answer is {u1, u4}.
As stated above, we also want to allow for approximate matching of queries on
graphs. Such approximate (or similarity) matching can take many forms and has
been the subject of much study [8,9,10,11,12,13]. In general, we are interested
in using weighted regular transducers to model the kinds of approximations allowed since single conjunct queries with a transducer applied can be evaluated
incrementally in polynomial time [9]. Incremental evaluation allows for answers
to be returned incrementally to a user in ranked order, without the user having
to wait for entire query evaluation to end. In this paper, we extend these results
to show that multiple conjunct queries can also be evaluated incrementally in
polynomial time, using ideas from [14].

A weighted regular transducer is basically a finite state automaton in which
the transitions are labelled with triples rather than single symbols. A transition
from state s to state t labelled with triple (a, i, b) means that if the transducer
is in state s, it can move to state t on input a with cost i while outputting b. In
our context, such a transition would be interpreted as specifying that symbol a
in a query can match the label b of a graph edge with cost i.

Weighted regular transducers provide for greater generality than we need for
most of our examples. They also make the agorithms more difficult to explain.
Hence for most of the paper we restrict ourselves to using approximate regular
expression matching [15], which can easily be specified using weighted regular
transducers [9]. The edit operations which we allow in approximate matching
are insertions, deletions and substitutions of symbols, along with insertions of
inverted symbols (corresponding to edge reversals) and transpositions of adjacent
symbols, each with an assumed cost of 1.
Example 2. Consider again the application in Example 1 and assume that a user
who has little knowledge of the structure of the data formulates the following
query to retrieve all the cities reachable from Santiago by non-stop flights:

?X  (Santiago, airplane, ?X)

The query does not return any answers because it does not match the structure
of the graph. However, allowing edit operations such as insertions of symbols
and inverted symbols (indicated by using  as a superscript to the symbol and
corresponding to matching an edge in the reverse direction), each at an assumed
cost of 1, the regular expression airplane can be successively relaxed to the
regular expression ((name)  airplane  name), which captures as answers the
city names of Temuco and Chillan. Since the cost of each edit operation is set
to 1, these answers can be regarded as having a distance of 2 from the original
query (two insertions).

Suppose now that, after acquiring some knowledge of the structure of the data,
the user formulates the following query to find cities reached from Santiago by
train:

?X  (Santiago, ((name)

  (train)+  name), ?X)

C.A. Hurtado, A. Poulovassilis, and P.T. Wood

If the user is prepared to consider replacing a train journey by a bus journey, but
at a cost of 1 per replacement, this can be specified as the only edit operation allowed on the users query. The same effect can be achieved by a transducer with a
single state with two self-edges to/from it: one labelled with (train, 0, train), i.e.
train can be matched by train with cost 0, and one labelled with (train, 1, bus),
i.e. train can be matched by bus with cost 1. Now, the results of the query will
be returned to the user ranked by the number of bus journeys: Talca and Chillan
will have rank 0, Valparaiso, Concepcion and Los Angeles will have rank 1, and

Temuco will have rank 2.

We do not expect that a user would necessarily want or be able to design a
weighted regular transducer in order to capture their requirements in terms of
approximate matching. Instead, we would expect that a query interface would
provide a user with readily understandable options from which to select their re-
quirements. Our concern in this paper is in showing that weighted regular transducers and conjunctive regular path queries provide a good framework within
which to investigate approximate querying of graph-structured data.

In the next section, we consider the special case of computing approximate
answers for queries consisting only of a single conjunct. We show that approximate answers can be computed in time which is polynomial in the size of the
query and the input graph. We also show that these answers can be computed
incrementally and returned to the user in ranked order. Section 3 generalises
to the case of multi-conjunct queries and shows that incremental computation
can still be achieved in polynomial time as long as the queries are acyclic and
have a fixed number of head variables. Related work is covered in Sect. 4 which
also shows how our approach generalises previous work in a number of areas.
Conclusions and future work are described in Sect. 5.

2 Single-Conjunct Queries

Recall that our data model is that of a directed graph G = (V, E), where each
node in V is labelled with a constant and each edge e is labelled with a symbol
l(e) drawn from a finite alphabet . In queries, we will allow edges to be traversed
both from their source to their target node and in reverse, from their target to
their source node. So we now introduce the notion of the inverse of an edge
, which is used to specify a reverse traversal of an edge.
label l, denoted by l
 to mean the inverse of l, that
Let 
is, if l is a for some a  , then l
 for some a  , then
 is a.
l
A single-conjunct query consists of an expression of the form:

 | l  }. If l    

, we use l

 = {l

 is a

, while if l is a

Z1, Z2  (X, R, Y )

where X and Y are constants or variables, R is a regular expression, and each of
Z1 and Z2 is one of X or Y . A regular expression R over  is defined as follows:

R := 	 | a | a

 |

| (R1  R2) | (R1|R2) | R

 | R+
?

?

?
 is the inverse of a,  
where 	 is the empty string, a is any symbol in , a
denotes the disjunction of all constants in , and the operators have their usual
meaning.

2.1 Exact Semantics

Because of the presence of inverse operators in our queries, we need to introduce
the notion of a semipath in G in order to define the semantics of a query [3].
A semipath p in G = (V, E) from x  V to y  V is a sequence of the form
(v1, l1, v2, l2, v3, . . . , vn, ln, vn+1), where n  0, v1 = x, vn+1 = y and for each
i vi  E. The semipath p conforms to
vi, li, vi+1 either vi
regular expression R if l1  ln  L(R), the language denoted by R.

li vi+1  E or vi+1

Given a single-conjunct query Q and graph G, let  be a matching from
variables and constants of Q to nodes of G that maps each constant to itself. We
say that the tuple (Z1, Z2) satisfies Q on G if there is a semipath from (X) to
(Y ) which conforms to R. The exact answer of Q on G, denoted Q(G), is the
set of tuples which satisfy Q on G.



l

2.2 Approximate Semantics

We also allow for approximate answers to queries using approximate regular
expression matching. As stated in the Introduction, we can in fact use a weighted
regular transducer to specify the approximations, but it is easier to explain using
only approximate regular expression matching. The edit operations that we allow
for approximate matching are insertions, deletions, inversions, substitutions, and
transpositions of adjacent symbols. The user can specify which, if any, of these
edit operations should be undertaken by the system when answering a particular
query. A different cost can be associated with applying each operation.

For strings, the edit distance from string w to string v is the minimum cost of
any sequence of edit operations which transforms w to v. In our case, we treat the
labels on edges as atomic and it is sequences of such labels which are transformed
using edit operations. The edit distance from a semipath w to a semipath v is the
minimum cost of any sequence of edit operations which transforms the sequence
of edge labels of w to the sequence of edge labels of v; for the sake of simplicity,
in this paper we assume that all edit operations have a cost of 1. The distance of
a semipath w to a regular expression R, denoted dist(w, R), is the minimum edit
distance from w to any semipath that conforms to R.

Given a matching  from variables and constants of a query Q to nodes in a
graph G, we have that the tuple (Z1, Z2) has distance dist(p, R) to Q, where
p is a semipath from (X) to (Y ) which has the minimum edit distance to R
of any semipath from (X) to (Y ) in G. Note that if p conforms to R, then
(Z1, Z2) has distance zero to Q.

Given a graph G = (V, E) and single-conjunct query Q, the approximate top-
k answer of Q on G is a list containing the k tuples (Z1, Z2) with minimum
distance to Q, ranked in order of increasing distance to Q. The approximate
answer of Q on G contains all the tuples at any distance to the query (ranked
?

?

?
by distance). Notice that for k = |E|2, the approximate answer is equal to the
approximate top-k answer.

2.3 Approximate Automaton

In this section we will introduce the notion of the approximate automaton of a
regular expression R: the approximate automaton of R at distance d, where d is
an integer, accepts all strings at distance at most d from R.

We make d copies of MR, each copy denoted M j

For any regular expression R we can construct an NFA MR to recognise L(R)
using Thompsons construction. This ensures that MR has a single initial state,
denoted s0, a single final state, denoted sf , and O(|R|) states. Then, the approximate automaton at distance d is obtained following a standard construction used
in approximate string matching [15].
R, 0  j  d, whose states
are those of MR with superscript j, representing distance j from the original
automaton MR. The only initial state in the approximate automaton M is s0
0,
in other words the initial state of MR at distance 0. The final state of each M j

remains a final state in the approximate automaton.
by O(|R|) transitions for deletions, O(||  |R|) transitions for insertions, O(||  |R|) transitions
for substitutions, O(|R|) transitions for inversions, and O(|R|2) transitions for
transpositions.

Subautomaton M j

R is connected to subautomaton M j+1

Figure 2 shows the skeleton of the construction for insertions and deletions.
Transitions for deletions are labelled with 	, and transitions for insertions are
 (because we may insert a label or an inverse label). Figure 3
labelled with , 
shows the additional states and transitions needed for transpositions, inversions,
and substitutions.

s0

si

s0
j

si
j

s0
k

si
k

s0
f

si
f



,



,

	



,



,

si+1

si+1
j

si+1
k

si+1
f

sd

sd
j

sd
k

sd
f

Fig. 2. Approximate automaton at level d (insertions and deletions only)

The following lemma shows two basic properties of the approximate automaton.

Lemma 1. Let G = (V, E) be a database, R be a regular expression, and M be
the approximate automaton of R at distance d. (i) M has size O(d  (|R| + || 
|R| + |R|2)). (ii) If d = |R| + |E|, then every semipath in G conforms to M.
?

?

?
si
j

a

b

b

si
k

si
l

si
j

si
k

si
j

a



a

a

si
k
\{a}

si
jkl

si+1
k

si+1
k

si+1
j

si+1
k

a

a

b

si+1
l

(a)

(b)

(c)

Fig. 3. Transitions for (a) transpositions, (b) inversions and (c) substitutions

Proof. (i) This follows directly from the definition of the approximate automa-
ton. (ii) Any semipath w in G can be accepted by the approximate automaton
through transitions labelled with 	 that delete all the symbols that appear in R

followed by transitions that add all the labels of w.

2.4 Evaluation of Single-Conjunct Queries

Consider the single-conjunct query Q:

Z1, Z2  (X, R, Y )

In order to evaluate Q on graph G, we start by constructing the approximate
automaton M of R at distance d = |R|+|E|. We next form the product automaton H = M  G, viewing each node in G as both an initial and a final state. H
contains as nodes all the pairs (x, y) such that x is a node of M and y is a node
of G, and edges ((x1, y1), (x2, y2)) labelled l such that there is an edge (x1, x2)
labelled l in M and there is an edge (y1, y2) labelled l in G.

We associate a cost with each transition in the product automaton as follows.
Any transition between a pair of states such that both derive from states of the
approximate automaton M with the same superscript has cost 0, while all other
transitions have cost 1.

Assume for the moment that X is a node n of G. We then perform a uniform
cost traversal of H starting from vertex (s0
0, n). We keep a list of visited nodes,
so that no node is visited twice. The size of the search tree is in O(|V |), where V
f , m) in H we output
is the set of vertices of H. Whenever we reach a vertex (si
m. The distance of m to the query Q is given by the total cost of the path from
(s0
0, n) to the vertex (si
When both Z1 and Z2 are variables and assuming that Z1 equals X, Q can
be evaluated by answering the query n, Z2  (n, R, Y ) for each node n in G.
Lemma 2. Let G = (V, E) be a graph and Q be a single-conjunct query using
regular expression R. Assuming |E| > |R|, the approximate answer of Q on G
can be computed in time O(|V |  |E|2  |R|2).

f , m) in the traversal tree.
?

?

?
Proof. Assuming |E| > |R|, the size of the approximation automaton M of R at
distance |R| + |E| is O(|E|  |R|2). The size of H = M  G is O(|E|2  |R|2) (we
can discard disconnected nodes from H). So computing the approximate answer
takes O(|V |  |E|2  |R|2), that is |V | traversals of H, each one at cost equal to

the size of H.

Example 3. Consider the graph depicted in Fig. 1 and a slight modification of
the query from Example 2:

?X  (Santiago, (airplane)+, ?X)

Figure 4 shows the approximate automaton of R at distance d = 2, where we use
a for airplane and n for name and, for simplicity, we consider only insertions of
n or n

 and inversion of a.

s0



n,n

s1



n,n

s2



a



a

a

a

a

a

s0
f



n,n

s1
f

a



n,n

s2
f

a

(s0

0, San)



n

,1

(s1

0, u1)

a,0

a,0

(s1

f , u4)

n,1

a,0

(s1

f , u7)

n,1

(s2

f , Chi)

(s1

f , u5)

(s2

f , T em)

n,1

(s2

f , Con)

Fig. 4. The approximate automaton (d = 2) for R = a+ and a traversal tree

Figure 4 also shows the traversal tree starting from (s0

0, San), where San,
Chi, Con and T em are abbreviations for Santiago, Chillan, Concepcion and
T emuco, respectively. Here we assume that all operations have cost 1.

As we saw previously, there are no answers at rank 0. The answers at rank 1
f ) are u4, u5 and u7, while those at
?

?

?
(indicated by being associated with state s1
rank 2 are Chi, Con and T em.

2.5 Incremental Evaluation
We may compute edges of the graph H = M  G above incrementally, avoiding
the precomputation and materialization of the entire graph H. Recall that a
?

?

?
vertex in H is a pair (sj
of G. Each edge of H is labelled with a symbol and a weight.

i , n), where sj

i is a state of automaton M and n is a node

The on-demand computation of edges of H is performed by calling a function
i , n) of H. The function returns a set of transitions e,w
k, m) with label e and
f , u4) returns the following transitions:
f , Chi) (insertion of label n

Succ with a node (sj
k, m), such that there is an edge in H from (sj
(sl
weight w. As an example, in Fig. 4 Succ(s1
a,0 (s1
at cost 1).

f , u5) (without relaxationcost 0) and n,1 (s2

i , n) to (sl

A procedure for computing Succ is shown overleaf. Here, MR is the original
NFA constructed to recognise L(R). The function nextStates(MR, s, c) returns
the set of states in MR that can be reached from state s on reading input c.
We assume that this function can also take as an argument a state si in the
approximate automaton at distance i from MR. If nextStates(MR, s, c) returns
{s1, s2, . . . , sk}, then nextStates(MR, si, c) returns {si

Incremental evaluation proceeds by performing the initialisations shown be-
low, where d is used to record distances of nodes, visitedR stores triples (v, n, s)
representing the fact that node n was visited in state s starting from node v,
and QR is a priority queue ordered by distance. The procedure getN ext (see
overleaf) returns the next tuple for a conjunct in ranked order.

2, . . . , si
k

1, si

}.

Incremental evaluation for a single-conjunct query

begin

end

construct NFA MR for R, with initial state s0 and final state sf
visitedR  
d  0
foreach node n in G do enqueue(QR, (n, n, s0, d))
while (v, n, d)  getNext(X, R, Y ) = null do output (v, n, d)

In particular, when called with conjunct (X, R, Y ), the procedure getN ext
begins by dequeuing a tuple (v, n, s, d) from QR, where v and n are nodes in G,
s is a state in the NFA MR, and d is the distance associated with visiting n in
state s having started from v. If s is the final state then the triple (v, n, d) is
returned. Otherwise we continue to traverse G from n.

Example 4. If we apply our incremental evaluation algorithm to Example 3, we
only need to enqueue (San, San, s0, 0) initially because X is the constant San.
This tuple is dequeued by getN ext and Succ(s0, San) is called. Since the only
edge adjacent to San in G is one labelled name with target San and source u1,
and there is no transition labelled with n
0, u1)
to W and returns. This results in (San, u1, s1

 from s0 in MR, Succ adds n

0, 1) being enqueued.

,1 (s1



The while loop now repeats and (San, u1, s1

called and because there is a transition labelled airplane from s1
edges in G from u1 to u4 and u7 labelled airplane, a,0 (s1

0, 1) is dequeued. Succ(s1
f , u4) and a,0 (s1

0, u1) is
f in MR and
f , u7) are

0 to s1

C.A. Hurtado, A. Poulovassilis, and P.T. Wood

Procedure Succ(si, n)

Input: state si and graph node n
Output: set of transitions which are successors of (si, n)
W  
for (n, a, m)  G do

for pi  nextStates(MR, si, a) do

add a,0 (pi, m) to W ;

for (m, a, n)  G do

for pi  nextStates(MR, si, a

add a



,0 (pi, m) to W ;

) do

/* normal traversal */

/* reverse traversal */

for (n, a, m)  G such that nextStates(MR, si, a) =  do

for (m, a, n)  G such that nextStates(MR, si, a

) =  do

add a,1 (si+1, m) to W ;

add a



,1 (si+1, m) to W ;

/* insertion of a */

/* insertion of a



*/

for pi  nextStates(MR, si, b) for each b   do

for (n, a, m)  G and (m, b, u)  G do

add 	,1 (pi+1, n) to W ;
for pi  nextStates(MR, si, a) and qi  nextStates(MR, pi, b) do

/* deletion of b */

/* swap of a and b */

add ba,1 (qi+1, u) to W ;

return W

Procedure getNext(X, R, Y )

Input: node in query evaluation tree corresponding to conjunct (X, R, Y )
Output: triple (v, n, d), where v and n are instantiations of X and Y
while nonempty(QR) do

(v, n, s, d)  dequeue(QR)
add (v, n, s) to visitedR
if s = si
foreach
?

?

?
f for some i then return (v, n, d)
, m)  Succ(s, n) s.t. (v, m, s
c,w (s

enqueue(QR, (v, m, s

, d + w))
?

?

?
)  visitedR do

return null

added to W . Although the Succ procedure shown would also consider traversals
to u2 and u3 by inserting bus and train respectively, recall that we are assuming
for this example that only name and (name) can be added. After Succ returns,
(San, u4, s1
f , 1) are enqueued. These tuples are at the front
of the queue and when dequeued result in (San, u4, 1) and (San, u7, 1) being
returned because s1
f is a final state. The algorithm continues in this way until

the entire tree shown in Fig. 4 has been traversed.

f , 1) and (San, u7, s1
?

?

?
3 Multi-conjunct Queries

Assume that we have a conjunctive query Q consisting of n conjuncts:

(Z1, . . . , Zm)  (X1, R1, Y1), . . . , (Xn, Rn, Yn)

in which each Xi and Yi, 1  i  n, is a variable or constant, and each Zi is
a variable appearing in the body of Q. Given a matching  from variables and
constants of Q to nodes in a graph G, we have that the tuple (Z1, . . . , Zm) has
distance dist(p1, R1)++dist(pn, Rn) to Q, where each pi is the semipath from
(Xi) to (Yi) which has the minimum edit distance to Ri of any semipath from
(Xi) to (Yi) in G. The approximate top-k answer of Q on G is the list of k
tuples of the form (Z1, . . . , Zm) with minimum distance to Q, ranked in order
of increasing distance to Q.

We also require that the conjuncts of a query Q are acyclic, which is needed to
ensure polynomial-time evaluation2 and means that there is a join tree T whose
nodes are the conjuncts of Q such that, for every variable in Q, the subgraph of
T induced by the conjuncts containing the variable is connected.

Our query evaluation algorithm is based on one of the rank-join algorithms
developed by Ilyas et al. [14], specifically their hash ripple join. That algorithm
takes as input m relations, each of whose sets of tuples has already been ranked
according to some citerion, a join condition, a monotone combining ranking
function and the number k of ranked results to be output. Ranking in their
case is by decreasing value of some score, whereas in our case it is by increasing
distance from Q.

In our case, given a graph G = (V, E), for each conjunct (Xi, Ri, Yi) we can
use the algorithm described in Sect. 2.5 to compute a relation ri over scheme
(Xi, Yi, Di) where, for tuple t  ri, t[Di] represents the minimum distance from
Ri of any path from t[Xi] to t[Yi] in G. Joining the results then uses the hash
ripple join of [14].

Lemma 3. Given a graph G and a multi-conjunct query Q with a fixed number
of head variables m, the approximate answer of Q on G can be computed in time
polynomial in the size of Q and G.

Proof. Each conjunct in Q can be evaluated in polynomial time, as shown in
Lemma 2. The result follows from the acyclicity condition and the fixed number

of head variables [16].

Because Q is acyclic, we can construct a query evaluation tree E for Q, which
consists of nodes denoting join operators and nodes representing conjuncts of Q.
We initialise all the algorithm structures by calling the procedure open, shown
below, with the root of E. The part of procedure open dealing with nodes denoting joins is adapted from [14]: hash tables are built for each child node (operands
LN and RN) and open is called recursively for each; the f irstT uple property of

2 It is well known that the problem of deciding if the natural join of n relations is

nonempty is NP-complete.

C.A. Hurtado, A. Poulovassilis, and P.T. Wood

each is set to true (this is used in the getN ext proceduresee below). The part
of open dealing with nodes denoting conjuncts (X, R, Y ) performs the same initialisations as in Sect. 2.5. For notational simplicity, we assume that each regular
expression in a conjunctive query Q is distinct. Hence, for conjunct (X, R, Y )
we can use MR to denote its NFA, QR its priority queue, etc.

Procedure open(N )

Input: node N in the query evaluation tree
allocate a priority queue QN associated with node N
if N is LN  RN then

build hash tables for LN and RN
open(LN); LN.f irstT uple  true
open(RN); RN.f irstT uple  true
TLNRN  0 ;

else

/* T is the threshold */
/* N is a conjunct (X, R, Y ) */

construct NFA MR for R, with initial state si and final state sf
visitedR  
d  0
foreach node n in G do enqueue(QR, (n, n, si, d))

Incremental evaluation of query Q proceeds by calling the procedure getN ext
with the root of the join tree E. There are two versions of getN ext, one for when
the evaluation tree node represents a join, shown overleaf and adapted from [14],
and one for when it represents a conjunct, which was discussed previously in
Sect. 2.5.

Procedure getNext(LN  RN )

Input: node N (corresponding to a join) in the query evaluation tree
while empty(QLNRN) or head(QLNRN )[D] > TLNRN do

determine next input I // either LN or RN
t  getN ext(I)
if I.f irstT uple then
Itop  t[D]
I.f irstT uple  f alse
Ibottom  t[D]
TLNRN  min(LNtop + RNbottom, LNbottom + RNtop)
insert t in hash table for I
probe other hash table with t
foreach valid join combination u of t with s, say do

u[D]  t[D] + s[D]
enqueue(QLNRN , u)

return dequeue(QLR)

The getN ext procedure for a join begins by choosing from which operand of
the join to retrieve tuples. We do not consider here the various heuristics that
might be used to decide this. For a tuple t, we denote the distance value of t
by t[D]. For input I (either LN or RN), Itop represents the distance value of
?

?

?
the first tuple retrieved from I (i.e., the smallest distance in I), while Ibottom
represents the distance of the most recently retrieved tuple from I. Although Itop
will always be 0 when I is a conjunct, this will not necessary be the case when I
is a join. The threshold value T represents the smaller of the two distances given
by LNtop + RNbottom and LNbottom + RNtop. These two values give the possible
distances arising from joining the first tuple of LN with the most recent tuple
from RN, or vice versa, either of which remains possible until the end of the
operation. The smaller of these two distances gives the smallest possible distance
for a join tuple that has yet to be computed; in other words, no tuple that might
result from the join of tuples yet to be retrieved with tuples already retrieved or
yet to be retrieved can have a distance less than T . It is therefore safe to output
a join tuple whose distance is equal to T .

4 Related Work and Generalisations

Jagadish et al. [11] develop a framework for similarity-based queries, but it turns
out to be too powerful to permit efficient query evaluation. For this reason,
Grahne and Thomo [9] restrict themselves to using weighted regular transducers
for performing transformations to regular path queries in order for them to match
semi-structured data approximately. Their regular path queries consist only of
a single conjunct and do not include inversions.

Similarity-based querying is also the focus of iSPARQL [13], where resources
are compared using similarity measures. One similarity measure used is that of
edit distance between strings. However, similarity is measured with respect to
the resources themselves rather than the paths connecting resources; thus it is
complementary to our approach.

SPARQLeR extends SPARQL with regular path expressions designed for
querying semantic associations [5]. Only exact answers are considered. nSPARQL
adds nested regular expressions to SPARQL and shows that these are necessary
in order to answer queries using the semantics of the RDFS vocabulary by directly traversing the RDF graph [6]. It would be interesting to see whether our
approach of augmenting ordinary regular expressions with a regular transducer
could similarly achieve this.

Kanza and Sagiv consider querying semistructured data using flexible matchings which allow paths whose edge labels simply contain those appearing in the
query to be matched [12]. Such semantics can be captured by our approach by
allowing transpositions and insertions as the only edit operations.

In cooperative query answering, overconstrained queries are automatically relaxed [8,10]. Dolog et al. [8] use conditional rewriting rules on query patterns
to perform both query refinement by including user preferences as well as query
relaxation. Our edit operations and, more generally, regular transducers also
effectively introduce a form of query rewriting, so it would be interesting to
compare the relative expressive power of the two approaches. Our previous work
in [10] was concerned with relaxing queries on RDF by considering query generalisation with respect to an RDFS vocabulary (see that paper for references to

C.A. Hurtado, A. Poulovassilis, and P.T. Wood

other work adopting a similar approach). The substitution edit operation of our
work here subsumes the property relaxation semantics used in [10].

As suggested by Example 2 where a user was prepared to consider travelling
by bus rather than by train, our approach in this paper has some overlap with
work which allows users to specify preferences in queries (e.g. [17]).

We can also apply our work to keyword search in relational databases. Given
nodes v1 to vn in G and assuming that only insertion edit operations are allowed
in approximate matchings, the query

X  (X, 	, v1), . . . , (X, 	, vn)

returns as its first result a median of G, that is, a node with minimum total distance to v1 to vn. A median is effectively what the BANKS algorithm finds [18],
where v1 to vn represent keywords in a relational database.

5 Conclusions

In this paper, we have developed a framework within which we can model various
aspects of approximate answers to queries on semistructured resources including
RDFS. We have presented incremental algorithms which allow answers to be
returned to a user in ranked order in polynomial time.

There are several improvements and generalisations which we are investigat-
ing. One obvious one is a mechanism to allow users and/or interface designers
to specify their requirements in terms of approximation. Another is the ability
to have the paths themselves returned to users, rather than simply nodes.

We are currently working on an implementation of the algorithms presented
above. This will allow us to determine both the utility and the practical efficiency
of the various operations for approximate matching.

Acknowledgements. This work was supported by the Royal Society under
their International Joint Projects Grant Programme. In addition, Carlos Hurtado was partially funded by Fondecyt project number 1080672.
