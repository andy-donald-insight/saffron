Decidable Order-Sorted Logic Programming for

Ontologies and Rules with Argument

Restructuring

Ken Kaneiwa1 and Philip H.P. Nguyen2

1 National Institute of Information and Communications Technology, Japan

2 Department of Justice, Government of South Australia

kaneiwa@nict.go.jp

philip.nguyen@sa.gov.au

Abstract. This paper presents a decidable fragment for combining
ontologies and rules in order-sorted logic programming. We describe
order-sorted logic programming with sort, predicate, and meta-predicate
hierarchies for deriving predicate and meta-predicate assertions. Metalevel predicates (predicates of predicates) are useful for representing
relationships between predicate formulas, and further, they conceptually yield a hierarchy similar to the hierarchies of sorts and predicates.
By extending the order-sorted Horn-clause calculus, we develop a queryanswering system that can answer queries such as atoms and meta-atoms
generalized by containing predicate variables. We show that the expressive query-answering system computes every generalized query in single
exponential time, i.e., the complexity of our query system is equal to
that of DATALOG.

1 Introduction

In the Semantic Web context, conceptual knowledge representation and
reasoning [23] have been studied for modeling ontologies in OWL (Web Ontology Language) [20]. In general, concepts are interpreted by sets of individuals,
and concept hierarchies are constructed by subsumption (similar to IS-A rela-
tions). The formal semantics and reasoning of concept description languages are
guaranteed by logical formalizations. Order-sorted logic [4,22,14] (as first-order
logic with partially ordered sorts) provides sorts and sort hierarchy that represent concepts and their concept hierarchy, respectively. A predicate hierarchy,
which is an extension of the sort hierarchy, consists of n-ary predicates that are
conceptually related to each other. In [13], order-sorted logic programming was
extended by introducing such a predicate hierarchy. Furthermore, the conceptual structure theory [19] was extended to include relation types and their type
hierarchy for building complex ontologies.

Meta-level predicates (predicates of predicates) are expressions that can be
employed for representing relationships between facts in knowledge bases. Similar
to hierarchies of sorts and predicates, these meta-predicates can be used to conceptually construct a hierarchy, e.g., the meta-predicate causes implies the super

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 328343, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
meta-predicate likelyCauses. In the OWL family, meta-concepts are supported
by OWL-Full (the most expressive language of OWL). The semantics of modeling for meta-concepts and the undecidability of meta-modeling in OWL-Full
have been discussed in [18]. Further, higher-order expressions may conceptually
yield a hierarchy when they are named using natural language words. However,
order-sorted (or typed) logic programming lacks representation and reasoning
for such meta-level predicates.

Alternatively, logic programming provides formal semantics and decidable
reasoning services for RuleML (Rule Makeup Language) [1] in the Semantic
Web. This language is a restricted fragment of first-order logic, and its complexities [5] have been studied in the area of automated deduction. It is known that
full logic programming is undecidable, but function-free logic programming (i.e.,
DATALOG) is EXPTIME-complete with respect to the length of a program. In
addition, non-recursive logic programming is NEXPTIME-complete, even if it
includes functions.

However, SWRL (Semantic Web Rule Language) [11], a combination of OWL
and RuleML, leads to undecidable reasoning between ontologies and rules (as
shown in [10]). Several decidable fragments for combining ontologies and rules,
such as DL-safe [9,21], DLP (Description Logic Programs) [7], and the rule-based
language ELP [16] (related to the tractable language profile OWL 2 EL [2]),
have been proposed by restricting the expressive power of rules. Similar to the
approaches adopted in past studies, in order to make ontologies and rules in
logic programing expressive and at the same time retain decidability, the logic
programming language must be carefully extended for conceptual knowledge
representation and reasoning. HILOG [3], which involves the second-order expression of meta-level predicates, has been developed as a decidable higher-order
language for logic programming, and it may be more complex than the EXPTIME complexity of DATALOG. Unfortunately, in most cases, higher-order logic
programming [12] makes reasoning increasingly difficult because complex structures of higher-order terms need to be treated.

To overcome the aforementioned difficulties related to expressiveness and com-
plexity, we introduce meta-predicates and their hierarchy in a restricted and
decidable fragment for combining ontologies and rules. In particular, we formalize an order-sorted logic programming language with a meta-predicate hierar-
chy. As a result, three kinds of hierarchies (sort hierarchy, predicate hierarchy,
and meta-predicate hierarchy) are included in the syntax and semantics of the
sorted logic programming. We develop the order-sorted Horn-clause calculus [8],
which serves as a sorted deductive system, for reasoning on concept hierarchies
where predicate assertions and relationships among the assertions are derived.
This calculus terminates if the knowledge bases are function free (i.e., only constants such as 0-ary functions are allowed). Using this calculus, we develop a
query-answering system that is extended by generalizing queries with predicate
variables. Our result shows that the complexity of the expressive query system
(even for meta-predicates and predicate variables) is single exponential time and
equal to the complexity of DATALOG.

K. Kaneiwa and P.H.P. Nguyen
?

?

?
human

area

illegalAct

natural
Disaster

minor

adult

country

river

mountain

coastalArea

assaults

robs

eruption

tsunami

earthquake

child

volcano

hits

robsWith
Violence

Fig. 1. Sort and predicate hierarchies
?

?

?
likelyCauses

likelyStops

includes

causes

isFollowedBy

stops

exclusively
Happens

spatially
Includes

temporally

Includes

spatioTemporally

Includes

Fig. 2. A meta-predicate hierarchy

2 Motivating Examples

We now present some examples of hierarchies in a query-answering system. Given
the sort, predicate, and meta-predicate hierarchies in Figs. 1 and 2, we consider logical reasoning using a knowledge base for the hierarchies. If the fact
hits(tom:minor,john:adult) is valid, then the super predicate illegalAct
can be derived in the predicate hierarchy (shown in Fig. 1).

hits(tom:minor,john:adult)
?-illegalAct(x:human)
yes
x=tom:minor

In this derivation, the second argument john:adult is deleted if the argument
structure of the predicate illegalAct lacks the second argument of the predicate
hits. Conceptually, both the name and argument structure of illegalAct are
more abstract than hits in the predicate hierarchy.

Moreover, we employ meta-predicates (predicates of predicates) to express relationships among facts in the knowledge base. For example, the meta-predicate
?

?

?
isFollowedBy is used to indicate that a tsunami in Phuket c2 occurred after the
earthquake in Indonesia c1.

isFollowedBy(earthquake(c1:country),tsunami(c2:coastalArea))
?-likelyCauses(earthquake(c1:country),tsunami(c2:coastalArea))
yes

If the relationship between the two facts is valid, the super meta-predicate
likelyCauses can be inferred in the meta-predicate hierarchy (shown in Fig. 2).
Additionally, the fact earthquake(c1:country) is derived from this relation-

ship because it is the first argument of the meta-predicate isFollowedBy.

?-earthquake(c1:country)
yes

The assumption underlying the abovementioned derivation is that the metapredicate points to the occurrence of facts in addition to indicating the existence
of a relationship between them.

An expression with predicate variables X and Y is used to query the validity

of a causal relationship between two natural disasters as follows.

?-likelyCauses(X:naturalDisaster(x:area),

yes
X=earthquake, x=c1:country, Y=tsunami, y=c2:coastalArea

Y:naturalDisaster(y:area))

Using the meta-predicate hierarchy, the reasoning engine should return the answer yes with a successful substitution of the variables, such as X=earthquake,
x=c1:country, Y=tsunami, and y=c2:coastalArea.

In the Semantic Web context, the argument manipulation shown above is very
useful when software agents derive semantically related terms and assertions
using ontologies. This is because the differences between argument structures in
predicates must facilitate such flexible reasoning for predicate assertions in the
sorted logic programming.

3 Order-Sorted Logic with Meta-predicates

We introduce meta-predicates as new conceptual symbols in a sorted language.
These meta-predicates represent n-ary relations among atomic predicate formulas and are used to construct a concept hierarchy.
Definition 1. The alphabet of a sorted first-order language L with sort, predi-
cate, and meta-predicate hierarchies contains the following symbols:

1. S: a countable set of sort symbols
2. Fn: a countable set of n-ary function symbols
3. Pn: a countable set of n-ary predicate symbols
4. n: a countable set of n-ary meta-predicate symbols
?

?

?
5. ,{,}: the connective and auxiliary symbols

6. Vs: an infinite set of variables x: s, y : s, z : s, . . . of sort s
The set of all predicates is denoted by P =
all sorts is denoted by V =
?

?

?
sS Vs.

n1 Pn, and the set of variables of

Definition 2 (Sorted Signatures). A signature of a sorted first-order language L with sort, predicate, and meta-predicate hierarchies (called a sorted sig-
nature) is a tuple  = (S, P, n , ,) such that:
1. (S,) is a partially ordered set of sorts (called a sort hierarchy);
2. (P,) is a partially ordered set of predicates (called a predicate hierarchy);
3. (n ,) is a partially ordered set of n-ary meta-predicates (called a meta-

4.  is a set of function and predicate declarations such that

predicate hierarchy);
(a) if f  Fn, then there is a unique function declaration of the form f : s1
(b) if p  Pn, then there is a unique predicate declaration of the form p: s1

  sn  s  , and
  sn  .

The predicate hierarchy includes predicates with different argument structures,
e.g., a binary predicate can be a subpredicate of a unary predicate. On the
contrary, the meta-predicate hierarchy only contains meta-predicates with a fixed
arity. In the sorted signature,  contains function and predicate declarations that
determine the domains and ranges of functions f and predicates p. In particular,
F0 is the set of 0-ary functions (i.e., constants), and each constant c  F0 has a
unique constant declaration of the form c:  s.

We generally call sorts, predicates, and meta-predicates concepts. Let cp1, cp2,
and cp3 be three concepts. A concept cp2 is called a upper bound for cp1 if
cp1  cp2, and a concept cp2 is called a lower bound for cp1 if cp2  cp1.
The least upper bound cp1  cp2 is a upper bound for cp1 and cp2 such that
cp1  cp2  cp3 holds for any other upper bound cp3. The greatest lower bound
cp1  cp2 is a lower bound for cp1 and cp2 such that cp3  cp1  cp2 holds for
any other lower bound cp3.

We define the following sorted expressions in the sorted signature : terms,
atoms (atomic formulas), meta-atoms (meta atomic formulas), goals, and clauses.
Definition 3 (Sorted Terms). Let  = (S, P, n , ,) be a sorted signature.
The set Ts of terms of sort s is defined by the following:
1. If x: s  Vs, then x: s  Ts.
2. If t1  Ts1 , . . . , tn  Tsn, f  Fn, and f : s1    sn  s  , then
3. If t  Ts and s
Note that Ts contains not only terms of sort s but also terms of subsorts s
sort s if s

  s. The set of terms of all sorts is denoted by T =

f(t1, . . . , tn): s  Ts.

  s, then t  Ts.
?

?

?
 of

The function sort is a mapping from sorted terms to their sorts, defined by
(i) sort(x: s) = s and (ii) sort(f(t1, . . . , tn): s) = s. Let Var(t) denote the set

Ts.

sS
?

?

?
of variables occurring in a sorted term t. A sorted term t is called ground if
Var(t) = . T0 = {t  T |Var(t) = } is the set of sorted ground terms, and the
set of ground terms of sort s is denoted by T0,s = T0  Ts. We write T 
s , T 
0 ,
s,0, and T  for explicitly representing the sorted signature .
T 
In the following definition, sorted Horn clauses [17,6] are extended by metaatoms (A1, . . . , An) that consist of meta-predicates  and atoms A1, . . . , An.

 A.

Definition 4 (Atoms, Meta-atoms, Goals, and Clauses)
Let  = (S, P, n , ,) be a sorted signature. The set A of atoms, the set MA
of meta-atoms, the set G of goals, and the set C of clauses are defined by:
1. If t1  Ts1 , . . . , tn  Tsn, p  Pn, and p: s1   sn  , then p(t1, . . . , tn)
2. If A1, . . . , An  A and   n, then (A1, . . . , An)  MA.
3. If L1, . . . , Ln  A  MA (n  0), then {L1, . . . , Ln}  G.
4. If G  G and L  A  MA, then L  G  C.
Meta-atoms assert n-ary relations  over atoms A1, . . . , An and can appear
in the heads and bodies of extended Horn clauses. For example, the atoms
earthquake(c1 : country) and tsunami(c2 : coastalArea) are used to assert the
meta-atom causes(earthquake(c1 : country), tsunami(c2 : coastalArea)), where
causes is a binary meta-predicate. A clause L  G is denoted by L  if G = .
We define a sorted substitution such that each sorted variable x: s is replaced
with a sorted term in Ts. Each sorted substitution is represented by {x1 : s1/t1,
. . . , xn : sn/tn}. Let  be a sorted substitution. Then,  is said to be a sorted
ground substitution if for every variable x: s  Dom(), (x: s) is a sorted
ground term. Let E be a sorted expression. The substitution  is a sorted ground
substitution for E if E is ground and Dom() = Var(E). The composition 12
of sorted substitutions 1 and 2 is defined by 12(x: s) = 2(1(x: s)).
In , there are various argument structures in the predicate hierarchy (P,)
because P contains predicates with various arities. Additionally, we declare the
argument structure for each predicate p  P in  as follows.
Definition 5 (Argument Declaration). Let  = (S, P, n , ,) be a sorted
signature. An argument declaration  is a pair (AN, ) of a set AN of argument
names and a set  of argument structures of the form p: a1, . . . , an where
p  Pn, a1, . . . , an  AN, and for any i = j, ai = aj.
Given an argument declaration  = (AN, ), we define an argument function
Arg : P  2AN such that Arg(p) = {a1, . . . , an} for each p: a1, . . . , an  . An
argument declaration  is well arranged in the predicate hierarchy if Arg(q) 
Arg(p) for any p, q  P with p  q. Intuitively, the well-arranged argument
declaration implies that the predicate q does not have any argument that its
subpredicate p does not have.
Definition 6 (Argument Elimination). Let  = (S, P, n , ,) be a sorted
signature with an argument declaration  = (AN, ), let d1, . . . , dn be an
?

?

?
n-tuple, and let p  Pn, q  Pm with Arg(q)  Arg(p). An argument elimination
from p to q is a function 

pq(d1, . . . , dn) = d



1, . . . , d
m
i = aj for each 1  i  m
?

?

?
i = dj if a
d
where p: a1, . . . , an and q : a
?

?

?
1, . . . , a
m
The argument eliminations will be used in the semantics and inference system of
the order-sorted logic. An important property of argument eliminations that is
used for the development of predicate-hierarchy reasoning is expressed as follows.

 such that

 in .

Proposition 1 (Transitivity of Argument Eliminations).
Let  be a sorted signature with an argument declaration , let  be an n-tuple,
and let p  Pn, q  Pm, and r  Pk. If p  q, q  r, and  is well arranged in
, then 


pq()) = 


pr().


qr(

This proposition guarantees that argument eliminations are safely embedded in
predicate-hierarchy reasoning if the argument declaration is well arranged.

We define the semantics of the order-sorted logic with sort, predicate, and

meta-predicate hierarchies as follows.

Definition 7 (-Models). Let  be a sorted signature with a well-arranged
argument declaration . A -model M is a tuple (U, UF , I) such that

1. U is a non-empty set of individuals;
2. UF is a non-empty set of facts;
3. I is a function with the following conditions:
(a) if s  S, then I(s)  U (in particular, I() = U),
(b) if si  sj for si, sj  S, then I(si)  I(sj),
(c) if f  Fn and f : s1  sn  s  , then I(f): I(s1) I(sn) 
(d) if p  Pn and p: s1  sn  , then I(p): I(s1) I(sn)  2UF ,
(e) if p  q for p  Pn and q  Pm, then I(p)()  I(q)(
(f) if   n, then I()  U nF ,
(g) if    for ,   n, then I()  I().


pq()),

I(s),

The class of -models is a restricted class of standard models such that the
domains and ranges of functions and predicates are constrained by sorts and the
hierarchies of sorts, predicates, and meta-predicates are interpreted by subset
relations over U, UF, and U nF .

By the argument eliminations in the predicate hierarchy, the following two

properties are derived in the class of -models.
Proposition 2 (Conceptuality of Predicates). Let p  Pn, q  Pm, and
r  Pk and let 1  U n, 2  U m, and   U k. Every -model M has the
following properties:
1. pq  r implies I(p)(1)I(q)(2)  I(r)() with  = 
2. r  p  q implies I(r)()  I(p)(


pr(1) = 

rp())  I(q)(



rq()).


qr(2).
?

?

?
This property is important for showing that predicates are consistently conceptualized in a hierarchy. However, this is not simple because predicates have their
respective arguments that have different structures in the predicate hierarchy.

Even if predicates are conceptually interpreted as sets of tuples, it is necessary

to define a model that can identify each fact expressed by predicate formulas.
Proposition 3 (Identifiability of Predicates). Let  be an n-tuple in U n,
and let p  Pn, q  Pm (p = q). Some -models M have the following properties:
1. If Arg(p) = Arg(q), then there are two facts e1  I(p)() and e2  I(q)().
2. If Arg(p)  Arg(q), then there are two facts e1  I(p)() and e2  I(q)(

pq

()).

We define an interpretation of sorted terms and atoms as follows.

This proposition indicates that any two ground atoms with identical arguments
p(t1, . . . , tn) and q(t1, . . . , tn) can be identified as distinct facts, if necessary. In
the -models, the set of facts UF is used to identify ground atoms such that
predicate assertions correspond to different elements in UF.
A variable assignment on a -model M = (U, UF , I) is a function : V  U
where (x: s)  I(s). The variable assignment [x: s/d] is defined by ( 
{(x: s, (x: s))}){(x: s, d)}. In other words, if v = x: s, then [x: s/d](v) = d,
and otherwise [x: s/d](v) = (v). Let   UF be a valuation of facts on M. A
-interpretation I is a tuple (M, , ) of a -model M, a valuation of facts  on
M, and a variable assignment  on M. The -interpretation (M, , [x: s/d])
is simply denoted by I[x: s/d].
Definition 8. Let I = (M, , ) be a -interpretation. The denotation function [[ ]] : T  U is defined by the following:
1. [[x: s]] = (x: s),
2. [[f(t1, . . . , tn): s]] = I(f)([[t1]], . . . , [[tn]]) with f : s1    sn  s  ,
3. [[p(t1, . . . , tn)]] = I(p)([[t1]], . . . , [[tn]]) with p: s1    sn  .
The satisfiability of atoms, meta-atoms, goals, and clauses is defined by a -
interpretation I.
Definition 9 (-Satisfiability Relation). Let I = (M, , ) with M = (U,
UF , I) be a -interpretation and let F  A  MA  G  C. The -satisfiability
relation I |= F is defined inductively as follows:
1. I |= A iff [[A]]
2. I |= (A1, . . . , An) iff I |= A1, . . . ,I |= An and ([[A1]]
3. I |= {L1, . . . , Ln} iff I |= L1, . . . , I |= Ln.
4. I |= L  G iff for all d1  I(s1),. . . ,dn  I(sn), I[x1 : s1/d1, . . . ,
xn : sn/dn] |= G implies I[x1 : s1/d1, . . . , xn : sn/dn] |= L where Var (L 
G) = {x1 : s1, . . . , xn : sn}.
Let F  A  MA  G  C. An expression F is said to be -satisfiable if for some
-interpretation I, I |= F . Otherwise, it is -unsatisfiable. F is a consequence
of a set of expressions S in the class of -interpretations (denoted S |= F ) if for
every -interpretation I, I |= S implies I |= F .

   [[An]]) 

I() = .

  = .

K. Kaneiwa and P.H.P. Nguyen

4 Horn-Clause Calculus for Predicate Hierarchies

In this section, we define the order-sorted Horn-clause calculus that is extended
by adding inference rules for predicate and meta-predicate hierarchies. A knowledge base K is a finite set of sorted clauses in  where  = (S, P, n , ,) is
a sorted signature with a well-arranged argument declaration .

Definition 10 (Sorted Horn-Clause Calculus). Let C be a ground clause,
K be a knowledge base, and l be a label (non-negative integer). A derivation of
C from K (denoted K # l : C) in the sorted Horn-clause calculus is defined as
follows:
 Sorted substitution rule: Let L  G  K and  be a sorted ground
substitution for L  G. Then, K # l : (L  G) and l is incremented.
{L} be ground clauses. If K # l1 : L  G
 Cut rule: Let L  G and L
and K # l2 : L
  G  G
.
 Predicate hierarchy rule: Let p(t1, . . . , tn)  G be a ground clause. If
m)  G where
K # l1 : p(t1, . . . , tn)  G and p  q, then K # l1 : q(t
?

?

?
1, . . . , t
pq(t1, . . . , tn) = t

 Meta-predicate hierarchy rule: Let (A1, . . . , An)  G be a ground
clause. If K # l1 : (A1, . . . , An)  G and   , then K # l1 : (A1, . . . , An)
 G.
 Fact derivation rule: Let (A1, . . . , An)  G be a ground clause. If K #
l1 : (A1, . . . , An)  G, then K # l : Ai  G with 1  i  n and l is
incremented.

  {L}, then K # l2 : L
?

?

?
1, . . . , t
m

  G

  G

.



We simply write K # l : L if K # l : L . The sorted substitution rule and
the cut rule serve as sorted inference rules in ordinary order-sorted logic. The
sorted substitution rule yields well-sorted ground clauses in the sort hierarchy.
The predicate hierarchy rule and the meta-predicate hierarchy rule can be used
to derive predicate and meta-predicate assertions in the predicate and metapredicate hierarchies, respectively. The fact derivation rule derives atoms from
meta-atoms, which was used in the third motivating example of Section 2.

if a labeled atom l : Ai

To prove the completeness of the Horn-clause calculus, we construct extended
Herbrand models for knowledge bases where positive atoms labeled by nonnegative integers are used to identify different facts. We write K #(A1,...,An)
is directly derived from a labeled meta-atom
l : Ai

l1 : (A1, . . . , An) using the fact derivation rule. Let L  G be a clause. We
define ground(L  G) as the set of sorted ground clauses for L  G. We define
LGK ground(L  G) as the set of sorted ground clauses for
ground(K) =
all L  G in K.
Definition 11 (Herbrand Models). Let K be a knowledge base. A Herbrand
model MH for K is a tuple (UH , UF,H , IH) such that
1. UH = T0,
2. UF,H = N  {l  N | ground(K) # l : L  G & L  MA},
3. IH is a function with the following conditions:
?

?

?
(a) IH(s) = T0,s for each sort s  S,

(b) if f  Fn and f : s1    sn  s  , then IH(f)(t1, . . . , tn) =
(c) if p  Pn and p: s1    sn  , then IH(p)() =
{l  UF,H |
| for every 1  i 
{(l1, . . . , ln)  U nF,H
(d) if   n, then IH() =

f(t1, . . . , tn): s where t1  IH(s1), . . . , tn  IH(sn),
ground(K) # l : q(

qp(

n, ground(K) #(A1,...,An) li : Ai}.
?

?

?
)} with 

) = ,

qp
?

?

?
T0,s1

pP
T0,sn

A Herbrand interpretation IH for K is a tuple (MH, H , ) such that MH =
(UH , UF,H , IH) is a Herbrand model for K, H =
IH(p)()
with p: s1    sn   is a valuation of facts on MH, and  is a variable
assignment on MH.
We show that a Herbrand interpretation IH is a -interpretation that satisfies
a knowledge base K.
Lemma 1. Let K be a knowledge base, let IH be a Herbrand interpretation for
K, and let L  G be a clause. Then, the following statements hold:
1. IH |= L  G if and only if IH |= ground (L  G).
2. IH is a -interpretation of K.
We use the Herbrand model and the abovementioned lemma to prove the completeness of the Horn-clause calculus as follows.
Theorem 1 (Completeness of Horn-Clause Calculus). Let K be a knowledge base in a sorted signature  and L be a ground atom or meta-atom. K |= L
iff K # l : L.
We show the termination of the Horn-clause calculus where a sorted signature
is function-free.
Theorem 2 (Termination of Horn-Clause Calculus). Let K be a knowledge base in a sorted signature . Then, the Horn-clause calculus terminates if
 is function-free.

The termination of the calculus is proved by the fact that the set of derivable
clauses Con(K) = {L  G | K # l : L  G} is finite. In other words, the calculus
cannot generate terms and clauses infinitely because the cardinality of Con(K)
is bounded by finite constant, predicate, and meta-predicate symbols in K.

We show the complexity of the derivation for atoms or meta-atoms L (not
limited to ground) from a knowledge base where the set of ground atoms or
meta-atoms L is computed using the Horn-clause calculus.

Corollary 1 (Complexity of Derivation for Atoms or Meta-atoms)
Let K be a knowledge base in a sorted signature , L be an atom or meta-
atom, and  be a sorted ground substitution for L. If  is function-free, then
deriving the set of ground atoms or meta-atoms L with K # l : L is (single)
EXPTIME-complete (w.r.t. the length of K).

K. Kaneiwa and P.H.P. Nguyen

5 Query System

n

}.

= {(A+

We describe a query-answering system for our order-sorted logic programming.
In this system, query expressions are generalized by adding predicate variables
in meta-atoms. The set of predicate variables is denoted by V. The set of atoms
with predicate variables is defined by AV = {X : p(t1, . . . , tn) | X  V, p(t1, . . . ,
tn)  A}. We call the form X : p(t1, . . . , tn) a predicate variable atom.
Definition 12 (Queries). Let  = (S, P, n , ,) be a sorted signature with
a well-arranged argument declaration , and let MAV
n ) |  
1 , . . . , A+
 A  AV} be the set of meta-atoms with predicate variables.
n , A+
1 , . . . , A+
The set Q of queries is defined by that if L1, . . . , Lh  A  AV  MAV
, then
{L1, . . . , Lh}  Q.
We introduce substitutions for predicate variables X  V such that each predi-
m) is replaced with an atom A  A. We denote
?

?

?
cate variable atom X : q(t
1, . . . , t
the set of atoms restricted to the subpredicates p of q by Aq = {p(t1, . . . , tn) 
A | p  q & 
pq(t1, . . . , tn) = t



1, . . . , t
m
Definition 13 (Substitutions for Predicate Variables)
A substitution for predicate variables is a partial function  : AV  A such that
(X : q(t
The substitutions for predicate variables follow the predicate hierarchy, i.e., a
subpredicate p of q is substituted for the predicate variable atom X : q(). A substitution  is a most specific substitution for a predicate variable atom X : q()
) =  and there is no other substitution 

if (X : q()) = p(
such that 
Definition 14 (Query System). Let Q be a query in Q,  be a substitution
for predicate variables in Q, and  be a sorted substitution for Q. Then, the
query system Query : Q  {yes, no} is defined by the following rule.
(i) If there exists K # l : Q such that V ar(Q)  V =  and V ar(Q) = ,

m))  Aq and the domain of  (denoted Dom()) is finite.
?

?

?
1, . . . , t

) =  and r  p.

) with 
(X : q()) = r(


pq(
) with 


rq(

then Query(Q) = yes.

(ii) Otherwise, Query(Q) = no.
Without losing decidability, the query system is realized in the following two
steps. First, atoms are substituted for predicate variable atoms in a query Q
along with the predicate hierarchy. Second, predicate and meta-predicate assertions in the substituted query Q are derived using the Horn-clause calculus.
Theorem 3 (Termination of Query System). Let K be a knowledge base in
a sorted signature . Then, the query system terminates if  is function-free.
The termination leads to the following corollary that the complexity of the queryanswering system is unaffected by the introduction of predicate variables in the
queries.
Corollary 2 (Complexity of Query System). Let K be a knowledge base in
a sorted signature  and let Q be a query. If  is function-free, then deciding
Query(Q) is (single) EXPTIME-complete (w.r.t. the length of K).
?

?

?
6 Derivation Using Argument Restructuring

In the Horn-clause calculus (discussed in Section 4), redundant arguments in each
predicate are deleted during the derivation of super predicates if the argument
structures are well-arranged in a hierarchy. In this section, we generalize sorted
signatures by removing the condition of their being well-arranged, i.e., some
predicates may have an argument that their subpredicates do not have.

We give some examples of hierarchies in a query-answering system for the case
where argument structures are not well-arranged in the sort, predicate, and metapredicate hierarchies shown in Figs. 1 and 2. If the fact assaults(tom:minor)
is valid, then the super predicate illegalAct can be derived in the predicate
hierarchy as follows.

assaults(tom:minor)
?-illegalAct(x:human,mary:woman)
no
?-illegalAct(x:human,y:human)
yes
x=tom:minor, y=c:human

In the first case, there is no fact that indicates someone acts against the second
argument mary:woman in the query. Thus, the answer to the first query is no. In
the second case, we can obtain the answer yes to the second query from the fact
assaults(tom:minor) and the predicate hierarchy. A new constant c:human is
substituted for the variable y because the argument structure of the predicate
assaults lacks the second argument of the predicate illegalAct.

For such argument structures in a predicate hierarchy (in a sorted signature),
we perform the addition of missing arguments for the derivation of super predicates as follows.
Definition 15 (Naive Argument Restructuring). Let  = (S, P, n , ,)
be a sorted signature with an argument declaration  = (AN, ), let d1, . . . , dn
be an n-tuple, and let p  Pn and q  Pm. An argument restructuring from p to
q is a function +

 such that

if a

pq(d1, . . . , dn) = d
?

?

?
1, . . . , d
m

i = aj
dj
otherwise
 in  and each ci is a new element.
?

?

?
i =
d
where p: a1, . . . , an and q : a
We refine the definition of -models such a way that every argument elimination

pq is replaced with an argument restructuring +
pq. The satisfiability relation

|= is denoted by |=+ if an argument restructuring + is employed in each
-model. The conceptuality and identifiability of predicates in Propositions 2
and 3 hold for the case where the -models are refined by replacement with an
argument restructuring +.
?

?

?
1, . . . , a
m
?

?

?
ci

In order to embed an argument restructuring + in the Horn-clause calculus,

we further extend the calculus as follows.

K. Kaneiwa and P.H.P. Nguyen

.
?

?

?
1, . . . , t
m

K # l1 : p(t1, . . . , tn)  G and p  q, then K # l1 : q(t
pq(t1, . . . , tn) = t
+

Definition 16 (Extended Sorted Horn-Clause Calculus)
Let C be a ground clause and K be a knowledge base. A derivation of C from K
(denoted K #+ l : C) in the sorted Horn-clause calculus is extended by replacing
the predicate hierarchy rule with the following rule:
 Predicate hierarchy rule+: Let p(t1, . . . , tn)  G be a ground clause. If
m)  G where
?

?

?
1, . . . , t
An atom A1 is a parent of another atom A2 if K #+ l : A2  G is derived from
K #+ l : A1  G by an application of the predicate hierarchy rule. An atom
A1 is an ancestor of another atom A2 if (i) A1 is a parent of A2 or (ii) A1 is an
ancestor of an atom A and A is a parent of A2. Let A be an atom p(t1, . . . , tn)
with p: a1, . . . , an  . We denote the occurrence of an argument name ak and
a term tk in A by A[ak, tk] if 1  k  n. The set of pairs of argument names and
terms for a labeled atom l : A is defined by AL(l : A) = {(a, t) | A[a, t]}{(a, t) |
[a, t] is an ancestor of A}.

In the following definition, we introduce a label-based argument restructuring
in order to solve the problem of incomplete derivation, i.e., the transitivity in
Proposition 1 no longer holds if the argument structures are not well-arranged.
Hence, it is necessary to solve the problem to prove the completeness of the
extended sorted Horn-clause calculus.

Definition 17 (Label-Based Argument Restructuring in Derivation)
Let  = (S, P, n , ,) be a sorted signature with an argument declaration
 = (AN, ), let d1, . . . , dn be an n-tuple, let p  Pn and q  Pm, and l be a
label (non-negative integer). An argument restructuring from p to q is label-based
 such that
pq(t1, . . . , tn) = t

if it is defined as a function 
i = aj with (aj, tj)  AL(l : p(t1, . . . , tn))
?

?

?
1, . . . , t
m
?

?

?
if a
?

?

?
i =

t

tj
?

?

?
cl,a
i

otherwise

where p: a1, . . . , an and q : a
 in  and each cl,a

indexed by the pair of the label l and the argument name a
i.
?

?

?
1, . . . , a
m

i is a new constant
?

?

?
We denote the set of new constants that are used to add missing arguments in
 by F0,new. The label-based argument
a label-based argument restructuring 
 can be applied to a tuple of terms t1, . . . , tn in a labeled atom
restructuring 
l : p(t1, . . . , tn) in the derivation. This leads to the following transitivity, although
the transitivity of naive argument restructurings + does not hold.

Proposition 4 (Transitivity of Label-Based Argument Restructurings)
Let  be a sorted signature with an argument declaration , let  be an n-tuple,
and let p  Pn, q  Pm, and r  Pk. If p  q and q  r, then 

pq()) =

pr().

The transitivity of label-based argument restructurings will be used to show the
completeness of the extended sorted Horn-clause calculus.


qr(
?

?

?
Theorem 4 (Completeness of Extended Horn-Clause Calculus)
Let K be a knowledge base in a sorted signature  and L be a ground atom or
meta-atom. K |=+ L iff K # L.
Note that the consequence relation K |=+ L is defined with a naive argument
restructuring + but the derivation K # L is extended to contain a label-based
. This is because K #+ L is incomplete for K |=+ L,
argument restructuring 
i.e., the derivation is insufficient for the semantics.
 lead to the undecidabil-

However, the label-based argument restructurings 

ity of the extended sorted Horn-clause calculus as follows.

Theorem 5 (Undecidability of Extended Horn-Clause Calculus)
The extended Horn-clause calculus does not terminate for a knowledge base K
in a function-free sorted signature .

Let p be an n-ary predicate and  be an n-tuple of sorted terms. We denote an
atom or meta-atom L by Lp if L = p() or L = (A1, . . . , Am) with Ai = p()
for some 1  i  m.
Definition 18 (Paths in a Knowledge Base). Let K be a knowledge base in
 be argument
a sorted signature , let Lp, Lq be atoms or meta-atoms, let a, a
names, and let t be a sorted term. Then, there is a path from Lp[a, t] to Lq[a
, t]
in K if one of the following conditions holds:
1. a = a

2. Lq[a
3. there are two paths from Lp[a, t] to Lr[a

, p  q, and a  arg(p)  arg(q),
, x: s]  G where Lp[a, x: s]  G and t  Ts, and

, t] and from Lr[a

, t] to Lq[a

, t].
?

?

?
In order to avoid the undecidability, we define a restricted set of knowledge bases
(called safe knowledge bases).
Definition 19 (Safe Knowledge Bases). A knowledge base K is safe if
1. V ar(L)  V ar(G) for every clause L  G in K, and
2. there is no path from Lp[a, t] to Lq[a

, t] in K such that q  p, a = a

,
?

?

?
a  arg(q), and a  arg(p).

Lemma 2. Let K be a safe knowledge base in a sorted signature . Then, the
extended Horn-clause calculus with label-based argument restructuring does not
generate new constants infinitely.

Furthermore, we can show the complexity of the extended sorted Horn-clause
calculus with label-based argument restructuring where  is function-free.

Theorem 6 (Complexity of Derivation for Atoms or Meta-atoms)
Let K be a safe knowledge base in a sorted signature , L be an atom or meta-
atom, and  be a sorted ground substitution for L. If  is function-free, then
deriving the set of ground atoms or meta-atoms L with K # l : L is (single)
EXPTIME-complete (w.r.t. the length of K).

K. Kaneiwa and P.H.P. Nguyen

Table 1. The complexities of Horn-clause calculus with argument manipulation

Horn-clause calculus
argument elimination

complexities
EXPTIME

naive argument restructuring

label-based argument restructuring
label-based argument restructuring

for safe knowledge bases

undecidable and incomplete
undecidable and complete

EXPTIME

Table 1 lists the complexities of the Horn-clause calculus with argument elimina-
tion, naive argument restructuring, and label-based argument restructuring. We
can extend the query system by using the Horn-clause calculus with label-based
argument restructuring.

Theorem 7 (Complexity of Extended Query System)
Let K be a safe knowledge base in a sorted signature  and let Q be a query.
If  is function-free, then deciding Query(Q) is (single) EXPTIME-complete
(w.r.t. the length of K).
Due to spatial constraints, detailed proofs of the lemmas and theorems in this
paper have been omitted (see http://kc.nict.go.jp/kaneiwa/).

7 Conclusions

We have developed an order-sorted logic programming language equipped with
concept hierarchies of sorts, predicates, and meta-predicates. Predicates with
differently structured arguments are conceptually interpreted in the semantics.
According to the semantics, predicate-hierarchy reasoning is realized in the hierarchies of predicates and meta-predicates such that predicate assertions are
used as arguments of meta-level predicates. To achieve such enhanced reason-
ing, we design inference rules for predicate and meta-predicate hierarchies in the
order-sorted Horn-clause calculus. We employ the calculus to develop a queryanswering system for generalized queries containing predicate variables. We show
that the complexity of our expressive query-answering system is identical to that
of DATALOG. We analyze several complexity results where argument restructuring gives rise to undecidable reasoning services in the derivation of super
predicates in a predicate hierarchy, but a set of safe knowledge bases preserves
the decidability of the derivation with argument restructuring.
