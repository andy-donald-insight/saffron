Efficient Query Answering for OWL 2

H ector P erez-Urbina, Ian Horrocks, and Boris Motik

Oxford University Computing Laboratory, Oxford, UK

{hector.perez-urbina,ian.horrocks,boris.motik}@comlab.ox.ac.uk

Abstract. The QL profile of OWL 2 has been designed so that it is possible to use database technology for query answering via query rewriting.
We present a comparison of our resolution based rewriting algorithm with
the standard algorithm proposed by Calvanese et al., implementing both
and conducting an empirical evaluation using ontologies and queries derived from realistic applications. The results indicate that our algorithm
produces significantly smaller rewritings in most cases, which could be
important for practicality in realistic applications.

1 Introduction

Ontologies can be used as conceptual schemas to provide an intuitive and unified
view over one or more data repositories, allowing queries to be independent of the
structure and location of the data. The use of ontologies as conceptual schemas
for data repositories has been extensively studied in a variety of contexts, such
as information integration [4]. The use of data repositories to store instance
data is becoming increasingly important, for instance in the semantic Web, due
to the scalability requirements of many applications and the widespread use of
ontologies.

In OWL 2a new version of the OWL ontology language that is currently
a W3C candidate recommendationscalability requirements are addressed by
profilessubsets of the language that enjoy desirable computational properties.
The OWL 2 QL profile was designed to allow query answering via query rewrit-
ing: a query over an OWL 2 QL ontology and a set of instance data stored in
a data repository can be answered by rewriting the query w.r.t. the ontology
and then answering the rewritten query in the data repository. In this paper we
focus on the case where the data is stored in a relational database and accessed
using SQL queries, but the same technique could be applied to data stored in a
triple store and accessed via SPARQL queries.

OWL 2 QL is based on DL-LiteRone of a family of description logics developed by Calvanese et al. [3]. The DL-LiteR rewriting algorithm of Calvanese et
al., which we will refer to as CGLLR, transforms a conjunctive query Q and a
DL-LiteR ontology O into a union of conjunctive queries QO such that the answers to Q and any set of instance data A can be obtained by evaluating QO over
A only. This technique has been implemented in reasoners such as QuOnto1 and

http://www.dis.uniroma1.it/~quonto/

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 489504, 2009.
c Springer-Verlag Berlin Heidelberg 2009

H. P erez-Urbina, I. Horrocks, and B. Motik

Owlgres2. Unfortunately, as shown by Calvanese et al., the size of QO is worstcase exponential w.r.t. the size of Q and O [3], and as we show in Section 4,
realistic ontologies and queries can result in QO being extremely large (e.g.,
containing tens of thousands of conjunctive queries). Thus, on the one hand,
QO may be costly to compute, and, on the other hand, evaluation by RDBMSs
may be costly or even unfeasible. Trying to produce small rewritings is therefore
of critical importance to the practical application of query rewriting in general,
and of OWL 2 QL in particular.

Motivated by the prospect of applying deductive database techniques to improve the scalability of reasoners, in our previous work [9] we considered the
problem of query rewriting for various logics of the DL-Lite and EL families,
the latter being the basis for the OWL 2 EL profile. Our algorithm takes as
input a conjunctive query Q and an ontology O, and uses a resolution-based
technique to produce a rewritten query QO. Although QO will, in general, be
a (possibly recursive) datalog query, and thus necessitate the use of a deductive
database system, the algorithm exhibits pay-as-you-go behavior for various
logics. In particular, if O is a DL-LiteR ontology, then QO is a union of conjunctive queries. Our algorithm can therefore be seen as a generalization and
extension of CGLLR.

In this paper we describe a simplified version of our algorithm that we will refer to as RQR (Resolution-based Query Rewriting). Like CGLLR, RQR rewrites
a query w.r.t. a DL-LiteR ontology to produce a union of conjunctive queries.
RQR differs from CGLLR mainly in the way it handles existential restrictions in
an ontology. First, RQR uses functional terms to keep track of successors whose
existence is implied by such restrictions, while CGLLR relies on a so-called reduction step. Second, RQR directly handles qualified existential restrictions (i.e.,
those where the restriction class is not owl:Thing), whereas CGLLR requires the
elimination of such restrictions using an encoding that introduces new auxil-
iary properties. We describe both algorithms in Section 3 and further discuss
their differences in Section 3.3.

Both the reduction step and the introduction of auxiliary properties can increase the size of the rewriting. Therefore, we conjectured that RQR will often produce smaller rewritings than CGLLR. In order to test the practicality
of query rewriting and the efficiency of the different rewriting techniques, we
have implemented RQR in a query rewriting system that we call REQUIEM3
(REsolution-based QUery rewrIting for Expressive Models), and compared its
behavior with that of our implementation of CGLLR that we refer to as C. The
comparison uses a benchmark suite containing realistic DL-LiteR ontologies and
test queries as well as some artificial ontologies and queries designed to highlight
the differences between the two algorithms. The benchmark suite also included
versions of the ontologies in which qualified existential restrictions have been explicitly encoded using auxiliary properties, as this allowed us to compare the two

http://pellet.owldl.com/owlgres/
http://www.comlab.ox.ac.uk/projects/requiem/
?

?

?
implementations in cases where RQRs native handling of qualified existential
restrictions is not advantageous.

Both algorithms are amenable to optimizations that can reduce the size of the
rewritings. One obvious optimization would be to use query subsumption checks
to eliminate redundant conjunctive queries from the rewriting; we discuss this
and other optimization techniques in Section 3.4. In order to compare optimized
versions of the two algorithms we additionally implemented REQUIEM-SC and
C-SC, both of which first compute the rewriting as in the original version, and
then apply the above-mentioned query subsumption optimization to the result.
Our evaluation showed that, even for ontologies in which qualified existential restrictions were already encoded, REQUIEM produced significantly smaller
rewritings than C in most cases. In one case, for instance, C exceeded the maximum allowed run time (600 seconds) after producing more than 42,000 conjunctive queries; in contrast, REQUIEM completed the rewriting in less than half
a second having produced only 624 queries. Moreover, the rewritings produced
by REQUIEM were often similar or identical to those produced by REQUIEM-
SC, something that was less often the case for C and C-SC; using RQR should,
therefore, reduce the need for (potentially costly) query subsumption checking.

2 Ontology-Based Data Access via Query Rewriting

We next describe how to answer queries over an OWL 2 QL ontology and a
database via query rewriting, illustrating the process by means of an example.
Suppose we have a relational database DB0 containing a table Professor
with attributes name, department, and telephone; and a table Student with
attributes name, major, address, and tutor. We can use a suitable ontology as
a conceptual schema that describes the structure of the data. For example, we
might use the following ontology O0 to describe DB0:4

Teacher  teaches
Professor  Teacher
  Professor

hasTutor

(1)
(2)
(3)

Axiom (1) states that teachers teach at least someone, axiom (2) states that
professors are teachers, and axiom (3) states that the range of the property
hasTutor is Professor.

Given suitable mappings from the classes and properties in the ontology to
data in the database, queries posed in terms of the ontology can be answered
using the database. This has several advantages: on the one hand, queries can
be posed in terms of the conceptual structure of the data rather than its arrangement in the database, and on the other hand, the database provides data
persistence and scalability.
Mappings from the ontology to the database are typically defined using expressions of the form D  QD, where D is a class or property occurring in
4 We use the description logic syntax for the sake of compactness.

H. P erez-Urbina, I. Horrocks, and B. Motik

the ontology and QD is an SQL query over the database; QD could, however,
equally well be a SPARQL query that accesses data in an RDF triple store. In
our example, the mapping M0 between O0 and DB0 is defined as follows:

Professor  SELECT Name FROM Professor
hasTutor  SELECT Name, Tutor FROM Student

Queries posed over the ontology are answered in two steps: first, the ontology
is used to rewrite the query into a union of conjunctive queries; and second,
the mappings are used to transform the rewritten query into an SQL query and
evaluate it using an RDBMS. For example, consider the query

(4)
posed over O0. The rewriting QO0 of query (4) w.r.t. O0 contains (4) and the
following queries:

Q0(x)  teaches(x, y)

Q0(x)  Teacher(x)
Q0(x)  Professor(x)
Q0(x)  hasTutor(y, x)

(5)
(6)
(7)
Transforming QO0 into an SQL query sql(QO0) basically amounts to using M0
to replace each class or property D occurring in a query contained in QO0 with
the corresponding SQL query QD, and forming the union of the resulting queries.
Note that M0 does not contain a mapping for every class and property of O0.
The answer to any query containing an atom for which there is no mapping will
necessarily be empty, and we can therefore discard such queries. Consequently,
queries (4) and (5) can be discarded in our example. As a result, we obtain the
following rewritten SQL query:

sql(QO0) = SELECT Name FROM Professor UNION

SELECT Tutor FROM Student

This query can now be directly evaluated in the RDBMS to compute the answers
to the original query Q0(x).
QO of a given query Q w.r.t. an OWL 2 QL ontology O.

In the rest of the paper we focus on the problem of computing the rewriting

3 Query Rewriting Algorithms

In this section we describe the RQR and CGLLR query rewriting algorithms,
discuss the differences between them, and present various optimizations that can
help us reduce the size of the rewritings.

Before presenting the algorithms, we introduce some notation and defini-
tions. We use the well-known notions of constants, variables, function sym-
bols, terms, and atoms of first-order logic. A Horn clause C is an expression
?

?

?
of the form D0  D1  ...  Dn, where each Di is an atom. The atom D0 is
called the head, and the set {D1, ..., Dn} is called the body. We require that
all the variables occurring in the head of C occur at least in one of its body
atoms. For instance, the expression teaches(x, f(x))  Professor(x) is a Horn
clause. The depth of a term t is defined as depth(t) = 0 if t is a constant
or a variable, and depth(f(s)) = 1 + depth(s) if t is a functional term f(s).
The notion of depth is extended to an atom R(t1, . . . , tn) in the natural way:
depth(R(t1, . . . , tn)) = max(depth(ti)) for 1  i  n. An atom D occurring in
a Horn clause C is said to be the deepest in C if depth(D)  depth(Di) for
every atom Di of C. For instance, the atom teaches(x, f(x)) is the deepest in
the previously mentioned example clause.
A conjunctive query (CQ) Q posed over an ontology O is a Horn clause whose
head predicate does not occur in O, and whose body predicates are class and
property names occurring in O. For instance, (4) is a CQ over the ontology O0.
A union of conjunctive queries (UCQ) over O is a set of conjunctive queries
over O with the same head up to variable renaming [1]. For instance, the query
QO0 composed of queries (4)(7) is a UCQ over the ontology O0. A tuple of
constants a is a certain answer to a UCQ Q over O and a set of instance
data A iff O  A  Q |= QP (a), where QP is the head predicate of Q, and Q
is considered to be a set of universally quantified implications with the usual
first-order semantics. The set of all answers to Q over O and A is denoted by
ans(Q,O  A). Given a conjunctive query Q and an ontology O, a query QO is
said to be a rewriting of Q w.r.t. O if ans(Q,O  A) = ans(QO,A) for every A.
Both algorithms compute the rewriting QO of a given query Q w.r.t.
a DL-LiteR ontology O. DL-LiteR is the basis for OWL 2 QL. Extending the
algorithms to handle the additional features of OWL 2 QL (e.g., datatypes, negative inclusions) is straightforward; we omit the details for the sake of simplicity.

3.1 CGLLR
The algorithm computes QO by using the axioms of O as rewrite rules and
applying them to the body atoms of Q. The algorithm is shown in Algorithm 1.
The partial function ref takes as input an axiom  and an atom D, and returns
an atom ref(D, ) as follows.
 If D = A(x), then we have that (i) if  = B  A, then ref(D, ) = B(x);
  A, then
), then we have that (i) if  = A  P , then ref(D, ) = A(x);
  P ,
, then ref(D, ) = A(x);
,
,
  P , then

(ii) if  = P  A, then ref(D, ) = P (x,
ref(D, ) = P ( , x).
(ii) if  = S  P , then ref(D, ) = S(x,
then ref(D, ) = S( , x).
(ii) if  = S  P
then ref(D, ) = S( , x).
then ref(D, ) = S(x, y); and (ii) if either  = S  P
ref(D, ) = S(y, x).

 If D = P ( , x), then we have that (i) if  = A  P

); and (iii) if  = S

); and (iii) if  = P

 If D = P (x,

); and (iii) if  = S
 If D = P (x, y), then we have that (i) if either  = S  P or  = S

, then ref(D, ) = S(x,

  P
  P

 or  = S

H. P erez-Urbina, I. Horrocks, and B. Motik

Input: Conjunctive query Q, DL-LiteR ontology O
QO = {Q};
repeat

foreach query Q  QO do

(reformulation) foreach atom D in Q

foreach axiom   O do

do

if  is applicable to D then

QO = QO  {Q[D/ref(D, )]};

end

end

end
(reduction) forall atoms D1, D2 in Q

do

if D1 and D2 unify then
 = MGU(D1, D2);
QO = QO  {(Q))};

end

end

end

until no query unique up to variable renaming can be added to QO ;
return QO;

Algorithm 1. The CGLLR algorithm

Input: Conjunctive query Q, DL-LiteR ontology O
R = (O)  {Q};
repeat

(saturation) forall clauses C1, C2 in R do

R = R  resolve(C1, C2);

end

until no query unique up to variable renaming can be added to R ;
QO = {C | C  unfold(ff(R)), and C has the same head predicate as Q};
return QO;

Algorithm 2. Our resolution-based algorithm

If ref(D, ) is defined for  and D, we say that  is applicable to D. The
] denotes the CQ obtained from Q by replacing the body
expression Q[D/D
. The function MGU takes as input two atoms and
atom D with a new atom D
returns their most general unifier [1]. The function  takes as input a CQ Q and
returns a new CQ obtained by replacing each variable that occurs only once in
Q with the symbol  .

Starting with the original query Q, CGLLR continues to produce queries
until no new queries can be produced. In the reformulation step the algorithm
 by using applicable ontology axioms
rewrites the body atoms of a given query Q
as rewriting rules, generating a new query for every atom reformulation. Then,
in the reduction step the algorithm produces a new query (Q
) for each pair
of body atoms of Q

 that unify.
?

?

?
3.2 RQR
The algorithm first transforms Q and O into clauses and then computes QO by
using a resolution-based calculus to derive new clauses from the initial set. The
procedure is presented in Algorithm 2, where we show only those parts of the
original algorithm that are relevant to DL-LiteR. The expression (O) denotes
the set of clauses obtained from O according to Table 1. The function resolve
takes two clauses C1 and C2, and it returns a set containing every clause CR
that can be obtained by combining the atoms of C1 and C2 according to the
inference templates shown in Table 2. A template of the form P1
denotes
that, if C1 is a clause of the form of P1 and C2 is a clause of the form of P2, then
resolve(C1, C2) contains all clauses of the form of R that can be constructed from
C1 and C2; otherwise, resolve(C1, C2) = . The function ff takes a set of clauses
N and returns the subset of the function-free clauses in N. The function unfold
takes a set of clauses N, and returns the set obtained by unfolding every clause
in N; for example, if we have that N = {QP (x)  A(x), A(x)  B(x)}, then
unfold(N) = N  {QP (x)  B(x)}, where QP (x)  B(x) is the result of unfolding A(x)  B(x) into QP (x)  A(x). A formal description of the unfolding
step can be found in [9].
RQR computes QO in three steps: first, in the clausification step, the algorithm transforms Q and O into a set of clauses (O)  {Q}; second, in the
saturation step, the algorithm continues to produce clauses until no new clauses
can be produced; third, in the unfolding and pruning step, clauses that are not
function free are discarded, the remaining clauses are unfolded, and then clauses
that do not have the same head predicate as Q are also discarded.

P2

3.3 Differences

The algorithms mainly differ in the way they handle existential restrictions.
This difference is twofold: first, while RQR deals with axioms containing existential quantifiers on the right-hand side by introducing functional terms,
CGLLR does so by restricting the applicability of such axioms and relying
on the reduction step; second, unlike RQR, CGLLR does not handle qualified existential restrictions nativelythat is, there is no rewriting rule for axioms of the form A  R.B; instead, the algorithm requires a preliminary step
in which each such axiom occurring in O is replaced with a set of axioms
{A  P1,P
1  B, P1  R}, where P1 is a new atomic property not occurring

in O. We explore these differences and their impact on the size of the rewritings
by means of an example.

Consider an OWL 2 QL ontology O1 that consists of the following axiom

Professor  teaches.Student,

which states that a professor teaches at least some student, and the query

Q1(x)  teaches(x, y)  Student(y).

(8)

(9)

H. P erez-Urbina, I. Horrocks, and B. Motik

Table 1. Translating O into a set of clauses (O)

DL-LiteR clause DL-LiteR axiom
A  B
B(x)  A(x)
P (x, f(x))  A(x) A  P
P (x, f(x))  A(x) A  P.B
B(f(x))  A(x)
P (f(x), x)  A(x) A  P 
P (f(x), x)  A(x) A  P .B
B(f(x))  A(x)
A(x)  P (x, y)
A(x)  P (y, x)
S(x, y)  P (x, y) P  S, P   S
S(x, y)  P (y, x) P  S, P   S

P  A
P   A

Note 1. Each axiom of the form A  R.B is uniquely associated with a function
symbol f.

Table 2. Inference templates for the function resolve

C(x)  B(x) B(f(x))  A(x)

C(f(x))  A(x)

B(x)  P (x, y) P (x, f(x))  A(x)

B(x)  A(x)

B(x)  P (x, y) P (f(x), x)  A(x)

B(f(x))  A(x)

B(x)  P (y, x) P (x, f(x))  A(x)

B(f(x))  A(x)

B(x)  P (y, x) P (f(x), x)  A(x)

B(x)  A(x)

S(x, y)  P (x, y) P (x, f(x))  A(x)

S(x, f(x))  A(x)

S(x, y)  P (x, y) P (f(x), x)  A(x)

S(f(x), x)  A(x)

S(x, y)  P (y, x) P (x, f(x))  A(x)

S(x, y)  P (y, x) P (f(x), x)  A(x)

S(f(x), x)  A(x)

S(x, f(x))  A(x)

where  = MGU(P (s, t), P (x, f(x)), and P (s, t) is deepest in its clause.

where  = MGU(P (s, t), P (f(x), x), and P (s, t) is deepest in its clause.

where  = MGU(B(t), B(f(x)), and B(t) is deepest in its clause.

Di(ti) B(f(x))  A(x)

Di(ti)

QP (u)  B(t) 
QP (u)  P (s, t) 
QP (u)  P (s, t) 

QP (u)  A(x) 
QP (u)  A(x) 
QP (u)  A(x) 

Di(ti) P (x, f(x))  A(x)

Di(ti)

Di(ti) P (f(x), x)  A(x)

Di(ti)
?

?

?
We first analyze the execution of CGLLR. Note that CGLLR cannot handle

axiom (8) natively, and it must first be replaced with the following axioms:

Professor  Raux
R
 Student

aux
Raux  teaches

(10)
(11)
(12)

In the first iteration, axiom (12) is applicable to the atom teaches(x, y) in (9).
Similarly, axiom (11) is applicable to Student(y) in (9). Therefore, we obtain the
following queries in the reformulation step:

Q1(x)  Raux(x, y)  Student(y)
Q1(x)  teaches(x, y)  Raux( , y)

(13)
(14)

In this iteration no query can be obtained in the reduction step. In the next itera-
tion, axiom (10) is not applicable to the atom Raux(x, y) in (13) because y occurs
in (13) in more than one place. Axiom (10) cannot be applied to (13) because
CGLLR does not keep track of information about role successors; furthermore,
if we naively allowed existential quantification axioms to be applied, the resulting calculus would become unsound. To illustrate this point, suppose that (10)
were applicable to Raux(x, y) in (13), and ref(Raux(x, y), (10)) = Professor(x);
we would then obtain the query

Q1(x)  Professor(x)  Student(y).

(15)

Note that the relation between x and y is lostthat is, the fact that the individual represented by y must be a teaches-successor of the individual represented
by x is not captured by query (15).

Although the applicability of (10) is restricted, axiom (11) is applicable to
Student(y) in (13). Similarly, axiom (12) is applicable to teaches(x, y) in (14).
Both reformulations produce the query

Q1(x)  Raux(x, y)  Raux( , y).

(16)

In the next iteration, no axiom is applicable to any body atom of (16), so no
query is added in the reformulation step. In the reduction step, however, the
algorithm produces

Q1(x)  Raux(x,

)

(17)

by unifying the body atoms of (16). In the following iteration, axiom (10) is
applicable to the only body atom of (17), producing
Q1(x)  Professor(x).

(18)

Note that without the reduction step, the algorithm would not have produced
query (18). It can be easily verified that no more new queries can be produced;
thus, CGLLR returns {(9), (13), (14), (16), (17), (18)}.

H. P erez-Urbina, I. Horrocks, and B. Motik

We now analyze the execution of RQR. According to Table 1, axiom (8) is
translated into the following clauses:

teaches(x, f(x))  Professor(x)
Student(f(x))  Professor(x)

In the saturation step the algorithm produces

resolve((9), (19)) = Q1(x)  Professor(x)  Student(f(x))
resolve((9), (20)) = Q1(x)  teaches(x, f(x))  Professor(x)
resolve((19), (22)) = Q1(x)  Professor(x)

(19)
(20)

(21)
(22)
(23)

Note the difference between queries (15) and (21). Since the function symbol f
is uniquely associated with clause (19), unlike query (15), query (21) captures
the fact that the individual represented by f(x) must be a teaches-successor of
the individual represented by x. It can easily be verified that no other clause is
produced in the first step. Clearly, ff(R) = {(9), (23)}. In this case, there is no
unfolding to be done, so RQR returns {(9), (23)}.

As shown in the above example, the introduction of auxiliary properties can
lead to an increase in the size of the rewritings. The reduction step alone, how-
ever, can also lead to larger rewritings. This situation arises especially in the case
where part of the data of the database describes a graph. As a simple example,
consider an OWL 2 QL ontology O2 that consists of the axiom

Student  hasTutor,

(24)

which states that a student has at least one tutor, and the query
Q2(x) hasTutor(x, y)  hasTutor(z, y)  hasTutor(z, w)  hasTutor(x, w).
(25)

When using CGLLR, axiom (24) is not applicable to query (25), so no query is
produced in the reformulation step. However, every pair of body atoms in query
(25) unify, and it is easy to see that for each query of this form with m body
new queries in the reduction step. Eventually, the
atoms, CGLLR produces
reduction step produces the query
?

?

?
m

Q2(x)  hasTutor(x,

).

(26)

Axiom (24) is now applicable to query (26), and the following query is produced
in the reformulation step:

Q2(x)  Student(x)

(27)

Note, however, that several queries needed to be produced in the reduction step
in order to produce query (27) in the reformulation step.
 produced from a query Q
in the reduction step, there is a substitution  such that Q  Q
, in which case

An important remark is in order. For every query Q
?

?

?
. It is well known that every query that is subsumed
we say that Q subsumes Q
by another can be discarded after the rewriting has been computed without affecting completeness [5]; however, identifying such queries is not straightforward
since CGLLR does not keep track of which queries were produced in the reduction step. In our example, query (25) subsumes query (26) by the substitution
 = {z  x, w  y}; therefore, query (26) can be safely discarded from the final
rewriting. In this case, however, note that query (26) subsumes query (25) as
well; therefore, it is sensible to eliminate query (25) instead since it is larger.
Since both queries subsume each other, we say that they are equivalent. More-
over, since query (26) is the minimal equivalent subquery of query (25), we say
that query (26) is a condensation of query (25) [2]. The potential generation of
condensations by the reduction step plays an important role in the optimization
of the rewritings. We discuss this aspect further in the following section.

The use of functional terms makes RQR more goal-oriented, in the sense that
it does not need to derive the irrelevant queries produced by the reduction step
of CGLLR in order to be complete. Moreover, RQR handles qualified existential
restrictions natively, whereas CGLLR needs to encode them away by introducing
new properties and axioms.

3.4 Optimizations

As discussed in the introduction, both algorithms are amenable to optimization.
One obvious optimization technique is to check subsumption between pairs of
conjunctive queries and eliminate any query that is subsumed by another. Such
a procedure can be simply (albeit not necessarily optimally) applied a posteriori
to the rewritings produced by RQR and CGLLR.

It is important to note that using the query subsumption optimization with
RQR and CGLLR does not necessarily result in exactly the same rewritings. This
is due to the fact that the CGLLR reduction step may produce condensations.
We illustrate this point with an example. Consider an OWL 2 QL ontology O3
that consists of the following axiom
teaches

  Student,

(28)

which states that someone that is taught is a student, and the query

Q3(x)  teaches(x, y)  Student(y).

CGLLR produces a set containing (29) and the following queries:

Q3(x)  teaches(x, y)  teaches( , y)
Q3(x)  teaches(x,

)

(29)

(30)
(31)

Note that query (31) was produced in the reduction step from (30) and it is a
condensation of (30). In the query subsumption check we have that query (31)
subsumes query (29), so the latter is discarded. Note, however, that query (31)
subsumes query (30) and vice versa. Therefore, since it is sensible to discard the

H. P erez-Urbina, I. Horrocks, and B. Motik

larger query, the condensation (31) is kept and query (30) is discarded instead.
It is easy to see that in the end we obtain {(31)}.

When using RQR, axiom (28) is translated into the following clause:

Student(x)  teaches(y, x)

(32)

The algorithm then produces a set containing (29) and the following clause:

Q3(x)  teaches(x, y)  teaches(z, y)

(33)

Since (33) subsumes (29), it is easy to see that after the query subsumption check
we obtain {(33)}. As can be seen, (31) is slightly smaller than (33); it is also a
condensation of (33). In our empirical evaluation (see Section 4), the optimized
versions of RQR and CGLLR produced the same rewritings modulo the condensations produced by CGLLR. Modifying RQR to replace queries with their
condensations before the query subsumption check would be straightforward.

Finally, we briefly describe two other well-known optimizations: forward and
backward subsumption [2]. Both optimizations compare each new clause C produced in the saturation step with the set of previously generated clauses. In
forward subsumption, C is discarded if the set of clauses already contains a
 is removed from the
clause C
set of clauses if it is subsumed by C.

 that subsumes C; in backward subsumption, C

Since RQR is based on a resolution calculus, both forward and backward subsumption can be straightforwardly applied without affecting completeness [2].
In the case of CGLLR, however, forward subsumption cannot be (straightfor-
wardly) applied: every query produced in the reduction step is subsumed by
another previously produced query; forward subsumption would thus effectively
eliminate the reduction step, and so compromise completeness. For example, forward subsumption would remove query (26) in the above example, preventing
the generation of query (27). It is not clear whether backward subsumption can
be applied to CGLLR without affecting completeness.

4 Evaluation

In this section we present an empirical evaluation of our implementations of
the RQR and CGLLR algorithms. RQR is implemented in a rewriting system
that we call REQUIEM, while our CGLLR implementation is called C. We also
implemented optimized versions of the two algorithms that try to reduce the size
of the rewriting using an a posteriori query subsumption checkthese are called
REQUIEM-SC and C-SC, respectively. Note that C-SC eliminates queries that
contain auxiliary properties (introduced by the encoding of qualified existential
restrictions) before performing the query subsumption check. Both REQUIEM
and C are available at REQUIEMs Web site.

The main goal of the evaluation is to compare the algorithms w.r.t. the size of
the rewritings they produce. Simply counting the number of conjunctive queries
?

?

?
in each rewriting might not provide a fair comparison as the queries themselves
could differ in size; we therefore additionally measured the total number of symbols needed to represent the complete rewriting in the standard datalog notation.
We also measured the time taken for each rewriting procedure. In view of our relatively na ve implementations, however, this may not provide a very meaningful
measure of the likely cost of the rewriting process. We therefore also measured
the number of inferences performed by each algorithm, where by an inference
we mean the derivation of a query. Note that the number of inferences is not
necessarily the same as the number of queries in the final rewriting since an
algorithm may derive the same query more than once.

Tests were performed on a PC running Windows XP with a 2.59 GHz Intel
processor and 1.87 GB of RAM. We used Java 1.6.0 Update 7 with a maximum heap size of 256 MB. Tests were halted if execution time exceeded 600
seconds.

4.1 Test Ontologies and Queries

The test set mainly consists of DL-LiteR ontologies that were developed in the
context of real applications, along with test queries that are based on canonical
examples of queries used in the corresponding application.

V is an ontology capturing information about European history, and developed
in the EU-funded VICODI project.5 S is an ontology capturing information about
European Union financial institutions, and developed for ontology-based data
access [10]. U is a DL-LiteR version of LUBM6a benchmark ontology developed
at Lehigh University for testing the performance of ontology management and
reasoning systemsthat describes the organizational structure of universities. A
is an ontology capturing information about abilities, disabilities, and devices, and
developed to allow ontology-based data access for the South African National
Accessibility Portal [7].

We additionally included two synthetic ontologies in our tests in order to provide a controlled scenario to help us understand the impact of the reduction step.
P1 and P5 model information about graphs: nodes are represented by individu-
als, and vertices are assertions of the form edge(a, b). The ontology P5 contains
classes representing paths of length 15, while P1 contains a class representing
paths of length 1 only.

Finally, for every ontology containing qualified existential restrictions, we created an ontology where the relevant axioms have been replaced by applying the
encoding required in CGLLR. We included these ontologies in order to measure
the impact of the encoding and the saturation step separately. These ontologies
are identified with the name of the original ontology and the suffix X. In our
discussion, we refer to these ontologies as the AUX ontologies and we refer to
the others as the original ontologies. All the ontologies and queries are available
at REQUIEMs Web site.

http://www.vicodi.org/
http://swat.cse.lehigh.edu/projects/lubm/

H. P erez-Urbina, I. Horrocks, and B. Motik

Fig. 1. Results

The number of classes, properties, and axioms are as follows:

classes

properties 10 12 26

axioms

4.2 Results

194 18 34 74 2 6 35 74
1 1 31 31

A P1 P5 UX AX P5X
?

?

?
222 51 127 137 2 10 137 189 18

Figure 1 shows the results of the empirical evaluation. For each ontology and
query, the column Queries shows the number of conjunctive queries in the
rewriting, the column Symbols shows the number of symbols needed to represent the rewriting in datalog notation, the column Inferences shows the number of inferences that were performed by each implementation to compute the
?

?

?
rewritings (note that the number of inferences for REQUIEM and REQUIEM-
SC, and for C and C-SC, is always the same), and the column Time shows
the number of milliseconds taken to compute the rewritings.

Comparing REQUIEM to C w.r.t. the original ontologies, it can be seen that
REQUIEM produced smaller rewritings than C in 25 out of 30 cases and equal
sized rewritings in the remaining 5 cases. Moreover, REQUIEM was often faster
and performed fewer inference steps, particularly in non-trivial cases (i.e., where
both implementations took more than 1,000ms). The differences in the size of
the rewritings are often significant: in the fifth queries over U, S, and P5, for
example, the rewritings produced by C contain between two and four times
as many queries (and contain correspondingly larger numbers of symbols). In
the fifth query over A, C had already produced more than 42,000 queries when
it exceeded the 600 second time limit; in contrast, REQUIEM completed the
rewriting in less than 350ms and produced only 624 queries.

When we compare REQUIEM to REQUIEM-SC, we can see that they produced the same rewritings in 19 out of 30 cases. In some cases, however, the
rewriting produced by REQUIEM was much larger: in the fifth query over S, for
example, REQUIEMs rewriting contained 2,880 queries compared to only 8 for
REQUIEM-SC. As we might expect given the larger rewritings produced by C,
it produced the same rewritings as C-SC in only 6 out of 30 cases. The differences in size were also generally larger: in the fifth query over S, for example, Cs
rewriting contained 11,487 queries compared to only 8 for C-SC. The large size
of the rewritings produced by C also mean that performing query subsumption
tests over these rewritings can be costly. In the fifth query over S, for example,
C-SC takes nearly three times as long as C.

Comparing REQUIEM-SC to C-SC, we can see that REQUIEM-SC produced
the same rewritings as C-SC in 21 out of 30 cases, larger rewritings in 8 cases, and
a smaller rewriting in the remaining case (due to the fact that C-SC exceeded
the maximum time of 600 seconds). The differences in size are minimal, and the
number of queries in the rewritings is always the same (with the exception of
the case where C-SC exceeded the time limit). Note that the smaller rewritings
produced by C-SC are due to its generation of condensations (see Section 3).

If we turn our attention to the AUX ontologies, we can see that REQUIEM
still produced smaller rewritings than C in 12 out of 15 cases, although the
differences were less marked. Moreover, REQUIEM still performed less inferences
than C in 9 out of 15 cases. In contrast to the results with the original ontologies,
REQUIEM was slower than C in 10 out of 15 cases; the differences, however,
were generally small.

Our analysis suggests that REQUIEM will produce significantly smaller
rewritings than C and will be significantly faster, particularly in cases where the
queries are relatively complex and/or the ontologies contain a relatively large
number of qualified existential restrictions. The size of the rewritings produced
in some cases also means that a query subsumption check may be prohibitively
costly in practice with CGLLR, even when queries containing auxiliary properties are removed before performing the check. Moreover, the results for the

H. P erez-Urbina, I. Horrocks, and B. Motik

AUX ontologies suggest that the reduction step alone has a negative impact on
the size of the rewritingsthat is, the introduction of auxiliary properties does
contribute to producing large rewritings, but it is not the only cause.

5 Future Work

We plan to implement an ontology-based data access system using REQUIEM
enhanced with various optimizations (i.e., forward/backward subsumption, query
subsumption, and query condensation); we expect such a system to perform well
both w.r.t. the size of the rewritings and the time needed to compute them. The
practicality of such a system is, however, still open, as our results suggest that
there are cases where the rewritings may be too large to evaluate. In such cases,
we believe that a further optimization that uses the mappings to prune irrelevant queries (as described in Section 2) might produce rewritings of manageable
proportions. We plan to test our system with actual data in order to discover if
this is indeed the case. Finally, we plan to extend the system to support all of
OWL 2 QL, which mainly involves adding support for datatypes.
