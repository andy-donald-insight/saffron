Goal-Directed Module Extraction for Explaining OWL

DL Entailments

Jianfeng Du1,2, Guilin Qi3,4, and Qiu Ji3

1 Institute of Business Intelligence and Knowledge Discovery,

Guangdong University of Foreign Studies, Guangzhou 510006, China
2 State Key Laboratory of Computer Science, Institute of Software,

Chinese Academy of Sciences, Beijing 100190, China

jfdu@ios.ac.cn

3 AIFB, Universit at Karlsruhe, D-76128 Karlsruhe, Germany

{gqi,qiji}@aifb.uni-karlsruhe.de

4 School of Computer Science and Engineering, Southeast University, Nanjing, China

Abstract. Module extraction methods have proved to be effective in improving
the performance of some ontology reasoning tasks, including finding justifications to explain why an entailment holds in an OWL DL ontology. However,
the existing module extraction methods that compute a syntactic locality-based
module for the sub-concept in a subsumption entailment, though ensuring the
resulting module to preserve all justifications of the entailment, may be insufficient in improving the performance of finding all justifications. This is because
a syntactic locality-based module is independent of the super-concept in a subsumption entailment and always contains all concept/role assertions. In order to
extract smaller modules to further optimize finding all justifications in an OWL
DL ontology, we propose a goal-directed method for extracting a module that
preserves all justifications of a given entailment. Experimental results on large
ontologies show that a module extracted by our method is smaller than the corresponding syntactic locality-based module, making the subsequent computation
of all justifications more scalable and more efficient.

1 Introduction

As the Semantic Web (SW) is evolving, ontologies become more and more important
because they provide formal representation of knowledge shared within the SW. To
enable users to understand the knowledge in a consistent way, ontologies need to be
logically constructed and have well-defined semantics. To this end, the W3C organization proposed the Web Ontology Language (OWL)1 for representing ontologies, which
is based on Description Logics (DLs) [1]. With well-defined semantics from DLs, some
important ontology reasoning tasks emerged, including classical reasoning tasks like
subsumption checking and instance retrieval [1], and non-standard reasoning tasks like
finding justifications to explain why an entailment holds in a given ontology [12,17],
where a justification of an entailment is a minimal subset of axioms in the given ontology that are responsible for the entailment.

1 http://www.w3.org/TR/owl-semantics/

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 163179, 2009.
c Springer-Verlag Berlin Heidelberg 2009

J. Du, G. Qi, and Q. Ji

Reasoning tasks in OWL ontologies are in general computationally hard, thus rely
on optimization techniques. To improve the performance of ontology reasoning, module extraction methods are often employed and their effectiveness has been adequately
verified. A module extraction method reduces a given ontology to a specific module
depending on specific tasks. These tasks include ontology reuse [16,4], subsumption
checking [21], incremental classification [7] and finding of justifications [2,22].

In this paper, we focus on the problem of extracting small modules to improve the
performance of an important reasoning task, namely finding all justifications of a given
entailment. The idea of using modules to optimize finding justifications is not new.
It has been shown in [2] and [22] that the syntactic locality-based module introduced
in [8] can be used to improve the performance of finding all justifications. As proved
in [22], a syntactic locality-based module is a module that preserves all subsumption
entailments A  B w.r.t. a concept name A and is independent of the super-concept B.
It follows that the extraction of a syntactic locality-based module is not goal-directed;
it may yield an unexpectedly large module as illustrated below.
Example 1. Let O be an ontology consisting of the following axioms.
ax1 : ChiefActress  Person
ax4 : Person  Man  Woman
Consider the above example. There are two justifications {ax1, ax4, ax5} and {ax2,
ax3} of the subsumption entailment ChiefActress  Woman in O. The syntactic
locality-based module w.r.t. ChiefActress in O is exactly O. This module cannot be
used to optimize finding all justifications of a subsumption entailment of the form
ChiefActress  B no matter what the concept name B is. On the other hand, a syntactic
locality-based module must contain all concept/role assertions because these assertions
can never be local [8]. This means that extracting a syntactic locality-based module can
hardly optimize finding justifications of a membership entailment A(a) or R(a, b), as
all concept/role assertions in the given ontology must be involved.

ax2 : ChiefActress  Actress
ax5 : ChiefActress  Man

ax3 : Actress  Woman

In order to extract modules smaller than the syntactic locality-based ones to further
optimize finding justifications, we propose a goal-directed method for module extraction in SHOIQ ontologies (see Section 4). The DL SHOIQ corresponds to OWL DL
allowing qualifying number restrictions. Since the problem of finding justifications of
a subsumption entailment can be reduced to the problem of finding justifications of a
membership entailment by introducing new concept assertions, our method focuses on
finding a module that preserves all justifications of a given membership entailment. The
basic idea is to start from a given membership entailment and backward traverse a set of
axioms that might be responsible for the given entailment. To ensure the traversed set
to be an intended module, our method compiles a propositional program from the given
ontology in which each clause may have a flag corresponding to an axiom in the given
ontology, such that the traversal of clauses corresponds to the traversal of axioms, i.e.,
the set of flags appearing in the traversed clauses corresponds to an intended module.

We implement the proposed method and test on large ontologies (see Section 5).
Experimental results show that our method can extract modules that are much smaller
than syntactic locality-based modules. They also show that, with our proposed module
extraction method, it is possible to efficiently find all justifications of a membership
entailment in a large ontology with millions of ABox axioms.
?

?

?
2 Related Work

Module extraction methods form an important category in ontology modularization.
Some methods rely on syntactically traversing axioms in the ontology and exploiting
different heuristics to determine which axioms belong to the extracted module, such as
those given in [16], [18] and [4]. Other methods formally specify the intended outputs
by considering the semantics of the ontology language, such as the method proposed by
Cuenca Grau et al. [8], which computes a so-called locality-based module that preserves
all subsumption entailments A  B for a given concept name A. There are two kinds
of locality-based modules, namely semantic ones and syntactic ones, both contain all
concept/role assertions [8]. The method proposed by Suntisrivaraporn [21] computes
so-called reachability-based modules in EL+ ontologies, which coincide with syntactic
locality-based modules. The above methods do not concern extracting a suitable module
to optimize finding all justifications.

Another important category in ontology modularization is formed by ontology partitioning methods, each of which divides a given ontology into a set of modules. For
example, Stuckenschmidt and Klein [20] propose a method to partition all concepts in
an ontology to facilitate visualization of the ontology; Cuenca Grau et al. [9] propose a
method for dividing an ontology into a set of modules such that all inferences about the
signature contained in a module can be made locally. These methods are less relevant
to ours because they yield a set of modules other than a single one.



3 Preliminaries
SHOIQ Syntax and Semantics. A SHOIQ ontology O consists of a terminological box (TBox) OT and an assertional box (ABox) OA. The TBox OT consists of a
finite set of concept inclusion axioms C  D, transitivity axioms Trans(R) and role
inclusion axioms R  S, where C and D are SHOIQ concepts, and R and S roles.
for some role name R; it is called
A role is either a role name or an inverse role R
simple if it has not any transitive subrole. The set of SHOIQ concepts is the smallest
set such that each concept name A (also called atomic concept) is a SHOIQ concept
and, for C and D SHOIQ concepts, R a role, S a simple role, a an individual, and n a
nonnegative integer, , , {a}, C, CD, C D, R.C, R.C, n S.C and n S.C
are also SHOIQ concepts. The ABox OA consists of a finite set of concept assertions
C(a), role assertions R(a, b) or R(a, b), equality assertions a  b and inequality assertions a  b, where C is a SHOIQ concept, R a role, and a and b individuals. In
this paper, both OT and OA are treated as sets of axioms, so is O = OT  OA.
As a fragment of first-order logic, SHOIQ inherits its semantics from first-order
logic by the standard translations known e.g. from [14]. Let  denote the operator for
mapping a SHOIQ ontology (resp. axiom) to a first-order logic program (resp. clause)
as given in [14]. Then O is called consistent or satisfiable if (O) has a model. An
atomic concept A is called satisfiable in O if there exists a model M of (O) such
that A(a)  M for some constant a. O is called coherent if all atomic concepts in O
are satisfiable. When O has atomic concepts, O being coherent implies O being consis-
tent. An axiom ax is called an entailment of O, denoted by O |= ax, if (ax) is satisfied
?

?

?
by all models of (O). An entailment of O is called a subsumption entailment (resp. a
membership entailment) if it is of the form C  D (resp. C(a) or R(a, b)).
First-Order Logic. We use the standard clausal form to represent a first-order logic
program. Terms are variables, constants or functional terms of the form f(t1, . . . , tn),
where f is a function symbol of arity n and t1, ..., tn are terms. Throughout this paper,
we use (possibly with subscripts) x, y, z for variables, a, b, c for constants, and s, t for
terms. We only consider unary function symbols because only unary function symbols
occur in first-order logic programs that are translated from SHOIQ ontologies.

Atoms are of the form T (t1, . . . , tn) where T is a predicate symbol of arity n and
t1, . . . , tn are terms. A literal is a positive or negative atom and a clause is a disjunction
of literals. Terms, atoms and clauses that do not contain variables are called ground.
A first-order logic program is a set of clauses in which all variables are universally
quantified. For a clause cl = A1  . . .  An  B1  . . .  Bm, the set of atoms
{A1, . . . , An} is denoted by cl
, whereas the set of atoms {B1, . . . , Bm} is denoted by
cl+. By |S| we denote the cardinality of a set S. A clause cl is called a fact if |cl
| = 0.
A propositional program  is a first-order logic program consisting of only ground



clauses. The set of ground atoms occurring in  is denoted by atoms().

  M . P is said to be satisfiable if P has a model.

  M , cl+  M = ; it is a minimal model of P if there is no model M

For a first-order logic program P , the set of ground terms (resp. ground atoms) defined from the first-order signature of P is called the Herbrand universe (resp. Herbrand
base) of P , denoted by HU(P ) (resp. HB(P )). The set of ground clauses obtained by
replacing all variables occurring in each clause in P with ground terms from HU(P ) is
called the primary grounding of P , denoted by G(P ). An interpretation M of P is a set
of ground atoms in HB(P ); it is a model of P if for any ground clause cl  G(P ) such
of P
that cl
such that M
The first-order logic program P translated from a SHOIQ ontology may contain
the equality predicate , which is interpreted as a congruence relation and different
from ordinary predicates. This difference is not captured by the above first-order seman-
tics. However, the equality predicate  can be explicitly axiomatized via a well-known
transformation from [6]. Let E(P ) denote the first-order logic program consisting of the
following clauses: (1) t  t, for each ground term t  HU(P ); (2) (x  y)  y  x;
(3) (x  y)(y  z) x  z; (4) (x  y) f(x)  f(y), for each function symbol f occurring in P ; (5) T (x1, . . . , xi, . . . , xn)(xi  yi)T (x1, . . . , yi, . . . , xn),
for each predicate symbol T other than  occurring in P and each position i. Appending E(P ) to P allows to treat  as an ordinary predicate, i.e., M is a model of P that
interprets  as a congruence relation, iff for any ground clause cl  G(P  E(P )) such
that cl

  M , cl+  M = .
?

?

?
4 Goal-Directed Module Extraction
We in this paper address the following problem: Given a coherent SHOIQ ontology O
which contains atomic concepts (thus O is consistent too) and an entailment ax of the
form A  B, A(a) or R(a, b) in O, where A and B are concept names, R a role name,
and a and b individuals, extract a just-preserving module of O for ax, which preserves
all justifications of ax.
?

?

?
offline phase

a given ontology

online phase

How to compute?

compile

ax

a given entailment

extract

rel

indentify Orel

transform

a relevant subset of 

a just-preserving module

a first-order logic program


an approximate grounding

Fig. 1. Illustration of our proposed method

of J , J  |= ax.

Definition 1 (Justification). For O an ontology and ax an axiom such that O |= ax,
a subset J of axioms in O is called a justification of ax in O if J |= ax and for all
proper subsets J 
Definition 2 (Just-Preserving Module). For O an ontology and ax an axiom such that
O |= ax, a subset M of axioms in O is called a just-preserving module of O for ax if
J  M for all justifications J of ax in O.
We present a goal-directed method for extracting just-preserving modules, depicted in
Figure 1. The method consists of two phases. In the first phase, the method first compiles
a given SHOIQ ontology O to a first-order logic program P (see Subsection 4.1),
then transforms P to a propositional program . Both P and  are independent of any
given entailment, thus this phase can be performed offline. To show the correctness of
the method in a clearer way, we present two algorithms for transforming P to , though
only one of them is used in the method. One algorithm transforms P to a propositional
program which has the same set of minimal models as P has (see Subsection 4.2).
The other algorithm transforms P to a finite variant of the above propositional program
(see Subsection 4.4); it is actually used in the proposed method. In the second phase,
for every given entailment ax, the method extracts a relevant subset rel from  in
a goal-directed manner and then identifies a just-preserving module for ax from rel
(see Subsection 4.3). Due to the space limitation, we do not provide proofs of lemmas
and theorems in this paper, but refer the interested reader to our technical report2.

4.1 Compiling a Diagnosing Program
denote O  {A(aA) | A is an atomic concept in O and aA is a new globally
Let O
unique individual corresponding to A}. Recall that O is assumed coherent and having
concept names in our addressing problem, so O
is consistent. Since the new individuals
introduced in O
is unique, we have O |= A  B iff O |= B(aA). Hence, J is
a justification of A  B in O iff J  {A(aA)} is a justification of B(aA) in O
. It
follows that M is a just-preserving module of O for A  B iff M{A(aA)} is a justpreserving module of O
for B(aA). That is, our addressing problem can be reduced
to a problem of extracting a just-preserving module for a membership entailment. We
therefore, in what follows, focus on membership entailments.

2 http://www.aifb.uni-karlsruhe.de/WBS/gqi/jp-module/

module-long.pdf

J. Du, G. Qi, and Q. Ji

We first translate O

.
?

?

?
axO (ax). Then the diagnosing program of O

Note that, for an concept/role assertion ax, O |= ax iff O {ax} is inconsistent,
so J is a justification of ax in O
iff J  {ax} is a minimally inconsistent subset of
axioms in O{ax} (simply called a MIS of O{ax}). It follows that M is a justfor ax iff S  M{ax} for all MISs S of O {ax}. To
preserving module of O
extract a just-preserving module of O
for ax, we characterize all MISs of O {ax}
by a first-order logic program, called the diagnosing program of O
, denoted by D(O),
in which every clause may have a positive literal 
ax that corresponds to an axiom
ax  O
. The atom 
ax is called the decision atom of ax. It is nullary and works as
a flag to associate the clauses containing it with the axiom ax. We detail below the
method for computing the diagnosing program of O
to a first-order logic program. Since a direct translation from
SHOIQ to first-order clauses may incur exponential blowup [13], we apply the wellknown structural transformation [11,13] to an axiom before translating it to first-order
clauses. By (ax) we denote the result of applying structural transformation and clausification (i.e. translating to clauses) to an axiom ax. As both structural transformation
and clausification are well-known, we do not give their definition here but refer the
reader to [13] or our technical report2.
Let (ax) denote the set of clauses obtained from (ax) by adding the decision
atom 
ax to every clause in (ax), i.e., (ax) = {cl  
ax | cl  (ax)}. Let
, i.e. D(O), is defined
(O) =
as follows: if some equational atom s  t occurs positively in (O), then D(O) =
(O)  E((O)), otherwise D(O) = (O). Recall that E((O)) is used to
axiomatize the equality predicate in (O) (see Section 3).
Example 2 (Example 1 continued). Consider the ontology O in Example 1. We compute O
as O  {ax6 : ChiefActress(a1), ax7 : Person(a2), ax8 : Actress(a3), ax9 :
Woman(a4), ax10 : Man(a5)}, where a1, . . . , a5 are all new individuals. We then compute (O) as {cl1, . . . , cl10} given below.
cl2 : ChiefActress(x)  Actress(x)  
ax2
cl1 : ChiefActress(x)  Person(x)  
ax1
cl3 : Actress(x)  Woman(x)  
ax3
cl4 : Person(x)  Man(x)  Woman(x)  
ax4
cl6 : ChiefActress(a1)  
ax6
cl5 : ChiefActress(x)  Man(x)  
ax5
cl7 : Person(a2)  
ax7
cl8 : Actress(a3)  
ax8
cl9 : Woman(a4)  
ax9
cl10 : Man(a5)  
ax10
Since there is no equational atom occurring positively in (O), the diagnosing program of O
Before showing how to use the diagnosing program, we introduce some notions. Given
a first-order logic program P , a set X of ground atoms never occurring negatively in
P and a truth assignment X on X, we define the reduction of P w.r.t. X, denoted
by P  X , as a first-order logic program obtained from P by deleting every clause
cl  P that contains a ground atom   X such that X() = true, and by removing
all ground atoms in X from the remaining clauses. Since any ground atom in X does
not occur negatively in P , it is clear that P  X is satisfiable iff there exists a model
M of P such that M  X = {  X | X() = true}.
In the remainder of this section, let X denote the set of decision atoms in D(O),
i.e., X = {
ax | ax  O}, and ax a membership entailment of O
on concept/role

, i.e. D(O), is exactly (O).

Goal-Directed Module Extraction for Explaining OWL DL Entailments
such that O  O

. For X
w.r.t. X, denoted by O  X,
  O

names if not otherwise specified. Consider an ontology O
a truth assignment on X, we define the reduction of O
as O\{ax
  O | X(
ax) = true}, i.e. the subset of O
such that X(
ax) = true are absent. We have the following relationship.
Lemma 1. Let P = D(O){ax} and O = O {ax}. For any truth assignment
X on X, P  X is satisfiable iff O  X is satisfiable.
The above relationship implies a correspondence between MISs of O  {ax} and
maximally unsatisfiable X-assignments for D(O)  {ax} (see Lemma 2), where a
maximally unsatisfiable X-assignment for D(O)  {ax} is a truth assignment X
on X such that (D(O)  {ax})  X is unsatisfiable and {  X | X() = true}
is maximal, formally defined below.

where all axioms ax

Definition 3 (Maximally Unsatisfiable X-Assignment). For P a first-order logic program and X a set of ground atoms never occurring negatively in P , a truth assignment
X on X for P is called an unsatisfiable X-assignment for P if P  X is unsat-
isfiable; an unsatisfiable X-assignment X for P is called a maximally unsatisfiable

X-assignment for P if there is no other unsatisfiable X-assignment 
X for P such that
{  X | X() = true}  {  X | 
X() = true}.

Lemma 2. Let P = D(O)  {ax} and O = O  {ax}. For a MIS S of O
  O \ S for all ax
truth assignment X on X, such that X(
ax) = true iff ax
O
X-assignment X for P , O \ {ax
According to Lemma 2, we can characterize a just-preserving module of O
the help of maximally unsatisfiable X-assignments for D(O)  {ax}.
Theorem 1. M is a just-preserving module of O
  O | X(
ax) =
false}  M for all maximally unsatisfiable X-assignments X for D(O)  {ax}.

, the
 
, is a maximally unsatisfiable X-assignment for P . For a maximally unsatisfiable

  O | X(
ax) = true} is a MIS of O

for ax iff {ax

for ax with

.

4.2 Exact Grounding of the Diagnosing Program
According to Theorem 1, we need to consider satisfiability problems on D(O) 
{ax}. This can be done by considering a propositional program that is transformed
from D(O)  {ax} and has the same set of minimal models as D(O)  {ax} has.
We extend the well-known intelligent grounding (IG) technique [5] which computes,
in a fixpoint-evaluation manner, a semantically equivalent propositional program containing only derivable ground atoms from a function-free first-order logic program. By
generalizing the idea of the IG technique, we define the so-called bottom-up grounding
of a general first-order logic program P , denoted by Gbu(P ), as the least fixpoint of
(n) such that (0) =  and for n  1, (n) = {cl  | cl  P,  is a ground substitution such that cl
Lemma 3. Let P be a first-order logic program in which the equality predicate  has
been axiomatized. Then (1) Gbu(P ) is the least subset S of G(P ) such that cl   S
for any clause cl  P and any ground substitution  such that cl
  atoms(S) and
cl+  HB(P ); (2) Gbu(P ) has the same set of minimal models as P has.

  atoms((n1)) and cl+  HB(P )}.





J. Du, G. Qi, and Q. Ji
?

?

?
1, ..., cl
?

?

?
1, ..., cl
?

?

?
1, ..., cl

11}, (4) = {cl
?

?

?
9}, (3) = {cl
?

?

?
1, ..., cl
12}, where cl
?

?

?
1, ..., cl

Example 3 (Example 2 continued). This example shows the steps of computing the
bottom-up grounding of D(O) given in Example 2. By applying the fixpoint-evaluation
process for defining Gbu(D(O)), we have (0) = , (1) = {cl
5}, (2) =

12} and (5) = (4), so
{cl

Gbu(D(O)) = {cl
?

?

?
12 are given below.
1, . . . , cl
2 : Person(a2)  
ax7
1 : ChiefActress(a1)  
ax6
?

?

?
cl
cl
4 : Woman(a4)  
ax9
3 : Actress(a3)  
ax8
?

?

?
cl
cl
6 : ChiefActress(a1)  Person(a1)  
ax1
5 : Man(a5)  
ax10
?

?

?
cl
cl
8 : Actress(a3)  Woman(a3)  
ax3
7 : ChiefActress(a1)  Actress(a1)  
ax2
?

?

?
cl
cl
10 : Actress(a1)  Woman(a1)  
ax3
9 : Person(a2)  Man(a2)  Woman(a2)  
ax4
?

?

?
cl
cl
12 : ChiefActress(a1)  Man(a1)  
ax5
11 : Person(a1)  Man(a1)  Woman(a1)  
ax4
?

?

?
cl
cl
, by lemma 3, Gbu(D(O)) |= ax. Hence
Since ax is a membership entailment of O
ax occurs positively in some clauses in Gbu(D(O)). Note that Gbu(D(O)  {ax})
can be computed by first grounding D(O) then adding the clause {ax}, and that
the adding of clause ax to Gbu(D(O)) does not introduce new ground atoms to
Gbu(D(O)), so Gbu(D(O)  {ax}) = Gbu(D(O))  {ax}. It follows from Theorem 1 and Lemma 3 that M is a just-preserving module of O
 
O | X(
ax) = false}  M for all maximally unsatisfiable X-assignments X for
Gbu(D(O)){ax}. Subsequently, a just-preserving module of O
for ax can be computed as {ax
  O | 
ax  atoms(rel)}, where rel is a subset of Gbu(D(O)) 
{ax} such that {
ax  X | X(
ax) = false}  atoms(rel) for all maximally
unsatisfiable X-assignments X for Gbu(D(O))  {ax}. We call such rel a justpreserving relevant subset of Gbu(D(O))  {ax} for ax.

for ax iff {ax

4.3 Extracting a Justification-Preserving Module
In this subsection, by  we denote Gbu(D(O)){ax} if not otherwise specified. Our
method for extracting a just-preserving relevant subset of  is based on the notion of a
connected component (see Definition 4 below), which is a subset of a propositional program such that any two clauses in it have common ground atoms. This notion has been
used to confine the search space in solving SAT problems [3] because an unsatisfiable
propositional program must have a maximal connected component that is unsatisfiable.
?

?

?
Definition 4 (Connected Component). Let  be a propositional program. Two ground
are called connected in  if there exists a sequence of clauses
clauses cl and cl
in  such that cli1 and cli have common ground atoms
cl0 = cl, cl1, . . . , cln = cl
for any 1  i  n. A connected component c of  is a subset of  such that any
in c are connected in c. c is called maximal if there is no
two clauses cl and cl
c of  such that c  

connected component 
?

?

?
c.
?

?

?
The basic idea employed in our method is that the maximal connected component of 
where ax occurs is a just-preserving relevant subset of  for ax. To obtain a smaller
just-preserving relevant subset, our method extends the basic idea by first removing
two subsets ur1 and ur2 from  in turn, then extracting a maximal connected component from the remaining set. The description and the correctness of the method are
shown in Lemma 4, while the idea is illustrated in Example 4.
?

?

?
Example 4 (Example 3 cont.). Let  = Gbu(D(O)){Person(a1)} for Gbu(D(O))
given in Example 3. This example shows the sets ur1, ur2 and rel that may be
computed by our method.
12 : ChiefActress(a1)  Man(a1)  
ax5
2 : Person(a2) 
ax7
?

?

?
cl
cl
ur2 : for all clauses cl  ur2,
3 : Actress(a3) 
ax8

cl
4 : Woman(a4) 
ax9

cl
Note that M0  A is a model of ur2 for any subset
5 : Man(a5) 
ax10

cl
A of ground atoms occurring in  \ (ur1  ur2).
7 : ChiefActress(a1) Actress(a1) 
ax2

cl
8 : Actress(a3) Woman(a3) 
ax3

cl
9 : Person(a2) Man(a2)  Woman(a2) 
ax4
6 : ChiefActress(a1)  Person(a1)  
ax1
?

?

?
cl
cl
10 : Actress(a1) Woman(a1) 
ax3
1 : ChiefActress(a1)  
ax6
?

?

?
cl
cl
11 : Person(a1)  Man(a1) Woman(a1) 
ax4 rel = the maximal connected component of \

cl
ur1 : for all clauses cl  ur1, cl+ contains at least one

cl\(ur1ur2) cl+.

 

Person(a1)

cl

(ur1  ur2) where Person(a1) occurs.
rel is a just-preserving subset of  for Person(a1), and
  O | 
ax  atoms(rel)} = {ax1, ax6}
is a just-preserving module of O

cl+ \ atoms( \ ur1), i.e. {ax

clur1

The set M0 =
the set of framed ground atoms, is a model of ur1.
In this example,  = ur1  ur2  rel. The key point to prove that rel is a just-preserving subset of  is that
for any maximally unsatisfiable X-assignment X of , X() = true for all   X \ atoms(rel), otherwise
X() = X() for all   X  atoms(rel)
  
?

?

?
X is satisfiable for 
X() = true for all   X \ atoms(rel); this implies that rel  X = rel  

and 
rel  X has a minimal model M, but then M  M0 is model of   X (contradiction).
?

?

?
X the truth assignment on X such that 
?

?

?
X is satisfiable and

for Person(a1).

ground atom not in X  atoms( \ ur1).
?

?

?
ur1 := ;

ur1 = ur1 do

in in, and a ground atom  occurring in in.


ur1 := ur1;
for each clause cl  ur1 such that cl+  X  atoms(in \ ur1) do
ur1 := ur1 \ {cl};

Algorithm 1. Extract(in, X, )
Input: A propositional program in with decision atoms, the set X of decision atoms occurring
Output: A subset of in  {}.
1. ur1 := in; 
2. while 
3.
4.
5.
6. 0 := ur1; 
0 = 0 do
7. while 
8.
9.
10.
11. rel := {}; 
12. while 
13. 
14.
15.
16. return rel;

rel := rel;
for each clause cl  in \ 0 such that (cl+  cl)  atoms(rel) =  do
rel := rel  {cl};

for each clause cl  in \ 0 such that cl 

0 := 0;
0 := 0  {cl};
rel = rel do

rel := ;

clin\0

0 := ;

cl+ do



Fig. 2. The algorithm for extracting a just-preserving relevant subset of in  {} for 

Lemma 4. Let ur1 be a subset of  such that for all clauses cl  ur1, cl+ contains
at least one ground atom not in Xatoms(\ur1). Let ur2 be a subset of \ur1
cl\(ur1ur2) cl+ for all clauses cl  ur2. Let rel be the
such that cl

  

J. Du, G. Qi, and Q. Ji

maximal connected component of  \ (ur1  ur2) where ax occurs. Then rel is
a just-preserving relevant subset of  for ax, i.e., {
ax  X | X(
ax) = false} 
atoms(rel) for all maximally unsatisfiable X-assignments X for .

According to Lemma 4, we develop an algorithm for extracting a just-preserving relevant subset of  for ax, shown in Figure 2. In the algorithm, lines 15 compute ur1
given in Lemma 4, lines 610 compute ur2 (where 0 \ ur1 in the algorithm corresponds to ur2 given in Lemma 4), and lines 11-15 compute rel. Note that rel is
computed in a goal-directed (backward traversal) manner.
Consider Extract(Gbu(D(O)), X, Person(a1)) for Gbu(D(O)) given in Example
3. It can be checked that the values of ur1, ur2 (i.e. 0 \ ur1 in the algorithm)
and rel are exactly those given in Example 4. By Lemma 4, rel is a just-preserving
subset of  for Person(a1), thus {ax
  O | 
ax  atoms(rel)} = {ax1, ax6} is
for Person(a1). Note that ChiefActress(a1)  O \ O,
a just-preserving module of O
so {ax1} is a just-preserving module of O for ChiefActress  Person. Recall that the
syntactic locality-based module of ChiefActress in O is exactly O. This shows that the
just-preserving module extracted by our goal-directed method can be much smaller than
the syntactic locality-based module.

The following theorem shows the correctness and complexity of the algorithm.

Theorem 2. Extract(Gbu(D(O)), X, ax) returns a just-preserving relevant subset of
Gbu(D(O))  {ax} for ax in time polynomial in |Gbu(D(O))|.
It follows from the above theorem that {ax
  O | 
ax  atoms(rel)} is a justpreserving module of O
for ax, where rel is the result of Extract(Gbu(D(O)), X,
ax). The remaining issue for extracting just-preserving modules is that Gbu(D(O))
can be infinite when there are function symbols occurring in D(O). We in the next
subsection show that a just-preserving module of O
for ax can also be extracted from
a finite variant of Gbu(D(O)) whose size is polynomial in the size of O.

4.4 Approximate Grounding of the Diagnosing Program

To tackle the problem that the bottom-up grounding  of a first-order logic program
can be infinite, we consider a mapping function on ground terms occurring in  such
that the range of this function is finite and small. We call a mapping function  :
terms()  terms(), where terms() is the set of ground terms occurring in ,
a convergent mapping function for , if for every functional term f1(...fn(a)) (where
a is a constant) occurring in , (f1(...fn(a))) = (a), and for every equational atom
s  t occurring in , (s) = (t). For example, given a propositional program 
 =
{hasFather(a, b)hasFather(a, f(a))b  f(a), Person(a)hasFather(a, f(a)),
Person(a)  Person(f(a))}, the mapping function  = {a  a, b  a, f(a)  a}
 = {a  b, b 
is a convergent mapping function for 
a, f(a)  a} is not since 
(f(a)) = 
Given a mapping function  on ground terms, by (), (cl), (A) and () we
respectively denote the results obtained from a ground atom , a clause cl, a set A of
ground atoms and a propositional program  by replacing every ground term t occurgiven above for example, for the mapping function  =
ring in it with (t). Take 


, but the mapping function 
(a).


?

?

?
Algorithm 2. ApproxGround(O)
Input: An SHOIQ ontology O
.
Output: A propositional program and a set of sets of constants.
1. Let P be obtained from D(O) by stripping all function symbols from functional terms;
2.  := ; S := ;
3.
4.
5.

 := ;
for each clause cl  P and each ground substitution  such that cl  atoms() 

repeat

HB(P ) and cl+  HB(P ) do

inst such that a and b are different constants do

clinst := cl ;
for each equational atom a  b  cl+
MergeConstants(a, b,S, clinst, P );
 :=   {clinst};

6.
7.
8.
9.
10. until  = ;
11.  := {cl   | cl+  cl  HB(P )};
12. return (,S);
Subprocedure MergeConstants(a, b,S, cl, P )
1. Let Ca be {a} if a does not occur in S, or the congruence class in S where a belongs to;
2. Let Cb be {b} if b does not occur in S, or the congruence class in S where b belongs to;
3.
4. Update cl and P by replacing every occurrence of a with b;

Cnew := Ca  Cb; rep(Cnew) := b; S := (S \ {Ca,Cb})  Cnew;

Fig. 3. The algorithm for approximately grounding the diagnosing program D(O)

{a  a, b  a, f(a)  a}, (
Person(a)  hasFather(a, a), Person(a)  Person(a)}.

) = {hasFather(a, a) hasFather(a, a) a  a,

It is obvious that for any convergent mapping function  for , () is finite when
 is infinite but the number of constants and predicate symbols occurring in  is
finite. Even when  is finite and does not contain function symbols, () can be much
smaller than  because the subset of ground clauses in  that form a congruence
relation is collapsed in ().
Lemma 5. Let  be an convergent mapping function for Gbu(D(O)) where decision atoms, treated as nullary atoms, are not in the domain of ,  be a superset of
(Gbu(D(O))), and rel be returned by Extract(, X, (ax)). Then {ax
  O |

ax  atoms(rel)} is a just-preserving module of O
To employ the above lemma to extract a just-preserving module of O
for ax, we develop an algorithm, shown in Figure 3, to compute a superset of (Gbu(D(O))) for
some convergent mapping function  for Gbu(D(O)).
In the algorithm, P is a first-order logic program obtained from D(O) by stripping
all function symbols from functional terms, i.e., by replacing every functional term
f1(...fn(t)) with t where t is a variable or a constant; HB(P ) is the Herbrand base of
P , which does not contain any function symbol and is changed whenever P is changed;
S is the set of sets of constants such that for any constant a in any element C  S, there
exists a constant b  C such that the equational atom a  b appears in the execution of

for ax.
?

?

?
the algorithm. We call an element in S a congruence class. Each congruence class C is
associated with a representative constant, denoted by rep(C), which is an element of C.
The algorithm does not directly compute a convergent mapping function  for
Gbu(D(O)), because such mapping function can be constructed from S. By map(t,
S) we denote the function for mapping a term t  HU(D(O)) to a constant occurring
in D(O) based on S, recursively defined as follows, where a is a constant.
 map(f1(...fn(a)),S) = map(a,S), where n > 0;
 map(a,S) = b, where b = rep(C) if a  C for some C  S, or b = a otherwise.
We naturally extend the function map to (sets of) ground atoms and ground clauses, i.e.,
by map(,S), map(A,S) and map(cl,S) we respectively denote the results obtained
from a ground atom , a set A of ground atoms, and a clause cl by replacing every
ground term t occurring in it with map(t,S).
We call a mapping function  : HU(D(O))  HU(D(O)) induced from the
function map w.r.t. S if (t) = map(t,S) for all ground terms t  HU(D(O)). One
goal of the algorithm is to ensure the mapping function  induced from map w.r.t.
S to be an convergent mapping function for Gbu(D(O)), i.e., ensure map(s,S) =
map(t,S) for all equational atoms s  t occurring positively in Gbu(D(O)). Another
goal of the algorithm is to return a superset  of (Gbu(D(O))). Consider how to
achieve this goal. By Lemma 3, Gbu(D(O)) is the least subset S of G(D(O)) such
 
that cl   S for any clause cl  D(O) and any ground substitution  such that cl
atoms(S) and cl+  HB(D(O)). It follows that (Gbu(D(O))) is the least subset
for any clause cl  D(O) and any ground
?

?

?
) and (cl+)  (HB(D(O))). If 
substitution  such that (cl
is a subset of (G(D(O))) such that (cl )   for any clause cl  D(O) and any
)  atoms() and (cl+)  (HB(D(O))),
ground substitution  such that (cl
then we have (Gbu(D(O)))  . Hence we refine the second goal to the goal of
finding the above subset .
In the following descriptions, we use  to denote a mapping function induced from
map w.r.t. S. At the beginning (before line 3), it is clear that HU(P ) = {map(t,S) | t 
HU(D(O))}. Hence we can use HU(P ) to represent {map(t,S) | t  HU(D(O))}
in the algorithm. To this end, we should ensure {map(t,S) | t  HU(D(O))} =
HU(P ) throughout the algorithm.
We now describe the main part of the algorithm. All clauses in P are instantiated iteratively until a fixpoint is reached (lines 310), making the instantiated set  satisfy ()
) 
(cl )   for any clause cl  D(O) and any ground substitution  s.t. (cl
atoms() and (cl+)  (HB(D(O))). Consider any clause cl  D(O) and any
ground substitution . Let cl
be obtained from cl by stripping all function symbols from

functional terms and by replacing every occurrence of constant a with (a), and 
be
  P
obtained from  by replacing each mapping x  t with x  map(t,S). Then cl
). Hence we only need to consider adding (cl ) to  for every
and (cl ) = (cl
clause cl  P and every ground substitution  such that every ground term occurring in
cl  also occurs in {map(t,S) | t  HU(D(O))} = HU(P ). Note that (cl ) = cl 
when every ground term occurring in cl  also occurs in HU(P ) and that HB(P ) =
(HB(D(O))), so in order to satisfy the condition (), every clause cl  P and every

of (G(D(O))) such that (cl )  S



)  atoms(S
?

?

?

?

?

?





?

?

?


  atoms()  HB(P ) and cl+  HB(P ) are
ground substitution  such that cl
handled as follows (lines 59). Let clinst = cl . Every ground term a  b  cl+
inst
such that a and b are different constants is handled by merging a and b to the same
congruence class in S and by updating clinst and P accordingly (see the subprocedure
MergeConstants). The merge of a and b is to ensure map(a,S) = map(b,S). The
update of clinst is to ensure map(clinst,S) = clinst. The update of P is to ensure again
{map(t,S) | t  HU(D(O))} = HU(P ). Since S is only updated in the subprocedure
MergeConstants, {map(t,S) | t  HU(D(O))} = HU(P ) holds throughout the al-
gorithm. After every ground term a  b  cl+
inst is handled, the possibly updated clinst
is added to . After  reaches a fixpoint, since  should be a subset of (G(D(O))),
every ground term occurring in  should be in {(t) | t  HU(D(O))} = HU(P ), so
those clauses in  that contain ground atoms not in HB(P ) are removed from  (line
11). Since the propositional program  returned by the algorithm satisfies the above
condition (), we have the following lemma.
Lemma 6. Let (,S) be returned by ApproxGround(O) and  be a mapping function induced from the function map w.r.t. S. Then (1) (Gbu(D(O)))   and  is a
convergent mapping function for Gbu(D(O)); (2) ApproxGround(O) works in time
polynomial in sm and || is polynomial in s, where m is the maximum number in all
qualifying number restrictions in O and s is the size of O.
The following theorem shows the correctness of our proposed method for extracting a
just-preserving module, which is immediately follows from Lemma 5 and Lemma 6.
Theorem 3. Let (,S) be returned by ApproxGround(O), and rel be returned
by Extract(, X, map(ax,S)). Then {ax
  O | 
ax  atoms(rel)} is a justpreserving module of O
To summarize, our proposed method works as follows. In the first and offline phase,
we first compute O = O  {A(aA) | A is an atomic concept in O and aA is a new
globally unique individual corresponding to A}, then compute (,S) as the result of
ApproxGround(O). In the second and online phase, for every coming entailment ax,
we first set  = B(aA) if the given entailment ax is A  B, or  = ax otherwise, then
compute rel = Extract(, X, map(,S)), and finally compute a just-preserving
module of O for ax as {ax

  O | 
ax  atoms(rel)}  O.

for ax.

5 Experimental Evaluation

We implemented the proposed method in GNU C++, using MySQL as the back-end
SQL engine. In the implementation, ABox axioms are maintained in databases, instantiated clauses in the course of grounding are maintained in disk files, and Pellet [19]
(version 2.0.0-rc6)3 is called to find all justifications of a given entailment. All our experiments were conducted on a machine with 2.33GHz Intel Xeon E5410 CPU and
8GB RAM, running Windows Server 2003, where the maximum Java heap size was set
to (max) 1252MB. The implementation, test sets and complete test results are available
at http://www.aifb.uni-karlsruhe.de/WBS/gqi/jp-module/.
3 Pellet (http://clarkparsia.com/pellet/) employs a hitting set tree (HST) based

algorithm [12] to find all justifications.

J. Du, G. Qi, and Q. Ji

Table 1. The characteristics of test ontologies and the execution time in the offline phase
?

?

?
LUBM1
LUBM10

UOBM-Lite1
UOBM-Lite10

|NC| |NR|

2,748

20,465

27,652
?

?

?
50,253
16 629,568
?

?

?
95,010
43 820,208

|A| Offline time(sec)
|T |
|NI|
1,431

4,529

7,519

0 28,897
10,901

0 46,940
?

?

?
100,543

94 1,272,575

245,864
?

?

?
130 2,096,973

Note: O = (T ,A) is a test ontology. NC, NR and NI are respectively the sets of concept names,
role names and individuals in O.

5.1 Experimental Setup

We conducted experiments on the GALEN Medical Knowledge Base4, the Gene Ontology (GO)5, the US National Cancer Institute Ontology (NCI)6, as well as Lehigh
University Benchmark (LUBM) [10] and University Ontology Benchmark (OWL Lite
version) [15] (UOBM-Lite) ontologies. By LUBMn and UOBM-Liten we respectively
denote the instances of LUBM and UOBM-Lite that contain axioms about n universi-
ties. We specifically tested on LUBM1, LUBM10, UOBM-Lite1 and UOBM-Lite10,
where the former two were generated by the LUBM data generator7, and the latter two
were all downloaded from the UOBM Website8.

Before testing our approach we stored ABoxes to MySQL databases. Table 1 lists

the characteristics of the seven test ontologies.

In our experiments, we randomly selected 40 subsumption entailments for each of
GALEN, GO and NCI, and randomly selected 40 membership entailments over concept
names for each of LUBM1, LUBM10, UOBM-Lite1 and UOBM-Lite10. For each selected subsumption, we extracted the just-preserving module introduced in this paper;
for comparison, we also extracted the corresponding syntactic locality-based module. In
particular, for each selected subsumption entailment A  B, we extracted the syntactic
locality-based module for A; for each selected membership entailment A(a), we extracted the syntactic locality-based module for {a}. We set a time limit of 1000 seconds
for Pellet to find all justifications of a selected entailment.

5.2 Experimental Results

Regarding the offline phase of our method, the execution time (in seconds) in this phase
is shown in the last column of Table 1. Though the offline phase is rather costly, it
is reasonable due to the following reasons. First, the offline phase is independent of
any given subsumption/membership entailment; i.e., once it is executed, the extraction

4 http://www.openclinical.org/prj_galen.html
5 http://www.geneontology.org
6 http://www.mindswap.org/2003/CancerOntology/nciOntology.owl
7 http://swat.cse.lehigh.edu/projects/lubm/index.htm
8 http://www.alphaworks.ibm.com/tech/semanticstk/
?

?

?
Table 2. The test results on finding all justifications of a selected entailment

Module Extr. by Our Method Syn. Locality-based Module
#SH SHTavg(sec)
3.555
7.314
4.065
69.061
95.721
24.813
32.278

# SHLB # SzJP
Sizeavg \SHJP < SzLB

134.78

32.25

70.95

100,596.00
MO1 1,272,615.00
?

?

?
245,966.00
MO2 2,097,047.00

Sizeavg #SH SHTavg(sec)
3.814
11.985
7.518
201.481
?

?

?
LUBM1
LUBM10

UOBM-Lite1
UOBM-Lite10
?

?

?
69.75
9.55
7.23
22.15
20.48
897.80
799.83
?

?

?
155.220

Note: #SH is the number of selected entailments that are successfully handled, i.e., all justifications of the entailment can be computed over the extracted module without running out of
time/memory. SHTavg is the average execution time for finding all justifications of each selected entailment that is successfully handled. Sizeavg is the average number of axioms in
each extracted module (counting all 40 selected entailments). #SHLB \ SHJP is the number
of selected entailments that are successfully handled in syntactic locality-based modules but not
successfully handled in modules extracted by our method. #SzJP < SzLB is the number of
selected entailments whose module extracted by our method is smaller than the corresponding
syntactic locality-based module. MO1 (resp. MO2) means that all runs are out of memory
when finding justifications (resp. when loading modules).

of just-preserving modules for any given subsumption/membership entailment can be
done without executing it again. This mechanism is suitable for the situation where the
given ontology is stable, which can happen because users may want to know why an un-
wanted/surprising entailment holds when they get some implicit results from ontology
reasoning. Second, the offline phase is theoretically tractable. More precisely, it works
in time polynomial in the size of the given ontology under the assumption that numbers
in qualifying number restrictions are bounded by some constant (see Lemma 6).

Regarding the online phase of our method, the test results are reported in Table 2.
For comparison, Table 2 also shows the results for applying Pellet to find all justifications over syntactic locality-based modules. We need to point out that the execution
time for finding all justifications over a module extracted by our method includes the
module extraction time, but the execution time for finding all justifications over a syntactic locality-based module excludes the module extraction time as we assume that all
syntactic locality-based modules are extracted offline.

The test results have some implications. First, a module extracted by our method
is smaller than the corresponding syntactic locality-based module; esp. for membership entailments, by orders of magnitude smaller. Second, finding all justifications over
modules extracted by our method is generally more efficient than finding all justifications over syntactic locality-based modules. The efficiency improvement is rather
small for test ontologies with large TBoxes because most of the selected entailments
have only a small justification (which results in a small syntactic locality-based mod-
ule) and the module extraction time is only included in the former case. Third, finding
all justifications over modules extracted by our method is much more scalable than
over syntactic locality-based modules against increasing number of ABox axioms. In

J. Du, G. Qi, and Q. Ji

particular, a good number of membership entailments are handled efficiently in modules that are extracted from a test ontology with millions of ABox axioms using our
method. It seems that the size of a module extracted by our method does not depend on
the number of ABox axioms, but mainly depends on the TBox complexity.

6 Conclusion and Future Work

In this paper, we have proposed a goal-directed method for extracting a just-preserving
module for a given entailment. The basic idea of the method is to first extract a relevant subset of a finite propositional program compiled from the given ontology, then
identify a just-preserving module for the given entailment from the extracted subset.
Experimental results on large ontologies show that a module extracted by our method is
smaller than the corresponding syntactic locality-based module, improving the performance of the subsequent computation of all justifications. For future work, we plan to
adapt the method to optimize finding all justifications of the inconsistency/incoherence
of an OWL DL ontology, and upgrade the compilation method to an incremental one to
cope with ontology changes.

Acknowledgments. Thanks all anonymous reviewers for their useful comments.
Jianfeng Du is supported in part by NSFC grants 60673103 and 70801020. Guilin Qi is
supported in part by the EU under the IST project NeOn (IST-2006-027595).
