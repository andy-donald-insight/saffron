A Practical Approach for

Scalable Conjunctive Query Answering on

Acyclic EL+ Knowledge Base

Jing Mei1, Shengping Liu1, Guotong Xie1, Aditya Kalyanpur2,

Achille Fokoue2, Yuan Ni1, Hanyu Li1, and Yue Pan1

1 IBM China Research Lab, Building 19 ZGC Software Park, Beijing 100193, China

{meijing,liusp,xieguot,niyuan,lihanyu,panyue}@cn.ibm.com

2 IBM Watson Research Center, P.O. Box 704, Yorktown Heights, NY 10598, USA

{adityakal,achille}@us.ibm.com

Abstract. Conjunctive query answering for EL++ ontologies has recently drawn much attention, as the Description Logic EL++ captures
the expressivity of many large ontologies in the biomedical domain and
is the foundation for the OWL 2 EL profile. In this paper, we propose
a practical approach for conjunctive query answering in a fragment of
EL++, namely acyclic EL+, that supports role inclusions. This approach
can be implemented with low cost by leveraging any existing relational
database management system to do the ABox data completion and query
answering. We conducted a preliminary experiment to evaluate our approach using a large clinical data set and show our approach is practical.

1 Introduction

The OWL 2 EL profile is a subset of OWL 2 that captures the expressive power of
many large ontologies in the biomedical domain, such as the Gene Ontology [6],
the Systematized Nomenclature of Medicine-Clinical Terms (SNOMED CT) [9],
and large parts of the Galen Medical Knowledge Base ontology [13]. This profile
is based on the Description Logic language EL++ [1,2] for which the concept
subsumption and instance checking problem can be decided in polynomial time.
Meanwhile, conjunctive query answering, which originated from research in
relational databases (RDB), is becoming a crucial requirement for ontology-
based, data intensive applications. In biomedicine, there are several, very large
EL+ ontological datasets, e.g., protein data annotated with the Gene Ontology
and clinical data annotated using SNOMED CT. However, theoretical results
have proved that conjunctive query answering is undecidable in both EL+ and
EL++ [14]. To regain the decidability for addressing conjunctive queries, some
fragments of EL+ and EL++ need to be identified. One approach is to exclude
role inclusions, e.g., related work on EL [11] and its follow-up work on ELHdr
[12], while another approach is to impose restrictions on role inclusions, e.g., the
so-called regular EL++ [10]. In either of the two approaches, less attention is
paid to provide full support for role inclusions. Considering that role inclusion

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 408423, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
does play an important role in biomedical ontologies (such as transitivity for the
part-of relationship in the Gene Ontology and the right identity axiom for directsubstance  active-ingredient  direct-substance in SNOMED CT), we prefer to
keep expressive roles in the logic and explore an alternate solution.
In this paper, we present a practical approach for scalable conjunctive query
answering on acyclic EL+ KBs. The acyclic notion generalizes the classical one
(as defined in the DL handbook [4]), by including general concept inclusions.
Note that acyclic EL+ KBs can admit the irregularity in EL+ role inclusions.
Also, acyclic EL+ is really useful in practice, because it is expressive enough for
the commonly used biomedical ontologies, e.g., Gene Ontology, SNOMED CT.
At a glance, our approach is similar to the bottom-up rule evaluation approach
which consists of: (1) doing an ABox completion to precompute all inferred
assertions; (2) answering conjunctive queries on the completed ABox. In the
first phase, we adopt the idea of shared individuals for existential restrictions,
referred to as canonical individuals in this paper. For example, suppose A 
R.B in the TBox with A(a) and A(b) in the ABox, we will generate one and
only one canonical individual u w.r.t. the existential restriction R.B, and the
completed ABox will have the assertions B(u), R(a, u), and R(b, u). Thus, the
cost of inference and the size of the completed dataset is greatly reduced, due
to less fresh individuals. However, the canonical individual u is now shared by
both a and b. If a query asks for R(x1, y) and R(x2, y), then the bindings x1 = a
and x2 = b (with y bound to u) is not a correct answer. Therefore, in the second
phase, we propose a base path criterion to decide the soundness of an answer
on the completed ABox. Towards a practical implementation, we materialize the
base path criterion by base path precomputation and query rewriting.

Accordingly, we implemented a prototype to evaluate our approach using a
relational database (DB2). Initially, both TBox and ABox are stored in an RDB.
The ABox completion is conducted by running an RDB-based Datalog engine
with our ABox completion rules. Finally, queries are rewritten and transformed
to SQL, making them executable on top of the RDB. The experimental results
show that our approach is practical for a large ABox with millions of triples.
Our key contributions in this paper are as follows: (a) we propose a practical
approach for conjunctive query answering for acyclic EL+ that supports role
inclusions; (b) we describe a low-cost implementation for this approach on top
of a standard relational database management system; (3) we demonstrate its
effectiveness and efficiency on a large-scale TBox and ABox.

We direct readers to the Appendix1 for all proofs.

2 Preliminaries
2.1 EL+ and EL Family
In EL, concept descriptions are C ::= A|R.C|C1  C2| where  is the top
concept, A is a concept name and R is a role name. A TBox T is a finite set
1 http://domino.research.ibm.com/comm/research people.nsf/pages/

jingmei.pubs.html/$FILE/iswc09 appendix.pdf
?

?

?
of general concept inclusions (GCIs) of the form C1  C2 where C1 and C2 are
concept descriptions. An ABox A is a set of concept assertions A(a) and role
assertions R(a1, a2) where A is a concept name, R is a role name, and a, a1, a2
are individual names. As usual in DLs, a knowledge base (KB) K is a pair T ,A
with T a TBox and A an ABox. We use N I (resp. N C and N R) to denote the
set of named individuals (resp. concept names and role names).
EL+ [3] extends EL by also allowing in the TBox a finite set of role inclusions
of the form R1    Rk  Rk+1 where each Ri is a role name and 1  i 
k +1. Particularly important from the perspective of ontology applications, EL+
generalizes the following: role hierarchies R  S (aka. ELH); transitive roles
expressed by RR  R (aka. ELHR+); and so-called left-identity rules RS  S
as well as right-identity rules R  S  R. Finally, EL++ [1] is an extension of
EL+ with the bottom concept , the nominal {a} and the concrete domain
p(f1, , fn).
As follows, we will focus on EL+ and its semantics is defined as usual. More-
over, EL+ TBoxes admit a normal form [3]. Any EL+ TBox in normal form consists of concept/role inclusions in one of the following forms: A  B, A1  A2 
B, A  R.B,R.A  B, R  S and R1  R2  S, where each A, B, A1, A2 is a
concept name or the top concept , and each R, S, R1, R2 is a role name. Unless
otherwise specified, this paper assumes that TBox T is in normal form.
A polynomial-time algorithm for TBox reasoning in EL+ has been proposed
and implemented [3]. Using C1 T C2, we denote that C1 is subsumed by C2
w.r.t. T . Given a TBox T , we redefine cycles in T (to generalize the classical
definition [4]). We say that A directly uses B in T , if A T R.B, and we call
uses the transitive closure of the relation directly uses. Then T contains a cycle iff
there exists a concept name in T that uses itself. Otherwise, T is called acyclic.
Finally, we also need to decide role subsumption in EL+. That is, given a
TBox T and a finite sequence of role names R1, , Rk where k  3, to find
the set {R | R1    Rk T R}. This problem can be computed in polynomial
time in the size of T . First, the role inclusions are expanded by exhaustively
applying the following four rules: (1) if R T S and S T T , then R T T ;
(2) if R1  R2 T S and S T T , then R1  R2 T T ; (3) if R1  R2 T S
and T T R1, then T  R2 T S; (4) if R1  R2 T S and T T R2, then
R1  T T S. Then, given R1, , Rk where k  3, we can recursively compute
{S|R1    Ri T S} and {T|Ri+1    Rk T T}, for 1  i < k, such that
{R | S  T T R}.

2.2 Conjunctive Query Answering

Referring to [11,12], we introduce conjunctive queries and certain answers.
A conjunctive query q is an expression of the form y.(x, y) where x =
{x1, , xm} and y = {y1, , yn} are vectors of variables, while  is a conjunction of concept atoms A(t) and role atoms R(t1, t2). Variables in x are called
distinguished variables (also called answer variables) and variables in y are nondistinguished (also called quantified variables). A term is a variable or a named
individual, and we use Term(q) to denote the set of all terms in a query q.
?

?

?
Let I be an interpretation and q = y.(x, y) a conjunctive query. A match
for I and q is a mapping  : Term(q)  
I for all named
individuals a  Term(q)  N I; (2) (t)  A
I for all concept atoms A(t)  q;
I for all role atoms R(t1, t2)  q. If x = {x1, , xm} with
(3) ((t1), (t2))  R
i for 1  i  m, then  is called an (a1, , am)-match for I and q. If

(xi) = a
such a match exists, we write I  q[a1, , am].
A certain answer for a conjunctive query q = y.(x, y) and a knowledge base
K is a tuple [a1, , am] such that, for any model J of K, J  q[a1, , am].
We use cert(q,K) to denote the set of all certain answers for q w.r.t K.

I such that: (1) (a) = a

3 ABox Completion

The purpose of this phase is to build a completed ABox by enriching the original
ABox with inferred assertions, so that conjunctive queries can be answered on
the completed ABox, instead of doing ABox reasoning at runtime.

3.1 ABox Completion Rules
To complete the ABox, one of the main difficulties is handling the existential
concept inclusion A  R.B, which is a generative axiom in that it introduces
new individuals not occurring in the original ABox.

A naive way to do the ABox completion is to compute: (1) a mapping MC
from concepts to a subset of individuals; and (2) a mapping MR from roles to a
binary relation on individuals. Below is the list of ABox completion rules.
AR1. If A  B  T , x  MC(A) and x / MC(B),
then MC(B) := MC(B)  {x}
AR2. If A1  A2  B  T , x  MC(A1), x  MC(A2) and x / MC(B),
then MC(B) := MC(B)  {x}
AR3. If R.A  B  T , (x, y)  MR(R), y  MC(A) and x / MC(B),
then MC(B) := MC(B)  {x}
AR4. If R  S  T , (x, y)  MR(R),
then MR(S) := MR(S)  {(x, y)}
AR5. If R1  R2  S  T , (x, y)  MR(R1), (y, z)  MR(R2),
then MR(S) := MR(S)  {(x, z)}
AR6. If A  R.B  T , x  MC(A), and there is no individual y
  MC(B) and (x, y
and MC(B) := MC(B)  {y} and MR(R) := MR(R)  {(x, y)}

, s.t.
)  MR(R), then generate a new individual y,

However, there will be a large number of individuals generated. Suppose Ai 
R.Aj with A0(a), where Ai = Aj and 0  i < j  m. By applying AR6 to
the named individual a, there are 2m  1 individuals generated. Let n be the
number of A0s instances. The size of the final generated individuals will blow
up to n  (2m  1).
To address this problem, an idea of shared individuals is adopted in this
paper. Specifically, for each existential restriction R.B, we will generate a fresh
new individual (viz. canonical individual) u with respect to R and B, denoted by

y
?

?

?
CI(u, R, B). To elaborate, for each existential concept inclusion A  R.B and
all instances a  MC(A), we ensure that u  MC(B) and (a, u)  MR(R). Below
is an alternate ABox completion rule AR6 that replaces the previous AR6.
AR6. If A  R.B  T , x  MC(A) and CI(u, R, B),

then MC(B) := MC(B)  {u} and MR(R) := MR(R)  {(x, u)}

It is not hard to show that, by repeatedly applying rules AR1  5 and AR6,
the rule application procedure will eventually terminate, when no more changes
to MC and MR occur. In fact, canonical individuals are those newly introduced
anonymous individuals, and we have generated all canonical individuals as the
preprocessing step for ABox completion, so that MC and MR are computed
using at most n m rule applications, yielding the data set bounded by O(n m),
where n and m are linear in the size of T and A.
Now, applying AR6 to the above example, we will only generate m individuals
for each and every R.Aj where 1  j  m, even if there are n instances of A0.
Besides, our ABox completion can benefit a lot from canonical individuals. First,
it dramatically reduces the number of anonymous individuals to be generated.
Second, it can be pre-computed for a given TBox, so as to reduce the cost of
doing the ABox completion.

Thus, similar to the theoretical result presented in [11], our ABox completion
can be done in linear time and yield a completed ABox whose size is linear w.r.t.
both the TBox and the ABox.

3.2 ABox Completion Implementation

Our approach is implemented using an RDB system. Actually, via introducing
canonical individuals, our ABox completion rules AR1  5 and AR6 can be
transformed into Datalog rules, and the completed ABox can be computed by
running an RDB-based Datalog engine via a bottom-up evaluation strategy.

First, we design a database schema s.t. the normalized TBox is stored in
6 tables, namely, atomicSub, existsSub, gciInter, gciExists, subRole and
roleChain. These tables correspond to the TBox axioms in form of: A  B, A 
R.B, A1  A2  B,R.A  B, R  S and R1  R2  S, respectively. Similarly,
the ABox is stored in two tables, typeOf and roleStmt, corresponding to assertions of A(x) and R(x, y), respectively. The pre-computed canonical individuals
are stored in the table canonInd.
Second, we translate the ABox completion rules AR1  5 and AR6 into Datalog rules, in addition to two initialization rules s.t., (1) if typeOf(x, y) then
infTypeOf(x, y); (2) if roleStmt(R, x, y) then infRoleStmt(R, x, y, 0). Now,
running an RDB-based Datalog engine with the rules, and via a bottom-up
evaluation strategy, all inferred assertions will be incrementally stored in tables
infTypeOf and infRoleStmt. In particular, the last column in infRoleStmt
is used to indicate the origin of inferred role assertions (the reason for doing
that will be explained in the next section). Specifically, if R(x, y) is inferred by
AR6, then we store it as infRoleStmt(R, x, y, 1); and if R(x, y) is inferred by
AR4  5, then we store it as infRoleStmt(R, x, y, 2). We remark that rules of
?

?

?
AR4  5 and AR6 are allowed to fire, even if the role assertion R(x, y) that
they are attempting to infer has already been computed as (x, y)  MR(R). For
instance, suppose T = {A  R1.B, B  R2.C, A  R2.C, R1  R2  R2}
and A = {A(a)}. After the rule execution, we have canonInd(u1, R1, B) and
canonInd(u2, R2, C), in addition to infRoleStmt(R2, a, u2, 1) because of A 
R2.C, and infRoleStmt(R2, a, u2, 2) because of R1  R2  R2.
Thus, the ABox completion is done as described above, and we use A to
denote the completed ABox, where the set of canonical individuals in A is
denoted by CI.

I := N I  CI
I := a for all a  N I
I := {e  
I := {(e1, e2)  

As follows, we define an interpretation I w.r.t. A s.t.
 
 a
 A
 R
It is not hard to show that I is a model of K, and if (a1, , am)  cert(q,K)
then I  q[a1, , am], but not vice versa.

I |R(e1, e2)  A} for all R  N R

I | A(e)  A} for all A  N C

I  

4 Query Answering

After ABox completion, queries are ready for answering. However, problems arise
due to the introduction of canonical individuals. In this section, we will illustrate
a running example, followed by our solution and optimization.

4.1 The Running Example
We use a query q = y.R(x1, y)  R(x2, y) and an EL+ KB K = T ,A as
the running example, where T = {C  R2.B, B  R.D, R1  R  R3, R2 
R  R4, R3  R, R4  R} and A = {B(b), C(c), R1(a, b)}. Note that T is
irregular. The query is shown below. By the ABox completion, there are two
canonical individuals generated, i.e. u1 for R2.B and u2 for R.D, in addi-
tion, A = A  {B(u1), D(u2), R(b, u2), R2(c, u1), R(u1, u2), R3(a, u2), R(a, u2),
R4(c, u2), R(c, u2)}, as sketched below. Now, matching the query q with the completed ABox A, we have the answer set, i.e., {(a, a), (b, b), (c, c), (a, b), (b, a),
(b, c), (c, b), (a, c), (c, a)}. As shown below, the last four ones, (b, c), (c, b), (a, c),
(c, a), are incorrect answers.

x1 x2 y answer
a a u2 correct
b u2 correct
b
c u2 correct
c
a b u2 correct
b a u2 correct
c u2 incorrect
b
b u2 incorrect
c
a c u2 incorrect
c a u2 incorrect

mx2


ma

mx1
@

@


	
@R
my

mc
?

?

?
?
mu1

?

m
?

?

?
HHHj
JJ^
b
mu2

A

q = y.R(x1, y)  R(x2, y)

J. Mei et al.

We observe that, first, there is a reverse tree in the query. Intuitively, a role
atom R(x, y) can be regarded as an edge with the direction pointing from x to y.
Roughly, if there are multiple edges pointing to the same y, we call it a reverse
tree. For q, role atoms R(x1, y) and R(x2, y) are regarded as two edges pointing to
the same y, which makes this a reverse tree. Second, the completed data R(a, u2)
and R(c, u2) matches the reverse tree incorrectly. This is due to the canonical
individual u2 that was generated for R.D and shared by b and u1, due to
B  R.D. Furthermore, the sharing is extended to a and c, due to R1 R T
R and R2  R T R, respectively, where R1(a, b) and R2(c, u1). As proposed
 =
in [11,12], to guarantee sound answers, the query would be rewritten as q
y.R(x1, y) R(x2, y) (CI(y)  x1 = x2) s.t., if y is matched with a canonical
individual, then x1 and x2 need to be matched with the same individual. In this
way, unsound answers like (x1/a, x2/c) are filtered. However, answers are now
incomplete, because some correct answers such as (x1/a, x2/b) are also removed.
The reason why the existing strategy of query rewriting fails in this case is
due to the increased role expressivity. A big difference between (x1/a, x2/c) and
(x1/a, x2/b) is that a and b share u2 in a native way, since R1  R T R.

Therefore, we need to distinguish variable bindings considering reverse trees in
the query. To this end, we first need to distinguish different role assertions in the
completed ABox, some of which are generated by existential concept inclusions,
and some of which are derived from role inclusions. The former is the origin of
incorrect query answering, while the latter extends the incorrectness. Recalling
our ABox completion implementation, we mark a tag in infRoleStmt, making R(b, u2), R2(c, u1), R(u1, u2) tagged by 1 and R3(a, u2), R(a, u2), R4(c, u2),
R(c, u2) tagged by 2. Thus, we distinguish role assertions tagged by 1 from
those tagged by 2, which are purely derived by AR6 and are the root cause
of the problem. We call them base triples.

Furthermore, we build so-called base paths by traversing the graph of base
triples. In our example, there are three base triples, i.e., R(b, u2), R2(c, u1),
R(u1, u2), and three base paths, i.e., bRu2, cR2u1, cR2u1Ru2. Given a base path,
the first individual is called the head, and the last individual is called the tail,
while all individuals in the base path are said to be directly located in it. If there
is a named individual reachable to the head of a base path, we refer to it as being
indirectly located in the base path. For instance, a is reachable to b, making a
indirectly located in bRu2.

These base paths are now used for filtering incorrect answers. Informally, all
terms occurring in a reverse tree of the query are required to be (in)directly
located in a single base path, so called the base path criterion. In our example,
a and b are, respectively, indirectly and directly located in bRu2, so (x1/a, x2/b)
is a correct answer. Conversely, there is no base path making both a and c
(in)directly located, so (x1/a, x2/c) is not a correct answer.
Meanwhile, we realize that it is infeasible to check base paths at runtime during query answering. As illustrated above, there are at least 9 matches for A
and q in our example. To reduce the cost, we precompute and materialize all
?

?

?
possible role assertions in the same base path in the table BPath(path, tail,
node1, node2, role), where the path has the tail, and node1 is (in)directly
located, while node2 is directly located in the path via the role relationship. Below is the BPath storage of our example. For example, BPath(bRu2, u2, a, u2, R)
indicates the path bRu2 has the tail u2, and a is indirectly located while u2 is
directly located via the assertion R(a, u2).

Table 1. An example of the BPath storage

path
cR2u1
bRu2
bRu2
bRu2

tail node1 node2 role
R2
u1

u2
u2
R3

u2
R2
cR2u1Ru2 u2

cR2u1Ru2 u2
R4
cR2u1Ru2 u2
cR2u1Ru2 u2

u1
u2
u2
u2
u1
u2
u2
u2

c
b
a
a
c
u1
c
c

Finally, our base path criterion is applicable for query rewriting. For q, we
 = y.R(x1, y)  R(x2, y)  (CI(y)  p.BP ath(p, y, x1, y, R) 
rewrite it as q
BP ath(p, y, x2, y, R)). Here, the satisfiability of CI(y) means ys match is a
canonical individual, while the satisfiability of both BP ath(p, y, x1, y, R) and
BP ath(p, y, x2, y, R) means the matches of x1 and x2 are (in)directly located in
a single base path p. As shown in Table 1, both BPath(bRu2, u2, a, u2, R) and
BPath(bRu2, u2, b, u2, R) are satisfied, making (x1/a, x2/b) a correct answer.

In the next three subsections, we will formally present our solution, including
how to identify reverse tress in the query, how to compute base paths in the ABox
completion, and how to rewrite the query according to our base path criterion.

4.2 Reverse Trees in Query

Before we provide a formal definition of reverse trees, we remark that little
attention is paid to multiple edges pointing to the same y, where y is bound
to a named individual. This is because only matches sharing some canonical
individuals are problematic. Moreover, EL+ models are split [11], i.e., there is
no role assertion pointing from an unnamed individual to a named one.
Formally, let q = y.(x, y) be a conjunctive query. We use GTq  Term(q) to
denote the set of grounded terms in q, s.t. for each t  Term(q): (1) if t  N I  x
then t  GTq; (2) if R(t, t
q := {y  GTq| {R(x, y)  q} > 1}, where  denotes the cardinality.

Next, we use q to denote the set of reverse tree roots in the query q, i.e.,
:= {R(x, y)  q}
Now, for each reverse tree root y  q, we compute E
y } and t  GTq}. The
)  E
refers to the set of multiple

  GTq then t  GTq.

(i+1)
and E
y
computation terminates, when E

y  {R(s, t)  q | t  {s
(i+1)
(i)
y = E
y

)  q and t

:= E

(0)
y

(i)

|R
?

?

?
(s
, t
(0)
. E
y

(i)

J. Mei et al.

edges pointing to the same y. By incrementally expanding in a reverse direction,
(i)
contains additional edges, all of which point to non-grounded terms, until

y
(i)
we reach a fixedpoint. The resultant set Ey :=
y , and we use Ey to
i0 E
denote the set of all reverse tree edges rooted by y  q.
is a pair (y, Ey) with y  q and there is no pair (y

Ey  Ey. We call a query q free of reverse trees, if RTq is empty.

Finally, we use RTq to denote the set of reverse trees, where each reverse tree
, Ey) in RTq such that
?

?

?
It is not hard to verify that GTq and RTq can be computed in time polynomial
in the size of q. Moreover, the size of GTq is linear in the size of q, and the size
of RTq is polynomial in the size of q.
As shown in the following theorem, for queries free of reverse trees, query
answering over the completed ABox is sound and complete, even in cyclic EL+
KBs. Thus, if the application requires only queries free of reverse trees, the rest
of this section can be skipped over.
Theorem 1. cert(q,K) = ans(q,A), given that q is a conjunctive query free
of reverse trees and K is an EL+ knowledge base.
To see which queries are free of reverse trees, consider the following samples.
First, q1 = y1, y2.R1(x1, y1)  R2(x2, y2) is forest-shaped (a notion well defined
in DL literature [8]), and we claim that forest-shaped queries are all free of
reverse trees. Next, neither q2 = y1, y2, y3.R(y1, y2)  R(y2, y3)  R(y3, y1) nor
q3 = y1, y2.R1(x1, y1)  R2(x2, y1)  R3(y1, y2)  R4(y2, x3) is forest-shaped,
while both q2 and q3 are free of reverse trees. In fact, there is no multiple edge
in q2, which makes it free of a reverse tree. In q3, the multiple edges point to y1
which is a grounded term due to the answer variable x3, so there is no reverse
tree root and q3 is also free of a reverse tree.

4.3 Base Paths in ABox Completion

First, we need to identify base triples in the ABox completion. Taking advantage
of the last column in infRoleStmt, BT is used to denote the set of base triples s.t.
BT := {R(x, y)|infRoleStmt(R, x, y, 1)}\ {R(x, y)|infRoleStmt(R, x, y, 2)}. In
other words, BT consists of triples which are purely derived by AR6.
Next, we traverse the graph of BT to compute base paths. Given a canonical
individual u  CI, we use BP (u) to denote the set of base paths ending up with
u such that BP (u) := {u0R1u1  Rkuk|u0  N I, uk = u, ui  CI, R(ui1, ui) 
BT, 1  i  k}. The following figure illustrates the intuition of our definition.

There are two planes: the NI plane contains
all triples between named individuals, and the
CI plane contains only the base triples between canonical individuals. Meanwhile, base
triples from named individuals to canonical individuals are those links from the NI plane to
the CI plane. Here is the running example.
?

?

?
Intuitively, a base path starts from a named individual (i.e. the head), followed
by a base triple jumping from the NI plane to the CI plane, and after traversal,
it ends up with a canonical individual (i.e. the tail). Therefore, all individuals in
a base path are canonical ones, except the head. Named individuals indirectly
located in a base path are those reachable to its head in the NI plane.
It is not hard to show that, disregarding cyclic EL+ KBs, the base path
computation will terminate, and using depth-first-search or breadth-first-search,
its time complexity is proportional to the number of nodes plus the number of
edges in the graph they traverse, i.e., O(|N I|+|CI|+|BT|). In other words, BP
can be computed in time linear in the size of A. Unfortunately, in the worst-
case, the size of base paths is exponential in the size of TBox and polynomial in
the size of ABox. We believe this upper bound is unlikely to occur in practice,
and Section 4.5 presents our optimization techniques to address this issue.

Finally, we precompute and materialize all possible role assertions in the same
base path in the table BPath(path, tail, node1, node2, role). For a base
path p: u0R1u1  Rkuk, we store it as BPath(p, uk, ui, uj, R), where 0  i <
j  k and Ri+1    Rj T R, as well, BPath(p, uk, a0, uj, R) where 0 < j  k
and R0  R1    Rj T R with R0(a0, u0)  A.

Here, we remark two key points about the BPath storage. One is how to compute the role, which denotes the super roles for the role chain from node1 to
node2. For BPath(p, uk, ui, uj, R) where 0  i < j  k, we need to compute
the set {R | Ri+1    Rj T R}, as discussed in the Section 2 (Preliminar-
ies). Similarly, for BPath(p, uk, a0, uj, R), where 0 < j  k, we compute the set
{R | R0  R1   Rj T R}. Another is how to compute all named individuals
reachable to u0. Suppose a0 is reachable to u0, via a sequence of named individuals a1, , an and a sequence of role names S1, , Sn, where an = u0 and
Si+1(ai, ai+1)  A for any 0  i < n, given S1    Sn  R1    Rj T R.
Thanks to the TBox normalization [1], a role inclusion in form of R1  Rk 
Rk+1 will be normalized inductively by R1Rk1  R
Rk  Rk+1,

where R
k is a newly introduced role name. In this respect, we are convinced that,
given S1    Sn  R1    Rj T R, there is a role name R0 (introduced
by the normalization) s.t. S1    Sn T R0 and R0  R1    Rj T R.
Thus, with u0 pinpointed, the set of named individuals reachable to u0 are
{a0 | R0(a0, u0)  A}.
?

?

?
k and R
?

?

?
k

4.4 Query Rewriting
Below, we define a base path criterion, then rewrite the query according to it.
Definition 1 (Base Path Criterion). Let  be a match for I and q.
We say that a reverse tree (y, Ey)  STq is satisfied by  if, (y)  CI implies
there is a base path u0R1u1  Rkuk  BP ((y)), and for any R(s, t)  Ey,
whenever (t) = uj and 1  j  k,
 (s) = ui and 0  i < j, given Ri+1    Rj T R, otherwise;
 (s) = a0 and 0  i < n, (ai, ai+1)  S

i+1 with an = u0, given S1  Sn 
I

R1    Rj T R.

J. Mei et al.
?

?

?
The base path criterion is that all reverse trees of q are satisfied by the match 
for I and q.
Since we have stored all base paths, the base path criterion can be directly
adopted by query rewriting. The rewritten query q

 is defined as



q

:= q 

(CI(y)  p.

(CI(t)  BP ath(p, y, s, t, R)))

(y,Ey)RTq

R(s,t)Ey

[a1, , am].


and the size of rewritten queries is bounded by O(|q|2).
By definition, an (a1, , am)-match  for I and q satisfies a reverse tree
(y, Ey)  STq if, (y)  CI implies there is p such that, whenever (t)  CI, we
have BPath((p), (y), (s), (t), R), for any R(s, t)  Ey. If there exists such a
match satisfying all reverse trees, we write I  BPath  q
Similar to [11,12], we use ans(q,A) to denote the set of answers that a
,A  BP ath) for
relational database system returns for q over A, while ans(q
 over A with BPath. This paper contributes the following theorem.
q
Theorem 2. cert(q,K) = ans(q
query and K is an acyclic EL+ knowledge base.
Interestingly, if K is an EL knowledge base, then our base path criterion is
reducible to the approach proposed for EL [11]. In fact, the Definition 1 will
be simplified s.t., for any R(s, t)  Ey, if (t) = uj then (s) = uj1, where
1  j  k. Suppose s1, , sl be a sequence of terms and all R(si, t)  Ey
for 1  i  l. Now, if (t) = uj then (s1) =  = (sl) = uj1, and in the
rewritten query, it becomes CI(t)  (s1 = s2    sl1 = sl).

,A  BP ath), given that q is a conjunctive



4.5 Optimization
Observing the possibility of using our approach for EL, we consider removing some BPath records which contribute little to the plus part of EL+, towards an optimal storage. Formally, we define the set N R+ := {R|R1  R2 T
R3, R T Ri, 1  i  3}. Our strategy is to check the BPath storage, and for
any BPath(p, z, x, y, R), if R  N R+, then this BPath record can be removed.
 as follows.
(CI(t)  BP ath(p, y, s, t, R))
?

?

?
Correspondingly, we also need to redefine the rewritten query  q
 q

(CI(y)  p.
?

?

?
:= q 
?

?

?
(y,Ey)RTq
?

?

?
R(s,t)Ey,RNR+
ti = ti+1) 



(CI(t) 

(CI(t) 

R(tpre



, t)))

RI

({t1, ,tl},)Forky

=

1i<l

(I,)ForkyH

The definitions of Forky
ELHdr [12]. The main differences are pre() := {t|R(t, t
N R+ and t
Here, R(t, t

  } and in() = {R|R(t, t
)  Ey and R  N R+ are imposed in our context.

= and ForkyH are almost the same as those defined for
)  Ey for some R 
  }.

)  Ey for some R  N R+ and t
?

?

?
To see why our optimization retains the correctness, consider the query q =
y1, y2, y.R1(x1, y1) R2(x2, y1) R(y1, y) R(y2, y) over an EL+ KB with R1 
R2 and R  R  R. There is one and only one reverse tree (y, Ey)  RTq, where
Ey consists of all role atoms in q, and N R+ = {R}. The non-optimized rewrit-
 is q  (CI(y)  p.BP ath(p, y, y1, y, R)  BP ath(p, y, y2, y, R) 
ten query q
(CI(y1)  BP ath(p, y, x1, y1, R1) BP ath(p, y, x2, y1, R2))), and the optimized
 is q(CI(y)  p.BP ath(p, y, y1, y, R)BP ath(p, y, y2, y, R)
rewritten query  q
 (CI(y1)  x1 = x2)  (CI(y1)  R1(x2, y1)). Below shows the theorem for
optimization, where BPath denotes the BPath storage after removal.
Theorem 3. cert(q,K) = ans( q

query and K is an acyclic EL+ knowledge base.
This section is now concluded with the theorem for complexity and data size.
Theorem 4. Conjunctive query answering on acyclic EL+ knowledge base can
be done in time polynomial in the size of the query, the TBox and the ABox,
with data of a polynomial-size blowup w.r.t. the query and the ABox while of an
exponential-size blowup w.r.t. the TBox.

,A  BP ath), given that q is a conjunctive

5 Preliminary Experiments

We have implemented a prototype to evaluate our approach using Java SDK
1.5 and DB2 V9.3 Enterprise Edition. It performs three steps: (1) does ABox
completion with canonical individuals and stores the completed ABox data in
the RDB; (2)computes the base paths and stores them in the RDB as well;
(3) rewrites the query according to the base path criteria, transforms the query
into SQL and executes it on the completed ABox with base paths. The preliminary experiments are performed on an X-3650 server with 8G memory and two
3.0GHz Xeon CPUs.

TBox. The SNOMED CT ontology is generated by executing the perl script
provided in the SNOMED CT 2009Jan release package, on the SNOMED CT
2007Jan release content files (because our data uses the 2007Jan version). It is
formulated as an acyclic EL+ ontology that contains 308,832 concept names,
62 role names with 47,317 concept definitions and 261,514 primitive concept
definitions. It also contains 11 role subsumption axioms and one right identity
axiom: caustiveAgent  hasActiveIngredient  caustiveAgent 2. After nor-
malization, the TBox includes 463,971 concept names, 576,971 axioms of form
A  B, 428,905 axioms of form A  R.B, 49,454 axioms of form R.A  B
and 118,124 axioms of form A1  A2  B.

2 Actually, the stated right identity axiom in the SNOMED CT 2009Jan Release
is directSubstance  hasActiveIngredient  directSubstance. We do not use this
axioms because there is no concept B appeared in both A  directSubstance.B
and B  hasActiveIngredient.C in the 2007Jan Release.

J. Mei et al.

ABox. The ABox of SNOMED CT ontology is constructed partly from a collection of 100,000 HL7 Clinical Document Architecture (CDA)[7] documents
collected from a large hospital in southern China. CDA is a widely adopted
standard to represent the electronic clinical documents, such as clinical notes
and prescriptions. These CDA documents are CDA level 3 documents with clinical statements using codes from SNOMED CT 2007-Jan release.

We developed an XML-2-RDF transformer that can extract RDF triples from
the structured body part of CDA documents. For each CDA document, the
XML-2-RDF transformer outputs a single RDF document.In addition, because
the collected CDA documents do not cover the concepts and roles involved in the
right identity axiom, we generate additional instances randomly for the classes
and roles involved in the right identity axiom, and then merge them into the
ABox. In our experiment, we generate on average 30 instances per CDA docu-
ment. The transformed RDF documents plus the randomly generated instances
are partitioned into four data sets (ABoxes) according to the number of CDA
documents, i.e, 0.1K, 1K, 10K and 100K.

ABox Data completion. After loading the normalized SNOMED CT ontology
and the ABox into the RDB, we use the RDB-based datalog engine developed
as part of the IBM SHER framework to perform ABox completion. To evaluate
the benefits of canonical individual, we implemented both the intuitive approach
and the canonical-individual-based approach.

In the intuitive approach, the algorithm first evaluates the ABox datalog rules
(AR1-5) by a semi-naive approach, then iteratively does the following steps
until no more new facts are generated: (1)For the TBox axiom: A  R.B, and
ABox assertion A(a), add new facts R(a, u), B(u) into the ABox if there is no
individual w satisfying both R(a, w) and B(w); (2) Incrementally evaluate the
ABox completion rules with the new facts.

In the canonical-individual-based approach, the algorithm first generates
canonical individuals for existential restrictions, then evaluates the ABox datalog
rules AR1-5,AR6 via a semi-naive evaluation. In this way, the overall number
of generated anonymous (canonical) individuals is fixed  76,614 in our case.

Table 2 summarizes the ABox completion results for both approaches. For
each ABox, we report the number of individuals (IND), the numbers of triples
(TRP) in the original ABox and in the completed ABox in both approaches, and
the data completion time (excluding the ABox data loading time).

Table 2. ABox data completion results

Dataset

Original

Intuitive Approach
TRP IND TRP Time
TRP Time
22K 77K 1,018K 4.3h
310K
53s
0.1K
1K
227K 793K 10,395K 58.4h 172K 4,099K 0.3h
10K 1,614K 2,155K N/A N/A N/A 1,618K 39,923K 1.4h
100K 15,097K 22,157K N/A N/A N/A 15,102K 387,316K 13.9h

CI-based Approach

16K

16K
169K
?

?

?
As can be seen from the Table 2, in the intuitive approach, the completed
ABox has a polynomial-size blowup. Also, it is very time-consuming to generate
due to many iterative calls to the datalog engine. When using canonical individ-
uals, the number of newly added individuals in the completed ABox is always
less than a constant (76,614 in our case). The size of inferred triples is about
10-20 times that of the original triples because of the deep hierarchy of the normalized SNOMED CT ontology. For example, the concept headache has 15
super concepts in original ontology, but has 27 super concepts in the normalized
ontology. Our experiment confirms that it is necessary to introduce canonical
individual for ABox data completion in practice.

Base path generation and query performance. After performing the ABox
completion, the base path can be generated and the query can be rewritten and
executed on the completed ABox with base paths. We first compare the efficiency
of base path generation of the initial approach and the optimized approach. Then
we design three typical queries to test the query performances. These queries are
designed according to the three typical query shape: point, tree and graph.
Q1(x)= Headache(x)
Q2(x) =y HearingN ormal(x), f indingSite(x, y), EntireLef tEar(y)
Q3(x,y)=z causativeAgent(x, z), causativeAgent(y, z)
In our implementation, the (rewritten) conjunctive query is represented using
the RDF SPARQL query language. The SPARQL query is further transformed
to SQL by a RDF-2-RDB mapping engine.

Table 3 summarizes the base path generation and query performance results
for each ABox. We report the count of base path records (BPSize), the time to
generate them (GenTime) and the query execution time for Q3 using the initial
approach and the optimized approach. Since Q1 and Q2 are free of reverse trees,
the base path optimization has no effect on their performances.

Table 3. Base path generation and query performance results

Dataset without optimization

with optimization

Q1

Q2

BPSize GenTime Q3 BPSize GenTime Q3
480s
172K
0.1K
1K
1,917K 2,237s
10K 16,764K 4.2h
100K
N/A

36.6s
10K
321ms
228s
3.5s
199K
22.1s 1,812K
1.1h
N/A 18,734K 7.8h

N/A

50ms 10ms 30ms
2.0s 61ms 500ms
12.7s 83ms
1.6s
313s 712ms 14.6s

Our experiment is still at a preliminary stage due to the limitations of the
ontology and data. However, from the results, we can observe that: (1) the
base path optimization dramatically reduces the number of stored base paths
in this case, because only five of SNOMED CTs 62 roles appear in the real
role inclusions, and further improves the performance of the rewritten query Q3
because self-joins on the base path table are involved; (2) the query answering
is scalable to a large data set because it can leverage the underlying relational
database for scalability.

J. Mei et al.

6 Related Work

 and R

 and R1 R

In recent years, a rich literature on the subject of conjunctive query answering
on the EL family has emerged, including both theoretical and practical work.
Theoretically, there are undecidable problems identified, such as answering
conjunctive queries in both EL+ and EL++ [14]. Meanwhile, related work [10]
presents that CQ answering on regular EL++ is decidable. However, we observed
that the notion of regularity syntactically depends on the normal form of TBox.
In other words, it can happen that a TBox becomes (ir)regular by normalizing
it differently, even if this does not change the semantics. For example, suppose
R1  R2  R3  R3 be a role inclusion originally asserted in the TBox. On the
one hand, this TBox can be normalized as R1  R2  R
  R3  R3,
which appear as regular. On the other hand, this TBox can also be normalized
as R2 R3  R
  R3, which becomes irregular. Besides, our acyclic
EL+ TBoxes admit the irregularity. Disregarding the rich expressivity of roles,
CQ answering on EL and ELH has been proved decidable and PTIME-complete
w.r.t. both data complexity and KB complexity [14].
As far as we know, the only practical approach for conjunctive query answering
in EL has been proposed by Lutz et al. [11,12]. Our work can be regarded as an
extension of their work by supporting role inclusions. A minor difference is that,
in the ABox completion phase, we only generate one anonymous individual for
each existential restriction, whereas their approach will generate one anonymous
individual (called auxiliary object) for each subconcept of concepts used in T . A
major difference arises in the query rewriting phase, since our approach supports
role inclusions. We firstly proposed a base path criterion and designed a base path
storage schema to enable query rewriting based on this criterion. The query
rewriting strategy in their approach is a special case of ours. Actually, as shown
in the Section 4.5 for optimization, we can embed their query rewriting strategy
into ours to handle the ELH part, while keeping the base path criterion dedicated
for the real role inclusions in EL+.
Meanwhile, we can imagine a deterministic algorithm for query answering in
ELHR+, which is a sub language of SHIQ [8]. Alternatively, DL-Lite [5] explores
such a way that resorts simply to query rewriting without ABox completion. To
employ either of them has to pay for an exponential blowup of the rewritten
queries. Towards a practical implementation, query rewriting in our approach
will only have a polynomial blowup, and we leverage RDB for query answering.

7 Conclusion

In this paper, we proposed a two-phase practical approach for query answering
in EL+. In phase one, we do ABox completion using the notion of canonical
individuals. For queries free of reverse trees, this phase is enough to provide sound
and complete answers, w.r.t. arbitrary EL+ KBs. In phase two, we proposed the
base path criterion and made the criterion applicable by the base path storage
and query rewriting. A combination of the two phases guarantees sound and
complete solutions to arbitrary queries on acyclic EL+ KBs.
?

?

?
As future work, we are planning to evolve the base path criterion, enabling
queries on cyclic but regular EL+ ontologies. Development of more optimizations
is also part of our ongoing work, especially reducing the blowup of base paths.
Besides, for updating concerns, we will develop an incremental ABox completion,
which is critical for the practical applications of our approach.

Acknowledgements

The authors wish to thank Carsten Lutz for useful discussions during the writing
of this paper.
