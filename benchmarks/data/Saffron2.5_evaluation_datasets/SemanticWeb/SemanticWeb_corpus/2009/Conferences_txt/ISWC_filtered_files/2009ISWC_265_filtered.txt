Modeling and Query Patterns for Process

Retrieval in OWL

Gerd Groener and Steffen Staab

ISWeb  Information Systems and Semantic Web,

Institute for Computer Science, University of Koblenz-Landau, Germany

{groener,staab}@uni-koblenz.de

Abstract. Process modeling is a core task in software engineering in
general and in web service modeling in particular. The explicit management of process models for purposes such as process selection and/or
process reuse requires flexible and intelligent retrieval of process structures based on process entities and relationships, i.e. process activities,
hierarchical relationship between activities and their parts, temporal relationships between activities, conditions on process flows as well as the
modeling of domain knowledge. In this paper, we analyze requirements
for modeling and querying of process models and present a patternoriented approach exploiting OWL-DL representation and reasoning capabilities for expressive process modeling and retrieval.

1 Introduction

Process models are used in various applications like business process modeling,
modeling of system processes and also the combination and interaction of web
services are described as processes. In order to use existing processes it is necessary to support basic process model management tasks like the retrieval of
processes [16].

There are various approaches for modeling processes and corresponding
retrieval methods like a keyword search or retrieval methods based on data
in- and output or process properties which are mainly process annotations. Retrieval with respect to the activities of a process and especially to the execution
order and dependencies of them requires the consideration of the control flow of
a process (cf. Section 2.2,[12]).

The problem of process retrieval based on control flow information depends on
the internal process structure. The structure includes sequences, choices, parallel
activities as well as activity specialization. Therefore, search capabilities for processes must include reasoning facilities that are able to match the heterogeneous
requirements that exist at different levels of granularities of process descriptions
between a query and a process. Moreover, this matching capability needs to
distinguish modalities of matches, i.e. whether a specific condition on a process
(part) must be always fulfilled or only for some of its instances. In order to tackle
the described challenges, we consider two main tasks:

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 243259, 2009.
c Springer-Verlag Berlin Heidelberg 2009

G. Groener and S. Staab

 A formal description of the control flow of a process which explicitly models

the various hierarchical and ordering relationships between activities.

 A characterization of query and reasoning tasks in order to retrieve processes

with specified control flow characteristics and modalities.

OWL-DL allows for the description of terminology of processes and activities.
DL reasoning enables matching of queries and processes (cf. Section 4). The
available reasoning procedures account for the aggregation of activities and for
different modalities.

OWL-DL and DL have been used for process modeling and retrieval before
(cf. [4,11,16,17]). However, in these process models, the control flow is either
not represented at all or represented by syntactic means that do not allow for
reasoning as needed or the process models are too weak to express realistic
control flows. A comprehensive survey is given in Section 6.

To remedy this situation, this paper provides a threefold contribution. First,
we analyze modeling and querying requirements for process retrieval in general
(Section 2). Second, we provide patterns for modeling process control flow in
OWL-DL (Section 3). Third, we demonstrate how to exploit these semantic-based
models for expressive retrieval of (parts of) process models by reasoning in OWLDL (Section 4). The retrieval capabilities of our model are evaluated in Section 5.

2 Process Retrieval Problems

This section outlines requirements for process modeling and retrieval motivated
by a retrieval scenario.

2.1 An Example Process Model as UML Activity Diagram

We use the widespread and standardized UML-Activity Diagrams for graphical process modeling. Figure 1 depicts three different process models describing
SalesOrder processes with different characteristics. The elements of UML Activity Diagrams are described in Table 2. Activities are the tasks which are executed by the process. An edge is the connection from an activity to the follower
activity.

The activities in the diagrams from Figure 1 are decomposed into more finegrained descriptions which are depicted in Figure 2. The Reorder process contains
a decision in combination with a condition. If the article is a standard article an
internal reorder activity is executed otherwise an external reorder activity.

2.2 Requesting Process Descriptions

We consider a situation where a customer wants to use an online shop to buy
a product. The selling procedure of the online shop is specified by a salesorder
process description. Depending on the individual preferences of the customer, he
may want to select a shopping service based on properties of the process control
flow which is realized by the shop. For instance, he may want to search for a
shop (Q) and expects a concrete response (R) fulfilling his request:
?

?

?
Q1: Which shop allows me to pay after delivery?

R1: Process that executes Delivery before P ayment.

Q2: Which shop allows me to pay by cash?

R2: SalesOrder that offers cash payment as payment method.

Q3: Which shop accepts only cash payment?

R3: SalesOrder process that only offers cash payment.

Fig. 1. UML-Activity Diagrams for Sales Order Processes

Fig. 2. UML-Activity Diagrams for the Subprocesses

G. Groener and S. Staab

In fact, quite often an online shop is requested that fulfills multiple constraints
simultaneously. Besides the customer, the service provider may have further
queries in order to find an appropriate process.
Q4: Which process executes at least all activities of SalesOrder2?

R4: SalesOrder3 process contains all activities of SalesOrder2 and an additional activity.

Q5: Which process runs are instances of SalesOrder2 and SalesOrder3?
R5: Process runs which are instances of both processes simultaneously.

2.3 Requirements for Process Modeling

In order to facilitate process retrieval we derived the requirements for process
modeling from the demonstrated queries. Table 1 describes the derived requirements with respect to the questions. (1) A query must consider the execution
order, e.g. that one activity happens (possibly indirectly) before another activity.
(2) Process specializations and (3) activity decomposition involve the terminol-
ogy, e.g. that one must consider the different specializations of payment types.
(4) Queries have to cover modality, e.g. that a property like the type of payment is unavoidable in all possible process enactments. (5) Instance queries are
relevant for all modeling dimensions. These requirements may be combined, e.g.
queries concerning the execution order have also to cover terminological informa-
tion. Obviously, these queries are general and imprecise process descriptions, e.g.
only a description of relevant parts of the process. Hence the process retrieval
has to account for incomplete process descriptions.

Table 1. Requirements derived from the queries

Questions

Requirements
Order of Activities and Subactivities Q1
Q4
Specialization, Inheritance
Q2, Q3
Activity Decomposition
Q2, Q3
Modality
Instance Queries
Q5

3 Process Modeling in OWL

We have investigated two important design decisions for modeling processes in
OWL-DL. The first method models occurrences of activities and their relative
positioning in the control flow. The advantage is that each step can be modeled
separately and - as we see later - some advantages with regard to refinements
are implied. The second method models a process as one complex DL expression
capturing all the steps. In this second model it is not fully possible to capture all
temporal and refinement relationships simultaneously. However, the advantage
of the second approach is that there are more possibilities for retrieval queries
than in the first approach. In this paper we only focus on the second approach.
?

?

?
3.1 Design Principles and Transformation

A process model (sometimes called a process template) describes the set of all
process runs it allows, i.e. a concept in OWL-DL. Process runs are instances in
OWL-DL. A process run is a composition of activity instances. We translate the
language primitives of the UML-Activity Diagram into an OWL-DL1 represen-
tation. Table 2 lists our translation rules. A, B, C and D are activities, P is a
process name.

Table 2. Transformation to Description Logic

UML Notation

Construct
1. Start
2. End
3. Activity
4. Edge
5. Process P (Axiom)

6. Flow

7. Decision

8. Condition

9. Fork and

Join

10. Loop

DL Notation
Starti
Endi

T Oi
P  Starti  =1 T Oi.

(A  =1 T Oi.Endi)

A  =1 T Oi.B

A  =1 T Oi.
 =1 T Oi.D

((B  C)

A  =1 T Oi.

((B  Cond) 

(Stalled  Cond))

A   T Oi.(B  =1 T Oi.D)
  T Oi.(C  =1 T Oi.D)
 = 2 T Oi

Loopj  =1T Oi.B,
Loopj  A  =1 T Oj.

(Loopj  Endj)

The relation between an activity and the follower activity is represented by
roles in DL, i.e. T O 2. In order to allow for process composition and refinement
in combination with cardinality restrictions the roles for each process (T Oi) are
distinguished from each other. All roles T Oi are defined as subroles of T O in
order to simplify query formulations. Therefore we may use T O for the retrieval
of all processes. T OT is a transitive superrole of T O (cf. Table 3) which is similar
to the relation pattern in DOLCE plan extension [9]. The combination of both
roles enables process retrieval with respect to direct and indirect activity order.
A process is either atomic or composed. An atomic process is a nondecomposable activity. A composed process is built using axioms (No.5). An
axiom defines a process starting with Starti followed by a sequence of composed
activities. The last activity is the concept Endi. The follower relation T Oi refers
1 We use the DL language SHOIN (D) which corresponds to OWL-DL.
2 For sake of a short name, the role name T O is used instead of a more meaningful

name like F ollowedBy.

G. Groener and S. Staab

to an edge in the process diagram. A flow (No.6) is translated to DL with the
expression A   T Oi.B. This means that the process flow defines an execution
of activity A which is directly followed by the activity B. The disjointness of A
and B in a flow is here not required which accounts for a larger result set in the
retrieval (cf. 5).
Decisions (No.7) are modeled in DL as a concept union  T Oi.(B  C)
representing a non-deterministic choice between two possible following activi-
ties. Both activities reach an activity D. The cardinality restrictions guarantee
that there is only one follower activity. A condition can be assigned to a flow
(No.8). Adding disjoint conditions to each flow of a decision leads to deterministic decisions. These deterministic decisions are used to model exclusive decisions
(exclusive or), i.e. exactly one path after the decision is executed.

Disjointness of the activities B and C is also not required. We describe conditions as set of states that may be reached when the condition is fulfilled. The
notation of No.8 describes that directly after the activity A there is an activity B and the condition Cond holds, i.e. the activity B is only executed if the
condition is satisfied. We add an additional activity Stalled if the condition is
not satisfied. The activity Stalled means that the control flow of the process is
stopped due to a violation of the condition. All conditions are subclasses of a
general concept Condition (Table 3).

Table 3. Process Model Axiomatization

Statement
Stalled has no follower
All activities are subclasses of Activity
Conditions are subclasses of the concept Condition j  Condition
Domain and Range of T O is Activity

DL Axiom
Stalled   T O.Activity  
A, B, C, D  Activity

T O is superrole of all T Oi
T OT is the transitive superrole of T O
Starti is the first activity
Endi is the last activity

 T O.  Activity
and    T O.Activity
T Oi  T O
T O  T OT , and T O+  T OT
Starti   T O
Endi   T Oi.Activity  

i .Activity  

A parallel execution (No.9) starts with a fork and ends with a join. The
fork is described by the explicit statement that there exist multiple follower
sequences, which is described by an intersection of the sequences. The join of
sequences like for decisions and parallel executions is represented by activity
(D) in the complex DL expression. Loops (No.10) are described by a subprocess
Loopj which contains the activities of the loop (A) and the follower activity is
either Loopj or Endj. This construct is a special decision with a self reference.
In case of a nested loop structure, i.e. there is a loop within another loop, the
transformation is straightforward. The inner loop is treated like a single activity
of the outer loop, e.g. activity A in No.10 could be an inner loop.
?

?

?
For each process definition we require that Starti has no predecessor, Endi
has no follower which is described in the second part of Table 3. In order to
model process refinements these conditions are only valid for this (sub-) process.
Therefore the start and end activities are distinguished from each other, using
levels (i) for each process. Further axioms like domain and range restrictions,
subclass relations between activities and conditions and the role hierarchy for
the follower relations (T Oi) are described in the first part of Table 3.

In our OWL-DL model there are limitations in the accuracy. Some model
constructs are non-deterministic, e.g. we use a disjunction in DL to model a nondeterministic control flow description and we do not require a general disjointness
of the activities of a process. However, this supports query expressions using
general and incomplete process descriptions with a maximal possible result set.

3.2 Process Transformation to OWL

Based on the described transformation pattern from UML process models to
OWL, we describe the SalesOrder processes from Section 2 in OWL-DL. Figure 3 depicts the axioms that describe the SalesOrder processes. For being more
readable, we omit here the cardinality restrictions in all process definitions and
the Stalled activity for violated conditions.

SalesOrder1  Start1   T O1.(Order   T O1.(Delivery   T O1.End1)
  T O1.(P ayment   T O1.End1))
SalesOrder2  Start2   T O2.(Order   T O2.
(Delivery   T O2.(P ayment   T O2.End2)))
SalesOrder3  Start3   T O3.
(Order   T O3. (Delivery   T O3.(P ayment   T O3.End3))
  T O3.(Reorder   T O3.(P ayment   T O3.End3)))
Delivery  Start4   T O4.(Conf irmOrder  T O4. (StockU pdate   T O4.End4))
  T O4(P repareShipping   T O4.(Shipping 
 T O4.(StockU pdate   T O4.End4)))

P ayment  Start5   T O5.( Invoice   T O5.(Debit   T O5.End5))
Reorder  Start6   T O6.(T estArticle   T O6. ((InternalReorder  Standard 

ExternalReorder  Standard)   T O6.
(SendReorder   T O6.End6)))

Fig. 3. The Sales Order Processes in DL

Domain knowledge (Figure 4) contains terminological information about activities and subactivities of the processes, e.g. a credit card payment is a subclass of payment. Figure 5 contains further process definitions also without
cardinality restrictions. CreditCardP ayment and CashP ayment are specializations of the P ayment activity. SalesOrder2 Credit and SalesOrder2 Cash
refine the SalesOrder2 process using the subconcepts CreditCardP ayment and
CashP ayment instead of P ayment. In the remainder of this paper, we refer to
the set of axioms from Table 3, Figures 3, 4 and 5 as the knowledge base KB.

G. Groener and S. Staab

CreditCardP ayment  P ayment
CashP ayment  P ayment
CashP ayment  CreditCardP ayment  

Fig. 4. Domain Knowledge Axioms

SalesOrder2 Credit  Start2   T O2.(Order   T O2.
SalesOrder2 Cash  Start2   T O2.(Order   T O2.

(Delivery   T O2.(CreditCardP ayment   T O2.End2)))
(Delivery   T O2.(CashP ayment   T O2.End2)))

Fig. 5. Additional SalesOrder-Processes in DL

3.3 Relations between Processes

Specialization and refinements are orthogonal relationships between processes.
A specialization (or sometimes called an extension) is a relationships between
processes in which the specialization of a process consists either of additional
activities or some of the activities are specialized. An activity specialization or
a subactivity is a subclass of the more general activity. Specializations are described as inheritance relationships in [20]. There is a distinction between four
different inheritance relationships. One of them is the projection inheritance
which refers to the notion of specialization in our process model. A formal definition is given in Definition 1.

As in [20] we use the term hidden activity to refer to an activity in a process which is not executed, i.e. this activity would be removed from the flow.
The edges to and from the hidden activity remain in the process as a valid
path but without these activity. For instance SalesOrder3 is a specialization
of SalesOrder2. The additional activity is Reorder. If Reorder is hidden in
SalesOrder3 the processes are equivalent. With equivalence we refer to bisimulation equivalence. The path via Reorder is still an existing path, but without
any activity. Therefore a hidden activity is also called an activity without effect.
 is a specialization or extension of P if the following
 or
 with respect to the terminology. The subactivity is
 are hidden
 are activities that are

Definition 1. A process P
conditions hold: (1) Each activity from process P is either an activity in P
there is a subactivity in P
subsumed by the activity from P . (2) If all additional activities in P
then P
neither in P nor subactivities of them are in P .

 and P are bisimilar. Additional activities of P

These definition refers to definitions like in [5,20]. In our model, we use DL concept subsumption to analyze process specializations. If a process specialization
contains a parallel execution instead of a sequential or it contains additional
activities or additional conditions, this specialization is subsumed, since it is
modeled as concept intersection. These DL concept subsumptions conform to
Definition 1, e.g. SalesOrder3 is subsumed by SalesOrder2 and SalesOrder3
is a specialization with respect to the definition.
?

?

?
A process containing a decision like Reorder is not subsumed by a process
without the decision. For instance the Reorder process without InteralReorder
activity does not subsume the Reorder process, since the decision is modeled as
a concept union and therefore define a more general concept. However, decisions
are not specializations with respect to our definition, since hidden additional
activities do not lead to the same process. The path of the hidden activity (e.g.
InternalReorder) still exists, and therefore the activity ExternalReorder could
be omitted using the other path (with no effect) which is still available. For loops
the DL subsumption also confirms to the definition. Adding a Loopj to a process
is like adding a single activity to the more general process.

In [21] process specialization is defined using execution set semantics. The ex-
 is a specialization
ecution set of a process contains all process runs. Process P
with respect to the minimal execution set semantics, if it contains at least all

process runs from the general process. This definition is valid for processes P
containing decisions compared to a process P without decision. Under the maximal execution set the specialization consists of a subset of the process P . This
definition refers to all other primitives except decisions that satisfy the concept
  P . Therefore this model can not be referred to only one of
subsumption P
these specialization notions.

A refinement is an equivalent representation with another granularity
(cf. [21]). The same process is described in a more fine-grained representation.
The inverse of a refinement is an abstraction. A refinement replaces activities
of a process with corresponding subprocesses, e.g. P ayment is replaced in a
SalesOrder process as described in Figure 2. A subprocess can also consist of a
single activity.

4 Semantic Query Patterns for Process Retrieval

In Section 3 we have used the expressiveness of OWL to describe the control flow
of processes, activity decomposition and specialization of activities and processes
(Figure 4,5). In order to satisfy the requirements from Section 2.3 we express
queries in DL and use DL reasoning to query the process models and derive
process information and relationships.

Queries are general and incomplete process descriptions which specify the
requested core functionality of the process. The query result contains all processes of the KB satisfying the query specification. The retrieval of a process
with respect to the query depends on the axioms in the KB, i.e. the process
information. We apply two different inference strategies in order to demonstrate
how information or missing information in the KB may lead to different query
results, depending on the applied inference method.

A strong inference method is the entailment of concept subsumption, i.e.
the query subsumes the retrieved processes. The subsumption is used only in
one direction. The result processes are specializations of the query. A weaker
inference method is the satisfiability of concept conjunction, i.e. to test whether
a process and the query process may have a common process run. This weaker

G. Groener and S. Staab

condition leads to a higher number of results. The result processes are candidates
for the query process. Missing information, e.g. missing disjointness axioms leads
to a higher number of positive results. In general, adding further axioms to the
KB reduces the result set for this inference method.

We consider three non-disjoint query patterns with respect to the control
flow of a process. The first pattern mainly considers the retrieval of processes
with respect to the execution order. The second pattern considers terminological queries. Queries for the modality are demonstrated with the third pattern.
The query pattern consist of three components: query, inference and result. The
query input P is a process description. Inference is the description of the applied
reasoning strategy, i.e. entailment or satisfiability. For sake of a shorter presen-
tation, we only depict the applied inference for one process (here SalesOrder1),
but this is performed for all processes in the KB.

Pattern for Execution Order. A query for question Q1 from section 2.2 is
described below. The query result contains all processes from the KB which
conform to the described execution order.
Query. Which processes execute P ayment after Delivery?
{P   T OT.(Delivery   T OT.P ayment)}
Inference. Test entailment of concept subsumption:
KB |= SalesOrder1  P , . . .
Result. {SalesOrder2, SalesOrder2 Cash, SalesOrder2 Credit, SalesOrder3}
The result contains all processes that execute Delivery before P ayment with
an arbitrary number of activities between them. The result includes also processes which specialize the P ayment activities. If the query should only retrieve
processes with directly connected activities, the transitive role T OT is replaced
by the role T O in the query. For instance the following query searches for all
processes with P ayment as direct follower of Order.

Query. Which processes execute P ayment directly after Order?
{P   T OT.(Order   T O.P ayment)}
Inference. Test entailment of concept subsumption:
KB |= SalesOrder1  P , . . .
Result. {SalesOrder1}
Pattern for Process Terminology. This pattern uses the terminological
knowledge. This covers the extension of processes and the specialization of ac-
tivities. The following query searches for all processes in which the Delivery
activity is executed before the Debit activity. In all described processes there is
at least the Invoice step between these activities.
Query. Which processes execute Delivery before Debit?
{P   T OT.(Delivery   T OT.Debit)}
?

?

?
Inference. Test entailment of concept subsumption:
KB |= SalesOrder1  P , . . .
Result: {SalesOrder2, SalesOrder2 Cash, SalesOrder2 Credit, SalesOrder3}
The query refers to the refinement of P ayment, since only the decomposed
process contains the Debit activity. If the query only uses the T O relationship
the result-set is empty.

The next query searches for all extensions of the process SalesOrder2, as

described in question Q4.
Query. Which processes extend SalesOrder2?
{P  SalesOrder2}
Inference. Test entailment of concept subsumption:
KB |= SalesOrder1  P , . . .
Result. {SalesOrder2 Credit, SalesOrder2 Cash, SalesOrder3}
The extensions SalesOrder2 Credit and SalesOrder2 Cash are generalized
by SalesOrder2 since they contain a payment activity which is defined as
a specialization of P ayment. The extension relation between SalesOrder2
and SalesOrder3 is inferred since SalesOrder3 contains all activities from
SalesOrder2 and additional activities (Recorder). For the entailment the same
T Oi roles are required.

Pattern for Process Modality. This pattern considers queries which express
the modality of processes that refer to questions like Q2 and Q3 and also terminological query Q4 from Section 2.2. The first query searches processes that
offer a credit card payment.

Query. Which process offers CreditCardP ayment?
{P   T OT.CreditCardP ayment}
Inference. Test entailment of concept subsumption:
KB |= SalesOrder1  P , . . .
Result. {SalesOrder2 Credit} There is only one process definition with an explicit statement that the payment method is CreditCardP ayment. The next
query searches for all processes that only offer credit card payment. Using concept subsumption there is no process that fulfills this condition, i.e. is subsumed
by the query process. Since in no process definition the condition is explicitly
stated. However, if the inference is changed to the weaker satisfiability of concept
intersection, there are processes which are candidates for satisfying the query.
The p in the query refers to a process run which is not in the KB.
Query. Which process only offers CreditCardP ayment?
{P   T OT.(P ayment  CreditCardP ayment)}
Inference. Test satisfiability of concept intersection: KB {p : (SalesOrder1 
P )}, . . .
?

?

?
Result. {SalesOrder1, SalesOrder2, SalesOrder2 Credit, SalesOrder3} The
query description P describes that if there is a P ayment activity in the process it must be a CreditCardP ayment. The formula is valid for all SalesOrder
processes except for the SalesOrder2 Cash processes since there is an axiom
in the KB that the payment methods CreditCardP ayment and CashP ayment
are disjoint.

5 Evaluation

Dataset: We evaluated the process retrieval with a KB of 182 different process
models. These process models are based on ten real world processes (business
processes) from the SAP Business Workflow library3, from the Enterprise Services (ES) Workplace at the SAP Developer Network (SDN)4 and from the
process library 5. We used multipliers in order to create from each basic process
model between 16 and 25 different models. A multiplier modifies the processes using the following operators: (1) Add and remove activities (2) Change of activity
order, (3) Replace activity with sub- or superactivity and (4) Add and remove
flow conditions. These process models were transformed into OWL. The process models contain unconditional decisions (70%), conditional decisions (65%),
split/fork (40%) and loops (25%). The DL expressivity is SHIQ.

Methodology. For the evaluation we used the Pellet 2.0.0 reasoner in Java 1.6
running on a computer with 1.7 GHz CPU and 1 GB RAM. The retrieval is
evaluated on four knowledge bases with different size. The first contains 52, the
second contains 107, and the third and fourth contain 182 process models. In
the last two KB the size of the processes (number of activities) is different. Due
to this generation method the KB contains many similar process models that
only differ in some activities or their ordering.

Depending on the size of the KB the evaluation consists of 25 until 35 queries
like the demonstrated queries from Section 4. In the evaluation each query invokes the reasoner without caching. The queries for activity order also considered
activities within non-sequential process parts, like in parallel executions or deci-
sions. For terminology, we queried also for flow conditions and their complement.

Result. The evaluation result is depicted in Table 4. The first column refers
to the number of processes in the KB. The second column contains the average
number (Av.) of activities in a process and the third column the maximal (Max.)
activities of a process. The number of axioms of the ontology is described in
column four. The columns five and six describe the retrieval time (average and
maximum) for simple queries in milliseconds (ms). Simple queries contain only
one activity or a negated activity. All other queries with multiple activities (at
least three) are referred to as complex queries, the retrieval time is in the columns

3 http://help.sap.com
4 http://esworkplace.sap.com/sdn
5 http://bpt.hpi.uni-potsdam.de/Prozessbibliothek/WebHome
?

?

?
Table 4. Retrieval Evaluation Result

No. KB Size Process Size Axioms Simple Query Complex Query Concept Sat.
Time [msec.] Time [msec.] Time [msec.]
Av. Max. Av. Max.
?

?

?
Av. Max.
12.7
12.9
12.9
21.2

Av.
?

?

?
seven and eight. The average size of the result set (number of process models) of
the queries using concept subsumption is 9.3 for the smallest KB, 9.8 for the KB
with 107 models, 13.7 and 14.6 for the knowledge bases with 182 models. The
retrieval time for all processes which satisfy the concept intersection with the
query process (weak reasoning condition) are outlined in column nine (Sat.).

The performance evaluation from Table 4 indicates the following results. The
influence of the size of the process models is negligible, as described in No.3, 4.
In both settings there are 182 process models in the KB but the average size of
the process models in No.4 is about 60% higher. For simple queries the retrieval
time is even lower. The retrieval time increases by the number of processes in the
KB. As indicated in the settings No.1 - 3 the retrieval time increases lightly from
a KB with 52 processes compared with the KB with 107. If the KB is extended
to 182 which is an increase of 70% the retrieval time is more than doubled. There
is no performance difference between queries which contain activities either at
the beginning of a process or at the end. The complexity of the query process
(simple or complex) has also no influence. This indicates that only the number
of process models in the KB affects the retrieval time.

The evaluation outlines the following qualitative results. (i) Processes form the
KB are subsumed by the more general query process using the roles T O and T OT ,
except queries with decisions, since decisions are not considered as specializations
and therefore not subsumed. (ii) However, if the query contains activities which
are after a decision and before the merging of the flows the query has to cover either
every sequence after the decision or use the disjoint flow conditions to retrieve the
processes containing the decision. Since loops are special decisions, the retrieval
of processes containing loops is realized in the same way.

(iii) The retrieval of refined processes depends on the refinement. If the refinement is realized by the decomposition of activities into subprocesses at the
end of a process, the processes are retrieved using concept subsumption. Otherwise it requires two queries. For instance the query for a refined process
 T OT.(StockU pdate   T OT.P ayment) is transformed into a first query that
selects the subprocess, the second query uses the start-activity of the refined pro-
cess, e.g.  T OT.(Starti   T OT.P ayment), at which Starti is the start-activity
(first activity) of the subprocess containing StockU pdate. The problem is that
the order relation T O is not inferred for the subactivities (e.g. StockU pdate)
with respect to the following activities of the original process (e.g. the relations

G. Groener and S. Staab

Table 5. Comparison of Modeling Dimensions

[3] [8] [10] [11] [6, 16] [19] Our Model
Modeling Characteristic
y y n
Control Flow Modeling
Realization of Process Retrieval
n n y
Activity Terminology in Modeling and Retrieval n n n
y y
Process Refinement
y
n n n
Modality
State Change
n n n

n
y
n
y
n
y

y
y
y
y
y
n

y
y
y
n
n
n

n
y
y
y
n
n

from StockU pdate to P ayment). (iv) More complex refinements, e.g. change of
the original execution order in combination with activity specialization is not
retrieved by concept subsumption.

Distinction to other Technological Approaches. (i) Another way of using OWL for
process modeling is the annotation of process models, i.e. other process models
like UML are enriched with OWL annotations. However, the aim of our model is a
generic process model in OWL with an explicit description of activity relations
within a process. (ii) Non-ontological models like graph-based representations
and queries [7] or tree-shaped diagram unraveling can manage the same ordering
queries, but there is no reasoning benefit for process retrieval and a lack of
representing terminological information, which is another aim of our approach.

Lessons Learned

Process Modeling. Modeling with cardinality restrictions leads to a more precise model. The difference between a decision and a parallel execution is emphasized with this restriction that there exists either exactly one follower or exactly
n follower. There is a modeling tradeoff between accuracy and generic modeling.
Generic descriptions account for a larger result set with respect to the demonstrated query mechanism. We do not model the join of decisions and parallel
flows, which could be easily added with axioms like D   T O

i .C
for No.7 and 9 in Table 2. The join is described by the occurrence of the same activity (name) in all paths after the decision or split. This accounts for a maximal
possible result set.
For the same reason we model decisions as union  T Oi.(B  C) with only
one T Oi relationship instead of  T Oi.B   T Oi.C in order to retrieve a process
with this decision also for queries which contain both activities simultaneously,
e.g. either B before C or vice versa. We do not require disjointness of activities
in a flow and within decisions and parallel flows which could be simply added to
the knowledge base by disjointness axioms.

i .B   T O


Process Retrieval. Retrieval of refined processes is difficult due to the process definition using complex expressions. The relation from an activity to its
successor is only defined for the process as a whole and not for the activities.
However, in the demonstrated modeling methodology the reasoning complexity
?

?

?
is lower than in the other modeling approach with explicit descriptions of the
activity relations since the number of defined concepts in the ontology would
be significantly higher. The query expressions are also more intuitive. Another
benefit from the chosen modeling technique is the possibility to identify relationships between processes, e.g. process specializations. Since processes would be
modeled by explicit relationships between activities, an activity can not occur
in two different processes. Therefore it is required to use subclasses to denote
the activities of the different processes.

6 Related Work

A comparison of our model with other process models is depicted in Table 5.
The comparison contains modeling and retrieval.

For a core of our model, i.e. sequences only, this had already been accomplished by [14]. We significantly extend their model to account also for decisions,
conditions, forks, joins, and loops. The matching of processes with different reasoning strategies is adopted from [13]. Process retrieval based on process information and annotation is realized in in [19]. A layered process representation is
used. A service retrieval with additional functional information is described in
[8,15] Other applications use search algorithms for process retrieval, like [6,16].
Similarity measure with respect to the process annotations and descriptions is
used instead of logical reasoning. They use a process ontology and a corresponding query language. The retrieval in [10] also uses search algorithms instead of
reasoning. DL based process models are described in [11] in order to enable
process reuse. The model does not consider complex control flow.

The following approaches are focused on modeling and analyzing without
retrieval. The OWL-S process model [1] is an OWL ontology for process descrip-
tion. Flow sequences are modeled as ordered lists. Like in OWL-S, processes are
described as service interactions in WS-BPEL [2]. A XML messaging protocol is
defined in order to specify the interoperability of services. The process specification language (PSL) [18] provides a mathematical model for activities, relations
between activities and for data exchange. In [3] the control flow is analyzed according to the OWL-S process model. A combination of OWL and petri nets is
demonstrated in [17]. OWL is only used to annotate the process models.

7 Conclusion

In this paper, we described process control flow modeling and retrieval
in
OWL-DL. For an application scenario we outlined the requirements of process
retrieval with respect to the internal process structure. In order to fulfill these
requirements it is necessary to describe explicitly the execution order of a process
and to express the modality and terminology of process activities and structures.
This also requires reasoning support to identify process extensions and terminological relationships between activities. Based on a process description with
UML Activity Diagram the process models were transformed into OWL-DL. This

G. Groener and S. Staab

contained a general description of the transformation and the design principles.
The query patterns for process retrieval with respect to the control flow also cover
the relationship between processes and demonstrate the usage of terminology and
modality in the retrieval. In the evaluation the modeling and retrieval results,
strengths and weaknesses are discussed.

Acknowledgements

This work has been supported by the European Projects MOST (ICT-FP7-2008
216691) and X-Media (IST-FP6-026978).
