A Weighted Approach to Partial Matching for

Mobile Reasoning

Luke Albert Steller, Shonali Krishnaswamy, and Mohamed Methat Gaber

Faculty of Information Technology, Monash University, Melbourne, Australia
{Luke.Steller,Shonali.Krishnaswamy,Mohamed.Gaber}@infotech.monash.edu

Abstract. Due to significant improvements in the capabilities of small
devices such as PDAs and smart phones, these devices can not only consume but also provide Web Services. The dynamic nature of mobile environment means that users need accurate and fast approaches for service
discovery. In order achieve high accuracy semantic languages can be used
in conjunction with logic reasoners. Since powerful broker nodes are not
always available (due to lack of long range connectivity), create a bottleneck (since mobile devices are all trying to access the same server) and
single point of failure (in the case that a central server fails), on-board
mobile reasoning must be supported. However, reasoners are notoriously
resource intensive and do not scale to small devices. Therefore, in this
paper we provide an efficient mobile reasoner which relaxes the current
strict and complete matching approaches to support anytime reasoning.
Our approach matches the most important request conditions (deemed
by the user) first and provides a degree of match and confidence result
to the user. We provide a prototype implementation and performance
evaluation of our work.

1 Introduction

The number of mobile subscribers is reaching the 3 billion mark, world wide [20].
This provides significant opportunities for new mobile applications which meet
mobile user demands for improved access to information in their environment.
The real usefulness of these small devices is in their interaction [23], that is,
information sharing. [24] advocates the usefulness of service oriented architectures and accurate service discovery for mobile services, because of the need to
support user mobility in dynamic environments. In addition, advances in device
capability mean that mobile devices can act not only as service consumers but
also as service providers or will do so in the near future [19,16]. Most current
service discovery architectures perform matching on a high-end broker server.
However, for dynamic ad-hoc mobile environments, assuming the existence of
devices that are stable and powerful enough to play the role of the central service registries [or brokers] is inappropriate [16]. In addition, with the growth
of increasing services, it is seen that such a centralised approach could become
a bottle neck for the whole system [22]. Cost is also a significant factor which
determines whether users are likely to use a mobile service. There are clear evidence in studies that the benefits must exceed the cost [9]. It is also noteworthy,

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 618633, 2009.
 Springer-Verlag Berlin Heidelberg 2009
?

?

?
that in terms of monitoring costs as well as cost energy efficiency, communication
from mobile devices to a remote location has been established as more expensive
than performing computation on the mobile device.

Employing a partially or completely decentralised approach in which the
matching occurs on the mobile device itself overcomes all of these problems. Onboard reasoning would remove a central point of failure, deployment is cheap and
scalable because adding more users does not involve any additional network provision and elevates privacy concerns. The ontologies used in the reasoning process
could be collected by devices as the user walks past other devices, short-range
download points (such as a Kiosk or shopping centre entrances) or downloaded
previously (eg at home or work) from the Internet. However, mobile service
discovery and matching must meet two important user requirements. Matching
must be accurate / useful [9] and fast [14].

Accuracy can be achieved by adopting semantic web ontology languages
(OWL) and using logic based reasoners to infer relationships to model requirements and using logic reasoners to infer new information from these ontologies.
Most current semantic reasoners utilise description logic (DL) which provides the
most expressive, decidable OWL logic. However, these logic reasoners are notoriously slow and resource intensive [25]. As such current reasoners cannot be
ported to resource constrained mobile devices such as smart phones and PDAs,
in their current form, especially since mobile users generally require a result
within 10-15 seconds [14]. Current reasoners give only a true or f alse result, or
no result at all, if the inference task is not completed in full. [4] advocates the
need to relax these traditional notions of absolute accuracy and completeness
for increased performance without reduced expressiveness. Therefore, in this pa-
per, we provide such an approach, a prototype and an evaluation, which has the
following features:

1. match the most important request conditions first (as deemed by the user

explicitly or implicitly by preferences);

2. handle heterogeneous inaccurate data by continuing to reason after a term

failed (if there is sufficient time);

3. handle time/resource pressures by supporting early stopping of the reasoner

and providing a current degree of inference to the user.

The remainder of the paper is structured as follows. In section 2 we describe
related work. In section 3 we discuss the current approach to reasoning using
Tableaux. In section 4, we provides an adaptive reasoning approach to meet
the three goals above. In section 5 we discuss our implementation and provide
evaluations of our work. Finally in section 6 we conclude the paper.

2 Related Work

While current service discovery architectures such as Jini [1] do not make use
of semantic languages, there is a growing emergence of OWL-S semantic matchmakers such as CMU Matchmaker [15] which requires a centralised high-end

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

node to perform reasoning. Architectures such as DIANE [11] and Gaia [13] provide semantically driven context middleware. EASY [12] takes context and QoS
into consideration and performs indexed classification of the ontology hierarchy
offline such that subsequent lookup is much faster. However all of these architectures require the existence of a high-end central node, due to their reliance
on current reasoners.

Gu et al. [6] an RDF reasoner which runs on mobile devices on J2ME with
acceptable performance, but it only supports a subset of semantic technologies
and forward chaining rule inference. Kleeman et. al. [10] have developed KRHy-
per, a first order logic (FOL) reasoner for deployment on resource constrained
devices. However, performance is comparable with RacerPro. [5] compares ontology terms by Google distance, but this requires Internet access to Google. [7]
disregards non-horn clauses, to provide a faster but less accurate result by reducing expressiveness. These works do not implement logical level optimisations
to enable mobile reasoning, other than by reducing the language expressively.

The work provided in [18] approximates class membership inference and iteratively matches all inference conditions. The reasoner can be stopped maturely,
and a true result is given if the current approximation / iteration holds. [21] provides conjunctive query answering and instance retrieval. The main limitation
of these approaches is that they rely on the Tableaux algorithm. It is evident in
[2] that DL Tableaux checks conditions in depth first order. Current approaches
do not take level of importance of each condition into consideration and do not
provide degree of match / confidence metrics. Therefore, we provide an approach
to address this need. In the next section we describe current Tableaux reasoning
then introduce our novel architecture in section 4.

3 Tableaux Reasoning

The power of semantics means that in addition to explicit definitions and as-
sertions, implicit knowledge can be made explicit using inference. The most
expressive OWL language which retains decidability [3] is known as OWL-DL
which is based on description logic (DL) [2]. OWL-DL inference proves include
Pellet1, FaCT++2, RacerPro3 and KAON24. Most of these reasoners use the
Tableaux algorithm which has dominated recent DL research [2].
DL comprises a TBox T containing terminological class concept definitions
and an ABox A comprising assertion definitions. The ABox assertions are called
nodes or individuals x which are defined by their membership to a class concept
C and by its relations R to other objects to form a graph. These two definitions
are given in equation 1.

C(x)

or

R(x1, x2)

(1)

1 http://clarkparsia.com/pellet
2 http://owl.man.ac.uk/factplusplus
3 http://www.racer-systems.com
4 http://kaon2.semanticweb.org
?

?

?
Tableaux [8] is an unsatisfiability algorithm which attempts to prove an inference
by refuting it. For instance, in order to prove an inference of the form C(x), its
negation is added the ABox A such that A0 = AC(x). The inference is proven
if any attempt to extend the asserted negation into a complete interpretation
will lead to a logical contradiction (a concept and its negation are present for the
same individual). Alternatively, if a sound and non-contradictory interpretation
is found, then this represents a counter example that disproves the conjectured
inference.
Tableaux minimises the amount of space used by utilising a Tableaux expansion tree T . This tree imposes an ordering on the application of expansion
rules. Disjunctive concepts give rise to expansion and every possible expansion
is searched in turn until a fully expanded and clash free tree is found, or all
possibilities have been shown to lead to a contradiction. When A contains the
disjunction (C1"C2)(x), disjunction transformation rule replaces A with A = A
{C1(x)},A = A{C2(x)}. As such (C1 " C2)(x) represents a branching point
node n in the expansion tree T which contains new ABox states, and the concepts C1(x) and C2(x) each represent possible future branching point nodes n. In
this paper, we distinguish between branching point nodes n  T and individuals
x  A, by referring to n as a node and x as an individual.

Tableaux also labels each concept in an individual and each role in an edge
with a dependency set, indicating the branching points on which it depends. A
concept C  L(x) depends on branching point n if C was added to L(x) at the
branching point n or if C depends on another concept D (or role R), and D (or
R) depends on the branching point n. A role R = L(x, y) depends on concept
D when x, y was labelled R by the application of an expansion rule that used
D. When a clash occurs, the reasoner state is restored to the most recent branch
point where exploring another branch might alleviate the cause of the clash.

It is evident in [2] that DL Tableaux employs depth first expansion, which
we illustrate in algorithm 1. Initially, this algorithm is started using the call
T abT reeT raverse(f, H,A,T ) where f is the top branch node in the expansion
tree, H is the assertion C(x) for the inference check C(x), A is the ABox,
which is initialised with all the explicit assertions and relations in the semantic
graph (knowledge base) and T is the expansion tree. The algorithm attempts to
expand the tree and apply Tableaux transformation rules in order to generate
a clash to prove all alternatives of the the tree, which are all of the conditions
of the inference. If it returns true then the inference is proven. The algorithm
utilises ApplyT ransRules(A) which applies the normal Tableaux DL transformation rules as defined in [2], on ABox A until a clash is detected (return true)
or there are no more rules to apply (return f alse). The backjumping functionality is provided in algorithm 2. We note that we define a branch point node n
identifier as branchID(n) and we define a concept C or role R dependency set
using depBranchIDs(C). Let currBranchN ode(A) contain the currently active
branch point node in the expansion tree for the ABox A.

An example of an dependency directed, expansion tree is shown in figure 1.
This figure represents the inference check C(x) where C is a conjunction of the

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

Algorithm 1. TabTreeTraverse(n, W,A,T )
1: Inputs: BranchNode n, Assertion W , ABox A, ExpansionTree T where W is of

the form C(x)

return true

for all Dj  W do

2: Outputs: Boolean clashF ound
3: Let clash be a clashing concept if one exists
4: clash  ApplyT ransRules(A) \ runs the standard Tableaux rules \
5: if clash = null then
6:
7: end if
8: Let clashF ound  false
9: Let branchID(n) denote the branch point node identifier for n
10: if W = (D1  D2  ...  Dm)(x) \ has children \ then
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24: end if
25: return clashF ound

Let c be a new BranchNode in the expansion tree T for A, T  T  {c}
branchID(c)  branchID(c) + 1
currBranchN ode(A)  c
L(x)  L(x)  {Dj(x)} where x is an individual in A
clashF ound  T abT reeT raverse(c, Di(x), A,T )
remove c from T
if clashF ound = false then

return false\ failed to prove inference for disjunct c \
restoreT o(n) \ backjump to n \

else

end if
end for

Algorithm 2. RestoreTo(u, A)
1: Inputs: int u and ABox where u is the branch node identifier to restore A to.
2: Outputs: ABox A
3: for all xi  A where xi is an individual \ all individuals in ABox A \ do
4:
5:

for all Aj  L(xi) where Aj is a class concept do

Let t be the minimum value in depBranchIDs(Aj) where depBranchIDs(Aj)
contains the branch dependency identifiers branchID for class concept Aj
if t > u \ Aj added after u \ then

remove Aj from L(xi)

6:
7:
8:
end if
9:
end for
10: end for
11: return A

form C  ((C1C2)C3). Also assume {C1, C2, C3}  L(x) where x  A. Since
Tableaux proves inference by refutation C is transformed into a disjunction of
the form C  ((C1 " C2) " C3). In figure 1a, a clash is detected caused
by C1 which is part of the disjunction (C1 " C2), added to L(x) at branch
?

?

?
node 2. Therefore, the Tableaux is restored to its earlier state, by a backjump to
branch 2. Then in 1b, the second element C2 of (C1 " C2) is applied, giving
rise to another clash. The reasoner backjumps to expansion tree node 1 (1c),
after which the second disjunct C3 of ((C1 " C2) " C3) is applied giving
rise to a third clash. All branch nodes clashed, so the inference C(x) is proven.
Note that grey nodes indicate those which have already been evaluated in a
previous iteration. In this example, only one individual x was used for briefness,
however in practise the expansion tree may apply disjuncts to several different
individuals.

L(x) U 

{((


?

?

?


)    


?

?

?
)}

L(x) U 

{((


?

?

?


)    

)}
?

?

?

Backjump: 1
?

?

?
L(x) U 

{((


?

?

?


)    


?

?

?
)}

L(x) U

}C
{

L(x) U
{(
Backjump: 2


?

?

?


)}

L(x) U

}C
{

{



C

}



L(x)
a

L(x) U

{(


?

?

?


)}
?

?

?
L(x) U
}C
{

 Clash

{



C

}



L(x)
b

 Clash

{



C

}



L(x)

 Clash

c

Fig. 1. Standard Tableaux Expansion Search Tree

Current Tableaux has the following shortcomings:

1. Only a true/false answer is provided. A weighted degree of match and a level
of confidence in this match based on how much of the inference was checked,
should be provided;

2. The order of condition and subcondition evaluation is depth-first. These
should be applied in weighted order of importance to the user, so that the
highest possible degree of match can be found in the time available;

3. Tableaux returns f alse as soon as any condition or subcondition in the inference check fails. Since pervasive environments inherently contain dynamic
heterogeneous data the reasoner should continue to check subsequent inference conditions, even if some fail (time/resource permitting).

Our approach, which addresses these shortcomings, is introduced in the next
section.

4 Weighted Adaptive Reasoning

We propose an approach to Tableaux inference proof, which supports a reduction
in result accuracy if greater efficiency is required. Our approach associates a
level of importance with each branch leaf and evaluates these branches first.
The reasoner will continue even if some conditions fail, and may be stopped at
any point in the reasoning process and a degree of match result is provided to
the user.

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

4.1 Weighted Expansion Tree Traversal

Certain inference conditions may have a different level of importance to the
user. Therefore, we associate weights with each condition and sub-condition.
These weights may be entered explicitly by the user at the time that the user
specifies the request as a rating from 1 to 10, high/medium/low priority, or
mandatory/non-mandatory. These values are converted to relative weights (see
below). Alternatively, weights may be gathered implicitly using historical user
preference data. For instance, if for half his or her requests, the user has invoked
services which are close in proximity, this characteristic may be inserted to future
requests with a weight of 0.5. In summary, weights may be assigned by different
means, however, the assignment process is not the principle focus on this paper,
therefore, we do not discuss this in further detail.

Let rw denote a relative weight value for each a condition or sub-condition derived from each conjunct or subconjunct in the class concept C, for the inference
check C(x). Since Tableaux proves the inference using negation, C is converted
into a disjunction where C  (D1 " (D2 "D3)" ...Dm), 1  j  m. Each
disjunct and sub-disjunct are organised as pairs containing the disjunct Dj
and relative weight rw(Dj) pairs and stored in descending rw(Di) order in a
queue, such that Q = {D1, rw(D1), D2, rw(D2), D3, rw(D3), ...,
Dm, rw(Dm)}, as shown in algorithm 3 where C is passed as input from
the inference C(x).

Weights are said to be relative, because the sum of the rw(Dj) values for all
children nodes much equal the rw(pe) of the parent node. Let pe denote a node,
and let C denote a set of child nodes for pe such that C = {c1, c2, ..., ct | (1 
s  t)}. rw values must be defined such that rw(pe) =
csC rw(cs) where
pe, rw(pe). Relative weights ensure that a disjunct D1 in P = (D1 " D2),
cannot be applied before its parent disjunction P is itself applied.
?

?

?
Algorithm 3. CreateQueue(A)
1: Inputs: ClassConcept A
2: Outputs: Queue Q
3: if A = (D1  ...  Dm) then
for all Dj  D do
4:
Q  Q  {Dj , rw(Dj)}
5:
6:
7: end if

end for

Algorithm 4 presents a general illustration of our adaptive reasoning search
tree expansion process, which replaces depth first with condition relative weight
order. This algorithm is invoked by the call AdapT reeT raverse(Q, x,A,T ) where
Q is the pre-initialised queue as specified above, of disjuncts and sub-disjuncts
which have been expressed in C for the inference check C(x), and their relative
weights. x is the individual in the inference check C(x). A is the ABox, which
contains the explicit assertions and relations in the semantic graph (knowledge
?

?

?
base) and T is the expansion tree. Unlike Algorithm 1, AdapTreeTraverse (algo-
rithm 4) is not a recursive algorithm, rather it iterates through all the concepts
in the queue Q, as specified above, in descending relative weight order. It attempts to expand the tree and apply Tableaux transformation rules to generate
clashes to prove each condition. The algorithm continues until all conditions are
checked, or the algorithm is stopped prematurely when KeepM atching() results
a f alse.
Algorithm 4 uses the functions defined as follows. Let currBranchN ode(A)
be a holder containing the currently active branch point node in the expansion
tree for ABox A. Let ApplyT ransRules(A) denote a function which applies the
normal Tableaux DL transformation expansion rules on ABox A until a clash is
detected (return true) or there are no more rules to apply (return f alse). Functions GetDegM atch() and GetConf() return the degree of match and the confidence values (see section 4.3), which also make use of the clashingConcept(W )
and checkedConcept(W ) return value.

The function, KeepM atching() is used to determine whether the reasoner
should stop execution prematurely, based on constraints. There may be several
constraint parameters P , such that P = {p1, p2, ..., pn | (1  i  n)} and
threshold values T for parameters, such that T = {t1, t2, ..., tn | (1  i  n)}.
Each pi corresponds to a threshold value ti. A pi represents a ratio (0  pi  1),
such as memory used over total memory, current confidence over total total
possible confidence, time elapsed over total time available (user specified), and
battery life remaining over total battery life. Each ti is specified by application
defaults or explicit user requirements, such that 0  ti  1. KeepM atching()
returns f alse iff any ti  pi. In the current implementation of the algorithm
(see section 5), we utilise time as our only resources parameter, such that p1 =
timeElapsed/totalT ime, where totalAvailT ime is user specified, eg I want a
result in 10 seconds.
Figure 2 illustrates an example utilising our adaptive reasoning approach,
for the inference check C(x) where C  ((C1 " C2) " C3) is given the
relative weights, such that {C, 1.0,(C1 " C2), 0.7,C1, 0.5,C3, 0.3,
C1, 0.2}. Assume also that {C1, C2, C3}  L(x) where x  A. The nodes are
executed in relative weight rw order (weights and node identifiers are displayed
on the nodes in figure 2). Notice that in contrast to depth-first Tableaux (see
figure 1), concept C3 is applied in step b, before the concept C2 from (C1 "
C2) is applied in step c. This is because C3 had a relative weight of 0.3,
which was higher than 0.2 for C2. The grey nodes denote those nodes which
have already been expanded in a previous step and do not need to be re-applied.
In this example, only one individual x was used for briefness, however in practise
the expansion tree may apply disjuncts to several different individuals.

4.2 Branch Identifiers and State Management

The, relative weight values control execution, as opposed to the traditional depth
or breath-first ordering. Therefore, it is likely that there may be multiple unfinished expansion branches. As shown in section 3, in depth-first reasoning,

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

if KeepM atching() = false then

return GetDegM atch(Q), GetConf(Q)

..., Dm, rw(Dm) | (1  j  m)} and D is a class concept \

Algorithm 4. AdapTreeTraverse(Q, x,A, T )
1: Inputs: Queue Q, Individual x, ABox A, ExpansionTree T .
2: Outputs: Decimal degM atch, Decimal conf
3: \ Q is in descending order by rw(nj) where Q = {D1, rw(D1), D2, rw(D2),
4: for all Dj  Q do
5:
6:
7:
8:

end if
Let h be a new BranchNode in the expansion tree T for A such that T  T {h}
currBranchN ode(A)  h
L(x)  L(x)  {Dj} \ where x is an individual in A \
checkedConcept(Dj)  true\ for confidence \
Let clash be a clashing concept, if one exists
clash  ApplyT ransRules(A) \ runs the standard Tableaux rules \
if clash = null then

9:
10:
11:
12:
13:
14:
15:
16:
end if
17: end for
18: return GetDegM atch(Q), GetConf(Q)

clashingConcept(clash)  true\ for degree of match & confidence \

)}



2-0
rw:1.0



{((

L(x) U 
2-0
rw:1.0
?

?

?


)    


?

?

?
)}



)    


?

?

?
)}

L(x) U 

{((


2-0
rw:1.0

L(x) U

}C
{

3-1
rw:0.3

3-0
rw:0.7

L(x) U

{(


?

?

?


)}

L(x) U 

{((


?

?

?


)    



)}

3-0
rw:0.7

L(x) U

{(


?

?

?
}C
{
L(x) U

4-0
rw:0.5

Change to: 3-1

Change to: 4-1

L(x) U

}C
{

4-1
rw:0.2

{



C

}



L(x)
a

 Clash

{



C

}

L(x)

b

 Clash

{



C

}



 Clash

L(x)
c

Fig. 2. Tableaux Adaptive Expansion Search Tree

a branch is continually expanded using transformation rules such that A =
A  {...}. This depth first expansion occurs until either a clash is found or
there are no more branches to apply. Where a clash is found the ABox An is
restored to an earlier branch node ni state Ai, and the current state An is
discarded. This means that all ABox assertions added after branchID(ni) are
removed. However, under our adaptive reasoning strategy, the expansion tree
is expanded in branch node weight order, rather than depth first. This implies
that there may be several unfinished open branches at one time, for instance
?

?

?
in figure 2, branch point 3-0 from step a, is preserved for step c, while a new
branch is opened in step b. This was because concept C3 was considered more
important than C2.

Support for this functionality requires modifications to:

 Branch point node identifiers branchID
 State of node labels L(x) and L(x, y) where x and y are individuals

In terms of branch point node identifiers, a branchID(n) must be unique. How-
ever, since a traditional branchID(n) is only a depth count, it is no longer unique
if multiple branches are present in the tree T . Therefore, we specify new branch
identifiers adapBranchID(n), of the form given in expression 2, to take breath
into account. Let adapBranchID(n) denote the branch identifier for a node n
in a tree formation where depth(n) denotes the distance from the top most object in the tree down to node n and breath(n) is a count which increases for
every node in the tree which has the same depth(n), such that {2  depth(n),
0  breath(n). Note that adapBranchID 0-0 and 1-0 are reserved for explicit assertions and pre-processing. Let adapDepBranchIDs(n) contain a dependency

list of adapBranchID(n) for the node n. adapDepBranchIDs(n) contains the
branch identifier for node n and for all of its parents in the expansion tree T , such
pP adapBranchID(p)
where P contains all parent nodes of n in T .

that adapDepBranchIDs(n) = adapBranchID(n)

,

adapBranchID(n) = depth(n)  breath(n)

(2)

In terms of type label state management standard Tableaux does not support
multiple unfinished open branches. The state of type labels L(x) and L(x, y)
where x and y are individuals in ABox A is determined by parent branch point
nodes. Class concepts and role assertions are progressively added to type labels
by tree branch expansions and by other transformation rules as they occur, and
removed when a backjump (restore) occurs. However, in order to support multiple open branches, previously applied branch nodes much be retained. Type
labels support multiple states, and their contents (state) at any one time must reflect the current branch point node without requiring re-application of all parent
node expansions and transformations, when moving back to a previously partially expanded branch. Therefore, we redefine type labels, such that concepts C
and role assertions R(x, y) added to type labels L(x) and L(x, y), respectively,
are indexed by branch identifier.
In this section we refer to both L(x) and L(x, y), simply as L, such that
L = {adapBranchID(1), 1, ...,adapBranchID(p), p | (1  k  p)}.
Let V (w) be a subset of the elements k (concepts and relations) in L, where
w is the currently active branch node in the expansion tree (see algorithm 4)
and where w has a set of branch node dependencies and all the elements in
V (w) must have a branch identifier which is in this set of dependencies. This
is defined in algorithm 5, such that V (w) = {1, ..., v | (1  u  v)} where
adapBranchID(u)  adapDepBranchIDs(w). Therefore, V (w) can be considered as the state of L when the currently active expansion node is w, to support
?

?

?
swapping between simultaneous unfinished branches. For example, if L = {2-
1, 1,2-3, 2, 3-1, 3, 4-0, 4} and adapDepBranchIDs(w) = {2-1, 3-1}
where w = currBranchN ode(A), then GetT ypeLabel returns {1, 3}
Algorithm 5. GetTypeLabel(L, ABox A)
1: Inputs: TypeLabel L, ABox A
2: Outputs: Set V
3: Let w = currBranchN ode(A) \ currently active branch point node for A \
4: for all i  L where i = adapBranchID(i), i do
5:
6:
7:
end if
8: end for
9: return V

if adapBranchID(i)  adapDepBranchIDs(w) then

V  V  {i}

4.3 Degree of Match and Match Confidence
In our adaptive reasoning strategy we provide a degree of inference match and
a level of confidence in this result. Degree of match is the known, weighted
degree to which a particular inference C(x), holds. It is a normalised value based
on those conditions actually checked in the processing time available, where 1
denotes a complete match and 0 denotes no match. A degree of match is the
sum of all relative weight rw values for all the concepts C where a clash was
detected. Let Q denote a set containing all conditions and sub-conditions to be
checked, as defined in defined in section 4.1, Q = {D1, rw(D1), D2, rw(D2),
..., Dp, rw(Dp) | (1  k  p)} as defined in section 4.1 where rw(Dk) is the
relative weights for each condition specified in C for the inference check C(x).
Let getDegM atch(T ), given in formula 3, return the known degree of match for
a particular inference. Let clashingConcept(W ) contain true if the concept W
caused a clash, set by algorithm 4.

GetDegM atch(Q) =

rw(Dk) iff clashingConcept(Dk) = true
?

?

?
ejQ
where ej = Dk, rw(Dk)

Confidence is the normalised ratio providing a measure indicating the proportion
of the total reasoning process, which has been completed. Confidence is the ratio
of worst-case weighted number of conditions to execute over the number actually
executed. Let GetConf(Q) denote the confidence value, given in formula 4. Let
checkedConcept(W ) return true if the class concept W was actually applied by
the algorithm 4.
?

?

?
GetConf(Q) =

ejQ rw(Dk) iff checkedConcept(Dk) = true

where ej = Dk, rw(Dk)

ejQ rw(Dk)

(3)

(4)
?

?

?
In this section we provided our adaptive reasoning approach. Both our adaptive
algorithm (see algorithm 4) and standard Tableaux (see algorithm 1) have a
worst case complexity of O(n) where n is the total number of branch point
nodes which can be expanded in the tree T . However, if the level of confidence
required is reduced, the adaptive reasoning strategy has a best case complexity
of O(1) while Tableaux has a best case complexity of O(m) where m is the
average number of nodes in a branch in the expansion tree T .

In the next section we discuss the implementation of our adaptive reasoning
approach and provide an evaluation to illustrate the effect on performance and
result accuracy.

5 Implementation and Evaluation

In this section we discuss the implementation of our adaptive reasoning strategy
provide a performance evaluation using a case study.

5.1 Case Study
To demonstrate our adaptive reasoning we approach we developed a case study
in which Bob is searching for particular attributes in a foreign city centre, such
as a movie cinema, printing service, Internet cafe etc. The case study comprises
several request queries as follows (relative weight in brackets):
1. RetailOutlet (0.33), MovieCinema (0.3), Internet (0.23), Cafe (0.14)
2. RetailOutlet (0.40), MovieCinema (0.32), Internet (0.2), Cafe (0.04), Colour

Fax WiFi Printer (0.04)

3. Internet (0.5), Colour Fax WiFi Printer (0.3), Cafe (0.2)
Our scenario also has 8 different service advertisements which we label A, B,
C, D, E, F, G, H, where A matches all requests, B-G only partially match each
request, while H does not match any attribute in any request. The ontologies
containing these service offerings comprise 204 classes and 241 individuals.

5.2 Implementation
We have implemented our adaptive strategies as an extension to the Pellet5
1.5 reasoner which supports OWL-DL with SHOIN expressiveness [2]. Pellet
is open source, allowing us to provide a proof of concept. We selected Pellet
over FaCT++ because it is written in Java, making it easily portable to small
devices such as PDAs and mobile phones, while FaCT++6 is written in C++. All
our evaluations were conducted on a HP iPAQ hx2700 PDA, with Intel PXA270
624Mhz processor, 64MB RAM, running Windows Mobile 5.0 with Mysaifu Java
J2SE Virtual Machine (JVM)7, allocated 15MB of memory. Note, that in the
next section, results for both standard reasoning and adaptive reasoning utilise
optimisations from previous work which enable mobile reasoning [17].
5 http://clarkparsia.com/pellet
6 http://owl.man.ac.uk/factplusplus
7 http://www2s.biglobe.ne.jp/ dat/java/project/jvm/index en.html

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

5.3 Evaluation
Figure 3 shows the degree of match obtained by comparing request 1 with service advertisements A-H (see section 5.1), for standard reasoning and adaptive
reasoning. Both standard and adaptive reasoning stop on failure (stop as soon as
any request condition fails to match). Standard reasoning provides a meaningless
f alse result when stopped prematurely, while our adaptive reasoning strategy
provides a degree of match result for those request conditions, which were successfully matched in the available time. This demonstrates a far better reporting
of inference results to the user. The Check All results, figure 3, demonstrate
our support for heterogeneous data (continue matching when some conditions
fail). Figure 4 demonstrates that our adaptive reasoning strategy matches the
most important conditions first, for the services A-H, as well as supporting premature stopping and a degree of match result to the user. For most service
advertisements, most of the degree of match result is obtained in the first 10
seconds of processing.

Figure 5 compares request 2 and 3 against service advertisement A, showing
similar results. For instance in 5(left), a degree of match of almost 80% was
reached in the first 10s of operation, while the remaining 20% required 40 seconds
to establish. Figure 5(right) shows that when condition weights are similar, the
correspondence between degree of match and processing time is more uniform.
When standard reasoning was used, no result was provided until the reasoning
was completed in full, requiring 40 seconds. Figure 6 further highlights the way
in which our adaptive reasoning strategy matches the most important attributes
first to provide a higher degree or match more quickly, in order to make the best
use of processing time available. This figure compares adaptive reasoning against
the result which would be obtained if standard Tableaux reasoners provided a
degree of match. Where request 2 is matched with service A (left), after 10
seconds the adaptive reasoner found a degree of match of almost 80% while
the standard reasoner had successfully matched conditions with weights that
added up to under 20%. This is because standard reasoners match attributes in
depth-first, arbitrary order. Therefore, it is often the case that attributes which
contribute greatly to the degree of match, are checked late in the process. Also
note while a cumulative result is shown for standard reasoners for illustrative
purposes only, standard reasoners cannot be stopped early.

The strategies presented in this paper are shown to effectively meet the fol-

lowing challenges:
1. match the most important request conditions first
2. handle heterogeneous inaccurate data by continuing to reason after a term

failed (if sufficient time).

3. handle time/resource pressures by supporting early stopping of the reasoner

and providing a current degree of inference to the user.

In this section we have clearly demonstrated that our adaptive reasoning approach provides a significant advantage over current reasoning strategies for
mobile users. Our approach effectively provides flexible reasoning to meet the
resource and time challenges which characterise mobile environments.
?

?

?
Degree of Match Comparison

0.8
0.6
0.4
0.2

h
c
t
a

f
o
e
e
r
g
e
?

?

?
Result: 
No Match

Standard Reasoning

Adaptive Reasoning:
Stop On Failure

Adaptive Reasoning:
Check All

Tests 1-8:  Degree of Match for Request: 1 to Service Advertisement: A, B, C, D, E, F, G, H, respectively

Fig. 3. Comparison of degree of match for standard (stop after any request condition fails) and adaptive reasoning (check all conditions), where Request 1 is compared
against 8 different potential services A-H see section 5.1

Adaptive Reasoning: Stop After Timeout Comparison

h
c
t
a

f
o
e
e
r
g
e

0.8

0.6

0.4

0.2

Stop After 10s

Stop After 20s

Stop After 30s

Tests 1-8:  Degree of Match for Request:1 to Service Advertisement: A, B, C, D, E, F, G, H, respectively

Fig. 4. Comparison of degree of match for adaptive reasoning after a timeout of 10,
20 and 30 seconds, where Request 1 is compared against 8 different potential services:
A-H see section 5.1

Degree of Match After Timeout Comparison

Request: 2 match Service: A

Request: 3 match Service: A

0.8
0.6
0.4
0.2

Did
Not
Com-
plete

Did
Not
Com-
plete

10s

20s

Did
Not
Com-
plete

Did
Not
Com-
plete
10s

Did
Not
Com-
plete
20s

30s
Stop Reasoning After x Second Timeout

40s

Adaptive
Reasoning

Standard
Reasoning

Did
Not
Com-
plete

30s

40s

Fig. 5. Comparison of degree of match for adaptive reasoning after a timeout of 10,
20, 30 and 40 seconds, for requests 2 (left) and 3 (right), matched against service
advertisement A

L.A. Steller, S. Krishnaswamy, and M.M. Gaber

Request: 2 match Service: A?

Request: 3 match Service: A?

Cumulative Degree of Match

5s 10s 15s 20s 25s 30s 35s 40s

5s 10s 15s 20s 25s 30s 35s

0.8
0.6
0.4
0.2

Adaptive
Reasoning
Standard
Reasoning

Fig. 6. Illustration of the cumulative degree of match for adaptive reasoning and
standard reasoning, where requests 2 (left) and 3 (right) are matched against service
advertisement A

6 Conclusion

We have presented a novel adaptive reasoning strategy which supports partial
matching, premature stopping and provides a degree of inference match, based on
those request conditions already checked. Our evaluations demonstrate that our
strategies effectively meet these goals, by matching the most important request
conditions first, to achieve the highest possible degree of match result within
the time available. This is a significantly more effective approach than current
approximate reasoning techniques which match request conditions arbitrarily
and completely before providing any results.
