A Conflict-Based Operator for Mapping Revision

Theory and Implementation

Guilin Qi1,2, Qiu Ji1, and Peter Haase1

1 Institute AIFB, University of Karlsruhe, Germany

{gqi,qiji,pha}@aifb.uni-karlsruhe.de

2 School of Computer Science and Engineering

Southeast University, Nanjing 210096

Abstract. Ontology matching is one of the key research topics in the
field of the Semantic Web. There are many matching systems that generate mappings between different ontologies either automatically or semi-
automatically. However, the mappings generated by these systems may
be inconsistent with the ontologies. Several approaches have been proposed to deal with the inconsistencies between mappings and ontologies.
This problem is often called a mapping revision problem, as the ontologies are assumed to be correct, whereas the mappings are repaired when
resolving the inconsistencies. In this paper, we first propose a conflictbased mapping revision operator and show that it can be characterized
by two logical postulates adapted from some existing postulates for belief base revision. We then provide an algorithm for iterative mapping
revision by using an ontology revision operator and show that this algorithm defines a conflict-based mapping revision operator. Three concrete
ontology revision operators are given to instantiate the iterative algo-
rithm, which result in three different mapping revision algorithms. We
implement these algorithms and provide some preliminary but interesting evaluation results.

1 Introduction

Next generation semantic applications are employed by a large number of on-
tologies, some of them constantly evolving. As the complexity of semantic applications increases, more and more knowledge is embedded in ontologies, typically
drawn from a wide variety of sources. This new generation of applications thus
likely relies on a set of distributed ontologies, typically connected by mappings.
One of the major challenges in managing these distributed and dynamic ontologies is to handle potential inconsistencies introduced by integrating multiple
distributed ontologies.

For inconsistency handling in single, centralized ontologies, several approaches
are known (see the survey in [7]). Recently, there are some works done on handling inconsistency in distributed ontologies connected by mappings, where a
mapping between two ontologies is a set of correspondences between entities
in the ontologies. In a distributed system consisting of two ontologies and a

 New affiliation since September 2009.

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 521536, 2009.
c Springer-Verlag Berlin Heidelberg 2009

G. Qi, Q. Ji, and P. Haase

mapping between them, correspondences in the mapping can have different in-
terpretations. For example, in Distributed Description Logics (DDL) [3], a correspondence in a mapping is translated into two bridge rules that describe the
flow of information from one ontology to another one. In [13], the authors deal
with the problem of mapping revision in DDL by removing some bridge rules
which are responsible for the inconsistency. The idea of their approach is similar
to that of the approaches for debugging and repairing terminologies in a single
ontology. Mappings can also be interpreted as sets of axioms in a description
logic. A heuristic method for mapping revision is given in [12]. However, this
method can only deal with inconsistency caused by disjointness axioms which
state that two concepts are disjoint. Later on, Meilicke et al. proposed another
algorithm to resolve the inconsistent mappings in [15]. The idea of their algorithm is similar to the linear base revision operator given in [16]. However, both
methods given in [12] and [15] lack a rationality analysis w.r.t. logical properties.
In this paper, we first propose a conflict-based mapping revision operator
based on the notion of a conflict set, which is a subset of the mapping that is
in conflict with ontologies in a distributed system. We then adapt two postulates
from belief revision theory [8] and show that our mapping revision operator can
be characterized by them (see Section 3). After that, in Section 4, we provide
an iterative algorithm for mapping revision by using a revision operator in description logics and show that this algorithm results in a conflict-based mapping
revision operator. We define a revision operator and show that the iterative algorithm based on it produces the same results as the algorithm given in [15].
This specific iterative algorithm has a polynomial time complexity if the satisfiability check of an ontology can be done in polynomial time in the size of the
ontology. However, this algorithm may still be inefficient for large ontologies and
mappings, because it requires a large number of satisfiability checks. Therefore,
we provide an algorithm to implement an alternative revision operator based
on the relevance-based selection function given in [11] which can be optimized
by a module extraction technique given in [22]. Neither of the above proposed
revision operators removes minimal number of correspondences to resolve in-
consistencies. To better fulfil the principle of minimal change, we consider the
revision operator given in [19] which utilizes a heuristics based on a scoring function which returns the number of minimal incoherence-preserving sub-ontologies
(MIPS) that an axiom belongs to. Instantiating our iterative algorithm with
this existing revision operator results in a new conflict-based mapping revision
operator. Finally, we implement these algorithms and provide evaluation results
for comparing their efficiency and effectiveness in Section 5.

Relationship with belief revision. This work is related to belief revision which
has been widely discussed in the literature [5,10]. Our conflict-based mapping
revision operator is inspired by the internal revision operator given in [8], and
the postulate used to characterize our mapping revision operator is adapted
from a postulate for internal revision operator given in [8]. The problem of
mapping revision is not exactly the same as the problem of belief base revision
because the mapping to be revised is dependent on ontologies in the distributed
?

?

?
system and each correspondence in the mapping carries a confidence value which
can be used to guide the revision. Our iterative algorithm is inspired by the
iterative revision algorithm given in [18] and is tailored to produce a conflictbased revision operator.

2 Preliminaries

We assume that the reader is familiar with Description Logics (DL) and refer
to Chapter 2 of the DL handbook [1] for a good introduction. Our method is
independent of a specific DL language, and thus can be applied to any DL.
A DL-based ontology (or knowledge base) O = (T ,R) consists of a set T of
concept axioms (TBox) and a set R of role axioms (RBox). In this paper, we treat
O as a set of axioms. Concept axioms (or terminology axioms) have the form
C  D, where C and D are (possibly complex) concept descriptions built from
a set of concept names and some constructors, and role axioms are expressions
of the form RS, where R and S are (possibly complex) role descriptions built
from a set of role names and some constructors.
,I) consists of a non-empty domain set I and an
interpretation function I, which maps from concepts and roles to subsets of the
domain and binary relations on the domain, respectively. Given an interpretation
I, we say that I satisfies a concept axiom C  D (resp., a role inclusion axiom
I). An interpretation I is called a model of
R  S) if C
an ontology O, iff it satisfies each axiom in O. A concept C in an ontology O is
unsatisfiable if for each model I of O, C
I = . An ontology O is incoherent if
there exists an unsatisfiable concept in O.

An interpretation I = (I

I (resp., R

I  S

ID
?

?

?
Given two ontologies O1 and O2, describing the same or largely overlapping

domains of interest, we can define correspondences between their elements.
Definition 1. [4] Let O1 and O2 be two ontologies, Q be a function that defines sets of mappable elements Q(O1) and Q(O2). A correspondence is a 4-tuple
e, e
  Q(O2), r is a semantic relation, and
, r,  such that e  Q(O1) and e
 is a confidence value from a suitable structure D,, such as a lattice. A
mapping M is a set of correspondences.
In Definition 1, there is no restriction on function Q, semantic relation r and
domain D. In the mapping revision scenario, we often consider correspondences
between concepts and restrict r to be one of the semantic relations from the
set {,,}, and let D = [0, 1]. A mapping is a set of correspondences whose
elements are mappable. The following definition is adapted from the definition
of a distributed system given in [23].
Definition 2. A distributed system is a triple D = O1, O2,M, where O1 and
O2 are ontologies and M is a mapping between them. We call O1 the source
ontology and O2 the target ontology.

Example 1. Take the two ontologies CRS and EKAW in the domain of conference
management systems as an example. They contain the following axioms:

G. Qi, Q. Ji, and P. Haase
?

?

?
.

crs : program  crs : document,
ekaw : Workshop Paper  ekaw : Paper

crs : article  crs : document,
ekaw : Paper  ekaw : Document,
ekaw : Conference Paper  ekaw : Paper, ekaw : PC Member  ekaw : Possible Reviewer,
The correspondences in the mapping M between O1 and O2 which is obtained
by the ontology matching system HMatch are listed as follows:
m1 : crs : article, ekaw : Conference Paper, , 0.65
m2 : ekaw : Workshop Paper, crs : article, , 0.65
m3 : ekaw : Document, crs : program,
, 0.80
, 0.80
m4 : crs : program, ekaw : Document,
m5 : crs : document, ekaw : Document,
, 0.93

, r, ) = CrC

Definition 3. [13] Let D = O1, O2,M be a distributed system. The union
O1 M O2 of O1 and O2 connected by M is defined as O1 M O2 = O1  O2 
{t(m) : m  M} with t being a translation function that converts a correspondence into an axiom in the following way: t(C, C
That is, we first translate all the correspondences in the mapping M into
DL axioms, then the union of the two ontologies connected by the mapping
is the set-union of the two ontologies and the translated axioms. Given D =
O1, O2,M, we use U nion(D) to denote O1 M O2. Take a correspondence in
Example 1 as an example, we have t(crs:article, ekaw:Conference Paper,, 0.65)
= crs:article  ekaw:Conference Paper.
Definition 4. [12] Given a mapping M between two ontologies O1 and O2, M
is consistent with O1 and O2 iff there exists no concept C in Oi with i  {1, 2}
such that C is satisfiable in Oi but unsatisfiable in O1 M O2. Otherwise, M
is inconsistent. A distributed system D = O1, O2,M is inconsistent if M is
inconsistent with O1 and O2.
An inconsistent mapping is a mapping such that there is a concept that is satisfiable in a mapped ontology but unsatisfiable in the union of the two ontologies
together with the mapping. In Example 1, since ekaw:Workshop Paper is satisfiable in both O1 and O2 but unsatisfiable in O1 M O2, M is inconsistent. Note
that O1  O2 must be coherent if both O1 and O2 are coherent because they use
different name spaces.
Definition 5. A mapping revision operator  is a function O1, O2,M =
O1, O2,M such that M  M, where O1 and O2 are two ontologies and
M is a mapping between them.
Our definition of a mapping revision operator is similar to the definition of
a revision function given in [14]. When repairing the mapping in a distributed
system, we assume that ontologies are more reliable than the mapping and therefore only remove correspondences in the mapping to restore consistency. This
makes the problem of mapping repair akin to the problem of belief revision.
Thus we call the problem of repairing mappings mapping revision. However,
this definition is very general and allows mapping revision operators that result in unintuitive results. That is, we can define two naive revision operators
?

?

?
F ullO1, O2,M = O1, O2, and N ullO1, O2,M = O1, O2,M. In belief
revision, the rationality of a revision operator is often evaluated by logical pos-
tulates. In this work, we will define a mapping revision operator and show that
it can be characterized by an important logical postulate.

3 A Conflict-Based Mapping Revision Operator

In this section, we propose a method for mapping revision based on the idea of
kernel contractions defined by Hansson in [9]. We adapt the notion of a minimal
conflict set of a distributed system given in [13] as follows.
Definition 6. Let O1, O2,M be a distributed system. A subset C of M is a conflict set for a concept A in Oi (i = 1, 2) if A is satisfiable in Oi but unsatisfiable
in O1 C O2. C is a minimal conflict set (MCS) for A in Oi if C is a conflict set
for A and there exists no C  C which is also a conflict set for A in Oi.
A minimal conflict set for a concept in one of the ontologies is a minimal subset
of the mapping that, together with the ontologies, is responsible for the unsatisfiability of the concept in the distributed system. It is similar to the notion of
a kernel in [9]. Note that if Oi (i = 1, 2) is incoherent, then it is meaningless to
define the notion of a MCS for an unsatisfiable concept. We use M CSO1,O2(M)
to denote the set of all the minimal conflict sets for all unsatisfiable concepts
in O1 C O2. It corresponds to the notion of a kernel set in [9]. In Example 1,
M CSCRS,EKAW (M) = {{t(m1), t(m3)},{t(m2), t(m3)},{t(m3), t(m5)},{t(m1),
t(m2), t(m3)},{t(m2), t(m3), t(m5)}}.

Hanssons kernel contraction removes formulas in a knowledge base through
an incision function, which is a function that selects formulas to be discarded.
However, we cannot apply the notion of an incision function to mapping revision
directly because the mapping to be revised is dependent on the ontologies in the
distributed system. Therefore, the problem of mapping revision is not exactly
the same as the problem of belief revision where the two knowledge bases may
come from different sources. Furthermore, each correspondence in the mapping
carries a confidence value which can be used to guide the revision. We use D and
M to denote the set of all the distributed systems and the set of all the subsets
of mappings in all distributed systems.
Definition 7. An incision function : D  M is a function such that for any
distributed system D = O1, O2,M, we have
(ii) if C =  and C  M CSO1,O2(M), then C  (D) = ;
(iii) if m = C, C

, r,   (D), then there exists C  M CSO1,O2(M) such that

(i) (D) 

(M CSO1,O2(M));
?

?

?
m  C and  = min{i : Ci, C
?

?

?
i, ri, i  C}.

The first two conditions say that an incision function selects from each kernel
set at least one element. The third condition says that if a correspondence is
selected by an incision function, then there must exist a MCS C such that its
?

?

?
confidence value is the minimal confidence value of correspondences in C. Going back to Example 1, the incision function  may select m1, m2 and m3 to
resolve inconsistency.

We define our mapping revision operator based on an incision function.

Definition 8. A mapping revision operator  is called a conflict-based mapping
revision operator if there exists an incision function  such that:
O1, O2,M = O1, O2,M \ (M CSO1,O2(M)).
?

?

?
, r,   M :  > }).

That is, we remove those correspondences in M that are selected by the incision function to restore consistency. We provide the representation theorem for
conflict-based mapping revision. Before that, we need to define the notion of an
inconsistency degree of a distributed system for a concept. Given a distributed
system D = O1, O2,M, a concept A in Oi (i = 1, 2) is unsatisfiable in D if A
is unsatisfiable in O1 M O2.
Definition 9. Given D = O1, O2,M, the -cut (resp. strict -cut) set of D,
denoted as D (resp. D>), is defined as D = O1, O2, {C, C
, r,   M :
  } (resp. D> = O1, O2,{C, C
The -cut set of D is a distributed system consisting of O1, O2 and correspondences in the mapping whose confidence values are greater than or equal to .
It is adapted from the notion of cut set in possibilistic DL in [20]. In Example 1,
D>0.65 = O1, O2,{t(m3), t(m4), t(m5)}.
Definition 10. Given D = O1, O2,M, the inconsistency degree of D for a
concept A in Oi (i = 1, 2), denoted by Inc(D)A, is defined as Inc(D)A =
max{ : A is unsatisfiable in D}. The inconsistency degree of D, denoted
as Inc(D), is defined as Inc(D) = max{ : there exists an unsatisfiable concept
in D}.
It is easy to check that Inc(D) = max{ : D is inconsistent}. In Example 1,
D0.93 is consistent but D0.8 is inconsistent since ekaw:Workshop Paper is un-
satisfiable. Thus, Inc(D) = 0.8.
?

?

?
We give a postulate for mapping revision by generalizing the postulate (Rele-
vance) for the internal partial meet revision operator given in [8]. It says that if
a correspondence is removed from the mapping after revision, then it must be in
a conflict set of the mapping for a concept and the confidence degree attached
to it is minimal among all the confidence degrees in the conflict set.
Postulate (Relevance). Suppose O1, O2,M = O1, O2,M, if m = C, C

r,   M and m  M, then there exists a concept A in Oi (i = 1, 2) and a
subset S of M such that A is satisfiable in O1, O2,S but is unsatisfiable in
O1, O2,S  {m} and Inc(O1, O2,S  {m})A = .

Relevance is an important postulate for minimal change. However, it does not
constrain the number of correspondences to be removed. Therefore, it does not
entail minimal change.

,
?

?

?
Algorithm 1. An iterative algorithm for mapping revision
Data: A distributed system D = O1, O2, M and a revision operator 
Result: A repaired distributed system D = O1, O2, M
begin

return D

if either O1 or O2 is incoherent then
Rearrange the weights in M such that 1>2>...>l > 0;
Si := {t(C, C
, r, M,  = i}, i = 1, ..., l;
while M in D is inconsistent do

, r, ) : C, C
?

?

?
if k = Inc(D) then
St := Sk \ (Sk  (Union(D)>k ));
, r,  : t(C, C
M := M \ {C, C
?

?

?
, r, )  St,  = k};

return D
?

?

?
end

We also need another postulate called Consistency.

Postulate (Consistency). For any D = O1, O2,M where Oi are coherent,
O1, O2,M is a consistent distributed system.

The following theorem shows that our conflict-based mapping revision operator can be characterized by the postulates (Relevance) and (Consistency).
Theorem 1. The operator  is a conflict-based mapping revision operator if and
only if it satisfies (Relevance) and (Consistency).
To show the if direction of the theorem, we can construct (D) = M \ M for
D = O1, O2,M and (D) = O1, O2,M, then show that  is an incision func-
tion. Unlike revision operators given in [8], our conflict-based mapping revision
operator is characterized by only two postulates. This is because the definition
of a conflict already gives some constraints on how we can repair a mapping.
According to Definition 5, ontologies in the distributed systems are not changed
and revised mapping must be a subset of the original one. These two conditions
correspond to (Success) and (Inclusion) for revision operators given in [8].

4 An Algorithm for Mapping Revision

In this section, we give an algorithm for mapping revision based on an ontology
revision operator and then present some concrete ontology revision operators.

4.1 Algorithm

We describe the idea of our algorithm (Algorithm 1) as follows. Given a distributed system D = O1, O2,M, if either O1 or O2 is incoherent, then we
take D as the result of revision. That is, no change is needed. Suppose M =
i, ri, i : i = 1, ..., n} where n is the number of correspondences in M. Let
{Ci, C

us rearrange the weights of axioms (i.e., i) in M such that 1>2>...>l > 0,
where i (i = 1, ..., l) are all the distinct weights appearing in M. For each i 
{1, ..., l}, Si consists of translated axioms of correspondences in M which have
the confidence value i. Suppose Inc(D) = k. We revise Sk by U nion(D>k).

G. Qi, Q. Ji, and P. Haase

Suppose St is the set of axioms in Sk that are removed after revision of Sk by
U nion(D>k) using the operator !. We then remove the correspondences in M
that have confidence values k and are mapped to axioms in St by the translation
function t. We iterate the revision process until the mapping becomes consistent.
In Algorithm 1, we need to compute the inconsistency degree of a distributed
system. This can be easily done by adapting the algorithm for computing the
inconsistency degree in [20] so we do not bother to provide it here.

We have not specified a revision operator in Algorithm 1. However, we require
that the revision operator ! used in the algorithm satisfy the following properties
which are similar to the postulates Inclusion, Success and Core-retainment for
kernel revision operator given in [9]:

  O  O

;

 Inclusion: O ! O
 Success: O
 Core-retainment: if   O and   O ! O

  O ! O

;

 and a subset Os of O, such that A is satisfiable in Os  O

, then there exist a concept A in
 but is

O  O
unsatisfiable in Os  O

  {}.

It is clear that Algorithm 1 generates a mapping revision operator. We show
that this operator is a conflict-based mapping revision operator.
Theorem 2. Suppose ! satisfies Inclusion, Success and Core-retainment, and
 is a mapping revision operator such that, for any distributed system D, (D) is
the result of Algorithm 1 with ! as an input parameter, then  is a conflict-based
mapping revision operator.

4.2 Concrete Revision Operators

 = O



We first give a simple revision operator which is adapted from the linear base
revision operator given in [16]. By SORT we denote a procedure that for each
ontology O = {1, ..., n}, randomly ranks its elements as an ordered sequence
 be two ontologies, and let SORT(O) = {1, ..., n}, the
(1, ..., n). Let O and O
random linear base revision operator, denoted as linear, is defined inductively
as follows O linear O
  S1  ...  Sn, where Si is defined by Si = {i} if
{i}O
j=1 Sj is coherent,  otherwise, for i  1. It is easy to check that this
i1
revision operator satisfies conditions Inclusion, Success and Core-retainment. We
show that the algorithm given in [15] is a special case of our iterative algorithm
where the operator linear is chosen.
Proposition 1. For any distributed system D = O1, O2,M where O1 and
O2 are coherent, suppose Dlinear is the result of revision by Algorithm 1, then
Dlinear can be obtained by the algorithm given in [15] as well.
As shown in [15], their algorithm only needs at most n satisfiability check, where
n is the number of correspondences. Therefore, our iterative algorithm based on
the revision operator linear has a polynomial time complexity if the satisfiability
check can be done in polynomial time in the size of union of ontologies and the
mapping. However, this algorithm requires to rank correspondences with the
same confidence value and there is no good principle to guide this ranking.
?

?

?
Table 1. Relevance-based mapping revision algorithm
?

?

?
)

CONF(C, O, O

Input: Two ontologies O and O
, and an
unsatisfiable concept C of O  O

Output: A hitting set hs in O for C w.r.t. O
(1) hs   ;
(2) while((O \ hs)  O
J  SINGLE CONFLICT(C, O \ hs, O
(3)
J  J  {J}
(4)
hs = hs  {} for some   J;
(5)
(6) }
(7) return hs;

 |= C  ){

);
?

?

?
);

REL REVISION(O, O
Input: Two ontologies O and O

)
?

?

?
, C);

)){

Output: A revised ontology O  O
(1) Global : J  ;
(2) HS  ;
(3) for(C  AllUnsatConcepts(O  O
k  1;
(4)
Ot  hs  ;
(5)
, C) = ){
while(sk(O  O
(6)
Ot  Ot  sk(O  O

(7)
if(hs = ){
(8)
if((O \ hs)  O
(9)
(10)
hs  CONF(C, Ot  (O \ hs), Ot  O
(11)
HS  HS  hs;
(12)
(13)
hs  CONF(C, Ot  O, Ot  O
(14)
HS  HS  hs;
(15)
(16)
(17)
(18)
(19) } (end for)
(20) return (O \ HS)  O

}
k  k + 1;
} (end while)

}else if(Ot |= C  ){

 |= C  )

break;

);
?

?

?
;

Furthermore, if the size of the union of ontologies and the mapping is big, then
the algorithm may still be inefficient because it will need a large number of
satisfiability checks over the union.

In the following, we present an algorithm REL REVISION (see Table 1) to
implement another concrete revision operator based on the relevance-based selection function. The motivation behind the algorithm is that when choosing between two correspondences to remove, we always remove the one which is more
relevant to an unsatisfiable concept and thus is more likely to be problematic.

Given two axioms  and ,  is directly relevant to  iff there is an overlap
between the signature of  and the signature of , where the signature of an
axiom is the set of all concept names, role names and individual names appearing
in it. Based on the notion of direct relevance, we can extend it to relevance
relation between an axiom and an ontology. An axiom  is relevant to an ontology
O iff there exists an axiom  in O such that  and  are directly relevant. We
introduce a selection function defined in [11].

Definition 11. [11] Let O be an ontology,  be an axiom and k be an integer. The
relevance-based selection function, written srel, is defined inductively as follows:
srel(O, , 0) = 
srel(O, , 1) = {  O :  is directly relevant to }
srel(O, , k) = {  O :  is directly relevant to srel(O, , k  1)}, where k > 1.
We call srel(O, , k) the k-relevant subset of O w.r.t. . For convenience, we
define sk(O, ) = srel(O, , k) \ srel(O, , k  1) for k  1.
Our algorithm REL REVISION is based on Reiters Hitting Set Tree (HST) algorithm [21]. Given a universal set U, and a set K = {s1, ..., sn} of subsets of

G. Qi, Q. Ji, and P. Haase

U which are conflict sets, i.e. subsets of the system components responsible for
the error, a hitting set T for K is a subset of U such that si  T =  for all
1  i  n. To adapt HST algorithm to deal with revision of ontologies in DLs,
we define the notion of a minimal conflict set of an ontology O for a concept C
. A subset Os of O is called a minimal conflict set of
w.r.t. another ontology O
 and (2) for any Ot  Os,
O for C w.r.t. O
C is satisfiable in Ot  O
. A more general definition of a minimal conflict set is
given in [2], where it is called a minimal axiom set.

, if (1) C is unsatisfiable in Os  O

)\srel(OO
?

?

?
, C) = , we still have (O \ HS)  O

, C) = (OO

In REL REVISION, we handle unsatisfiable concepts in the union of the mapped
ontologies and the ontology translated from the mapping one by one until we
resolve the inconsistency. For each unsatisfiable concept to be handled, we first
select axioms that are relevant to it iteratively by the relevance-based selection function until the concept is unsatisfiable in these axioms. sk(O, C) is
the abbreviation of sk(O, C  ). We find a hitting set for the selected subontologies by calling the procedure CONF and update the existing incomplete
hitting set HS. We then add to the selected sub-ontologies those axioms that
are directly relevant to them and further expand the hitting set tree by calling to procedure CONF. We continue this process until the inconsistency is
resolved. The procedure SINGLE CONFLICT computes a minimal conflict set
. This kind of procedure can be found in the literature,
of O for C w.r.t. O
such as GETMUPS in [19]. It is possible that some axioms that are involved
in a conflict set are not selected by the selection function. Therefore, when
sk(O  O
|= C  , then we set
sk(OO
, C  , k1). Note that our algorithm may

not remove minimal number of correspondences to resolve inconsistency because
we only expand one branch of the hitting set tree in a depth-first manner. This is
compensated by higher efficiency. Furthermore, although our algorithm does not
remove minimal number of correspondences, the removals of correspondences are
guided by a relevance-based selection function to improve the quality of removal.
It is easy to see that the revision operator obtained by REL REVISION satisfies
conditions Inclusion, Success and Core-retainment.
, we need to
. The time complexity
compute some minimal conflict sets of O for C w.r.t. O
of REL REVISION depends on the DL under consideration. In the worst case,
i.e., all the minimal conflict sets of all the unsatisfiable concepts are disjoint, our
algorithm needs to compute all the minimal conflict sets for all the unsatisfiable
concepts, which is a hard task [17]. For instance, the number of all the minimal conflict sets for an unsatisfiable concept is exponential in the worst case for
lightweight ontology language EL+ [2]. However, the average case complexity
will be considerably lower: For many real ontologies, the number of all minimal
conflict sets for an unsatisfiable concept is much less than the size of the ontol-
ogy. Our algorithm usually does not compute all the minimal conflict sets for
an unsatisfiable concept. Another complexity of our algorithm comes from the
computation of a minimal conflict set, which is as hard as satisfiability checking
of the underlying DL. Despite the high complexity of our algorithm, fortunately,

In REL REVISION, to resolve an unsatisfiable concept C in O O
?

?

?
there is an optimization technique to improve its efficiency. That is, for each unsatisfiable concept to be handled, we extract a so-called syntactic locality-based
module [6] from O  O
 which contains all the minimal conflict sets of O for C
. The module extraction step can be added between line 6 and line 7
w.r.t. O
in REL REVISION. The correctness of our modified algorithm is ensured by the
fact that the locality-based module contains all the minimal sub-ontologies of an
ontology that are responsible for unsatisfiability of a concept shown in in [22].
Example 2. To illustrate our iterative algorithm (i.e. Algorithm 1) based on
REL REVISION, we follow Example 1. First of all, we need to reorder all distinct
confidence values in a descending order 1 = 0.93 > 2 = 0.8 > 3 = 0.65
and the corresponding layers of correspondence axioms are S1 = {t(m5)}, S2 =
{t(m3), t(m4)} and S3 = {t(m1), t(m2)} respectively. Then, we go into line 6
since M is inconsistent. We obtain the inconsistency degree of D as 0.8. So
k = 2. As we know that 2 = 0.8, we use U nion(D>0.8) to revise S2 and the
revision result is (S2\{t(m3)}) U nion(D>0.8) according to REL REVISION (see
Illustration of REL REVISION below). Therefore, we remove m3 from M (see
line 9). Then we go to another iteration of the while loop. Since the modified M
becomes consistent when m3 is removed from it, the whole process of Algorithm 1
can be terminated and the result is D = O1, O2,M \ {m3}.
 = U nion(D>0.8).
Illustration of REL REVISION: The input is O = S2 and O
Suppose the first found unsatisfiable concept is article. We keep on selecting
the k-relevant axioms in O  O
 w.r.t. the concept article until Ot = O  O

(i.e. article becomes unsatisfiable in Ot). Then we go to line 14 and get the
minimal conflict set {t(m3)} of O w.r.t. O
 and a hitting set hs = {t(m3)} (see
Illustration of CONF below). So HS = {t(m3)}. After this, we go to another
iteration of the while loop. Since all the axioms in O have been selected, we can
terminate the process and return (S2 \ {t(m3)})  U nion(D>0.8).
 = U nion(D>0.8)
Illustration of CONF: The input is C = article, O = S2 and O
for CONF. First of all, we compute a MCS J = {t(m3)} in line 3. Since only
one axiom in J, we get hs = {t(m3)} in line 5. We return {t(m3)} and update
J = {t(m3)}.

Neither of the above proposed revision operators removes minimal number
of correspondences to resolve inconsistencies. To better fulfil minimal change,
we consider the revision operator given in Algorithm 1 in [19] which utilizes a
heuristics based on a scoring function which computes the number of minimal
incoherence-preserving sub-ontologies (MIPS) that an axiom belongs to. It is
not difficult to check that this revision operator satisfies conditions Inclusion,
Success and Core-retainment. A MIPS of ontology O w.r.t. another ontology
. Instantiating our
 is a minimal sub-ontology of O that is incoherent with O

iterative algorithm with this operator results in a new conflict-based mapping
revision operator. The disadvantage of this revision operator is that it needs to
all the MIPSs obtained from all the minimal conflict sets of O for any concept
 by using a modified hitting set tree algorithm, thus its computational
w.r.t. O
complexity is at least harder than those of previous revision operators.

G. Qi, Q. Ji, and P. Haase

5 Experimental Evaluation
In this section, we present the evaluation results of our algorithms by comparing them with existing algorithms. Our algorithms were implemented with the
KAON2 API1, using KAON2 as a black box reasoner. To fairly compare with the
mapping repair algorithms in [13] and [15], we re-implemented them using the
KAON2 API. More precisely, the following algorithms have been evaluated:

 Weight-based-One: Compute one minimal conflict subset each time and

remove an element in it with lowest weights (see [13]).

 Linear: Our iterative algorithm based on the random linear base revision

operator (it is equivalent to the algorithm given in [15]).

 Weight-based-All: Compute all minimal conflict subsets for an unsatisfiable
concept and then resolve the unsatisfiability based on weights (see Algorithm
3 in [19]).

 Relevance-based: Our iterative algorithm based on the revision operator

REL REVISION defined in Table 1.

 Score-based: Our iterative algorithm based on the revision operator defined

by Algorithm 1 in [19].

All of the experiments were performed on a Linux server with an Intel(R) CPU
Xeon(TM) 3.2GHz running Suns Java 1.5.0 with allotted 2GB heap space. Our
system2 including the implementation of the five algorithms can be downloaded,
together with all the data sets and results.

5.1 Data Sets

We use the ontology matching data sets available in OAEI083 (Ontology Alignment Evaluation Initiative), which provides a platform for evaluating ontology
matching systems. For our experiments, the following individual ontologies in
the domain of scientific conferences are used: confOf with 197 axioms, ekaw with
248 axioms and cmt with 246 axioms. The pairwise mappings have been generated by the matching systems participating in OAEI.4 For simplicity, we use,
for example, confOf-ekaw-DSSim to indicate a distributed system consisting of
individual ontologies confOf and ekaw and a mapping between them which is
generated by system DSSim.

5.2 Evaluation Results

We evaluated our algorithms with respect to the following measures: efficiency,
scalability and correctness.
Efficiency and Scalability. To measure efficiency and scalability of the algorithms,
we considered revision time, which includes the time used to check whether a

http://kaon2.semanticweb.org/
http://radon.ontoware.org/downloads/mapping-revision-09.zip
http://oaei.ontologymatching.org/2008/

4 In addition, we use FOAM (http://ontoware.org/projects/map/) to generate map-

pings by applying only some simple string-based algorithms.
?

?

?
)
s
d
n
o
c
e
s
(
 

i

 

e
m

e
s
n
o
p
s
e

confOf-ekaw-DDSim

cmt-ekaw-FOAM

Data Sets

)
s
d
n
o
c
e
s
(
 
e
m

e
s
n
o
p
s
e

i

# New_Corre-
pondences
# New_Axioms

Weight-based-One
Relevance-based

Linear
Score-based

Weight-based-All

Weight-based-One
Relevance-based

Linear
Score-based

Weight-based-All

Fig. 1. The revision time of the algorithms

mapping is inconsistent and the time used to resolve inconsistencies. If a module
extraction algorithm was applied, the time used to extract modules was also in-
cluded. To test the efficiency of an algorithm, we continuously ran it for 30 times
and took the average revision time. We have done the experiment based on the
distributed systems D1 :confOf-ekaw-DSSim and D2 :cmt-ekaw-FOAM.
The left part of Figure 1 shows the average revision time over all runs for
each algorithm. From this part we can see that for D1 and D2 which contain relatively small size of ontologies (i.e. no more than 250 axioms for each individual
ontology) with mappings consisting of few correspondences (e.g. 19 and 55 correspondences for the mappings in D1 and D2 separately), Linear outperforms all
the others. The second observation is that our Relevance-based outperforms all
the others except Linear. It is because we expand only one branch of the hitting
set tree in a depth-first manner and we apply the module extraction to optimize
expanding the hitting set tree. Score-based has the worst performance for D1
but performs better for D2. This is because all correspondences in the mapping
of D1 have the same weights so Score-based needs to compute all the minimal
conflict sets for all unsatisfiable concepts in D1, whilst the correspondences in
the mapping of D2 can be stratified by their weights so we only need to compute
some minimal conflict sets. Another observation is that Weight-based-All does
not perform well for D2 since it needs to compute all the minimal conflict sets
for an unsatisfiable concept in each iteration.
In the right part, we show the scalability of the algorithms using the extended
data sets based on D3 :cmt-ekaw-Lily. This experiment is used to show that Linear may perform worse than some other algorithms if there are many axioms and
correspondences that are not involved in the conflict sets. Here #New Axioms
means the number of axioms which are newly added to each individual on-
tology. #New Correspondences indicates the number of newly added correspon-
dences. Take the first column in the right part of Figure 1 as an example, we
added 1000 dummy axioms to cmt and ekaw respectively and 100 dummy correspondences between the newly introduced concepts. Similarly we constructed
other data sets by adding more axioms and correspondences. According to the
right part of Figure 1, when adding more axioms and correspondences to D3,
Weight-based-one and Linear perform worse and worse. In contrast, the other three
algorithms are optimized by applying the module extraction technique and thus
gain the advantage over Weight-based-one and Linear in the scalability test.

G. Qi, Q. Ji, and P. Haase

Table 2. Correctness of the algorithms

Distributed Algorithm
Systems
confOf
ekaw
DSSim

Weight-based-One
Linear
Weight-based-All
Relevance-based
Score-based
Weight-based-One
Linear
Weight-based-All
Relevance-based
Score-based

cmt
ekaw

Repair precision

Repair recall

Max(P ri) Avg(P ri) Min(P ri) Max(Rri) Avg(Rri) Min(Rri)

1.00
1.00
1.00
0.89
0.86
1.00
1.00
1.00
1.00
1.00

0.73
0.75
0.81
0.72
0.86
0.96
0.97
1.00
0.98
1.00

0.55
0.50
0.56
0.50
0.86
0.94
0.93
1.00
0.93
1.00

0.89
0.78
0.78
0.89
0.67
0.66
0.56
0.70
0.58
0.56

0.71
0.67
0.71
0.72
0.67
0.62
0.56
0.66
0.56
0.56

0.56
0.56
0.56
0.56
0.67
0.60
0.56
0.64
0.56
0.56

Correctness. In order to measure the correctness of the algorithms, we adopted
the definitions of repair precision Pr and repair recall Rr in [13]. Assume M
is a mapping between two ontologies and G is the reference mapping which
is created manually by domain experts. Then M = M  G indicates those
correspondences in M which are not correct. The repair precision and repair
recall are defined as follows:

Repair precision : Pr = removed correspondences in M
Rr = removed correspondences in M
Repair recall :

all removed correspondences

|M|

This experiment is again based on D1 and D2, and we continuously ran each
algorithm 30 times. For each run i (i=1,...,30), we compute the repair precision
Pri and recall Rri. Table 2 shows the maximal, minimal and average repair
precision and recall from all runs for each algorithm.

According to Table 2, we can see that Score-based has the highest repair precision and lowest repair recall in most cases. This shows that this algorithm best
fulfils the principle of minimal change. On the other hand, since Score-based
removes less correspondences, it may fail to remove some erroneous correspon-
dences. We also noticed that Weight-based-All performs slightly better than all
the others except Score-based w.r.t. both average repair precision and the average repair recall. For example, Weight-based-All reaches higher average precision
(i.e. 0.81) and recall (i.e. 0.71) for D1 and the highest average repair precision
(i.e. 1) and recall (i.e. 0.66) for D2. This shows that this algorithm removes more
correspondences which are incorrect comparing with the results from other algorithms in most cases.

6 Conclusion and Discussion

In this paper, we discussed the problem of repairing inconsistent mappings in the
distributed systems. We first defined a conflict-based mapping revision operator
and provided a representation theorem for it. We then presented an iterative algorithm for mapping revision in a distributed system based on a revision operator
in DLs and showed that this algorithm results in a conflict-based mapping revision operator. We showed that the algorithm given in [15], which we call Linear,
can be encoded as a special iterative algorithm. We also provided an algorithm
?

?

?
to implement an alternative revision operator based on the relevance-based selection function given in [11] which can be optimized by a module extraction
technique and considered a revision operator based on a scoring function in
[19]. All three specific iterative algorithms have been implemented. We compared these algorithms with two other existing algorithms for mapping revision
in [13] and [19]. Although our experimental results are preliminary and do not
tend to be conclusive, we can still make some interesting observations:

 For most of the tests, our iterative algorithms (where Linear is equivalent
to the algorithm given in [15]) performed well compared with two existing
mapping revision algorithms. It is interesting to see that Linear performed
quite well for all the real life data, although it performed much worse than
other iterative algorithms for the scalability test.

 The iterative algorithm Score-based showed its advantage over other algorithms w.r.t. minimal change and it produced the most stable results. How-
ever, it did not perform so well for the efficiency test.

 Our iterative algorithm Relevance-based was in a good position for the correctness test. It outperformed other algorithms except Linear w.r.t efficiency
and had good performance on scalability test. Thus it is a good choice to
revise inconsistent mappings in those distributed systems with large scale
mappings and ontologies.

 Weight-based-One performed worst for the scalability test and it does not
perform well for other tests, so we suggest that it can be replaced by Linear.
 We also noticed Weight-based-All had good performance for the correctness
test, although it did not perform so well for the efficiency test. So it is a
good alternative to the iterative algorithms.

In the future work, we could further optimize our iterative algorithms Relevancebased and Score-based. For example, since the module extraction algorithm used
to optimize our algorithms is independent on the super-concept of a subsumption
entailment and thus may result in a large module, we will consider a goal-directed
module extraction method that can produce a smaller module than the syntactic
locality-based module. For Relevance-based, we used the relevance-based selection function in this paper because it can be applied to any DL and is the basis
of some other selection functions. This selection function may select too many
axioms in each iteration. Other selection functions will be considered.

Acknowledgments
Research reported in this paper was partially supported by the EU in the IST
project NeOn (IST-2006-027595, http://www.neon-project.org/). We would
like to thank the anonymous reviewers as well as Richard Booth and Renata
Wassermann for their helpful comments.
