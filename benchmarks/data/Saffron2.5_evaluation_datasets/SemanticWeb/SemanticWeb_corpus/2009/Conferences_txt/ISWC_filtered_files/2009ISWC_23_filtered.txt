Queries to Hybrid MKNF Knowledge Bases

through Oracular Tabling

Jos e J ulio Alferes, Matthias Knorr, and Terrance Swift

CENTRIA, Dep. Inform atica, Faculdade de Ciencias e Tecnologia

Univ. Nova de Lisboa, 2825-516 Caparica, Portugal

Abstract. An important issue for the Semantic Web is how to combine
open-world ontology languages with closed-world (non-monotonic) rule
paradigms. Several proposals for hybrid languages allow concepts to be
simultaneously defined by an ontology and rules, where rules may refer to
concepts in the ontology and the ontology may also refer to predicates defined by the rules. Hybrid MKNF knowledge bases are one such proposal,
for which both a stable and a well-founded semantics have been defined.
The definition of Hybrid MKNF knowledge bases is parametric on the
ontology language, in the sense that non-monotonic rules can extend any
decidable ontology language. In this paper we define a query-driven procedure for Hybrid MKNF knowledge bases that is sound with respect to
the original stable model-based semantics, and is correct with respect to
the well-founded semantics. This procedure is able to answer conjunctive
queries, and is parametric on an inference engine for reasoning in the ontology language. Our procedure is based on an extension of a tabled rule
evaluation to capture reasoning within an ontology by modeling it as
an interaction with an external oracle and, with some assumptions on
the complexity of the oracle compared to the complexity of the ontology
language, maintains the data complexity of the well-founded semantics
for hybrid MKNF knowledge bases.

1 Introduction

Ontologies and Rules offer distinctive strengths for the representation and transmission of knowledge in the Semantic Web. Ontologies offer the deductive advantages of first-order logics with an open domain while guaranteeing decidability.
Rules offer non-monotonic (closed-world) reasoning that can be useful for formalizing scenarios under (local) incomplete knowledge; they also offer the ability
to reason about fixed points (e.g. reachability) which cannot be expressed within
first-order logic. Interest in both and their combination is demonstrated by the
pervasive interest in Ontology languages for the Semantic Web and the growing
interest on Rule languages for the Semantic Web, cf. the RIF and the RuleML
initiatives.

The two most common semantics for rules are the well-founded semantics
(WFS) [19] and the answer-sets semantics [6]. Both semantics are widely used;
both offer closed-world reasoning and allow the representation of fixed points;

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 116, 2009.
c Springer-Verlag Berlin Heidelberg 2009

J.J. Alferes, M. Knorr, and T. Swift

furthermore the relationship between the two semantics has been fully explored.
Of the two, the well-founded semantics is weaker (in the sense that it is more
skeptical), but has the advantage that its lower complexity allows it to be integrated into the general-purpose programming language Prolog. Thus in addition
to its features for knowledge representation, WFS rules can provide a reactive
or procedural component missing from ontologies. Several formalisms have concerned themselves with combining decidable ontologies with WFS rules [3,5,9].
Among these, the Well-Founded Semantics for Hybrid MKNF knowledge bases
(MKNFW F S), introduced in [9] and overviewed in Section 2 below, is the only one
which allows knowledge about instances to be fully inter-definable between rules
and an ontology that is taken as a parameter of the formalism. Using this parameterized ontology, MKNFW F S is defined using a monotonic fixpoint operator
that computes in each iteration step, besides the usual immediate consequences
from rules, the set of all atoms derivable from the ontology whose ABox is augmented with the already proven atomic knowledge. The least fixpoint of the
MKNFW F S operator coincides with the original WFS [19] if the DL-component
is empty, and when dealing with tractable description logics MKNFW F S retains
a tractable data complexity. Furthermore, MKNFW F S is sound wrt. to that of
[12] for MKNF knowledge bases, which is based on answer-set semantics and
coincides with the answer-sets semantics if the DL-part is empty.

In one sense, the fixpoint operator of MKNFW F S provides a way to compute,
in a naive bottom-up fashion, all consequences of a knowledge base. However,
such an approach is far from practical for large knowledge bases, as in the Semantic Web context. As a concrete example, consider a medical knowledge base
about patients in a large research study. Such a knowledge base might use a
standard OWL-ontology representing pathologies, treatment procedures, phar-
maceuticals, and so on (e.g. http://www.mindswap.org/2003/CancerOntology).
At the same time rules may be used to represent complex temporal constraints
that a research study imposes on a given patient, to interface with a patients
electronic health record, and even to extend the ontology with local procedures
or policies. To be practical this requires efficient techniques to answer queries
about patients, health-care workers, and other objects of interest.
This paper presents a querying mechanism, called SLG(O), that is sound
and complete for MKNFW F S, and sound for MKNF knowledge bases of [12].
SLG(O) accepts DL-safe conjunctive queries, (i.e. conjunctions of predicates
with variables where queries have to be ground when processed in the ontology),
returning all correct answer substitutions for variables in the query. To the best
of our knowledge, this is the first query-driven, top-down like, procedure for
knowledge bases that tightly combine an ontology with non-monotonic rules.

The Gist of the Approach

The main element of our approach addresses the interdependency of the ontology
and rules. In particular, our program evaluation method SLG(O), presented in
Section 4, extends SLG resolution [2], which evaluates queries to normal logic
programs (i.e. sets of non-disjunctive non-monotonic rules) under WFS. SLG
?

?

?
is a form of tabled resolution that handles loops within the program, and does
not change the data complexity of WFS. It does that by resorting to already
computed results, in a forest of derivation trees, a technique also known as
tabling. To adjoin an ontology to rules, the first thing that needs to be done is to
allow an SLG evaluation to make calls to an inference engine for the ontology.
Since MKNF is parametric on any given decidable ontology formalism1, the
inference engine is viewed in SLG as an oracle. In fact, every time SLG selects
an atom that is (perhaps jointly) defined in the ontology, the oracles inference
engine must be called, in case the atom is not provable by the rules alone. Such a
queried atom, say P (a), might thus be provable but only if a certain set of atoms
in turn is provable via rules. Our approach captures this by allowing the oracle
to return a new program clause, say P (a) :- Goals, which has the property that
(possibly empty) Goals, in addition to the axioms in the ontology and the atoms
already proven by the program would be sufficient to prove P (a). SLG(O) then
treats these new clauses just as if they were program clauses. Note that, getting
these conditional answers does not endanger decidability (or tractability, if it
is the case) of reasoning in the ontology alone. In fact, it is easy to conceive
a modification of a tableaux based inference engine for an ontology, that is
capable of returning these conditional answers and is decidable if the tableaux
algorithm is: add all those atoms that are defined in the program to the ABox;
then proceed with the tableaux as usual, but collect all those added facts that
have been used in the proof. Under some assumptions on the complexity of the
oracle, it is shown (in Section 5 along with some other properties) that SLG(O)
also retains tractability.

The other element of our approach arises from the need to combine the classical negation of an ontology with the non-monotonic negation of rules. This
problem is similar to the issue of coherence that arises when adding strong negation to logic programs [6,13,14]: the strong (or classical) negation must imply
negation by default. In our case, if the ontology entails that some atom A is
false, then perforce the default negation not A must hold in the program. The
derivation must accordingly be modified since the proof of not A cannot simply
rely on the failure of the proof of A as it is usual in logic programming. For sim-
plicity, instead of modifying SLG(O), our proposal (in Section 3) transforms the
original knowledge base K to ensure coherence. SLG(O) is then applied to the
transformed K. This transformation itself provides an alternative formulation of
MKNFW F S and is another original result of the paper.

2 Preliminaries

2.1 Syntax of Hybrid MKNF Knowledge Bases
We presume a basic understanding of the well-founded semantics [19] and firstorder logics, in particular notions related to logic programming and resolution
1 The limitation to decidability is theoretically not strictly necessary but a choice to
achieve termination and complexity results in accordance with the decidable ontology
languages like OWL (http://www.w3.org/2004/OWL/).

J.J. Alferes, M. Knorr, and T. Swift

(see e.g. [11]). Hybrid MKNF knowledge bases as introduced in [12] are essentially formulas in the logics of minimal knowledge and negation as failure
(MKNF) [10], i.e. first-order logics with equality and two modal operators K
and not allowing inspection of the knowledge base: intuitively, given a first-order
formula , K asks whether  is known while not is used to check whether
 is not known. Hybrid MKNF knowledge bases consist of two components, a
decidable description logics (DL) knowledge base2, translatable into first-order
logics, and a finite set of rules.
Definition 1. Let O be a DL knowledge base built over a language L with distinguished sets of countably infinitely many variables NV , and finitely many individuals NI, and predicates NC. An atom P (t1, . . . , tn) where P  NC and
ti  NV  NI is called a DL-atom if P occurs in O, otherwise it is called non-
DL-atom. An MKNF rule r has the following form where Hi, Ai, and Bi are
atoms: KH  KA1, . . . , KAn, notB1, . . . , notBm. H is called the (rule) head
and the sets {KAi}, and {notBj} form the (rule) body. Literals3 are positive
literals KA or negative literals notA. A rule r is positive if m = 0 and a fact
if n = m = 0. A program P is a finite set of MKNF rules and a hybrid MKNF
knowledge base K is a pair (O,P).

We will usually omit the modal operators K in the rule head and the positive
body, though they remain implicit however. Furthermore, we sometimes also
omit the terms ti of an atom as well (in the context of description logics).

For decidability DL-safety is applied which basically constrains the use of rules
to individuals actually appearing in the knowledge base under consideration.
Formally, an MKNF rule r is DL-safe if every variable in r occurs in at least
one non-DL-atom KB occurring in the body of r. A hybrid MKNF knowledge
base K is DL-safe if all its rules are DL-safe4. Likewise, to ensure decidability,
grounding the knowledge base, i.e. its rules, is restricted to individuals appearing
in the knowledge base and not to the whole infinite domain5. Therefore, given
a hybrid MKNF knowledge base K = (O,P), the ground instantiation of K is
the KB KG = (O,PG) where PG is obtained from P by replacing each rule r
of P with a set of rules substituting each variable in r with constants from K
in all possible ways (for more details we refer to [12] and [9]). DL-safety is also
imposed on (conjunctive) queries:

Definition 2. A conjunctive query q is a non-empty set, i.e. conjunction, of
literals where each variable in q occurs in at least one non-DL atom in q. We
also write q as a rule q(Xi)  A1, . . . , An, notB1, . . . , notBm where Xi is the
(possibly empty) set of variables, appearing in the body, which are requested.

2 For a thorough introduction on description logics we refer to [1].
3 In [9], the term modal atom is used and modal atoms in MKNF are in general not
restricted to first-order atoms but in this paper it is essentially their only appearance.

4 In the following all hybrid MKNF knowledge bases are assumed to be DL-safe.
5 As well-known, description logics semantics usually require an infinite domain to

admit the intended semantics for statements involving unknown individuals.
?

?

?
The restriction of conjunctive queries to DL-safety is not always necessary: for
DLs like SHIQ conjunctive query answering is possible ([7]) and we may also
make use of such existing algorithms, however, when there is no algorithm for
conjunctive query answering yet or it is even not decidable (like for EL++ [15])
then the limitation is required to achieve decidability in the combined approach.

2.2 Well-Founded Semantics of Hybrid MKNF Knowledge Bases

The well-founded MKNF semantics as presented in [9] is based on a complete
three-valued extension of the original MKNF semantics. However, here we are
not interested in obtaining the entire semantics where a model consists of two
sets of sets of first-order interpretations. Instead we limit ourselves here to the
computation of what is called the well-founded partition in [9]: basically the
literals which are true and false. For that reason, and in correspondence to logic
programming, we will name this partition the well-founded model. At first, we
recall some notions from [9] which will be useful in the definition of the operators
for obtaining that well-founded model.
Definition 3. Consider a hybrid MKNF knowledge base K = (O,P). The set
of K-atoms of K, written KA(K), is the smallest set that contains (i) all positive
literals occurring in P, and (ii) a literal K for each literal not occurring in
K. Furthermore, for a set of literals S, SDL is the subset of DL-atoms of S, and

S = { | K  S}.

Basically all literals appearing in the rules are collected in KA(K) as a set of
positive literals and the other two notions provide restrictions on such a set.

To guarantee that all atoms that are false in the ontology are also false by
default in the rules, we introduce new positive DL atoms which represent firstorder false DL atoms, and another program transformation making these new
literals available for reasoning in the respective rules.
Definition 4. Let K be a hybrid MKNF knowledge base. We obtain K+ =
(O+, P ) from K by adding an axiom P  NP for every DL atom P which
occurs as head in at least one rule in K where NP is a new predicate not already
occurring in K. Moreover, we obtain K from K+ by adding notN P (t1, . . . , tn)
to the body of each rule with a DL atom P (t1, . . . , tn) in the head.
By K+, NP represents P (with its corresponding arguments) and K introduces
a restriction on each rule with such a DL atom in the head saying intuitively
that the rule can only be used to conclude the head if the negation of its head
does not hold already6.

We continue now by defining an operator TK which allows to draw conclusions

from positive hybrid MKNF knowledge bases.
6 Note that K+ and K are still hybrid MKNF knowledge bases, so we only refer to
K+ and K explicitly when it is necessary.
?

?

?
Definition 5. For K a positive hybrid MKNF knowledge base, RK, DK, and TK
are defined on the subsets of KA(K) as follows:

RK(S) = S  {KH | K contains a rule of the form (1) such that KAi  S

DK(S) = {K | K  KA(K) and O SDL |= }  {KQ(b1, . . . , bn) |

for each 1  i  n}

KQ(a1, . . . , an)  S \ SDL, KQ(b1, . . . , bn)  KA(K), and

O SDL |= ai  bi

for 1  i  n}

TK(S) = RK(S)  DK(S)

RK derives consequences from the rules while DK obtains knowledge from the
ontology O, respectively from non-DL-atoms and the equalities occuring in O.
The operator TK is shown to be monotonic in [9] so, by the Knaster-Tarski
theorem, it has a unique least fixpoint, denoted lfp(TK), which is reached after
a finite number of iteration steps.

The computation follows the alternating fixpoint construction [18] of the wellfounded semantics for logic programs which neccesitates turning a hybrid MKNF
knowledge base into a positive one to make TK applicable.
Definition 6. Let KG = (O,PG) be a ground hybrid MKNF knowledge base
and let S  KA(KG). The MKNF transform KG/S = (O,PG/S) is obtained by
PG/S containing all rules H  A1, . . . , An for which there exists a rule KH 
KA1, . . . , KAn, notB1, . . . , notBm in PG with KBj  S for all 1  j  m.
This resembles the transformation known from answer-sets [6] of logic programs
and the following two operators are defined.
Definition 7. Let K be a hybrid MKNF knowledge base and S  KA(K).

K(S) = lfp(TK+

G/S)
?

?

?
K(S) = lfp(TK


G/S)

Both operators are shown to be antitonic [9] and form the basis for defining the
well-founded MKNF model. Here we present its alternating computation.
?

?

?
P0 = 

P =

Pn+1 = K(Nn)

Pn
?

?

?
N0 = KA(K)

K(Pn)
Nn

N =

Nn+1 = 

Note that by finiteness of the ground knowledge base the iteration stops before
reaching . It was shown in [9] that the sequences are monotonically increasing,
decreasing respectively, and that P and N form the well-founded MKNF model.
Definition 8. Let K = (O,P) be a hybrid MKNF knowledge base and let
PK, NK  KA(K) with PK being P and NK being N, both restricted to the
literals only occurring in KA(K). Then MW F = {KA | A  PK}  {K(O)} 
{notA | A  KA(K) \ NK} is the well-founded MKNF model of K.
All literals in MW F are true, its counterparts are false (e.g. if KH is true then
notH is false) and all other literals from KA(K) are undefined. Note that K(O)
appears in the model for conciseness with [9].
?

?

?
3 Alternative Computation of MKNFW F S

As we have seen, the bottom-up computation of the well-founded MKNF model
requires essentially two operators each with its own transformation of the knowledge base. Using directly this as a basis for the top-down procedure, would complicate it, in that we would have to consider two different copies of the program,
and use them alternately in different parts of the procedure. This is why, in this
section, we define that computation in a different way. Namely, we double the
rules in K using new predicates, transform them appropriately, and double the
ontology, so that we can apply just one operator and still obtain the well-founded
MKNF model.
Definition 9. Let K = (O,P) be a hybrid MKNF knowledge base. We introduce new predicates, i.e. a predicate Ad for each predicate A appearing in
K, and define Kd as the knowledge base obtained by adding O+ to O where
each predicate A in O is substituted by Ad, and transforming each H(ti) 
A1, . . . , An, notB1, . . . , notBm occuring in P, ti representing the arguments of
H, into the following two rules:
(1) H(ti)  A1, . . . , An, notBd
(2a) H d(ti)  Ad
(2b) H d(ti)  Ad
Note that the predicate notN H is in fact the one introduced by K+.

n, notB1, . . . , notBm otherwise
We can now define a new operator  d on Kd only7.

n, notB1, . . . , notBm, notN H(ti) if H is a DL-atom;

1 , . . . , notBd

m and either

1, . . . , Ad

1, . . . , Ad

or

G/S) and K(S) =  dK( dK(S)).

Definition 10. Let K = (O,P) be a hybrid MKNF knowledge base and S 
KA(Kd). We define  dK(S) = lfp(TKd
The operator  dK is antitonic just like K, and so K is a monotonic operator.
Therefore K also has a least and a greatest fixpoint and we can formulate their
iteration in the same manner as for P and N.
0 = KA(Kd)
Nd
n+1 =  dK(Pd
n)
 =
Nd
Nd
n
?

?

?
0 = 
Pd
n+1 =  dK(Nd
n)
 =
Pd
Pd
n
?

?

?
Nd

Pd

We can now state the relation of the least and the greatest fixpoint of K to P
and N, from which the well-founded MKNF model is obtained.
Theorem 1. Let K = (O,P) be a hybrid MKNF knowledge base and let Pd
the least fixpoint of K and Nd
 A  P if and only if A  Pd
 B  N if and only if Bd  Nd
It follows immediately from this theorem that we can use K to compute the
well-founded MKNF model. We also derive from the theorem that we have to
use the new predicates Ad if we query for negative literals.
7 Note that the operators in Definition 5 are now defined for subsets of KA(Kd).

 be the greatest fixpoint of K. We have:

 be





J.J. Alferes, M. Knorr, and T. Swift

4 Tabled SLG(O)-Resolution for Hybrid MKNF
Now we present the new SLG-resolution, SLG(O), for Hybrid MKNF Bases
which extends [2]. We should mention that the definition of SLG(O) is quite involved and requires that certain definitions are interlinked with each other (links
are provided in each of these cases). It is based on sets of trees of derivations
(forests). Tree nodes contain sets of literals which we also call goals (cf. Def.12).
To deal with termination, some literals must be delayed during the tabled res-
olution, and so we have to define delay literals (cf. Def.11). Also, a notion of
completely evaluated goals in a forest is needed for termination (cf. Def.14). The
trees, and the delaying of literals, are constructed according to the set of operations in Def.18. Some of these operations require resolution of selected literals
with program rules and, since delayed literals may exist, a slightly changed resolution is required (cf. Def.13). For dealing with the ontology, derivation steps
must also take into account an oracle; thus, a suitable definition of what is expected from the oracle is required (cf. Def.17). We begin the presentation of
SLG(O) by defining the delay literals, and then forests:
Definition 11. A negative delay literal has the form not A, where A is a ground
Answer, where A is an atom whose
atom. Positive delay literals have the form ACall
truth value depends on the truth value of some literal Answer for the literal Call.
If  is a substitution, then (ACall
Positive delay literals can only appear as a result of resolution. Its special form
as indicated by the names is meant to keep track of the answer and call used for
that resolution and possible substitutions are thus only applied to A itself.
Definition 12. A node has the form

Answer) = (A)Call

Answer.

Answer T emplate :- Delays|Goals

or

f ail.

In the first form, Answer T emplate is an atom, Delays is a sequence of (positive
and negative) delay literals and Goals is a sequence of literals. The second form
is called a failure node. A program tree T is a tree of nodes whose root is of the
form S :- |S for some atom S: S is the root node for T and T is the tree for
S. An SLG forest F is a set of program trees. A node N is an answer when it
is a leaf node for which Goals is empty. If Delays of an answer is empty it is
termed an unconditional answer, otherwise, it is a conditional answer. Program
trees T may be marked as complete.
Whenever Goals contains various elements we effectively have to select one of
them, by using a selection function. The only requirement for such a selection
function, is that DL-atoms are not selected until they are ground (which is always
possible given DL-safety).

The definition of answer resolution is slightly different from the usual one to
take delay literals in conditional answers into account.
Definition 13. Let N be a node A :- D|L1, ..., Ln, where n > 0. Let Ans =
| be an answer whose variables have been standardized apart from N.
 :- D
?

?

?
N is SLG resolvable with Ans if i, 1  i  n, such that Li and A
with an mgu . The SLG resolvent of N and Ans on Li has the form:

 are unifiable

(A :- D|L1, ..., Li1, Li+1, ..., Ln)

if D

 is empty; otherwise the resolvent has the form:

(A :- D, Li

Li

A|L1, ..., Li1, Li+1, ..., Ln)

We delay Li rather than propagating the answers delay list. This is necessary,
as shown in [2], to ensure polynomial data complexity8.
At a certain point in SLG(O) resolution, a set of goals may be completely

evaluated, i.e. it can produce no more answers.
Definition 14. A set S of literals is completely evaluated if at least one of the
conditions holds for each S  S
1. The tree for S contains an answer S :- |; or
2. For each node N in the tree for S:

(a) The underlying subgoal9 of the selected literal of N is completed; or
(b) The underlying subgoal of the selected literal of N is in S and there are no
applicable New Subgoal, Program Clause Resolution, Oracle
Resolution, Equality Resolution, Positive Return, Negative
Return or Delaying operations (Definition 18) for N.

Once a set of literals is determined to be completely evaluated, the Completion
operation marks the trees for each literal (Definition 12). Such completely evaluated trees can then be used to simplify other trees in the evaluation.

According to Definition 13, if a conditional answer is resolved against the
selected literal in the set Goals of a node, the information about the delayed literals in the answer is not propagated. However, in certain cases, the propagation
of conditional answers can lead to a set of unsupported answers  conditional
answers that are false in the well founded model (see e.g. Example 1 of [17])10.
Definition 15. Let F be an SLG forest, S a root of a tree in F, and Answer be
an atom that occurs in the head of some answer of S. Then Answer is supported
by S in F if and only if:
1. S is not completely evaluated; or
2. there exists an answer node Answer :- Delays| of S such that for every

positive delay literal DCall

Ans , Ans is supported by Call.

We can obtain an interpretation from an SLG forest representing the truth values
of the roots of its trees. This interpretation will later also correspond to MW F
(cf. Theorem 4).

8 If we propagated the delay lists, we would propagate all derivations which could be

exponential in bad cases.

9 The underlying subgoal of literal L is L if L is positive and S if L = not S.
10 As an aside, we note that unsupported answers appear to be uncommon in practical

evaluations which minimize the use of delay such as [16].
?

?

?
Definition 16. Let F be a forest. Then the interpretation induced by F, IF , is
the smallest set such that:
 A (ground) atom A  IF iff A is in the ground instantiation of some unconditional answer Ans :- | in F.
 A (ground) literal not A  IF iff A is in the ground instantiation of a
completely evaluated literal in F, and A is not in the ground instantiation
of any answer in a tree in F.

 (not S

) is in IF for every S

 in the
An atom S is successful (failed) in IF if S
ground instantiation of S. A negative delay literal not D is successful (failed) in a
forest F if D is (failed) successful in F. Similarly, a positive delay literal DCall
Ans is
successful (failed) in a F if Call has an unconditional answer Ans :- | in F.
In order to describe a tabled evaluation that is parameterized by an oracle,
we need to characterize the behavior of an abstract oracle, O11 that computes
entailment according to a theory, i.e. the ontology. For that purpose, we define
an oracle transition function that in just one step computes all possible atoms
required to prove the goal. In other words, such an oracle, when posed a query S
non-deterministically returns in one step a set of atoms defined in the program
(i.e. atoms for which there is at least one rule with it in the head) such that, if
added to the oracle theory, immediately derives S.
Definition 17. Let K = (O,P) be a hybrid MKNF knowledge base, S a goal,
and L a set of ground atoms which appear in at least one rule head in PG. The
complete transition function for O, denoted compTO, is defined by

compTO(IFn , S, L) iff O  IFn  L |= S

We are now able to characterize SLG(O) operations.
Definition 18 (SLG(O) Operations). Let K = (O,P) be a hybrid MKNF
knowledge base. Given a forest Fn of an SLG(O) evaluation of K, Fn+1 may be
produced by one of the following operations.
1. New Subgoal: Let Fn contain a tree with non-root node

N = Ans :- Delays|G, Goals

where G is the selected literal S or not S. Assume Fn contains no tree with
root S. Then add the tree S :- |S to Fn.
2. Program Clause Resolution: Let Fn contain a tree with root node N =
S :- |S and C be a rule Head :- Body such that Head unifies with S with
mgu . Assume that in Fn, N does not have a child Nchild = (S :- |Body).
Then add Nchild as a child of N.

11 We overload O syntactically to represent the oracle and the ontology, since seman-

tically they are the same anyway.
?

?

?
3. Oracle Resolution: Let Fn contain a tree with root node N = S :- |S
and S and all G  Goals be DL-atoms. Assume that compTO(IFn , S, Goals).
If N does not have a child Nchild = S :- |Goals in Fn then add Nchild as a
child
4. Equality Resolution: Let Fn contain a tree with root node N = S :- |S
where S and G  Goal are ground non-DL-atoms with the identical predicate.
Assume that compTO(IFn , S, Goal). If N does not have a child Nchild =
S :- |Goal in Fn then add Nchild as a child
5. Positive Return: Let Fn contain a tree with non-root node N whose selected literal S is positive. Let Ans be an answer for S in Fn and Nchild be
the SLG resolvent of N and Ans on S. Assume that in Fn, N does not have
a child Nchild. Then add Nchild as a child of N.
6. Negative Return: Let Fn contain a tree with a leaf node, whose selected

literal not S is ground

N = Ans :- Delays|not S, Goals.

form fail.

form: Ans :- Delays|Goals.

(a) Negation Success: If S is failed in F then create a child for N of the
(b) Negation Failure: If S succeeds in F, then create a child for N of the
7. Delaying: Let Fn contain a tree with leaf N = Ans :- Delays|not S, Goals,
such that S is ground, in Fn, but S is neither successful nor failed in Fn.
Then create a child for N of the form Ans :- Delays, not S|Goals.
8. Simplification: Let Fn contain a tree with leaf node N = Ans :- Delays|,
and let L  Delays
(a) If L is failed in F then create a child fail for N.
(b) If L is successful in F, then create a child Ans :- Delays

| for N, where
9. Completion: Given a completely evaluated set S of literals (Definition 14),
10. Answer Completion: Given a set of unsupported answers UA, create a

mark the trees for all literals in S as completed.
failure node as a child for each answer Ans  UA.

Delays

 = Delays  L.

The only thing now missing is the formalization of the initialization of an SLG
evaluation process.
Definition 19. Let K be a hybrid MKNF knowledge base and let q be a query
of the form q(Xi)  A1, . . . , An, notB1, . . . , notBm where Xi is the (possibly
empty) set of requested variables. We set F0 = {q(Xi) :  | q(Xi)} to be the
initial forest of an SLG(O) evaluation of Kd for q.
Of course, if the query is atomic we can usually simply start with that atomic
query. Note that since we use Kd, the technically correct way to query negative
literals is to use notBd instead of notB for any atom B.
Example 1. In order to illustrate the actions of SLG(O) we consider a derivation
of an answer to the query ?- discount(bill) to the KB due to [12]12:
12 We adopt that only DL-atoms start with a capital letter. Also, to ease the reading,
and since it has no influence in this example, instead of Kd we operate on K directly.

J.J. Alferes, M. Knorr, and T. Swift

N onM arried  M arried
Spouse.T  M arried
N onM arried(X)  not M arried(X).
discount(X)  not HighRisk(X)

M arried  HighRisk
bill  (Spouse.michelle)

Note that both TBox and ABox information are each distributed over both the
description logic and the program. Figure 1 shows the final forest for this evalu-
ation, where elements are marked in the order they are created. The initial forest for the evaluation consists of node 0 only. Since the selected literal of node
0, discount(bill) is a non-DL-atom and there are no equalities in the KB, we
can only apply Program Clause Resolution which produces node 1, followed
by a New Subgoal to produce node 2. Node 2 is a DL-atom, there are no rules
applicable for HighRisk(bill), but an Oracle Resolution operation can be
applied to derive bill  N onM arried (node 3). Then via a New Subgoal operation node 4 is obtained. The selected literal for node 4, NonMarried(bill) is a
DL-atom that also is the head of a rule, so the oracle and the program evaluation
may both try to derive the atom. On the program side, Program Clause Resolution produces nodes 5 and 6. The selected literal of node 6, Married(bill),
is a DL-atom that is not the head of a program rule, so once again the only possibility is to use Oracle Resolution, and derive Married(bill); using this a
Negative Return operation produces node 8, and the tree for Married(bill)
can be early completed. The tree for NonMarried(bill) which does not have an
answer must be completed (step 10), and the same for HighRisk(bill) (step 11).
Once this occurs, a Negative Return operation is enabled to produce node 12.

0. discount(bill): |discount(bill)

1. discount(bill): | not HighRisk(bill)

11. complete

12. discount(bill):

2. HighRisk(bill): HighRisk(bill)

3. HighRisk(bill): NonMarried(bill)

4. NonMarried(bill): NonMarried(bill)

9. complete

6. Married(bill): Married(bill)

10. complete

5. NonMarried(bill): not Married(bill)

7. Married(bill)

8. fail

Fig. 1. Final Forest for query ?- discount(bill) to K1

The evaluation illustrates several points. First, the evaluation makes use of
classical negation in the ontology along with closed world negation in the rules.
From an operational perspective, the actions of the description logic prover and
the program are interleaved, with the program calling the oracle by creating
new trees for DL-atoms, and the oracle calling the rule system through Oracle Resolution operations. As a result, trees for DL-atoms must either be
early-completed, or explicitly completed by the tabulation system.
?

?

?
5 Properties
Theorem 2. Let q = L be a query to a hybrid MKNF knowledge base K. Then
any SLG(O) evaluation of q will terminate after finitely many steps, producing
a finite final forest.
The way SLG(O) is defined there is no real order in which to apply any of
the operations possible in a forest Fi. Some orders of application are in general
more efficient than others but it was shown in [2] that any order yields the same
outcome for any query. We adopt this statement here to SLG(O).
Theorem 3. Let E1 and E2 be two SLG(O) evaluations of a query q = L to a
G. Let F1 be the final forest of E1 and F2 be the final
hybrid knowledge based Kd
forest of E2. Then, IF1 = IF2.
This theorem will also be helpful when it comes to proving that SLG(O) is
in fact a query procedure for MKNFW F S and may terminate within the same
complexity bounds as the semantics defined in [9]. At first, we will show that
the procedure presented in the previous section coincides with MKNFW F S. In-
tuitively, what we have to show is that the well-founded MKNF model, as presented in section 2 and based on the computation presented in Section 3, and
the interpretation IF induced by Fn for some query q to Kd coincide for each
ground literal appearing in Kd
G. We can simplify that by showing for each literal
G that L  MW F if and only if L  IF with query q = L and
L appearing in Kd
Fn for some n. Additionally, we prove that the same correspondence holds for
(positive)13 atoms only appearing in the ontology.
Theorem 4. Let K be a hybrid MKNF knowledge base and L be a modal atom
which appears in Kd
G. SLG(O)resolution is correct and complete wrt. MKNFW F S,
i.e. L  MW F if and only if L  IF where IF is induced by the forest F of an
SLG(O)evaluation of Kd
G for query q = L and, for atoms P not appearing in any
rule, MW F |= P if and only if P  IF .
Given the soundness of MKNFW F S wrt. the semantics of MKNF knowledge
bases of [12], it follows easily that:
Corollary 1. Let K be a consistent hybrid MKNF knowledge base and L be a
modal atom which appears in Kd
G. If L  IF , where IF is induced by the forest F
of an SLG(O) evaluation of Kd
G for query q = L, then L belongs to all MKNF
two-valued models (as in [12]) of K.
In addition to the interpretation of the final forest IF being sound with respect
to the 2-valued MKNF model, the conditional answers in F can be seen as a wellfounded reduct of the rules in K, augmented with conditional answers derived
through Oracle Resolution and Equality Resolution operations. As a

13 We cannot query directly for explicit negated atoms, however, a simple transforma-

tion similar to the one yielding K+ provides a solution to that problem.

J.J. Alferes, M. Knorr, and T. Swift

result, the final forest can be seen as a residual program: a sound transformation
not only of the rules, but of information from the oracle, and can be used to
construct a partial 2-valued stable model.
Regarding complexity, it is clear that the complexity of the whole SLG(O)
depends on the complexity of the oracle, and also on the number of results
returned by each call to the oracle. Clearly, the complexity associated to the
computation of one result of the oracle function is a lower-bound of the complexity of SLG(O). Moreover, even if e.g. the computation of one result of the
oracle is tractable, if exponentially many solutions are generated by the oracle (e.g. returning all supersets of a solution), then the complexity of SLG(O)
becomes exponential. This is so, because our definition of the oracle is quite
general, and in order to prove interesting complexity results some assumptions
most be made about the oracle. We start by defining a correct partial oracle:
Definition 20. Let K = (O,P) be a hybrid MKNF knowledge base, S a goal,
and L a set of ground atoms which appear in at least one rule head in PG (called
program atoms). A partial oracle for O, denoted pTO, is a relation pTO(IFn , S, L)
such that if pTO(IFn , S, L) then O  IFn  L |= S.
A partial oracle pTO is correct iff when replacing compTO in SLG(O) suc-

ceeds for exactly the same set of queries.

Note that the complete oracle is indeed generating unnecessarily many answers,
and it can be replaced by a partial one which assures correctness. E.g. consider
a partial oracle that does not return supersets of other results. Such a partial
oracle is obviously correct. Making assumptions on the complexity and number
of results of an oracle, complexity results of SLG(O) are obtained.
Theorem 5. Let pTO be a correct partial oracle for the hybrid MKNF knowledge
base K = (O,P), such that for every goal S, the cardinality of pTO(IFn , S, L) is
bound by a polynomial on the number of program atoms. Moreover, assume that
computing each element of pTO is decidable with data complexity C. Then, the
SLG(O) evaluation of a query in Kd
In particular, this means that if the partial oracle is tractable, and only with
polynomial many results, then SLG(O) is also tractable. Clearly, for an ontology
part of the knowledge base which is a tractable fragment, it is possible to come
up with a correct partial oracle that is also tractable. Basically, all it needs
to be done is to proceed with the usual entailment method, assuming that all
program atoms hold, and collecting them for the oracle result. To guarantee
that the number of solutions of the oracle is bound by a polynomial, and still
keeping with correctness, might be a bit more difficult. It amounts to find a
procedure that returns less results, and at the same time does not damage the
completeness proof (similar to that of Theorem 4). At least for the tractable case
this is possible, albeit the oracle being the (polynomial complexity) bottom-up
procedure that defines MKNFW F S.

G is decidable with data complexity PC.
?

?

?
6 Discussion and Conclusions
Together with the alternate computation method of Section 3, SLG(O) provides
a sound and complete querying method for hybrid MKNF knowledge bases, that
unlike others (cf. below) freely allows bidirectional calls between the ontology
and the rules, and that does not impose a burden of complexity beyond that of
the ontology. As such it presents a significant step towards making hybrid MKNF
knowledge bases practically usable for the Semantic Web. In fact, work has begun on a prototype implementation of the SLG(O) method presented here using
XSB Prolog and its ontology management library CDF [8]. Because the CDF theorem prover is implemented directly using XSB, the Oracle Resolution and
Equality Resolution operations of Section 4 are more easily implemented
than they would be using a separate prover, as is the detection of when a mutually dependent set of subgoals is completely evaluated (Definition 14), and
the guarantee of the polynomial size of the oracle. The resulting implementation will enable further study into how hybrid MKNF knowledge bases can be
practically used and will indicate needed optimizations. For instance, since XSB
supports constraint processing, temporal or spatial constraints can be added to
the ABox. From a systems perspective, the multi-threading of XSB can allow
for the construction of hybrid MKNF knowledge servers that make use of either
Prolog rules or F-logic rules (via FLORA-2, which is implemented using XSB).
As mentioned in Section 5 the final forest of a SLG(O) evaluation produces a
well-founded reduct of the rules and oracle information. This reduct, which is
materialized in a table in XSB, can be sent to a stable model generator through
XSBs XASP library to obtain a partial stable MKNF model of [12].

There are two other semantics which define a well-founded model for a combination of rules and ontologies, namely [5] and [3]. The approach of [5] combines
ontologies and rules in a modular way, i.e. keeps both parts and their semantics
separate, thus having similarities with our approach. The interface is done by the
dlv hex system [4]. Though with identical data complexity to the well-founded
MKNF semantics for a tractable DL, it has a less strong integration, having limitations in the way the ontology can call back program atoms (see [5] for details).
Hybrid programs of [3] are even more restrictive in the combination: in fact it
only allows to transfer information from the ontology to the rules and not the
other way around. Moreover, the semantics of this approach differs from MKNF
[12,9] and also[5] in that if an ontology expresses B1  B2 then the semantics in
[3] derives p from rules p  B1 and p  B2, p while MKNF and [5] do not.

While queries posed to KBs without an ontology are handled in the same way
as in SLG, strictly speaking the queries posed to the (oracle) DL fragment, are
not conjunctive queries in the sense of [7] where boolean queries may contain
anonymous variables which never get instantiated. Here we ask whether a ground
atom holds when querying the oracle. We nevertheless obtain conjunctive queries
up to a certain extent in the sense of [7] only wrt. the entire KB, and our queries
are not limited to fit the tree-shaped models there. One line of future work will
thus be an extension to such queries which is supported by possible anonymous
variables in XSB, the system in which the semantics is currently implemented.

J.J. Alferes, M. Knorr, and T. Swift
