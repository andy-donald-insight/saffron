Concept and Role Forgetting in ALC Ontologies

Kewen Wang1, Zhe Wang1, Rodney Topor1, Jeff Z. Pan2, and Grigoris Antoniou3

{k.wang,jack.wang,r.topor}@griffith.edu.au

1 Griffith University, Australia

2 University of Aberdeen, UK
jeff.z.pan@abdn.ac.uk
3 University of Crete, Greece
antoniou@ics.forth.gr

Abstract. Forgetting is an important tool for reducing ontologies by eliminating some concepts and roles while preserving sound and complete reasoning.
Attempts have previously been made to address the problem of forgetting in relatively simple description logics (DLs) such as DL-Lite and extended EL . The
ontologies used in these attempts were mostly restricted to TBoxes rather than
general knowledge bases (KBs). However, the issue of forgetting for general KBs
in more expressive description logics, such as ALC and OWL DL, is largely un-
explored. In particular, the problem of characterizing and computing forgetting
for such logics is still open.
In this paper, we first define semantic forgetting about concepts and roles in
ALC ontologies and state several important properties of forgetting in this set-
ting. We then define the result of forgetting for concept descriptions in ALC ,
state the properties of forgetting for concept descriptions, and present algorithms
for computing the result of forgetting for concept descriptions. Unlike the case of
DL-Lite, the result of forgetting for an ALC ontology does not exist in general,
even for the special case of concept forgetting. This makes the problem of how
to compute forgetting in ALC more challenging. We address this problem by
defining a series of approximations to the result of forgetting for ALC ontologies
and studying their properties and their application to reasoning tasks. We use the
algorithms for computing forgetting for concept descriptions to compute these
approximations. Our algorithms for computing approximations can be embedded
into an ontology editor to enhance its ability to manage and reason in (large)
ontologies.

1 Introduction

The amount of semantically annotated data available on the Web is growing rapidly.
Often, the formal model used for representing such information is an ontology in some
description logic. As more ontologies are used for annotating data on the Web, and
as the populated ontologies become larger and more comprehensive, it becomes increasingly important for the Semantic Web [4] to be able to construct and manage
such ontologies. Examples of large ontologies currently in use include the Systematised

 This work was partially supported by the Australia Research Council (ARC) Discovery Project

0666107.

A. Bernstein et al. (Eds.): ISWC 2009, LNCS 5823, pp. 666681, 2009.
c Springer-Verlag Berlin Heidelberg 2009
?

?

?
Nomenclature of Medicine Clinical Terms (SNOMED CT) containing 380K concepts,
GALEN, the Foundational Model of Anatomy (FMA), the National Cancer Institute
(NCI) Thesaurus containing over 60K axioms, and the OBO Foundry containing about
80 biomedical ontologies.

While it is expensive to construct large ontologies, it is even more expensive to host,
manage and use a large, comprehensive ontology when a smaller ontology would suf-
fice. Therefore, tools to reduce large ontologies to smaller ontologies that meet the
needs of specific applications aid and encourage the use of existing ontologies. How-
ever, as the tool evaluation study in [5] shows, existing tools, such as Prot eg e [28],
NeOn [29] and TopBraid [30], are far from satisfactory for this purpose.

Ontology engineers thus face the task of reducing existing, large ontologies to
smaller, better focussed ontologies by hiding or forgetting irrelevant concepts and roles
while preserving required reasoning capabilities. Such ontology reductions can be applied to ontology extraction, ontology summary, ontology integration, and ontology
evolution.

We consider two typical scenarios, in ontology extraction and ontology summary,

respectively.

Ontology Extraction. To avoid building new ontologies from scratch, it is preferable to
reuse existing ontologies whenever possible. But often, only part of an existing ontology
is required. For exxample, if we had an ontology of medical terms, such as SNOMED,
but were only interested in infectious diseases, it would be desirable to forget all other
terms in the ontology before starting to reason about infectious diseases.
Ontology summary: As argued in [1,18], a key problem faced by ontology engineers
is the task of constructing a summary of an existing ontology so that other users can
decide whether or not to use it. This task involves first identifying the key concepts
(and roles) in the ontology and then hiding or forgetting all other concepts (and roles).
For example, an astronomical ontology of the solar system might have planets as key
concepts and asteroids and comets as less important concepts.

However, an ontology is often represented as a logical theory, and the removal of
one term may influence other terms in the ontology. Thus, more advanced methods for
dealing with large ontologies and reusing existing ontologies are desired.

Forgetting (or uniform interpolation) has previously been studied for propositional
and first-order logic and logic programming[15,16,6], where it has proved a useful technique for reducing the size of a logical theory while preserving sound and complete
reasoning in the resulting smaller theory.

However, description logic (DL) [3] is a different, important. knowledge representation framework, which is the basis for ontology languages such as OWL, that are widely
used in the Semantic Web. In this context, an ontology is a knowledge base (KB) in a
particular description logic, where a knowledge base consists of a terminology box
(TBox) and an assertion box (ABox).

Although most description logics are equivalent to fragments of first-order logic
(FOL), the forgetting for first-order logic introduced in [16] is not directly applicable
to description logics for at least two reasons. First, the correspondence between DLs
and FOL is useless in investigating forgetting for DLs because the result of forgetting
in a theory of the first-order logic (FOL) may only be expressible in second-order logic.

K. Wang et al.

Second, it is preferable to perform forgetting in description logics directly rather than
transforming an ontology into a first-order theory, forgetting and then transforming back
to an ontology.
Attempts have previously been made to address the problem of forgetting in relatively simple description logics (DLs) such as DL-Lite [21,14] and extended EL [12].
The ontologies used in these attempts were mostly restricted to KBs with empty
ABoxes. Forgetting also generalizes previous work on conservative extensions [9,7,17]
and the modularity defined in [8,10,13]. A definition of forgetting for TBoxes in the
more expressive DL ALC was given in [7].
However, the issue of forgetting for general KBs, with nonempty ABoxes, in more
expressive DLs, such as ALC and OWL DL, is largely unexplored. In particular, the
problem of characterizing and computing forgetting for such logics is still open.
In this paper we first give a semantic definition of forgetting for ontologies in the
description logic ALC and state several important properties of forgetting. We choose
ALC to study in this paper because it allows all boolean operations and most expressive
DLs are based on it. Others have argued [19] that practical ontologies such as SNOMED
would benefit from a more expressive DL. We then define the result of forgetting for
concept descriptions in ALC , state the properties of forgetting for concept descriptions,
and present algorithms for computing the result of forgetting for concept descriptions.
(Forgetting for concept descriptions in ALC has previously been investigated under the
name of uniform interpoloation in [20].) Unlike the case of DL-Lite, the result of forgetting for an ALC ontology does not exist in general, even for the special case of concept
forgetting. This makes the problem of how to compute forgetting in ALC more chal-
lenging. We address this problem by defining a series of approximations to the result
of forgetting for ALC ontologies and studying their properties and their application to
reasoning tasks. We use the algorithms for computing forgetting for concept descriptions to compute these approximations. Our algorithms for computing approximations
can be embedded into an ontology editor to enhance its ability to manage and reason in
(large) ontologies.

Our work significantly extends previous work in at least two ways: (1) We make the
first attempt to study forgetting for an expressive description logic, instead of DL-Lite
and variants of EL . (2) Ontologies in this paper are KBs with nonepty ABoxes, rather
than TBoxes only in previous work. In addition, our definitions and results hold for
forgetting about both concepts and roles.

Due to space limitation, proofs are omitted in this paper but can be
found at http://www.cit.gu.edu.au/ kewen/Papers/alc_forget_
long.pdf

2 Description Logic ALC
In this section, we briefly recall some preliminaries of ALC , the basic description logic
which contains all boolean operators. Further details of ALC and other DLs can be
found in [3].
First, we introduce the syntax of concept descriptions for ALC . To this end, we
assume that NC is a set of concept names (or concept), NR is a set of role names (or
roles) and NI is a set of individuals.
?

?

?
Elementary concept descriptions consist of both concept names and role names. So a
concept name is also called atomic concept while a role name is also called atomic role.
Complex concept descriptions are built inductively as follows: A (atomic concept); 
(universal concept);  (empty concept); C (negation); C  D (conjunction); C " D
(disjunction); R.C (universal quantification) and R.C (existential quantification).
Here, A is an (atomic) concept, C and D are concept descriptions, and R is a role.
is a non-empty set called the
domain and I
is an interpretation function which associates each (atomic) concept A
I  
?

?

?
.
with a subset A
The function I

of 
can be naturally extended to complex descriptions:

An interpretation I of ALC is a pair (

and each atomic role R with a binary relation R

,I) where 

I  

I = 

(C)I = 
I  C

(C " D)I = C
I  D
I : b.(a, b)  R
(R.C)I = {a  
(R.C)I = {a  
I : b.(a, b)  R
?

?

?
I = 
(C  D)I = C
implies b  C
I}
and b  C
I}

I  D

, b

I  C

I)  R

An ALC assertion box (or ABox) is a finite set of assertions. An assertion is a concept
assertion of the form C(a) or a role assertion of the form R(a, b), where a and b are
individuals, C is a concept name, R is a role name.

An interpretation I satisfies a concept assertion C(a) if a

, a role assertion
. If an assertion  is satisfied by I, it is denoted I |= . An
R(a, b) if (a
interpretation I is a model of an ABox A, written I |= A, if it satisfies all assertions
in A.
A inclusion axiom (simply inclusion, or axiom) is of the form C  D (C is subsumed
by D), where C and D are concept descriptions. The inclusion C  D (C is equivalent
to D) is an abbreviation of two inclusions C  D and D  C. A terminology box, or
TBox, is a finite set of inclusions. An interpretation I satisfies an inclusion C  D if
I  D
. I is a model of a TBox T , denoted I |= T , if I satisfies every inclusion of

T . T |= C  D if for any I, I |= T implies I |= C  D.
Formally, a knowledge base (KB) is a pair (T ,A) of a TBox T and an ABox A. An
interpretation I is a model of K if I is a model of both T and A, denoted I |= K. If 
is an inclusion or an assertion, K |=  if every model of K is also a model of . Two
are equivalent, written K  K
, if they have the same models.  can
KBs K and K
be similarly defined for ABoxes and TBoxes.
The signature of a concept description C, written sig(C), is the set of all concept and
role names in C. Similarly, we can define sig(A) for an ABox A, sig(T ) for a TBox T ,
and sig(K) for a KB K.
3 Forgetting in ALC Ontologies

In this section, we will first give a semantic definition of what it means to forget about a
set of variables in an ALC KB, and then state and discuss several important properties
of forgetting that justify the definition chosen. This is the first study of forgetting both
concepts and roles for arbitrary knowledge bases in ALC .
As explained earlier, given an ontology K on signature S and V  S, in ontology enon S V such that reasoning
gineering it is often desirable to obtain a new ontology K
?

?

?
;

is weaker than K in general.

over the signature sig(K)  V is a result of forgetting about V in K if

. As a result, K
tasks on S  V are still preserved in K
This intuition is formalized in the following definition.
Definition 3.1 (KB-forgetting). Let K be a KB in ALC and V be a set of variables. A
KB K
(KF1) K |= K
(KF2) for each concept inclusion C  D in ALC not containing any variables in V,
K |= C  D implies K |= C  D;
(KF3) for each membership assertion C(a) or R(a, b) in ALC not containing any
variables in V, K |= C(a) (resp., K |= R(a, b)) implies K |= C(a) (resp., K |=
R(a, b));

Condition (KF3) extends previous definitions [7] to allow for nonempty ABoxes in
KBs.

To illustrate the above definition of semantic forgetting and how forgetting can
be used in ontology extraction, consider the following example of designing an
ALC ontology about flu.
Example 3.1. Suppose we have searched the Web and found an ontology about human
diseases (such a practical ontology could be very large):

Disease  attacks.Human,
Human  Male " Female,
Human  Infected  shows.Symptom,
Disease  Infectious " Noninfectious,
Influenza " HIV " TB  Infectious.

We want to construct a (smaller) ontology only about flu by reusing the above ontol-
ogy. This is done by forgetting about the undesired concepts {Disease, Noninfectious,
HIV , TB}. As a result, the following ontology is obtained:

Influenza  Infectious,
Infectious  attacks.Human,
Human  Male " Female,
Human  Infected  shows.Symptom,

The next example shows that the result of forgetting in an ALC ontology may not exist
in some cases.
Example 3.2. Let K = (T ,A) be an ALC KB where T = { A  B, B  C, C 
R.C, C  D }, and A = { B(a), R(a, b)}.
Take K1 = (T1,A1) where T1 = { A  C, C  R.C, C  D } and A1 =
{ C(a), R(a, b)}. Then K1 is a result of forgetting about concept B in K.
However, there does not exist a result of forgetting about {B, C} in K. To understand
this, we note that the result of forgetting about {B, C} in K should include the following
inclusions:

A  D, A  R.D, A  R.R.D, . . . , and
D(a), (R.D)(a), (R.R.D)(a), . . . , and
R(a, b), D(b), (R.D)(b), (R.R.D)(b), . . .
?

?

?
In fact, there is no finite ALC KB which is equivalent to the above infinite set of
inclusions.
If the result of forgetting about V in K is expressible as an ALC KB, we say V is
forgettable from K.
In the rest of this section, we state and discuss some important consequences of this
definition of forgetting for KBs in ALC . These properties provide evidence that the
defintion is appropriate.
Proposition 3.1. Let K be a KB in ALC and V a set of variables. If both K
in
ALC are results of forgetting about V in K, then K  K
This proposition says that the result of forgetting in ALC is unique up to KB equiva-
lence. Given this result, we write forget(K,V) to denote any result of forgetting about
V in K in ALC . In particular, forget(K,V) = K
is a result of forgetting
about V in K.
In fact, forgetting in TBoxes is independent of ABoxes as the next result shows.
Proposition 3.2. Let T be an ALC TBox and V a set of variables. Then,
any ALC ABox A, T 
forget((T ,),V).
For simplicity, we write forget(T ,V) for forget((T ,),V) and call it the result of
TBox-forgetting about V in T .

is the TBox of forget((T ,A),V) iff T 

for
is the TBox of

.

means that K

and K

The following result, which generalizes Proposition 3.1, shows that forgetting pre-

serves implication and equivalence relations between KBs.
Proposition 3.3. Let K1,K2 be two KBs in ALC and V a set of variables. Then
 K1 |= K2 implies forget(K1,V) |= forget(K2,V);
 K1  K2 implies forget(K1,V)  forget(K2,V).
However, the converse of Proposition 3.3 is not true in general. Consider K and K1 in
Example 3.2, it is obvious that forget(K,{B})  forget(K1,{B}). However, K and
K1 are not equivalent.

Consistency and query answering are two major reasoning tasks in description log-
ics. It is a key requirement for a reasonable definition of forgetting to preserve these
two reasoning forms.
Proposition 3.4. Let K be a KB in ALC and V a set of variables. Then
1. K is consistent iff forget(K,V) is consistent;
2. for any inclusion or assertion  not containing variables in V, K |=  iff

forget(K,V) |= .

The next result shows that the forgetting operation can be divided into steps, with a part
of the signature forgotten in each step.
Proposition 3.5. Let K be a KB in ALC and V1,V2 two sets of variables. Then we have

forget(K,V1  V2)  forget(forget(K,V1),V2).

To compute the result of forgetting about V in K, it is equivalent to forget the variables
in V one by one, i.e., forgetting can be computed incrementally.

K. Wang et al.

4 Forgetting in ALC Concept Descriptions

Forgetting in a concept description has been investigated under the name of uniform
interpolation in [20]. In this section, we reformulate the definition of the forgetting
about concept and role names in ALC concept descriptions (briefly, c-forgetting) and
introduce some results that will be used in the next section. From the view point of
ontology management, the issue of forgetting in concept descriptions is less important
than that for KBs and TBoxes. However, we will show later that c-forgetting can be
used to provide an approximation algorithm for KB-forgetting in ALC , as well as its
theoretical importance.
?

?

?
Intuitively, the result C

of forgetting about a set of variables from a concept description C should be weaker than C but as close to C as possible. For example, after
the concept Male is forgotten from a concept description for Male Australian stu-
dent Australians  Students  Male, then we should obtain a concept description
Australians  Students for Australian student. More specifically, C
should be a
concept description that defines a minimal concept description among all concept descriptions that subsume C and are syntactically irrelevant to V (i.e., variables in V do
not appear in the concept description).
Definition 4.1 (c-forgetting). Let C be a concept description in ALC and V a set
on the signature sig(C)  V is a result of c-
of variables. A concept description C
forgetting about V in C if the following conditions are satisfied:
(CF1) |= C  C
(CF2) For every ALC concept description C
implies |= C

)  V = , |= C  C
?

?

?
.
  C

with sig(C
?

?

?
.

.
?

?

?
and C

  C

The above (CF1) and (CF2) correspond to the conditions (2) and (3) of Theorem 8 in
[20]. A fundamental property of c-forgetting in ALC concept descriptions is that the
result of c-forgetting is unique under concept description equivalence.
Proposition 4.1. Let C be a concept description in ALC and V a set of variables. If
in ALC are results of c-forgetting about V in C,
two concept descriptions C
then |= C
As all results of c-forgetting are equivalent, we write forget(C,V) to denote an arbitrary
result of c-forgetting about V in C.
Example 4.1. Suppose the concept Research Student is defined by C = Student 
(Master "PhD)supervised .Professor where Master, PhD and Professor are
all concepts; supervised is a role and supervised(x, y) means that x is supervised by
y. If the concept description C is used only for students, we may wish to forget about
Student: forget(C, Student) = (Master " PhD)  supervised .Professor . If we do
not require that a supervisor for a research student must be a professor, then the filter
Professor can be forgotten: forget(C, Professor ) = Student  (Master " PhD) 
supervised ..
I =  for some interpretation I on sig(C). C
A concept description C is satisfiable if C
is unsatisfiable if |= C  . By Definition 4.1, c-forgetting also preserves satisfiability
of concept descriptions.
?

?

?
Proposition 4.2. Let C be a concept description in ALC , and V be a set of variables.
Then C is satisfiable iff forget(C,V) is satisfiable.
Similar to forgetting in KB, the c-forgetting operation can be divided into steps.
Proposition 4.3. Let C be a concept description in ALC and V1,V2 two sets of vari-
ables. Then we have

|= forget(C,V1  V2)  forget(forget(C,V1),V2).

Given the above result, when we want to forget about a set of variables, they can be
forgotten one by one. Also, the ordering of c-forgetting operation is irrelevant to the
result.
Corollary 4.1. Let C be a concept description in ALC and let V = {V1, . . . , Vn} be a
set of variables. Then, for any permutation (i1, i2, . . . , in) of {1, 2, . . . , n},

|= forget(forget(forget(C, Vi1), Vi2), . . .), Vin) 
forget(forget(forget(C, V1), V2), . . .), Vn).

The following result, which is not obvious, shows that c-forgetting distributes over
union ".
Proposition 4.4. Let C1, . . . , Cn be concept descriptions in ALC . For any set V of
variables, we have

|= forget(C1 "  " Cn,V)  forget(C1,V) "  " forget(Cn,V).

However, c-forgetting for ALC does not distribute over intersection . For example, if
the concept description C = A  A, then forget(C, A) = , since |= C  . But
forget(A, A)  forget(A, A)  .

An important reason for this is that c-forgetting does not distribute over negation.

Actually, we have

|= forget(C,V)  C  forget(C,V).

These subsumptions may be strict, e.g., if C is A B and V is {A}, then forget(C,V)
is B, but forget(C,V) is .

The next result shows that c-forgetting distributes over quantifiers. Since c-forgetting
does not distribute over negation, the two statements in the following proposition do
not necessarily imply each other. The proof uses tableau reasoning for ALC and is
surprisingly complex.
Proposition 4.5. Let C be a concept description in ALC , R be a role name and V be
a set of variables. Then
 forget(R.C,V) =  for R  V, and forget(R.C,V) = R.forget(C,V) for
 forget(R.C,V) =  for R  V, and forget(R.C,V) = R.forget(C,V). for

R  V;
R  V;
?

?

?
These results suggest a way of computing c-forgetting about set V of variables in a
complex ALC concept description C. That is, to forget about each variable V in V one
after another, and to distribute the c-forgetting computation to subconcepts of C.

In what follows, we introduce an algorithm for computing the result of c-forgetting
through rewriting of concept descriptions (syntactic concept transformations) [20]. This
algorithm consists of two stages: (1) C is first transformed into an equivalent disjunctive
normal form (DNF), which is a disjunction of conjunctions of simple concept descrip-
tions; (2) the result of c-forgetting about V in each such simple concept description is
obtained by removing some parts of the conjunct.
Before we introduce disjunctive normal form (DNF), some notation and definitions
are in order. We call an (atomic) concept A or its negation A a literal concept or
simply a literal. A pseudo-literal with role R is a concept description of the form R.F
or R.F , where R is a role name and F is an arbitrary concept. A generalized literal is
either a literal or a pseudo-literal.
Definition 4.2. A concept description D is in disjunctive normal form (DNF) if D = 
or D =  or D is a disjunction of conjunctions of generalized literals D = D1 " "
Dn, where each Di   (1  i  n) is a conjunction
R.(E
?

?

?
L of literals, or of the form
 UR)
?

?

?
R.UR  
?

?

?
L  
RR

(k)

k

(k)

 UR is

where R is the set of role names that occur in Di, and each UR and each E
a concept description in DNF.
We note that, to guarantee the correctness of the algorithm, the above DNF for ALC is
more complex than we have in classical logic and DL-Lite. See Example 4.2 for an
example of a concept description in DNF.
Each concept description in ALC can be transformed into an equivalent one in DNF
by the following two steps: (1) first transform the given concept description into a disjunction of conjunctions of pseudo-literals using De Morgans laws, distributive laws
and necessary simplifications, and then (2) for each conjunction in the resulting concept
description, perform the following three transformations in order:

C ; R.  C,

for C = R.C1    R.Cm, m > 0

R.C1  R.C2 ; R.C1  R.(C1  C2)

R.C1    R.Cn ; R.(C1    Cn).

The first transformation above is to transform a concept description containing only
existential quantifier into the normal form. For example, if C is concept name, R.C,
which is not in normal form, can be transformed into the normal form R.  R.C.
While the second is to assemble several quantifications with the same role name into a
single one, the third is crucial for guaranteeing the correctness of our algorithm.
Once an ALC concept description D is in the normal form, the result of c-forgetting
about a set V of variables in D can be obtained from D by simple symbolic manipulations (ref. Algorithm 1).

According to Algorithm 1, an input concept description must first be transformed
into the normal form before the steps for forgetting are applied. For instance, if we
?

?

?
Algorithm 1. (Compute c-forgetting)
Input: An ALC concept description C and a set V of variables in C.
Output: forget(C,V).
Method:
Step 1. Transform C into its DNF D. If D is  or , return D; otherwise, let D = D1 Dn
as in Definition 4.2.
Step 2. For each conjunct E in each Di, perform the following transformations:
 if E is a literal of the form A or A with A  V, replace E with ;
 if E is a pseudo-literal in the form of R.F or R.F with R  V, replace E with ;
 if E is a pseudo-literal in the form of R.F or R.F where R  V, replace F with

forget(F,V), and replace each resulting R.(  F ) with .
Step 3. Return the resulting concept description as forget(C,V).

Fig. 1. Forgetting in concept descriptions

want to forget A in the concept description D = A  A  B, D is transformed into
the normal form, which is , and then obtain forget(D, A) = . We note that B is not
a result of forgetting about A in D.
Example 4.2. Given a concept D = (A " R.B)  R.(B " C), we want to forget
about concept name B in D. In Step 1 of Algorithm 1, D is firstly transformed into its
 = [AR.(B " C)]" [R.(B " C)R.(B  C)]. Note that R.(B  C)
DNF D
is transformed from R.[B  (B " C)]. Then in Step 2, each occurrence of B in D

is replaced by , and R.( " F ) is replaced with . We obtain forget(D,{B}) =
A " R.C. To forget about role R in D, Algorithm 1 replaces each pseudo-literals in
?

?

?
of the form R.F or R.F with , and returns forget(D,{R}) = .

Obviously, the major cost of Algorithm 1 is from transforming the given concept description into its DNF. For this reason, the algorithm is exponential time in the worst
case. However, if the concept description C is in DNF, Algorithm 1 takes only linear
time (w.r.t. the size of C) to compute the result of c-forgetting about V in C. And the
result of c-forgetting is always in DNF.
Theorem 4.1. Let V be a set of concept and role names and C a concept description
in ALC . Then Algorithm 1 always returns forget(C,V).
The proof of this theorem uses the tableau for ALC .
5 Approximate Forgetting in ALC Ontologies
As we showed in Section 3, the result of forgetting for an ALC KB might not exist.
However, if our goal is to determine whether a given set  of inclusions and assertions
are logical consequences of the result of forgetting for a KB K, we show in this section
how to determine this without computing the result of forgetting at all. Instead, given an

K. Wang et al.

upper bound on the size of the inclusions and assertions in , we show how to compute
a finite KB K
such that K |=  if and only if K |= . Here, we assume  does
not contain any of the variables that are being forgotten. The finite KB K
is called
an approximation to the result of forgetting for K. In fact, we show how to compute
a sequence of approximations that can determine whether inclusions and assertions
of increasingly large size are logical consequences of the result of forgetting. These
approximations are computed using Algorithm 1 for c-forgetting. We can thus obtain the
benefits of forgetting, by computing a smaller KB, and performing reasoning, without
having to actually compute the (non-existent) result of forgetting.
As a special case, we first introduce an approximation to TBox-forgetting. Example 3.2 shows that, for some TBox T , forget(T ,V) may not be expressible as a finite
ALC TBox. Thus, it is natural to consider a sequence of (finite) TBoxes that approximate the result of forgetting in T in the sense that the sequence is non-decreasing in
terms of logical implication and the limit of the sequence is the result of forgetting. Such
a consequence is constructed by using results developed for c-forgetting in Section 4.
We note that, for an inclusion C  D in T , forget(C,V)  forget(D,V) may not be
a logical consequence of T and thus may not be in forget(T ,V). However, if we trans-

form T into an equivalent singleton TBox {  CT }, where CT =
CDT (C "
D), then inclusion 0 of the form   forget(CT ,V) is a logical consequence of
T . In general, the singleton TBox {0} is not necessarily equivalent to forget(T ,V).
However, it can be a starting point of a sequence whose limit is forget(T ,V). Note
that T is also equivalent to {  CT  R.CT } for an arbitrary role name R in T .
Hence, inclusion 1 of the form   forget(CT R.CT ,V) is a logical consequence
of T , and it can be shown that TBox {1} is logically stronger then {0}. That is,
forget(T ,V) |= {1} |= {0}. Let 2 be   forget(CT  R.CT  R.R.CT ,V),
then we have forget(T ,V) |= {2} |= {1} |= {0}. In this way, we can construct a
sequence of TBoxes with increasing logical strength, whose limit is forget(T ,V).

For n  0, define

(n)T =

n
?

?

?
k=0

R1,...,RkR

R1 Rk.CT

where CT =
?

?

?
CDT (C " D) and R is the set of role names in K.

We now define a sequence of TBoxes, which essentially provides an approximation

forgetn(T ,V) = {   forget(C

to the result of TBox-forgetting.
Definition 5.1. Let T be an ALC TBox and V be a set of variables. For each n  0,
the TBox
is called the n-forgetting about V in T .
Note that the above n-forgetting for TBoxes is defined in terms of forgetting in concept
descriptions (c-forgetting).
Example 5.1. Consider the TBox T in Example 3.2, we have CT = (A " B) 
(B " C)  (C " R.C)  (C " D), and C
(1)T = CT  R.CT , . . . ,
(n1)
(n)T = CT  R.C
?

?

?
(0)T = CT , C

(n)T ,V)}

(n  2).
?

?

?
Let V = {B, C}. For each n  0, the forgetn(T ,V) can be computed as follows.
forget0(T ,V) = {   A " D }, which is equivalent to { A  D }.
forget1(T ,V) = {   A " (D  R.D)}, which is { A  D, A  R.D }.
#

forgetn(T ,V) = { A  D, A  R.D, . . . , A  R.R R
$

the conjunction of assertions C1(a), . . . , Cn(a) while

i=1 Ci)(a) is called the disjunction of these assertions.
Before we can perform forgetting on a given ABox, we need to preprocess it and

i=1 Ci)(a)
?

?

?
n
(

.D }.

We call
(

n

 

!"

n Rs

thus transform it into a normal form. To this end, we give the following definition.
Definition 5.2. An ABox A in ALC is complete if for any individual name a in A and
assertion C(a) with A |= C(a), we have |= C
(a) is the conjunction of
all the concept assertions about a in A.
For example, ABox A = {R.A(a), R(a, b)} is incomplete, because A |= A(b)
whereas no assertion C(b) exists in A such that |= C  A. After adding assertions
A(b), R.A(a) and (a) into A, the resulting ABox is complete.

  C, where C

In complete ABoxes, concept assertion entailment can be reduced to concept sub-

sumption, and is independent of role assertions.
However, there exist incomplete ABoxes that are not equivalent any (finite) complete
(b, a)} has infinitely many logical conse-
ABox. For example, the ABox {R(a, b), R
quences of the form (R.R
.C " C)(a) where C is an arbitrary concept description.
This kind of situations are caused by certain cycles in ABoxes. We say an ABox is
acyclic if there exists no cycle of the form R1(a, a1), R2(a1, a2), . . . , Ri(ai, a) in A
in the ABox. Many practical ABoxes are acyclic or can be transformed to equivalent
acyclic ABoxes.
?

?

?
Note all the role assertions in an acyclic ABox form tree-shape relations between
individuals. We call an individual without any predecessor a root individual, and that
without any successor a leaf individual.
Algorithm 2 is developed to transform a given acyclic ALC ABox into an equivalent
complete ABox. The correctness of the algorithm shows that any acyclic ABox can be
transformed to an equivalent complete ABox in ALC .

Note that Algorithm 2 always terminates.

that is equivalent to A.

Lemma 5.1. Given an acyclic ALC ABox A, Algorithm 2 always returns a complete
ABox A
With the notion of complete ABox, we can extend n-forgetting in TBoxes and define
n-forgetting for an ALC KB as follows.
For the remainder of this section, we assume that the ABox of every KB K is acyclic.
Definition 5.3. Let K = (T ,A) be an ALC KB and V a set of variables. For each
,A) is called the result of n-forgetting about V in
n  0, the KB forgetn(K,V) = (T 
K, where T  = forgetn(T ,V) = {   forget(C
is obtained from A
through the following steps:

(n)T ,V)} and A

K. Wang et al.

.

Algorithm 2. (Complete an acyclic ABox)
Input: An acyclic ALC ABox A.
Output: An equivalent complete ALC ABox A
Method:
$n
Step 1. Starting from root individuals, for each individual a and each role assertion R(a, b) in A,
$n
let C(a) be the conjunction of all the concept assertions about a in A.
i=1 Di as in Definition 4.2. Let R.Ui be the universal quanTransform C into its DNF C =
i=1 Ui)(b) to A.
tified conjunct of R in Di. Add (
Step 2. For each individual a in A, add (a) to A.
Step 3. Starting from leaf individuals, for each individual b and each role assertion R(a, b) in A,
add assertion (R.E)(a) to A, where E(b) is the conjunction of all the concept assertions about
b in A.
Step 4. Return the resulting ABox.

Fig. 2. Transform an acyclic ABox into a complete ABox

1. For each individual name a in A, add C
2. Apply Algorithm 2 to obtain a complete ABox, still denoted A.
3. For each individual name a in A, replace C(a) with (forget(C,V))(a), where C(a)
is the conjunction of all the concept assertions about a in A.
4. Remove each R(a, b) from A where R  V.

(n)T (a) to A.

The basic idea behind Definition 5.3 is to transform the given KB into a new KB such
that forgetting can be done in its ABox and TBox, separately, in terms of c-forgetting
for individual assertions and inclusions.
Example 5.2. Consider the KB K = (T ,A) in Example 3.2 and let V = {B, C}.
putation of A0 as follows: Note that A is acyclic. First C
into A, where C
the resulting ABox is equivalent to

For each n  0, let An be the ABox of forgetn(K,V). We will elaborate the com-
(0)T (b) are added
is the same as in Example 5.1. After applying Algorithm 2 to A,

(0)T (a) and C

(n)T

{ (B  C  R.C  D)(a), R(a, b), ((A " B)  C  R.C  D)(b),
R.((A " B)  C  R.C  D)(a) }

By applying c-forgetting to the conjunctions of concept assertions about, respectively,
a and b, we obtain A0 = { D(a), R(a, b), D(b)}.

Similarly, we can compute A1, . . . ,An as:
 
 

A1 = { D(a), (R.D)(a), R(a, b), D(b), (R.D)(b)}.
#
An = { D(a), (R.D)(a), . . . , (R.R R
.D)(a), R(a, b),
#
D(b), (R.D)(b), . . . , (R.R R
.D)(b)}.

!"
!"



n Rs

n Rs
?

?

?
C(a)A |C|. Then for a KB K = (T ,A), |K| = |T | + |A|.

The following result shows that n-forgetting preserves logical consequences of the
original KB.

Given a concept description C, let |C| be the number of all different subconcepts of
CDT (|C|+|D|). Similarly, for an ABox A, define
C. For a TBox T , define |T | =
|A| =
Proposition 5.1. Let K be an ALC KB and V be a set of variables. Then forgetn(K,V)
satisfies the following conditions:
1. K |= forgetn(K,V).
2. Let C and D be two concept descriptions containing no variable in V. If n 
3. Let C be a concept description containing no variable in V, and a an individual
4. Let R be a role name not in V, and a, b two individual names in K. Then K |=

2|C|+|D|+|K|
name in K. If n  2|C|+|K|
R(a, b) iff forgetn(K,V) |= R(a, b).

, then K |= C  D iff forgetn(K,V) |= C  D.

, then K |= C(a) iff forgetn(K,V) |= C(a).

Recall from the definition of KB-forgetting that, with respect to inclusions and assertions not containing variables in V, K is logically equivalent to forget(K,V). Proposition 5.1 tells us that if we know which inclusions and assertions not containing variables
in V we wish to reason about in advance, then we can derive a value for n, compute
forgetn(K,V), and use the fact that, with respect to these inclusions and assertions,
forgetn(K,V) is logically equivalent to K and hence to forget(K,V). In this way, we
can use forgetn(K,V) as a practical approximation to forget(K,V).
The above proposition shows that, for any n  0, each forgetn(K,V) is logically
weaker than forget(K,V). Also, as the number n is sufficiently large, forgetn(K,V)
preserves more and more consequences of K. Therefore, the sequence of KBs
{forgetn(K,V)}n0 is non-decreasing w.r.t. semantic consequence as the next proposition shows.
Proposition 5.2. Let K be an ALC KB and V a set of variables. Then, for any n  0,
we have forgetn+1(K,V) |= forgetn(K,V).
Based on the above two results, we can show the main theorem of this section as fol-
lows, which states that the limit of the sequence of n-forgettings captures the result of
forgetting.
Theorem 5.1. Let K be an ALC KB and V a set of variables. Then

%

forget(K,V) =

forgetn(K,V).

n=0

So, by Theorem 5.1, we can compute forget(K,V), if it exists, using algorithms introduced in the paper.
Corollary 5.1. Let K be an ALC KB and V be a set of variables. V is forgettable from
K if and only if there exists N  0 such that forgetn(K,V)  forgetN (K,V) for all
n  N . In this case, forget(K,V) = forgetN (K,V).

K. Wang et al.

As we can see from Example 3.2, the sizes of consequences (assertions and inclusions)
of K not containing variables in V do not have an upper bound. If it does not exist,
we can always choose n large enough to approximate forget(K,V). However, two
issues are still unclear to us: First, the computation of forgetn+1(K,V) is not based
on forgetn(K,V). Next, it would be interesting to find a way to measure how close
forgetn(K,V) is from forget(K,V).

6 Conclusion

We have presented a theory and methods for forgetting for knowledge bases in the expressive description logic ALC . This is the first work that deals with the combination or
concepts and roles, nonempty ABoxes, and ALC . Because the result of forgetting may
not exist for ALC knowledge bases, we define a sequence of finite knowledge bases
that approximate the result of forgetting and serve as a basis for query answering over
the ontology with forgotten concepts and roles. We provide algorithms for computing
these approximations, using algorithms for forgetting for concept descriptions, and note
their correctness. Proofs of our results may be found in an online report.
Many interesting problems remain unsolved. It would be useful to clarify the decision problem of whether the result of forgetting for an ALC knowledge base exists. It
would be useful to extend the results of this paper to even more expressive description
logics. It would be interesting to find lower bounds on the complexity of forgetting
for description logics. It would be useful to find an incremental algorithm for computing approximations. It would be useful implement our algorithms and incorporate them
into ontology editors such as Prot eg e [28]. See http://www.cit.gu.edu.au/
 kewen/DLForget for our progress on this task.
