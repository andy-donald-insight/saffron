Link Discovery with Guaranteed Reduction

Ratio in Affine Spaces with Minkowski Measures

Axel-Cyrille Ngonga Ngomo

Department of Computer Science

University of Leipzig

Johannisgasse 26, 04103 Leipzig

ngonga@informatik.uni-leipzig.de

http://bis.uni-leipzig.de/AxelNgonga

Abstract. Time-efficient algorithms are essential to address the complex linking tasks that arise when trying to discover links on the Web of
Data. Although several lossless approaches have been developed for this
exact purpose, they do not offer theoretical guarantees with respect to
their performance. In this paper, we address this drawback by presenting
the first Link Discovery approach with theoretical quality guarantees. In
particular, we prove that given an achievable reduction ratio r, our Link
  r in a metric
Discovery approach HR3 can achieve a reduction ratio r
space where distances are measured by the means of a Minkowski metric
of any order p  2. We compare HR3 and the HYPPO algorithm implemented in LIMES 0.5 with respect to the number of comparisons they
carry out. In addition, we compare our approach with the algorithms implemented in the state-of-the-art frameworks LIMES 0.5 and SILK 2.5
with respect to runtime. We show that HR3 outperforms these previous approaches with respect to runtime in each of our four experimental
setups.

Introduction

One of the key principles of the Linked Data paradigm is the inclusion of links
between data sets [1]. While this principle is central for tasks such as federated
querying [20], cross-ontology question answering [12], large-scale inferences [22]
and data integration [3], it is increasingly tedious to implement manually. One of
the main difficulty behind the discovery of links is its intrinsic time complexity.
Over the last five years, the Linked Data Web has evolved from 12 knowledge
bases (May 2007) to more than 295 knowledge bases in September 2011 which
contain more than 31 billion triples1. The combination of the mere size of these
knowledge bases and the quadratic a-priori time complexity of Link Discovery leads to brute-force algorithms requiring weeks and even longer to compute
links between large knowledge bases such as DBpedia2 and LinkedGeoData3.

http://www4.wiwiss.fu-berlin.de/lodcloud/state/
http://dbpedia.org
http://linkedgeodata.org

P. Cudr e-Mauroux et al. (Eds.): ISWC 2012, Part I, LNCS 7649, pp. 378393, 2012.
c Springer-Verlag Berlin Heidelberg 2012

Addressing this challenge demands the development of time-efficient and lossless solutions for the computation of links. Link Discovery frameworks such as
LIMES [15,14] and SILK [9] have been designed to address this challenge. Yet,
none of the manifold approaches they implement provides theoretical guarantees
with respect to their performance. Thus, so far, it was impossible to predict how
Link Discovery frameworks would perform w.r.t. time or space requirements.
Consequently, the deployment of techniques such as customized memory management [5] or time-optimization strategies [23] (e.g., automated scaling for cloud
computing when provided with very complex linking tasks) was rendered very
demanding if not impossible.
In this paper, we introduce the novel approach HR3. Similar to the HYPPO
algorithm [14] (on whose formalism it is based), HR3 assumes that the property
values that are to be compared are expressed in an affine space with a Minkowski
distance. Consequently, it can be most naturally used to process the portion of
link specifications that compare numeric values (e.g., temperatures, elevations,
populations, etc.). HR3 goes beyond the state of the art by being able to carry
out Link Discovery tasks with any achievable reduction ratio [6]. This theoretical
guarantee is of practical importance, as it does not only allow our approach to
be more time-efficient than the state of the art but also lays the foundation for
the implementation of customized memory management and time-optimization
strategies for Link Discovery. The three main contributions of this paper are
thus as follows:

1. We present a novel indexing scheme for hypercubes in metric spaces with
Minkowski distances. This scheme builds the basis upon which HR3 discards
unnecessary comparisons.
2. We prove formally that HR3s reduction ratio can be made arbitrarily close
to the optimal reduction ratio. For this purpose, we first define the relative
reduction ratio (RRR). We then show that HR3s RRR converges towards
a lower bound and prove this bound to be exactly 1.

3. We show experimentally that in addition to providing theoretical guarantees,
our approach outperforms the state of the art. For this purpose, we compare
the number of comparisons carried out by HR3 and HYPPO. In addition, we
compare HR3s runtime with that of HYPPO (as implemented in LIMES)
and SILK4.

The rest of this paper is structured as follows: In Section 2, we present preliminaries and the notation used to formalize our approach HR3. We also introduce
the relative reduction ratio RRR. We then prove that our algorithm can achieve
any RRR score larger than 1 and that we can therewith achieve any possible
reduction ratio (Section 3). After a short presentation of the implementation of
our algorithm in Section 4, we evaluate our approach against SILK and HYPPO
in four experiments in Section 5. Subsequently, in Section 6, we give an overview
of previous approaches to Link Discovery. Finally, we discuss our findings and
conclude in Section 7.
4 The algorithm was implemented in the new verison of LIMES, of which a demo is

available at http://limes.aksw.org

A.-C. Ngonga Ngomo

2 Preliminaries

In this section, we present the preliminaries necessary to understand the subsequent parts of this work. In particular, we define the problem of Link Discovery,
the reduction ratio and the relative reduction ratio formally as well as give an
overview of space tiling for Link Discovery. The subsequent description of HR3
relies partly on the notation presented in this section.

2.1 Link Discovery
The goal of Link Discovery is to compute the set of pair of instances (s, t)  ST
that are related by a relation R, where S and T are two not necessarily distinct
sets of instances. One way to automate this discovery is to compare the s  S
and t  T based on their properties using a distance measure. Two entities are
then considered to be linked via R if their distance is less or equal to a threshold
 [15].

Definition 1 (Link Discovery on Distances). Given two sets S and T of
instances, a distance measure  over the properties of s  S and t  T and a
distance threshold   [0,[, the goal of Link Discovery is to compute the set
M = {(s, t, (s, t)) : s  S  t  T  (s, t)  }.
Note that in this paper, we are only interested in lossless solutions, i.e., solutions
that are able to find all pairs that abide by the definition given above.

2.2 Reduction Ratio

A brute-force approach to Link Discovery would execute a Link Discovery task
on S and T by carrying out |S||T| comparisons. One of the key ideas behind timeefficient Link Discovery algorithms A is to reduce the number of comparisons
that are effectively carried out to a number C(A) < |S||T| [21]. The reduction
ratio RR of an algorithm A is given by

RR(A) = 1  C(A)
|S||T| .

(1)
RR(A) captures how much of the Cartesian product |S||T| was not explored
before the output of A was reached. It is obvious that even an optimal lossless
solution which performs only the necessary comparisons cannot achieve a RR of
1. Let Cmin be the minimal number of comparisons necessary to complete the
Link Discovery task without losing recall, i.e., Cmin = |M|. We define the relative
reduction ratio RRR(A) as the proportion of the minimal number of comparisons
that was carried out by the algorithm A before it terminated. Formally

RRR(A) =

1  Cmin
|S||T|
1  C(A)
|S||T|

|S||T|  Cmin
|S||T|  C(A)

.

=

(2)

RRR(A) indicates how close A is to the optimal solution with respect to the
number of candidates it tests. Given that C(A)  Cmin, RRR(A)  1. Note
that the larger the value of RRR(A), the poorer the performance of A with
respect to the task at hand.

The main observation that led to this work is that while most algorithms
aim to optimize their RR (and consequently their RRR), current approaches to
Link Discovery do not provide any guarantee with respect to the RR (and consequently the RRR) that they can achieve. In this work, we present an approach
to Link Discovery in metric spaces whose RRR is guaranteed to converge to 1.

2.3 Space Tiling for Link Discovery
Our approach, HR3, builds upon the same formalism on which the HYPPO
algorithm relies, i.e., space tiling. HYPPO addresses the problem of efficiently
mapping instance pairs (s, t)  S  T described by using exclusively numeric
values in a n-dimensional metric space and has been shown to outperform the
state of the art in previous work [14]. The observation behind space tiling is
that in spaces (, ) with orthogonal, (i.e., uncorrelated) dimensions5, common
metrics for Link Discovery can be decomposed into the combination of functions i,i{1...n} which operate on exactly one dimension of  :  = f (1, ..., n).
For Minkowski distances of order p, i(x, ) = |xi  i| for all values of i and
p
i (x, )p. A direct consequence of this observation is the inequality i(x, )  (x, ). The basic insight that results this observation is that the
hypersphere H(, ) = {x   : (x, )  } is a subset of the hypercube V defined as V (, ) = {x   : i  {1...n}, i(xi, i)  }. Consequently, one can

(x, ) = p

"

n

i=1

reduce the number of comparisons necessary to detect all elements of H(, ) by
discarding all elements which are not in V (, ) as non-matches. Let  = /,
where   N is the granularity parameter that controls how fine-grained the
space tiling should be (see Figure 1 for an example). We first tile  into the
adjacent hypercubes (short: cubes) C that contain all the points  such that

i  {1...n}, ci  i < (ci + 1) with (c1, ..., cn)  Nn.

(3)

We call the vector (c1, ..., cn) the coordinates of the cube C. Each point  
 lies in the cube C() with coordinates (i/()i=1...n. Given such a space
i  {1...n} : |ci  c()i|  .

tiling, it is obvious that V (, ) consists of the union of the cubes such that

Like most of the current algorithms for Link Discovery, space tiling does not
provide optimal performance guarantees. The main goal of this paper is to build
upon the tiling idea so as to develop an algorithm that can achieve any possible
RR. In the following, we present such an algorithm, HR3.

5 Note that in all cases, a space transformation exists that can map a space with

correlated dimensions to a space with uncorrelated dimensions.

A.-C. Ngonga Ngomo
?

?

?
(a)  = 1
?

?

?
(b)  = 2
?

?

?
(c)  = 4

Fig. 1. Space tiling for different values of . The colored squares show the set of
elements that must be compared with the instance located at the black dot. The points
within the circle lie within the distance  of the black dot. Note that higher values of
 lead to a better approximation of the hypersphere but also to more hypercubes.

3 Approach
The goal of the HR3 algorithm is to efficiently map instance pairs (s, t)  S  T
that are described by using exclusively numeric values in a n-dimensional metric
space where the distances are measured by using any Minkowski distance of order
p  2. To achieve this goal, HR3 relies on a novel indexing scheme that allows
achieving any RRR greater than or equal to than 1. In the following, we first
present our new indexing scheme and show that we can discard more hypercubes
than simple space tiling for all granularities  such that n( 1)p > p. We then
prove that by these means, our approach can achieve any RRR greater than 1,
therewith proving the optimality of our indexing scheme with respect to RRR.

3.1 Indexing Scheme
Let    = S  T be an arbitrary reference point. Furthermore, let  be the
Minkowski distance of order p. We define the index function as follows:

0 if i : |ci  c()i|  1 with i  {1, ..., n},
n

(|ci  c()i|  1)p else,

index(C, ) =

(4)

i=1

where C is a hypercube resulting from a space tiling and   . Figure 2 shows
an example of such indexes for p = 2 with  = 2 (Figure 2(a)) and  = 4
(Figure 2(b)).

Note that the blue square with index 0 contains the reference point . Also
note that our indexing scheme is symmetric with respect to C(). Thus, it is
sufficient to prove the subsequent lemmas for hypercubes C such that ci > c()i.
In Figure 2, this is the upper right portion of the indexed space with the gray
?

?

?
(a)  = 2

(b)  = 4

Fig. 2. Space tiling and resulting index for a two-dimensional example. Note that the
index in both subfigures was generated for exactly the same portion of space. The black
dot stands for the position of .

background. Finally, note that the maximal index that a hypercube can achieve

is n(  1)p as max|ci  ci()| =  per construction of H(, ).

The indexing scheme proposed above guarantees the following:
Lemma 1. index(C, ) = x  s  C() t  C p(s, t) > xp.

Proof. This lemma is a direct implication of the construction of the index.
index(C, ) = x implies that

n

(ci  c()i  1)p = x.

i=1

Now given the definition of the coordinates of a cube (Eq. 3), the following holds:

s  C() t  C |si  ti|  (|ci  c()i|  1).

Consequently,

s  C() t  C

n

i=1

|si  ti|p  n

i=1

(|ci  c()i|  1)pp.

By applying the definition of the Minkowski distance of the index function, we
finally get s  C() t  C p(s, t) > xp.

Note that given that   C(), the following also holds:

index(C, ) = x  t  C : p(, t) > xp.

(5)

A.-C. Ngonga Ngomo

3.2 HR3
The main insight behind HR3 is that in spaces with Minkowski distances, the
indexing scheme proposed above allows to safely (i.e., without dismissing correct
matches) discard more hypercubes than when using simple space tiling. More
specifically,
Lemma 2. s  S : index(C, s) > p implies that all t  C are non-matches.

Proof. This lemma follows directly from Lemma 1 as

index(C, s) > p  t  C, p(s, t) > pp = p.

(6)

For the purpose of illustration, let us consider the example of  = 4 and p = 2
in the two-dimensional case displayed in Figure 2(b). Lemma 2 implies that any
point contained in a hypercube C18 with index 18 cannot contain any element t
such that (s, t)  . While space tiling would discard all black cubes in Figure
2(b) but include the elements of C18 as candidates, HR3 discards them and still
computes exactly the same results, yet with a better (i.e., smaller) RRR.
One of the direct consequences of Lemma 2 is that n(  1)p > p is a
necessary and sufficient condition for HR3 to achieve a better RRR than simple
space tiling. This is simply due to the fact that the largest index that can be
( 1)p = n( 1)p. Now, if n( 1)p > p, then
this cube can be discarded. For p = 2 and n = 2 for example, this condition is
satisfied for   4. Knowing this inequality is of great importance when deciding
on when to use HR3 as discussed in Section 5.
Let H(, ) = {C : index(C, )  p}. H(, ) is the approximation of the
hypersphere H() = {
)  } generated by HR3. We define the
volume of H(, ) as

assigned to a hypercube is
?

?

?
n

i=1
?

?

?
: (, 
V (H(, )) = |H(, )|p.

(7)
To show that given any r > 1, the approximation H(, ) can always achieve a
an RRR(HR3)  r, we begin by showing that
Lemma 3.  > 1 V (H(, )) > V (H(2, )).
Proof. Any cube C discarded by HR3() is split into 2n cubes C by HR3(2),
each of which has the coordinates 2ci or 2ci + 1. In the worst case for HR3,
 is assigned the coordinates 2ci() + 1. Figure 3 exemplifies this property of
our indexing scheme. Figure 3(b) is an indexing of the same space with the the
twofold granularity.
When processed by HR3(2), the minimal index of a hypercube C is then

given by

min index(C) =

n

n

(2ci  (2ci() + 1)  1)p =

2p(ci  c()  1)p.

i=1

i=1

(0,1) 

(1,1) 

(0,0) 

(1,0) 

(-1,2)  (0,2) 

(1,2) 

(2,2) 

(-1,1)  (0,1) 

(1,1) 

(2,1) 

(-1,0) 

(0,0) 

(1,0) 

(2,0) 

(-1,-1)  (0,-1) 

(1,-1)  (2,-1) 

(a) Initial coordinates

(b) Coordinates with twofold granularity

Fig. 3. Commparison of coordinates for granularities  and 2

Given that C was discarded, we know that

(cici()1) > p. Consequently,

i=1

min index(C) > (2)p.

n
?

?

?
This leads to all C that were discarded by HR3() also being discarded by
HR3(2). Proving our lemma is consequently equivalent to showing that there
  H(, ) that is such that one of the 2n cubes Q it is split
is a hypercube C
into gets discarded by HR3(2). An example of such a case for p = 2 and n = 2
is shown in Figures 4(a) and 4(b). For  = 4, the cubes that are adjacent to the
corner and do not lie on the diagonal of the square are not excluded. Yet, for
 = 8, 2 of the hypercubes in which they are split are discarded.

Let C = (c1, ..., cn) / H(, ) while C

= (c1  1, ..., cn)  H(, ). In the
following, we show that the hypercube Q = (2c1  1, 2c2 + 1, ..., 2cn + 1), which
n
gets split into by virtue of its coordinates,6 will
is one of the hypercubes that C
be discarded by HR3(2), i.e., Q / H(, 2).
n
(ci  ci()  1)p > p.
n
Now, min index(Q) = (2c1  (2c1() + 1) 1)p +
(2ci + 1 (2ci() + 1) 1)p.
[2(ci  ci()  1) + 1]p.
Consequently, min index(Q) = 2p(c1  c1()  1)p +
n
[2(ci  ci() 1)]p. From the premise that
(ci  ci()  1)p > p, we can finally infer that min index(Q) > (2)p. Thus,
we can conclude that  > 1 V (H(, )) > V (H(2, )).

One of the consequences of Lemma 2 w.r.t. RRR(HR3, ), i.e., the RRR achieved
by HR3 when the granularity is set to , is

We know that C = (c1, ..., cn) gets discarded, i.e.,

This value is obviously larger than

i=2

i=1

i=2

n

i=1

i=1

 > 1 : RRR(HR3, ) > RRR(HR3, 2).

(8)

6 Note that 2c1  1 = 2(c1  1) + 1.

A.-C. Ngonga Ngomo

Note that this inequality is not sufficient to prove that we can achieve any RRR
greater than 1, as series can converge to any real number. Consequently, we still
need to show the following:

Lemma 4.

 RRR(HR3, ) = 1.

lim

Proof. The cubes that are not discarded by HR3() are those for which (|ci 
ci()|  1)p  p. When   ,  becomes infinitesimally small, leading to

the cubes being single points. Each cube C thus contains a single point x with
coordinates xi = ci. Especially, ci() = . Consequently,

|xi  i|  

 p  p.

Given that  = , we get

i=1



i=1

n

(|ci  ci()|  1)p  p  n
|xi  i|  
 p  p  n
n
(|xi  i|  )p  p      n

n

i=1

i=1



Finally,   0 when    leads to

(9)

(10)

(|xi  i|  )p  p.

|xi  i|p  p.

(11)

i=1

i=1

This is exactly the condition for linking specified in Definition 1 applied to
Minkowski distances of order p. Consequently, H(,) is exactly H(, ) for
any . Thus, the number of comparisons carried out by HR3() when   

is exactly Cmin, which leads to the conclusion lim

 RRR(HR3, ) = 1.

Our conclusion is illustrated by Figure 4, which shows the approximations computed by HR3 for different values of  with p = 2 and n = 2. The higher , the
closer the approximation is to a circle. Note that these results allow to conclude
that for any RRR-value r larger than 1, there is a setting of HR3 that can
compute links with a RRR smaller or equal to r.

Implementation

The HR3 algorithm was implemented as shown in Algorithm 1. It is important
to notice that the memory requirements of HR3 are smaller than those of most
other approaches and especially than those of simple space tiling for any  such
that n( 1)p > p, as HR3 then generates less hypercubes. Yet, HR3 requires
one supplementary computational step as it has to compute the index of cubes
before discarding the unnecessary ones. Consequently, although we have shown
that HR3 can achieve any RRR > 1, the question that remains to elucidate
is whether this theoretical guarantee also offers a practically superior algorithm
w.r.t. its runtime. That is the goal of the subsequent evaluation.

(a)  = 4

(b)  = 8

(c)  = 10

(d)  = 25

(e)  = 50

(f)  = 100

Fig. 4. Approximation generated by HR3 for different values of . The white squares
are selected whilst the colored ones are discarded.

5 Evaluation

5.1 Experimental Setup
We carried out four experiments to compare HR3 with LIMES 0.5s HYPPO
and SILK 2.5.1. In the first and second experiments, we aimed to deduplicate
DBpedia places by comparing their names (rdfs:label), minimum elevation,
elevation and maximum elevation. We retrieved 2988 entities that possessed
all four properties. We use the Euclidean metric on the last three values with
the thresholds 49 meters resp. 99 meters for the first resp. second experiment.
The third and fourth experiments aimed to discover links between Geonames
and LinkedGeoData. Here, we compared the labels (rdfs:label), longitude and
latitude of the instances. This experiment was of considerably larger scale than
the first one, as we compared 74458 entities in Geonames with 50031 entities
from LinkedGeoData. Again, we measured the runtime necessary to compare
the numeric values when comparing them by using the Euclidean metric. We
in experiment 3 resp. 4. We ran all
set the distance thresholds to 1 resp. 9
experiments on the same Windows 7 Enterprise 64-bit computer with a 2.8GHz
i7 processor with 8GB RAM. The JVM was allocated 7GB RAM to ensure that
the runtimes were not influenced by swapping. Only one of the kernels of the
processors was used. Furthermore, we ran each of the experiments three times
and report the best runtimes in the following.



A.-C. Ngonga Ngomo

Algorithm 1. The HR3 algorithm

Require: Source knowledge base S, target knowledge base T , distance threshold ,

Minkowski distance  of order p, granularity factor 
Mapping M := 
 = /
for   S  T do

C(1/, ..., n/) := C(1/, ..., n/)  {}

end for
for s  S do

for C  H(s, ) do
for t  C  T do

if (s, t)   then

M := M  (s, t, (s, t))

end if
end for

end for

end for
return M

5.2 Results
We first measured the number of comparisons required by HYPPO and HR3
to complete the tasks at hand (see Figure 5). Note that we could not carry out
this section of the evaluation for SILK2.5.1 as it would have required altering
the code of the framework. In the experiments 1, 3 and 4, HR3 can reduce the
overhead in comparisons (i.e., the number of unnecessary comparisons divided by
the number of necessary comparisons) from approximately 24% for HYPPO to
approximately 6% (granularity = 32). In experiment 2, the overhead is reduced
from 4.1% to 2%. This difference in overhead reduction is mainly due to the
data clustering around certain values and the clusters having a radius between
49 meters and 99 meters. Thus, running the algorithms with a threshold of 99
meters led to only a small a-priori overhead and HYPPO performing remarkably
well. Still, even on such data distributions, HR3 was able to discard even more
data and to reduce the number of unnecessary computations by more than 50%
relative. In the best case (Exp. 4,  = 32, see Figure 5(d)), HR3 required
approximately 4.13  106 less comparisons than HYPPO for  = 32. Even for
the smallest setting (Exp. 1, see Figure 5(a)), HR3 still required 0.64  106 less
comparisons.
We also measured the runtimes of SILK, HYPPO and HR3. The best runtimes
of the three algorithms for each of the tasks is reported in Figure 6. Note that
SILKs runtimes were measured without the indexing time, as the data fetching
and indexing are merged to one process in SILK. Also note that in the second
experiment, SILK did not terminate due to higher memory requirements. We
approximated SILKs runtime by extrapolating approximately 11 min it required
for 8.6% of the computation before the RAM was filled. Again, we did not
consider the indexing time.
?

?

?
 

 

 

 
?

?

?
(a) Experiment 1
?

?

?
(c) Experiment 3
?

?

?
(b) Experiment 2
?

?

?
(d) Experiment 4

Fig. 5. Number of comparisons for HR3 and HYPPO
?

?

?
Fig. 6. Comparison of the runtimes of HR3, HYPPO and SILK2.5.1

Due to the considerable difference in runtime (approximately 2 orders of mag-
nitude) between HYPPO and SILK, we report solely HYPPO and HR3s runtimes in the detailed runtimes figures 7(a) and 7(b). Overall, HR3 outperformed
the other two approaches in all experiments, especially for  = 4. It is important
to note that the improvement in runtime increases with the complexity of the
experiment. For example, while HR3 outperforms HYPPO by 3% in the second
experiment, the different grows to more than 7% in the fourth experiment. In
addition, the improvement in runtime augments with the threshold. This can
be seen in the third and fourth experiments. While HR3 is less than 2% faster

A.-C. Ngonga Ngomo

in the third experiment, it is more than 7% faster when  = 4 the fourth experiment . As expected, HR3 is slower than HYPPO for  < 4 as it carries
out exactly the same comparisons but still has the overhead of computing the
index. Yet, given that we know that HR3 is only better when n(  1)p > p,
our implementation only carries out the indexing when this inequality holds. By
these means, we can ensure that HR3 is only used when it is able to discard
hypercubes that HYPPO would not discard, therewith reaching superior runtimes both with small and large values . Note that the difference between the
improvement of the number of comparisons necessitated by HR3 and the improvement in runtime over all experiments is due to the supplementary indexing
step required by HR3.
Finally, we measured the RRR of both HR3 and HYPPO (see Figures 7(c)
and 7(d)). In the two-dimensional experiments 3 and 4, HYPPO achieves a RRR
close to 1. Yet, it is still outperformed by HR3 as expected. A larger difference
between the RRR of HR3 and HYPPO can be seen in the three-dimensional
experiments, where the RRR of both algorithms diverge significantly. Note that
the RRR difference grows not only with the number of dimensions but also with
the size of the problem. The difference in RRR between HYPPO and HR3 does
not always reflect the difference in runtime due to the indexing overhead of
HR3. Still, for  = 4, HR3 generates a sufficient balance of indexing runtime
and comparison runtime (i.e., RRR) to outperform HYPPO in all experiments.
?

?

?
(a) Runtimes for experiments 1 and 2

(b) Runtimes for experiments 3 and 4
?

?

?
(c) RRR for experiments 1 and 2

(d) RRR for experiments 3 and 4

Fig. 7. Comparison of runtimes and RRR of HR3 and HYPPO

6 Related Work

The growing size and number of knowledge bases available in the Linked Data
Cloud makes Link Discovery intrinsically complex with respect to its runtime.
To address this issue, manifold time-efficient frameworks have been developed.
LIMES [14] offers a complex grammar for link specifications that can be translated into a combination of time-efficient atomic mappers that are combined
via a hybrid approach. For example, LIMES implements a dedicated approach
for numeric values called HYPPO. SILK [9] implements a different Link Discovery paradigm and aims to place all instances that are to be compared in a
multi-dimensional space. It then uses MultiBlock to discard unnecessary comparisons efficiently. In contrast to LIMES and SILK, which implement lossless
approaches, the approach presented in [21] uses a candidate selection approach
based on discriminative properties to compute links very efficiently but potentially loses links while doing so. Other frameworks and approaches include those
described in [18,8,19].

Albeit Link Discovery is closely related with record linkage [7] and deduplication [4], it is important to notice that Link Discovery goes beyond these two tasks
as Link Discovery aims to provide the means to link entities via arbitrary relations.
Different blocking techniques such as standard blocking, sorted-neighborhood, bigram indexing, canopy clustering and adaptive blocking have been developed by
the database community to address the problem of the quadratic time complexity of brute force comparison [11]. In addition, very time-efficient approaches have
been proposed to compute string similarities for record linkage, including AllPairs [2], PPJoin and PPJoin+ [24]. However, these approaches alone cannot deal
with the diversity of property values found on the Web of Data as they cannot deal
with numeric values. In addition, most time-efficient string matching algorithms
can only deal with simple link specifications, which are mostly insufficient when
computing links between large knowledge bases.

In recent work, the discovery of adequate link specifications has been addressed mainly by using machine learning approaches. For example, [21] detect
discriminative properties by using string concatenations. RAVEN [16] combines
stable marriage algorithms and a perceptron-based learning algorithm with the
frame of active learning to compute boolean and linear classifiers. SILK [10] employs genetic programming to learn link configurations from positive and negative examples.
[13] go a step further and combine genetic programming with
active learning to discover high-accuracy link specificity with a small number
of annotations. Another approach based on genetic programming is presented
in [17]. Here, the authors show how link specifications can be learned without
any input from the user. To the best of our knowledge, none of the approaches
presented previously provide formal guarantees w.r.t. their performance. HR3 is
the first matching approach that it guaranteed not to lose links while converging
to the small possible reduction ratio. Note that while HR3 was designed for numeric values, it can be used in any space with Minkowski distances, for example
for comparing indexes in multi-dimensional spaces. Thus, it can be used for any
datatype mapped to a metric space.

A.-C. Ngonga Ngomo

7 Conclusion and Future Work
In this paper, we presented HR3, a time-efficient approach for the discovery
of links in spaces with Minkowski distances. We proved that our approach can
achieve is optimal w.r.t its reduction ration by showing that its RRR converges
towards 1 when  converges towards . It is important to note that an optimal
RRR(A) does not necessarily mean that A outperforms algorithms with a poorer
RRR with respect to runtime as achieving a good RRR score usually requires
better preprocessing (usually in form of indexing), which might be more timedemanding than the combination of a rougher preprocessing and a run with a
poorer RRR. Thus, in addition to proving formally that we can guarantee a
RRR that converges towards 1, we implemented our approach and compared it
with the state-of-the-art algorithms HYPPO implemented in LIMES and SILK.
We showed that we outperform both frameworks w.r.t. to their runtime and
that we reach RRR close to 1 for  as small as 32. Our experiments also showed
that  = 4 is a good setup for HR3. Our approach aims to be the first of a
novel type of Link Discovery approaches, i.e., of approaches which can guarantee
theoretical optimality while also being empirically usable. In future work, we will
thus aim to develop more of such approaches and to make use of their theoretical
characteristics for memory and space management. With respect to HR3, we
will mainly improve the implementation of its indexing to ensure even better
runtimes.
