Evaluation of Techniques

for Inconsistency Handling in OWL 2 QL Ontologies

Riccardo Rosati, Marco Ruzzi, Mirko Graziosi, and Giulia Masotti

DIAG, Sapienza Universit`a di Roma
Via Ariosto 25, I-00185 Roma, Italy

Abstract. In this paper we present the Quonto Inconsistent Data handler (QuID).
QuID is a reasoner for OWL 2 QL that is based on the system Quonto and is able
to deal with inconsistent ontologies. The central aspect of QuID is that it implements two different, orthogonal strategies for dealing with inconsistency: ABox
repairing techniques, based on data manipulation, and consistent query answering techniques, based on query rewriting. Moreover, by exploiting the ability of
Quonto to delegate the management of the ABox to a relational database system
(DBMS), such techniques are potentially able to handle very large inconsistent
ABoxes. For the above reasons, QuID allows for experimentally comparing the
above two different strategies for inconsistency handling in the context of OWL
2 QL. We thus report on the experimental evaluation that we have conducted using QuID. Our results clearly point out that inconsistency-tolerance in OWL 2
QL ontologies is feasible in practical cases. Moreover, our evaluation singles out
the different sources of complexity for the data manipulation technique and the
query rewriting technique, and allows for identifying the conditions under which
one method is more efficient than the other.

1 Introduction

One of the most important current issues in OWL ontology management is dealing with
inconsistency, that is, the presence of contradictory information in the ontology [8]. It
is well-known that the classical semantics of OWL and Description Logics (DL) is not
inconsistency-tolerant, i.e., it does not allow for using in a meaningful way any piece
of information in an inconsistent ontology. On the other hand, the size of ontologies
used by real applications is scaling up, and ontologies are increasingly merged and
integrated into larger ontologies: the probability of creating inconsistent ontologies is
consequently getting higher and higher (see e.g. [4]).

In this paper we focus on ABox inconsistency, i.e., the case of inconsistent ontologies
where the TBox (intensional part of the ontology) is consistent, while the ABox (exten-
sional part of the ontology) is inconsistent with the TBox, i.e., a subset of the assertions
in the ABox contradicts one or more TBox assertions.

We follow an approach that is formally based on inconsistency-tolerant semantics;
such semantics overcome the limitations of the classical DL semantics in inconsistency
management. In particular, we consider inconsistency-tolerant semantics for general
DLs recently proposed in [5], called IAR semantics, for which reasoning has been
studied in the context of the Description Logics of the DL-Lite family, and in particular

P. Cudr e-Mauroux et al. (Eds.): ISWC 2012, Part II, LNCS 7650, pp. 337349, 2012.
c Springer-Verlag Berlin Heidelberg 2012

R. Rosati et al.

the DL DL-LiteA, that underlies the OWL profile OWL 2 QL. The IAR semantics is
centered around the notion of ABox repair, which is a very simple and natural one: the
ABox repair of a DL ontology is the intersection of all the maximal subsets of the ABox
that are consistent with the TBox.

Recently, two different methods for reasoning under the IAR inconsistency-tolerant
semantics have been studied: techniques based on the computation of the ABox repair (ABox cleaning) and techniques based on a tranformation of the queries posed to
the (possibly inconsistent) ontology (consistent query rewriting). In particular, in [5]
it was proved that computing the ABox repair of a DL-LiteA ontology under the IAR
semantics is a tractable problem. Then, in [6] a technique for query answering under
IAR-semantics in DL-LiteA is presented: instead of modifying the ABox, this method
of the initial query Q and then evaluating the
is based on computing a rewriting Q
query Q

with respect to the original ABox.
?

?

?
We argue that the results of [5,6] are potentially very important from the practical
viewpoint, for the following reasons: (i) they are based on formally grounded notions
of inconsistency-tolerant semantics; (ii) they identify (to the best of our knowledge) the
first inconsistency-tolerant semantics in DLs for which query answering is tractable. So,
based on such results, in principle it might be possible to define practical algorithms for
handling inconsistency in OWL 2 QL.

This paper starts from the above results, and tries to provide an experimental evaluation and comparison of both the ABox cleaning approach and the consistent query
rewriting approach mentioned above. In particular, our main goal was to address the
following fundamental questions: (i) is ABox cleaning a feasible technique? (ii) is consistent query rewriting a feasible technique? (iii) under which conditions consistent
query rewriting is to prefer to ABox cleaning (and vice versa)?

In this paper, we provide the following contributions:

(1) We present effective techniques for both ABox cleaning and consistent query rewriting in DL-LiteA/OWL 2 QL under IAR semantics. To this aim, we present the QUonto
Inconsistent Data handler (QuID), that implements, within the Quonto system,1 techniques for both the computation of the ABox repair of a DL-LiteA ontology under the
above semantics, as well as techniques for computing the consistent query rewriting
of queries. QuID constitutes (to the best of our knowledge) the first implementation
of tractable algorithms for handling inconsistent instances in OWL ontologies. More-
over, Quonto delegates the management of the ABox to a relational database system
(DBMS). Therefore, for ABox cleaning, all modifications of the ABox are delegated
to the DBMS through SQL queries and updates; and for consistent query rewriting, the
rewritten query can be directly executed by the DBMS on the original database. This
potentially allows for handling inconsistency in very large ABoxes under both tech-
niques.
(2) We present the results of a set of experiments that we have conducted using QuID.
These results clearly show that ABox cleaning in DL-LiteA is actually scalable: QuID is
able to efficiently compute the IAR repair of both complex and large ontologies, whose
ABoxes contain up to millions of assertions and have hundreds of thousands of assertions inconsistent with the TBox. On the other hand, the results for the query answering

1 http://www.dis.uniroma.it/ quonto
?

?

?
technique based on consistent query rewriting are in general less encouraging, since
the structural complexity of the reformulated queries makes the whole query answering
process slower than the approach based on ABox cleaning, although consistent query
rewriting does not require pre-processing of the ABox.
(3) Our experimental results allow us to understand the actual impact of the different aspects involved in the computation of the ABox repair and in consistent query rewriting,
and the limits and possibilities of the two approaches implemented in QuID.
The rest of the paper is organized as follows. In Section 2, we present a detailed algorithm for computing IAR repairs in DL-LiteA. In Section 3, we briefly recall the algorithm presented in [6] for consistent query rewriting under IAR semantics in DL-LiteA.
In Section 4 we present the QuID system and report on the experimental evaluation we
have conducted with QuID. Finally, in Section 5 we conclude the paper.

2 ABox Cleaning Technique for OWL 2 QL

We start by briefly recalling the DL DL-LiteA and the IAR semantics.

In this paper we consider DL ontologies specified in DL-LiteA, a member of the
DL-Lite family of tractable Description Logics [2,1], which is at the basis of OWL 2 QL,
one of the profiles of OWL 2, the ontology specification language of the World Wide
Web Consortium (W3C). DL-LiteA distinguishes concepts from value-domains, which
denote sets of (data) values, and roles from attributes, which denote binary relations
between objects and values. Concepts, roles, attributes, and value-domains in this DL
are formed according to the following syntax:

B  A | Q | (U )
C  B | B
Q  P | P

R  Q | Q

E  (U )
F  D | T1 |
V  U | U

 

| Tn

In such rules, A, P , and U respectively denote an atomic concept (i.e., a concept name),
an atomic role (i.e., a role name), and an attribute name, P
denotes the inverse of an
atomic role, whereas B and Q are called basic concept and basic role, respectively.
Furthermore, (U ) denotes the domain of U , i.e., the set of objects that U relates to
values; (U ) denotes the range of U , i.e., the set of values that U relates to objects;
D is the universal value-domain; T1, . . . , Tn are n pairwise disjoint unbounded value-
domains. A DL-LiteA ontology is a pair K = T ,A, where T is the TBox and A the
ABox. The TBox T is a finite set of assertions of the form



B  C

Q  R

E  F

U  V

(funct Q)

(funct U )

From left to right, the first four assertions respectively denote inclusions between con-
cepts, roles, value-domains, and attributes. In turn, the last two assertions denote functionality on roles and on attributes. In fact, in DL-LiteA TBoxes we further impose that
roles and attributes occurring in functionality assertions cannot be specialized (i.e., they
cannot occur in the right-hand side of inclusions). In practice, the only difference between DL-LiteA and OWL 2 QL lies in the presence of functionality assertions (which

R. Rosati et al.

are not allowed in OWL 2 QL). Due to space limitations, we refer the reader to [7] for
details on the semantics of DL-LiteA.
We then briefly recall the IAR semantics for inconsistency-tolerance in DL ontologies (see [5] for more details). Let K = T ,A be a DL ontology. Then, the IAR-repair
of K is defined as the ABox corresponding to the intersection of all the maximal subsets
of A that are consistent with T . A first-order formula  is entailed by K under the IAR
semantics if  is entailed by T ,AR under the standard DL semantics, where AR is
the IAR-repair of K. We are interested in checking (Boolean) unions of conjunctive
queries (UCQs) over DL ontologies.
The technique for computing the IAR-repair of a DL-LiteA ontology T ,A is based
on the idea of deleting from A all the membership assertions participating in minimal
conflict sets for T . As shown in [5], this task is relatively easy (in particular, tractable)
in DL-LiteA because the following property holds: for every DL-LiteA TBox T , all the
minimal conflict sets for T are either unary conflict sets or binary conflict sets. This
property is actually crucial for tractability of reasoning under IAR semantics.

We now present a detailed algorithm for computing the IAR-repair of a DL-LiteA
ontology. This algorithm exploits the techniques presented in [5], whose aim was only
to provide PTIME upper bounds for the problem of computing such repairs. In partic-
ular, the present algorithms specify efficient ways of detecting minimal conflict sets.
Instead, the previous techniques check all unary and binary subsets of the ABox for
these purposes.
In the following, we call annotated ABox assertion an expression  of the form , 
where  is an ABox assertion and  is a value in the set {cons, ucs, bcs}. Furthermore,
we call annotated ABox a set of annotated ABox assertions. The intuition behind an
annotated ABox assertion  is that its annotation  expresses whether the associated
ABox expression  does not participate in any minimal conflict set (cons) or participates
in a unary conflict set (ucs) or to a binary conflict set (bcs).



The following algorithm QuID-IAR-repair computes the IAR-repair of a DL-LiteA
ontology. For ease of exposition, the algorithm does not report details on the treatment
of attributes, which are actually handled in a way analogous to roles. In the following,
we denote concept names with the symbol A, role names with the symbol P , basic
concepts (that is, a concept name A or the domain of a role P or the range of a role
P
) with the symbols B1, B2, and basic roles (that is, either a role name P or the
) with the symbols R, S. Moreover, the expression B(a) with
inverse of a role name P
B basic concept denotes: the instance assertion A(a) if B = A; an instance assertion
of the form P (a, b) if B = P ; an instance assertion of the form P (b, a) if B = P

.
Algorithm QuID-IAR-repair(K)
input: DL-LiteA ontology K = T ,A, output: IAR-repair of K
begin
// STEP 1: create annotated ABox Aann



// STEP 2: detect unary conflict sets in Aann

Aann = ;
for each   A do Aann = Aann  , cons;
for each concept name A s.t. T |= A  A do
for each role name P s.t. T |= P  P do

for each  = A(a), cons  Aann do Aann = Aann  {}  {A(a), ucs};
?

?

?
for each  = P (a, b), cons  Aann do Aann = Aann  {}  {P (a, b), ucs};
for each  = P (a, a), cons  Aann do Aann = Aann  {}  {P (a, a), ucs};

for each role name P s.t. T |= P  P
// STEP 3: detect binary conflict sets in Aann

or T |= P  P

do





ann such that 1, 2 = ucs do

ann such that 1, 2 = ucs do

for each disjointness B1  B2 such that T |= B1  B2 do
Aann = Aann  {1, 2}  {B1(a), bcs,B2(a), bcs};

for each pair 1 = B1(a), 1, 2 = B2(a), 2  A
for each disjointness R  S such that T |= R  S do

for each pair 1 = R(a, b), 1, 2 = S(a, b), 2  A

Aann = Aann  {1, 2}  {R(a, b), bcs,S(a, b), bcs};

for each functionality assertion (funct R)  T do

for each pair 1 = R(a, b), 1, 2 = R(a, c), 2  A

such that b = c and 1, 2 = ucs do
Aann = Aann  {1, 2}  {R(a, b), bcs,R(a, c), bcs};
// STEP 4: extract the IAR repair from Aann

ann

A
= ;
for each , cons  Aann do A
return A

= A  {};

end

The algorithm QuID-IAR-repair consists of four steps which can be informally de-

scribed as follows.
step 1. copy of A into an annotated ABox Aann . In this step, the value of the annotation
is initialized to cons for all ABox assertions.
step 2. detection of the unary conflict sets in Aann . For every assertion of the form
 = , cons, such that {} is a unary conflict set for T , Aann = Aann  {} 
{, ucs}, i.e., the annotation relative to  is changed to ucs. Unary conflict sets
are actually detected through TBox reasoning, by looking at empty concepts and
roles in T , as well as asymmetric roles, i.e., roles disjoint with their inverse.
step 3. detection of the binary conflict sets in Aann . For every pair of assertions of the
form 1 = 1, 1, 2 = 2, 2 such that 1 = ucs and 2 = ucs and {, } is a
binary conflict set for T , Aann = Aann  {1, 2}  {, bcs,, bcs}, i.e., the
annotation relative to  and  is changed to bcs. As in the case of unary conflict
sets, to find binary conflict sets the algorithm looks for disjoint concepts and roles
in T , as well as functional roles.
step 4. extraction of the IAR-repair from Aann . The IAR-repair can be now simply
extracted from the annotated ABox Aann , by eliminating both unary conflict sets
and binary conflict sets. Therefore, for every assertion of the form , cons in
Aann ,  is copied into the (non-annotated) ABox A
which is finally returned by
the algorithm.

Correctness of the above algorithm can be proved starting from the results in [5].
Theorem 1. Let K be a DL-LiteA ontology and let A
QuID-IAR-repair(K). Then, A

is the IAR repair of K.

be the ABox returned by

R. Rosati et al.

3 Perfect Reformulation of UCQs under IAR Semantics
?

?

?
We now briefly recall the query rewriting technique proposed in [6]. Such a technique
starting from a union of conjunctive queries Q and
computes a first-order query Q
a DL-LiteA TBox T . The query Q
is a perfect reformulation of Q with respect to T

is such that, for every ABox A, the answers to Q over

under the IAR semantics, i.e., Q
T ,A under the IAR semantics correspond to to the answers to Q
computed over the
ABox A only. Due to space limits, here we just report the main definitions of the query
rewriting technique: we refer the reader to [6] for more details on the method.
?

?

?
The first definition that we give can be used to establish whether a certain atom is
consistent with the TBox axioms. Let A be an atomic concept in O and t a term (i.e.,
A(t) = false if T |= A  A,

either a constant or a variable symbol), we pose ConsAt

true otherwise. That is, ConsAt
A(t) is false if and only if the concept A is unsatisfi-
able. For an atomic role P  O and terms t, t

) = false
if T |= P  P
if T |= P  P ; (ii) t = t
; (iii) true
otherwise (an analogous definition holds for an attribute U  O and terms t and t

P (t, t
or T |= P  P


, we define: (i) ConsAt



).
?

?

?
Now we deal with possible clashes involving negative inclusions, which are also
called disjointnesses. Let B be a basic concept built from an atomic concept or an

atomic role of O, and let t be a term. Then, we define NotDisjClash
B(t) as the following FOL formula:
?

?

?
ADCN (B,T )

(A(t)  ConsAt
(y.P (y, t)  ConsAt

P (t, y))

(y.U (t, y)  ConsAt

U (t, y))
PDRR(B,T )
where y is a variable symbol such that y = t , DCN , DRD, DRR, and DAD are
defined as follows:

P (y, t))  

(y.P (t, y)  ConsAt

PDRD (B,T )

UDAD(B,T )

A(t))  

DCN (B,T ) = {A | A is an atomic concept of O and T |= B  A}
DRD(B,T ) = {P | P is an atomic role of O and T |= B  P}
DRR(B,T ) = {P | P is an atomic role of O and T |= B  P
}
DAD(B,T ) = {U | U is an attribute of O and T |= B  (U )}

Let us now consider disjointness clashes for roles. Let P be a role name from O and
let t, t

be terms, we define the formula NotDisjClash
?

?

?
P (t, t
?

?

?
SDisjRoles(P,T ) (S(t, t
SDisjInvRoles(P,T ) (S(t
?

?

?
)  ConsAt
, t)  ConsAt
?

?

?
S (t, t
?

?

?
S (t
?

?

?
) as follows:
P (t)

))  NotDisjClash
, t))  NotDisjClash
?

?

?
P  (t
?

?

?
)
?

?

?
where, again, if either t or t
sets DisjRoles(P,T ) and DisjInvRoles(P,T ) are defined as follows:

are variable symbols, then they are free variables, and the

DisjRoles(P,T ) = {S | S is a role name of O and T |= P  S}
DisjInvRoles(P,T ) = {S | S is a role name of O and T |= P  S

}.

P (t, t
?

?

?
) will be used in the reformulation to deal with pos-
Intuitively, NotDisjClash
sible violations of negative inclusions involving P . This means considering role in-
clusions, through the sets DisjRoles(P,T ) and DisjInvRoles(P,T ), and concept in-
  B, through the use
clusions of the form P  B and of the form P
?

?

?
U for attributes U is defined analogously.)
?

?

?
We are now able to define for each DL-LiteA construct the formula that combines
together the various formulas we have introduced for dealing with the various possible
?

?

?
A(t) for an atomic concept name A and
clashes: (i) NotClash
A(t) = NotDisjClash

) for a
term t; (ii) NotClash
Z (t, t
role or attribute name Z and terms t, t

i ) 
i ), where
every Ai is an atomic concept, every Pi is an atomic role, every Ui is an attribute, and
i is either a constant or a variable xj with 1  j  k. Then, we
every t1
define IncRewritingIAR(q,T ) as the following FOL sentence

)  NotFunctClash

i ) 

) = NotDisjClash

n
i=1 Ai(t1
?

?

?
i=1 Ui(t4

m
i=1 Pi(t2

Z (t, t

Z (t, t
?

?

?
i , t2

i , t3

i , t5
?

?

?
.

i , t5

Let q be a CQ x1, . . . , xk.

n
i=1 Ai(t1
i )  ConsAt
i )  ConsAt

i , t3
i , t4

x1, . . . , xk.

m
i , t3
i=1 Pi(t2

i , t5
i=1 Ui(t4

Ai (t1

i )  ConsAt
i , t3
i , t5

Pi (t2

Ui (t4

i )  NotClash

i , t3
Pi (t2
i )

i , t5
Ui (t4
i )

i )  NotClash
i )  NotClash

Ai (t1

i )

Evaluation of Techniques for Inconsistency Handling
?

?

?
S (t, t
?

?

?
P (t) and NotDisjClash

P (t

), respectively. ConsAt

of NotDisjClash
here a role analogous to the one played by ConsAt formulas in NotDisjClash
(The function NotDisjClash

U for attributes U is defined in an analogous way.)

P (t, t

Finally, we consider clashes on functionalities and define NotFunctClash
the following FOL formula:
 if (funct P )  T and (funct P
 if (funct P )  T and (funct P
 if (funct P )  T and (funct P
 if (funct P )  T and (funct P

)  T , then NotFunctClash

  ConsAt

P (t, y));
)  y = t  ConsAt

P (y, t));
ConsAt
P (t, y))(y.P (y, t

) = true;
)  T , then NotFunctClash
?

?

?
P (t, t
)  T , then NotFunctClash

P (t, t
)  T , then NotFunctClash

P (t, t
)y = tConsAt

(y.P (t, y)  y = t
(y.P (y, t
(y.P (t, y)y = t

P (t, t






?

?

?
) =

) =

) =

P (y, t)).

) plays

B(t).
?

?

?
) as

n

i ).

i , t5

Ai (t1

Ai(t1

Finally, we

i ) and Ui(t4

i ), each membership assertion of the ABox A con-
Informally, for each atom Ai(t1
stituting an image of Ai(t1
i ) has not to be inconsistent with the TBox (condition
i )), and has not to be involved in any clash with some other assertion of A
ConsAt
on any negative inclusion (condition NotClash
i )). Similarly for atoms of the form

i , t3
Pi(t2
Let Q be the UCQ q1  . . .  qn. Then, we define IncRewritingUCQIAR(Q,T ) =
i=1 IncRewritingIAR(qi,T ).
as
IncRewritingUCQIAR(PerfectRef(Q,T ),T ), where PerfectRef(Q,T ) denotes the
algorithm for computing a perfect reformulation of a UCQ Q with respect to a
DL-LiteA TBox T under standard semantics [2,7] (the algorithm PerfectRef(Q,T )
returns a UCQ specified over T ). It can be shown (see [6]) that PerfectRefIAR(Q,T )
constitutes a perfect reformulation of Q with respect to T under IAR semantics.
Therefore, using this technique, it is possible to solve query answering under IAR
semantics in DL-LiteA as follows. Given the initial query Q and the ontology T ,A,
the first-order query PerfectRefIAR(Q,T ) is computed, and then such a first-order query
is evaluated over the original ABox (which is in general inconsistent with T ). So, in this
case no repair of the ABox is performed, differently from the algorithm presented in the
previous section.

PerfectRefIAR(Q,T )

define

R. Rosati et al.

4 Experiments

We have implemented the techniques presented in the previous Section in the Quonto
system, in a module called QuID (the QUonto Inconsistent Data handler). Essentially,
QuID is a Java implementation of the above algorithms for ABox repair and for query
rewriting. In fact, in the Quonto architecture, the management of the ABox is delegated
to a relational database management system (DBMS): therefore, all the operations on
ABox assertions of the algorithms for computing repairs are executed in QuID by the
DBMS used by Quonto, through appropriate SQL scripts.

We have experimented QuID in order to answer several open questions about: (i)
the computational cost of the various steps of the ABox cleaning algorithm and of the
query rewriting algorithm; (ii) the scalability of such algorithms; (iii) the impact of the
degree of inconsistency of the ABox on the computational cost of the algorithms; (iv)
the practical difference between the ABox cleaning tecnhique and the purely intensional
rewriting technique.

Experimenting the QuID-IAR-repairalgorithm. We have experimented our implementation of the QuID-IAR-repair algorithm over the LUBM benchmark ontology,2
whose TBox has 43 concept names, 25 role names, 7 attribute names, and about 200
TBox assertions. We have generated 4 different ABoxes by means of the UBA Data
Generator provided by the LUBM website, with an increasing number of assertions, and
used such ABoxes in our experiments. It is important to note that the original LUBM
ontology has no axioms which can generate inconsistency, and hence, no inconsistent
data is contained in the generated ABoxes. So, we sligthly modified the LUBM ontology by adding some inconsistency-generating axioms and then added inconsistencies
to the ABoxes. We created four different version for every original ABox with different percentages of ABox assertions involved in minimal conflict sets, in order to get
ABoxes with respectively 1%, 5%, 10% and 20% of inconsistent assertions, uniformly
distributed among the axioms which might generate inconsistency. Figure 1 shows the
size (number of instance assertions) of the ABoxes we used in the experiments: every
column is labeled with the number of Universities the ABox data contains, and every
row is labeled with the percentage of inconsistent facts added to the ABox itself.

Figure 2 report some of the experimental results that we have obtained. The table
displayed presents the experimental results for QuID-IAR-repair using a PostgreSQL
9.1 instance as external DBMS. The results have been conducted on a Pentium i5 (2.4
GHz) CPU with 4GB RAM under Windows 7 (64 bit) operating system.

All

the necessary software, as well as

instructions on how to repro-
section, are publicly available at
duce the experiments presented in this
http://www.dis.uniroma1.it/ ruzzi/quid/. Further details on the ontology used in the experiments are also available there.

In the table displayed in Figure 2, the first column reports the number of universities
represented in the ABox, while the second column reports the percentage of ABox
assertions that participate in minimal conflict sets for the considered TBox. Moreover:

 T1 denotes the time to create the annotated ABox (step 1 of QuID-IAR-repair);

2 http://swat.cse.lehigh.edu/projects/lubm/
?

?

?
 T2 denotes the time to detect unary and binary conflict sets (steps 2 and 3 of QuID-

IAR-repair);

 T3 denotes the time to extract the IAR-repair from the annotated ABox (step 4 of

QuID-IAR-repair);

 Total is the total time to compute the IAR-repair, i.e., T1+T2+T3.

.

c
r
e

.

c
n
?

?

?
103765
109165
115845
130445

Number of Universities

631960
658980
692400
765380

1285244
1339304
1406124
1552104

2711216
2819337
2952957
3244937

Fig. 1. Size of the UBA generated ABoxes

#Univ

Inc%
?

?

?
T1 (ms)

T2 (ms)

T3 (ms)
?

?

?
414477
419298
412371
466363
968123
945471
936688
987216
2381829
2485267
2233066
2297791
?

?

?
131805
254000

140447
271830
573020
137327
353486
722468
1417200
?

?

?
418970
414854
403619
406880
953037
917890
884835
873664
2379121
2251335
2212381
2090794

Total (ms)
142881
152708
166156
204048
846863
894586
947795
1127243
1952220
2003808
2093353
2433900
4898277
5090088
5167915
5805785

Fig. 2. Repair generation time

The above experimental results show that:

(i) the computation of the IAR-repair (column T1) seems really scalable, and grows

almost linearly w.r.t. the size of the ABox.

(ii) the percentage of inconsistency, i.e., the fraction of ABox assertions that participate
in minimal conflict sets, has a real impact only on the detection of minimal conflict
sets (column T2);

(iii) most of the whole execution time of the QuID-IAR-repair algorithm is devoted
to the creation of annotated ABox (T1) and of the final repair (T3): if this could
be avoided (e.g., by just modifying the original database, as explained below), the
algorithm would be much more efficient, since only time T2 would be consumed.

Experimenting the Consistent Query Rewriting Approach. As above observed, most
of the execution time of the algorithm QuID-IAR-repair using a disk-resident DB is
due to the creation of the annotated ABox (step 1) and to the creation of the IAR-repair
(step 4). Thus, avoiding these steps would dramatically improve the efficiency of this
algorithm.

R. Rosati et al.

To this aim, we observe that both the above steps could be completely avoided if the
database schema used for representing the ABox would present an additional attribute
for storing annotations in every relation (the usual DB representation of an ABox uses a
unary relation for every concept and a binary relation for every role). This corresponds
to the idea of directly using an annotated ABox instead of a standard ABox in the
system. In this case, the computation of the IAR-repair could only consist of steps 2 and
3 of the algorithm QuID-IAR-repair. However, the choice of using an annotated ABox
instead of a standard ABox could affect query answering, since the queries evaluated on
an annotated ABox should be able to only consider the assertions whose annotation is
equal to cons. Similarly, exploiting the query rewriting technique presented in Section 3,
it is possible to completely avoid the computation of the annotated ABox, and could be
able to evaluate the first-order query corresponding to the perfect reformulation of the
original query directly over the original, inconsistent, ABox.

We have experimented whether this choice is actually feasible. In particular, we
tested and compared three different approaches: (IAR) evaluation of the IAR perfect
reformulation over the inconsistent ABox; (AN N ) evaluation over the annotated ABox
Aann (produced by the QuID-IAR-repair algorithm) of the original query enriched with
suitable conditions that are needed to filter out the assertions belonging to minimal conflict sets; (REP ) evaluation of the original query over the repair using the standard
query answering technique of QuOnto. Figure 3 presents a table showing the evaluation time of nine of the fourteen queries of the LUBM benchmark over all the ABoxes
previously considered. We adopted a timeout (denoted by T.o. in the table) of 1 hour.3

Comparing the Two Approaches. These experimental results show that, in QuID, evaluating queries on the annotated ABox is computationally not harder than evaluating them
on the standard ABox. Conversely, the evaluation of the IAR perfect reformulations is
often more expensive (in particular, it is more expensive for queries Q5Q9). This is
due to the fact that we have built no repair and we are querying the inconsisent ABox:
thus, as shown in the previous section, the IAR perfect reformulation essentially has
to select only assertions of the ABox which do not participate in minimal inconsistent
sets (with respect to the TBox). This makes the form of such queries quite involved: in
particular, the SQL queries corresponding to the IAR perfect refomulations of UCQs
may present several nesting levels, which makes such queries hard to evaluate by current
DBMSs. This consideration is enforced, e.g., by the evaluation time of query Q5, which
is greater than 1 hour on the ABox representing 5 universities. That is, in this case the
time to evaluate the IAR perfect reformulation of this query over the original ABox is
much greater than computing the IAR repair and then evaluating the original query on
the repaired ABox.

Combining the results of Figure 2 and Figure 3, it seems that, in general, the ABox
cleaning approach is more convenient than the consistent query rewriting approach.
In other words, the cost of preprocessing the ABox is generally an acceptable one,
and really pays off during the evaluation of the queries, especially when the annotated
representation of the ABox is adopted.

3 Further details on our experiments can be found at

http://www.dis.uniroma1.it/ ruzzi/quid/.
?

?

?
#Univ

Inc%
?

?

?
#Univ

Inc%
?

?

?
#Univ

Inc%
?

?

?
Q1
?

?

?
Q4
?

?

?
Q7
?

?

?
Q2
?

?

?
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
T.o.
?

?

?
Q5
?

?

?
112814
113969
103710
Q8
?

?

?
127796
132288
110622
110339
?

?

?
Q3
?

?

?
Q6
?

?

?
Q9
?

?

?
Fig. 3. Query answering time (in milliseconds) for the various techniques

R. Rosati et al.

On the other hand, it is worth recalling that the ABox cleaning approach might not
always be possible or easily realizable in real applications, especially in ontology-based
data access (OBDA) scenarios where the ABox is actually a virtual object that is defined
through virtual queries/views over one or more remote databases: (see e.g., [7]): in these
cases, the OBDA system can typically only read such databases.

5 Conclusions

In this paper we have presented a practical approach to automatic the repair of inconsistent ontologies. The key features of our approach are the following: (i) the semantics
of the repair are simple, intuitive, formally grounded, and defined for all DLs; (ii) such
semantics allow for tractable automatic ABox cleaning and consistent query rewriting
in the case of OWL 2 QL ontologies; (iii) our experiments show that the approach is
really scalable, and that very large ABoxes can be effectively repaired.

The work presented in this paper can be extended in several directions. First, the
present implementation can be certainly further optimized. For instance, besided working with an annotated ABox representation, other optimizations are possible: one possibility which seems worth exploring is employing summarization techniques for ABox
representation, as in [3]. Also, the consistent query rewriting technique can be certainly
optimized to the aim of reducing the size of the reformulated query. Then, it would be
very interesting to see whether the techniques presented in this paper can be extended
to other tractable OWL profiles.

Acknowledgments. This research has been partially supported by the ICT Collaborative Project ACSI (Artifact-Centric Service Interoperation), funded by the EU under
FP7 ICT Call 5, 2009.1.2, grant agreement n. FP7-257593.
