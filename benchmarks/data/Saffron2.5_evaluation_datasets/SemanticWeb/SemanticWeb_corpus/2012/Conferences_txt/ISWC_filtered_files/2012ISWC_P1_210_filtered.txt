Ontology-Based Access to Probabilistic Data

with OWL QL

Jean Christoph Jung and Carsten Lutz

Universit at Bremen, Germany

{jeanjung,clu}@informatik.uni-bremen.de

Abstract. We propose a framework for querying probabilistic instance
data in the presence of an OWL2 QL ontology, arguing that the interplay
of probabilities and ontologies is fruitful in many applications such as
managing data that was extracted from the web. The prime inference
problem is computing answer probabilities, and it can be implemented
using standard probabilistic database systems. We establish a PTime vs.
#P dichotomy for the data complexity of this problem by lifting a corresponding result from probabilistic databases. We also demonstrate that
query rewriting (backwards chaining) is an important tool for our frame-
work, show that non-existence of a rewriting into first-order logic implies
#P-hardness, and briefly discuss approximation of answer probabilities.

Introduction

There are many applications that require data to be first extracted from the
web and then further processed locally, by feeding it into a relational database
system (RDBMS). Such web data differs in several crucial aspects from traditional data stored in RDBMSs: on the one hand, it is uncertain because of the
unreliability of many web data sources and due to the data extraction process,
which relies on heuristic decisions and is significantly error prone [23]; on the
other hand, web data is often provided without explicit schema information and
thus requires interpretation based on ontologies and other semantic techniques.
This latter aspect is addressed by ontology languages such as OWL2. In par-
ticular, the OWL2 QL profile is a popular lightweight ontology language that is
tailored towards enriching standard RDBMS query answering with an ontology
component, thus allowing the user of semantic technologies to take advantage of
the maturity and effiency of such systems [6]. While the current techniques developed around OWL2 QL are well-suited to deal with the interpretation aspect
of web data, they are not able to deal with its uncertainty. In this paper, we
propose and analyze a framework for data storage and querying that supports
ontologies formulated in (a fragment of) OWL2 QL, but also features prominent
aspects of probabilistic database models to explicitly represent uncertainty. In
a nutshell, our approach relates to probabilistic database systems (PDBMSs) in
the same way that traditional OWL2 QL query answering relates to RDBMSs.

In our framework, we adopt data models from the recently very active area of
probabilistic databases [7,31], but use an open world assumption as is standard in

P. Cudr e-Mauroux et al. (Eds.): ISWC 2012, Part I, LNCS 7649, pp. 182197, 2012.
c Springer-Verlag Berlin Heidelberg 2012
?

?

?
the context of OWL2 QL. Specifically, we store data in description logic ABoxes
enriched with probabilities that are attached to probabilistic events, which can
either be modeled explicitly (resulting in what we call pABoxes) or be implicitly
associated with each ABox assertion (resulting in ipABoxes). For example, a
pABox assertion SoccerPlayer(messi) can be associated with an event expression

e1 e2, where e1 and e2 represent events such as web extraction tool x correctly

analyzed webpage y stating that Messi is a soccer player. We generally assume
all events to be probabilistically independent, which results in a straightforward
semantics that is similar to well-known probabilistic versions of datalog [27,12].
Ontologies are represented by TBoxes formulated in the description logic DL-
Lite, which forms a logical core of the ontology language OWL2 QL. We are then
interested in computing the answer probabilities to conjunctive queries (CQs);
note that probabilities can occur only in the data, but neither in the ontology
nor in the query. We believe that this setup is of general interest and potentially useful for a wide range of applications including the management of data
extracted from the web, machine translation, and dealing with data that arises
from sensor networks. All these applications can potentially benefit from a fruitful interplay between ontologies and probabilities; in particular, we argue that
the ontology can help to reduce the uncertainty of the data.

In database research, practical feasibility is usually identified with PTime
data complexity, where data complexity means to treat only the (probabilistic)
data as an input while considering both the TBox and the query to be fixed. The
main aim of this paper is to study the data complexity of ontology-based access
to probabilistic data (pOBDA) in the concrete framework described above. As a
central tool, we use query rewriting (also called backwards chaining), which is
an important technique for traditional ontology based data access (OBDA), i.e.,
answering CQs in the presence of a DL-Lite TBox over non-probabilistic data [6].
Specifically, the idea is to rewrite a given CQ q and DL-Lite TBox T into an SQL
(equivalently: first-order) query qT such that for any ABox A, the certain answers
to q over A relative to T are identical with the answers to qT over A viewed as
a relational database instance. We set out with observing that rewritings from
traditional OBDA are useful also in the context of pOBDA: for any pABox A,
the probability that a tuple a is a certain answer to q over A relative to T
is identical to the probability that a is an answer to qT over A viewed as a
probabilistic database. This lifting of query rewriting to the probabilistic case
immediately implies that one can implement pOBDA based on existing PDBMSs
such as MayBMS, Trio, and MystiQ [1,33,5].

Lifting also allows us to carry over the dichotomy between PTime and #P-
hardness for computing the probabilities of answers to unions of conjunctive
queries (UCQs) over probabilistic databases recently obtained by Dalvi, Suciu,
and Schnaitter [8] to our pOBDA framework provided that we restrict ourselves
to ipABoxes, which are strictly less expressive than pABoxes. Based on a careful syntactic analysis, we provide a transparent characterization of those CQs q
and DL-Lite TBoxes T for which computing answer probabilities is in PTime.
We then proceed to showing that query rewriting is a complete tool for proving

J.C. Jung and C. Lutz

PTime data complexity in pOBDA, in the following sense: we replace DL-Lite
with the strictly more expressive description logic ELI, which is closely related
to the OWL2 profile OWL2 EL and where, in contrast to DL-Lite, rewritings
into first-order queries do not exist for every CQ q and TBox T ; we then prove
that if any (q,T ) does not have a rewriting, then computing answer probabilities for q relative to T is #P-hard. Thus, if it is possible at all to prove that
some (q,T ) has PTime data complexity, then this can always be done using
query rewriting. Both in DL-Lite and ELI, the class of queries and TBoxes
with PTime data complexity is relatively small, which leads us to also consider
the approximation of answer probabilities, based on the notion of a fully polynomial randomized approximation scheme (FPRAS). It is not hard to see that
all pairs (q,T ) have an FPRAS when T is formulated in DL-Lite, but this is
not the case for more expressive ontology languages such as ALC. Note that
these results are in the spirit of the non-uniform analysis of data complexity
recently initiated in an OBDA context in [26]. We defer some proofs to the appendix of the long version of this paper, available at http://www.informatik.uni-
bremen.de/tdki/research/papers.html.

Related Work. The probabilistic ABox formalism studied in this paper is inspired
by the probabilistic database models in [9], but can also be viewed as a variation
of probabilistic versions of datalog and Prolog, see [27,12] and references therein.
There have recently been other approaches to combining ontologies and probabilities for data access [11,14], with a different semantics; the setup considered
by Gottlob, Lukasiewicz, and Simari in [14] is close in spirit to the framework
studied here, but also allows probabilities in the TBox and has a different, rather
intricate semantics based on Markov logic. In fact, we deliberately avoid probabilities in the ontology because (i) this results in a simple and fundamental, yet
useful formalism that still admits a very transparent semantics and (ii) it enables
the use of standard PDBMSs for query answering. There has also been a large
number of proposals for enriching description logic TBoxes (instead of ABoxes)
with probabilities, see [24,25] and the references therein. Our running application
example is web data extraction, in the spirit of [16] to store extracted web data
in a probabilistic database. Note that It has also been proposed to integrate both
probabilities and ontologies directly into the data extraction tool [13]. We believe that both approaches can be useful and could even be orchestrated to play
together. Finally, we note that the motivation for our framework is somewhat
similar to what is done in [30], where the retrieval of top-k-answers in OBDA is
considered under a fuzzy logic-like semantics based on scoring functions.

2 Preliminaries

We use standard notation for the syntax and semantics of description logics
(DLs) and refer to [3] for full details. As usual, NC, NR, and NI denote countably
infinite sets of concept names, role names, and individual names, C, D denote
(potentially) composite concepts, A, B concept names, r, s role names, R and S
?

?

?

?

?

?





?

?

?


,I

, then as

   with B and B

In DL-Lite, TBoxes are finite sets of concept inclusions (CIs) B  B

denotes r. We consider the following DLs.
concepts of the form r, r

role names or their inverse, and a, b individual names. When R = r
usual R
and
,  or A. Note that there
BB
is no nesting of concept constructors in DL-Lite. This version is sometimes called
DL-Litecore and includes crucial parts of the OWL2 QL profile; some features of
OWL2 QL are omitted in DL-Litecore, mainly to keep the presentation simple.
ELI is a generalization of DL-Lite without  (which we will largely disregard
in this paper for reasons explained later on) and offers the concept constructors
.C. In ELI, a TBox is a finite set of CIs C  D with
, C  D, r.C, and r
C and D (potentially) compound concepts.
In DLs, data is stored in an ABox, which is a finite set of concept assertions
A(a) and role assertions r(a, b). We use Ind(A) to denote the set of individual
names used in the ABox A and sometimes write r
) as usual [3].
An interpretation is a model of a TBox T (resp. ABox A) if it satisfies all
concept inclusions in T (resp. assertions in A), where satisfaction is defined in
the standard way. An ABox A is consistent w.r.t. a TBox T if A and T have a
common model. We write T |= C  D if for all models I of T , C
and
say that C is subsumed by D relative to T .
Conjunctive queries (CQs) take the form y.(x, y), with  a conjunction of
) and where x, y denote (tuples of) variables
atoms of the form A(t) and r(t, t
taken from a set NV and t, t
denote terms, i.e., a variable or an individual name.
We call the variables in x the answer variables and those in y the quantified
variables. The set of all variables in a CQ q is denoted by var(q) and the set
of all terms in q by term(q). A CQ q is n-ary if it has n answer variables and
Boolean if it is 0-ary. Whenever convenient, we treat a CQ as a set of atoms and
sometimes write r

The semantics of DLs is based on interpretations I = (

(a, b)  A for r(b, a)  A.

Let I be an interpretation and q a CQ with answer variables x1, . . . , xk. For

(t, t
k, an a-match for q in I is a mapping  : term(q)  

for all a  term(q)NI, (t)  A

a = a1  ak  NI
such
that (xi) = ai for 1  i  k, (a) = a
for all
A(t)  q, and ((t1), (t2))  r
for all r(t1, t2)  q. We write I |= q[a] if there
is an a-match of q in I. For a TBox T and an ABox A, we write T ,A |= q[a] if
I |= q[a] for all models I of T and A. In this case and when all elements of a
are from Ind(A), a is a certain answer to q w.r.t. A and T . We use certT (q,A)
to denote the set of all certain answers to q w.r.t. A and T .

I  D


?

?

?
)  q instead of r(t
?

?

?
, t)  q.
?

?

?
As done often in the context of OBDA, we adopt the unique name assumption
for all interpretations I and all a, b  NI with
(UNA), which requires that a
a = b. Note that, in all logics studied here, query answers with and without UNA
actually coincide, so the assumption of the UNA is without loss of generality.

I = b

3 Probabilistic OBDA

We introduce our framework for probabilistic OBDA, starting with the definition
of a rather general, probabilistic version of ABoxes. Let E be a countably infinite

J.C. Jung and C. Lutz

set of atomic (probabilistic) events. An event expression is built up from atomic
events using the Boolean operators , , . We use expr(E) to denote the set of
all event expressions over E. A probability assignment for E is a map E  [0, 1].
Definition 1 (pABox). A probabilistic ABox (pABox) is of the form (A, e, p)
with A an ABox, e a map A  expr(E), and p a probability assignment for EA,
the atomic events in A.
Example 1. We consider as a running example a (fictitious) information extraction tool that is gathering data from the web, see [16] for a similar setup. Assume
we are gathering data about soccer players and the clubs they play for in the
current 2012 season, and we want to represent the result as a pABox.
(1) The tool processes a newspaper article stating that Messi is the soul of the
Argentinian national soccer team. Because the exact meaning of this phrase
is unclear (it could refer to a soccer player, a coach, a mascot), it generates
the assertion Player(messi) associated with the atomic event expression e1 with
p(e1) = 0.7. The event e1 represents that the phrase was interpreted correctly.
(2) The tool finds the Wikipedia page on Lionel Messi, which states that he is
a soccer player. Since Wikipedia is typically reliable and up to date, but not

always correct, it updates the expression associated with Player(messi) to e1  e2
and associates e2 with p(e2) = 0.95.
(3) The tool finds an HTML table on the homepage of FC Barcelona saying
that the top scorers of the season are Messi, Villa, and Pedro. It is not stated
whether the table refers to the 2011 or the 2012 season, and consequently we
generate the ABox assertions playsfor(x, FCbarca) for x  {messi, villa, pedro} all
associated with the same atomic event expression e3 with p(e3) = 0.5. Intuitively,
the event e3 is that the table refers to 2012.
(4) Still processing the table, the tool applies the background knowledge that
top scorers are typically strikers. It generates three assertions Striker(x) with
x  {messi, villa, pedro}, associated with atomic events e4, e

4 . It sets

p(e4) = p(e
4 ) = 0.8. The probability is higher than in (3) since being
a striker is a more stable property than playing for a certain club, thus this
information does not depend so much on whether the table is from 2011 or 2012.
(5) The tool processes the twitter message Villa was the only one to score a
goal in the match between Barca and Real. It infers that Villa plays either for
Barcelona or for Madrid, generating the assertions playsfor(villa, FCbarca) and
playsfor(villa, realmadrid). The first assertion is associated with the event e5, the
second one with e5. It sets p(e5) = 0.5.
Now for the semantics of pABoxes (A, e, p). Each E  EA can be viewed as a
truth assignment that makes all events in E true and all events in EA \ E false.
Definition 2. Let (A, e, p) be a pABox. For each E  EA, define a corresponding non-probabilistic ABox AE := {  A | E |= e()}. The function p
represents a probability distribution on 2EA, by setting for each E  EA:
?

?

?
4) = p(e
?

?

?
4, and e

p(E) =

eE

p(e) 

(1  p(e)).

eEA\E
?

?

?
The probability of an answer a  Ind(A)n to an n-ary conjunctive query q over
a pABox A and TBox T is
?

?

?
pA,T (a  q) =

EEA : acertT (q,AE )

p(E).

For Boolean CQs q, we write p(A,T |= q) instead of pA,T (()  q), where ()

denotes the empty tuple.

Example 2. Consider again the web data extraction example discussed above.
To illustrate how ontologies can help to reduce uncertainty, we use the DL-Lite
TBox

T = { playsfor  Player

Player  playsfor
Striker  Player
}

playsfor

  SoccerClub

Consider the following subcases considered above.
(1) + (3) The resulting pABox comprises the following assertions with associated
event expressions:

Player(messi)  e1

playsfor(messi, FCbarca)  e3
playsfor(villa, FCbarca)  e3 playsfor(pedro, FCbarca)  e3

with p(e1) = 0.7 and p(e3) = 0.5. Because of the statement playsfor  Player,
using T (instead of an empty TBox) increases the probability of messi to be an
answer to the query Player(x) from 0.7 to 0.85.
(5) The resulting pABox is

playsfor(villa, FCbarca)  e5 playsfor(villa, realmadrid)  e5

with p(e5) = 0.5. Although Player(villa) does not occur in the data, the probability of villa to be an answer to the query Player(x) is 1 (again by the TBoxstatement playsfor  Player).
(3)+(4) This results in the pABox

playsfor(messi, FCbarca)  e3 Striker(messi)  e4

playsfor(villa, FCbarca)  e3
Striker(villa)  e
?

?

?
playsfor(pedro, FCbarca)  e3 Striker(pedro)  e

4 ) = 0.8. Due to the last three CIs in T ,

with p(e3) = 0.5 and p(e4) = p(e
each of messi, villa, pedro is an answer to the CQ y.playsfor(x, y)SoccerClub(y)
with probability 0.9.
?

?

?
4) = p(e

Related Models in Probabilistic Databases. Our pABoxes can be viewed as an
open world version of the probabilistic data model studied by Dalvi and Suciu
in [9]. It is as a less succinct version of c-tables, a traditional data model for
probabilistic databases due to Imielinski and Lipski [18]. Nowadays, there is an
abundance of probabilistic data models, see [15,29,2] and the references therein.

J.C. Jung and C. Lutz

All these models provide a compact representation of distributions over potentially large sets of possible worlds. Since we are working with an open world
semantics, pABoxes instead represent a distribution over possible world descrip-
tions. Each such description may have any number of models. Note that our
semantics is similar to the semantics of (type 2) probabilistic first-order and
description logics [17,25].

Dealing with Inconsistencies. Of course, some of the ABoxes AE might be inconsistent w.r.t. the TBox T used. In this case, it may be undesirable to let them
contribute to the probabilities of answers. For example, if we use the pABox

Striker(messi)  e1 Goalie(messi)  e2

with p(e1) = 0.8 and p(e2) = 0.3 and the TBox Goalie  Striker  , then

messi is an answer to the query SoccerClub(x) with probability 0.24 while one
would probably expect it to be zero (which is the result when the empty TBox is
used). We follow Antova, Koch, and Olteanu and advocate a pragmatic solution
based on rescaling [2]. More specifically, we remove those ABoxes AE that are
inconsistent w.r.t. T and rescale the remaining set of ABoxes so that they sum
up to probability one. In other words, we set

pA,T (a  q) =

pA,T (a  q)  p(A,T |= )

1  p(A,T |= )

inconsistent w.r.t. T . The rescaled probability pA,T (a  q) can be computed in
where  is a Boolean query that is entailed exactly by those ABoxes A that are
PTime when this is the case both for pA,T (a  q) and p(A,T |= ). Note that
rescaling results in some effects that might be unexpected such as reducing the
probability of messi to be an answer to Striker(x) from 0.8 to 0.74 when the
above TBox is added.
In the remainder of the paper, for simplicity we will only admit TBoxes T
such that all ABoxes A are consistent w.r.t. T .

4 Query Rewriting
The main computational problem in traditional OBDA is, given an ABox A,
query q, and TBox T , to produce the certain answers to q w.r.t. A and T . In the
context of lightweight DLs such as DL-Lite, a prominent approach to address
this problem is to use FO-rewriting, which yields a reduction to query answering
in relational databases. The aim of this section is to show that this approach
is fruitful also in the case of computing answer probabilities in probabilistic
OBDA. In particular, we use it to lift the PTime vs. #P dichotomy result on
probabilistic databases recently obtained by Dalvi, Suciu, and Schnaitter [8] to
probabilistic OBDA in DL-Lite.
?

?

?
4.1 Lifting FO-Rewritings to Probabilistic OBDA

We first describe the query rewriting approach to traditional OBDA. A firstorder query (FOQ) is a first-order formula q(x) constructed from atoms A(x) and
r(x, y) using negation, conjunction, disjunction, and existential quantification.
The free variables x are the answer variables of q(x). For an interpretation I,
we write ans(q,I) to denote the answers to q in I, i.e., the set of all tuples a
such that I |= q[a]. In what follows, we use IA to denote the ABox A viewed as
an interpretation (in the obvious way). A first-order (FO) TBox is a finite set
of first-order sentences.

Definition 3 (FO-rewritable). A CQ q is FO-rewritable relative to an FO
TBox T if one can effectively construct a FOQ qT such that certT (q,A) =
ans(qT ,IA) for every ABox A. In this case, qT is a rewriting of q relative to T .
For computing the answers to q w.r.t. A and T in traditional OBDA, one can
thus construct qT and then hand it over for execution to a database system that
stores A.
The following observation states that FO-rewritings from traditional OBDA
are also useful in probabilistic OBDA. We use pdA(a  q) to denote the probability that a is an answer to the query q given the pABox A viewed as a
probabilistic database in the sense of Dalvi and Suciu [8]. More specifically,
?

?

?
pdA(a  q) =

EEA | aans(q,IA

E )

p(E)

The following is immediate from the definitions.
Theorem 1 (Lifting). Let T be an FO TBox, A a pABox, q an n-ary CQ,
a  Ind(A)n a candidate answer for q, and qT an FO-rewriting of q relative
to T . Then pA,T (a  q) = pdA(a  qT ).

From an application perspective, Theorem 1 enables the use of probabilistic
database systems such as MayBMS, Trio, and MystiQ for implementing probabilistic OBDA [1,33,5]. Note that it might be necessary to adapt pABoxes in an
appropriate way in order to match the data models of these systems. However,
such modifications do not impair applicability of Theorem 1.

From a theoretical viewpoint, Theorem 1 establishes query rewriting as a
useful tool for analyzing data complexity in probabilistic OBDA. We say that
a CQ q is in PTime relative to a TBox T if there is a polytime algorithm
that, given an ABox A and a candidate answer a  Ind(A)n to q, computes
pA,T (a  q). We say that q is #P-hard relative to T if the afore mentioned
problem is hard for the counting complexity class #P, please see [32] for more
information. We pursue a non-uniform approach to the complexity of query
answering in probabilistic OBDA, as recently initiated in [26]: ideally, we would
like to understand the precise complexity of every CQ q relative to every TBox T ,
against the background of some preferably expressive master logic used for T .
Note, though, that our framework yields one counting problem for each CQ and

J.C. Jung and C. Lutz

TBox, while [26] has one decision problem for each TBox, quantifying over all
CQs.
Unsurprisingly, pABoxes are too strong a formalism to admit any tractable
queries worth mentioning. An n-ary CQ q is trivial for a TBox T iff for every
ABox A, we have certT (A, q) = Ind(A)n.
Theorem 2. Over pABoxes, every CQ q is #P -hard relative to every first-order
TBox T for which it is nontrivial.
Proof. The proof is by reduction of counting the number of satisfying assignments of a propositional formula.1 Assume that q has answer variables x1, . . . , xn
and let  be a propositional formula over variables z1, . . . , zm. Convert  into
a pABox A as follows: take q viewed as an ABox, replacing every variable x
with an individual name ax; then associate every ABox assertion with  viewed
as an event expression over events z1, . . . , zm and set p(zi) = 0.5 for all i. We
are interested in the answer a = ax1  axn. For all E  EA with E |= , we
have AE =  and thus a / certT (q,AE) since q is non-trivial for T . For all
E  EA with E |= , the ABox AE is the ABox-representation of q and thus
a  certT (q,AE). Consequently, the number of assignments that satisfy  is
pA,T (a  q)  2m. Thus, there is a PTime algorithm for counting the number of
satisfying assignments given an oracle for computing answer probabilities for q
and T .
Theorem 2 motivates the study of more lightweight probabilistic ABox for-
malisms. While pABoxes (roughly) correspond to c-tables, which are among
the most expressive probabilistic data models, we now move to the other end
of the spectrum and introduce ipABoxes as a counterpart of tuple independent
databases [9,12]. Argueably, the latter are the most inexpressive probabilistic
data model that is still useful.

Definition 4 (ipABox). An assertion-independent probabilistic ABox (short:
ipABox) is a probabilistic ABox in which all event expressions are atomic
and where each atomic event expression is associated with at most one ABox
assertion.
To save notation, we write ipABoxes in the form (A, p) where A is an ABox
and p is a map A  [0, 1] that assigns a probability to each ABox assertion.

A p() 
In this representation, the events are only implicit (one atomic event per ABox
assertion). For A  A, we write p(A
) as a shorthand for p({e  E |   A

:
e() = e}). Note that p(A
A\A (1  p()) and thus all
assertions in an ipABox can be viewed as independent events; also note that for
any CQ q, we have pA,T (a  q) =
). Cases (1) and (4) of
our web data extraction example yield ipABoxes, whereas cases (2), (3), and (5)
do not. We refer to [31] for a discussion of the usefulness of ipABoxes/tuple
independent databases. For the remainder of the paper, we assume that only
ipABoxes are admitted unless explicitly noted otherwise.

AA:acertT (q,A) p(A

) =

1 Throughout the paper, we use the standard oracle-based notion of reduction origi-

nally introduced by Valiant in the context of counting complexity [32].


?

?

?
4.2 Lifting the PTime vs. #P Dichotomy

We now use Theorem 1 to lift a PTime vs. #P dichotomy recently obtained in
the area of probabilistic databases to probabilistic OBDA in DL-Lite. Note that,
for any CQ and DL-Lite TBox, an FO-rewriting is guaranteed to exist [6]. The
central observation is that, by Theorem 1, computing the probability of answers
to a CQ q relative to a TBox T over ipABoxes is exactly the same problem as
computing the probability of answers to qT over (ipABoxes viewed as) tuple
independent databases. We can thus analyze the complexity of CQs/TBoxes
over ipABoxes by analyzing the complexity of their rewritings. In particular,
standard rewriting techniques produce for each CQ and DL-Lite TBox an FOrewriting that is a union of conjunctive queries (a UCQ) and thus, together with
Theorem 1, Dalvi, Suciu and Schnaitters PTime vs. #P dichotomy for UCQs
over tuple independent databases [8] immediately yields the following.
Theorem 3 (Abstract Dichotomy). Let q be a CQ and T a DL-Lite TBox.
Then q is in PTime relative to T or q is #P-hard relative to T .
Note that Theorem 3 actually holds for every DL that enjoys FO-rewritability,
including full OWL2 QL. Although interesting from a theoretical perspective,
Theorem 3 is not fully satisfactory as it does not tell us which CQs are in
PTime relative to which TBoxes. In the remainder of this chapter, we carry out
a careful inspection of the FO-rewritings obtained in our framework and of the
dichotomy result obtained by Dalvi, Suciu and Schnaitter, which results in a
more concrete formulation of the dichotomy stated in Theorem 3 and provides
a transparent characterization of the PTime cases. For simplicity and without
further notice, we concentrate on CQs that are connected, Boolean, and do not
contain individual names.
and write q T q

,A) for all ABoxes A. We say that q and q
when certT (q,A)  certT (q
are T -

equivalent and write q T q
 T q. We say that q is T -minimal
if q T q
?

?

?
and q
  q such that q T q
. When T is empty, we simply drop it from

if there is no q
the introduced notation, writing for example q  q
and speaking of minimality.
To have more control over the effect of the TBox, we will generally work with
CQs q and TBoxes T such that q is T -minimal. This is without loss of generality
that is T -minimal
because for every CQ q and TBox T , we can find a CQ q
[4]; note that the answer probabilities relative to T are
and such that q T q

identical for q and q
.

and a TBox T , we say that q T -implies q

For two CQs q, q
?

?

?
We now introduce a class of queries that will play a crucial role in our analysis.

Definition 5 (Simple Tree Queries). A CQ q is a simple tree if there is a

variable xr  var(q) that occurs in every atom in q, i.e., all atoms in q are of
the form A(xr), r(xr, y), or r(y, xr) (y = xr is possible). Such a variable xr is
called a root variable.
The following result shows why simple tree queries are important. A UCQ q is

As examples, consider the CQs in Figure 1, which are all simple tree queries.

reduced if for all disjuncts q, q

ofq, q  q
?

?

?
implies q = q

.
?

?

?
J.C. Jung and C. Lutz

r
?

?

?
t

s

t

q1

t

s

r

q2

s

s

r

q3

Fig. 1. Example queries

Theorem 4. Let q be a CQ and T a DL-Lite TBox such that q is T -minimal
and not a simple tree query. Then q is #P-hard relative to T
Proof. (sketch) Let qT be a UCQ that is an FO-rewriting of q relative to T . By
definition of FO-rewritings, we can w.l.o.g. assume that q occurs as a disjunct
of qT . The following is shown in [8]:

it is #P-hard over tuple independent databases;

1. if a minimal CQ does not contain a variable that occurs in all atoms, then

2. if a reduced UCQ q contains a CQ that is #P-hard over tuple independent
databases, then q is also hard over tuple independent databases.

Note that since q is T -minimal, it is also minimal. By Points 1 and 2 above,
it thus suffices to show that qT can be converted into an equivalent reduced
UCQ such that q is still a disjunct, which amounts to proving that there is no
  q. The details of the proof, which is
disjunct q
surprisingly subtle, are given in the appendix.

in qT such that q  q

and q
?

?

?
To obtain a dichotomy, it thus remains to analyze simple tree queries. We say
that a role R can be generated in a CQ q if one of the following holds: (i) there
is an atom R(xr, y)  q and y = xr; (ii) there is an atom A(xr)  q and
T |= R  A; (iii) there is an atom S(x, y)  q with x a root variable and such
that y = x occurs only in this atom, and T |= R  S. The concrete version
of our dichotomy result is as follows. Its proof is based on a careful analysis of
FO-rewritings and the results in (the submitted journal version of) [8].
Theorem 5 (Concrete Dichotomy). Let T be a DL-Lite TBox. A T -minimal
CQ q is in PTime relative to T iff

1. q is a simple tree query, and
2. if r and r

are T -generated in q, then {r(x, y)} T q or q is of the form



{S1(x, y), . . . , Sk(x, y)}.

Otherwise, q is #P-hard relative to T .
As examples, consider again the queries q1, q2, and q3 in Figure 1 and let T be
the empty TBox. All CQs are T-minimal, q1 and q2 are in PTime, and q3 is
#P-hard (all relative to T). Now consider the TBox T = {s  r}. Then q1
is T -minimal and still in PTime; q2 is T -minimal, and is now #P-hard because


?

?

?


is T -generated. The CQ q3 can be made T -minimal by dropping

both s and s
the r-atom, and is in PTime relative to T .

Theorems 4 and 5 show that only very simple CQs can be answered in PTime.
This issue is taken up again in Section 6. We refrain from analyzing in more detail
the case where also answer variables and individual names can occur in CQs, and
where CQs need not to be connected. It can however be shown that, whenever
a connected Boolean CQ q is in PTime relative to a DL-Lite TBox T , then any
CQ obtained from q by replacing quantified variables with answer variables and
individual names is still in PTime relative to T .

5 Beyond Query Rewriting

We have established FO-rewritability as a tool for proving PTime results for CQ
answering in the context of probabilistic OBDA. The aim of this section is to
establish that, in a sense, the tool is complete: we prove that whenever a CQ q is
not FO-rewritable relative to a TBox T , then q is #P-hard relative to T ; thus,
when a query is in PTime relative to a TBox T , then this can always be shown
via FO-rewritability. To achieve this goal, we select a DL as the TBox language
that, unlike DL-Lite, also embraces non FO-rewritable CQs/TBoxes. Here we
choose ELI, which is closely related to the OWL2 EL profile and properly generalizes DL-Lite (as in the previous sections, we do not explicitly consider the
 constructor). Note that, in traditional OBDA, there is a drastic difference in
data complexity of CQ-answering between DL-Lite and ELI: the former is in
AC0 while the latter is PTime-complete.

We focus on Boolean CQs q that are rooted, i.e., q involves at least one individual name and is connected. This is a natural case since, for any non-Boolean
connected CQ q(x) and potential answer a, the probability pA,T (a  q(x))
that a is a certain answer to q w.r.t. A and T is identical to the probability
p(A,T |= q[a]) that A and T entail the rooted Boolean CQ q[a]. Our main
theorem is as follows.
Theorem 6. If a Boolean rooted CQ q is not FO-rewritable relative to an ELITBox T , then q is #P-hard relative to T .
Since the proof of Theorem 6 involves some parts that are rather technical, we
defer full details to the appendix and present only a sketch of the ideas. A central
step is the following observation, whose somewhat laborious proof consists of a
sequence of ABox transformations. It uses a notion of boundedness similar to
the one introduced in [26], but adapted from instance queries to CQs.
Lemma 1. If a Boolean rooted CQ q is not FO-rewritable relative to an ELITBox T , then there exists an ABox A and assertions R3(a3, a2), R2(a2, a1),
R1(a1, a0) such that A,T |= q, but A
is A with any of the
assertions R3(a3, a2), R2(a2, a1), R1(a1, a0) dropped.

,T |= q when A

We now prove Theorem 6 by a reduction of the problem of counting the number of
satisfying assignments for a monotone bipartite DNF formula, which is known to

J.C. Jung and C. Lutz

R3

a3

R3

b1

...

R2
...

...

c1

...

bnx

R2

cny

R1

R1

a0

Fig. 2. Gadget for the #P-hardness proof

be #P-hard. The reduction is similar to what was done in [9]. More specifically,
input formulas are of the form  = (xi1  yj1 )    (xik
 yjk ) where the set

For the reduction, let  be a formula as above, X = {x1, . . . , xnx

X of variables that occur on the left-hand side of a conjunction in  is disjoint
from the set Y of variables that occur on the right-hand side of a conjunction
in .
}, and Y =
}. We define an ipABox (A, p) by starting with the ABox A from
{y1, . . . , yny
Lemma 1 and duplicating the assertions R3(a3, a2), R2(a2, a1), R1(a1, a0) using
fresh individual names b1, . . . , bnx and c1, . . . , cny . This is indicated in Figure 2
where, in the middle part, there is an R2-edge from every bi to every cj. Apart
from what is shown in the figure, each bi receives exactly the same role assertions
and outgoing edges that a2 has in A, and each ci is, in the same sense, a duplicate
of a1 in A.
In the resulting ipABox A, every assertion except those of the form R3(a3, bi)
and R1(ci, a0) has probability 1; specifically, these are all assertions in A that
are not displayed in the snapshot shown in Figure 2 and all R2-edges in that
figure. The edges of the form R3(a3, bi) and R1(ci, a0) have probability 0.5.
For computing the answer probability p(A,T |= q), one has to consider the
ABoxes A  A with p(A
2|X|+|Y | and
corresponds to a truth assignment A to the variables in X  Y : for xi  X,
A (xi) = 1 iff R3(a3, bi)  A
and for yi  Y , A (yi) = 1 iff R1(ci, a0)  A
.
Let # the number of truth assignments to the variables X  Y that satisfy .
To complete the reduction, we show that p(A,T |= q) = #
2|X|+|Y | . By what was
said above, this is an immediate consequence of the following lemma, proved in
the appendix.
,T |= q.
This finishes the proof of Theorem 6. As a by-product, we obtain the following;
the proof can be found in the long version.
Theorem 7 (ELI dichotomy). Let q be a connected Boolean CQ and T an
ELI-TBox. Then q is in PTime relative to T or #P-hard relative to T .

) > 0. Each such ABox has probability

Lemma 2. For all ABoxes A  A with p(A

) > 0, A |=  iff A

6 Monte Carlo Approximation

The results in Sections 4 and 5 show that PTime complexity is an elusive property even for ipABoxes and relatively inexpressive TBox languages such as DL-
?

?

?
Lite and ELI. Of course, the same is true for probabilistic databases, even for
very simple data models such as tuple independent databases. To address this
fundamental problem, researchers are often trading accuracy for efficiency, replacing exact answers with approximate ones. In particular, it is popular to use
Monte Carlo approximation in the incarnation of a fully polynomial randomized
approximation scheme (FPRAS). In this section, we discuss FPRASes in the
context of probabilistic OBDA.
An FPRAS for a Boolean CQ q and TBox T is a randomized polytime algorithm that, given an ipABox A and an error bound 	 > 0, computes a real
number x such that

|p(A,T |= q)  x|

p(A,T |= q)

Pr
?

?

?
 1
	

 3

.

In words: with a high probability (the value of 3
4 can be amplified by standard
methods), the algorithm computes a result that deviates from the actual result
by at most the factor 1
	 .

It follows from the proof of Theorem 2 and the fact that there is no FPRAS
for the number of satisfying assignments of a propositional formula (unless the
complexity classes RP and NP coincide, which is commonly assumed not to be
the case) that, over pABoxes, there is no FPRAS for any CQ q and TBox T .
Thus, we again have to restrict ourselves to ipABoxes. As observed in [9], it is an
easy consequence of a result of Karp and Luby [21] that there is an FPRAS for
every CQ over tuple independent databases. By Theorem 1, there is thus also an
FPRAS for every CQ q and DL-Lite TBox T over ipABoxes. The same is true
for every FO-rewritable TBox formulated in ELI or any other TBox language.
This observation clearly gives hope for the practical feasibility of probabilistic
OBDA.

It is a natural question whether FPRASes also exist for (CQs and) TBoxes formulated in richer ontology languages. No general positive result can be expected
for expressive DLs that involve all Boolean operators; the basic such DL is ALC
with concept constructors C, C  D, and r.C, a typically well-behaved fragment of OWL DL. As analyzed in detail in [26], there is a large class of Boolean
CQs q and ALC-TBoxes T such that, given a non-probabilistic ABox A, it is
coNP-hard to check the entailment A,T |= q. A computation problem whose
decision version is coNP-hard cannot have an FPRAS [19], and thus we obtain
the following.
Theorem 8. There are CQs q and ALC-TBoxes T such that there is no FPRAS
for q and T .
In ELI, entailment by non-probabilistic ABoxes can be checked in PTime for all
CQs q and TBoxes T . By what was said above, the interesting cases are those
that involve a TBox which is not FO-rewritable. For example, answering the
query A(a) and TBox {r.A  A} over ipABoxes roughly corresponds to a di-
rected, two-terminal version of network reliability problems, for which FPRASes
can be rather hard to find, see for example [20,34]. We leave a detailed analysis

J.C. Jung and C. Lutz

of FPRASes for (CQs q and) ELI-TBoxes T as interesting future work. Ideally,
one would like to have a full classification of all pairs (q,T ) according to whether
or not an FPRAS exists.

7 Conclusion

We have introduced a framework for ontology-based access to probabilistic data
that can be implemented using existing probabilistic database system, and we
have analyzed the data complexity of computing answer probabilities in this
framework. There are various opportunities for future work. For example, it
would be interesting to extend the concrete dichotomy from the basic DL-Lite
dialect studied in this paper to more expressive versions of DL-Lite that, for ex-
ample, allow role hierarchy statements in the TBox. It would also be worthwhile
to add probabilities to the TBox instead of admitting them only in the ABox;
this is done for example in [27,12], but it remains to be seen whether the semantics used there is appropriate for our purposes. Finally, it would be interesting
to study the existence of FPRASes for approximating answer probabilities when
TBoxes are formulated in ELI.

Acknowledgement. This work was supported by the DFG project Prob-DL
(LU1417/1-1).
