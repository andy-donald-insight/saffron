MORe: Modular Combination of OWL
Reasoners for Ontology Classification

Ana Armas Romero, Bernardo Cuenca Grau, and Ian Horrocks

Department of Computer Science, University of Oxford

Abstract. Classification is a fundamental reasoning task in ontology
design, and there is currently a wide range of reasoners highly optimised
for classification of OWL 2 ontologies. There are also several reasoners
that are complete for restricted fragments of OWL 2 , such as the OWL
2 EL profile. These reasoners are much more efficient than fully-fledged
OWL 2 reasoners, but they are not complete for ontologies containing
(even if just a few) axioms outside the relevant fragment. In this paper,
we propose a novel classification technique that combines an OWL 2
reasoner and an efficient reasoner for a given fragment in such a way that
the bulk of the workload is assigned to the latter. Reasoners are combined
in a black-box modular manner, and the specifics of their implementation
(and even of their reasoning technique) are irrelevant to our approach.

Introduction

Classificationthe problem of identifying the subsumption relationships between all pairs of classes in the input ontologyis a fundamental reasoning
task in ontology design. For expressive ontology languages, however, the decision
problems associated with classification have a very high worst-case complexity;
in particular, subsumption with respect to an OWL 2 ontology is known to be
a 2Nexptime-complete problem [15,6].

In spite of these discouraging complexity results, highly optimised reasoners
such as Pellet [21], FaCT++ [22], RacerPro [10] and HermiT [8] are able to
classify many ontologies used in applications. The optimisations employed by
these reasoners aim not only to improve performance on individual subsumption tests, but also to reduce the number of tests performed when classifying a
given ontologymost OWL 2 reasoners use variants of the well-known Enhanced
Traversal Algorithm to incrementally construct a compact representation of the
subsumption relation, along with the told subsumptions optimisation, which provides an inexpensive way of identifying obvious subsumption relationships that
hold in the input ontology [2,11]. Identifying obvious non-subsumptions is also
important, as most possible subsumption relationships do not hold, and has been
addressed by optimisations such as completely defined concepts, which identifies a
fragment of the ontology for which told subsumptions provide complete informa-
tion, model-merging, and other related techniques that exploit the computations
performed during individual class satisfiability tests [23,11,9,8].

P. Cudr e-Mauroux et al. (Eds.): ISWC 2012, Part I, LNCS 7649, pp. 116, 2012.
 Springer-Verlag Berlin Heidelberg 2012

A. Armas Romero, B. Cuenca Grau, I. Horrocks

However, notwithstanding extensive and ongoing research into optimisation
techniques, the classification of large ontologiessuch as the SNOMED medical ontologycan still require a very large number of subsumption tests, and
even if no individual test is very costly, the total amount of time required for
classification can still be large. This (and other performance issues) has motivated a growing interest in so-called lightweight description logics: weaker logics
that enjoy favourable computational properties. OWL 2 includes several profiles
(language fragments) based on such lightweight DLs, including OWL 2 EL, a
profile based on the EL++ DL for which most standard reasoning tasks can be
performed in polynomial time [19]. Very efficient profile-specific reasoners have
been developed for OWL 2 EL, including CEL [3] and ELK [16], which can
classify ontologies as large as SNOMED in just a few seconds.
Unfortunately, a reasoner for profile L (an L-reasoner) is only able to (com-
pletely) classify ontologies in the L profile (L-ontologies), and restricting the
ontology to a given profile may be undesirable or even infeasible in practice,
with many existing ontologies falling outside all of the tractable profiles of OWL
2. In many cases, however, such ontologies contain only a relatively small number
of axioms that are outside one of the tractable fragments. For example, of the
219,224 axioms in the latest version of the National Cancer Institute Ontology
(NCI), only 65 are outside the OWL 2 EL profile. Using a suitable L-reasoner
to efficiently classify most classes (i.e., to find all their subsumers) in the signature (or vocabulary) of a given ontology might, therefore, lead to significant
improvements in performance. Unfortunately, using an L-reasoner in this way is
far from simple, as even a single axiom that is outside L could affect every class
in the ontology.
In this paper, we propose a novel technique where an efficient L-reasoner and
a fully fledged OWL 2 reasoner are combined in a modular way to classify an
OWL 2 ontology. More precisely, given an OWL 2 ontology O, and a fragment
L of OWL 2 , our classification algorithm proceeds as follows:

L  Sig(O) and an L-ontology ML  O such that
can be completely classified using only the axioms in ML
.
can be

1. It computes a signature 
2. It computes an ontology ML  O such that the classes in O \ 
3. It classifies ML

the classes in 
fully classified using only the axioms in ML
the classification of O by classifying ML

using a fully-fledged OWL 2 reasoner and then completes

using an L-reasoner.

.

must be complete for 

Step 1 involves two important technical challenges. First, 
should be as large
as possible; in particular, for ontologies with only a few non L-axioms, it is
reasonable to expect 
to contain most of the ontologys signature. Second,

; i.e., if a subsumption relationship between two
classes in 
. Although
techniques such as the completely defined concepts optimisation can be used to
identify a fragment of the ontology that is complete for a certain signature, these
techniques are very restrictedthey are not applicable to all OWL 2 ontologies,
and even when they are applicable they use a fixed fragment of OWL 2 that

is entailed by O, then it must also be entailed by ML
?

?

?
is much smaller than the OWL 2 EL profile. In contrast, we exploit module
extraction [5,4] to develop a technique that provides the following compelling
features:

 It is general and flexible, as it is neither tied to any particular fragment or
profile L of OWL 2, nor to any particular reasoner or reasoning technique.
 It is easy to implement, as reasoners are combined in a black-box manner,
with no modification of their internals being required.
 It exhibits pay-as-you-go behaviour when an L-ontology is extended with
axioms outside L: on the one hand, the use of an L-reasoner is not precluded
by the extension; on the other hand, performance degrades gracefully with
the number of additional non L-axioms.

We believe that our results are interesting from both a theoretical and a practical
point of view. From a theoretical point of view, we show that given an OWL
2 ontology O that is not captured by any known tractable fragment of OWL
2, it is often possible to identify a large subset  of its signature such that all
subsumers of classes in  w.r.t. O can be computed using a polynomial time
classification algorithm. From a practical point of view, our experiments with a
prototype implementation MORe,1 which integrates the OWL 2 reasoner HermiT
and the OWL 2 EL reasoner ELK, illustrate the potential of this approach for
optimising classification and providing a modular reasoning system with robust
pay-as-you-go performance.

2 Preliminaries

We assume basic familiarity with the W3C standard OWL 2 [6] and its EL profile
[19]. When talking about ontologies and axioms we implicitly refer to OWL 2
ontologies and axioms, and when talking about OWL 2 we implicitly refer to
OWL 2 under the direct semantics [20].

For compactness reasons, we adopt description logic notation rather than
OWL syntax in examples and definitions; hence we also assume basic familiarity
with the syntax and semantics of the DLs SROIQ [12] and EL++ [1], which
provide the logical underpinning for OWL 2 and OWL 2 EL, respectively.

We consider the standard notions of signature (or vocabulary), interpretations
and models, entailment, satisfiability, and class subsumption. We denote with
Sig(O) (respectively, Sig()) the signature of an ontology O (respectively, of an
axiom ), and use the greek letters  and  to denote signatures. We denote
with L a generic fragment of OWL 2either one of its profiles or any other
possible fragment for which we may have an efficient reasoner. Finally, given an
OWL 2 ontology O, we denote with OL the set of L-axioms in O.

2.1 Module Extraction
Intuitively, a module M for an ontology O w.r.t. a signature  is an ontology
M  O such that M and O entail the same axioms over  [5].
1 Modular OWL Reasoner.

A. Armas Romero, B. Cuenca Grau, I. Horrocks

BursitisOrCellulitisOfKnee
::::::::::::::::::::


: BursitisOfKnee  CellulitisOfKnee

::::::::::::::::::::::::::

BursitisOfKnee  Bursitis  hasLocation.Knee
BursitisOfJoint  Bursitis  hasLocation.Joint

Bursitis  Swelling
Cellulitis  Swelling  hasOrigin.Infection

InfectiousDisease  hasOrigin.Infection

hasOrigin.  Disease

Knee  Joint

(1)

(2)

(3)

(4)

(5)

(6)

(7)

(8)

Fig. 1. The example ontology Oex. Its only non OWL 2 EL axiom is underlined

= 

,I
= X

for every symbol X  .

) of M, there exists a model J = (
?

?

?
This intuition is typically formalised using the notions of deductive and modelbased conservative extensions [17,5]. In this paper, we define modules in terms
of the model-based notion of conservative extension.
Definition 1 (Model Conservative Extension). Let O be an ontology and
let   Sig(O). We say that O is a model conservative extension of M  O
,J
w.r.t.  if, for every model I = (

)
of O such that 
?

?

?
and X
That is, O is a model conservative extension of M for  if every model of M can
be extended to a model of O without changing either the interpretation domain,
or the interpretation of the symbols in .
Definition 2 (Module). Let O be an ontology and let  be a signature. We say
that M  O is a module for O w.r.t.  if O is a model conservative extension
of M w.r.t. .
In particular, if M is a module for O w.r.t. , then the following condition
holds: for each axiom  with Sig()  , we have M |=  iff O |= .
Example 1. Consider the ontology Oex, given in Figure 1, which we will use as a
running example. Consider also the fragment Oex
1 = {(1), (2), (3), (4), (8)} of Oex.
1 . We can obtain a model of Oex by interpreting
Let I be an arbitrary model of Oex
all symbols in Sig(Oex
1 ) in the same way as I, and all symbols outside Sig(Oex
1 )
as the empty set. Thus, Oex is a model conservative extension of Oex
1 , and Oex
is a module for Oex w.r.t. Sig(Oex
1 ). As a result, Oex and Oex

1 entail exactly the
same axioms constructed using only symbols from Sig(Oex

1 ).
The problem of checking whether M is a module for O w.r.t.  is, however,
already undecidable for fairly lightweight fragments of OWL 2, such as the OWL
2 EL profile [18]; therefore, approximations are needed in practice. The following
sufficient condition for model conservativity is known to work well [5,7].
?

?

?
Definition 3 (-locality). Let  be a signature. An interpretation I is -local
for  if for every class A   and every property R  , we have A
= .

An axiom  is -local for  if I |=  for each I that is -local for . An ontology
O is -local for  if every axiom in O is -local for .
Example 2. It is easy to check that the ontology Oex \ Oex
1 , consisting of axioms
(5), (6) and (7), is -local w.r.t. Sig(Oex
1 ). For example, to see that axiom (5)
is indeed -local w.r.t. Sig(Oex
1 ), consider any I that interprets all symbols in
(5) other than those in Sig(Oex

1 ) as the empty set. Thus, we have Cellulitis
=
= . Clearly, both left and right hand sides of axiom (5)

hasOrigin
are interpreted as the empty set by I (see below) and hence I satisfies (5).

= Infection

= R

  
Cellulitis  Swelling  


?

?

?

?

?

?
  
?

?

?
Infection



hasOrigin .
?

?

?


for any 

  .


Checking -locality for OWL 2 axioms is, however, a Pspace-complete problem
[5]. Since our goal is to optimise classification, checking -locality might still
be too costly. Instead, we will use -localitya well-known sufficient syntactic
condition for -locality which has been successfully used for both ontology reuse
and reasoning problems [5,14,7,4].
The grammar defining -locality for SROIQ can be found in the literature
[4,5]. It suffices to note that -locality can be checked in polynomial time and
that it implies -locality. Furthermore, the following property holds [4,5]:
Proposition 1. If an axiom  is -local w.r.t. a signature , then  is -local
w.r.t. 
We use -locality to define the notion of -module. The fact that -locality
implies -locality ensures that, if M is a -module for O w.r.t.  (as defined
next), then it is a module for O w.r.t. .
Definition 4 (-module). Let O be an ontology and let  be a signature. We
say that M  O is a -module for O w.r.t.  if O\M is -local for Sig(M).
Example 3. It was pointed out in Example 2 that Oex \ Oex
is -local w.r.t.
1 is also -local w.r.t Sig(Oex
Sig(Oex

1 ), and therefore
Oex

1 is a -module for Oex w.r.t Sig(Oex
1 ).
The algorithm for -module extraction [7] is given in Algorithm 1. This algorithm computes the unique smallest -module for a given O and  (the smallest
subset M  O s.t. O\M is -local for  Sig(M)). We refer to such a smallest
-module as the -module for O w.r.t. , and denote it with M[O,].
Example 4. Suppose that we want to extract a -module for O w.r.t.  , with

1 ). In particular, Oex \ Oex

 = {Knee, Bursitis, hasLocation}

It can be observed in Algorithm 1 that new symbols added to the modules
signature in some iteration may cause more axioms to be added to the module

A. Armas Romero, B. Cuenca Grau, I. Horrocks

:= O

Algorithm 1. -module(O, )
Input: an ontology O and a signature 
1: M := ; O
2: repeat
3:
4:
5:
6:
7:
8: until changed = false
9: return M

M := M  {}; O
changed := true

changed := false
for all   O

do

if  not -local w.r.t   Sig(M) then

:= O \ {}

in subsequent iterations. The algorithm stops once a fixpoint is reached and no
more symbols need to be added to the modules signature.

1 and its signature is precisely Sig(Oex
1 ).

On the first iteration, we would only add axioms (2), (4) and (8) to our
module. Then, due to having added Joint and BursitisOfKnee to the modules
signature, we would have to add axioms (1) and (3) as well. We would thus find
that M[Oex, ] coincides with Oex

In addition to being modules as in Definition 2, -modules enjoy a property that
makes them especially well-suited for optimising classification [4].
Proposition 2. Let O be an ontology, let A, B be classes in Sig(O)  {,},
let   Sig(O) with A  , and let M  O be a -module in O w.r.t. . Then
O |= A  B iff M |= A  B.
Example 5. Proposition 2 implies that O |= Bursitis  Cellulitis. Indeed, we have
that Bursitis   but Cellulitis / Sig(M[O, ]); therefore, it must be the case that
M[O, ] |= Bursitis  Cellulitis, and thus O |= Bursitis  Cellulitis.


3 Modular Classification of Ontologies
Consider an ontology O such that most of the axioms in it are expressed in some
restricted fragment L of OWL 2. This is the case, considering L = OWL 2 EL,
for our example ontology Oex, whose L-fragment OexL contains all the axioms in
Oex except axiom (1).
L  Sig(O) such that the corresponding -module M[O,L] is contained in the L-fragment OL of O. We call
an L-signature for O. Proposition 2 ensures that an L-reasoner
. Section 3.1

any such 
can then be used to determine all the subsumers of classes in 
addresses the problem of identifying as large an L-signature as possible.

Our first goal is to identify a signature 

has been identified, the use of a fully-fledged OWL
2 reasoner can be restricted to computing the subsumers of the classes in the
complementary signature L = Sig(O)\
. The details of how our classification

Once an L-signature 
?

?

?
algorithm combines the use of both an L-reasoner and an OWL 2 reasoner as
black boxes are given in Section 3.2.

3.1 Computing an L-signature
The definition of -module suggests a simple guess and check algorithm for
computing a (maximal) L-signature for O: consider all subsets   Sig(O)
in decreasing size order and, for each of them, check whether M[O,] is an L-

ontology. This could, however, be quite costly, and as our objective is to optimise
classification we propose a goal directed algorithm. Although our algorithm is
not guaranteed to compute a maximal L-signature, it can be implemented very
efficiently; furthermore, as shown in the evaluation section, it typically computes
large L-signatures, provided that OL is a large enough fragment of O.
() below. If () does not hold, then M[O,L] will contain some non L-axiom.

We start by pointing out that every L-signature 

must satisfy the property

Property ():

O \ OL is -local w.r.t. 

Example 6. Consider again our example ontology Oex and let L be OWL 2 EL.
As already mentioned, the L-fragment OexL of Oex contains all axioms in Oex
except for (1). One may think that the signature of OexL is an L-signature, which
makes the computation of a maximal L-signature trivial; this is, however, not
the case. Note that the signature of OexL , namely

Sig(OexL ) = Sig(Oex) \ {BursitisOrCellulitisOfKnee, CellulitisOfKnee}

is not an L-signature for Oex; indeed, axiom (1) is not -local w.r.t Sig(OexL ). In
contrast, we have that axiom (1) is -local w.r.t.
?

?

?


= {Bursitis, hasLocation, Joint, BursitisOfJoint, Swelling, Infection,

InfectiousDisease, Disease, hasOrigin}

Furthermore, M[Oex, ] consists of axioms (3), (4) (5) (6) (7), which are all within


is an L-signature for Oex.

the OWL 2 EL fragment; hence, 
?

?

?
Although Example 6 might suggest that property () is also a sufficient condition
for 

to be an L-signature in O, this is unfortunately not the case.

Example 7. Consider again the signature  from Example 4. Clearly, axiom (1)
(the only non L-axiom in Oex) is -local w.r.t  and hence () holds for  .
Note, however, that  is not an L-signature for Oex since, as already discussed,
axiom (1) is contained in M[Oex, ]. One way to address this problem is to reduce
 to  \ {Knee}. The corresponding -module only contains axiom (4), which

implies that such reduced signature is indeed an L-signature for Oex.
Example 7 suggests an algorithm for computing an L-signature for O, which can
be intuitively described as follows.

A. Armas Romero, B. Cuenca Grau, I. Horrocks

1. Reduce 0 = Sig(O) to a subset 1 of 0 such that S0 = O \ OL is -local
2. Compute the set S1 of axioms in M[O,1] containing symbols not in 1.
3. Reduce 1 to a subset 2 of 1 such that S1 is -local w.r.t. 2.

w.r.t. 1 (thus satisfying ()).

4. Repeat Steps [2-4] until the set of axioms computed in Step 2 is empty.
The sequence (i)i0 will eventually converge to a fixpoint (as we will shortly
prove), and this fixpoint will be guaranteed to be an L-signature, 
. We next
explain the intuition behind our algorithm with an example.
Example 8. Consider once more our example ontology Oex. As already men-
tioned, the only non OWL 2 EL axiom is (1), so we start with

0 = Sig(Oex)
S0 = {BursitisOrCellulitisOfKnee  BursitisOfKnee  CellulitisOfKnee}

The only way to make axiom (1) -local is by removing BursitisOrCellulitisOfKnee,
BursitisOfKnee and CellulitisOfKnee from 0. So we take

1 = 0 \ {BursitisOrCellulitisOfKnee, BursitisOfKnee, CellulitisOfKnee}

Next, we compute M[Oex,1] using Algorithm 1. This module contains axiom (2),
which mentions BursitisOfKnee (not in 1). Because this class is in the modules
signature, the module needs to contain axiom (1) as well. This gives us

S1 = {BursitisOrCellulitisOfKnee  BursitisOfKnee  CellulitisOfKnee,

BursitisOfKnee  Bursitis  hasLocation.Knee}

At this point, we need not worry about axiom (1) anymore; it was already

cannot be outside the module either. Thus, we need to make sure that axiom

We have seen that, unless axiom (2) in S1 is outside the module, axiom (1)
(2) is -local. For this, we can take 2 = 1 \ {Knee}.
local w.r.t. 1, so, by Proposition 1, it will be -local w.r.t. any subset of 1.
Next, we compute M[Oex,2] and find that it contains all axioms in Oex except
for axioms (1), (2) and (8). This implies that all symbols in M[Oex,2] are in 2
and hence S3 = . The algorithm then terminates and returns 
is indeed an L-signature since the module M[Oex,2] does not


contain axiom (1) and hence is an OWL 2 EL ontology.

Note that 

= 2.

Note that there can be many ways to perform the signature reduction required

in Steps 1 and 4. In Example 8, for instance, we could have taken 2 = 1 \
{Bursitis} or 2 = 1 \ {hasLocation}, or even any subset thereof. Making rea-

sonable choices requires good heuristics. In our implementation our choices are
guided so that as many properties as possible are kept within 
. Indeed, ontologies typically contain many more classes than properties, and each property
typically occurs in a larger number of axioms; thus, having a property outside


. The following
example illustrates how different choices lead to rather different L-signatures.

is likely to cause many other symbols to be left outside 
?

?

?
Algorithm 2. L-signature(O)
Input: an ontology O
:= Sig(O) ; S := O \ OL
1: 
2: canReduce := true
3: while S =  and canReduce do
4:
5:
6:
7: return 

=  then canReduce := false
else S := {  M[O,L] | Sig()  

:= reduce(


if 

, S)

L}

Example 9. As already mentioned, in Example 8 we could have alternatively

chosen to take 2 = 1 \{hasLocation}. This would have caused M[O,2] = Oex

again, and we would have obtained

S3 = S2  {BursitisOfJoint  Bursitis  hasLocation.Joint}

It would now be enough to take 3 = 2 \{BursitisOfJoint}, and we would have
S4 = . In this case we would get 
= 3, which is smaller (and hence less


obtained in Example 8.

appealing) than the 

These signature reductions satisfy the same properties that make them accept-
able. We can characterise these acceptable reductions as given next.
Definition 5. Given an ontology O, a signature reduction is a function

reduce : P(Sig(O))  P(O)  P(Sig(O))
?

?

?
exists.

if S =  and 

   s.t. each axiom in S is -local w.r.t. 

that, given   P(Sig(O)) and S  P(O) not -local w.r.t. , returns
1.  if S = .
2. 
3.  otherwise.
Note that the Cases 1 and 3 correspond to the extreme situations when S = 
or when there is no satisfying way of reducing . Case 2 constitutes the essence
of the reduction, namely to compute a strict subset of the signature that makes
the given set of axioms -local.
Given a particular reduce function, Algorithm 2 accepts an ontology O and
L  Sig(O). Theorem 1 guarantees the termination of
returns a signature 
Algorithm 2 as well as its correctness: any non-empty signature returned by the
algorithm is an L-signature for O.
Theorem 1. Let O be an ontology and let reduce be a signature reduction func-
tion. Furthermore, let Si, i (i  0) be defined by the following construction:

(i = 0) : 0 = Sig(O)
(i  1) : i = reduce(i1,Si1) Si = {  M[O,i] | Sig()  i}

S0 = O \ OL
?

?

?
A. Armas Romero, B. Cuenca Grau, I. Horrocks

Finally, let 

i0 i. Then, the following properties hold:
1. There exists k < |Sig(O)| such that either k =  or Sk = .

:=

2. Either 

=  or M[O,L]  OL.

L  Sig(M[O,L]).

We finally show Claim 2. Suppose 

First, we are going to see that Sig(M[O,L])  

Proof. We first show Claim 1. Suppose i =  for each i  0. A straightforward
inductive argument would show that j  i for each j > i  0. Furthermore,
0 = Sig(O), so it cannot be the case that j  i for each 0  i < j  |Sig(O)|.
Therefore, there must be some k < |Sig(O)| such that k+1 = k; by the
definition of reduce, this implies that Sk = .
L = . It is enough to prove that each
  O \ OL is -local w.r.t. 
there exists k < |Sig(O)| such that Sk = . This implies that, for each axiom

  M[O,k], we have Sig()  k. It is easy to see that Sk =  also implies that
j = k for each j > k. Together with the fact that j  i for each j > i  0,
i0 i = k. But then for each   M[O,L] = M[O,k] we

have Sig()  k = 

Now we can just prove that each   O \ OL is -local w.r.t. 
i0 i = , in particular it must be the case that 0 = . By definition

=
of reduce, either O \ OL = , in which case it is immediate that M[O,L]  OL,
or every axiom in S0 = O \ OL is -local w.r.t. 1 = reduce(0,S0). Then, by

Proposition 1, each   O \ OL is -local w.r.t. 

, and so Sig(M[O,L])  

. According to Claim 1,

this implies 

. Because

L  1.

=

.



3.2 Black-Box Modular Classification
Having identified a (hopefully large) L-signature for our ontology O, we can next
proceed to classify the ontology in a modular way.
using only an L-
reasoner. This is a consequence of Proposition 2 and the fact that M[O,L]  OL.

As already mentioned, we can fully classify the classes in 
To classify the classes in L = Sig(O) \ 

Once the OWL 2 reasoner has computed the classification of M

, however, a fully fledged OWL 2
reasoner is still required. By Proposition 2, the OWL 2 reasoner does not need
to consider all the axioms in O, but only those in the relevant module M
[O,L].
[O,L], we
can express the classification result as simple subsumption axioms of the form
A  B. These axioms, together with M[O,L], can be given to the L-reasoner,
which will use the resulting ontology to compute a complete classification of O.
Algorithm 3 describes the entire classification process for a given fragment L
of OWL 2 and a particular signature reduction function reduce. The function
L-signature is as given in Algorithm 2. The function classification returns the
classification of the given ontology (computed using an OWL 2 reasoner) as
a set of axioms of the form A  B. The function classificationL returns the
classification of the given ontology as computed by an L-reasoner.
?

?

?
Algorithm 3. L-ModularClassification(O)
Input: an OWL 2 ontology O
:= L-signature(O)

1: 
L := classification(M
2: H
[O,L])
3: H := classificationL(M[O,L]  H
4: return H

L )

 See Algorithm 2
 using the OWL 2 reasoner
 using the L-reasoner

Example 10. Recall the L-signature 

for Oex computed in Example 8:
= {Bursitis, hasLocation, BursitisOfJoint, Joint, Swelling, Cellulitis,



hasOrigin, Infection, InfectiousDisease, Disease}

The complementary signature is

L = {BursitisOrCellulitisOfKnee, BursitisOfKnee, CellulitisOfKnee, Knee}

and the relevant -module is M
tion of this module leads to the following subsumptions H

[Oex,L] = {(1), (2), (3), (4), (8)}. The classifica-

L :

CellulitisOfKnee  BursitisOrCellulitisOfKnee
BursitisOfKnee  BursitisOrCellulitisOfKnee
BursitisOfKnee  BursitisOfJoint
BursitisOfKnee  Bursitis

BursitisOfJoint  Bursitis
Bursitis  Swelling

Knee  Joint

We can now use the L-reasoner to classify M[O,L]  H
the remaining subsumption relationships that hold in Oex:

L, thus obtaining all

Cellulitis  Swelling
InfectiousDisease  Disease

Cellulitis  InfectiousDisease
Cellulitis  Disease



The following Theorem establishes the correctness of Algorithm 3.
Theorem 2. Let O be an ontology, let reduce be a signature reduction function
and let M[O,L], H
L be as computed by Algorithm 3. Then, for any two classes
A  Sig(O) and B  Sig(O)  {,}, we have that

O |= A  B iff (M[O,L]  H

L) |= A  B

Proof. Let A  Sig(O) and B  Sig(O)  {,}. We consider two cases.
 Case 1: A  

M[O,L] |= A  B. Also, because M[O,L]  M[O,L]  H
tonicity we have that M[O,L] |= A  B implies (M[O,L]H

. Then, by Proposition 2, we have that O |= A  B iff
L, by mono-
L) |= A  B.

It remains to show that

(M[O,L]  H

L) |= A  B implies M[O,L] |= A  B

(9)

A. Armas Romero, B. Cuenca Grau, I. Horrocks

L) |= A  B implies (M[O,L]  M

L encodes the classification of M

Because H
(M[O,L]  H
Now, it is immediate that M[O,L]  M
is a module for O w.r.t. 
w.r.t. 

. So, again by Proposition 2, we have

[O,L]

(M[O,L]  M

[O,L], we have that

[O,L]) |= A  B (10)
 O; thus, because M[O,L]
[O,L]

, it must also be a module for M[O,L]M

[O,L]) |= A  B implies M[O,L] |= A  B

(11)

[O,L]

Now, (10) and (11) imply (9), as required.

we have M

. Then, by Proposition 2, O |= A  B iff
 Case 2: A  L = Sig(O) \ 

L represents the classification of M
|= A  B. Because H
[O,L],
|= A  B iff H
L |= A  B. It remains to show that
[O,L]
L |= A  B iff M[O,L]  H

L |= A  B

(12)

L |= A  B. Since H

M[O,L]  H
we have M[O,L]  M
M[O,L]  M
[O,L]
By Proposition 2, M

Left to right implication holds directly by monotonicity, so let us assume
[O,L],
[O,L] is a -module for
 O w.r.t. L since it is a -module for O w.r.t. L.

[O,L]

L is the classification of M

|= A  B, which implies H

|= A  B. Now, M

L |= A  B.

[O,L]

Implementation and Experiments

We have implemented our modular reasoner MORe2 in Java using the OWL
API.3 Our implementation of a signature reduction function reduce (see Section
3.1) is based on the -locality module extractor described in [14].4 Our system
currently integrates ELK, which acts as an OWL 2 EL reasoner, and HermiT,
which plays the role of a fully-fledged OWL 2 reasoner.
In the implementation of the signature reduction, symbols required to make
a set of axioms -local are selected greedily axiom by axiom. As discussed in
Examples 8 and 9, when selecting symbols it is often a good idea to implement
heuristics that try to keep as many properties as possible within 

.

Evaluation on BioPortal Ontologies. We have compared classification times
obtained by MORe and HermiT over a set of large bio-medical ontologies available from BioPortal.5 Results are summarised in the upper part of Table 1. The
Gene Ontology (GO) and Gazetteer are OWL 2 EL ontologies; therefore, MORe
delegates all the work to ELK, with the consequent performance improvement.
For the latest version of NCI and for Protein, which contain only a small number

http://www.cs.ox.ac.uk/isg/tools/MORe/
http://owlapi.sourceforge.net/
http://www.cs.ox.ac.uk/isg/tools/ModuleExtractor
http://bioportal.bioontology.org/
?

?

?
Table 1. MORe vs HermiT. Comparison on BioPortal ontologies and on mapped on-
tologies. Tables show number of axioms outside OWL 2 EL, relative size of 
and

[O,L], and classification times using HermiT and MORe. For MORe we specify the
performance gain w.r.t. HermiT alone and the time taken by HermiT and ELK.

Ontology |O \ OL|

|

L|

|M

|

[O,L]

HermiT

Gazeteer

Protein
Biomodels
cellCycle
NCI+CHEBI
NCI+GO
NCI+Mouse
?

?

?
22,079

100%
100%

0%
0%

7.1
838.1
94.9% 15.4%
84.1
98.1%
6.6%
11.4
45.2% 66.4% 741.4

1 > 99.9% < 0.1%


?

?

?
95.6%
96.7%
96.0%

10.3% 116.6
10.4% 110.0
13.3%
93.7

Classif. time (seconds)

MORe

total

2.2 (69.0%)
28.2 (96.6%)
28.6 (66.0%)
2.9 (74.6%)
575.6 (22.4%)
13.9 (
34.0 (70.8%)
37.6 (65.8%)
31.0 (66.9%)

HermiT ELK
0.1
15.6
3.3
0.9
2.6
4.9
4.1
3.2
2.6
?

?

?
15.8
0.4
540.1
) <0.1
16.3
17.6
16.6



contains most of Sig(O), and
of axioms outside OWL 2 EL, the obtained 
hence MORe significantly outperforms HermiT. Biomodels, however, contains a
large number of axioms outside OWL 2 EL, thus the size of 
is proportionally much smaller and MORe must assign a higher workload to HermiT, which
results in a more modest performance gain. Finally, the Cell Cycle ontology is
an extreme case: an ontology that is almost OWL 2 EL and can be classified
efficiently with MORe, while HermiT alone runs out of memory.

Evaluation on Ontologies Integrated via Mappings. We have used the
ontology matching tool LogMap [13] to integrate the latest version of NCI with
other widely used ontologies. Results are summarised in the lower part of Table
1. We can observe that MORe consistently outperforms HermiT by 65-70%.

Evaluation on versions of NCI. We have compared MORe with HermiT on
10 versions of NCI.6 Unsurprisingly, there have been significant variations in 10
years of development; for example, a 2003 version was entirely in OWL 2 EL, a
version in 2009 contained more than 4, 000 axioms outside OWL 2 EL, and the
current version only contains 65. Figure 2 summarises our results; in all cases,
MORe outperforms HermiT.

Extensions of SNOMED. We have manually extended SNOMED (v. Jan
2010), which is fully expressed in OWL 2 EL, with a few disjunctive axioms
suggested by domain experts who are involved in SNOMEDs development. All
these axioms share the same structure; for example,

Sprain of ankle OR foot  Sprain of ankle  Sprain of foot

6 See http://ncit.nci.nih.gov/. We consider the latest version in each year.

A. Armas Romero, B. Cuenca Grau, I. Horrocks

e
m

i
t
 
n
o
i
t
a
c
i
f
i
s
s
a

l

MORe
HermiT

v.03.12e (0)

v.04.12g (3201)

v.05.12f (3180)

v.06.12d (4532)

v.07.12e (4597)

v.09.12d (577)
v.08.12d (4592)

v.10.12c (31)

v.11.12e (65)

v.12.04e (65)

NCI version and number of non-EL axioms

Fig. 2. Classification times (seconds) for MORe and HermiT on NCI. The X axis indicates the version and the number of axioms outside OWL 2 EL (in parenthesis).

Table 2. Extensions of SNOMED

L|

|M

[O,L]

| Classif. time
HermiT MORe

# |
1 99.98% 0.10% 1,788.5 25.3
2 99.94% 0.24% 1,959.2 29.0
3 99.88% 0.52% 1,872.8 29.3
4 99.86% 0.61% 1,933.2 30.9
5 99.86% 0.63% 1,898.6 31.6
6 99.86% 0.63% 1,920.2 31.0
7 99.86% 0.64% 1,884.8 31.8
8 99.85% 0.65% 1,868.2 31.3
9 99.85% 0.66% 1,937.2 31.9
10 99.79% 1.00% 1,863.7 32.8

L|

|M

[O,L]

| Classif. time
# |
HermiT MORe
30.6
1.00% 1,922.5
11 99.79%
30.6
1.01% 1,912.4
12 99.79%
30.5
1.02% 1,864.0
13 99.78%
33.0
1.91% 1,890.5
14 99.76%
42.9
3.19% 1,925.9
15 98.76%
9.79% 1,930.2 138.5
16 97.10%
17 97.08%
9.89% 1,927.9 134.7
18 96.27% 13.50% 1,881.4 269.8
19 94.10% 17.65% 1,847.4 401.1
20 94.02% 17.78% 1,904.0 410.8

introduces a new class that is fully defined as the set of all sprains that affect
either the ankle or the foot (or both). In total, 20 such axioms were added to
SNOMED, one by one.

Table 2 presents the results obtained for these extended ontologies. Each of
them is identified, in the first column, by the number of disjunctive axioms
that it contains. The second and third columns indicate the relative sizes of
the computed L-signature and the resulting M
[O,L]. The last two columns
give the classification times obtained using MORe and HermiT. In most cases
classification times are improved by between one and two orders of magnitude.
?

?

?
and, consequently, on the size of M

We can observe, however, that axioms 15, 16, 18, and 19 have a significant
[O,L] and the total
effect on the size of 
classification time. This is due to the classes involved in these particular axioms,
which force our algorithm to keep very general classes outside 
; for example,
in one of these cases, the class Liquid Substance is removed from the successive
approximations to 
at some point during its computation; by Proposition 2,
all classes representing some kind of liquid substanceand therefore subsumed
by the class Liquid Substancemust be left outside 
too, which leads to a
significantly smaller L-signature. It is part of our future work plan to improve
the heuristics we use in order to avoid, when possible, leaving out of 
classes
that are likely to be high up in the class subsumption hierarchy.

5 Conclusion and Future Work

In this paper, we have proposed a technique for classifying an OWL 2 ontology
O by exploiting a reasoner for one of its profiles. Our technique allows us to show
that the subsumers of many classes in O can be completely determined using
only the fragment-specific reasoner. Our technique is general and flexible, it exhibits pay-as-you-go behaviour, and it is relatively easy to implement. Although
the implementation in our reasoner MORe is still prototypical, our preliminary
experiments show the potential of our approach in practice.

There are also many interesting possibilities for future work:
 Our heuristics for computing an L-signature are rather basic, and there is
plenty of room for improvement. For example, it might be possible to explore
modular decomposition techniques to compute larger L-signatures [24].
 -modules provide very strong preservation guarantees (they preserve not
just atomic subsumptions, but even models). It would be interesting to devise
techniques for extracting modules that are more permissive, in the sense
that they only provide preservation guarantees for atomic subsumptions.

 Our technique could also be applied to a different notion of locality, as long

as it satisfied a result analogous to Proposition 2.
extraction. By rewriting O into an L-ontology O
classifying O

 We could explore ontology rewriting techniques that complement module
such that O |= O, and
, we can obtain an upper bound on the classification of O.

Acknowledgements. This work was supported by the Royal Society, the EU
FP7 project Optique and the EPSRC projects Score!, ExODA and LogMap.
