Extending Description Logic Rules

David Carral Mart nez and Pascal Hitzler

Kno.e.sis Center, Wright State University, Dayton, OH, U.S.A.

Abstract. Description Logics  the logics underpinning the Web Ontology Language OWL  and rules are currently the most prominent
paradigms used for modeling knowledge for the Semantic Web. While
both of these approaches are based on classical logic, the paradigms also
differ significantly, so that naive combinations result in undesirable properties such as undecidability. Recent work has shown that many rules can
in fact be expressed in OWL. In this paper we extend this work to include some types of rules previously excluded. We formally define a set
of first order logic rules, C-Rules, which can be expressed within OWL
extended with role conjunction. We also show that the use of nominal
schemas results in even broader coverage.

Introduction

Several different paradigms have been devised to model ontologies for the Semantic Web [6]. Currently, the most prominent approaches for modeling this knowledge are description logics (DLs) [1] and rules based on the logic programming
paradigm. Although both are based on classical logic, they differ significantly
and the search for a satisfactory integration is still ongoing [4,11].

Even if the DL-based Web Ontology Language OWL [5], a W3C standard,
is the main language for modeling ontologies in the Semantic Web, rule-based approaches have also proven very successful. Included in many commercial
applications, rules continue to be pursued in parallel to OWL using the Rule
Interchange Format RIF [2], also a W3C standard, as a rule exchange layer. Understanding the differences between both paradigms in order to come up with
workable combinations has become a major effort in current research.

This paper extends on the work presented in [13] where it has been shown that,
in fact, many rules can be expressed in OWL. We extend this work to include
some types of rules previously excluded. We formally define C-Rules, a set of
rules that can be embedded directly into OWL extended with role conjunction.
We also discuss how our approach can be used in conjunction with previous
weaker methods for embedding rules based on nominal schemas.
To express C-Rules in DL notation we employ the DL SROIQ(), an extension of SROIQ [8], which underlies OWL 2 DL. SROIQ() encompasses
SROIQ adding a restricted form of role conjunction.
 This work was supported by the National Science Foundation under award 1017225

III: Small: TROn  Tractable Reasoning with Ontologies.

E. Simperl et al. (Eds.): ESWC 2012, LNCS 7295, pp. 345359, 2012.
c Springer-Verlag Berlin Heidelberg 2012

D. Carral Mart nez and P. Hitzler

To introduce our approach, consider the following rule R which cannot be
readily expressed in SROIQ using known techniques. Although R may not
have a single directly equivalent axiom in DL, we can transform it into a set of
equisatisfiable statements in first-order predicate logic (FOL).
hasFather(x, y)  hasBrother(y, z)  hasTeacher(x, z)  TaughtByUncle(x)

The example rule R can be represented as an equisatisfiable set of statements:
 hasFather(x, y)  hasBrother(y, z)  hasUncle(x, z)
 hasUncle(x, z)  hasTeacher(x, z)  hasTeacherAndUncle(x, z)
 hasTeacherAndUncle(x, z)  TaughtByUncle(x)
This set of FOL statements can then be translated into
 hasFather  hasBrother  hasUncle
 hasUncle  hasTeacher  hasTeacherAndUncle
 hasTeacherAndUncle.#  TaughtByUncle
and therefore the rule R can be expressed in DL notation.

Although some rules fall under our definition and are expressible using these
combinations of role constructors, there are even more complex rules that cannot
be simplified using the approach presented in this paper.

A prominently discussed idea for retaining decidability, and still be able to
express complex rules, is to restrict the applicability of rules to named individu-
als. Rules with this kind of semantics are called DL-safe, and the combination of
OWL and DL-safe rules is indeed decidable [7,16]. In this paper we also discuss
the use of nominal schemas to express complex rules. Nominal schemas are a DL
constructor presented in [15] described as variable nominal classes. Restricted
to stand only for named individuals as DL-safe variables, nominal schemas have
the advantage of allowing us to express complex rules in native OWL notation.
The plan for the paper is as follows. After providing some preliminaries in
Section 2, the paper continues in Section 3 with the formal definition of C-Rules
with unary predicates in the head. Section 4 extends the approach presented in
the previous section to rules with binary predicates in the head. Section 5 contains some examples. Section 6 contains the discussion about rules and nominal
schemas. Section 7 includes the conclusions of the paper and future work.

2 Preliminaries
We introduce SROIQ(), a DL fragment that adds role conjunction, in a
restricted way, to SROIQ [8]. Axioms of the form R1  R2  V are allowed in
SROIQ(), where R1 and R2 are two (possibly complex) roles.1
Roles which appear on the right hand sides of axioms of the form R1  R2 
V are restricted to only appear in concepts of the form V.C. Although this
1 In a sense, role conjunction was already implicit in [14], and is also used in [13], for

a similar purpose.
?

?

?
precondition might look very restrictive, it suffices for the use of role conjunction
for expressing rules, as discussed in this paper. As a technical note, in terms of
regularity of RBoxes (required for decidability), we assume that for a role V

appearing in an axiom R1  R2  V we have that both R1  V and R2  V (
SROIQ() bears the same semantics as SROIQ, with the exception of the
role conjunction constructor. The formal semantics is as usual (see, e.g., [17]),
and for lack of space we do not repeat it here. Note that it follows easily from
the arguments laid out in [17] that SROIQ() is decidable.

indicates the order in a regular role hierarchy).
?

?

?
2.1 Description Logic Rules and Graph Notation

Bi  H, where
We define U-Rules (respectively, B-Rules) as rules of the form
all Bi are unary or binary predicates and H is a unary (binary) predicate.2 We
Bi and H as the body and the head of the rule respectively. We assume
refer to
without loss of generality that at least one of the variables in the head of the
rule also appears in the body of the rule at least once.3

Let R be any given U-Rule or B-Rule. We can define an undirected graph GR
derived from R as a set of vertices and edges s.t. every variable in the body of R
is a vertex of GR and GR contains an edge (t, u) if S(t, u) is a binary predicate
in the body of R, and t and u are different variables. Note, that rules containing
a predicate of the form R(x, x) where R is a complex role cannot be expressed in
SROIQ, as it will be shown in Section 3.1. Consequently, if this is the case the
reduction process cannot be performed. Graphs will be used across the paper to
represent and reduce rules in an easy and intuitive way.

Note that constants, and even binary predicates containing only one vari-
able, are not included in the graph. Having a prefixed meaning, constants can
be simplified independently and therefore, there is no need to relate them to
other elements in the graph. On the other hand, FOL variables, having shared
non-fixed meanings, need to keep the links that determine their relation to the
predicates in the rule where they appear.

We have defined undirected graphs GR as sets and consequently there cannot
be repetitions amongst its elements. Even if two different binary predicates relate
the same pair of terms, in the graph these predicates map to the same single
edge. Note also that we work with undirected graphs and therefore, elements
(u, t) and (t, u) stand for different representations of the same edge.

For an undirected graph GR, derived from a U-Rule or a B-rule R, we define
a vertex as a root vertex rR if it has been derived from a variable appearing both
in the head and the body of the rule. Note that by our standing assumption,
there will always be at least one root vertex for any given graph GR.

We define, for two given vertices t and u, to be directly connected if (t, u)  GR.

We define, for two given vertices t and u, to be connected as the symmetric
2 In our context unary predicates will refer to any kind of valid unary SROIQ()
concept in negation normal form, either in the head or in the body of the rule.

3 Note that, if none of the variables in the head of the rule appears in the body, we

can always include one of them in the body using a unary top predicate.

D. Carral Mart nez and P. Hitzler

transitive closure of being directly connected. We assume without loss of generality that any two vertices in the graph are connected.4 We define the degree
of a vertex d(t) as the number of different edges (t, u) in the graph GR where t
appears.

3 Description Logic Rules in SROIQ()

In this section, we formally describe rules that can be expressed in the DL
fragment SROIQ(). While close in general spirit to the brief exhibit in [12,
Section 8.3], our treatment is quite different.

Definition 1. We propose in this definition a formal method to verify if a U-

Rule R is expressible in SROIQ(). Given a graph GR derived from a given

rule R, repeat non-deterministically and exhaustively:

 Substitute a pair of edges (t, u) and (u, v) by a single edge (t, v) and eliminate

vertex u if d(u) = 2 and u is a non-root vertex.

GR := {GR \ {(t, u), (u, v), u}| d(u) = 2, u = rR}  {(t, v)}

 Eliminate an edge (t, u) and a vertex u where d(u) = 1 and u is a non-root

vertex.

GR := {GR \ {(t, u), u} |(t, u)  GR, d(u) = 1, u = rR}

A rule R is expressible in SROIQ() if the graph GR gets reduced to the root

vertex after the reduction process.

The reduction process defined in Definition 1 only halts under two different
situations. Either the graph GR gets reduced to a single vertex or, for every
non-root vertex u in the graph we have that d(u)  3 (possibly after several
reduction steps). Steps 1 and 2 presented in the previous reduction process can
remove a vertex u if d(u) = 2 or d(u) = 1 respectively if u is a non-root vertex.
It is obvious that a graph containing a non-root vertex u s.t. d(u) < 3 can be
reduced at least one step further, and a graph where d(u)  3 for every non-root
vertex u  GR cannot be simplified.
The process presented in Definition 1 presents a formal approach to determine
if a given rule R is expressible in SROIQ(). In the sequel we explain how,
from this graph reduction approach, we can derive a set of SROIQ() axioms
equivalent to the original rule R. Formally stated, the following two lemmas and
theorem hold. Their correctness is shown in Section 3.1.
Note that, even if we do not provide an explicit definition for rules that are
not expressible in SROIQ() this can be easily inferred. Rules with four nodes
that are fully connected through paths not containing any of those nodes are
not expressible. Even if all the other nodes in the paths get simplified these four
nodes will form a clique where each one of them has degree three or higher.
Therefore, they cannot be reduced using the approach presented in this paper.

4 Again, we can connect any two variables in a rule using the universal rolealthough

regularity issues need to be taken into consideration here.
?

?

?
Lemma 1. Let R be a U-Rule with a derived graph GR. Every transformation
performed on GR as explained in Definition 1 leads to a new reduced graph
GR . Then a new rule R1 can be constructed from R s.t. we can derive a graph
GR1 from R1 and GR1 = GR . Furthermore, there exist a set of SROIQ()
statements 1 s.t. {R1}  1  {R}.

Definition 2. The process defined in Lemma 1 can be repeated iteratively produc-

ing a new rule from every rule derived from R s.t. R  R1  1, R1  R2 
2, ..., Rt1  Rt  t. Rt is a rule with a derived graph GRt s.t. GRt cannot be reduced anymore. If GRt has been reduced to a single vertex we call Rt a terminal rule.
Lemma 2. A terminal rule Rt is directly expressible as a SROIQ() axiom.

Intuitively, the simplifications done on the graph will be mirrored in the rule.
Through this iterative process we can start reducing the rule, splitting it into
several SROIQ axioms that preserve equisatisfiability. When the rule gets reduced to a terminal rule it can be directly translated into SROIQ(). Adding
this translation to the set of previous axioms derived in the reduction process
we obtain an equivalent set of atoms in SROIQ(). The following Theorem
follows directly from Lemmas 1 and 2.
?

?

?
Theorem 1. Assume that a rule R is reduced to terminal rule Rt. Then the original knowledge base KB containing R is equisatisfiable w.r.t. a new knowledge
is obtained from KB by substituting R by 1  ...  t1  {Rt}
base KB
where Rt is the direct translation of the terminal rule Rt and 1, ..., t1 are the
sets of axioms produced in every step during the reduction process of rule R.

. KB
?

?

?
3.1 Satisifiability Preserving Transformations

We show how to carry out the mentioned graph transformations for a given
rule R, preserving equisatisfiability in every step. For every transformation we
present a table with three columns. The first column shows the initial subset
of R that will be replaced in the next iteration of the reduction process. The
second column includes the new simplified subset. By substituting the initial
subset by the simplified one in the original rule R we obtain the new simplified
rule. Column three shows all the SROIQ() statements that we need to add
to the knowledge base in order to preserve equivalence.

Roling Up Unary Predicates. We start by proving that unary predicates can be
automatically embedded into binary predicates using role constructors. There-
fore, these predicates do not need to be considered when we build the graph to
know if a description logic rule R is expressible in SROIQ(). This technique,
called rolification, is presented in [11].

Initial rule subset Eq Subset
V (x, y)  D(y)

Set 

S(x, y) D  W.Self
V  W  S

Hereby, W and S are fresh names not already appearing in the knowledge base.

D. Carral Mart nez and P. Hitzler
?

?

?
Proposition 1. Let KB be a knowledge base containing a U-Rule R s.t.
V (x, y)D(y) appears in R. From KB we can construct an equivalent knowledge
is a new U-Rule obtained
base KB
from R by substituting V (x, y)  D(y) with S(x, y) and the set  contains the
axioms D  W.Self and V  W  S, with W and S fresh predicate names. We
prove that KB and KB

:= {KB \ R}  {R

are equisatisfiable knowledge bases.

}  , where R

s.t. KB
?

?

?
.
?

?

?
for KB

Now assume that M

models axioms {R

s.t. M
= { (b, b) | b  DM } and SM

Proof. Assume M is a model for the KB. Obviously M models R. From M we

can build a model M
is identical to M except for the mappings
 }.
= { (a, b) | (a, b)  V M and (b, b)  W M
W M
These mappings are enforced by the new  axioms added to the knowledge base.
}  and hence, M

Obviously, if M models R, M
is a model

for KB
}  . Then we have that M = M
is a
model for R. Consider ground instances of the rule and assume that M |=

Bi.
Now we need to prove that M |= H. Since we assume that M |=
Bi we have
that M models every Bi in the body of the rule, in particular M |= V (a, b)D(b).
Hence, (b, b)  W M
and (a, b)  SM
. Then we have that M |=
?

?

?
i where B
body. Therefore M |= H
?

?

?
i
is the head of the new rule R
is the R
, where H
.
= H, hence, we have shown that that M |= H being H.

We have that H

Consequently M models R and is a model for KB.

is a model of {R
?

?

?
All the other transformations presented below can be proved in a similar way.
We thus refrain from including any more detailed formal arguments for them.
Note that V (x, y)  D(x) can be simplified in a similar way. In the following,

W and S are fresh role names in the ontology.

Initial rule subset Eq Subset
V (x, y)  D(x)

Set 

S(x, y) D  W.Self
W  V  S

Undirected Graph. The direction of the edges in the graph can be changed using
the inverse role constructor. Therefore, there is no need for our algorithm in
Definition 1 to check the direction of binary predicates when we apply different
simplifications. Below, S is fresh role name in the knowledge base.

Rule Subset Eq Subset Set  to the KB

R(x, y)

S(y, x)

  S

Reducing Vertices of Degree Two

Rule Subset

R(x, y)  W (y, z)

Eq Subset Set  to the KB

R  W  S

S(x, z)

Hereby, d(y) = 2 and S is fresh role name in the knowledge base.

Note that when we simplify a vertex by using a role chain we loose the reference to the term u in the middle of the role chain for a given rule R. Therefore
this can only be executed for terms u with a degree of two, without further
references in other predicates of the rule R.
?

?

?
Reducing Vertices of Degree One

Rule Subset

Eq Subset
R(x, y)  V (y, z) R(x, y)  D(y)

Set  to the KB

V.#  D

Hereby, d(z) = 1 and D is a fresh concept name in the knowledge base.

Note that even if we part from a very similar subset rule as in the previous
subsection we follow a different method here. The fresh unary predicate produced
can be simplified as shown in earlier sections.

Simplifying Binary Predicates with One Constant

Initial rule subset Eq Subset

V.{a}  S
Hereby, S is a fresh unary predicate and a is a is a constant.

Set 

V (x, a)

S(x)

The fresh unary predicate can be simplified as shown in earlier sections. Note
that we can always swap the order of the terms in a predicate of the form V (a, x).

Simplifying Binary Predicates of the Form (x, x)

Initial rule subset Eq Subset

V (x, x)

S(x)

Set 

V.Self  S

Hereby, S is a fresh unary predicate.

Using this simplification whenever possible, there is no need to consider these
kind of predicates in the graph. Note that this can only be done if V is a simple
role w.r.t. role box in the knowledge base. To retain decidability SROIQ does
not allow to use complex in a concept of the form C.Self.

Unifying Binary Predicates

Rule Subset
R(x, y)  V (x, y) S(x, y)

Eq Subset Set  to the KB

R  V  S

Hereby, S is a fresh role name in the knowledge base.

Any pair of binary predicates can be unified if both contain the same pair
of variables. Note that, even if the variables do not appear in the same order,
we can use the inverse role construct to align them. We assume without loss
of generality that every pair of binary predicates containing the same pair of
variables in a rule is automatically unified and therefore, we can define graphs
as sets without repetitions of the same edge. Note that the unification of binary
predicates needs to be done with a higher priority than other transformations,
such as the reduction of vertices of degree two. If not cycles may be reduced
to predicates of the form R(x, x) where R is a complex role that cannot be
simplified using the R.Self.

The transformations just shown correspond to graph transformations as mentioned in Definition 1. The arguments just given thus constitute a proof of
Lemma 1. Note that the order of the transformations is non-deterministic. This
is a kind of dont care determinism, where the order in which we apply the
rules does not matter. We further elaborate about this in Section 5.

D. Carral Mart nez and P. Hitzler
?

?

?
Bi  H.
Translating Terminal Rules. A terminal rule R is a rule of the form
Bi contains one, and at most one, free FOL
We have that the body of the rule
variable x appearing only once in a unary predicate of the form B(x) (the graph
has been reduced to the root vertex, and therefore, there is only one variable
Bi might also contain other predicates of
left appearing only once). The body
the form C(a) or R(b, c) s.t. a, b, and c are constants. The head H is composed
of a single unary predicate H(x) s.t. x is the same free variable that appears in
the body.
?

?

?
A terminal rule R is translated into a DL inclusion axiom of the form
?

?

?
Bi 

H. This axiom contains a fresh concept H on the right hand side of the role
inclusion axiom and a concept intersection on the left hand side featuring the
next elements:

free variable appearing in the rule.

 A fresh concept B standing for the unary predicate B(x) s.t. x is the only
 A concept U.(C{a}) for every unary predicate of the form C(a) appearing
 A concept U.({b}  R.{c}) for every binary predicate of the form R(b, c)

in the body where a is a constant.

appearing in the body of the rule where b and c are constants.

The argument just given also constitutes a proof of Lemma 2.

4 Rules with Binary Predicates in the Head

We can extend our approach to cover rules with binary predicates in the head.
As already stated, at least one variable in the head of the rule needs to appear
in the body. Attending to this fact we need to consider two different situations.
If only one of the terms in the head of the rule appears in the body the
simplification is straightforward. We just need to substitute the binary predicate
R(x, y)5 in the head by a fresh unary predicate C(x) and add the axiom R.# 
C to the SROIQ() knowledge base. After this modification the rule can be
reduced using the same approach presented in the previous section.

If both variables appearing in the head of the rule appear in the body we need
to slightly modify our method presented in Section 3. In this case, we consider
both variables in the head as root vertices. Now, if the rule is expressible in
SROIQ() the graph gets reduced to a single edge containing both variables in
the head. This new kind of terminal rule can be expressed in SROIQ() using
a role inclusion axiom S  R.
Theorem 2. Let R be a B-Rule s.t. S(x, y) is the predicate in the head H of R
and both x and y appear in the body

Bi of the rule.
?

?

?
Given a graph GR derived from rule R, where we consider both x and y to be

If after the reduction process, the graph GR gets reduced to a single edge, then

root vertices. Then exhaustively apply steps 1 and 2 from Definition 1.
rule R is expressible as a SROIQ()axiom.
5 Assume x is the root vertex. Otherwise use the inverse role constructor to change

the order of the terms in the predicate.
?

?

?
Again, we see that any GR where every vertex u has d(u)  3 (possibly
obtained after several reduction steps) cannot be simplified. Otherwise the graph
can be reduced to a single edge (u, t) s.t. u  H and t  H with H the head of
the rule. Note that the procedure is almost the same as in Section 3, except for
the accepting condition.
The process to translate the rule into a set of equivalent SROIQ() statements and proofs remain the same as the one presented in Section 3 except for
the trivial translation of the terminal rule.

It is important to remark that in some cases a B-Rule may not be expressible
while a U-Rule with the same body is. The second vertex might block a possible
role reduction forbidding further simplifications. As an example we have that

R1(x, y)  R2(x, w)  R3(w, y)  R4(y, z)  R5(w, z)  C(x) is expressible in
SROIQ() using our approach, while R1(x, y)R2(x, w)R3(w, y)R4(y, z)
R5(w, z)  C(x, z) is not.

Definition 3. Formally, by C-Rules we mean the collection of all rules which
are U-Rules or B-Rules and which are expressible in SROIQ using the approach
presented in this paper.

5 Examples

We start with a worked example for our transformation. As initial rule, we use

A(x, y)  B(y)  C(z, y)  D(y, z)  E(x, a)  F (x, z)  Y (a, b)  Z(x)

where a and b are constant and x, y and z are free variables. Transformations
following the discussion from Section 3 are detailed in Table 1.
Note that the rule listed in step 6 of Table 1 can already be directly translated
to SROIQ() as M.#  E.{a}  U.({a}  Y.{b})  Z. But to improve
readability of the paper, our rule reduction approach has been presented in a
simpler form, avoiding such shortcuts. So, although the method shown is sound
and correct, there are U-Rules and B-Rules, as the one presented in the example,
where at some step of the reduction process no further simplifications are strictly
required. An earlier translation of the rule reduces the number of statements that
need to be added to the knowledge base. Recall, in particular, that rules with
tree shaped graphs are directly expressible in DL [11,13].

Also, we have that reductions according to our transformations are applied
non-deterministically. Although any rule reduction leading to a terminal rule is
essentially correct, there might be differences in the set of axioms added to the
knowledge base. For example, let R be a U-Rule containing the binary predicates
A(x, y) and B(y, z) s.t. both y and z are variables not appearing anywhere else
in the rule (hence, we have that d(y) = 2 and d(z) = 1). In the next reduction
step, we can decide which variable, y or z, we want to erase.

Assuming we want to reduce A(x, y) and B(y, z) to Z(x), there are two different ways of doing so, namely (1) first reducing y, and (2) first reducing z. In
the first case, we end up with two axioms A B  C and C.#  Z, while in the

D. Carral Mart nez and P. Hitzler

Table 1. Reduction example. For every step substitute the rule in the previous row by
the one in the current one and add the axioms on the second column to the knowledge
base.

Step

1. Original Rule

2. Invert C

3. Intersect D and H

4. Role Up B

5. Simplify E

6. Role Up L

7. Reduce y
8. Intersect N and O
9. Reduce z
10. Translate Terminal Rule

Add to KB Rule

A(x, y)  B(y)  C(z, y)  D(y, z)
E(x, a)  F (x, z)  Y (a, b)  Z(x)
A(x, y)  B(y)  H(y, z)  D(y, z)
  H

E(x, a)  F (x, z)  Y (a, b)  Z(x)
A(x, y)  B(y)  I(y, z)  E(x, a)
D  H  I
F (x, z)  Y (a, b)  Z(x)
B  J.Self K(x, y)  I(y, z)  E(x, a)
F (x, z)  Y (a, b)  Z(x)
A  J  K
E.{a}  L K(x, y)  I(y, z)  L(x)
F (x, z)  Y (a, b)  Z(x)
L  M.Self K(x, y)  I(y, z)
M  F  N N (x, z)  Y (a, b)  Z(x)
K  I  O
O(x, z)  N (x, z)  Y (a, b)  Z(x)
P (x, z)  Y (a, b)  Z(x)
N  O  P
P.  Q
Q(x)  Y (a, b)  Z(x)

Q  U.({a}  Y.{b})  Z

second case four axioms are required B.#  D, D  E.Self, A  E  F , and
F.#  Z. Note that giving priority to the reduction of variables with degree 2
reduces the number of required axioms to preserve equisatisfiability.
The regularity issue. In order to preserve decidability, SROIQ() enforces a
strict partial order on complex roles (known as the regularity condition). When a
C-Rule R is translated into SROIQ, we add many new complex role inclusions
axioms to the Rbox. These new roles may violate the partial order established
by previous roles or even contradict role regularity by themselves. After the
reduction of a C-Rule and the inclusion of new produced SROIQ() axioms,
role regularity needs to be carefully checked in order to preserve decidability.

It is important to note that only the translation of expressible B-Rules might
cause these role regularity violations. Although the role regularity hierarchy
is modified in many steps of our rule reduction approach note that for every
statement R  S added we have that S is a fresh role. Fresh roles do not
appear in any other part of the role hierarchy and therefore they cannot produce
violations of the irreflexive order.
The only step of the process where the RBox may loose its regularity is in the
translation of a terminal B-Rule. Adding this last axiom of the form R  S also
adds the statement R  S to the role hierarchy where S is a role which may
have appear in any other part of the knowledge base.

Let us look at an example of a knowledge base where the reduction of some
of the rules leads to role regularity violations. Let KB be a knowledge base
containing the following rule.
?

?

?
TeacherOf(y, x)  ReviewerOf(y, z)  AuthorOf(x, z)  IllegalReviewerOf(y, z)

This rule places a pair of individuals under the binary predicate IllegalReviewerOf if the first is a teacher of the student who is the author of the reviewed
paper. It can be transformed into the following set of SROIQ() axioms.

TeacherOf  AuthorOf  R1
ReviewerOf  R1  R2

R2  IllegalReviewer

From these axioms, we obtain the relations TeacherOf  R1, AuthorOf  R1,
ReviewerOf  R2, R1  R2, and R2  IllegalReviewer, which entail the statement ReviewerOf  IllegalReviewerOf. If would be natural to also add the axiom
IllegalReviewerOf  ReviewerOf to the same ontology. However, the inclusion
of this axiom adds the statement IllegalReviewerOf  ReviewerOf which then
violates role regularity.

A workaround to this issue, however, is possible, namely by employing nominal

schemas, and we will return to this issue at the end of the next section.

6 Using Nominal Schemas and SROIQV()

In earlier sections of this paper we have shown how to translate some FOL rules
into DL notation. Although some rules can be translated to SROIQ() using
the presented approach there are still more complex rules that cannot be simplified in the same way. To express these rules we employ the DL SROIQV ().
SROIQV() adds nominal schemas, a DL constructor that can be used as
variable nominal classes, to the previously described SROIQ(). We will
refrain from introducing all formal details and refer the reader to [9,10,11,15]
for this. While the semantic intuition behind nominal schemas is the same as
that behind DL-safe variables, nominal schemas integrate seamlessly with DL
syntax. As a consequence, the DL fragment SROIQV() encompasses DL-safe
variables while staying within the DL/OWL language paradigm avoiding the use
of hybrid approaches.

Using these nominal schemas we are able to express FOL rules that are not

part of the treatment in Sections 3 and 4. Consider, for example, the rule

R1(x, y)  R2(x, z)  R3(x, w)  R4(y, z)  R5(y, w)  R6(w, z)  C(x).

(1)

Using {z} and {w} as nominal schemas, we can express it as

R1.(R4.{z}  R5.{w})  R2.{z}  R3.({w}  .R6.{z})  C

Note that, as already stated, nominal schemas do not share the same semantics
defined for FOL variables. Nominal schemas, as DL-safe variables, are restricted
to stand only for nominals which are explicitly present in the knowledge base,

D. Carral Mart nez and P. Hitzler

while FOL variables can represent both named and unknown individuals. There-
fore, the statements presented in the example just given are not strictly equiva-
lent. Despite this fact, nominal schemas allow us to retain most of the entailments
from the original FOL axiom without increasing the worst-case complexity of the
DL fragment.

Although nominal schemas do not increase the worst-case complexity of the
language [15], the number of different nominal schemas per axiom can affect the
performance of the reasoning process [3,10]. It is therefore desirable to use as
few nominal schemas as possible.

We now discuss two different ways of translating complex rules into DLs. First

we prove the following.

Theorem 3. Any U-Rule or B-Rule R containing m different free variables,
where m > 3, can be directly expressed in DL using n nominal schemas s.t.
n  m  2.

Proof. Given a rule R, firstly role up to simplify all binary predicates containing
one constant as shown in Section 3. All binary predicates in the rule containing
the same pair of variables are also replaced by a single binary predicate as
described under Unifying Binary Predicates in Section 3.

Due to these transformations, we can now assume without loss of generality
that the rule R contains only unary predicates with a constant, binary predicates
with two constants, and binary predicates with two variables as arguments.

Now choose two variables x and y s.t. x is a root vertex and y is not. Using
the inverse role construct we can now swap arguments in binary predicates s.t. x
is always appearing in the first argument and y is in the first argument of every
predicate where the other variable is not x. The variables selected will be the
only ones not substituted by a nominal schema in the translated rule.

The rule body is now translated as shown in Table 2. The resulting DL ex-
Ri(y, vi) are all the

Bi(y), R(x, y), and

pressions are joined by conjunction.
predicates where y appears.
?

?

?
Table 2. Translating Rules with Nominal Schemas

Predicate type

Unary Predicates with 1 constant B(a)
Binary Predicates with 2 constants R(a, b)
R(x, v)
Binary Predicates containing
x and not y
Unary Predicates containing x
Binary and Unary
Predicates containing y
Unary Predicates not containing B(v)
x, y, or constants
Binary Predicates not containing R(v, u)
x, y, or constants

B(x)

R(x, y)  


Ri(y, vi)

U.({a}  B)
U.({a}  R.{b})
R.{v}
?

?

?
Bi  
U.({v}  B)
U.({v}  R.{u})

Bi(y) R.(

Ri.{vi})
?

?

?
Finally, the head H(x) can be rewritten into the concept H (or if it is a
binary predicate H(x, z), a concept of the form H.{z}), and the implication
arrow replaced by class inclusion .

It is straightforward to formally verify the correctness of this transformation,
and parts of the proof are simliar to the correctness proof from [15] for the
embedding of binary Datalog into SROIQV.
Clearly, the number of nominal schemas used to represent rule R is n 2, the
?

?

?
total number of free variables minus 2.

With the transformation just given, rule (1) can be rewritten as

R1.(R4.{z}  R5.{w})  R2.{z}  R3.{w}  .U ({w}  .R6.{z})  C

As another example, the following rule transforms into the subsequent axiom.

R1(x, y)  R2(y, z)  R3(w, z)  R4(x, z)  R5(y, w)  R6(w, u)  R7(y, u)
 H(x, u)

R1.(R2.{z}  R5.{w}  R7.{u})  U.({w}  R4.{z})

R4.{z}  U.({w}  R6.{u})  H.{u}

Theorem 4. Any U-Rule or B-Rule R containing m different free variables can
be expressed in DL by fully grounding m  3 free variables in R.

Proof. By grounding every variable but three in the rule to named individuals
we end up with a larger number of rules s.t. each one of them contains only
three different free variables.6 All these new grounded rules are expressible in

DL using the approach presented in Section 3 of this paper.

While the first of the approaches just mentioned allows us to represent all knowledge in SROIQV(), the second one, although initially looking more efficient,
requires preprocessing steps. Further research and algorithms are required to
smartly deal with nominal schemas other than through such grounding, a cumbersome technique that requires too much space and time for current reasoners
[3,10].

Let us finally return to the regularity issue discussed at the very end of Section 5. In the example discussed there, if we desire to also add the statement
IllegalReviewerOf  ReviewerOf to the knowledge base, we cannot do so directly
without violating regularity. Using nominal schemas, however, we can weaken
this axiom to the form

IllegalReviewerOf.{x}  ReviewerOf.{x}

(or, e.g., to

IllegalReviewerOf


.{x}  ReviewerOf


.{x}

6 Note that any rule with three variables can be reduced used our approach. Having
only three nodes in the graph for all of them we have that d(u)  2 and therefore
all of them can be reduced.

D. Carral Mart nez and P. Hitzler

or to both), where {x} is a nominal schema. Essentially, this means that the
role inclusion will apply in case the first argument or the second argument (the
filler) is a known individual. I.e., the individuals connected by the IllegalReviewerOf property are not both are unnamed. While this is weaker than the
standard semantics, it should provide a viable workaround in many cases. Also
note that, alternatively, the regularity violation could be avoided by using a
similarly weakened form of any of the other statements involved in the violation.

7 Conclusions and Future Work

This paper presents an extension of previous work on Description Logic Rules.
We specify a translation of rules into OWL extended by role conjunction (more
precisely, the description logic SROIQ()), which strengthens previously obtained such translations. In essense, our work shows that the fragment of Datalog
which can be expressed in description logics is larger than previously assumed.
We furthermore included a discussion proposing two approaches to express
more complex rules within the DL notation. Two different options are considered,
the use of nominal schemas and fully grounding of some variables to named
individuals. While the former might present a higher complexity, it allows to
express these rules in native DL/OWL notation and avoid some cumbersome
preprocessing steps.
Future work includes the development of a goal directed algorithm that can
solve inference problems in SROIQV() possibly including some other role
constructs (probably the extension of a current tableau algorithm). This algorithm could serve as basis for practical implementations of reasoners that include
role constructs amongst their features.

Also, the development of APIs that can automatically validate FOL rules
as DL expressible and translate them into sets of equisatisfiable OWL axioms
might be a very useful tool. Although some aspects of modeling ontologies, such
as building concept hierarchies, are very intuitive when we work with DL/OWL
languages, the translation of DL rules, as shown in this paper, may not be so
straightforward for users that do not have a strong background in more formal
logics. Additional tool support will be required to provide convenient modeling
interfaces.
