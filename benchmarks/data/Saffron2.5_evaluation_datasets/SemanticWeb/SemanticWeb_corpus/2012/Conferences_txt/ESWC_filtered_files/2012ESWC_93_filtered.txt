Preserving Information Content in RDF

Using Bounded Homomorphisms

Audun Stolpe and Martin G. Skjveland

Department of Informatics, University of Oslo, Norway

{audus,martige}@ifi.uio.no

Abstract. The topic of study in the present paper is the class of RDF
homomorphisms that substitute one predicate for another throughout
a set of RDF triples, on the condition that the predicate in question
is not also a subject or object. These maps turn out to be suitable for
reasoning about similarities in information content between two or more
RDF graphs. As such they are very useful e.g. for migrating data from
one RDF vocabulary to another. In this paper we address a particular
instance of this problem and try to provide an answer to the question
of when we are licensed to say that data is being transformed, reused or
merged in a non-distortive manner. We place this problem in the context
of RDF and Linked Data, and study the problem in relation to SPARQL
construct queries.

Introduction

As yet, the World Wide Web shows a bias towards getting the information to
flow, at the expense of maintaining the integrity of the circulated information.
Maintaining integrity is usually recognised as a very real and increasingly acute
need, though. Take public sector information: open public sector information is
a valuable national resource, and there is widespread agreement that dissemination promotes transparent and accountable government, improves quality of
service, and in general serves to maintain a well-informed public. Yet, whilst the
political pressure for reusable public sector information is building momentum,
as witnessed e.g. by the European Public Sector Information Directive of 2003,
governments as suppliers and authoritative sources of information on the Web
must nevertheless acknowledge the challenges related to maintaining the primary
nature of its information. This points to a general tension between two fundamental requirements of the data-oriented Web: Keep the data freely flowing, but
shepherd the data into sanctioned use. In the present paper we shall place this
problem in the context of RDF and Linked Data, and study it in relation to
SPARQL construct queries.

Example 1. The Cultural Heritage Management Office in Oslo is the City of
Oslos adviser on questions of cultural conservation of architecturally and culturally valuable buildings, sites and environments. It maintains a list of protected
buildings, known as the yellow list, which has been transformed to RDF and
published as Linked Data [11]. A small excerpt is given below:

E. Simperl et al. (Eds.): ESWC 2012, LNCS 7295, pp. 7286, 2012.
c Springer-Verlag Berlin Heidelberg 2012
?

?

?
<http://sws.ifi.uio.no/gulliste/kulturminne/208/5/6643335/597618>

rdf:type gul:Kontor ;
hvor:gateadresse "Akersgata 44" ;
hvor:postnummer

"0180" ;

geo:long "10.749" ;
geo:lat
"59.916" .

Note that there is no explicit representation of city or country, and no grouping
of similar data. Suppose now that we wish to lift all available information about
culturally valuable buildings in Norway to the national level. We do so by adding
Oslo and Norway as parts of the address data. Also, we add types to buildings by
linking to the relevant class from the CIDOC CRM standard for cultural heritage
information (http://www.cidoc-crm.org/). For heuristic purposes we also group
geographical information and address information respectively around suitably
typed nodes:

CONSTRUCT{ ?x rdf:type ?y, cidoc:E25.Man-Made_Feature;

vcard:adr [ rdf:type vcard:Address;

vcard:street-address ?street;
vcard:locality geonames:3143242; # Oslo
vcard:country-name "Norway"@en ] ;

vcard:zip-code ?code;

vcard:geo [ rdf:type geo:Point;

geo:lat ?lat;

geo:long ?long ] }

WHERE{ ?x rdf:type ?y;

hvor:gateadresse ?street;
geo:lat ?lat;

geo:long ?long . }

hvor:postnummer ?code;

The structural change to the data caused by the construct query is rather
thoroughgoing and extensive. Yet, there is still a principled relationship between
structural elements of the two graphs, e.g. the property hvor:gateadresse morphs
into the sequence of properties vcard:adr, vcard:street-address. Moreover, the
pairs of resources that are linked by hvor:gateadresse in the former graph remain linked by vcard:adr, vcard:street-address in the latter graph, and no other
pairs are similarly related. Indeed, the transformation can easily be seen to be
systematic in the sense that all pairs related in the same manner in the source
graph are transformed uniformly in terms of the same structural element in the
target graph. It is also non-distortive in the sense that no other pair of resources
are so related. Contrast with the case in which we replace hvor:postnummer with
vcard:locality, whilst keeping everything else as-is. We would then not be able
to distinguish between cities and zip-codes in the target graph, and would in
that sense have distorted the information from the source.

The purpose of the present paper is to give these intuitions mathematical
content. That is, we wish to formulate a criterion to sort conservative from
non-conservative ways of transforming data. Since we take construct queries
as our paradigm of RDF transformation, this means sorting conservative from
non-conservative construct queries. It is important to note that the uniformity
and non-distortiveness criteria we shall propose are purely structural, and do
not heed the semantics of the vocabulary elements involved. To the question
what makes the chain vcard:adr, vcard:zip-code an adequate representation of
hvor:gateadresse? the only answer is because somebody wishes it to be so.
What our criteria have to offer is thus nothing more than a clear notion of what

A. Stolpe and M.G. Skjveland

you are rationally committed to, in terms of the structure of the target graph,
once you have made your choice of representatives for elements of the source
graph. We will do so by studying a class of RDF homomorphisms that substitutes one edge for another throughout a set of RDF triples, subject to the
condition that the edge in question is not also a vertex.

The paper is organised as follows: Section 2 defines the general concept
of an RDF homomorphism, and distinguishes the subset of conditional edgesubstitutions mentioned above. We shall call them p-maps. Section 3 recapitulates the basic syntax and semantics of the SPARQL query language. Section 4
defines the notion of a bounded p-map and argues that it gives an adequate
criterion of conservativeness. Section 5 generalises the conservativeness criterion
to handle more sophisticated construct queries, e.g. that of Example 1. Section 6
presents essential results on the computational properties of computing p-maps,
whilst Section 7 closes with a summary and a few pointers to future lines of
research.

Related Work. Our homomorphisms differ from those of [1, 2] which essentially
rename blank nodes in order to mimic the semantics of RDF as defined in [6].
To the best of our knowledge, our particular notion of RDF homomorphism, and
the use of it, is novel. Considered as an embedding of one graph into another
a p-map can be viewed in two different ways which, although they amount to
the same formally, give rather different gestalts to the central issue. Looked at
from one angle, our problem (i.e. embedding a source into a target) resembles
data exchange: Given one source of data marked up in one way, one wants to
migrate the data to some target repository in a way that conforms to the targets
schema. Yet, it differs from the problem studied in [4] in that our setup takes the
target to be fixed and possibly non-empty. Looked at from another angle, the
problem concerns how to extend an RDF graph conservatively. More specifically,
it concerns the problem of how to ensure that a transformation of source data into
a target repository does not interfere with the assertive content of the source.
Yet, it is unlike logic-based conservative extensions [5, 7, 8] in that the logical
vocabulary is being replaced as the source is extended into the target. As such
bounded p-maps may also have a role to play in data fusion, which is defined as
the process of fusing multiple records representing the same real-world object
into a single, consistent, and clean representation [3].

2 RDF Graphs and RDF Homomorphisms

Let U , B and L be pairwise disjoint infinite sets of URI references, blank nodes
and literals, respectively, and let U denote the union of these sets. An RDF triple
is a member of T := (U  B)  U  U. We shall write RDF triples as a, p, b
and say that a and b are vertexes, and p the edge of the triple. An RDF graph
is a finite set of RDF triples. The vocabulary of an RDF graph G is the set

UG = VG  EG, where VG is the set of vertexes and EG the set of edges in G.
Note that VG and EG need not be disjointa matter of some importance as we
shall see later. i(t) denotes the i-th element of the tuple or sequence t.
?

?

?
Definition 1. An RDF homomorphism of RDF graph G to RDF graph H is
a function h : UG  UH which induces a function h : G  H such that
h(a, p, b) = h(a), h(p), h(b)  H.
Definition 2. A p-map h : G  H is an RDF homomorphism h : G  H
where h(u) = u for all u  VG.

Thus, a p-map is an RDF homomorphism in which the only elements that are
allowed to vary are edges: If h : G  H is an RDF homomorphism between
RDF graphs G and H, then h(g)  H for all triples g  G, while if h is a p-
map, then a, h(p), b  H for all triples a, p, b  G. This is a natural class of
homomorphisms to study for our purposes since edges are typically vocabulary
elements, while vertexes contain the real data. Note, though, that the definition of a p-map is not without subtleties, given that a single element in an RDF
graph may be both a vertex and an edge:
Proposition 1. Let h be a p-map of G and let a, p, b be any arbitrarily chosen
triple in G. Then h(a, p, b) = a, p, b whenever p  VG.

3 Syntax and Semantics of SPARQL

To make this paper reasonably self-contained, we introduce a minimum of
SPARQL syntax and semantics, considering only the select-project-join frag-
ment. For a complete exposition of SPARQL, consult e.g. [1, 9, 10].
Assume the existence of a set of variables V disjoint from U. A SPARQL graph

pattern is defined recursively as follows:
Definition 3. A SPARQL graph pattern S is either a triple pattern t in (V 
U ) (V  U ) (V  U  L), or a conjunction S1&S2 of SPARQL graph patterns.

According to this definition SPARQL graph patterns do not contain blank nodes.
As shown in [1] it is easy to extend the definition in this respect, but as blank
nodes behave like variables in select queries, we shall not care to do so. We use
var(S) to denote the set of variables occurring in a set of triples S, and varp(S)
to denote those occurring as edges, i.e. in the second element of triples.

Definition 4. A conjunctive SPARQL query, or just select query, is a pair
S, x, where S is a SPARQL graph pattern and x a subset of var(S).
A variable mapping is a partial function  : V  U that extends in the natural
way to a function on triples which respects RDF triple grammar, i.e. (S)  T
for any triple pattern S. The domain of a function f is denoted dom(f ), and the
range by ran(f ). The semantics of the select-project-join fragment of select and
construct SPARQL queries can now be given by the following series of definitions,
modelled after [1, 9]:

Definition 5. 1 and 2 are compatible variable mappings if for every x 
dom(1)  dom(2) we have 1(x) = 2(x).

A. Stolpe and M.G. Skjveland

Definition 6. Let 1 and 2 be sets of variable mappings. We define the join
of 1 and 2 as 1  2 := {1 2 | 1  1, 2  2, 1 and 2 compatible}.
Definition 7. The evaluation of S over an RDF graph G, written SG, is
1. { | dom() = var(t) and (t)  G}, if S is a triple pattern t,
2. S1G  S2G, if S is a conjunction S1&S2
Definition 8. The answer to a query S, x over a graph G, written S, x (G),
is the set {(x) |   SG}.

Definition 9. A SPARQL template is a SPARQL graph pattern in which blank
nodes may occur as vertexes.

Definition 10. Let C be a SPARQL template, S a SPARQL graph pattern, G
an RDF graph, and blank(T ) be the set of blank nodes occurring in a set of

triples T . We define the set of renaming functions { |   SG} relative to

C and S as follows:

 for every , dom() = blank(C) and ran()  (B \ blank(G)),
 every  is injective, and
 for all 1, 2  SG, if 1 = 2, then ran(1 ) = ran(2 ).

Definition 11. A SPARQL construct query, or just construct query, is a pair
C, S, where C is a SPARQL template and S a SPARQL graph pattern such
that var(C)  var(S). The answer to a construct query C, S over an RDF
graph G, written C, S (G), is the RDF graph SG (((C)).

We end this section with a lemma that links the principal notions introduced
so far. It shows, essentially, that answers to queries and evaluations of SPARQL
patterns are interchangeable idioms for talking about transformations of RDF
graphs:

Lemma 1. Let G and H be RDF graphs, and h any function from UG to UH .

Then,

1. S, x (G)  h(S), x (H) iff SG  h(S)H .
2. h(S), x (H)  S, x (G) iff h(S)H  SG.

Proof. The claim follows immediately from Definition 8 and the fact that
dom(h)  V = , whence var(S) = var(h(S)).
?

?

?
4 Degrees of Conservativeness

Having assembled the requisite preliminaries, we turn to the problem of analysing
the notion of a conservative construct query. We shall limit the analysis in this
section to the simple case where the query transforms RDF triples to RDF
triples. Let G be any RDF graph. As a tentative characterisation we may say
that a construct query is conservative if applied to G it evaluates to a graph
?

?

?
that conservatively transforms the sub-graph of G that matches the pattern in
the SELECT clause. This pushes the question back to what it means for an RDF
graph to be a conservative transformation of another. As the reader may suspect
already, we shall take the existence of a particular kind of p-map between two
graphs to provide a sufficient condition. As homomorphisms, p-maps in general
reflect the structure of the source in the target. A simple consequence of this is
that queries over the source can be translated to queries over the target without
loss of tuples in the result set:
Theorem 1. Let G and H be RDF graphs, h : G  H a p-map, and S a
SPARQL pattern such that varp(S) = . Then S, x (G)  h(S), x (H).

The existence of a p-map between the source and the target graph may thus
be taken to account for the systematicity of a construct query, as alluded to in
Section 1. It does not account for non-distortiveness for which we also need to
reflect the structure of the result back into the source. We shall consider three
ways of doing that, represented by bounds on p-maps:
Definition 12. A p-map h : G  H is bounded, and called a p1-, p2- or p3-
map, respectively, if it satisfies one of the following conditions; for all a, p, b  U:

a, h(p), b  H  a, p, b  G
a, h(p), h(b)  H or h(a), h(p), b  H  a, p, b  G
h(a), h(p), h(b)  H  a, p, b  G

(p1)
(p2)

(p3)

As we shall see, each bound reflects a different aspect of the structure of the
target in the source. It is easy to check that (p1) is strictly stronger than (p2),
and that (p2) is strictly stronger than (p3). To be sure, there are other bounds,
but these are particularly simple and natural. We shall need the following lemma:

Lemma 2. If varp(t) =  and t, x (G) =  for a triple pattern t, then
2(h(t)) = h(2(t)) for any p-map h.

Turning now to condition (p1) we obtain the converse of Theorem 1:

Theorem 2. If S, x (G) = , varp(S) =  and h is a p1-map h : G  H,
then h(S), x (H)  S, x (G).

Proof. Assume the conditions of the theorem hold. By Lemma 1 it suffices to

show that h(S)H  SG. The proof proceeds by induction on the complexity
of S. For the base case, suppose S is a triple pattern t and that   h(t)H . By
Definition 7(1) it follows that (h(t))  H. By the suppositions of the theorem
we have varp(t) =  and t, x (G) = , whence Lemma 2 yields 2(h(t)) =
h(2(t)) = h(p) for some p  2(G). Therefore (h(t)) = a, h(p), b  H for
some a, b, whence a, p, b  G since h is a p1-map. By Definition 7(1) dom() =
var(h(t)) = var(t), so   tG as desired. For the induction step, assume
the property holds for simpler patterns, and consider S = Sb&Sc such that
the suppositions of the theorem hold, and such that   h(Sb&Sc)H . It is

A. Stolpe and M.G. Skjveland

easy to check that h(Sb&Sc)H = h(Sb)&h(Sc)H , whence   h(Sb)H 
h(Sc)H , by Definition 7(2). It follows from Definition 6 that  = b  c for
compatible b and c such that b  h(Sb)H and c  h(Sc)H . Now, since
Sb&Sc, x (G) =  and varp(Sb&Sc) = , by the supposition of the case, we have
Sb, y (G) =  and varp(Sb) =  for y such that yi  dom(b) for all yi  y
and similarly for Sc. Therefore the induction hypothesis applies, so b  SbH
and c  ScH by Lemma 1. We have already assumed that b and c are
compatible, so b  c  SbG  ScG = Sb&ScG by Definition 7(2). Since
b  c = , we are done.
?

?

?
Theorem 1 and Theorem 2 show that p1-maps induces a transformation between
RDF graphs that is exact in the sense that the diagram in Figure 1 commutes.
That is, whatever answer a query Q yields over G, h(Q) yields precisely the same
answer over H. Interestingly, the converse is also true, if a function induces an,
in this sense, exact transformation between graphs, then it is a p1-map:
Theorem 3. Let h be any function from U to itself. If for all SPARQL patterns
S we have S, x (G) = h(S), x (H), then h is a p1-map of G to H.
Proof. The proof is by induction on the complexity of S. The induction step is
easy, so we show only the base case where S is a triple pattern t. Suppose that
h is not a homomorphism between G and H. Then there is a triple a, p, b  G
such that h(a), h(p), h(b) / H. Let t := x, p, y and x := x, y. Then h(t) =
x, h(p), y, and a, b  t, x (G) \ h(t), x (H). We therefore have t, x (G) 
h(t), x (H). Suppose next that h does not satisfy (p1). Then there is a triple
a, h(p), b  H such that a, p, b / G, and t := x, p, y separates G and H by

a similar argument.

U n

The class of p1-maps thus completely characterises the
pairs of graphs for which there is an exact triple-to-triple
translation of select queries from one to the other. Note
that exactness here does not mean that the source and
target are isomorphic. The target may contain more information in the form of triples, as long as these triples do
not have source edges that map to them. Indeed, a p1-map
need not even be injective:
Example 2. Assume we have the following RDF graphs: G := {a, p, b ,a, q, b},
H1 := {a, r, b} and H2 := {a, r, b ,c, s, d}. Then {p  r, q  r} is a p1-map
of G to H1, and of G to H2, given that h is the identity on vertexes.

Fig. 1.

h(Q)

h

Characterisation results similar to Theorem 2 and Theorem 3 are easily forthcoming for p2- and p3-maps as well. The proofs are reruns with minor modifications of that for p1-maps.
Theorem 4. Let h be any function from U to itself and suppose S, x (G) = 
and varp(S) = . Then, h : G  H is a p2-map iff u  h(S), x (H) \
S, x (G) implies u / UG for any u  u, and h : G  H is a p3-map iff
u  h(S), x (H) \ S, x (G) implies u / UG for some u  u.
?

?

?
Different bounds may be used to exercise different levels of control depending on
the nature or interpretation of an edge. More specifically, different predicates may
be restricted in different ways depending on the intended interpretation of those
predicates: p1-maps are suitable for that part of a data-set to which one would
wish to remain absolutely faithful, typically the domain-specific information that
is collected and managed by the issuer of the data-set. p2-maps are suitable
for situations where you would want to merge domain-specific knowledge from
two different sources whilst keeping the information from each of the sources
unchanged. They are more forgiving than p1-maps in the sense that they allow
a relation to grow as long as every added pair relates new objects only. Finally,
p3-maps would typically be applied to vocabulary elements that are most aptly
considered as part of the logical or general-purpose vocabulary. For instance,
applied to rdf:type, they allow types to be added to source elements as long as
those types are not already used in the source. In other words, p3-maps allow
additional typing as long as the added types do not occur in the source.

Example 3. Let G be the excerpt of triples listed in Example 1 and assume it is
transformed into the following target H:

<http://sws.ifi.uio.no/gulliste/kulturminne/208/5/6643335/597618>

rdf:type gul:Kontor, cidoc:E25.Man-Made_Feature ;
vcard:street-address "Akersgata 44" ;
vcard:zip-code "0180" ;

geo:long "10.749" ;
geo:lat
"59.916" .

<http://sws.ifi.uio.no/gulliste/kulturminne/999/2/6644406/596768>

rdf:type cidoc:E25.Man-Made_Feature ;
geo:long "10.731" ;

geo:lat

"59.926" .

The map of the source into the target shows the features of bounded p-maps given
in the preceding paragraph. The edges hvor:gateaddresse and hvor:postnummer
are mapped to respectively vcard:street-address and vcard:zip-code under the
(p1) bound, indicating that these edges relate the exact same data as their counterparts in the source. The edges geo:lat and geo:long are mapped to themselves
under bound (p2), meaning that new relationship may be added as long as they
relate only new data elements, i.e. elements not originating from the source. The
edge rdf:type is also mapped to itself under a (p3) bound allowing new types
to be added to the buildings in the yellow list (and new buildings be given old
types). The transformation is illustrated below:

t y p e

h

\

a

t

\ l
long
\
s-address
\
z - c o d e

h(G)

t y p e\

\\\

type

l

a

t

long
g-adresse
p - n u m m e r

\

a

t

\

\\ l
long
\\
type

VH \ VG

Marked arrows, \
and \\\ , represent triples satisfying bound (p1), (p2)
and (p3), respectively. The set of target vertexes is partitioned into two sets, VG
and VH \ VG, illustrated by the dashed line.

, \\

A. Stolpe and M.G. Skjveland

Conservativeness (in our sense) is preserved by composition:

Theorem 5. Let h1 be a p-map of G to H that satisfies a bound pi, and h2 a
p-map of H to I that satisfies a bound pj, and suppose pi logically entails pj.
Then h2  h1 is a p-map that satisfies pj.

As the theorem shows, a composition of two bounded p-maps will satisfy the
weakest of the two bounds. Since they are both conservative in the abovementioned sense, we can claim that the use of bounded p-maps counteract cumulative error in iterated data transformation.

Note that SPARQL graph patterns and SPARQL templates are similar to
RDF graphs in the sense that they too are sets of triples. Thus, we may extend
the notion of a p-map accordingly by including variables in the domain and
letting the p-map be the identity on those variables. Clearly, if h is a p-map
of the latter sort, then we have var(t) = var(h(t)) for any triple pattern t.
Moreover, for triple patterns where no edge is a variable,  and h commute:
(h(t)) = h((t)). This allows us to prove the following result:
Theorem 6. Let C, S be a construct query, where C contains no variables as
edges. If h is a p-map of S to C which is bounded by one of (p1)(p3), then h
is a p-map under the same bound of S, S (G) to C, S (G).
Proof. In the limiting case that SG = , we have C, S (G) =  as well,
whence the theorem holds vacuously. For the principal case where SG = 
suppose g  S, S (G) = SG(((S)). By Definition 3 we have that S
does not contain blank nodes, so g  SG ((S)). It follows that g = (t)
for a triple pattern t in S and some   SG. By assumption, h is a p-map
it follows that (h(t))  SG (((C)). It remains to show that h(g) =

of S to C, whence h(t) is a triple pattern in C, and since var(h(t)) = var(t),

(h(t)). Since g = (t) it suffices to show that h((t)) = (h(t)), which is just
the commutativity of  and h. The relationships between the different graphs
are illustrated in Figure 2. Now assume that h from S to C is restricted by a
bound (p1)(p3), indicated by (p) in the figure. Then for every t  C there is a
  S such that the bound holds. For all  such that (t)  C, S (G) we have
t
)  S, S (G), but then the p-map h must be restricted by the same bound
(t

as between S, S (G) and C, S (G).
?

?

?
Thus, if there is a bounded p-map from the
WHERE block to the CONSTRUCT block in a construct query, then any sub-graph that matches
the former can be p-mapped with the same
bound into the result of the query. By the
properties of bounded p-maps, therefore, we
are licensed to say that the construct query is
a conservative transformation.



S, S (G)

h

(p)

h

(p)



C, S (G)

Fig. 2.
?

?

?
5 Generalising the Conservativeness Criterion

We take ourselves to have demonstrated that a bounded p-map is an interesting
kind of structure-preserving map for the purpose of maintaining information
content across repeated transformation of RDF data. Needless to say triple-to-
triple transformations are very restrictive. As Example 1 shows, many construct
queries seem to have a legitimate claim to conservativity even though they fall
outside of this class. The purpose of the present section is therefore to put the
concept of a p-map to more creative use and expand the class of RDF graphs
that we recognise as conservative in relation to others. More specifically, we shall
generalise the notion of a p-map from a triple-to-triple transformation to a subgraph to sub-graph transformation, no longer requiring that pairs of vertexes be
consistently and non-distortively related by triplesonly that they be so related
by sub-graphs. The point is to have a transformation that is conservative in
much the same sense as a bounded p-map is. That is, the transformation should
satisfy the property that if a sub-graph of H is expressed purely in terms of
representatives of structural elements of G, then it reflects an actual sub-graph
of G. We shall illustrate this approach by considering a function that maps
paths in G to paths in H. This particular choice is motivated by Example 1 and
similar ones which show that many construct queries can indeed be considered
as transformations mapping triples to paths, or paths to paths more generally.

Definition 13. A walk is a non-empty sequence  of triples  := g1, g2, . . . , gn
such that 3(gi) = 1(gi+1) for 1  i < n. We shall let len() = n denote the
length of , whilst px() := 1(g1) and dt() := 3(gn) will denote the proximal
and distal vertexes of , respectively. A cycle is a walk  where dt() = px().
A path is a walk where no proper segment forms a cycle.

Note that we only consider finite paths. The set of paths in an RDF graph G,

denoted G
, is thus finite too. Cycles are allowed, as long as they do not contain
smaller cycles, and triples are considered as unary paths (or unary cycles if the
vertexes are the same). We next introduce two equivalence relations on paths:

Definition 14. Let  and  be paths. We define the equivalence relations =V
and =E on paths as

1.  =V  iff px() = px() and dt() = dt()
2.  =E  iff  equals , except that the respective proximal and distal vertexes

of  and  may differ.

In the case where  is a path and g a triple we shall abuse this notation slightly,

writing  =E g to mean  =E g, and similarly for =V .
Clearly, if two paths are both =V -equivalent and =E-equivalent, then they are
the same path. Neither relation factors blank nodes into the notion of sub-graph
equivalence. This is an obvious further development which we shall comment on
below. By the use of the relations =E and =V it is possible to impose restrictions
that intuitively constrain the transformation of paths to paths in the same way
that a bound constrains the transformation of triples to triples.

A. Stolpe and M.G. Skjveland

)



H

H (H

)


G(G

Consider the diagram in Figure 3. Here G and
H are functions that return the closure under
compositiona notion yet to be definedof the two
RDF graphs G and H. We shall say that a bound on
maps of paths corresponds to a bound on p-maps if

and H
for every f , G
, there

is an h : G(G
) such that f satisfies
the path map bound iff h satisfies the p-map bound.
If that is the case, then a consistent relation between triples in the top row is
reflected by a consistent relation between paths in the lower row, whence f may
be used in loco parentis for h to measure the conservativeness of H wrt. G. To
that end, we next define the closure under composition of an RDF graph, and
state a few properties of this operation:

)  H (H

  H

where f : G

Fig. 3.



h

f

G









Definition 15. A composition function  for an RDF graph G is a function of
type  : G

  T such that

1.  =V (),
2.  =E  iff () =E (),
3. 2(()) = 2(), if len() = 1, otherwise 2(()) / UG.

According to this definition, a composition function is such that every non-unary
path in G is correlated with a triple whose edge is new to G. Essentially for this
reason, composition functions always exist:

Lemma 3. There is a composition function for every RDF graph G.


and (G


A composition function for G extends G, and puts G
correspondence, as one would expect:
Proposition 2. If  is a composition function for G, then G  (G


Lemma 4. A composition function  for G is a bijection between G
Turning to path-maps, that is, to functions of type f : T   T 
, we are not
interested in all path-maps, only those that can be used to emulate p-maps.
For want of a better name we shall call them c-maps:


and (G

) in one-to-one

).

).

Definition 16. A c-map is a path-map f where:
1. the relation {(g, g
2.  =V f (),
3. if  =E , then f () =E f (),
4. len()  len(f ()).

)  f} is a p-map,

) | (g ,g
?

?

?
The class of c-maps thus consists of those path-maps that behave like a p-map
on unary paths (1), are sensitive to =V - and =E-equivalence (2, 3), and never


truncate paths (4). The next theorem shows that every c-map of G
induces a p-map of G(G) to H (H), for some G and H :

to H
?

?

?
Lemma 5. Let G, H be composition functions for RDF graphs G and H, re-
spectively. Then every path-map f : G
) to
H (H
), defined by letting hf be the identity on vertexes and putting
hf (2(G())) = 2(H (f ())).


induces a p-map hf of G(G

  H





We now generalise the p-map bounds of Definition 12 to bounds on c-maps:

Definition 17. Suppose  and  are paths in the RDF graphs G and H, re-
spectively. We shall say that a c-map f : G
is respectively a c1-, c2- or
c3-map if one of the following conditions holds:

  H



 f () =  for some   G

f () =E 
f () =E  and {px(), dt()}  VG =   f () =  for some   G

 f () =  for some   G
f () =E  and {px(), dt()}  VG


(c1)
(c2)
(c3)

That these bounds are in fact generalisations of those of Definition 12 is established by the following theorem:





) to H (H

) where a, b  VG. We need to show that a, p, b  G(G

and   H


Theorem 7. Let f be a c-map of RDF graph G to RDF graph H, G and H
composition functions for G and H, respectively, and hf the induced p-map of

). Then f is a cn-map iff hf is a pn-map, for n = 1, 2 or 3.
G(G
Proof. Suppose f is a c3-map and assume that there is a triple g := a, hf (p), b 
H (H
). Given that
G and H are surjective by Lemma 4, let   G

be such that
2(G()) = p and H () = g. By the definition of hf given in Lemma 5,
f () =E , so by bound (c3) there is a   G

where f () = . We have
g =V  =V  by Definition 16 and Definition 15, and  =E  by Definition 16,
since f () =E . This means that G() = a, p, b. For the converse direction,
suppose hf is a p3-map and assume, for some   G

, that f () =E
 and a, b  VG, where a := px() and b := dt(). By the definition of hf we
have hf (2(G())) = 2(H ()), so let H () := a, hf (p), b. Since hf satisfies
(p1), we have a, p, b  G(G

G() = a, p, b. Since G() =E G(), we have f () =E f (), and given that
 =V f () =V , we arrive at f () = . It is easy to adjust the membership of
a, b, px(), dt() in VG in the proof and confirm the claim for two other pair of

corresponding bounds.

). By Lemma 4, there is a   G


and   H

such that



Expanding the class of conservative construct queries to also handle paths requires the following generalisation of Theorem 6:
Theorem 8. Let C, S be a construct query, where C contains no blank nodes
and no variables as edges. If f is a cn-map of S to C, then f is a cn-map of
S, S (G) to C, S (G), for n = 1, 2, 3.

Proof (Sketch). Let  be a chain in S and let f be a c-map of C to S. If
f () contains blank nodes then, due to the relabelling function , f () may
be instantiated differently for each pair of objects that matches the vertexes

A. Stolpe and M.G. Skjveland

( (f ())), whence f
of . This means we may not have ((f ())) =E 
is not a c-map of S, S (G) to C, S (G). In the absence of blank nodes in
C this situation cannot arise,  becomes redundant, and the proof becomes a

straightforward generalisation of that for Theorem 6.
?

?

?
As this proof-sketch is designed to show, extra care is required when the construct
query C contains blank nodesas it does for instance in Example 1. However,
the preceding lemmata and theorems lay out all the essential steps. More specific-
ally, all that is needed in order to accommodate Example 1 and similar ones, is to
substitute equivalence classes of paths for paths throughout, where equivalence is
equality up to relabelling of blank nodes. The verification of this claim is a rerun
with minor modifications, and has therefore been left out.

6 Computational Properties

The problem of deciding whether there exists a homomorphism between two
(standard) graphs is well-known to be NP-complete. Since p-maps are more
restricted than generic graph homomorphisms, identifying p-maps between RDF
graphs is an easier task. In fact it can be done in polynomial time, the verification
of which is supported by the following lemmata:

Lemma 6. Let h1 and h2 be p-maps of G1 and G2 respectively to H. Then
h1h2 is a p-map of G1G2 to H if h1(u) = h2(u) for all u  dom(h1)dom(h2).
Lemma 7. If h1, h2 are bounded p-maps such that h1(u) = h2(u) for all u 
dom(h1)  dom(h2). Then h1  h2 is a bounded p-map satisfying the weaker of

the two bounds.

According to Lemma 6 the task of finding a p-map of G to H can be reduced to
the task of finding a set of p-maps of sub-graphs of G into H that are compatible
wrt. to shared domain elements. Lemma 7 then tells us that to check whether the
resulting p-map is bounded by some bound pn, it suffices to check whether each
of the smaller maps is. This procedure, each step of which is clearly polynomial,
does not require any backtracking, whence:
Theorem 9. Given two RDF graphs G and H, finding a p-map h : G  H,
bounded or not, is a problem polynomial in the size of G and H.

Proof (Sketch). For any RDF graphs G and H, fix the set VG of nodes occurring
as vertexes in G. Then for each p  EG construct a p-map of Gp := {a, p
, b 
= p} into H. This amounts to iterating through the edges of H and
G | p
finding one, say q, such that i) a, p, b  Gp  a, q, b  Hq and ii) if p  VG
?

?

?
then p = q. Lemma 6 tells us that the union of these maps is a p-map of G
to H, i.e. no choice of q for p is a wrong choice. There is therefore no need for
backtracking, whence a p-map can be computed in polynomial time. To check
whether it satisfies a given bound pn, it suffices by Lemma 7 to check that each
of the maps hp of Gp to Hq does. That is, for each element a, q, b  Hq \ Gp

check that the required triple is in Gp. This is clearly a polynomial check.
?

?

?
Input : RDF graphs G and H, bound pn.
Output: A p-map h bounded by pn, or  if none exists.
h := {a, a} for a  VG;
for p  EG
if p  VG

if a, p, b  G  a, p, b  H

for c, p, d  H \ G

if not CheckBound(c, p, d , pn) return ;

else return ;

else

if not found and a, p, b  G  a, q, b  H

if not CheckBound(c, q, d , pn) break;

bool found := false;;
for q  EH

for c, q, d  H \ G
h := h  {p, q};;
found := true;
if not found return ;

return h;

Algorithm 1. Computing a bounded p-map if one exists. The check for compliance
with the bounds is encapsulated in a boolean subroutine CheckBound.

n=1

)|  |VG|

|EG|  n! . Yet, this is not a problem for any

For c-maps the situation is more complex. Since the composition of an RDF
graph may be exponentially larger than the graph itself, the problem is no longer
polynomial. More precisely, if G is an RDF graph and  a composition function
for G, then |(G

realistically sized construct query. An experimental application is up and running
at http://sws.ifi.uio.no/MapperDan/. Mapper Dan takes two RDF graphs or a
construct query as input, lets the user specify which bounds to apply to which
predicates, and checks whether there is a map under the given bound between
the two graphs or between the WHERE and CONSTRUCT block of the construct query.
In the cases where a bound is violated Mapper Dan offers guidance, if possible,
as to how to obtain a stratified map which satisfies the bounds. A map can
be used to translate the source RDF data to the target vocabulary, produce a
construct query which reflects the map, or to rewrite SPARQL queries.

7 Conclusion and Future Work

This paper provides a structural criterion that separates conservative from nonconservative uses of SPARQL construct queries. Conservativity is here measured
against the asserted content of the underlying source, which is required to be
preserved by the possible change of vocabulary induced by the construct clause.
Our problem led us to consider a class of RDF homomorphisms (p-maps) the
existence of which guarantees that the source and target interlock in a reciprocal
simulation. Viewed as functions from triples to triples, p-maps are computable in

A. Stolpe and M.G. Skjveland

polynomial time. The complexity increases with more complex graph patterns.
The class of p-maps has other applications besides that described here, e.g as the
basis for a more refined notion of RDF merging. As of today merging is based on
the method of taking unions modulo the standardising apart of blank nodes. If
one also wants a uniform representation of the data thus collected this method
is too crude. What one would want, rather, is a way of transforming the data by
swapping vocabulary elements whilst, as far as it goes, preserving the information
content of all the involved sources (this is not easily achieved by subsuming a set
of properties or types under a common super-type in an ontology). Such a merge
procedure may turn out to be an important prerequisite for truly RESTful write
operations on the web of linked data.

Acknowledgements. This research was partially funded by the Norwegian
Research Council through the Semicolon II project (http://www.semicolon.no/).
