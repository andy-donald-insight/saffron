Modelling Structured Domains

Using Description Graphs and Logic Programming

Despoina Magka, Boris Motik, and Ian Horrocks

Department of Computer Science, University of Oxford

Wolfson Building, Parks Road, OX1 3QD, UK

Abstract. Although OWL 2 is widely used to describe complex objects such as
chemical molecules, it cannot represent structural features of chemical entities
(e.g., having a ring). A combination of rules and description graphs (DGs) has
been proposed as a possible solution, but it still exhibits several drawbacks. In this
paper we present a radically different approach that we call Description Graph
Logic Programs. Syntactically, our approach combines DGs, rules, and OWL 2
RL axioms, but its semantics is defined via a translation into logic programs under stable model semantics. The result is an expressive OWL 2 RL-compatible
formalism that is well suited for modelling objects with complex structure.

1 Introduction

OWL 2 [7] is commonly used to represent objects with complex structure, such as complex assemblies in engineering applications [8], human anatomy [22], or the structure of
chemical molecules [10]. In order to ground our discussion, we next present a concrete
application of the latter kind; however, the problems and the solution that we identify
apply to numerous similar scenarios.

The European Bioinformatics Institute (EBI) has developed the ChEBI ontologya
public dictionary of molecular entities used to ensure interoperability of applications
supporting tasks such as drug discovery [17]. In order to automate the classification of
molecular entities, ChEBI descriptions have been translated into OWL and then classified using state of the art Semantic Web reasoners. While this has uncovered numerous implicit subsumptions between ChEBI classes, the usefulness of the approach was
somewhat limited by a fundamental inability of OWL 2 to precisely represent the structure of complex molecular entities. As we discuss in more detail in Section 3, OWL 2
exhibits a so-called tree-model property [23], which prevents one from describing non-
tree-like relationships using OWL 2 schema axioms. For example, OWL 2 axioms can
state that butane molecules have four carbon atoms, but they cannot state that the four
atoms in a cyclobutane molecule are arranged in a ring. Please note that this applies
to schema descriptions only: the structure of a particular cyclobutane molecule can be
represented using class and property assertions, but the general definition of all cyclobutane moleculesa problem that terminologies such as ChEBI aim to solvecannot be

 This work was supported by the EU FP7 project SEALS and the EPSRC projects ConDOR,

ExODA, and LogMap.

E. Simperl et al. (Eds.): ESWC 2012, LNCS 7295, pp. 330344, 2012.
c Springer-Verlag Berlin Heidelberg 2012
?

?

?
fully described in OWL 2. As we show in Section 3, an ontology may therefore fail to
entail certain desired consequences.

A common solution to this problem is to extend OWL 2 with a rule-based formalism such as SWRL [11]. However, adding rules to even a very small fragment of OWL
2 makes the basic reasoning problems undecidable [14], which hinders practical us-
ability. Decidability can be ensured by applying the rules only to the explicitly named
individuals [21], or by restricting the shape of the rules [12]. Such restrictions, however,
typically prevent the rules from axiomatising the required structures.

In our previous work, we considered a combination of OWL 2, rules, and description
graphs (DGs) [20]a graphical notation for describing non-tree-like structures. We
ensured decidability of reasoning via a property separation condition and by requiring
DGs to be acyclic. Intuitively, the latter means that DGs can describe structures of
arbitrary shape, but bounded in size, while the former limits the interaction between
the OWL and DG parts, thus preventing multiple DG structures from merging into one
structure of (potentially) unbounded size. As reported in [10], DGs solved only some
of the problems related to the representation of structured objects, and our subsequent
discussions with EBI researchers have revealed the following drawbacks.

First, the DG approach [20] does not allow one to define structures based on the
absence of certain characteristics. For example, an inorganic molecule is commonly
described as a molecule not containing a carbon atom, which can then be used to
classify water as an inorganic molecule. Designing an axiomatisation that produces the
desired entailment is very cumbersome with the DG approach: apart from stating that
each water molecule consists of one oxygen and two hydrogen atoms, one must additionally state that these three atoms are the only atoms in a water molecule and that
neither hydrogen nor oxygen atoms are carbon atoms. Second, the separation conditions governing the interaction of the OWL 2 and DG components makes the combined
language rather difficult to use, as no role can be used in both components. Third, the
acyclicity condition from [20] is rather cumbersome: a modeller must add a number
of negative class assertions to DGs so as to make any ontology with cyclic implications between DGs unsatisfiable. This solution fails to cleanly separate the semantic
consequences of an ontology from the acyclicity check.

In response to this critique, in this paper we present a radically different approach to
modelling complex objects via a novel formalism that we call Description Graph Logic
Programs (DGLP). At the syntactic level, our approach combines DGs, rules, and OWL
2 RL axioms [19]. In order to overcome the first problem, we give semantics to our
formalism via a translation into logic programs (which can be easily done for OWL 2
RL axioms [9]) interpreted under stable model semantics. As we show in Section 4,
the resulting formalism can capture conditions based on the absence of information.
Moreover, we address the second problem by ensuring decidability without the need
for complex property separation conditions.

To address the third problem, in Section 5 we discuss existing syntactic acyclicity
conditions, such as weak acyclicity [6] and super-weak acyclicity [16], and argue that
they unnecessarily rule out some very simple and intuitively reasonable ontologies. As a
remedy, we present a novel semantic acyclicity condition. Roughly speaking, a modeller
is required to specify a precedence relation describing which DGs are allowed to imply

D. Magka, B. Motik, and I. Horrocks

other DGs; a cyclic ontology that is not compatible with this precedence relation entails
a special propositional symbol. A cyclic ontology can still entail useful consequences,
but termination of reasoning can no longer be guaranteed.

In Section 6 we consider the problem of reasoning with ontologies including only
negation-free rules. We show that the standard bottom-up evaluation of logic programs
can decide the relevant reasoning problems for semantically acyclic ontologies, and that
it can also decide whether an ontology is semantically acyclic. Furthermore, in Section
7 we show that this result can be extended to ontologies with stratified negation.

In Section 8 we present the results of a preliminary evaluation of our formalism.
We show that molecule descriptions from the ChEBI ontology can be translated into a
DGLP ontology that entails the desired subsumption consequences. Furthermore, despite the very preliminary nature of our implementation, we show that reasoning with
DGLP ontologies is practically feasible. Thus, in this paper we lay the theoretical foundations of a novel, expressive, and OWL 2 RL-compatible ontology language that is
well suited to modelling objects with complex structure.

The proofs of all technical results presented in this paper are given in a technical

report that is available online.1

2 Preliminaries

We assume the reader to be familiar with OWL and description logics. For brevity, we
write OWL axioms using the DL notation; please refer to [1] for an overview of the DL
syntax and semantics. Let  = (C , F , P ) be a first-order logic signature, where
C, F , and P are countably infinite sets of constant, function, and predicate sym-
bols, respectively, and where P contains the 0-ary predicate . The arity of a predicate
A is given by ar (A). A vector t1, . . . , tn of first-order terms is often abbreviated as t.
An atom is a first-order formula of the form A(t), where A  P and t is a vector of
the terms t1, . . . , tar (A). A rule r is an implication of the form

B1  . . .  Bn  not Bn+1  . . .  not Bm  H1  . . .  H

(1)
where H1, . . . , H are atoms, B1, . . . , Bm are atoms different from , m  0, and
 > 0. Let head (r) = {Hi}1i, body +(r) = {Bi}1in, body
(r) = {Bi}n<im,
and body(r) = body +(r)  body
(r). A rule r is safe if every variable that occurs in
head (r) also occurs in body +(r). If body(r) =  and r is safe, then r is a fact. We

denote with head P (r), body +
P (r), and body P (r) the set of predicates that
occur in head (r), body +(r), body
(r), and body (r), respectively. A rule r is functionfree if no function symbols occur in r. A logic program P is a set of rules. A logic
program P is negation-free if, for each rule r  P , we have body

P (r), body



(r) = .







Given a logic program P , HU (P ) is the set of all terms that can be formed using the
constants and the function symbols from P (w.l.o.g. we assume that P contains at least
one constant). If no variables occur in an atom (rule), then the atom (rule) is ground.
Given a logic program P , the set HB(P ) is the set of all ground atoms constructed
using the terms in HU (P ) and the predicates occuring in P . The grounding of a rule r

1 http://www.cs.ox.ac.uk/isg/people/despoina.magka/
?

?

?


w.r.t. a set of terms T is the set of rules obtained by substituting the variables of r by
the terms of T in all possible ways. Given a logic program P , the program ground(P )
is obtained from P by replacing each rule r  P with its grounding w.r.t. HU (P ).
Let I  HB (P ) be a set of ground atoms. Then, I satisfies a ground rule r if
body +(r)  I and body
(r)  I =  imply head (r)  I. Furthermore, I is a model
of a (not necessarily ground) program P , written I |= P , if   I and I satisfies each
rule r  ground(P ). Given a negation-free program P , set I is a minimal model of P
if I |= P and no I
 |= P . The Gelfond-Lifschitz reduct P I of a
logic program P w.r.t I is obtained from ground(P ) by removing each rule r such that
(r)  I = , and removing all atoms not Bi in all the remaining rules. A set I is
body
a stable model of P if I is a minimal model of P I. Given a fact A, we write P |= A if
A  I for each stable model I of P ; otherwise, we write P |= A.

  I exists such that I



A substitution is a partial mapping of variables to ground terms. The result of applying a substitution  to a term, atom, or a set of atoms M is written as M  and is defined
as usual. Let P be a logic program in which no predicate occurring in the head of a rule
in P also occurs negated in the body of a (possibly different) rule in P . Operator TP
applicable to a set of facts X is defined as follows:
TP (X) = X  {h | h  head (r), r  P,  maps the variables of r to

HU (P  X) such that body +(r)  X and body
P = TP (T i1

P ) for i  1, and let T


P =



P = , let T i



(r)  X = }
 T i+1

P is the

P . Clearly, T i
Let T 0
for each i  0. Furthermore, such P has at most one stable model [3], and T

stable model of P if and only if   T

i=1 T i


P .

3 Motivating Application

We next motivate our work using examples from the chemical Semantic Web application mentioned in the introduction. The goal of this application is to automatically
classify chemical entities based on descriptions of their properties and structure. Un-
fortunately, as discussed in [20], OWL cannot describe cyclic structures with sufficient
precision. This causes problems when modelling chemical compounds since molecules
often have cyclic parts. For example, the cyclobutane molecule contains four carbon
atoms connected in a ring,2 as shown in Figure 1(a). One might try to represent this
structure using the following OWL axiom:

Cyclobutane  Molecule  = 4 hasAtom.[Carbon  (= 2 bond.Carbon)]

This axiom is satisfied in first-order interpretations I and I
shown in Figures 1(b)
and 1(c), respectively; however, only interpretation I correctly reflects the structure of
cannot be ruled out by writing additional
cyclobutane. Furthermore, interpretation I
axioms: OWL has a variant of the tree-model property, so each satisfiable TBox has at
least one tree-shaped interpretation. This can prevent the entailment of certain desired
?

?

?
2 In fact, cyclobutane also contains two hydrogens attached to each carbon; however, hydrogen

atoms are commonly left implicit to simplify the presentation.

D. Magka, B. Motik, and I. Horrocks

hasAtom

bond

(a) Chemical structure of cyclobutane

Molecule, Cyclobutane

Molecule,

Cyclobutane

Carbon

Carbon

Carbon
(b) Interpretation I

Carbon

Carbon

Carbon

Carbon

Molecule, Cyclobutane

Oxygen

CarbonCarbon

Carbon Carbon

Carbon

Carbon

Carbon

CarbonCarbon

CarbonCarbon

(c) Interpretation I
?

?

?
Carbon
(d) Interpretation I

Carbon
?

?

?
Fig. 1. The chemical structure and the models of cyclobutane

consequences. For example, one cannot define the class of molecules containing fourmembered rings that will be correctly identified as a superclass of cyclobutane.

The formalism from [20] addresses this problem by augmenting an OWL ontology
with a set of rules and a set of description graphs (DGs), where each DG describes a
complex object by means of a directed labeled graph. To avoid misunderstandings, we
refer to the formalism from [20] as DGDL (Description Graph Description Logics), and
to the formalism presented in this paper as DGLP (Description Graph Logic Programs).
Thus, cyclobutane can be described using the DG shown in Figure 2(a). The first-order
semantics of DGDL ontologies ensures that all models of an ontology correctly reprefrom Figure 1(c) does not satisfy
sent the DG structure; for example, interpretation I
the DG in Figure 1(a). Nevertheless, the first-order models of DGDL ontologies can still
shown in Figure 1(d) satbe insufficiently precise. For example, the interpretation I
isfies the definition of cyclobutane under the semantics of DGDL ontologies. We next
show how the presence of models with excess information can restrict entailments.3
?

?

?
One might describe the class of hydrocarbon molecules (i.e., molecules consisting
exclusively of hydrogens and carbons) using axiom (2). One would expect the definition
of cyclobutane (as given in a DGDL ontology) and (2) to imply subsumption (3).

3 Krotzsch et al. [13] also suggest an extension of OWL 2 for the representation of graph-like
structures. As we show next, the first-order semantics of this formalism exhibits the same
problems as that of DGDL ontologies.
?

?

?
Molecule  hasAtom.(Carbon  Hydrogen)  Hydrocarbon
Cyclobutane  Hydrocarbon

(2)

(3)
?

?

?
This, however, is not the case, since interpretation I
does not satisfy axiom (3). One
might preclude the existence of extra atoms by adding cardinality restrictions requiring
each cyclobutane to have exactly four atoms. Even so, axiom (3) would not be entailed
because of a model similar to I, but where one carbon atom is also an oxygen atom.
One could eliminate such models by introducing disjointness axioms for all chemical
elements. Such gradual circumscription of models, however, is not an adequate solution,
as one can always think of additional information that needs to be ruled out [18].

In order to address such problems, we present a novel expressive formalism that
we call Description Graph Logic Programs (DGLP). DGLP ontologies are similar to
DGDL ontologies in that they extend OWL ontologies with DGs and rules. In our case,
however, the ontology is restricted to OWL 2 RL so that the ontology can be translated into rules [9]. We give semantics to our formalism by translating DGLP ontologies into logic programs with function symbols. As is common in logic programming,
the translation is interpreted under stable models. Consequently, interpretations such
are not stable models of the DG in Figure 2(a), and hence subsumption (3) is
as I
entailed.
?

?

?
Logic programs with function symbols can axiomatise infinite non-tree-like struc-
tures, so reasoning with DGLP ontologies is trivially undecidable [4]. Our goal, how-
ever, is not to model arbitrarily large structures, but to describe complex objects up to a
certain level of granularity. For example, acetic acid has a carboxyl part, and carboxyl
has a hydroxyl part, but hydroxyl does not have an acetic acid part (see Fig. 3(a)).

In Section 5 we exploit this intuition and present a condition that ensures decidabil-
ity. In particular, we require the modeller to specify an ordering on DGs that, intuitively,
describes which DGs are allowed to imply existence of other DGs. Using a suitable test,
one can then check whether implications between DGs are acyclic and hence whether
DGs describe structures of bounded size only. The resulting semantic acyclicity condition allows for the modelling of naturally-arising molecular structures, such as acetic
acid, that would be ruled out by existing syntax-based acyclicity conditions [6,16].

4 Description Graph Logic Programs

We now present the DGLP formalism in detail. We start by defining a slightly modified
notion of description graphs; compared to the definition from [20], the new definition allows for only a single start predicate instead of a set of main concepts, and it includes a
graph mode that allows for the automatic generation of recognition rulessomething
that had to be introduced by hand in [20].

Definition 1 (Description Graph). A description graph G = (V, E, , A, m) is a directed labeled graph where
 V = {1, . . . , n} is a nonempty set of vertices,
 E  V  V is a set of edges,

D. Magka, B. Motik, and I. Horrocks

HasAtom

Bond

Cyclobutane

Gcb :

Carbon

3 Carbon

Carbon

4 Carbon

(a) Cyclobutane DG

Gcb
(a), f

Gcb
(a), f

(a)) for each i  {1, 2, 3, 4}
i+1(a)) for each i  {1, 2, 3}

Cyclobutane(a) Molecule(a)
Gcb
Gcb
(a), f
Gcb(a, f
(a))
?

?

?
Gcb
HasAtom(a, f
(a)) for each i  {1, 2, 3, 4}
i
Gcb
Carbon(f
i
Gcb
(a), f
Bond(f
i
Gcb
Gcb
Bond(f
(a), f
?

?

?
MolWith4MemberedRing(a)
Hydrocarbon(a)

Gcb

(a))

(b) The stable model of LP(O)

Fig. 2. Representing cyclobutane with DGLP

  assigns a set of unary predicates (v)  P to each vertex v  V and a set of
binary predicates (v1, v2)  P to each edge (v1, v2)  E,
 A  P is a start predicate for G such that A  (1), and
 m  {,,} is a mode for G.
A description graph (DG) abstracts the structure of a complex object by means of a directed labeled graph. For example, Figure 2 illustrates a DG that represents the structure
of a cyclobutane molecule. The start predicate of the graph (Cyclobutane in this case)
corresponds to the name of the object that the graph describes. The mode determines
whether a graph should be interpreted as an only if, if, or if and only if state-
ment. More precisely,  means that each instance of the DGs start predicate implies
the existence of a corresponding instantiation of the entire graph structure;  means
that an instantiation of a suitable graph structure is recognised as an instance of the
corresponding DG; and  means both of the above.

Next we define graph orderings, which will play an important role in ensuring the

decidability of DGLP.

Definition 2 (Graph Ordering). A graph ordering on a set of description graphs DG
is a transitive and irreflexive relation   DG  DG.
Intuitively, a graph ordering specifies which DGs can imply the existence of instances
of other DGs. For example, let GAA be a graph that represents the structure of the acetic
acid, and let Gcxl be a graph that represents the structure of the carboxyl group that
is a substructure of acetic acid (see Figure 3); then, one might define  such that
GAA  Gcxl, so that an acetic acid instance may imply the existence of a carboxyl
group instance, but not vice versa. We are now ready to define DGLP ontologies.
Definition 3 (DGLP Ontology). A DGLP ontology O = DG,, R, F is a quadruple where DG is a finite set of description graphs,  is a graph ordering on DG, R is
a finite set of function-free and safe rules, and F is a finite set of function-free facts.

For the sake of simplicity, we do not explicitly include an OWL 2 RL TBox into the
definition of DGLP ontologies: OWL 2 RL axioms can be translated into rules as shown
?

?

?
Carboxyl

GAA :

AceticAcid

Gcxl :

Carboxyl

Carbonyl

HasPart

Methyl

CH3

Hydroxyl

Methyl

Carboxyl

Carbonyl

Hydroxyl

(a) Chemical graph of acetic acid

(b) Acetic acid DG

(c) Carboxyl DG

Fig. 3. The chemical graph of acetic acid and the GAA and the Gcxl DGs

in [9] and included in R, and datatypes can be handled as in [15]. Similarly, we could
think of F as an OWL 2 ABox, as ABox assertions correspond directly to facts [9]. An
example of a DGLP ontology is {GAA, Gcxl},{(GAA, Gcxl)},,{AceticAcid(a)}.
We next define the semantics of DGLP via a translation into logic programs. Since
R and F are already sets of rules and  serves only to check acyclicity, we only need
to specify how to translate DGs into rules.

Definition 4 (Start, Layout, and Recognition Rule). Let G = (V, E, A, , m) be a
description graph and let f G
1 , . . . , f G|V |1 be fresh distinct function symbols uniquely
associated with G. The start rule sG, the layout rule G, and the recognition rule rG of
G are defined as follows:
A(x)  G(x, f G
G(x1, . . . , x|V |) 

R(xi, xj )
?

?

?
(sG)

(G)

i,jE,R(i,j)
R(xi, xj)  G(x1, . . . , x|V |)

(rG)
?

?

?
1 (x), . . . , f G|V |1(x))
B(xi) 
?

?

?
iV,B(i)

B(xi) 

iV,B(i),B=A

i,jE,R(i,j)

The start and layout rules of a description graph serve to unfold the graphs structure.
The function terms f G
1 (x), . . . , f G|V |1(x) correspond to existential restrictions whose
existentially quantified variables have been skolemised.

Example 1. The DG of cyclobutane from Figure 2 can be naturally represented by the
existential restriction (4). The skolemised version of (4) is the start rule (sGcb).

Cyclobutane(x) y1, y2, y3, y4 : Gcb(x, y1, y2, y3, y4)
Cyclobutane(x) Gcb(x, f

Gcb
(x), f

Gcb
(x), f

Gcb
(x), f

Gcb

(x))

(4)

(sGcb)

The layout rule (Gcb) encodes the edges and the labelling of the description graph.4
Finally, the rule rGcb is responsible for identifying the cyclobutane structure:

4 In the rest of the paper for simplicity we assume that bonds are unidirectional.
?

?

?
D. Magka, B. Motik, and I. Horrocks
Gcb(x1, x2, x3, x4, x5) Cyclobutane(x1) 
?

?

?
Bond(xi, xi+1)  Bond(x5, x2) 
2i4
?

?

?
HasAtom(x1, xi) 
Carbon(xi) 

(Gcb)
2i5
Bond(xi, xi+1)  Bond(x5, x2) 

HasAtom(x1, xi)

Carbon(xi)

2i5

2i5

2i5

2i4

Gcb(x1, x2, x3, x4, x5)

(rGcb)
?

?

?
Next, we define Axioms(DG), which is a logic program that encodes a set of DGs.
Definition 5 (Axioms(DG)). For a description graph G = (V, E, , A, m), the program Axioms(G) is the set of rules that contains the start rule sG and the layout rule
G if m  {,}, and the recognition rule rG if m  {,}. For a set of description graphs DG = {Gi}1in, let Axioms(DG) =
For each DGLP ontology O = DG,, R, F, we denote with LP(O) the program
Axioms(DG)  R  F . To check whether a class C is subsumed by a class D, we can
proceed as in standard OWL reasoning: we assert C(a) for a a fresh individual, and we
check whether D(a) is entailed.
Definition 6 (Subsumption). Let O be a DGLP ontology, let C and D be unary predicates occurring in O, and let a be a fresh individual not occurring in O. Then, D
subsumes C w.r.t. O, written O |= C  D, if LP(O)  {C(a)} |= D(a) holds.

GiDG Axioms(Gi).

Example 2. We now show how a DGLP ontology can be used to obtain the inferences
described in Section 3. Rule (r1) encodes the class of four-membered ring molecules:

HasAtom(x, yi) 

Bond(yi, yi+1)  Bond(y4, y1)

not yi = yj  MolWith4MemberedRing(x)

(r1)
?

?

?
1i4
?

?

?
Molecule(x) 

1i<j4
?

?

?
1i3

The use of the equality predicate = in the body of r1 does not require an extension to
our syntax: if = occurs only in the body and not in the head of the rules, then negation
of equality can be implemented using a built-in predicate. In addition, we represent the
class of hydrocarbons with rules (r2) and (r3).
Molecule(x)  HasAtom(x, y)  notCarbon(y)  notHydrogen(y)  NHC(x) (r2)
Molecule(x)  not NHC(x)  HydroCarbon(x)
(r3)
Cyclobutane(x)  Molecule(x)
(r4)
Finally, we state that cyclobutane is a molecule using (r4) that corresponds to the OWL
2 RL axiom Cyclobutane  Molecule. Let DG = {Gcb}, let  = , let R = {ri}4
i=1,
let F = {Cyclobutane(a)}, and let O = DG,, R, F. Figure 2(b) shows the only
stable model of LP(O) by inspection of which we see that LP(O) |= Hydrocarbon(a)
and LP(O) |= MolWith4MemberedRing(a), as expected.
?

?

?
5 Semantic Acyclicity

Deciding whether a logic program with function symbols entails a given fact is known
to be undecidable in general [4]. This problem is closely related to the problem of
reasoning with datalog programs with existentially quantified rule heads (known as
tuple-generating dependencies or tgds) [5]. For such programs, conditions such as weak
acyclicity [6] or super-weak acyclicity [16] ensure the termination of bottom-up reasoning algorithms. Roughly speaking, these conditions examine the syntactic structure of
the programs rules and check whether values created by a rules head can be propagated
so as to eventually satisfy the premise of the same rule. Due to the similarity between
tgds and our formalism, such conditions can also be applied to DGLP ontologies. These
conditions, however, may overestimate the propagation of values introduced by existential quantification and thus rule out unproblematical programs that generate only finite
structures. As we show in Example 4, this turns out to be the case for programs that
naturally arise from DGLP representations of molecular structures.

To mitigate this problem, we propose a new semantic acyclicity condition. The idea
is to detect repetitive construction of DG instances by checking the entailment of a special propositional symbol Cycle. To avoid introducing an algorithm-specific procedural
definition, our notion is declarative. The graph ordering  of a DGLP ontology O is
used to extend LP(O) with rules that derive Cycle whenever an instance of a DG G1
implies existence of an instance of a DG G2 but G1  G2.
Definition 7 (Check(O)). Let Gi = (Vi, Ei, i, Ai, mi), i  {1, 2} be two description
graphs. We define ChkPair(G1, G2) and ChkSelf(Gi) as follows:

ChkPair(G1, G2) = {G1(x1, . . . , x|V1|)  A2(xk)  Cycle | 1  k  |V1|}
ChkSelf(Gi) = {Gi(x1, . . . , x|Vi|)  Ai(xk)  Cycle | 1 < k  |Vi|}

(5)
(6)
Let DG = {Gi}1in be a set of description graphs and let  be a graph ordering on
DG. We define Check(DG,) as follows:
?

?

?
Check(DG,) =

i,j{1,...,n}, i=j, GiGj

ChkPair(Gi, Gj) 

ChkSelf(Gi)

1in

For a DGLP ontology O = DG,, R, F, we define Check(O) = Check(DG,).

Example 3. Figure 3(a) shows the structure of acetic acid molecules and the parts they
consist of. In this example, however, we focus on the description graphs for acetic acid
(GAA) and carboxyl (Gcxl), which are shown in Figures (3)(b) and (3)(c), respectively.
Since an instance of acetic acid implies the existence of an instance of a carboxyl, but
not vice versa, we define our ordering as GAA  Gcxl. Thus, for DG = {GAA, Gcxl} and
 = {(GAA, Gcxl)}, set Check(DG,) contains the following rules:

Gcxl(x1, x2, x3)  AceticAcid(xi)  Cycle
GAA(x1, x2, x3)  AceticAcid(xi)  Cycle
Gcxl(x1, x2, x3)  Carboxyl(xi)  Cycle

for 1  i  3
for 2  i  3
for 2  i  3

D. Magka, B. Motik, and I. Horrocks

We next define when a DGLP ontology is semantically acyclic. Intuitively, this condition will ensure that the evaluation of LP(O) does not generate a chain of description
graph instances violating the DG ordering.
Definition 8. A DGLP ontology O is said to be semantically acyclic if and only if
LP(O)  Check(O) |= Cycle.
Example 4. Let DG = {GAA, Gcxl} with mAA = mcxl =  , let  = {(GAA, Gcxl)},
let F = {AceticAcid(a)}, and let O = DG,,, F. By Definition 5, logic program
LP(O) contains F and the following rules (HP abbreviates HasPart):

AceticAcid(x)  GAA(x, f1(x), f2(x))
GAA(x, y, z)  AceticAcid(x)  Methyl(y)  Carboxyl(z)  HP(x, y)  HP(x, z)
Methyl(y)  Carboxyl(z)  HP(x, y)  HP(x, z)  GAA(x, y, z)
Carboxyl(x)  Gcxl(x, g1(x), g2(x))
Gcxl(x, y, z)  Carboxyl(x)  Carbonyl(y)  Hydroxyl(z)  HP(x, y)  HP(x, z)
Carbonyl(y)  Hydroxyl(z)  HP(x, y)  HP(x, z)  Gcxl(x, y, z)

Let also Check(O) = Check(DG,) as defined in Example 3. The stable model of
P = LP(O)  Check(O) can be computed using the TP operator:
P = {AceticAcid(a), GAA(a, f1(a), f2(a)), HP(a, f1(a)), HP(a, f2(a)),


Methyl(f1(a)), Carboxyl(f2(a)), Gcxl(f2(a), g1(f2(a)), g2(f2(a))), Carbonyl(g1(f2(a))),
Hydroxyl(g2(f2(a))), HP(f2(a), g1(f2(a))), HP(f2(a), g2(f2(a)))}
Since Cycle is not in the (only) stable model of P , we have P |= Cycle and O is
semantically acyclic. However, P is neither weakly [6] nor super-weakly acyclic [16].
This, we believe, justifies the importance of semantic acyclicity for our applications.

Example 5 shows how functions may trigger infinite generation of DG instances.
Example 5. Let O = {G},,{B(x)  A(x)},{A(a)} be a DGLP ontology where G
is such that Axioms(G) is as follows:

Axioms(G) = {A(x)  G(x, f(x)), G(x1, x2)  A(x1)  B(x2)  R(x1, x2)}

For Check(O) = {G(x1, x2)  A(x2)  Cycle} and P = LP(O)  Check(O), we
P = {A(a), G(a, f(a)), R(a, f(a)), B(f(a)), A(f(a)), Cycle, . . .}. Now O is not

have T
semantically acyclic because Cycle  T

P , which indicates that TP can be applied to F
in a repetitive way without terminating.
Semantic acyclicity is a sufficient, but not a necessary termination condition: bottom-up
evaluation of LP(O)  Check(O) can terminate even if O is not semantically acyclic.
Example 6. Let O = {G},,{R(x1, x2)  C(x1)  A(x2)},{A(a), C(a)} be a DGLP
ontology where G, Check(O), and P are defined as in Example 5. One can
see that {A(a), C(a), G(a, f(a)), R(a, f(a)), B(f(a)), A(f(a)), Cycle, G(f(a), f(f(a))),
B(f(f(a))), R(f(a), f(f(a)))} is the stable model of P computable by finitely many applications of the TP operator; however,O is not semantically acyclic since Cycle  T

P .
?

?

?
6 Reasoning with Negation-Free DGLP ontologies

P , T 2

P , . . . , T i

In the present section, we consider the problem of reasoning with a DGLP ontology
O = DG,, R, F where R is negation-free. Intuitively, one can simply apply the
TP operator to P = LP(O)  Check(O) and compute T 1
P and so on. By
Theorem 7, for some i we will either reach a fixpoint or derive Cycle. In the former case,
we have the stable model of O (if   T i
P ), which we can use to decide the relevant
reasoning problems; in the latter case, we know that O is not acyclic.
Theorem 7. Let O = DG,, R, F be a DGLP ontology with R negation-free, and
let P = LP(O)  Check(O). Then, Cycle  T i
By Theorem 7, checking the semantic acyclicity of O is thus decidable. If the stable
model of LP(O)  Check(O) is infinite, then Cycle is derived; however, the inverse
does not hold as shown in Example 6. Furthermore, a stable model of LP(O), if it
exists, is clearly contained in the stable model of LP(O)  Check(O), and the only
possible difference between the two stable models is for the latter to contain Cycle.

P for some i  1.

P or T i+1

P = T i

7 Reasoning with Stratified Negation-as-Failure

)  (r) for each r
) < (r) for each r

We now extend the reasoning algorithm from Section 6 to the case of DGLP ontologies O = DG,, R, F where R contains stratified negation-as-failure. We start by
recapitulating several definitions. Let P be a logic program. A stratification of P is a
mapping  : P  N such that for each rule r  P the following conditions hold:
 if B  body +
); and
P (r), then (r
 if B  body

).
P (r), then (r
A logic program P is stratifiable if there exists a stratification of P . Moreover, a partition P1, . . . , Pn of P is a stratification partition of P w.r.t.  if, for each r  P ,
we have r  P(r). The sets P1, . . . , Pn are called the strata of P . Let U
= T 1
,
P1

Pj = T i
U i
). The stable model
Pj1
of P is given by U
Example 8. Take O from Example 2 and let P = LP(O). The mapping  : P  N
such that we have (Cyclobutane(a)) = (sGcb) = (Gcb) = (rGcb ) = (r4) = 1,
(r1) = (r2) = 2, and (r3) = 3, is a stratification of P .

) for 1  j  n and i  1 and U

Pn.

  P with B  head P (r
  P with B  head P (r


Pj = T


Pj (U


Pj1
?

?

?

P0
?

?

?
Pj (U

Next we introduce the notion of a DG-stratification, which ensures that the cycle detection rules are assigned to the strata containing the relevant start rules of DGs.
Definition 9 (DG-stratification). Let O = DG,, R, F be a DGLP ontology, let
P = LP(O)  Check(O) and let P1, . . . , Pn be a stratification partition of P w.r.t.
some stratification  of P . Then,  is a DG-stratification if
 for each G1, G2  DG such that G1 = G2, G1  G2, and {sG1, sG2
have ChkPair(G1, G2)  Pi, and
 for each G  DG such that sG  Pi, we have ChkSelf(G)  Pi.

}  Pi, we
?

?

?
The following result shows that, as long as LP(O) is stratified, one can always assign
the cycle checking rules in Check(O) to the appropriate strata and thus obtain a DGstratification of LP(O)  Check(O).
Lemma 1. Let O = DG,, R, F be a DGLP ontology. If  is a stratification of
LP(O), then  can be extended to a DG-stratification 
The following theorem implies that, given a stratifiable DGLP ontology, we can decide
whether the ontology is semantically acyclic, and if so, we can compute its stable model
and thus solve all relevant reasoning problems.
Theorem 9. Let O be a DGLP ontology and P = LP(O)  Check(O). If P1, . . . , Pn
is a stratification partition of P w.r.t. a DG-stratification of P , then, for each j with
1  j  n, there exists i  1 such that Cycle  U i
Pj is finite.

of LP(O)  Check(O).
?

?

?
Pj , or U i+1

Pj = U i

Pj and U i

8 Implementation Results and Discussion

In order to test the applicability of our approach in practice, we have developed a prototypical implementation based on the XSB system.5 We used the XSB engine because it
supports function symbols, which are needed in the transformation of DGLP ontologies
to logic programs. XSB does not compute the stable model(s) of a logic program, but
implements query answering as the main reasoning task; by Definitions 8 and 6, this is
sufficient for checking acyclicity and subsumption.
To obtain test data, we extracted from the ChEBI ontology seven DGLP ontologies Oi = DG i,, R, Fi, 1  i  7. Each set of description graphs DG i contained
i  10 description graphs, each describing the structure of a particular molecule; the start
predicate of each DG is the molecules name; and the mode of the DG is . ChEBI describes about 24,000 molecules in total;6 however, due to the prototypical nature of our
implementation we can currently handle only a small subset of ChEBI. Also, since DG i
does not model DGs that imply existence of other DGs, for each Oi we set  = . Each
Oi contains the same set of rules R that models general chemical knowledge, such as
cyclobutane is a molecule and a single bond is a bond; furthermore, R contains rules
that classify molecules into five classes T1T5 shown in Figure 4. Finally, each Fi contains a fact of the form Mj(mj) for each molecule predicate Mj and fresh individual mj.
Thus, Fi instantiates all description graphs in DG i, so we can check Oi |= Mj  Tk
by equivalently checking LP(Oi) |= Tk(mj). All test ontologies are available online.7
We conducted the following tests for each Oi. First, we loaded LP(Oi) into XSB.
Second, we checked whether Oi is acyclic. Third, for each class of molecules Tk,
1  k  5 shown in Table 4, we measured the time needed to test Oi |= Mj  Tk
for each molecule Mj in Oi; each test of the latter form was performed by checking
LP(Oi) |= Tk(mj). Figure 4 summarises the loading and classification times; the times
needed to check acyclicity are not shown since they were under a second in all cases.
The experiments were performed on a desktop computer with 3.7 GB of RAM and Intel
CoreTM 2 Quad Processors running at 2.5 GHz and 64 bit Linux.

5 http://xsb.sourceforge.net/
6 http://www.ebi.ac.uk/chebi/statisticsForward.do
7 http://www.cs.ox.ac.uk/isg/people/despoina.magka/tools/ChEBIClassifier.tar.gz
?

?

?
No mol. No rules Loading time T1

T2

T3

T4
?

?

?
2.08
8.35
11.35
16.14
23.11
168.71
239.06

0.01
0.02
0.03

2.47
< 0.01 < 0.01 < 0.01 0.36
10.66
2.07
< 0.01 < 0.01 0.02
13.85
0.01 < 0.01 0.03
2.23
19.06
2.58
0.01 < 0.01 0.04
0.06
0.01
27.15
3.55
0.51 109.88 21.68 300.84
0.04
0.06
0.75 172.14 35.08 447.12

T5 Total time
0.02
0.21
0.23
0.29
0.41

T1: hydrocarbons, T2: inorganic molecules, T3: molecules with exactly two carbons,

T4: molecules with a four-membered ring, T5:molecules with a benzene ring

Fig. 4. Evaluation results

Our tests have shown all of the ontologies to be acyclic. Furthermore, all tests have
correctly classified the relevant molecules into appropriate molecule classes; for exam-
ple, we were able to conclude that acetylene has exactly two carbons, that cyclobutane has a four-membered ring, and that dinitrogen is inorganic. Please note that none
of these inferences can be derived using the approach from [20] due to the lack of
negation-as-failure, or using OWL only due to its tree-model property.

All tests were accomplished in a reasonable amount of time: no test required more
than a few minutes. Given the prototypical character of our application, we consider
these results to be encouraging and we take them as evidence of the practical feasibility
of our approach. The most time-intensive test was T4, which identified molecules containing a four-membered ring. We do not consider this surprising, given that the rule for
recognising T4 contains many atoms in the body and thus requires evaluating a complex
join. We noticed, however, that reordering the atoms in the body of the rule significantly
reduces reasoning time. Thus, trying to determine an appropriate ordering of rule atoms
via join-ordering optimisations, such as the one used for query optimisation in relational
databases, might be a useful technique in an optimised DGLP implementation.

9 Conclusions and Future Work

In this paper, we presented an expressive and decidable formalism for the representation
of objects with complex structure; additionally, our preliminary evaluation provides
evidence that our formalism is practically feasible. In our future work, we shall modify
our approach in order to avoid the explicit definition of graph ordering on behalf of the
user; furthermore, we plan to investigate whether semantic acyclicity can be combined
with other conditions (such as [2]) in order to obtain a more general acyclicity check.
Finally, we shall optimise our prototypical implementation in order to obtain a fullyscalable chemical classification system.
