Prexto: Query Rewriting

under Extensional Constraints in DL-Lite

Riccardo Rosati

Dipartimento di Ingegneria Informatica, Automatica e Gestionale Antonio Ruberti

Sapienza Universita di Roma, Italy
lastname@dis.uniroma1.it

Abstract. In this paper we present Prexto, an algorithm for computing a perfect
rewriting of unions of conjunctive queries over ontologies expressed in the description logic DL-LiteA. The main novelty of Prexto lies in the fact that it constitutes
the first technique for query rewriting over ontologies which fully exploits extensional constraints to optimize query rewriting. In addition, Prexto makes use of
functional role axioms and of concept and role disjointness axioms to optimize
the size of the rewritten query. We show that these optimizations allow Prexto to
outperform the existing query rewriting techniques for DL-Lite in practical cases.

1 Introduction

The DL-Lite family of description logics [4,2] is currently one of the most studied ontology specification languages. DL-Lite constitutes the basis of the OWL2 QL language
[1], which is part of the standard W3C OWL2 ontology specification language. The
distinguishing feature of DL-Lite is to identify ontology languages in which expressive
queries, in particular, unions of conjunctive queries (UCQs), over the ontology can be
efficiently answered. Therefore, query answering is the most studied reasoning task in
DL-Lite (see, e.g., [13,9,7,15,6,5]).

The most common approach to query answering in DL-Lite is through query rewrit-
ing. This approach consists of computing a so-called perfect rewriting of the query with
respect to a TBox: the perfect rewriting of a query q for a TBox T is a query q
that
can be evaluated on the ABox only and produces the same results as if q were evaluated
on both the TBox and the ABox. This approach is particularly interesting in DL-Lite,
can be expressed in first-order logic (i.e., SQL),
because, for every UCQ q, query q
therefore query answering can be delegated to a relational DBMS, since it can be reduced to the evaluation of an SQL query on the database storing the ABox.
?

?

?
The shortcoming of the query rewriting approach is that the size of the rewritten
query may be exponential with respect to the size of the original query. In particular,
this is true when the rewritten query is in disjunctive normal form, i.e., is an UCQ. On
the other hand, [5] shows the existence of polynomial perfect rewritings of the query in
nonrecursive datalog.

However, it turns out that the disjunctive normal form is necessary for practical applications of the query rewriting technique, since queries of more complex forms, once
translated in SQL, produce queries with nested subexpressions that, in general, cannot

E. Simperl et al. (Eds.): ESWC 2012, LNCS 7295, pp. 360374, 2012.
c Springer-Verlag Berlin Heidelberg 2012
?

?

?
be evaluated efficiently by current DBMSs. So, while in some cases resorting to more
compact and structurally more complex perfect rewritings may be convenient, in general this strategy does not solve the problem of arriving at an SQL expression that can
be effectively evaluated on the database.

In this scenario, a very interesting way to limit the size of the rewritten UCQ has been
proposed in [11]. This approach proposes the use of the so-called ABox dependencies
to optimize query rewriting in DL-LiteA. ABox dependencies are inclusions between
concepts and roles which are interpreted as integrity constraints over the ABox: in other
words, the ABox is guaranteed to satisfy such constraints. In the presence of such con-
straints, the query answering process can be optimized, since this additional knowledge
about the extensions of concepts and roles in the ABox can be exploited for optimizing
query answering. Intuitively, the presence of ABox dependencies acts in a complementary way with respect to TBox assertions: while the latter complicate query rewriting,
the former simplify it, since they state that some of the TBox assertions are already
satisfied by the ABox.

As explained in [11], ABox dependencies have a real practical interest, since they
naturally arise in many applications of ontologies, and in particular in ontology-based
data access (OBDA) applications, in which a DL ontology acts as a virtual global
schema for accessing data stored in external sources, and such sources are connected
through declarative mappings to the global ontology. It turns out that, in practical cases,
many ABox dependencies may be (automatically) derived from the mappings between
the ontology and the data sources.

In this paper, we present an approach that follows the ideas of [11]. More specifically,
we present Prexto, an algorithm for computing a perfect rewriting of a UCQ in the
description logic DL-LiteA. Prexto is based on the query rewriting algorithm Presto
[13]: with respect to the previous technique, Prexto has been designed to fully exploit
the presence of extensional constraints to optimize the size of the rewriting; moreover,
differently from Presto, it also uses concept and role disjointness assertions, as well as
role functionality assertions, to reduce the size of the rewritten query.

As already observed in [11], the way extensional constraints interact with reason-
ing, and in particular query answering, is not trivial at all: e.g., [11] defines a complex
condition for the deletion of a concept (or role) inclusion from the TBox due to the
presence of extensional constraints. In our approach, we use extensional constraints in
a very different way from [11], which uses such constraints to deactivate corresponding TBox assertions in the TBox: conversely, we are able to define significant query
minimizations even for extensional constraints for which there exists no corresponding
TBox assertions. Based on these ideas, we define the Prexto algorithm: in particular,
we restructure and extend the Presto query rewriting algorithm to fully exploit the
presence of extensional constraints.

Finally, we show that the above optimizations allow Prexto to outperform the existing query rewriting techniques for DL-Lite in practical cases. In particular, we compare
Prexto both with Presto and with the optimization presented in [11].

The paper is structured as follows. After some preliminaries, in Section 3 we introduce extensional constraints and the notion of extensional constraint Box (EBox). In
Section 4 we discuss the interaction between intensional and extensional constraints in

R. Rosati

query answering. Then, in Section 5 we present the Prexto query rewriting algorithm,
and in Section 6 we compare Prexto with existing techniques for query rewriting in
DL-LiteA. We conclude in Section 7.

2 The Description Logic DL-LiteA
A Description Logic ontology O = T ,A consists of a TBox T , representing intensional knowledge, and an ABox A representing extensional knowledge. O will denote
the alphabet of the ontology, that is, the union of the predicate symbols occurring in T
and A, whereas C will denote the alphabet of constant symbols occurring in A.

In this paper we consider ontologies specified in DL-LiteA [10], a member of the
DL-Lite family of tractable Description Logics. DL-LiteA distinguishes concepts from
value-domains, which denote sets of (data) values, and roles from attributes, which denote binary relations between objects and values. Concepts, roles, attributes, and valuedomains in this DL are formed according to the following syntax:

B  A | Q | (U )
C  B | B
Q  P | P

R  Q | Q

E  (U )
F  #D | T1 |
V  U | U



| Tn

In such rules, A, P , and U respectively denote an atomic concept (i.e., a concept name),
denotes the inverse of an
an atomic role (i.e., a role name), and an attribute name, P
atomic role, whereas B and Q are called basic concept and basic role, respectively.
Furthermore, (U ) denotes the domain of U , i.e., the set of objects that U relates to
values; (U ) denotes the range of U , i.e., the set of values that U relates to objects;
#D is the universal value-domain; T1, . . . , Tn are n pairwise disjoint unbounded value-
domains. A DL-LiteA TBox T is a finite set of assertions of the form



B  C

Q  R

E  F

U  V

(funct Q)

(funct U )

From left to right, the first four assertions respectively denote inclusions between con-
cepts, roles, value-domains, and attributes. In turn, the last two assertions denote functionality on roles and on attributes. In fact, in DL-LiteA TBoxes we further impose that
roles and attributes occurring in functionality assertions cannot be specialized (i.e., they
cannot occur in the right-hand side of inclusions). We call concept disjointness assertions the assertions of the form B1  B2, and call role disjointness assertions the
assertions of the form Q1  Q2.
A DL-LiteA ABox A is a finite set of membership (or instance) assertions of the
forms A(a), P (a, b), and U (a, v), where A, P , and U are as above, a and b belong to
O, the subset of C containing object constants, and v belongs to V , the subset of
C containing value constants, where {O, V } is a partition of C.
The semantics of a DL-LiteA ontology is given in terms of first-order logic (FOL)
= V  
interpretations I over a non-empty domain 
?

?

?
O, where 

is the domain used to interpret object constants in O, and V is the fixed domain

O) used to interpret data values. Furthermore, in DL-LiteA the Unique
(disjoint from 

such that 
?

?

?
= c

Prexto: Query Rewriting under Extensional Constraints in DL-Lite

Name Assumption (UNA) is adopted, i.e., in every interpretation I, and for every pair
c1, c2  C, if c1 = c2 then c

2 . The notion of satisfaction of inclusion, disjoint-
ness, functionality, and instance assertions in an interpretation is the usual one in DL
ontologies (we refer the reader to [10] for more details).
We denote with Mod(O) the set of models of an ontology O, i.e., the set of FOL
interpretations that satisfy all the TBox and ABox assertions in O. An ontology is inconsistent if Mod(O) =  (otherwise, O is called consistent). As usual, an ontology O
entails an assertion , denoted O |= , if  is satisfied in every I  Mod(O).
Given an ABox A, we denote by IA the DL-LiteA interpretation such that, for every
iff C(a)  A, for every role instance asseriff R(a, b)  A, and for every attribute instance assertion

II  R

concept instance assertion C(a), a
tion R(a, b), a
U (a, b), a
, b

, b
II  U

I  C

iff U (a, b)  A.

We now recall queries, in particular conjunctive queries and unions of conjunctive

queries. A conjunctive query (CQ) q is an expression of the form

q(x)  1, . . . , n

where x is a tuple of variables, and every i is an atom whose predicate is a concept
name or a role name or an attribute name, and whose arguments are either variables or
constants, such that every variable occurring in x also occurs in at least one i. The
variables occurring in x are called the distinguished variables of q, while the variables
occurring in some i but not in x are called the existential variables of q. The predicate
q is called the predicate of the query, and the number of elements of x is called the arity
of q. A CQ is a Boolean CQ if it has no distinguished variables.

A union of conjunctive queries (UCQ) Q is a set of conjunctive queries of the same
arity and having the same query predicate. A UCQ Q is a Boolean UCQ if every CQ
belonging to Q is Boolean.

Given a CQ q of arity n, we denote by q(c) the Boolean CQ obtained from q by
replacing the distinguished variables in x with the constants in the n-tuple of constants
c. As usual, given a DL-LiteA interpretation I, and a Boolean CQ q  1, . . . , n,
where y are the existential variables occurring in q, we say that I satisfies q if there
exists an assignment  for the variables y such that every atom i is satisfied by I, .
Given a Boolean UCQ Q, we say that I satisfies Q if I satisfies at least one CQ in

Q. Given a CQ q of arity n, the evaluation of q in I, denoted by eval(q,I), is the set
of n tuples of constants c such that I satisfies q(c). The evaluation of a UCQ Q in I,

qQ eval(q,I).
denoted by eval(Q,I), is the set
The set of certain answers to a UCQ Q over a DL-LiteA ontology T ,A, denoted
by cert(Q,T ,A), is the set of tuples
IMod(T ,A) eval(Q,I).
Given a UCQ Q and a TBox T , a UCQ Q
is a perfect rewriting of Q with respect to
T if, for every ABox A such that T ,A is consistent, cert(Q,T ,A) = eval(Q,IA).
The above notion of perfect rewriting immediately extends to any query language for
which the evaluation eval of queries on a first-order interpretation is defined. We remark
that many algorithms are available to compute perfect rewritings in DL-Lite logics (e.g.,
[4,10,13,9,6,5]).

In the following, for ease of exposition, we will not consider attributes in DL-LiteA
ontologies. However, all the algorithms and results that we present in this paper can be
?

?

?
R. Rosati

immediately extended to handle attributes (since attributes can essentially be treated in
a way analogous to roles).

3 Extensional Constraints

We now define the notion of EBox, which constitutes a set of extensional constraints,
i.e., constraints over the ABox. The idea of EBox has been originally introduced in [11],
under the name of ABox dependencies.

The following definitions are valid for every DL, under the assumption that the assertions are divided into extensional assertions and intensional assertions, and extensional
assertions correspond to atomic instance assertions.
Given a set of intensional assertions N and an interpretation I, we say that I satisfies
N if I satisfies every assertion in N .

Given an ABox A and an EBox E, we say that A is valid for E if IA satisfies E.

An extensional constraint box, or simply EBox, is a set of intensional assertions.
Notice that, from the syntactic viewpoint, an EBox is identical to a TBox. Therefore,
entailment of an assertion  with respect to an EBox E (denoted by E |= ) is defined
exactly in the same way as in the case of TBoxes.
Definition 1. (Admissible ABox) Given a TBox T and an EBox E, an ABox A is an
admissible ABox for T and E if A is consistent with T and A is valid for E. We denote
with ADM(T ,E) the set of ABoxes A that are admissible for T and E.
Informally, an EBox acts as a set of integrity constraints over the ABox. Differently
from other recent approaches that have proposed various forms of integrity constraints
for DL ontologies (e.g., [8,14]), an EBox constrains the ABox while totally discarding
the TBox, since the notion of validity with respect to an EBox only considers the ABox.
We are now ready to define the notion of perfect rewriting in the presence of both a
TBox and an EBox.
Definition 2. (Perfect rewriting in the presence of an EBox) Given a TBox T , an EBox
E, and a UCQ Q, a FOL query  is a perfect rewriting of Q with respect to T ,E if,
for every ABox A  ADM(T ,E), T ,A |= Q iff IA |= .
The above definition establishes a natural notion of perfect rewriting in the presence
of an EBox E. Since E constrains the admissible ABoxes, the more selective is E (for
the same TBox T ), the more restricted the set ADM(T ,E) is. If for instance, E,E
are
two EBoxes such that E  E
, we immediately get from the above definitions that
ADM(T ,E)  ADM(T ,E
). Now, let Q be a UCQ, let  be a perfect rewriting of Q
with respect to T ,E and let 
be a perfect rewriting of Q with respect to T ,E: 

will have to satisfy the condition T ,A |= Q iff IA |=  for more ABoxes A than
?

?

?
. Therefore,
. Consequently,  will have to be a more complex query than 
query 
larger EBoxes in principle allow for obtaining simpler perfect rewritings.

4 Extensional Constraints and Query Rewriting

As already explained, the goal of this paper is to use extensional constraints to optimize
query rewriting in DL-LiteA. An intuitive explanation of how extensional constraints allow for simplifying query rewriting can be given by the following very simple example.
?

?

?
Suppose we are given a TBox {Student  Person}, an empty EBox E0, and an EBox
E1 = {Student  Person}. Now, given a query q(x)  Person(x), a perfect rewriting
of this query with respect to T ,E0 is

q(x)  Person(x)
q(x)  Student(x)

while a perfect rewriting of query q with respect to T ,E1 is the query q itself. Namely,
under the EBox E1 we can ignore the TBox concept inclusion Student  Person, since
it is already satisfied by the ABox.



However, as already explained in [11], we can not always ignore TBox assertions
that also appear in the EBox (and are thus already satisfied by the ABox). For instance,
let q be the query q  C(x). If the TBox T contains the assertions R  C and
D  R
and the EBox E contains the assertion R  C, we cannot ignore this last
inclusion when computing a perfect rewriting of q (or when answering query q). In fact,
suppose the ABox is {D(a)}: then A  ADM(T ,E) and query q is entailed by T ,A.
But actually q is not entailed by T 

From the query rewriting viewpoint, a perfect rewriting of q with respect to T is

,A where T 

= T  E.

q  C(x)
q  R(x, y)
q  D(y)
while a perfect rewriting of q with respect to T 
is
q  C(x)

And of course, the ABox A shows that this last query is not a perfect rewriting of q
with respect to T ,E. Therefore, also when computing a perfect rewriting, we cannot
simply ignore the inclusions of the TBox that are already satisfied by the ABox (i.e.,
that belong to the EBox).

The example above shows that we need to understand under which conditions we are

allowed to use extensional constraints to optimize query rewriting.

5 Prexto

In this section we present the algorithm Prexto (Perfect Rewriting under EXTensional
cOnstraints). Prexto makes use of the algorithm Presto, originally defined in [13],
which computes a nonrecursive datalog program constituting a perfect rewriting of
a UCQ Q with respect to a DL-LiteA TBox T . The algorithm Presto is reported in
Figure 1. We refer the reader to [13] for a detailed explanation of the algorithm. For
our purposes, it suffices to remind that the program returned by Presto uses auxiliary
datalog predicates, called ontology-annotated (OA) predicates, to represent every basic
concept and basic role that is involved in the query rewriting. E.g., the basic concept

R. Rosati
?

?

?
Algorithm Presto(Q,T )
Input: UCQ Q, DL-LiteR TBox T
Output: nr-datalog query Q
begin

= Rename(Q);
?

?

?
= DeleteUnboundVars(Q
?

?

?
= DeleteRedundantAtoms(Q
?

?

?
= Split(Q

repeat
if there exist r  Q
such that Eliminable(x, r,T ) = true
and x has not already been eliminated from r

and ej-var x in r

,T );

);

);
?

?

?
then begin
?

?

?
= EliminateEJVar(r, x,T );

= DeleteUnboundVars(Q
);
= DeleteRedundantAtoms(Q
= Q

  Split(Q
?

?

?
)
?

?

?
,T );
?

?

?
end
?

?

?
has reached a fixpoint;

until Q
for each OA-predicate pn
do Q

  DefineAtomView(pn

 occurring in Q
,T )

= Q
?

?

?
end

Fig. 1. The original Presto algorithm [13]

B is represented by the OA-predicate p1
OA-predicate p2

R (the superscript represents the arity of the predicate).1

B, while the basic role R is represented by the

In the following, we modify the algorithm Presto. In particular, we make the fol-

lowing changes:

1. the final for each cycle of the algorithm (cf. Figure 1) is not executed: i.e., the rules

defining the OA-predicates are not added to the returned program;

2. the algorithm DeleteRedundantAtoms is modified to take into account the
presence of disjointness assertions and role functionality assertions in the
TBox. More precisely, the following simplification rules are added to algorithm
,T ) (in which we denote basic concepts by B, C,
DeleteRedundantAtoms(Q
basic roles by R, S, and datalog rules by the symbol r):
S(t1, t2) occur in r and T |= R  S, then eliminate r from
(a) if p2
R(t1, t2) and p2
;
S(t2, t1) occur in r and T |= R  S
(b) if p2

R(t1, t2) and p2

, then eliminate r


?

?

?
B(t) and p1
R(t1, t2) and p1

C (t) occur in r and T |= B  C, then eliminate r from Q

C (t1) occur in r and T |= R  C, then eliminate r from

;
?

?

?
from Q

;

(c) if p1
(d) if p2
;
?

?

?
1 Actually, to handle Boolean subqueries, also 0-ary OA-predicates (i.e., predicates with no

arguments) are defined: we refer the reader to [13] for more details.
?

?

?
  C, then eliminate r

(e) if p2

R(t1, t2) and p1
?

?

?
from Q

;

C (t2) occur in r and T |= R
?

?

?
(f) if p0
(g) if p1
(h) if p2
(i) if p2

 and p0
B(t) and p0
R(t1, t2) and p0
R(t1, t2) and p2

 occur in r and T |= 0  0, then eliminate r from Q

;
 occur in r and T |= B0  0, then eliminate r from Q

2) (with t2 = t
?

?

?
2 are two different constants, then eliminate r from Q

 occur in r and T |= R0  0, then eliminate r from Q

;
2) occur in r and (funct R)  T , then,

R(t1, t
if t2 and t
; otherwise,
replace r with the rule (r), where  is the substitution which poses t2 equal

to t
2;
)  T ,
(j) if p2
R(t2, t1) and p2
then, if t2 and t
; other-
wise, replace r with the rule (r), where  is the substitution which poses t2
equal to t
?

?

?
2) occur in r and (funct R

2 are two different constants, then eliminate r from Q

2, t1) (with t2 = t
?

?

?
R(t


?

?

?
;
?

?

?
2.

Example 1. Let us
the new transformations added to
DeleteRedundantAtoms through two examples. First, suppose T = {B 
B

show the effect of
?

?

?
, (funct R)} and suppose r is the rule
B(y), p2

q(x)  p1

R(x, y), p2

R(x, z), p1

B (z)

Then, the above case (i) of algorithm DeleteRedundantAtoms can be applied, which
transforms r into the rule

q(x)  p1

B(y), p2

R(x, y), p1

B (y)

Now, the above case (c) of algorithm DeleteRedundantAtoms can be applied, hence
this rule is deleted from the program. Intuitively, this is due to the fact that this rule
, which is impossible
looks for elements belonging both to concept B and to concept B
is entailed by the TBox T . Therefore, it is
because the disjointness assertion B  B
correct to delete the rule from the program.
?

?

?
From now on, when we speak about Presto we refer to the above modified version
of the algorithm, and when we speak about DeleteRedundantAtoms we refer to the
above modified version which takes into account disjointness and functionality asser-
tions.

The Prexto algorithm is defined in Figure 2. The algorithm is constituted of the

following four steps:
?

?

?
1. the nonrecursive datalog program P is computed by executing the Presto algo-
rithm. This program P is not a perfect rewriting of Q yet, since the definition of the
intermediate OA-predicates is missing;

2. the program P

is then constructed (by the three for each cycles of the program).
This program contain rules defining the intermediate OA-predicates, i.e., the concept and role assertions used in the program P . To compute such rules, the algorithm makes use of the procedure MinimizeViews, reported in Figure 3. This procedure takes as input a basic concept (respectively, a basic role) B and computes a

of the set  of the subsumed basic concepts (respectively, subminimal subset 
sumed basic roles) of B which extensionally cover the set , as explained below.

R. Rosati

Algorithm Prexto(Q,T ,E )
Input: UCQ Q, DL-LiteA TBox T , DL-LiteA EBox E
Output: UCQ Q
begin
?

?

?
P = Presto(Q,T );
= ;
?

?

?
for each OA-predicate P 2
 = MinimizeViews(R,E ,T );
?

?

?
= P

R occurring in P do

  {p2
 {p2

B(x, y)  S(x, y) | S is a role name and S  }
  };
B(x, y)  S(y, x) | S is a role name and S

for each OA-predicate P 1
 = MinimizeViews(B,E ,T );
?

?

?
= P

B occurring in P do

  {p1
 {p1

B(x)  C(x) | C is a concept name and C  }
B(x)  R(x, y) | R  }  {p1

B(x)  R(y, x) | R

  };

N occurring in P do

for each OA-predicate P 0
 = MinimizeViews(N 0,E ,T );
?

?

?
  {p0
N  C(x) | C is a concept name and C 0  }
= P
N  R(x, y) | R is a role name and R0  };
 {p0
= P  P

;

= Unfold(P
= DeleteRedundantAtoms(Q

,E );

);
?

?

?
return Q
?

?

?
end

Fig. 2. The Prexto algorithm
3. then, the overall nonrecursive datalog program P  P
?

?

?
is unfolded, i.e., turned into
. This is realized by the algorithm Unfold which corresponds to the usual

a UCQ Q
unfolding of a nonrecursive program;
?

?

?
4. finally,

the UCQ Q

algorithm
the
DeleteRedundantAtoms which takes as input the UCQ Q
and the EBox
E (notice that, conversely, the first execution of DeleteRedundantAtoms within
the Presto algorithm uses the TBox T as input).

simplified

executing

by

is
?

?

?
Notice that the bottleneck of the whole process is the above step 3, since the number
of conjunctive queries generated by the unfolding may be exponential with respect to
the length of the initial query Q (in particular, it may be exponential with respect to the
maximum number of atoms in a conjunctive query of Q). As shown by the following ex-
ample, the usage of extensional constraints done at step 2 through the MinimizeViews
algorithm is crucial to handle the combinatorial explosion of the unfolding.
Example 2. Let T be the following DL-LiteA TBox:

Company  givesHighSalaryTo

givesHighSalaryTo
  Manager
Manager  Employee
Employee  HasJob
receivesGrantFrom  StudentWithGrant
StudentWithGrant  FulltimeStudent

FulltimeStudent  Unemployed
FulltimeStudent  Student
isBestFriendOf  knows
(funct isBestFriendOf)

(funct isBestFriendOf
)
HasJob  Unemployed
?

?

?
Algorithm MinimizeViews(B,E ,T )
Input: basic concept (or basic role, or 0-ary predicate) B,

DL-LiteA EBox E, DL-LiteA TBox T
?

?

?
Output: set of basic concepts (or basic roles, or 0-ary predicates) 
begin

  B};

 = {B
= ;


for each B

 | T |= B
   do
if there exists B
  {B

then 
= 
=   
?

?

?
;

while there exist B, B
such that B = B
};

do 
= 

return 

  {B

   such that E |= B

};
  

and E |= B  B
?

?

?
  B
?

?

?
and E |= B

  B
?

?

?
and E |= B

  B

end

Fig. 3. The MinimizeViews algorithm

Moreover, let E1, . . . , E4 be the following concept inclusions:
E1 = FulltimeStudent  StudentWithGrant
E2 = receivesGrantFrom  StudentWithGrant
E3 = HasJob  Employee
E4 = Manager  Employee

and let E = {E1, E2, E3, E4}.

Finally, let q1 be the following query:

q1(x)  Student(x), knows(x, y), HasJob(y)

Let us first consider an empty EBox. In this case, during the execution of
Prexto(q1,T ,) the algorithm MinimizeViews simply computes the subsumed sets
of Student, knows, HasJob, which are, respectively:

MinimizeViews(Student,,T ) =
MinimizeViews(knows,,T ) =
MinimizeViews(HasJob,,T ) =

{Student, FulltimeStudent, StudentWithGrant, receivesGrantFrom}
}
{knows, knows

{HasJob, Employee, Manager, givesHighSalaryTo

, isBestFriendOf, isBestFriendOf

}

Since every such set is constituted of four predicates, the UCQ returned by the unfolding
step in Prexto(q1,T ,E) contains 64 CQs. This is also the size of the final UCQ, since
in this case no optimizations are computed by the algorithm DeleteRedundantAtoms,
because both the disjointness assertion and the role functionality assertions of T have
no impact on the rewriting of query q1.

R. Rosati

Conversely, let us consider the EBox E: during the execution of Prexto(q1,T ,E),

we obtain the following sets from the execution of the algorithm MinimizeViews::

MinimizeViews(Student,E,T ) =
{Student, StudentWithGrant}
MinimizeViews(knows,E,T ) =
{knows, knows

MinimizeViews(HasJob,E,T ) =
{Employee, givesHighSalaryTo

}

, isBestFriendOf, isBestFriendOf

}

Thus, the algorithm MinimizeViews returns only two predicates for Student and only
two predicates for HasJob. Therefore, the final unfolded UCQ is constituted of 16 CQs
(since, as above explained, the final call to DeleteRedundantAtoms does not produce
any optimization).

We now focus on the proof of correctness of Prexto, which is based on the known results about the Presto algorithm. Indeed, to prove correctness of Prexto, essentially we
have to show that the modifications done with respect to the Presto algorithm preserve
correctness.

In particular, it is possible to prove the following properties:

1. The additional simplification rules added to the DeleteRedundantAtoms algorithm preserve completeness of the algorithm. More specifically, it can be easily
shown that, in every execution of the algorithm DeleteRedundantAtoms within
Presto, every additional rule transformation either produces a rule that is equivalent (with respect to the TBox T ) to the initial rule, or deletes a rule which is
actually empty, i.e., which does not contribute to any nonempty conjunctive query
in the final UCQ.

2. The optimization realized by the MinimizeViews algorithm is correct. More pre-

cisely, the following property can be easily shown:
Lemma 1. Let T be a TBox, let E be an EBox, let B be a basic concept and let 
be the set of basic concepts subsumed by B in T and let 

be the set returned by
MinimizeViews(B,E,T ). Then, the following property holds:
?

?

?
B
?

?

?
B

IA =

An analogous property can be shown when B is a basic role (or a 0-ary predicate).
From the above lemma, it easily follows that step 2 of Prexto is correct.
3. In step 4 of Prexto, the final simplification of conjunctive queries realized by the
execution of the algorithm DeleteRedundantAtoms over the EBox E is correct.
This immediately follows from the correctness of DeleteRedundantAtoms shown
in the above point 1 and from the fact that the final UCQ is executed on the ABox,
i.e., it is evaluated on the interpretation IA.

Therefore, from the above properties and the correctness of the original Presto algo-
rithm, we are able to show the correctness of Prexto.
?

?

?
Theorem 1. Let T be a DL-LiteA TBox, let E be a DL-LiteA EBox, let Q be a UCQ
be the UCQ returned by Prexto(Q,T ,E). Then, for every ABox A such that
and let Q
A  ADM(T ,E), cert (Q,T ,A) = eval(Q
?

?

?
,IA).

Finally, it is easy to verify the following property, which states that the computational
cost of Prexto is no worse than all known query rewriting techniques for DL-LiteA
which compute UCQs.
Theorem 2. Prexto(Q,T ,E) runs in polynomial time with respect to the size of T E,
and in exponential time with respect to the maximum number of atoms in a conjunctive
query in the UCQ Q.

6 Comparison

We now compare the optimizations introduced by Prexto with the current techniques
for query rewriting in DL-Lite.

In particular, we consider the simple DL-LiteA ontology of Example 2 and compare
the size of the UCQ rewritings generated by the current techniques (in particular, Presto
and the rewriting based on the TBox minimization technique TBox-min shown in [11])
with the size of the UCQ generated by Prexto. To single out the impact of the different
optimizations introduced by Presto, we present three different execution modalities
for Prexto: without considering the EBox (we call this modality Prexto-noEBox); (ii)
without considering disjointness axioms and role functionality axioms in the TBox (we
call this modality Prexto-noDisj); (iii) and considering all axioms both in the TBox and
in the EBox (we call this modality Prexto-full). Moreover, we will consider different
EBoxes of increasing size, to better illustrate the impact of the EBox on the size of the
rewriting.
Let T be the DL-LiteA ontology of Example 2 and let E1, . . . ,E4 be the following

EBoxes:

E1 = {E1}
E2 = {E1, E2}
E3 = {E1, E2, E3}
E4 = {E1, E2, E3, E4}

where E1, . . . , E4 are the concept inclusion assertions defined in Example 2. Finally,
let q0, q1, q2, q3 be the following simple queries:

q0(x)  Student(x)
q1(x)  Student(x), knows(x, y), HasJob(y)
q2(x)  Student(x), knows(x, y), HasJob(y), knows(x, z), Unemployed(z)
q3(x)  Student(x), knows(x, y), HasJob(y), knows(x, z), Unemployed(z),

knows(x, w), Student(w)

The table reported in Figure 4 shows the impact on rewriting (and answering) queries
q0, q1, q2 and q3 of: (i) the disjointness axiom and the functional role axioms in T ; (ii)
the EBoxes E1, . . . ,E4. In the table, we denote by Presto+unfolding the UCQ obtained
by unfolding the nonrecursive datalog program returned by the Presto algorithm, and

R. Rosati

query

algorithm

E =  E = E1 E = E2 E = E3 E = E4

TBox-min

TBox-min

Prexto-noEBox
Prexto-noDisj

Prexto-full

Prexto-noEBox
Prexto-noDisj

Prexto-full
?

?

?
q0 Presto+unfolding
?

?

?
q0
?

?

?
q0
?

?

?
q0
?

?

?
q0
q1 Presto+unfolding
?

?

?
q1
?

?

?
q1
?

?

?
q1
?

?

?
q1
q2 Presto+unfolding 1024
?

?

?
q2
?

?

?
q2
?

?

?
q2
?

?

?
q2
q3 Presto+unfolding 16384 16384 16384 16384 16384
16384 16384 16384 16384 16384
q3
Prexto-noEBox 12672 12672 12672 12672 12672
q3
Prexto-noDisj

q3

q3
?

?

?
16384 6912
12672 5660
?

?

?
Prexto-full

TBox-min

Prexto-noEBox
Prexto-noDisj

Prexto-full

TBox-min

Fig. 4. Comparison of query rewriting techniques on T , E and queries q0, q1, q2, q3

denote by TBox-min the execution of Presto+unfolding which takes as input the TBox
minimized by the technique presented in [11] using the extensional inclusions in the
EBox. These two rows can be considered as representative of the state of the art in
query rewriting in DL-Lite (with and without extensional constraints): indeed, due to
the simple structure of the TBox and the queries, every existing UCQ query rewriting
technique for plain DL-Lite ontologies (i.e., ontologies without EBoxes) would generate
UCQs of size analogous to Presto+unfolding (of course, we are not considering the
approaches where the ABox is preprocessed, in which of course much more compact
query rewritings can be defined [7,11]).

The third column of the table displays the results when the empty EBox was con-
sidered, while the fourth, fifth, sixth, and seventh column respectively report the results
when the EBox E1, E2, E3, E4, was considered. The numbers in these columns represent the size of the UCQ generated when rewriting the query with respect to the TBox
T and the EBox E: more precisely, this number is the number of CQs which constitute
the generated UCQ. We refer to Example 2, for an explanation of the results obtained
in the case of query q1.

The results of Figure 4 clearly show that even a very small number of EBox axioms
may have a dramatic impact on the size of the rewritten UCQ, and that this is already
the case for relatively short queries (like query q2): this behavior is even more apparent
for longer queries like q3. In particular, notice that, even when only two extensional inclusions are considered (case E = E2), the minimization of the UCQ is already very sig-
nificant. Moreover, for the queries under examination, extensional inclusions are more
?

?

?
effective than disjointness axioms and role functionalily axioms on the minimization of
the rewriting size.

The results also show that the technique presented in [11] for exploiting extensional
inclusions does not produce any effect in this case. This is due to the fact that the
extensional inclusions considered in our experiment do not produce any minimization
of the TBox according to the condition expressed in [11]. Conversely, the technique for
exploiting extensional constraints of Prexto is very effective. For instance, notice that
this technique is able to use extensional constraints (like E2 and E3) which have no
counterpart in the TBox, in the sense that such concept inclusions are not entailed by
the TBox T .

Finally, we remark that the above simple example shows a situation which is actually
not favourable for the algorithm, since there are very few extensional constraints and
short (or even very short) queries: nevertheless, the experimental results show that, even
in this setting, our algorithm is able to produce very significant optimizations. Indeed,
the ideas which led to the Prexto algorithm came out of a large OBDA project that our
research group is currently developing with an Italian Ministry. In this project, several
relevant user queries could not be executed by our ontology reasoner (Quonto [3]) due
to the very large size of the rewritings produced. For such queries, the minimization
of the rewriting produced by the usage of the Prexto optimizations is actually much
more dramatic than the examples reported in the paper, because the queries are more
complex (at least ten atoms) and the number of extensional constraints is larger than in
the example. As a consequence, Prexto was able to lower the number of conjunctive
queries generated, and thus the total query evaluation time, typically by two to three
orders of magnitude: e.g., for one query, the total evaluation time passed from more
than 11 hours to 42 seconds; other seven queries, whose rewritings could not even be
computed or executed because of memory overflow of either the query rewriter or the
DBMS query parser, could be executed in few minutes, or even in a few seconds, after
the optimization.

7 Conclusions

In this paper we have presented a query rewriting technique for fully exploiting the presence of extensional constraints in a DL-LiteA ontology. Our technique clearly proves
that extensional constraints may produce a dramatic improvement of query rewriting,
and consequently of query answering over DL-LiteA ontologies.

We remark that it is immediate to extend Prexto to OWL2 QL: the main features of
OWL2 QL that are not covered by DL-LiteA mainly consist of the presence of additional
role assertions (symmetric/asymmetric/reflexive/irreflexive role assertions). These aspects can be easily dealt with by Prexto through a simple extension of the algorithm.

We believe that the present approach can be extended in several directions. First, it
would be extremely interesting to generalize the Prexto technique to ontology-based
data access (OBDA), where the ABox is only virtually specified through declarative
mappings over external data sources: as already mentioned in the introduction, in this
scenario extensional constraints would be a very natural notion, since they could be
automatically derived from the mapping specification. Then, it would be very interesting to extend the usage of extensional constraints beyond DL-LiteA ontologies: in this

R. Rosati

respect, a central question is whether existing query rewriting techniques for other description logics (e.g., [9,12]) can be extended with optimizations analogous to the ones
of Prexto. Finally, we plan to fully implement our algorithm within the Quonto/Mastro
system [3] for DL-LiteA ontology management.

Acknowledgments. This research has been partially supported by the ICT Collaborative Project ACSI (Artifact-Centric Service Interoperation), funded by the EU under
FP7 ICT Call 5, 2009.1.2, grant agreement n. FP7-257593.
