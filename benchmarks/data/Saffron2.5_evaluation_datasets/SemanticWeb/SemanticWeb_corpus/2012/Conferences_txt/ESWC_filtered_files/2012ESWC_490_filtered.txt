Enhancing OLAP Analysis with Web Cubes

Lorena Etcheverry1 and Alejandro A. Vaisman2

1 Instituto de Computaci on, Universidad de la Rep ublica, Uruguay

lorenae@fing.edu.uy

2 Universit e Libre de Bruxelles

avaisman@ulb.ac.be

Abstract. Traditional OLAP tools have proven to be successful
in
analyzing large sets of enterprise data. For todays business dynamics,
sometimes these highly curated data is not enough. External data (par-
ticularly web data), may be useful to enhance local analysis. In this paper
we discuss the extraction of multidimensional data from web sources, and
their representation in RDFS. We introduce Open Cubes, an RDFS vocabulary for the specification and publication of multidimensional cubes
on the Semantic Web, and show how classical OLAP operations can be
implemented over Open Cubes using SPARQL 1.1, without the need of
mapping the multidimensional information to the local database (the
usual approach to multidimensional analysis of Semantic Web data). We
show that our approach is plausible for the data sizes that can usually
be retrieved to enhance local data repositories.

Introduction

Business intelligence (BI) comprises a collection of techniques used for extracting and analyzing business data, to support decision-making. Decision-support
systems (DSS) include a broad spectrum of analysis capabilities, from simple reports to sophisticated analytics. These applications include On-Line Analytical
Processing (OLAP) [9], a set of tools and algorithms for querying large multidimensional databases usually called data warehouses (DW). Data in a DW
come from heterogeneous and distributed operational sources, and go through
a process, denoted ETL (standing for Extraction, Transformation, and Load-
ing). In OLAP, data are usually perceived as a cube. Each cell in this data cube
contains a measure or set of measures representing facts and contextual information (the latter called dimensions). For some data-analysis tasks (e.g., worldwide
price evolution of a certain product), the data contained the DSS do not suf-
fice. External data sources (like the web) can provide useful multidimensional
information, although usually too volatile to be permanently stored in the DW.
We now present, through a use case, the research problems that appear in this
scenario, and our approach for a solution to some of them.

1.1 Motivation and Problem Statement

A new electronics retail store is running a promotional campaign to improve
sales on an specific segment of the digital cameras market: amateur digital SLR

E. Simperl et al. (Eds.): ESWC 2012, LNCS 7295, pp. 469483, 2012.
c Springer-Verlag Berlin Heidelberg 2012

L. Etcheverry and A.A. Vaisman

Product

Locat. profit #sales unitPrice unitCost profit #sales unitPrice unitCost

November 2011

December 2011

Time

Q3-2011

Canon T3i Kit 18-55

T3 Kit 18-55

Nikon D3100 Kit 18-55
?

?

?
NY 1044

Body only NJ
?

?

?
WA 1020
?

?

?
Kit 55-200 NY

Body only CA
?

?

?
Body only CA
?

?

?
D5100 Kit 18-55

Fig. 1. A Sales Data Cube

cameras. The company sales products from several manufacturers and wants
to find out candidates for best deals kind of offer. In todays business, web
information is crucial for this. Price policies must take into account current
deals found on the Internet (e.g., number of available offers, shipping policies,
expected delivery time), as well as user opinions and product features. Jane, the
data analyst of the company manually searches the web, querying different sites,
and building spreadsheets with the collected data. Then she analizes local data
at the DSS, together with data from web sources. This procedure is not only
inefficient but also imprecise. Jane needs flexible and intelligent tools to get an
idea of what is being offered on the web. We propose to make Janes work more
productive, by semi-automatically extracting multidimensional information from
web data sources. This process produces what we denote web cubes, which
can then be related to local OLAP cubes through a set of operators that we
study in this paper. A key assumption is that web cubes only add knowledge for
decision-making, and are not aimed at replacing precise information obtained
from traditional DSS. Thus, we do not need these data to be complete, not
even perfectly sound: Jane only needs a few good answers [17] to enhance
her analysis, and our approach takes this into account. In a nutshell, web cubes
are data cubes (obtained from web data sources) expressed using an RDF [10]
vocabulary. We show through an use case how web cubes could be used to
enhance existing DSS.

The case starts with Jane using her local DSS to analyze sales of digital
cameras. From local cubes she produces a multidimensional report (Figure 1),
actually a data cube with dimensions Product, Geography, and Time, and measures profit, #sales, unitPrice, and unitCost. From the report, Jane identifies that
the sales of Canon T3 and T3i cameras have dropped in December. She conjectures that probably these products are being offered on the web at better prices,
thus she decides to build a web cube to retrieve information about offers of these
camera models. To start the process of building web cubes, Jane specifies her
information requirements, which in this particular case are: price, delivery time
?

?

?
and shipping costs of new Canon T3 and T3i DSLR cameras. She will try to obtain sales facts with these three measures, if possible with the same dimensions
than the local cube. We assume that there is a catalogue of web data sources,
with metadata that allows deciding which sources are going to be queried, the
query mechanisms available for each source, and the format of the results.

Web data are available in many formats. Each one of these formats can be
accessed using different mechanisms. For example RDF data can be published via
SPARQL [16] endpoints, or extracted from HTML pages that publish RDFa [1]
(among other formats), while XML data may be the result of querying RESTful
web services (also known as web APIs). Tabular data may be extracted from
HTML tables or retrieved from data sharing platforms, such as Google Fusion
Tables1. In this paper we do not deal with the problem of retrieving web cubes.
Well-known Information Retrieval and Natural Language Processing techniques
can be used for this. For integrating the information retrieved from the data
sources, and for representing the web cubes that are built after data extraction,
we propose to use RDF as the data model. For the latter task, we devised a
vocabulary called Open Cubes that we present in Section 3. It is highly possible
that not all of Janes requirements can be satisfied. For example, data could
be obtained at an aggregation level different from the requested one. Or may
be incomplete. We do not deal with these issues in this paper. Continuing with
our use case, let us suppose that from www.overstock.com, Jane obtaines the
following following RDF triples.

@ p r e f i x d c : <h t t p : // p u r l . o r g / dc>
@ p r e f i x r d f :<h t t p : //www. w3 . o r g /1999/02/22 r d fs y n t a xn s#>
@ p r e f i x s c h e m a : <h t t p : // s chem a . o r g />

<h t t p : //www. o v e r s t o c k . com / . . . / 5 7 0 0 6 1 0 / p r o d u c t . htm l> d c : t i t l e
  Canon EOS R e b e l T 3i 18 D55mm I S I I D i g i t a l SLR Camera K i t O v e r s t o c k  
: n o d e 1 6 b t 8 f d b 2 x 1 r d f : t y p e s c h e m a : P r o d u c t
: n o d e 1 6 b t 8 f d b 2 x 1 s chem a: nam e
  Canon EOS R e b e l T 3i 18 D55mm I S I I D i g i t a l SLR Camera K i t   .
: n o d e 1 6 b t 8 f d b 2 x 1 s c h e m a : o f f e r s
: n o d e 1 6 b t 8 f d b 2 x 2 r d f : t y p e s c h e m a : O f f e r .
: n o d e 1 6 b t 8 f d b 2 x 2 s c h e m a : p r i c e

: n o d e 1 6 b t 8 f d b 2 x 2 .

.

  USD 8 5 0 . 8 2  

.

.

From these triples, a web cube is built (represented using the Open Cube vocab-
ulary). Figure 2 shows this cube, in report format. Note that in this example,
the new cube has the same dimensions than the cube in Figure 1, but different
measures. Also notice that we have maximized the number of returned results,
leading to the presence of null values (denoted by - in Figure 2), which should
be replaced by appropriate values (e.g., unknown state) to guarantee the correctness of the results when performing OLAP operations. Jane now wants to
compare the price of each product in the local cube, with the price for the same
product in the web cube. This requires using OLAP operators like roll-up, slice,
dice, or drill-across, over web Cubes. Jane then realizes that in the Geography dimension of the web cube, data are presented per city instead of per state (which
is the case in the local cube). Thus, she needs to transform the web cube to the
same level of detail as the local cube, taking both cubes to the country level,
using a roll-up operation in the Geography dimension. After this, both cubes can
be merged, and Jane can compare the prices in the local cube with those found

1 http://www.google.com/fusiontables/Home/

L. Etcheverry and A.A. Vaisman

Product

SLR Camera Canon T3i Kit 18-55 USA -

Geography
-

NY Amityville

-
Body only USA -

-
-

T3 Kit 18-55 USA NJ Somerset

-

-

Time

Q3-2011

December 2011

unitPrice deliveryTime shippingCost

850.82
799.95
760.00
672.99
466.82
476.99

-

-
-

19.95
?

?

?
-

(1)
(2)
(3)
(4)
(5)
(6)

Fig. 2. A web cube in report format

Time

Q3-2011

December 2011

Product

Geography profit #sales unitPrice unitCost deliveryTime shippingCost

Canon T3i Kit 18-55

672.5

Body only

395.0

-

T3 Kit 18-55

520.0

-

Nikon D3100 Kit 18-55

Kit 55-200
Body only
D5100 Kit 18-55
Body only
?

?

?
-

500.0

290.0
?

?

?
-

-

-
?

?

?
872.5
803.6
843.3
673.0
470.0
471.9
609.3

502.5
?

?

?
783.0

765.0

400.0

547.0

450.0
?

?

?
-

7.5

-
-
-

7.0

-
-
-
-
-

-

19.95

-

0.0

-

0.0

-
-
-
-
-

Fig. 3. Results of merging local and web cubes

on the Internet (grey rows). Figure 3 shows the result (Section 4 shows how web
cubes can be mapped to the multidimensional model of the local cube).
Contributions. The following research questions arise in the scenario described
above: Is it possible to use web data to enhance local OLAP analysis, without
the burden of incorporating data sources and data requirements into the existent
DSS life-cycle? What definitions, data-models, and query mechanisms are needed
to accomplish these tasks? Our main goal is to start giving answers to the some
of these questions. Central to this goal is the representation and querying of
multidimensional data over the Semantic Web. Therefore, our main contributions
are: (a) We introduce Open Cubes, a vocabulary specified using RDFS that
allows representing the schema and instances of OLAP cubes, which extends
and makes workable other similar proposals, since it is not only devised for data
publishing, but for operating over RDF representation of multidimensional data
as well (Section 3); (b) We show how typical OLAP operators can be expressed
in SPARQL 1.1 using the vocabulary introduced in (a). We give an algorithm for
generating SPARQL 1.1. CONSTRUCT queries for the OLAP operators, and show
that implementing these operators is feasible. The basic assumption here is that
web cubes are composed of a limited number of instances (triples) of interest
(Section 4); (c) We sketch a mapping from a web cube to the multidimensional
(in what follows, MD) model, in order to be able to operate with the local cubes.
We do this through an example that shows how web cubes can be exported to
the local system, using the Mondrian OLAP server2 (Section 4).

2 http://mondrian.pentaho.com/documentation/schema.php
?

?

?
2 Preliminaries

RDF and SPARQL. The Resource Description Framework (RDF) [10] is a data
model for expressing assertions over resources identified by an universal resource identifier (URI). Assertions are expressed as triples subject - predicate
- object, where subject are always resources, and predicate and object could be
resources or strings. Blank nodes are used to represent anonymous resources or
resources without an URI, typically with a structural function, e.g., to group
a set of statements. Data values in RDF are called literals and can only be
objects. A set of RDF triples or RDF dataset can be seen as a directed graph
where subject and object are nodes, and predicates are arcs. Many formats for
RDF serialization exist. The examples presented in this paper use Turtle [2].
RDF Schema (RDFS) [3] is a particular RDF vocabulary where a set of reserved words can be used to describe properties like attributes of resources, and
to represent relationships between resources. Some of these reserved words are
rdfs:range [range], rdfs:domain [dom], rdf:type [type], rdfs:subClassOf [sc],
and rdfs:subPropertyOf [sp].

SPARQL is the W3C standard query language for RDF [16]. The query evaluation mechanism of SPARQL is based on subgraph matching: RDF triples
are interpreted as nodes and edges of directed graphs, and the query graph is
matched to the data graph, instantiating the variables in the query graph defini-
tion. The selection criteria is expressed as a graph pattern in the WHERE clause,
consisting basically in a set of triple patterns connected by the . operator. The
SPARQL 1.1 specification [5], with status of working draft at the moment of
writing this paper, extends the power of SPARQL in many ways. Particularly
relevant to our work is the support of aggregate functions and the inclusion of
the GROUP BY clause.
OLAP. In OLAP, data are organized as hypercubes whose axes are dimensions.
Each point in this multidimensional space is mapped through facts into one or
more spaces of measures. Dimensions are structured in hierarchies of levels that
allow analysis at different levels of aggregation. The values in a dimension level
are called members, which can also have properties or attributes. Members in
a dimension level must have a corresponding member in the upper level in the
hierarchy, and this correspondence is defined through so-called rollup functions.
In our running example we have a cube with sales data. For each sale we have
four measures: quantity of products sold, profit, price and cost per product (see
Figure 1, which shows a cube in the form of a report). We have also three dimen-
sions: Product, Geography (geographical location of the point of sale), and Time.
Figure 4 shows a possible schema for each dimension, and for the sales facts. We
can see that in dimension Geography, cities aggregate over states, and states over
countries. A well-known set of operations are defined over cubes. We present (for
clarity, rather informally) some of these operations next, following [9] and [19].

Roll-Up. Summarizes data at a higher level in the hierarchies of a dimension.

Given a cube C, a dimension D  C, such that dl is the lowest level of D in C;
a dimension level du  D such that dl & du (meaning that dl is lower than du

L. Etcheverry and A.A. Vaisman

manufacturer

category

iTTTTTT

year

country

quarter

model

product

state

city

month

date

P roducts

Geography

T ime

SALES[product, city, date]  [prof it, #sales, unitP rice, unitCost]

Fig. 4. Examples of dimensions (above) and fact schemas (below)

in the hierarchy of D), and a set of aggregate functions f , Roll-Up(C, D, du, f )
returns a new cube C
whose dimensions and levels are the same than in C,
except for the lowest level of D in C
are
the result of applying each function in f to the corresponding measures in C.
Aggregation is performed according with the rollup function associated with the

, which becomes du. Measures in C

relation dl & du. As an example, consider the cube C in Figure 5a with di-

mensions Product and Time and measure qtySold. Figure 5b shows the result of
Roll-Up(C, Time, month, Sum). (If the cube has more than one measure, and different aggregate funnctions fi are applied, pairs (measure,fi) must be specified.
Slice. Removes one dimension from a cube C. Intuitively, given a cube C, a
dimension D  C, and an aggregation function f , the result of applying the Slice
operation is a new cube C
= Slice(C, D, f ) whose dimensions are the ones of C,
except for D. Measures in C
are the result of applying the aggregation function
f to the measure in C. Figure 5c shows the result of Slice(C, Product, Sum). (The
same as above holds if there is more than one measure in C)).
Dice. Selects a subset of the instances of a cube. Intuitively, given a cube C, a
dimension D  C, and a formula  over the levels in D, the operation Dice is a
= Dice(C, D, ) whose dimensions are same as in C, and such that
new cube C
the elements in C are the ones that satisfy . Assuming that date1  date2 
date3, Figure 5d shows the result of Dice(C, Time, date > date1).

3 OLAP Cubes Specification in RDF

We now introduce Open Cubes, a vocabulary specified using RDFS that allows
representing the schema and instances of OLAP cubes. Recently, an RDF vocabulary called Data Cube [4] has been proposed that supports the exchange
of statistical data according to the ISO standard SDMX. 3 Although OLAP
and statistical databases are very similar concepts, they differ in the problems

3 http://sdmx.org/
?

?

?
i
?

?

?
prod1

prod2

month1

month2

date1
date2
date3
?

?

?
(a) Cube C

prod1

prod2

month1
month2
?

?

?
(b) RollU p(C, T ime, month, sum)

month1

month2

date1
date2
date3
?

?

?
month1
month2

date2
date3
?

?

?
prod1

prod2

(c) Slice(C, P roduct, sum)

(d) Dice(C, T ime, date > date1)

Fig. 5. Applying OLAP operations to a cube

they address [18]. In particular, the Data Cube vocabulary does not provide the
means to perform OLAP operations over data. This and other issues will be
further discussed in Section 5.

Open Cubes is based on the multidimensional data model presented in [6],

whose main concepts are dimensions and facts 4.

Dimensions have a schema and a set of instances; the schema contains the
name of the dimension, a set of levels and a partial order defined among them;
a dimension level is described by attributes; a dimension instance contains a
set of partial functions, called roll-up functions, that specify how level members
are aggregated. Facts also have a schema and instances; the former contains
the name of the fact, a set of levels and a set of measures; the latter is a partial
function that maps points of the schema into measure values. Figure 6 graphically
presents the most relevant concepts in the Open Cubes vocabulary, where bold
nodes represent classes and regular nodes represent properties. Labelled directed
arcs between nodes represent properties with a defined domain and range among
concepts in the vocabulary. We omit properties whose range is a literal value.

In Open Cubes, the class oc:Dimension and a set of related levels, modelled by the oc:Level property, represent dimension schemas. A partial order
among levels is defined using properties oc:parentLevel and oc:childLevel,
while the attributes of each level member are modelled using the oc:Attribute
property. A fact schema is represented by the class oc:FactSchema and a set
of levels and measures, which are modelled using the properties oc:Level and
oc:Measure respectively. For each measure the aggregation function that can
be used to compute the aggregated value of the measure, can be stated using
the oc:hasAggFunction property. As an example, Figure 8 shows RDF triples
(in Turtle notation) that represent the schemas of the Products dimension and
the Sales fact from the report in Figure 7, using the Open Cubes vocabulary.
The prefixes oc and eg represent the Open Cube vocabulary and the URI of the
RDF graph of this example, respectively.

Dimension instances are modelled using a set of level members, which are represented by the oc:LevelMember class. The properties oc:parentLevelMember

4 We could have used a more complex model, like [7]. However, the chosen model is

expressive enough to capture the most usual OLAP features.

L. Etcheverry and A.A. Vaisman

Fig. 6. Open Cubes vocabulary: classes and properties

Time

Q3-2011

December 2011

date1

date2

Product

Geography

price qtySold price qtySold

DSLR Camera Canon T3i Kit 18-55 USA OR Portland 714.54
T3 Kit 18-55 USA NJ Somerset 466.82

Jersey City 480
?

?

?
714.54
466.82
?

?

?
Fig. 7. Sample sales fact instances

e g : p r o d u c t s

r d f : t y p e o c : D i m e n s i o n ;

o c : d i m H a s L e v e l e g : p r o d u c t ;
o c : d i m H a s L e v e l e g : m o d e l ;
o c : d i m H a s L e v e l e g : m a n u f a c t u r e r ;
o c : d i m H a s L e v e l e g : c a t e g o r y .

r d f : t y p e o c : L e v e l .

r d f : t y p e o c : L e v e l .

e g : p r o d u c t
e g : m o d e l
e g : m a n u f a c t u r e r r d f : t y p e o c : L e v e l .
e g : c a t e g o r y r d f : t y p e o c : L e v e l .
e g : p r o d u c t o c : p a r e n t L e v e l e g : m o d e l .
e g : m o d e l o c : p a r e n t L e v e l

e g : s a l e s

r d f : t y p e o c : F a c t S c h e m a ;

o c : h a s L e v e l e g : p r o d u c t ;
o c : h a s L e v e l e g : c i t y ;
o c : h a s L e v e l e g : d a t e ;
o c : h a s M e a s u r e e g : p r i c e ;
o c : h a s M e a s u r e e g : q t y S o l d ;

e g : p r i c e r d f : t y p e o c : M e a s u r e ;

o c : h a s A g g F u n c t i o n av g .

e g : q t y S o l d r d f : t y p e o c : M e a s u r e ;

o c : h a s A g g F u n c t i o n sum .

e g : m o d e l o c : p a r e n t L e v e l e g : c a t e g o r y .

o c : m a n u f a c t u r e r .

Products dimension schema

Sales fact schema

Fig. 8. Expressing schemas using Open Cubes vocabulary

and oc:childLevelMember represent the roll-up functions that specify the navigation among level members. Instances of oc:FactInstance class represent fact
instances. The set of level members and the values of each measure are related
to the fact instance using pre-defined properties of type Level and Measure
?

?

?
 t 3 i k i t 1855  o c : i n L e v e l

e g : p r o d u c t ;
o c : p a r e n t L e v e l M e m b e r

 t 3 i  .

 t 3 i  o c : i n L e v e l e g : m o d e l ;

o c : p a r e n t L e v e l M e m b e r
o c : p a r e n t L e v e l M e m b e r

 Canon  ;
DSLR cam era  .

 t 3 k i t 1855  o c : i n L e v e l e g : p r o d u c t ;

o c : p a r e n t L e v e l M e m b e r

 t 3  .

e g : s a l e s i 1 r d f : t y p e

o c : F a c t I n s t a n c e ;
 t 3 i k i t 1855 

o c : h a s S c h e m a e g : s a l e s
e g : p r o d u c t
e g : d a t e
e g : c i t y  P o r t l a n d 
e g : p r i c e
e g : q t y S o l d   3    x s d : i n t e g e r

;

 d a t e 1 

;

;

;

  7 1 4 . 5 4    x s d : d e c i m a l ;

.

 t 3  o c : i n L e v e l e g : m o d e l ;

e g : s a l e s i 2 r d f : t y p e

o c : F a c t I n s t a n c e ;

o c : p a r e n t L e v e l M e m b e r
o c : p a r e n t L e v e l M e m b e r

 Canon  ;
DSLR cam era  .

. . . .

e g : s a l e s i 3 r d f : t y p e

o c : F a c t I n s t a n c e ;

 Canon  o c : i n L e v e l e g : m a n u f a c t u r e r .

. . . .

DSLR cam era  o c : i n L e v e l e g : c a t e g o r y .

Products dimension instances

Sales fact instances

Fig. 9. Expressing instances using Open Cubes vocabulary

respectively. For example, Figure 9 shows how the instances in Figure 7 can be
represented using the Open Cubes vocabulary. Is it worth noting that subjects
in RDF triples should be either blank nodes or URIs. For clarity, we use constant
values between quotation marks to represent the identifier of each level member.
These constant values should be replaced by URIs that uniquely identify each
of the level members. The oc:hasFactId property allows to provide a literal
that uniquely identifies each fact instance within a collection of cubes or multidimensional database. Due to space reasons we omit the oc:childLevelMember
relationships between the level members, and only show one complete fact instance RDF representation (the first tuple in Figure 7) .

4 Operating with Web Cubes

The operators introduced in Section 2 can be implemented in SPARQL 1.1 as
we show next. Let us start with a couple of examples.
Roll-up: This operation encompasses two tasks: (i) creating the schema of the
new cube; (ii) populating it. For instance, consider the Sales cube representation in Open Cubes (Figures 8 and 9), and a new cube SalesByMonth =
Roll-Up(Sales, T ime, month, price, avg, qty, sum). Figure 10 shows the specification in Open Cubes of the SalesByMonth schema and a SPARQL 1.1 query
that populates it. It is important to remark that new IRIs must be generated to
identify each of the fact instances.
Slice: Slicing out the Geography dimension from the Sales cube of in Figures 8 and
9, returns a new cube SalesWithoutGeo that satisfies SalesWithoutGeo =
Slice(Sales, Geography, avg, sum). Figure 11 shows the Open Cubes specification of the SalesWithoutGeo schema, and a SPARQL 1.1 query that populates it.

4.1 A General Algorithm for Roll-Up over Open Cubes

We now show an algorithm for the Roll-up operation, probably the most used
one in the OLAP setting. We define the following functions: (a) newV ar(i)

L. Etcheverry and A.A. Vaisman

generates unique SPARQL variable names; (b) value(v) returns the value stored
in variable v; (c) levels(s) returns all the levels in a schema s (i.e., all the values
of ?l that satisfy s oc:hasLevel ?l); (d) measures(s) returns all the measures
in a schema s (all the values of ?m that satisfy s oc:hasMeasure ?m); and (e)
aggF unction(m) returns the aggregation function of measure m (all the values
of ?f that satisfy m oc:hasAggFunction ?f). Also assume that there is a level
dlo in dimension d such that there exists a path between dlo and dlr which
contains only arcs with type oc:parentLevel. The function levelsP ath(d1, d2)
retrieves the ordered list of levels in the path between d1 and d2 (including both
levels). Also assume that it is possible to access and modify different parts of
a SPARQL query via the properties: resultFormat, graphPattern, and groupBy,
among others. The add(s) function appends s to a particular part of the query.

e g : s a l e s M o n t h r d f : t y p e o c : F a c t S c h e m a ;

o c : h a s L e v e l e g : p r o d u c t ; o c : h a s L e v e l e g : c i t y ;
o c : h a s L e v e l e g : m o n t h ; o c : h a s M e a s u r e e g : p r i c e ;
o c : h a s M e a s u r e e g : q t y S o l d .

SalesByMonth schema
CONSTRUCT { ? i d o c : h a s S c h e m a e g : s a l e s M o n t h . ? i d e g : p r o d u c t ? p r o d .

? i d e g : c i t y ? c i t y . ? i d e g : m o n t h ?mon .
? i d e g : p r i c e ? p r i c eM o n t h . ? i d e g : q t y S o l d ? qtyMonth . }

WHERE{ {
SELECT ? p r o d ? c i t y ?mon
(SUM( ? q t y S o l d ) AS ? qtyMonth )
( i r i ( f n : c o n c a t (  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ,  s a l e s  ,   ,
f n : s u b s t r i n g a f t e r ( ? prod ,  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ) ,   ,
f n : s u b s t r i n g a f t e r ( ? c i t y ,  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ) ,   ,
f n : s u b s t r i n g a f t e r ( ? mon ,  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ) ) ) AS ? i d )

(AVG( ? p r i c e ) AS ? p r i c eM o n t h )

WHERE {

? i o c : h a s S c h e m a s l : s a l e s
? i
? i
? d a t e o c : p a r e n t L e v e l M e m b e r ?mon . ?mon o c : i n L e v e l e g : m o n t h

e g : c i t y ? c i t y . ? i e g : d a t e ? d a t e .
e g : p r i c e ? p r i c e . ? i e g : q t y S o l d ? q t y .

. ? i e g : p r o d u c t ? p r o d .

}GROUP BY ? p r o d ? c i t y ?mon}}

SalesByMonth instances

Fig. 10. RollUp implementation over Open Cubes

e g : s a l e s W i t h o u t G e o r d f : t y p e o c : F a c t S c h e m a ;

o c : h a s L e v e l e g : d a t e ; o c : h a s L e v e l e g : c i t y ;
o c : h a s M e a s u r e e g : p r i c e ; o c : h a s M e a s u r e e g : q t y S o l d .

SalesWithoutGeo schema

CONSTRUCT
{ ? i d o c : h a s S c h e m a e g : s a l e s W i t h o u t G e o . ? i d e g : c i t y ? c i t y .

? i d e g : d a t e ? d a t e . ? i d e g : p r i c e ? a v g P r i c e
? i d e g : q t y S o l d ? sumQtySold .

} WHERE {{
SELECT ? c i t y ? d a t e (AVG( ? p r i c e ) AS ? a v g P r i c e )

.

(SUM( ? q t y ) AS ? sumQtySold )
( i r i ( f n : c o n c a t (  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ,  s a l e s S G e o  ,   ,
f n : s u b s t r i n g a f t e r ( ? c i t y ,  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ) ,   ,
f n : s u b s t r i n g a f t e r ( ? d a t e ,  h t t p : // ex am pl e . o r g / s a l e s I n s t a n c e s# ) ) ) AS ? i d )
WHERE {

? i o c : h a s S c h e m a e g : s a l e s
? i
? i

e g : c i t y ? c i t y
e g : p r i c e ? p r i c e . ? i e g : q t y S o l d ? q t y .

. ? i e g : d a t e ? d a t e .

.

}GROUP BY ? c i t y ? d a t e }}

SalesWithoutGeo instances

Fig. 11. Slice implementation over Open Cubes
?

?

?
Algorithm 1 shows a general procedure to build the SPARQL query needed

= Roll-up(C, D, dlr, F ), according to the definitions of

to populate a cube C
Section 2. Two SPARQL queries are needed: an inner query qInner that performs the GROUP BY, and an outer query qOuter that builds triples based on
the retrieved values from the inner query. The algorithm incrementally builds
both queries simultaneously, using the add function. Line 1 states that generated
facts have sr as schema. Line 2 adds a triple to the WHERE clause of the inner
query, that allows selecting facts from schema so. Lines 3 through 11 project
the members of each level in the schema into the result of both queries, also
adding triples to the WHERE clause of the inner query and adding the variables
that represent the level members to the GROUP BY clause in the inner query.
Lines 12 through 18 do the same for measures. In lines 13 and 16 f represents the
SPARQL function corresponding to the aggregate function for each measure and
f (value(mi)) is the string that should be included to calculate the aggregated
value (e.g sum(?m) if value(mi) =?m). Lines 19 to 30 add the triples needed to
navigate the dimension hierarchy. Line 22 adds to the inner query a triple that
associates the level member with the fact instance, line 25 adds a triple that
allows to check to which level the level member belongs to, and line 27 retrieves
the parent level member of the current level. Line 30 adds the target level to the
GROUP BY clause. Finally, line 33 sets the inner query as the WHERE clause
of the outer query, which is returned in line 34. For clarity, we omitted the clause
that generates the expression that binds variable ?id to a dynamically generated
URI from the values in the fact.

Preliminary Results. We have implemented the roll-up operation. We generated
over 24000 triples from synthetic data that represent instances of 3000 facts and
dimension members. Those triples were loaded in Virtuoso Opensource 6.1.45.
SPARQL 1.1 queries that implement the roll-up operation were performed over
the triples, retrieving results in less than 0.1 seconds. Our assumption is that
web cubes will not be large, since they will contain very focused an current data
from selected sources. Then, the operators over web cubes will be useful to avoid
going back and forth from the local multidimensional representation.

4.2 Exporting Web Cubes to a Local DSS

We now sketch how web cubes can be exported into the Mondrian OLAP server.
Multidimensional schemas in Mondrian are specified via an XML file, which also
contains the directives that allow populating the schemas.

The general mechanism has two phases: structure definition and population.
The definition phase takes a web cube schema as input and produces two outputs:
(i) the SQL code that creates tables in a relational database6, and (ii) an XML
file that contains the schema definition of the cube, and the mappings that
allow to populate the multidimensional schema with data stored in the relational
database. The population phase takes as input a web cube instance, expressed

5 http://www.openlinksw.com/wiki/main/Main
6 Mondrian represents the cube in the relational model.

L. Etcheverry and A.A. Vaisman

using Open Cubes, and produces SQL code that loads data into the database
created in the definition phase. Figure 12 shows a portion of the XML file that
represents the cube shown in Figure 2, closing the cycle of our running example:
Jane requested the web cubes, which were retrieved, and represented in RDF
using Open Cubes vocabulary; then she operated over the RDF representation
of the web cube, and finally imported it to the local DSS, for joint analysis with
the local cube.

Algorithm 1. Generates the SPARQL query that builds the Roll-Up instances
Input: so original schema, sr new schema, dlo level of D  so, dlr level of D  sr
Output: qOuter is a SPARQL CONSTRUCT query that creates the roll-up instances

if l = dlo then
newVar(li)
qOuter.resultFormat.add(?id , l, value(li))
qInner.resultFormat.add(value(li))
qInner.graphPattern.add(?i , l, value(li))
qInner.groupBy.add(value(li))

1: qOuter.graphPattern.add(?id , oc:hasSchema, sr)
2: qInner.graphPattern.add(?i , oc:hasSchema, so)
3: for all l  L = levels(so) do
4:
5:
6:
7:
8:
9:
end if
10:
11: end for
12: for all m  M = measures(so) do
13:
f = aggFunction(m)
newVar(mi); newVar(agi)
14:
qOuter.resultFormat.add(?id , m, value(agi))
15:
qInner.resultFormat.add(f(value(mi)) AS agi)
16:
qInner.graphPattern.add(?i , m, value(mi))
17:
18: end for
19: for all dli  path = levelsP ath(dlo, dlr) do
20:
21:
22:
23:
24:
25:
26:
27:
28:
end if
29:
30: end for
31: newVar(lmi)
32: qInner.groupBy.add(plmi)
33: qInner.resulFormat.add(plmi)
34: qOuter.resultFormat.add(?id , dlr, value(plmi))
35: qOuter.graphPattern.set(qInner)
36: return qOuter

end if

newVar(lmi)
if dli = dlo then

else

qInner.graphPattern.add(?i , value(dli), value(lmi))

newVar(plmi)
qInner.graphPattern.add(value(plmi), oc:inLevel, value(dli))
if dli = dlr then

qInner.graphPattern.add(value(lmi), oc:parentLevelMember,value(plmi) )
?

?

?
<Schema>
<Cube name= WCubeSales >
<T a b l e name= w c u b e s a l e s f a c t  />
<D i m e n s i o n name= P r o d u c t s  f o r e i g n K e y = p r o d u c t i d >
<H i e r a r c h y h a s A l l= f a l s e 
prim ary Key= p r o d u c t i d >
<T a b l e name= p r o d u c t s  />
<L e v e l name= Model  col um n= m o d e l
<L e v e l name= M a n u f a c u r e r  col um n= m a n u f i d  uni q ueMem bers= t r u e  />
<L e v e l name= C a t e g o r y  col um n= c a t e g o r y i d  uni q ueMem bers= t r u e  />
</ H i e r a r c h y>
</ D i m e n s i o n>
<D i m e n s i o n name= Time f o r e i g n K e y = d a t e >
. . .
</ D i m e n s i o n>
<Meas ure name= U n i t P r i c e  col um n= u n i t p r i c e  a g g r e g a t o r= av g  />
<Meas ure name= D e l i v e r y Time col um n= d e l t i m e  a g g r e g a t o r= av g  />
<Meas ure name= S h i p p i n g C os t  col um n= s h i p c o s t  a g g r e g a t o r= av g  />
</Cube>
</ Schema>

i d  uni q ueMem bers= t r u e  />

Sales schema representation using Mondrian

Fig. 12. Exporting Web Cubes to a local DSS

5 Related Work

Our work is highly related with the idea of situational BI, a term coined in [11].
Situational BI focuses on executing complex queries, mainly natural language
queries, over unstructured and (semi-) structured data; in particular, unstructured text retrieved from documents is seen as a primary source of information.
In the context of situational BI the process of augmenting local data with data
retrieved from web sources is discussed in [12].

In [4] a vocabulary called RDF Data Cube(DC) is presented. This vocabulary
is focused on representing statistical data, according to the SDMX data model.
Although this underlying data model shares some terms with traditional multidimensional data models, the semantics of some of the concepts are different. An
example of this is the concept of slices. Slices, as defined in the DC vocabulary,
represent subsets of observations, fixing values for one or more dimensions. Slices
are not defined in terms of an existing cube, they are defined as new structures
and new instances (observations). An example can be found in [4], Section 7.
The semantics of the slice operator in the MD model is quite different, as shown
in Section 2. Besides, while dimensions and its hierarchical nature are first class
citizens in MD models, DC dimensions are flat concepts that allow to identify
observations at a single granularity. The DC vocabulary does not provide the
constructs to explicitly represent hierarchies within dimensions, neither at the
schema level (DataStructureDefinition) nor at the instance level. As the DC vocabulary adheres to Linked Data principles hierarchies within dimensions may
be inferred from external hierarchies, whenever possible. For example, members
of a dimension stated to be of type foaf:Person can be grouped according to
their place of work using the foaf:workplaceHomepage property. This is clearly
not enough to guarantee the capability of the model to support OLAP operations
as roll-up, which need to represent hierarchical relationships within dimensions
levels and level members. Some of the problems found when trying to map cubes
expressed in the DC vocabulary into a multidimensional model are discussed in
[8]. In light of the above, we decided to buid a new vocabulary from scratch,
instead of extending DC.

L. Etcheverry and A.A. Vaisman

To our knowledge no previous work addresses the problem of expressing OLAP
operators over multidimensional data structures expressed in RDF. Nevertheless
the idea of using RDFS or OWL ontologies to represent multidimensional data
structures has been already explored. There is a line of work that uses these kinds
of ontologies as auxiliary artefacts in traditional DSS. In [15] the authors propose
an OWL ontology that models OLAP cubes schemas to assist in the ETL process
of a traditional DSS, while in [14] a variation of the former ontology is used to
check the consistency of summarizations. Among the approaches to the problem
of populating multidimensional schemas with semantic web data, in [13] a process
that extracts facts from semantic web data sources is outlined, assuming that the
multidimensional schema and the sources are annotated using a single ontology.
This work, however, does not deal with the extraction of dimension hierarchies.

6 Conclusion and Open Problems

We have presented an scenario where DSS systems are enhanced with web cubes
obtained from current data on the web. We defined a vocabulary to represent
these multidimensional data in RDFS, and operations over this representation,
to avoid exporting these cubes to a classic OLAP system. We also presented
a general algorithm for creating the SPARQL 1.1 queries that implement the
Roll-up operation. To the best of our knowledge, this is the first approach of
this kind in the field of BI over the Semantic Web. Existing approaches are
based on the idea of obtaining RDF data and exporting these data to traditional
OLAP cubes. Future work includes developing the complete framework, which
encompasses requirements specification, data acquisition, web cubes extraction
and publication, and data analysis using web cubes.

Acknowledgement. This work has been partially funded by the LACCIR
Project Monitoring Protected Areas using an OLAP-enabled Spatio-Temporal
Geographic Information System. Alejandro Vaisman has been partially funded
by the Open Semantic Cloud for Brussels (OSCB) Project, supported by the
Brussels Capital Region, Belgium.
