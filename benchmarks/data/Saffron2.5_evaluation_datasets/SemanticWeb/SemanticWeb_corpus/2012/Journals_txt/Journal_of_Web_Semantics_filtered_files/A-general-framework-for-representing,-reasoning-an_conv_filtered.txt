Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

Contents lists available at SciVerse ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : h t t p : / / w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

A general framework for representing, reasoning and querying with annotated
Semantic Web data
Antoine Zimmermann c,

, Nuno Lopes a, Axel Polleres a, Umberto Straccia b

a Digital Enterprise Research Institute, National University of Ireland, Galway, Ireland
b Istituto di Scienza e Tecnologie dellInformazione (ISTI  CNR), Pisa, Italy
c INSA-Lyon, LIRIS, UMR5205, F-69621, France

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 3 March 2011
Received in revised form 31 August 2011
Accepted 31 August 2011
Available online 16 September 2011

Keywords:

Annotations
SPARQL
Query

1. Introduction

We describe a generic framework for representing and reasoning with annotated Semantic Web data, a
task becoming more important with the recent increased amount of inconsistent and non-reliable metadata on the Web. We formalise the annotated language, the corresponding deductive system and address
the query answering problem. Previous contributions on specific RDF annotation domains are encompassed by our unified reasoning formalism as we show by instantiating it on (i) temporal, (ii) fuzzy,
and (iii) provenance annotations. Moreover, we provide a generic method for combining multiple annotation domains allowing to represent, e.g., temporally-annotated fuzzy RDF. Furthermore, we address the
development of a query language  AnQL  that is inspired by SPARQL, including several features of
SPARQL 1.1 (subqueries, aggregates, assignment, solution modifiers) along with the formal definitions
of their semantics.

O 2011 Elsevier B.V. All rights reserved.

RDF (Resource Description Framework) [1] is the widely used
representation language for the Semantic Web and the Web of
Data. RDF exposes data as triples, consisting of subject, predicate
and object, stating that subject is related to object by the predicate
relation. Several extensions of RDF were proposed in order to deal
with time [24], truth or imprecise information [5,6], trust [7,8]
and provenance [9]. All these proposals share a common approach
of extending the RDF language by attaching meta-information
about the RDF graph or triples. RDF Schema (RDFS) [10] is the specification of a restricted vocabulary that allows one to deduce further information from existing RDF triples. SPARQL [11] is the
W3C-standardised query language for RDF.

In this paper, we present an extension of the RDF model to support meta-information in the form of annotations of triples. We
specify the semantics by conservatively extending the RDFS
semantics and provide a deductive system for Annotated RDFS.
Further, we define a query language that extends SPARQL and include advanced features such as aggregates, nested queries and
variable assignments, which are part of the not-yet-standardised
SPARQL 1.1 specification. The present paper is based on and ex-

 Corresponding author.

E-mail addresses: antoine.zimmermann@insa-lyon.fr (A. Zimmermann), nuno.-
lopes@deri.org (N. Lopes), axel.polleres@deri.org (A. Polleres), straccia@isti.cnr.it (U.
Straccia).

1570-8268/$ - see front matter O 2011 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2011.08.006

tends two previously published articles introducing Annotated
RDFS [12] and AnQL (our SPARQL extension) [13]. In addition to
improving the descriptions of this existing body of work, we provide the following novelties:

1. We introduce a use case scenario that better reflects a realistic

example of how annotations can be used.

2. We detail three concrete domains of annotations (temporal,
fuzzy, provenance) that were only sketched in our previous
publications.

3. We present a detailed and systematic approach for combining
multiple annotation domains into a new single complex
domain; this represents the most significant novel contribution
of the paper.

4. We discuss the integration of annotated triples with standard,
non-annotated triples, as well as the integration of data using
different annotation domains.

5. We describe a prototype implementation.

Section 2 gives preliminary definitions of the RDFS semantics
and query answering, restricting ourselves to the sublanguage
qdf. Our extension of RDF is presented in Section 3 together with
essential examples of primitive domains. Our extension of SPARQL,
is presented in Section 4. Furthermore, Section 5 presents a discussion of important issues with respect to specific domains and their
combination.
our prototype
implementation.

Section 6 describes

Finally,

1.1. Related work

The basis for Annotated RDF were first established by Udrea
et al. [14,15], where they define triples annotated with values taken from a finite partial order. In their work, triples are of the form
(s, p : k, o), where the property, rather than the triple is annotated.
We instead rely on a richer, not necessarily finite, structure and
provide additional inference capabilities to [15], such as a more involved propagation of annotation values through schema triples.
For instance, in the temporal domain, from (a, sc, b): [2,6] and
(b, sc, c): [3,8], we will infer (a, sc, c): [3,6] (sc is the subclass prop-
erty). Essentially, Udrea et al. do not provide an operation to combine the annotation in such inferences, while the algebraic
structures we consider support such operations. Also, they require
specific algorithms, while we show that a simple extension to the
classical RDF inference rules is sufficient. The query language presented in this paper consists of conjunctive queries and, while
SPARQLs Basic Graph Patterns are compared to their conjunctive
queries, they do not consider extending SPARQL with the possibility of querying annotations. Furthermore, OPTIONAL, UNION and
FILTER SPARQL queries are not considered which results in a subset of SPARQL that can be directly translated into their previously
presented conjunctive query system.

Adding annotations to logical statements was already proposed
in the logic programming realm in which Kifer and Subrahmanian
[16] present a similar approach, where atomic formulas are annotated with a value taken from a lattice of annotation values, an
annotation variable or a complex annotation, i.e., a function applied to annotation values or variables. Similarly, we can relate
our work to annotated relational databases, especially Green
et al. [17] who provides a similar framework for the relational alge-
bra. After presenting a generic structure for annotations, they focus
more specifically on the provenance domain. The specificities of
the relation algebra, especially Closed World Assumption, allows
them to define a slightly more general structure for annotation do-
mains, namely semiring (as opposed to the residuated lattice in our
initial approach [12,13]). In relation to our rule-based RDFS Rea-
soning, it should be mentioned that Green et al. [17] also provide
an algorithm that can decide ground query answers for annotated
Datalog, which might be used for RDFS rules; general query
answering or materialisation though might not terminate, due to
the general structure of annotations, in their case. Karvounarakis
et al. [18] extend the work of [17] towards various annotations 
not only provenance, but also confidence, rank, etc.  but do not
specifically discuss their combinations.

In a generic approach mostly focused on Semantic Web ontolo-
gies, Baader et al. [19,20] describe a framework to delimit subontologies according to access restrictions, where access rights
are modelled by labels from a finite lattice, attached to ontological
axioms. The approach is not tied to a particular ontology language,
thereby could be used on RDF datasets. As the algebraic structure is
fully compatible with our framework, we can consider that this
case is covered by our work. However, the goal of their work is
not to provide means to reason and query over the access right
annotations but rather to enforce the access rights on subsets of
the axioms.

For the Semantic Web, several extensions of RDF were proposed
in order to deal with specific domains such as truth of imprecise
information [5,21,22,6], time [24], trust [7,8] and provenance
[9]. These approaches are detailed in the following paragraphs.

Straccia [6], presents Fuzzy RDF in a general setting where triples are annotated with a degree of truth in [0,1]. For instance,
Rome is a big city to degree 0.8 can be represented with
(Rome, type, BigCity): 0.8; the annotation domain is [0,1]. For
the query language, it formalises conjunctive queries. Other similar
approaches for Fuzzy RDF [5,21,22] provide the syntax and seman-

tics, along with RDF and RDFS interpretations of the annotated tri-
ples. In [22] the author describes an implementation strategy that
relies on translating the Fuzzy triples into plain RDF triples by
using reification. However these works focus mostly on the representation format and the query answering problem is not
addressed.

Gutierrez et al. [2] presents the definitions of Temporal RDF,
including reduction of the semantics of Temporal RDF graphs to
RDF graphs, a sound and complete inference system and shows
that entailment of Temporal graphs does not yield extra complexity than RDF entailment. Our Annotated RDFS framework encompasses this work by defining the temporal domain. They present
conjunctive queries with built-in predicates as the query language
for Temporal RDF, although they do not consider full SPARQL. Pugliese et al. [3] presents an optimised indexing schema for Temporal
RDF, the notion of normalised Temporal RDF graph and a query
language for these graphs based on SPARQL. The indexing scheme
consists of clustering the RDF data based on their temporal dis-
tance, for which several metrics are given. For the query language
they only define conjunctive queries, thus ignoring some of the
more advanced features of SPARQL. Tappolet and Bernstein [4]
present another approach to the implementation of Temporal
RDF, where each temporal interval is represented as a named
graph [23] containing all triples valid in that time period. Information about temporal intervals, such as their relative relations, start
and end points, is asserted in the default graph. The s-SPARQL
query language allows to query the temporal RDF representation
using an extended SPARQL syntax that can match the graph pattern against the snapshot of a temporal graph at any given time
point and allows to query the start and endpoints of a temporal
interval, whose values can then be used in other parts of the query.
SPARQL extensions towards querying trust have been presented
by Hartig [7]. Hartig introduces a trust aware query language,
tSPARQL, that includes a new constructor to access the trust value
of a graph pattern. This value can then be used in other statements
such as FILTERs or ORDER. Also in the setting of trust manage-
ment, Schenk [8] defines a bilattice structure to model trust relying
on the dimensions of knowledge and truth. The defined knowledge
about trust in information sources can then be used to compute the
trust of an inferred statement. An extension towards OWL is presented but there is no query language defined. Finally, this approach is used to resolve inconsistencies in ontologies arising
from connecting multiple data sources.

In [9] the authors also present a generic extension of RDF to represent meta information, mostly focused on provenance and uncer-
tainty. Such meta information is stored using named graphs and
their extended semantics of RDF, denoted RDF, assumes a predefined vocabulary to be interpreted as the meta information. However they do not provide an extension of the RDFS inference
rules or any operations for combining meta information. The
authors also provide an extension of the SPARQL query language,
considering an additional expression that enables querying the
RDF meta information.

Our initial approach of using residuated lattices as the structure
for representing annotations [12,13] was extended to the more
general semiring structure by Buneman and Kostylev [24]. This paper also shows that, once the RDFS inferences of an RDF graph have
been computed for a specific domain, it is possible to reuse these
inferences if the graph is annotated with a different domain. Based
on this result the authors define a universal domain which is possible to transform to other domains by applying the corresponding
transformations.

Aidan Hogans thesis [25, Chapter 6] provides a framework for a
rank,
specific combination of annotations (authoritativeness,
blacklisting) within RDFS and (a variant of) OWL 2 RL. This work
is orthogonal to ours, in that it does not focus on aspects of query

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

answering, or providing a generic framework for combinations of
annotations, but rather on scalable and efficient algorithms for
materialising inferences for the specific combined annotations under consideration.

2. Preliminaries  classical RDF and RDFS

In this section we present notions and definitions that are necessary for our discussions later. First we give a short overview of
RDF and RDFS.

2.1. Syntax

Consider pairwise disjoint alphabets U, B, and L denoting,
respectively, URI references, blank nodes and literals.1 We call the
elements in UBL (B) terms (variables, denoted x, y, z). An RDF triple
is s = (s, p, o) 2 UBL 
 U 
UBL.2 We call s the subject, p the predicate,
and o the object. A graph G is a set of triples, the universe of G, uni-
verse(G), is the set of elements in UBL that occur in the triples of
G, the vocabulary of G, voc(G), is universe(G) \ UL.

We rely on a fragment of RDFS, called qdf [26], that covers
essential features of RDFS. qdf is defined as the following subset
of the RDFS vocabulary: qdf 14 fsp; sc; type; dom; rangeg. Informally,
(i) (p, sp, q) means that property p is a subproperty of property q; (ii)
(c, sc, d) means that class c is a subclass of class d; (iii) (a, type,b)
means that a is of type b; (iv) (p, dom, c) means that the domain of
property p is c; and (v) (p, range, c) means that the range of property
p is c. In what follows we define a map as a function l : UBL ? UBL
preserving URIs and literals, i.e., l(t) = t, for all t2UL. Given a graph
G, we define lG 14 fls; lp; lo j s; p; o 2 Gg. We speak of a
map l from G1 to G2, and write l : G1 ! G2,
if l is such that
lG1 # G2.

2.2. Semantics

An interpretation I

over a vocabulary V is a tuple
I 14 DR; DP; DC ; DL; Ps 	 t; Cs 	 t; 	I
i, where DR; DP; DC; DL are the interpretation domains of I, which are finite non-empty sets, and
Ps 	 t; Cs 	 t;	I are the interpretation functions of I. They have to
satisfy:

1. DR are the resources (the domain or universe of I);
2. DP are property names (not necessarily disjoint from DR);
3. DC # DR are the classes;
4. DL # DR are the literal values and contains L \ V;
5. Ps 	 t is a function Ps 	 t : DP ! 2DR
DR ;
6. Cs 	 t is a function Cs 	 t : DC ! 2DR;
7. 	I maps each t 2 UL \ V into a value tI 2 DR [ DP, and such that
	I is the identity for plain literals and assigns an element in DR
to each element in L.

An interpretation I is a model of a ground graph G, denoted
I  G, if and only if I is an interpretation over the vocabulary
qdf [ universeG that satisfies the following conditions:

Simple:
1. For each s; p; o 2 G; pIA 2 DP and sIA ; oIA 2 PspIA t.
Subproperty:
1. PsspIA t is transitive over DP;
2.

if p; q 2 PsspIA t then p; q 2 DP and Pspt # Psqt.

if c; d 2 PsscIA t then c; d 2 DC and Csct # Csdt.

Subclass:
1. PsscIA t is transitive over DC;
2.
Typing I:
1. x 2 Csct if and only if x; c 2 PstypeIA t;
2.
3.
Typing II:
1. For each e 2 qdf; eIA 2 DP;
2.
3.
4.

if p; c 2 PsdomIA t then p 2 DP and c 2 DC;
if p; c 2 PsrangeIA t then p 2 DP and c 2 DC;
if x; c 2 PstypeIA t then c 2 DC.

if p; c 2 PsdomIA t and x; y 2 Pspt then x 2 Csct;
if p; c 2 PsrangeIA t and x; y 2 Pspt then y 2 Csct.

Entailment among ground graphs G and H is as usual. Now,
G  H, where G and H may contain blank nodes, if and only if for
any grounding G0 of G there is a grounding H0 of H such that
G0  H0.3

Remark 2.1. In [26], the authors define two variants of the
semantics: the default one includes reflexivity of PsspI t (resp.
CsscI t) over DP
(resp. DC) but we are only considering the
alternative semantics presented in [26, Definition 4] which omits
this requirement. Thus, we do not support an inference such as
G  a; sc; a, which anyway are of marginal interest.

Remark 2.2. In a First-Order Logic (FOL) setting, we may interpret
classes as unary predicates, and (RDF) predicates as binary predi-
cates. Then

1. a subclass relation between class c and d may be encoded as the

2. a subproperty relation between property p and q may be

formula 8x:cx ) dx;
encoded as 8x8y:px; y ) qx; y;
8x8y:px; y ) cx and 8x8y:px; y ) cy;
8x8y9z:px; z ^ pz; y ) px; y.

3. domain and range properties may be represented as:

4. the transitivity of a property can be represented as

Although this remark is trivial, we will see that it will play an

important role in the formalisation of Annotated RDFS.

2.3. Deductive system

In what follows, we provide the sound and complete deductive
system for our language derived from [26]. The system is arranged
in groups of rules that captures the semantic conditions of models.
In every rule, A, B, C, X, and Y are meta-variables representing elements in UBL and D, E represent elements in UL. The rules are as
follows:

1. Simple:

a G
G0

for a mapl : G0 ! G b G

G0 for G0

# G

2. Subproperty:

A; sp; B;B; sp; C

A; sp; C

D; sp; E;X; D; Y

X; E; Y

3. Subclass:

A; sc; B;B; sc; C

A; sc; C

A; sc; B;X; type; A

X; type; B

1 We assume U, B, and L fixed, and for ease we will denote unions of these sets

simply concatenating their names.

2 As in [26] we allow literals for s.

3 A grounding G0 of graph G is obtained, as usual, by replacing variables in G with

terms in UL.

4. Typing:

D; dom; B;X; D; Y

X; type; B

D; range; B;X; D; Y

Y; type; B

5. Implicit Typing:
;X; D; Y
; D; sp; A


A; dom; B


X; type; B
; D; sp; A
;X; D; Y

A; range; B


Y; type; B

icate p, where ps arguments may be q df variables, values from UL,
and p has a fixed interpretation. We will assume that the evaluation of the predicate can be decided in finite time. For convenience,
we write functional predicates4 as assignments of the form
x :14 fz and assume that the function fz is safe. We also assume
that a non functional built-in predicate pz should be safe as well.

A query example is:

qx; y   y; created; x;y; type; Italian;

x; exhibitedAt; Uffizi

A reader familiar with [26] will notice that these rules are as rules
15 of [26] (which has 7 rules). We excluded the rules handling
reflexivity (rules 67) which are not needed to answer queries. Fur-
thermore, as noted in [26], the Implicit Typing rules are a necessary addition to the rules presented in [27] for complete RDFS
entailment. These represent the case when variable A in (D, sp, A)
and (A, dom,B) or (A, range, B), is a property implicitly represented
by a blank node.

We denote with fs1; . . . ; sngRDFS s that the consequence s is
obtained from the premise s1; . . . ; sn by applying one of the inference rules 25 above. Note that n 2 f2; 3g. RDFS is extended to
the set of all RDFS rules as well, in which case n 2 f1; 2; 3g.

If a graph G0 can be obtained by recursively applying rules 1-5
from a graph G, the sequence of applied rules is called a proof, denoted G  G0, of G0 from G. The following proposition shows that
our proof mechanism is sound and complete w.r.t. the qdf
semantics:

Proposition 2.1 (Soundness and completeness [26]). Inference 
based on rules 15 as of [26] and applied to our semantics defined
above is sound and complete for , that is, G  G0 if and only if G  G0.

Proposition 2.2 [26]. Assume G  G0 then there is a proof of G0 from
G where the rule (1a) is used at most once and at the end.

Finally, the closure of a graph G is defined as clG 14 fs j G sg,
where  is as  except that rule (1a) is excluded. Note that the size
of the closure of G is polynomial in the size of G and that the closure is unique. Now we can prove that:

Proposition 2.3. G  G0 if and only if G0 # clG or G0 is obtained from
clG by applying rule (1a).

having intended meaning to retrieve all the artefacts x created by
Italian artists y, being exhibited at Uffizi Gallery.

In order to define an answer to a query we introduce the

following:

Definition 2.1 (Query instantiation). Given a vector x 14 hx1; . . . ; xki
of variables, a substitution over x is a vector of terms t replacing
variables
in x with terms of UBL. Then, given a query
qx   9y:ux; y, and two substitutions t; t0 over x and y,
the query instantiation ut; t0 is derived from
respectively,
ux; y by replacing x and y with t and t0, respectively.

Note that a query instantiation is an RDF graph.

Definition 2.2 (Entailment). Given
query
qx   9y:ux; y, and a vector t of terms in universe(G), we say
that qt is entailed by G, denoted G  qt, if and only if in any
model I of G, there is a vector t0 of terms in universe(G) such that I
is a model of the query instantiation ut; t0.

graph G,

Definition 2.3. If G  qt then t is called an answer to q. The
answer set of q w.r.t. G is defined as ansG; q 14 ft j G  qtg.

We next show how to compute the answer set. The following

can be shown:

Proposition 2.4. Given a graph G, t is an answer to q if and only if
there exists an instantiation ut; t0 that is true in the closure of G
(i.e., all triples in ut; t0 are in clG).

Therefore, we have a simple method to determine ansG; q.
Compute the closure clG of G and store it into a database, e.g.,
using the method [29]. It is easily verified that any query can be
mapped into an SQL query over the underlying database schema.
Hence, ansG; q can be determined by issuing such an SQL query
to the database.

2.4. Query answering

3. RDFS with annotations

Concerning query answering, we are inspired by Gutierrez et al.
[28] and the logic programming setting and we assume that a RDF
graph G is ground, that is, all blank nodes have been skolemised,
i.e., replaced with terms in UL.

A query is of the rule-like form

qx   9y:ux; y;
where qx is the head and 9y:ux; y is the body of the query, which
is a conjunction (we use the symbol , to denote conjunction in the
rule body) of triples si1 6 i 6 n). x is a vector of variables occurring
in the body, called the distinguished variables, y are so-called nondistinguished variables and are distinct from the variables in x, each
variable occurring in si is either a distinguished or a non-distin-
guished variable. If clear from the context, we may omit the existential quantification 9y.

In a query, we allow built-in triples of the form (s, p, o), where p
is a built-in predicate taken from a reserved vocabulary and having
a fixed interpretation. We generalise the built-ins to any n-ary pred-

This section presents the extension to RDF towards generic
annotations. Throughout this paper we will use an RDF dataset
describing companies, acquisitions between companies and
employment history. This dataset is partially presented in Fig. 1.
We consider this data to be annotated with the temporal domain,
which intuitively means that the annotated triple is valid in dates
contained in the annotation interval (the exact meaning of the
annotations will be explained later). Also, the information in this
example can be derived from Wikipedia and thus we can consider
this data also annotated with the provenance domain (although
not explicitly represented in the example). We follow the modelling of employment records proposed by DBpedia, for instance a
list of employees of Google is available as members of the class
http://dbpedia.org/class/yago/GoogleEmployees. For presentation
purposes we use the shorter name googleEmp. We also introduce

4 A predicate px; y is functional if for any t there is unique t0 for which pt; t0 is
true.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

Remark 3.1. In previous work [12,13], an annotation domain was
assumed to be a more specific structure, namely a residuated
bounded lattice D 14 hL;;^;_; 
;);?;>i. That is:

1. hL;;^;_;?; >i is a bounded lattice, where ? and > are bottom

and top elements, and ^ and _ are meet and join operators.

2. hL;
;>i is a commutative monoid.
3. ) is the so-called residuum of 
, i.e., for all k1; k2; k3; k1 
k3  k2

if and only if k3  k1 ) k2.
Note that any bounded residuated lattice satisfies the conditions of an annotation domain. In [24] it was shown that we may
use a slightly weaker structure than residuated lattices for annotation domains.

Remark 3.2. Observe that hL;;;?;>i is a bounded join semi-
lattice.

Remark 3.3. Note that the domain D01 14 hf0; 1g; max; min; 0; 1i
corresponds to the boolean case. In fact, in this case Annotated
RDFS will turn out to be the same as classical RDFS.

s : 122003; 2008,

Remark 3.4. We use  to combine information about the same
statement. For instance, in temporal logic, from s : 122000; 2006
and
as
[2000,2008] = [2000,2006] [ [2003,2008]; here, [ plays the role
of .
In the fuzzy context, from s : 0:7 and s : 0:6, we infer
s : 0:7, as 0.7 = max(0.7,0.6) (here, max plays the role of ).

s : 122000; 2008,

infer

we

Remark 3.5. We use 
 to model the conjunction of information.
In fact, a 
 is a generalisation of boolean conjunction to the manyvalued case. In fact, 
 satisfies also that

1. 
 is bounded: i.e., k1 
 k2  k1.
2. 
 is -monotone, i.e., for k1  k2; k 
 k1  k 
 k2.

For instance, on interval-valued temporal logic, from (a, sc,b):
infer (a, sc, c):
[2000,2006] and (b, sc, c): [2003,2008], we will
[2003,2006], as [2003,2006] = [2000,2006] \ [2003,2008]; here,
\ plays the role of 
.6 In the fuzzy context, one may chose any t-
norm [30,31], e.g., product, and, thus, from (a, sc,b): 0.7 and (b, sc,c):
0.6, we will infer (a, sc,c): 0.42, as 0.42 = 0.7 	 0.6 (here, 	 plays the
role of 
).

Remark 3.6. Observe that the distributivity condition is used to
guarantee that, e.g., we obtain the same annotation k 
 k2  k3
14 k1 
 k2  k1 
 k3 of the triple (a, sc, c) that can be inferred from
triples a; sc; b : k1;b; sc; c : k2 and b; sc; c : k3.

Finally, note that, conceptually, in order to build an annotation

domain, one has to:

1. determine the set of annotation values L (typically a countable

set7), identify the top and bottom elements;

2. define suitable operations 
 and  that acts as conjunction
and disjunction function, to support the intended inference
over schema axioms, such as

from a; sc; b : k and b; sc; c : k0 infer a; sc; c : k 
 k0
and
from s : k and s : k0 infer s : k  k0.

Fig. 1. Company acquisition dataset example.

SkypeCollab (resp. EbayCollab) to represent Skypes (resp.
Ebays) collaborators.

3.1. Syntax

Our approach is to extend triples with annotations, where an

annotation is taken from a specific domain.5

An annotated triple is an expression s : k, where s is a triple and
k is an annotation value (defined below). An annotated graph is a finite set of annotated triples. The intended semantics of annotated
triples depends of course on the meaning we associate to the annotation values. For instance, in a temporal setting [2]

 : 122003; 2007
has intended meaning Niklas was CEO of Skype during the period
20032007, while in the fuzzy setting [6] (skype, ownedBy, big-
Company): 0.3 has intended meaning Skype is owned by a big company to a degree not less than 0.3.

niklasZennstrom; ceoOf; skype

3.2. RDFS Annotation domains

To start with, let us consider a non-empty set L. Elements in L
are our annotation values. For example,
in a fuzzy setting,
L = [0,1], while in a typical temporal setting, L may be time points
or time intervals. In our annotation framework, an interpretation
will map statements to elements of the annotation domain. Our
semantics generalises the formulae in Remark 2.2 by using a well
known algebraic structure.

We say that an annotation domain for RDFS is an idempotent,

commutative semi-ring
D 14 hL;;
;?;>i;
where  is >-annihilating [24]. That is, for k; ki 2 L
1.  is idempotent, commutative, associative;
2. 
 is commutative and associative;
3. ? k 14 k;> 
 k 14 k;? 
k 14?, and >  k 14 >;
4. 
 is distributive over , i.e., k1 
 k2  k3 14 k1 
 k2 k1 
 k3.
It is well-known that there is a natural partial order on any
idempotent semi-ring: an annotation domain D 14 hL;;
;?; >i induces a partial order  over L defined as:
k1  k2
The order  is used to express redundant/entailed/subsumed
information. For instance, for temporal intervals, an annotated tri-
ple
as
122003; 2004 #122000; 2006 (here, # plays the role of ).

s; p; o : 122003; 2004,

s; p; o : 122000; 2006

k1  k2 14 k2:

if and only if

entails

5 The readers familiar with the annotated logic programming framework [16], will

6 As we will see,  and 
 may be more involved.
7 Note that one may use XML decimals in [0,1] in place of real numbers for the

notice the similarity of the approaches.

fuzzy domain.

3.3. Semantics

Fix an annotation domain D 14 hL;;
;?;>i.

Informally, an
interpretation I will assign to a triple s an element of the annotation domain k 2 L. Formally, an annotated interpretation I over a
vocabulary V is a tuple

I 14 DR; DP; DC; DL; Ps 	 t; Cs 	 t;	I

where DR; DP; DC; DL
Ps 	 t; Cs 	 t;	I are interpretation functions of I.

are

interpretation domains of I

and

They have to satisfy:

1. DR is a nonempty finite set of resources, called the domain or

universe of I;

2. DP is a finite set of property names (not necessarily disjoint

from DR);

Remark 3.7. Note that we always have that G  s :?. Clearly,
triples of the form s :? are uninteresting and, thus, in the following
we do not consider them as part of the language.

As for the crisp case, it can be shown that:

Proposition 3.1. Any Annotated RDFS graph has a finite model.

Proof 3.1. Let G be an annotated graph over domain d. Let
Lit 14 L \ universeG be the set of literals present in G and l0 2 Lit.
We define the interpretation I over V as follows:

1. DR 14 DP 14 DC 14 Lit 14 DL 14 Lit;
2. 8x; y; p Psptx; y # >;
3. 8x; c Csctx # >;
4. (a) 8l 2 L; lI 14 l,
(b) 8x 2 V; lI 14 l0.

It is easy to see that I satisfies all the conditions of RDF-

3. DC # DR is a distinguished subset of DR identifying if a resource

satisfiability and thus is a model of G.

denotes a class of resources;

L \ V;

4. DL # DR, the set of literal values, DL contains all plain literals in
5. Ps 	 t maps each property name p 2 DP

into a function
Pspt : DR 
 DR ! L, i.e., assigns an annotation value to each pair
of resources;
6. Cs 	 t maps each class c 2 DC into a function Csct : DR ! L, i.e.,
assigns an annotation value representing class membership in
c to every resource;

7. 	I maps each t 2 UL \ V into a value tI 2 DR [ DP and such that 	I
is the identity for plain literals and assigns an element in DR to
each element in L.

An interpretation I is a model of an annotated ground graph G,
denoted I  G, if and only if I is an interpretation over the vocabulary qdf [ universeG that satisfies the following conditions:

Simple:
1. s; p; o : k 2 G implies pI 2 DP and PspItsI; oI  k.
Subproperty:
1. PsspItp; q 
 PsspItq; r  PsspItp; r;
2. PspItx; y 
 PsspItp; q  PsqItx; y.
Subclass:
1. PsscItc; d 
 PsscItd; e  PsscItc; e;
2. CscItx 
 PsscItc; d  PsdItx.
Typing I:
1. Csctx 14 PstypeItx; c;
2. PsdomItp; c 
 Psptx; y  Csctx;
3. PsrangeItp; c 
 Psptx; y  Cscty.
Typing II:
1. For each e 2 qdf, eI 2 DP;
2. PsspItp; q is defined only for p; q 2 DP;
3. CsscItc; d is defined only for c; d 2 DC;
4. PsdomItp; c is defined only for p 2 DP and c 2 DC;
5. PsrangeItp; c is defined only for p 2 DP and c 2 DC;
6. PstypeIts; c is defined only for c 2 DC.
Intuitively, a triple s; p; o : k is satisfied by I if (s, o) belongs to
the extension of p to a wider extent than k. Note that the major
differences from the classical setting relies on items 5 and 6.

We further note that the classical setting is as the case in which

the annotation domain is D01 where L 14 f0; 1g.
Finally, entailment among annotated ground graphs G and H is
as usual. Now, G  H, where G and H may contain blank nodes, if
and only if for any grounding G0 of G there is a grounding H0 of H
such that G0  H0.

Therefore, we do not have to care about consistency.

3.4. Examples of primitive domains

To demonstrate the power of our approach, we illustrate its
[2] and

fuzzy [6],

temporal

application to some domains:
provenance.

3.4.1. The fuzzy domain

To model fuzzy RDFS [6] we may define the annotation domain
as D120;1 14 h120; 1; max;
; 0; 1i where 
 is any continuous t-norm on
[0,1].

Example 3.1. Adapting our example of employment records to the
fuzzy domain we can state the following: Skype collaborators are
also Ebay collaborators to some degree since Ebay possesses 30% of
Skypes shares, and also that Toivo is a part-time Skype
collaborator:
SkypeCollab; sc; EbayCollab : 0:3
toivo; type; SkypeCollab : 0:5:
Then, e.g., under the product t-norm 
, we can infer the following
triple:
toivo; type; EbayCollab : 0:15:

3.4.2. The temporal domain

Most of the semantic information on the Web deals with time in
an implicit or explicit way. Social relation graphs, personal profiles,
information about various entities continuously evolve and do not
remain static. This dynamism can take various forms: certain information is only valid in a specific time interval (e.g., somebodys ad-
dress), some data talks about events that took place at a specific
time point in the past (e.g., beginning of a conference), some data
describe eternal truth (e.g., tigers are mammals), or truth that is
valid from a certain point of time onwards forever (e.g., Elvis is
dead), or creation or change dates of online information items
(e.g., the edit history of a wiki page). We believe that treating
Web data in a time-sensitive way is one of the biggest steps
towards turning the Semantic Web idea into reality.

3.4.2.1. Precise temporal information. For our representation of the
temporal domain we aim at using non-discrete time as it is necessary to model temporal intervals with any precision. however, for
presentation purposes we will show the dates as years only.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

3.4.2.2. Modelling the temporal domain. To start with, time points are
elements of the value space Q [ f1;1g. A temporal interval is
a non-empty interval 12a1; a2, where ai are time points. An empty
interval is denoted as ;. We define a partial order on intervals as
I1 6 I2 if and only if I1 # I2. The intuition here is that if a triple is
true at time points in I2 and I1 6 I2 then, in particular, it is true
at any time point in I1

 ;.

Now, apparently the set of intervals would be a candidate for L,
which however is not the case. The reason is that, e.g., in order to
represent the upper bound interval of s : 121; 5 and s : 128; 9 we
rather need the union of intervals, denoted f121; 5;128; 9g, meaning
that a triple is true both in the former as well as in the latter inter-
val. Now, we define L as (where ?14 f;g;> 14 f121; 1g)
L 14 ftjt is a finite set of disjoint temporal intervalsg [ f?;>g:

such that I1 6 I2:

Therefore, a temporal term is an element t 2 L, i.e., a set of pairwise disjoint time intervals. We allow to write [a] as a shorthand
for 12a; a; s : a as a shorthand of s : f12ag and s : 12a; a0 as a shorthand
of s : f12a; a0g. Furthermore, on L we define the following partial
order:
t1  t2 if and only if 8I1 2 t19I2 2 t2;
Please note that  is the Hoare order on power sets [32], which is a
pre-order. For the anti-symmetry property, assume that t1  t2 and
t2  t1: so for I1 2 t1, there is I2 2 t2 for which there is I3 2 t1 such
I1 14 I3 14 I2. So,
that I1 # I2 # I3. But, t1 is maximal and, thus,
t1 14 t2 and, thus,  is a partial order. Similarly as for time intervals,
the intuition for  is that if a triple is true at time points in intervals
in t2 and t1  t2, then, in particular, it is true at any time point in
intervals in t1. Essentially, if t1  t2 then a temporal triple s2 : t2 is
true to a larger temporal extent than the temporal triple s1 : t1.
It can also be verified that hL; ;?;>i is a bounded lattice. Indeed,
to what concerns us, the partial order  induces the following join
() operation on L. Intuitively, if a triple is true at t1 and also true at
t2 then it will be true also for time points specified by t1  t2 (a kind
of union of time points). As an example, if s : f122; 5;128; 12g and
s : f124; 6;129; 15g are true then we expect that this is the same as
saying that s : f122; 6;128; 15g is true. The join operator will be de-
f122; 5;128; 12g  f124; 6;129; 15g 14
fined
f122; 6;128; 15g. Operationally, this means that t1  t2 will be obtained as follows: (i) take the union of the sets of intervals
t 14 t1 [ t2; and (ii) join overlapping intervals in t until no more
overlapping intervals can be obtained. Formally,
t1  t2 14 infft j t  ti; i 14 1; 2g:

such way

that

in

It remains to define the meet 
 over sets of

intervals.
Intuitively, we would like to support inferences such as from
a; sc; b : f122; 5;128; 12g
infer
a; sc; b : f124; 5;129; 12g, where f122; 5;128; 12g 
 f124; 6,
129; 15g 14
f124; 5;129; 12g. We get it by means of
t1 
 t2 14 supft j t  ti; i 14 1; 2g:

b; sc; c : f124; 6;129; 15g

and

Note that here the t-norm used for modelling conjunction

coincides with the lattice meet operator.

Example 3.2. Using the data from our running example, we can
infer that
chadHurley; type; googleEmp : 122006; 2010;
where
f122005; 2010g 
 f122006; 2011g 14 f122006; 2010g:

In [2] are described some further features such as a Now time
point (which is just a defined time point in DT) and anonymous
time points, allowing to state that a triple is true at some point.
Adding anonymous time points would require us to extend the lattice by appropriate operators, e.g. 124; T  12T; 8 14 124; 8 (where T is
an anonymous time point), etc.

3.4.3. Provenance domain

Identifying provenance of triples is regarded as an important issue for dealing with the heterogeneity of Web data, and several
proposals have been made to model provenance [3336]. Typically,
provenance is identified by a URI, usually the URI of the document
in which the triples are defined or possibly a URI identifying a
named graph. However, provenance of inferred triples is an issue
that have been little tackled in the literature [37,35]. We propose
to address this issue by introducing an annotation domain for
provenance.

The intuition behind our approach is similar to the one of [37]
and [35] where provenance of an inferred triple is defined as the
aggregation of provenances of documents that allow to infer that
triple. For instance, if a document d1 defines (youtubeEmp, sc,
googleEmp):d1 and a second document d2 defines (chadHurley,
type, youtubeEmp):d2, then we can infer (chadHurley, type,
googleEmp):d1 ^ d2.

Such a mechanism makes sense and would fit well as a meet
operator, but these approaches do not address the join operation
which should take place when identical triples are annotated dif-
ferently. We improve this with the following formalisation.

3.4.3.1. Modelling the provenance domain. We start from a countably infinite set of atomic provenances P which, in practice, can
be represented by URIs. We consider the propositional formulae
made from symbols in P (atomic propositions), logical or (_) and
logical and (^), for which we have the standard entailment . A
logical
provenance
equivalence relation, i.e., the set of annotation values is the quotient set of P by the logical equivalence. The order relation is ,

 and  are ^ and _, respectively. We set > to true and ? to
false.

an equivalent

value

class

is

for

the

Example 3.3. Consider the following data:
chadHurley; worksFor; youtube : chad
chadHurley; type; Person : chad
youtube; type; Company : chad
Person; sc; Agent : foaf
worksFor; dom; Person : workont
worksFor; range; Company : workont:
We can deduce that chadHurley is an Agent in two different
ways: using the first, fourth and fifth statement or using the second
and fourth statement. So, it is possible to infer the following annotated triple:
chadHurley; type; Agent : chad ^ foaf ^ workont

_ chad ^ foaf

However, since chad ^ foaf ^ workont _ chad ^ foaf is logically equivalent to chad^foaf, the aggregated inference can be
collapsed into:
chadHurley; type; Agent : chad ^ foaf :

Intuitively, a URI denoting a provenance can also denote a RDF
graph, either by using a named graph approach, or implicitly by
getting a RDF document by dereferencing the URI. In this case,
we can see the conjunction operation as a union of graphs and disjunction as an intersection of graphs.

3.4.3.2. Comparison with other approaches. [37] does not formalise
the semantics and properties of his aggregation operation (simply
denoted by ^) nor the exact rules that should be applied to correctly and completely reason with provenance. Query answering
is not tackled either.

The authors of [35] are providing more insight on the formalisation and actually detail the rules by reusing (tacitly) [26]. They also
provide a formalisation of a simple query language. However, the
semantics they define is based on a strong restriction of qdf.8

As an example, they define the answers to the query (?x, type,?-
y,?c) as the tuples (X, Y, C) such that there is a triple (X, type, Y, C)
which can be inferred from only the application of rules (3a) and
(3b). This means that a domain or range assertion would not provide additional answers to that type of query.

Provenance also relates to the named graphs formalism [23]
where one can identify distinct graphs with a URI. The name can
be seen as an atomic provenance annotation. However, named
graphs do not provide operations to combine the provenances.
Yet, the formalism could be used as a possible syntactic solution
for representing annotated triples.

Finally, none of those papers discuss the possibility of universally true statements (the > provenance) or the statements from
unknown provenance (?). They also do not consider mixing nonannotated triples with annotated ones as we do in Section 5.3.

3.5. Deductive system

An important feature of our framework is that we are able to
provide a deductive system in the style of the one for classical
RDFS. Moreover, the schemata of the rules are the same for any annotation domain (only support for the domain dependent 
 and 
operations has to be provided) and, thus, are amenable to an easy
implementation on top of existing systems. The rules are arranged
in groups that capture the semantic conditions of models, A, B, C, X
and Y are meta-variables representing elements in UBL and D, E
represent elements in UL. The rule set contains two rules (1a)
and (1b), that are the same as for the crisp case, while rules
(2a)(5b) are the annotated rules homologous to the crisp ones. Fi-
nally, rule (6) is specific to the annotated case.

Please note that rule (6) is destructive i.e., this rule removes the
premises as the conclusion is inferred. We also assume that a rule
is not applied if the consequence is of the form s :? (see Remark
3.7). It can be shown that:

1. Simple:

a G
G0
b G
G0

for a map l : G0 ! G
for G0

# G

2. Subproperty:

A; sp; B : k1;B; sp; C : k2

A; sp; C : k1 
 k2

D; sp; E : k1;X; D; Y : k2

X; E; Y : k1 
 k2

3. Subclass:

4. Typing:

A; sc; B : k1;B; sc; C : k2

A; sc; C : k1 
 k2

A; sc; B : k1;X; type; A : k2

X; type; B : k1 
 k2

D; dom; B : k1;X; D; Y : k2

X; type; B : k1 
 k2

D; range; B : k1;X; D; Y : k2

Y; type; B : k1 
 k2

5. Implicit Typing:

A; dom; B : k1;D; sp; A : k2;X; D; Y : k3

X; type; B : k1 
 k2 
 k3

A; range; B : k1;D; sp; A : k2;X; D; Y : k3

Y; type; B : k1 
 k2 
 k3

6. Generalisation:

X; A; Y : k1;X; A; Y : k2

X; A; Y : k1  k2

Proposition 3.2 (Soundness and completeness). For an annotated
graph, the proof system  is sound and complete for , that is, (1) if
G  s : k then G  s : k and (2) if G  s : k then there is k0  k with
G  s : k0.

We point out that rules 25 can be represented concisely using

the following inference rule:

s1 : k1; . . . ; sn : kn;fs1; . . . sng RDFSs

s : 
iki

Essentially, this rule says that if a classical RDFS triple s can be inferred by applying a classical RDFS inference rule to triples s1; . . . sn
(denoted fs1; . . . ; sngRDFSs), then the annotation term of s will be

iki, where ki is the annotation of triple si. It follows immediately
that, using rule (AG), in addition to rules (1) and (6) from the deductive system above, it is easy to extend these rules to cover complete
RDFS.

Finally, like for the classical case, the closure is defined as
clG 14 fs : k j G s : kg, where  is as  without rule (1a). Note
again that the size of the closure of G is polynomial in j G j and
can be computed in polynomial time, provided that the computational complexity of operations 
 and  are polynomially bounded
(from a computational complexity point of view, it is as for the
classical case, plus the cost of the operations 
 and  in L). Even-
tually, similar propositions as Propositions 2.2 and 2.3 hold.

Example 3.4. As an example, consider the following triples from
Fig. 1:

youtubeEmp; sc; googleEmp : 122006; 2011
chadHurley; worksFor; youtubeEmp : 122005; 2010
we infer the following triple:
chadHurley; type; googleEmp : 122006; 2010

3.6. Query answering

8 Remember that qdf is already a restriction of RDFS.

Informally, queries are as for the classical case where triples are
replaced with annotated triples in which annotation variables

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

(taken from an appropriate alphabet and denoted K) may occur.
We allow built-in triples of the form (s, p, o), where p is a built-in
predicate taken from a reserved vocabulary and having a fixed
interpretation on the annotation domain d, such as (k,,l) stating
that the value of lambda has to be  than the value l 2 L. We generalise the built-ins to any n-ary predicate p, where ps arguments
may be annotation variables, qdf variables, domain values of d, values from UL, and p has a fixed interpretation. We will assume that
the evaluation of the predicate can be decided in finite time. As for
the crisp case, for convenience, we write functional predicates as
assignments of the form x :14 fz and assume that the function fz
is safe. We also assume that a non functional built-in predicate
pz should be safe as well.

For instance, informally for a given time interval 12t1; t2, we may
define x :14 length12t1; t2 as true if and only if the value of x is t2  t1.

Example 3.5. Considering our dataset from Fig. 1 as input and the
query asking for people that work for Google between 2002 and
2011 and the temporal term at which this was true:
qx; K   x; worksFor; google : K0

K :14 K0 ^ 122002; 2011;

will get the following answers:
steveChen;122006; 2011

chadHurley;122006; 2010

jawedKarim;122006; 2011

larryPage;122002; 2011

sergeyBrin;122002; 2011

Formally, an annotated query is of the form

i:

qx; K   9y9K0:u x; K; y; K0
in which ux; K; y; K0 is a conjunction (as for the crisp case, we use
, as conjunction symbol) of annotated triples and built-in predi-
cates, x and K are the distinguished variables, y and K0 are the vectors of non-distinguished variables (existential quantified variables),
and x; K; y and K0 are pairwise disjoint. Variables in K and K0 can
only appear in annotations or built-in predicates. The query head
contains at least one variable.

Given an annotated graph G, a query qx; K   9y9K0:
ux; K; y; K0, a vector t of terms in universeG and a vector K of annotated terms in L, we say that qt; K is entailed by G, denoted
G  qt; K, if and only if in any model I of G, there is a vector t0 of terms
in universeG and a vector K0 of annotation values in L such that I is a
model of ut; K; t0; K0. If G  qt; K then ht; Ki is called an answer to
q. The answer set of q w.r.t. G is ( extends to vectors point-wise)
ansG; q 14 fht; ki j G  qt; k; k  ? and

for any k0k such that G  qt; k0; k0  k holdsg:

That is, for any tuple t, the vector of annotation values k is as large
as possible. This is to avoid that redundant/subsumed answers occur in the answer set. The following can be shown:

Proposition 3.3. Given a graph G, ht; ki is an answer to q if and only
if 9y9K0:ut; k; y; K0 is true in the closure of G and k is -maximal.9
Therefore, we may devise a similar query answering method as
for the crisp case by computing the closure, store it into a database
and then using SQL queries with the appropriate support of built-in
predicates and domain operations.

9 9y9K0:ut; k; y; k0 is true in the closure of G if and only if for some t0; k0 for all
triples in u t; k; t0; k0
there is a triple in clG that subsumes it and the built-in
predicates are true, where an annotated triple s : k1 subsumes s : k2 if and only if
k2  k1.

3.7. Queries with aggregates

As next, we extend the query language by allowing so-called
aggregates to occur in a query. Essentially, aggregates may be like
the usual SQL aggregate functions such as SUM, AVG, MAX, MIN.
But, we have also domain specific aggregates such as  and 

The following examples present some queries that can be ex-

pressed with the use of built-in queries and aggregates.

Example 3.6. Using a built-in aggregate we can pose a query that,
for each employee, retrieves his maximal time of employment for
any company in the following way:
qx; maxL   x; worksFor; y : k;

maxL :14 maxlengthk:

Here, the maxlength built-in predicate returns, given a set of temporal intervals, the maximal interval in the set.

Example 3.7. Suppose we are looking for employees that work for
some companies for a certain time period. We would like to know
the average length of their employment. Then such a query will be
expressed as
qx; avgL   x; worksFor; y : k;

GroupedByx;
avgL :14 AVG12lengthk

Essentially, we group by the employee, compute for each employee
the time he worked for a company by means of the built-in function
length, and compute the average value for each group. That is,
g 14 fht; t1i; . . . ;ht; tnig is a group of tuples with the same value t
for employee x, and value ti for y, where each length of employment
for ti is li (computed as length	), then the value of avgL for the
group G is 

ili=n.

Formally, let @ be an aggregate function with @ 2 fSUM; AVG;
MAX; MIN; COUNT;;
g then a query with aggregates is of the
form
qx; K; a   9y9K0:ux; K; y; K0;

GroupedByw;
a :14 @12fz

where w are variables in x, y or K and each variable in x and K occurs in w and any variable in z occurs in y or K0.

From a semantics point of view, we say that I is a model of (sat-

isfies) qt; k; a, denoted I  qt; k; a if and only if
a 14 @ 12a1; . . . ; ak where g 14 t; k; t0

k; k0
; . . . ; t; k; t0
is a group of k tuples with identical projection
on the variables in w; ut; k:; t0
r is true inI
and ar 14 ft where t is the projection of ht0
on the variables z:

1; k0

r; k0

ri
r; k0

Now, the notion of G  qt; K; a is as usual: any model of G is a
model of qt; K; a.

Eventually, we further allow to order answers according to

some ordering functions.

Example 3.8. Consider Example 3.7. We additionally would like to
order the employee according to the average length of employ-
ment. Then such a query will be expressed as
qx; avgL   x; worksFor; y : k;

GroupedByx;
avgL :14 AVG12lengthk;
OrderByavgL

GroupedByw;
a :14 12fz;
OrderByz

Formally, a query with ordering is of the form

qx; K; z   9y9K0:u x; K; y; K0
or, in case grouping is allowed as well, it is of the form
qx; K; z; a   9y9K0:ux; K; y; K0;

; OrderByz

From a semantics point of view, the notion of G  qt; K; z; a is as
before, but the notion of answer set has to be enforced with the fact
that the answers are now ordered according to the assignment to
the variable z. Of course, we require that the set of values over
which z ranges can be ordered (like string, integers, reals). In case
the variable z is an annotation variable, the order is induced by .
In case,  is a partial order then we may use some linearisation
method for posets, such as [38]. Finally, note that the additional
of the SQL-like statement LIMIT(k) can be added straightforwardly.

4. AnQL: Annotated SPARQL

Our introduced query language so far allows for conjunctive
queries. Languages like SQL and SPARQL allow to pose more complex queries including built-in predicates to filter solutions, advanced features such as negation or aggregates. In this section
we will present an extension of the SPARQL [11] query language,
called AnQL, that enables querying annotated graphs. We will begin by presenting some preliminaries on SPARQL.

4.1. SPARQL

SPARQL [11] is the W3C recommended query language for RDF.
A SPARQL query is defined by a triple Q = (P, G, V), where p is a graph
pattern and the dataset G is an RDF graph and V is the result form.
We will restrict ourselves to SELECT queries in this work so it is
sufficient to consider the result form V as a list of variables.

Remark 4.1. Note that, for presentation purposes, we simplify the
notion of datasets by excluding named graphs and thus GRAPH
queries. Our definitions can be straightforwardly extended to
named graphs and we refer the reader to the SPARQL W3C
specification [11] for details.

We base our semantics of SPARQL on the semantics presented
by Perez et al. [39], extending the multiset semantics to lists, which
are considered a multiset with default ordering. RDF triples, possibly with variables in subject, predicate or object positions, are
called triple patterns. In the basic case, graph patterns are sets of
triple patterns, also called Basic Graph Patterns (BGP). Let U, B, L
be defined as before and let V denote a set of variables, disjoint
from UBL. We further denote by var(P) the set of variables present
in a graph pattern p.

Definition 4.1 (Solution [11, Section 12.3.1]). Given a graph G and a
BGP p, a solution h for p over G is a mapping over a subset V of
var(P), i.e., h : V ! termG such that G  Ph where Ph represents
the triples obtained by replacing the variables in graph pattern p
according to h, and whre G  Ph means that any triple in Ph is
entailed by G. We call V the domain of h, denoted by dom(h). For
convenience, sometimes we will use the notation h 14 fx1=
t1; . . . ; xn=tng to indicate that hxi 14 ti, i.e., variable xi is assigned
to term ti.

Two mappings h1 and h2 are considered compatible if for all
x 2 domh1 \ domh2; h1x 14 h2x. We call the evaluation of a
BGP p over a graph G, denoted sPtG, the set of solutions.

Remark 4.2. Note that variables in the domain of h play the role of
distinguished variables in conjunctive queries and there are no
non-distinguished variables.

The notion of solution for BGPs is the same as the notion of an-

swers for conjunctive queries:

Proposition 4.1. Given a graph G and a BGP p, then the solutions of p
are the same as the answers of the query qvarP   P (where var(P)
is the vector of variables in p), i.e., ansG; q 14 sPtG.

We present the syntax of SPARQL based on [39] and present
graph patterns similarly. A triple pattern (s, p, o) is a graph pattern
where s, o 2 ULV and p 2 UV.10 Sets of triple patterns are called Basic
Graph Patterns (BGP). A generic graph pattern is defined in a recursive
manner: any BGP is a graph pattern; if p and P0 are graph patterns, R
is a filter expression (see [11]), then P AND P0;P OPTIONAL P0;
P UNION P0;P FILTER R are graph patterns. As noted in Remark
4.1 we do not consider GRAPH patterns.

Evaluations of more complex patterns including FILTERs, OPTIONAL patterns, AND patterns, UNION patterns, etc. are defined
by an algebra that is built on top of this basic graph pattern matching (see [11,39]).

Definition 4.2 (SPARQL Relational Algebra). Let X1 and X2 be sets
of mappings:

X1 ffl X2 14 fh1 [ h2 j h1
2 X1; h2 2 X2; h1 and h2 compatibleg
X1 X2 14 fh j h 2 X1 or h 2 X2g
X1  X2 14 fh1 2 X1 j forall h2 2 X2;
X1  X2

h1 and h2 not compatibleg

X2 14 X1 ffl X2

X1

Definition 4.3 (Evaluation [39, Definition 2.2]). Let s = (s, p, o) be a
triple pattern, P; P1; P2 graph patterns and G an RDF graph, then
the evaluation s 	 tG is recursively defined as follows:
sttG 14 fh j domh 14 varP and G  shg
sP1 AND P2tG 14 sP1tG ffl sP2tG
sP1 UNION P2tG 14 sP1tG
sP2tG
sP1 OPTIONAL P2tG 14 sP1tG
sP FILTER RtG 14 fh 2 sPtG j Rh is trueg

sP2tG

Let R be a FILTER11 expression, u; v 2 V [ UBL. The valuation of R

on a substitution h, written Rh, is true if:

(1) R 14 BOUNDv with v 2 domh;
(2) R 14 isBLANKv with v 2 domh and hv 2 B;
(3) R 14 isIRIv with v 2 domh and hv 2 U;
(4) R 14 isLITERALv with v 2 domh and hv 2 L;
(5) R 14 u 14 v with u; v 2 domh [ UBL ^ hu 14 hv;
(6) R 14 :R1 with R1h is false;
(7) R 14 R1 _ R2 with R1h is true or R2h is true;
(8) R 14 R1 ^ R2 with R1h is true and R2h 9m.
Rh yields an error (denoted e), if:
(1) R 14 isBLANKv, R 14 isIRIv, or R 14 isLITERALv and

v R domh [ T;

10 We do not consider blank nodes in triple patterns since they can be considered as
variables.
11 For simplicity, we will omit from the presentation FILTERs such as comparison
>, 6, P), data type conversion and string functions and refer the
operators (<,
reader to [11, Section 11.3] for details.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295
 : 122000; 2009
 : 121999; 2005
 : 122005; 2010

(2) R 14 u 14 v with u R domh [ T or v R domh [ T;
(3) R 14 :R1 and R1h 14 e;
(4) R 14 R1 _ R2 and R1h  > and R2h  > and R1h 14 e or
(5) R 14 R1 ^ R2 and R1h 14 e or R2h 14 e.
Otherwise Rh is false.

R2h 14 e;

In order to make the presented semantics compliant with the
SPARQL specification [11], we need to introduce an extension to
consider unsafe FILTERs (also presented in [40]):

Definition 4.4 (OPTIONAL with FILTER Evaluation). Let P1; P2 be
graph patterns R a FILTER expression. A mapping h is in
sP1 OPTIONAL P2 FILTER RtDS if and only if:
 h 14 h1 [ h2, s.t. h1 2 sP1tG; h2 2 sP2tG are compatible and Rh is
true, or
 h 2 sP1tG and 8h2 2 sP2tG; h and h2 are not compatible, or
 h 2 sP1tG and 8h2 2 sP2tG s.t. h and h2 are compatible, and Rh3 is
false for h3 14 h [ h2.

4.2. AnQL

We are now ready to extend SPARQL for querying Annotated
RDF. We call the novel query language AnQL. For the rest of this
section we fix a specific annotation domain, D 14 hL;; 
;?;>i, as
defined in Section 3.2.

4.2.1. Syntax

We take inspiration on the notion of conjunctive annotated
queries discussed in Section 3.6. A simple AnQL query is defined 
analogously to a SPARQL query  as a quadruple Q = (P, G, V,A) with
the differences that (1) G is an Annotated RDF graph; (2) we allow
annotated graph patterns as presented in Definition 4.5 and (3) A is
the set of annotation variables taken from an infinite set A (distinct
from V). We further denote by avar(P) the set of annotation variables present in a graph pattern p.

Definition 4.5 (Annotated graph pattern). Let k be an annotation
value from L or an annotation variable from A. We call k an
annotation label. Triple patterns in annotated AnQL are defined
the same way as in SPARQL. For a triple pattern s, we call s : k
an annotated triple pattern and sets of annotated triple patterns
are called Basic Annotated Patterns (BAP). A generic annotated
graph pattern is defined in a recursive manner: any BAP is an
if p and P0 are annotated graph
annotated graph pattern;
patterns,
then
P AND P0;P OPTIONAL P0;P UNION P0;P FILTER R
are
annotated graph patterns.

expression

filter

(see

[11]),

is

Example 4.1. Suppose we are looking for Ebay employees during
some time period and that optionally owned a car during that per-
iod. This query can be posed as follows:

SELECT ?p ?l ?c WHERE {

(?p type ebayEmp) : ?l
OPTIONAL{(?p hasCar ?c) : ?l}

Assuming our example dataset from Fig. 1 extended with the

following triples:

toivo; type; paypalEmp
toivo; hasCar; peugeot
toivo; hasCar; renault


we will get the following answers:
h1 14 f?p=toivo; ?l=122002; 2009g
h2 14 f?p=toivo; ?l=122002; 2005; ?c=peugeotg
h3 14 f?p=toivo; ?l=122005; 2009; ?c=renaultg:

The first answer corresponds to the answer in which the
OPTIONAL pattern is not satisfied, so we get the annotation value
[2002,2009] that corresponds to the time toivo is an Ebay
employee. In the second and third answers, the OPTIONAL pattern
is also matched and, in this case, the annotation value is restricted
to the time when Toivo is employed by Paypal and has a car.

Note that  as we will see  this first query will return as a result for the annotation variable the periods where a car was owned.

Example 4.2. A slightly different query can be the employees of
Ebay during some time period and optionally owned a car at some
point during their stay. This query  which will rather return the
time periods of employment  can be written as follows:

SELECT ?p ?l ?c WHERE {

(?p type ebayEmp) : ?l
OPTIONAL {(?p hasCar ?c) : ?l2
FILTER (?l2  ?l)}

Using the input data from Example 4.1, we obtain the following

answers:
h1 14 f?p=toivo; ?l=122002; 2009g
h2 14 f?p=toivo; ?l=122002; 2009; ?c=renaultg
In this example the FILTER behaves as in SPARQL by removing from
the answer set the mappings that do not make the FILTER expression true.

This query also exposes the issue of unsafe filters, noted in [40]
and we presented the semantics to deal with this issue in Definition 4.4.

4.2.2. Semantics

We are thus ready to define the semantics of AnQL queries by
extending the notion of SPARQL BGP matching. As for the SPARQL
query language, we are going to define the notion of solutions for
BAP as the equivalent notion of answers set of annotated conjunctive queries. Just as matching BGPs against RDF graphs is at the
core of SPARQL semantics, matching BAPs against Annotated RDF
graphs is the heart of the evaluation semantics of AnQL.

We extend the notion of substitution to include a substitution of
annotation variables in which we do not allow any assignment of
an annotation variable to ? (of the domain d). An annotation value
of ?, although it is a valid answer for any triple, does not provide
any additional information and thus is of minor interest. Furthermore this would contribute to increasing the number of answers
unnecessarily.

Definition 4.6 (BAP evaluation). Let p be a BAP and G an Annotated
RDF graph. We define evaluation sPtG as the list of substitutions
that are solutions of p, i.e., sPtG 14 fh j G  hPg, and where G  h(P)
means that any annotated triple in h(P) is entailed by G.

As for SPARQL, we have:

Proposition 4.2. Given an annotated graph G and a BAP p, the
solutions of p are the same as the answers of the annotated query
qvarP   P (where var(P) is the vector of variables in p), i.e.,
ansG; q 14 sPtG.

For the extension of the SPARQL relational algebra to the annotated case we introduce  inspired by the definitions in [39]  definitions of compatibility and union of substitutions:

Definition 4.7 (
-compatibility). Two substitutions h1 and h2 are

-compatible if and only if (i) h1 and h2 are compatible for all the
non-annotation variables, i.e., h1x 14 h2x for any non-annotation
variable x 2 domh1 \ domh2; and (ii) h1k 
 h2k  ? for any
annotation variable k 2 domh1 \ domh2.

Definition 4.8 (
-union of substitutions). Given two 
-compatible
substitutions h1 and h2, the 
-union of h1 and h2, denoted h1 
 h2, is
as h1 [ h2, with the exception that any annotation variable
k 2 domh1 \ domh2 is mapped to h1k 
 h2k.

We now present the notion of evaluation for generic AnQL

graph patterns. This consists of an extension of Definition 4.3:

Definition 4.9 (Evaluation, extends [39, Definition 2]). Let p be a
BAP, P1; P2 annotated graph patterns, G an annotated graph and R a
filter expression, then the evaluation s 	 tG, i.e., set of answers,12 is
recursively defined as:

g,

and

sPtG 14 h j domh 14 varP and G  hP
sP1 AND P2tG 14 h1 
 h2 j h1 2 sP1tG; h2 2 sP2tG; h1

h2 
 compatibleg,
sP1 UNION P2tG 14 sP1tG [ sP2tG,
sP1 FILTER RtG 14 h j h 2 sP1tG and Rh is true
sP1 OPTIONAL P212RtG 14 fh j and h meets one of the following
conditions:
h 14 h1 
 h2 if h1 2 sP1tG; h2 2 sP2tG; h1 and h2
-compatible,
1.
and Rh is true;
h 14 h1 2 sP1tG and 8h2 2 sP2tG such that h1 and h2 
-com-
patible, Rh1 
 h2 is true, and for all annotation variables
k 2 domh1 \ domh2; h2k  h1k;
h 14 h1 2 sP1tG and 8h2 2 sP2tG such that h1 and h2 
-com-
patible, Rh1 
 h2 is false.

2.

3.

Let R be a FILTER expression and x; y 2 A [ L, in addition to the
FILTER expressions presented in Definition 4.3 we further allow
the expressions presented next. The valuation of R on a substitution h, denoted Rh is true if:13

(9) R 14 x  y with x; y 2 domh [ L ^ hx  hy;

(10) R 14 pz with pzh 14 true if and only if phz 14 true,

where p is a built-in predicate.
Otherwise Rh is false.

In the FILTER expressions above, a built-in predicate p is any n-
ary predicate p, where ps arguments may be variables (annotation
and non-annotation ones), domain values of d, values from UL, p
has a fixed interpretation and we assume that the evaluation of
the predicate can be decided in finite time. Annotation domains
may define their own built-in predicates that range over annotation values as in the following query:

12 Strictly speaking, we consider sequences of answers  note that SPARQL allows
duplicates and imposes an order on solutions, cf. Section 4.2.3 below for more
discussion  but we stick with set notation representation here for illustration.
Whenever we mean real sets where duplicates are removed we write f. . . gDISTINCT.
13 We consider a simple evaluation of filter expressions where the error result is
ignored, see [11, Section 11.3] for details.

Example 4.3. Consider our example dataset from Fig. 1 and that
we want to know where chadHurley was working before 2005.
This query can be expressed in the following way:

SELECT ?city WHERE {

(chadHurley worksFor ?comp) : ?l
FILTER(before(?l, [2005]))

Remark 4.3. For practical convenience, we retain in s 	 tG only
domain maximal answers. That is, let us define h0  h if and only
if (i) h0  h; (ii) domh 14 domh0; (iii) hx 14 h0x for any nonannotation variable x; and (iv) h0k  hk for any annotation variable k. Then, for any h 2 sPtG we remove any h0 2 sPtG such that
h0  h.

Remark 4.4. Please note that the cases for the evaluation of the
OPTIONAL are compliant with the SPARQL specification [11], covering the notion of unsafe FILTERs as presented in [40]. However,
there are some peculiarities inherent to the annotated case. More
specifically case 2 introduces the side effect that annotation variables that are compatible between the mappings may have different values in the answer depending if the OPTIONAL is matched or
not. This is the behaviour demonstrated in Example 4.1.

The following proposition shows that we have a conservative

extension of SPARQL.

Proposition 4.3. Let Q 14 P; G; V be a SPARQL query over an RDF
graph G. Let G0 be obtained from G by annotating triples with >. Then
sPtG under SPARQL semantics is in one-to-one correspondence to sPtG0
under AnQL semantics such that for any h 2 sPtG there is a h0 2 sPtG0
with h and h0 coinciding on varP.

4.2.3. Further Extensions of AnQL

In this section we will present extensions of Definition 4.9 to
include variable assignments, aggregates and solution modifiers.
These
are
to the ones presented in
Section 3.7.

extensions

similar

Definition 4.10. Let p be an annotated graph pattern and G an
annotated graph, the evaluation of an ASSIGN statement is defined
as:
sP ASSIGN fz AS ztG 14 fh j h1 2 sPtG;
h 14 h112z=fh1zg

where


if z R domh

h12z=t 14 h [ fz=tg
h n fz=t0g
Essentially, we assign to the variable z the value fh1z, which
is the evaluation of the function fz with respect to a substitution
h1 2 sPtG.

 [ fz=tg otherwise:

Example 4.4. Using a built-in function we can retrieve for each
employee the length of employment for any company:

SELECT ?x ?y ?z WHERE {
(?x worksFor ?y):?l
ASSIGN length(?l) AS ?z

Here, the length built-in predicate returns, given a set of

temporal intervals, the overall total length of the intervals.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

Remark 4.5. Note that this definition is more general than
SELECT expr AS ?var project expressions in current SPARQL 1.1
[41] due to not requiring that the assigned variable be unbound.
We introduce the ORDERBY clause where the evaluation of a
sP ORDERBY ?xtG statement is defined as the ordering of the solutions  for any h 2 sPtG  according to the values of h(?x). Ordering
for non-annotation variables follows the rules in [11, Section 9.1].
Similarly to ordering in the query answering setting, we require
that the set of values over which x ranges can be ordered and some
linearisation method for posets may be applied if necessary, such
as [38]. We can further extend the evaluation of AnQL queries with
aggregate functions
@ 2 fSUM; AVG; MAX; MIN; COUNT;;

as follows:

Definition 4.11. The evaluation of a GROUPBY statement is
defined as14:
sP GROUPBYw @fz ASatG 14fh j h1in sPtG;

h 14 h1jw12ai=@ifihizigDISTINCT

where the variables ai R varP; zi 2 varP and none of the GROUPBY variables w are included in the aggregation function variables zi.
Here, we denote by hjw the restriction of variables in h to variables in
w. Using this notation, we can also straightforwardly introduce pro-
jection, i.e., sub-SELECTs as an algebraic operator in the language
covering another new feature of SPARQL 1.1:
sSELECT V fPgtG 14 fh j h1 in sPtG; h 14 h1jvg:

Remark 4.6. Please note that the aggregator functions have a
domain of definition and thus can only be applied to values of their
respective domain. For example, SUM and AVG can only be used on
numeric values, while MAX, MIN are applicable to any total order.
Resolution of type mismatches for aggregates is currently being
defined in SPARQL 1.1 [41] and we aim to follow those, as soon
as the language is stable. The COUNT aggregator can be used for
any finite set of values. The last two aggregation functions, namely
 and 
, are defined by the annotation domain and thus can be
used on any annotation variable.

Remark 4.7. Please note that, unlike the current SPARQL 1.1 syn-
tax, assignment, solution modifiers (ORDER BY, LIMIT) and aggregation are stand-alone operators in our language and do not
need to be tied to a sub-SELECT but can occur nested within any
pattern. This may be viewed as syntactic sugar allowing for more
concise writing than the current SPARQL 1.1 [41] draft.

Example 4.5. Suppose we want to know, for each employee, the
average length of their employments with different employers.
Then such a query will be expressed as:

SELECT ?x ?avgL WHERE {

(?x worksFor ?y) : ?l
GROUPBY(?x)
AVG(length(?l)) AS ?avgL

Essentially, we group by the employee, compute for each
employee the time he worked for a company by means of the builtin function length, and compute the average value for each group.

That is, if g 14 fht; t1i; . . . ;ht; tnig is a group of tuples with the same
value t for employee x, and value ti for y, where each length of
employment for ti is li (computed as length	), then the value of
avgL for the group G is

ili

=n.

Proposition 4.4. Assuming the built-in predicates are computable in
finite time, the answer set of any AnQL is finite and can also be computed in finite time.

This proposition can be demonstrated by induction over all the

constructs we allow in AnQL.

4.3. Constraints vs. filters

Please note that FILTERs do not act as constraints over the
query. Given the data from our dataset example and for the following query:

SELECT ?l1 ?l2 WHERE {

(?p type youtubeEmp) : ?l1.
(steveChen type youtubeEmp) : ?l2

with an additional constraint that requires ?l1 to be before ?l2,

we could expect the answer
f?l1=122005; 2010; ?l2=122011; 2011g:
This answer matches the following triples of our dataset:


and satisfies the proposed constraint. However, we require maximality of the annotation values in the answers, which in general,
do not exist in presence of constraints. For this reason, we do not allow general constraints.

steveChen; type; youtubeEmp
chadHurley; type; youtubeEmp

 : 122005; 2011
 : 122005; 2010

4.4. Union of annotations

The SPARQL UNION operator may also introduce some discussion when considering shared annotations between graph pat-
terns. Take for example the following query:

SELECT ?l WHERE {

{(chadHurley type youtubeEmp) : ?l1}

(chadHurley type paypalEmp) : ?l

and assume our dataset from Fig. 1 as input. Considering the
temporal domain, the intuitive meaning of the query is retrieve
all time periods when chadHurley was an employee of Youtube
or PayPal. In the case of UNION patterns the two instances of
the variable ?l are treated as two different variables. If the intended
query would rather require treating both instances of the variable
?l as the same, for instance to retrieve the time periods when chadHurley was an employee of either Youtube or PayPal but assuming
we may not have information for one of the patterns, the query
should rather look like:

SELECT ?l WHERE {

14 In the expression, @fz AS a is a concise representation of n aggregations of the
form @ifizi AS ai.

{(chadHurley type youtubeEmp):?l1}

{(chadHurley type paypalEmp):?l2}
ASSIGN ?l1 _ ?l2 as ?l

(a)

(c)

(b)

(d)

(e)

Fig. 2. Temporal relations.

where _ represents the domain specific built-in predicate for union
of annotations.

5. On primitive domains and their combinations

In this section we discuss some practical issues related to (i) the
representation of the temporal domain (Section 5.1); (ii) the combination of several domains into one compound domain (Sec-
tion 5.2); (iii) the integration of differently annotated triples or
non-annotated triples in the data or query (Section 5.3).

5.1. Temporal issues

Let us highlight some specific issues inherent to the temporal
domain. Considering queries using Allens temporal relations [42]
(before, after, overlaps, etc.) as allowed in [4], we can pose queries
like find persons who were employees of PayPal before toivo.
This query raises some ambiguity when considering that persons
may have been employed by the same company at different disjoint intervals. We can model such situations  relying on sets of
temporal intervals modelling the temporal domain. Consider our
dataset triples from Fig. 1 extended with the following triple:
toivo; type; paypalEmp : f121999; 2004;122006; 2008g:

Tappolet and Bernstein [4] consider this triple as two triples with
disjoint intervals as annotations. For the following query in their
language sSPARQL:

SELECT ?p WHERE {

[?s1,?e1] ?p type youtubeEmp.
[?s2,?e2] chadHurley type youtubeEmp.
[?s1,?e1] time:intervalBefore [?s2,?e2]

We would get chadHurley as an answer although toivo was
already working for PayPal when chadHurley started. This is
one possible interpretation of before over a set of intervals. In
AnQL we could add different domain specific built-in predicates,
representing different interpretations of before. For instance,
we could define binary built-ins (i) beforeAny (?A1,?A2) which is
true if there exists any interval in annotation ?A1 before an interval

in ?A2, or, respectively, a different built-in beforeAll (?A1,?A2)
which is only true if all intervals in annotation ?A1 are before
any interval in ?A2. Using the latter, an AnQL query would look
as follows:

SELECT ?p WHERE {

(?p type youtubeEmp):?l1.
(toivo type youtubeEmp):?l2.
FILTER(beforeAll(?l1,?l2))

This latter query gives no result, which might comply with peoples understanding of before in some cases, while we also have
the choice to adopt the behaviour of [4] by use of beforeAny instead.
More formally, if we consider an Allen relation r that holds between individual intervals, we can define a relation r over sets of
intervals in five different ways:

Definition 5.1. Let T1 and T2 be two non-empty sets of disjoint
intervals. We define the following relations:

 r99 14 fhT1; T2i j 9t1 2 T1;9t2 2 T2 such that ht1; t2i 2 rg;
 r98 14 fhT1; T2i j 9t1 2 T1;8t2 2 T2 such that ht1; t2i 2 rg;
 r89 14 fhT1; T2i j 8t1 2 T1;9t2 2 T2 such that ht1; t2i 2 rg;
 r98^89 14 r98 \ r89;
 r88 14 fhT1; T2i j 8t1 2 T1;8t2 2 T2 such that ht1; t2i 2 rg.

These relations can be compared with each others according to
set inclusion, as shown in Fig. 3. We illustrate them by the following examples, taking the Allen relation before:

Example 5.1. Fig. 2is an example of time intervals that make each
of the relations introduced in Definition 5.1 true for the before Allen
relation.

It should be noticed that if one sticks to one choice of quantifier,
the resulting set of relations does not form a proper relation alge-
bra. Indeed, it is easy to see that, in the first 3 cases, the relations
are not disjoint. For instance, two sets of intervals can be involved
in both a before99 and an after99 relation. On the other hand, the last
4 cases are incomplete, that is, there are pairs of sets of intervals
that cannot be related with any of the r98; r89; r88 or r98^89.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

 : h122005; 2009; wikipediai


skypeEmp; sc; ebayEmp
skypeEmp; sc; ebayEmp : h121958; 2012; wrongi
Using a point-wise aggregation method, the result would be:
skypeEmp; sc; ebayEmp : h121958; 2012;

wikipedia _ wrongi

which entails:
skypeEmp; sc; ebayEmp : h121958; 2012; wikipediai:
Again, the problem is that provenance here does not define the
provenance of the temporal annotation and the temporal annotation is not local to a certain provenance.

In order to match the intuition, we devise a systematic construction that defines a new compound domain out of two existing
domains.

Fig. 3. Hierarchy of relations.

5.2. Extensions to multiple domains

5.2.2. Improved formalisation

Since annotations in our framework can range over different domains in different applications, one may be interested in combining several annotation domains such as annotating triples with a
temporal term and a truth degree or degree of trust, etc. In [12],
we proposed an approach for easily combining multiple domains,
based on the pointwise extension of domain operators to a product
of domains. Here, we criticise this approach and propose a revised
approach that better fits the intuition.

5.2.1. Former approach and criticism

1; . . . ; kni0 14 hk1 
 k0

The approach described in [12] is the following. In general,
assuming having domains D1; . . . ; Dn, where Di 14 hLi;i;
i;?i; >ii,
we may build the domain D 14 D1 
 			 
 Dn 14 hL; ;
;?;>i, where
L 14 L1 
 			 
 Ln;?14 h?1; . . . ;?ni;> 14 h>1; . . . ;>ni and the meet
and join operations 
 and  are extended pointwise to L, e.g.,
hk1; . . . ; kni 
 hk0
SkypeCollab; sc; EbayCollab : h122009; 2011; 0:3i
may indicate that during 20092011, the collaborators of Skype
were also considered collaborators of Ebay to degree 0.3 (here we
combine a temporal domain and a fuzzy domain). The interesting
point of our approach is that the rules of the deductive systems
need not be changed, nor the query answering mechanism (except
to provide the support to compute 
 and  accordingly).

ni. For instance,

1; . . . ; kn 
 k0

The problem with this approach is that the annotations are
dealt with independently from each others. As a result, e.g., the
truth value 0:3 does not apply to the time range [2009,2011]. This
problem is made very apparent when one observes the unexpected
consequences of our  operator on such a combination:
SkypeCollab; sc; EbayCollab : h122005; 2009; 1i
SkypeCollab; sc; EbayCollab : h122009; 2011; 0:3i

Applying the point-wise operation , this leads to the conclusion:
SkypeCollab; sc; EbayCollab : h122005; 2011; 1i:
This defies the intuition that, between 2005 and 2009, Skype collaborators where also Ebay employees (collaborate to degree 1), but
from 2009 to 2011 Skype collaborators were Ebay collaborators to
the degree 0.3. The pointwise aggregation does not follow this intuition and levels up everything. In the example above, we would like
to say that the fuzzy value itself has a duration, so that the temporal
interval corresponds more to an annotation of a quadruple. Note
that this problem is not specific to the combination of time and
fuzziness. We observe a similar issue when combining provenance,
for instance, with other domains:

In this section, we propose a generic construction that builds an
annotation domain by combining two predefined domains in a systematic way. To achieve this, we will assume the existence of two
annotation domains D1 14 hL1;1;
1; ?1;>1i and D2 14 hL2;2;

2;?2;>2i which will be instantiated in examples with the temporal domain for D1 (abbreviated Dt) and either the fuzzy domain (Df)
or the provenance domain (Dp) for D2. We denote the temporal and
fuzzy combination time + fuzzy, and the temporal and provenance
combination time + provenance.

5.2.2.1. Intuition and desired properties. In our former approach, we
remarked that some information is lost in the join operation. Considering time + fuzzy, we see that the join should represent temporary changes in the degree of truth of the triple. Yet, it is clear that
representing such changes cannot be done with a simple pair
(intervals,value). So, as a first extension of our previous naive solu-
tion, we suggest using sets of pairs of primitive annotations, as
exemplified below
SkypeCollab; sc; EbayCollab : fh122005; 2009; 1i;
h122009; 2011; 0:3ig

Starting from this, we devise an annotation domain that correctly
matches the intuitive meaning of the compound annotations. The
annotated triple above can be interpreted as follows: for each pair
in the annotation, for each time point in the temporal value of the
pair, the triple holds to at least the degree given by the fuzzy value
of the pair. The time + provenance combination is interpreted anal-
ogously, except that the triple holds (at least) in the context given
by the provenance value of the pair.

This interpretation of the compound annotations implies that
multiple sets of pairs can convey the exact same information. For
example,
the following time + fuzzy annotated triples are
equivalent:

SkypeCollab; sc; EbayCollab
SkypeCollab; sc; EbayCollab :

fh122005; 2009; 1ig
fh122005; 2009; 0:3i;
h122005; 2009; 1ig

From this observation, we postulate the following desired property:

Property 1. For all x 2 L1; y; y0 2 L2 and for all qdf
s : fhx; yi;hx; y0ig is semantically equivalent to s : fhx; y2y0ig.

triples s,

Consequently, it is always possible to assign a unique element
y 2 L2 to a given element of L1. Thus, an arbitrary set of pairs in
L1 
 L2 is equivalently representable as a partial mapping from L1
to L2. Additionally, given a certain time interval, we can easily compute the maximum known degree to which a time + fuzzy anno-
tated
annotation

instance, with

holds.

the

triple

For

fh122005; 2009; 0:3i;h122008; 2011; 1ig, we can assign the degree 1
to any subset of [2008,2011]; the degree 0.3 to any subset of
[2005,2009] which is not contained in [2008,2009]; the degree 0
to any other temporal value.

This remark justifies that we can consider a compound annotation A as a total function from L1 and L2. From now on, whenever A
is a finite set of pairs, we will denote by A the function that maps
elements of L1 to an element of L2 that, informally, minimally satisfies the constraints imposed by the pairs in A. This is formalised
below. For instance, if A 14 fh122005; 2009; 0:3i;h122008; 2011; 1ig,
then:

Ax 14

if x #122008; 2011

0:3 if x #122005; 2009 and x U122008; 2009

otherwise

8><>:

Whereas in this example, for the time + fuzzy domain the value
of A for a particular interval seems to follow quite intuitively, let us
next turn to the less obvious combination of time + provenance.
Here, we postulate that the following triples
s : f

s : f

s : f

h122005; 2009; wikipediai;
h122008; 2011; wrongig
h122005; 2007; wikipediai;
h122007; 2009; wikipediai;
h122008; 2011; wrongig
h122005; 2008; wikipediai;
h122008; 2009; wikipedia _ wrongi;
h122009; 2011; wrongig;

represent in fact equivalent annotations. Let us check the intuition
behind this on a particular interval, [2005,2009], which for the
first triple has unambigously associated the provenance value
wikipedia. Considering the second annotated triple, we observe
that the provenance wikipedia can likewise be associated with
the interval [2005,2009] because this provenance is associated
with two intervals that  when joined  cover the time span
[2005,2009]. In the case of the last annotated triple, the provenance wikipedia_wrong means that the triple holds in wikipedia as well as in wrong (notice that x_y means that the assertion
holds in x and in y likewise, see Section 3.4.3 for details). Intui-
tively, we expect for the last triple that the provenance associated
with the joined interval [2005,2009] is obtained from applying the
meet operator over the respective provenance annotations wikipedia (for
[2005,2008]) and wikipe-
dia_wrong
i.e.,
interval
(wikipedia_wrong)^ wikipedia which  again  is equivalent
to wikipedia in the provenance domain. Besides, considering
now the interval [2005,2011], the triple is true in either wikipe-
dia.org or wrong, which is modelled as (wikipedia^wrong) in
the provenance domain. Let us cast this intuition into another
property we want to ensure on the function A:

the partial
the
(for

interval
partial

[2008,2009]),

Property 2. Given a set of annotation pairs A, for all x0 2 L1 whenever
9J # A with x01

1hx;yi2Jx, we have Ax02

2hx;yi2Jy.

Our goal in what follows is to characterise the set of functions
associated with a finite set of pairs, that is fA j A # L1 
 L2g, in a
manner such that Property 1 and Property 2 are satisfied.

5.2.2.2. Formalisation. As mentioned before, a compound annotation can be seen as a function that maps values of the first domain
to values of the second domain. In order to get the desired properties above established, we restrict this function to a particular type
of functions that we call quasihomomorphism because it closely
resembles a semiring homomorphism.

Definition 5.2 (Quasihomomorphism). Let f be a function from
D1 14 hL1;1;
1;?1; >1i to D2 14 hL2;2;
2; ?2;>2i. f is a quasihomomorphism of domains if and only if
(i)
fx1y2fx
2fy and (ii) fx
1y2fx2fy.

for all x; y 2 L1:

We now use quasihomomorphisms to define  on an abstract

level  a compound domain of annotations.

Definition 5.3 (Compound annotation domain). Given two primitive annotation domains D1 and D2, the compound annotation
domain of D1 and D2 is the tuple hL12;12;
12;?12;>12i defined as
follows:

 L12 is the set of quasihomomorphisms from D1 to D2;
 ?12 is the function defined such that for all x 2 L1;?12x 14 ?2;

 >12 is the function defined such that for all x 2 L1;>12x 14 >2;
 for all k; l 2 L12, for all x 2 L1;k12lx 14 kx2lx;
 for all k; l 2 L12, for all x 2 L1;k
12lx 14 kx
2lx;

This definition yields again a valid RDF annotation domain, as

stated in the following proposition:

Proposition 5.1. hL12;12;
12;?12;>12i is an idempotent, commutative semiring and 12 is >12-annihilating.

Remark 5.1. It can be noticed that, a priori, the order of the primitive annotations matters
compound
annotations.

to the definition of

Quasihomomorphisms are abstract values that may not be representable syntactially. By analogy with XML datatypes [43], we
can say that they represent the value space of the compound do-
main. In the following, we want to propose a finite representation
of some of these functions. Indeed, as we have seen in the examples above, we intend to represent compound annotations just as
finite sets of pairs of primitive annotations. Thus, continuing the
analogy, the lexical space is merely containing finite sets of pairs
of primitive annotation values. To complete the definition, we just
have to define a mapping from such finite representation to a corresponding quasihomomorphism. That is, we have to define the
lexical-to-value mapping.

Consider again the (primitive) domains D1 and D2 and let

A # L1 
 L2 be a finite set of pairs of primitive annotations. We define the function A : D1 ! D2 as follows15:
8z 2 L1; Az 14 lub b

hx;yi2J

y j J # A and z1

hx;yi2J

Theorem 5.2. If A # L1 
 L2 is a finite set of pairs of primitive
annotations, then A is a quasihomomorphism.

The proof is mostly a sequence of manipulation of notations

with little subtlety, so we refer the reader to A for details.

Now, we know that we can translate an arbitrary finite set of
pairs of primitive annotations into a compound annotation. How-
ever, using arbitrary sets of pairs is problematic in practice for
two reasons: (1) several sets of pairs have equivalent meaning,16
that is, the function induced by the two sets are identical; (2) the approach does neither gives a programmatic way of computing the
operations (
12;12) on compound annotations, nor gives us a tool
to finitely represent the results of these operations.

Thus, we next turn towards how to choose a canonical finite
representative for a finite set annotation pairs. To this end, we need

15 Note that as D2 is an annotation domain, the lub operation is well defined.
16 Particularly, we note that there can still be an infinite set of finite representations
of the same compound annotation.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

a normalising function N : 2L1
L2 ! 2L1
L2
for all
# L1 
 L2; A 14 A0 if and only if NA 14 NA0. This will in turn
A; A0
also allow us to define the operations 12 and 
12 over the set of
normalised annotations.

such that

5.2.2.3. Normalisation. We propose a normalisation algorithm
based on two main operations:

Saturate: informally, the saturate function increases the size of a
set of pairs of annotations by adding any redundant
pairs that result from the application of 
 and  to values existing in the initial pairs;

Reduce: takes the output of the saturation step and removes

subsumed pairs.

In particular, the Saturate algorithm is adding pairs of annotations to the input such that in the end, all primitive annotations
that can be produced by the use of existing values and operators

 and  appear in the output. The algorithm for Saturate, Reduce
and Normalise are given in Algorithms 13, respectively.

If the operations 
1 and 
2 are idempotent, Algorithm 1 ensures that given a value x 2 L1 that is the result of using operators

1 and 1 on any number of primitive annotations of L1 appearing
in A, then there exists y 2 L2 such that hx; yi exists in the output of
Saturate. Similarly, given y 2 L2 that can be obtained from combinations of values of L2 appearing in A and operators 
2 and 2, then
there exists x 2 L2 such that hx; yi exists in the output of Saturate.

Algorithm 1. Saturate (A)
Input: A # L1 
 L2 finite
Output: Saturate(A)

R :14 ;;
forall X # 2A do

R :14 R [ fha

J2X
R :14 R [ fhb

J2X

hx;yi2J

hx;yi2J

x; b

J2X
x; a

J2X

hx;yi2J

hx;yi2J

yig;
yig;

return R;

Example 5.2. Consider the following time + fuzzy annotation:
fh122000; 2005; 0:7i;h122002; 2008; 0:5ig
Application of the function saturate gives the following result:
fh122000; 2005; 0:7i;h122002; 2008; 0:5i;
h122000; 2008; 0:35i;h122002; 2005; 0:7i;
h122000; 2005; 0:49i;h122002; 2005; 0:49ig:

Now we notice that this can introduce redundant information,
which should be eliminated. This is the goal of the function Reduce
which is defined by Algorithm 2.

Algorithm 2: Reduce(A)
Input: A # L1 
 L2 finite and saturated
Output: Reduce(A)

while 9hx; yi 2 A; 9hx0; y0i 2 A n fhx; yig such that
x1x0 and y2y0 do
R :14 R n fhx; yig;
while 9hx; yi 2 A such that x 14 ?1 or y 14 ?2 do

R :14 R n fhx; yig;

return R;

Example 5.3. Considering Example 5.2 the output of the Saturate
algorithm above, the Reduce function gives the following result:
fh122000; 2005; 0:7i;h122002; 2008; 0:5i;
h122000; 2008; 0:35ig

Algorithm 3. Normalise(A)
Input: A # L1 
 L2 finite
Output: Normalise(A)

return Reduce(Saturate(A));

the

following

5.4. Consider

time + provenance

Example
annotation:
fh121998; 2006; wikipediai;h122001; 2011; wrongig;
which normalises to:
fh121998; 2011; wikipedia ^ wrongi;
h121998; 2006; wikipediai;h122001; 2011; wrongi;
h122001; 2006; wikipedia _ wrongig
Note that the pair h122001; 2006; wikipedia _ wrongi is introduced
by Line 6 of Algorithm 1 and is not discarded during the reduction
phase.

The following property can be shown:

Proposition 5.3. If D1 14 hL1;1;
1;?1;>1i is a lattice then, for all
A # L1 
 L2 finite, A 14 NormaliseA.

Notice that we must impose that the first primitive domain of
annotation is a lattice for the normalisation to work, that is, we
need that z1x and z1y iff z1x
1y. Details of the proof can be
found in A.

The following theorem shows that the normalisation is actually

unique up to equivalence of the corresponding functions.

Theorem 5.4. If D1 14 hL1;1;
1;?1;>1i is a lattice then, for all
A; B # L1 
 L2 finite then A 14 B () NormaliseA 14 NormaliseB.

Again, to improve readability, we put the proof in A.

5.2.2.4. Operations on normalised annotations. We can now present
the operations 12 and 
12 on normalised finite sets of pairs.
 A12B 14 NormaliseA [ B;

 A
12B 14 Normalisefhx
1x0; y
2y0i j hx; yi;hx0; y0i 2 A 
 Bg.

Finally, with the proposed representation and operations, we
devised a systematic approach to compute combination of domains using existing primitive domains. This implies that an
implementation would not need to include operators that are specific to a given combination, as long as programmatic modules exist for the primitive annotation domains.

5.2.3. Discussion

Our definition of a compound annotation domain is, to the best
of our knowledge, a novelty in settings involving annotations: previous work on Annotated RDF [15,12], annotated logic programmes
[16] or annotated database relations [17] have not addressed this
issue. We present in this section some considerations with respect
to the chosen approach.

1. The normalisation algorithm is not optimised and would prove
inefficient if directly implemented as is. In this part, we have
provided a working solution for normalising compound annotation as a mere proof of existence of such a solution. By observing the examples that we provide for the time + fuzzy domain, it
seems that the cost of normalising can be reduced significantly
with appropriate strategies.

2. As indicated by Theorem 5.4, we only ensure that the normalisation is feasible for a combination of annotation domains
where at least one is a lattice. Whether a normalisation function
exists in the more general case of two commutative, idempo-
tent, >-annihilating semirings is an open question.

3. The method we provide defines a new domain of annotation in
function of existing domains, such that it is possible to reason
and to query triples annotated with pairs of values. This does
not mean that it is possible to reason with a combination of triples annotated with the values of the first domain, and triples
annotated with values of the second domain. For instance, reasoning with a combination of temporally annotated triples and
fuzzy annotated triples does not boil down to reasoning over
time + fuzzy-annotated triples. The next section discusses this
issues and how non-annotated triples can be combined with
annotated triples.

5.3. Integrating differently annotated triples in data and queries

While our approach conservatively extends RDFS, we would
like to be able to seamlessly reason with and query together
annotated triples and non-annotated triples. Since non-annotated
triples can be seen as triples annotated with boolean values, we
can generalise this issue to reasoning and querying graphs annotated with distinct domains. For instinct, let us assume that a
dataset provides temporally annotated triples, another one contains fuzzy-annotated triples and yet another is a standard RDF
dataset. We want to provide a uniform treatment of all these
datasets and even handle the merge of differently annotated tri-
ples. Moreover, we expect to allow multiple annotation domains
in AnQL queries.

5.3.1. Multiple annotation domains in the data

Consider the following example:

 : 122006; 2010
 : 0:7


chadHurley; type; googleEmp

chadHurley; type; googleEmp

 : 0:97
googleEmp; sc; Person
We can assume that the subclass relation has been determined by
ontology matching algorithms, which typically return confidence
measures in the form of a number between 0 and 1. Consider as
well the following example queries:

Example 5.5.

SELECT ?a WHERE {

(chadHurley type googleEmp):?a

Example 5.6.

SELECT ?a WHERE {

(chadHurley type Person):?a

We propose two alternative approaches to deal with multiple
annotation domains. The first one simply segregates the domains
of annotations, such that no inferences are made across differently
annotated triples. The second one takes advantage of the compound domain approach defined in Section 5.2.

5.3.2. Segregation of domains

With this approach, distinct domains are not combined during
reasoning, such that the first annotated triple together with the
third one would not produce new results. The query from Example
5.5 would have the following answers: f?a=122006; 2010g;f?a=0:7g.
The query from Example 5.6 would have the answer f?a=0:679g
(under product t-norm 
).

The main advantage is that query answering is kept very
straightforward. Moreover,
it is possible to combine different
annotation domains within the query by simply joining results
from the segregated datasets. The drawback is that reasoning
would not complement non-annotated knowledge with annotated
one and vice versa.

5.3.3. Using compound domains

The principle of this approach is to assume that two primitive
annotation values from distinct domains actually represent a pair
with an implicit default value for the second element. The default
value can be domain dependent or generic, such as using > or ?
systematically. An example of domain specific default is found in
[2] where the value 121; Now is used to fill the missing annotations in standard, non-annotated RDF. It can be noticed that using
? as a default would boil down to having segregated datasets, as in
the previous approach. The use of > has the advantage of being
generic and allows one to combine knowledge from differently
annotated sources in inferences. So, the query in Example 5.5 has
answer f?a=fh122006; 2010; 1i;h121;1; 0:7igg, while Example
5.6 has the answer f?a=fh122006; 2010; 0:97i;h121;1; 0:679igg.
The main advantage is the possibility to infer new statements
by combining various annotated or non-annotated triples. The
drawbacks are that (i) our combination approach is, so far, limited
to the case where one domain is a lattice; (ii) if triples with a new
annotation domain are added, then it adds one dimension to the
answers, which obliges to recompute existing answers; (iii) the
combination of more than two domains may be particularly complex and possibly non-commutative.

5.3.4. Multiple annotation domains in the query

When dealing with multiple domains in the query, we face a
similar choice as in the data, but we are also offered the option
to replace the default value with a variable. If segregation of domains has been chosen, then distinct domains in the query are only
used to match the corresponding data, but it is still possible to
combine the results from differently annotated sources. For
instance:

SELECT ?e ?c ?t ?f WHERE {

{(?c sc ebayEmp):?f}

{(?e type ?c):?t.}

FILTER{?t t [2005,2011] OR ?f f 0.5}

This query can be executed even on a dataset that does not include fuzzy value. The fuzzy-annotated triple pattern can be simply ignored and the temporally annotated pattern evaluated. As
mentioned in Definition 4.9, the comparators t and f return false
whenever at least one of the operands is an unbound variable, so

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

that the FILTER is not influenced by a missing type of annotations.
In the case of the second approach using compound domains,

the choices are as follow:

1. add a single fresh annotation variable for all triples in the query

that are missing a value for an annotation domain; or

2. add a different fresh annotation variable for each triple in the

query; or

3. add a constant annotation such as > to all missing annotation

values.

In later discussions, we will use the meta-variable HD to represent the default value of domain d assigned to annotations in the
query triples.

Example 5.7. For instance,
if we again consider the query
(excluding the annotation variables) and input data from Example
4.1, the query would look like:

SELECT ?p ?c WHERE {

(?p type :ebayEmp)
OPTIONAL{(?p :hasCar ?c)}

Now, given the above three approaches for transforming this

query we would get the following answers:

Approach 1

Approach 2

Approach 3

?p=toivo
?p=toivo
?p=toivo
?p=toivo
?p=toivo

?c=peugeot
?c=renault
?c=peugeot
?c=renault

5.3.5. Querying multi-dimensional domains

Similarly to the discussion in the previous subsection, we can
encounter mismatches between the Annotated RDF dataset and
the AnQL query. In case the AnQL query contains only variables
for the annotations, the query can be answered on any Annotated
RDF dataset. From a user perspective, the expected answers may
differ from the actual annotation domain in the dataset, e.g., the
user may be expecting temporal intervals in the answers when
the answers actually contain a fuzzy value. For this reason some
built-in predicates to determine the type of annotation should be
introduced, like isTEMPORAL, isFUZZY, etc.

If the AnQL query contains annotation values and the Annotated
RDF dataset contains annotations from a different domain, one option is to not provide any answers. Alternatively, we can consider
combining the domain of the query with the domain of the annotation into a multi-dimensional domain, as illustrated in the next
example.

Example 5.8. Assuming the following input data:
chadHurley; type; youtubeEmp : chad
When performing the following query:

SELECT ?p ?c WHERE {

(?p type ?c):[2009, 2010]

we would interpret the data to the form:

chadhurley; type; youtubeEmp : hchad; Xtemporali

Fig. 4. Annotated RDF implementation schema.

while the query would be interpreted as:

SELECT ?p ?c WHERE {

(?p type ?c):hHprovenance, [2009, 2010]i

where Xtemporal and Hprovenance are annotations corresponding to the
default values of their respective domains, as discussed in Section
5.3.4. The semantics of combining different domains into one
multi-dimensional domain has been discussed in Section 5.2.

6. Implementation notes

Our prototype implementation is split into two distinct mod-
ules: one that implements the Annotated RDFS inferencing and
the second module is an implementation of the AnQL query language that relies on the first module to retrieve the data. Our prototype implementation is based on SWI-Prologs Semantic Web
library [44] and we present the architecture of the implementation
in Fig. 4.

Our Annotated RDFS module consists of a bottom-up reasoner
used to calculate the closure of a given RDF dataset (1). The variable components comprise (2) the specification of the given annotation domain; and (3) the ruleset describing the inference rules
and the way the annotation values should be propagated. For (1)
we do not suggest a special RDF serialisation for temporal triples
but rely on existing proposals using reification [2]. Annotation domains in (2) are to be specified by appropriate lattice operations
and describing default annotations for non-annotated triples.

The rules in (3) are specified using a high-level language to
specify domain independent rules that abstracts from peculiarities
of the reification syntax. For example the following rule provides
subclass inference in the RDFS ruleset:

rdf(O, rdf:type, C2, V) <==

rdf(O, rdf:type, C1, V1),
rdf(C1, rdfs:subClassOf, C2, V2),
infimum(V1, V2, V).

(2) and (3) are independent of each other: it is possible to com-

bine arbitrary rulesets and domains (see above).

The AnQL module also implemented in Prolog relies on the
SPARQL implementation provided by the ClioPatria Semantic
Web Server.17 For the AnQL implementation, the domain specification needs to be extended with the grammar rules to parse an annotation value and any built-in functions specific to the domain.

More information and downloads of the prototype implementa-

tion can be found at http://anql.deri.org/.

17 http://www.swi-prolog.org/web/ClioPatria/.

6.1. Implementation of specific domains

For example, for the fuzzy domain the default value is considered to be 1 and the 
 and  operations are, respectively, the
min and max operations. The AnQL grammar rules consist simply
of calling the parser predicate that parses a decimal value.

As for the temporal domain, we are representing triple annotations as ordered list of disjoint time intervals. This implies some
additional care in the construction of the 
 and  operations. For
the representation of 1 and 1 we are using the inf and sup
Prolog atoms, respectively. Concrete time points are represented
as integers and we use a standard constraint solver over finite domains (CLPFD) in the 
 and  operations. The default value for
non-annotated triples is [inf,sup]. The 
 operation is implemented as the recursive intersection of all the elements of the
annotation values, i.e., temporal intervals. The  operation is handled by constructing CLPFD expressions that evaluate the union of
all the temporal intervals. Again, the AnQL grammar rules take care
of adapting the parser to the specific domain and we have defined
the domain built-in operations described in Section 5.1.

6.2. Use-case example: sensor data

As a use-case for Annotated RDF and AnQL, we present the scenario of exposing sensor readings as RDF data. Representing sensor
data as RDF, more specifically as Annotated RDF, enables not only a
precise and correct representation for sensor data but also the possibility of interlinking the data with other existing sources on the
Web.

Consider the scenario in which each person is assigned a sensor
tag (mode) to use in a building that is equipped with several sensor
base-stations (that will be responsible for recording the presence
of tags). Whenever sensor modes are detected in the proximity
of a base-station, sensor readings are created. Normally this sensor
reading will contain the time of the reading, the identifier of the
base-station and the tag. For our example we used datasets publicly available, that represent movements of persons in a confer-
ence. For our test purposes we used a subset of the dataset
available at http://people.openpcd.org/meri/openbeacon/sputnik/
data/24c3/ with a 1 h time frame.

For the specific Annotated RDF domain, we can take as starting
point the temporal domain, where each triple is annotated with a
temporal validity. Conceptually, a temporally annotated triple
would look like the following:
tag4302 locatedIn room103 :

122010-07-28T16 : 52 : 00Z; 2010-07-28T14 : 59 : 00Z

stating that the tag represented by the URI tag4302 was in the
room identified by room103 during the specified time period. For
the URIs we can define a domain vocabulary or rely on an already
existing vocabulary.

Since a sensor mode can, at any time, be discovered by several
base-stations the issue arrises of how to detect which base-station
it is closer to. This can be viewed as a data cleanup process that can
be achieved as a post-processing step over the stored data. In our
specific experiment, the sensor readings were of the following
format:

2010-10-11 14:57:51 10.254.2.15 4302 83
2010-10-11 14:57:51 10.254.3.1 4302 83
2010-10-11 14:57:51 10.254.2.6 4302 83

where the columns represent respectively: (1) timestamp
when the record was created; (2) ip address of the base station;
(3) tag identifier and; (4) ssi. The ssi represents the signal

strength of the response from the tag. Each base station registers
each tag at the same timestamp with different signal strengths,
which can be interpreted as the lower the signal strength value
is, the closer the tag is to the base station. This value can then
be used in the data cleanup process to discard the base station
records in which the tag is furthest from.

In the data cleanup process we start by grouping all the ips
(with the lowest ssi) for a given timestamp and tag. After this
step we can merge all records that share the tag and ip and have
consecutive timestamp into a single interval.

6.3. Concrete syntax for Annotated RDFS

In this paper, we stay agnostic with respect to the concrete
syntax used to serialise annotated graphs. However, we present
here a suggested syntax based on N-Quads [45]. Other possibil-
ities, for instance using named graphs, could be exploited as
well, but we believe
is more
straightforward.

following proposal

the

We first present how primitive domains are represented, then
extend it to combination of domains. In the format N-Quads, the
data structure is organised in quadruples:

< subject >< predicate >< object >< context > :

where <subject> <predicate> <object>. form a valid N-Triple
[46] statement. The element <context> is an optional context value that belongs to the set UBL. In the case of Annotated RDFS,
<context> will be a typed literal that denotes the annotated value.
The datatype of the literal represents the domain of annotation.
Consequently, in order to define a concrete representation of an
annotation domain, one must at least define its associated datatype,
which has three components [47]:

 a lexical space, that is, a set of Unicode character strings (e.g.,

the set of finite sequences of digits);

 a value space, that is, the set of values represented by the anno-

tations (e.g., the set of time points);

 a lexical-to-value mapping which maps each member of the

lexical space to a value in the value space.

In addition to these components, which are mandated by the
XML Schema Datatypes specification, the specification of a concrete domain must provide the operations 
 and , from which
the partial order , the upper and lower bounds are also derived.
We give as an example the specification of the fuzzy domain. The
lexical space, value space and lexical-to-value mapping are the
same as the XSD datatype xsd:decimal. However, it is not possible
to simply reuse this datatype, as it does not specify which operations should be used. Since several t-norms can be used as an 

operation, it is necessary to mint distinct URIs for distinct fuzzy
semi-rings. Let us call ex:fuzzy-min the fuzzy domain with the
min t-norm. A fuzzy-annotated triple would look as follows:18

<ex> <type> <EbayEmp> "0.3"^^ex:fuzzy-min.

With this approach, our framework is made compatible with
RDF stores that understand N-Quads. A typical store would simply
consider distinct annotation values as different contexts. However,
a store implementing Annotated RDFS would be able to easily recognise the annotation domains of the data and load an appropriate
reasoning engine dynamically. The reasoner could simply reason
separately with different annotation domains.

18 For brevity, we simplify the URIs. A real N-Quads document should have complete
URIs all the time.

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

As compound domains are annotation domains as well, it is
possible to use the same approach by providing a distinct lexical/
value space for each pair of domains. As an example, one could
imagine the following triple occurring in an N-Quads document19:

lub b

hx;yi2J

<s> <p> <o> "(0.3,[2001,2003])"^^:fuzzy-time.

Yet, the purpose of Section 5.2 was to define the combination of
domains in function of the primitive domains. Thus, a smart implementation of Annotated RDFS should be able to deal with arbitrary
combinations dynamically when they occur in the data. However,
this means that there should be a generic syntax for writing compound annotations. To that extent, we propose to extend the N-
Quads syntax to a generic tuple syntax where each element of
the tuple is in UBL. The example above would then look as follows:

<s> <p> <o> "0.3"^^:fuzzy "[2001,2003]"^^:time.

Few RDF stores are able to parse arbitrary tuples with the nota-

ble exception of YARS [48].

7. Conclusion

In this paper we have presented a generalised RDF annotation
framework that conservatively extends the RDFS semantics, along
with an extension of the SPARQL query language to query annotated data. The framework presented here is generic enough to
cover other proposals for RDF annotations and their query lan-
guages. Our approach extends the classical case of RDFS reasoning
with features of different annotation domains, such as temporality,
fuzzyness, trust, etc. and presents a uniform and programatic way
to combine any annotation domains.

Furthermore, we presented a semantics for an extension of the
SPARQL query language, AnQL, that enables querying RDF with
annotations. Queries exemplified in related literature for specific
extensions of SPARQL can be expressed in AnQL. Noticeably, our
semantics goes beyond the expressivity of the current SPARQL
specification and includes some features from SPARQL 1.1 such
as aggregates, variable assignments and sub-queries. We also described our implementation of AnQL based on constraint logic programming techniques along with a practical experiment for
representing sensor data as Annotated RDF.

Acknowledgement

We would like to thank Gergely Lukacsy for his participation in
the development of this work. The work presented in this paper
has been funded in part by Science Foundation Ireland under Grant
No. SFI/08/CE/I1380 (Lion-2) and supported by COST Action IC0801
on Agreement Technologies.

Appendix A. Proofs of theorems and propositions

A.1. Proof of Theorem 5.2

We start by proving that for all z; z0 2 L1; Az1z02Az
2Az0.
Proof Appendix A. 1. Let z; z0 2 L1. In order to prove the propo-
xg. The
sition, we introduce the notation KA
property that we want to prove can be rewritten:

z 14deffJ # A j z1

hx;yi2J

y j J 2 KA

z1z0

2

lub b

hx;yi2J

y j J 2 KA

2lub b

hx;yi2J0

y j J0 2 KA
z0

Let us introduce two intermediary lemmas:

Lemma Appendix A. 1. For all z; z0 2 L1; KA

z1z0 14 KA

z \ KA
z0 .

Proof Appendix A. 2. We simply prove each inclusion separately:

x, that is J 2 KA

# : let J 2 KA
z1z0 , which implies that z1z01
z and J 2 KA
and z0 a
z0 .

hx;yi2J
z \ KA
z0 , which implies that z1
: let J 2 KA
so z1z01

hx;yi2J

hx;yi2J
x by definition of 1. Consequently, J 2 KA
z1z0 .

x and z01

x. So, z1

hx;yi2J

hx;yi2J

hx;yi2J

x,

Lemma Appendix A. 2. For all
2 KA

z 
 KA
z0g.

z; z0 2 L1; KA

z1z0 14 fJ [ J0 j J; J0

Proof Appendix A. 3. Again, we prove each inclusion separately:
z0 and J 14 J [ J.

x. Conse-

hx;yi2J[J0
z . Symmetrically, we prove that J [ J0 2 KA
z0 .

z1z0 implies that J 2 KA
z0 . Clearly, a

hx;yi2J

# : trivial since J 2 KA
: let

quently, J [ J0 2 KA

z and J0 2 KA

z \ KA
x1

J 2 KA

This allows us to rewrite the problem into:

lubf b

hx;yi2J[J0

y j J; J0 2 KA

z 
 KA

lubf b

hx;yi2J

y j J 2 KA

which is more concisely written:

z0g2
zg
2lubf b

hx;yi2J0

z0g
y j J0 2 KA

2

hx;yi2J[J0

J;J02KA
z 
KA
z0
This is easily established by distributivity of 
2 over 2 in the right
hand side and by remarking that 20

hx;yi2J0

hx;yi2J

J02KA
z0

J2KA

1A

J02KA
z0

J2KA

hx;yi2J

hx;yi2J0

2

J;J02KA
z 
KA
z0

hx;yi2J[J0

The second part of

z; z0 2 L1; Az
1z02Az2Az0.

the proof demonstrates that

for all

Proof Appendix A. 4. Before giving the main arguments for the
proof, we rewrite the goal as follows: 21

lubf b

hx;yi2J

y j J 2 KA

2lubf b

hx;yi2J

y j J0 2 KA
z0g

zg2lubf b

hx;yi2J0

1z0g;
y j J 2 KA

0@

19 This is again a fictitious example for the sake of illustration. A more realistic
syntax for the representation of time would use XSD dateTime literals.

20 Note that if 
2 is idempotent, then the inequality becomes an equality.
21 We here reuse the notation KA

z introduced above.

R [ fha
1c; b2digz 14 Rz 2

2b2d j J # R and

lubf b

hx;yi2J

z1 a

hx;yi2J

x1a
1cg:

Further, due to distributivity,

hx;yi2J

2b2d 14  b

hx;yi2J

2b2 b

hx;yi2J

2d:

which again can be made more concise with the following notation:

J2KA

hx;yi2J

2

J2KA
z0

hx;yi2J0

2

J2KA

1z0

hx;yi2J

Associativity of 2 simplifies the equation further:

J2KA
z [KA
z0

hx;yi2J

2

J2KA

1z0

hx;yi2J

We established the result by first proving the following lemma:

Lemma Appendix A. 3. For all z; z0 2 L1; KA

z [ KA

z0 # KA

1z0 .

Proof Appendix A. 5. Let J 2 KA

1z01z. So J 2 KA
easily see that

1z0 . Idem for any J 2 KA

z . It holds that z1

hx;yi2J

x and

z0 . This allows us now to

J2KA
z [KA
z0

hx;yi2J

2

J2KA

1z0

y:

hx;yi2J

Notice that the opposite inequality does not hold in general.

A.2. Proof of Theorem 5.4

In order to prove the theorem, we first demonstrate the follow-

ing proposition:

Proposition Appendix A. 4. If D1 14 hL1;1;
1; ?1;>1i is a lattice
then, for all A # L1 
 L2 finite, A 14 NormaliseA.
Let us assume that D1 is a lattice. We show the proposition by proving that at each step of the saturation and reduction, the set R is
such that R 14 A. This is trivially true at the initialisation of Saturate.
Now let us assume that R satisfies this property at a certain step of
the execution. We start by ensuring that
R 14 R [ fha

J2X

x; b

J2X

hx;yi2J

hx;yi2J

yig

and
R 14 R [ fhb

J2X

hx;yi2J

x; a

J2X

hx;yi2J

yig :

We can decompose further the proof by simply showing that, given
ha; bi; hc; di 2 R,
R 14 R [ fha
1c; b2dig
and
R 14 R [ fha1c; b
2dig:
To structure the proof better, we split the proof into several lemmas
corresponding to each of the aforementioned steps.

Lemma
R [ fha
1c; b2digz 14 Rz holds.

Appendix

A.

5. Let

z 2 L1.

The

equality

Proof Appendix A. 6. If the pair ha
1c; b2di already belongs to R,
the equality is trivial. Let us assume ha
1c; b2di R R so that we can
easily distinguish between sets that include ha
1c; b2di and sets
that do not. Using the definition of R [ fha
1c; b2digz, we can
write:

We can therefore rewrite the previous equality to:
R [ fha
1c; b2digz 14 Rz

2 lubf b

hx;yi2J
2 lubf b

hx;yi2J

2b j J # R and z1 a

hx;yi2J

2d j J # R and z1 a

hx;yi2J

x1a
1cg
x1a
1cg:

x1c:

x1a
1c 14  a

hx;yi2J

x1a
1c implies z1 a

hx;yi2J

Additionally, since D1 is a lattice, we have

x1a
1 a

hx;yi2J
hx;yi2J
So z1 a

hx;yi2J
This means that J [ fha; big 2 fK # R j z1

hx;yi
and generalising to any suitable J, we conclude, using the equation
above, that R [ fha
1c; b2digz 14 Rz.

2b2Rz. Analogically, we conclude that  b

hx;yi2J

x1c.
xg so necessarily,

2d2Rz

x1a and z1 a

hx;yi2J

hx;yi2J

Now let us prove this second equality:

Lemma Appendix A. 6. Let z 2 L1. The equality R [ fha1c; b
2dig
z 14 Rz holds.

Proof Appendix A. 7. We apply a similar method as for Lemma 5
to get to the following equality:
R [ fha1c; b
2digz 14 Rz 2

lubf b

hx;yi2J

2b
2d j J # R and

z1 a

hx;yi2J

x1a2cg:

This means that J [ fha; bi;hc; dig 2 fK # R j z1
plies that  b

hx;yi2J

xg, which im-

2b
2d2Rz. Generalising this to any suitable

hx;yi2K

J, we obtain the equality.

Now, let us prove that the reduce algorithm preserves the quasi

homomorphism.

Lemma Appendix A. 7. A 14 ReduceA.

Proof Appendix A. 8. Let ha; bi 2 R such that there exists ha0; b0i 2 R
such that a 1 a0 and b 2 b0. Using the same approach as in Lemma
5, we obtain the following equality:
Rz 14 R n fha; bigz 2

lubf b

hx;yi2J

2b j J # R n fha; big and

z1 a

hx;yi2J

x1ag:

From the hypothesis, we have that z1 a

hx;yi2J
ate J. Moreover, for the same J, we have  b

hx;yi2J

x1a0 for any appropri-

2b2b0. Generalis-

ing to all adequate J, we entail that:

A. Zimmermann et al. / Web Semantics: Science, Services and Agents on the World Wide Web 11 (2012) 7295

R n fha; bigz2lubf b

hx;yi2J
z1 a

hx;yi2J

2b j J # R n fha; bigand
x1ag

and, thus, Rz 14 R n fha; bigz. Similarly, every pair h?1; yi or hx;?2i
does not affect the function R.

Now, the proof of Proposition 4 follows from an inductive appli-

cation of Lemmas 57. Therefore, A 14 NormaliseA holds.

A.3. Proof of the theorem

The implication ( is a direct consequence of Proposition 4.
Let us prove the other direction. Let A and b two finite sets of
pairs of primitive annotations in L1 
 L2 such that A 14 B. For
A # L1 
 L2 and x 2 L1, let KA
ag. We also remind
that:
A : L1 ! L2
x # a

J2KA

x 14 fJ # A j x1

ha;bi2J

ha;bi2J

Moreover, we introduce the following new notation:

A : L1 ! L1
x # b

J2KA

ha;bi2J

We establish the proof through the support of several intermediary
lemmas.

Lemma Appendix A. 8. If hx; yi 2 A then y2Ax.

Lemma Appendix A. 12. For all x 2 L1, there exists u 2 L1 such that
hu; Axi 2 NormaliseA and x1u.

Proof Appendix A. 13. Let x 2 L1. Again, h
Then, due to the reduction algorithm,
hu; vi 2 NormaliseA such that u1
sider the following assertions:

Ax; Axi 2 SaturateA.
there must exist
Ax and v2Ax. We can con-

D1 is a lattice
Ax1u
Ax2v
A is antitone
x1
Ax
Ax2A

Au2v
Ax 14 v

Ax
Ax2Au

(by hypothesis)
(due to Reduce)
(due to Reduce)
(from (H1) and Lemma 10)
(from Lemma 9)
(from (A1) and (A2))
(from (R1) and (A1))
(from Lemma 8)
(from (A3), (A4), (A5) and (R2))

(H1)
(R1)
(R2)
(A1)
(A2)
(A3)
(A4)
(A5)
(C1)

Assertions (C1) and (C2) establish the lemma.

Proof Appendix A. 14 [Of Theorem 5.4]. Let hx; yi 2 NormaliseA.
Ax and y 14 Ax. Moreover,
From Lemma 11, we know that x 14
from the hypothesis of the theorem, Ax 14 Bx. Hence, due to
Lemma 12, there exists u 2 L1 such that hu; yi 2 NormaliseB and
x1u. By using the same reasoning, we can infer that there exists
v 2 L1 such that hv; yi 2 NormaliseA and u1v. But due to Lemma
11, we have that y = v and therefore hx; yi 2 NormaliseB.

The situation is symmetrical with respect to A and b, so finally

Normalise(A) = Normalise(B).

Proof Appendix A. 9. Let hx; yi 2 A. We remark that x1
and fhx; yig # A, so:
y 14 b

J2KA

b 14 Ax:

ha;bi2J

ha;bi2fhx;yig

b2

ha;bi2fhx;yig
