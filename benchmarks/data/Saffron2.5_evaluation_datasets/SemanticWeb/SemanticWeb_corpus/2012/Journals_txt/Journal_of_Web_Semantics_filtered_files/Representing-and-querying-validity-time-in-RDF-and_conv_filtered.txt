Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Contents lists available at SciVerse ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : h t t p : / / w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

Representing and querying validity time in RDF and OWL: A logic-based approach q

Boris Motik


Oxford University Computing Laboratory, Oxford, UK

a r t i c l e

i n f o

a b s t r a c t

RDF(S) and OWL 2 can currently represent only static information. In practice, however, the truth of
statements often changes with time. Semantic Web applications often need to represent such changes
and reason about them. In this paper we present a logic-based approach for representing validity time
in RDF(S) and OWL 2. Unlike the existing proposals, our approach is applicable to nondeterministic
entailment relations and/or entailment relations that involve existential quantification, such as the
OWL 2 Direct Entailment and the OWL 2 RDF-Based Entailment. We also present an extension of SPARQL
that can be used to query temporal RDF(S) and OWL 2. Moreover, we present a general query evaluation
algorithm that can be used with all entailment relations used in the Semantic Web. Finally, we present
two optimizations of the algorithm that are applicable to entailment relations characterized by a set of
deterministic rules, such RDF(S) and OWL 2 RL/RDF Entailment.

O 2011 Elsevier B.V. All rights reserved.

Article history:
Available online 25 November 2011

Keywords:

SPARQL
Validity time
Temporal databases
Query answering

1. Introduction

The Resource Description Framework (RDF) [1] is the standard
language for metadata management in the Semantic Web. RDF
provides a simple, but powerful data model that encodes facts
using triples; sets of triples are called RDF graphs. RDF Schema
(RDFS) extends RDF with vocabulary for schema modeling. The
Web Ontology Language (OWL), particularly in its latest incarnation called OWL 2 [2], extends RDFS to a very expressive ontology
language. The semantics of RDF graphs is determined by entailment relations, such as Simple Entailment or OWL 2 RL/RDF
Entailment.

RDF(S) and OWL 2 have been implemented in RDF management systems such as Jena [3], Jena2 [4], Sesame [5], Oracle [6],
Kowari [7], 4store [8], YARS [9], Hexastore [10], and Redland
[11], as well as reasoners such as FaCT   [12], Pellet [13], and
HermiT [14]. Such systems were successfully applied in numerous
applications in fields as diverse as biology [15], medicine [16],
geography [17], astronomy [18], agriculture [19], and defense
[20]. These applications, however, often need to deal with information that is not static, but that changes with time. To understand this problem, we present an example derived from the
authors collaboration with ExperienceOn1a start-up IT company
from Barcelona, Spain.

q This is an extended version of a paper with the same name published at ISWC

2010, pp. 550565.

 Tel.: +44 1865 283544.

E-mail address: boris.motik@cs.ox.ac.uk

1 http://www.experienceon.com/.

1570-8268/$ - see front matter O 2011 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2011.11.004

ExperienceOn aims to improve search in the tourism domain
by providing an advanced system that can answer complex requests such as trips to the second week of Oktoberfest. Users
will input their questions in natural language, and NLP technology will translate such questions into one or more queries over
a knowledge base containing information about flights, lodging,
events, geography, and so on. ExperienceOns system must be
able to represent statements that are not universally true, but
are associated with validity timesspecifications of time instants
at which the statements are true. For example,
Oktoberfest is
being held in Munich is true only while the festival is actually
being held; similarly, statements describing airline flight schedules are valid only in certain time intervals. Validity time must
be tightly integrated with reasoning; for example,
from the
knowledge about Oktoberfest and German geography, ExperienceOns system should be able to conclude that Oktoberfest is
being held in Bavaria is true for the duration of the festival.
Validity time should also be integrated with a query language,
allowing one to retrieve flights from London to Munich during
Oktoberfest. Validity time thus affects virtually all aspects of
knowledge representation and reasoning in many advanced application scenarios. Some applications also need to represent transaction times, which specify the period during which a fact is
present in the system [21]. Transaction times are important in
the context of data management, but they are not part of an
application domains description. Since modeling the latter is
the primary concern in the Semantic Web, in this paper we focus
on validity rather than transaction time. Note, however, that the
techniques for the management of one can kind of time often
be applied to the other kind of time as well.

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

RDF(S) and OWL 2 can represent only static facts whose truth
does not change with time. This deficiency has been recognized
in the Semantic Web community, and a number of approaches
for the representation, reasoning, and querying of validity time
were developed [2229]; we discuss various aspects of these approaches in Section 7. These approaches, however, do not provide
a general framework for the management of validity time in the
Semantic Web: all approaches known to us are applicable only to
entailment relations that can be characterized by deterministic
inference rules without existential quantifiers, such as RDFS or
OWL 2 RL.

In this paper we present a novel logic-based approach for representing validity time that is applicable to all entailment relations of
the Semantic Web, including RDF(S), OWL 2 Direct Semantics, and
all profiles of OWL 2. To this end, in Section 3 we introduce a notion of temporal RDF graphs similar to the one used in [22]. Instead
of developing a notion of temporal entailment from scratch, we
give semantics to temporal graphs by simply mapping them into
first-order theories.

In Section 4, we turn our attention to the problem of querying
temporal graphs. We argue that a naive extension of SPARQL with
temporal features is likely to be problematic. For example, let G
be the temporal graph in which some triple A holds from a fixed
time instant t1 onwards, and let Q 1 be a query for all time instants at which A holds; the answer to Q 1 on G is infinite since
the time line is unbounded. Furthermore, even if we restrict
temporal triples to finite intervals, the answers to queries such
as Q 1 can be much larger than the graphs to which the queries
are applied. An obvious way to overcome this problem is to
restrict answers to time instants explicitly occurring in the temporal graph; in our example, the answer to Q 1 on G would then
contain only t1. Under such a definition, however, evaluating
the same query over semantically equivalent temporal graphs
could produce different answers. For example, consider a temporal graph G0 in which triple A holds between time instants t1 and
t2, and from t3 onwards, where t1 < t3 < t2. The constraints on
t1; t2, and t3 ensure that G and G0 are semantically equivalent;
however, the answer to Q 1 on G0 would contain t1; t2, and t3,
which is different from the answer to Q 1 on G. We address these
problems in two steps:

 We extend the formalization of SPARQL by Perez et al. [30] with
primitives that allow for querying temporal graphs. For each
query expressed in our language, the answers on semantically
equivalent temporal graphs are guaranteed to coincide. Our
query language explicitly incorporates the notions of maximal-
ity/minimality by allowing for queries such as Q2 = the maximal interval in which A holds and Q3 = the minimal time
instant at which A holds.
 We define a syntactic notion of safety that guarantees finiteness
of temporal query answers. Queries such as Q 2 and Q 3 are safe,
but queries such as Q 1 are not; intuitively, only queries that ask
for maximal intervals can bind variables in a query.

 In Section 5.2 we present an algorithm for computing answers
to safe temporal queries. The query answering algorithm uses
the temporal entailment algorithm as a black box and thus handles arbitrary temporal entailment relations.

In Section 6 we consider several optimizations of the general

query answering algorithm.

 In Section 6.1 we present a query answering algorithm that is
applicable to Simple Entailment. The algorithm consists of
two parts: a temporal graph is preprocessed into a particular
normal form, after which the evaluation of temporal queries is
reduced to simple evaluation of conjunctive queries over the
normalization. The evaluation of conjunctive queries is implemented in virtually all RDF management systems, so integrating
our algorithm into these systems should be straightforward.

 In Section 6.2 we present an algorithm for reasoning with temporal graphs that is applicable to deterministic entailment relations such as RDF(S) and OWL 2 RL/RDF. Practical RDF systems
usually reason with such entailment relations on nontemporal
graphs by materializing all consequences of a suitable datalog
program. We show how to modify an arbitrary such program
into one that correctly processes the required temporal infor-
mation. Our approach can thus easily be integrated into existing
materialization-based RDF management systems.

2. Preliminaries

In this section we recapitulate some basic definitions of first-or-

der logic, RDF, OWL, and SPARQL.

2.1. First-order logic and sorts

We use the notions of constants, variables, function symbols,
terms, predicates, atoms, and formulae from first-order logic
[31]. For r a (partial) mapping of variables to terms and w a
first-order formula, r(w) is the result of replacing in w, for each
variable x such that rx is defined, each free occurrence of x with
rx. A first-order interpretation I is a tuple I 14 MI;	I, where MI is a
nonempty domain set of I, and 	I is a function that assigns an interpretation XI to each predicate, function symbol, and constant X. Let
u and v be arbitrary first-order formulae without free variables.
We write I  u to denote that u is satisfied in a first-order interpretation I; then, I is a model of u. Furthermore, we write u  v
to denote that I  v for each I such that I  u; then, u entails v.
The skolemization of a first-order formula u is a formula w obtained by replacing existentially quantified variables occurring in
u with function terms as described in [31]. For example, the skolemization of formula u shown below is the formula w, where c is a
fresh constant and f is a fresh function symbol.

u 14 129x : Ax ^ 128x : Ax ! 9y : 12Rx; y ^ Ay
w 14 Ac ^ 128x : Ax ! 12Rx; fx ^ Afx

In Section 5 we then turn our attention to algorithms for dealing

with temporal graphs.

 In Section 5.1 we present an algorithm that can decide certain
basic types of temporal entailments. Our algorithm reduces a
temporal entailment problem to linearly many nontemporal
entailment problems. Thus, the algorithm can be applied to an
arbitrary temporal entailment relation for which the nontemporal counterpart is available, including relations requiring nonde-
terministic
reasoning with existential
quantifiers, such as OWL 2 Direct Entailment or OWL 2 RDFBased Entailment.

reasoning and/or

For arbitrary first-order formulae u and v without free variables,
and for w the skolemization of u, we have w  u (but u  w does
not hold in general), and u  v if and only if w  v [31].

For reasons that will become apparent in Section 3, we assume
in this paper that the equality predicate  is treated as an ordinary
first-order predicate with an explicit axiomatization. With C we
denote the axioms of equality from [31] instantiated for all the
symbols in the signature. (Note that C is infinite if the signature
is infinite.)

For reasons that will also become apparent in Section 3, in this
paper we use the many-sorted variant of first-order logic. Please refer to [32] for a formal definition of many-sorted logic. Roughly

speaking, variables in many-sorted logic range over fixed subsets
of the domain sets.

2.2. RDF and OWL

respectively.

references, blank nodes, and literals,

The syntax of RDF [1] is defined w.r.t. infinite sets U;B, and L of
Let

UBL 14 U [ B [ L. An RDF triple (usually abbreviated to just triple)
is an assertion of the form hs; p; oi such that s; p; o 2 UBL. 2 An RDF
graph (usually abbreviated to just graph) G is a finite set of triples.
With ulG and bG we denote the subsets of the elements of U [ L
and B, respectively, that occur in G. Blank nodes are usually written
as :x. For r a (partial) mapping of the blank nodes in G into UBL, with
rG we denote the temporal graph obtained form G by replacing with
r :x each blank node :x for which r :x is defined.

The semantics of RDF is defined by a model theory [33] that
maps a graph G to RDF interpretations. In this paper, however,
we use a different, but nevertheless equivalent formulation: we
map G to a first-order theory mG that captures the consequences
of G. For convenience, we assume that each t 2 U [ L corresponds
to a first-order constant t, and that each blank node :x 2 B corresponds to a first-order variable :x. Our mapping encodes the truth
of triples using a ternary first-order predicate Tthat is, each triple

A 14 hs; p; oi is mapped into a first-order atom vA 14 Ts; p; o; fur-
thermore,

formula
vG 14 9bG:
A2GvA, where 9bG abbreviates 9 :x1 . . .9 :xk for
f :x1; . . . ; :xkg 14 bG.

is mapped

graph

into

Several entailment relations can be used with RDF: Simple Entail-
ment, RDF Entailment, RDFS Entailment, and D-Entailment are defined in [33], OWL 2 RDF-Based Entailment is defined in [34], and
OWL 2 RL/RDF Entailment is defined in [35]. An entailment relation
X places constraints on RDF interpretations; in our framework, we
can capture these constraints using a first-order theory CX (i.e., a
set of first-order formulae) in which T and  are the only predicates.
For example, for Simple Entailment, Csimple 14 ;; for RDF Entailment,
CRDF contains the rules in [33, Section 7]; and for OWL 2 RL/RDF
Entailment, CRL contains the rules in [35, Section 4.3]. We assume
that CX does not contain the elements of B, and that, if the equality
predicate  is used in CX, then CX contains the explicit axiomatization of equality C. Note that CX is not required to be finite. The
semantics of a graph G under entailment relation X is then captured
by the first-order theory mXG 14 fvGg [ CX. A graph G1 X-entails a
graph G2, written G1 X G2, if mXG1  mXG2; the latter condition is
clearly equivalent to mXG1  vG2. Finally, for convenience, we
define the following notation:

ulXG 14 ulG

bXG 14 bG

pXG 14

vA

A2G

As defined above, pXG, bXG, and ulXG do not depend on X if X is
an entailment relation mentioned at the beginning of this para-
graph. However, we next present different definitions of
pXG; bXG, and ulXG for the case when X is OWL 2 Direct Entail-
ment. In this way, we obtain notation that allows us to uniformly
refer to an arbitrary entailment relation of RDF and OWL 2.

The OWL 2 Direct Entailment (written DL due to its relationship
with description logics [36]) employs a completely different
approach to interpreting graphs. A graph G is said to encode an
OWL 2 DL ontology if G can be transformed into an OWL 2 DL ontology OG as specified in [37]. This process is rather complex, and we
cannot discuss it in detail. Roughly speaking, various triple patterns
are applied to G in order to extract parts of OG. Axioms of OG are
recognized by triple patterns listed in [37, Tables 16 and 17]. Each
of these triple patterns contains either a single main triple or a single

2 RDF actually requires s 2 U [ B, p 2 U, and o 2 UBL; however, this is not
important in our framework so we assume s; p; o 2 UBL for the sake of simplicity.

triple of the form h :x; rdf:type; yi where :x is a blank node and y is
an OWL 2 resource specifying the type of the axiom. We call a triple
of either of these two forms a lead triple; intuitively, a lead triple is a
triple that represents the axiom in G. Different conditions are required to hold at various stages during the transformation process.
If at any point in time a condition becomes invalidated, the transformation fails and the input RDF graph cannot be used with
OWL 2 Direct Entailment. In contrast, if the transformation of G into
OG is successful, ontology OG is interpreted as specified in [38].
To obtain a common semantic framework, however, in this paper
we equivalently map OG into a first-order formula. More pre-
cisely, for an OWL 2 DL axiom a, let h(a) be the translation of a into
a first-order formula [36] in which blank nodes occur as free vari-
ables; note that this translation uses the equality predicate  to
interpret features such as number restrictions and nominals. Let
ulDLG and bDLG be the subsets of the elements of U [ L and B,
respectively, that occur in OG. The semantics of a graph G under
OWL 2 Direct Entailment is then captured by the first-order theory
mDLG defined as follows:
pDLG 14
mDLG 14 f9bDLG : pDLGg [ C

ha

a2OG

To clarify, in the above definition we assume that C axiomatizes
the equality predicate  for all symbols in the signature, not just
for those occurring in OG. For G1 and G2 graphs that encode
OWL 2 DL ontologies, G1 DL-entails G2, written G1 DL G2,
if
mDLG1  mDLG2.

A remark about notation is in order. Note that, for an arbitrary
entailment relation X and graphs G, G1, and G2 that can be interpreted under X, pXG is a first-order formula whose free variables
(if any) are contained in B; furthermore, mXG is a first-order theory that contains a formula of the form 9bDLG : pXG plus possibly other formulae without blank nodes; finally, G1 X G2 if and
only if mXG1  9bXG2 : pXG2.
The result of skolemizing the blank nodes in mXG is the firstorder theory nXG obtained from mXG by removing 9bXG and
replacing each blank node in pXG with a fresh URI reference.
We assume that each blank node is uniquely associated with a
fresh URI reference used for skolemization; furthermore, we
define uslXG as ulXG extended with the URI references obtained
by the skolemization of mXG. For arbitrary G1 and G2, by
the properties of skolemization we have G1 X G2 if and only if
nXG1  9bXG2 : pXG2.
The X-skolemization of a graph G is the graph G0 obtained from G
by replacing each blank node in bXG with the corresponding URI
reference from uslXG. Note that, for X other than DL, graph G0 does
not contain blank nodes; however, for X 14 DL, graph G0 can contain
blank nodes: bXG contains only the blank nodes that occur in
OG, but not the ones that encode syntactic parts of OWL 2 DL axioms (such as owl:SomeValuesFrom restrictions). In all cases, how-
ever, we have mXG0 14 nXG0;
is always
semantically equivalent with mXG0. Thus,
it does not matter
whether we transform G into mXG and then skolemize the latter,
or we skolemize G and then transform the resulting graph G0 into
mXG0: the resulting theories are semantically equivalent.

furthermore, nXG

2.3. SPARQL

We next present an overview of SPARQLthe standard W3C
language for querying RDF graphs. In this paper we focus on group
patternsthe core of SPARQL that deals with pattern matching and
is largely independent from constructs such as aggregates and
sorting. We formalize group patterns along the lines of [30]. Let
V be an infinite set of variables disjoint with UBL. A mapping is a

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

partial function l : V ! UBL. The domain and the range of l are given by doml and rngl, respectively. We define lt 14 t for each
t 2 UBL [ V n doml. Mappings l1 and l2 are compatible if
l1x 14 l2x for each x 2 doml1 \ doml2; in such a case,
l1 [ l2 is also a mapping. We use the following algebraic operations on sets of mappings X1 and X2 to define the semantics of
group patterns.
X1 ffl X2 14fl1 [l2jl1 2 X1;l2 2 X2;and l1 and l2 are compatibleg
X1 n X2 14fl1 2 X1jeach l2 2 X2 is not compatible with l1g

A built-in expression is constructed using the elements of
V [ U [ L as specified in [30]; furthermore,
for each built-in
expression R and each mapping l, we can determine whether R
evaluates to true under l, written l  R, as specified in [30]. A basic graph pattern (BGP) is a set of triples of the form hs; p; oi where
s; p; o 2 UBL [ V. A group pattern (GP) is inductively defined as a ba-
sic
form
P1 and P2; P1 union P2; P1 opt P2, or P1 filter R, where P1 and P2 are
group patterns, and R is a built-in expression. Let A be a built-in
expression or a group pattern, and let l a be a mapping; then
varA is the set of variables occurring in A, and lA is the result
of replacing in A, for each variable x where rx is defined, each
occurrence of x with rx.

expression

pattern

group

the

an

or

of

We next define the notion of answers to group patterns on an
RDF graph. Please note that the 1.0 version of SPARQL does not
specify how to evaluate BGPs under entailment relations other
than Simple Entailment. The 1.1 version of SPARQL is expected to
correct this, but the details have not yet been finalized. In this pa-
per, we adopt definitions that, we believe, are likely candidates for
the formalization of SPARQL 1.1. Our definitions address the following two technical problems.

for

[33],

; RDF lB

First, we must ensure that answers are always finite. Consider
B 14 fhx; rdf:type; rdf:Propertyig. Due to the axiomatic triples of
each l such that
RDF Entailment
lx 2 frdf: 1; rdf: 2; . . .g. Thus, if the answer to B on the empty
RDF graph under RDF Entailment is to be finite, it cannot contain
such mappings. As a remedy, we assume that, for each entailment
relation X and each graph G, one can determine the answer domain
adXG #UBL of G w.r.t. X. Then, for each group pattern P and each
mapping l contained in the answer to P on G w.r.t. X, we require
rngl # adXG; thus, adXG identifies the subset of UBL that is allowed to occur in an answer to P in G w.r.t. X. If adXG is finite, then
each answer to P on G w.r.t. X will be finite as well. In our example,
to ensure that answers to group patterns are finite on finite graphs,
we can define the answer domain for RDF Entailment as
adRDFG 14 ulRDFG [ bRDFG, which effectively restrict the answers
to refer only to the elements of UBL that occur in G.

G 14 fha; b; ci;hd; e; :yig
P 14 fha; b; xig
l 14 fx # :yg

Second, we must deal with the fact that blank nodes are treated
in SPARQL as objects with distinct identity. To understand this,
consider G; P, and l defined as follows, where :y is a blank node:


Even though G RDF lP, the answer to P on G under RDF entailment should not contain l. Roughly speaking,
:y is distinct from
c even though :y is semantically a placeholder for an arbitrary
URI reference. We capture this idea using skolemization: we replace
the blank nodes in G with fresh URI references, thus giving each
blank node a unique identity. Our answers are isomorphic to the answers of the current SPARQL 1.1. specification, so skolemization allows us to simplify the technical presentation without losing
generality. We formalize this idea by evaluating group patterns in
nXG instead of mXG.

Table 1
Semantics of group patterns.

G 14 flj doml 14 varB; rngl # adXG; and nXG  9bXlB : pXlBg

sBtX
sP1 and P2tX
sP1 union P2tX
sP1 opt P2tX
sP1 filter RtX

G ffl sP2tX
G [ sP2tX
G ffl sP2tX

G 14 sP1tX
G 14 sP1tX
G 14 sP1tX
G 14 fl 2 sP1tX

G jl  Rg

G [ sP1tX

G n sP2tX

Table 1 defines the answer sPtX

G to a group pattern P in a graph G

w.r.t. an entailment relation X.

G, sP1 opt P2tX

G, sP1 union P2tX

G, and sP1 filter RtX

Note that the official semantics of SPARQL treats answers as
multisets, rather than sets of mappings. The multiset variant of
SPARQL can be formalized as in Table 1, but by using the multiset
versions of ffl and the set operators in the definitions of
sP1 and P2tX
G. As we
show in the following sections, our temporal extension of SPARQL
essentially changes just the definition of sBtX
G. Thus, we can obtain
a temporal extension of SPARQL with multiset semantics by using
the multiset versions of group patterns that are not basic. Analo-
gously, by using the appropriate version of the set operators, our
algorithms for computing answers to temporal queries can be
modified to support the multiset semantics. Therefore, in this paper we simplify the presentation by treating answers to be sets,
rather than multisets; as in [30], we do not believe that this affects
the generality of our results in any significant way.

3. Representing validity time in RDF and OWL

Existing RDF and OWL ontologies often contain temporal infor-
mation. For example, the following (nontemporal) RDF triple represents the fact that Oktoberfest 2011 starts at time instant 80
(we will discuss shortly our choice of representing time instants
as integers).

h:Oktoberfest 2011; :startsAt; 80i

Despite the fact that it refers to time instants, triple (4) can be considered as being universally true at all time instants. To understand
why this might be a practical problem, assume that the Oktoberfest
organizing committee meets at time instant 40 and decides that
Oktoberfest 2011 should start at time instant 120; however, due
to popular demand, the organizing committee reconvenes at time
instant 60 and decides to start the event at time instant 80. One
can encode such information using an ad hoc solution; for example,
one could introduce a property :previouslyStartsAt to record previously considered start time instants. A more principled solution,
however, would be to explicitly represent the fact that triple

h:Oktoberfest 2011; :startsAt; 120i

is true between time instants 40 and 60, but that triple (4) is true
from time instant 60 onwards. In other words, we would like to
annotate our triples with validity times to specify the time instants
at which the triples are true. In the rest of this section, we present a
framework that can be used to achieve this goal. In particular, our
framework allows for temporal RDF triples such as (6) and (7), which
we interpret formally in first-order logic.

h:Oktoberfest 2011; :startsAt; 120i1240; 59
h:Oktoberfest 2011; :startsAt; 80i1260;1


Please note the distinction between two kinds of
temporal
information in the above example. Time instants 120 and 80 do
not specify the validity time of RDF triples; thus, we can process
such information using an adequate datatype and a suitable set of
built-in SPARQL expressions, the design of which is not the subject
of this paper. In contrast, our framework focusses on techniques for
the management of annotations such as 1240; 59 and 1260;1 that
restrict the validity of triples to specific time intervals.

A simple extension of RDF with validity time might include
annotating each triple with a time instant that specifies when
the triple is true. Triples, however, can be true for long periods of
time, which makes listing all time instants explicitly impractical.
Furthermore, triples that hold from/to eternity would need to be
associated with infinitely many instants, which is practically
infeasible.

We overcome these problems by applying the principles from
temporal databases. In particular, Chomicki [39] distinguishes an
abstract from a concrete temporal database [39]. An abstract temporal database can be understood as a sequence of static dat-
abases, each of which contains the facts that are true at one
particular time instant. Since the number of time instants is generally assumed to be unbounded, an abstract temporal database is
infinite and thus cannot be represented explicitly. In contrast, a
concrete temporal database is a finite specification of abstract temporal databases. The correspondence between concrete and abstract temporal databases is zero-to-many: a concrete temporal
database that contains a contradiction corresponds to no abstract
temporal databases; similarly, a concrete temporal database may
not fully specify the truth of facts at all time instants, so it may correspond to several abstract temporal databases. In the rest of this
section we apply this approach to RDF and OWL. In particular,
we devise a notion of temporal RDF and OWL graphs, which correspond to concrete temporal databases in the framework by Chom-
icki. Furthermore, we provide the semantics to temporal graphs by
mapping them into first-order theories; the models of these theories correspond to abstract temporal databases in the framework
by Chomicki.

In Section 4 we will need the ability to refer to predecessors and
successors of time instants, so we use a discrete model of time. Fur-
thermore, in this paper we do not consider implementation issues
such as mapping time instants to calendar points, or selecting the
appropriate granularity of the time line: any implementation of a
time line that is isomorphic with the set of integers can be used.
Thus, to simplify the definitions, we take the set of all time instants TI to be the set of all integers, and we assume TI to be disjoint with UBL. We use many-sorted first-order logic with a
temporal sort t interpreted over TI; we sometimes write tt to stress
that a term t is of sort t. The following example demonstrates the
benefits of using many-sorted first-order logic.
Example 1. Let w 14 f8x : x  cg [ C be the theory that corresponds with the first-order encoding of the (nontemporal) OWL 2
DL ontology containing axiom > v fcg. Theory w requires all objects
in a domain set to be equal. Thus, if we assume the interpretation
domain set to contain TI, then w becomes unsatisfiable, which is
clearly undesirable. In contrast, w is satisfiable in our many-sorted
setting: since x is not of sort t, the universal quantifier in formula
8x : x  c does not range over time instants. h

We integrate temporal instants into first-order logic as follows.

 We allow each time instant t 2 TI to be used in first-order formulae as a constant of sort t; each such time instant is interpreted in each interpretation as t.

 We introduce the binary predicate 6 (with both arguments of
sort t), which is interpreted in each interpretation as the standard ordering on integers. We often abbreviate t1 6 t ^ t 6 t2
as t1 6 t 6 t2.
 We introduce unary functions 1 and 1 (with the argument
and the function value of sort t); usually, we write 1t and
1t as t  1 and t  1, respectively. These functions are interpreted in each interpretation as the successor and predecessor
functions on integers.

We will often need to describe temporal intervals with unbounded start- and/or end-points. To this end, we introduce special
constants 1 and 1 (not occurring in UBL [ TI), which we allow to occur only in atoms of the following forms, for tt a term
of sort t:

1 6 tt

 1 6 1

tt 6 1

All such atoms should be understood as syntactic abbreviations for
true. Thus, 1 and 1 are not constants in the sense of first-order
logic: they are not mapped to objects in an interpretation domain,
but are used as syntactic abbreviations. Constants 1 and 1 allow us to simplify the notation for unbounded time intervals; for
example, to state that the interval described by the formula
t1 6 xt 6 t2 has no lower bound, we can replace t1 with 1, which
makes the formula equivalent to xt 6 t2. In addition to the set TI of
all temporal instants, we use the following sets in the rest of this
paper:

TI 14 TI [ f1;1g
TI 14 TI [ f1g
TI 14 TI [ f1g

We use 6 and \ as the orderings on TI defined in the obvious way.
Note that symbol 6 thus ambiguously denotes both an ordering and
a predicate; however, the appropriate meaning of the symbol
should be clear from the context. We use analogous conventions
for 1 and 1.

We next define the notion of temporal RDF graphs.

Definition 2. A temporal triple is an expression of the form
hs; p; oi12t or hs; p; oi12t1; t2 such that s; p; o 2 UBL, t 2 TI, t1 2 TI,
and t2 2 TI. A temporal graph G is a finite set of temporal triples.

In order to store temporal triples in Web documents, a suitable
encoding of temporal triples is needed. One possibility is to extend
the RDF syntax and explicitly capture temporal information. Another possibility is to develop an encoding similar to the one used
in [22] which encodes temporal graphs into nontemporal graphs
by reifying temporal triples. In this paper, we do not discuss such
implementation details, but instead focus on the conceptual aspects of the syntax, semantics, and query answering.

We next define the semantics of temporal triples by mapping
them into formulae of many-sorted first-order logic. Towards
this goal, we associate facts with validity time instants via the
temporal arguments approach [40]. More concretely, for each
n-ary predicate P, we introduce an n  1-ary predicate ^P in
then, ^Pu1; . . . ; un; tt
which the last argument
encodes the fact that Pu1; . . . ; un is true at time instant tt. As
explained in Section 2,  is an ordinary predicate with an explicit axiomatization, so ^ is a well-defined ternary predicate that
should be understood as time-varying equality; the rationale
behind such a definition is discussed in more detail in Example
12 at the end of this section.

is of sort

t;

For a (nontemporal) first-order formula u and a term tt of sort t,
we define uhtti as the formula obtained from u by replacing each
atom Pu1; . . . ; un with ^Pu1; . . . ; un; tt. Intuitively, uhtti states that
the condition expressed by u holds at the time instant corresponding to tt.

Our definitions use a special unary predicate O. This predicate
should be understood as being internal to our semanticsthat
is, it should not occur in any input. Furthermore, we assume that
the axiomatization of equality C does not contain the replacement
rules for O. Intuitively, predicate O will be axiomatized so that it
contains all elements of ulXG [ bXG that occur in G. As a
consequence of such a definition, whenever a temporal graph

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Table 2
Mapping temporal graphs into logic.

vT

vhs; p; oi12t 14 ^Ts; p; o; t
vhs; p; oi12t1; t2 14 8xt : t1 6 xt 6 t2 ! ^Ts; p; o; xt
pXG 14
xXG 14

mXG 14 9bXG : xXG ^ pXG

O :x

T2G

:x2bXG

g [ fOuj u 2 ulXGg [ f8xt : uhxtiju 2 CXg

G1 X-entails a temporal graph G2, all blank nodes in G2 are satisfied
by objects occurring in uslXG1. We discuss the rationale behind
this in Example 9.

We are now ready to define the mapping of temporal graphs

into many-sorted first-order logic.

Definition 3. Let X be an entailment relation from Section 2 other
than DL, and let CX be the first-order theory that characterizes X.
Then, for G a temporal graph,

respectively, that occur in G;

X G are the subsets of U [ L, B, and TI,

 ulXG, bXG, and ti
 pXG, xXG, and mXG are defined as shown in Table 2;
 nXG is obtained from mXG by skolemizing the existential
quantifiers in 9bXG;
 uslXG is ulXG extended with the URI references used for the
skolemization of mXG; and
 the X-skolemization of G is the result of replacing in G each blank
node from bXG with the corresponding URI reference from
uslXG.

Graph G is X-satisfiable if mXG is satisfiable. A temporal graph
G1 X-entails
if

mXG1  mXG2.

graph G2, written G1 X G2,

temporal

Example 4. Let G1 be the temporal graph containing temporal
triples (8)(11).

h:LHR; :flightTo; :MUCi1250; 120
h:LHR; :flightTo; :MUCi12100; 150
h:Munich; :hosts; :Oktoberfesti1280; 180
h:hosts; rdfs:subPropertyOf ; :hasEventi12130; 300


Triples in (8) and (9) state that there is a flight from LHR to MUC;
this information may have been gathered from two distinct sources,
so validity times of the two triples overlap. Triple (10) states that
Munich hosts Oktoberfest. Finally, triple (11) states that, if x hosts
y, then x has y as an event; that this statement is not universally
true might be due to the fact that events are relevant only during
holiday seasons. Now let G2 be the temporal graph containing temporal triple (12).

h:Munich; :hasEvent; :Oktoberfesti12130; 180

One can readily verify that, according to Definition 3, G1 RDFSentails G2. h

OWL 2 Direct Entailment is not characterized by a fixed set of
first-order implications, so we next present separate definitions
that are applicable to this entailment relation. We start by defining
the notion of temporal OWL 2 DL axioms. The following definition
allows us to attach validity time to arbitrary axioms and not just
facts, which provides us with a flexible language that can repre-
sent, for example, class hierarchies that change over time.

Definition 5. A temporal OWL 2 DL axiom is an expression of the
form a12t or a12t1; t2, where a is an OWL 2 DL axiom, t 2 TI,

t1 2 TI, and t2 2 TI. A temporal OWL 2 DL ontology is a finite set
of temporal OWL 2 DL axioms. Temporal axioms are mapped into
many-sorted first-order formulae as follows, where ha is the
translation of an OWL 2 DL axiom a into first-order logic as
discussed in Section 2:

ha12t 14 hahti
ha12t1; t2 14 8xt : t1 6 xt 6 t2 ! hahxti

Our ultimate goal is to apply the OWL 2 Direct Entailment to
temporal graphs. As in the case of nontemporal graphs, the first
step is to translate a temporal graph into temporal OWL 2 DL axi-
oms, and the following definition shows how to do this. Please refer to Section 2.2 for a brief overview of the transformation for
nontemporal RDF and an explanation of the notion of lead triples.

Definition 6. A temporal graph G encodes a temporal OWL 2 DL
ontology OG if OG can be extracted from G using the mapping
from [37] modified as follows:

1. Each triple hs; p; oi in [37, Tables 38 and 1015] is replaced

temporal triple hs; p; oi121;1;

with hs; p; oi121;1.
2. Each triple pattern T in [37, Tables 16 and 17] with a lead triple
hsL; pL; oLi producing an axiom a is replaced with the following
triple patterns T1 and T2.
Triple pattern T1 is obtained from T as follows:
(a) each triple hs; p; oi other than hsL; pL; oLi is replaced with
(b) hsL; pL; oLi is replaced with hsL; pL; oLi12t; and
(c) T1 produces the temporal axiom a12t.
Triple pattern T2 is obtained from T as follows:
(d) each triple hs; p; oi other than hsL; pL; oLi is replaced with
(e) hsL; pL; oLi is replaced with hsL; pL; oLi12t1; t2; and
(f) T2 produces the temporal axiom a12t1; t2.

temporal triple hs; p; oi121;1;

The

following example discusses

the

intuition behind

Definition 6.

Example 7. As explained in Section 2.2, the RDF encoding of each
(nontemporal) OWL 2 DL axiom contains a single lead triple, which
represents the axiom in an RDF graph. Thus, axiom A v 9R:B is
encoded using triples (13)(16), with (13) being the lead triple.

hA; rdfs:subClassOf ; :xi
h :x; rdf:type; owl:Restrictioni
h :x; owl:onProperty; Ri
h :x; owl:someValuesFrom; Bi


By Definition 5, one can associate validity time with axioms, but
not with parts of axioms (such as 9R:B). Therefore, Condition 1 of
Definition 6 requires triples that encode parts of axioms, such as triples (14)(16), to be annotated with 121;1. Condition 2 of Definition 6 essentially says that, to annotate an OWL 2 DL axiom with
validity time, one should attach the validity time to the axioms lead
triple and annotate all other triples with 121; 1. Thus, each triple
pattern from [37, Tables 15 and 17] that recognizes a nontemporal
OWL 2 DL axiom is transformed into two triple patterns: the one
defined in conditions 2(a)(c) recognizes temporal axioms that hold
at a single time instant t, and the one defined in conditions 2(e)(f)
recognizes temporal axioms that hold between time instants t1 and
t2. Consequently, temporal axiom A v 9R:B125; 8 should be encoded using temporal RDF triples as follows, which allows the triple
patterns from Definition 6 to reconstruct the original axiom.

hA; rdfs:subClassOf ; :xi125; 8
h :x; rdf:type; owl:Restrictioni121;1
h :x; owl:onProperty; Ri121;1
h :x; owl:someValuesFrom; Bi121;1


Apart from the modifications outlined in Definition 6, the process of
extracting OG from G is the same as in [37]. If the transformation
fails, G does not encode a temporal OWL 2 DL ontology, and so G
cannot be used with temporal OWL 2 Direct Entailment. h

We are finally ready to define the semantics of temporal graphs
under OWL 2 Direct Entailment. Remember that C is the axiomatization of the equality predicate .

Definition 8. Let G be a graph that encodes a temporal OWL 2 DL
ontology OG. Then,

 ulDLG; bDLG, and ti
 pDLG; xDLG, and mDLG are defined as follows:

respectively, that occur in OG;

DLG are the subsets of U [ L;B, and TI,

A2OG

pDLG 14

hA

O :x

xDLG 14
mDLG 14 9bDLG : xDLG ^ pDLG

:x2bDLG

g[

fOuj u 2 ulDLGg [ f8xt : uhxtiju 2 Cg

 nDLG is obtained from mDLG by skolemizing the existential
quantifiers in 9bDLG;
 uslDLG is ulDLG extended with the URI references used for the
skolemization of mDLG; and
 the DL-skolemization of G is the result of replacing in G each
blank node from bDLG with the corresponding URI reference
from uslDLG.

Graph G is DL-satisfiable if mDLG is satisfiable. For G1 and G2 temporal graphs that encode temporal OWL 2 DL ontologies, G1 DLentails G2, written G1 DL G2, if mDLG1  mDLG2.

Based on these observations, we have m0
DLG1  m0
m0
DLG2  m0
m0
isfy the nonrigid existential quantifier 9z in (24).

DLG2 and
DLG3, which can be counterintuitive. Note also that
DLG1, which is intuitive: :y in (25) is rigid, so it can satIn our approach, OG1;OG2, and OG3 are translated into the

DLG1 2 m0

following first-order theories:

mDLG1 14 f 128xt : 9z : ^ps; z; xt; Os g [ D
mDLG2 14 f 129 :y : O :y ^ 8xt : ^ps; :y; xt; Os g [ D
mDLG3 14 f129 :y : O :y ^ ^ps; :y; 1; Os g [ D


As before, blank node :y is rigid in (28) and (29). Atoms Os and
O :y in (27)(29) thus essentially enumerate all rigid objects.
Consider now checking whether G1 DL-entails G2 or G3. Atoms
O :y in (28) and (29) ensure that 9 :y can be satisfied only by rigid
objects, and not by nonrigid objects implied by 9z in (27). Conse-
quently, we have mDLG1 2 mDLG2 and mDLG1 2 mDLG3, as one
might expect. Furthermore, note that the O predicate does not preclude the conclusion mDLG2  mDLG1.

To summarize, blank nodes can be understood in our framework
as unnamed constants that denote the same object at all time instants.
This is in line with all proposals for validity time on the Semantic Web
known to us, including the one by Gutierrez et al. [22]. h

The rigidity of blank nodes allows us to eliminate them from

entailment problems as shown next.

Theorem 10. Let X be an entailment relation, let G be a temporal
:x be a blank node, and let w be a formula with free
graph, let
variable :x. Then, nXG  9 :x : O :x ^ w holds if and only if an
element u 2 uslXG exists such that nXG  rw for mapping
r 14 f :x # ug.

nXG  rw

that

holds

Assume

Proof. (U)
some
r 14 f :x # ug. Since u 2 uslXG, a formula of the form Ou ^ u
(with u possibly
so
is
nXG  9 :x : O :x ^ w clearly holds.
()) Assume that nXG  9 :x : O :x ^ w holds. Let I be an
arbitrary first-order model of nXG, and let I0 be the interpretation
defined as follows:

contained

nXG,

empty)

for

in

The following example explains the rationale behind the predi-

cate O in Definitions 3 and 8.

 MI0 14 MI;
 XI0 14 XI for each symbol X different from the special predicate O;

OG1 14 f 9p:>s121;1 g
OG2 14 f ps; :y121;1 g
OG3 14 f ps; :y121 g

Example 9. Let G1; G2, and G3 be temporal graphs that encode the
following temporal OWL 2 DL ontologies OG1;OG2, and OG3.


Let us for the moment assume that our definitions do not
include the atoms with the O predicate. Then, G1; G2, and G3 would
be translated into the following theories; to simplify the presenta-
tion, we abbreviate with D the set of formulae obtained from C.


Note that 9z comes after 8xt in (24), so z can refer to different objects at different time instantsthat is, variable z is not rigid. In con-
trast, 9 :y comes before 8xt in (25), so the object that :y refers to
does not depend on xtthat is, blank node :y is rigid as it refers
to the same object at all time instants. Finally, the rigidity of
:y
in (26) is irrelevant, since (26) does not quantify over time instants.

DLG1 14 f 128xt : 9z : ^ps; z; xtg [ D
m0
DLG2 14 f 129 :y : 8xt : ^ps; :y; xt g [ D
m0
DLG3 14 f 129 :y : ^ps; :y; 1 g [ D
m0

and

 OI0 14 fsI j s 2 uslXGg.
The predicate O occurs in nXG only in formulae of the form
Ou ^ u (with u possibly empty) for u 2 uslXG1. Therefore, we
have OI0
# OI and I0  nXG; but then, nXG  9 :x : O :x ^ w
implies I0  9 :x : O :x ^ w. Thus, an element u 2 uslXG exists
such that I0  rw for r 14 f :x # ug; but then, OI0
implies
I  rw as well, which proves our claim. h

# OI

The following theorem provides us with basic building blocks
for checking temporal entailment; we use this result in Section
5.1 to obtain a concrete algorithm.

Theorem 11. Let X be an entailment relation, and let G1 and G2 be
temporal graphs. Then, G1 X G2 if and only if both of the following
two conditions hold:

mapping

 a
nXG1  pXrG2, and
 for each u 2 ulXG2, either u 2 ulXG1 or ulXG2 contains a literal

r : bXG2 ! uslXG1

exists

such

that

semantically equivalent with u.

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Proof. By Definitions 3 and 8, G1 X G2 iff mXG1  mXG2. Since
nXG1 is the skolemization of mXG1, by the properties of skolemization from Section 2.1, the latter condition is equivalent to
nXG1  mXG2. By Definitions 3 and 8, each formula w in mXG2
is of one of the following three types:

 9bXG2 : xXG2 ^ pXG2,
 Ou with u 2 ulXG2, and
 a formula of the form 8xt : uhxti where u is contained in CX or
C.

Since semantic entailment
is distributive over conjunction,
nXG1  mXG2 if and only if nXG1  w for each formula w mentioned above. We have the following cases:

 Assume w 14 9bXG2 : xXG2 ^ pXG2. By Theorem 10, then
nXG1  w if and only if a mapping r : bXG2 ! uslXG1 exists
such that the entailment nXG1  rpXG2 holds. By the definition of pX, we have rpXG2 14 pXrG2, so the last condition is equivalent to nXG1  pXrG2.
 Assume w 14 Ou. If we have u 2 ulXG1, then w 2 nXG1, so
nXG1  w clearly holds. In contrast, assume that u R ulXG1;
since O occurs in nXG1 only in atoms of the form Ov (note
that nXG1 does not even contain the replacement axioms for
O), then nXG1  w if and only if nXG1 contains an atom of
the form Ov where v is a literal semantically equivalent with
u.
 Assume w 14 8xt : uhxti. But then, w 2 nXG1, so nXG1  w
always holds.

The claim of this theorem follows immediately from the above
arguments. h

We finish this section with a brief discussion of why the equality predicate  is treated in our framework as an ordinary predicate with an explicit axiomatization.

Example 12. Let G be a temporal graph such that OG contains
the following temporal OWL 2 DL axioms.

a  b121 Ca121; 2 :Cb123 Da123

Then pDLG is defined as follows:
pDLG14 ^a;b;1^:^Cb;3^ ^Da;3^128xt :16 xt 6 2! ^Ca;xt

Furthermore, mDLG contains pDLG; Oa; Ob, and the following
formulae obtained from C.

8xt; y : ^y; y; xt
8xt; y1; y2 : ^y1; y2; xt ! ^y2; y1; xt
8xt; y1; y2; y3 : ^y1; y2; xt ^ ^y2; y3; xt ! ^y1; y3; xt
8xt; y1; y2 : ^Cy1; xt ^ ^y1; y2; xt ! ^Cy2; xt
8xt; y1; y2 : ^Dy1; xt ^ ^y1; y2; xt ! ^Dy2; xt


First, note that, in each model I 14 MI;	I of mDLG, the domain set
MI is rigidthat is, it is the same at all time instants. Second, note
that the interpretation of constants in each such I is also rigid: aI
and bI are fixed domain elements that do not depend on the time
instant. Third, the interpretation of  is not rigid: constants a and
b are equal in each model of mDLG at time instant 1, but a model
of mDLG exists in which a and b are not equal at time instants
other than 1. Thus, mDLG is satisfiable even though OG contains
axiom :Cb123; furthermore, one can see that

mDLG  ^Cb; 1
mDLG  9x : ^Cx; 1 ^ ^Dx; 3
mDLG 2 ^Cb; 2


all hold in mDLG. h

4. Querying temporal graphs

To design a temporal query language, we must first identify the
types of questions that the language should support. The language
of first-order logic readily reveals the following natural types of
questions, where B is a BGP, G is a temporal graph, and t, t1, and
t2 are time instants:

Q1. Is B true in G at instant t?
Q2. Is B true in G at all instants between t1 and t2?
Q3. Is B true in G at some instant between t1 and t2?

By allowing t, t1, and/or t2 to be variables, we obtain non-Boolean
questions that not only check the truth of B in G, but also retrieve
values from G.

Such questions can be easily encoded using first-order formu-
lae. Furthermore, the answer to a query Q in a temporal graph G
w.r.t. an entailment relation X can be defined to contain each mapping l of the free variables of Q to UBL [ TI such that G X lQ.
Such an approach, however, exhibits several important drawbacks,
as the following example demonstrates.

Example 13. Let G1 be the temporal graph shown in (40) and let Q
be the query shown in (41).

G1 14 fha; b; ci125; 12; ha; b; ci129;1g
Qx1; x2 14 8x : x1 6 x 6 x2 ! ha; b; ci12x


Evaluating Q on G1 would not be a problem if x1 and x2 were concrete time instants. Note, however, that Q retrieves x1 and x2, and
that it does not ask for maximal x1 and x2. Thus, without any restric-
tions, the answer to Q on G1 is infinite since it contains each mapping l such that 5 6 lx1 6 lx2 6 1.

# 5; x2

# 9; x2

For

To overcome this problem, one might restrict all mappings in an
answer to Q to refer only to time instants occurring in G. This,
however, also has undesirable consequences. First, such answers
can contain redundant mappings.
example, mapping
#  1g is the most general mapping in the
l1 14 fx1
answer to Q on G1, but the answer also contains a less general
# 12g. Second, answers can differ on
mapping l2 14 fx1
syntactically different but semantically equivalent
temporal
graphs. For example, let G2 be the temporal graph shown in (42).

Note that G2 is equivalent with G1 under Simple Entailment; how-
ever, mapping l2 is not contained in the answer to Q on G2, and
mapping l3 14 fx1
# 10g is not contained in the answer to
Q on G1. Third, computing redundant answers can be costly: an answer to Q in a graph with n overlapping intervals consists of mappings that refer to any two pairs of interval endpoints, so the
number of mappings in an answer can be exponential in n.

G2 14 f ha; b; ci125; 10; ha; b; ci127;1 g

# 7; x2

As a possible remedy, one might try to identify the most
general mappings. Note, however, that a mapping refers to time
instants rather than intervals; therefore, we were unable to devise
a generality criterion that would be backed by a clear semantic
justification. h

We deal with these problems in two stages. First, we introduce
primitives that support questions of types Q1Q3, and of types

Q4Q5 listed below. We thus introduce the notion of maximality
into our query language.

Table 4
Evaluating basic temporal group patterns.

Q4. Is 12t1; t2 the maximal interval such that B is true in G for each

time instant in the interval?

Q5. Is t the smallest/largest time instant at which B is true in G?

We define our notion of answers w.r.t. TI, which makes the answers independent from the syntactic form of temporal graphs. Sec-
ond, we define a syntactic notion of safety, which guarantees that
only questions of type Q4 and Q5 can bind variables in a temporal
query, which then ensures finiteness of query answers.

Practical applications will often need to express constraints on
time points and intervals retrieved via Q1Q5. For example, to retrieve hotels with vacancy during Oktoberfest, we must require
the duration of Oktoberfest to be contained in the hotels vacancy
period. Such conditions can be expressed, for example, using Allens
interval algebra [41], and they can be integrated into our query language via built-in expressions. For example, we can easily devise a
built-in expression that takes two pairs of interval end-points and
that evaluates to true if and only if the first interval is contained in
the second. Such extensions of our query language are straightfor-
ward, so we do not discuss them further in the rest of this paper.

Definition 14. A temporal group pattern (TGP) is an expression
defined inductively as shown in Table 3, where B is a BGP, P1 and P2
are TGPs, R is a built-in expression, t1 2 TI [ V; t2 2 TI [ V, and
t3 2 TI [ V. TGPs from the first two lines of the table are called
basic.
For B a variable-free BGP and X an entailment relation, xXB is
the formula defined as follows, where O is the special predicate
from Section 3:

xXB 14

O :x

:x2bXB

We redefine a mapping as a partial

function from V to
UBL [ TIthat is, l : V ! UBL [ TI. Let X be an entailment relation and G a temporal graph. We define adXG 14 adXG0, where G0
is the nontemporal graph obtained by replacing each temporal triple in G of the form hs; p; oi12u or hs; p; oi12u1; u2 with hs; p; oi. The
answer to a basic temporal group pattern P in G w.r.t. X is the set
sPtX

G that contains each mapping l such that

 doml 14 varP,
 rngl # adXG [ TI, and
 S 14 lP is a well-formed variable-free TGP that satisfies condi-

tion dXS; G in Table 4.

Answers to TGPs that are not basic are defined as shown in Table 1.

Definition 14 should intuitively be understood as follows. Let P
be a TGP, let G be a temporal graph, and let X be an entailment rela-
tion. Then, the answer sPtX
G to P on G w.r.t. X contains each mapping
l that maps all variables in P into an element of adXG [ TI; thus,
each lx is either an element of the answer domain of G w.r.t. X, a
temporal instant, 1, or 1. Mapping l must be such that lP is
a well-formed variable-free TGP. For example, for P 14 ha; b; ci at x,
l1 14 fx # dg, and l2 14 fx #  1g, we have l1P 14 ha; b; ci at d

Table 3
Definition of temporal group patterns.

B at t3
B maxint 12t1; t2
P1 and P2
P1 filter R

B during 12t1; t2
B mintime t3
P1 union P2

B occurs 12t1; t2
B maxtime t3
P1 opt P2

dXS; G

B at t3
B during 12t1; t2
B occurs 12t1; t2
B maxint 12t1; t2

nXG  9bXB : xXB ^ pXBht3i
nXG  9bXB : xXB ^ 8xt : 12t1 6 xt 6 t2 ! pXBhxti
nXG  9bXB : xXB ^ 9xt : 12t1 6 xt 6 t2 ^ pXBhxti
a mapping r : bXB ! uslXG exists such that
nXG  8xt : 12t1 6 xt 6 t2 ! pXrBhxti, and
t1 14 1 or nXG 2 pXrBht1  1i, and
t2 14 1 or nXG 2 pXrBht2  1i

B mintime t3

B maxtime t3

a mapping r : bXB ! uslXG exists such that

nXG  pXrBht3i and
nXG 2 9xt : 12xt 6 t3  1 ^ pXrBhxti

a mapping r : bXB ! uslXG exists such that

nXG  pXrBht3i and
nXG 2 9xt : 12t3  1 6 xt ^ pXrBhxti

and l2P 14 ha; b; ci at  1, which are not well-formed TGPs, so
l1 and l2 cannot be contained in an answer to P. Finally, the var-
iable-free TGP S 14 lP must satisfy the condition dXS; G from Table 4 that defines the semantics of basic TGPs. This condition
essentially make

 B at t3 of type Q1,
 B during 12t1; t2 of type Q2,
 B occurs 12t1; t2 of type Q3,
 B maxint 12t1; t2 of type Q4, and
 B mintime t3 and B maxtime t3 of type Q5.
Note that t3 cannot be1 or1: since these constants do not represent concrete time instants, asking whether B holds at1 or1
does not make sense. Similarly, t1 cannot be 1 and t2 cannot be
1 in order to ensure that all temporal intervals in TGPs are well
formed.

Conditions for S of types Q4 and Q5 involve several positive and
negative entailment checks, and the mapping r ensures that the
blank nodes in S are interpreted in all checks in the same way. This
affects the notion of answers as shown in the following example.

Example 15. Let G be a temporal graph and let P be a TGP defined
as follows:

G 14 fha; b; ci122; 5; ha; b; di123; 8g
P 14 ha; b; :yi maxint 12x1; x2


Blank node :y in P can be satisfied in G by either c or d, so the answer to
# 5g and
P on G w.r.t. Simple Entailment contains l1 14 fx1
# 8g. This is consistent with the rigid interpretation
l2 14 fx1
of blank nodes introduced in Section 3. h

# 3; x2

# 2; x2

One might argue that the conditions for S of type Q4 and Q5 are
not elegant because the interpretation of the blank nodes in S is not
captured using a first-order formula. As a possible remedy, one
might try to rewrite the condition for S 14 B maxint 12t1; t2 as
 nXG  9bXB 8xt : 12t1 6 xt 6 t2 ! pXBhxti, and
 t1 14 1 or nXG 2 9bXBpXBht1  1i, and
 t2 14 1 or nXG 2 9bXBpXBht2  1i.

Such a definition, however, would have counterintuitive conse-

quences, as shown by the following example.

Example 16. Let G, P, l1, and l2 be defined as in Example 15. With
the alternative condition for P outlined above, the answer to P on G
w.r.t. simple entailment does not contain l1, since it is not the case

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Table 5
Example temporal group patterns.

fhx; :flightTo; :MUCi; h:Munich; :hosts; :Oktoberfestig maxint 12y; z
fh:Munich; :hosts; :Oktoberfestig maxint 12x; y and fh:London; :hosts; zig occurs 12x; y
fh:Munich; :hosts; :Oktoberfestig mintime x
fh:Room123; :hasPrice; xi; h:Munich; :hosts; yig occurs 1250; 100

(45)
(46)
(47)
(48)

that nsimpleG 2 9 :y : O :y ^ ^Ta; b; :y; 6; one can analogously see
that the answer does not contain l2 either. Intuitively, this is
because the alternative condition for P does not ensure that the
blank nodes in P are interpreted in the same way in all entailment
checks. h

Conditions for S of types Q4 and Q5 can be formulated in an
autoepistemic extension of first-order logic with a modal operator
K, such as the one used in the definition of the EQL-Lite query language [42]. A detailed discussion of such an alternative formulation
is out of scope of this paper; we merely observe that the condition
for S 14 B maxint 12t1; t2 (with t1
  1) could be expressed as

  1 and t2

nXG  9bXB : xXB ^ K 8xt : t1 6 xt 6 t2 ! pXBhxti

:KpXBht1  1i ^ :KpXBht2  1i

and that conditions for S of type Q5 could be expressed in an analogous way.

We next present several temporal graph patterns and their

answers.

Example 17. Let G be the temporal graph containing triples (8)
(11) from Section 3. Table 5 shows several TGPs that could be used
in our running example.

TGP (45) returns all airports x and all maximal intervals 12y; z
during Oktoberfest in which there is a flight from x to Munich
airport. The answer to (45) on G contains only the mapping
fx # :LHR; y # 80; z # 150g.

TGP (46) retrieves the duration 12x; y of Oktoberfest and all
events z in London that have at least one time point in common
with 12x; y. If occurs were changed to during, the TGP would retrieve
all events z in London whose duration is contained in 12x; y.

TGP (47) retrieves the first time instant at which Munich hosts
Oktoberfest. The answer to (47) on G contains only the mapping
fx # 80g.

TGP (48) returns all prices x for a particular room during an

event y in Munich within interval [50,100]. h

According to Definition 14, adXG does not contain ti

X G, so the
time instants used in temporal triples do not affect the answer domain of a temporal graph. This allows us to prove the following
property.

Proposition 18. Let X be an entailment relation, let G1 and G2 be
temporal graphs, and let G0
2 be the X-skolemizations of G1 and
G2, respectively. If G0
1 X G0
1, and adXG1 14 adXG2, then
for each temporal group pattern P we have sPtX

1 and G0
2, G0

2 X G0

G1 14 sPtX

G2

1 X G0

2 X G0

2 and G0

1, we have that formulae mXG0

Proof. Due to G0
and mXG0
2 are equivalent; but then, so are nXG1 and mXG2. Based
on this observation, we prove our claim by induction on the structure of P. The inductive steps are straightforward, so we consider
only the base cases where P is a basic TGP.

let l be an arbitrary mapping such that

Let P 14 B at t3;

lt3 2 TI. Then,

nXG1  9bXlB : xXlB ^ pXlBhlt3i

if and only if

nXG2  9bXlB : xXlB ^ pXlBhlt3i:

Thus, adXG1 14 adXG2 implies sPtX
gous for all other types of basic TGPs. h

G1 14 sPtX

G2

. The proof is analo-

and G2

Example 19. Let G1 and G2 be as specified in Example 13. Although
have
G1
adXG1 14 adXG2. Thus, since the X-skolemizations of G1 and G2
X-entail each other, for each TGP P we have sPtX

instants, we

different

contain

time

. h

G1 14 sPtX

G2

Note that Proposition 18 requires the X-skolemizations of G1
and G2 to X-entail each other, rather than G1 and G2 themselves.
This is not a side-effect of our temporal framework: as the following example shows, this is already the case in nontemporal
SPARQL.

Example 20. Let G1 and G2 be the nontemporal graphs defined in
(49) and (50), respectively; furthermore, let P be the BGP (51);
finally, let X be Simple Entailment.

G1 14 fha; b; :xi;hc; d; :yig
G2 14 fha; b; :yi;hc; d; :xig
P 14 fha; b; zig


The X-skolemizations of G1 and G2 are as follows, where u1 and u2
are used to skolemize :x and :y, respectively.

1 14 fha; b; u1i;hc; d; u2ig
G0
2 14 fha; b; u2i;hc; d; u1ig
G0


Clearly, adXG1 14 adXG2. Furthermore, we clearly have G1 X G2
and G2 X G1; however, we also have G0
1. In other
words, G1 and G2 X-entail each other, but their X-skolemizations do
not. Since P is evaluated in G1 and G2 w.r.t. their X-skolemizations,
the answers to P on G1 and G2 differ:

2 and G0

2 2X G0

1 2X G0

sPtX
sPtX

G1 14 f fz # u1g g
G2 14 f fz # u2g g


This example can be straightforwardly extended to temporal graphs
and queries, which requires us to restrict the applicability of Proposition 18. Apart from these issues inherited from nontemporal RDF
and SPARQL, however, Proposition 18 shows that the addition of
validity time does not introduce further problems. h

Since the answers are defined w.r.t. the entire set TI, basic
TGPs can have infinite answers, as discussed at the beginning of
this section. We next define a notion of safe TGPs. In Section 5.2
we then present an algorithm that computes a finite answer for
each safe TGP.

Definition 21. Let P be a temporal group pattern. Then, tvarP and
bindP are sets of variables, and safeP is a Boolean value defined
as shown in Table 6. Pattern P is safe if and only if safeP 14 true.

Intuitively, x 2 bindP ensures that lx 2 ti

X G for each map-
G. Thus, B at t3, B during 12t1; t2, and B occurs 12t1; t2 are
ping l 2 sPtX
safe if and only if t1, t2, and t3 are not variables: B can be true at
potentially infinitely many time instants, which could give rise to
infinite answers if t1, t2, or t3 were a variable.
In contrast,
B maxint 12t1; t2, B mintime t3, and B maxtime t3 are always safe as
there are finitely many maximal intervals in which B is true. For
P 14 P1 union P2, a mapping in an answer to P is produced either

Table 6
The definition of functions tvar, bind, and safe.

B at t3
B during 12t1; t2
B occurs 12t1; t2
B maxint 12t1; t2
B mintime t3
B maxtime t3
P1 and P2
P1 union P2
P1 opt P2
P1 filter R

tvarP
ft3g \ V
ft1; t2g \ V
ft1; t2g \ V
ft1; t2g \ V
ft3g \ V
ft3g \ V
tvarP1 [ tvarP2
tvarP1 [ tvarP2
tvarP1 [ tvarP2
tvarP1

bindP

tvarP
tvarP
tvarP
bindP1 [ bindP2
bindP1 \ bindP2
bindP1
bindP1

safeP
tvarP 14 ;
tvarP 14 ;
tvarP 14 ;
true
true
true
tvarP 14 bindP
safeP1 ^ safeP2
safeP1 ^ safelbindP1P2
safeP1 ^ varR # varP1

Note: mapping lbindP1 is defined by setting lbindP1x 14 0 for each x 2 bindP1.

by P1 or P2, so both P1 and P2 must be safe for P to be safe. For
P 14 P1 opt P2, the definition of safety assumes that P1 is evaluated
before P2: to evaluate P, one first evaluates P1, and then for each
mapping l in the answer, one evaluates lP2, so P is safe if and
only if P1 and lP2 are safe. For P 14 P1 filter R, all time instants
in an answer to P are produced by P1, so P is safe if and only if P1
is safe. Finally, for P 14 P1 and P2, each time instant in an answer
to P is produced by P1 and P2, so P is safe if and only if the value
of each variable in the answer is produced by either P1 or P2. Note
that this allows P to be safe even if neither P1 nor P2 is safe.

5. Algorithms for temporal graphs

In this section we turn our attention to the computational problems involving temporal graphs. In particular, in Section 5.1 we
show how to solve certain basic types of entailments involving
temporal graphs; then, in Section 5.2 we use these results to obtain
an algorithm for computing answers to safe TGPs.

5.1. Checking temporal entailments

In this section we show how to reduce several basic types of
temporal entailment to nontemporal entailment. We first show
how, given an entailment relation X and a temporal graph G, one
can extract a nontemporal graph NXG; t that describes the consequences of G at a time instant t 2 TI. As in all definitions presented
thus far, we must treat the case of OWL 2 Direct Entailment sepa-
rately; hence, we proceed as follows.

 If X  DL, then NXG; t contains each nontemporal triple a for
which G contains a temporal triple of the form a12t or a12t1; t2
with t1 6 t 6 t2.
 For X 14 DL, let OG; t be the nontemporal OWL 2 DL ontology
that contains each OWL 2 DL axiom a for which OG contains
a temporal axiom of the form a12t or a12t1; t2 with t1 6 t 6 t2;
then, NXG; t is the nontemporal graph that encodes OG; t.
Let N be an arbitrary subset of TI. A pair t1; t2 with
t1; t2 2 TI is consecutive w.r.t. N if t1 6 t2 and no t 2 N exists with
t1 < t < t2. The following property follows straightforwardly from
the definition of NXG; t.

Proposition 22. Let X be an entailment relation, let G be a temporal
graph, and let t be an arbitrary time instant such that t 2 TI n ti
X G.
For each time instant t0 2 TI such that t; t0 or t0; t is consecutive
X G, we have NXG; t # NXG; t0; furthermore, if in addition
w.r.t. ti
we have t0 R ti

X G, then NXG; t 14 NXG; t0 holds as well.

We next identify interesting time instantsthat is, time instants at which the consequences of G can change. Let t1 2 TI
and t2 2 TI; then, exXG; t1; t2 is the smallest set satisfying the
following conditions:

 for each t 2 ti
t 2 exXG; t1; t2;

X G \ TI

such that

t1 6 t 6 t2, we have

  1, then t1 2 exXG; t1; t2;
  1, then t2 2 exXG; t1; t2; and

 if t1
 if t2
 if t1 14 1 and t2 14 1, then 0 2 exXG; t1; t2.
Furthermore, allXG; t1; t2 is the smallest set such that, for each
t 2 exXG; t1; t2, we have
 t 2 allXG; t1; t2,
 t1 < t implies t  1 2 allXG; t1; t2, and
 t < t2 implies t  1 2 allXG; t1; t2.

With these definitions in place, we can obtain the desired
reductions as shown in Table 7. The following theorem shows that
the reductions are correct.

Theorem 23. All claims in Table 7 are true.

Proof. Note that, by Definitions 3 and 8, nXG contains precisely
one formula of the form

Ou ^

wihtii ^

8xt : t1

6 xt 6 t2

j  ! jjhxti;

i141

j141

zero of more formulae of the form Ou, and zero or more formulae
of the form 8xt : ukhxti. For an arbitrary time instant t 2 TI, let  t be
the set of formulae that contains

 wihtii for each 1 6 i 6 m such that ti 14 t,
 jjhti for each 1 6 j 6 n such that t1
 ukhti for each k.

6 t 6 t2

j , and

Furthermore, let  be the set of formulae that contains each
Ou occurring in nXG and  t for each t 2 TI. Clearly, nXG  
and   nXG. Furthermore, let It be a model of nXNXG; t; then,
the interpretation I0
t 14 MIt
MI0
t 14 cIt for each constant c
cI0
t 14 fhi1; . . . ; in; tijhi1; . . . ; ini 2 PItg for each n-ary predicate P
^PI0

t, defined below, is clearly a model of  t:

Finally, each model of  t can be converted into a model of
nXNXG; t by an analogous transformation.

(Claim 1) If  is satisfiable, then  t is clearly satisfiable for each
t 2 TI, so NXG; t is X-satisfiable for each t 2 exXG;1;1 as
well. Conversely, assume that NXG; t is X-satisfied in a model It
for each time instant t 2 exXG;1;1, and consider an arbitrary
time instant t 2 TI n ti
X G. Since exXG;1;1 is not empty, a
time instant t1 2 exXG;1;1 exists such that t; t1 or t1; t
X G; then NXG; t # NXG; t1 by Proposition
is consecutive w.r.t. ti

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Table 7
Reducing temporal to nontemporal entailment.

1. G is X-satisfiable if and only if NXG; t is X-satisfiable for each t 2 exXG;1;1.
2. nXG  pXBht3i if and only if G is not X-satisfiable or NXG; t3 X B.
3. nXG  8xt : 12t1 6 xt 6 t2 ! pXBhxti if and only if G is not X-satisfiable or NXG; t X B for each t 2 allXG; t1; t2.
4. nXG  9xt : 12t1 6 xt 6 t2 ^ pXBhxti if and only if G is not X-satisfiable or NXG; t X B for some t 2 exXG; t1; t2.

Note: X is an arbitrary entailment relation; G is an arbitrary temporal graph; B is an arbitrary BGP with varB 14 bXB 14 ;;
t1 2 TI; t2 2 TI; and t3 2 TI.

22, so by the monotonicity of first-order logic NXG; t is X-satisfied
in It1 . Thus, NXG; t is X-satisfied in a model It for each t 2 TI. Without loss of generality, we can assume that all It have the same domain and that they interpret all constants in the same way; for
example, we can take It to be Herbrand models with parameters
[31]. Let I0
t be the models of  t obtained from It using the transformation described above, and let I be the interpretation defined as
follows:

MI 14 MI0
cI 14 cI0

0 for each constant c occurring in 
0 j c is a constant occurring in g
OI 14 fcI0
XI0
XI 14

t for each predicate X  O

t2TI

Since each  t refers only to the time instant t, it is clear that I   ,
so I  nXG as well.

(Claim 2) If nXG is unsatisfiable, then G is not X-satisfiable, so
the claim holds. Assume now that nXG is satisfiable. Formula
pXBht3i contains only atoms of the form ^Pu1; . . . ; un; t3; thus,
  pXBht3i if and only if  t3  pXBht3i. By the correspondences
between the models of  t3 and NXG; t3 outlined above, we have
that  t3  pXBht3i if and only if NXG; t3 X B, which proves our
claim.

(Claim 3) The claim is equivalent to the claim that   pXBhti
for each t with t1 6 t 6 t2 if and only if  is unsatisfiable or
 t  pXBhti for each t 2 allXG; t1; t2. This is obvious if  is unsat-
isfiable, so assume that  is satisfiable. As in Claim 2, we can equivalently show that NXG; t X B for each t with t1 6 t 6 t2 if and
only if NXG; t X B for each t 2 allXG; t1; t2. The ()) direction is
obvious, so we focus on the (U) direction; consequently, assume
that NXG; t X B for each time instant t 2 allXG; t1; t2 and consider an arbitrary time instant t0 2 TI n allXG; t1; t2 such that
t1 6 t0 6 t2. Now allXG; t1; t2 is not empty, so a time instant t00 with
t00 2 allXG; t1; t2 and t00 R ti
X G exists such that t0; t00 or t00; t0 is
X G;
ti
consecutive w.r.t.
Proposition 22,
NXG; t0 14 NXG; t00, so NXG; t00 X B implies NXG; t0 X B. This
holds for an arbitrary t0 that satisfies the mentioned conditions,
so our claim holds.

then,

but

by

(Claim 4) The claim is equivalent to the claim that   pXBhti
for some t with t1 6 t 6 t2 if and only if  is unsatisfiable or
 t  pXBhti for some t 2 exXG; t1; t2. This is obvious if  is unsat-
isfiable, so assume that  is satisfiable. As in Claim 2, we equivalently show that NXG; t X B for some t with t1 6 t 6 t2 if and
only if NXG; t X B for some t 2 exXG; t1; t2. The (U) direction is
obvious, so we focus on the ()) direction; consequently, assume
that NXG; t X B for some t with t1 6 t 6 t2 and t R exXG; t1; t2.
Since exXG; t1; t2 is not empty, a time instant t0 2 exXG; t1; t2 exists such that t; t0 or t0; t is consecutive w.r.t. ti
X G; but then,
NXG; t # NXG; t0 by Proposition 22; since first-order logic is
monotonic, we have that NXG; t X B implies NXG; t0 X B, which
implies our claim. h

The following example illustrates Theorem 23.

Example 24. Let G and B be as shown in (56) and (57),
X G is then
respectively, and let X be Simple Entailment. The set ti
shown in (58).

G 14 fha; b; ci122; 4; ha; b; ci128g
B 14 ha; b; ci
XG 14 f2; 4; 8g
ti


To check entailment

nXG  8xt : 123 6 xt 6 8 ! pXB12xt

we proceed as follows. First, we determine exXG; 3; 8 as shown in
(60) and allXG; 3; 8 as shown in (61), and we determine the relevant NXG; t as shown in (62)(64).

exXG; 3; 8 14 f2; 3; 4; 8g
allXG; 3; 8 14 f2; 3; 4; 5; 7; 8g
NXG; 5 14 NXG; 7 14 ;
NXG; 2 14 NXG; 3 14 fha; b; cig
NXG; 4 14 NXG; 8 14 fha; b; cig


Next, we check the satisfiability of G by checking whether NXG; t is
satisfiable for each t 2 exXG; 3; 8. This is the case, so we finally
check whether NXG; t X B for each t 2 allXG; 3; 8. The latter does
not hold for t 14 5 and t 14 7, so (59) does not hold either. h

Note that Claims 1 and 4 in Table 7 involve only the time instants
in exXG; t1; t2, whereas Claim 3 involves the time instants in
allXG; t1; t2. This can intuitively be explained by observing that, if
NXG; t X B holds for some time instant t with t1 6 t 6 t2, then
Proposition 22 and the monotonicity of first-order logic imply that
NXG; t0 X B holds as well for t0 the nearest time instant to t such
that t0 2 exXG; t1; t2; thus, we can focus our attention only to time
instants between t1 and t2 that occur in G. In contrast, if we want
NXG; t X B to hold for each time instant t with t1 6 t 6 t2, then
we need to ensure that NXG; t0 X B holds not only for t0 explicitly
occurring in G, but also for t0 occurring between time instants in G.

Example 25. Let G be as in Example 24. Note that NXG; t X B for
each t 2 exXG; 3; 8, but not for each t 2 allXG; 3; 8. In other words,
considering only the time instants in exXG; 3; 8 would lead us to
incorrectly conclude that (59) holds. h

Based on these results, whether G1 X G2 holds can be checked

using the following nondeterministic algorithm.

1. Guess a mapping r : bXG2 ! uslXG1.
2. Compute pXrG2; the result will be of the form

wihtii ^

8xt : t1

6 xt 6 t2

j  ! jjhxti:

i141

j141

3. Check nXG1  wihtii for each 1 6 i 6 m.
4. Check nXG1  8xt : t1
j  ! jjhxti for each 1 6 j 6 m.
5. For each u 2 ulXG2, check whether u 2 ulXG1 or ulXG1 con-

6 xt 6 t2

tains a literal semantically equivalent with u.

6. Return true if all checks in Step 4 and 5 succeed.

The correctness of this algorithm follows straightforwardly
from Theorem 11 and the fact that u  w1 ^ 			 ^ wk if and only if
u  wi for each 1 6 i 6 k. Furthermore, all temporal entailment
checks in Steps 3 and 4 can be solved using polynomially many
nontemporal entailment checks as shown in Table 7. Since none
of these entailments involve blank nodes, it is also straightforward
to see that this algorithm is worst-case optimal for all entailment
relations listed in Section 2.

5.2. Answering temporal queries

In Table 8 we define a recursive function that computes the answer for a safe temporal group pattern P. Roughly speaking, if P is a
basic TGP, then evalXP; G can be computed as follows. We enumerate all mappings potentially relevant to P. For each candidate
mapping l, we evaluate the condition from Table 4 by eliminating
blank nodes as shown in Theorem 10, and then checking the
remaining condition using Theorem 23; if all of these checks suc-
ceed, we include l in the answer to P. Clearly, such a straightforward approach is unlikely to be suitable for practical use;
however, it does show that the problem is solvable in principle.
Furthermore, this general approach can be optimized; for example,
in Section 6 we present optimizations that are applicable to deterministic entailment relations and that make our algorithm
practicable.

The following theorem shows that, if P is safe, then evalXP; G
G, and the latter set is finite whenever

indeed computes sPtX
adXG is finite.

Theorem 26. Let G be a temporal graph, let X be an entailment
relation, and let P be a safe temporal group pattern. Then
evalXP; G 14 sPtX
G is finite
as well.

G; furthermore, if adXG is finite, then sPtX

X G [ f1;1g. To prove this theorem, we
Proof. Let D 14 ti
show the following properties, where P is an arbitrary TGP in
Points 1a and 1c, and P is a safe TGP in Points 1b, 2, and 3:

1. For each l 2 sPtX

G, the following holds:

(a) for each x 2 bindP, we have x 2 doml and lx 2 D (even

if P is not safe);

(b) rngl # adXG [ D (if P is safe); and
(c) if rngl # adXG [ D, then l 2 evalXP; G (even if P is not

safe).

Table 8
Evaluation of safe temporal group patterns.

2. evalXP; G # sPtX
3. If adXG is finite, then sPtX

G (if P is safe).

G is finite as well (if P is safe).

Note that, if P is safe, then from Points 1b and 1c we can con-
G # evalXP; G; combined with Point 2, we can conclude
G 14 evalXP; G. Thus, the claim of this theorem follows from

clude sPtX
sPtX
Points 13.

For Point 3, note that the conditions in Table 8 ensure that
rngl # adXG [ D for each l 2 evalXP; G. The set ti
X G is always
finite; thus, if adXG is finite, then evalXP; G is finite as well; but
then, sPtX

G is finite by Points 1b, 1c, and 2.

We prove Points 1 and 2 by induction on the structure of P. To
simplify the presentation, we first consider Point 2. Assume that P
is a basic TGP. Note that the ranges of the mappings in evalXP; G
are restricted to adXG [ D (cf. Table 8), whereas in sPtX
G they are
restricted to adXG [ TI (cf. Table 4); apart from this difference,
all remaining conditions are the same. Since D #TI, Point 2 holds
for P. Furthermore, assume that P is of the form P1 and P2. By
induction assumption we have that
for
i 2 f1; 2g, so then clearly evalXP; G # sPtX
G as well. The cases when
P is of the form P1 union P2 or P1 filter R are analogous. Finally,
assume that P is of the form P1 opt P2. Note that the following
identities are true by the definition of ffl and n for arbitrary P1
and P2.

evalXPi; G # sPitX

sP1tX
sP1tX

G ffl sP2tX
G n sP2tX

G 14 fl1 [ l2 jl1 2 sP1tX
G 14 fl1 jl1 2 sP1tX

G and sl1P2tX

G 14 ;g

G and l2 2 sl1P2tX
Gg

P 14 B at t3

The condition for P in Table 8 is thus equivalent to the one in Table
1. Assume now that P1 and P2 satisfy Points 1 and 2 and that P is
safe. By Definition 21, P1 is safe as well, so by Points 1 and 2 we have
G. Furthermore, also by Definition 21, l1P2 is
evalXP1; G 14 sP1tX
safe for each mapping l1 2 sP1tX
G, so by Points 1 and 2 we have that
evalXl1P2; G 14 sl1P2tX
G. Thus, Point 2 holds for P provided that
P1 and P2 satisfy Point 1. We next show that Points 1a1c hold
for all possible forms of P.

P 14 B during 12t1; t2

or

that

Assume

or
P 14 B occurs 12t1; t2 and consider an arbitrary mapping l 2 sPtX
G.
Since bindP 14 ;, Point 1a holds vacuously. Furthermore, if P is
safe, then tvarP 14 ;, so t1, t2, and t3 are not variables; thus,
doml 14 varB and rngl # adXG, so Point 1b holds. Finally, if
we have rngl # adXG [ D, then the conditions in the definitions
of sPtX
Assume that P 14 B maxint 12t1; t2 and consider an arbitrary mapping l 2 sPtX
G. Let r be a mapping for which dXlP; G holds, and
let B0 14 rlB. Assume that t1 is a variable x1 such that lx1 R D;
by condition dXlP; G then we have nXG  pXB0hlx1i and
nXG 2 pXB0hlx1  1i. The latter condition implies that nXG

G and evalXP; G are equivalent for l, so Point 1c holds.

evalXP; G is the set of mappings that is inductively defined as follows depending on the type of P:
P 14 B at t3
P 14 B during 12t1; t2
P 14 B occurs 12t1; t2
P 14 B maxint 12t1; t2
P 14 B mintime t3
P 14 B mintime t3 :

or
or
or
or
or

flj doml 14 varP; rngl # adXG [ ti

X G [ f1;1g; and dXlP; G holdsg

P 14 P1 and P2 :

fl1 [ l2 jl1 2 evalXP1; G; l2 2 evalXP2; G; and l1 and l2 are compatibleg

P 14 P1 union P2 :

evalXP1; G [ evalXP2; G

P 14 P1 opt P2 :

fl1 [ l2 jl1 2 evalXP1; G; and l2 14 ; if evalXlP2; G 14 ; or l2 2 evalXl1P2; Gg

P 14 P1 filter R :

fl 2 evalXP1; G jl  Rg

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

and

satisfiable,

NXG; lx1  1 2X B0.

so by Claim 2 of Theorem 23 we have
is
NXG; lx1 X B0
Furthermore,
NXG; lx1 # NXG; lx1  1 by Proposition 22; moreover, firstorder logic is monotonic, so we have NXG; lx1  1 X B0, which
is a contradiction; thus lx1 2 D. In a completely analogous way
we can show that, if t2 is a variable x2, then lx2 2 D. But then,
l 2 evalXP; G and Points 1a1c clearly hold.
Assume that P 14 B mintime t3 and consider an arbitrary mapping l 2 sPtX
G. Let r be a mapping for which dXlP; G holds,
and let B0 14 rlB. Assume that
is a variable x3 with
lx3 R D; by condition dXlP; G then nXG  pXB0hlx3i and

t3

nXG 2 9xt : 12xt 6 lx3  1 ^ pXB0hx3i;

condition,

Theorem 23, we

gous to the previous case.

formula nXG
is
By
NXG; lx3  1 2X B0.

satisfiable and
by the latter
nXG 2 pXB0hlx3  1i.
then
have
NXG; lx3 X B0
Furthermore,
and
NXG; lx3 # NXG; lx3  1 by Proposition 22; moreover, firstorder logic is monotonic, so we have NXG; lx3  1 X B0, which
is a contradiction; thus lx3 2 D. But then, l 2 evalXP; G and
Points 1a1c clearly hold.
Assume that P 14 B maxtime t3. The proof is completely analoAssume that P 14 P1 and P2 and consider an arbitrary mapping
l 2 sPtX
G. Let l1 and l2 be the mappings compatible with l such
that domli 14 varPi for each i 2 f1; 2g; clearly, we have li 2 sPitX
G.
 Consider an arbitrary variable x 2 bindP. By Table 6,
x 2 bindP1 or x 2 bindP2.
If x 2 bindP1, then x 2 doml1
and l1x 2 D by the induction assumption; but
then,
x 2 doml
reasoning
for
x 2 bindP2, we see that Point 1a holds.
 If P is safe, then tvarP 14 bindP. Consider now an arbitrary variable x 2 varP: if x R tvarP, then lx 2 adXG; otherwise,
x 2 bindP due to the safety of P, so lx 2 D by Point 1a. Con-
sequently, rngl # adXG [ D, and Point 1b holds.
 Assume that
then clearly we have
rngli # adXG [ D for each i 2 f1; 2g. Since Point 1c holds for
Pi and li 2 sPitX
G by the induction assumption, we have
li 2 evalXPi; G. But then, l 2 evalXP; G by Table 8, so Point
1c holds.

and lx 2 D. By

rngl # adXG [ D;

analogous

Assume that P 14 P1 union P2 and consider an arbitrary mapping

l 2 sPtX

G. Clearly, we have l 2 sPitX

G for i 14 1 or i 14 2.

 Consider an arbitrary variable x 2 bindP. Then x 2 bindPi by
Table 6, so x 2 doml and lx 2 D by the induction assump-
tion, and Point 1a holds.

 If P is safe, then Pi is safe as well. But then, Point 1b is satisfied
for Pi and l by the induction assumption, we have
rngl # adXG [ D, so Point 1b holds.
 Assume that rngl # adXG [ D. Since Point 1c holds for Pi and
l by the induction assumption, we have l 2 evalXPi; G. But
then, l 2 evalXP; G as well, so Point 1c holds.
Assume that P 14 P1 opt P2 and consider an arbitrary mapping
G. Let l1 be the mapping compatible with l such that
G. Furthermore, let l2 be the
that

l 2 sPtX
doml1 14 varP1; clearly, l1 2 sP1tX
compatible
maximal mapping
such
doml2 # varl1P2; clearly, l2 14 ; or l2 2 sl1P2tX
G.
 Consider an arbitrary variable x 2 bindP. Then x 2 bindP1 by
Table 6, so we have x 2 doml1 and l1x 2 D by the induction
assumption; but then, x 2 doml and lx 2 D, and Point 1a
holds.

 Assume that P is safe. Then P1 is safe as well, so Point 1b is satisfied for P1 and l1 by the induction assumption, so we have

with

 ; and let P0

2 14 l1P; clearly, P0

rngl1 # adXG [ D. Point 1b clearly holds if l2 14 ;. Therefore,
assume that l2
2 is safe, since
the actual values that l1 assigns to the variables in bindP1
do not affect the definition of safety. Point 1b is satisfied for
2 and l2 2 sl1P2tX
P0
G by the induction assumption, so
rngl2 # adXG [ D.
have
rngl # adXG [ D, so Point 1b holds.
 Assume
rngl # adXG [ D.
have
rngli # adXG [ D for each i 2 f1; 2g. Point 1c holds for P1
and l1, as well as for l1P2 and l2, so l1 2 evalXP1; G and
l2 2 evalXl1P2; G. But then, l 2 evalXP; G by Table 8, and
Point 1c holds.

l 14 l1 [ l2,

Since

Then

that

we

we

Assume that P 14 P1 filter. Points 1a1c hold for P1 by the induction assumption; but then, by the definition of evalXP; G they
clearly hold for P as well. h

Intuitively, evalXP; G evaluates P bottom-up, in a way similar to
the one shown in Table 1; however, instead of matching the variables from P to the values in the infinite set adXG [ TI, the values from the finite set adXG [ ti
X G [ f1;1g suffice because
the definition of safety ensures that each variable is bound by
a safe basic TGP.

Note that the computation of sPtX

G is not a decision (i.e., a
yes/no) problem. Therefore, in order to determine the complexity
of our query language, we must consider a decision version of
the problem: given an entailment relation X, a temporal graph G,
a safe temporal group pattern P, and a mapping l, decide whether
l 2 sPtX
G.

A worst-case optimal procedure for deciding l 2 sPtX

G can be
obtained by a slight modification of [30, Algorithm 1]: the only difference is in the treatment of basic TGPs, which can be handled as
shown in Theorem 23. Thus, one can show that the complexity of
deciding l 2 sPtX
G is either PSPACE or the complexity of the corresponding nontemporal entailment, whichever is higher. The proof
of these claims is quite straightforward, so we refrain from going
into further detail.

One might naively try to solve the above mentioned decision
problem by computing evalXP; G and then checking whether
l 2 evalXP; G. Function evalXP; G, however, can return exponentially many mappings (in varP and the number of URI references
in G). Note that the latter is not because evalXP; G is suboptimal: it
is simply due to the fact that sPtX
G can be exponential in size. Thus,
the naive decision procedure outlined above might use exponential
space for storing intermediate results and would therefore be sub-
optimal. Function evalXP; G is nevertheless useful since it shows
that the answers to safe TGPs are finite: we would not be able to
prove this by considering only the decision version of the problem.
Furthermore, evalXP; G provides us with a bottom-up algorithm
that is quite similar to the algorithms used to evaluate relational
algebra queries [43].

6. Optimized query answering

In order to compute the answer to a safe basic TGP P using the
function evalXP; G presented in Section 5.2, we can enumerate all
candidate mappings and then decide for each mapping whether
the mapping is contained in the answer. The latter problem can
be solved using the reduction from Section 5.1 by checking one
or more nontemporal entailments. Such an approach is very general and can handle arbitrary entailment relations; however, the
resulting algorithm is unlikely to be practicable: the set of all candidate mappings is likely to be much larger than the answer to P, so
the algorithm is likely to perform a lot of computation. In this section we optimize this general algorithm for specific entailment
relations to make it more goal-directed.

In Section 6.1 we present a goal-oriented approach for evaluating TGPs under Simple Entailment. The resulting algorithm uses a
preprocessing phase in order to normalize a temporal graph, after
which temporal queries can be evaluated by simple matching in
the normalization. This approach can be straightforwardly integrated into virtually all existing RDF management systems.

In Section 6.2 we extend our optimization to entailment relations that can be characterized by a set of deterministic rules,
such as RDF(S) and OWL 2 RL/RDF Entailment. In particular, we
show how to apply the rules to a temporal graph in a bottomup fashion and thus materialize all relevant consequences. The
resulting materialized graph can then be normalized, after which
temporal queries can be answered using the optimization from
Section 6.1.

In order to simplify our definitions, in the rest of this section we
consider temporal triples of the form hs; p; oi12t as syntactic abbreviations for hs; p; oi12t; t.

6.1. Simple Entailment

Simple Entailment is the basic entailment relation in which
BGPs can be evaluated in nontemporal graphs by simple lookup.
Such an approach provides the basis of virtually all practical RDF
management systems, so it would be beneficial if similar approaches were applicable to TGPs and temporal graphs. As the following example demonstrates, however, a naive application of
graph matching would result in an incorrect algorithm.

Example 27. Let P be as in (65), and let G be the temporal graph
that contains the temporal triples shown in (8)(11) in Section 3;
then, sPtsimple

is shown in (66).

14 ffx # 50; y # 150gg
that G does not

P 14 fh:LHR; :flightTo; :MUCig maxint 12x; y
sPtsimple


triple
Note, however,
a 14 h:LHR; :flightTo; :MUCi1250; 150, so sPtsimple
cannot be computed
by simple lookup. Temporal graph G is equivalent under Simple
Entailment to the normalized temporal graph nrm(G) obtained from
G by replacing (8) and (9) with a; furthermore, P can be evaluated in
nrm(G) by simple lookup. h

contain temporal

Based on these observations, we develop our optimized ap-

proach for TGP evaluation.

Let G be a temporal graph, and let A 14 hs; p; oi12t1; t2 be a temporal triple in G. Then A directly overlaps with hs; p; oi12t0
2 2 G if
maxt1; t0
2; overlaps is the transitive closure of directly overlaps; and GA is the set that contains precisely all temporal triples in G that overlap with A. The normalization of A w.r.t. G is
the temporal triple nrmAA defined as follows:

1 6 mint2; t0

1; t0

nrmGA 14 hs; p; oi12t1; t2
t1 14 min
1;ti
t2 14 max
1;ti

hs;p;oi12ti

hs;p;oi12ti

22GA

22GA

ti

ti

Finally, the normalization of G is the temporal graph nrmG obtained
from G by replacing each temporal triple C 2 G with nrmGC.

Temporal graph nrmGC can be computed from G using Algorithm 1. Due to sorting, all temporal triples in G are grouped by
s, p, and o, and within each group, the triples are ordered by t1
and t2. Thus, at each point in time during the execution of the
for-loop, either sc is undefined or hsc; pc; oci12tc
2 is the normalization w.r.t. G of all triples of the form hsc; pc; oci12t1; t2 processed
thus far. Consequently, the algorithm correctly computes nrmG.
In a system where G is stored in a relational database, Algorithm

1; tc

1 can be straightforwardly implemented using a stored
procedure.
Algorithm 1. Computing nrmG

Sort the triples hs; p; oi12t1; t2 in G by s, p, and o, t1, and t2
R :14 ;
sc :14 pc :14 oc :14 tc
for all hs; p; oi12t1; t2 2 G do

2 :14 undefined

1 :14 tc

if s  sc or p  pc or o  oc or t1 > tc

if sc  undefined then
R :14 R [ fhsc; pc; oci12tc

2g
1; tc
end if
sc :14 s; pc :14 p; oc :14 o; tc
1 :14 t1; tc
end if
2 14 maxtc
tc

2; t2

2 then

2 :14 t2

end for
if sc  undefined then
R :14 R [ fhsc; pc; oci12tc

2g
1; tc

end if
return R

We next show how to answer TGPs under Simple Entailment

using nrmG.
Definition 28. Let B be a BGP containing hsi; pi; oii for 1 6 i 6 k;
and let ~x 14 hx1; . . . ; xki, ~y 14 hy1; . . . ; yki, z1, and z2 be distinct
variables not occurring in B. Then, MB~x;~y; z1; z2 is the following
conjunction:

MB~x;~y; z1; z2 

hsi; pi; oii12xi; yi

i141
z1 14 maxx1; . . . ; xk^
z2 14 miny1; . . . ; yk^
z1 6 z2

For P a basic TGP, uP is the first-order formula defined as shown in
Table 9.
Let G be a temporal graph. For P a safe basic temporal group
pattern, sevalP; G is the set of mappings obtained by evaluating uP
in nrmG, where the latter is treated in the obvious way as a
relation in a relational database. For P a safe TGP of any other type,
sevalP; G is defined analogously as in Table 8.

Theorem 29. For each temporal graph G and each safe temporal
group pattern P, sevalP; G 14 sPtsimple

Proof. Temporal graphs G and nrmG are obviously equivalent
w.r.t. any entailment relation. Furthermore, by the definition of
if
normalization,
sfhs; p; oig maxint 12t1; t2tsimple
 ;that is, each temporal assertion
in nrmG covers the maximal interval in which the assertion is
valid.
Now let P be a safe TGP of the form B maxint 12t1; t2. Conjunction

hs; p; oi12t1; t2 2 nrmG

only

and

if

hsi; pi; oii12xi; yi

i141

is true in nrmG precisely for each mapping r such that
domr 14 varP [ f~x;~yg and hrs; rp; roi12rt1; rt2 2 nrmG,
so MB~x;~y; z1; z2 is true if and only if, in addition, interval z1; z2
is the nonempty intersection of all intervals xi; yi; consequently,
uP is true in nrmG precisely for those mappings l such that
l 2 sPtsimple

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

Table 9
Evaluation of Safe TGPs under Simple Entailment.

B at t3
B during 12t1; t2
B occurs 12t1; t2
B maxint 12t1; t2
B mintime t3
B maxtime t3

u~v
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ z1 6 t3 6 z2
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ z1 6 t1 6 t2 6 z2
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ maxz1; t1 6 minz2; t2
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ t1 14 z1 ^ t2 14 z2
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ t3 14 z1 ^ 8~x0; ~y0; w1; w2 : MB~x0; ~y0; w1; w2 ! z1 6 w1
9~x;~y; z1; z2 : MB~x;~y; z1; z2 ^ t3 14 z2 ^ 8~x0; ~y0; w1; w2 : MB~x0; ~y0; w1; w2 ! z2 P w2

The proofs for the remaining forms of P are analogous and are

omitted for the sake of brevity. h

Computing answers to safe basic TGPs can thus be reduced to
the evaluation of first-order queries in the normalization of a temporal graph, and the latter can be implemented using SQL. Further-
more, all other types of TGPs can be handled by translating them
into SQL, so Theorem 29 provides the foundation for a practical
implementation of our framework in RDF systems.

We finish this section with an observation that, in SQL, mintime
and maxtime can be handled using aggregate functions, rather than
nested subqueries. We do not discuss this optimization any further
because of the well-known problems involved in capturing the
semantics of aggregate functions in first-order logic.

6.2. Entailments characterized by deterministic rules

Let X be an entailment relation that can be characterized by a

set CX of deterministic rules of the form (67).

A1 ^ 			 ^ An ! B

Numerous RDF systems, such as such as Jena [3], Jena2 [4], Sesame
[5], and Oracle [6], use a materialization approach to deal with such
X: they initially compute and store all consequences w.r.t. CX of a
nontemporal graph. Any query can then be evaluated in the materialization by straightforward lookup.

We next show how to materialize the temporal closure clsXG
of a temporal graph G using the rules from CX. After this is done,
we can normalize clsXG and use the algorithm from Section 6.1
in order to answer TGPs.

By examining the semantics of temporal entailment in Section 3,

A112xt ^ 			 ^ An12xt ! B12xt

one might naively try to transform each rule of the form (67) into

and then apply the transformed rules to G. Such an approach, how-
ever, will not work: most triples in a temporal graph are likely to be
of the form hs; p; oi12t1; t2 rather than hs; p; oi12t, so a rule such as (68)
will not match to most triples in a graph. We can, however, use a
slight modification of this idea. In the rest of this section, we slightly
abuse notation and allow a temporal graph G without blank nodes
to be infinite; then, pXG 14

A2GpXA.

Definition 30. For X and CX as stated above, let RX be the set
containing the rule (69) for each rule (67) in CX.

A112x1; y1^
. . .
An12xn; yn^
z1 14 maxx1; . . . ; xn^
z2 14 miny1; . . . ; yn^
z1 6 z2

! B12z1; z2

Let G be a temporal graph containing only triples of the form
hs; p; oi12t1; t2.3 The temporal closure of G is the (possibly infinite)

3 As explained earlier, triples of the form hs; p; oi12t can be considered abbreviations
for hs; p; oi12t; t.

temporal graph clsXG obtained by exhaustively applying the rules
in RX to the X-skolemization of G.

Example 31. Let G be the temporal graph that contains the temporal triples shown in (8)(11) in Section 3. By applying the approach
from Definition 30 to G under RDFS entailment, one can see that
(10) and (11) produce the following temporal triple:
h:Munich; :hasEvent; :Oktoberfesti12130; 180
This triple captures the RDFS consequences of G. h

The following proposition shows that, instead of evaluating
TGPs in G under X-entailment, one can evaluate them in clsXG under simple entailment.

Theorem 32. Let X and G be as stated in Definition 30, and let
G0 14 clsXG. Then,
for each temporal group pattern P, we have
sPtX

G 14 sPtsimple

G0

G0

G 14 sPtX
G1 14 sPtsimple

Proof. Let P be an arbitrary TGP, and let G1 be the X-skolemization
of G. Clearly sPtX
G1 , so the claim of this theorem holds if and
only if sPtX
Let G2 be the temporal graph that contains hs; p; oi12t for each
hs; p; oi12t1; t2 2 G1 and each t with t1 6 t 6 t2. Furthermore, let XX
be the set containing a rule of the form (68) for each rule of the
form (67) in CX; and let G3 be the temporal graph obtained by
applying exhaustively the rules in XX to G2. Since XX is a
deterministic set of rules,
it can be understood as a datalog
program; furthermore, G3 can be seen as the least fixpoint of G2
w.r.t. XX. Thus, by [43], for each temporal triple A of the form
hs; p; oi12t, we have psimpleG3  psimpleA if and only if
pXG1 [ f8xt : uhxtiju 2 CXg  psimpleA;

so sPtX

G1 14 sPtsimple

G3

Let G4 be the temporal graph that contains hs; p; oi12t for each
hs; p; oi12t1; t2 2 G0 and each t with t1 6 t 6 t2. It is straightforward
to see that each derivation tree for a triple hs; p; oi12t 2 G3 can be
transformed to a derivation tree of hs; p; oi12t1; t2 2 G0 such that
t1 6 t 6 t2; similarly, one can easily see that each derivation tree
for a triple hs; p; oi12t1; t2 2 G0 can be transformed to a derivation
tree of the triple hs; p; oi12t 2 G3 for each t1 6 t 6 t2. Consequently,
so psimpleG3 and psimpleG0 are equivalent, and
G3 14 G4,
sPtsimple

14 sPtsimple

. h

G3

G0

We next comment on a somewhat technical issue involved in
Definition 30. For the sake of generality, our definitions allow CX
to be infinite so, given a finite temporal graph G, the closure
clsXG can be infinite as well. Thus, to correctly state our results,
we need the ability to deal with infinite temporal graphs. Note,
however, that blank nodes are encoded using existential quantifi-
ers; therefore, to correctly capture the semantics of blank nodes
in infinite temporal graphs, we might need to existentially quantify
over infinite sets of formulae, which is not possible in standard firstorder logic. In order to avoid such technical problems, Definition 30

simply skolemizes blank nodes in G before applying the rules. This
does not affect the answers to TGPs since the definition of TGP
semantics already involves skolemizing the blank nodes in G.

Rules of the form (69) are just plain datalog rules so, provided
that CX is finite, clsXG can be computed using standard datalog
evaluation techniques, such as variants of the seminaive strategy
[44]. These techniques are used in most materialization-based
RDF systems to handle nontemporal RDF, so extending the
mentioned systems
should be
straightforward.

to handle temporal graphs

7. Related work

The management of validity time has been extensively studied
in relational databases and artificial intelligence. Neither RDF nor
OWL, however, supports validity time, and SPARQL does not provide the primitives for temporal querying of data. These deficiencies have been recognized in the Semantic Web community, and
several proposals have emerged. In this section we present an
overview of these related proposals and discuss the similarities
and differences with our work.

Chomicki presented an extensive overview of the principles of
the representation and querying of validity time in relational databases [39], and Vila did the same in the context of artificial intelligence [40]. The surveyed results, however, are quite general and
do not handle the family of Semantic Web languages. In this paper
we adapted the principles from [39,40] to the specifics of RDF,
OWL, and SPARQL, and we provided appropriate reasoning algo-
rithms. In particular, we distinguish logical from physical temporal
databases as in [39], and we use temporal arguments to associate
time instants with facts as in [40].

Gutierrez et al. presented a comprehensive framework for representing and querying validity time in RDF [22]. They defined a
syntactic notion of temporal RDF graphs quite similar to the one
presented in this paper. To obtain a notion of temporal entailment,
they defined the snapshot of a temporal graph G at a time instant
t 2 TI as the nontemporal graph Gt that contains each hs; p; oi
such that hs; p; oi12t 2 G or hs; p; oi12t1; t2 2 G and t1 6 t 6 t2; then,
for G1 and G2 temporal graphs, G1  G2 holds if and only if
G1t  G2t for each t 2 TI. To obtain a practical characterization
of temporal entailment, the authors defined the slice closure of a
temporal graph G as the union of the closures of Gt for each
t 2 TI, where the notion of a closure of a nontemporal graph is taken from [45]. Finally, the authors also developed an encoding of
temporal graphs into nontemporal graphs that preserves temporal
entailment, and they presented a basic temporal query language.
This framework was extended in [23] with more general temporal
constraints.

Although there are many similarities between our work and the
framework presented in [22], our work differs in several important
ways.

 The notion of temporal graph entailment from [22] is not applicable to OWL 2 Direct Entailment, and the notion of slice closures is applicable only to deterministic entailment relations
without existential quantifiers, which excludes OWL 2 RDFBased Entailment. In contrast, our work provides a unifying
semantic and algorithmic framework for the management of
validity time in the Semantic Web that is applicable to an arbitrary entailment relation, including OWL 2 Direct Entailment
and OWL 2 RDF-Based Entailment. Note that our approach produces the same consequences as [22] for RDFS Entailment.

 Expressions of the form hs; p; oi12t1; t2 are considered in [22] to
be syntactic abbreviations for temporal triples hs; p; oi12t for each
t1 6 t 6 t2, rather than full-fledged parts of a temporal graph.

Thus, t1 and t2 in such an expression cannot be 1 and 1,
as this would result in an infinite temporal graph and would
consequently invalidate key technical results, such as [22,
Proposition 2]. Such a definition has another side-effect: each
triple hs; p; oi12t1; t2 contributes Ot2  t1 to the size of a temporal graph (this is implicitly assumed in all technical results in
[22]): since the slice closure of G is defined as the union of a closure of Gt for each t 2 TI, if G contains hs; p; oi12t1; t2, at least
t2  t1  1 time instants must be considered during the computation of a slice closure. Thus, the presence of large time intervals in a temporal graph can adversely affect the complexity
of the employed algorithms. In contrast, temporal triples of
the form hs; p; oi12t1; t2 are first-class citizens in our frame-
work, they can be used to express facts with unbounded validity
intervals, and the size of their time intervals does not affect the
complexity of our reasoning algorithms.

 Third, the query language presented in [22] does not address

the issues we discussed in Section 4.

Pugliese et al. [24] extended the approach by Gutierrez et al.
in several ways. First, they allowed temporal triples to refer to
unknown, rather than precisely named time points; second, they
defined a temporal query language based on graph matching; and
third, they presented a way for indexing temporal graphs. Since
the approach by Pugliese et al. is based on [22], it does not
handle nondeterministic entailment relations or entailment relations that involve existential quantification; furthermore, the presented query language does not address the problems discussed
in Section 4.

Tappolet and Bernstein [25] discussed various technical issues
involved in an implementation of the approach by [22] and presented a temporal extension of SPARQL. However, neither the syntax nor the semantics of the presented query language has been
formally specified.

There are numerous proposals in literature for extending
description logics with validity time; Artale and Franconi [26]
and Lutz et al. [27] presented comprehensive surveys of the
relevant results. These works, however, typically focus on expressing and reasoning with complex temporal constraints. Such
constraints usually allow for quantification over (potentially un-
known) time instants; thus, the computational problems in temporal description logics are usually quite different from the ones in
the Semantic Web, since the latter typically deal with efficient
retrieval and management of known time instants.

Milea et al. presented a temporal extension of OWL [28]. Time
instants are encoded as values of a particular concrete domain,
and predefined concepts and properties are used to associate time
intervals with facts. The authors, however, do not discuss an appropriate temporal query language.

In a somewhat independent line of research, several frameworks for annotating RDF triples were developed. One of the first
such proposals was by Udrea et al. [46]; Straccia et al. extended
this proposal in [29] with a more general deductive system and
they presented in [47] a language for querying annotated RDF.
These frameworks allow an RDF triple to be annotated by an element of a suitably defined annotation domain. The latter is assumed
to exhibit some very general mathematical properties, such as
being partially ordered or being a lattice, which is used to define
the semantics of annotated RDF graphs and obtain an adequate
deductive system. RDF annotation frameworks are thus very general and can capture a wide range of annotation information, such
as fuzziness, provenance, or validity time. The latter can be captured by an annotation domain that contains time intervals; thus,
the temporal domain is interval-based. This is in contrast to the
work by Gutierrez et al. [22] and our work in which the temporal
domain is point-based. Furthermore, unlike the work presented

B. Motik / Web Semantics: Science, Services and Agents on the World Wide Web 1213 (2012) 321

in this paper, none of the frameworks listed above are applicable to
nondeterministic entailment relations, entailment relations that
involve existential quantifiers, or OWL 2 Direct Entailment.

8. Implementation and outlook

In this paper we presented an approach for representing validity time in RDF and OWL, an extension of SPARQL that allows for
querying temporal graphs, and two query answering algorithms.
We implemented our approach in ExperienceOns backend system.
The system is based on a proprietary extension of RDF that supports n-ary relations; it uses an ontology language based on OWL
2 RL; and it implements a proprietary query language based on
the primitives and the notion of safety outlined in Section 4. The
PostgreSQL database is used for data persistence and query pro-
cessing. Ontology reasoning is implemented by translating the
ontology into a datalog program, which is then compiled into a
plSQL script that implements the seminaive datalog evaluation
strategy [44]. Datalog rules are modified as described in Section
6.2 in order to deal with validity time; furthermore, the resulting
set of facts obtained by applying the rules is normalized to allow
for efficient query answering. Finally, temporal queries are translated into SQL as outlined in Section 6.1 and then evaluated using
the query engine of PostgreSQL. The source code of the system is
not open, and ExperienceOn has no plans for licensing the system
to third-party developers. Therefore, we do not present a performance evaluation since such results could not be validated by
the community. We merely note that ExperienceOn is successfully
using our approach with datasets consisting of tens of millions of
triples, which we take as confirmation that our approach is amenable to practical implementation.

An important open question is to see whether the general algorithm from Section 4 can be successfully used with entailment
relations such as OWL 2 Direct Entailment. We believe this to be
possible provided that the algorithm is adequately optimized.
