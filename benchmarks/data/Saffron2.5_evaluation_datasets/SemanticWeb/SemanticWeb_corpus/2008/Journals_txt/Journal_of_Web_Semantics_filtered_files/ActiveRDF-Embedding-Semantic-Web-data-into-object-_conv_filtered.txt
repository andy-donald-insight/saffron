Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

Contents lists available at ScienceDirect

Web Semantics: Science, Services and Agents

on the World Wide Web

j o u r n a l h o m e p a g e : w w w . e l s e v i e r . c o m / l o c a t e / w e b s e m

ActiveRDF: Embedding Semantic Web data into object-oriented
languages
Eyal Oren a,, Benjamin Heitmann b, Stefan Decker b

a Vrije Universiteit Amsterdam, de Boelelaan 1081a, 1081 HV,
Amsterdam, Netherlands
b Digital Enterprise Research Institute, National University of Ireland,
Galway, Ireland

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 2 December 2007
Accepted 28 April 2008
Available online 26 July 2008

Keywords:
Semantic Web
RDF(S)
Embedded data access
Object-oriented programming
Scripting languages

Semantic Web applications share a large portion of development effort with database-driven Web appli-
cations. Existing approaches for development of these database-driven applications cannot be directly
applied to Semantic Web data due to differences in the underlying data model. We develop a mapping
approach that embeds Semantic Web data into object-oriented languages and thereby enables reuse of
existing Web application frameworks.

We analyse the relation between the Semantic Web and the Web, and survey the typical data access
patterns in Semantic Web applications. We discuss the mismatch between object-oriented programming languages and Semantic Web data, for example in the semantics of class membership, inheritance
relations, and object conformance to schemas.

We present ActiveRDF, an object-oriented API for managing RDF data that offers full manipulation and
querying of RDF data, does not rely on a schema and fully conforms to RDF(S) semantics. ActiveRDF can
be used with different RDF data stores: adapters have been implemented to generic SPARQL endpoints,
Sesame, Jena, Redland and YARS and new adapters can be added easily. We demonstrate the usage of
ActiveRDF and its integration with the popular Ruby on Rails framework which enables rapid development
of Semantic Web applications.

 2008 Elsevier B.V. All rights reserved.

1. Introduction

The Semantic Web simplifies knowledge discovery, reuse, and
management [18,47,50] by explicitly and formally representing
information about online data sources: it enriches the publishing infrastructure of the Web with ontologies, formal and explicit
machine-understandable descriptions of data [29] and introduces
self-describing formats for interpreting and reusing the data itself.
Through ontologies, the Semantic Web simplifies and improves
knowledge-intensive applications, by addressing weaknesses in
information retrieval, information extraction, and data integration
on the current Web [1,17,23].

As the Semantic Web standards such as RDF(S), OWL, and
SPARQL, have been agreed upon and as infrastructure is matur-

 This article is an extended version of Oren et al. (2007). This material is
based upon works supported by the Science Foundation Ireland under Grant No.
SFI/02/CE1/I131.
 Corresponding author.
E-mail addresses: eyal@cs.vu.nl (E. Oren), benjamin.heitmann@deri.org (B. Heit-

mann), stefan.decker@deri.org (S. Decker).

1570-8268/$  see front matter  2008 Elsevier B.V. All rights reserved.
doi:10.1016/j.websem.2008.04.003

ing, applications can be developed that exploit the benefits of the
Semantic Web. Such applications need to access data sources to
retrieve, manipulate, and display data to its users [54].

1.1. Mapping relational data

In traditional relational-database applications, various solutions
have been developed that offer programmatic access to relational
data sources. These solutions, such as Hibernate [4] or ADO.Net
[13], are embedded in the programming language and map the
data elements into programmatic objects, which allows developers to access and manipulate data using their familiar programming
concepts and constructs.

But these existing mapping approaches do not suffice for Semantic Web applications since the access and manipulation patterns
differ from the relational setting. Secondly, the conceptual model
of Semantic Web data and the semantics of RDF Schema differ
substantially from both the object-oriented paradigm and the relational paradigm on which the existing mappings rely. To support
application developers, new mappings need to be developed that
provide programmatic access to Semantic Web data and offer the
access patterns required by typical applications.

E. Oren et al. / Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

1.2. Web application frameworks

Another important benefit of such mappings lies in their
usage in Web application frameworks such as Struts,1 Ruby on
Rails2 or Django.3 As will be explained, these frameworks are
based on the modelviewcontroller paradigm, and rely on these
objectrelational solutions to automatically map relational data
into object-oriented models in the MVC paradigm. Such automatic
mappings alleviate application developers to focus on developing
the controllers, containing the application logic, and the views,
containing the user interface.

Since Semantic Web applications share large portions of functionality with traditional Web applications, such as authentication
management, session management, caching, user interface wid-
gets, reusing these Web application frameworks is desirable. But
since these frameworks rely on an objectrelational mapping, a
similar mapping from graph-based Semantic Web data to programmatic objects would be required.

1.3. Outline

In this article, we develop a mapping approach that embeds
Semantic Web data into object-oriented languages. We first analyse the relation between the Semantic Web and the Web, and
investigate how Semantic Web applications are developed. We
then analyse the data access patterns in these applications and
discuss the mismatch between object-oriented programming languages and Semantic Web data. We present ActiveRDF, a mapping
approach that addresses these mismatches, evaluate its impact on
the development process and demonstrate an example Web application based on ActiveRDF.

2. Related work

Our mapping approach is related to work in objectrelational
mappings, in accessing Semantic Web data, and in Web application
development.

2.1. Objectrelational mappings

Translating data manipulations and data access between applications and databases is a well-known problem, especially between
object-oriented programming and relational databases, due to the
impedance mismatch between relational and object-oriented
data, and the need for an abstraction layer to prevent vendor dependence [46]. Existing objectrelational mappings such as Hibernate
for Java, ActiveRecord for Ruby follow the Active Record pattern
([26], p. 160) in which tables are mapped to classes; tuples are
mapped to objects; columns are mapped to class attributes; foreign
keys and intersection tables modelling many-to-many relations are
mapped to object relationships.

In Section 6, we will identify several mismatches between
Semantic Web data and object-oriented data. These mismatches
do not occur for relational data, and are therefore not address by
these traditional mapping techniques:
 Class membership: in the relational model, every tuple belongs to
exactly one table, which maps without problem to the objectoriented requirement that every object must be member of
exactly one class.

 Class inheritance: a non-issue since no inheritance of tables is
allowed in the relational model.
 Object conformance: in the relational model each tuple must conform strictly to the table definition in the schema, which maps
without problem to the object-oriented notion of object confor-
mance. Although tables can have optional columns, a tuple cannot
contain other columns than specified in the table definition.
 Semi-structured data: relational data cannot appear without
schema information and tuples cannot deviate from the column
definition.
 Runtime evolution: database systems are typically closed systems
whose schema definitions do not change dynamically at runtime,
and thus do not require the runtime evolution needed for RDF
data.

The ADO.Net objectrelational mapping [13] supports a slightly
different access pattern; it maps data elements into the ADO.Net
entity framework [2] and relies on declarative mapping specifications to automatically create the objectrelational mappings [46].
Still, only relational data is considered and no support is given for
the above problems.

2.2. RDF data access

Many RDF APIs are available in various programming languages.
Some provide access to one specific RDF store, such as the Jena API
[75] or the Sesame API [10], and some are agnostic to the underlying data store, such as RDF2Go.4 Most of these APIs are generic and
triple-based, offering methods such as getStatement and getO-
bject. These APIs provide low-level manipulation facilities but
do not map their data into programmatic objects; they are less
embedded in the programming language than our approach and
are exactly the APIs that we abstract from.

With similar goals as ours, the development of an objectoriented API has been attempted in Java, for example in RdfReactor,5
Elmo6 and Jastor.7 These approaches are based on a statically typed
object-oriented language and thus encounter exactly the discussed
mismatches: they do not fully account for the flexible and semistructured nature of RDF data, relying instead on the existence of an
RDF Schema to generate corresponding classes. They also assume
stability of the schema, requiring manual regeneration and recompilation if the schema changes. Finally, they assume strict schema
conformance by not allowing objects whose structure differs from
their class definition.

2.3. Semantic Web application development

Several approaches for the development of Web application and
Semantic Web applications raise the abstraction level of development by separating the conceptual model (of, e.g. site navigation)
from the implementation: WebML [14,15] and OOHDM [66] offer
a model-driven Web application design methodology which can
generate Web applications from a high-level description; Strudel
[24] offers a declarative language to describe data integration and
manipulation in Web applications which can in turn be used inside
a design methodology such as WebML.

These Web engineering approaches have been extended
towards Semantic Web data. Facca and Brambilla [22] present an
initial adaptation of WebML to enable ontology querying and navi-

1 http://struts.apache.org.
2 http://rubyonrails.org.
3 http://djangoproject.com.

4 http://rdf2go.ontoware.org.
5 http://rdfreactor.ontoware.org/.
6 http://www.openrdf.org/doc/elmo/users/index.html.
7 http://jastor.sourceforge.net/.

gation. Lima and Schwabe [44] present the SHDM approach which
extends OOHDM into a complete design framework for Semantic
Web applications based on navigational sets. The Hera methodology [35,74] and its more flexible successor Hera-S [69] support
the design and engineering of Semantic Web information systems.
Similar to the modelviewcontroller pattern, Hera decomposes
an application into three layers, the semantic layer, the application layer and the presentation layer. Hera focuses mainly on the
presentation layer and the user interaction, but similarly to SHDM,
limits navigation to predefined paths. Corcho et al. [16] introduce
a Semantic Web portal using the modelviewcontroller design
pattern, but do not integrate it with an existing framework. Sim-
ilarly, Ontowebber [37] uses Semantic Web ontologies to model
the application domain and the navigational structure of the Web
application, leading to an ontology-driven Web application. Maedche et al. [45] present SEAL, a portal design using Semantic Web
data based on Ontobroker [19].

These approaches all provide elaborate and comprehensive
methodologies and frameworks for development of Semantic Web
applications. However, none of these address the semantic differences between relational data and Semantic Web data and the
embedding of such Semantic Web data into existing programming
languages and existing Web application frameworks.

Some approaches [59,62] enhance Web engineering frameworks to produce sites with embedded Semantic Web annotations,
others use RDF to represent the engineering artifacts during the
Web engineering lifecycle [39], allowing designers to exchange and
reuse these design artifacts. Where we focus on developing Web
applications from Semantic Web data (as opposed to relational
or XML data) and on reusing external Semantic Web datasources,
these techniques focus on enhancing traditional architectures to
expose traditional data through annotated Web pages.

3. Developing Semantic Web applications

The relation between the Web and the Semantic Web has
changed, as the understanding and interpretation of the Semantic Web has evolved over time [31]: on the one hand, the vision of
the Semantic Web has been interpreted as an enrichment of the
current Web, employing for example named-entity recognition or
document classification, resulting in semantically annotated Web
documents [30,38] on the other hand, the Semantic Web has been
interpreted as an interlinked Web of data [6,64,67] enabling ubiquitous data access and unexpected reuse and integration of online
data sources.

We focus mostly on the latter interpretation and consider a
Semantic Web application to be an application that delivers some
functionality to its users while using Web standards such as HTML,
CSS, and JavaScript for its user interface, using Web standards such
as HTTP to deliver the application to its users and using information from online data sources, using Semantic Web standards such
as RDF(S), OWL, and SPARQL.

This Web of data has been referred to as Web 3.0 [41]:
the continuing evolution of the Web towards the usage of open,
interchangeable, dataeven though little consensus exists on the
evolution from Web 1.0 to Web 2.0 [48,51], which has been characterised as the advent of social Web applications [67], of rich user
interfaces [58], of mashups and data exchange [36], of harnessing
the controversial wisdom of the crowds [68,70], of business models
that build extensible platforms rather than closed applications [3],
and as combinations of all these characteristics.

Following the notion of Web 3.0, much of the application
infrastructure and development approach can be shared between
existing Web applications and Semantic Web applications, since

Table 1
Traditional vs. Semantic Web applications

Web applications

Centralised
One fixed schema
One fixed vocabulary
Centralised publishing
One datasource
Closed systems

Semantic Web applications

Decentralised
Semi-structured
Arbitrary vocabulary
Publish anywhere
Many distributed datasources
Open systems

both are open architectures for information sharing: the first
oriented more towards documents, the second more publishing,
allowing anyone to create documents or assert statements at any
location, using any vocabulary or structure.

The Web is not only a publishing infrastructure but also an application platform for Web applications. But existing applications use
the Web primarily as a means to access their application, generating
HTML pages from their database content and serving these pages
over HTTP. These database-driven applications result in a deep
or hidden Web [25], whose dynamically generated pages do not
conform to traditional Web principles such as hyperlinks and are
thus hard to crawl and index [42,43,60].

More importantly, these database-driven applications are closed
systems that rely on a single centralised datasource; due to the
inherent limitations of their relational databases, these Web applications operate on fixed datastructures and schema, use one fixed
vocabulary, and do not interlink their data. In contrast, Semantic
Web applications are more aligned with the principles89 of the
Web, such as interoperability, universality, evolvability and decen-
tralisation, hence the incremental version number of Web 3.0. As
shown in Table 1, Semantic Web applications are decentralised and
open, operate on distributed data that can be published anywhere,
may conform to arbitrary vocabulary and follow semi-structured
schemas.

4. Requirements for Semantic Web application
development

To analyse the requirements for Semantic Web application
development, we have performed a survey of Semantic Web appli-
cations. The survey is described in detail in [33], we summarise
some relevant results here.

The survey investigated 50 existing applications, characterised
them on a wide range of properties based on available publications
and demonstration prototypes, and cross-validated this information with the original application developers and authors. The
surveyed applications were categorised into six different application types: semantic viewer, semantic portal, semantic annotation,
semantic repository, semantic authoring, s emantic desktop. The survey identified several typical components that re-occurred across
many applications. We observed that, in most of the surveyed appli-
cations, these components have been manually implemented by
the application developers for that application only. Given the large
degree of similarity between the applications, these components
could be extracted into separate, reusable, libraries:

User interface. An end-user application needs a user interface
for navigation and visualisation of the application data; some
techniques exist for navigating RDF data but these rely on manually specified navigation schemas, which limits the flexibility of

8 http://www.w3.org/Consortium/Points/.
9 http://www.w3.org/DesignIssues/Principles.html.

E. Oren et al. / Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

handling unexpected data. An initial approach and related work
towards such a component have been described in [53].
Data interface. An application that processes Semantic Web data
needs a data interface to programmatically access and manipulate
its application data; many RDF stores to hold and query data currently exist but a programmatic interface is needed to access that
data from within the application, in the same programming language as used for the application. We develop such a component
in the rest of this article.
Reasoning interface. An application that processes Semantic Web
data needs to also reason using the semantics of this data (such
as OWL statements). Many RDF stores include a reasoning component as part of the query answering interface, others rely on
external reasoners or do not support such functionality at all. In
this article, we focus on using and manipulating RDF data and
therefore assume that reasoning is performed as part of the data
interface. Note that this black box assumption prevents applications from introspecting reasoning results but this is current
practice and a known limitation of, e.g. the SPARQL protocol.
Persistence layer. An application that allows users to edit and
update data requires a persistence layer in which to store these
annotations. Many RDF stores exist that offer such functionality
[5,10,32,75]. These can directly be used as persistence compo-
nents, as long as their interface supports data manipulation and
persistent updates.
Annotation interface. An application that allows users to edit
data requires a user interface mechanism to help users in their
annotation. In an open and decentralised environment, aligning
vocabulary during editing is crucial to ensure high-quality data
which can be understood by others later. We have described the
first part of such an annotation component, namely a collaborative
recommendation algorithm for annotation vocabulary, in [55].
Crawler and integration service. An application operating on distributed data sources needs a component to crawl remote sources,
to locate relevant data sources for inclusion in the application, and
to integrate that data into one uniform picture. We have described
the first part of such a component, the crawling and locating of
data sources, in [52,72].

5. Typical data access and manipulation patterns

Based on this survey, we have analysed the data access patterns
in existing approaches for programmatic access to relational data
[26] and in several APIs for accessing and manipulating RDF data
such as Sesame [10], Jena [75] and RDF2Go.10 In general, these APIs
contain helper and configuration methods for handling datatypes,
language tags, reasoning, parsing, serialisation, persistence, and
error handling. Secondly, the APIs contain methods to execute arbitrary queries on the dataset, in the language supported by the
underlying store, similar to safe conjunctive datalog [73].

Most importantly, these APIs contain several high-level methods
for the most common access patterns that abstract from the lowlevel query languages of the data stores. Generalising over these
various APIs, we can observe three such high-level methods that
describe the offered data access patterns: to read object values, to
w rite object values and to find resources. These access patterns
correspond to the main manipulation patterns in relational data
abstraction patterns such as ActiveRecord ([26], p. 160).

Fundamentally, these data access patterns are based on filtering the graph into a set of relevant objects and then manipulating
those objects. We can describe these patterns formally as a graph-

based language with path accessors. In fact, the three patterns that
emerged from our analysis, reading object values, writing object
values and finding resources, can be expressed using a subset of the
PathLog language [27]. A short example is shown in Fig. 1, selecting each employee X who is 30 years old and living in New York,
together with the number of cylinders of his cars. In this syntax,
variable names are capitalised, : indicates class membership, and
. and .. are path accessors for scalar and set-valued objects.

In our analysis we use only a subset of PathLog, described
in Definition 5.1; we only give a syntactical definition, the wellformedness and semantics are as defined by Frohn et al. [27]. In
this definition, the set of names consists of all subjects, predicates
and objects in our graph, which is the union of all vertices and edge
labels in the RDF graph.

Definition 5.1. Given an alphabet, consisting of a set N of names,
a set V of variables and the usual logical quantifiers, the set of all
object references (data access patterns) are defined as follows:
 A node n N is a reference, called simple reference.
 A variable X  V is a reference, called simple reference.
 If ri is a reference and rj is a simple reference, then the expression
ri.rj is a reference, called path reference.
 If ri, rk are references and rj is a simple reference, then the expressions ri[rj  rk] and ri : rj are references, called molecules.
 If ri[rj  rk] and ri[rl  rm] are references then the expression
ri[rj  rk; rl  rm] is a reference, called molecule.

Fig. 2 shows examples of the three identified patterns (read-
ing object values, writing object values and finding resources)
expressed according to Definition 5.1: Examples 1(a) and 1(b) show
simple path references of length one that retrieve the author and
topics of some post, Example 1(c) shows a longer path reference
that retrieves the age of the author of some post. The Examples 2(a)
and 2(b) show how to add and delete add an objects value based on
direct or longer path references. Example 2(c) combines these two
to set an objects value by deleting all existing values and setting
the new value. Note that since multi-valued data does not exist in
the relational paradigm, our distinction between adding and setting
data values does not appear in relational access patterns. Examples
3(a)3(c) show how to locate resources that fulfil certain properties
(described by filtering molecules); the first selects all posts (filter-
ing on their class), the second selects all posts written by John and
the third selects all posts written by John on some topic. Note that
even though applications may use arbitrary queries for retrieving
data, these can typically be mapped to the given patterns.

6. Programming languages for embedding RDF data

After analysing the typical patterns for data access and manipu-
lation, a mapping solution should be designed that supports exactly
these patterns from within the application programming language.
Since a large portion of current software is developed in the objectoriented paradigm,11 an appropriate mapping solution should be
embedded inside an object-oriented language.

However, directly designing a mapping solution in a statically
typed object-oriented language such as Java or C# would suffer
from several mismatches between these languages and Semantic Web data, as shown in Table 2: in typical OO languages each
object must be a member of exactly one class, whereas in RDF(S)
resources can have multiple types; in typical OO languages classes
can only inherit behaviour from at most one direct superclass,

10 http://rdf2go.ontoware.org.

11 http://www.tiobe.com/tpci.htm.

Fig. 1. Example PathLog expression, adapted from [27].

Fig. 2. Typical object-oriented data manipulation patterns.

Table 2
Mismatches between object-oriented and Semantic Web data

Capability

Class membership
Class inheritance

Object conformance

Semi-structured data

Runtime evolution

Object-oriented languages

RDF Schema

Each object is member of exactly one class
Classes can inherit behaviour from at most one superclass,
interfaces notwithstanding
Instance structure must strictly adhere to class definitions

Class definitions are strict, prescribe all instance properties
and are required for all instances
Class definitions typically cannot evolve during runtime

Resources can have multiple types
Classes can inherit from multiple superclasses

Class definitions are not exhaustive and do not constrain
the structure of their instances
Instances might deviate from the class Definition or appear
without any schema information
Data is integrated from heterogeneous sources with
varying structures where both schema and data may
evolve at runtime

whereas in RDF(S) classes can have multiple superclasses (although
interfaces may be used to mimic multiple inheritance, implementing multiple class membership is still awkward); in typical OO
languages, instances must conform exactly to the structure (prop-
erties and methods) of their class definition, whereas in RDF(S)
instances may easily deviate from their class definitions or not have
such definitions at all;12 finally, in typical OO languages the class
definitions are known at design-time and do not change during run-
time, whereas the typical application setting of RDF(S) data would
include data and schema evolution from various sources at runtime.
Statically typed object-oriented languages, such as Java, are
designed for programming closed systems in which design-time
constraints have been set in the form of class definitions and must
be followed during runtime [63]: for example, instance cannot have
properties that are not defined in their classes. In contrast, the
semantics of classes and instances in RDF Schema assumes an open-

12 Note that the meaning of rdfs:domain is often misinterpreted. P rdfs:domain
D does not mean that all members of D have a property P, but that if a property P
occurs for a resource R, R must be a member of D, e.g. all things that have a name are
a Person: has Name.  Person. However, OO class definitions specify something
else, namely that all Persons have a name: Person  has Name., equivalent to
has Name.  Person, stating that everything that does not have a name is not a
Person, which does not hold in RDF(S). Thus, when mapping domain definitions to
methods on the object-oriented class D, not all members of D will conform to the
class definition.

world model where constraints cannot be enforced by a central
party.

Given the dynamic, open, nature of the Semantic Web,
dynamic general-purpose scripting languages seem more suit-
able, since their origin as glue code makes them fault-tolerant
and well-suited for handling heterogeneous data and uncertainty that underlie open systems without central control [57].
These languages, such as Smalltalk, Perl, Python, and Ruby, are
dynamically typed, typically allow higher-order constructs (e.g.
passing methods to methods) and support complete reflection,
both introspection (obtaining information on objects at runtime)
as intercession (modifying objects at runtime). Such dynamically
typed languages enable us to address the identified mismatches in
Table 2 as follows:

Class membership: the dynamic typing of these languages does not
require object classes to be defined statically but rather allows
them to be determined at runtime by the capabilities of the object.
Dynamic typing maps well onto RDF(S) class membership, which
can change dynamically during runtime as well. Although objects
in most dynamically typed languages can have not more than one
class at a time, we can change that behaviour at runtime (using
intercession).
Inheritance: similarly, although most dynamically typed languages
do not support multiple-inheritance, this behaviour can be added
through reflection (by injecting multiple supertypes into sub-

E. Oren et al. / Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

classes during runtime) since, in the absence of behavioural
definitions, inheritance in RDF(S) affects only object typing.
Object conformance: dynamically typed languages typically do not
require objects to strictly conform to their class definitions but
instead allow objects to deviate from their classes by, for exam-
ple, specifying a different behaviour (method implementation) for
several objects of the same class.
Semi-structured data: the flexibility and intercession facility of
these languages often removes the need for attribute definitions
in classes and lets instance attributes have multiple values of multiple types without problems.
Runtime evolution: because dynamically typed languages are interpreted and do not rely on strict and predefined classes, they
are well-suited for flexible environments in which both data and
schema can evolve. Their introspection features enable programs
to interrogate the schemas and domain vocabulary at runtime.

7. A layered architecture for programmatic access to data

Having analysed the typical access patterns for a mapping
library and explained the suitability of implementing such mappings in a dynamically typed programming language, we now
present ActiveRDF, an object-oriented API for Semantic Web data.
ActiveRDF maps RDF Schema classes to programming classes, RDF
resources to programming objects and RDF predicates to methods
on those objects, thus lifting data elements into first-class citizens
(objects of the language itself). ActiveRDF is implemented in Ruby,
and available open-source from http://activerdf.org.

ActiveRDF offers a virtual API which is simulated through
reflection and meta-programming. This virtual API completely
implements the pattern language described in Definition 5.1 and
Fig. 2. Apart from these high-level access patterns, ActiveRDF also
allows full programmatic access to construct and execute arbitrary queries, but without the abstraction into high-level patterns.
ActiveRDF supports simultaneous access to data from multiple
sources, using quads (named graphs [12]) to distinguish the provenance of the data.

The concrete programmatic primitives of ActiveRDF depend
on the actual available instance data at runtime and thus form
a domain-specific language for the application developer [20,49].
For example, if during, data is encountered about Persons with
names, the method Person.find by namewill be created. In fact,
the method is not created but only simulated through meta-
programming, which is relatively straightforward in a dynamically
typed interpreted language such as Ruby.

The general principle of ActiveRDF is to represent RDF resources
through transparent proxy objects. Each proxy object represents
one RDF resource but does not contain any state. All methods on
the proxy object are translated into read or write queries related to
the proxys RDF resource. Our architecture consists of four layers
which incrementally abstract RDF data into objects, as shown in
Fig. 3. Such a layered architecture [28] supports (i) design based
on increasing levels of abstraction, allowing the implementation to
partition the problem into a set of incremental steps; (ii) gradual
enhancement because as each layer interacts only with the layers
directly above and below itself, the effects of changes are limited;
(iii) reuse, since different implementations of the same layer can
be used interchangeably. The layers incrementally abstract the RDF
statements from the data sources into objects.

7.1. Adapters

Adapters provide access to a specific RDF data-store by translating generic RDF operations to a store-specific API. Such RDF

Fig. 3. ActiveRDF architecture.

data-store specific adapters are necessary, because of the absence
of a general standardised query language which provides create,
read, update, and delete access. The adapter layer assures vendorindependence in the rest of the architecture, as all store-specific
operations are encapsulated within the adapters. The adapters
translate and execute queries from the federation manager into a
query language supported by their data source.

Adapters do not necessarily wrap RDF data sources, they can
also wrap sources such as desktop application data [65] or relational
databases [7], as long as they respond to RDF queries and also return
query results in RDF. Adapters have been implemented for generic
SPARQL endpoints, and for Sesame [10], Jena [75], YARS [32], and
Redland [5].

7.2. Federation manager

The federation manager manages the collection of available data
sources, distributes the queries over some or all of these sources
and collects their results. The federation manager should, when
querying multiple data sources, consolidate the results [21]: similar
objects that are identified differently in the different data sources
should be merged before the results are returned. In the current
implementation query distribution is achieved by simply querying
all data sources sequentially; query result aggregation is achieved
through a union of individual results. We have not yet implemented
a consolidation strategy in the federation manager, but we do offer
an extension point for later addition of such functionality.

7.3. Query engine

ActiveRDF includes a complete query API and execution engine,
providing an abstract interface independent of a specific data
source and query language. Through the query API, applications
can specify expressive queries in a compact Ruby syntax without relying on a single data store. ActiveRDF does not contain a
query processor: for execution the queries are handed to the federation manager which distributes the queries over the data sources
through its adapters; each query is executed by each data source.
The query manager is used by the object manager to construct
queries for each object manipulation and can be used by the application developer to execute complex queries on the data sources.
The query API supports most of the SPARQL grammar, namely conjunctive queries with select, distinct, arbitrary where clauses, and
several filters. Additionally it allows (for adapters that support this)

Fig. 4. Evaluation queries in SPARQL.

counting query results, specifying the limit and offset of the query
results and full-text keyword search.

7.4. Object manager

The object manager offers the top-level virtual API to manipulate RDF. This virtual API is modelled to mimic the ActiveRecord
pattern [26] where possible. The object manager is the library entry
point and provides all the mapping functionality for the identified
patterns as a domain-specific language.

The object manager maps all RDF(S) classes to Ruby classes, all
RDF resources to Ruby objects, and all RDF properties to attributes
on the Ruby objects. All RDF resources are by default created as
Ruby objects of class RDFS::Resource. Since Ruby does not allow
multiple class membership such as in RDFS, we override all relevant built-in methods using reflection to rely on the defined
rdf:type(s) of the resource instead of on its Ruby class.

such

as

Domain-specific methods

or
post.creator
post.title are not generated but provided virtually:
the
object manager catches their invocation and translates the method
call into a query. Without the object managers interference, Ruby
would throw a M ethodNotFound error. To prevent clashes between
similarly named classes in different libraries we map the RDF
namespaces onto the namespace mechanism provided by Ruby.

Fig. 5. Evaluation queries in ActiveRDF.

page and all available people; the other queries use the Query API. A
further indication of the gained productivity has been given in some
of our publications [8,34,56] that describe the effort required for
developing several Semantic Web applications using ActiveRDF; a
further development example will be described in the next section.
For quantitative evaluation, we compared query execution on
Sesame (using various queries and various datasets) using the curl
HTTP client (which shows the time needed by the data store for
query answering), the Sesame Java API and ActiveRDF. We evaluated
the same queries from Fig. 4 using five different datasets (ranging
from 2500 to 50,000 triples). Each test was first run to warm-boot
the server and then repeated 10 times. The tests were run on a
server with two 1994MHz AMD Opteron 246 processors and 2Gb
RAM.

Fig. 6 shows the average response time (including result parsing
in Java and ActiveRDF) of each query using curl, Java, and ActiveRDF
in a logarithmic scale. It can be seen that for most queries ActiveRDF
adds only little overhead. On some queries ActiveRDF seems to perform faster than using curl HTTP, which is probably due to random
hardware variations and measurement difficulties in those small
response time ranges.

For queries #3, #4 and #5 however the overhead of ActiveRDF
is substantial. Because these queries return large amounts of XML
results, we suspected the performance to be influenced by the
Ruby XML parser. Fig. 7 therefore shows the average response time
for same queries but with the JSON result format instead of XML:
indeed the response time is on average halved, but still rather large
(query #3 from 30s to 15s, query #4 from 20s to 12s, query #5 from
13s to 7s).

8. Evaluation

9. Example application: exploring online communities

We evaluate ActiveRDF both in qualitative and in quantitative
sense. First, we can indicate the elegance of the mapping approach
through some typical examples. We have already shown some
example object manipulations for reading and writing triples in
the previous section. Figs. 4 and 5 compare some typical queries in
the standard SPARQL query language with their ActiveRDF counter-
parts; the same queries will be used for the quantitative evaluation
next.

The first query retrieves the homepage of a certain person, then
several queries are given that retrieve all predicates and objects of
a certain resource and all of all resources, including and excluding
duplicates, and the final query retrieves all people. The ActiveRDF
version of these queries is shown in Fig. 5; first some namespaces
are registered after which the queries are listed. The first and last
query use the virtual API to find one specific person and his home-

This section describes the SIOC explorer, an example implementation of a Semantic Web portal. The application shows the
feasibility of assembling an application according to the pattern architecture [33] and the development support provided by
ActiveRDF in combination with Ruby on Rails.

The SIOC explorer crawls, fetches and integrates information
from several online community sites, such as forums, weblogs and
bulletin boards. These community sites enable data integration by
exporting their content using the Semantically Interlinked Online
Communities (SIOCs) vocabulary, which was developed to express
the content of community-centred web sites as RDF data.

The SIOC explorer lets the user subscribe to SIOC data from
web sites, then aggregates the SIOC data and provides a faceted
user interface for browsing and navigating the data. This gives
the user a unified view on the content and the community

E. Oren et al. / Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

Fig. 6. Querying Sesame in ActiveRDF (log scale).

from multiple sites at once, which users can use to better follow activities of a community on the web. The SIOC explorer
implements the semantic portal pattern [33].
It utilises the
Ruby on Rails web application framework as the basis for the
application and implements the different parts of the semantic
portal pattern through pre-made components or some custom
implementations.

9.1. Domain: social communities on the web

Online community sites (such as blogs, wikis and bulletin
boards) are playing an important role in keeping people informed
and facilitating communication on the Web. Some of these sites
are more centralised, others are more decentralised, but from an
abstract perspective all such communities play a similar role: they

allow users to gather online, create content and participate in discussions about their topics of interest.

Often, discussions range over several of these communication
channels. People try to keep up with these discussions by following
web feeds or by using search engines. However, these methods are
insufficient for following some communities. Current feed formats
only allow to see a single stream of content with a rigid internal
structure of textual feed items. Search engines define the relevance
of content based on the links pointing to the content and not on
measures intrinsic to a specific community.

The SIOC initiative aims to facilitate the integration of online
social community information [9]. SIOC provides a unified ontology
to describe online communities; additionally, the SIOC initiative
offers several exporters that translate data from weblogs, forums
and mailing lists into RDF using the SIOC vocabulary.

Fig. 7. Querying Sesame ActiveRDF using JSON (log scale).

Fig. 8. Architecture of the SIOC explorer.

9.2. The Ruby on Rails Web application framework

Ruby on Rails is an MVC-based rapid application development
framework [71]. It is used as the foundation on which the SIOC
explorer is built, as it provides a domain independent framework
for building web applications. It divides the web application into
three layers according to the modelviewcontroller [11,40,61]: the
model provides objects that represent the real-world data, the controller implements the application logic and the flow between the
model and the view, and view displays the results of the controller
to the user.

Ruby on Rails provides scripts which allow developers to create
an empty skeleton of a typical web application. The skeleton application has stubs for the model, view and controller parts, which
can be customised by the application developer to implement their
business and domain logic. The model is typically provided by
an automatic mapping from an existing database, the controller
describes the control-flow in Ruby and the view is specified through
HTML templates with embedded Ruby code.

Ruby on Rails has two main strengths: on the one hand it
provides default application logic for the generic parts of web
applications and several helper methods for data manipulation
and JavaScript effects, alleviating developers from these tasks.
On the other hand, since Ruby on Rails is targeted towards web
applications that operate on relational databases, it integrates the
business logic with the domain data using an objectrelational
mapping: database tables serve as domain models and database
tuples become Ruby instances.

The two pre-made components used in the SIOC explorer,
ActiveRDF and BrowseRDF, both extend Ruby on Rails, and provide
access to Semantic Web technologies, while still enabling the developer to reuse the whole Ruby on Rails ecosystem of libraries, helpers
and deployment mechanisms. ActiveRDF can serve as a data layer
in Ruby on Rails, replacing or augmenting the default ActiveRecord
layer. The BrowseRDF navigation algorithms are implemented as a
library that provides generic navigation on top of ActiveRDF; the
library also includes helpers that generate the appropriate HTML
navigation code in any Ruby on Rails application.

9.3. Implementing the SIOC explorer

tion logic for extracting social context and (v) a viewer interface
which provides facetted browsing. Fig. 8 shows the different parts
of the application.

The interaction between the parts of the SIOC explorer follow
the typical interaction schema of the semantic portal pattern [33]:
the viewer interface mediates between the user and the back-end
components of the application. The user can use it to subscribe to
SIOC enabled sites and to browse and navigate the aggregated data,
which is loaded from the semantic persistent store. The crawler
aggregates the data by visiting the subscribed sites, and stores the
data to the semantic persistent store. The integration service unifies
the aggregated data, and writes it back to the store. The application
logic for extracting social context works on the unified data and
creates social metrics which it writes back to the store. All data is
then displayed by the viewer interface.

9.3.1. Crawling SIOC data

A custom crawler has been implemented for this application,
based on cURL13 and Hpricot14 to extract links to the SIOC RDF data
from the community sites; the Redland [5]rapper utility to fetch
the actual SIOC RDF and to convert it into ntriples; the Linux cron
daemon to schedule periodic updates of the data; and Berkeley DB15
as a persistent hashtable of visited sites.

9.3.2. Integrating the data

The crawled data from the different community sites has to be
integrated and consolidated, which has been implemented in a custom component. The data from multiple sites is first converted into
a common RDF serialisation and concatenated into a single set of
triples. The data is then consolidated based on OWL inverse functional properties, using the OWLIM16 extension for the Sesame [10]
in combination with a custom algorithm for rewriting synonym
resources into a single canonical URI.

9.3.3. Application logic: social context extraction

The application uses algorithms from the domain of social network analysis to extract two types of social context information
from the gathered SIOC data, described in [8]. On the one hand, we
extract the social neighbourhood of each site member, formed by
the set of people that he knows directly or indirectly via online

Internally, the SIOC explorer consists of (i) a custom built
crawler, which acquires and aggregates SIOC data from web sites,
(ii) a semantic persistent store for the SIOC data, (iii) an integration
service for unifying the crawled data, (iv) domain specific applica-

13 http://curl.haxx.se/.
14 http://code.whytheluckystiff.net/hpricot/.
15 http://www.oracle.com/database/berkeley-db.html.
16 http://www.ontotext.com/owlim/.

E. Oren et al. / Web Semantics: Science, Services and Agents on the World Wide Web 6 (2008) 191202

Fig. 9. Overview page of the SIOC explorer.

interaction. On the other hand, we extract the social reputation
of each member, based on their community involvement, on their
activity level and on their connectedness to their peers.

and interests, and also his extracted social context. The screenshot
shows a summary of these relations, with more details and links to
actual people in the social neighbourhood available by clicking the
links.

9.3.4. Faceted navigation with BrowseRDF

The viewer interface is based on the reusable BrowseRDF [53]
component, with some application-specific customisations. The
BrowseRDF component enables faceted navigation through an arbitrary dataset; in the SIOC explorer, BrowseRDF is used for filtering
the presented SIOC data.

Fig. 9 shows the overview page of the current prototype, with
a list of several weblogs and forums. Users can decide to browse
a particular forum, or see all posts aggregated from all sites. After
selecting a particular forum, the user is presented with a list of
posts in this forum in a reverse chronological order. Each post is
summarised and can be opened to read the full content. An example of detailed view is shown in Fig. 10, which includes metadata
about the post, its complete text and all replies (which might have
been posted outside of this particular weblog). Also, lateral social
browsing is supported: clicking on an author or commenter jumps
to this persons profile which includes all posts and replies written by this person across all forums; clicking on a topic shows all
posts tagged with this topic, again across all forums. In contrast to
ordinary feed readers, our lateral browsing works across all types of
community forums: clicking on the user Cloud will not only show
all his weblog posts, but also his contributions to mailing lists, IRC
discussions, bulletin boards, etc.

Fig. 11 shows an example of a persons description, including
information from his FOAF profile such as his picture, homepage

9.4. Implemented Semantic Web capabilities

The SIOC explorer is able to leverage the Ruby on Rails framework through the ActiveRDF object-oriented data mapping. Due
to this data mapping and the set of related components, the
implementation efforts is relatively low. The data models are
automatically provided as virtual models through ActiveRDF, the
controller (with all application logic) contains around 95 lines of
code and the views contain around 100 lines of abstract HTML.
The SIOC crawler consists of around 150 lines of code. The application still manages to implement many of the possible capabilities
of Semantic Web applications described in [33].

The application supports the Semantic Web standard RDF
together with parts of RDF Schema and OWL which are used for
object consolidation. The open SIOC schema is used as the basis for
the viewer interface. Data can be accessed and aggregated from
any existing SIOC enabled web site, which enables accessing data
with diverse ownership from distributed storage. Updates to the
data are possible at runtime. The application treats RDF schema
information as any other data and does not support specific schema
access capabilities.

Data

integration

and

semi-
automatically: only SIOC sources are supported, which can be
easily integrated without human supervision using a straight-

performed

alignment

is

Fig. 10. An example post and aggregated replies.

Fig. 11. An example user profile with extracted social relations.

forward integration algorithm. Inferencing is used during the
integration process to collide nodes with shared identity. Text
and images are the supported content types, without support for
authoring or collaboration, as the application only provides read
access to the data. Finally, the SIOC explorer has some degree of
openness, since it can use data from any external source, as long as
that data conforms to the SIOC vocabulary.

10. Conclusion

As any application needs to manipulate data, typical access patterns should be abstracted into higher-level libraries and embedded
into the application programming environment. We have analysed
which access patterns should be supported in a programmatic man-
ner, formally expressed these as a subset of PathLog and explained
why the techniques used in traditional objectrelational mapping approaches are not sufficient for Semantic Web data. We
have showed why dynamically typed object-oriented languages
offer a suitable environment for our mapping solution, given their
dynamic typing of objects, which maps well onto the RDF(S) class
membership, their support for full reflection, which allows us to
implement the multi-inheritance of RDF(S), and their relaxation of
strict object conformance to class definitions.

We have presented ActiveRDF, an object-oriented library for RDF
data that supports the analysed access patterns through a layered
architecture that ensures vendor-independence. ActiveRDF is lightweight and implemented in around 600 lines of code. It can be used
with generic SPARQL endpoints, on popular RDF data stores, and
with desktop application data. ActiveRDF can serve as a data layer
in Ruby on Rails, replacing or augmenting the default ActiveRecord layer, to provide a data access solution in the development of
Semantic Web applications.

For future work we are investigating improving the performance
of our object mapping technique. We are also trying to analyse
and categorise typical software patterns in Semantic Web applications (see, e.g. [33]) and investigating how to support these patterns
within ActiveRDF.
