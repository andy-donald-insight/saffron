Laconic and Precise Justifications in OWL

Matthew Horridge, Bijan Parsia, and Ulrike Sattler

School of Computer Science
The University of Manchester

Oxford Road
Manchester
M13 9PL

Abstract. A justification for an entailment in an OWL ontology is a minimal subset of the ontology that is sufficient for that entailment to hold.
Since justifications respect the syntactic form of axioms in an ontology,
they are usually neither syntactically nor semantically minimal. This paper presents two new subclasses of justificationslaconic justifications and
precise justifications. Laconic justifications only consist of axioms that do
not contain any superfluous parts. Precise justifications can be derived
from laconic justifications and are characterised by the fact that they consist of flat, small axioms, which facilitate the generation of semantically
minimal repairs. Formal definitions for both types of justification are pre-
sented. In contrast to previous work in this area, these definitions make it
clear as to what exactly parts of axioms are. In order to demonstrate the
practicability of computing laconic, and hence precise justifications, an algorithm is provided and results from an empirical evaluation carried out on
several published ontologies are presented. The evaluation showed that la-
conic/precise justifications can be computed in a reasonable time for entailments in a range of ontologies that vary in size and complexity. It was found
that in half of the ontologies sampled there were entailments that had more
laconic/precise justifications than regular justifications. More surprisingly
it was observed that for some ontologies there were fewer laconic justifications than regular justifications.

1 Introduction

Since the Web Ontology Language, OWL, became a W3C standard, there has
been a notable increase in the number of people building, extending and using
ontologies. As a result of this, a large number of people have been enticed into
using some kind of description logic reasoning service as an aid during the construction and deployment of ontologies. As people have gained in confidence,
they have begun to move from creating or using modestly expressive ontologies,
through to using richly axiomatised ontologies that exercise the full expressivity
of OWL-DL. Experience of delivering a variety of tools to a wide range of users
has made it evident that there is a significant demand for editing environments
that provide sophisticated editing and browsing support services. In particular,
the generation of justifications [1] for entailments is now recognised as highly desirable functionality for both ontology development and ontology reuse. A clear

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 323338, 2008.
c Springer-Verlag Berlin Heidelberg 2008

M. Horridge, B. Parsia, and U. Sattler

demonstration of the need for practical explanation services that provide justifications was demonstrated by the fact that many users switched from Prot eg e 3.2
to Swoop purely for the benefits of automatic explanation facilities.

The ability to obtain justifications for entailments was originally exposed to
the masses in the ontology editing and browsing tool Swoop [2]. Since then, other
OWL tools, such as Prot eg e-4 [3], OWLSight,1 and Top Braid Composer2 have
adopted the ability to generate these justifications, showing the importance of
explanations to end users.

Intuitively, a justification is a set of axioms from an ontology that is sufficient
for an entailment to hold. A key aspect of justifications is that they operate
on the level of asserted axioms. That is, the axioms in a justification directly
correspond to axioms that have been asserted in the ontology in which the
entailment holds. Therefore, if an ontology contains long axioms, for example,
ones containing many complex class expressions, then there may be parts of
axioms in a justification that are not required for the entailment that is supported
by the justification. For example, consider the set of axioms J = {A  BC, C 
D, A  D} which entails A  . The right hand side of first axiom in the set
contains the conjunct B. However, this conjunct does not play any part in causing
A to be unsatisfiable. In this sense, if this set of axioms is a justification for A  
then it could be more fine-grainedit should be somehow possible to indicate
that only part of the first axiom is required for the entailment A   to
hold. Justifications that only contain parts of axioms that are relevant for the
entailment to hold, have been referred to as fine-grained justifications [4], and
also precise justifications [5].

While there is a general feeling that fine-grained justifications should only
consist of the parts of axioms that are relevant to the entailment in question,
there have not been any attempts to produce a rigourous formalisation of these
kinds of justifications. This means that while it is cut and dried as to what
exactly a justification is, the same cannot be said for fine-grained justifications.
In particular, it is not clear what it means to talk about parts of axioms. Not
only does this make it difficult for implementers to be sure they can generate
fine-grained justifications in a sound and complete manner, it also makes it
difficult to compare the approach taken by one system in generating fine-grained
justifications to the approach taken by other systems.

The purpose of this paper is to identify the desirable characteristics of finegrained justifications, propose a formal definition for these types of justifications,
and show how they can be computed for OWL-DL. In order to demonstrate
that computing these justifications according to this definition is feasible, an
algorithm is provided, which is evaluated on a sample of published ontologies.

2 Preliminaries

Throughout this paper, the following nomenclature is used.

1 http://pellet.owldl.com/ontology-browser/
2 http://www.topbraid.org
?

?

?

||

(O)

O
((O)) the deductive closure of the structural transformation of O
O+
?

?

?
an axiom; subscripts and primes are used to denote different axioms
refers to the length of 
an ontology
a set of axioms that is the result of a structural transformation on O
an arbitrary entailment that is assumed to hold in some ontology or set of axioms
the deductive closure of an ontology O
a subset of the deductive closure of an ontology O
a set of sets of axioms
a justification
a description logic, e.g. ALC, SHOIQ
?

?

?
A, B, C, D, E are used as concept names, R and S as role names, n and n
are place holders for positive integers. T refers to a T-Box, R a Role-Box and
A an A-Box.
Given an ontology, O, and a description logic L the deductive closure of O,
is written as OL, where OL = {  L | O |= }. In other words the deductive
closure contains all well formed L-axioms that are entailed by the ontology O.
When it is clear from the context, the subscript L is dropped.
 |= .

 is said to be weaker than another axiom,  iff  |= 

An axiom 

 and 

OWL and Description Logics. This paper focuses on OWL-DL or its rough
syntactic variant SHOIN (D) [6], but the approach can be applied to other
description logics such as SROIQ, which will underpin the next version of OWL.
For the purposes of this paper, an ontology is regarded as a finite set of
SHOIN axioms {0, . . . , n}. An axiom is of the form of C  D or C  D,
where C and D are (possibly complex) concept descriptions, or S  R or S  R
where S and R are (possibly inverse) roles. OWL contains a significant amount of
syntactic sugar, such as DisjointClasses(C, D), F unctionalObjectP roperty(R)
or Domain(R, C), however, these kinds of axioms can be represented using subclass axioms [6].

Justifications. A justification [1,7,8] for an entailment in an ontology is a
minimal set of axioms from the ontology that is sufficient for the entailment
to hold. The set is minimal in that the entailment does not follow from any
proper subset of the justification. It should be noted that there may be several,
potentially overlapping, justifications for a given entailment.
Definition 1 (Justification). For an ontology O and an entailment  where
O |= , a set of axioms J is a justification for  in O if J  O, J |=  and if
J   J then J  |= .

3 Motivation for Fine-Grained Justifications

Justifications have proved to be very useful in general. However, there are at
least four reasons that motivate the investigation of fine-grained justifications:

M. Horridge, B. Parsia, and U. Sattler

1. An axiom in a justification can contain irrelevant parts. Consider O = {B 
C  D, D  E} |= B  E. Clearly, O is a justification for B  E, but the
first conjunct in the first axiom is irrelevant for this entailment and might
distract a user from identifying the relevant parts. It is arguable that focusing
a users attention on the relevant parts of an axiom can make it easier for
them to understand a justification.
2. A justification can conceal relevant information. Consider O = {B  C 
D, B  C  D} |= B  . B is unsatisfiable for two distinct reasons, but
there is only a single justification for it (containing both axioms from O). If
this entailment is broken by deleting one of the axioms then modelling errors
could be introducedit may be that the repaired ontology should contain
B  D  C. We refer to this condition as internal masking.
3. Justifications can mask relevant axioms. Consider O = {B  DDC, B 
C} |= B  . There is no justification in O for B   that includes
{B  C}, yet, it clearly plays a role in entailing the unsatisfiability. Users
working with justifications would most likely be unaware of this. We refer to
this condition as external masking

4. Multiple justifications can conceal a fine-grained core. In certain cases there
may be multiple justifications for an entailment but fewer fine-grained justifications for the same entailment. Consider {A  B  C, B  D} and
{A  B  F, B  D} as two justifications for A  B. There is just one
fine-grained justification: {A  B, B  D}. Besides making the entailment
easier to understand, this scenario might also indicate modelling errors or
redundancies.

A common point running through all of the above is the issue of repair. Since
a justification is a subset of an ontology, and consists of asserted axioms, it is
relatively straightforward, and intuitive, to devise a repair for the ontology that
breaks the entailment in question: Given some undesired entailment  that holds
in an ontology O, and a set of justifications J for , a simple method of breaking
the entailment is to choose one axiom from each justification J  J and remove
these chosen axioms from O. However, from the above examples, it should be
fairly clear that when working with regular justifications there is a potential to
over repair an ontology so that more entailments are lost than is necessary. In
this sense, it is desirable that any definition of fine-grained justifications should
result in justifications that make it easy to devise and enact a minimal and
consistent repair of an ontology. Ideally, the underlying repair process should
mimic the intuitive process of repair when working with regular justifications
one axiom from each fine-grained justification should be identified as a candidate
for removal from the ontology or some suitable variant.

4 Related Work

In [5], Kalyanpur et al. propose an algorithm for computing precise justifica-
tions. The algorithm rewrites axioms into smaller axioms in order to obtain the
relevant parts.
?

?

?
The ontology editor Swoop [2] features the ability to strike out irrelevant
parts of axioms in a justification. However, this is based on a heuristic approach,
and while it is very efficient, and is strongly expected to be sound, it is incomplete.
In [4], Lam presents fine grained justifications for ALC with general TBoxes.
A tableaux reasoning technique, which is an extension of the technique from
Meyer et al. [9] and Baader and Hollunder [10] is used.

In [8], Schlobach and Cornet focus on computing explanations for unsatisfiable classes. They define the concepts of MUPS (Minimal Unsatisfiability Preserving Sub-TBoxes) and MIPS (Minimal Incoherence Preserving Sub-TBoxes),
which are special cases of justifications. Schlobach and Cornet describe a procedure that syntactically generalises all of the axioms in each MIPS to produce
a generalised TBox that contains smaller axioms which are responsible for any
unsatisfiable classes.

Deng et al. [11] take a novel approach to measuring inconsistencies in description logic ontologies by using results obtained from Game Theory. Although no
details are provided, Deng claims that the technique could easily be extended
to pinpoint the proportions of axioms that are responsible for an unsatisfiable
class, via the use of clause pinpointing.
Finally, in [12] Baader et al. pinpoint axioms for entailments in the description
logic EL. Although the work is not concerned with fine-grained justifications, the
EL subsumption algorithm uses a normalisation procedure that flattens axioms
and makes them smaller. These smaller axioms could be used to indicate the
parts of axioms responsible for an entailment.

A common aim of all previous approaches for computing fine-grained justifications is to determine the parts of axioms that are responsible for a particular
entailment. However, none of these approaches define exactly what they mean
by parts of axioms. Moreover, each approach is specific to a particular implementation technique and is defined in an operational sense. This means that it is
generally unclear as to what exactly constitutes a fine-grained justification. As
a consequence, it is unclear as to whether any one approach for computing finegrained justifications would result in the obtaining the same set of fine-grained
justifications for an entailment when compared to another approach.

In summary, a general definition of fine-grained justifications is needed. Ide-
ally, such a definition would not be tied to a particular DL. This definition
would then permit the evaluation and comparison of algorithms for computing
fine-grained or precise justifications and, it would make it possible to investigate the underlying problem in a thorough way.

5 Laconic and Precise Justifications Defined

There appear to several desirable properties that a definition for fine-grained
justifications should satisfy. In particular:

 Minimality Each axiom in a fine-grained justification should, in some sense,
be as small as possibleeach axiom should only capture the parts of the
asserted form that are required for the entailment in question to hold.

M. Horridge, B. Parsia, and U. Sattler

 Repair As with regular justifications, fine-grained justifications should suggest as simple a repair as possible. Ideally, removing an axiom from a finegrained justification should generate a repair that is minimal in terms of lost
entailments.
In what follows a definition of fine-grained justifications is proposed. This
definition consists of two parts: 1) a definition of what we term laconic justifi-
cations, which informally are justifications that do not contain any superfluous
parts; 2) a definition of what we term precise justifications, that can be derived
from laconic justifications, and are such that their axioms are flat, small and
semantically minimal. Precise justifications are primarily geared towards repair.

5.1 The Structural Transformation
The definition of laconic justifications below uses (J ), where  is a satisfiability
preserving structural transformation on J that removes all nested descriptions
and hence produces axioms that are as small and flat as possible. An appropriate
transformation, a version of which is shown below, is the well known structural
transformation described in Plaisted and Greenbaum [13] and used in [14].
C1C2T (  nnf(C1  C2))

(O) :=

(D(a)) := (  {a}  nnf(D))
?

?

?
i=1(A

(  C  D) := (  A
?

?

?
 Di) for D =
(  C  R.D) := (  AD  C)  {AD  R.A
}  (A
 D)
?

?

?
(  C  R.D) := (  AD  C)  {AD  R.A
}  (A
 D)
?

?

?
 D)
}  (A
(  C  nR.D) := (  AD  C)  {AD  nR.A
?

?

?
(  C  R.D) := (  AD  C)  {AD  nR.A
}  (A
 D)
?

?

?
 D) (If D is of the form A or A)

n
i=1Di

RA () 

 C) 

n
?

?

?
(A
?

?

?
(A

 D) := (A
?

?

?
 D) := (  A
?

?

?
() :=  for any other axiom

 D) (If D is not of the form A or A)

Note. A is an atomic concept in the signature of O, AD and A

D are fresh concept names that are not in the signature of O. Ci and D are arbitrary concepts,
excluding ,  and literals of the form X or X where X is not in the signature of O, C is a possibly empty disjunction of arbitrary concepts. C  D
is syntactic sugar for C  D and D  C, as is =nR.D for nR.D  nR.D.
Domain and range axioms are GCIs so that Domain(R, C) means R.  C,
and Range(R, C) means   R.C. The negation normal form of D is nnf(D).
The transformation ensures that concept names that are in the signature of
O only appear in axioms of the form X  A or X  A, where X is some
concept name not occurring in the signature of O. Note that the structural
transformation does not use structure sharing3.
3 For example, given   C  R.C, two new names should be introduced, one for
each use of C, to give {  X0  X1, X1  R.X2, X2  C}. The preclusion of
structure sharing ensures that the different positions of C are captured.
?

?

?
5.2 Axiom Length

The definition of laconic justifications uses the notion of the length of an axiom.
Length is defined as follows: For X, Y a pair of concepts or roles, A a concept
name, and R a role, the length of an axiom is defined as follows:
|X  Y | := |X|+|Y |,

|Sym(R)| = |T rans(R)| := 1,

|X  Y | := 2(|X|+|Y |),

where

|| = || := 0,
|A| = |{i}| = |R| := 1,
|C| := |C|
|C  D| = |C  D| := |C| + |D|
|R.C| = |R.C| = |  nR.C| = |  nR.C| := 1 + |C|

Note. This definition is slightly different from the usual definition, but it allows
cardinality axioms such as A   2R.C to be weakened to A   3R.C without
increasing the length of the axiom.

5.3 Laconic Justifications

With a suitable structural transformation, , and the notion of axiom length
in hand, laconic justifications can be defined. (Recall that O is the deductive
closure of O)
Definition 2. (Laconic Justification) Let O be an ontology such that O |= .
J is a laconic justification for  over O:
1. J is a justification for  in O
2. (J ) is a justification for  in ((O))
3. For each   (J ) there is no 

 such that

 and 

(a)  |= 
 |= 
(b) |
(c) (J ) \ {}  ({

|  ||

}) is a justification for  in ((O))

Intuitively, a laconic justification is a justification where all axioms only contain sub-concepts (parts) that are relevant for the entailment in question, and
moreover, these sub-concepts (parts) are as weak as possible.

5.4 Notes on Definition 2
Othe deductive closure of O. It is apparent from Definition 2(1) that
laconic justifications for an entailment in an ontology may be drawn from the
deductive closure of that ontology. Therefore, unlike regular justifications, laconic
justifications are not specific to the asserted axioms in an ontology. This ensures
that it is possible to capture the internal and external masking cases highlighted
in Section 3.

M. Horridge, B. Parsia, and U. Sattler

a structural transformation. The primary use of a structural transformation in Definition 2 is to transform a justification into an equi-satisfiable set of
axioms, (J ), where each axiom does not have any nested complex descriptions
(each axiom is flattened out) and each axiom is as small as possible. These
axioms can be thought of as a representation of all of the parts of the axioms
in J . Thus, ensuring that the axioms in (J ) are as weak as possible ensures
that all parts of axioms in a laconic justification are as weak as possible.
Applying the transformation to a justification results in two possibilities:
1. (J ) is not a justification for it is a superset of a justification for 
because J consists of axioms that contains parts or strong parts that are
not required for J |= . Hence condition 2 of Definition 2 is violated and J
is not laconic.
2. (J ) is a justification for , which implies that all sub-concepts of all axioms
(in their existing or in a weakened form) are required for J |= . Hence, if
each axiom in (J ) is as weak as possible, as dictated by condition 3 of
Definition 2, then J is laconic.

Example 1. Consider the following ontology O = {1 : A  B, 2 : B  D, 3 :
A  B  C} |= A  D. There are two justifications for O |= A  D, J1 =
{1, 2} and J2 = {2, 3}. By Definition 2, J1 is a laconic justification since
(J1) = {  X0  X1, X0  A, X1  B,  X2  X3, X2  B, X3  D}
neither of these axioms can be weakened further without lengthening them or
without resulting in J1 |= A  D. Conversely, J2 is not a laconic justification
since after performing the structural transformation to obtain (J ) a superset
of a justification for  is obtained.

Definition 3. (Precise Justification)
Let O be an ontology such that O |= . Let J be a justification for O |=  and
let J  = (J ). J  is precise with respect to J if J is a laconic justification for
O |= .
Intuitively, a precise justification is a version of a laconic justification where
the axioms contained in the precise justification are as flat, small and as weak
as possible. In essence, a precise justification is a repair friendly version of a
laconic justification. Note that a precise justification is precise with respect to a
laconic justificationa justification cannot in itself be precise.

Lemma 1. All laconic justifications can be converted to precise justifications by
means of the structural transformation, .

5.5 Repair

Although repair is not the primary subject of this paper, it should be noted
that the motivation behind Definition 3 is based on the notion that it should
be possible to generate a repair that makes semantically minimal changes to
an ontology. Because, by definition, a precise justification contains axioms that
are maximally flat, small and weak, it is only necessary to remove one of these
?

?

?
axioms in order to generate a minimal repair. A semantically minimal repair will
be generated if an axiom of the form X  A or X  A, where X is any named
introduced in the structural transformation and A is a concept name occurring
in the signature of O, is removed (hence the requirement that  produces axioms
where concept names from the signature of O only occur in the aforementioned
pattern).

In order to generate a semantically minimal repair for an entailment, laconic
justifications for the entailment should be first generated, then precise justifications for these laconic justifications should be computed. The precise justifications can then be used to guide the process of axiom selection to indicate the
parts of asserted axioms that should be removed.

6 Filtering Laconic Justifications

Since laconic justifications are defined with respect to the deductive closure of an
ontology, it is not difficult to see that there could be many laconic justifications
for an entailment. For example, given O = {C  D  D  E, A  B}, laconic
justifications for O |= C   include {C  D  D} and {C  D, C  D}.
It is noticeable that both of these justifications are somewhat structurally or
syntactically related to the asserted axioms in O. However, Definition 2, also
admits other laconic justifications such as {C  B  B} (since C  B 
B is also in the deductive closure of O). Despite the fact that this is a valid
laconic justification, it is arguable that justifications of this ilk, which could
be considered to be syntactically irrelevant or incidental, are not of general
interest to an ontology modeller who is trying to understand the reasons for an
entailment.
In order to focus on syntactically relevant laconic justifications, a filter on the
deductive closure, called O+, is introduced. O+ is essentially a representative
of the deductive closure of an ontology, which gives rise to preferred laconic
justifications.
Definition 4. (O+ completeness) Let O be an ontology, O+ a set of axioms
such that O  O+  O, and  such that O |= . O+ is complete for  and O
if for J the set of all laconic justifications for  w.r.t. O+, for any O such that
O  O+, if O |= J for all J  J, then O |= .

Completeness ensures that the laconic justifications can be used for a simple
repair: if an ontology is weakened so that it entails none of the laconic justifica-
tions, then it no longer entails .
The exact details of how to construct a suitable O+ depend somewhat on how
laconic justifications will be used. For example, an application that presents
laconic justifications to end users may well prefer justifications that maintain
conjunctions or disjunctions. For example given O = {C  D  D  E}, it
might be preferable to generate {C  DD} as opposed to {C  D, C  D}
as a laconic justification for C  . The reverse may be true if generating laconic

M. Horridge, B. Parsia, and U. Sattler

justifications to display in a repair tool, where smaller axioms might suggest a
more appropriate repair.
In what follows an O+ is specified for the description logic SHOIQ (O+SHOIQ)
so as to capture the sort of laconic (fine-grained) OWL-DL justifications in play
in the literature. Importantly, O+SHOIQ produces laconic justifications that are
syntactically relevantthere is a direct correspondence between asserted axioms
in O and axioms that appear in laconic justifications, which is essential for
usability in tools such as browsers and editors, and directly corresponds with the
strikeout feature that is available in Swoop. It should be noted that O+SHOIQ is
finite, which means that the set of precise justifications with respect to O+SHOIQ
is also finite. Even though it is possibly exponentially larger than O, it will later
be seen that it is not necessary to compute O+SHOIQ in its entirety.
  () where   O}. We define the
Definition 5. Let O+SHOIQ = {
mappings (), (C) and (C) inductively as follows, where X  {, } is used
as a meta-variable with  = ,  = , max = , max = , and n
 be the
maximum number in number restrictions in O:
 (Dj)}
 D
(C1    Cn  D1    Dm) :={C

(C  D) := (C  D)  (D  C)  {C  D}
j
(R  S) :={R  S}
(R  S) :={R  S}  {S  R}

 (Ci), D

 | 

| C
?

?

?
j
?

?

?
i
?

?

?
i

X(A) :={maxX , A} for A a concept name or {i}

(T rans(R)) :={T rans(R)}
   C
   C

X(C1    Cn) :={C
X(C1    Cn) :={C
?

?

?
n
n

| C
| C
?

?

?
i
i

 X(Ci)}
 X(Ci)}

  X(C)}
 | C
X(C) :={C
X(R.C) :={R.C
 | C
  X(C)}  {}
 | C
  X(C)}  {}
X(R.C) :={R.C
X( nR.C) :={ mR.C
 | C
( nR.C) :={ mR.C
 | C
 | C
( nR.C) :={ mR.C

X({j1 . . . jn}) := X({j1}    {jn})

}  {maxX}
  X(C), n  m  n
  (C), 0  m  n}  {}
  (C), n  m  n
}  {}

In essence O+SHOIQ generates weaker, shorter axioms from asserted axioms in O
by, for example, stepwise replacement of sub-concepts with either  or . In fact,
O+SHOIQ parallels the well know structural transformation without transforming
axioms into negation normal form or clausal form. The benefit of this being a
close syntactic correspondence of axioms in O+SHOIQ with axioms in O. From
now on the subscript SHOIQ is dropped so that O+ refers to O+SHOIQ.

7 Computing Laconic Justifications

In order to compute laconic justifications for display in editors such as Swoop and
Prot eg e-4, or for use in other tools such as automatic repair tools, it is necessary
?

?

?
to compute the preferred laconic justifications. Recall that these particular kinds
of justifications are computed with respect to a representative of the deductive
closure of an ontology, namely O+. Therefore, one of the conceptually simplest
methods of computing precise justifications for an entailment  in an ontology O
would be to first compute O+ directly from O and then compute justifications
with respect to O+. This would yield a set of justifications that is the superset
of the set of preferred laconic justifications for O |= . The actual set of laconic
justifications could then be obtained by some post processing of the justifications that were computed from O+. However, the size of O+ is exponential in
the size of axioms in O. Since for a given entailment not all axioms and their
weakenings will participate in the laconic justifications that are obtained from
O+, computing O+ for a whole ontology O could be regarded as being wasteful
both in terms of space and time.

S  ComputeOP lusJustif ications(O, )
for S  S

Algorithm. ComputeLaconicJustifications
Input: O an ontology,  and entailment such that O |= 
Output: S, a set of precise justifications for O |= 
1.
2.
3.
4.
5.

if IsLaconic(S, ) = false

S  S \ S

return S

Algorithm. ComputeOPlusJustifications
Input: O an ontology,  and entailment such that O |= 
Output: S, a set of justifications for O+ |= 
1. O  O
S  
2.
S  Justif ications(O
3.
4.
repeat
5.
6.
7.
8.
9. until S = S
10. return S

S  S
for S  S
S  Justif ications(O

O  (O \ S)  ComputeOP lus(S)

, )

, )

Algorithm. IsLaconic
Input: J, a justification,  and entailment such that J |= 
Output: true if J is laconic, otherwise false
1.
2.

S  Justif ications(ComputeOP lus((J)), )
return S = {(J )}
It is also tempting to assume that the laconic justifications can efficiently be
computed directly from regular justifications without reference to rest of the

M. Horridge, B. Parsia, and U. Sattler

ontology. While it may be sufficient to utilise this strategy when implementing a
strikeout feature similar to that found in Swoop, this approach would not capture
all laconic justifications with respect to O+. As described in Section 3 point 3,
the external masking condition means that there could be laconic justifications
that would not be found using this technique.

With these points in mind, an optimised algorithm for computing precise
justifications, ComputeLaconicJustifications, is presented below. Since the algorithm does not require a specific reasoner, or indeed a particular reasoning
procedure such as tableau, it is a Black-Box algorithm. The algorithm incrementally computes the set of all laconic justifications for a given entailment by
incrementally computing O+ from previously found justifications. This yields
a set of justifications that is a superset of the laconic justifications for the entailment in question. The algorithm then processes each justification in this set
to extract the justifications that are laconic justifications using the IsLaconic
subroutine. This subroutine essentially tests whether a justification J is laconic
by computing ComputeOP lus((J )) and then computing laconic justifications
from this set of axioms. If the justification is laconic then its singleton set will
be equal to the justifications computed from ComputeOP lus((J )).

The algorithm requires two main subroutines that are not defined below.
Justif ications, which computes the (regular) justifications for an entailment 
that holds in some set of axioms (ontology). This subroutine can be implemented
using any strategy that computes justifications in accordance with Definition 1.
Additionally, the ComputeOP lus subroutine takes a set of axioms and returns a
set of axioms that represents O+ computed from this set of axioms in accordance
with Definition 5.

7.1 Performance

In order to evaluate the practicability of computing laconic justifications, the
above algorithm and subroutines were implemented using the latest version of
the OWL API4 backed with the Pellet reasoner [15]. This API has clean and
efficient support for manipulating an ontology at the level of axioms, and has a
relatively efficient and direct wrapper for Pellet. A selection of publicly available
ontologies, shown in Table 1 were chosen for number of entailments that hold in
them and to provide a range of expressivity.5

Each ontology was classified in order to determine the unsatisfiable classes
and atomic subsumptions. These kinds of entailments were selected as input to
the compute laconic justifications algorithm because they are usually exposed by
tools such as Prot eg e-4 or Swoop and are therefore the kinds of entailments that
users typically seek justifications for. For each entailment the time to compute
all regular justifications and all laconic justifications was recorded.

4 http://owlapi.sourceforge.net
5 All of the ontologies used may be found in the TONES ontology repository at
http://owl.cs.manchester.ac.uk/repository. Entailments include atomic subsumptions and unsatisfiable classes.
?

?

?
Table 1. Ontologies used in experiment

Expressivity Axioms No. Entailments
ID Ontology
ALCOIF

1 Generations
ALCH(D)

2 Economy
ALCHOIN

3 People+Pets
?

?

?
4 MiniTambis
?

?

?
5 Nautilus
?

?

?
6 Transport
?

?

?
7 University
8 PeriodicTableComplex ALU
?

?

?
9 EarthRealm
?

?

?
10 Chemical

11 DOLCE
?

?

?
)
s
m
(
 
/
 
e
m
i

1000000

100000

Regular

Laconic

Ontology ID

Fig. 1. Times to compute justifications

Figure 1 displays the times for computing regular justifications and laconic
justifications. It is clear to see that computing laconic justifications takes longer
than computing regular justifications. This is to be expected since the computation of regular justifications is used as a first step for computing laconic
justifications. Nevertheless, the mean time for computing laconic justifications is
acceptable for the purposes of computing laconic justifications on demand in an
ontology development environment. It can be seen from Figure 1 that Ontology
10, which is the Chemical ontology, required the most time computationally
the average time was 100000 milliseconds (1 min 40 seconds) per entailment.
Indeed, for the Chemical ontology, the average time per entailment to compute
regular justifications is 20 seconds. The reason for this longer computation time,
is that on average, each entailment in the chemical ontology has 9 justifications,
with one entailment topping 26 justifications.

8 Observations on Computed Laconic Justifications

The laconic justifications that were computed in the experiment, and the relationship that these have with their corresponding regular justifications, exhibited

M. Horridge, B. Parsia, and U. Sattler

several properties that verify the motivational reasons for laconic justifications
(Section 3). Examples of masking and larger numbers of regular justifications
than laconic justifications for a given entailment were present. This section discusses these examples.

8.1 Masking

As described in Section 3 one of the main issues with regular justifications is
that for a given entailment they can mask other justifications. An example of
such masking occurs in the DOLCE ontology. The entailment quale  region
has a single justification: {quale  region atomic-part-of.region}. How-
ever, computing laconic justifications for this entailment reveals that there are
further justifications that are masked by this regular justification. There are
three laconic justifications, the first being {quale  region}, which is directly
obtained as a weaker form of the regular justification. This first laconic justification could be identified in Swoop using the strike out feature (The conjunct  atomic-part-of.region would be struck out). More interestingly, there
are two additional laconic justifications: {quale  atomicPartOf.region,
, region  part.region} and also
atomicPartOf  partOf, partOf  part

{quale

atomicPart
,
atomicPart  part, region  part.region}

atomicPartOf.region, atomicPartOf

Masking is surprising in general, and the above example is a nice illustration
of how this information would not be revealed with regular justifications. In such
cases the user or developer of an ontology would be completely unaware of these
further justifications when attempting to formulate a repair strategy or when
simply trying to gain a deeper understanding of the ontology.
?

?

?
8.2 Number of Justifications Versus Number of Laconic

Justifications

Figure 2 displays the mean number of justifications per entailment. For ontologies
1, 2, 5, 6 and 9 (five out of eleven ontologies) the number of laconic justifications
coincides with the number of regular justifications. However, for ontologies 3, 4,
7, 8 and 11, the mean number of laconic justifications per entailment is greater
than that of regular justifications. This is an indication that internal or external
masking is occurring for a significant number of ontologies, corresponding to the
second and third motivations in Section 3. Again, these extra justifications would
not be salient to a user who only works with regular justifications, and would
mean that it might be impossible to gain a full understanding of an ontology
when devising a repair plan.

In ontology 10, the Chemical ontology, it is evident that the mean number of
laconic justifications per entailment is less than the number of regular justifica-
tions. In fact, in this particular ontology, there is an entailment with six regular
justifications and only two laconic justifications. This situation also occurs in
places in the PeriodicTableComplex ontology, where there are a large number of
entailments that have two regular justifications and one laconic justification. In
?

?

?
Regular

Laconic

s
n
o
i
t
a
c
i
f
i
t
s
u

f
o
 
r
e
b
m
u
n
n
a
e

Ontology ID

Fig. 2. Number of regular justifications versus the number of laconic justifications

the case where there are fewer laconic justifications than regular justifications,
the laconic justifications highlight a common core amongst the regular justifications that is responsible for the entailment. Working with this information
when repairing an ontology potentially minimises the possibility of applying an
over-repair that could occur by quasi-independently examining each regular
justification.

9 Exploiting Laconic and Precise Justifications

It should be noted that the work presented in this paper has not covered how
laconic, or in particular how precise justifications, should be presented to users,
incorporated into workflows or how they might be exploited in various reasoning services. While it is easy to imagine how they can be used to provide an
enhanced and complete service for striking out irrelevant parts of axioms, they
could also be used as a basis for measuring incoherence, measuring complexity
of understanding, as metrics for repair services, and in ontology refactoring and
simplification services. The issue of presenting laconic and precise justifications
and incorporating them into various services is the topic of future work.

10 Conclusions and Future Work

This paper has presented a formal definition of fine-grained justifications in the
form of laconic justifications and precise justifications. The definition of laconic
justifications captures the intuitive notion of fine-grained justifications from previous related work, while the definition of precise justifications captures the
notion of being able to generate a semantically minimal repair. An optimised algorithm to computed laconic justifications in accordance with this definition has
been given and it has been shown that it is feasible to compute laconic justifications (and hence precise justifications) in practice. The definition and evaluation
has provided a deeper insight into the properties of laconic justifications and

M. Horridge, B. Parsia, and U. Sattler

how laconic justifications and their precise counterparts might eventually be ex-
ploited. Finally, it should be noted that the definition that has been presented
in this paper assumes a consistent ontology. Dealing with inconsistent ontologies
is the subject of future work.
