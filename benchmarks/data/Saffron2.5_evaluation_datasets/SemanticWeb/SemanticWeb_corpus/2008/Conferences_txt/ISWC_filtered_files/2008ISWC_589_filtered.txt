Formal Model for Semantic-Driven Service

Execution

Tomas Vitvar1, Adrian Mocan1, and Maciej Zaremba2

1 Semantic Technology Institute (STI2)

University of Innsbruck, Austria
firstname.lastname@sti2.at

2 Digital Enterprise Research Institute (DERI)
National University of Ireland in Galway, Ireland

maciej.zaremba@deri.org

Abstract. Integration of heterogeneous services is often hard-wired in
service or workflow implementations. In this paper we define an execution model operating on semantic descriptions of services allowing flexible integration of services with solving data and process conflicts where
necessary. We implement the model using our WSMO technology and a
case scenario from the B2B domain of the SWS Challenge.

1 Introduction

Existing technologies for service invocation and interoperation usually depend
on ad-hoc or hard-wired solutions for interoperability. In particular, message
level interoperability is often maintained in business processes using XSLT, and
process level interoperability is often achieved through manual configuration of
workflows. Such rigid solutions are a drawback to services flexibility and adapt-
ability: changes in service descriptions require changes in service implementation
or workflows. One possible approach to improve the interoperability is to use semantics in service descriptions. With help of semantics and a logical reasoning,
it is possible to automate the integration process and achieve an integration that
is more adaptive to changes in business requirements.

In Semantic Web Services (SWS), there are two phases in the service integration process, namely late-binding phase and execution phase [15]. Late-binding
phase allows binding a user request and a set of services on-the-fly through
semi-automation of the service lifecycle by applying tasks for service discovery,
composition, selection, mediation, etc. Execution phase allows for the invocation and conversation of bound services. While services may have heterogeneous
descriptions in terms of data and protocols, it is important to achieve their
interoperability within the both phases. In this paper we elaborate on the execution phase and show how semantic services can be decoupled in the integration
process and how their interoperability can be achieved through combined data
and process mediation. Particular contributions of our paper are as follows:

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 567582, 2008.
c Springer-Verlag Berlin Heidelberg 2008

T. Vitvar, A. Mocan, and M. Zaremba

 We define a sound conceptual model for data and process mediation for SWS
exectuion extending our previous, more technical and implementation-driven
work in [7].

 We built on top of existing results from the area of ontology-based data
mediation [11] by providing a formal algorithm that shows how a run-time
mediation can be interlaced with other type of mediation, that is, process
mediation.

 We show how the formal model for service exectution can provide a solution for a real-world case scenario. For this purpose we describe the implementation using the WSMO[13], WSML[13], WSMX1 including a solution
architecture for a case scenario from the SWS Challenge2.

Blue Company

WSMO Goal

description

implementation

Moon Company

WSMX Middleware

Publish

descriptions

WSMO Service

implementation

description

Ontology

Choreography

Interface

Publish

mappings

PO request

Data 

Mediation

Publish

mappings

openOrder

Orchestration

searchCustomer

Ontology

Choreography

Interface

Customer 
Relationship 
Management

Web Service

RosettaNet
Gateway

PO Confirmation

Web Services

addItems

closeOrder

orderConfirmation

Fig. 1. Case Scenario and Solution Architecture

Order

Management 

System

In order to demonstrate a problem we target in our work, Figure 1 depicts a
case scenario of the SWS Challenge mediation problem. In the scenario, a trading company, called Moon, uses a Customer Relationship Management system
(CRM) and an Order Management System (OMS) to manage its order process-
ing. Moon has signed agreements to exchange Purchase Order (PO) messages
with a company called Blue using the RosettaNet standard PIP3A4. There are
two interoperability problems in the scenario: At the data level, the Blue uses
PIP3A4 to define the PO request and confirmation messages while Moon uses a
proprietary XML Schema for its OMS and CRM systems. At the process level,
the Blue follows PIP3A4 Partner Interface Protocol (PIP), i.e. it sends out a
PIP3A4 PO message, including all items to be ordered, and expects to receive a

1 http://www.wsmx.org
2 SWS Challenge, http://www.sws-challenge.org, defines a testbed together with a
set of increasingly difficult problems on which various SWS solutions can be objectively evaluated.
?

?

?
PIP3A4 PO confirmation message. On the other hand, various interactions with
the CRM and OMS systems must be performed in Moon in order to process the
order, i.e. get the internal ID for the customer from the CRM system, create
the order in the OMS system, add line items into the order, close the order, and
send back the PO confirmation.

In section 4 we further describe a solutuion for the scenario building on our
SWS technology implementing the service execution model. In Section 2 we
provide some background definitions for this model and in Section 3 we formaly
define this model.

2 Definitions

A service engineer or a client (depending on the level of automation) must decide
whether to bind with services according to the descriptions of service contracts. In
SWS, we represent service contracts at the semantic level and non-semantic level.
For the non-semantic level we use Web Service Description Language (WSDL) and
for the semantic level we use four types of descriptions: information, functional,
non-functional and behavioral. In addition, grounding defines a link between semantic and non-semantic descriptions of services.

For purposes of the execution phase, we provide the background definitions
for information and behavioral semantic descriptions of services together with
grounding to WSDL. In this paper we do not use the other types of semantic
descriptions, please refer to e.g. [14] for more information about these descrip-
tions. In addition, we provide definitions for the two major stages of the execution
phase, that is, data mediation and process mediation.

2.1 Information Semantics

Information semantics is the formal definition of some domain knowledge used by
the service in its input and output messages. We define the information semantics
as an ontology

O = (C, R, E, I)

(1)

with a set of classes (unary predicates) C, a set of relations (binary and higherarity predicates) R, a set of explicit instances of C and R called E (extensional
definition), and a set of axioms called I (intensional definition) that describe
how new instances are inferred.

2.2 Behavioral Semantics

Behavioral semantics is a description of the public and the private service be-
haviors. For our work we only use the public behavior, called choreography,
describing a protocol, that is, all messages sent to the service from the network

T. Vitvar, A. Mocan, and M. Zaremba

and all messages sent from the service back to the network3. We do not use
the private behavior of the service, i.e. the internal workflow, in our model. We
define the choreography X using the Abstract State Machine (ASM) as

X = (, L),

(2)
where   ({x}  C  R  E) is the signature of symbols, i.e., variable names
{x} or identifiers of elements from C, R, E of some ontology O; and L is a set
of rules. Further, we denote by I and O the input and output symbols of the
choreography (subsets of C  R E), corresponding to the input data sent to the
service and the returned output data. Each rule r  L is defined as rcond  reff
where rcond is an expression in logic L() which must hold in a state before
the rule is executed; reff is an expression in logic L() describing how the state
changes when the rule is executed.

2.3 Grounding

Grounding defines a link between semantic descriptions of services and various
components of WSDL. We denote the WSDL schema as S and the WSDL interface as N. Further, we denote {x}S as a set of all element declarations and
type definitions of S, and {o}N as a set of all operations of N. Each operation o  {o}N may have one input message element m  {x}S and one output
message element n  {x}S.

There are two types of grounding used for information and behavioral se-
mantics. The first type of grounding specifies references between input/output
symbols of a choreography X = (, L) and input/output messages of respective
WSDL operations {o}N with schema S. We define this grounding as

(3)
where m  {x}S, c   and ref is a binary relation between m and c. Further, m
is the input message of operations in {o}N if c  I or m is the output message
of operations in {o}N if c  O.

ref (c, m)

The second type of grounding specifies transformations of data from schema
S to ontology O = (C, R, E, I) called lifting and vice-versa called lowering. We
define this grounding as

and

lower(c1) = m

(4)
where m, n  {x}S, c1, c2  (C  R), lower is a lowering transformation function transforming the semantic description c1 to the message m, and lift is a
lifting transformation function transforming the message n to the semantic description c2.

lift(n) = c2,

3 Please note, that our notion of the choreography is different from the one
used by the Web Service Choreography Description Language (WS-CDL) defining the choreoraphy as a common behavior of collaborating parties (http://
www.w3.org/TR/ws-cdl-10/)
?

?

?
Table 1. MEPs, Rules and WSDL operations

MEP and Rule
in-out:
if c1 then add (c2)
c1  I , ref (c1, msg1)
c2  O, ref (c2, msg2)
in-only:
if c3 then no action
c3  I , ref (c3, msg3)
out-only:
if true then add (c4)
c4  O, ref (c4, msg4)
out-in:
if true then add (c5)
if c5  c6 then no action
c5  O, ref (c5, msg5)
c6  I , ref (c6, msg6)

WSDL Operation
<operation name="oper1" pattern="w:in-out">
<input messageLabel="In" element="msg1"/>
<output messageLabel="Out" element="msg2"/>

</operation>
<operation name="oper2" pattern="w:in-only">
<input messageLabel="In" element="msg3"/>

</operation>
<operation name="oper3" pattern="w:out-only">
<output messageLabel="Out" element="msg4"/>

</operation>
<operation name="oper4" pattern="w:out-in">

<output messageLabel="Out" element="msg5"/>
<inpput messageLabel="In" element="msg6"/>

</operation>

A client uses both types of grounding definitions when processing the choreography rules and performing the communication with the service while following
the underlying definition of WSDL operations and their Message Exchange Patterns (MEPs). Table 1 shows basic choreography rules for four basic WSDL 2.0
MEPs4, i.e. in-out, in-only, out-only, out-in (please note that we currently do
not handle fault messages), and corresponding WSDL operations. Here, a rule
rcond  reff is represented as if rcond then reff ; the symbols msg1. . . msg6
refer to schema elements used for input/output messages of operations; the
symbols c1 . . . c6 refer to identifiers of semantic descriptions of these messages;
ref (m, c) denotes a reference grounding, and w: is a shortening for the URI
http://www.w3.org/ns/wsdl/.

2.4 Data Mediation

Data mediation resolves interoperability conflicts between two services that use
two different ontologies. In general, the data mediation has two stages: 1) creation of alignments between source and target ontologies during design-time and
2) applying the alignments to resolve interoperability conflicts during run-time.
Since the interoperability problems can greatly vary in their nature and sever-
ity, fully automatic solution for the creation of alignments are not feasible in
real-world case scenarios due to the lower than 100% precision and recall of existing methods5. From this reason, the design-time data mediation stage is still
dependent on manual support of a service engineer.

4 http://www.w3.org/TR/wsdl20-adjuncts/#meps
5 The Ontology Alignment Evaluation Initiative 2006  [5] shows that the best five
systems scores vary between 61% and 81% for precision and between 65% and 71%
for recall.

T. Vitvar, A. Mocan, and M. Zaremba

An alignment consists of a set of mappings (rules) expressing the semantic
relationships that exist between the two ontologies. In particular, a mapping can
specify that classes from two ontologies are equivalent while corresponding rules
use logical expressions to unambiguously define how the data encapsulated in
an instance of one class can be encapsulated in instances of the second class.
Formally, we define an alignment A between source and target ontologies Os =
(Cs, Rs, Es, Is) and Ot = (Ct, Rt, Et, It) as

As,t = (Os, Ot, s,t)

where s,t is the set of mappings m in the form

m =< s, t, s , t >

(5)

(6)

where s, t represent the mapped entities from the two ontologies while s,
t represent restrictions (i.e. conditions) on these entities such as s  Cs  Rs,
t  Ct  Rt while s and t are expressions in logic L(Cs  Rs  Es) and
L(Ct  Rt  Et), respectively.

In order to execute the mappings during the execution phase, these mappings
must be grounded6 to rules expressed in some logical language for which a reasoning support is available (in Section 4 we use the WSML language for this
grounding). We obtain the set of rules s,t = G
s,t by applying the grounding G
to the set of mappings . In the following definitions, {x} stands for the set of
 and x
 are two particular variables.
variables used by the mapping rule and x
{x}

Every mapping rule mr  s,t has the following form:

{x}

mr :



mrhead

i

mrbody

i

(7)

where

i=1..n

i=1..n

mrhead  {x
instanceOf  |   Ct  x

{(x
?

?

?
, x

) |   Rt  (x
?

?

?
, x

  {x}} 
)  Et  x

, x

  {x}}

mrbody  {x
instanceOf  |   Cs  x

{(x
?

?

?
, x
{s | s  L(Cs  Rs  Es  {x})} 
{t | t  L(Ct  Rt  Et  {x})}

) |   Rs  (x
?

?

?
  {x}} 
)  Es  x

, x
?

?

?
, x

  {x}} 

(8)

(9)

A mapping rule is formed of a head and a body. The head is a conjunction
of logical expressions over the target elements and describes the result of the
mediation in terms of instances of the target ontology. The body is formed of a
set of logical expressions over the source entities which represent the data to be
mediated, plus a set of logical expressions representing conditions over both the
source and the target data.

6 Please note, that this grounding is different to the grounding defined in Section 2.3.
?

?

?
There are situations when there is no corresponding data in the source ontology as required by the target ontology such as when mapping prices with
different currency units. These issues are, however, dependant on implementation of the data mediation and the reasoning engine. In our implementation, it
is possible to specify an URI for a transformation function and its parameters as
placeholders for the missing target values. It is the role of the reasoning engine
to fill the parameters placeholders with data from the source ontology. The data
mediation engine then executes the function and gets the data for the target
ontology.

2.5 Process Mediation

Process Mediation handles interoperability issues which occur in descriptions of
choreographies of the two services. In [3] Cimpian defines five process mediation
patterns:

a. Stopping an unexpected message when one service sends a message

which is not expected by the other service.

b. Inverting the order of messages when one service sends messages in a

different order than the other service expects them to receive.

c. Splitting a message when a service sends a message which the other service

expects to receive in multiple different messages.

d. Combining messages when a service expects to receive a message which

is sent by the other service in multiple different messages.

e. Generating a message when one service expects to receive a message

which is not supplied by the other service.

3 Execution Phase

Figure 2 depicts the main states of the execution phase In Section 3.1 we define
the algorithm for the execution phase and in Section 3.2 we discuss some relevant
aspects for the data and process mediation applied within the algorithm.

3.1 Algorithm

Input:

 Service W1 and service W2. Each such a service W contains the ontology
(information semantics) W.O (Eq. 1), the choreography W.X (Eq. 2) with
set of rules W.X.L, WSDL description and grounding (Eq. 3, 4). In addition,
for a rule r  W.X.L, the condition rcond is a logical expression with set of
semantic descriptions {c}, and the effect reff is a logical expression with set
of actions {a}. For each element a we denote its action name as a.action
with values delete or add and a semantic description as a.c.

 Mappings 12 of W1.O to W2.O and mappings 21 of W2.O to W1.O.

T. Vitvar, A. Mocan, and M. Zaremba

5: receive

end

7: End

new data

receive

3: process 
Choreography

control

process

choreography

2: Control

control

1: Initialize

send

sent

4: send

data mediated

6: mediateData

mediate data

Fig. 2. Control State Diagram for the Execution Phase

Uses:
 Symbols M1 and M2 corresponding to the processing memory of the choreography W1.X and W2.X respectively (a memory M is a populated ontology
W.O with instance data). The content of each memory M determines at
some point in time a state in which a choreography W.X is. In addition,
each memory has methods M.add and M.remove allowing to add or remove
data to/from M and a flag M.modified indicating whether the memory was
modified. The flag M.modified is set to true whenever the method M.add or
M.remove is used.

 Symbols D1 and D2 corresponding to the set of data to be added to the
memory M1 and M2 after one or more rules of a choreography are processed.
Each D has a method D.add for adding new data to the set.

 A symbol A corresponding to all actions to be executed while processing
the choreography. Each element of A has the same definition as the element
of the rule effect reff . A has methods A.add and A.remove for adding and
removing actions to/from the set.

 A symbol o corresponding to a WSDL operation of a service and symbols
m, n corresponding to some XML data of the message (input or output) of
the operation o.

States 1, 2, 7: Initialize, Control, End
1: M1  ; M2  
2: repeat
3: M1.modified  false; M2.modified  false
4: D1  processChoreography (W1, M1)
5: D2  processChoreography (W2, M2)

if D1 =  then

6:
?

?

?
Dm  mediateData(D1, W1.O, W2.O, 12)
M1.add(D1); M2.add(Dm)
end if
if D2 =  then
Dm  mediateData(D2, W2.O, W1.O, 21)
M1.add(Dm); M2.add(D2)

7:
8:
9:
10:
11:
12:
13:
14: until not M1.modified and not M2.modified

end if

After the initialization of the processing memory M1 and M2 (line 1), the execution gets to the control state when the algorithm can process choreographies
(state 3), mediate the data (state 6) or end the execution (state 7). The execution ends when no modifications of the processing memories M1 or M2 has
occurred.

end for

A.add(reff )
for all c in rcond : c  W.X.I do
send(c, W )

State 3: D = processChoreography(W , M )
1: A  ; D  
2: {Performing rules conditions and sending data}
3: for all r in W.X.L : holds(rcond , M) do
4:
5:
6:
7:
8: end for
9: {Performing delete actions}
10: for all a in A : a.action = delete do
11: M.remove(a.c)
12:
13: end for
14: {Receiving data and performing add actions}
15: while A =  do
c  receive(W )
if c = null then

A.remove(a)

for all a in A: (a.action = add and a.c = c) do

D.add(c)
A.remove(a)

16:
17:
18:
19:
20:
21:
22:
23: end while
24: return D

end if

end for

The algorithm executes each rule of the choreography which condition holds in
the memory by processing its condition and effect, i.e. the algorithm collects all
data to be added to the memory or removes existing data from the memory in
three major steps as follows.

T. Vitvar, A. Mocan, and M. Zaremba

 Performing rules conditions and sending data (lines 2-8): the algorithm adds the effect of the rule which condition holds in the memory (line
3) to the set of effects A (line 4). Then, for each input symbol of the rules
condition (line 5), the algorithm sends the data to the service (line 6, see
State 4).

 Performing delete actions (lines 9-13): the algorithm processes all effects with delete action, removes the data of the effect from the memory (line
11) as well as from A (line 12).

 Receiving data and performing add actions (lines 14-24): when there
are effects to be processed in A and the new data is received from the service
(line 16), the algorithm checks if the new data corresponds to some of the
add effect from A. In this case, it adds the data to the set D (line 19) and
removes the effect from A (line 20).

The result of the algorithm is the set D which contains all new data to be added
to the memory M. The actual modification of the memory M with the new data
is done in State 2. During the choreography processing, the algorithm relies on
a consistent definition of the reference grounding (see Eq. 3), i.e. choreography
rules are consistent with WSDL operations and their MEPs, as well as assumes
no failures occur in services. In lines 14-23 the algorithm waits for every message
from the service for every add action of the rules effect. If the definition of the
rules was not consistent with WSDL description, the algorithm would either
ignore the received message which could in turn affect the correct processing of
the choreography (in case of missing add action) or wait infinitely (in case of
extra add action or a failure in a service). For the latter, the simplest solution
would be to introduce a timeout in the loop (lines 14-23), however, we do not
currently handle this situation.

State 4: send(c, W )
1: m  lower(c)
2: for all o of which m is the input message do
3:
4: end for

send m to W

In order to send the data c the algorithm first retrieves a corresponding message
definition according to the grounding and transforms c to the message m using
the lowering transformation function (line 1). Then, through each operation of
which the message m is the input message, the algorithm sends the m to the
service W .

c  lift(m)
return c

State 5: c = receive(W )
1: if receive m from W then
2:
3:
4: else
5:
6: end if

return null
?

?

?
When there is new data from the service W , the algorithm lifts the data (message
m in XML) to the semantic representation using lifting transformation function
associated with the message (line 2).

State 6: Dm = mediateData(D, Os, Ot, )
1:   ; m  
2: for all c  D do

  getTypeOf (c);
m  null
for all m =< s, t, s , t >  do
if  = s then
if isBetterFit(t, m) then
m  t
end if
mG  ground(m);     {mG}
end if
end for
m  m  m

3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14: end for
15: if m = null then
16:
17: end if
18: Dm  getDataForType(m, )
19: return Dm

return null

The algorithm performs two steps during data mediation. Firstly, the algorithm
processes mappings in order to determine the most suitable target concepts to
mediate the source data to, and secondly, the algorithm transforms the mappings
into an executable form and executes the mappings. Since current reasoning
engines does not scale well in terms of processing time, keeping these steps
separate enable high-performance in processing of alignments independent on
the logical language and reasoning engine used. In other words, this approach
minimizes the use of the reasoning during the data mediation.

 Step 1. The algorithm first determines a concept for an instance data to
be mediated (line 3). After that, the algorithm traverses through a set of
mappings in order to determine the type of the target data (mediated data)
(lines 5-12). Since there could be more mappings from a given source entity to
the several other target entities, the algorithm determines the most suitable
concept (lines 7-9). In particular, if a concept s is mapped to two target
concepts 1
t (the
most specific) or if 2
t can be reached via binary relationships (i.e. attributes)
starting from 1

t is a sub-concept of 2

t is more suitable if 1

t (maximal coverage).

t and 2

t , then 1

 Step 2: While traversing the set of mappings, the algorithm grounds each
mapping to a logical language by transforming them to a set of logical mapping rules (line 10). Finally, by using a reasoner engine, the algorithm queries

T. Vitvar, A. Mocan, and M. Zaremba

and retrieves all the data of the selected target type according to the source
data and the set of mapping rules (line 18).

3.2 Discussion

Data mediation ensures that all new data coming from one service is translated
to the others service ontology. Thus, no matter from where the data originates
the data is always ready to use for the both services. From the process mediation
point view, the data mediation also handles the splitting of messages (pattern c)
and combining messages (pattern d). Since the mediated data is always added to
the both memories (see State 2, lines 8, 12 and the next paragraph for additional
discussion) the patterns (a) and (b) are handled automatically through processing
of the choreography rules. In particular, the fact that a message will be stopped
(pattern a) means that the message will never be used by the choreography because no rule will use it. In addition, the order of messages will be inverted (pat-
tern b) as defined by the choreography rules and the order of ASM states in which
conditions of rules hold. This means that the algorithm automatically handles the
process mediation with help of data mediation through rich description of choreographies when no central workflow is necessary for that purpose. In order to fulfill
the pattern (e), the algorithm might need a third-party data for which an integration workflow might be neccessary. Although some of the third-party data can be
gathered through transformation functions of the data mediation which can in
turn facilitate some cases of pattern (e), we do not provide a general solution for
this pattern. A special case of pattern (e) could be generating an acknowledgement message for which the algorithm should distinguish types of interactions.
For example, if the algorithm is able to understand control interactions (such as
acknowledgements) among all the interactions between services, it could generate
an acknowledgment message (evaluation of successfull reception of the message
by the other service is, however, another issue).

4 Implementation

In this section we describe the implementation of the execution model using the
WSMO, WSML and WSMX technology on the use case from the SWS Challenge
as Figure 1 depicts. We use WSMO to model ontologies, services, mediators
and goals according to the scenario. WSMO uses WSML family of ontology
languages to define concrete semantics of these elements. In addition, WSMX is
the execution environment for WSMO allowing to run the execution of WSMO
services. In the core of the solution, the WSMX middleware is located between
Blue and Moon systems. WSMX functionality can be customized to conform
to particular integration needs through choosing appropriate components and
their configuration. For our solution, we use the orchestration which executes
the conversation and the data mediation which resolves the heterogeneity issues,
both operating according to the execution model. In addition, WSMX contains
the base components such as reasoning which performs logical reasoning over
?

?

?
semantic descriptions and communication or persistence. For brevity, we do not
show them in the figure.

We use WSMO ontology to model the information semantics of services, and
the choreography interface definition of WSMO Service/Goal to model the behavioral semantics of services. In addition, we need to create grounding to underlying WSDL and XML Schema (The SWS Challenge provides all services
in WSDL together with endpoints accessible via SOAP over HTTP) and mapping rules between ontologies. Firstly, we create ontologies in WSML language
as semantic representations of the PIP3A4, CMR and OMS XML schemata.
Secondly, we create lifting and lowering transformations in XSLT between underlying XML and the ontologies. Finaly, we define mappings between the both
ontologies. Although we could define one overarching ontology for the both XML
schema together with lifting/lowering transformations to this ontology, we want
to demonstrate the use of mappings and data mediation. Hence we define two
heterogeneous ontologies for the two heterogeneous XML schema.

axiom aaMappingRule23

definedBy

mediated(?X21, SearchCustomerReq)[searchString hasValue ?Y22] memberOf o1#

: ?X21[businessName hasValue ?Y22] memberOf o2#BusinessDescription.

SearchCustomerReq

Listing 1.1. Mapping Rules in WSML

Listing 1.1 shows a sample mapping rule between the SearchCustomerReq concept of the CMR ontology (denoted using o1 prefix) and BusinessDescription concept of the PIP3A4 ontology (denoted using o2 prefix). The construct mediated
(X, C) represents the identifier of the newly created target instance, where X is
the source instance that is transformed, and C is the target concept we map to.
In line with Eq. 2, the WSMO service choreography contains the definition
of the input, output and shared symbols (called state signature or vocabulary)
and a set of rules. Using these rules we model the choreography of the both
PIP3A4 and CRM/OMS services separately and for each define the order in
which the operations should be correctly invoked. Listing 1.2 shows a fragment
of the choreography for the CRM/OMS service. There are two rules defined.
The first rule (lines 17-22) defines that the SearchCustomerReq will be sent to
the service and on result the SearchCustomerResp will be expected as the output message. The SearchCustomerReq message must be available in the memory
(in our case the data for the message is provided by the Blue after the data
mediation). The second rule (lines 24-30) defines that the SearchCustomerResp
must be available in the memory while its customerId will be used for the customerId of the CreateNewOrderReq which will be sent to the service. On result,
the CreateNewOrderResp will be expected to be received back. The data for the
CreateNewOrderReq will be again supplied by the Blue after the data mediation.
All the messages used in the choreography as the input or output symbols refer

T. Vitvar, A. Mocan, and M. Zaremba

to the definition of concepts in the ontology imported in line 3 while at the
same time the grounding of these concepts to the underlying WSDL messages is
defined in lines 5-14.
?

?

?
choreography MoonWSChoreography
stateSignature http://example.com/ontologies/MoonWS#statesignature
importsOntology { http://example.com/wsml/Moon }
// input symbols
in moon#SearchCustomerReq

withGrounding { http://example.com/MoonCRM#wsdl.interfaceMessageReference(search/in0)

moon#CreateNewOrderReq
withGrounding { http://example.com/MoonOMS#wsdl.interfaceMessageReference(openorder/

}

in0)}

// output symbols
out moon#SearchCustomerResp

withGrounding { http://example.com/MoonCRM#wsdl.interfaceMessageReference(search/

moon#CreateNewOrderResp
withGrounding { http://example.com/MoonOMS#wsdl.interfaceMessageReference(openorder

out0)}

/out0)}

...

transitionRules http://example.com/ontologies/MoonWS#transitionRules
// rule 1: search the customer in CRM
forall {?customerReq} with (
?customerReq memberOf moon#SearchCustomerReq
) do
add( # memberOf moon#SearchCustomerResp)
endForall

// rule 2: open the order in OMS
forall {?orderReq, ?customerResp} with (
?customerResp[customerId hasValue ?id] memberOf moon#SearchCustomerResp and
?orderReq[customerId hasValue ?id] memberOf moon#CreateNewOrderReq
) do
add( # memberOf moon#CreateNewOrderResp)
endForall

Listing 1.2. Moon CRM/OMS Choreography

5 Related Work

The most relevant related work is among other submissions addressing the SWSChallenge mediation scenario, namely WebML [10] and dynamic process binding
for BPEL[8]. They are based on software engineering methods focusing on modelling of integration process as a central point of integration. They do not use
logical languages in their data model. In addition, Preist et al [12] presented a
solution covering all phases of a B2B integration life-cycle, starting from discovering potential partners to performing integrations including mediations. Their
solutions is rather conceptual with missing details about the actual components
and algorithms used. More general SWS related work include IRS-III[4] which
is an execution environment also based on WSMO. In addition, there are related works that apply ASM for various stages of service integration process.
Altenhofen et al [1] also address Process Mediation of services modelled using
?

?

?
ASM, however they focus only on Process Mediation aspect while we provide
a complete conceptual model and implementation addressing both Data and
Process Mediation. In [6] a composition algorithm based on Web service process
ASMs is described where formal, mathematical model of Web services and orchestrations is provided. Their model of ASMs varies from our ontologized ASMs
model for example with respect to modelling incoming and outgoing messages. In
our model it is implicitly inferred from concept grounding in choreography in/out
states whether ASM Knowledge Base modifications entail communication with
the service as opposed to ASM used in [6] explicitly models communication con-
structs. The purpose of describing Web service public processes in [6] is different
 it is primarily focused on composition of ASM services, while we utilize ASMs
for achieving Process Mediation between communicating Web services. Lerner
[9] focuses on analysis and verification of parameterized State Machines applied
to reusable processes specified in Little-JIL language. Provided algorithm is able
to detect deadlock and other anomalies of analyzed processes. Underlying language is based on State Machines similarly like in our case. We might consider
in the future to focus more on the ASM process analysis and verification using
similar methods as proposed by Lerner. Benatallah et al [2] present a conceptual
model for Web service protocol specifications. They provide framework supporting analysis of commonalities and differences between protocols supported by
different Web services. Similarly, like in case of Lemcke [6] most of the focus
was given to public process analysis (called Web service protocol by Benatal-
lah) while in our work we presented models, mediation algorithms and working
implementation addressing both data and public process heterogeneity issues.

6 Conclusion and Future Work

One of the main advantages of our approach is the strong partner de-coupling.
This means that when changes occur in back-end systems of one partner, consequent changes in service descriptions does not affect changes in the integration.
The integration automatically adapts to the changes in service descriptions as
there is no central integration workflow. On the other hand, changes in back-end
system still require manual effort in making changes in semantic descriptions
such as ontologies and mapping rules. Although our SWS technology allows for
semi-automated approaches in modelling and mapping definitions, it is still a
human user who must adjust and approve the results. It is important to note,
however, that this type of integration where no central workflow is necessary is
only usable in situations when two public processes (ASM choreographies) are
compatible, that is, they may have different order/structure of messages but
by adjusting the order/structure the integration is possible. In general, there
could be cases where third-party data need to be obtained (e.g. from external
databases) for some interactions. Although some of the third-party data can be
gathered through the transformation functions of the mapping rules, in some
cases, an external workflow could be required to accommodate the integration
process. It is our open research work to further investigate such cases in detail.

T. Vitvar, A. Mocan, and M. Zaremba

Acknowledgments

This work is supported by the Science Foundation Ireland Grant No. SFI/02/
CE1/I131, and the EU projects SUPER (FP6-026850), and SemanticGov (FP-
027517).
