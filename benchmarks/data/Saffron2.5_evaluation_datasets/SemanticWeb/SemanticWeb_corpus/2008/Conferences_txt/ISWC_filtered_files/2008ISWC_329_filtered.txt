OWL Datatypes: Design and Implementation

Boris Motik and Ian Horrocks

University of Oxford, UK

Abstract. We analyze the datatype system of OWL and OWL 2, and
discuss certain nontrivial consequences of its definition, such as the extensibility of the set of supported datatypes and complexity of reasoning.
We also argue that certain datatypes from the list of normative datatypes
in the current OWL 2 Working Draft are inappropriate and should be replaced with different ones. Finally, we present an algorithm for datatype
reasoning. Our algorithm is modular in the sense that it can handle any
datatype that supports certain basic operations. We show how to implement these operations for number and string datatypes.

1 Introduction

The Web Ontology Language (OWL) has been phenomenally successful, and
the OWL DL version of OWL is nowadays routinely used for conceptual modeling in fields as diverse as biomedicine, clinical sciences, astronomy, geography,
aerospace and defence. OWL DL is grounded in description logics (DLs) [1]
a family of theoretically well-understood knowledge representation formalisms.
The popularity of OWL DL is largely due to the availability of practically effective reasoners1 that can be used in applications.

Applications of OWL often use properties with values such as strings and
integers. OWL therefore supports datatypes, a simplified version of the concrete
domain approach [2] that can be combined with most DLs in a decidable way
[5,7]. A datatype can be seen as a unary predicate with a built-in interpreta-
tion; for example, the xsd:integer datatype is interpreted as the set of all integer
values. Particular data values can be denoted at the syntax level using con-
stants. Properties in OWL DL are separated into object properties, interpreted
as relations between pairs of individuals, and data properties, interpreted as relations between individuals and data values. Data properties can be used in
axioms such as the range of the a:name property is xsd:string, or each instance of the a:Person class must have an xsd:integer data value for the a:age
property.

Practical experience with OWL DL has revealed several shortcomings of its
datatype system. The datatypes in OWL DL are modeled after XML Schema [3],
which provides a rich set of datatypes; however, only xsd:string and xsd:integer
are normative in OWL DL, which is often not sufficient for applications. Fur-
thermore, OWL DL provides no portable means for restricting datatypes, as
1 http://www.cs.man.ac.uk/sattler/reasoners.html

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 307322, 2008.
c Springer-Verlag Berlin Heidelberg 2008

B. Motik and I. Horrocks

in a person who is 70 or older or the values of the a:name property should
be a string not containing a whitespace. Various OWL DL tools, such as the
RACER reasoner [4], have provided proprietary solutions to these problems;
however, there is currently little or no compatibility between extensions provided by different tools.

In order to address these shortcomings, as well as some shortcomings unrelated
to datatypes, a W3C Working Group2 has recently been established with the
goal of developing a major revision of the language called OWL 2. The current
OWL 2 Working Draft3 lists most XML Schema datatypes as normative, and it
supports XML Schema facets for restricting the range of built-in datatypes. For
example, the minExclusive facet can be applied to xsd:integer to obtain a subset
of integers larger than a particular value.

Extensions of DLs with concrete domains and datatypes have received indepth theoretical treatment [2,9,10,5,7]. Furthermore, datatype groups [11] provide an architecture for integrating different datatypes, and the OWL-Eu approach [12] provides a way to restrict datatypes using expressions. These works
assume that datatype reasoning can be performed using an external datatype
checking procedure. Standard DL tableau calculi can then be extended to handle datatypes by invoking the datatype checker as an oracle.

Less attention has so far been paid to actual datatype checking algorithms.
Datatype checking is a constraint satisfaction problem; however, general CSP
algorithms [14] are typically too general and complex than what is necessary
for datatype reasoning. Furthermore, the list of normative datatypes in the current OWL 2 Working Draft has been selected without paying attention to their
suitability and implementability in a datatype checker.

In this paper we therefore formally define the OWL 2 datatype system, review its design, and investigate the problem of implementing a suitable datatype
checker. Our analysis reveals several nonobvious consequences of the current de-
sign. In particular, we show that datatype checking in OWL 2 is NP-hard in
the general case, but may become trivial in many (hopefully typical) cases.
We also argue that certain datatypes listed as normative in the current OWL
2 Working Draft may be unsuitable from both a modeling and implementation perspective, and we suggest several changes to the Working Draft that
address the problems identified. We then present a modular datatype checking algorithm that can support any datatype for which it is possible to
implement a small set of basic operations that we call a datatype handler. Fi-
nally, we discuss how to implement datatype handlers for number and string
datatypes.

The results of this paper thus provide important guidance for the designers of
OWL 2, by pointing out potential design mistakes that could make implementation difficult, and for implementors of OWL 2 reasoners, by showing how to
implement a suitable datatype checker.

2 http://www.w3.org/2007/OWL/wiki/OWL Working Group
3 http://www.w3.org/TR/owl2-syntax/
?

?

?
2 Preliminary Definitions

In this section, we present the formal definitions underlying the datatype system
of OWL 2. For simplicity, we focus here only on unary datatypes; our definitions
can be extended to n-ary datatypes as in [11]. We assume the reader to be
familiar with the basics of DL syntax and semantics [1].

The central notion in the datatype system of OWL is the datatype map. In
OWL 2, datatype maps can additionally support facetsexpressions that can
be applied to a datatype to restrict its interpretation.
Definition 1. A datatype map is a 4-tuple D = (ND, NC, NF ,D), where
 ND is a set of datatypes,
 NC is a function assigning a set of constants NC(d) to each d  ND,
 NF is a function assigning a set of facets NF (d) to each d  ND,
 D is a function assigning a datatype interpretation d

D to each datatype
D to each facet f  NF (d), and a

d  ND, a facet interpretation f
data value v

D to each constant v  NC(d).

D  d

D  d
?

?

?
 f

dND

D \ f

D, (f1  f2)D = f

2 , and (f1  f2)D = f

NC(d); the intended usage of NC
By a slight abuse of notation, let NC =
should be clear from the context.
A facet expression for a datatype d  ND is a formula  built using propositional connectives over the elements from NF (d)  {d,d}. The function D
is extended to facet expressions for d by setting, for f(i)  NF (d), D
D,
d = d
d = , (f)D = d
 f
D
?

?

?
2 .

In the rest of this paper we additionally assume that the datatypes in ND are
pairwise disjointthat is, that d1, d2  ND and d1 = d2 imply d
 d
2 = . As
?

?

?
we show in Sections 3 and 5, this leads to no loss of generality, simplifies our
reasoning algorithm, and allows for a modular treatment of different datatypes.
Our datatypes are, in this respect, comparable to datatype groups [11].
For example, D might be a datatype map with ND = {str, real}, where str

D are the set of all strings and real numbers, respectively. The sets
and real
NC(str) and NC(real) would then contain all string constants and all decimal
representations of real numbers. Finally, the set NF (real) might contain the facet
int, interpreted as the set of all integers, and facets of the form <w, >w, w,
and w for each decimal number w. Thus, the facet expression int  >12  <15
would represent the integers 13 and 14.
We next show how to extend a description logic DL with a datatype map.
We omit the definition of the concepts and axioms of DL, and present only the
concepts and axioms of the combined language that involve datatypes. We first
introduce data rangesexpressions over the predicates in Dand then show
how to integrate data ranges into DL concepts and axioms.
Definition 2. Let D = (ND, NC , NF ,D) be a datatype map. The set of data
ranges for D is the smallest set that contains D, d, d[], {v1, . . . vn}, dr, for
d  ND,  a facet expression for d, vi  NC, and dr a data range.

B. Motik and I. Horrocks

Table 1. Model-Theoretic Semantics of DL+D
?

?

?
Semantics of Concepts

Semantics of Data Ranges
= D
(D)
({v1, . . . , vn})
= {v
n }
?

?

?
1 , . . . , v
I  y  dr
= {x | y : x, y  U
D}
D}
= {x | y : x, y  U
I  y  dr
= {x | {y | x, y  U
I  y  dr
D}  n}
D}  n}
I  y  dr
= {x | {y | x, y  U

(U.dr)

(U.dr)

( n U.dr)

( n U.dr)

Note: N is the number of elements in a set N .
?

?

?
(d[])
dr

= 
= D \ dr
Semantics of Axioms

Dis(U1, U2)  U
U1  U2  U
U (a, v)

1  U
2 = 
?

?

?
1  U
?

?

?
D  U
 aI , v
?

?

?
Let DL be a description logic, defined over a set of individuals NI, and let NDP
be a set of data properties disjoint from each of the sets of symbols used in DL.
The logic DL+D, obtained by extending DL with D, is defined as follows. The set
of concepts of DL+D extends the set of concepts of DL with datatype concepts of
the form U.dr, U.dr,  n U.dr, and  n U.dr, for U  NDP , n a nonnegative
integer, and dr a data range for D. The set of axioms of DL+D extends the
set of axioms of DL with data property disjointness axioms Dis(U1, U2), data
property inclusion axioms U1  U2, and data property assertions U(a, v), for
U(i)  NDP , a  Ni, and v  NC.
,I), where #I and
#D are nonempty disjoint sets such that d
D  #D for each d  ND, and I is
a function assigning to each concept C, property R, and individual a of DL,
I  #I  #I,
and to each data property U  NDP , interpretations C
I  #I  #D respectively. The functions D and I are extended
I  #I, and U
a
to data ranges and datatype concepts as shown in Table 1. For DL+D knowledge
bases K and K, an interpretation I is a D-model of K, written I |=D K, if all
axioms of DL are satisfied in I as specified by DL, and the additional axioms
are satisfied in I and D as specified in Table 1; furthermore, K D-entails K,
written K |=D K, if I |=D K whenever I |=D K.

An interpretation for DL+D is a triple I = (#I

I  #I, R

,#D

3 The Architecture of the Datatype System of OWL 2

We now explain the rationale behind and some nontrivial consequences of the
definitions presented in Section 2.

3.1 Openness of the Domain in a Datatype Map

A number of approaches for adding datatypes to DLs are based on the framework
of concrete domains [2], in which the set #D is fixed in advance; for example,
#D can be fixed to the set of all integers. Datatype groups [11] are similar to
datatype maps, but they also fix the set #D as the union of the interpretations
of all datatypes in the group. The semantics of OWL DL [13] is somewhat
?

?

?
ambiguous regarding this point: it says that #D contains the interpretation
of all datatypes, but it is not clear whether #D must be exactly that set (the
intention was, however, that #D should not be fixed4).

The set of datatypes in OWL 2 should be extensible: future versions of OWL
might want to add support datatypes that will not be normative in OWL 2, and
implementations might also want to support custom datatypes. Extensibility,
however, is impossible if the set #D is fixed in advance. For example, the axiom
 =   U. <5 U.real is a tautology w.r.t. a datatype map D where #D is
fixed to the set of all real numbers: if some individual a is connected by U to
a data value, this value must be a real number, so U.real(a) is satisfied; if a
has no U-connections, then U. <5 (a) is satisfied. The axiom , however, is not
a tautology w.r.t. a datatype map D in which #D is fixed to contain all real
numbers and all strings: an individual a might be connected only to a string,
which makes neither disjunct in  satisfied. This example shows that, in general,
the consequences of a knowledge base K can depend on datatypes that are not
mentioned in K at allclearly an undesirable situation.
Therefore, in DL+D (and in OWL 2) the set #D can be any set that at least
contains the interpretations of all datatypes in D. The following proposition
shows that K can in fact be interpreted by considering only those datatypes
explicitly mentioned in K. Therefore, in the rest of this paper we simply talk of
models and entailment instead of D-models and D-entailment.
Proposition 1. Let D1 = (ND1 , NV1, NF1,D1) be a datatype map and K and K
DL+D1 knowledge bases. For each datatype map D2 = (ND2 , NV2 , NF2,D2) such
 ND2, NV1(d)  NV2(d) and NF1(d)  NF2(d) for each d  ND1, and
that ND1
D2 coincides with D1 on the elements from D1, we have K |=D1
K.
K. The () direction is
K iff K |=D1
Proof. We show the contrapositive: K |=D2
,I) be an interpretation such that
,#D
trivial. For the () direction, let I = (#I
I |=D1
,I
,#D
) such that #I
:= #I
K and I |=D1
K. We construct I = (#I
and I
is obtained from #D by adding the interpretations of all
:= I, and #D
\ ND1. Extending #D to #D
datatypes from ND2
can change only the interpretation of complemented data ranges; hence, for each data range dr over D1,
D for each U  NDP , for each concept C of
D  dr
D
we have dr
DL+D1, we have C
?

?

?
I; but then, I |=D2

K and I |=D2

K iff K |=D2

K.

D

= U

. Since U
I

= C

3.2 Giving Names to Data Ranges

The OWL 2 Working Group is currently considering whether to extend the
language with the ability to explicitly name commonly used data ranges. For
example, the axiom Teens  real[int  >12  <20] would give a name Teens to
the set of integers between 12 and 20, which could then be used in concept
definitions such as Teenager  hasAge.Teens. The syntax and the semantics of
such axioms can be formalized as shown in the following definition.

4 Personal communication with Peter F. Patel-Schneider.

B. Motik and I. Horrocks

,#D

,I) interprets each dn  NN as dn
D = dr

Definition 3. Let D = (ND, NC , NF ,D) be a datatype map, and let NN be a
set of datatype names, disjoint with ND, NC, and NF . The set of data ranges of
D is extended such that each dn  NN is a data range. A datatype naming axiom
then has the form dn  dr, where dn  NN and dr is a data range. An interpretation I = (#I
D  #D. Furthermore,
I satisfies a datatype naming axiom dn  dr iff dn
D.
Although seemingly innocuous, datatype naming axioms can easily invalidate
Proposition 1. For example, let K = {A  real, A  D}. The datatype naming
axioms in K behave similarly to general concept inclusions, allowing us to fix
the set #D to the set of real numbers. Thus, K is satisfiable w.r.t. a datatype
map that contains only real numbers, but it becomes unsatisfiable as soon as we
extend the datatype map with a datatype disjoint with real.

Datatype naming axioms thus seem to be too expressive in general: datatypes
are fully described by the datatype map, so allowing for additional axioms about
the datatypes is likely to be undesirable. This problem can be solved by requiring
datatype naming axioms dn  dr to be acyclic [1]: each name dn may occur in
at most one such axiom, and it may neither directly nor indirectly be used in dr.
With such restrictions, each datatype name dn can be unfoldedthat is, it can
be (recursively) replaced with its definition. Thus, datatype names can always
be eliminated from a knowledge base, so Proposition 1 still holds.

3.3 Disjointness of Datatypes in a Map

In Definition 1 and in OWL 2, the datatypes in a datatype map need not be
disjoint. Without losing generality, however, we can assume the contrary: two
nondisjoint datatypes d1 and d2 can be replaced with a datatype d1+2 that is
interpreted as a union of d1 and d2 and that provides d1 and d2 as facets. For
example, a datatype system with strings, real numbers, and integers can be
formalized as a datatype map in which strings and real numbers are datatypes,
and integers are modeled as a facet for the real numbers.

Assuming that datatypes in a map are disjoint allows us to obtain a modular
algorithm for datatype reasoning. In particular, only four basic operations (see
Definition 5) are needed to support a datatype d in our datatype reasoning
algorithm; if d is disjoint from any other datatype in the map, these operations
need not consider any of the other supported datatypes. For example, in Sections
5.2 and 5.3 we present datatype handlers for numbers and strings, respectively.
Although the handler for numbers needs to know about all kinds of numbers, it
does not need to know about strings and vice versa. Therefore, the notion of a
datatype provides us with a natural modularization boundary for reasoning.

3.4 The Semantics of Complemented Data Ranges
Complemented data ranges have been added to DL+D mainly to support the
representation of axioms in negation-normal form. In (1), for example, the concept hasAge.real[<18] is implicity negated, which becomes visible if the axiom
?

?

?
is brought into negation-normal form, cf. (2).

(1)
(2)

hasAge.real[<18]  YoungPerson
  hasAge.real[<18]  YoungPerson

Note that the semantics of complemented data ranges is defined w.r.t. the
entire set #D; hence, the interpretation of real[<18] includes all real numbers
greater than or equal to 18, as well all data values that are not numbersthat
D  real[18] D. This may seem counterintuitive, but it is
is, real[<18]
necessary if DL+D is to have a standard first-order semantics. For example, if
real[<18] were interpreted as the set of real numbers greater than or equal to
18, then hasAge.real[<18] would not be the complement of hasAge.real[<18],
which would invalidate the basic assumptions of first-order logic.

= real

3.5 Reasoning with a Datatype Map

Several tableau algorithms for DLs extended with datatypes have been proposed
[2,10,5,7,11]; we illustrate them using the ABox A, shown in (3). First, standard
tableau expansion rules are used to expand A to A, shown in (4). To obtain a
model from A, one must check whether individuals t1 and t2 can be assigned values from #D in a consistent way. For this purpose, algorithms such as [7] invoke
an external datatype checkeran oracle that decides satisfiability of conjunctions of the form d1(x1)  . . .  dn(xn), where di are datatypes. In our example,
 = {5}(x1)  int[>4  <6](x2) is satisfied by an assignment x1 = x2 = 5, so we
can conclude that A and A are satisfiable.
(3)
(4)

A = { U1.{5}(a), U2.int[>4  <6](a) }
int[>4  <6](t2) }

= A  { U1(a, t1), {5}(t1), U2(a, t2),

A

Although the set #D in a datatype map is not fixed (see Section 3.1), a tableau
algorithm for DL can be combined with a datatype checker in much the same way
as in [2,10,5,7,11]. A minor problem in DL+D arises due to disjointness of data
properties. Assume that the knowledge base shown in (3) also contains the axiom
Dis(U1, U2). The assignment x1 = x2 = 5 is the only one satisfying ; however,
setting t1 and t2 equal to 5 clearly invalidates Dis(U1, U2). A similar problem has
been observed and solved in a slightly different context [10]. Roughly speaking,
the solution is to derive the inequality t1  t2 whenever U1(s, t1) and U2(s, t2)
are derived and U1 and U2 are disjoint. In our example, deriving t1  t2 gives
 =   x1  x2, which is clearly unsatisfiable. The model
rise to a conjunction 
construction therefore fails, and we can correctly conclude that A  {Dis(U1, U2)}
is unsatisfiable.

The following definition formalizes the datatype checking problem, as applicable in our setting, and introduces some useful notation. For convenience, we treat
conjunctions of datatype assertions as sets.
Definition 4. Let D = (ND, NC , NF ,D) be a datatype map and NV a set of
variables disjoint with NC. A D-conjunction is a finite set of assertions of the

B. Motik and I. Horrocks

D  #D for each d  ND, ( ii) (c) = c

form dr(t) and t1  t2, for dr a data range over D and t(i)  NV  NC. A D-
conjunction  is D-satisfiable if a set #D and a mapping  : NV  NC  #D
D for each c  NC,
exist such that ( i) d
( iii) dr(t)   implies (t)  (dr)D, and ( iv) t1  t2   implies (t1) = (t2).
Let  be a D-conjunction. Each assertion t1  t2 in  should also be read as
t2  t1that is, the  predicate has built-in symmetry. For x a variable, /x
is the result of deleting all assertions in  that contain x; for t a variable or a
constant, /xt is the result of replacing x with t in all assertions in  ; finally,
let cv(, x) = {x
Boolean combinations of facets are thus dealt with in the datatype checker rather
than the tableau algorithm, since knowledge about datatypes and facets can be
used to optimize the handling of common cases (see Sections 5.2 and 5.3).

  x  } and cc(, x) = {c | c  x  }.

 | x

3.6 Complexity of Datatype Checking

We now turn our attention to the complexity of datatype reasoning, and show
that datatype checking is intractable in general (Proposition 2), but that an
important case exists in which the problem becomes trivial (Proposition 3).
Proposition 2. Checking D-satisfiability of a D-conjunction is NP-hard.
Proof. The proof is by reduction from the NP-hard Graph 3-Colorability
problem: for a finite undirected graph G = (V, E), decide whether it is possible
to label each vertex in V with a number from the set {1, 2, 3} such that adjacent
vertices are not labeled with the same number.
For G = (V, E) a finite graph, let xi be a variable uniquely assigned to each
vertex i  V , and let G be the following D-conjunction, where dr = {1, 2, 3}:
?

?

?
It is easy to see that G is 3-colorable if and only if G is D-satisfiable.
The proof of Proposition 2 requires inequality predicates, which are already
necessary for the proper handling of number restriction datatype concepts. Such
concepts, however, generate sets of pairwise unequal variables, which may be
easier to handle; for example, it is not trivial to see if they can encode Graph
3-Colorability. In contrast, D-conjunctions of the form used in the proof
of Proposition 2 can be obtained using only axioms of the form U.dr(a) and
Dis(U1, U2). Proposition 2 thus suggests that data property disjointness axioms
might make datatype checking harder in practice.
Proposition 3. Let  be a D-conjunction and x a variable such that ( i) x
occurs in  in exactly one assertion of the form dr(x),5 ( ii) x  x   , and
D  cv(, x) + cc(, x) + 1.6 Then,  is D-satisfiable if and only if
( iii) dr
/x is D-satisfiable.
5 If  does not contain such assertion, we can always take dr = D.
6 S denotes the cardinality of the set S.
?

?

?
{ dr(xi) } 

G =

iV

i,jE

{ xi  xj }
?

?

?
Proof. The () direction is obvious. For the () direction, assume that a set
#D and a mapping  of variables in /x to the elements of #D exist such that
  cv(, x)}
/x is satisfied. By (iii), the set dr
contains at least one element that is not mapped to a variable in cv(, x) or a
constant in cc(, x). Let (x) be an arbitrarily selected element from this set.
By (i) and (ii), all assertions in  \ /x are of the form dr(x), x  x
 with

  cv(, x), or x  c with c  cc(, x). Clearly,  satisfies  .
x

D | c  x  } \ {(x

D \ {c

) | x

4 Selecting the Set of Datatypes for OWL 2

The current OWL 2 Working Draft7 contains a normative list of datatypes and
facets, most of which are taken from XML Schema [3]. Although these datatypes
may be quite useful in XML applications, some of them do not seem appropriate
for a logic-based language such as OWL 2.

4.1 String-Based Datatypes

The base string datatype in OWL 2 is xsd:string, and it is equipped with facets
length n, minLength n, maxLength n, which restrict the length of a string, and
pattern re, which restricts the form of a string to the regular expression re. We
present algorithms for handling strings and all these facets in Section 5.3. XML
Schema includes a number of string-derived datatypes [3], which can be seen as
shortcuts for the pattern facet with particular values. The xsd:anyURI datatype
represents Uniform Resource Locators (URIs). The OWL 2 specification needs
to clarify whether this datatype is a subset of xsd:string.

4.2 Numbers

XML Schema provides a multitude of datatypes for numbers: xsd:decimal represents arbitrarily long numbers in decimal notation, xsd:integer represents
unbounded integers, and xsd:double and xsd:float represent floating-point numbers in double and single precision, respectively. Other numeric datatypes are
derived from these base ones by imposing various restrictions; for example,
xsd:nonNegativeInteger represents all nonnegative integers. The supported facets
are minInclusive x, minExclusive x, maxInclusive x, and maxExclusive x, which restrict the range of numbers, and pattern re, which restricts numbers to those
whose string representation matches the regular expression re.

These datatypes exhibit a number of different problems. First, xsd:decimal
is not closed under division, so it does not provide a suitable basis for possible
extensions of OWL 2 with arithmetic. Second, the floating-point datatypes have
a very large but finite number of values, and can also exhibit complex behavior
due to rounding of values that cannot be exactly represented; these features
could lead to unexpected inferences, and they might be a source of inefficiency
in implementations. Third, the pattern facet seems to be of limited utility for

7 http://www.w3.org/TR/2008/WD-owl2-syntax-20080411/

B. Motik and I. Horrocks

number types, and it might place an unreasonable burden on implementers as it
allows for data ranges such as all decimal numbers greater than 5 that match
a particular regular expression.

In view of these problems, we propose that the OWL 2 datatypes xsd:decimal,
xsd:double, and xsd:float be replaced with a new datatype owl:real, interpreted
as the set of all real numbers. Clearly, not all data values in the interpretation
of owl:real can be represented using a constant (i.e., a finite string over a finite
alphabet). This should, however, not pose a problem in practice: one could define
constants for all rational numbers, and possibly also for important irrational
numbers such as  or e. The xsd:integer datatype can be supported as a facet of
owl:real, as can the other facets apart from pattern. In Section 5.2 we present a
reasoning algorithm for this datatype.

4.3 Date and Time

XML Schema provides the xsd:dateTime datatype, interpreted as a set of time
points in the Gregorian calendar. A number of other datatypes represent possibly
recurring intervals and time points. For example, xsd:date represents intervals
of length one day; xsd:time represents an instance in time that recurs each day;
and xsd:gMonthDay represents a Gregorian date that recurs every year.

Reasoning about recurring time points and intervals is difficult due to their
complex and ill defined semantics: the recurrences are irregular due to exceptions
such as leap years; furthermore, the occurrence of future time points cannot be
determined in advance due to leap seconds, which are introduced into the calendar by the International Earth Rotation and Reference Systems Service as
necessary. Therefore, only the xsd:dateTime datatype seems amenable to imple-
mentation, and it can be handled by techniques similar to the ones for numbers.

5 Reasoning with Datatypes in OWL 2

While the principles of integrating a datatype checker with a tableau algorithm
are well understood, little attention has been paid in the literature to the details
of actual datatype checking algorithms. We next present such an algorithm that
is extensible w.r.t. the set of supported datatypes and show its correctness.

5.1 An Extensible Datatype Checking Algorithm

We first identify the basic operations that are needed to support a particular
datatype in a datatype map. In Sections 5.2 and 5.3, we discuss how to implement
these operations for the real and string datatypes, respectively.
Definition 5. Let D = (ND, NC , NF ,D) be a datatype map where the interpretations of different datatypes are pairwise disjoint. A datatype handler for a
datatype d  ND is a 4-tuple (mincd, enud, ind, eqd) of functions where, for each
data range dr of the form d[],
?

?

?
D = {c
?

?

?
1 , . . . , c
n

D contains at least n elements,

 mincd(dr, n) = true for an integer n iff dr
 enud(dr) is defined only if dr

D is finite, and it is a set {c1, . . . , cn} such that
}that is, enud(dr) returns a finite set of constants that

dr
enumerate the interpretation of dr,
 ind(c, dr) = true for c  NC(d) iff c
D  dr
D, and
 eqd(c1, c2) = true for c1, c2  NC(d) iff c
?

?

?
2 .
1 = c
Our algorithm for checking D-satisfiability of a D-conjunction  consists of Procedures 1 and 2. For convenience, we assume that all data ranges in  are of
the form d[] (i.e., data ranges without facet expressions are represented as
d[d]). The letter c (possibly with subscripts or superscripts) denotes a con-
stant. We additionally use the following two auxiliary functions: for c1 and c2
constants, eq(c1, c2) = true iff c1 and c2 are constants of the same datatype
d and eqd(c1, c2) = true; furthermore, for c a constant and d[] a data range,
in(c, d[]) = true iff c is a constant of the datatype d and ind(c, d[]) = true.

We next explain the intuition behind Procedure 1. First,  is checked for
trivial unsatisfiability (lines 13), after which all complemented enumerations
are rewritten using inequalities (lines 46) in order to simplify the rest of the
algorithm. Lines 722 form the core part of the algorithm. For each variable x
in  , the set of data ranges in which x occurs is normalized (line 8)that is, it
is reduced to  (meaning that x is trivially satisfiable), a data range of the form
d[], or a finite enumeration {c1, . . . , cn}. In the second case, a call is made to
the datatype handler to see whether Proposition 3 is applicable (line 9); if so,
the variable x is removed from  (line 11). If D = d[] and the test in line 9
fails, then the interpretation of D is finite, so it is enumerated (line 13). Thus, by
line 15, D is either  or a finite enumeration. If D is empty, then  unsatisfiable
(lines 1516). If D is not empty, the normalized data range D is reintroduced
into  (lines 1721): if D is a singleton, then x must be assigned the only value in
D (line 18); otherwise, all original data range assertions involving x are replaced
with D(x) (line 20). By line 23, therefore, in all assertions of the form dr(x)   ,
for dr a nonempty enumerated data range.

Lines 2333 try to further simplify  , first by considering all assertions not
containing variables (lines 2330), and then by applying Proposition 3 to the
remaining assertions (lines 3133). All that now remains is to check if  is
satisfied for at least one assignment of values to variables and constants. This
part of the algorithm is nondeterministic, and can be implemented using search.
To reduce the search space,  is first decomposed into variable-disjoint subsets
(line 34), each of which is tested for D-satisfiability independently (lines 3543).
Procedure 2 normalizes a set of data ranges S to a finite enumeration of
constants of the form {c1, . . . , cn}, a single data range of the form d[], or 
(meaning that the corresponding variable is trivial to satisfy). Lines 113 handle
the case where S contains at least one enumerated data range: the result is then
an enumeration containing only those constants ci that are contained in all data
ranges in S. If S does not contain at least one positive data range (line 14),
then the corresponding variable can be assigned a fresh distinct data value not
contained in the interpretation of any of the datatypes (note that #D can be

B. Motik and I. Horrocks

return false

 := /x
D := 

else if D = d[] then

D := enud(D)

 := ( \ { {c1, . . . , cn}(t) })  {t  c1, . . . , t  cn}

end if
if D =  then
else if D = {c} then
else if D =  then

return false
 := ( \ {dr(x) | dr(x)  })/xc
 := ( \ {dr(x) | dr(x)  })  {D(x)}

Procedure 1. D-satisfiable( )
Require: a D-conjunction  containing assertions of the form dr(t) and t1  t2
1: if D(t)   for t a variable or a constant, or x  x   then
2:
3: end if
4: for each {c1, . . . , cn}(t)   for t a variable or a constant do
5:
6: end for
7: for each variable x occurring in  do
D := normalize({dr | dr(x)  })
8:
if D = , or D = d[] and mincd(D, cv(, x) + cc(, x) + 1) = true then
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22: end for
23: for each    that does not contain a variable do
24:
25:
26:
27:
28:
29:
30: end for
31: while  contains some {c1, . . . , cn}(x) such that n  cv(, x) + cc(, x) + 1 do
 apply Proposition 3 to x
32:
33: end while
34: decompose  into nonempty mutually disjoint subsets 1, . . . , n such that no
35: for each 1  i  n do
36:
37:
38:
39:
40:
41:
42:
43: end for
44: return true

 = d[](c) and in(c, d[]) = false, or  = d[](c) and in(c, d[]) = true, or
 = {c1, . . . , cn}(c) and eq(c, ci) = false for each 1  i  n then
return false
end if
 :=  \ {  }

(c) = c for each constant c, and
{c1, . . . , cm}(x)   implies (x) = ci for some 1  i  m, and
t1  t2   implies eq((t1), (t2)) = false

i and j, i = j, have variables in common

does not exist then

return false

end if

end if

if  = c1  c2 and eq(c1, c2) = true, or

 apply Proposition 3 to x

 := /x

if an assignment  to variables and constants in i such that
?

?

?
end if

end for

end for
return R

dr = d[] and in(c, d[]) = false, or
dr = d[] and in(c, d[]) = true then
R := R \ {c}

R := {c1, . . . , cn}
for each c  R do
for each dr  S do
m} and eq(c, c
i) = false for each 1  i  m, or
if dr = {c
?

?

?
1, . . . , c

Procedure 2. normalize(S)
Require: a nonempty set of data ranges S of the form d[], d[], or {c1, . . . , cn}
1: if S contains a data range of the form {c1, . . . , cn} then
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13: end if
14: if S contains no data range of the form d[] then
15:
16: else if S contains data ranges d1[1] and d2[2] such that d1 = d2 then
17:
18: end if
19: let d be the datatype of all the data ranges in S of the form d[]
20:  := d
21: for each dr  S do
if dr = d[] then
22:
 :=   
23:
24:
 :=   
25:
26:
27: end for
28: return d[]

return 
return 

else if dr = d[] then

end if

any set that contains the interpretations of all the datatypes in D). If S contains
two positive data ranges with different datatypes (line 16), then S is clearly
unsatisfiable. Lines 2127 then combine the facet expressions in all the data
ranges in S. Note that the simplification of complemented data ranges in line
25 is possible because d[]
and, since S contains at least one
data range of the form d[], no data value can be in both d[]D and d

D  d[]

= d

.

The correctness of our algorithm follows easily from Proposition 3. Therefore,

we only sketch the proof of the following theorem.
Theorem 1. D-satisfiable( ) returns true if and only if  is D-satisfiable.
Proof (Sketch). It is easy to see that, for each D = normalize(S), the following
holds (): D =  if and only of all data ranges in S are of the form d[]; otherwise,
?

?

?
D 

D =
Sp = {dr  S | dr is not of the form d[]}.

d[]S\Sp

(d[])D

drSp

dr

, where

B. Motik and I. Horrocks

We now prove the claim of this theorem. If  is D-satisfiable, then the condition in line 1 cannot be satisfied. Furthermore, the transformation in line 5
clearly preserves D-satisfiability of  . Consider now the iteration over the variables occurring in  in lines 722. In lines 911, assertions containing x can
be deleted from  without affecting its D-satisfiability if either D = , or if
D = d[] and Proposition 3 is applicable; in the former case, this is because ()
tells us that we can interpret x as an arbitrary unique element not contained in
any datatype in D. If D = d[] and Proposition 3 is not applicable, then d[]
must be finite and equal to the enumeration obtained in line 13; hence, in lines
1522 we can either return false (if the enumeration is empty), replace x with c
in  (if D(x) is a singleton enumeration {c}), or replace all assertions of the form
dr(x) in  with a single assertion D(x), all of which preserve the D-satisfiability
of  . Lines 2330 detect obvious inconsistencies involving assertions in  that
do not contain variables; clearly, this does not affect the D-satisfiability of  .
Lines 3133 apply Proposition 3 again, which by definition preserves the D-
satisfiability of  . Since all data ranges in  are now finite enumerations, only a
finite number of assignments need to be considered, and lines 3444 will detect

if one of these satisfies  .
In practice, the number of variables in a D-conjunction  is likely to be of the
same order of magnitude as the numbers occurring in number restrictions, which
are usually quite small. Furthermore, data ranges are rarely constrained to small
interpretations in practice, so test (9) is likely to succeed. The satisfiability of
such a  can thus be decided without the need to enumerate data ranges and
perform combinatorial reasoning. The performance of our algorithm in practice
is thus mainly limited by the efficiency of mincd, which, as we discuss next, can
be efficiently implemented for numbers and strings.

5.2 A Datatype Handler for Numbers

To implement a datatype handler for the owl:real datatype of OWL 2, here
abbreviated as real, we devise an efficient representation of the interpretation of
a facet expression . In particular, we represent fragments of this interpretation
as intervals of the form t[l, u], t[l, u), t(l, u], and t(l, u), where t  {real, int, int}
determines the type of the interval, l is either  or a real number, and u is
either + or a real number, such that l  u. Such an interval represents the
set of all real numbers of type t between l and u; the round parenthesis means
that the end-point is not included, and the square parenthesis means that the
end-point is included in the set. By taking into account that int  int = , it is
straightforward to define the intersection    of intervals  and .

We can now represent the interpretation of each facet expression  using a

set of intervals S, inductively defined as follows:

S<w = {real(, w)}
Sw = {real(, w]}
Sint = {int(, +)}

S12 = S1

 S2

S>w = {real(w, +)}
Sw = {real[w, +)}
S = {real(, +)   |   S}
S12 = {   |   S1 and   S2
}
?

?

?
In practice, it is beneficial to ensure that each S does not contain overlapping,
empty, or adjoining intervals; the sets S can then be efficiently implemented by
storing interval end-points in a sorted array.

The function mincreal(real[], n) can then be implemented by computing S,
checking whether it consists only of finite integer-restricted intervals, and if so,
comparing their total length to n. Similarly, the function enureal(real[]) can
be implemented by computing S, checking whether it consists of only finite
integer-restricted intervals, and if so, enumerating all the relevant integers. The
function inreal(c, real[]) can be implemented in a straightforward manner if  is
a facet, and it can be computed recursively for  a general expression by taking
into account the standard semantics of propositional connectives. Finally, the
function eqreal(c1, c2) can be implemented by normalizing the lexical representation of c1 and c2 and then comparing the result.

5.3 A Datatype Handler for Strings

We now discuss the implementation of the datatype handler for the xsd:string
datatype of OWL 2, here abbreviated as str. The function eqstr(c1, c2) can be
implemented as an identity. The function instr(d[], c) can be implemented in a
straightforward manner if  is a facet (if  is a regular expression, membership
of a string in a regular language can be checked as in [6]), and it can be computed
recursively for a general expression  in the obvious way.

The implementations of mincstr(d[], n) and enustr(d[]) differ based on the
facets used in . If  contains no regular expressionsthat is, if the only restrictions are on the length of the stringthen the intervals of allowed string
lengths can be computed as in Section 5.2. If  contains regular expressions,
then each of the facets in  can be represented using a finite state automaton
[6]. (Note that the languages of all strings longer or shorter than some integer
are regular.) Regular languages are closed under Boolean connectives so using,
say, the results from [6], one can compute a finite state automaton A accepting
the language L of . The next step is to test whether L is finite. This can
be done by identifying states that can occur on a path between the starting
and the accepting states of A and checking whether these states can occur in
a loop. If the language is finite, it can be enumerated by identifying all finite
paths between the starting and the accepting states of A.
We note that checking emptiness for intersections of regular languages is
known to be PSpace-complete [8]. This source of complexity, however, has been
well studied in the literature and several optimization techniques are available.

6 Conclusion

In this paper, we have formalized the datatype system of OWL 2 and have
discussed some nontrivial consequences of our definitions. Furthermore, we have
discussed the normative datatypes listed in the current OWL 2 Working Draft
and have proposed some modifications to the list. Finally, we have presented a

B. Motik and I. Horrocks

general algorithm for datatype checkingthe basic reasoning problem involving
datatypes. Our algorithm is applicable to any datatype for which a small set
of basic operations can be implemented. We have also discussed how to realize
these operations for strings and numbers. The main challenge for our future work
is to implement these algorithms in our reasoner and test them in practice.
