Combining a DL Reasoner and a Rule Engine for 

Improving Entailment-Based OWL Reasoning 

Georgios Meditskos and Nick Bassiliades 

Department of Informatics 

Aristotle University of Thessaloniki 

{gmeditsk,nbassili}@csd.auth.gr 

Abstract.  We  introduce  the  notion  of  the  mixed  DL  and  entailment-based 
(DLE)  OWL  reasoning,  defining  a  framework  inspired  from  the  hybrid  and 
homogeneous paradigms for integration of rules and ontologies. The idea is to 
combine the TBox inferencing capabilities of the DL algorithms and the scalability of the rule paradigm over large ABoxes. Towards this end, we define a 
framework  that  uses  a  DL  reasoner  to  reason  over  the  TBox  of  the  ontology 
(hybrid-like)  and  a  rule  engine  to  apply  a  domain-specific  version  of  ABoxrelated entailments (homogeneous-like) that are generated by  TBox queries to 
the  DL  reasoner.  The  DLE  framework  enhances  the  entailment-based  OWL 
reasoning paradigm in two directions. Firstly, it disengages the manipulation of 
the TBox semantics from any incomplete entailment-based approach, using the 
efficient DL algorithms. Secondly, it achieves  faster application of the ABoxrelated  entailments  and  efficient  memory  usage,  comparing 
the  
conventional entailment-based approaches, due to the low complexity  and the 
domain-specific nature of the entailments. 

to 

it 

Keywords:  Hybrid  and  Homogeneous Systems,  Rule-based  OWL  Reasoning, 
Entailment Rules, Rule Engines, DL Reasoning.  

1   Introduction 

The Web Ontology Language (OWL) [29] is the W3C recommendation for creating 
and  sharing  ontologies  on  the  Web  and  its  theoretical  background  is  based  on  the 
Description Logic (DL) [2] knowledge representation formalism, a subset of predicate 
logic.  Existing  sound  and  complete  DL  reasoners  [12][44][45]  implement  tableaux 
algorithms  [3].  However,  although  these  systems  perform  well  on  complex  TBox 
reasoning, they have a high ABox reasoning complexity on medium and large complexity TBoxes that constitutes a serious limitation regarding the efficient query answering capabilities needed in domains with large ABoxes [13][15][35].  

Rules play an important role in the Semantic Web and, although there is not an unrestricted translation of DLs into the rule paradigm, they can be used in many directions, 
such  as  reasoning,  querying,  non-monotonicity,  integrity  constraints  [4][11]  [34].  Regarding rule-based OWL reasoning, the idea is to map OWL on a rule formalism that 
applies (a subset of) the OWL semantics in the KB of a rule engine. Practical examples 
of rule-based OWL reasoners are [21][23][27][28][33] that follow the entailment-based 

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 277292, 2008. 
 Springer-Verlag Berlin Heidelberg 2008 

G. Meditskos and N. Bassiliades 

OWL  reasoning  (EOR)  approach  [17],  and  [19]  that  reduces  OWL  into  disjunctive 
Datalog [18]. 

We present our effort to combine the strong points of the DL and EOR paradigms; 
the  former  performs  efficient  TBox  reasoning  while  the  latter  is  characterized  by 
ABox reasoning scalability (comparing it to the DL paradigm), and the simplicity of 
implementation.  We  define  a  mixed  DL  and  rule-based  (DLE)  framework  that  embeds the TBox inferencing results of the DL paradigm, and it is able to handle larger 
ABoxes than the conventional EOR systems. The latter is achieved by substituting the 
TBox-related  entailments  with  TBox  queries  to  the  DL  reasoner,  generating  the 
ABox-related entailments. The DLE  framework is  inspired from the  hybrid and  homogeneous approaches for integration of rules and ontologies [1], using the DL reasoner to answer TBox queries and the rule engine for instance queries. 

The rest of the paper is structured as follows. In section 2 we present related background and our motivation for the DLE framework. In section 3 we describe the classification of entailments on which our methodology is based. In section 4 we give the 
general reasoning principles of the DLE framework. In section 5 we present experimental results about the reasoning activity of DLE-based implementations. Finally, in 
sections 6 and 7, we present related work and we conclude, respectively. 

2   Background and Motivation 

The RDF and RDFS semantics can be captured using entailments [14] that are rules 
that denote the RDF triples [10] that should be inferred (rule head) based on existing 
ones (rule body). A triple has a subject, a predicate and an object, represented as s p 
o, where s is an RDF URI reference or a blank node, p is an RDF URI reference (in 
[17] p is allowed to take blank nodes) and o is an RDF URI reference, a blank node or 
a literal. Examples of entailments can be found in Table 1. 

Horst [16] defines the pD* semantics as a weakened variant of OWL Full and in 
[17] they are extended to apply to a larger subset of the OWL vocabulary, using 23 
entailments  and  2  inconsistency  rules.  Many  practical  OWL  reasoners  are  based  on 
the implementation of entailments in a rule engine, such as [21][23][27][28][31][33]. 
These systems apply a larger set of entailments than the  pD*  semantics define. For 
example, class intersection or the eRDFS [14] entailments (RDF entailment regimes 
[5]) are not considered in pD* semantics. 

In general, the approaches towards the combination of rules and ontologies are either hybrid or homogeneous [1]. In homogeneous approaches, the rule and ontology 
predicates  are  treated  homogeneously,  as  a  new  single  logic  language.  Practically, 
ontologies  are  mapped  on  a  rule-based  formalism  that  coexists  in  the  KB  with  rule 
predicates  [32][40][41].  The  EOR  is  a  type  of  a  homogeneous  approach,  since  any 
rule predicate of a rule program coexists with the entailment rules [1].  

In hybrid approaches, the rule and ontology predicates are separated and the ontology  predicates  can  be  used  as  constraints  in  rules.  This  is  achieved  by  following  a 
modular architecture, combining a DL reasoner for OWL reasoning and a rule engine 
for  rule  execution  [6][7][9][24][39].  Therefore,  while  in  homogeneous  approaches 
OWL reasoning is performed only by rules, in the hybrid paradigm the OWL reasoning is performed only by the DL reasoner. 
?

?

?
While the DL reasoners have poor ABox reasoning performance [13][15][35], the 
EOR paradigm has limited TBox reasoning completeness. For example, if p and g are 
both the inverse properties of q, then p and g should be inferred as equivalent proper-
ties.  We  observed  that  the  [23][28][33]  EOR  systems  do  not  deduce  such  a  TBox 
relationship,  in  contrast,  for  example,  to  Pellet  [44]  which  supports  it.  Notice  that 
[23][28][33] treat the properties p and g as equivalent at the instance level through the 
implementation of the inverse entailment (rdfp8ax, Table 1). Thus, if x p y then y q 
x, and therefore, x g y. However, they do not infer that p and g are equivalent because  they  do  not  implement  the  corresponding  entailment.  In  the  EOR  paradigm, 
some TBox entailments are either ignored, in order to speed up the TBox reasoning 
procedure, or they have not been considered during implementation. For both reasons, 
the result is an incomplete TBox reasoning procedure in the EOR paradigm. 

The use of entailments makes the EOR paradigm also incomplete on ABox reason-
ing, for the same reasons we mentioned previously. Thus, the choice between an EOR 
system  and  a  DL  reasoner  depends  on  the  domain  and  the  needs  of  the  application 
(see also [4][38]). With DLE we tackle the TBox reasoning incompleteness of EOR. 
Our motivation can be summarized in the following observation: Why do we need to 
struggle to define the entailments for OWL TBox reasoning in the EOR paradigm, if 
we can make it effortless and more complete using the efficient DL algorithms?. 

In [37] the RDFS(FA) sublanguage of RDFS and the RDF Model Theory are dis-
cussed.  In  brief,  RDFS(FA)  eliminates  the  dual  roles  of  RDFS,  stratifying  built-in 
RDF primitives in different layers. On the other hand, the RDF MT handles dual roles 
by treating classes and properties as objects. Practically, DL reasoners treat the OWL 
extension of the bottom two layers of RDFS(FA), while the entailments are defined in 
RDF  MT.  For  example,  RDFS(FA)  distinguishes  built-in  from  user-defined  proper-
ties,  while  in  RDFS  there  is  no  such  restriction  and  thus  it  is  more  expressive  (al-
though it is argued that this expressivity is too confusing). The existing EOR systems 
treat OWL as an extension of RDF MT, allowing anyone to say anything about any-
thing. This was the domain of interest in [30] and [31], where only a rule engine is 
considered for TBox and ABox entailments in the RDF MT. On the other hand, the 
DLE framework is an RDFS(FA)-oriented approach, since it uses a DL component to 
reason on OWL ontologies, following though the EOR paradigm.  

Our  DLE  framework  considers  the  EOR  paradigm  as  a  rule  program  (ABox  en-
tailments) over the KB of a DL reasoner after TBox reasoning, following the architecture  of  the  hybrid  paradigm.  Therefore,  any  subsequent  user-defined  rule  program 
would then coexist in the rule base of the rule engine with the ABox rule program, in 
the same manner as in the homogeneous paradigm. Thus, in contrast to the existing 
EOR implementations, the OWL reasoning in the DLE framework is performed both 
by a DL component and a rule engine. More specifically, it combines the TBox inference capabilities of the DL component to compute the subsumption hierarchy and the 
related semantics to the ontology roles, e.g. domain constraints, property types, etc., 
with the ability of a rule engine to process a large number of instances, applying do-
main-specific entailment rules that are generated based on the DL reasoner. 

G. Meditskos and N. Bassiliades 

Apart from scalability issues, one of the attracting features of the EOR paradigm is 
that it can be easily implemented in any rule engine, e.g. Jess [22], or a Prolog engine 
[42],  enabling  the  use  of  ontological  information  into  rule  programs,  exploiting  the 
research on efficient rule engines with different capabilities. The DLE framework is 
based on this practicality and actually enhances the EOR paradigm in two directions: 

-  It simplifies the development of an EOR system, disengaging the TBox reasoning  procedure  from  any  (incomplete)  TBox  entailment  implementation  that 
should take into account all the possible OWL TBox semantic derivations. 

-  The  rule  engine  applies  faster  the  domain-specific  ABox  entailments  than  the 
corresponding  generic  entailments  of  the  traditional  EOR  systems,  enhancing 
their scalability in terms of ABox reasoning time and memory utilization.  

3   Entailment Classification 

The DLE framework is based on the classification of entailments into terminological, 
hybrid and exceptional. In this section we present the necessary and sufficient conditions  for  performing  such  a  classification.  Notice  that,  since  we  are  based  on  a  DL 
reasoner,  the  DLE  framework  is  not  compatible  with  RDF  ontologies  and  handles 
only  the  OWL  vocabulary  [29].  Thus,  we  do  not  capture  relationships  such  as  that 
owl:Class  is  equivalent  or  subclass  to  rdfs:Class,  owl:Thing  is  equivalent  or 
subclass to  rdfs:Resource or  owl:ObjectProperty is equivalent or subclass to 
rdfs:Property. Furthermore, owl:ObjectProperty and owl:DatatypePrope-
rty are disjoint sets [29]. Since we approach the entailment-based reasoning from the 
OWL perspective, we substitute any reference to rdfs:Resource and rdfs:Class 
in entailment rules with owl:Thing and owl:Class, respectively (Table 1).   

We present a definition of an entailment rule that we follow in the rest of the paper. 

Definition 1. An entailment rule for an RDF graph G is of the form 

s1 p1 o1 s2 p2 o2 ... sn pn on   s1 p1 o1 s2 p2 o2 ... sm pm om, 

where n  1, m  1, si, si, pi and pi are RDF URI references or blank nodes, and oi 
and oi are RDF URI references, blank nodes or literals. The sn pn on triples denote 
the condition of the entailment and the sm pm om triples the conclusion. The condition of the rule denotes the RDF triples that should exist in G, and the conclusion the 
RDF triples that should be added in G. 

If  n  =  0,  then  all  the  conclusion  triples  should  always  exist  in  G  (axiomatic  triples 
[14][17]).  If  m  =  0,  then  the  entailment  denotes  that  the  triple  pattern  of  the  body 
should be viewed as inconsistent (inconsistency entailment). 

3.1   Terminological and Assertional Triples 

We  present  a  classification  of  triples  into  terminological  (T-triples)  and  assertional 
(A-triples),  according  to  the  OWL  DL  vocabulary  V  [29]  of  their  components  (pre-
fixes have been omitted). 
?

?

?
Definition 2. A triple t = s p o is a terminological triple, denoted as tT = s p oT, iff  
-  p    {domain,  range,  subClassOf,  subPropertyOf,  inverseOf,  
equivalentProperty,  equivalentClass,  intersectionOf,  unionOf, 
complementOf,  onProperty,  hasValue,  someValuesFrom,  allVal-
uesFrom,  maxCardinality,  minCardinality,  cardinality,  dis-
jointWith}, or 

-  p = type  o  {ObjectProperty, DatatypeProperty, FunctionalProp-
erty,  InverseFunctionalProperty,  SymmetricProperty,  Transi-
tiveProperty, Class, Restriction}. 

A  T-triple  denotes  information  about  the  TBox  of  the  ontology  (class  and  property 
axioms), such as subclass relationships, class equivalence, property types, etc. The A- 
triples are defined as the complement of the terminological. 

Definition 3. A triple t = s p o is an assertional triple, denoted as tA = s p oA, iff it 
is not a terminological, that is tA  tT. 
Intuitively, an A-triple denotes information about the ABox of the ontology, such as 
instance  class  membership  or  instance  equality/inequality  (sameAs  /different 
From) (we consider the oneOf construct as simple i : C assertions). Thus, p domain 
cT and p type FunctionalPropertyT, whereas x sameAs yA. Therefore, a triple 
component can either be bound to a term of the OWL vocabulary or not be bound. In 
the former case, we refer to the component as constant, whereas in the latter as variable  (blank  node).  For  example,  the  triple  p  domain  c has  a  variable  subject  and 
object, and a constant predicate. We use the notation var(c) to denote that the c component of the triple is a variable. 

3.2   Terminological, Hybrid and Exceptional Entailments 

Based on the triple classification of section 3.1, we define the terminological, hybrid 
and exceptional entailments.  
 
Definition 4. An entailment is considered as a terminological (T-entailment), if and 
only if it contains only T-triples in its conclusion. 
 
Definition 5. An entailment is considered as a hybrid (H-entailment), if and only if it 
contains both T- and A-triples in its condition and only A-triples in its conclusion. 
 
Definition  6.  An  entailment  is  considered  as  an  exceptional  (E-entailment),  if  and 
only if it contains only A-triples in its condition and conclusion. 
 
Table 1 depicts some indicative examples of entailment classification, as well as some 
eRDFS entailments needed for OWL TBox reasoning [14] (denoted as extX). 

4   Reasoning on the DLE Framework 

The reasoning on the DLE framework is based on two reasoning paradigms over two 
distinct KBs that cooperate. 

G. Meditskos and N. Bassiliades 

Table 1. Classification examples of some common entailment rules 

p domain cT c subClassOf dT  p domain dT 
p domain cT b subPropertyOf pT  b domain cT 

c type ClassT  c subClassOf ThingT 
c subClassOf dT d subClassOf kT  c subClassOf kT 

Terminological Entailment Rules (T-entailments) 
rdfs8 
rdfs11 
rdfp12c  c subClassOf dT d subClassOf cT  c equivalentClass dT 
rdfp13c  p subPropertyOf qT q subPropertyOf pT  p equivalentProperty qT 
ext1 
ext2 
Hybrid Entailment Rules (H-entailments) 
p domain cT x p yA  x type cA 
rdfs2 
rdfp8ax  p inverseOf qT x p yA  y q xA 
c subClassOf dT x type cA  x type dA 
rdfs9 
p type FunctionalPropertyT x p yA x p zA   y sameAs zA 
rdfp1 
p type TransitivePropertyT x p yA y p zA  x p zA 
rdfp4 
rdfp14a  r hasValue yT r onProperty pT x p yA  x type rA 
Exceptional Entailment Rules (E-entailments) 
rdfs4a 
rdfs4b 
rdfp6 
rdfp7 
rdfp11 

x p yA  x type ThingA 
x p yA  y type ThingA 
x sameAs yA  y sameAs xA 
x sameAs yA y sameAs zA  x sameAs zA 
x p yA x sameAs x A y sameAs y A  x p y A 

 

Definition  7.  The  DLE  framework  consists  of  two  distinct  knowledge  bases  DLE  = 
(DLKB, RKB) where: 

-  DLKB is the DL components KB, with DLKB = T, where T is the ontology 

TBox (concept and role axioms), and 

-  RKB is the rule engines KB, with RKB = RB, A, where RB is the rule base 
of the rule engine that contains the entailment rules and A is the ABox of the ontology (instance and role assertions). 

The two KBs are distinct in the sense that the information flows only from the DLKB 
to the RKB (unidirectional) in order to populate the RB with entailments. 

4.1   Reasoning on the DL Component 

Basic DL reasoning problems include class equivalence, concept subsumption, satisfiability and realization. Since the DLKB does not consider ABoxes, the DL component of the DLE framework is not used for instance realization.  

The  use  of  DL  TBox  reasoning  in  the  DLE  framework  makes  redundant  the  T-
entailments. These entailments generate T-triples (Definition 4), such as subclass and 
class equivalence relationships, domain and range restrictions, property equivalence, 
etc. Since these TBox semantics are handled by the DL reasoner, the T-entailments 
are  ignored,  decoupling  the  TBox  inference  procedure  from  any  entailment-based 
approach. As we explain in the next section, each T-triple of an H-entailment is substituted with a query to the DLKB. In that way, we are not concerned about how to 
implement the TBox semantics in the DLE framework, but only how to use them at the 
instance level via ABox entailments. 
?

?

?
To  exemplify,  consider  the  rdfs11  entailment  for  subclass  transitivity.  For  every 

three concepts C, D, E  T of the DLKB: 

 

if T  C (cid:139) D and T  D (cid:139) E, then DLKB  C (cid:139) E. 

 
Practically, by querying the DLKB for the indirect superclasses of a concept, all 
the concepts that belong to the subclass transitive closure are returned (as well as their 
equivalents), thus the rdfs11 entailment is natively supported.  

Consider also the intersectionOf construct. A class C is contained in the intersection of the classes C1,..., Cn by saying that C is a subclass of each class Cn. This is 
also the inference result of a DL reasoner:  
 

if T  C  C1 (cid:138)...(cid:138) Cn, then DLKB  C (cid:139) Cn. 

 

Thus,  by  querying  the  DL  reasoner  for  the  superclasses  of  C,  the  intersection 
classes  Cn are also returned (a similar approach is followed for the semantics of the 
unionOf  construct).  Notice  that  the  iff  semantics  of  class  intersection  (and  union) 
require ABox reasoning and thus, the DLE  framework handles them at the instance 
level  by  entailments.  The  same  holds  for  class  restrictions,  e.g. R.C.  The  DL  reasoner is used also to facilitate entailment-free TBox consistency check, e.g. inconsistent subclass relationships of disjoint classes.  

4.2   Transforming H-Entailments 

Since we do not consider T-entailments, the RKB does not contain any T-triple and 
thus, the H-entailments would never be activated. In order to cope with the missing 
TBox  triple  information,  we  substitute  each  T-triple  of  the  condition  of  an  H-
entailment  with  a  query  to  the  DL  component  in  order  to  ground  the  TBox-related 
variables (vars) of the remaining A-triples. We call this procedure entailment reduc-
tion, because the H-entailments are reduced to domain-specific E-entailments, which 
we call dse-entailments. Therefore, for a specific H-entailment, it is possible to generate more than one dse-entailment. There are two advantages behind the reduction: 

-  Since the dse-entailments are generated based on the ontology TBox axioms, the 
RB  will  contain  only  the  entailments  that  are  needed,  in  contrast  to  the  traditional  EOR  paradigm  where  all  the  entailments  are  preloaded.  For  example,  a 
transitive role-free ontology will result in a transitive entailment-free RB, reducing the number of the rules need to be checked in each cycle. 

-  The  dse-entailments  contain  less  conditional  elements  than  the  initial  H-
entailments,  since  the  T-triples  are  removed.  Thus,  the  dse-entailments  have 
lower complexity and thus, they are activated faster by the rule engine. 

 
DL queries. A T-triple tt can be transformed into a TBox query for the DL compo-
nent,  denoted  as  tT   DLQ(tT),  in  order  to  retrieve  the  ontology  values  that  correspond to the variables of the T-triple. Similarly, the set T of the conditional T-triples 
of an H-entailment H can be transformed into a conjunction query, denoted as DLQH, 
that corresponds to each T-triple, that is T  DLQ(t1T)  ...  DLQ(tnT), tnT  T. 

G. Meditskos and N. Bassiliades 

 

 

To exemplify, using a predicate-like syntax for the DL queries, the T-triple p do-

main cT of the rdfs2 entailment can be transformed into the query: 
 

DLQrdfs2 : p domain cT   domain(var(p), var(c)),  

retrieving all the properties of the DLKB with their domain constraints. Similarly, the 
T-triples of the rdfp14a entailment can be transformed into: 
 
DLQrdfp14a : {r hasValue yT, r onProperty pT}    
 
 
retrieving the properties and their restriction values for every hasValue restriction. 
 
T-dependency.  We  introduce  the  notion  of  T-dependency  between  an  A-triple  (tA) 
and a T-triple (tT), according to whether tA has a variable component that exists in tT. 

hasValue(var(r), var(y))  onProperty(var(r), var(p)), 

 

 

Definition  8.  An  A-triple  tA  is  T-dependent  to  a  T-triple  tT,  denoted  as  tA  (cid:122)  tT,  iff 
var(c)  tA : var(c)  tT. Each such c variable of a T-dependent triple is called T-
dependent variable and it is denoted as [c] in the entailment rule. 

 

For example, both the t2A = x p yA and t3A = x  type cA A-triples of the  rdfs2 h-
entailment are T-dependent to t1T = p domain cT, that is t2A (cid:122) t1T and t3A (cid:122) t1T, 
since  var(p)   t2A,  var(c)   t3A and  var(p),  var(c)   t1T. On the other  hand, in the 
rdfp1 H-entailment only the A-triples t2A = x p yA and t3A = x p zA are T-dependent 
to  t1T  =  p  type  FunctionalPropertyT,  since  (cid:140)var(c)    t1T  :  var(c)   t4A  =  y 
sameAs  zA.  The  T-dependency  denotes  the  A-triples  whose  T-dependent  variables 
should be grounded, due to the removal of the T-triple on which they depend. 

Generating the dse-entailments. An H-entailment H is reduced by removing the T-
triples of its condition and applying a DLQH query. The results of the query are used 
to  ground  the  T-dependent  variables  of  the  A-triples,  generating  domain-specific 
versions of H (dse-entailments). The H-entailment reduction can be considered as the 
procedure of grounding the T-dependent variables of a pseudo-rule.  

Definition 9. The pseudo-rule PRH for the H-entailment H, is the entailment-like rule 
we obtain after the removal of any T-triple of the Hs condition, and it is of the form 
 
[si] pi oiA ... sk [pk] okA ... sn pn [on]A   

[sl] pl olA ... sm [pm] omA ... so po [oo]A ... su pu ouA, 

  
where  [x]  denotes  the  T-dependent  variables  of  the  entailment.  The  pseudo-rule  is 
actually  a  template  rule  which  can  be  loaded  in  the  RB  as  a  valid  rule  (dse-
entailment) after the grounding of its T-dependent variables.  

For example, the pseudo-rule PRrdfs2 for the rdfs2 entailment that we obtain after the 
removal of its T-triples is the following: 

x [p] yA  x type [c]A, 
?

?

?
where [p] and [c] are the two T-dependent variables of the entailment. Thus, based on 
the DLQrdfs2 query, we can ground (G[PRrdfs2(p, c)]) the T-dependent variables as: 
 

(p, c)  DLQrdfs2 : G[x [p] yA  x type [c]A], 

 
generating  as  many  rules  as  the  pairs  (property,  domain)  are  in  the  ontology.  For 
example, for two properties pk and pm with the classes ck and cm as domain constraints, 
respectively, we will obtain the following dse-entailments: 
 

x pk yA  x type ckA,  
x pm yA  x type cmA. 

 

One of the advantages of the entailment reduction is that the complexity of the dseentailments is lower than the  corresponding H-entailments. The time needed for the 
rdfs2 H-entailment to be activated is O(n2), where n is the size of the partial closure 
graph  under  construction  [17],  whereas  the  reduced  one  can  be  handled  in  O(pn), 
where p is the number of the grounded entailments generated from an H-entailment. 
Similarly, the rdfp14a H-entailment requires O(n3) time, while the reduced entailment 
runs in O(pn). Generally, if O(nt) is the complexity of an H-entailment, where t is the 
number of triples of the condition, the reduced entailments have O(pnt-k) complexity, 
where k is the number of T-triples (that are removed). We should mention that: 

-  The reduction results in a RB that contains more entailments than the initial H-
entailments, since for each H-entailment more than one rule might be generated 
(p rules). However, in section 5 we show that such an RB terminates the ABox 
reasoning procedure faster than the corresponding generic H-entailment RB. 

-  The RB contains only ABox-related entailments. Thus, only updates related to 

instances can be handled. We elaborate further on this in section 7.  

4.3   Basic Reasoning Steps in a Forward Chaining DLE Framework 

The E-entailments are the only entailments  that are predefined in the DLE  frame-
work,  since  they  cannot  be  reduced,  following  the  approach  of  the  convectional 
EOR paradigm. Assuming that EA and PR are the sets of the A-entailments and the 
pseudo-rules  (reduced  H-entailments)  that  will  be  supported  by  the  DLE-based 
implementation, the algorithm of Fig. 1 depicts the reasoning methodology using a 
forward chaining rule engine. Initially, the TBox of the ontology is loaded into the 
DL  reasoner  in  order  to  classify  the  ontology  (lines  1  and  2).  Then,  the  ABox  is 
loaded into the rule engine (line 3) in order to create the internal rule engine repre-
sentation,  for  example  triple  facts.  Moreover,  the  predefined  E-entailments  are 
loaded  into  the  RB  (line  4).  In  order  to  generate  the  dse-entailments,  i.e.  the 
grounded pseudo-rules, we conduct the necessary DLQH queries to the DL component  in  order  to  retrieve  the  values  for  the  T-dependent  variables  of  the  H  entail-
ments.  The  resulting  rules  are  loaded  into  the  RB,  populating  it  with  the  domain 
specific dse-entailments (lines 5, 6 and 7). Finally, the rule engine runs and materializes the semantics in the form of derived triples. 

G. Meditskos and N. Bassiliades 

1.  T  load(TBox) 
2.  classify(DLKB) 
3.  A  load(ABox) 
4.  for each eA  EA do RB  load(eA) 
5.  for each prH  PR do 
6.     for each (x1,...,xn)  DLQH do  
7.          RB  load(G[prH(x1,...,xn)]) 
8.  RKB.run() 

Fig. 1. The reasoning steps involved in a production rule-based DLE system 

5   Testing the ABox Reasoning Performance 

We  conducted  experiments  to  test  the  scalability  of  the  dse-entailments  against  the 
conventional implementation of the same set of entailments in the same rule engine. 
We used three rule engines (Bossam [33], the forwardRETE rule engine of Jena [28] 
and Jess [22]) and developed six prototype implementations: three DLE-based, using 
the Pellet reasoner as the DL component, and three generic, i.e. direct implementation 
of  the  entailments  following  the  conventional  EOR  paradigm.  Each  prototype  was 
tested on the UOBM [26], Vicodi and wine ontologies1. Table 2 depicts the number of 
entailment rules that each implementation involves. Notice that:  

-  Our intention is to test the behaviour of a rule engine following the DLE and the 
generic  EOR  paradigms  and  not  to  compare  these  two  paradigms  on  different 
rule engines, since each rule engine has a different performance.   

-  We are not concerned about the completeness of reasoning, since it depends on 
the number of the implemented entailments2. We want only to test the scalability 
of the prototypes in terms of rule application time and memory utilization. 

-  The  response  time  of  queries  over  the  ABoxes  between  a  DLE-based  and  the 
corresponding generic implementation in the same rule engine is the same, since 
both approaches result in the same KB (inferred triples). 

Moreover  we  should  mention  that  a  fair  comparison  of  the  DLE  prototypes  with 
existing EOR systems that use the same rule engines is not feasible since this requires 
the implementation of the same set of entailments that the reasoners support, as well 
as to follow the same implementation principles or potential optimizations. However, 
the Bossam OWL reasoner does not provide the full set of the supported entailments, 
and the Jena  OWL reasoner and OWLJessKB implement  some semantics internally 
without entailments, such as the class intersection (Jena reasoner) or using defqueries and deffunctions (OWLJessKB). In order to conduct a fair comparison, we 
re-implemented  directly  the  same  set  of  entailments  in  the  three  rule  engines.  The 
experiments ran on Windows XP  with 3.2 GHz processor, 2 GB RAM and 1.2 GB 
maximum Java heap space.  
                                                           
1 We obtained Vicodi and wine from kaon2.semanticweb.org/download/test_ontologies.zip 
2 A set of OWL entailment rules can be found in http://www.agfa.com/w3c/euler/owl-rules 
?

?

?
Table 2. The number of the entailments involved in the DLE and Generic implementations 

 

DLE Implementations 

(dse-entailments + exceptional)

Generic Implementations 

(generic entailments) 

Vicodi 
wine 

1,164 

(16 terminological + 13 hybrid + 5 exceptional) 

Fig. 2 depicts the ABox reasoning performance of each prototype in each ontology 

dataset. Each graph displays also the memory requirements of each implementation. 
UOBM. We used a dataset of almost 810,000 triples (Fig. 2 (a)). DLE Bossam reasoned considerably faster than the Generic Bossam. In particular, it reasoned on five 
times  more triples  until it reached the  memory limit.  DLE Jena displayed a notably 
better  performance  than  the  Generic  Jena,  processing  almost  200,000  more  triples 
without  reaching  the  memory  limit.  Finally,  DLE  Jess  managed  to  process  faster  a 
dataset twice the size of the one processed by the Generic Jess. 

Vicodi. These experiments were performed on three datasets (Fig. 2 (b)). DLE Jess 
demonstrated a better performance than the Generic Jess both in terms of reasoning 
time  and  memory  utilization.  DLE  Jena  processed  the  first  two  datasets  in  almost  

)
c
e
s
(
 

e
m

i

(a) UOBM

DLE Bossam
DLE Jena
DLE Jess

Generic Bossam
Generic Jena
Generic Jess

1.2GB

1.2GB

Generic Jess

DLE Jess

Generic Jena

DLE Jena

Generic Bossam

DLE Bossam

(b) Vicodi

960MB

458MB

411MB

183MB

825MB

436MB

181MB

94MB

52MB

220K triples
110K triples
55K triples

950MB

900MB
450MB

Time (sec)

)
c
e
s
(
 

e
m

i

1.2GB

1.2GB

1.2GB
251MB

(c) wine

812MB

710MB

150MB

1GB

680MB
700MB

DLE Bossam
DLE Jena
DLE Jess

Generic Bossam
Generic Jena
Generic Jess

#triples (thousands)

#triples (thousands)

Fig. 2. Results on ABox reasoning 

G. Meditskos and N. Bassiliades 

the same time to the Generic Jena but with better memory utilization, enabling the 
processing  also  of  the  third  dataset  without  reaching  the  memory  limit.  The  same 
behaviour observed in DLE Bossam that managed to process the first two datasets 
without reaching the memory limit. In contrast to DLE Jess, DLE Bossam and DLE 
Jena seem to be affected by the number of the dse-entailments (1,159) of their rule 
base. However, the memory utilization remains still in lower levels than the generic 
prototypes. 

Wine.  The  wine  experiments  used  a  dataset  of  about  110,000  triples  (Fig.  2  (c)). 
DLE  Bossam  processed  the  dataset  significantly  faster  than  the  Generic  Bossam, 
using  half  of  the  available  memory.  Generic  Jena  displayed  a  poor reasoning  per-
formance,  while  the  DLE  Jena  managed  to  load  the  dataset  in  a  reasonable  time 
limit. Finally, Generic Jess processed only half triples than DLE Jess before reaching the memory limit.  

Fig.  3  (a)  depicts  the  TBox  reasoning  times  of  the  prototypes.  Since  the  DLE  
implementations  are  based  on  Pellet  for TBox  reasoning,  they  have  the  same  TBox 
reasoning  performance.  Except  for  the  wine  ontology,  Pellet  achieves  faster  TBox 
inferencing than the generic entailment-based approaches. Bear in mind that the generic prototypes  had been implemented  with a limited  number of T-entailments (16 
entailments), while Pellet performs full TBox reasoning. The average dse-entailments 
generation time of the three DLE-prototypes is 250 ms (lines 5, 6 and 7 in Fig. 1).  

In  order  to  give  a  gist  about  the  ABox  reasoning  performance  of  Pellet  and 
KAON2, we present in Fig. 3 (b) the time needed by Pellet, KAON2 and DLE Jena to 
retrieve the instances on some datasets (since KAON2 performs reasoning on demand 
and  thus,  a  query  is  required).  We  forced  Pellet  to  completely  realize  the  ABoxes 
which  is  close  to  the  total  materialization  approach  of  our  six  prototypes,  since  we 
used forward chaining rule engines. For TBoxes with medium and large complexity, 
i.e. many class restriction, intersection or equivalence axioms, such as the UOBM and 
wine ontologies, Pellet does not perform well compared to the DLE approach, emphasizing the need for scalable implementations. On simple TBoxes, such as the Vicodi 
ontology  which  contains  only  simple  subclass  axioms,  Pellet  performs  better,  but 
KAON2  depicts  the  best  performance,  exploiting  the  ability  to  reason  on  demand. 
However,  on  the  other  two  ontologies  of  medium  and  large  TBox  complexity,  the 
DLE  implementation  performs  better,  especially  on  UOBM,  even  if  it  follows  the  

)
c
e
s
(
 
e
m

i

0,1

(a) TBox Reasoning

Average dse-entailment generation: 250 ms

Vicodi

wine

DLEGenericDLEGenericDLEGeneric

BossamJenaJess

(b) Pellet, DLE Jena and KAON2 instance retrieval times

KAON2

Pellet

DLE Jena
94MB

47MB

83MB

475MB

)
c
e
s
(
 

e
m

i

0,1

179MB

10MB

48MB

29MB

12MB

Vicodi

wine

(24,800 triples)

(107,734 triples)

(3,619 triples)

 

Fig. 3. (a) TBox reasoning times, and (b) Pellet, KAON2 and Jena DLE instance retrieval times 
?

?

?
complete  materialization  approach.  Notice  that  the  results  of  Fig.  3  (b)  cannot  be 
considered as a fair comparison, due to the limited semantics that the DLE prototype 
supports  and  the  different  rule  paradigm  that  it  follows.  A  comparison  of  KAON2 
with a backward chaining DLE implementation would be more meaningful. However, 
Fig. 3 (b) gives a gist about the weak and strong points of each reasoning paradigm. 

6   Related Work 

To the best of our knowledge, the existing EOR systems, such as OWLJessKB [23], 
Bossam [33], BaseVISor [27], Jena [28] and OWLIM [21], follow the same approach: 
the  asserted  ontological  knowledge  is  transformed  into  facts  and  TBox  and  ABox 
entailment rules are applied. Although some systems offer the possibility to attach a 
DL reasoner for both TBox and ABox OWL reasoning, e.g. Jena, none of them has 
considered the possibility of using a DL reasoner in parallel with the rule engine for 
OWL reasoning. The DLE framework works towards this idea, combining the TBox 
inferencing capabilities of DL reasoners with the scalability of the EOR paradigm.  

In  [43]  and  [25],  the  entailments  were  enhanced  with  a  dependency  information, 
denoting the rules that should be checked after the firing of each entailment. Although 
this  improves  the  performance,  it  is  very  difficult  to  manage  such  rule  bases,  since 
any modification needs the reconfiguration of the correlations. Furthermore, our experiments have shown that it is not the number of the rules that matters most, but the 
complexity of their condition. Although the RB of the DLE approach contains more 
rules  than  the  conventional  EOR  paradigm,  the  inferencing  procedure  terminates 
faster. However, we believe that a combination of the DLE with the approach of [43] 
and [25] would increase even more the performance. 

KAON2 [19] reduces OWL into disjunctive Datalog [18]. Its reasoning procedure 
is based totally on rules and it is focused mainly on query answering. As it was mentioned  in  [35],  DL  reasoners  have  better  classification  performance  on  complex 
TBoxes than KAON2. The DLE framework tries to embed this DL TBox efficiency 
into  the  EOR  paradigm.  The  ABox  performance  of  KAON2  depends  on  the  TBox, 
having an increased performance on simple TBoxes. 

Instance Store [15] combines a DL reasoner with a relational database. The idea is 
to use the DL reasoner for TBox reasoning and the database to store the ABox. The 
limitation of this approach is that it deals only with role-free ontologies, i.e. ontologies that contain only axioms of the form i : C. However, the use of a database is the 
only  solution  when  the  ABox  exceeds  the  size  of  main  memory  (see  also  [43]  and 
Owlgres [36] for DL-Lite). DLE has been only tested in main memory. 

In [5] the embedding of different RDF entailments (including eRDFS) in F-Logic 
is presented that can be used to extend RDF or to align RDF and OWL DL. The DLE 
approach is focused only on the OWL language, defining an OWL reasoning framework based both on a DL reasoner and a rule engine. 

The  notion  of  generating  ABox  rules  in  the  conventional  EOR  paradigm  was 
briefly  introduced  in  [30]  and  [31],  where  both  the  TBox  and  ABox  reasoning  are 
performed only by a rule engine (RDF MT). DLE extends and enhances our previous 
research,  defining  a  new  EOR  reasoning  paradigm  (dedicated  to  OWL  ontologies) 
using DL reasoning for TBox inferencing and ABox entailment generation. 

G. Meditskos and N. Bassiliades 

7   Conclusions and Future Work  

In this paper we presented an approach for embedding the TBox inferencing capabilities of DL reasoners into the EOR paradigm, resulting in an OWL-oriented reasoning 
framework. In that way we are able to capture OWL TBox semantics without applying TBox entailments, as well as to enhance the EOR scalability in terms of reasoning 
time and memory utilization. This is achieved by generating engine-friendly ABox 
entailments, with less conditional elements in their body (thus less complex) than the 
corresponding generic entailments of the traditional EOR paradigm.  

We tested three DLE-based implementations against the three traditional EOR im-
plementations, using three well known rule engines. The experiments have shown that 
although the DLE prototypes need to apply more rules than the corresponding EOR, 
they achieve better reasoning performance (at least on the tested ontologies) in terms 
of rule application time and  memory  utilization. We conclude that a DLE approach 
can considerably enhance the performance of existing EOR systems (regarding OWL 
reasoning),  such  as  the  Jena,  OWLJessKB  and  Bossam  OWL  reasoners.  More  ex-
periments,  however,  need  to  be  conducted  in  order  to  investigate  the  impact  of  the 
number of the dse-entailments on the reasoning performance.  

Although we define an entailment-free TBox framework, the DLE still depends on 
entailments  for  ABox  reasoning.  Thus,  it  is  still  a  rule-based  approach  with  all  the 
modelling  strengths  and  weaknesses  comparing  it  to  the  DL  paradigm,  such  as  the 
limited modelling capabilities with incomplete information, the closed-world reasoning or the Unique Name Assumption (UNA) (see [4][34][38] for details). 

In section 4 we mentioned that DLE is a unidirectional framework able to handle 
updates only on instances. However, in the hybrid paradigm, there is the notion of the 
bidirectional combination, allowing the rule program to alter the ontological information of the DL component [8][20][46]. This would be an interesting extension of the 
DLE  framework  and  we  plan  to  implemented  it  by  indexing  appropriately  the  dseentailments in order to modify the RB according to TBox updates. 

We are working on releasing a stable, DIG-compliant and more complete, in terms 
of  supported  ABox  entailments,  Jena-based  DLE  system,  since  with  the  Jena  rule 
engine  we  achieved  the  best  combination  of  memory  utilization  and  reasoning  per-
formance. We plan also to implement a DLE system using the backward-chaining rule 
engine  of  Jena.  As  a  practical  application  of  the  DLE  framework,  we  consider  the 
domain of OWL-S Semantic Web Service discovery and composition, where there is 
the need of efficient TBox reasoning on complex TBoxes, and scalable ABox reasoning on service advertisements that point to TBox concepts (inputs/outputs). 

Acknowledgments.  This  work  was  partially  supported  by  a  PENED  program  (No. 
0373), jointly funded by the European Union and the Greek government (GSRT). 
