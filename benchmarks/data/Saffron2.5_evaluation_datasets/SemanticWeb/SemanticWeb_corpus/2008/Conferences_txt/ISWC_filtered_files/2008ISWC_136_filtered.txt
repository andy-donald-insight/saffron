The Expressive Power of SPARQL

Renzo Angles and Claudio Gutierrez

Department of Computer Science, Universidad de Chile

{rangles,cgutierr}@dcc.uchile.cl

Abstract. This paper studies the expressive power of SPARQL. The
main result is that SPARQL and non-recursive safe Datalog with negation have equivalent expressive power, and hence, by classical results,
SPARQL is equivalent from an expressiveness point of view to Relational Algebra. We present explicit generic rules of the transformations
in both directions. Among other findings of the paper are the proof that
negation can be simulated in SPARQL, that non-safe filters are super-
fluous, and that current SPARQL W3C semantics can be simplified to a
standard compositional one.

1 Introduction

Determining the expressive power of a query language is crucial for understanding its capabilities and complexity, that is, what queries a user is able to pose,
and how complex the evaluation of queries is, issues that are central considerations to take into account when designing a query language.

SPARQL, the query language for RDF, has recently become a W3C recommendation [9]. In the RDF Data Access Working Group (WG) were it was
designed, expressiveness concerns generated ample debate. Many of them remained open due to lack of understanding of the theoretical expressive power of
the language.

This paper studies in depth the expressive power of SPARQL. A first issue
addressed is the incorporation of negation. The W3C specification of SPARQL
provides explicit operators for join and union of graph patterns, even for specifying optional graph patterns, but it does not define explicitly the difference of
graph patterns. Although intuitively it can be emulated via a combination of
optional patterns and filter conditions (like negation as failure in logic program-
ming), we show that there are several non-trivial issues to be addressed if one
likes to define the difference of patterns inside the language.

A second expressiveness issue refers to graph patterns with non-safe filter, i.e.,
graph patterns (P FILTER C) for which there are variables in C not present in
P . It turns out that these type of patterns, which have non-desirable properties,
can be simulated by safe ones (i.e., patterns where every variable occurring in
C also occurs in P ). This simple result has important consequences for defining
a clean semantics, in particular a compositional and context-free one.

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 114129, 2008.
c Springer-Verlag Berlin Heidelberg 2008
?

?

?
A third topic of concern was the presence of non desirable features in the W3C
semantics like its operational character. We show that the W3C specification of
the semantics of SPARQL is equivalent to a well behaved and studied compositional semantics for SPARQL, which we will denote in this paper SPARQLC [6].
Using the above results, we are able to determine the expressive power of
SPARQL. We prove that SPARQLC and non-recursive safe Datalog with nega-

) are equivalent in their expressive power. For this, first we
tion (nr-Datalog

show that SPARQLC is contained in nr-Datalog
by defining transformations

(for databases, queries, and solutions) from SPARQLC to nr-Datalog
, and we
prove that the result of evaluating a SPARQLC query is equivalent, via the trans-

formations, to the result of evaluating (in nr-Datalog
) the transformed query.

is contained in SPARQLC using a similar
Second, we show that nr-Datalog
approach. It is important to remark that the transformations used are explicit
and simple, and in all steps bag semantics is considered.

Finally, and by far, the most important result of the paper is the proof that
SPARQL has the same expressive power of Relational Algebra under bag semantics (which is the one of SPARQL). This follows from the well known fact that

Relational Algebra has the same expressive power as nr-Datalog

[1].

The paper is organized as follows. In Section 2 we present preliminary mate-
rial. Section 3 presents the study of negation. Section 4 studies non-safe filter
patterns. Section 5 proves that the W3C specification of SPARQL and SPARQLC
are equivalent. Section 6 proves that SPARQLC and nr-Datalog have the same
expressive power. Section 7 presents the conclusions.

Related Work. The W3C recommendation SPARQL is from January 2008. Hence,
it is no surprise that little work has been done in the formal study of its expressive
power. Several conjectures were raised during the WG sessions 1. Furche et al. [3]
surveyed expressive features of query languages for RDF (including old versions
of SPARQL) in order to compare them systematically. But there is no particular
analysis of the expressive power of SPARQL.

Cyganiak [2] presented a translation of SPARQL into Relational Algebra considering only a core fragment of SPARQL. His work is extremely useful to implement and optimize SPARQL in SQL engines. At the level of analysis of expressive
issues it presented a list of problems that should be solved (many of which still
persist), like the filter scope problem and the nested optional problem.

Polleres [8] proved the inclusion of the fragment of SPARQL patterns with
safe filters into Datalog by giving a precise and correct set of rules. Schenk [10]
proposed a formal semantics for SPARQL based on Datalog, but concentrated
on complexity more than expressiveness issues. Both works do not consider bag
semantics of SPARQL in their translations.

The work of Perez et al. [6] and the technical report [7], that gave the formal
basis for SPARQLC compositional semantics, addressed several expressiveness
issues, but no systematic study of the expressive power of SPARQL was done.

1 See http://lists.w3.org/Archives/Public/public-rdf-dawg-comments/, espe-

cially the years 2006 and 2007.

R. Angles and C. Gutierrez

2 Preliminaries

2.1 RDF and Datasets

Assume there are pairwise disjoint infinite sets I, B, L (IRIs, Blank nodes, and
RDF literals respectively). We denote by T the union I  B  L (RDF terms).
A tuple (v1, v2, v3)  (I  B)  I  T is called an RDF triple, where v1 is the
subject, v2 the predicate, and v3 the object. An RDF Graph [4] (just graph from
now on) is a set of RDF triples. Given a graph G, term(G) denotes the set of
elements of T occurring in G and blank(G) denotes the set of blank nodes in G.
The union of graphs, G1  G2, is the set theoretical union of their sets of triples.
An RDF dataset D is a set {G0,u1, G1, . . . ,un, Gn} where each Gi is a
graph and each uj is an IRI. G0 is called the default graph of D and it is denoted
dg(D). Each pair ui, Gi is called a named graph; define name(Gi)D = ui and
gr(ui)D = Gi. We denote by term(D) the set of terms occurring in the graphs of
D. The set of IRIs {u1, . . . , un} is denoted names(D). Every dataset satisfies that:
(i) it always contains one default graph (which could be empty); (ii) there may
be no named graphs; (iii) each uj is distinct; and (iv) blank(Gi) blank(Gj) = 
for i = j. Finally, the active graph of D is the graph Gi used for querying D.

2.2 SPARQL

A SPARQL query is syntactically represented by a block consisting of a query
form (SELECT, CONSTRUCT or DESCRIBE), zero o more dataset clauses
(FROM and FROM NAMED), a WHERE clause, and possibly solution modifiers (e.g. DISTINCT). The WHERE clause provides a graph pattern to match
against the RDF dataset constructed from the dataset clauses.

There are two formalizations of SPARQL which will be used throughout
this study: SPARQLWG, the W3C recommendation language SPARQL [9] and
SPARQLC, the formalization of SPARQL given in [6]. We will need some general
definitions before describe briefly both languages.

Assume the existence of an infinite set V of variables disjoint from T . We
denote by var() the set of variables occurring in the structure . A tuple from
(I  L V ) (I  L V ) (I  V ) is called a triple pattern. A basic graph pattern
is a finite set of triple patterns.
A filter constraint is defined recursively as follows: (i) if ?X, ?Y  V and
u  I  L then ?X = u, ?X = ?Y , bound(?X), isIRI(?X), isLiteral(?X), and
isBlank(?X) are atomic filter constraints 2; (ii) if C1 and C2 are filter constraints
then (C1), (C1  C2), and (C1  C2) are complex filter constraints.
A mapping  is a partial function  : V  T . The domain of , dom(), is
the subset of V where  is defined. The empty mapping 0 is a mapping such
that dom(0) = . Two mappings 1, 2 are compatible, denoted 1  2, when
for all ?X  dom(1)  dom(2) it satisfies that 1(?X) = 2(?X), i.e., when
1  2 is also a mapping. The expression ?Xv denote a mapping such that
dom() = {?X} and (?X) = v.
2 For a complete list of atomic filter constraints see [9].
?

?

?
The evaluation of a filter constraint C against a mapping , denoted (C), is
defined in a three value logic with values {true, false, error} as follows:
 If C is an atomic filter constraint, excluding bound(), and var(C)  dom(),
then (C) = error; else if C is ?X = u and (?X) = u, or if C is ?X = ?Y and
(?X) = (?Y ), or if C is isIRI(?X) and (?X)  I, if C is isLiteral(?X)
and (?X)  L, if C is isBlank(?X) and (?X)  B, then (C) = true;
otherwise (C) = false.

(C1) = true; and (C) = error when (C1) = error.

 If C is bound(?X) then (C) = true if ?X  dom() else (C) = false.3
 If C is (C1) then (C) = true when (C1) = false; (C) = false when
 If C is (C1  C2) then (C) = true if either (C1) = true or (C2) = true;
 If C is (C1  C2) then (C) = true if (C1) = true and (C2) = true;
(C) = false if either (C1) = false or (C2) = false; otherwise (C) = error.
A mapping  satisfies a filter constraint C, denoted  |= C, iff (C) = true.
Consider the following operations between two sets of mappings 1, 2:

(C) = false if (C1) = false and (C2) = false; otherwise (C) = error.

1  2 = {1  2 | 1  1, 2  2 and 1  2}
1  2 = { |   1 or   2}
1 \ 2 = {1  1 |
1 \C 2 = {1  1 | for all 2  2, 1 and 2 are not compatible } 
{1  1 | for all 2  2 such that 1  2, (1  2)  C}
1 2 = (1  2)  (1 \ 2)
1 C 2 = { |   (1  2) and  |= C}  (1 \C 2)

for all 2  2, 1 and 2 are not compatible }

Syntax and Semantics of SPARQLC.
A SPARQLC graph pattern P is defined recursively by the following grammar:

GP ::= P "AND" P | P "UNION" P | P "OPT" P | P "FILTER" C |

::= t | "(" GP ")"

n "GRAPH" P

where t denotes a triple pattern, C denotes a filter constraint, and n  I  V .
The evaluation of a SPARQLC graph pattern P over an RDF dataset D having
active graph G, denoted PD
 if P is a triple pattern t, PD
G = { | dom() = var(t) and (t)  G}
where (t) is the triple obtained by replacing the variables in t according to
mapping .

G, is defined recursively as follows:

 if P is a complex graph pattern then PD

G is defined as given in Table 1.

Syntax and Semantics of SPARQLWG.
A SPARQLWG graph pattern GroupGP is defined by the following grammar4:

GroupGP
GPNotTriples

::= "{" TB? ((GPNotTriples | Filter) "."? TB?)* "}"
::= OptionalGP | GroupOrUnionGP | GraphGP

3 Functions invoked with an argument of the wrong type are evaluated to error.
4 http://www.w3.org/TR/rdf-sparql-query/#grammar. We use GP and TB to abbre-

viate GraphPattern and TriplesBlock respectively

R. Angles and C. Gutierrez

Table 1. Semantics of SPARQLC graph patterns. P1, P2 are SPARQLC graph patterns,
C is a filter constraint, u  I and ?X  V .

Graph pattern P

(P1 AND P2)

(P1 OPT P2)

(P1 UNION P2)

(P1 FILTER C)

Evaluation P D

 P2D
P1D

G P2D
P1D
 P2D
P1D

{ |   P1D
P1D

G and  |= C}

(u GRAPH P1)
(?X GRAPH P1) vnames(D)(P1D

gr(u)D

gr(v)D

 {?Xv})

::= "OPTIONAL" GroupGP
OptionalGP
GraphGP
::= "GRAPH" VarOrIRIref GroupGP
GroupOrUnionGP ::= GroupGP ( "UNION" GroupGP )*
Filter
where TB denotes a basic graph pattern (a set of triple patterns), VarOrIRIref
denotes a term in the set I  V and Constraint denotes a filter constraint. Note
that the operator {A . B} represents the AND but it has not fixed arity.

::= "FILTER" Constraint

The evaluation of a SPARQLWG graph pattern GroupGP is defined by a series
of steps, starting by transforming GroupGP, via a function T , into an intermediate
algebra expression E (with operators BGP, Join, Union, LeftJoin, Graph and
Filter), and finally evaluating E on an RDF dataset D.
The transformation T (GroupGP) is given by Algorithm 1. The evaluation of
E over an RDF dataset D having active graph G, which we will denote ED
(originally denoted eval(D(G), E) in [9]), is defined recursively as follows:
 if E is BGP(TB), ED
G = { | dom() = var(E) and (E)  G} where
(E) is the set of triples obtained by replacing the variables in the triple
patterns of TB according to mapping .
 if E is a complex expression then PD
Note 1. In the definition of graph patterns, we avoided blank nodes, because this
restriction does not diminish the generality of our study. In fact, each SPARQL
 without blank nodes in its
query Q can be simulated by a SPARQL query Q
pattern. It follows from the definitions of RDF instance mapping, solution map-
ping, and the order of evaluation of solution modifiers (see [9]), that if Q is a
 is the same query where each blank node
query with graph pattern P , and Q
 give the same
b in P has been replaced by a fresh variable ?Xb then Q and Q
results. (Note that, if Q has the query form SELECT or DESCRIBE, the  parameter is according to the specification of SPARQL an abbreviation for all
 should explicit in
variables occurring in the pattern. In this case the query Q
the SELECT clause all variables of the original pattern P .)
Note 2. SPARQLC follows a compositional semantics, whereas SPARQLWG follows a mixture of compositional and operational semantics where the meaning
of certain patterns depends on their context, e.g., lines 7 and 8 in algorithm 1.

G is defined as given in Table 2.
?

?

?
) then E  LeftJoin(E, E

Algorithm 1. Transformation of SPARQLWG patterns into algebra expressions.
1: // Input: a SPARQLWG graph pattern GroupGP
2: // Output: an algebra expression E = T (GroupGP)
3: E  empty pattern; F S  
4: for each syntactic form f in GroupGP do
if f is TB then E  Join(E, BGP(TB))
5:
if f is OPTIONAL GroupGP1 then
6:

if T (GroupGP1) is Filter(F, E
7:
else E  LeftJoin(E, T (GroupGP1), true)
8:
if f is GroupGP1 UNION  UNION GroupGPn then
9:
if n > 1 then
10:
11:
12:
13:
14:
15:
16:
17:
18: end for
19: if F S =  then E  Filter(F S, E)
20: return E

end if
if f is GRAPH VarOrIRIref GroupGP1 then
E  join(E, Graph(VarOrIRIref, T (GroupGP1)))
if f is FILTER constraint then F S  (F S  constraint)

  Union( (Union(T (GroupGP1), T (GroupGP2)) ), T (GroupGPn))

else E
E  Join(E, E

  T (GroupGP1)

, F )

)
?

?

?
Table 2. Semantics of SPARQLWG graph patterns. A pattern GroupGP is transformed
into an algebra expression E using algorithm 1. Then E is evaluated as the table shows.
E1 and E2 are algebra expressions, C is a filter constraint, u  I and ?X  V .

Algebra Expression E

Join(E1, E2)

LeftJoin(E1, E2, C)

Union(E1, E2)

Filter(C, E1)

Graph(u, E1)

Graph(?X, E1)

Evaluation ED
G  E2D
E1D
G CE2D
E1D
E1D
 E2D
{  |   E1D
E1D
v  names(D)(E1D

gr(u)D

G and  |= C}

 {?Xv})

gr(v)D

Note 3. In this paper we will follow the simpler syntax of SPARQLC, better suited to do formal analysis and processing than the syntax presented by
SPARQLWG. There is an easy and intuitive way of translating back and forth
between both syntax formalisms, which we will not detail here.

2.3 Datalog

We will briefly review notions of Datalog (For further details and proofs see [1,5]).
A term is either a variable or a constant. An atom is either a predicate formula
p(x1, ..., xn) where p is a predicate name and each xi is a term, or an equality

R. Angles and C. Gutierrez

formula t1 = t2 where t1 and t2 are terms. A literal is either an atom (a positive
literal L) or the negation of an atom (a negative literal L).
A Datalog rule is an expression H  B where H is a positive literal called
the head 5 of the rule and B is a set of literals called the body. A rule is ground
if it does not have any variables. A ground rule with empty body is called a fact.
A Datalog program  is a finite set of Datalog rules. The set of facts occurring in , denoted facts(), is called the initial database of . A predicate is
extensional in  if it occurs only in facts(), otherwise it is called intensional.
A Datalog program is non-recursive and safe if it does not contain any predicate that is recursive in the program and it can only generate a finite number
of answers. In what follows, we only consider non-recursive and safe programs.
A substitution  is a set of assignments {x1/t1, . . . , xn/tn} where each xi is a
variable and each ti is a term. Given a rule r, we denote by (r) the rule resulting
of substituting the variable xi for the term ti in each literal of r.

The meaning of a Datalog program , denoted facts

(), is the database
resulting from adding to the initial database of  as many new facts of the
form (L) as possible, where  is a substitution that makes a rule r in  true
and L is the head of r. Then the rules are applied repeatedly and new facts
are added to the database until this iteration stabilizes, i.e., until a fixpoint is
reached.



A Datalog query Q is a pair (, L) where  is a Datalog program and L is
a positive (goal) literal. The answer to Q over database D = facts(), denoted
ansd(Q, D) is defined as the set of substitutions { | (L)  facts

()}.



2.4 Comparing Expressive Power of Languages

By the expressive power of a query language, we understand the set of all queries
expressible in that language [1,5]. In order to determine the expressive power of
 and
a query language L, usually one chooses a well-studied query language L
 in their expressive power. Two query languages have the
compares L and L
same expressive power if they express exactly the same set of queries.
A given query language is defined as a quadruple (Q,D,S, eval), where Q is a
set of queries, D is a set of databases, S is a set of solutions, and eval : QD  S
is the evaluation function. The evaluation of a query Q  Q on a database D  D
is denoted eval(Q, D). Two queries Q1, Q2  Q are equivalent, denoted Q1  Q2,
if eval(Q1, D) = eval(Q2, D) for every D  D.
Let L1 = (Q1,D1,S1, eval1) and L2 = (Q2,D2,S2, eval2) be two query lan-
guages. We say that L1 is contained in L2 if and only if there are bijective
data transformations TD : D1  D2 and TS : S1  S2, and query transformation TQ : Q1  Q2, such that for all Q  Q1 and D  D1 it satisfies that
TS(eval1(Q, D)) = eval2(TQ(Q),TD(D)). We say that L1 and L2 are equivalent
if and only if L1 is contained in L2 and L2 is contained in L1. (Note that if L1
and L2 are subsets of a language L, then TD, TS and TQ are the identity.)

5 We may assume that all heads of rules have only variables by adding the correspond-

ing equality formula to its body.
?

?

?
3 Expressing Difference of Patterns in SPARQLWG

The SPARQLWG specification indicates that it is possible to test if a graph
pattern does not match a dataset, via a combination of optional patterns and
filter conditions (like negation as failure in logic programming)([9] Sec. 11.4.1).
In this section we analyze in depth the scope and limitations of this approach.
We will introduce a syntax for the difference of two graph patterns P1 and
P2, denoted (P1 MINUS P2), with the intended informal meaning: the set of
mappings that match P1 and does not match P2. Formally:

\ P2D
G.

G = P1D

Definition 1. Let P1, P2 be graph patterns and D be a dataset with active graph
G. Then (P1 MINUS P2)D
A naive implementation of the MINUS operator in terms of the other operators
would be the graph pattern ((P1 OPT P2) FILTER C) where C is the filter con-
straint
( bound(?X)) for some variable ?X  var(P2) \ var(P1). This means that for
each mapping   (P1 OPT P2)D
G at least one variable ?X occurring in P2,
but not occurring in P1, does not match (i.e., ?X is unbounded). There are two
problems with this solution:

 Variable ?X cannot be an arbitrary variable. For example, P2 could be in
turn an optional pattern (P3 OPT P4) where only variables in P3 are relevant.
 If var(P2) \ var(P1) =  there is no variable ?X to check unboundedness.
The above two problems motivate the introduction of the notions of non-optional
variables and copy patterns.

The set of non-optional variables of a graph pattern P , denoted nov(P ), is a
subset of the variables of P defined recursively as follows: nov(P ) = var(P ) when
P is a basic graph pattern; if P is either (P1 AND P2) or (P1 UNION P2) then
nov(P ) = nov(P1)nov(P2); if P is (P1 OPT P2) then nov(P ) = nov(P1); if P is
(n GRAPH P1) then either nov(P ) = nov(P1) when n  I or nov(P ) = nov(P1)
{n} when n  V ; and nov(P1 FILTER C) = nov(P1). Intuitively nov(P ) contains
the variables that necessarily must be bounded in any mapping of P .
Let  : V  V be a variable-renaming function. Given a graph pattern P , a
copy pattern (P ) is an isomorphic copy of P whose variables have been renamed
according to  and satisfying that var(P )  var((P )) = .

Theorem 1. Let P1 and P2 be graph patterns. Then:

(P1 MINUS P2)  ((P1 OPT((P2 AND (P2)) FILTER C1)) FILTER C2)

(1)

where:

 C1 is the filter constraint (?X1 =?X
 C2 is the filter constraint ( bound(?X

i = (?Xi) for 1  i  n.
?

?

?
and ?X
?

?

?
 ?Xn =?X
)) for some ?X

n) where ?Xi  var(P2)
?

?

?
  nov((P2)).

R. Angles and C. Gutierrez

Note 4 (Why the copy pattern (P ) is necessary?).
Consider the naive implementation of difference of patterns, that is the graph
pattern ((P1 OPT P2) FILTER C) where C is the filter constraint ( bound(?X))
for some ?X  var(P2)\var(P1). Note that such implementation would fail when
var(P2) \ var(P1) = , because there exist no variables to check unboundedness.
To solve this problem, P2 is replaced by ((P2 AND (P2)) FILTER C1) where
(P2) is a copy of P2 whose variables have been renamed and whose relations
of equality with the original ones are in condition C1. Then we can use some
variable from (P2) to check if the graph pattern P2 does not match. The copy
pattern ensure that there will exist a variable to check unboundedness.

Note 5 (Why non-optional variables?). Consider the graph pattern

P = ((?X, name, ?N) MINUS((?X, knows, ?Y ) OPT(?Y, mail, ?Z))).

The naive implementation of P would be the graph pattern
= ((P1 OPT P2) FILTER( bound(?Z))),
?

?

?
Note that the evaluation of graph pattern P

where P1 = (?X,name, ?N), P2 = ((?X,knows, ?Y ) OPT(?Y,mail, ?Z)) and ?Z
is the variable selected to check unboundedness. (Note that variable ?Y could
also have been selected because ?Y  var(P2) \ var(P1).)
 differs from that of pattern P . To
see the problem recall the informal semantics: a mapping  matches the pattern
P if and only if  matches P1 and  does not match P2. This latter condition
means: it is false that every variable in P2 (but not in P1) is bounded. But to say
every variable is not correct in this context, because P2 contains the optional
pattern (?Y,mail, ?Z), and its variables could be unbounded for some valid solutions of P2. The problem is produced by the expression ( bound(?Z)), because
the bounding state of variable ?Z introduces noise when testing if pattern P2
gets matched.

Now, if we ensure the selection of a non-optional variable to check unboundedness when transforming P , we have that ?Y is the unique non-optional variable
occurring in P2 but not occurring in P1, i.e., variable ?Y works exactly as the
test to check if a mapping matching P1 matches P2 as well. Hence, instead of
, the graph pattern
?

?

?
= ((P1 OPT P2) FILTER( bound(?Y )))

is the one that expresses faithfully the graph pattern (P1 MINUS P2), and in
fact, the evaluation of P

 gives exactly the same set of mappings as P .

4 Avoiding Unsafe Patterns in SPARQLWG

One influential point in the evaluation of patterns in SPARQLWG is the behavior
of filters. What is the scope of a filter? What is the meaning of a filter having
variables that do not occur in the graph pattern to be filtered?
?

?

?
It was proposed in [6] that for reasons of simplicity for the user and cleanness
of the semantics, the scope of filters should be the expression which they filter,
and free variables should be disallowed in the filter condition. Formally, a graph
pattern of the form (P FILTER C) is said to be safe if var(C)  var(P ). In [6]
only safe filter patterns were allowed in the syntax, and hence the scope of the
filter C is the pattern P which defines the filter condition. This approach is
further supported by the fact that non-safe filters are rare in practice.

The WG decided to follow a different approach, and defined the scope of a

filter condition C to be a case-by-case and context-dependent feature:

1. The scope of a filter is defined as follows: a filter is a restriction on solutions

over the whole group in which the filter appears.

2. There is one exception, though, when filters combine with optionals. If a filter
expression C belongs to the group graph pattern of an optional, the scope
of C is local to the group where the optional belongs to. This is reflected in
lines 7 and 8 of Algorithm 1.

The complexities that this approach brings were recognized in the discussion
of the WG, and can be witnessed by the reader by following the evaluation of
patterns in SPARQLWG.

Let SPARQLSafe

WG be the subset of queries of SPARQLWG having only filtersafe patterns. In what follows, we will show that, in SPARQLWG, non-safe filters
are superfluous, and hence its non-standard and case-by-case semantics can be
avoided. In fact, we will prove that non-safe filters do not add expressive power
to the language, or in other words, that SPARQLWG and SPARQLSafe
WG have the
same expressive power, that is, for each pattern P there is a filter-safe pattern
 which computes exactly the same mappings as P .

The transformation safe(P ) is given by Algorithm 2. This algorithm works
as the identity for most patterns. The key part is the treatment of patterns
which combine filters and optionals. Line 9 is exactly the codification of the
WG evaluation of filters inside optionals. For non-safe filters (see lines 15-20), it
, where a free variable occurs, by either an
replaces each atomic filter condition C
 is bound(); or an expression bound(a) otherwise. (note
expression false when C
that bound(a) is evaluated to a logical value of error because a is a constant.)

Note 6 (On Algorithm 2). The expression in line 9 must be refined for bag
semantics to the expression:

  (((safe((P1 AND P3) FILTER C) UNION (safe(P1) MINUS safe(P3)))

UNION (safe(P1) MINUS(safe(P1) MINUS safe(P3))))

MINUS safe((P1 AND P3) FILTER C))

Lemma 1. For every pattern P , the pattern safe(P ) defined by Algorithm 2 is
filter-safe and it holds P = safe(P ).
Thus we proved:

Theorem 2. SPARQLWG and SPARQLSafe

WG have the same expressive power.

R. Angles and C. Gutierrez

  

else P

  safe(P )

if P2 is (P3 FILTER C) then

  (safe(P1) OPT(safe((P1 AND P3) FILTER C)))

  (safe(P1) OPT safe(P2))

  (safe(P1) AND safe(P2))
  (safe(P1) UNION safe(P2))
  (n GRAPH safe(P1))

Algorithm 2. Transformation of a general graph pattern into a safe pattern.
1: // Input: a SPARQLWG graph pattern P
2: // Output: a safe graph pattern P
3: P
4: if P is (P1 AND P2) then P
5: if P is (P1 UNION P2) then P
6: if P is (n GRAPH P1) then P
7: if P is (P1 OPT P2) then
8:
9:
10:
11: end if
12: if P is (P1 FILTER C) then
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25: end if
26: return P

if var(C)  var(safe(P1)) then P
else
for all ?X  var(C) and ?X / var(safe(P1)) do
for all atomic filter constraint C
if C

end for
end for
  (safe(P1) FILTER C)

  (safe(P1) FILTER C)

Replace in C the constraint C

by bound(a) //where a is a constant

else if C

is bound(?X) then

Replace in C the constraint C

by false

is (?X = u) or (?X =?Y ) or isIRI(?X) or isBlank(?X) or isLiteral(?X)

in C
?

?

?
end if

5 Expressive Power of SPARQLWG is Equivalent to

SPARQLC

As we have been showing, the semantics that the WG gave to SPARQL departed
in some aspects from a compositional semantics. We also indicated that there
is an alternative formalization, with a standard compositional semantics, which
was called SPARQLC [6].

The good news is that, albeit apparent differences, these languages are equiv-

alent in expressive power, that is, they compute the same class of queries.

Theorem 3. SPARQLSafe

WG is equivalent to SPARQLC under bag semantics.

The proof of this theorem is an induction on the structure of patterns. The only
non-evident case is the particular evaluation of filters inside optionals where
WG and SPARQLC differ. Specifically, given a graph
the semantics of SPARQLSafe
pattern P = (P1 OPT(P2 FILTER C)), we have that SPARQLSafe
WG evaluates the
algebra expression LeftJoin(P1, P2, C), whereas SPARQLC evaluates P to the
expression P1P2 FILTER C, which is the same as the SPARQLWG algebra
expression LeftJoin(P1, Filter(C, P2), true).
?

?

?
The Expressive Power of SPARQL

In this section we study the expressive power of SPARQLC by comparing it
against non recursive safe Datalog with negation (just Datalog from now on).

Note that because SPARQLC and Datalog programs have different type of
input and output formats, we have to normalize them to be able to do the
comparison. Following definitions in section 2.4, let Ls = (Qs,Ds,Ss, anss) be
the SPARQLC language, and Ld = (Qd,Dd,Sd, ansd) be the Datalog language.
In this comparison we restrict the notion of SPARQLC Query to a pair (P, D)

where P is a graph pattern and D is an RDF dataset.

6.1 From SPARQLC to Datalog
To prove that Ls is contained in Ld, we define transformations TQ : Qs  Qd,
TD : Ds  Dd, and TS : Ss  Sd. That is, TQ transforms a SPARQLC query into
a Datalog query, TD transforms an RDF dataset into a set of Datalog facts, and
TS transforms a set of SPARQLC mappings into a set of Datalog substitutions.
RDF datasets as Datalog facts. Given a dataset D, the transformation TD(D)
works as follows: each term t in D is encoded by a fact iri(t), blank(t) or literal(t)
when t is an IRI, a blank node or a literal respectively; the set of terms in D
is defined by the set of rules term(X)  iri(X), term(X)  blank(X), and
term(X)  literal(X); the fact N ull(null) encodes the null value 6; each triple
(v1, v2, v3) in the default graph of D is encoded by a fact triple(g0, v1, v2, v3);
each named graph u, G in D is encoded by a fact graph(u) and each triple in
G is encoded by a fact triple(u, v1, v2, v3).
SPARQLC mappings as Datalog substitutions. Given a graph pattern P , a dataset
D with default graph G, and the set of mappings  = PD
G. The transformation
TS() returns a set of substitutions defined as follows: for each mapping   
there exists a substitution   TS() satisfying that, for each x  var(P ) there
exists x/t   such that t = (x) when (x) is bounded and t = null otherwise.
Graph patterns as Datalog rules. Let P be a graph pattern to be evaluated
against an RDF graph identified by g which occurs in dataset D. We denote by
(P, g)D the function which transforms P into a set of Datalog rules. Table 3
shows the transformation rules defined by the function (P, g)D. The notion of
compatible mappings is implemented by the rules:
comp(X, X, X)  term(X), comp(X, null, X)  term(X),
comp(null, X, X)  term(X) and comp(X, X, X)  N ull(X).

Let ?X, ?Y  V and u  I  L. An atomic filter condition C is encoded by
a literal L as follows: if C is either (?X = u) or (?X=?Y) then L is C; if C is
(isIRI(?X)) then L is iri(?X); if C is (isLiteral(?X)) then L is literal(?X); if C
is (isBlank(?X)) then L is blank(?X); if C is (bound(?X)) then L is N ull(?X).
The transformation follows essentially the intuitive transformation presented
by Polleres [8] with the improvement of the necessary code to support faithful

6 We use the term null to represent an unbounded value.

R. Angles and C. Gutierrez

Table 3. Transforming SPARQLC graph patterns into Datalog Rules. D is a dataset
having active graph identified by g. var(P ) denotes the tuple of variables obtained from
a lexicographical ordering of the variables in the graph pattern P . Each pi is a predicate
identifying the graph pattern Pi. If L is a literal, then j (L) denotes a copy of L with
its variables renamed according to a variable renaming function j : V  V . cond is
a literal encoding the filter condition C. Each P1i is a copy of P1 and ui  names(D).
P3 = (P1 AND P2), P4 = (P1 FILTER C1) and P5 = (P1 FILTER C2).

Pattern P

(x1, x2, x3)

(P1 AND P2)

(P, g)D
p(var(P ))  triple(g, x1, x2, x3)
p(var(P ))  1(p1(var(P1)))  2(p2(var(P2)))

xvar(P1)var(P2) comp(1(x), 2(x), x),
(P1, g)D , (P2, g)D
dom(1) = dom(2) = var(P1)  var(P2), range(1)  range(2) = .

(P1, g)D

(P1 FILTER C) p(var(P ))  p1(var(P1))  cond
C is atomic
(P1 FILTER C) p(var(P ))  p1(var(P1))  p4(var(P1)),
C is ((C1))
(P1 FILTER C) p(var(P ))  p1(var(P1))  p

(var(P1))  p1(var(P1))  p
C is (C1  C2)

(var(P1)),
(var(P1))  p4(var(P1))  p5(var(P1)),
?

?

?
(P1, g)D , (P4, g)D

(var(P1)),
?

?

?
p
p
(P4, g)D , (P5, g)D

(P1 FILTER C) p(var(P ))  p1(var(P1))  p

(var(P1))  p1(var(P1))  p
C is (C1  C2)

(var(P1))  p4(var(P1)),

(var(P1))  p5(var(P1)),
?

?

?
p
p
p
(P4, g)D , (P5, g)D

(var(P1)),
?

?

?
(var(P1))
?

?

?
1(var(P1)) xvar(P2)x /var(P1) N ull(x),

(P1 OPT P2)

(P1 UNION P2) p(var(P ))  p1(var(P1)) xvar(P2)x /var(P1) N ull(x),
p(var(P ))  p2(var(P2)) xvar(P1)x /var(P2) N ull(x),
(P1, g)D , (P2, g)D
p(var(P ))  p1(var(P1))  p
p(var(P ))  p3(var(P3)),
1(var(P1))  p3(var(P3)),

p
(P1, g)D , (P2, g)D , (P3, g)D
p(var(P ))  p1(var(P1)),
(P1, u)D

(u GRAPH P1)
and u  I
(?X GRAPH P1) p(var(P ))  p11(var(P11))  graph(?X)  ?X = u1,
and ?X  V (P11, u1)D,

 
p(var(P ))  p1n(var(P1n))  graph(?X)  ?X = un,
(P1n, un)D
?

?

?
translation of bag semantics. Specifically, we changed the transformations for
complex filter expressions by simulating them with double negation.
SPARQLC queries as Datalog queries. Given a graph pattern P , a dataset D
with default graph G, and the SPARQLC query Q = (P, D). The function
TQ(Q) returns the Datalog query (, p(var(P ))) where  is the Datalog program TD(D)  (P, g0)D, g0 identifies the default graph G, and p is the goal
literal related to P .

The following theorem states that the above transformations work well.

Theorem 4. SPARQLC is contained in non-recursive safe Datalog with negation.

6.2 From Datalog to SPARQLC
Q : Qd  Qs,
To prove that Ld is contained in Ls, we define transformations T 
T 
S : Sd  Ss. That is, T 
D : Dd  Ds, and T 
Q transforms a Datalog query into an
SPARQLC query, T 
D transforms a set of Datalog facts into an RDF dataset, and
T 
S transforms a set of Datalog substitutions into a set of SPARQLC mappings.
Datalog facts as an RDF Dataset. Given a Datalog fact f = p(c1, ..., cn), consider
that desc(f) = { ( :b,predicate,p), ( :b,rdf: 1,c1),. . . ,( :b,rdf: n,cn) }, where :b
is a fresh blank node. Given a set of Datalog facts F , we have that T 
D(F ) returns
an RDF dataset with default graph {desc(f) | f  F}, where blank(desc(fi)) 
blank(desc(fj)) =  for each fi, fj  F with i = j.
Datalog substitutions as SPARQLC mappings. Given a set of substitutions ,
the transformation T 
S() returns a set of mappings defined as follows: for each
substitution    there exists a mapping   T 
S() satisfying that, if x/t  
then x  dom() and (x) = t.
Datalog rules as SPARQLC graph patterns. Let  be a Datalog program, and L
be a literal p(x1, . . . , xn) where p is a predicate in  and each xi is a variable. We
define the function gp(L) which returns a graph pattern encoding the program
(, L), that is, the fragment of the program  used for evaluating literal L.

The translation works intuitively as follows:

(b) If predicate p is intensional, then for each rule in  of the form

(a) If predicate p is extensional, then gp(L) returns the graph pattern
((?Y, predicate, p) AND(?Y, rdf: 1, x1) AND  AND(?Y, rdf n, xn)),
where ?Y is a fresh variable.
L  p1    ps  q1    qt  Leq
where Leq
gp(L) returns a graph pattern with the structure
((( ((gp(p1) AND  AND gp(ps))

   Leq
u ,

k are literals of the form t1 = t2 or (t1 = t2), we have have that

MINUS gp(q1)) ) MINUS gp(qt))
FILTER(Leq

   Leq

u )).

(2)

The formal definition of gp(L) is Algorithm 3.

R. Angles and C. Gutierrez
?

?

?
i) = xi
?

?

?
do

  gp(q)
AND gp(q))

if P
else P
end for
for each negative literal q(y1, . . . , ym) in the body of r

Let ?Y be a fresh variable
P  ((?Y, predicate, p) AND(?Y, rdf: 1, x1) AND  AND(?Y, rdf n, xn))
for each rule r   with head p(x

  

C  

= (r) where  is a substitution such that (x
Let r
for each positive literal q(y1, . . . , ym) in the body of r
=  then P
  (P

Algorithm 3. Transformation of Datalog rules into SPARQLC graph patterns
1: //Input: a literal L = p(x1, . . . , xn) and a Datalog program 
2: //Output: a SPARQLC graph pattern P = gp(L)
3: P  
4: if predicate p is extensional in  then
5:
6:
7: else if predicate p is intensional in  then
?

?

?
n) do
1, . . . , x
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31: end if
32: return P

end for
  (P
if C =  then P
if P =  then P  P

else P  (P UNION P
?

?

?
end for
for each negative literal (t1 = t2) in r

if C =  then C  (t1 = t2)
else C  C  (t1 = t2)

end for
for each equality formula t1 = t2 in r

if C =  then C  (t1 = t2)
else C  C  (t1 = t2)

MINUS gp(q))

  (P
?

?

?
FILTER C)

end for
?

?

?
do

 do
?

?

?
do
?

?

?
)

Datalog queries as SPARQLC queries. Given a Datalog program , a literal
L = p(x1, . . . , xn), and the Datalog query Q = (, L). The function T 
Q(Q)
returns the SPARQLC query (P, D) where P is the graph pattern gp(L) and
D is an RDF dataset with default graph T 

D(facts()).

The following theorem states that the above transformations work well.

Theorem 5. nr-Datalog is contained in SPARQLC.

7 Conclusions

We have studied the expressive power of SPARQL. Among the most important
findings are the definition of negation, the proof that non-safe filter patterns are
superfluous, the proof of the equivalence between SPARQLWG and SPARQLC.
?

?

?
From these results we can state the most relevant result of the paper:

Theorem 6 (main). SPARQLWG has the same expressive power as Relational
Algebra under bag semantics.
This result follows from the well known fact (for example, see [1] and [5]) that
relational algebra and non-recursive safe Datalog with negation have the same
expressive power, and from theorems 2, 3, 4 and 5.

Relational Algebra is probably one of the most studied query languages, and
has become a favorite by theoreticians because of a proper balance between
expressiveness and complexity. The result that SPARQL is equivalent in its expressive power to Relational Algebra, has important implications which are not
discussed in this paper. Some examples are the translation of some results from
Relational Algebra into SPARQL, and the settlement of several open questions
about expressiveness of SPARQL, e.g., the expressive power added by the operator bound in combination with optional patterns. Future work includes the
development of the manifold consequences implied by the Main Theorem.

Acknowledgments. R. Angles was supported by Mecesup project No.
UCH0109. R. Angles and C. Gutierrez were supported by FONDECYT project
No. 1070348. The authors wish to thank the reviewers for their comments.
