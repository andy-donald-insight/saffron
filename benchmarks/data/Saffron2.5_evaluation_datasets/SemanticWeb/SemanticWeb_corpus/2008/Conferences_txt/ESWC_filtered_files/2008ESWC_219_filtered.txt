dRDF: Entailment for Domain-Restricted RDF

Reinhard Pichler1, Axel Polleres2, Fang Wei1, and Stefan Woltran1

1 Institut f ur Informationssysteme, Technische Universit at Wien, Austria

{pichler,wei,woltran}@dbai.tuwien.ac.at

2 Digital Enterprise Research Institute (DERI), National University of Ireland, Galway

axel.polleres@deri.org

Abstract. We introduce domain-restricted RDF (dRDF) which allows to associate an RDF graph with a fixed, finite domain that interpretations for it may
range over. We show that dRDF is a real extension of RDF and discuss impacts
on the complexity of entailment in dRDF. The entailment problem represents the
key reasoning task for RDF and is well known to be NP-complete. Remarkably,
we show that the restriction of domains in dRDF raises the complexity of entailment from NP- to  P
2 -completeness. In order to lower complexity of entailment
for both domain-restricted and unrestricted graphs, we take a closer look at the
graph structure. For cases where the structure of RDF graphs is restricted via
the concept of bounded treewidth, we prove that the entailment is tractable for
unrestricted graphs and coNP-complete for domain-restricted graphs.

1 Introduction

The Resource Description Framework [18] provides means to publish and share metadata on the Web in a machine readable form. One of the features of RDF is to express
incomplete metadata by so-called blank nodes, which allow to make statements about
unknown resources, such as I know somebody called Tim Berners-Lee (but I dont
know the URI identifying him). In a sense, blank nodes can be viewed as existential variables in the data. In certain circumstances however, it is conceivable that more
refined statements could be made about this somebody. Normally, an RDF graph is
interpreted over an infinite set of resources. However, one often has a concrete set of
resources in mind when writing RDFs. For instance, we want to be able to say: I
dont know the URI identifying Tim, but I know that it is one of the URIs listed at:
http://www.example.org/w3c-people, i.e. we want to assign blank nodes
only to certain URIs from a restricted, finite set, but we just do not know which one.

In this paper, we introduce and investigate so-called domain-restricted RDF (dRDF)
graphs which allow to define exactly such restrictions. Domain-restricted RDF graphs
are graphs for which interpretations are bound to a fixed, finite domain.

Example 1. The RDF graphs in Fig. 1 model collaboration links between various peo-
ple. In the figure and subsequent examples, we use :b1, :b2, ..., :bn to denote blank
nodes, quoted strings for literals of L, and colon separated pairs of alphanumeric strings

 The work of Axel Polleres has been supported by the European FP6 project inContext (IST-

034718) and by Science Foundation Ireland under the Lion project (SFI/02/CE1/I131).

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 200214, 2008.
c Springer-Verlag Berlin Heidelberg 2008
?

?

?
G1

G2

G3

( :b1,foaf:name,"Fang"),
( :b2,foaf:name,"Stefan"),
( :b3,foaf:name,"Reini"),
( :b1,:worksWith, :b2),
( :b2,:worksWith, :b3)

( :b1,foaf:name,"Stefan"),
( :b2,foaf:name,"Reini"),
( :b3,foaf:name,"Fang"),
( :b1,:worksWith, :b2),
( :b3,:worksWith, :b1),
( :b1,:worksWith, :b3),
( :b4,foaf:name,"Axel"),
( :b1,:worksWith, :b4)

( :b2,foaf:name,"Stefan"),
( :b1,foaf:name,"Axel"),
( :b2,:worksWith, :b1)

Fig. 1. Fictitious collaboration graphs published by Fang, Stefan W. and Stefan D

where the prefix may be empty for QNames/URIs.1 Graphs are sets of triples, as usual.
The two fictitious graphs G1 and G2 describe metadata we assume to be published by
two of the authors of this paper working at TU Vienna, Fang and Stefan. Fangs graph
only talks about current employees of TU Vienna, Stefans graph talks about current
and past employees of TU Vienna, whereas G3 denotes collaboration links of Stefan
Decker, who talks in his graph only about current DERI employees. Even if we assume
that lists of URIs to denote these domains 2 are published at some Web referenceable
address, current RDF does not provide means to allow the respective publishers of the
graphs G1  G3 to express or reference the domain they are talking about. dRDF fills
exactly this gap.

The key reasoning task for RDF is deciding whether the information in one RDF graph
is subsumed by what is said by another RDF graph  the RDF entailment problem.
Entailment should intuitively be affected by restricting the domain of a graph. For in-
stance, the graph G3 is subsumed by G2 modulo blank node renaming. Nevertheless,
since these graphs talk about different domains, a reasoning engine aware of these domain restrictions should not conclude entailment here.

It is well known that blank nodes raise the complexity of the entailment problem
to NP-completeness [14]. A major goal of this work is to search for realistic restrictions which might ensure tractability of the entailment problem. We thus study two
kinds of restrictions: one is the restriction to a fixed, finite domain (i.e., dRDF) mentioned above. The other one is the restriction of the graph structure of the (RDF or
dRDF) graphs. More precisely, we investigate the entailment problem for graphs having bounded treewidth, which can be thought of as a generalization of acyclicity. It has
been successfully applied to graph-related problems in many areas [3,8] where otherwise intractable problems have been proved to become tractable if the underlying graph
structure has bounded treewidth.

One may expect that both kinds of restrictions decrease the complexity of the entailment problem. Somewhat surprisingly, we will show that the restriction to finite domains

1 We use QNames in the sense of RDF notations such as Turtle [2], where e.g. foaf:name,
:axel, or :worksWith stand for full URIs, but we leave out the actual namespace prefixes
here, as they do not matter for illustration.

easy to obtain.

Institutes

2 Complete lists of URIs denoting all employees of TU Vienna, DERI, etc. should
be
e.g.
http://www.deri.ie/about/team/ or http://www.dbai.tuwien.ac.at/
staff/. It would be easy to write e.g. a GRDDL [9] transformation for those pages which
creates lists of unique identifiers for their respective team members.

typically already do publish this data,

see

R. Pichler et al.

does not help at all. In contrast, it even increases the complexity of entailment up to the
second level of the polynomial complexity hierarchy, viz. to  P
2 -completeness. On the
other hand, we will show that the restriction to RDF graphs of bounded treewidth indeed
makes the entailment problem tractable. We will present a polynomial-time algorithm
for this case. Actually, also for dRDF graphs, bounded treewidth decreases the complexity of entailment by one level in the polynomial hierarchy; we thus end up with
coNP-completeness rather than  P

2 -completeness.

Our complexity results are summarized as follows. Note that the case of infinite

resources and no restriction on the treewidth is well known to be NP-complete [14].

finite domain-restricted graphs unrestricted graphs

bounded treewidth
unbounded treewidth

coNP-complete
p
2-complete

in P

NP-complete

The remainder of this paper is organized as follows. In Section 2 we will first review
the formal definitions of RDFs syntax and semantics and introduce domain-restricted
RDF (dRDF) along the way. In this section we will also prove some important theoretical properties concerning general RDF entailment vs. dRDF entailment. The complexity of the entailment problem in case of domain-restricted RDF is dealt with in
Section 3. The effect of bounded treewidth without or with domain-restriction is investigated in Section 4 and Section 5, respectively. We wrap up the paper with an outlook
to related and future works and draw conclusions in Sections 6 and 7. For an extended
version of this paper including more detailed proofs we refer to [22].

2 Preliminaries

In this paper, we exclusively deal with simple RDF entailment, i.e., without giving any
special semantics to the RDF(S) vocabulary. For short, we shall therefore use the term
RDF entailment throughout this paper in order to refer to simple RDF entailment.
For the definition of the syntax and semantics of RDF graphs, we find the notation
given in [14] more convenient than the one used for defining the standard semantics
in [10]. It should be noted that for simple interpretations which we consider here both
approaches are equivalent, apart from the fact that plain literals are ignored in [14]. It
can be easily verified that our complexity results also hold if we stick literally to the
definitions in [10].

2.1 RDF Graphs and Domain-Restricted RDF Graphs

We consider an infinite set U (RDF URI references), an infinite set B (blank nodes, also
referred to as variables), and an infinite set L (RDF literals). An RDF triple is a triple
of the form (v1, v2, v3)  (U  B)  U  (U  B  L). In such a triple, v1 is called
the subject, v2 the predicate, and v3 the object. The union of the sets U and L is often
denoted by UL, and likewise, U  B  L is often denoted by UBL.

An RDF graph (or simply a graph) is a set of RDF triples. A subgraph is a subset of
a graph. The vocabulary of a graph G, denoted by ULG, is the set of elements of UL
?

?

?
occurring in triples of G. A graph is ground if it has no blank nodes. RDF graphs are
often represented as edge-labeled, directed graphs where a triple (a, b, c) is represented
by a b c.
A map is a function : UBL  UBL preserving URIs and literals, i.e., (v) = v
for all v  UL. We define (G) := {((s), (p), (o)) | (s, p, o)  G}. A graph G
is
an instance of G if there exists a map  with G = (G). With some slight ambiguity
we say that there exists a map : G1  G2 if there is a map : UBL  UBL, such
that (G1) is a subgraph of G2. Let G1 and G2 be graphs. The union G1  G2 is the
set-theoretical union of their sets of triples.
Let D  UL be a non-empty set of URI references and literals and G be an RDF
graph. A domain-restricted RDF graph (dRDF graph) is a pair G, D. Graphs such
that |D| = n is finite are also called finitely restricted (or simply restricted for short);
graphs with D = UL are also called unrestricted graphs. Sightly abusing notation,
instead of G, UL we also write G to denote unrestricted graphs.

2.2 Semantics of (Domain-Restricted) RDF Graphs

A simple interpretation I = (Res, P rop, Lit, , IS, IL)3 of an RDF graph G over
vocabulary ULG is defined by (1) a non-empty set of resources Res (also called the
domain of I) and of properties P rop, (2) a distinguished subset Lit  Res, (3) an
extension (pr)  Res  Res for every property pr  P rop, and (4) mappings
IS : UG  Res  P rop and IL: L  Lit.

We write I(.) to denote the valuation under the interpretation I. We have I(u) :=
IS(u) for a URI u and, I(l) := IL(l) for a literal l. A triple (s, p, o) has the value true
in I if IS(p)  P rop and (I(s), I(o))  (IS (p)); otherwise (s, p, o) has the value
false. For a ground graph G, we have I(G) = true if every triple of G is true in I.
Blank nodes in non-ground graphs are interpreted as existentially quantified vari-
ables. Let A: B  Res be a blank node assignment (or an assignment, for short), and
let I be an interpretation. Then we write [I + A] to denote the interpretation I extended
by the blank node assignment A. Clearly, [I + A](b) = A(b) for blank nodes b  B,
while [I + A](a) = I(a) for a  UL. A non-ground graph G is true in I, if there exists
an assignment A : B  Res, s.t. every triple of G is true in [I + A]. If a graph G is
true in an interpretation I, then we say that I is a model of G or I satisfies G.
We say that an RDF graph G1 entails the graph G2, if every interpretation I which
satisfies G1 also satisfies G2. If this is the case, we write G1 |= G2. This leads us to
the RDF entailment problem: Given two RDF graphs G1, G2, does G1 |= G2 hold?
This problem is well known to be NP-complete [14]. We may assume w.l.o.g. that
 ULG1, since otherwise G1 |= G2 clearly holds (i.e., we can easily construct
ULG2
an interpretation I which satisfies G1 but not G2).
Interpretations for a dRDF graph G, D restrict general RDF interpretations in the
following sense. Given an interpretation I = (Res, P rop, Lit, , IS, IL) and a set
D  UL we call the interpretation I = (Res  D, P rop, Lit  D, , IS, IL) with
IS = ISResD and IL = ILResD the D-restriction of I, also written ID. Note that
3 As mentioned above, we are following the notation from [14]. Clearly, Res, P rop, Lit, , IS,

and IL correspond to IR, IP, LV, IEXT, IS, and IL, respectively, in [10].

R. Pichler et al.

we do not restrict the domain of P rop in ID. Since the purpose of domain-restrictions
is mainly to restrict the values which blank nodes may take, we do not need to restrict
propertiesblank nodes are not allowed in property position in RDF anyway.
We define d-models as before with the only difference that for any interpretation I
its D-restriction is considered. I.e., given an interpretation I and a dRDF graph G, D,
if G is true in ID, then we say that I is a d-model of G, D or I d-satisfies G, D.
Finally, we say that a dRDF graph G1, D1 d-entails G2, D2 (by overloading |=
we write G1, D1 |= G2, D2), if for any interpretation I s.t. ID1 satisfies G1, ID2
also satisfies G2. Obviously, if D1 contains an element not existing in D2, then this
condition can never be fulfilled. Indeed, if c  D1 \ D2, then we can easily construct a
D1-model of G1 (where every URI in G1 is mapped to c) which is not a D2-model of
G2. Conversely, if D2 contains elements not existing in D1, then these elements play no
role for d-entailment, i.e., we have G1, D1 |= G2, D2 iff G1, D1 |= G2, D1D2.
Therefore, in the sequel, we shall restrict ourselves w.l.o.g. to the case D1 = D2.

2, where G

Example 2 (Example 1 contd). Getting back to the graphs in Fig. 1, it is easy to
see that G2 |= G3 and that G1 |= G
2 is the graph obtained from G2
by removing the last three statements of G2. As mentioned earlier, Fangs graph G1
talks only about people working at TU Vienna, i.e., it is restricted to the fixed domain
D1 = {"Fang", "Stefan", "Reini"}  DT UV where DT UV is a fixed, finite list
of URIs which gives identifiers to all current TU Vienna employees and contains for
instance the URIs :fangwei, :stefanwoltran, and :reinhardpichler. This list
may be huge and instead of looking up all the real identifiers there, Fang still uses
blank nodes as in the example for publishing her metadata. But in order to indicate the
fact that her graph talks about a finite domain she publishes the dRDF graph G1, D1.
Likewise, Stefan publishes his collaboration links as graph G2, D2. Stefans graph
is restricted to D2 = D1  DT UV old where DT UV old is a finite list of identifiers of
former TU Vienna members that also contains the URI :axelpolleres, for example.
Both G1, D1 |= G
, D2 and G2, D2 |= G3 hold. However, G3 is in fact none of
the authors but Stefan Deckers collaboration graph at DERI and restricted to the domain D3 = { "Stefan", "Axel"} DDERI where DDERI is the (again finite) list of
identifiers of DERI employees that contains among others the URIs :axelpolleres
and :stefandecker, but none of the other previously mentioned URIs. Obviously,
G2, D2 |= G3, D3 despite the fact G2, D2 |= G3.

2.3 Properties of (Domain-Restricted) Entailment

Before we have a closer look at the complexity of this restricted form of the entailment
problem, let us discuss some fundamental properties of (domain-restricted) entailment.
Proposition 1. Let G1, G2 be graphs and D a finite domain. Then G1 |= G2 implies
G1, D |= G2, D while the converse is, in general, not true.
Proof. Clearly, entailment implies d-entailment, since every d-model is also a model.
To see that the converse is, in general, not true, consider the following counter-example:
Let G1 = {(a, p, b), (a, p, c), (b, p, c)} and G2 = {(x, p, x)} where a, b, c, p  U and
?

?

?
x  B. Moreover, let D = {d1, d2}. Then G1, D |= G2, D holds: Indeed, with
|D| = 2, any d-model I of G1, D assigns the same value di (for some i  {1, 2}) to
two URIs out of {a, b, c}. Hence, G2 is true in [I + A] with A(x) = di.
Proposition 2. Let G1, G2 be graphs and D a finite domain with |D|  |U LG1G2
Then G1 |= G2 iff G1, D |= G2, D.

|.

Proof. The only if direction immediately follows from Proposition 1. The basic idea
of the if-direction is that, for any interpretation, only the active domain (i.e, the
elements in Res which are actually used for interpreting the elements in U LG1G2) is
relevant. For details, see [22].

Intuitively, Proposition 2 states that entailment and d-entailment coincide for a sufficiently large domain D.

We conclude this section by showing that w.l.o.g. several simplified assumptions

may be made, both for the entailment problem and the d-entailment problem.

A Skolemization of a graph G is a ground instance of G which maps every blank
node in G to some fresh URI reference. These fresh URI references are called the
Skolem vocabulary. The Skolemization of G is denoted as sk(G). The usefulness of
Skolemizations is due to the following property:

Lemma 1. Let G1, G2 be graphs and let sk(G1) be a Skolemization of G1, s.t. the
Skolem vocabulary is disjoint from both G1 and G2. Moreover, let D be a finite domain.
Then the following equivalences hold: G1 |= G2  sk(G1) |= G2 and G1, D |=
G2, D  sk(G1), D |= G2, D.

Proof. The correctness of this lemma in case of ordinary entailment is shown in [10].
The case of d-entailment can be shown by exactly the same arguments.

In other words, for both ordinary entailment and d-entailment, we may assume w.l.o.g.
that the graph G1 is ground. After having restricted the syntax, we show that also the
set of models to be inspected by an (ordinary or d-) entailment test can be significantly
restricted. In [10], entailment testing is reduced to Herbrand models. However, in case
of domain-restricted graphs, we can of course not be sure that the Herbrand universe
is contained in the finite domain D. We thus have to generalize the idea of Herbrand
models to minimal models.
Definition 1. We call a model I of an RDF graph G (resp. a dRDF graph G, D) a
minimal model of G (resp. G, D), if the extensions (pr) in I are chosen minimal (for
every pr  P rop) s.t. G is true in I. In other words, for every property pr  P rop, a
minimal model is characterized by the following relation

(pr) = {(I(s), I(o)) | (s, p, o)  G1 and IS(p) = pr}.

Clearly, every Herbrand model is a minimal model while the converse is, in general,
not true. The following lemma states that, for (d-) entailment testing, we may restrict
ourselves to minimal models of G1.

R. Pichler et al.

 U LG1 and G1 is ground. Moreover, let

Lemma 2. Let G1, G2 be graphs, s.t. U LG2
D denote a finite domain. Then the following equivalences hold:
(a) G1 |= G2 iff every minimal model I of G1 satisfies G2.
(b) G1, D |= G2, D iff every minimal model I of G1 with Res  D satisfies G2.
Proof. The restriction to minimal models of G1 (resp. G1, D) is based on the following observation: Suppose that G1 (or G1, D) is true in some interpretation I. It
with (pr) = (pr){(I(s), I(o)) | (s, p, o) 
clearly remains true if we restrict  to 
G1 and IS(p) = pr}. In case (b), the restriction to interpretations I with Res  D is
obvious since, in a d-interpretation, Res is restricted to a subset of D anyway.

3 Complexity of d-Entailment

We are now ready to investigate the complexity of d-entailment testing. It turns out that
it is one level higher in the polynomial hierarchy than without domain restrictions.

The  P

2 upper bound is easily established via the lemmas from Section 2.3.

Lemma 3. The d-entailment problem is in  P
2 .

2 -algorithm.

Proof. Recall that, by Lemma 1, we may assume w.l.o.g. that G1 is ground. Then the
complementary problem G1, D does not d-entail G2, D can be decided by the
following P
1. Guess an interpretation I over the vocabulary of G1  G2, s.t. G1 is true in I.
2. Check that for all assignments A for the blank nodes in G2, the graph G2 is false

in [I + A]. Clearly, this check can be done by a coNP-oracle.

, and a Herbrand universe H, C H

The proof of the  P
2 lower bound is much more involved. Due to space limitations, we
can only give a rough sketch here. For details, see [22]. The proof goes by a reduction
from a restricted form of the so-called H-subsumption problem. H-subsumption was
introduced in the area of automated deduction as a powerful technique of redundancy
elimination (cf. [12]). Given two clauses C, C
C
holds, iff, for each substitution  of the variables in C
to H, there exists a substitution
 of the variables in C to H, such that C  C. In this paper we are only interested in the case that H is a finite domain of constants. In [21], it was shown that the
H-subsumption problem is  P
consist of unnegated atoms
only. However, we need a strongly restricted version of H-subsumption: In particular,
we have to restrict the H-subsumption problem to the setting, where no constants are
allowed to occur in the clauses and where all predicates are binary. We call such problems total, binary H-subsumption problems (TBH-subsumption, for short). Of course,
it is a priori by no means clear that TBH-subsumption is still  P
2 -hard. Hence, the
 P
2 -hardness proof essentially consists of two parts: the problem reduction from TBHsubsumption to d-entailment and the  P

2 -complete even if C and C

2 -hardness proof of TBH-subsumption.

ss

Lemma 4. The TBH-subsumption problem can be reduced in polynomial time to the
d-entailment problem.
?

?

?
(since otherwise C H

ss

C

ss

C

Proof. Consider an instance C H
of the TBH-problem over some finite universe
H. In C, C
, all predicates are binary and all arguments of the atoms in C and C
are first-order variables. W.l.o.g., the clauses C and C
have no variables in common.
Moreover, all predicates in C also occur in C
trivially
holds) and all predicates in C
also occur in C (since literals in C with a predicate
symbol not occurring in C
play no role at all in the H-subsumption testthey can
never be matched by literals in C). We define the dRDF graphs G1, D and G2, D
with D = H, G1 = {(s, p, o) | p(s, o)  C}, and G2 = {(s, p, o) | p(s, o)  C},
s.t. the vocabulary of G1  G2 is given as U := {s, p, o | p(s, o)  C} and L = .
Moreover, we have B = {s, o | p(s, o)  C}. In other words, G1 is ground while G2
contains only blank nodes. Clearly, this reduction is feasible in polynomial time. The
correctness (i.e., C H

Lemma 5. The TBH-subsumption problem is  P

C  G1, D |= G2, D) is shown in [22].

ss

2 -hard.

Proof. The proof is highly involved and very technical. It proceeds in three steps: First,
 P
2 -hardness is shown for clauses using only ternary predicates over a 2-element Herbrand universe H = {a, b}. This result is then extended to an arbitrary, finite H with
|H|  2. Finally, it is shown that  P
2 -hardness still holds even if the clauses are built
up from binary predicates only and |H|  4; details are fully worked out in [22].

Putting the Lemmas 35 together, we immediately get the following result.

Theorem 1. The d-entailment problem is  P

2 -complete.

In other words, the complexity of entailment increases from NP- to  P
2 -completeness
if we restrict the domain. This unexpected effect can be explained as follows. RDF entailment with unrestricted domain admits a syntactical characterization: G1 |= G2 iff
there exists a map from G2 to G1. The proof of the only if direction of this equivalence crucially depends on an argument via Herbrand interpretations of G1 (see the
interpolation lemma and its proof in [10]). Of course, this argument is no longer valid
for dRDF-graphs if the domain D is smaller than the Herbrand universe (note that the
counter-example given in the proof of Proposition 1 is based on a similar idea).

4 Efficient Entailment Through Bounded Treewidth

In this section we first define the treewidth of an RDF graph, then show that the entailment problem of G1 |= G2 can be solved in polynomial time, if G2 has bounded
treewidth. Recall that an RDF triple has the form (v1, v2, v3)  (U  B)  U  (U 
B  L). Let us denote those triples (v1, v2, v3) where v1 and v3 are two distinct variables as blank triples. Moreover, we speak of semi-blank triples if only one of v1, v3 is
a variable or if v1 and v3 are identical variables.
It is interesting to observe that the intractability of the RDF entailment problem
G1 |= G2 depends only on the blank triples in G2. To see this, consider the ground
and semi-blank triples in G2: finding a map of any ground triple is merely an existence
test of the triple in G1. Thus all the ground triples can be tested independently from
each other. Now let us assume that G2 contains only semi-blank triples with k distinct

R. Pichler et al.

variables. Assume further that |G1| = m and |G2| = n. To test G1 |= G2, we first partition all the triples of G2 into k disjoint sub-graphs P1, . . . , Pk, s.t. two triples belong
to the same sub-graph if and only if they contain the same variable. For each i, let ni
denote the cardinality |Pi| of Pi. Clearly, n1 +  + nk = n. We can then check the
entailment of the sub-graphs one by one. For each Pi(1ik), the variable in Pi can be
mapped to m possible values. Because there is only one variable in Pi, for each map ,
we have to execute the existence test (Pi)  G1, which takes maximum mni steps.
Thus in summary, the total cost of the entailment test is O(m2n).

However, if the graph G2 contains blank triples, it is possible that the variables are
intertwined s.t. no variable can be tested independently, thus the number of possible
maps is exponential in the size of the variables occurring in blank triples. Treewidth is a
well-known metric on graphs that measures how tree-like a graph is. Many intractable
problems become tractable, if the treewidth of the underlying structure is bounded.
We shall now show that the entailment problem G1 |= G2 becomes tractable if
the graph G2 has bounded treewidth. Recall the syntactical characterization of entailment [10,14]: G1 |= G2 iff there exists a map from G2 to G1. Hence, the entailment
problem for unrestricted RDF graphs comes down to a special case of conjunctive query
containment where all predicates are binary. Hence, the notion of treewidth and the
tractability of conjunctive query containment in case of bounded treewidth (see e.g. [5])
naturally carry over to RDF graphs and the entailment problem. However, we prefer to
give a native definition of tree decomposition for RDF graphs here, so that the RDF
intuition is preserved. Likewise, we explicitly present an entailment algorithm in terms
of the RDF terminology rather than by just referring to conjunctive queries.

We start by giving the definitions of tree decomposition and treewidth for an RDF
graph. By the above considerations, we assume that the RDF graph does not contain
any ground triple. We denote all the variables occurring in G as BG.
Definition 2. A tree decomposition T of an RDF graph G is defined as T, (Bi)iT
where T is a tree and each Bi is a subset of BG with the following properties:
1. Every b  BG is contained in some Bi.
2. For every blank triple (v1, v2, v3)  G, there exists an i  T with {v1, v3}  Bi.
3. For every b  BG, the set {i | b  Bi} induces a subtree of T .
The third condition is usually referred to as the connectedness condition. The sets Bi
are called the blocks of T . The width of the tree decomposition T, (Bi)iT is defined
as max{|Bi| | i  T} 1. The treewidth of an RDF graph G (denoted as tw(G)) is the
minimal width of all tree decompositions of G. For a given w  1, it can be decided
in linear time whether some graph has treewidth  w. Moreover, in case of a positive
answer, a tree decomposition of width w can be computed in linear time [4].

Example 3. Consider the graph G2 given in Fig. 2. The undirected graph and the tree
decomposition are depicted in Fig. 3. The treewidth of G2 is 2.

Below, we describe an algorithm which, given the tree decomposition of G2, tests
G1 |= G2 in polynomial time. The intuition behind the algorithm is as follows: we
first construct partial maps from the nodes on the tree decomposition into G1 (denoted
?

?

?
G1

G2

( :b1,:worksWith, :b2),
( :b2,:worksWith, :b3),
( :b1,:worksWith, :b3),
( :b2,:worksWith, :b5),
( :b1,:worksWith, :b5),
( :b3,:worksWith, :b6),
( :b3,:worksIn,"TUV"),
( :b5,:worksIn,"DERI")

( :b1,:worksWith, :b2),
( :b2,:worksWith, :b3),
( :b1,:worksWith, :b3),
( :b2,:worksWith, :b4),
( :b1,:worksWith, :b4),
( :b2,:worksWith, :b5),
( :b4,:worksWith, :b6),
( :b3,:worksIn,"TUV"),
( :b5,:worksIn, :b7)

Fig. 2. RDF graphs for Example 3

b4

b2

b1

b3

b6

b7

b5

b1b2b3

b1b2b4

b4b6

b2b5

b5b7

Fig. 3. Undirected graph of G2 from Fig. 2 and the tree decomposition of G2

as Mi in the algorithm below), then successively merge those partial maps which are
consistent with each other. If at last the merging succeeds, G1 |= G2 holds, otherwise
not. Note that the connectedness property of the tree decomposition allows us to merge
such partial maps in a bottom up manner on the tree (by using the semi-join operation
of relational algebra), in polynomial time. We thus carry over ideas proposed in [5] for
testing conjunctive query containment to the RDF entailment problem.
Polynomial Time Algorithm. Let T, (Bi)iT be the tree decomposition of the RDF
graph G2 with treewidth k. Given a node i in T , Si is denoted as the union of all the
blocks in the sub-tree rooted at i. The induced sub-graph G[Si] contains all the triples
(v1, v2, v3) in G2, such that either v1 or v3 belongs to Si. We maintain for each node i
in T a relation Mi. In the algorithm below,  is the natural semi-join operator.

The Polycheck algorithm for checking G1 |= G2 consists of the following steps:
1. For each node i in T , generate the sub-graph G
(v1, v2, v3) such that {v1, v3}  Bi  ULG2 and {v1, v3}  Bi = .
2. Initialize the relation Mi as follows: for each map  from G
is in Mi.

i which contains all the triples

i to G1, the tuple (Bi)

3. Process the tree nodes bottom-up as follows: Suppose i is a tree node in T all of
whose children have been processed. For each child j of i, we set Mi := Mi  Mj.
4. Let r be the root of T . Then G1 |= G2 if and only if Mr is not empty.
Example 4. Let us continue with Example 3. With the given tree decomposition of G2,
we illustrate in Fig. 4 how the Polycheck algorithm works when testing G1 |= G2.
Step 1: We need to generate the sub-graphs G
decomposition. For instance, G
worksW ith, :b6).

5 for the nodes 15 of the tree
4 is the sub-graph consisting of only one triple ( :b4, :

, . . . , G

R. Pichler et al.

b1   b2   b3

b1b2b3

b1   b2   b3
b1   b2   b5

b1b2b4

b1    b2
b2    b3
b1    b3
b2    b5
b3    b6
b1    b5

b4b6

b2b5

b1    b2
b2    b3
b1    b3
b2    b5
b3    b6
b1    b5

b5b7

b3     TUV
b5     DERI

Fig. 4. Bottom up processing on the tree decomposition

4 to G1, thus M4 consists of six tuples.

in M4, s.t. t and t

Step 2: Next we generate the partial maps Mi(1i5), which are given as the tables
beside the tree nodes. Note that following the convention of relational databases, the
variable names at each block give the relation schema for that block and every row of a
table is called a tuple. For the time being, let us ignore the dotted lines drawn over the
tuples. Now consider M4. For every map  with (( :b4, : worksW ith, :b6)  G1,
we insert the tuple ( :b4, :b6) into M4. It is easy to verify that there are six distinct
maps from G
Step 3: We execute semi-joins along the bottom-up traversal of the tree decomposition.
The tables at the leaf nodes remain unchanged. Let us consider the semi-join operation
M2  M4. By definition, the result of the semi-join is the set of those tuples t in M2 for
which there is a tuple t
coincide on their common attributes (in our
case b4). Such a t
is called a partner of t. Now let us consider the first tuple (b1, b2, b3)
in M2. In this case, b3 is the value for the common attribute b4. A partner tuple (b3, b6)
in M4 is found, thus the tuple (b1, b2, b3) remains in M2. However, for the second tuple
(b1, b2, b5), there does not exist any partner tuple in M4. Therefore the tuple (b1, b2, b5)
is deleted by the semi-join operation.
Step 4: Finally, the only tuple in M1 remains after the semi-join operation with both
M2 and M3, thus the entailment test succeeds.

Theorem 2. The algorithm Polycheck correctly decides whether G1 |= G2.
Proof. We use induction on the number of nodes processed in the tree, with the following hypothesis: After node i is processed, tuple t  Mi if and only if there is a map 
from G[Si] to G1 such that (Bi) = t. Thus when the root r has been processed, Mr is
non-empty if and only if there is a map  from G[Sr] to G1. Because G[Sr] is G2, we
can therefore conclude that G1 |= G2.
sub-graph G[Sl] of any leaf node l is the the graph G
For the induction, assume that we have processed all the children j1, . . . , jr of node
i. Suppose that t  Mi holds before the processing of node i. Let  be the map of G
to G1 s.t. (Bi) = t. If t  Mi still holds after the processing of i (i.e., the semi-join
i
operations with all the child nodes), then for each jk(1kr), there is a tuple tk  Mjk,
that agrees with t on the variables in Bi  Bjk. By the induction hypothesis, there is a
map k from G[Sjk] to G1, such that k(Bjk) = tk.

The induction hypothesis holds for the leaves, because of step 2, and the induced

l we defined in the step 1.
?

?

?
It remains to show that the maps , 1, . . . , r are consistent. Assume that v occurs
in the blocks Bj and Bj of two children of i. According to the connectedness condi-
tion, v occurs in Bi too. Since , j and j agree on the common variables, , j
and j are consistent. Let  :=   1  . . .  r. Then  is clearly a map from G[Si]
to G1 such that (Bi) = t.
Conversely, assume there is a map  from G[Si] to G1 such that (Bi) = t, we show
that t is in Mi after the processing of i. Clearly t is in Mi before the processing of i,
because G
i as defined in step 1 is a sub-graph of G[Si]. Let 1, . . . , r be the projection
, . . . , Sjr , and let  be the projection of  onto the variables
 onto the variables in Sj1
in Bi. By the induction hypothesis, there is a tuple ti  Mjk , where 1  k  r,
such that k(Bjk) = tk. After step 2, there is a tuple t  Mi, such that (Bi) = t.
Since t agrees with the tuples t1, . . . , tr on all common attributes, t is in Mi after the
processing of i.

Theorem 3. The entailment problem of G1 |= G2 can be decided in polynomial time if
G2 has bounded treewidth.
Proof. Suppose that |G1| = n, |G2| = m and tw(G2) = k  1. Step (1): For each tree
node i, we need to scan all the triples in G2 to generate the subgraph G
i of G2. Since
the size of the tree decomposition of G2 is not more than m, we have an m2 upper
bound. Step (2): For block Bi with size k, there are nk possible tuples to be checked.
For each tuple t, we generate the map  from Bi to t. If (Gi)  G1, then t is added
to Mi. Thus, the cost for the initialization of all the nodes is mnk. Step (3): Each semijoin operation of two k-ary relations takes n2k (using primitive nested loops), thus the
total cost is mn2k. In summary, we get the upper bound O(m2 + mn2k) on the time
complexity of the algorithm Polycheck.
To summarize, the entailment problem G1 |= G2 is intractable, only if the blank triples
in G2 are cyclic. We note that, in practice, an RDF graph contains rarely blank nodes,
and even less blank triples. Hence, most of the real RDF graphs are acyclic or have
low treewidth such as 2, and the entailment can be tested efficiently with the above
algorithm. For instance, all the graphs in Fig. 1 are acyclic and thus have tw  1.

5 Bounded Treewidth and d-Entailment

In the previous section, we have seen for RDF graphs that bounded treewidth significantly decreases the complexity of entailment. We shall now prove a similar result for
d-entailment, where bounded treewidth again has a positive impact on the complexity.
Lemma 6. The d-entailment problem of G1, D |= G2, D is in coNP if G2 has
bounded treewidth.
Proof. Suppose that tw(G2) is bounded by some constant. Recall that, by Lemma 1,
we may assume w.l.o.g. that G1 is ground. Then the complementary problem of testing
G1 |= G2 can be decided by the following NP-algorithm:
1. Guess an interpretation I over the vocabulary of G1  G2, s.t. G1 is true in I.
2. Check that there exists no assignments A for the blank nodes in G2, s.t. the graph

G2 is true in [I + A].
?

?

?
The check in step 2 comes down to an ordinary entailment test G
1 :=
{(I(s), I(p), I(o)) | (s, p, o)  G1} and G
2 := {(I(s), I(p), I(o)) | (s, p, o)  G2},
where we stipulate I(z) = z for the variables z in G2. We clearly, have tw(G2) =
|= G
tw(G
2). Hence, by Theorem 3, the check G
2 is feasible in polynomial time. 2
Lemma 7. The d-entailment problem of G1, D |= G2, D is coNP-hard for bounded
treewidth of G2. It remains coNP-hard even if tw(G2) = 0 (i.e., the graph induced by
the blank nodes consists of isolated nodes only).

2 with G

|= G

Proof. We prove the coNP-hardness by reducing the well-known NP-complete problem
of graph -colorability with   3 to the complementary problem G1, D |= G2, D.
Let G = (V, E) be a graph with vertices V and edges E. We define two RDF graphs
G1 and G2 as G1 := {(u, e, v) | (u, v) is an edge in E} and G2 := {(x, e, x)} for some
blank node x. Clearly, tw(G2) = 0. Moreover, this reduction is feasible in polynomial
time. It remains to show the correctness of this reduction, which can be seen as follows:
By definition, G is -colorable iff there exists a mapping , assigning different colors
to any two adjacent vertices u, v  V . Obviously, such an assignment exists iff there
exists an interpretation I sending all triples (u, e, v) in G1 to values (I(u), I(e), I(v))
with I(u) = I(v). This, in turn, is the case iff there exists no blank node assignment A,
s.t. (A(x), A(x))  (I(e)).

In summary, we thus have the following exact complexity classification.
Theorem 4. The d-entailment problem of G1, D |= G2, D is coNP-complete if G2
has bounded treewidth.

6 Related and Future Work

Our results touch upon many related issues on RDF reasoning and Semantic Web reasoning in general. First of all, we point out that the peculiarities of reasoning with open
and restricted domains raised by dRDF are closely related to similar issues discussed in
the context of reasoning with rules and ontologies [6].

Next, we have only discussed simple (d)RDF entailment in this paper. As for future works, it will be interesting to see, which implications restrictions on the domain
will have when higher entailment regimes such as RDF entailment, RDFS entailment,
D-entailment, or entailments in OWL variants are considered. Standard fragments of
OWL are well-known to be syntactic variants of decidable Description Logics [1], i.e.
OWL Light is reducible to SHIF(D) and OWL DL is reducible to SHOIN(D) [16].
We plan to investigate how (finite) domain-restrictions on the data affect the complexity of entailment in these languages, see also [1, Chapter 5]. Alternatively to finitely
restricting the domain of interpretations for the whole graph it seems that restricting
the blank nodes in an RDF graph to a finite, enumerated class (using OWLs oneOf
constructor) could have similar effects, when we extend our considerations towards
OWL. We are currently investigating respective generalizations of the definition of
dRDF graphs. As for rule extensions on top of ontology languages, we remark that
RDF(S) and some non-standard fragments of OWL entailment can be reduced to sets of
?

?

?
Datalog rules [7,13,17,27] and thus combined straightforwardly with datalog rules on
top. Note however, that subsumption of arbitrary Datalog programs is undecidable [26].
Issues get even more involved, when standard OWL fragments or (non-monotonic) rule
languages are added on top of these languages (see [11,15,25] and references therein)
since in the unrestricted case, even the satisfiability problem for rule-extended ontologies problem becomes undecidable. However, here domain-restrictions may turn out
to be actually a good thing, since those cases become decidable for finite domains. A
complete investigation of complexity classes for such combinations is on our agenda.
In the context of (non-monotonic) rules extensions, let us mention that restricting the
domain of interpretations is also related to restricting the scope of negation to closed
sets of rules in non-monotonic rule languages for the Web, see [23] for further details.
As for related results on finding tractable fragments of RDF, Mu noz et al. [19] define
a syntactic subclass of RDFS with O(n log n) bounds for entailment (without blank
nodes though), which our results complement.

Deciding whether a SPARQL [24] query has an answer is an extension of simple
RDF entailment which is PSPACE complete in general but also NP-complete in many
cases [20]. We expect that our results propagate to tractable fragments of SPARQL over
unrestricted RDF as well as over dRDF graphs, which to define is on our agenda.

Bounded treewidth is a well-established method for identifying tractable subclasses
of otherwise intractable problems. It has been successfully applied to a great variety of
graph-related problems like network reliability, job scheduling, compiler optimization,
model checking, etc. (see e.g., [3,8]). To the best of our knowledge though, bounded
treewidth has not yet been considered in the context of Semantic Web reasoning.

7 Conclusions

Entailment checking is the key reasoning task for RDF. In this work, we have investigated how the complexity of deciding entailment in RDF is affected by two restrictions.
Firstly, we introduced dRDF, a variant of RDF which allows to associate an RDF graph
with a fixed, finite domain that interpretations for it may range over. We have demonstrated that such restrictions are useful in environments where someone wants to make
RDF statements over closed contexts such as enterprises or institutions. Secondly, we
investigated restrictions of the graph structure of (d)RDF graphs. Particularly, we investigated the effect of restricting the structure of RDF graphs to bounded treewidth,
which considerably lowered the complexity of entailment checking. As related works
show, there are many promising directions for applying our results, such as finding further tractable algorithms for fragments of SPARQL, or applying respective restrictions
beyond simple RDF entailment.
