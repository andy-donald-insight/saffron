Web Service Composition with User Preferences

Naiwen Lin1, Ugur Kuter1, and Evren Sirin2

1 Department of Computer Science and Institute for Advanced Computer Studies,

University of Maryland, College Park, MD 20742, USA

{nwlin,ukuter}@cs.umd.edu

2 Clark & Parsia, LLC, 926 N Street, NW Rear, Studio # 1,

Washington, DC 20001, USA
evren@clarkparsia.com

Abstract. In Web Service Composition (WSC) problems, the composition process generates a composition (i.e., a plan) of atomic services, whose execution
achieves some objectives on the Web. Existing research on Web service composition generally assumed that these objectives are absolute; i.e., the servicecomposition algorithms must achieve all of them in order to generate successful
outcomes; otherwise, the composition process fails altogether. The most straightforward example is the use of OWL-S process models that specifically tell a
composition algorithm how to achieve a functionality on the Web. However, in
many WSC problems, it is also desirable to achieve users preferences that are
not absolute objectives; instead, a solution composition generated by a WSC algorithm must satisfy those preferences as much as possible. In this paper, we
first describe a way to augment Web Service Composition process, where services are described as OWL-S process models, with qualitative user preferences.
We achieve this by mapping a given set of process models and preferences into
a planning language for representing Hierarchical Task Networks (HTNs). We
then present SCUP, our new WSC planning algorithm that performs a best-first
search over the possible HTN-style task decompositions, by heuristically scoring
those decompositions based on ontological reasoning over the input preferences.
Finally, we discuss our experimental results on SCUP.

1 Introduction

Web Service Composition (WSC), dynamic integration of multiple Web Services to
fulfill the requirements of the task at hand, is one of the most important area in the
Web Services research. Most research on composing Web services has been focused
on developing new algorithms based on existing AI planning techniques. Examples
of this approach include [1,2,3,4,5,6]. All of these works generally assumed that the
composition process generates a solution composition (i.e., a plan) of atomic services,
whose execution achieves some objectives on the Web. Those objectives are almost
always required to be absolute; i.e., a service-composition algorithm must achieve all
of them in order to generate successful outcomes; otherwise, the composition process
fails altogether. As an example, in WSC planning systems such as [2,4,6], such absolute
objectives and constraints specify structural ways of decomposing higher-level process
models in OWL-S [7] into an atomic-level composition that solves the input WSC
problem.

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 629643, 2008.
c Springer-Verlag Berlin Heidelberg 2008

N. Lin, U. Kuter, and E. Sirin

In many real-life WSC scenarios, on the other hand, the aim is to generate a solution
that not only achieves some absolute goals and any constraints associated with them,
but also is desirable with respect to some user-provided preferences. For example, there
are abundant number of travel Web sites providing transportation and accommodation
services. Possibly, there will be several combinations of these services that will allow
one to plan for a trip from a source location to a destination. However, an agent making such trip arrangements will need to take into account user preferences such as a
desired range on the total cost of the trip, preferences on particular transportation com-
panies/hotels, and certain times/dates for the trip. None of these are necessarily absolute
goals in the sense that, if violated, they do not affect the correctness of the compositions
but specify that certain compositions are more preferable than others.

In this paper, we describe a new WSC technique in which the Web services are
described as OWL-S process models and the composition process is augmented with
user preferences. Our contributions are as follows:
 We first describe a planning formalism that is based on the previous languages developed for Hierarchical Task Networks (HTNs). Then, we describe a way to take
OWL-S service descriptions and preferences described in the PDDL3 language [8],
and translate them into our formalism. This enables us to investigate the semantics
of user preferences in the context of HTNs and provides a clear, unifying framework
for augmenting service composition process with user preferences.
 We describe our new automated planning algorithm, called SCUP (for Service Composition with User Preferences). SCUP combines HTN planning with best-first
search that uses a heuristic selection mechanism based on ontological reasoning over
the input user preferences, state of the world, and the HTNs. In this context, the
ontological reasoning provides a way to compute the heuristic cost of a method before decomposing it. Using best-first search, SCUP generates compositions for WSC
problems with minimal cost of violations of the user preferences.
 We present an experimental evaluation, demonstrating that our approach is a promising one. On two benchmark problem suites that were used in the latest International
Planning Competition (IPC-5) [9], SCUP generated solutions that had substantially
better quality than the ones generated by the planning algorithm SGPlan [10,11], the
winner of the IPC-5 in thePlanning with Qualitative Preferences track.

2 Preliminaries

Our formalism is based on the several previous HTN-planning formalisms; in particular,
we use similar definitions as for the Universal-Method Composition Planner (UMCP)
[12,13,14] and the HTN-DL WSC system [4,15].

We assume the traditional definitions for logical constant and variable symbols,
atoms, literals, and ontologies. A state is a set of ontological assertions describing the
world. A state s is consistent if there is an interpretation  that satisfies all axioms and
assertions in s; otherwise we say the state is inconsistent.

We assume the existence of finite set of symbols, called task symbols. A task is an
expression of the form t = (head, Inp, Out, Pre, Eff). head, the name of this task, is a
task symbol. Inp and Out, the set of input and output parameters respectively, are finite
?

?

?
sets of variable symbols. Pre and Eff are the preconditions and the effects of the task,
respectively, both of which are in the form of conjunctive ontological assertions.

are the labels associated with two tasks t and t

A task network is of the form ((n1 : t1, n2 : t2, . . . , nk : tk), ) such that each ni
is a unique label symbol, each ti is a task, and  is a set of task-network constraints.
Label symbols in a task network are used to differentiate with different occurrences of
a particular task in the network. We define two kinds of task-network constraints: taskordering and state constraints. A task-ordering constraint is an expression of the form
(n  n), where n and n
in the current
task network, respectively. Intuitively, n  n
means that the task denoted by the label
n must be accomplished before the task denoted by n
A state constraint is either of the following forms: (n, ), (, n), or (n, , n). Here,
 is an arbitrary logical formula, and n, n
are label symbols. Intuitively, state constraints (n, ) and (, n) mean that the literal  must be true in the state immediately
after or before the task labeled with n, respectively. These constraints are used to specify the effects and preconditions of a task labeled by n. A state constraint of the form
(n, , n) means that  is true in every state between n and n

.

.

If we want a state constraint to hold for every occurrence of the task regardless of
the label symbols, we simply use the task name in the constraint, e.g. (, t). We also
use task variables in constraint expressions, e.g. (, ?t) and (?t1  ?t2), in order
to represent an existential constraint. Intuitively, a task variable will be bound (only
once) to a task that exists in the task network such that the constraint will be satisfied.
If no such binding is possible throughout the decomposition process we say that the
constraint is violated. In addition, we allow a task-binding constraint in the form (?t =
t) and (?t = t) to restrict the tasks that a task variable can be bound to.

Let s be a state, w be a task network, and x be a task-network constraint in w. Then,

we define a violation-cost function, , as the partial function:
?

?

?
(s, w, x) =

(1)
where c is either a positive number or it is . The overall violation cost of a task
network w = (, ) in a state s is

if x does not hold in w given s,
otherwise

c,
0,

(s, w, ) =

(s, w, x).

(2)
?

?

?
x

A WSC planning operator is an expression of the form o = (task, Inp, Out, Pre, Eff)
where task is a task symbol that specifies the task of this operator, Inp is the set of
input parameters, Out is the set of output parameters, Pre is the preconditions of the
operator, and Eff is the effects of the operator. Pre and Eff are in the form of conjunctive
ontological assertions. An action is a ground operator instance which can be executed
directly on the Web. A plan (or equivalently, a service composition) is a sequence of
actions. We describe the state change from s to s
when applying an action a by the
state-transition function : that is, s = (s, a).

A WSC planning operator o is applicable to a task t in a state s, if there is a variable
substitution  such that (o) is ground, the preconditions of (o) hold in the state s, o
has the same task symbol as in t, and (o) entails the effects of (t).

N. Lin, U. Kuter, and E. Sirin

A task-decomposition method is a tuple m = (task, Inp, Out, Local, Pre, Eff,  ),
where task, Inp, Out, Pre, and Eff are defined the same as in the above definition of a
planning operator.  is a task network. Local is a set of local variables used in P and  .
Local variables are those variables in m that does not appear in the inputs, but are bound
in the preconditions of the method or of a task network. A method m is applicable to
a task t in a state s, if there is a variable substitution  such that (m) is ground, the
preconditions of (m) are satisfied in the state s, m has the same task symbol as in t,
and the effects of the (m) entails the desired effects of (t).

A WSC planning domain D is a triple of (O, M, Tont), where O is the set of operator
descriptions, M is the set of methods, and Tont is the task ontology. We assume that
the task ontology Tont is an OWL ontology [16] that describes the set of all possible
tasks in the domain. A WSC planning problem is a triple P = (s0, w, D, ), where s0
is the initial state, w is the initial task network, D is the WSC planning domain, and 
is the overall violation-cost function. A solution for P is a task network w = (, )
such that (1) all of the tasks in  are primitive; (2) there exists a total-ordering of the
tasks in  (i.e., a solution plan  = a1, a2, ..., ak) that has a minimum overall cost
(sk, w, ) < , where sk is the final state generated by applying the actions in  in
s0. Note that a plan that has a violation-cost of  is not a solution even if it somehow
generates the final state, when applied in the initial state s0.

We remark that our formalism above is not intended to depend on a particular WSC
system and can be implemented as the input languages of any of the existing HTNbased WSC systems such as [4,15,6]. The rationale behind this formalism is that it
provides a clear semantics for augmenting a Web Service composition process, where
the services are described as OWL-S process models, and user preferences in a single
unifying framework, as we will describe and discuss in the rest of this paper.

3 Modeling User Preferences

Our preference language is largely based on the recent language PDDL3 [8] that allows
to incorporate user preferences in AI planning problems. In PDDL3, preferences are
described as logical assertions over states and state trajectories by defining basic preferences and temporal preferences. A basic preference (BP) is a logical formula , or a
formula built with logical connectives , ,  from other basic preferences. Let  be a
basic preference. Then, a temporal preference (TP) is any of the following:
T P :=always(BP) | sometime(BP) | at most once(BP) | f inal(BP) |

sometime af ter(BP,BP) | sometime bef ore(BP,BP)

As the above definition demonstrates, we do not allow the nesting of temporal constraints in this paper. We assume that each temporal preference has a unique label; e.g.,
p1 : (f inal ), where p1 is the unique label and  is a basic preference.
The satisfaction of temporal constraints is defined with respect to a plan  and its
state trajectory S = s0, . . . sn in an initial state s0 as follows.
 If  is a ground atom then , S, si |=  iff si |= ;
 Quantifiers and logical connectives have the same meaning as in first-order logic.
For example, , S, si |=   

iff , S, si |=  and , S, si |= 

;
?

?

?
 , S, si |= always() iff j : i  j  n  , S, sj |= ;
 , S, si |= sometime() iff j : i  j  n  , S, sj |= ;
 , S, si |= f inal() iff , S, sn |= ;
 , S, si |= at most once() iff (1) j : i  j  , S, sj |=  and  k : i 
k  , S, sk |= , or (2) there is no i  j such that , S, sj |= ;
 , S, si |= sometime af ter(, ) iff (1) j : i  j  , S, sj |=  and
k : j  k  , S, sk |= 
 , S, si |= sometime bef ore(, ) iff (1) j : i  j  , S, sj |=  and
k : i  k  j  , S, sk |= 
PDDL3 also allows for representing preferences with universal and existential quan-
tification. As an example, consider the following two different kinds of quantified preferences specified in PDDL3 for a transportation domain:

, or (2) true, if  j : i  j  , S, sj |= ;
, or (2) true,  j : i  j  , S, sj |= ;

p1A: sometime (forall (?t - truck) at(?t, loc1))
forall (?t - truck) (p1B: (sometime at(?t, loc1)))

The preference p1A suggests all trucks stay at location loc1 sometime in the plan
trajectory. If a truck does not satisfy the condition, the preference p1A is violated. The
preference p1B defines a group of preferences with different truck instantiation: e.g., if
there are three trucks in the problem defintion, p1B defines three independent prefer-
ences. Violation of one preference will not affect the satisfaction of the others.

4 Augmenting Web Service Composition with User Preferences

In this section, we describe a translation methodology that takes OWL-S descriptions of
Semantic Web services and PDDL3-style preferences as above, and maps them into our
planning formalism described in Section 2. The rationale behind this methodology is
to represent both the Web services and the preferences in a single unifying framework,
in which a planning algorithm could work to generate compositions of services while
satisfying the user preferences as much as possible.

From OWL-S to HTN-Based Constraints. Our translation method for encoding
OWL-S in our HTN-based constraint language is very similar to the technique described in [4] for encoding OWL-S in the input language of the SHOP2 planner [17].
Suppose K is a collection of OWL-S process models. First of all, for every process
C in K, we create a task of the form (C v u p e) where v and u are the list of input
and output parameters defined in DC, p and e are the preconditions and effects of DC,
and a corresponding label nC for that task.

We translate each atomic process in K into a corresponding planning operator in the
same way as in [4]. The translation of a composite process C in K with a sequence
control construct is as follows. Let DC be the OWL-S definition of the process C.
Next, we define an HTN method m in our constraint language whose head is C and
whose inputs, outputs, preconditions, and effects are v, u, p and e, respectively. The
task network specified by the method m is translated from the process C as follows:

N. Lin, U. Kuter, and E. Sirin

1. For each precondition p defined in DC, we create a state-constraint of the form

(p, nC) where nC is the label of the task corresponding to the process C.

2. For the sequence C1, C2, . . . , Ck of composite process defined in the sequence

control construct of C, we do the following.
 We define a task ti = (Ci vi ui pi ei) as above, and a corresponding task label
ni. The task network in the method m contains the tasks defined as ((ni : ti))k
i=1.
 For each 1  i < k, we define an ordering constraint (ni  ni+1) where ni and
ni+1 are task labels for the tasks that correspond to the processes Ci and Ci+1.
Both sets of constraints above go into the constraint definition  of the task network
associated with the method m.

The translation of a process C with an if-then-else control construct is as follows. Let
Pif be the conditions for the if clause as defined in DC. We define two HTN methods
mif and melse to encode C such that the heads of both methods are the same task (Cv).
Then, we do the following translation for the constraint part of those methods:
 For mif :

1. For each precondition p either defined in DC or in Pif , we define a state-

constraint (p, nC) where nC is the label of the task corresponding to C.

2. For the process Cthen defined for the then construct in DC, we define a task
t = (Cthen vthen uthen pthen ethen) as above, and a corresponding label n.
The task list of the task network associated with the method mif is ((n : t)).

 For melse:

1. For each precondition p defined in DC, we define a state-constraint of the form

2. For each precondition p defined in Pif , we define a state-constraint of the form

(p, nC) where nC is the label of the task corresponding to the process C.
(p, nC) where nC is the label of the task corresponding to the process C.

3. For the process Celse defined for the else construct in DC, we define a task
t = (Celse velse uelse pelse eelse) as above, and a corresponding label n. The
task list of the task network associated with the method melse is ((n : t)).

The translations for repeat-while, repeat-until, choice, and unordered constructs

that may appear in the processes in K are similar to the ones above.
For every HTN task-network constraint generated with our translation, we assign
a violation-cost of , independent of the state and task network that the constraints
might be evaluated in. By doing so, we ensure that the translation generates a bijection
between the OWL-S process models (where such constraints must be satisfied with
absolute certainty) and the translated HTN constructs.
Proposition 1. The translation from OWL-S service process models into HTN constraints is correct, i.e. for each OWL-Sprocess construct as described above, there is
a corresponding set of HTN constructs that specify the same process-model semantics.

Translating Preferences into HTN Constraints. We will now describe how to translate a preference  to one compound task-network constraint  (). With this transla-
tion, whenever we augment a task network w with  (), we have a direct method to
evaluate if a state trajectory (i.e., a plan) satisfies or violates the preference.
?

?

?
In our translation, we use two special task symbols tstart and tend as the start and
end tasks that will be added to every initial task network w with labels nstart and nend.
We also add the ordering constraint nstart  n and n  nend for every n : t  w.
We use the special symbol  to denote a trivially satisfiable HTN constraint and
 to denote an unsatisfiable HTN constraint with the usual semantics that  = ,
 = ,    = ,    = ,    =  and    = . If  () = , then
every plan satisfies  and if  () =  there is no plan that can satisfy .

Now we describe how we construct  () by analyzing the temporal preferences

separately:
  ()  (nstart, , nend), if   always(), where  is a basic preference.
  ()  (?t, ), if   sometime(), where  is a basic preference.
  ()  (, nend), if   f inal(), where  is a basic preference.
  () = (?t1, )  (?t2, )  (?t1  ?t2), if   sometime af ter(, ).
  () = (?t1, )  (?t2, )  (?t2  ?t1), if   sometime bef ore(, ).
  () = (, ?t) and for every task t, (, t) = ?t = t, if   at most once().
We translate the universally- and existentially-quantified preferences as follows:

 If   (?x)  , where ?x is a variable symbol, then we apply the following rules:
1. If  is a basic preference, then  ()   ((?x = x1)  (?x = x2)  . . . 
(?x = xn)), for all possible instantiations xi of ?x, i = 1, . . . , n.
2. If  is a temporal preference, then  ()  { ((?x = x1)),  ((?x =
x2)), . . . ,  ((?x = xn))}, for all possible instantiations xi of ?x, i = 1, . . . , n.
 We have   (?x)() as  ()   since existential quantification has the same
logical meaning for both basic and temporal preferences.

Proposition 2. The translation from preferences into HTN constraints is correct: if  =
a1, a2, . . . , ak is a solution plan to a WSC planning problem (s0, w, D, ) with a
violation cost of v, where the user preferences  are translated into HTN constraints
 () in the task network w, then v = (sk, w,  ()), where w = (, ), sk is the
final state generated by applying  in s0 and  ()  .

5 SCUP: Service Composition with User Preferences

We are now ready to describe our new WSC planning algorithm, SCUP, for generating
service compositions while satisfying user preferences as much as possible. Figure 1
shows the abstract description of the SCUP algorithm. SCUP takes five inputs s0,
w0, D, , and . s0 is the initial state and w0 is the initial task network. D is the
domain knowledge including the task-ontology definitions, HTN methods, and planning
operators.  is the set of user preferences and  is the overall violation cost function.
The algorithm first generates the task network w, where the tasks in w0 = (, ) are
rearranged based on the ordering constraints in w0 and the ordering constraints in the
translation  () of the input preferences in . The Preprocess subroutine is responsible for this operation (Line 2 of the pseudocode in Figure 1). Preprocess first scans

N. Lin, U. Kuter, and E. Sirin

  

Procedure SCUP(s0, w0, D, , )
1.
2. w = (, )  Preprocess(w0, D, R)
3. OP EN  {(s0, w, , (s0, w, ))}
4. while OP EN =  do
5.
6.
7.
8.

select the first node x = (s, w, , v) from OP EN and remove it
if  is a solution then return 
Succ  Decompose(s, w, , v, D)
OP EN  OP EN 
, (s

)  Succ}
sort OP EN in the ascending order based on the cost function 

)) | (s

= (
?

?

?
{(s

, 

), 

, w

, 

, w

, 
?

?

?
, w
?

?

?
9.
10.

return f ailure

Fig. 1. An abstract description of the SCUP algorithm

all preferences and see if there are final, sometime before, sometime after,
and sometime preferences. If there are no such preferences in , the algorithm simply
returns the original task network w0 with    (). Otherwise, Preprocess checks
all of the preferences of the above types and verify if additional tasks will be added in
w0 in order to guarantee the satisfaction of these preferences in  as much as possible.

The rationale behind the preprocessing step is as follows:

 Preprocessing (sometime ). If no task in  can achieve the effect , there might
be still other tasks in the input task ontology, when/if decomposed into a primitive HTN successfully, can achieve . Thus, Preprocess searches for such an additional task t whose effect entails . If there is such a task in the input task ontology,
Preprocess adds t in  and the state constraint (t, ) into . The state-constraint
(t, ) ensures that the condition  is supposed to be achieved after the decomposition
of t is done. As a result, if the task t is accomplished successfully during planning,
then the preference  will be satisfied as well.
sets of tasks T1 and T2 that can accomplish the effect  and 
task t in T1 with a label n, the subroutine chooses a task t
adds the task-network constraints (n  n), (n, ), and (n, ) to .
The preprocessing of final and sometime after preferences are are similar to

). In this case, Preprocess generates two
, respectively. For each
, and

 Preprocessing (sometime before  

in T2 with a label n

sometime and sometime before as described above.

After adding all task-ordering constraints into the task network w0 based on the
preferences in , the set of ordering and state constraints in w0 may not be satisfi-
able. For example, in a transportation-services domain as in [6], we may have both
(n1 : load(truck1, package1)  n2 : drive(truck1)) and (n2 : drive(truck1) 
n1 : load(truck1, package1)) in . As another example, we may also have a cyclic
constraint such as (n1 : drive(truck1)  n2 :
load(truck1, package1)), (n2 :
load(truck1, package1)  n3 : deliver(package1)) and (n3 : deliver(package1) 
n1 : drive(truck1)) in w0. There is no solution plan which can satisfy these HTN
constraints during the planning process. Thus, Preprocess, in such cases, greedily
?

?

?
removes the constraint with less weight from w0 in order to satisfy more important
preferences (i.e., preferences with smaller costs).

A couple of remarks on Preprocess are in order. First, it is important to note that
the additional HTN constraints that Preprocess adds to  is due to the translation 
of those preferences based on the additional tasks from the task ontology. Second, we
only work with final, sometime before, sometime after, and sometime
preferences in the preprocessing phase. The reason is that we can improve the cost
value by adding additional tasks for sometime and final, and rearrange task orderings for sometime before, sometime after, and sometime. As for other
preferences like always and at most once, we can only check their satisfaction in
decomposition and choose the best tuple in OP EN list by using best first search.

After rearranging the task network w = (, ), the algorithm computes the overall
violation-cost value v = (s0, w, ) and puts the tuple (s0, w, , v) in the OP EN list
(see Line 3), where  is the current partial plan. As we mentioned above, SCUP is an
HTN task-decomposition planner that is based on a best-first search procedure. At each
iteration of the loop, SCUP first takes the first tuple (s, w, , v)  OP EN and removes
it. If  is a solution composition (i.e., plan), then SCUP returns . Otherwise, the algorithm decomposes the task-network w according to the task-decomposition methods
in D, generates the set Succ of successor state and task-network pairs, computes the
violation costs for those new pairs in Succ, and puts them back in OP EN (see Line
9). The tuples in OP EN are then sorted in the ascending order of their violation costs.
This process continues until SCUP finds a solution or fails to generate a plan.

In Line 8 of Figure 1, the Decompose subroutine first nondeterministically chooses
a task t in w with no predecessors and finds the set A of all applicable operators and
methods for task t. If it cannot find any applicable operators or methods, it simply
returns failure. Otherwise, for each item u in A, Decompose does the following:
 If u is an operator, Decompose first generates the action a by applying input bindings to u. Then, it computes the next state s = (s, a), where s is the current state,
and the successor task-network w
by removing t from w. It appends a to the partial
plan .
 If u is a method, the subtasks w
will replace task t in w. The effects of each task in
w
is then used to check if any preference is satisfied or violated in the current state,
and thus, to update the overall cost. This helps us foresee the violation costs without
further decomposition, and decide whether we should continue on this task network.
Decompose adds in Succ the tuple with the same state s, the updated task nework
w

in w, and the same partial plan .

by replacing t with w

After the loop over all applicable operators and methods, Decompose checks and
removes duplicate tuples in Succ that are those which have the same task network and
partial plan, in order not to repeat the same decompositions during planning.

An example of how Decompose uses the task effects to compute the heuristic violation costs is in order. First, recall that the preprocessing phase generates the postcondition state-constraint (t, ) for each task t that is inserted into the task network
due to a preference. Once the planner completely decomposes t into a primitive task
network, Decompose checks if the post-condition  is satisfied in the current state.

N. Lin, U. Kuter, and E. Sirin

For example, suppose we have a task SendP ackage(package1, location3) with an
post-condition delivered(truck3, package1) due to a preference (p1 : sometime
delivered(truck3, package1)). The following is an abstract description of an OWL-S
service for SendP ackage:

Composite Service: SendPackage

Input Parameters: ( ?pac ?loc)
Local Parameters: (?truck)
Preconditions: ( available(?truck) )
ComposedOf: ( Load(?truck, ?package), Deliver(?truck, ?pac, ?loc) )
Results: ( delivered(?truck, ?pac) )

Note that truck3 is not the input to SendP ackage, and the HTN method that corresponds to the above service uses a variable ?truck to match any available trucks
near package1. Suppose the planner finds three trucks truck1, truck2, truck3 in the
current state. Then, it will create three tuples in Succ each possible truck. However,
since SendP ackage has the post-condition delivered(truck3, package1), only the tuple with the truck variable binding truck3 will satisfy the preference p1 and the others
will violate it, increasing their cost values. Thus, when the tuples in Succ are merged
into the OP EN list and sorted based on the costs of its tuples, SCUP will always
consider the tuple that satisfies the preference p1.

6 Implementation and Preliminary Experiments

We have implemented a prototype of the SCUP algorithm. Our current prototype is
built on our previous WSC system HTN-DL [15]. HTN-DL does not directly implement our planning language as we described in Section 2. Thus, we assumed that the
translation from OWL-S to HTN-DL has been done automatically as described in [15]
and we implemented the translation of user preferences from PDDL3 into HTN-DLs
input language. Furthermore, we used the interface functionality between HTN-DL and
Pellet, an OWL DL reasoner [18], that we used in our SCUP prototype for knowledge
inference and ontological reasoning.

During planning, the size of SCUPs OP EN list may get very large and this may
induce serious performance drawbacks for the SCUP algorithm. For that reason, we implemented an additional input parameter k that bounds the size of the OP EN , which,
as a trade-off, may affect the solution plan quality. If k is too small, a tuple in OP EN
with prospective solution may be discarded in the first few decompositions. This happens when the local optimal search node is not the global optimal search node. In our
experiments described below, we used k = 20 as the size of the OP EN list and this
was sufficient to generate optimal (or in some cases, near-optimal) solutions.

We have designed the following preliminary experiments with SCUP in order to
evaluate our planners performances with compared to other approaches. Since, to the
best of our knowledge, the only preference-based WSC techniques are based on AI
planning algorithms, we have chosen an AI planning algorithm, SGPlan [10,11], that
was participated in the Planning with Qualitative Preferences track of the most recent International Planning Competition (IPC-5) (http://zeus.ing.unibs.it/
ipc-5/), and won the 1st place; hence, it is considered as the state-of-the-art
?

?

?
Fig. 2. The violation costs of the solutions generated by SCUP and SGPlan on the Trucks
problems

technique for preference-based planning. We have not run the SGPlan ourselves for our
experiments; instead, we used the published results for it from the IPC-5 [9]. Note that
this does not affect our results since we are comparing SCUP with SGPlan on the costs
of their solutions and neither of the planners had any memory issues in our experiments.
We have conducted experiments with two benchmark planning domains used in IPC-
5: Trucks and Rovers. In the Trucks domain, the goal is to move packages between locations by using trucks. There are only four operators load, drive, unload, and deliver.
Each truck may have multiple truck areas so as to carry packages, but there are constraints and penalties on the ordering of loading packages and the input user preferences
model choices over the trucks based on those constraints. Generally, loading multiple
packages will result in preference violations, and on the other hand, delivering only a
single package at a time may delay the delivering deadlines of other packages.

In the Rovers domain, the goal is to navigate the rovers on a planet surface, collect
scientific data such as rock and soil samples, and send them back to a lander. These
tasks need to be achieved by considering the input spatial constraints and temporal
preferences on the operation of a rover. Each rover has only a limited storage capacity
for the collected samples and it is only capable of sampling either soil, rock, image, or
some combination of them specified in the problem descriptions. A rover can only travel
between certain waypoints only when the path from source to destination is visible.

We used the exact planning domain and problem descriptions that were used in IPC-
5. For each planning domain, we have 20 problems with increasing number of instances,
goals and preferences. In our experiments, we compared the overall violation cost values of the solutions generated by SCUP and SGPlan.

Figure 2 shows our results in the Trucks domain. SCUP has generated solutions that
have cost values that are substantially less than SGPlan in all 20 problems, where SCUP
satisfied all preferences in 8 of the experimental problems. The average cost value for
SCUP is 2.00, less than one-third of SGPlans average 7.45. Most violations in SCUP

N. Lin, U. Kuter, and E. Sirin

Fig. 3. The violation costs of the solutions generated by SCUP and SGPlan on the smaller Rover
problems

Fig. 4. The violation costs of the solutions generated by SCUP and SGPlan on the larger Rover
problems

solutions result from the conflicts between preferences; e.g., delivering multiple packages on a particular truck is necessary to satisfy delivery deadline preferences that had
larger costs, and this unavoidably causes violations of using multiple truck areas.

Figures 3 and 4 illustrate how SCUP and SGPlan performed in the Rovers domain.
SCUP has outperfermed SGPlan in 19 out of 20 problems. In these experiments, we
found that as the size of the problems is increased, SCUP discarded possible solution
tuples due to the OP EN list size limitation. However, generally SCUP has higher
quality solutions with average cost value 888.645, compared to SGPlans 1608.378.
?

?

?
7 Related Work

There has been many advances in WSC planning in the recent years [2,4,6,19,20,21].
Probably the first work in this research area is the one described in [2], where the states
of the world and the world-altering actions are modeled as Golog programs, and the
information-providing services are modeled as external functions calls made within
those programs. The goal is stated as a Prolog-like query and the answer to that query
is a sequence of world-altering actions that achieves the goal, when executed in the
initial state of the world. During the composition process, however, it is assumed that
no world-altering services are executed. Instead, their effects are simulated in order to
keep track of the state transitions that will occur when they are actually executed.

In [4], the WSC procedure is based on the relationship between the OWL-S process
ontology [7] used for describing Web services and Hierarchical Task Networks as in
HTN Planning [17]. OWL-S processes are translated into tasks to be achieved by the
SHOP2 planner [17], and SHOP2 generates a collection of atomic process instances
that achieves the desired functionality. [6] extended this work to cope better with the
fact that information-providing Web services may not return the needed information
immediately, or at all. The ENQUIRER algorithm presented there does not cease the
search process while waiting answers to some of its queries, but keeps searching for
alternative compositions that do not depend on answering those specific queries.

In all works above, search for desirable solutions have been incorporated into the
service-composition process as hard constraints; i.e., constraints that must be satisfied
by all of the solutions. Recently, several different approaches have been developed for
planning with preferences; i.e., soft constraints that are preferably but not necessarily
satisfied by a plan. There are various different approaches for integrating user preferences in the planning process. Examples include [22,23,10,24].

In our experimental study here, we considered one of those state-of-the-art planners,
SGPlan [10,11], that won the recent International Planning Competition in the Plan-
ning with Qualitative Preferences track. SGPlan is a planning algorithm that uses a
divide-and-conquer approach: the planner serializes a large planning problem into subproblems with subgoals, solves the sub-problems, merges the solutions to those sub-
problems, and tries to remove conflicts between them. It has been demonstrated in
experimental studies that this approach largely reduces the search space compared to
the state-space of the original problem.

In another work that is very related to our paper, Baier et al. proposed the heuristicsearch planner HPlan-P in [24]. They used a best-first search algorithm with a goal
distance function to find the first solution, and tried to improve solution by using other
heuristics. Unfortunately, we were not able to get the HPlan-P planner for experimentation due to its distribution-licensing problems at the time we personally communicated
with the authors of that planner, and since SGPlan significantly outperformed HPlan-P
in IPC-5, we have not included its results here.

8 Conclusions and Future Work

In many interesting Web Service Composition (WSC) problems, the goal is to generate
desirable solutions with respect to some user preferences that are not necessarily abso-

N. Lin, U. Kuter, and E. Sirin

lute objectives or constraints, but a composition algorithm needs to try to satisfy them
as much as possible. In this paper, we have described a novel approach for incorporating user preferences in planning for Web Service Composition. We have first described
a way to take OWL-S service descriptions and PDDL3-style preferences, and translate them into a planning language for Hierarchical Task Networks (HTNs). Based on
this translation, we have then described an HTN planning algorithm, called SCUP, that
combines HTN planning and best-first search for WSC planning with preferences.

Our preliminary experiments demonstrated that SCUP is a promising approach: our
prototype implementation of SCUP was able to generate solutions that satisfy more
user preferences and those preferences that have more value (i.e., less cost) than the
state-of-the-art planner SGPlan, the winner of the latest International Planning Competition in the Planning with Qualitative Preferences track.

In the near future, we are planning to conduct extensive theoretical and experimental
evaluation of our approach. In parallel to that evaluation, there are a couple of future
research direction based on our work described in this paper. One possible direction is
to develop ways to augment user preferences directly into OWL-S process models by
representing them in OWL. This will enable us to use encode and reason about user
preferences in real Semantic Web services on the Web.

In another direction, we have just started a new research project based on SCUP
that will focus on reasoning about user preferences in a social setting; in this project,
our objective is to develop ways to represent user preferences based on social factors
such as trust and confidence in social networks. As Web-based social networks is a very
important research area, this will enable us to investigate Web services in the existing
social settings and how users generate service compositions to achieve their objectives
based on social factors.

Acknowledgments. This work was supported in part by DARPAs Integrated Learning
Program. The opinions in this paper are those of the author and do not necessarily reflect
the opinions of the funders.
