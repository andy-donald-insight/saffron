Finite Model Reasoning in DL-Lite

Riccardo Rosati

Dipartimento di Informatica e Sistemistica

Sapienza Universit`a di Roma

Via Ariosto 25, 00185 Roma, Italy
rosati@dis.uniroma1.it

Abstract. The semantics of OWL-DL and its subclasses are based on the classical semantics of first-order logic, in which the interpretation domain may be
an infinite set. This constitutes a serious expressive limitation for such ontology
languages, since, in many real application scenarios for the Semantic Web, the
domain of interest is actually finite, although the exact cardinality of the domain
is unknown. Hence, in these cases the formal semantics of the OWL-DL ontology
does not coincide with its intended semantics. In this paper we start filling this
gap, by considering the subclasses of OWL-DL which correspond to the logics of
the DL-Lite family, and studying reasoning over finite models in such logics. In
particular, we mainly consider two reasoning problems: deciding satisfiability of
an ontology, and answering unions of conjunctive queries (UCQs) over an ontol-
ogy. We first consider the description logic DL-LiteR and show that, for the two
above mentioned problems, finite model reasoning coincides with classical rea-
soning, i.e., reasoning over arbitrary, unrestricted models. Then, we analyze the
description logics DL-LiteF and DL-LiteA. Differently from DL-LiteR, in such
logics finite model reasoning does not coincide with classical reasoning. To solve
satisfiability and query answering over finite models in these logics, we define
techniques which reduce polynomially both the above reasoning problems over
finite models to the corresponding problem over arbitrary models. Thus, for all
the DL-Lite languages considered, the good computational properties of satisfiability and query answering under the classical semantics also hold under the
finite model semantics. Moreover, we have effectively and easily implemented
the above techniques, extending the DL-Lite reasoner QuOnto with support for
finite model reasoning.

1 Introduction

The semantics of OWL-DL [3] and its fragments [8] are based on the classical semantics
of first-order logic, in which the interpretation domain may be either a finite or an
infinite set. This constitutes a serious expressive limitation for these ontology languages,
since in many real application scenarios for the Semantic Web, the domain of interest
is actually finite, although the exact cardinality of the domain is unknown. Hence, in
these cases the formal semantics of the OWL-DL ontology does not coincide with its
intended semantics.

We illustrate the above problem through two simple examples (in the following ex-
amples, the ontologies are expressed using the DL-LiteF language, which corresponds
to a fragment of OWL-DL: DL-LiteF is formally introduced in Section 2).

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 215229, 2008.
c Springer-Verlag Berlin Heidelberg 2008
?

?

?
Example 1. Let O be the following ontology about employees:

Employee  isHelpedBy
isHelpedBy
  Employee
  HighSalary
isHelpedBy

(funct isHelpedBy
)
Employee(Paul)

(1)
(2)
(3)
(4)
(5)

which formalizes the following knowledge about the concepts Employee, HighSalary
and the role isHelpedBy:

 every employee has some colleague who is committed to help her/him to perform

some special task (assertion (1));

 those who are committed to help employees are also employees (assertion (2)) and

have a high salary (assertion (3));

= d0;

for each i  0.

 an employee can commit to help at most one of her/his colleagues (assertion (4));
 Paul is an employee (assertion (5)).
Now, on the one hand, it can be shown that the ontology O does not entail (under
the standard OWL-DL semantics) HighSalary(Paul): indeed, consider the following
interpretation I over the countably infinite domain {d0, . . . , dn, . . .}:

 Paul
 di  Employee
for each i  0;

 di  HighSalary
for each i  1;

 di, di+1  isHelpedBy

It is immediate to verify that I satisfies the ontology O and that HighSalary(Paul) is
not satisfied in I.
On the other hand, every finite model for O satisfies HighSalary(Paul). In fact, if
the domain is finite, then the chain of employees induced by the ontology on the binary relation isHelpedBy must be finite, so the only possible way to close such a chain
is to come back to the initial employee, i.e., Paul, who is the only employee who
does not help someone yet. Consequently, in every finite model for O, Paul helps some
colleague, hence he has a high salary.
Now, for the above ontology O it seems very natural to assume that the domain of
interest is always finite (although not exactly known), i.e., it is unreasonable to assume
as possible the existence of an infinite number of employees. Hence, in this case we
would like to conclude from the above ontology that Paul has a high salary. However,
all current OWL reasoners will not derive such a conclusion.
Example 2. Let O be the following ontology about peer networks:

EUpeer  hasNAmirror
hasNAmirror
  NApeer
NApeer  hasEUmirror

(6)
(7)
(8)
?

?

?
hasEUmirror

Finite Model Reasoning in DL-Lite
  EUpeer
  AlwaysOnline

(funct hasNAmirror
)

(funct hasEUmirror
)
EUpeer(dis.uniroma1.it)

(9)
(10)
(11)
(12)
(13)

which formalizes the following knowledge about the concepts EUpeer, NApeer,
AlwaysOnline and the roles hasNAmirror, hasEUmirror:

 every European peer has a mirror who is a North American peer (assertions (6)

and (7));

 every North American peer has a mirror who is a European peer (assertions (8)

and (9));

 peers who are mirrors of North American peers are always on-line (assertion (10));
 a peer can be the mirror of at most one North American peer (assertion (11)) and

of at most one European peer (assertion (12));

 dis.uniroma1.it is a European peer (assertion (13)).
In a way similar to the previous example, it can be shown that O does not entail (under
the standard OWL-DL semantics) AlwaysOnline(dis.uniroma1.it), while every
finite model for O satisfies AlwaysOnline(dis.uniroma1.it). Similarly to the previous example, also for the above ontology O it seems very natural to assume that
the domain of interest is always finite. Hence, we would like to conclude that peer
dis.uniroma1.it is always on-line, but all current OWL reasoners will not derive
such a conclusion.

The above examples highlight the fact that OWL-DL ontologies (under the classical
first-order semantics) lack the ability to properly handle finite domains of interest. In
this respect, it is also important to point out that database applications are always based
on a finite domain assumption: such an assumption should be taken into account in
ontology-based access to database information sources, which is going to be one of the
prominent applications of the Semantic Web technology [12].

Finite model reasoning has actually been studied in past research in Description Logics (DLs) [2], which constitute the logical basis of OWL-DL. In particular, besides previous studies summarized in [2], recent research has mainly focused on ALCQI, a large
fragment of OWL-DL [4,10]: for such a logic, an EXPTIME-completeness result for fi-
nite model reasoning has been established [10]. However, such results on finite model
reasoning in DLs only consider classical DL reasoning tasks (concept subsumption,
knowledge base satisfiability) and do not take query answering into account. Moreover,
none of the currently available (OWL)DL reasoners supports finite model reasoning.

Thus, with respect to finite model reasoning in OWL-DL ontologies, we are still
missing: (i) a thorough computational analysis, in particular for tractable fragments of
OWL-DL [8]; (ii) an analysis of query answering over finite models; (iii) the implementation of ontology-management systems supporting finite model reasoning.

In this paper we start filling this gap, by considering the subclasses of OWL-DL
which correspond to the logics of the DL-Lite family of Description Logics [6], and

R. Rosati

study reasoning over finite models in such logics. In particular, we consider three
reasoning problems: deciding entailment of intensional assertions (TBox entailment),
deciding satisfiability of the ontology, and answering queries (specifically, unions of
conjunctive queries) over an ontology.

Our contributions can be summarized as follows:

1. We first consider the description logic DL-LiteR and show that, for all the above
mentioned problems, finite model reasoning coincides with classical reasoning, i.e.,
reasoning over arbitrary, unrestricted models.

2. Then, we analyze the description logics DL-LiteF and DL-LiteA. Differently from
DL-LiteR, in such logics finite model reasoning does not coincide with classical
reasoning. To solve TBox entailment, satisfiability and query answering over fi-
nite models in these logics, we define techniques which reduce polynomially all
the above reasoning problems over finite models in such logics to the corresponding problem over arbitrary models. This allows us to show that, for all the DL-Lite
languages considered, the good computational properties of TBox entailment, satisfiability and query answering under the classical semantics also hold under the
finite semantics.

3. Finally, we have effectively and easily implemented the above techniques to provide the DL-Lite reasoner QuOnto with support for finite model reasoning. To the
best of our knowledge, such an extension of QuOnto constitutes the first ontology
management system providing an automated support to finite model reasoning.

2 The Description Logics DL-LiteF and DL-LiteR

2.1 Syntax

We start from three mutually disjoint alphabets: an alphabet of concept names, an alphabet of role names, and an alphabet of constant (or individual) names. We call basic
concept an expression of the form B ::= A | P | P 
, where A is a concept name
and P is a role name, and we call basic role an expression of the form R ::= P | P 
,
where P is a role name.

A DL-LiteR TBox assertion is an expression of one of the following forms:
 B1  B2 (concept inclusion assertion) where B1, B2 are basic concepts;
 R1  R2 (role inclusion assertion) where R1, R2 are basic roles;
 B1  B2 (concept disjointness assertion) where B1, B2 are basic concepts;
 R1  R2 (role disjointness assertion) where R1, R2 are basic roles;
A DL-LiteF TBox assertion is an expression of one of the following forms:
 B1  B2 (concept inclusion assertion) where B1, B2 are basic concepts;
 B1  B2 (concept disjointness assertion) where B1, B2 are basic concepts;
 (funct R) (functionality assertion) where R is a basic role.

A DL-LiteR TBox is a set of DL-LiteR TBox assertions, while a DL-LiteF TBox is a
set of DL-LiteF TBox assertions.
?

?

?
A membership assertion is a ground atom, i.e., an expression of the form A(a),

P (a, b) where A is a concept name, P is a role name, and a, b are constant names.

An ABox is a set of membership assertions.
A DL-LiteR knowledge base (KB) is a pair K = T ,A where T is a DL-LiteR
TBox and A is an ABox. Analogously, a DL-LiteF KB is a pair K = T ,A where T
is a DL-LiteF TBox and A is an ABox.


F TBox a DL-LiteF TBox without disjointness assertions. Analo-


R TBox a DL-LiteR TBox without disjointness assertions.

gously, We call DL-Lite

We call DL-Lite

We now introduce queries. A union of conjunctive query (UCQ) is an expression of

{x1, . . . , xn | conj1  . . .  conjm

the form
where n  0, m  1, and each conji is an expression of the form (y1, . . . , yj.a1 
. . .  ah), where j  0, h  1, each ai is an atom, i.e., an expression of the form A(t)
or P (t, t) where A is a concept name, P is a role name and t, t
are either constants
or variables from {x1, . . . , xn, y1, . . . , yj}. When n = 0 (i.e., the above expression is a
first-order sentence) the UCQ is called a Boolean UCQ.

}

over I

. (o, o)  RI}

2.2 Semantics
The semantics of a DL is given in terms of interpretations, where an interpretation
I = (I ,I) consists of a non-empty interpretation domain I
and an interpretation
function I
of I
, and to each role R a
binary relation RI

that assigns to each concept C a subset CI

An interpretation I is a model of B  C, where C is either a basic concept or the
. Similarly, I is a model of R  E, where R is

. In particular, we have:
AI  I
P I  I  I
(P )I = {(o2, o1) | (o1, o2)  P I}
(R)I = {o | o
(B)I = I \ BI
(R)I = I  I \ RI
An interpretation I = (I ,I) is called finite if I
negation of a basic concept, if BI  CI
a basic role and E is either a basic role or the negation of a basic role, if RI  EI
To specify the semantics of membership assertions, we extend the interpretation
function to constants, by assigning to each constant a a distinct object aI  I
. Note
that this implies that we enforce the unique name assumption on constants [2]. An interpretation I is a model of a membership assertion A(a), (resp., P (a, b)) if aI  AI
(resp., (aI , bI)  P I
Given an (inclusion, or membership) assertion , and an interpretation I, we denote
by I |=  the fact that I is a model of . Given a (finite) set of assertions , we
denote by I |=  the fact that I is a model of every assertion in . A model of a KB
K = T ,A is an interpretation I such that I |= T and I |= A. A finite interpretation
that is a model of a KB K is called finite model of K.

is a finite set.

).

.

The reasoning tasks we are interested in are UCQ entailment, KB satisfiability, and

TBox entailment. More precisely:
?

?

?
 A KB K entails a Boolean UCQ q, denoted by K |= q, if all models of K are also
models of q (where an interpretation I is a model of q if I satisfies the first-order
sentence q according to the standard notion of satisfiability in first-order logic). K
finitely entails a UCQ q, denoted by K |=fin q, if all finite models of K are also
models of q;

 a KB is satisfiable if it has at least one model, and is finitely satisfiable if it has at
least one finite model.
 a TBox T entails a TBox assertion , denoted by T |= , if all models of T are also
models of , while T finitely entails , denoted by T |=fin , if all finite models of
T are also models of .

Since in the following we will focus on UCQ entailment, from now on when we speak
about UCQs we always mean Boolean UCQs. We recall that answering arbitrary (i.e.,
non-Boolean) UCQs can be easily reduced to UCQ entailment (for more details see
e.g. [9]).

3 Finite Model Reasoning in DL-LiteR

In this section we show that, in DL-LiteR, finite model reasoning coincides with classi-

cal reasoning. We start by proving such property for DL-Lite
R KBs (i.e., DL-LiteR KBs
without disjointness assertions) and for UCQ entailment.
R-TBox, and let q be a UCQ. Then, for every ABox A,
Lemma 1. Let T be a DL-Lite

T ,A |=fin q iff T ,A |= q.
Proof. The proof is a consequence of Theorem 4 of [11], since a DL-LiteR KB corresponds to a database with inclusion dependencies (interpreted under open-world as-
sumption). More precisely, given a DL-LiteR KB K = T ,A, we build a database
instance (i.e., a set of facts) D and a set of inclusion dependencies C as follows:
 for every concept name A (respectively, role name R) occurring in K, the database
schema contains a unary relation A (respectively, a binary relation R)
 for every concept inclusion in T of the form A1  A2, C contains the inclusion
dependency A1[1]  A2[1];
), C
 for every concept inclusion in T of the form A  R (respectively, A  R
contains the inclusion dependency A[1]  R[1] (respectively, A[1]  R[2]);
 for every concept inclusion in T of the form R  A (respectively, R  A), C
contains the inclusion dependency R[1]  A[1] (respectively, R[2]  A[1]);
 for every concept inclusion in T of the form R1  R2 (respectively, R1 
2 ), C contains the inclusion dependency R1[1]  R2[1] (respectively, R1[1] 
R
R2[2]);

R
2 ), C contains the inclusion dependency R1[2]  R2[1] (respectively, R1[2] 
R2[2]);
2 ), C
 for every role inclusion in T of the form R1  R2 (respectively, R1  R
contains the inclusion dependency R1[1, 2]  R2[1, 2] (respectively, R1[1, 2] 
R2[2, 1]);

 for every concept inclusion in T of the form R

 R2 (respectively, R
?

?

?
 for every role inclusion in T of the form R
2 ), C
contains the inclusion dependency R1[2, 1]  R2[1, 2] (respectively, R1[2, 1] 
R2[2, 1]).

 R2 (respectively, R

 R

Finally, for every membership assertion of the form A(a) (respectively, R(a, b)) in the
ABox A, the database instance D contains the fact A(a) (respectively, R(a, b)).
We now recall the definition of [11] of semantics of the pair (C,D): we denote by
sem(C,D) the set of database instances {B | B  D and B satisfies C}, where each B
is a (possibly infinite) set of facts. Moreover, we denote by semf (C,D) the subset of
sem(C,D) where each B is a finite set of facts.
It is now immediate to verify that the set of models of K is in one-to-one correspondence with sem(C,D): more precisely, every database instance B in sem(C,D)
corresponds to a model I(B) of K where I(B) is the interpretation defined as follows:
for each concept name C and for each constant a, a  CI(B) iff C(a)  B, and for
each role name R and pair of constant a, b, a, b  RI(B) iff R(a, b)  B.
This in turn immediately implies that for every UCQ q, T ,A |= q iff q is true
in all database instances of sem(C,D), and T ,A |=fin q iff q is true in all database
instances of semf (C,D). Since from Theorem 4 of [11] q is true in all database instances
of sem(C,D) iff q is true in all database instances of semf (C,D), the thesis follows.

We now extend the above result to arbitrary DL-LiteR KBs (i.e., KBs whose TBox may
also contain disjointness assertions).
Given a DL-LiteR TBox T , let D(T ) denote the set of disjointness assertions occurring in T , and let T  = T  D(T ), i.e., T 
denotes the TBox obtained from T by
eliminating all disjointness assertions.

Given a disjointness assertion , we denote by Q() the Boolean conjunctive query

defined as follows:
 if  = A1  A2, then Q() = x.A1(x)  A2(x);
 if  = A  R or  = R  A, then Q() = x, y.A(x)  R(x, y);
 if  = A  R
 if  = R1  R2, then Q() = x, y, z.R1(x, y)  R2(x, z);
 if  = R1  R
R2(z, x);
 R
 if  = R
Informally, Q() is satisfied in an interpretation I iff I does not satisfy the disjointness
assertion .

or  = R  A, then Q() = x, y.A(x)  R(y, x);
2 or  = R
2 , then Q() = x, y, z.R1(y, x)  R2(z, x).

 R1, then Q() = x, y, z.R1(x, y) 

Furthermore, given a set of disjointness assertions , we define Q() as the follow-

ing UCQ:

Q() =
?

?

?


Q()

Lemma 2. Let T be a DL-LiteR-TBox, and let q be a UCQ. Then, for every UCQ
q, T ,A |= q iff T ,A |= q  Q(D(T )) and T ,A |=fin q iff T ,A |=fin
q  Q(D(T )).
?

?

?
Proof. It is immediate to verify that D(T ) corresponds to a first-order sentence 
which is equivalent to Q(D(T )), therefore from the deduction theorem it follows
that T ,A |=fin q iff T ,A |=fin q  Q(D(T )). Moreover, since T 

is a DL-Lite
TBox, from Theorem 1 it follows that T ,A |=fin q  Q(D(T )) iff T ,A |=

q  Q(D(T )).

As an immediate consequence of Lemma 2 and of Lemma 1, we obtain the following
property.
Theorem 1. Let T be a DL-LiteR-TBox, and let q be a UCQ. Then, for every ABox A,
T ,A |=fin q iff T ,A |= q.
Then, we turn our attention to KB satisfiability. It can easily be shown that the technique
for reducing KB unsatisfiability in DL-LiteR to UCQ entailment (see Lemma 16 of [6])
is also correct when we restrict to finite models. This fact and Theorem 1 imply the
following property.
Theorem 2. Let K be a DL-LiteR KB. Then, K is finitely satisfiable iff K is satisfiable.
Moreover, it can also be shown that the technique for reducing TBox entailment in
DL-LiteR to KB unsatisfiability (see Theorem 22 and Theorem 23 of [6]) is also correct
when we restrict to finite models. Consequently, the two previous theorems imply the
following property.
Theorem 3. Let T be a DL-LiteR-TBox, and let  be a DL-LiteR TBox assertion. Then,
T |=fin  iff T |= .

4 Finite Model Reasoning in DL-LiteF

In this section we study finite model reasoning in DL-LiteF . First, we remark that,
differently from the case of DL-LiteR, in DL-LiteF UCQ entailment over finite models
differs from UCQ entailment over arbitrary models, as illustrated by both Example 1
and Example 2. So, since we cannot simply establish an equivalence between classical
reasoning and finite model reasoning as in the case of DL-LiteR, we must look for new
reasoning methods to solve finite model reasoning in DL-LiteF .


F KBs (i.e., DL-LiteF KBs without disjointness as-

We start by considering DL-Lite

sertions) and define inference rules for TBox assertions in DL-Lite


F .


4.1 Finite TBox Inference Rules in DL-Lite

In the following, R denotes a basic role expression (i.e., either P or P 
role name), while R
R = P 

where P is a
denotes the inverse of R, i.e., if R = P (R is a role name), then

, while if R = P 

, then R = P .
F TBox T , finClosureF (T ) denotes the closure of T


Definition 1. Given a DL-Lite
with respect to the following inference rules:
?

?

?
1. (inclusion-rule) if B1  B2 and B2  B3 then conclude B1  B3;
2. (functionality-inclusion-cycle-rule) if there is an inclusion-functionality cycle, i.e.,

a sequence of TBox assertions of the form

(funct R1), R2  R
. . . , (funct Rk), R1  R

k

, (funct R2), R3  R

,

. . .

(where each Ri is a basic role expression, i.e., either P or P 

), then conclude
 R3, . . .

1 ), R
(funct R
. . . , (funct R

 R2, (funct R

2 ), R

k ), R

k

 R1

It is immediate to verify that the above inference rules are not sound with respect to
classical TBox entailment (i.e., entailment over unrestricted models). On the other hand,
we now prove that the above inference rules are sound with respect to TBox entailment
over finite models.
Lemma 3. Let T be a DL-Lite
finClosureF (T ) |=  then T |=fin .
Proof. The proof is a consequence of the axiomatization for unary inclusion dependencies and functional dependencies presented in [7].


F TBox and let  be a DL-Lite


F TBox assertion. If

We call a TBox f-closed if it is closed with respect to the two inference rules above.


4.2 Query Answering over Finite Models in DL-Lite


F KBs. NoWe now turn our attention to query answering over finite models in DL-Lite
tice that Lemma 3 does not imply that query answering over finite models can be solved
by simply augmenting the TBox with the new assertions implied by Definition 1. How-
ever, we now show that this strategy is actually complete, i.e., we can answer (unions
F KB K = T ,A by first gen-

of) conjunctive queries over finite models of a DL-Lite
erating the augmented TBox T 
obtained from T by adding the new assertions implied
by Definition 1, and then computing the certain answers to queries over the KB T ,A
according to the unrestricted semantics.
Theorem 4. Let T be a DL-Lite
T ,A |=fin q iff finClosure F (T ),A |= q.
Proof(sketch). The proof is rather involved and is based on the notion of chase of a
DL-Lite KB [6]. More precisely, we modify the notion of (generally infinite) chase of
a DL-LiteF KB, denoted by chase(K) and presented in [6], thus defining the notion of
finite chase of degree k of K, denoted by finChase F
Informally, chase(K) is an ABox built starting from the initial ABox A and applying a chase expansion rule that adds new membership assertions to the ABox until all
inclusions in T are satisfied. In this expansion process new constants are introduced
in the ABox, and in the presence of cyclic concept inclusions this process may produce an infinite ABox. The important semantic properties of chase(K) are the follow-
ing: (i) chase(K) is isomorphic to an interpretation I(chase(K)) which is a model

F -TBox, and let q be a UCQ. Then, for every ABox A,


k (K).
?

?

?
k (K) is isomorphic to an interpretation I(finChase F
model of K, under the assumption that the TBox T of K is f-closed;

k (K)) which is a
(B) for every positive integer k, entailment of a UCQ of length less or equal to k (i.e.,
all of whose conjunctions have a number of atoms less or equal to k) can be decided
by simply evaluating the query over I(finChase F

k (K)).

R. Rosati

of K; (ii) UCQ entailment over K can be solved by simply evaluating the query over
I(chase(K)).

We modify the above chase procedure and define a chase procedure, called
k (K) (parameterized with respect to a positive integer k), that always termifinChase F
k (K) only partially
nates, thus returning a finite ABox. Then, we prove that finChase F
preserves the above semantic properties of the chase with respect to finite model se-
mantics. More precisely, we prove that:

k (K) in place, we can prove the theorem as follows. First,
With the notion of finChase F
let K = T ,A and K = finClosure F (T ),A. Soundness is trivial: if K |=fin q, then
K |=fin q, and since the set of finite models of K
is a subset of the set of models of
, it follows that K |= q. To prove completeness, assume that K |= q and let k be
K
the length of q. Now, by property (A) above, I(finChase F
k (K)) is a finite model of K
,
k (K)) is a model of K. Finally, since K |= q, from the
and by Lemma 3, I(finChase F
above property (B) it follows that I(finChase F
k (K)) |= q, which in turn implies that
K |=fin q.

4.3 Query Answering over Finite Models in DL-LiteF

It is now immediate to extend the above theorem to DL-LiteF , since it is possible to
encode disjointness assertions in the UCQ, as illustrated already in Section 3. Given a
DL-LiteF TBox T , let D(T ) denote the set of disjointness assertions occurring in T ,
and let T  = T  D(T ), i.e., T 
F TBox obtained from T by

eliminating all disjointness assertions.
Theorem 5. Let T be a DL-LiteF -TBox, and let q be a UCQ. Then, for every ABox A,
T ,A |=fin q iff finClosure F (T ),A |= q  Q(D(T )).

denotes the DL-Lite

4.4 Finite KB Satisfiability and TBox Entailment

We now focus on KB satisfiability. Again, we start by showing that, differently from the
case of DL-LiteR, in DL-LiteF finite KB satisfiability does not coincide with classical
KB saisfiability. In particular, there are DL-LiteF KBs that only admit infinite models.
Example 3. Let T be the following DL-LiteF TBox:

A  R

A  R

R  R

(funct R

)

and let A be the ABox A = {A(a)}. It is easy to see that the KB K = T ,A is not
finitely satisfiable, while K is satisfiable (i.e., there are models for K but they are all
infinite).
?

?

?
To compute finite KB satisfiability, it is possible to show that the technique for reducing
KB unsatisfiability in DL-LiteF to UCQ entailment (see Lemma 16 of [6]) is also correct
when we restrict to finite models. This fact and Theorem 5 imply that we can reduce
finite KB satisfiability in DL-LiteF to standard KB satisfiability. Formally, the following
property holds:
Theorem 6. Let K be a DL-LiteF KB. Then, K is finitely satisfiable iff T 
finClosureF (T ),A is satisfiable.
It also turns out that finite TBox entailment in DL-LiteF can be reduced to finite KB
unsatisfiability. In fact, it is easy to show that Theorem 22 and Theorem 24 of [6]
hold also when restricting to finite models, while Theorem 25 of [6] holds for finite
models under the assumption that the TBox T is f-closed. Consequently, the following
property holds.
Theorem 7. Let T be a DL-LiteF -TBox, and let  be a DL-LiteF TBox assertion. Then,
T |=fin  iff T  finClosure F (T ) |= .

5 Complexity Results

We now study the computational complexity of finite model reasoning in DL-LiteR and
DL-LiteF .

First, in the case of DL-LiteR, the theorems shown in Section 3 immediately imply
that, for the reasoning tasks considered in this paper, the complexity of finite model reasoning and of classical reasoning coincide. Hence, the complexity results for DL-LiteR
reported in [6] also holds when restricting to finite models.

We now analyze complexity in the case of DL-LiteF . First, we show the following

property.

F TBox T and a DL-Lite


F TBox assertion , T |=fin 


Lemma 4. Given a DL-Lite
can be decided in polynomial time with respect to the size of T  {}.
Moreover, by definition, finClosureF (T ) is only composed of DL-Lite

F TBox assertions using concept and role names occurring in T , and the number of possible

F TBox assertions using such names is quadratic with respect to the size of
DL-Lite
T . Thus, from the above lemma, it follows that finClosureF (T ) can be computed in
polynomial time with respect to the size of T . Furthermore, it is immediate to see that
Q(D(T )) can also be computed in polynomial time with respect to the size of T .

Therefore, from the theorems shown in Section 4, it follows that the complexity

results for DL-LiteF reported in [6] also holds when restricting to finite models.

The above results are formally summarized as follows:

Theorem 8. Deciding UCQ entailment over finite models in DL-LiteR and DL-LiteF is:

 in LOGSPACE with respect to the size of the ABox;
 in PTIME with respect to the size of the KB;
 NP-complete with respect to the size of the KB and the query.

R. Rosati

Theorem 9. Let K be either a DL-LiteR or a DL-LiteF KB. Deciding whether K is
finitely satisfiable is:

 in LOGSPACE with respect to the size of the ABox;
 in PTIME with respect to the size of the TBox;
 in PTIME with respect to the size of the KB.
Theorem 10. Finite entailment of an assertion  with respect to a TBox T in DL-LiteR
and DL-LiteF can be decided in PTIME with respect to the size of T  {}.

6 Extension to DL-LiteA

In this section we extend the previous results for finite model reasoning to the case
of DL-LiteA. Due to space limitations, in the present version of the paper we are not
able to introduce DL-LiteA in detail (see [5]) and just sketch the way in which we have
extended the previous results to the case of DL-LiteA KBs.

Informally, a DL-LiteA TBox is a TBox which admits all the TBox assertions allowed in both DL-LiteF and DL-LiteR with the following limitation: a functional role
cannot be specialized, i.e., if the assertion (funct R) or (funct R) is in the TBox,
then there is no role inclusion assertion of the form R  R or of the form R  R
in
the TBox. Moreover, DL-LiteA allows for defining concept attributes, i.e, binary relations whose ranges, called value-domains, are concepts interpreted over a domain that
is disjoint from the interpretation domain of ordinary concept and roles. A DL-LiteA
TBox allows for value-domain inclusion/disjointness assertions and for attribute inclu-
sion/disjointness assertions. We refer the reader to [5] for more details.

cept or role or value-domain or attribute) disjointness assertions.


A the version of DL-LiteA that does not allow for (con-
A TBox T , we denote by finClosureA(T ) the closure of T with


respect to the following inference rules:
1. (binary-inclusion-rule) if R1  R2 is either a role inclusion assertion or an attribute
2. (transitivity-rule) if B1  B2 and B2  B3 then conclude B1  B3;
3. (functionality-inclusion-cycle-rule) if there is an inclusion-functionality cycle, i.e.,

inclusion assertion, then conclude R1  R2 and R

 R
2 ;

a sequence of TBox assertions of the form

(funct R1), R2  R
. . . , (funct Rk), R1  R

k

, (funct R2), R3  R

,

. . .

(where each Ri is a basic role expression, i.e., either P or P 
2 ), R

 R2, (funct R

1 ), R
(funct R
. . . , (funct R

 R1

k ), R

k

), then conclude
 R3,

. . .

Observe that, with respect to finClosureF , to compute finClosureA we basically just
add inference rules for deriving unary (i.e., concept and value-domain) inclusions from
binary (i.e., role and attribute) inclusions.

First, we denote by DL-Lite

Given a DL-Lite
?

?

?
We first modify the procedure for computing finChase F

We are now able to prove that the reduction of query answering over finite models
to query answering over unrestricted models proved in Section 4 for DL-LiteF can be
extended to DL-LiteA.
Theorem 11. Let T be a DL-LiteA-TBox, and let q be a UCQ. Then, for every ABox
A, T ,A |=fin q iff finClosureA(T ),A |= q  Q(D(T )).
Proof. First, consider a DL-Lite
concept and value-domain) inclusions and functionality assertions in T .

A TBox T . Let U(T ) denote the set of unary (i.e.,

k , illustrated in the proof of
Theorem 4, thus producing a new terminating chase procedure finChase A
k . Then, we
k (K)) that
k (K) is isomorphic to an interpretation I(finChase A
prove that: (A) finChase A
is a model of K; (B) for every positive integer k, entailment of a UCQ of length less
k (K)).
or equal to k can be decided by simply evaluating the query over I(finChase A
From the above two properties, the thesis follows with a proof analogous to the proof
of Theorem 4.
Finally, let us consider the case when T is an arbitrary DL-LiteA TBox, i.e., when T
also contains disjointness assertions. In this case, the thesis is proved in the same way
as in the proof of Theorem 5.

From the above theorem, and in the same way as in the case of DL-LiteF , we are able
to derive the following properties.
Theorem 12. Let K be a DL-LiteA KB. Then, K is finitely satisfiable iff T 
finClosureA(T ),A is satisfiable.
Theorem 13. Let T be a DL-LiteA-TBox, and let  be a DL-LiteA TBox assertion.
Then, T |=fin  iff T  finClosureA(T ) |= .
Finally, from the above results it follows that the computational properties expressed by
Theorem 8, Theorem 9, and Theorem 10 extend to the case of DL-LiteA.

7 Implementation

In this section we show that the techniques presented in this paper allow for an efficient
and effective implementation of finite model reasoning services for DL-Lite ontologies.
We have implemented the above techniques in QuOnto [1]. QuOnto is a DL-LiteA
reasoner whose main purpose is to deal with very large instances (i.e., ABoxes). To
this aim, in QuOnto the ABox is stored and managed by a relational database system
(RDBMS). The main reasoning services provided by QuOnto are the extensional
ones, i.e., KB satisfiability and query answering (it allows for posing UCQs over the
ontology).

Computation in QuOnto is divided into an off-line and an on-line phase. Off-line
processing concerns purely intensional tasks, i.e., upload of the TBox, classification of
concept and roles, etc. On-line processing concerns the tasks involving the ABox, i.e.,
KB satisfiability and query answering. In particular, query answering is divided into a

R. Rosati

query rewriting phase, in which the query is reformulated in terms of an SQL query
(through a reasoning step which exploits the knowledge expressed by the TBox), and a
query evaluation phase, in which the generated SQL query is evaluated over the ABox
by the RDBMS, and the answers are presented to the user.

To provide support for finite model reasoning, we have extended QuOnto as follows:
 during off-line processing, the system computes finClosureA(T ), and the assertions in finClosureA(T )  T are stored in an auxiliary TBox T 
 during on-line processing, at every service request (KB satisfiability or query an-
swering) the user may choose between the classical semantics and the finite model
semantics;
method (KB satisfiability or query answering) using the TBox T T 
executes its method on the TBox T .

 if finite model semantics is selected, then the system executes its reasoning service
, otherwise it

;

Notice that
the main additional computation requested is the computation of
finClosureA(T ), which is only executed during off-line processing. Hence, finite model
reasoning does not imply any significant overhead during on-line processing. Moreover,
even the off-line overhead caused by the computation of finClosureA(T ) is usually not
very significant, since such a computation is in the worst case quadratic in the number
of functional roles of T (which are usually only a small fraction of the total number
of roles in T ). This very nice computational behaviour has been confirmed by our ex-
periments. We have thus included these functionalities for finite model reasoning in the
next version of QuOnto, which is going to be publicly released in 2008.

8 Conclusions
Comparison with Related Work. We remark that DL-LiteR and DL-LiteF are fragments of expressive Description Logics for which finite model reasoning has been studied in the past [4,2,10]. In particular, decidability of finite KB satisfiability and of finite
TBox entailment for both DL-LiteF and DL-LiteR is a consequence of such previous re-
sults. However, the complexity of such tasks in these two logics was not known, while

the PTIME upper bound for finite TBox entailment in DL-Lite
F is implied by the results
in [7]. Furthermore, nothing was known about decidability and complexity of answering
conjunctive queries and unions of conjunctive queries over finite models in such logics.

Future Work. From the theoretical viewpoint, our aim is to extend the present computational analysis towards other species of OWL-DL. In particular, we are interested
in the tractable Description Logics which could become part of the standardization process of OWL 1.1 [8]. From a both theoretical and practical viewpoint, we would like to
explore the idea of extending the ontology specification language with constructs that
allow the user to associate single subparts of the ontology with either finite or unrestricted interpretation.

Acknowledgments. The author wishes to thank Maurizio Lenzerini for inspiring the
present work. The author also warmly thanks the anonymous reviewers for their com-
ments, in particular for pointing out the relationship between Lemma 3 and the results
?

?

?
in [7]. This research has been partially supported by FET project TONES (Thinking
ONtologiES), funded by the EU under contract number FP6-7603, by project HYPER,
funded by IBM through a Shared University Research (SUR) Award grant, and by
MIUR FIRB 2005 project Tecnologie Orientate alla Conoscenza per Aggregazioni
di Imprese in Internet (TOCAI.IT).
