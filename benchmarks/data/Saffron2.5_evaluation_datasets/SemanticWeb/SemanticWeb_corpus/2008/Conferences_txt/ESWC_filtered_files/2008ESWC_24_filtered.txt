Semantic Web Technology for Agent

Communication Protocols

Idoia Berges, Jes us Berm udez, Alfredo Go ni, and Arantza Illarramendi

{iberges003,jesus.bermudez,alfredo,a.illarramendi}@ehu.es

University of the Basque Country

http://siul02.si.ehu.es

Abstract. One relevant aspect in the development of the Semantic Web
framework is the achievement of a real inter-agents communication capability at the semantic level. The agents should be able to communicate and understand each other using standard communication protocols
freely, that is, without needing a laborious a priori preparation, before
the communication takes place.

For that setting we present in this paper a proposal that promotes to
describe standard communication protocols using Semantic Web technology (specifically, OWL-DL and SWRL). Those protocols are constituted
by communication acts. In our proposal those communication acts are
described as terms that belong to a communication acts ontology, that
we have developed, called CommOnt. The intended semantics associated
to the communication acts in the ontology is expressed through social
commitments that are formalized as fluents in the Event Calculus.

In summary, OWL-DL reasoners and rule engines help in our proposal
for reasoning about protocols. We define some comparison relationships
(dealing with notions of equivalence and specialization) between protocols used by agents from different systems.

Keywords: Protocol, Communication acts, agents.

1 Introduction

In the scenario that promotes the emergent Web, administrators of existing Information Systems, that belong to nodes distributed along the Internet network,
are encouraged to provide the functionalities of those systems through agents
that represent them or through Web Services. The underlying idea is to get a
real interoperation among those Information Systems in order to enlarge the
benefits that users can get from the Web by increasing the machine processable
tasks.

 The work of Idoia Berges is supported by a grant of the Basque Government.
 All authors are members of the Interoperable DataBases Group. This work is also
supported by the University of the Basque Country, Diputaci on Foral de Gipuzkoa
(cosupported by the European Social Fund) and the Spanish Ministry of Education
and Science TIN2007-68091-C02-01.

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 518, 2008.
c Springer-Verlag Berlin Heidelberg 2008

I. Berges et al.

Although agent technology and Web Services technology have been developed in a separate way, there exists a recent work of several members from both
communities trying to consolidate their approaches into a common specification
describing how to seamlessly interconnect FIPA compliant agent systems [1] with
W3C compliant Web Services. The purpose of specifying an infrastructure for
integrating these two technologies is to provide a common means of allowing
each to discover and invoke instances of the other [2]. Considering the previous approach, in the rest of this paper we will only concentrate on inter-agent
communication aspects.

Communication among agents is in general based on the interchange of communication acts. However, different Information Systems have incorporated different classes of communication acts as their Agent Communication Language
(acl) to the point that they do not understand each other. Moreover, protocols
play a relevant role in agents communication. A protocol specifies the rules of
interaction between agents by restricting the range of allowed follow-up communication acts for each agent at any stage during a communicative interaction. It
is widely recognized the interest of using standard communication protocols.

We advocate so that the administrators of the Information Systems proceed
in the following way. When they wish to implement the agents that will represent
their systems, they first select, from a repository of standard protocols (there
can exist one or more repositories), those protocols that fulfill the goals of their
agents. Sometimes a single protocol will be sufficient and other times it will
be necessary to design a protocol as a composition of some other protocols.
Next, they can customize the selected protocols before they incorporate them to
the agents. In that setting, when agents of different Information Systems want
to interoperate it will be relevant to reason about the protocols embedded in
the agents in order to discover relationships such as equivalence or restriction
between them. Moreover, once those relationships are discovered both agents
can use the same protocol by replacing dynamically in one agent the protocol
supported by the other. Finally, in our opinion it will be desirable to use a formal
language to represent the protocols.

In this paper we present a proposal that promotes to describe standard communication protocols using Semantic Web Technology (OWL-DL and SWRL).
In addition, communication acts that take part of the protocols are described as
terms that belong to a communication acts ontology, that we have developed,
called CommOnt (see more details about the ontology in [3]). The use of that
ontology favours on the one hand, the explicit representation of the meaning of
the communication acts and on the other hand, the customization of existing
standard protocols by allowing the use of particular communication acts that
can be defined as specializations of existing standard communication acts.

Terms of the CommOnt ontology are described using OWL-DL and we have
adopted the so called social approach [4,5] for expressing the intended semantics
of the communication acts included in the protocols. According to the social
approach, when agents interact they become involved in social commitments or
obligations to each other. Those commitments are public, and therefore they
?

?

?
are suitable for an objective and verifiable semantics of agent interaction. Social commitments can be considered as fluents in the Event Calculus, which is
a logic-based formalism for representing actions and their effects. Fluents are
propositions that hold during time intervals. A formula in the Event Calculus
is associated to a communication act for describing its social effects. The set of
fluents that hold at a moment describes a state of the interaction. DL axioms
and Event Calculus formulae apply to different facets of communication acts.
DL axioms describe static features and are principally used for communication
act interpretation purposes. Event Calculus formulae describe dynamic features,
namely the social effects of communication acts, and are principally used for
communication act operational contexts such as supervising conversations.

In summary the main contributions of the proposal presented in this paper are:
 It favours a flexible interoperation among agents of different systems by using
standard communication protocols described through tools promoted by the
W3C.

 It facilitates the customization of those standard communication protocols
allowing to use communication acts in the protocols that belong to specific acl of Information Systems. The particular communication acts are
described in an ontology.

 It provides a basis to reason about relationships between two protocols in
such a way that the following relations can be discovered: equivalence or
restriction (and also considering a notion of specialization). Moreover, notice that our approach allows to get protocols classification in terms of the
intended semantics of communication acts that appear in the protocols.

 It allows modeling the communication among agents without regarding only
to the lower level operational details of how communication acts are interchanged but taking also into account the meaning of those acts.
The rest of the paper is organized as follows: Section 2 provides background
on the communication ontology, that contains terms corresponding to communication acts that appear in the protocols, and on the semantics associated to
those acts. Section 3 explains how protocols are described using Semantic Web
Technology and presents the definitions of the relationships considered between
protocols. Section 4 discusses different related works, and conclusions appear in
the last section.

2 Two Basic Supports for the Proposal: The CommOnt
Ontology and the Representation of the Semantics of
Communication Acts

Among the different models proposed for representing protocols one which stands
out is that of State Transition Systems (STS).
Definition 1. A State Transition System is a tuple (S, s0, L, T , F ), where
S is a finite set of states, s0  S is an initial state, L is a finite set of labels,
T  S  L  S is a set of transitions and F  S is a set of final states.

I. Berges et al.

In our proposal we use STS where transitions are labeled with communication act
classes described in a communication acts ontology called CommOnt. That is to
say, the set of labels L is a set of class names taken from that ontology. Moreover,
as mentioned before, the intended semantics associated to the communication
acts in the ontology is expressed through predicates in the Event Calculus that
initiate or terminate fluents. In our case, each state is associated to the set of
fluents that holds at that moment.

In the following two subsections we present the main features of the CommOnt ontology and of the intended semantics associated to communication acts,
respectively.

2.1 Main Features of the CommOnt Ontology
The goal of the CommOnt ontology is to favour the interoperation among agents
belonging to different Information Systems. The leading categories of that ontology are: first, communication acts that are used for interaction by actors
and that have different purposes and deal with different kinds of contents; and
second, contents that are the sentences included in the communication acts.

The main design criteria adopted for the communication acts category of the
CommOnt ontology is to follow the speech acts theory [6], a linguistic theory that is recognized as the principal source of inspiration for designing the
most familiar standard agent communication languages. Following that theory
every communication act is the senders expression of an attitude toward some
possibly complex proposition. A sender performs a communication act which is
expressed by a coded message and is directed to a receiver. Therefore, a communication act has two main components. First, the attitude of the sender which
is called the illocutionary force (F ), that expresses social interactions such as
informing, requesting or promising, among others. And second, the propositional
content (p) which is the subject of what the attitude is about. In CommOnt
this F(p) framework is followed, and different kinds of illocutionary forces and
contents leading to different classes of communication acts are supported. More
specifically, specializations of illocutionary forces that facilitate the absorption
of aspects of the content into the illocutionary force are considered.

CommOnt is divided into three interrelated layers: upper, standards and
applications, that group communication acts at different levels of abstraction.
Classes of the CommOnt ontology are described using the Web Ontology Language OWL-DL. Therefore, communication acts among agents that commit to
CommOnt have an abstract representation as individuals of a shared universal
class of communication acts.

In the upper layer, according to Searles speech acts theory, five upper
classes of communication acts corresponding to Assertives, Directives, Com-
missives, Expressives and Declaratives are specified. But also the top class
CommunicationAct1 is defined, which represents the universal class of communication acts. Every particular communication act is an individual of this class.

1 This type style refers to terms specified in the ontology.
?

?

?
In CommOnt, components of a class are represented by properties. The most
immediate properties of CommunicationAct are the content and the actors who
send and receive the communication act. There are some other properties related
to the context of a communication act such as the conversation in which it is
inserted or a link to the domain ontology that includes the terms used in the
content.

A standards layer extends the upper layer of the ontology with specific terms
that represent classes of communication acts of general purpose agent communication languages, like those from KQML or FIPA-ACL. Although the semantic
framework of those agent communication languages may differ from the semantic framework adopted in CommOnt, in our opinion enough basic concepts and
principles are shared to such an extent that a commitment to ontological relationships can be undertaken in the context of the interoperation of Information
Systems.

With respect to FIPA-ACL, we can observe that it proposes four primitive
communicative acts [1]: Confirm, Disconfirm, Inform and Request. The terms
FIPA-Confirm, FIPA-Disconfirm, FIPA-Inform and FIPA-Request are used to
respectively represent them as classes in CommOnt. Furthermore, the rest of
the FIPA communicative acts are derived from those mentioned four primi-
tives. Analogously, communication acts from KQML can be analyzed and the
corresponding terms in CommOnt specified. It is of vital relevance for the interoperability aim to be able of specifying ontological relationships among classes
of different standards.

Finally, it is often the case that every single Information System uses a limited
collection of communication acts that constitute its particular agent communication language. The applications layer reflects the terms describing communication acts used in such particular Information Systems. The applications layer of
the CommOnt ontology provides a framework for the description of the nuances
of such communication acts. Some of those communication acts can be defined
as particularizations of existing classes in the standards layer and maybe some
others as particularizations of upper layer classes. Interoperation between agents
of two systems using different kinds of communication acts will proceed through
these upper and standard layer classes.

Following we show some axioms in the CommOnt ontology. For the presentation we prefer a logic notation instead of the more verbose owl/xml syntax.

CommunicationAct  =1 hasSender.Actor  hasReceiver.Actor 

hasContent.Content

Request  Directive  hasContent.Command
Accept  Declarative

Responsive  Assertive  inReplyTo.Request

2.2 Semantics Associated to Communication Acts

Formal semantics based on mental concepts such as beliefs, desires and intentions have been developed for specifying the semantics of communication acts.

I. Berges et al.

However, they have been criticized on their approach [4] as well as on their analytical difficulties [7]. We have adopted the so called social approach [5,8,9] to
express the intended semantics of communication acts described in the CommOnt ontology. According to the social approach, when agents interact they
become involved in social commitments or obligations to each other.
Definition 2. A base-level commitment C(x, y, p) is a ternary relation representing a commitment made by x (the debtor) to y (the creditor) to bring about
a certain proposition p.

Sometimes an agent accepts a commitment only if a certain condition holds or,
interestingly, only when a certain commitment is made by another agent. This
is called a conditional commitment.

Definition 3. A conditional commitment CC(x, y, p, q) is a quaternary relation
representing that if the condition p is brought out, x will be committed to y to
bring about the proposition q.

Moreover, the formalism we use for reasoning about commitments is based on
the Event Calculus. The basic ontology of the Event Calculus comprises actions,
fluents and time points. It also includes predicates for saying what happens
when (Happens), for describing the initial situation (Initially), for describing
the effects of actions (Initiates and Terminates), and for saying what fluents
hold at what times (HoldsAt). See [10] for more explanations.

Commitments (base-level and conditional) can be considered fluents, and semantics of communication acts can be expressed with predicates. For example:
 Initiates(Request(s,r,P), CC(r, s, accept(r,s,P), P), t)

A Request from s to r produces the effect of generating a conditional commitment expressing that if the receiver r accepts the demand, it will be
commited to the proposition in the content of the communication act.

 Initiates(Accept(s,r,P), accept(s,r,P), t)

The sending of an Accept produces the effect of generating the accept fluent.

Furthermore, some rules are needed to capture the dynamics of commitments.
Commitments are a sort of fluents typically put in force by communication acts
and that become inoperative after the appearance of other fluents. In the following rules e(x) represents an event caused by x. The first rule declares that
when a debtor of a commitment that is in force causes an event that initiates
the proposition committed, the commitment ceases to hold.
Rule 1: HoldsAt( C(x, y, p), t)  Happens(e(x), t)  Initiates(e(x), p, t) 

Terminates(e(x),C(x, y, p), t).

The second rule declares that a conditional commitment that is in force disappears and generates a base-level commitment when the announced condition
is brought out by the creditor.
Rule 2: HoldsAt( CC(x, y, c, p), t)  Happens(e(y), t)  Initiates(e(y), c, t)
 Initiates(e(y),C(x, y, p), t)  Terminates(e(y),CC(x, y, c, p), t).
?

?

?
Following we state some predicates that describe the semantics asociated to
some of the communication acts of the upper level of the CommOnt ontology.
This semantics is determined by the fluents that are initiated or terminated as
a result of the sending of a message between agents.

 Initiates(Assertive(s,r,P), P, t)
 Initiates(Commissive(s,r,C,P), CC(s,r,C,P), t)
 Initiates(Responsive(s,r,P, RA), P, t)

Terminates(Responsive(s,r,P, RA),C(s,r,RA), t)

Effects of these predicates can be encoded with SWRL rules. For instance, the
predicate Initiates(Request(s, r, P), CC(r, s, accept(r, s, P), P), t) can be encoded as follows:
Request(x)  hasSender(x,s)  hasReceiver(x,r)  hasContent(x,p)  hasCom-
mit(x,c)  isConditionedTo(c,a)  atTime(x, t)  initiates(x,c)  hasDebtor(c,r)
 hasCreditor(c,s)  hascondition(c,p)  Acceptance(a)  hasSignatory(a,r) 
hasAddressee(a,s)  hasObject(a,p)  atTime(c, t)

3 Protocol Description

As mentioned in the introduction, our proposal promotes to describe standard
protocols using Semantic Web technology. We use STS as models of protocols.
More specifically, we restrict to deterministic STS (i.e. if (s, l, s)  T and (s, l, s)
 T then s = s). In order to represent protocols using OWL-DL, we have defined
five different classes: Protocol, State, Transition, Fluent and Commitment,
which respectively represent protocols, states, transitions in protocols, fluents and
commitments associated to states.

We model those class descriptions with the following guidelines: A state has
fluents that hold in that point and transitions that go out of it. A transition is
labelled by the communication act that is sent and is associated to the state that
is reached with that transition. A fluent has a time stamp that signals the moment
it was initiated. An actual conversation following a protocol is an individual of the
class Protocol. Following are some of the ontology axioms:

Protocol  hasInitialState.State 

hasInitialState.State

State  hasTransition.Transition 

hasFluent.Fluent 
hasFluent.Fluent

Transition  =1 hasCommAct.CommunicationAct 

FinalState  State 

=1.hasNextState.State

hasFluent.(Fluent  Commitment)

Fluent  =1 atTime

Commitment  Fluent  =1 hasDebtor.Actor 

=1 hasCreditor.Actor 

I. Berges et al.

ConditionalCommitment  Fluent  =1 hasDebtor.Actor 

=1 hasCondition.Fluent

=1 hasCreditor.Actor 
=1 hasCondition.Fluent 
=1 isConditionedTo.Fluent

The OWL-DL description of protocols reflects their static features and can be
used to discover structural relationships between protocols. For instance, in Fig. 1
we show a simple protocol where agent A asks for time to agent B. The protocol
description appears in the following:

Fig. 1. Protocol AskTime

Asktime  Protocol  hasInitialState.S0

S0  State  hasTransition.T01  hasFluent.F0
S1  State  hasTransition.T12  hasFluent.F1
S2  State  hasTransition.T23  hasFluent.F2
S3  FinalState  hasFluent.F3
T01  Transition  hasCommAct.TimeRequest  hasNextState.S1
T12  Transition  hasCommAct.TimeAccept  hasNextState.S2
T23  Transition  hasCommAct.TimeInform  hasNextState.S3

TimeRequest  Request  =1 hasContent.TimeReq
TimeAccept  Accept  =1 hasContent.TimeReq
TimeInform  Responsive  =1 hasContent.TimeInfo  =1 inReplyTo.TimeRequest

However, dealing only with structural relationships is too rigid if a flexible interoperation among agents that use different standard protocols is promoted. For
that reason, we propose to consider what we call protocol traces.
Definition 4. A protocol trace is a sequence of time stamped fluents sorted in increasing order of time stamp.
Notice that protocol traces are defined in terms of the semantics of communication
acts, not in terms of the communication acts themselves; in contrast with many
other related works (see section 4) that consider messages as atomic acts without
considering their content, neither their semantics.

During a simulation of a protocol run we apply the SWRL rules that encode
the semantics of the communication acts (see section 2.2) appearing in the run.
Then, we can consider the sorted set of time stamped fluents that hold at a final
state of the protocol. That set represents the effects of the protocol run. Following
we show an example of the application of the rules to a run of protocol AskTime
in Fig. 1.
?

?

?
Fig. 2. Protocol fluents

In Fig. 2 we show which are the fluents associated to the states of the protocol
and how they vary as a consequence of the communication acts that are sent and
the rules described in section 2.2. We depart from a situation where the set of fluents is empty (F0). When the TimeRequest message is sent, due to the predicate
Initiates(Request(s, r, P), CC(r, s, accept(r,s,P), P), t) the conditional commitment CC1 is initiated, which states that if agent B accepts to give information
about the time, then it will be committed to do so; t1 is the time stamp asso-
ciated. By convention we sort time stamps by their subindexes, that is: ti < tj
if i < j. Then agent B agrees to respond by sending the TimeAccept message,
and due to the predicate Initiates(Accept(s,r,P), accept(s,r,P), t), the fluent ac-
cept(B, A, TimeReq) is initiated at time t2. At this point, Rule 2 (see section 2.2)
can be applied, so CC1 is terminated and the base commitment C1 is initiated at
time t3. Finally, agent B sends the TimeInform message, and because of the predicates Initiates(Responsive(s,r,P, RA), P, t) and Terminates(Responsive(s,r,P,
RA), C(s,r,RA), t), C1 is terminated and a new fluent, TimeInfo, is initiated at
time t4. So, at this point we can say that the fluents that hold at the final state of
the protocol are (accept(B, A, TimeReq), t2) and (TimeInfo, t4).
Then, we say that the protocol trace [(accept(B, A, TimeReq), t2), (TimeInfo,
t4)] is generated by the protocol. We denote T (A) to the set of all protocol traces
generated by a protocol A.

Now, we proceed with the definitions of relationships between protocols we
are considering. Our relationships are not structure-based but effect-based. In-
tuitively, two protocols are equivalent if the same effects take place in the same
relative order. Runs of a protocol are made up of communication acts, and fluents
are the effects they leave.
Definition 5. Protocol A is equivalent to protocol B if T (A) = T (B).
Sometimes, a protocol is defined by restrictions on the allowable communication
acts at some states of a more general protocol. In those situations the application
of those restrictions is reflected in the corresponding effects.
Definition 6. Protocol A is a restriction of protocol B if T (A)  T (B).

I. Berges et al.

Protocols for specific Information Systems may use specialized communication
acts. Specialization can also be applied also to domain actions that can be represented by specialized fluents.
Definition 7. A protocol trace t is a specialization of a protocol trace s, written
ts, if i. t(i)  s(i) in an ontology of fluents.
Definition 8. Protocol A is a specialized-equivalent of protocol B if t  T (A).
s  T (B). ts and s  T (B). t  T (A). ts.
Definition 9. Protocol A is a specialized-restriction of protocol B if t  T (A).
s  T (B). ts.
Notice that all those relationships can be easily discovered by straightforward algorithms supported by OWL-DL reasoners. Those reasoners deal with the ontology descriptions and rule engines that consider our semantic rules for generating
protocol traces.

Moreover, sometimes we may be interested in comparing protocol traces independently of time stamps. That is, we may be interested in knowing if a protocol
produces the same fluents as another, in whatever order. For example, in Fig. 3
we show two protocols that can be used to ask for information related to the vital
signs temperature and pulse. In fact, for that purpose it is irrelevant the order in
which the two requests are done.

Fig. 3. Specialization of protocols

In protocol P1 we can find a general protocol, in which agent A makes a request about the temperature using the communication act RequestTemp for that
purpose. Then, agent B accepts and replies with a TempInform message, which is
used to give information about the temperature. Once agent A receives this infor-
mation, it asks agent B information about the pulse using a RequestPulse. Finally agent B accepts and replies with a PulseInform message and the final state
F is reached. On the other hand, in protocol P2 we can find the specific protocol
used by the agents of a specific system, called Aingeru2, to exchange information
about vital signs. Protocol P2 may be a specialization of an standard protocol.
First, agent A asks for the pulse, using the communication act A-RequestPulse.
Then, agent B accepts and responds to the request using the A-PulseInform mes-
sage. Next, agent A sends a A-RequestTemp message to ask about the tempera-
ture. Finally, agent B accepts and replies using the A-TempInform message and
2 The A- prefix intends to label the AINGERU terminology.
?

?

?
reaches state F. Following we show the OWL specification for the communication acts used in this example.

RequestTemp  Request  =1 hasContent.TempReq
AcceptTemp  Accept  =1 hasContent.TempReq
TempInform  Responsive  =1 hasContent.TempInfo  =1 inReplyTo.RequestTemp

RequestPulse  Request  =1 hasContent.PulseReq
AcceptPulse  Accept  =1 hasContent.PulseReq
PulseInform  Responsive  =1 hasContent.PulseInfo  =1 inReplyTo.RequestPulse

A-RequestTemp  RequestTemp  =1 theSystem.Aingeru  =1 hasContent.A-TempReq
A-AcceptTemp  AcceptTemp  =1 theSystem.Aingeru  =1 hasContent.A-TempReq
A-TempInform  TempInform  =1 theSystem.Aingeru  =1 hasContent.A-TempInfo 

=1 inReplyTo.A-RequestTemp

A-RequestPulse  RequestPulse  =1 theSystem.Aingeru  =1 hasContent.A-PulseReq
A-AcceptPulse  AcceptPulse  =1 theSystem.Aingeru  =1 hasContent.A-PulseReq
A-PulseInform  PulseInform  =1 theSystem.Aingeru  =1 hasContent.A-PulseInfo 

=1 inReplyTo.A-RequestPulse

Notice that every communication act in protocol P2 is a subclass of its counterpart in protocol P1 (i.e. A-RequestPulse  RequestPulse, etc.) and correspondingly A-PulseInfo  PulseInfo, etc., is also satisfied.

Through a reasoning procedure analogous to that explained with the example
T (P 1) = {[(accept(B, A, TempReq), t2), (TempInfo, t4), (accept(B, A,
T (P 2) = {[(accept(B, A, A-PulseReq), t2), (A-PulseInfo, t4), (accept(B, A, A-

of the AskTime protocol, we get the following sets of protocol traces:
PulseReq), t6), (PulseInfo, t8)] }
TempReq), t6), (A-TempInfo, t8)] }

Even if the structure of the protocols is not exactly the same, we can relate both
protocols by a shallow notion of specialization from the following point of view. If
we get abstracted from time stamps, we can see protocol traces as multi-sets. Let
us denote abstract-time(t) to the multi-set formed by the fluents appearing in the
protocol trace t, without any time stamp associated. Now, we define

S(A) = {abstract-time(t)|t  T (A)}
Then, we are in condition to define analogous relationships to the previous five,
but in a shallow mood.
Definition 10. 1. Protocol A is shallow-equivalent to protocol B if S(A) =
2. Protocol A is a shallow-restriction of protocol B if S(A)  S(B).
3. A protocol trace t is a shallow-specialization of a protocol trace s, written t s
s, if there is a map  from abstract-time(t) to abstract-time(s) such that f 
abstract-time(t).f  (f) in an ontology of fluents.
4. Protocol A is a shallow-specialized-equivalent of protocol B if t  S(A). s 
S(B). t s s and s  S(B). t  S(A). t s s.
5. Protocol A is a shallow-specialized-restriction of protocol B if t  S(A). s 
S(B). t s s.

S(B).

Finally, using our proposal, we can conclude that protocols P1 and P2 are shallow-
specialized-equivalent, although they use different communications acts and have
different structure.

I. Berges et al.

4 Related Works

Among the different related works that we can find in the specialized literature,
the closer work is [11], where protocols are represented as transition systems and
subsumption and equivalence of protocols are defined with respect to three state
similarity funtions. We share some goals with that work, but the protocol description formalism used by them is not considered in the paper and there is no references to how protocol relationships are computed. In contrast, we describe protocols with a description logic language and protocol relationships can be computed
by straightforward algorithms. It is worth mentioning that protocol relationships
considered in that paper deserve study in our framework.

The works of [12] and [13] are quite similar one to each other. Both capture
the semantics of communication acts through agents commitments and represent
communication protocols using a set of rules that operate on these commitments.
Moreover those rule sets can be compiled as finite state machines. Nevertheless,
they do not consider the study of relationships between protocols. In addition, in
[14], protocols are also represented with a set of rules with terms obtained from
an ontology, but their main goal is protocol development and, in order to reason
about protocol composition, they formalize protocols into the -calculus. Then,
equivalence through bisimulation is the only process relationship considered. In
[15], they also consider commitment protocols; however, their main focus is on
combining them with considerations of rationality on the enactment of protocols.
Our proposal could be complemented with their approach.

An alternative way to describe finite state machines with a description logic
language is to take advantage of the relationship of that logic with Deterministic
Propositional Dynamic Logic, see [16] for an example in the context of Web Services composition. The approach of that paper is very different in purpose from
ours. Their states and transitions descriptions are not prepared to be confronted
in a comparison. In constrast, our state and transition descriptions are carefully
modelled as class descriptions such that semantics relationships between protocols
can be captured.

Also in the context of Web Services, state transition systems are used in [17]
for representing dynamic behaviour of services and they define some notions of
compatibility and substitutability of services that can be easily translated to the
context of compatibility of protocols. Relationships between their compatibility
relations and our defined relationships deserve study.

In [18] protocols are defined as a set of permissions and obligations of agents
participating in the communication. They use an OWL ontology for defining the
terms of the specification language, but their basic reasoning is made with an ad
hoc reasoning engine. We share their main goal of defining protocols in a general
framework that allows reutilization. Nevertheless, they do not consider relationships between protocols.

The problem of determining if an agents policy is conformant to a protocol is a
very important one, but we are not treating that topic in this paper. Nevertheless,
the topic is close to ours and it is worth mentioning the following papers that consider different notions of conformance: In [19], deterministic finite state machines
?

?

?
are the abstract models for protocols, which are described by simple logic-based
programs. Three levels of conformance are defined: weak, exhaustive and robust.
They consider communication acts as atomic actions, in contrast to our semantic
view. In [20]a nondeterministic finite state automata is used to support a notion of
conformance that guarantees interoperabiliy among agents conformant to a pro-
tocol. Their conformance notion considers the branching structure of policies and
protocols and applies a simulation-based test. Communication acts are considered
atomic actions, without considering their semantics. In [21], communication acts
semantics is described in terms of commitments but it is not used for the conformance notion. A third different notion of conformance is defined and, moreover,
it is proved orthogonal to their proposed notions of coverage and interoperability.
Finally, [22] and [23] use finite state machines and Petri nets, respectively, but
without taking into account the meaning of the communication acts interchanged,
neither considering relationships between protocols.

5 Conclusions

Increasing machine-processable tasks in the Web is a challenge considered at
present. In this line we have presented in this paper a proposal that favours the
communication among agents that represent to different Information Systems accessible through the Web. The main contributions of the proposal are:
 The management of the semantics aspects when dealing with agent commu-

nication protocols.

 The provision of the possibility of customizing standard communication pro-

tocols and management of them.

 The use of standard Semantic Web tools to describe protocols.
 The support for discovering different kinds of relationships between protocols.
