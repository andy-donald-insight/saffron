Safe and Economic Re-Use of Ontologies:

A Logic-Based Methodology and Tool Support

Ernesto Jim enez-Ruiz1, Bernardo Cuenca Grau2, Ulrike Sattler3,

Thomas Schneider3, and Rafael Berlanga1

1 Universitat Jaume I, Spain
{berlanga,ejimenez}@uji.es
2 University of Oxford, UK

berg@comlab.ox.ac.uk

3 University of Manchester, UK

{sattler,schneider}@cs.man.ac.uk

Abstract. Driven by application requirements and using well-understood
theoretical results, we describe a novel methodology and a tool for modular
ontology design. We support the user in the safe use of imported symbols
and in the economic import of the relevant part of the imported ontology.
Both features are supported in a well-understood way: safety guarantees
that the semantics of imported concepts is not changed, and economic import guarantees that no difference can be observed between importing the
whole ontology and importing the relevant part.

1 Motivation

Ontology design and maintenance require an expertise in both the domain of application and the ontology language. Realistic ontologies typically model different
aspects of an application domain at various levels of granularity; prominent examples are the National Cancer Institute Ontology (NCI)1 [1], which describes
diseases, drugs, proteins, etc., and GALEN2, which represents knowledge mainly
about the human anatomy, but also about other domains such as drugs.

Ontologies such as NCI and GALEN are used in bio-medical applications as
reference ontologies, i.e., ontology developers reuse these ontologies and customise
them for their specific needs. For example, ontology designers use concepts3 from
NCI or GALEN and refine them (e.g., add new sub-concepts), generalise them
(e.g., add new super-concepts), or refer to them when expressing a property of
some other concept (e.g., define the concept Polyarticular JRA by referring to the
concept Joint from GALEN).

One of such use cases is the development within the Health-e-Child project of
an ontology, called JRAO, to describe a kind of arthritis called JRA (Juvenile

1 Online browser: http://nciterms.nci.nih.gov/NCIBrowser/Dictionary.do, latest

version: ftp://ftp1.nci.nih.gov/pub/cacore/EVS/NCI Thesaurus

2 http://www.co-ode.org/galen
3 We use the Description Logic terms concept and role instead of the OWL terms

class and property.

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 185199, 2008.
c Springer-Verlag Berlin Heidelberg 2008

E. Jim enez-Ruiz et al.

Arthropathy

Arthritis

Autoimmune

Disease

Rheumatologic

Disorder

Atrophic Arthritis

Polyarthritis

Rheumatoid Arthritis

Juvenile Chronic Polyarthritis

Juvenile Rheumatoid Arthritis

Arthritis diseases

s

t

c

a ff e

. . .

C1

C7

isTreatedBy

Joints

Drugs

Fig. 1. Constructing the ontology JRAO reusing fragments of GALEN and NCI

Rheumatoid Arthritis).4 Following the ILAR5, JRAO describes the kinds of JRA.
Those are distinguished by several factors such as the joints affected or the occurrence of fever, and each type of JRA requires a different treatment. GALEN
and NCI contain information that is relevant to JRA, such as detailed descriptions of the human joints as well as diseases and their symptoms. Figure 1 gives
a fragment of NCI that defines JRA. It also shows our reuse scenario, where
C1, . . . , C7 refer to the kinds of JRA to be defined in JRAO.

The JRAO developers want to reuse knowledge from NCI and GALEN for
three reasons: (a) they want to save time through reusing existing ontologies
rather than writing their own; (b) they value knowledge that is commonly accepted by the community and used in similar applications; (c) they are not
experts in all areas covered by NCI and GALEN.

Currently, GALEN, NCI, and JRAO are written in OWL DL [2], and thus they
come with a logic-based semantics, which allows for powerful reasoning services
for classification and consistency checking. Thus, ontology reuse should take
into account the semantics and, more precisely, should provide the following two
guarantees. First, when reusing knowledge from NCI and GALEN, the developers
of JRAO do not want to change the original meaning of the reused concepts.
For example, due to (b) and (c) above, if it follows from the union of JRAO
and NCI that JRA is a genetic disorder, then it also follows from NCI alone.
Second, only small parts of large ontologies like NCI and GALEN are relevant

4 See http://www.health-e-child.org. This project aims at creating a repository of

ontologies that can be used by clinicians in various applications.

5 Int. League of Associations for Rheumatology http://www.ilarportal.org/
?

?

?
to the sub-types of JRA. For efficiency and succinctness, the JRAO developers
want to import only those axioms from NCI and GALEN that are relevant for
JRAO. By importing only fragments of NCI and GALEN, one should not lose
important information; for example, if it follows from the union of the JRAO
and NCI that JRA is a genetic disorder, then this also follows from the union of
JRAO and the chosen fragment of NCI.

Our scenario has two main points in common with other ontology design
scenarios: the ontology developer wants to reuse knowledge without damaging
it, and also to import only the relevant parts of an existing ontology. To support
these scenarios whilst providing the two above guarantees, a logic-based approach
to reuse is required. Current tools that support reuse, however, do not implement
a logic-based solution and thus do not provide the above guaranteesand neither
do existing guidelines and best practices for ontology design.

In this paper, we propose a methodology for ontology design in scenarios
involving reuse which is based on a well-understood logic-based framework [3].
We describe a tool that implements this methodology and report on experiments.

2 Preliminaries on Modularity

Based on the application scenario in Section 1, we define the notions of a conservative extension, safety, and module [4, 3]. For simplicity of the presentation,
we restrict ourselves to the description logic SHIQ, which covers most of OWL
DL [2]. Therefore the ontologies, entailments and signatures we consider are
relative to SHIQ. The results mentioned in this section, however, can be extended to SHOIQ and therefore OWL DL [3]. In this and the following section,
we have omitted a few technical details, for instance proofs of the propositions.
They can be found in a technical report available at http://www.cs.man.ac.uk/
~schneidt/publ/safe-eco-reuse-report.pdf.

2.1 The Notions of Conservative Extension and Safety

As mentioned in Section 1, when reusing knowledge from NCI and GALEN,
the developer of JRAO should not change the original meaning of the reused
concepts. This requirement can be formalised using the notion of a conservative
extension [4, 5]. In the following, we use Sig() to denote the signature of an
ontology or an axiom.
Definition 1 (Conservative Extension). Let T1  T be ontologies, and S a
signature. We say that T is an S-conservative extension of T1 if, for every axiom
 with Sig()  S, we have T |=  iff T1 |= ; T is a conservative extension of
T1 if T is an S-conservative extension of T1 for S = Sig(T1).
Definition 1 applies to our example as follows: T1 = NCI is the ontology to be
reused, T is the union of JRAO and NCI, S represents the symbols reused from
NCI, such as JRA and Rheumatologic Disorder, and  stands for any axiom over
the reused symbols only, e.g., JRA  Rheumatologic Disorder.

E. Jim enez-Ruiz et al.

Definition 1 assumes that the ontology to be reused (e.g. NCI) is static. In
practice, however, ontologies such as NCI are under development and may evolve
beyond the control of the JRAO developers. Thus, it is convenient to keep NCI
separate from the JRAO and make its axioms available on demand via a reference
such that the developers of the JRAO need not commit to a particular version
of NCI. The notion of safety [3] can be seen as a stronger version of conservative
extension that abstracts from the particular ontology to be reused and focuses
only on the reused symbols.
Definition 2 (Safety for a Signature). Let T be an ontology and S a signa-
ture. We say that T is safe for S if, for every ontology T  with Sig(T )Sig(T ) 
S, we have that T  T  is a conservative extension of T .

2.2 The Notion of Module

As mentioned in Section 1, by importing only a fragment of NCI and GALEN,
one should not lose important information. This idea can be formalised using
the notion of a module [3]. Intuitively, when checking an arbitrary entailment
over the signature of the JRAO, importing a module of NCI should give exactly
the same answers as if the whole NCI had been imported.
Definition 3 (Module for a Signature). Let T 
 T  be ontologies and S
a signature. We say that T 
1 is a module for S in T  (or an S-module in T )
if, for every ontology T with Sig(T )  Sig(T )  S, we have that T  T  is a
conservative extension of T  T 
The notions of safety and module are related as follows:
Proposition 4 ([3], Safety vs. Modules). If T  \ T 
then T 

1 is safe for S  Sig(T 
1 ),

1 is an S-module in T .

1 for Sig(T ).

2.3 Locality Conditions

The decision problems associated with conservative extensions, safety and mod-
ulesi.e., whether T is an S-conservative extension of T1, whether T is safe
for S, or whether T 
1 is an S-module in T are undecidable for SHOIQ [6, 3].
Sufficient conditions for safety have been proposed: if an ontology satisfies such
conditions, then we can guarantee that it is safe, but the converse does not
necessarily hold [3]. By means of Proposition 4, such conditions could be used
for extracting modules. A particularly useful condition is locality [3]: it is widely
applicable in practice and it can be checked syntactically.

As mentioned in Section 1, when using a symbol from NCI or GALEN, the
JRAO developers may refine it, extend it, or refer to it for expressing a property
of another symbol. The simultaneous refinement and generalisation of a given
external symbol, however, may compromise safety. For example, JRAO cannot
simultaneously contain the following axioms:

Polyarticular JRA  JRA (-local)

Juvenile Chronic Polyarthritis  Polyarticular JRA (-local)

(1)
(2)
?

?

?
where the underlined concepts are reused from NCI, see Figure 1. These axioms
imply Juvenile Chronic Polyarthritis  JRA, and therefore an ontology containing
axioms (1) and (2) is not safe w.r.t. S = {JRA, Juvenile Chronic Polyarthritis}.
Thus, when designing sufficient conditions for safety, we are faced with a fundamental choice depending on whether the ontology designer wants to reuse or
generalise the reused concepts. Each choice leads to a different locality condition.
The following definition introduces these conditions and refers to Figure 2. In
this figure, A and R stand for concept and role names not in S. The letters C
and R denote arbitrary concepts and roles.
Definition 5 (Syntactic -Locality and -Locality). Let S be a signature.
An axiom  is -local w.r.t. S (-local w.r.t S) if   Ax(S), as defined in
Figure 2 (a) ((b)). An ontology T is -local (-local) w.r.t. S if  is -local
(-local) w.r.t. S for all   T .

(a) -Locality
Con( S) ::= A
Con(S) ::= C
Ax(S)
::= C

Let C
 | Cs | C  C
 | Cs
  C | C  Cs | R

1  Cs

  R | Trans(R



)

  Con( S), Cs
 | C

  C | R.C

(i)  Con(S)
 |  n R.C

 | (R



.C) | ( n R



.C)

Let Cs  Con(S), C


(i)

 Con( S)

(b) -Locality
Con(S) ::= C
Con( S) ::= A
Ax(S)

 | C  Cs | Cs  C | R.Cs |  n R.Cs
 | Cs | C


 |  n R
2 | R



.C
.C
 | Trans(R
 | R  R

)

1  C

::= Cs  C | C  C

Fig. 2. Syntactic locality conditions

Axiom (2) is -local w.r.t. S = {Juvenile Chronic Polyarthritis}, and Axiom (1)
is -local w.r.t. S = {JRA}. Note that the locality conditions allow us to refer to
a reused concept for expressing a property of some other concept; for example,
the axiom Polyarticular JRA   5 affects.Joint is -local w.r.t. S = {Joint}.

Both -locality and -locality are sufficient for safety:

Proposition 6 ([3], Locality Implies Safety). If an ontology T is -local
or -local w.r.t. S, then T is safe for S.
Propositions 4 and 6 suggest the following definition of modules in terms of
locality.
Definition 7. Let T1  T be ontologies, and S a signature. We say that T1 is a
-module (-module) for S in T if T \T1 is -local (-local) w.r.t. S Sig(T1).
We illustrate these notions by an example. Figure 3 (a) shows an example ontology (TBox). The set of external symbols is S0 = {A, t1, t2}. In order to extract

E. Jim enez-Ruiz et al.

T = { A  A2,

A2  r2.C2,
A2  r2.D2,

A2  s2.E2,
A2  t2.F2,

A1  A,
r1.C1  A1,
r1.D1  A1

s1.E1  A1,
t1.F1  A1 }

(a) The TBox

Consideration

(1) A  S0, A2  S0  A  A2  Ax(S0)
(2) A2  S1, C2  S1  r2.C2  Con( S1)

 A2  r2.C2  Ax(S1)

Consequence
S1 = S0  {A2}

S2 = S1  {r2, C2}

(3) A2  S2, r2  S2, D2  S2  r2.D2  Con( S2)

 r2.D2  Con( S2)  A2  r2.D2  Ax(S2) S3 = S2  {D2}

(4) A2  S3, s2  S3, E2  S3  s2.E2  Con( S3)

 s2.E2  Con( S3)  A2  s2.E2  Ax(S3) S4 = S3
analogous to (3)

(5)
S5 = {A, A2, C2, D2, F2, r2, t1, t2}
The -module consists of S5 and all axioms   T with Sig()  S5.

S5 = S4  {F2}

(b) Extracting the -module

Fig. 3. An example illustrating - and -modules

the -module, we extend S0 stepwise as in Figure 3 (b). The -module is ob-
5 = {A, A1, C1, D1, F1, r1, t1, t2} and all
tained analogously and consists of S
axioms   T with Sig()  S
5.

It is clear that -modules and -modules are modules as in Definition 3:

Proposition 8 ([3], Locality-based Modules are Modules). Let T1 be either a -module or a -module for S in T and let S = S  Sig(T1). Then T1 is
an S-module in T .
These modules enjoy an important property which determines their scope: suppose that T1 (T2) is a -module (-module) for S in T , then T1 (T2) will contain
all super-concepts (sub-concepts) in T of all concepts in S:
Proposition 9 ([3], Module Scope). Let T be an ontology, X, Y be concept
names in T  {}  {},  := (X  Y ),  := (Y  X), and TX  T with
X  S. Then the following statements hold.

(i) If TX is a -module in T for S, then TX |=  iff T |= .
(ii) If TX is a -module in T for S, then TX |=  iff T |= .

For example, if we were to reuse the concept JRA from NCI as shown in Figure 1
by extracting a -module for a signature that contains JRA, such a module
would contain all the super-concepts of JRA in NCI, namely Rheumatoid Arthritis,
Autoimmune Disease, Rheumatologic Disorder, Arthritis, and Arthropathy. Since
such a fragment is a module, it will contain the axioms necessary for entailing
those subsumption relations between the listed concepts that hold in NCI.
?

?

?
Finally, given T and S, there is a unique minimal -module and a unique
minimal -module for S in T [3]. We denote these modules by UpMod(T , S) and
LoMod(T , S). This is motivated by the alternative terms upper/lower module
that refer to the property from Proposition 9. Following a similar approach as
exemplified in Figure 3 (b), the modules can be computed efficiently [3].

3 A Novel Methodology for Ontology Reuse

Based on our scenario in Section 1 and the theory of modularity summarised
in Section 2, we propose a novel methodology for designing an ontology when
knowledge is to be borrowed from several external ontologies. This methodology
provides precise guidelines for ontology developers to follow, and ensures that a
set of logical guarantees will hold at certain stages of the design process.

3.1 The Methodology

We propose the working cycle given in Figure 4. This cycle consists of an offline phasewhich is performed independently from the current contents of the
external ontologiesand an online phasewhere knowledge from the external
ontologies is extracted and transferred into the current ontology. Note that this
separation is not strict: The first phase is called offline simply because it does
not need to be performed online. However, the user may still choose to do so.
The Offline Phase starts with the ontology T being developed, e.g., JRAO.
The ontology engineer specifies the set S of symbols to be reused from external
ontologies, and associates to each symbol the external ontology from which it
will be borrowed. In Figure 4 this signature selection is represented in the Repeat
loop: each Si  S represents the external symbols to be borrowed from a partic-
i ; in our example, we have S = S1  S2, where S1 is associated
ular ontology T 
with NCI and contains JRA, and S2 is associated with GALEN and contains
symbols related to joints and drugs. This part of the offline phase may involve
an online component since the developer may browse through the external
ontologies to choose the symbols she wants to import.

Next, the ontology developer decides, for each Si, whether she wants to refine
or generalise the symbols from this set. For instance, in the reuse example shown
in Figure 1, the concept JRA from NCI is refined by the sub-concepts abbreviated
C1, . . . , C7. In both cases, the user may also reference the external symbols via
roles; in our example, certain types of JRA are defined by referencing concepts in
GALEN (e.g., joints) via the roles affects and isTreatedBy. As argued in Section
1, refinement and generalisation, combined with reference, constitute the main
possible intentions when reusing external knowledge. Therefore it is reasonable
for the user, both from the modelling and tool design perspectives, to declare
her intention. This step is represented by the For loop in Figure 4.
At this stage, we want to ensure that the designer of T does not change the
original meaning of the reused concepts, independently of what their particular
meaning is in the external ontologies. This requirement can be formalised using
the notion of safety introduced in Section 2:

E. Jim enez-Ruiz et al.

Load local ontology T
Repeat at users discretion

Choose a set of external symbols Si
plus associated ontology T 

i

Let S = S1    Sn
For each Si do

Select refinement or generalisation view

Safety

Repeat at users discretion

Select an Si
Load external ontology T 
Customise scope of module
Extract module TSi from T 
Import TSi into T

i

i for Si

Module Coverage
Mod. Independence
?

?

?
Fig. 4. The two phases of import with the required guarantees

Definition 10 (Safety Guarantee). Given an ontology T and signatures
S1, . . . , Sn, T guarantees safety if T is safe for Si for all 1  i  n.
In the next subsection, we will show how to guarantee safety.

As shown in Figure 4, the import for each external ontology T 

In the Online Phase, the ontology engineer imports the relevant knowledge
from each of the external ontologies. As argued in Section 1 and 2, we aim at
extracting only those fragments from the external ontologies that are relevant
to the reused symbols, and therefore the extracted fragments should be modules
in the sense of Definition 3.
is performed
in four steps. First, T 
i is loaded; by doing so, the ontology engineer commits to a
particular version of it. Second, the scope of the module to be extracted from T 
i
is customised; in practice, this means that the ontology engineer is given a view
of T 
i and enabled to extend Si by specifying requirements such as: The module
has to contain the concept joint, all its direct super-concepts and two levels of
its sub-concepts. In the third step, the actual fragment of T 
is extracted. At
this stage, we should ensure that the extracted fragment is a module for the customised signature according to Definition 3. Therefore, the following guarantee
should be provided for each external ontology and customised signature:

i

i
?

?

?
S). Then, T 

S is a module for S in T .

S  T  such that S  Sig(T 

Definition 11 (Module Coverage Guarantee). Let S be a signature and
T 
S,T  be ontologies with T 
S guarantees
coverage of S if T 
Finally, the actual module TSi is imported. The effect of this import is that the
ontology T being developed evolves to T TSi; as a consequence, the safety guarantee with respect to the remaining external ontologies might be compromised.
Such an effect is obviously undesirable and hence the following guarantee should
be provided after the import:
Definition 12 (Module Independence Guarantee). Given an ontology T
and signatures S1, S2, we say that T guarantees module independence if, for all
T1 with Sig(T )  Sig(T1)  S1, it holds that T  T1 is safe for S2.

3.2 Achieving the Logical Guarantees

In order to provide the necessary guarantees of our methodology, we will now
make use of the locality conditions introduced in Section 2.3 and some general
properties of conservative extensions, safety and modules.

The Safety Guarantee. In Section 2.3, we argue that the simultaneous refinement and generalisation of an external concept may compromise safety. To
preserve safety, we propose to use two locality conditions: -locality, suitable
for refinement, and -locality, suitable for generalisation. These conditions can
be checked syntactically using the grammars defined in Figure 2, and therefore
they can be easily implemented in a tool. In order to achieve the safety guarantee at the end of the offline phase, we propose to follow the procedure sketched
in Figure 5, where locality of T for Si according to the choice for Si means
-locality if Si is to be refined and -locality if Si is to be generalised.

Input:T : Ontology

S1, . . . , Sn: disjoint signatures
a choice among refinement and generalisation for each Si
ontology T1 that guarantees safety

Output:
1: T1 := T
2: while exists Si such that T not local according to the selection for Si do
3:
4:
5:
end if
6:
7: end while
8: return T1

check locality of T1 w.r.t. Si according to the choice for Si
if non-local then

T1 := repair T1 until it is local for Si according to the choice for Si

Fig. 5. A procedure for checking safety

E. Jim enez-Ruiz et al.

It is immediate to see that the following holds upon completion of the proce-
dure: for each Si, if the user selected the refinement (generalisation) view, then
T is -local (-local) w.r.t. Si. This is sufficient to guarantee safety, as given
by the following proposition:
Proposition 13. Let T be an ontology and S = S1  . . .  Sn be the union of
disjoint signatures. If, for each Si, either T is -local or -local w.r.t. Si, then
T guarantees safety.

The Module Coverage Guarantee. The fragment extracted for each customised signature in the online phase must satisfy the module coverage guar-
antee. As seen in Section 2.3, -locality and -locality can also be used for
extracting modules in the sense of Definition 3. Given an external ontology T 
and customised signature Si, the scope of the -module and -module is determined by Proposition 9: as shown in Figure 3, the -module will contain all the
super-concepts in T  of the concepts in Si, whereas the -module will contain
all the sub-concepts.
The construction in Figure 3 also shows that the extraction of -modules or
-modules may introduce symbols not in Si, and potentially unnecessary. To
make the module as small as possible, we proceed as follows, given T 
i and Si:
first, extract the minimal -module M for S in T 
i ; then, extract the minimal
-module for S in M. The fragment obtained at the end of this process satisfies
the module coverage guarantee as given in the following proposition:
Proposition 14. Let T 
erage of S in T .

2 = LoMod(UpMod(T , S), S). Then T 

2 guarantees cov-

The Module Independence Guarantee. When a module is imported in the
online phase (see Figure 4), module independence should be guaranteedthat
is, importing a module for a signature Si from an external ontology T 
into T
should not affect the safety of T w.r.t. to the other external ontologies. The
following proposition establishes that this guarantee always holds provided that
the imported module in T 
i does not share symbols with the remaining external
ontologies T 
j . In practice, this is always the default situation since different
reference ontologies have different namespaces and therefore their signatures are
disjoint. The following proposition is an immediate consequence of the syntactic
definition of -locality and -locality.
Proposition 15. Let T be an ontology and S1, S2 disjoint signatures. If, for each
i = 1, 2, T is -local or -local w.r.t. Si, then T guarantees module independence.

i

4 The Ontology Reuse Tool

We have developed a Prot eg e 46 plugin that supports the methodology presented in Section 3. The plugin and user manual can be downloaded from
http://krono.act.uji.es/people/Ernesto/safety-ontology-reuse.
6 Ontology Editor Prot eg e 4: http://www.co-ode.org/downloads/protege-x/
?

?

?
Fig. 6. Prot eg e Safe Manager Interface

The Offline Phase. The first step of the offline phase involves the selection of the
external entities. Our plugin provides functionality for declaring entities as external as well as for defining the external ontology URI (or signature subgroup) for the
selected entities; this information is stored in the ontology using OWL 1.1 annotations [7] as follows: we use an ontology annotation axiom per external ontology, an
entity annotation axiom to declare an entity external, and an entity annotation axiom per external entity to indicate its external ontology. The set of external entities
with the same external ontology URI can be viewed as one of the Si. Finally, the UI
of the plugin also allows for the specification, for each external ontology, whether
it will be refined or generalised. Once the external entities have been declared and
divided into groups, the tool allows for safety checking of the ontology under development w.r.t. each group of external symbols separately. The safety check uses
-locality (-locality) for signature groups that adopt the refinement (generalisa-
tion) view. The non-local axioms to be repaired are appropriately displayed.

Figure 6 shows the Safe Prot eg e Manager component with the set of signature
subgroups in the top left corner, and the non-local axioms in the bottom left
corner. Note that, in this phase, our tool does allow the user to work completely
offline, without the need of extracting and importing external knowledge, and
even without knowing exactly from which ontology the reused entities will come
from. Indeed, the specification of the URI of the external ontologies is optional
at this stage, and, even if indicated, such URI may not refer to a real ontology,
but it may simply act as a temporary name.

The Online Phase. In the online phase, the user chooses external ontologies
and imports axioms from them. At this stage, the groups of external symbols to

E. Jim enez-Ruiz et al.

Fig. 7. Module information obtained from Galen. (left) Module average size against
max size. (right) Frequency distributions for module sizes.

be imported should refer to the location of a real external ontology. Once an
external signature group Si has been selected for import, the selected signature
can be customised by adding super-concepts and sub-concepts of the selected
symbols. The tool provides the functionality for previewing the concept hierarchy of the corresponding external ontology for this purpose. Once the specific
signature group under consideration has been customised, a module for it can
be extracted. The module is computed using the procedure in Proposition 14;
the user can compute the module, preview it in a separate frame, and either
import it or cancel the process and come back to the signature customisation
stage. The user is also given the option to import the whole external ontology
instead of importing a module. Note that currently the import of a module is
done by value, in the sense that the module becomes independent from the
original ontology: if the external ontology on the Web evolves, the previously
extracted module will not change.

The right hand side of the Safe Prot eg e Manager component (see Figure 6)
includes the set of necessary components to support the proposed steps for the
online phase.

5 Evaluation

So far, we have demonstrated our tool to various ontology developers7 who have
expressed great interest, and we are currently working on a proper user study.
In the following, we describe the experiments we have performed to prove that
locality-based modules are reasonably sized compared to the whole ontology.
7 Thanks to Elena Beiwanger, Sebastian Brandt, Alan Rector, and Holger Stenzhorn

for valuable comments and feedback.
?

?

?
For each concept name A in NCI or Galen8, we have proceeded as follows.
(i) For each pair (u, ) between (0, 0) and (3, 3), construct the signature S(A, u, )
by taking A, its super-concepts in the next u levels and its sub-concepts in the
2 = LoMod(T 
next  levels. (ii) Extract T 
, SA), see
Proposition 14. From now on, we will refer to the modules T 
1 and T 
2 mentioned
above as Upper Module (UM) and Lower of Upper Module (LUM).

1 = UpMod(T , SA) and T 

We have grouped the extracted modules according to the size of the input
signature in order to evaluate its impact on the size of the modules. Figure 7
shows the obtained results for Galen (3161 entities and 4170 axioms), where
the size of a module is the number of its axioms. The following conclusions
can be drawn from the empirical results: first, the modules obtained are small
on average since 99% of UMs have at most 487 axioms ( 12% of the size
of Galen), and 99% of the LUMs contain at most and 386 axioms ( 9% of
the size of Galen) for initial signatures S(A, u, ) containing between 1 and 330
entities; second, the growth in the size of the modules w.r.t. the size of the initial
signature is smooth and linear up to initial signatures containing 100 entities.
We have similar findings for NCI v3 (27,722 entities and 395,124 axioms, most
of them annotations), NCI v7 (63,754 entities and 867,374 axioms, most of them
annotations) and SNOMED (entities and 389,541 axioms and 389,544 entities).
In addition to the synthetic experiments, we have undertaken some real
experiments in the context of the Health-e-Child projects user scenario, see
Section 1. The experiments focus on JRA and Cardiomyopathies (CMP)a
group of diseases that are central to the project. Using our tool, members of
the project have manually selected signatures that are relevant to JRA and
Cardiomyopathies from both Galen and NCI, expanded these signatures as in
the case of the synthetic tests, and extracted the corresponding modules. For
example, in the case of JRA in Galen, the initial signature and expanded signature consisted of 40 and 131 entities. The following tables show the sizes of all
signatures and modules extracted from (a) Galen and (b) NCI.

(a) Disease

Signature size

JRA JRA CMP

(b) Disease

Signature size

JRA JRA CMP

# axioms
# concepts
# roles

490 1151
?

?

?
# axioms
# concepts
# roles

300 1258
?

?

?
6 Related Work

Ontology Engineering Methodologies: Several ontology engineering methodologies can be found in the literature; prominent examples are Methontology [8],
On-To-Knowledge (OTK) [9], and ONTOCLEAN [10]. These methodologies, how-
ever, do not address ontology development scenarios involving reuse. Our proposed
methodology is complementary and can be used in combination with them.
8 We have used a fragment of GALEN expressible in OWL:

http://krono.act.uji.es/Links/ontologies/galen.owl/view

E. Jim enez-Ruiz et al.

Ontology Segmentation and Ontology Integration Techniques: In the
last few years, a growing body of work has been developed addressing Ontology
Modularisation, Ontology Mapping and Alignment, Ontology Merging, Ontology
Integration and Ontology Segmentation, see [11, 12, 13] for surveys. This field
is diverse and has originated from different communities.

In particular, numerous techniques for extracting fragments of ontologies.
Most of them, such as [14, 15, 16], rely on syntactic heuristics for detecting
relevant axioms. These techniques do not attempt to formally specify the intended outputs and do not provide any guarantees.
Ontology Reuse techniques: There are various proposals for safely combining modules; most of these proposals, such as E-connections, Distributed
Description Logics and Package-based Description Logics propose a specialised
semantics for controlling the interaction between the importing and the imported
modules to avoid side-effects, for an overview see [17]. In contrast, in our paper
we assume that reuse is performed by simply building the logical union of the
axioms in the modules under the standard semantics; instead, we provide the
user with a collection of reasoning services, such as safety testing, to check for
side-effects. Our paper is based on other work on modular reuse of ontologies
[18, 19, 6, 5] which enables us to provide the necessary guarantees. We extend
this work with a methodology and tool support.

7 Lessons Learned and Future Work

We have described a logic-based approach to the reuse of ontologies that is both
safe (i.e., we guarantee that the meaning of the imported symbols is not changed)
and economic (i.e., we import only the module relevant for a given set of symbol
and we guarantee that we do not lose any entailments compared to the import
of the whole ontology). We have described a methodology that makes use of
this approach, have implemented tool support for it in Prot eg e, and report on
experiments that indicate that our modules are indeed of acceptable size.

In the future, we will extend the tool support so that the user can shop for
symbols to reuse: it will allow to browse an ontology for symbols to reuse and
provide a simple mechanism to pick them and, on check-out, will compute the
relevant module. Moreover, we are working on more efficient ways of module
extraction that make use of already existing computations. Next, we plan to
carry out a user study to learn more about the usefulness of the interface and
how to further improve it. Finally, our current tool support implements a by
value mechanism: modules are extracted and added at the users request. In
addition, we would like to support import by reference: a feature that checks
whether the imported ontology has changed and thus a new import is necessary.

Acknowledgements

This work was partially supported by the PhD Fellowship Program of the Generalitat Valenciana, by the Fundaci o Caixa Castell o-Bancaixa, and by the UK
EPSRC grant no. EP/E065155/1.
?

?

