Forgetting Concepts in DL-Lite

Zhe Wang1, Kewen Wang1, Rodney Topor1, and Jeff Z. Pan2

1 Griffith University, Australia

2 The University of Aberdeen, UK

Abstract. To support the reuse and combination of ontologies in Semantic Web
applications, it is often necessary to obtain smaller ontologies from existing larger
ontologies. In particular, applications may require the omission of many terms,
e.g., concept names and role names, from an ontology. However, the task of omitting terms from an ontology is challenging because the omission of some terms
may affect the relationships between the remaining terms in complex ways. We
present the first solution to this problem by adapting the technique of forgetting,
previously used in other domains. Specifically, we present a semantic definition
of forgetting for description logics in general, which generalizes the standard
definition for classical logic. We then introduce algorithms that implement forgetting in both DL-Lite TBoxes and ABoxes, and in DL-Lite knowledge bases.
We prove that the algorithms are correct with respect to the semantic definition
of forgetting, and that they run in polynomial time.

1 Introduction

Ontologies are required for Semantic Web applications as they provide a shared representation of the terms and the relationships between terms in particular application
domains. Such Semantic Web applications will normally require access to only some
of the terms, i.e., concept and role names, in available ontologies. However the tasks of
restricting attention to relevant terms in, or omitting irrelevant terms from, a given ontology is challenging because the omission of some terms generally affects the relationships between the remaining terms. Accordingly, the ontological engineering tasks of
combining and transforming large ontologies have received extensive attention
recently.

Current technologies, however, provide only limited support for such operations. The
web ontology language OWL allows users to import one ontology into another using
the owl : imports statement. Most ontology editors allow the reuse of another ontology by including it in the model that is being designed. For example, Prot eg e allows
user to include other projects. However, these approaches to ontology reuse have at
least two limitations: (1) Some ontologies are very large and ontology engineers might
need to import only a part of the available ontologies. For instance, the medical ontology UMLS 1 contains around 300,000 terms and only some of these will be relevant to
any particular application. (2) The ability to deal with inconsistency and contradiction
caused by merging ontologies is very limited in these approaches. Hence, researchers

1 http://www.nlm.nih.gov/research/umls

S. Bechhofer et al.(Eds.): ESWC 2008, LNCS 5021, pp. 245257, 2008.
c Springer-Verlag Berlin Heidelberg 2008

Z. Wang et al.

have proposed alternative approaches to address these problems in reusing and merging ontologies. In the literature, the problem of reusing portions of large ontologies is
referred to as partial use of ontologies.

Consider the following scenario. Suppose we need an ontology about Cancer but
only have a large ontology Medicine, which describes many diseases and treatments.
It would not be efficient to adopt and use the whole ontology Medicine, since we only
need a small part of its contents. A better strategy is to discard those terms that are not
required (such as Odontia) and use the resulting restriction of the ontology.

Another scenario occurs when ontology engineers are constructing a complex on-
tology. The engineers may wish to conveniently delete terms which are unnecessary
or poorly defined. This task is relatively easy in traditional database systems, but in an
ontology, where concepts are more closely related to each other, simply removing a concept or role name may destroy the consistency of the ontology and may cause problems
with subsequent reasoning. More sophisticated methods for deleting (omitting/hiding)
information in ontologies are required.

In this paper we address the issue of partial ontology reuse by employing the technique of forgetting, which has been previously been thoroughly studied in classical
logic [13,12] and logic programming [6,14]. Informally, forgetting is a particular form
of reasoning that allows a piece of information (say, p) in a knowledge base to be discarded or hidden in such a way that future reasoning on information irrelevant to p will
not be affected. Forgetting has proved to be a very useful tool in many tasks such as
query answering, planning, decision-making, reasoning about actions, knowledge update and revision in classical logic [13,12] and logic programming [6,14]. However, to
the best of our knowledge, forgetting has not previously been applied to description
logic ontology reuse.

In particular, we study new techniques for forgetting from knowledge bases in the
DL-Lite family of description logics. This family was recently proposed by Calvanese
et al. [2,3,4]. Logics in this family are particularly attractive because they are expressive enough for many purposes and have polynomial time reasoning algorithms in the
worst case, in contrast to more common description logics which have exponential time
reasoning algorithms. Indeed, logics in the DL-Lite family have been proved to be the
maximal logics allowing efficient conjunctive query answering using standard database
technology.

The main contributions of the paper include the following.

1. We provide a semantic definition of forgetting from DL-Lite TBoxes, which also

applies to other description logics.

2. We prove that the result of forgetting from TBoxes in languages of the DL-Lite
family can always be expressed in the same languages, and present algorithms to
compute TBox forgetting for such languages.

3. We introduce a definition of forgetting for DL-Lite ABoxes, which preserves conjunctive query answering, and use this to define forgetting for arbitrary DL-Lite
knowledge bases.

4. Finally, we prove our algorithms are correct and that they run in polynomial time.

The rest of the paper is organized as follows. Some basics of DL-Lite are briefly recalled
in Section 2. We present the semantic definition of forgetting in arbitrary description logic
?

?

?
(DL) TBoxes in Section 3 and show the DL forgetting has the same desirable properties
that classical forgetting has. In Section 4, we introduce our algorithms for computing the
result of forgetting in DL-Lite TBoxes, and show the algorithms are correct with respect
to the semantic definition. We note that the forgetting algorithms are simple, run in polynomial time, and do not make other reasoning processes more complex. The forgetting
technique and the results are then extended to DL-Lite ABoxes and knowledge bases in
Section 5, and detailed examples are presented to show how forgetting algorithms work.
Finally, Section 6 concludes the paper and discusses future work.

2 Preliminaries

Description logics (DLs) are a family of concept-based knowledge representation for-
malisms, equipped with well-defined model-theoretic semantics [1]. The DL-Lite family is a family of lightweight ontology languages that can express most features in UML
class diagrams but still have low reasoning overheads [2]. Besides standard reasoning
tasks like subsumption between concepts and satisfiability of knowledge bases, the issue
of answering complex queries is especially considered. The DL-Lite family consists of
a core language DL-Litecore and some extensions, among which two main extensions
are DL-LiteF , and DL-LiteR,.

The DL-Litecore language has the following syntax:

B  A | R
C  B | B
R  P | P 

where A is an atomic concept and P is an atomic role (with P 
called a basic concept, R a basic role and C is called a general concept.

as its inverse). B is

A DL-Litecore TBox is a set of inclusion axioms of the form

B  C

A DL-Lite ABox is a set of membership assertions on atomic concepts and atomic

roles:

A(a), P (a, b)

A DL-Lite knowledge base (KB) is a tuple KB K = T ,A, where T is a DL-Lite
The semantics of a DL is given by interpretations. An interpretation I is a pair
is an interpretation
and each
. For DL-Litecore, the interpreta-

where a and b are constants.
TBox and A is a DL-Lite ABox.
(I ,I), where I
function which associates each atomic concept A with a subset AI
atomic role P with a binary relation P I  I  I
tion function I

is a non-empty set called the domain and I

of I

can be extended to complex descriptions:
(P )I = {(a, b) | (b, a)  P I}
(R)I = {a | b.(a, b)  RI}
(B)I = I \ BI

Z. Wang et al.

An interpretation I is a model of B  C iff BI  CI
, that is, all instances of
concept B are also instances of concept C.
(resp., (aI , bI) 
An interpretation I is a model of A(a) (resp., P (a, b)) if aI  AI
P I
).
An interpretation I is a model of a KB T ,A, if I is a model of all axioms of T
and assertions of A. A KB K is consistent if it has at least one model. Two KBs that
have the same models are said to be equivalent. A KB K logically implies an axiom (or
assertion) , denoted K |= , if all models of K are also models of .

Although DL-Lite is a simple language, it is useful because it is sufficiently expressive and because conjunctive query evaluation over DL-Lite KBs is extremely efficient.
A conjunctive query (CQ) q(x) over a KB K is an expression of the form

{x | y.conj(x, y)}

where x, y are lists of variables, conj(x, y) is a conjunction of atoms, and atoms have
the form A(s) or P (s, t), where A is an atomic concept, P is an atomic role, and s and
t are either individual names or variables. Given an interpretation I, qI
is the set of
tuples of domain elements such that, when assigned to x, y.conj(x, y) is true in I.
Given a CQ q(x) and a KB K, the answer to q over K is the set ans(q,K) of tuples a
of constants in K such that a

for every model I of K.

I  qI

DL-LiteF , extends DL-Litecore by allowing for conjunction of concepts in the
left-hand side of inclusions and role functionality axioms in TBoxes. The extended
syntax is:

B  A | R
D  B | D1  D2
C  B | B
R  P | P 

and TBoxes contain axioms of the form:

D  C and (funct R).
Given an interpretation I, we define (D1  D2)I = D1
(funct R) iff (a, b1)  RI

and (a, b2)  RI

I  D2
implies b1 = b2.

. Then I is a model of

DL-LiteR, extends DL-Litecore by allowing for conjunctions of concepts in the
left-hand side of inclusions axioms, role complements, and role inclusion axioms in
TBoxes. In this case the extended syntax is:

B  A | R
D  B | D1  D2
C  B | B
R  P | P 
S  R | R

and TBoxes contain axioms of the form:

D  C and R  S.
?

?

?
Given an interpretation I, we define (R)I = I  I \ RI

. Then I is a model of

R  S iff RI  SI

.

We note that the data complexity of DL-Litecore is log-space whereas the data com-

plexity of the two extensions (as defined here) is polynomial-time.

Example 2.1. The following is a simple DL-Litecore knowledge base Library, which
describes the resources, users and lending policies of a library. This knowledge base
has a TBox T consisting of the following axioms:

onLoanTo  LibItem, onLoanTo
Member  Person, Visitor  Person, Visitor  Member ,
LibItem  hasCatNum, hasCatNum
hasCatNum  Missing  LibItem

  CatNum,

  Member ,

and an ABox A consisting of the following assertions:

LibItem(SWPrimer), onLoanTo(DLHandBook , Jack).
Here, LibItem denotes library items, onLoanTo denotes the loan relationship between library items and people, CatNum denotes catalogue numbers, and hasCatNum
denotes the relationship between library items and their catalogue numbers. Note that
not every person is a member or visitor.

If we regarded this example as a knowledge base of DL-LiteF ,, we could add the

TBox axioms (funct onLoanTo) and (funct hasCatNum).

3 Forgetting Concepts from DL-Lite TBoxes
In this section, we define the operation of forgetting about a concept A in a TBox T .
Informally, the TBox that results from forgetting about A in T should: (1) not contain
any occurrence of A, (2) be weaker than T , and (3) give the same answer to any query
that is irrelevant to A. We will first give a semantic definition of forgetting in DL-Lite,
investigate its properties and in the next section introduce algorithms for computing the
result of forgetting in different languages of the family DL-Lite.
Let L be a DL-Lite language. The signature SL of L is the set of concept and role
names in L. We will omit the subscript if there is no confusion caused. Our semantic
definition of forgetting in DL-Lite is an adaption of the corresponding definition for
classical logic.
Let A be an atomic concept name in L and I1 and I2 interpretations of L. We define
I1 A I2 iff I1 and I2 agree on all atomic and concept role names except possibly A:
1. I1 and I2 have the same domain (I1 = I2), and interpret every individual name
the same (aI1 = aI2 for every individual name a).
2. For every concept name A1 distinct from A, AI1
3. For every role name P , P I1 = P I2.
Clearly, A is an equivalence relation, and we say I1 is A-equivalent to I2.
Definition 3.1. Let T be a TBox in L and A an atomic concept in T . A TBox T 
the signature S \ {A} is a result of forgetting about A in T if any interpretation I
model of T 

if and only if there is a model I of T such that I A I

1 = AI2
1 .

on
is a

.

Z. Wang et al.

It follows from the above definition that the result of forgetting about an atomic concept
A in a TBox T is unique in the sense that, if both T 
are results of forgetting
about A in T , then they are equivalent. So we will use forget(T , A) to denote the result
of forgetting about A in T throughout the paper.
Obviously, forget(T , A) does not contain any occurrence of A and is weaker than T .
However, the definition of forgetting guarantees that forget(T , A) and T are equivalent
under query answering on S \ {A}.

and T 

Note that the above definition of forgetting can be applied to other description logics.
Example 3.1. Consider the TBox T in Example 2.1. Suppose the library now wishes
to allow nonmembers to borrow library items but still wishes to prevent visitors from
borrowing library items, i.e, suppose the library wishes to forget about atomic concept
Member in T . From the definition, forget(T , Member) now consists of the following
axioms:

  CatNum,

onLoanTo  LibItem, onLoanTo
Visitor  Person, onLoanTo
LibItem  hasCatNum, hasCatNum
hasCatNum  Missing  LibItem.

  Person,

  Visitor ,

We believe this definition correctly captures the informal operation of forgetting a concept from a TBox.

Definition 3.1 clearly captures our informal understanding of forgetting. However,
we have not yet shown that the result of forgetting about a concept always exists or
how to compute the result of forgetting. In the next section, we introduce algorithms for
computing the result of forgetting in different DL-Lite languages. From the soundness
and completeness of these algorithms, we can immediately conclude that the result of
forgetting about concepts exists for every TBox in DL-Lite.
Theorem 3.1. Let T be a TBox in a DL-Lite language L and A an atomic concept.
Then the result of forgetting about A in T always exists and is in L.
Forgetting in DL-Lite has other important properties. In particular, it preserves reasoning relative to TBoxes.
Proposition 3.1. LetT be a TBox inL and A an atomic concept. LetT  = forget(T , A).
Then, for any ABox A on S \ {A}, we have:
 The knowledge base T ,A is consistent iff T ,A is consistent.
 For any inclusion axiom  not containing A, T |=  iff T  |= .
 For any membership assertion  not containing A, T ,A |=  iff T ,A |= .
 For any conjunctive query q not containing A, ans(q,T ,A) = ans(q,T ,A).
It is straightforward to generalize Definition 3.1 to the operation of simultaneously forgetting about a set of concept names.

We can forget about a set of concept names by forgetting one by one since, if A1 and

A2 are concept names, it is easy to show that

forget(forget(T , A1), A2)  forget(forget(T , A2), A1).
?

?

?
This property allows us to define the result of forgetting a set S = {A1, . . . , An} of
concept names by

forget(T , S)  forget(. . . (forget(T , A1), . . . ), An).

4 Computing the Result of Forgetting in DL-Lite
In Example 3.1, the result of forgetting about Member in the TBox T was obtained
from T by simple syntax transformations. In this section, we introduce algorithms for
computing the result of forgetting in different languages of DL-Lite. We prove that our
algorithms are sound and complete with respect to the semantic definition of forgetting
in the previous section. Our algorithms show that the result of forgetting in a DL-Lite
TBox can always be obtained using simple syntax-based transformations.
A language of DL-Litecore (resp. DL-LiteF ,, DL-LiteR,) is denoted Lcore (resp.
LF ,, LR,). We first introduce the forgetting algorithm for DL-Litecore as Algorithm 1, then extend it to algorithms for DL-LiteF , and DL-LiteR,. The basic idea of
Algorithm 1 is to first transform the given TBox into a standard form and then remove
all occurrence of A.

Algorithm 1 (Computing the result of forgetting in DL-Litecore)
Input: A TBox T in Lcore and an atomic concept A.
Output: forget(T , A)
Method:
Step 1. Remove axiom A  A from T if it is present.
Step 2. If axiom A  A is in T , remove each axiom A  C or B  A from T , and replace
each axiom B  A in T by B  B.
Step 3. Replace each axiom B  A in T by A  B.
Step 4. For each axiom Bi  A (1  i  m) in T and each axiom A  Cj (1  j  n) in
T , where each Bi is a basic concept and each Cj is a general concept, if Bi  Cj is not in T
already, add Bi  Cj to T .
Step 5. Return the result of removing every axiom containing A in T .

Fig. 1. Forgetting in a DL-Litecore TBox

Example 4.1. Consider the TBox T in Example 2.1 again. Algorithm 1 replaces the
axioms

onLoanTo

  Member , Member  Person andVisitor  Member

by the axioms

onLoanTo

  Person and onLoanTo

  Visitor ,

which gives the same result as Example 3.1.

If the library wants to completely eliminate lending restrictions, then the result of forgetting about the concept Visitor can be obtained by removing the following (lending
restriction) axioms:

Visitor  Person and onLoanTo

  Visitor .

Z. Wang et al.

We can now show that Algorithm 1 is sound and complete with respect to the seman-

tic definition of forgetting in DL-Litecore TBoxes.
Theorem 4.1. Let T be a TBox in Lcore and A an atomic concept appearing in T .
Then Algorithm 1 always returns forget(T , A).
Given the forgetting algorithm for a DL-Litecore TBox, we can extend it to compute the
results of forgetting in DL-LiteF , and DL-LiteR, TBoxes.

and B  D  B are equivalent.

be basic concepts and D a conjunction of basic concepts, then

Recall that both DL-LiteF , and DL-LiteR, extend DL-Litecore by allowing conjunctions of basic concepts in the left-hand side of inclusion axioms. Therefore, to extend
Algorithm 1 to these two extensions, we need a method of handling such conjunctions.
For inclusion axioms in which the concept A occurs negatively, i.e., axioms of the
form of D  A, where D is a conjunction, we cannot transform it into an equivalent
axiom A  D, as we did previously, since this is not an axiom in the DL-Lite lan-
guage. However, the following two lemmas give useful properties of conjunctions that
can be applied in the extended algorithm.
Lemma 4.1. Let B, B
the two axioms B  D  B
Lemma 4.2. Suppose T is a TBox in L and T = { Di  A | i = 1, . . . , m}  { A 
 Cj | j = 1, . . . , n}  TA, where m, n  0, A is an atomic concept, each Di
D
is a nonempty conjunction, each D
j is a (possibly empty) conjunction, each Di, D
and Cj does not contain A, and TA is a set of axioms that do not contain A. Then
T  = {Di  D
 Cj | i = 1, . . . , m, j = 1, . . . , n}  TA = forget(T , A). (If m or n
is 0, then T 
Because we are currently concerned only with forgetting concepts, the extensions to
functional role axioms and role inclusion axioms are not relevant to our algorithm.
Hence, the same algorithm implements concept forgetting for both DL-LiteF , and DL-
LiteR, TBoxes. This algorithm is now given as Algorithm 2. Throughout Algorithm 2,
D denotes a possibly empty conjunction and D
From the definition of Algorithm 2 it is easy to see that the following result holds.
Proposition 4.1. Let T be a TBox T in LF , or LR, and A an atomic concept name
appearing in T . Then Algorithm 2 always terminates and takes polynomial time in the
size of T .
It is an immediate corollary that Algorithm 1 has the same properties.

denotes a nonempty conjunction.

j

j

j

is the empty set).

From Lemma 4.1 and Lemma 4.2, it can easily be shown that Algorithm 2 is sound
and complete with respect to the semantic definition of forgetting for DL-Lite. In other
words, we have following theorem.
Theorem 4.2. Let T be a TBox T in LF , or LR, and A an atomic concept name
appearing in T . Then Algorithm 2 always returns forget(T , A).
Example 4.2. Recall the TBox T in Example 2.1. If we want to forget about concept
name LibItem in T , then Algorithm 2 returns the following axioms, which comprise
forget(T , LibItem):

onLoanTo  hasCatNum, onLoanTo

  Member ,
?

?

?
Algorithm 2 (Computing the result of forgetting in DL-Litecore extensions)
Input: A TBox T in LF , or LR, and an atomic concept name A.
Output: forget(T , A)
Method:
Step 1. Remove each axiom A  D  A in T .
Step 2. If axiom A  A is in T , remove each axiom A  D  C or D
  B and B  A by B  B.
each axiom B  D
Step 3. Replace each axiom A  D  A in T by D  A.
Step 4. Replace each axiom B  D  A in T by A  D  B.
Step 5. For each axiom D
i  Dj and add D
i  Dj  Cj to T .
in T if D
?

?

?
Step 6. Return the result of removing every axiom containing A in T .

i  Dj  Cj is not in T , simplify D
?

?

?
i  A (1  i  m) in T and each axiom A  Dj  Cj (1  j  n)
?

?

?
  A by D

  A, and replace

Fig. 2. Forgetting in DL-Litecore extension TBoxes

Member  Person, Visitor  Person, Visitor  Member ,
hasCatNum
hasCatNum  onLoanTo  Missing.

  CatNum,

5 Forgetting Concepts from DL-Lite Knowledge Bases

Given the semantic definition of forgetting in TBoxes, we want to extend the notion
of forgetting to ABoxes and DL-Lite Knowledge Bases (KB). However, DL-Lite languages are not closed under ABox forgetting, i.e., the classical forgetting result in an
DL-Lite ABox is not expressible in the same language. A simple example would be, a
DL-Lite KB with one axiom A  B in TBox and one assertion A(a) in ABox. To
forget about concept name A in ABox, we have to remove the assertion A(a). However,
the original KB has a logical consequence B(a), that is, a cannot be interpreted as a
member of concept B, which can not be expressed by standard DL-Lite ABoxes. Once
concept A is forgotten, we also lose the information about a and B.

Adopting classical forgetting into DL-Lite ABoxes might lead outside of the original language. However, we argue that, for ABoxes, the classical forgetting is not nec-
essary. Since ABoxes are used for maintain membership information and for query-
answering, an ABox forgetting operation, as long as it preserves membership relation
(rather than non-membership relation) and query-answering, should be good enough for
ontology uses.
Given a Knowledge Base (KB) K = T ,A in DL-Lite language L, the result of
forgetting about a concept name A in K should be a KB K
does
not contain any occurrence of A and (2) K and K
are equivalent w.r.t. any conjunctive
query on the signature L \ {A}.
Definition 5.1. Let K = T ,A be a knowledge base in a DL-Lite language L and A
on the signature S \ {A} is a result of forgetting
an atomic concept in A. An ABox A
about A in A with respect to K if, for any conjunctive query q on the signature of
S \ {A}, ans(q,T ,A) = ans(q,T ,A) holds.

in L such that (1) K

Z. Wang et al.

Example 5.1. Consider the following ABox from Example 2.1:

A = {LibItem(SWPrimer), onLoanTo(DLHandBook , Jack)}

To forget about atomic concept LibItem, we cant just remove the membership assertion LibItem(SWPrimer), because we would lose information about SWPrimer.
According to the TBox axiom, we know that SWPrimer must have a catalogue num-
ber, so we can replace LibItem(SWPrimer) with hasCatNum(SWPrimer , z) where
z denotes the catalogue number of SWPrimer . This is the result of forgetting about
LibItem in A.

From the above example we can see that a major issue in forgetting about an atomic
concept A in an ABox A is how to preserve subsumption relations between different
concepts. For example, if A  B is in TBox T and A(a) is in A, then B(a) is derivable
from K = T ,A. However, if we simply delete A(a) from A, we will be unable to
derive B(a) from the resulting knowledge base. Hence, we have to propagate selected
information before a concept name can be forgotten. For convenience, we slightly extend our definition of ABoxto allow variables in assertions. An assertion with variables
represents a scheme (in particular, we use the symbol   to represent non-distinguished
variables) in ABox [8].
To forget about A(a) from DL-Litecore ABox A, an intuitive way is to remove A(a)
and add all B(a) to A such that B subsumes A. However, as we will show later, it is
sufficient to add each (a), where  is explicitly asserted to subsume A.
New membership assertions generated from A(a) form a set f(A, a) = { (a) |
A   in T }, where  is a concept description in DL-Lite, and





(a) =

B(a)
P ( , a)
P (a, )

if  = B is an atomic concept,
if  = P 
if  = P .

,

The result of forgetting about a concept name A in A, denoted forgetK(A, A), is a
new ABox obtained by replacing every assertion A(a)  A with the corresponding set
f(A, a) of assertions. When the DL-Lite KB K is clear from the context, we can omit
it from forgetK(A, A) and write forget(A, A) instead.
In a DL-LiteF , or DL-LiteR, ABox, if we want to forget about an atomic concept A, then axioms of the form A D   must also be considered, i.e., if A(a) needs
to be removed and K |= D(a), then (a) must be added into the new knowledge base.
Let A be an ABox in LF , or LR, and A an atomic concept name. Then, as in
the case of DL-Litecore, we can define (a) and thus f(A, a) = { (a) | A  D 
 in T and K |= D(a)}, where D is a concept conjunction ( K |= D(a) is true when
D is empty).
forgetting, i.e., for some model I
model I of A such that I A I
.

An important observation is that ABox forgetting does not coincides with classical
, there may not exist a

of the result of forgetting A

For simplicity, we will only consider consistent knowledge bases in the following

theorem.

Theorem 5.1. Let A be an atomic concept name in a consistent knowledge base K =
T ,A in DL-Lite language L. For any conjunctive query q on the signature SL \ {A},
we have

Forgetting Concepts in DL-Lite

ans(q,K) = ans(q,T , forgetK(A, A)).

Having defined forgetting for both ABoxes and TBoxes, we are now able to define
forgetting in a DL-Lite knowledge base.
Definition 5.2. Let K = T ,A be a DL-Lite knowledge base and A a concept in
DL-Lite language L. The result of forgetting about A in K is defined to be

forget(K, A) = forget(T , A), forgetK(A, A),

where forgetK(A, A) = A \ {A(a) | a is a constant in L}  { (a) | A  D 
 in T and K |= D(a)}.

It is important to note that the forgetting operation in ABoxes is with respect to the original knowledge base (especially, the original TBox). However, forgetting in the TBox
does not depend on the ABox. The computation process of forgetting about a concept
in a DL-Lite knowledge base is shown in Algorithm 3. In this algorithm, D denotes a
possibly empty conjunction.

Algorithm 3 (Computing the result of forgetting in an DL-Lite knowledge base)
Input: A knowledge base K = T ,A in L and an atomic concept A.
Output: forget(K, A).
Method:
Step 1. For each assertion in A of the form A(a),
- for every axiom A  D  B in T , if K |= D(a) (true when D is empty), add B(a) to A;
- for every axiom A  D  P in T , if K |= D(a), add P (a, ) to A;
in T , if K |= D(a), add P ( , a) to A;
- for every axiom A  D  P
Step 2. Remove all assertions containing A in A, giving A
forgetK(A, A))
be the result of forgetting about A in T , ignoring A
Step 3. Let T 
Step 4. Return the knowledge base K

. (As shown before, A

= T 



,A.

.

=

Fig. 3. Forgetting in a DL-Lite knowledge base

From Proposition 3.1 and Theorem 5.1, it is not hard to see following theorem holds.
Theorem 5.2. Let K = T ,A be a consistent knowledge base in DL-Lite language L
and A an atomic concept in K. For any conjunctive query q on SL \ {A}, we have

ans(q,K) = ans(q, forget(K, A))

.

Z. Wang et al.

6 Related Work

An alternative approach to partial reuse of ontologies is based on the notion of conservative extensions [7], a notion that has been well investigated in classical logic. An
ontology T is a conservative extension of its subontology T   T w.r.t a signature S
are equivalent under query answering on S. The theory of
if and only if T and T 
conservative extensions can be applied in ontology refinement and ontology merging
[7]. Since the goal of partial use of ontology is to obtain a smaller ontology from a
larger ontology, a dual theory of conservative extensions, called modularity of ontology
is also explored in [10,11]. Unfortunately, given an ontology T , there does not exist a
conservative extension in many cases. Moreover, it is exponential to decide if there is a
conservative extension/module for a given ontology in common description logics such
as ALC . A more recent approach is introduced in [9]. Unlike modularity approach, this
approach focuses on ABoxes update. A shortcoming of this approach is that DL-Lite
languages are not closed under their ABox update operation. Eiter et al [5] have also
attempted to define forgetting for OWL ontologies by transforming an OWL ontology
into a logic program. However, this approach only works for some OWL ontologies.

7 Conclusion

We have presented the first complete account of forgetting from DL-Lite description
logics. This process is a key operation in reusing and combining ontologies, which are
based on such description logics. We have presented a semantic definition of forgetting from DL-Lite TBoxes and ABoxes and correct, efficient implementations of the
semantics.

Natural next steps are to extend these approaches to other description logic families,
to investigate forgetting roles as well as concepts, to find more efficient algorithms for
forgetting a set of concepts (or roles) simultaneously, and to implement and apply the
methods to practical problems.

Acknowledgments

The authors would like to thank three anonymous referees for their helpful comments.
This work was partially supported by the Australia Research Council (ARC) Discovery
Projects DP0666107.
