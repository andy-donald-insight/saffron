LINGUISTICAND COMPUTATION ALSEMANTICS *
Brian Cantwell Smith
XEROX Palo Alto Research Center
3333 Coyote Hill Road , Palo Alto , CA 94304

We argue that because the very concept of computation rests on notions of interpretation  , the semantics of natural anguages and the semantics of computational formalisms are in the deepest sense the same subject  . The attempt to use computational formalisms in aid of an explanation of natural language semantics  , therefore , is an enterprise that must be undertaken with particular care  . We describe a framework for semantical analysis that we have used in the computational realm  , and suggest hat it may serve to under write computadonally-oriented linguisticser  . antics as well . The major feature of this framework is the explicit recognition of both the declarative and the procedural import of meaningful expressions  ; we argue that whereas these two viewpoints have traditionally been taken as alternative  , any comprehensive semantical theory must account for how both aspects of an expression contribute to its overall significance  . 
We have argued elsewhere 1 that the distinguishing mark of those objects and processes we call computational has to do with attn'buted semantics  . " we humans find computational processes coherent exactly because we attach semantical significance to their behaviour  , ingredients , and so forth . Put another way , computers , on our view , are those devices that we understand by deploying our linguistic faculties  . For example , the reason that a calculator is a computer , but a car is not , is that we take the ingredients of the calculator to be symbolic  ( standing , in this particular case , for numbers and functions and so forth ) , and understand the interactions and organisation of the calculator in terms of that interpretation  ( this part divides , this part represent she sum , and so on ) . Even though by and large we are able to produce an explanation of the behaviour that does not rest on external semantic attribution  ( this is the formality condition mentioned by Fodor  , Haugel and . and others z ) , we nonetheless peak , when we use computational terms , in terms of this semantics . These semantical concepts rest at the foundations of the discipline : the particular organisations that computers have their computation alraison d ' et re ~ emerge not only from their mechanical structure but also from their semantic interpretability  . 
Similarly , the terms of art employed in computer science -- program  , compiler , implementation , iter preter , and so forth--will ultimately he definable only with reference to this attributed semantics  ; they will not , on our view , ever be found reducible to non-semantical predicates ? This is a ramifying and problematic position  , which we cannot defend here . 4 We may simply note , however , the overwhelming evidence in favour of a semantical approach manifested by everyday computational language  . Even the simple view of computer science as the study of symbol manipulations reveals this bias  . Equally telling is the fact that programming languages are called languages  . 
In addition , language-derived concepts like name and reference and semantics permeate computational jargon  ( to say nothing of interpreter , value , variable , memory , expression , identifier and so on ) -- a fact that would be hard to explain if semantics were not crucially involved  . It is not just that in discussing computation we use language  ; rather , in discussing computation we use words that suggest that we are also talking about linguistic phenomena  . 
The question we will focus on in this paper , very briefly , is this : if computational rte facts are fundamentally inguistic  , and if , therefore , it is appropriate to analyse them in terms of formal theories of semantics  ( it is apparent that this is a widely held view )  , then what is the proper relationship between the socalled computational semantics that results  , and more standard linguistic semantics ( the discipline that studies people and their natural languages : how we mean  , and what we are talking about , and all of . 
that good stuff ) ? And furthermore , what is it to use computational models to explain natural language semantics  , if the computational models are themselves in need of semantical analysis ? On the face of it  , there would seem to be a certain complexity that should he sorted out  . 
In answering these questions we will argue approximately as follows : in the limit computational semantics and linguistic semantics will coincide  , at least in underlying conception , if not in surface detail ( for example some issues , like ambiguity , may arise in one case and not in the other ) . Unfortunately , however , as presently used in computer science the term " semantics " is given such an operational cast that it distracts attention from the human attribution of significance to computational structures  . 6 In contrast , the most successful models of natural language semantics  , embodied for example in standard model theories and even in Montague's program  , have concentrated almost exclusively on referential or denotational aspects of declarative sentences  . Judging only by surface use , in other words , computational semantics and linguistic semantics appear almost orthogonal in concern  , even though they are of course similar in so'le ( for example they both use meta-theoretic mathematical techniques -- functional composition  , and so forth--to recursively specify the semantics of complex expressions from a given set of primitive atoms and formation rules  )  . It is striking , however , to observe two facts . First , computational semantics is being pushed ( by people and by need ) more and more towards declarative or referential issues  . Second , natural anguage semantics , particularly in computationally-based tudies , is focusing more and more on pragmatic questions of use and psychological import  . Since computational linguistics operates under the computational hypothesis of mind  , psychological issues are assumed to be modelled by a field of computational structures and the state of a processor running over them  ; thus these linguistic oncerns with " use " connect naturally with the " operational " flavour of standard programming language semantics  . It seems not implausible , therefore -- we betray our caution with the double negative -- that a unifying framework might be developed  . 
It will be the intent of this paper to present a specific  , if preliminary , proposal for such a framework . First , however , some introductory comments . In a general sense of the term , semantics can be taken as the study of the relationship between entities or phenomena in a syntactic domains and corresponding entities in a semantic domain t  )  . as pictured in the following diagram . 
IS2ntactic Domain Si@Semantic Domain D , , I We call the function mapping dements from the first domain into elements of the second an interpretation function  ( to be sharply distinguished 7 from what in computer science is called an interpreter  , which is a different beast altogether ) . Note that the question of whether an element is syntactic or semantic is a function of the point of view  ; the syntactic domain for one interpretation function can readily be the semantic domain of another  ( and a semantic domain may of course include its own syntactic domain  )  . 
Not all relationships , of course , count as semantical ; the " grandmother " elationship fits into the picture just sketched  , but stakes no claim on being semantical . Though it has often been discussed what constraints on such a relationship characterise genuinely semantical ones  ( compositionality or recursive specifiability , and a certain kind of formal character to the syntactic domain  , are among those typically mentioned ) , we will not pursue such questions here . Rather , we will complicate our diagram as follows , so as to enable us to characterise a rather large class of computational and linguistic formalisms : \[   ) ? otation ) ? l\]\] ) ~ otation ~2 \] t ~ ua and N2 are intended to be notational or communicational expressions  , in some externally observable and consensually established medium of interaction  , st ! 21 an strings of characters , streams of words , or sequences of display images on a computer terminal  . The relationship O is an interpretation function mapping notations into internal elements of some process over which the primary semantical and processing regimens are defined  . In first-order logic , sl and s2 would be something like abstract derivation tree types of first-order formulae  ; if the diagram were applied to the human mind , under the hypothesis of a formally encoded mentales e  , s ~ and s2 would be tokens of internal mentales e , and e would be the function computed by the " linguistic " faculty  ( on a view such as that of Fodora )  . In adopting these terms we mean to be speaking very generally  ; thus we mean to avoid , for example , any claim that tokens of English are internalised  ( a term we will use for o ) into recognisable tokens of mentales e . In particular , the proper account of e for humans could well simply describe how the field of mentales e structures  , in some configuration , is transformed into some other configuration , upon being presented with a particular English sentence  ; this would still count , on our view , as a theory of o . 
In contrast , ~ is the interpretation function that makes explicit the standard enotational significance of linguistic terms  , relating , we may presume , expressions in $ to the world of discourse . The relationship between my mental token for T . S . Eliot , for example , and the poeth imself , would he formulated a span of ~ . Again , we speak very broadly ; ? is intended to manifest what , paradigmatically , expressions are about , however that might best be formulated ( , 1 , includes for example the interpretation functions of standard model theories  )  , q , , in contrast , relate some internal structures or states to other s--one can imagine it specifically as the formally computed derivability relationship in a logic  , as the function computed by the primitive language processor in a computational machine  ( i . e . , as tzsP'S EVAL ) , or more generally as the function that relates one configuration of a field of symbols to another  , in terms of the modifications engendered by some internal processor computing over those states  . (~ and q , are named , form nemonicon venience , by analogy with philosophy and psychology , since a study of ? is a study of the relationship between expressions and the world--since philosophy takes you " out of your mind "  , so to speak--whereas a study of ~ v is a study of the internal relationships between symbols  . 
all of which , in contrast , are " within the head " of the person or machine . ) Some simple comments . First`N ~ , N2 , Sl , S  ~ , o  ~ , and oz need not all necessarily be distinct : in a case where sl is a self-referential designator  , for example , D ~ would he the same as s ~; similarly , in a case where ~ , computed a function that was designation -preserving  , then D ~ and o7 would be identical . Secondly , we need not take a stand on which of x ~ and ? has a prior claim to being the semantics of sl  . In standard logic , q , ( i . e . , derivability : -) is a relationship , hut is far from a function , and there is little tendency to think of it as semantical  ; a study of , I , is called proof theory . In computational systems , on the other hand , q , is typically much more constrained , and is also , by and large , analysed mathematically in terms of functions and so forth  , in a manner much more like standard model theories  . Although in this author's view it seems a little far-fetched to call the internal relationships  ( the " use " of a symbol ) semantical , it is nonetheless true that we are interested in characterising both  , and it is unnecesary to express a preference . For discussion , we will refer to . he " , -semantics of a symbol or expression as its declarative /  mp0rt   , and refer to its *- semantics as its procedural consequence  . 
We have heard it said in other quarters that " procedural " and " declarative " theories of semantics are contenders  ;   9 to the extent hat we have been able to make sense of these notions  , it appears that we need both . 

It is possible to use this diagram to characterise a variety of standard formal systems  . In the standard models of the k-calculus , for example , the designation function ~ , takes h-expressions onto functions ; the procedural regimen % usually consisting of =- and / l-reductions  , can be shown to be ~ , -preserving . Similarly , if in a standard predicate logic we take ? to be ( the inverse of the ) satisfaction relationship , with each element of S being a sentence or set of sentences  , and elements of o being those possible worlds in which those sentences are true  , and similarly take , I , as the derivability relationship , then soundness and completeness can he expressed as the equation ' l '  ( sl , s2)m\[o ~ C_D ~\] . As for all formal systems ( these presumably subsume the computation alones )  , it is crucial that , t , he specifiable independent of , l ,  . The h-calculus and predicate logic systems , furthermore , have no notion of a processor with state ; thus the appropriate ? involves what we may call local procedural conse  . quence , r lating a simple symbol or set of symbols to another set  . In a more complex computational circumstance , as we will see below , it is appropriate to characterise a more complex f ~ rll procedural consequence involving not only simple expressions  , but fuller encodings of the state of various aspects of the computational machine  ( for example , at least environments and continuations in the typical computational  easel0  )  . 
An important consequence of the analysis illustrated in the last figure is that it enables one to ask a question ot typically asked it " computer science  , about the ( q , - ) semantic character of the function computed by ~ ,  . Note that questions about soundness and completeness in logic are exactly questions of this type  . In separate research , 11 we have shown , by subjecting it to this kind of analysis , tJ~at computational formalisms can be usefully analysed in these terms as well  . In particular , we demonstrated that the universally a:cepted LISP evaluation protocol is semantically Confused  , in the fbllowing sense : sometimes it preserves ?   ( i . e .  ~( , I , ( S )) = ~ , ( s )) , and sometimes itembodies ?( i . e . , , l , ( s ) = , l , ( s)) . The traditional LISP notion of evaluation , in other words , conflates simplification and reference relationships  , to its peril ( in that report we propose some LISP dialects in which these two are kept strictly separate  )  . The current moral , however , is merely that our approach allows the question of the semantical import of  , ~ to be asked . 
As well as considering LISP . we may use our diagram to c~laracterise the various linguistically oriented projects carried on under the banner of " semantics "  . Model theories and formal theories of language ( we include Tarski and Montague in one sweep ) have concentrated primarily on ~ ,  . Natural language semantics in some quarters 12 focuses on o ~ on the translation into an internal medium ~ although the question of what aspects of a given sentence must be preserved in such a translation are of course of concern  ( no translator could ignore the salient properties  , emantical and otherwise , of the target language , be it mentale se or predicate logic , since the endeavour would otherwise be without constraint  )  . 
l . ew is ( for one ) has argued that the project of articulating O ~ an ? ndeavour he calls markerese semantics -- cannot really be called semantics at all  ,   13 since it is essentially a translation relationship  , zlthough it is worth noting that e in computational formalisms is not z  . l ways trivial , and a case can at least be made that many superficial aspects of natural language use  , such as the resolution of indexicals , raay be resolved at this stage ( if for example you say I am warm then I may internalise your use of the first person pronoun into my iaternal name for you  )  . 
Those artificial intelligence researchers working in knowledge representation  , perhaps without too much distortion , can be divided into two groups : a ) those whose primary semantical allegiance is to ~ , and who ( perhaps as a consequence ) typically use an encoding of first-order logic as . their representation language , and b ) those who concern themselves primarily with , ~ , and whother e for e ( legitimately enough ) reject logic as even suggestive ( * in logic--derivability is a relatively unconstrained relationship  , for one thing ; secondly , the relationship between the entailment relationship  , to which derivability is a hopeful approximation , and the proper " ~ , " of rational belief revision , is at least a matter of debate l4) . 
Programming language semantics , for reasons that can at least be explored , if not wholly explained , have focused primarily on q , , although in ways that tend to confuse it with ~ . Except for PROLOG , which borrows its ? straight from a subset of first-order logic  , and the LIsPs mentioned earlier , is we have never seen a semantical account of a programming language that gave independent accounts of ? and  , 1 ,  . There are complexities , furthermore , in knowing just what the proper treatment of general anguage should be  . In a separate paper 16 we argue that the notion program is inherently defined as a set of expressions whose  ( ~- ) semantic domain includes data structures ( and set-theoretic entities built up over them )  . In other words , in a computational process that deals with finance  , say , the general data structures will likely designate individuals and money and relationships among them  , but the terms in that pan of the process called a program will not designate these people and their money  , but will instead design a : ~' the data ztructures that designate people and money  ( plus of course relationships and functions over those data structures  )  . Even on a declarative view like ours , in other words , the appropriate semantic domain for programs is built up over data structures -- a situation strikingly like the standard semantical accounts that take abstract records or locations or whatever as elements of the otherwise mathematical domain for programming language semantics  . It may be that this fact that all base terms in programs are meta-syntactic that has spawned the confusion between operations and reference in the computational setting  . 
Although the details of a general story remain to be worked out  , the LiSP case mentioned earlier is instructive , by way of suggestion as to how a more complete computational theory of language semantics might go  . In particular , because of the context relativity and nonlocal effects that can emerge from processing a LISP expression  ,  ~ , is not specifiable in a strict composition alway .   , ~-- when taken to include the broadest possible notion that maps entire configurations of the field of symbols and of the processor itself onto other configurations and states -- is of course recursively specifiable  ( the same tact , in essence , assaying that LISP is a deterministic formal calculus  )  . A pure characterlsation f , I , without a concomitant account of $ , however , is unmotivated -- as empty as a specification of a derivability relationship would be for a calculus for which no semantics had been given  . Of more interest is the ability to specify what we call a general significance  . function 2 , that recursively specifies , I , and , ~ together ( this is what we were able to do for LZSP )  . In particular , given any expressions ~ , any configuration of the rest of the symbols , and any state of the processor , the function z will specify the configuration and state that would result  ( i . e . . it will specify the use of sx ) , and also the relationship to the world that the whole signifies  . For example , 1 t given a LISP expression of the form ( + z ( PROG ( SETQA 2 ) A ) ) , ~ g would specify that the whole expression designated the number three  , that it would return the numeral "3" , and that the machine would be left in a state in which the binding of the variable A was changed to the numeral " z "  . A modest result ; what is important is merely a ) that both declarative import and procedural significance must be reconstructed in order to tell  . a full story about LISP ; and b ) that they must be formulated together . 
Rather than pursue this view in detail , it is helpful to set out several points that emerge from analyses developed within this framework : a  . In most programming languages , o can be specified compositionally and independently of  4  , or *-- this amounts to a formal statement of Fodor's modularity thc~m for language  , z 7In the ease of formal systems , O is often contextfree and compositional , but not always ( reader macros can render i to paque , or at least intensional , and some languages such as ALGOLale apparently context-sensitive  )  . It is noteworthy , however , that there have been computational languages for whiche could not be specified indepently of * a fact that is often stated as the fact that the programming language " cannot be parsed except at runtime "  (   TEC0 and the first versions of SHALLTALK had this character  )  . 
b . Since LISP is computational , it follows that a full account of its * can be specified independent of  4  , ; this is in essence the formality condition . It is important obring out , however , that a local version of * will typically not be compositional in a modem computational formalism  , even though such locality holds in purely extensional contextfree side-effectfree language such as the h-calculus  . 
c . It is widely agreed that * does not uniquely determine  , I ,   ( this is the " psychology narrowly construed " and the concomitant methodological solipsism of Putnam and Fodorando them lS  )  . 
However this fact is compatible with our foundational claim that computational systems are distinguished in virtue of having some version of  4  , as part of their characterisation . A very similar point can be made for logic : although any given logic can  ( presumably ) be given a mathematically-specified model theory , that theory doesn'typically tie down what is often called the standard model or interpretation -- the interpretation that we use  . This fact does not release us , however , from positing as a candidate logic only a formalism that humans can interpret  . 
d . The declarative interpretation 4 , cannot be wholly determined independent of * , except in purely declarative languages ( uch as the x-calculus and logic and so forth )  . This is to say that without some account of the effect on the processor of one fragment of a whole linguistic structure  , it may be impossible to say what that processor will take another fragment as designating  . The use of StTQ in LISP is an example ; natural language instances will be explored , below . 
This last point needs a word of explanation . It is of course possible to specify 4 , in mathematical terms without any explicit mention of a ?- like function  ; the approach we use in LISP defines both . and in terms of the overarching function ? mentioned above  , and we could of course simply define 4 , without defining . at all . Ouri ~ oint , rather , is that any successful definition of ~ , will effectively have to do the work of * , more or less explicidy , either by defining some identifiable relationship  , or else by embedding that relationship within the recta-theoretic machinery  . We are arguing , in other words , only that the subject we intend * to cover must be treated in some fashion or other  . 
What is perhap surprising about a II of this machinery is that it must be brought to bear on a purely procedural language -- all three relationships  ( O ,  4 , , and . ) figure crucially in an account even of LISP . we are not suggesting that LzsP is like natural anguages : to point out just one crucial difference  , there is no way in LISP or in any other programming language  ( except PROLOG ) tO say anything , whereas the ability to say things is clearly a foundational aspect of any human language  . The problem in the procedural languages is one of what we may call assertional force  ; although it is possible to construct a sentence -like expression with a clear declarative semantics  ( such as some equivalent of " x ? 3" )  , one cannot use it in such a way as to actually mean it--so as to have it carry any assertional weight  . For example , it is trivial to set some variable x to a , or to ask whether x is 3 , but there is no way to state that x is 3 , It should be admitted , however , that computation a languages bearing assertional force are under considerable current investigation  . This general interest is probably one of the reasons for PaOLOG ' Semergent popularity  ; other computational systems with an explicit declarative character include for example specification languages  , database models , constraint languages , and knowledge representation languages in A . I . We can only assume that the appropriate semantics for all of these formalisms will align even more closely with an illuminating semantics for natural language  . 
What does all of this have to do with natural language  , and with computational linguistics ? The essential point is this : tf this characterisation f formal systems is tenable  , and if the techniques of standard programming language semantics can be fit into this mould  , then it may be possible to combine those approaches with the techniques of programming language semantics and of logic and model theories  , to construct complex and interacting accounts of * and of  4  ,  . To take just one example , the techniques that are used to construct mathematical c counts of environments and continuations might be brough to bear on the issue of dealing with the complex circumstances involving discourse models  , theories of focus in dealing with anaphora , and so on ; both cases involve an attempto construct a recursively specifiable account of nonlocal interactions among disparate fragments of a composite text  . But the contributions can proceed in the other direction as well : even from a very simple application of this framework to this circumstance of LISP  , for example , we have been able to show how an accepted computational notion fails to cohere with our attributed linguistically based understanding  , involving us in a major reconstruction of LZSP'S foundations  . The similarities are striking . 
Our claim , in sum , is that similar phenomena occur in programming languages and natural languages  , and that each discipline could benefit from the semantical techniques developed in the other  . Some examples of these similar phenomena will help to motivate this view  . The first is the issue ~ t , , . appropriate use of noun phrases : as well as employing a noun phrase in a standard e  . ~ , lnmnal position , natural language semantics has concerned itself with more difficult cases such as intensional contexts  ( as in the underline designator in I didn't know The Big Apple was an island  . 
where the co-designating term New York cannot be substituted without changing the meaning  )  , the socalled attributive ~ referential noun phrase like " the man with a martini " to inform you that someone is drinking a martini  , as Opposed to a situation where one uses the heater's belief or assumption that someone is drinking a martinito refer to him  )  , and so on . Another example different from either of these is provided by the underlined term in For the next  20 years let's re~tric the president's alary to $20  , 000 , on the reading in which after Reagan is defeated he is allowed to earn as much a shepleases  , but his successor comes under our constraint . The analagous computational cases include for example the use of an expression like  ( the formal analog of ) make the sixth array element be 10 ( i . e . , A(B)::~10) . where we mean not that the current sixth element should be  10   ( the current sixth array element might at the moment tie  9  , and 9 can't be 10) , but rather that we would like the description " the sixth array element " to refer to  10 ~ socalled " L-values " , analogous to HACI . ISP'Sserf construct) . Or , to take a , : lifferent case , suppose we say set x to the sixt harray element ( i . e . , x :: = A(B )) , where we mean not that x should be set to the current sixth array element  , but that it should always be equal to that element  ( stated computation a Uy this might be phrased as saying that : ~ should track a  ( 6 )  ; stated linguistically we might say that X should mean " the sixth array element "  )  . Although this is not a standard type of assignment  , he new constraint languages provide exactly such facilities  , and macros ( classic computational intensional operators ) can be used in more traditional languages for such purposes  , Or , for a final example , consider the standardec ~ ation : z ~ r\[GeAx , in which the term " x " refers neither to the variable itself  ( variables are variables , not numbers ) , nor to its current designation , but rather to whatever will satisfy the description " the value of x " at any point in the course of a computation  . All in all , we cannot ignore the attempt on the computationalists ' part to provide complex mechanisms so strikingly similar to the complex ways we use noun phrases in English  . 
A very different sort of lingusitic phenomenon that occurs in both programming languages and in natural language are what we might call " premature xits ": cases where the processing of a local fragment aborts the standard interpretation of an encompassing discourse  . If for example Isay to you I was walking down the street that leads to the house that Mary's aunt used to  . . . forget it ;\[ was taking a walk , then the " forget it " must be used to discard the analysis of some amount of the previous entence  . The grammatical structure of the subsequent phrase determines how much has been discarded  , of course ; the sentence would still be comprehensible if the phrase " an old house I like " followed the " forget it "  . We are not accustomed to semantical theories that deal with phenomena like this  , of course , but it is clear that any serious attempto model real language understanding will have to face them  . Our present point is merely that continuations z ? enable computational formalisms to deal exactly with the computational analogs of this : socalled escape operators like I  , IACLISP'STHROW and CATCH and QUIT . 
In addition , a full semantics of language will want to deal with such sentences as If by " flustrated " you meanwhat I think  , then she was certainly fluslrated . The proper treatment of the first clause in this sentence will presumably involve lots of "  , t , " sorts of considerations : its contribution to the rcmainder of the sentence has more to do with the mental states of speaker and hearer than with the world being describe by the presumed conversation  . Once again , the overarching computational hypothesisuggests that the way these psychological effects must be modelled is in terms of alterations in : he state of an internal process running over a field of computational structures  . 
As well as these specific examples , a couple of more general morals can be drawn , important in that they speak directly to styles of practice that we see in the literature  . The first concerns the suggestion , apparently of some currency , that we reject the notion of logical form , and " do semantics directly " in a computational model On our account his is a mistake  , pure and simple : to buy into the computational framework is to believe that the ingredients in any computational process are inherently linguistic  , in need of interpretation . Thus they too will need semantics ; the internalisation of English into a computer ( O ) is a translation relationship ( in the sense of preserving ~ , presumably ) -- even if it is wildly contextual , and even if the internal anguage is very different in structure from the st  . rucmre of English . It has sometimes been informally suggested , in an analogous vein , that Montague semantics cannot be taken seriously computationally  , because the models that Montague proposes are " too big "-- how could you possibly carry these infinite functions around in your head  , we are asked to wonder . But of course this argument comits a use/mention mistake : the only valid computational reading of Montague would mean that mentalse  (  , ~ ) would consist of designators of the functions Montague propose ~ and those designators can of course be a few short formulae  , It is another consequence of our view that any semanticist who propose some kind of " mental structure " in his or her account of language is commited to providing an interpretation of that structure  . Consider for example a proposal that posits a notion of " focus " for a discourse fragment  . Such a focus might be viewed as a ( possibly abstracO entity in the world , or as a element of computational structure playing such-and-such role in the behavioural model of language understanding  . It might seem that these are alternative accounts : what our view insists is that an interpretation of the latter must give it a designation  ( e  ~ )  ; thus there would be a computational structure ( being biased , we will call it the focus-designator ) , and a designation ( that we call the focus . itsel\]) . 
The complete account of focus would have to specify both of these  ( either directly , or else by relying on the generic declarative semantics to mediate between them  )  , and also tell a story about how the focus -designator plays a causal role  (  , I , ) in engendering the proper behaviour in the computational model of language understanding  . 
There is one final problem to be considered : what it is to design an internal folvnatism S  ( the task , we may presume , of anyone designing a knowledge representation language  )  . Since , on our view , we must have a semantics , we have the option either of having the semantics informally described  ( or , even worse , tacitly assumed ) , or else we can present an explicit account , either by defining such a story ourselves or by borrowing from someone lse  . If the LIsp case can be taken as suggestive , a purely declarative model theory will be inadequate to handle the sorts of comptuational interactions that programming languages have required  ( and there is no a priori reason to assume that successful computational models for natural language will be found that are simpler than the programming languages the community has found necessary for the modest sons of tasks computers are presently able to perform  )  . However it is also reasonable to expect hat no direct analog to programming language semantics will suffice  , since they have to date been so concerned with purely procedural  ( behavioural ) consequence . It seems at least sort mentioned earlier , may be required . 
Consider for example the ZLONE language presented by Brachmaneta L  21 Although no semantics for KLONE has been presented  , either procedural or declarative , its proponents have worked both in investigating the o-sehaantics  ( how to translate English into KLONE )  , and in developing an informal account of the proceduralspects  . Curiously , recent directions in that project would suggest hat its authors expect obeable to provide a " declarative-only " account of KLONE semantics  ( i . e . , expect o be able to present an account of ~ , independent of ~ , ) , in spite of our foregoing remarks . Our only comment is to remark that independence of procedural consequence is not a prerequisite to an adequate semantics  ; the two can be recursively specifiable together ; thus this apparent position is stronger than formally necessary ~ which makes it perhaps of considerable interest  . 
In sum , we claim that any semantical account of either natural language or computational language must specify O  ,   , I , , and , ~; if any are leRout , the account is not complete . We deny , furthermore , that there is any fundamental distinction to be drawn between socalled procedural languages  ( of which LISP is the paradigmatic example in A . I . ) and other more declarative languages ( encodings of logic , or representation languages ) . We deny as well , contrary to at least some popular belief , the view that a mathcmatically well-specified semantics for a candidate " mcntales e " must bc satisfied by giving an independently specified declarative semantics  ( as would be possible for an encoding of logic , for example ) . The designers of zat , zz for example , for principled reasons denied the possibility of giving a semantics ind cpendent of the procedures in which the Kat structures participated  ; our simple account of LISP has at least suggested that such an approach could be pursued on a mathematically sound footing  . Note however , in spite of our endorsement of what might be called a procedural semantics  , that this innoway frees one from from giving a declarative semantics as well  ; procedural semantics and declarative semantics are two pieces of a total story  ; they are not alternatives . 
NOTES * I am grateful to Barbara Grosz and Hector Levesque for their comments on an earlier draft of this short paper  , and to Jane Robinson for her original suggestion that it be written  . 
1 . Smith (1982 1o ) 2 . Fodor (1978) , Fodor (1980) , Haugeland ( forthcoming ) 3 . At least until the day arrives -- if ever -- when a successful psychology of language is presented wherein all of human semantieity is explained in non-semantical terms  . 
4 . Problematic because it defines computation ia manner that is derivative on mind  ( in that language is fundamentally a mental phenomenon  )  , thus dashing the hope that computational psyc . ~ , : ! c , td will offer a release from the semantic irreducibility of previous accounts of human cognition  . Though we state this position and explore some of its consequences in Smith  ( 1982b )  , a considerably fuller treatment will be provided in Smith  ( forthcoming )  . 
5 . See for example Newelt (1980) 6 . The term " semantics " is only one of a large collection of terms  , unfortunately , that are technical terms in computer science and in the attendant cognitive disciplines  ( including logic , philosophy of language , linguistics , and psychology ) , with different meanings and different connotations  . Reference , interpretation , memory , and value are just a few examples of the others . It is our view that in spite of the fact that semantical vocabulary is used in different ways  , the fields are both semantical in fundamentally the same ways : a unification of terminology would only be for the best  . 
7 . An example of the phenomenon noted in foomote 6 . 
8 . Fodor ( forthcoming ) 9 . Woods (1981) 10 . For a discussion of continuations see Gordon ( 1979 )  , Steele and Sussman (1978) , and Smith (1982a ) ; the formal device is developed in Strachey & Wadsworth  ( 1974 )  . 
H . Smith (1982a).
12 . A classic example is Katz and Postal (1964) , but much of the recent A . I . research in natural language in A . L can be viewed in this light . 
13. Lewis (1972).
14. Israel (1980).
15 . For a discussion of P ~ OLOG see Clocks in & Mellish  ( 198 l )  ; the
Lt SPS are described in Smith (1982a ) ? 16 . Smith ( forthcoming ) . 
17. Fodor ( forthcoming).
18 . The term " methodological solipsism " is from Putnam  ( 1975 )  ; see also Fodor (1980) . 
19. Donnellan (1966).
20. See note 10, above.
21. Brachman (1979).
22. Bobrow and Winograd (1977).

Bobrow , Daniel G . . and Winograd , Terry , " An Overview of KRL : A Knowledge Representation Language "  , Cognitive Science 1 pp .  3-46, 1977 . 
Brachman , Ronald , " On the Epistemological Status of Semantic Networks "  , in Findlerl Nicholas V . ( ed . ) , Associative Networks : Representation ad Use of Knowledge by Computers  , New York:
Academic Press , 1979.
Clocks in . W . F . , and Mellish , C . S . , Programming in Prolog , Berlin:
Springer-Verlag , 1981.
Donnellan , K . , " Reference and Definite Descriptions " , Philosophical Review 75:3(1966) pp . 281-304; reprinted in Rosenberg and Travis ( eds . ) , Readings in the Philosophy of Language , Prentice-
Hall , 1971.
Fodor , Jerry , " TomSwift and his Procedural Grandmother " , Cognition 6 , 1978; reprinted in Fodor (1981) . 
" Methodological Solipsism Considered as a Research Strategy in Cognitive Psychology "  , The Behavioral and Brain Sciences , 3:1(1980) pp . 63-73; reprinted in Haugel and ( ed . ) , Mind Design , Cambridge : Bradford ,  1981 , and in Fodor (1981) . 

Israel , David , " What's Wrong with N on Monotonic Logic ?" , Proceedings of the First Annual Conference of the American Association for Artificial Intelligence  , Stanford , California ,  1980 , pp .  99-101 . 
Katz , Jerrold , and Postal , Paul , An Integrated Theory of Linguistic Descriptions , Cambridge : M . I . T . Press , 1964 . 
Lewis , David , " General Semantics " , in Davidson and Harman ( eds . ) , Semantics of Natural Langauges , Dordrecht , Holland : D . Reidel , 1972, pp .  169-218 . 
Newe U , Alien , " Physical Symbol Systems " , Cognitive Science 4 , pp . 

Putnam , Hilary , " The meaning of ' meaning '" , in Putnam , Hilary , Mind Language and Reality , Cambridge , U . K . : Cambridge
University Press , 1975.
Smith . Brian C . , Reflection and Semantics in . a Procedural Language , Laboratory for Computer Science Report LCS-TR-272 , M . I . T . ,
Cambridge , Mass ., 1982 ( a).
, " Semantic Attribution and the Formality Condition "  , presented at the Eighth Annual Meeting of the Society for Philosophy and Psychology  , London , Ontario , Canada , May 1316 , 1982 ( b) . 
, The Computational Metaphor , Cambridge : Bradford ( forthcoming ) . 
Steele , Guy , and Sussman , Gerald J . , " The Art of the Interpreter , or the Modularity Complex ( parts Zero , One , and Two ) " , M . LT . 
Artificial Intelligence Laboratory McmoAIM-453 , Cambridge , 
Mass , 1978.
Strachey , C . , and Wadsworth , C . P . , " Continuations -- a Mathematical Semantics for Handling Full Jumps "  , PRG-I1 , Programming Rcsearch Group , University of Oxford ,  1974 . 
Woods , William A . , " Procedural Semantics as a Thcory of Meaning " , Report No . 4627, Bolt Beranek and Newman , 50 Moulton St . , Cambridge , Mass . , 02138; reprinted in Joshi , A . , Sag , I . , and Webber , B . , Computational Aspects of Linguistic Structures and Discourse Settings  , Cambridge , U . K . : Cambridge University
Press , 1982.

