LR Parsers
For Natural Languages,
Masaru Tomita
Computer Science Department
Carnegie Mellon University
Pittsburgh , PA 15213

MLR , an extended LR parser , is introduced , and its application to natural language parsing is discussed  . 
An LR parser is a ~ ; hift-reduce parser which is do terministically guided by a parsing table  . A parsing table can be obtained automatically from a contextfree phrase structure grammar  . LR parsers cannot manageant l ) iguous grammars such as natural language grammars , because their I ) arsing tables would have multiply-defined entries , which precludes deterministic parsing . MLR , however , can handle mulliply-defined entries , using a dynamic programnting method . When an input sentence is ambiguous , the MI . R parser produces all possible parse trees witf toul parsing any part of the input sentenc : e more than once in the same way  , despite the fact that the parser does not maintain a chart as in chart par~ing  . Our method also prnvkles an elegant solution to the problem of multi-part-of-speech words such as " that "  . The MLR parser and its parsing table generator have been implemented at Carnegie Mellon 

1 Introduction
LR parsers \[ I ,   2\] have been developed originally for programming language of compilers  . An LR parser is a shift-reduce parser which is detenninistically guided by a par  . ~ it ~ gtable indicating what action should be taken next  . The parsing table can be obtained automatically from a contextfree phrase structure grammar  , using an algorithm first developed by De Remer\[5 ,  6\] . We do not describe the algorithm here , reffering the render to Chapter 6 in Aho and UIIman \[4\]  . The LR parsers have seldom been used for Natural Language Processing probably because :  1  . It has been thought that natural languages are not contextfree  , whereas LR parsers can deal only with contextfree languages  . 
2 . Natural languages are ambiguous , while standard LR parsers cannot handle ambi ~ juous languages  . 
The recent literature\[8\] shows that the belief " natural languages are not contextfree " is not necessarily true  , and there is no reason for us to give up the context-freedom of natural languages  . We ( to not discuss on this matter further , considering the fact that even if natural languages are not contextfree  , a fairly comprehensive grammar for a subset of natural language suflicient for practical systems can be written in context  . free phrase structure . lht J . % our main concern is how to cope with the ambiguity of natural languages  , and this concern is addressed in the fallowing section  . 
2 LR parsers and Ambiguous Grammars
If a given grammar is ambiguous ? we cannot have a parsing table in which ~ ve ~ y entry is uniquely defined  ; at lea~tone entry of it ~ parsing table is in ulliply defined  . It has been thought that , for LRpa ~ sers , nnd tiple entries are fatal because they make deterministic parsing no longer po ~$ ible  . 
Aho et . al .   \[3\] and Shieber\[121 coped with this ambiguity problem by statically 3 selecting one desired action out of multiple actions  , and thus converting n = ulliply-defined entries into uniquely-defined ones  . With this approach , every input sentence has no more than one parse tree  . This fact is desirable for progralnming languages . 
For natural languages , however , it is sometimes necessary for a parser to produce more than one parse tree  . For example , consider the following short story . 
I saw the man with a telescope.
He should have bought it at the department store.
When the first sentence is read , there is absolutely no way to resolve the ambiguity  4 at that time . The only action the system can take is to produce two parse trees and store them somewhere for later disambiguation  . 
In contrast with Aho et . al . and Shieber , our approach is to extend LR parsers so that they can handle multiple entries and produce more than one parse tree if needed  . We call the extended LR parsers MLR parsers . 
ll ' his rP . ~ i:i'?l'Ctl was-~pon~oled by the Df . ' ie ose Advanced Research Projects Agency ( DOD ) , ARPA Older No .  3597 , munitoled hylhe Air Foi'r:e Avionics Lot ) oratory Under C , uolracl F3:)(~1581K-t539 . The views and con, . ;lusion $ conl , lii ~ cdi=1lhi . ~;(lo =; unlq ; nta~i . ~ tho ' . ; e()tt1 ~ . !; iuh or . ~; alld should not be illler preted as n : pre . -' , enling the official p(':licie : ; , c , ilher expressed or implied , of the Defense Advanced Re , ql . .'; . trch Projects Ag 4 . tn cy or the US Gow . ~ . rnnlent . 
2 A grammar is ambi Quous , if some input sentence can be parsed in more than on ~  . W , gy , 3Byt ' ~ tatically ", we mean the ~ . .: election is done at par . ~ ing table construction time , 4"1" have the telescope , or " the man " has the telescope . 
3 54   3 MLRParsers of different parses have in the chart parsing method  \[10  ,  11\] . The idea should be made clear by the following example  . 
An example grammar and its MLR parsing table produced by the construction algorithm are shown in fig  . 1 and 2, respectively . 
The MLR parsing table construction algorithm is exactly the same as the algorithm for LR parsers  . Only the difference is that an MLR parsing table may have multiple entries  . Grammar symbols starting with . . . . . represent preterminals . " shn " in the action table ( the left part of the table ) indicates the action " shift one word from input buffer onto the stack  , and go to state n " . " ren " indicates the action " reduce constituents on the stack using rule n "  . " acc " stands for tile action " accept " , and blank spaces represent " error " . Gototable ( the right part of the table ) decides to what state the parser should go af tera reduce action  . The exact definition and operation of LR parsers can be found in Aho and Ulhnan  \[4\]  . 
We can see that there are two multiple entries ir ~ the table  ; on the rows of state t t and 12 at the column of "' prep " . As mentioned above , once a parsing table has multiple entries , deterministic parsing is no longer possible ; some kind of nondeterminism is necessary . We . ~ hali see that our dynamic programming approach , which is described below , is much more efficient than conventional breath -first or depth-first search  , and makes MLR parsing feasible . 
4 An Example
In this section , we demonstrate , step by step , how our MLR parser processes the sentence :
ISAWAMANWITHATELESCOPE using the grammar and the parsing table shown in figt and  2  . 
This sentence is ambiguous , and the parser should accept the sentence in two ways  . 
Until the system finds a multiple entry , it behaves in tile exacts a memanner as a conventional LR parser  , as shown in fig 3 a below . The number on the top(ri . qhtmost ) of the stack indicates the current state . Initially , the current state is 0 . Since the parser is looking at the word "1" , whose category is "* n " , the next action " shift and go to state 4" is determined from the parsing table . "\] he . 
parser takes the word "1" away from the input buffer , and pushes the preterminal "* n " ontotile stack  . The next word the parser is looking at is " SAW " , whose category is "' v " , and " reduce using rule 3" is determined as the next action . After reducing , the parser determines the current state ,  2 , by looking at the intersection of the row of state  0 and the column of " NP ?' , and so on . 
Our approach is basically pseudo-parallelism ( breath-first search )  . When a process encounters a multiple entry with n different actions  , the process is split inton processes , and they are executed individually and parallelly  . Each process is continued until either an " error " or an " accept " action is found  . 
The processes are , however , synchronized in the following way : When a process " shifts " a word  , it waits until all other processes " shift " the word  . Intuitively , all processes always look at the same word . After all processes shift a word , the system may find that two or more processes are in the ~ lnle state  ; that is , some processes have a common state number on the top of their stacks  . These processes would do the exactly same thing until that common state number is popped from their stacks by some " reduce " action  . In our parser , this common part is processed only once . As soon as two or more processes in a common state are found  , they are combined into one process . This combining mechanism guarantees that any part of an input sentence is parsed no more than once in the same manner  . " This makes the parsing much more efficient than simple breath-first or depth-first search  . Our method has the same effect in terms of parsing efficiency that posting and recognizing common subconstituents 
STACK MrXT-ACIIONNEXT-WORD .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
0 sh 4  \[  0 = n 4 re 3 SAW 0 NPZ sh 7 SAW 0 NP 2 " v 7 sh 3 A 0 NP 2 ev 7 = det . 3sh IOMAN0NP2Ov7O?let , 3 entOre4WITH0NP2 = v7NPtZre 7 , sh6WI\[II .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . :  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig3oa
At this point , tile system finds a multiple entry with two different actions  , " reduce 7" and " . 3 hiltg " . Both actions are processed in parallel , as shown in fig 3b . 
State * det*n*v " prep$NPPP VPS .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
s h3   sh4   2 t sh6 acc 5   sh7   sh6   9   8   sht0   re3   re3   re3   re2   re2   sh3   sh4   11   sh3   sh4   12   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  2  ( I ) S-->NP VP3 ( 2 ) S-->SPP 4 ( 3  ) NP --> = n 5 ( 4  ) NP-->* det*n6 ( 5  ) NP-->NP PP7 ( 6  ) PP-->=prep NP8 ( 7  ) VP-->"vNP9 .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  10
Fig 1 rettel re5re5 re4 re4 re6 re6 , sh6re69 re7 , sh6re 79
Fig 20 NP 2* v1 HI )   12 * prep 6 waitA 0 S\[sh 6 WI\[II 0 NP 2 " vl NP 12 " prep 6 wait A This process is also finished by the action " accept "  . The system has accepted the input sentence in both ways  . It is important to note that any part of the input sentence  , including the prepositional phrase " WITHA TELESCOPE "  , is parsed only once in the same way , without maintaining a chart . 
0 SI*l ) rep6sh3A0NPZ*v7NPt2"prep6sh3A .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig 3b
Here , the system finds that both processes have the common state number  ,  6 , on the top of their slacks . It combines two proces : ; os into one , and operates as if there is only one process , as shown in fig 3c . 
5 Another Example
Some English words belong to more than one gramillatical category  . When such a word is encountered , tile MLR parsing table can immediately tell which of its cutegories are legal and which are not  . When more than one of its categories a relegal , tile parser behaves as if a multiple entry were encountered  . The idea should be ' made clear by the following example  . 
.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . e .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
OSIII " prep 6 sh 3 A 0 HI ' 2 " v 1 i ' lP 12   4v   0 St " prep 13 " det 3 sh 10 TELESCOPE 0 MP 2 " v 7 NP t2 d #" 0 SII " prep 6 " dot 3 " n ) 0 re 4  $  0 NP 2 " v 7 NP t2 alP " Consider the word " that " in the sentence : That information is important is doubtful  . 
A ~3ample grammar and its parsing table are shown in Fig . 4 and 5, respectively . Initially , the parser is at state O . The first word " that " can be either " " det " or "* that "  , and the parsing table tells us that both categories a relegal  . Thus , the parser processes " sh 5" and " sh 3" in parallel , as shown below . 
0 S ! j " prop G ~ IP tt re 6  $  0 NP 2 " v 7 NP 12  ~  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
STACKNEXIACIIONN\[XXIWORD .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
0 sh5, sh3I'hat
Fig 3c
The action " reduce 6" pops the common state number 6  , and the system can no longer operate the two processes as one  . The two processes are , again , operated in parallel , as shown in fig 3d . 
0 S I PP 5 re 2  $  0 NP 2 = v 7 NP 12 PP 9 re 5  $  0 S\[accept 0 NP 2 * v 7 NP 12 re 7  $  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig 3d
NOW , one of the two processes is finished by the action " accept "  . The other process is still continued , as shown in fig 3-e . 

0 NP 2 VP 8 ret $ 0 St accept 0 sh 5 Fhat 0 sh 3 That 0 * det 5 sh 9 information 0 " that 3 sh 4 information 0 * det 5 * n 9 re 2 is 0 * that 3 * n 4 re 3 is 0 NP 2 sh 6 Is 0 = that 3 NP 2 sh 6 is
Fig . 6-a
At this point , the parser founds that both processes are in the same state  , namely state 2 , and they are combined as one process . 
Fig 3-e ( 2 ) NP-->"det*n3 ( 3  ) NP-->"n4 ( 4 ) NP-- ) * that S5 ( 5  ) VP -->" be " adj 6 .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  7
Fig . 410
State * adj " be " det*n * that $ NP SVP .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
s h5   sh4   sh3   2   1 acc sh6   7   sh5   sh4   sh3   2   8   re3   sh9 shl O re1   re1   re4   re2   re5   re5   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig .   5   0 NP ~ Z * he 6 sh 10 important 0 " that 3 NP 0   NPh=mmmm~2 " b e 6  "  . dj . tat3 NP ftOre 51 , o0NP~2 VP7 rets0"that3NP- .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig . 6-b
The process is split into two processes again.
0 ~ IP 2 VP 7 reIi $ 0 * that 3 NP 2 VP 7 re 1   1=1   0   5   1  #ERRORItl 0 " thor 3  $  8 re 4 is .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig . 6-??
One of two processes detects " error " and halts ; only the other process goes on . 
0 NP 2 sh 6 t = 0 NP 2 * he 6 shtO doubtful 0 ~ JPZ " be 6 " adJtOre 5  $  0   . P2v P7 re1$0sIace$ .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 
Fig . 6-d
Finally , the sentence has been parsed in only one way . We emphasize again that , " in spite of pseudo-parallelism , each part of the sentence was parsed only once in the same way  . 
6 Concluding Remarks
The MLR parser and its parsing table generator have been implemented at Computer Science Department  , Carnegie . Mellon University . The system is written in MACLISP and running on

One good feature of an MLR parser ( and of an LR parser ) is that , even if the parser is to run on a small computer , the construction of the parsing table can be done on more powerful  , larger computers . Once a parsing table is constructed , the execution time for parsing depends weakly on the number of productions or symbols in a grammar  . Also , in spite of pseudo . 
parallelism , our MLR parsing is theoretically still deterministic  . 
This is because the number of processes in our pseudo  . 
parallelism never exceeds the number of states in the parsing table  . 
One concern of our parser is whether the size of a parsing table remains tractable as the size of a grammar grows  . Fig .   6 shows the relationship between the complexity of a grammar and its LR parsing table  ( excerpt from I noue\[9\] )  . 
XPLEULER FOR TRANAL GOL 60
Terminals 477 463 66
Non-terminals 51 45 77 99
Productions 108 121 172 205
States 180t 9332 2337
Table Size ( byte ) 204 1258 7366 24264
Fig . 6
Although the example grammars above are for programming langauges  , it seems that the size of a parsing table grows only in proportion to the size of its grammar and does not grow rapidly  . 
Therefore , there is a hope that our MLR parsers can manage grammars with thousands of phrase structure rules  , which would be generated by rule-schema and metarules for natural language in systems such as GPSG  \[7\]  . 

I would like to thank Takehiro Tokuda , Osamu Watanabe , Jaime Carbonell and Herb Simon for thoughtful comments on an earlier version of this paper  . 
References\[1\]Aho , A.V . and Ullman , J.D.
The Theory of Parsing , Translation and Compiling.
Prentice-Hall , Englewood Cliffs , N.J ., 1972.
\[2\]AhO , A.V . and Johnson , S.C.
LR parsing.
ComPuting Surveys 6: 2:99-124, 1974.
\[3\] Aho , A . V . , Johnson , S . C . and UIIman , J . D . 
Deterministic parsing of ambiguous grammars.
Comm . ACM 18:8:441-452, 1975.
\[4\] Aho , A.V . and UIIman , J.D.
Principles of Compiler Design.
Addison Wesley , 1977.
\[5\] Oeremer , F . L
Practical Translators for LR(k ) Languages.
PhD thesis , MIT , 1969.
\[6\]DeRemer , F.L.
SimpleLR(k ) grammars.
Comm . ACM 14:7:453-460, 1971.
FIGazdar , G.
Phrase Structure Grammar.
D . Reid , l , 1982, pages 131.186.
\[8\]G = zder , G.
Phrase Structure Grammars and Natural Language.
Proceedings of the Eighth International Joint Conference on Artificial Intelligence v  . 1, August , 1983 . 
\[9\] Inoue , K . and Fujiwara , F,
On LLC(k ) Parsing Method of LR(k ) Grammars.
Journal of Inlormation Processing vol . 6(no . 4):pp . 206-217, 1983 . 
\[10\] Kapisn , R.M.
A general syntactic processor.
Algorithmics Press , New York , 1973, pages 193 . 241 . 
\[1 ~\] Kay , M .
The MIND system.
Algorithmics Press , New York ,  1973 , pages 155-188 . 
\[12\] Shieber , S.M.
Sentence Disambiguation by a ShiR-Reduce Parsing

Proceedings of the Eighth International Joint Conference on Artificial Intelligence v  . 2, August , 1983 . 

