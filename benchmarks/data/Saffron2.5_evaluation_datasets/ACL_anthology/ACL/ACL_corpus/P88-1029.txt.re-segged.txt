Conditional Descriptions in
Functional Unification Grammar
Robert T . Kasper
USC/Information Sciences Institute
4676 Admiralty Way , Suite 1001
Marina del Rey , CA 90292 U.S.A.
Abstract
A grammatical description often applies to a linguistic object only when that object has certain features  . Such conditional descriptions can be indirectly modeled in Kay's Functional Unification Grammar  ( FUG ) using functional descriptions that are embedded within disjunctive alternatives  . An extension to FUG is proposed that allows for a direct representation of conditional descriptions  . This extension has been used to model the input conditions on the systems of systemic grammar  . Conditional descriptions are formally defined in terms of logical implication and negation  . This formal definition enables the use of conditional descriptions as a general notational extension to any of the unification-based gram ? mar representation systems currently used in computational linguistics  . 
1 Introduction
Functional Unification Grammar\[Kay 79\] ( FUG ) and other grammatical formalisms that use feature structures and unification provide a general basis for the declarative r presentation of natural language grammars  . In order to utilize some of the computational tools available with unification grammars  , we have developed a mapping from sVstelnic ? ram -mars\[  Hall76\] into FUG notation . This mapping has been used as the first step in creating a general parsing method for systemic grammars\[  Kas87a  \] . The experience of translating systemic grammars into FUG has shown several ways in which the notational resources of FUG may be improved  . 
In particular , FUG has limited notational resources for expressing conditional information  . In this paper we describe how FUG has been enhanced by the addition of conditional descriptions  , building on research that has already been reported\[  Kas87a  , Kas86 , Kas87b\] . 
Conditional information is stated explicitly in systemic grammars by the input conditions of systems that specify when a system must be used  . Consider , for example , the two systems ( MoodType and Indicatlve'l~ype ) x shown in Figure 1 . 
The input condition for the MoodType system is the feature ITh is example is extracted from Nigel\ [   Mann83\]  , a large systemic grammar of English that has been developed in text generation research at USC/ISI  . 
C/auae , and the input condition for the Indicatlve Type systemls the feature Indicative  . Because the features of a systemic grammar are normally introduced by a unique system  , these input conditions actually express a bidirectional type of logical implication : I  . If a constituent has the feature ( s ) specified by a sys-tem's input condition , then exactly one of the alternatives described by that system must also beyard for the constituent  ;  2 . If a constituent has one of the feature alternatives described by a system  , then it must also have the fea-ture ( s ) specified by that system's input condition . 
Thus the input condition of the Irtd/cative ~ p e system expresses the following implications :  1  . If a clause ha~s the feature Indic , ~ tive , then it must also have exactly one of the alternatives from the  Zndica-tive23  , /pesystem ( either Declarative or Interrogative ) . 
2 . If a clause has one of the feature alternatives described by the  Indicativs~3ype system ( either Declarative or/n-terrooaties )  , then it must also have the feature Indiea-ties . 
While it is theoretically correct or egard the two directions of implication as exact converses of each other  , there is a subtle difference between them . The consequent of the first type of implication is the description of the entire system  , including systemic features and their realizations  .   2 The antecedent of the second type of implication can be safely abbreviated by the systemic features without heir realizations  , because the presence of a systemic feature implies that its realizations also hold  . We will return to this distinction when we provide a formal definition of conditional descriptions in Section  2  . 
For simple input conditions , the first type of implication can be expressed in FUG  , as it was originally formulated by Kay\[Kay 79\] , by embedding the description of one system inside the description of another  . For example , we can capture this implication for the Indicative Type system by embedding it within the description of the Indicative alternative of the  2A realization is a statement of structural properties that are required by a feature  , such as the statement that SUBJECT precedes FINITE for the feature declarative  . 

RANK~-Clause MOODTY PE~Imperative NONFINITIVE !Stem 
LIn INDICATIVE dl cat lve TYPE


UBJECT^FINITE

Figure 1: The MoodType and Indicative Type Systems
Rank = Clause
MoodType=Imperative
NONFI~ITIVE----\[Form=Stem\]J
MoodType--Indicative \]
SUBJECT----"\[Case=Nominative\]LfF Indicatlve Type = Declarative  1 ~ pattern = (  .   .   . SUBJECTFINITE .   .   . ) jJL ~ Indicative Type - - - - - Interrogative \] .   3 IndicatlveType~\[MoodType--Indicative\]" Figure  2: The MoodType and Indlcative Type Systems in FUG Mood Type system  , as shown in Figure 2 . Note that the second type of implication expressed by systemic input conditions has not been expressed by embedding one functional description is idean other  . To express the second type of lm-plicatlon , we have used a different notational device , called a feature xistence condition ; it will be defined in Section 2 . 4 . 
Not all systems have simple input conditions consisting of single features  . Those input conditious which are complex boolea ~ u expressions over features cannot be expressed directly by embedding  . Consider the Benefactive Volces system shown in Figure  3 as an example . Its input condition is the conjunction of two features  , Agentive and Benef active . 
One way to express a system with a complex input condition in FUG is to use a disjunction with two alternatives  , as shown in Figure 4 . The first alternative corresponds to what happens when the Benef+ctive Voice system is entered  ; the second alternative corresponds to what happens when the Benefactlve Voice system is not entered  . The first alternative also includes the features of the input condition  . The second alternative includes the features of the negated input condition  . Notice that the input condition and its negation must both be stated explicltly  , unlike in systemic notation . If the negation of the input condition was not included in the second alternative  , it would be possible to use this alternative 3The Benefactiv c Voice system iJ also extracted from the Nigel grammar\[  Mann83\]  . It describes the active and passive voice options that are possible in clauses that have both an agent and a beneficiary  . The active/passive distinction is not primitive in systemic grammars of English  . Instead , it is decomposed into several cases depending on which participant roles are present in the clause  . In this case the subject of a passive clause may be conflated with either beneficiary or medium  . 
even when the input condition for the system holds  . Thus the description of the system would not always be used when it should be  . Note that this method of encoding system i c input conditions presupposes an adequate treatment of negated features  . " A formal definition of negation will be developed in Section  2  . 3 . 
While it is formally possible to encode complex input con-ditione by disjunction and ne ~ tion  , such encoding IS not altogether satisfactory : It should not be necessary to state the negated input condition explicitly  , since it can always be derived automatically from the unne &-~ ted condition  . It is also rather inefficient to mix the features of the input condition with the other features of the system  . The features of the input condition contain exactly the information that is needed to choose between the two alternatives of the disjunction  ( Le . , to choose whether the system is entered or not ) . It would be more efficient and less verbose to have a notation in which the features of the input condition are distlnguished from the other features of the system  , and in which the negation of the input condition does not need to be stated explicitly  . 
Therefore , we have developed an extension to FUG that uses a conditional operator  ( -~ )  , as illustrated by the encoding of the Benefactive Voice system shown in Figure  5  . A description corresponding to the input condition appears to the left of the --~ symbol  , and the description to be included when the input condition is satisfied appears to its right  . A formal definition of what it means for a description to be satisfied will be given in Section  2  . 1 . 
4Some negations ofatomic features can be replaced by a finite disjunction ofother pouible values for that feature  , but this technique only works effectively when the set of possible values is small and can be enumerated  . 

Agentive-
Benef active -

VOICE f ' Benefact\]ve Active
AGENT/SUBJECT lv\[EDIUM/DIRECTCOMP

MEDIUM/SUBJECT-Bene Psssive
BENEFICIARY/SUBJECT
MEDIUM/DIRECTCOMP
Figure ' 3: The Benefactive Voice System.
Rank = Clause
Agentivity = Agentive
Benefaction = Benefa citve ' Benefactive Voice = Benefactive Active \] 
AGENT=<SUBJECT >
MEDIUM = < DIRECTCOIqP >\]
Benefactlve Voice = Medio Passive \] , MEDIUM=<SUBJECT >
Benefactlve Volce = Bene Passive
BENEFICIARY=<SUBJECT > , MEDIUM = < DIRECTCOMP > J ' Agentivity=NOT AEentive \] ~\]' 
Benefaction = NOT Benefactive \] S/
Benefactlve Volce = NONEJ
Figure 4: Benefactive Voice system in FUG , using disjunction and negation . 
Rank = Clause
Agentivity=Agent lve\]BenefactiveVoice = lvfedio Passlve - - - k Benefaction = Benefactive MEDIUM=<SUBJECT > 
Benefactlve Voice = Bene Pessive
BENEFICIARY=<SUBJECT >
MEDIUM=<DIRECTCOIVIP > 3 Benefactive Volce-- , \ [ Agentivity=Agent lve\]
Benefaction = Bene fact lve
Benefactive Volce = Benefactive Active \]\] AGENT = < SUBJECT > MEDIUM = < DIRECTCOMP > Figure  5: Benefactive Voice system in extended FUG , using two conditional descriptions . 
Note : In systemic notation curly braces represent conjunction and square braces represent disjunction  , while in FUG curly braces represent disjunction and square braces represent conjunction  . 

Note : A and L are
NILl : ~~ < p ~ > . . . . . < p . >\] ~^ ~ or\[~ .   .   .  ~ . \] ~ bzV ~ b ~ or ~ bz . . . ~ b . denoting no information ; where a EA , to describe atomic values ; where lEL and ~ bEFDL , to describe structures in which the feature labeled by I has a value described by ~  ; where each p ; EL ' , to describe an equivalence lass of paths sharing a common value in a feature structure  ; where ~ iEFDL , denoting conjunction ; where ~; EFDL , denoting disjunction . 
sets of symbols which are used to denote atomic values and feature labels  , respectively . 
Figure 6: Syntax of FDL Formulas.
2 Definitions
The feature description logic ( FDL ) of Kasper and Rounds\[ Kas86\] provides a coherent framework to give a precise interpretation for conditional descriptions  . As in previous work , we carefully observe the distinction between feature structures and their descriptions  . Feature structures are represented by directed graphs  ( DGs )  , and descriptions of feature structures are represented by logical formulas  . The syntax for formulas of FDL is given in Figure  6  . We define several new types of formulas for conditional descriptions and negations  , but the domain of feature structures remains DGs , as before . 
2 . 1 Sat i s fac t ion and Compat ib i l i ty In order to understand how conditional descriptions are used  , it is important to recognize two relations that may hold between a particular feature structure and a description : satisfaction and compatibility  . Satisfaction implies compatibility , so there are three possible states that a particular structure may have with respect o a description : the structure may fully  8ati~/X/the description , the structure may be i . eompat . 
is le with the description , or the structure may be ? ompatiMe with ( but not satisfy ) the description . To define these terms more precisely , consider the state of an arbitra ~7 structure ,  /~ , with respect o an atomic feature description , f : e : satisfies f : eiff occurs in A with value e  ; is incompatible with f:eifj ' occursing with value z  , for some z ~ ~ ; /~ is ( merely ) compatible with f:eiff does not occur in A . 
Because feature structures are used to represent partial information  , it is possible for a structure that is merely compatible wlth a description to be extended  ( i . e . , by adding a value for some previously nonexistent feature  ) so that it either satisfies or becomes incompatible with the description  . 
Consider , for example , the structure (~ z ) shown in Figure 7 , and the three descriptions : aubj : ( perao . : 3A . umber : ai . g ) ( I ) subj : ( perao . : 1A . umber : . i . g ) (2) 8= by : ( case: . ore ^ . t , , n be . : si . g )   ( 3 ) subj ~ nders tagneut Figure 7: Example feature structure ( AZ ) -Description ( I ) is satisfied by Az , because  z is fully iustan-tiated with all the required feature values  . Description (2) is i , e ompatible with A z , because Az has a different value for the feature aubj : person  . Description ( 3 ) is merely compatible with Az ( but not satisfied by Az )  , because Az has no value for the feature aubj : e ~se  . 
In the following definitions , the notation A ~ ~5 means that the structure A satisfies the description ~  , and the notation A ~ ~ means that the structure A is compatible to it h the description ~  . 
Logical combinations of feature descriptions are evaluated with their usual semantics to determine whether they are satisfied by a structure  . Thus , a conjunction is satisfied only when every conjunct is satisfied  , and a disjunction is satls-fied if any disjunct is satisfied  . The formal semantics of the satisfaction relation has been specified in our previous work describing FDL\[  Kas86\]  . The semantics of the compatibility relation is given by the following conditions : 
I . ~ -- NIL always ; 2 . A . ~ ? ?=? . / ~ is the atomic structure ~; 3 . A ~\[ < Pz >,- . -, < P . >\]~= ~ all DGs in the set ~ q/<Pz > . . . . . 4/< p . > can be unified ( any member of this set may be undefined ; such members are equivalent to null DGs ) ;  4 . /~~ I : ~?=~/~/ ! is undefined or ~/1~~; 5 . A ~ ~ V ~ ?= ~ ~ ~ ~ ~ ~ ~ 0; 6 . ~ N~bA ~, ? ffiffi ~ . ~, canonical form of ~ bA ~ . 
Unlike satisfaction , the semantics of compatibility cannot be defined by simple induction over conjunctive formulas  , because of a subtle interaction between path equivalences and shown LU Figure  7  , is compatible with the description : nurnber : pl A < ~* ~ mber >  , < aubj number >\] . 
A , is compatible with r~urn ber:pl , and d , k also compatible with ~< nurnber > , < subjn~mber > l , but #~ , is not compatible with the conjunction of these two descriptions  , because it requires aub \]: r~mber:pl and , ~ , hassi ~ , g as the value of that feature . 
Thus , in order to determine whether a structure is compat -ible wlth a conjunctive description  , it is generally necessary to unify all conjuncts , putting the description i to the canonical form described in \[  Kas87c  \] . This canonical form ( i . e . the feature . description data structure ) contains definite and indefinite components . The definite component contains no disjunction , and is represented by a DG structure that satisfies all non-disjunctive parts of a description  . The indefinite component is a list of disjunctions  . A structure is compatible with a description i canonical form if and only if it is unifiable with the definite component and it is compa !  ; ible wlth each disjunction of the indefinite component  . 
2.2 Conditional Description
We augment FDL with a new type of formula to represent conditional descriptions  , using the notation , n - .  ~ , and the standard interpretation given for material implication : 
AI=~-~p ~ AI=~av #. C4)
This Luterpret at lonf conditionals presupposes an interpretation of negation over feature descriptions  , which is given below . To simpLify the interpretation f negations , we exclude formulas contaiuing path equivalences and path values from the antecedents of conditlonak  . 
2.3 Negation
We use the classical interpretation of negation , where / ~ ~- ~ b ? = ~/ ~ ~ ~ : # . Negated descriptions are defined for the following types of formulas :  1  . A ~-~? = ~ A is not the atom ~; 2 . A~-~(l : ~) ~ Jl ~= l : "- ~ or . ~/ ! is not defined ; 3 . , ~~-~(~ v ,/,)~: ~ A ~-, ~^-,, p ; 4 . , ~ M - ,( ~^, p ) ~, ~ M - , ~ v - , , p . 
Note that we have not defined negation for formulas containing path equivalences or path values  . Thls restriction makes it possible to reduce all occurrences of negation to a boolean combLuatlon of a fiuite number of negative constraints on atomic values  . While the classical interpretation f negation is not strictly monotonic with respecto the normal sub-sumptlon ordering on feature structures  , the restricted type of negation proposed here does not suffer from the inefficiencies and order -dependent uuificatic n properties of general negation or intuitic nistic negation \[  Mosh87  , Per87\] . The reason for this is that we have restricted negation so that all negative information can be specified as local constra Luts on single atomic feature values  . Thus , these constraints only come into play when specific atomic values are proposed for a feature  , and they can be checked as efficiently as positive atomic value constraints  . 
2.4 Feature Existence Conditions
A special type of conditional description kneeded when the antecedent of a conditional is an existence predicate for a particular feature  , and not a regular feature description . We call this type of conditional \ [ eature zistence condition  , and use the notation : B/-+~ , where A~3\[4 == ~ A/\[ is defined . 
Thk use of B/is essentially equivalent to the use off = ANY in Kay's FUG  , where ANYlsa placeholder for any substantive ( i . e . , non-NIL ) value . 
The primary effect of a feature xistence condition  , such as 3 f -- ,  ~ , is that the consequent is asserted whenever a substantive value is introduced for a feature labeled by f  . The treatment of feature xistence conditions differs slightly from other conditional descriptions in the way that an uusatisfiable consequent is handled  . In order to negate the antecedent of 3f--~# , we need to state that f may never have any substantive value  . This is accomplished by unifying a special atomic value  , such as NONE , with the value of f . This special atomic value is incompatible with any other real value that might be proposed as a value for f  . 
Feature xistence conditions are needed to model the second type of implication expressed by systemic input conditions-namely  , when a constituent has one of the feature alternatives described by a system  , it must also have the fea-ture ( s ) specified by that system's input condition . Generally , a system named f with input condition a and alternatives described by / ~  , can be represented by two conditional de -scriptlons :  1  . a . -- . p ; 2 . Bf -* a . 
For example , recall the Benfactive Voice system , which is represented by the two conditionals shown in Figure  5  . 
It is important to note that feature existence conditions are used for systems with simple input conditions as well as for those with complex input conditions  . The use of feature existence conditions i essential in both cases to encode the bidirectional dependency between systems that is implicit in a systemic network  . 
3 Unification with Conditional
Descriptions
The unification operation , which is commonly used to corn-blue feature structures  ( i . e . , non-disjunctive , non-conditional DGs ) , can be generalised to define an operation for combLu Lug the information of two feature descriptions  ( i . e . , formulas of FDL ) . In FDL , the unification of two descriptions i equivalent to their logical conjunction  , as discussed in \[ Kas87b\] . We accomplished for disjunctive descriptions without expanding to disjunctive normal form  . 
This unification method factors descriptions into a canonical form conslstlng of definite and indefinite components  . 
The definite component contains nodls junctlon , and is represented by a DG structure that satisfies all non-disjunctive parts of a description  . The indefinite component of a description ka list of disjunctions  . When two descriptions are unified , the first step is to unlfy their definite components  . Then the indefinite components of each description are checked for compatl bility with the resulting definite component  . Dlsjuncts are eliminated from the description when they are inconsistent with deflnlte information  . When only one alternative of a disjunction remains  , it is unified with the definite component of the description  . 
This section details howthls unification method can be extended to handle conditional descriptions  . Conditionals may be regarded as another type of indefinite information i the description of a feature structure  . They are indefinite \] n the sense that they impose constraints hat can be satisfied by several alternatives  , depending on the values of features already present in a structure  . 
3.1 How to Satisfya Conditional

The constraints imposed on a feature structure by a conditional description can usually be determined most emclently by first examining the antecedent of the conditional  , because it generally cont ~ nla smaller amount of information than the consequent  . F , xamining the antecedent k often sufficient to determine whether the consequent is to be included or discarded  . 
Given a conditional description , C - - - ~ - + ~ , we can define the coustralnts that it imposes on a feature structure  ( A ) as follows . When : ~ ct , then A ~ ~ ; 6 ~ or , then ? imposes no further constraint on A , and can therefore beelhn Jnated ; A ~ , c  ~ , then check whether ~ ls compatible wlthA . 
If compatible , then C must be retained in the description of ~ . 
If incompatible , then ~~- ~ a ( and ? can be elimionated ) . 
These constraints follow directly from the interpretation  ( 4 ) that we have given for conditional descriptions . These con-straiuts are logically equivalent to those that would be imposed on A by the disjunction - ~ V ~  , as required . However , the constraints of the conditional can often be imposed more ef ~ ciently than those of the equivalent dJs junctlon  , because examlnlng the antecedent of the conditional carries the same cost as examining only one of the dk juncts  . When the constraints of a disjunction are imposed  , both of the disjuncts must be examined in all cases  . 
6 Read this constraint as : U make sure that . 4 satisfies ~ . t3 . 2 Extending the Unification

The unification algorithm for d lsjunctlve feature descriptions\[  Kas87c \] can be extended to handle conditionals by recognizing two types of indefinite ~ u formatlon i a description : disjunctions and conditionals  . The extended feature-descriptlon data structure has the components : definite : a DG structure  ; disjunctions : all stof disjunctions ; conditionals , a list of conditional descriptions . 
The part of the unification algorithm that checks the compatibility of indefinite components of a description with its definite component is defined by the function CHECK-INDEF  , shown in Figure 8 . Thk algorithm checks the disjunctions of a description before conditionals  , but an equally correct version of thk algorithm ight check conditionals before disjunctions  . In our application of parsing with a systemic grammar it is generally more et ~ cient to check disjunctions first  , but ? other applications might be made more efB clent by vary lng this order  . 
4 Potential Refinements
Several topics merit further investlg at lon regarding conditional descrlptions  . The implementation we describe has the constraints of conditionals and dkjunctions imposed in an arbitrary order  . Changng the order has no effect on the final result  , but it is likely that the el ~ clency of unification could be improved by ordering the conditionals of a grammar in a deliberate way  . Another way to improve the efficiency of unification with condltion a ~ would involve indexing them by the features that they contain  . Then a conditional would not need to be checked against a structure until some feature value of the structure might determine the manner in which it keats f led  . The amount of efficiency gained by such techniques clearly depends largely on the nature of the particular grammar being used in an appll catlon  . 
A slightly differentype of conditional might be used as a way to speed up unification with binary disjunctive descriptions  . If it k known that the values of a relatively small number of features can be used to discrimlnate between two alternative descriptions  , then those features can be factored into a separate condition in a description such as 
IF cor , ditio a THENalt ~ ELSE air 2.
When the condition is satisfied by a structure , then alt l is selected . When the condition is incompatible with a structure  , then air2 is selected . Otherwise both alternatives must remain under consideration  . As it often requires a considerable amount of time to check which alternatives of adkjunc-tion are applicable  , this technlque might offer a significant improvement in an application where large dlsjunctlve descriptions are used  . 
Remember that we have restricted conditionals by requiring that their antecedents do not contain path equivalences  . 

Function CHECK-INDEF ( desc ) Returns feature-description : where desc is a featur ~ description  . 
Let P = desc . deflnite(aDG).
Let disjunctions = desc.disjunctions.
Let conditionals = desc.conditionals.
Let unchecked-parts----true.
While unchecked-parts , do : unchecked-parts := false . 
Cheekeomp~h'~/tyoj'd/~nct/onm ~ P(omited , see\[Kas87c\]) . 
O ~ e keomp ~' t ~ U of ? o ~ o ~ b ~ P :
Let new-conditionals ----~.
For each ~, -- . / 9 in conditionals : test whether D satisfies or is compatible with  , -: SATISFIES : 9:= UNIFY-DGS (9 ,  ~ . deflnite ), disjunctions := disjunctionsU ~ . dlsjunctions , unchecked-parts := true ; COMPATIBLE : If ~) is compatible with ~ , then new-conditionals := new-conditionals Ua-- ,  ~ , else let neg-ant e = -~ e . 
D := UNIFY-DGS(P , neg-ante . deflnite ) , disjunctions : ---- disjunctions uneg-ante . disjunctions , unchecked-parts := true ; INCOMPATIBLE : t~eoad~/on , dimposem no \] ur O ~ ee co aa ~ v ~/ nt . 
end ( for loop).
conditionals : ---- new-conditionals.
end ( while loop).
Let nd----make feature-description with : nd . deflnite-~P , nd . disjunctions = disjunctions , nd . conditional s---- conditionals . 
Return ( nd).
Figure 8: CHECK-INDEF : Algorithm for checking compat ibility of indefinite parts of a feature -description with its definite component  . 
This restriction has been acceptable in our use of conditional descriptions to model systemic grammars  . It kunclear whether a treatment of conditional descriptions without thls restriction will be needed in other applications  . If this restriction is lifted , then further work will be necessary to define the behavior of negation over path equivalences  , and to handle such negations in a reasonably e ~cient manner  . 
5 Summary
We have shown how the notational resources of FUG can be extended to include descriptions of conditional information about feature structures  . Conditional descriptions have been given a precise logical definition in terms of the feature description logic of Kasper and Rounds  , and we have shown how a unification method for feature descriptions can be extended to use conditional descriptions  . We have implemented this unification method and tested it in a parser for systemic grammars  , using several hundred conditional descriptions . 
The definition of conditional descriptions and the unification method should be generaily applicable as an extension to other unificatlon-based grammar frameworks  , as well as to FUG and the modeling of systemic grammars  . In fact , the implementation described has been carried out by extending PATI~II\[  Shie84\]  , a general representational framework for unificatlon-based grammars  . 
While it is theoretically possible to represent the information of conditional descriptions indirectly using notational devices already present in Kay's FUG  , there are practical advantages to representing conditional descriptions directly  . 
The indirect encoding of conditional descriptions by dlsjunc-tions and negations entails approximately doubling the size of a description  , adding many explicit nonexistence constraints on features  ( NONE values )  , and slowing the unification process . In our experiments , unification wlth conditional descriptions requires approximately  50~ of the time required by unification with an indirect encoding of the same descriptions  . By adding conditional descriptions as a notational resource to FUG  , we have not changed the theoretical limits of what FUG can do  , but we have developed a representation that is more per spicuous  , less verbose , and computationaily more e/~clent . 

I would like to thank Bill Rounds for suggesting that it might be worthwhile to clarify ideas about conditional descriptions University of Michigan  . Helpful comments on earlier versions of this paper were provided by Bill Mann  , Ed Hovy and John

This research was sponsored by the United States Air\[  Shie84\] Force Office of Scientific Research under contract  F49620-87-C-0005  ; the opinions expressed here are solely those of the author  . 
References/Hall 76\] Gunther R . Kress , editor . II allidap : System and Function in Language . Oxford University Press,
London , England , 1976.
\[Kas87 aI Robert T . Kasper . Systemic Grammar and Functional Unification Grammar  . In J . Benson and W . 
Greaves , editors , SV stemic Functional Approaches to Discourse , Norwood , New Jersey : Ablex ( in press ) . Also available as USC/information Sciences Institute  , Technical Report RS-87-179 , May 1987 . 
\[Kas86\]Robert . T . Kasper and William C . Rounds . A Logical Semantics for Feature Structures . In Proceedings of the 24 ta Annual Meeting of the Association for Computational Linguistics  , Columbia Unlver-slty , New York ,  1~/' , June 1013 ,  1986 . 
\[Kas87b\]RobertT . Kasper . Feature Structures : ALo~cal 7'heorv ~ dth Application to Language An alpds . Phi ) dlssertation , University of Mlchlgan ,  1987 . 
\[Kas87c\]RobertT . Kasper . A Unification Method for DIS-junctive Feature Descriptions  . In Proceed/ng8 o / the 25 ta Annual Meeting of the Association for Computational Linguistica  , Stanford University , Stanford , 
CA , July 69, 1987.
/Kay 79\] Martin Kay . Functional Grammar . In Proceeding8 o/the Fifth Annual Meeting of the Bsrkcl spLingui ~- ticaSociet p  , Berkeley Linguistics Society , Berkeley , 
Ca2ifornia , February 1719, 1979.
\[ Mmm83\]Wi\]fiamC . Mann and Christian Matthiemen . 
Nigel : A Systemic Grammar for Text Generation.
USC/Information Sciences Institute , RR-83-105.
Also appears in R . Benson and J . Greaves , editors , Spatemie Perapectivs ~ on Diacourss : Selected Paper  ,   Paper8 from the Ninth International Spstsmics Work Jhop , Ablex , London , England ,  1985 . 
\[ Mosh87\] ~ Drew Moshier and William C . Rounds . A Logic for Partially Specified Data Structures . In Proceed-ing8 of the ACM Spmposium on Principl cJ of Pro -graraming Languages  ,  1987 . 
Fernando C . N . Perelra . Grammars and Logics of Partial Information . In Proceedings of the International Conference on Logic Programming  , Melbourne , Austra Lia , May 1987 . 
Stuart M . Shieber . The design of a computer language for lingu\]stic information  . In Proceedings of the Tenth International Conference on Computational Linguistics : COLING  84  , Stanford Unlver-sity , Stanford , California , July 27 ,  1984 . 

