TAL Recognition in O(M(n2)) Time
Sanguthevar Rajasekaran
Dept . of CISE , Univ . of Florida

Shibu Yooseph
Dept . of CIS , Univ . of Pennsylvania
yooseph@gradient.cis.upenn.edu

We propose an O ( M ( n2 ) ) time algorithm for the recognition of Tree Adjoining Languages  ( TALs )  , where n is the size of the input string and M ( k ) is the time needed to multiply two kxk boolean matrices  . 
Tree Adjoining Grammars ( TAGs ) are formalism suitable for natural language processing and have received enormous attention in the past among not only natural language processing researchers but also algorithms designers  . The first polynomial time algorithm for TAL parsing was proposed in  1986 and had a runtime of O ( n6 )  . 
Quite recently , an O(n3M(n )) algorithm has been proposed . The algorithm presented in this paper improves the runtime of the recent result using an entirely different approach  . 
1 Introduction
The Tree Adjoining Grammar ( TAG ) formalism was introduced by : loshi , Levy and Takahashi (1975) . 
TAGs are tree generating systems , and are strictly more powerful than contextfree grammars  . They belong to the class of mildly context sensitive grammars  ( : loshi , et al ,  1991) . They have been found to be good grammatical systems for natural languages  ( Kroch , Joshi ,  1985) . The first polynomial time parsing algorithm for TALs was given by Vi-jayas hanker and : loshi  ( 1986 )  , which had a runtime of O(n6) , for an input of size n . Their algorithm had a flavor similar to the Cocke -Younger-Kasami  ( CYK ) algorithm for contextfree grammars . An Earley-type parsing algorithm has been given by Schabes and Joshi  ( 1988 )  . An optimal inear time parallel parsing algorithm for TALs was given by Palls  , Shende and Wei (1990) . In a recent paper , Rajasekaran ( 1995 ) shows how TALs can be parsed in time O ( n3M ( n ) ) . 
In this paper , we propose an O ( M ( n2 ) ) time recognition algorithm for TALs , where M ( k ) is the time needed to multiply two kxk boolean matrices  . The best known value for M ( k ) is O ( n2"3 vs )   ( Coppersmith , Winograd ,  1990) . Though our algorithm is similar in flavor to those of Graham  , Harrison , & Ruzzo (1976) , and Valiant ( 1975 )   ( which were Mgorithms proposed for recognition of Context Pree Languages  ( CFLs ) ) , there are crucial differences . As such , the techniques of ( Graham , et al , 1976) and ( Valiant , 1975) do not seem to extend to
TALs ( Satta , 1993).
2 Tree Adjoining Grammars
A Tree Adjoining Grammar ( TAG ) consists of a quintuple ( N , ~ U ~ , I , A , S ) , where N is a finite set of nonterminal symbols , is a finite set of terminal symbols disjoint from
N , is the empty terminal string not in ~ , I is a finite set of labelled initial trees , 
A is a finite set of auxiliary trees,
SEN is the distinguished start symbol
The trees in IUA are called elementary trees . All internal nodes of elementary trees are labelled with nonterminal symbols  . Also , every initial tree is labelled at the root by the start symbol S and has leaf nodes labelled with symbols from  ~3 UE . An auxiliary tree has both its root and exactly one leaf  ( called the foot node ) labelled with the same nonterminal symbol . All other leaf nodes are labelled with symbols in EU  ~  , at least one of which has a label strictly in E . An example of a TAG is given in figure 1 . 
A tree built from an operation involving two other trees is called a derived tree  . The operation involved is called adjunction . Formally , adjunction is an operation which builds a new tree  7  , from an auxiliary treefland another tree ~ ( a is any tree-initial , auxiliary or derived ) . Let c ~ contain an internal node m labelled X and let fl be the auxiliary tree with root node also labelled X  . The resulting tree 7 , obtained by adjoining flontoc ~ at node mis built as follows  ( figure 2 ) :




G = S , a , b , c , e , or , ~, S

SbS *
Figure 1: Example of a TAG
Auxiliary tree 1 . The subtree of a rooted at m , call itt , is excised , leaving a copy of m behind . 
2 . The auxiliary treeflis attached at the copy of m and its root node is identifed with the copy of m  . 
3 . The subtreet is attached to the foot node of fl and the root node of t  ( i . e . m ) is identified with the foot node offt . 
This definition can be extended to include adjunction constraints at nodes in a tree  . The constraints include Selective , Null and Obligatory adjunction constraints . The algorithm we present here can he modified to include constraints  . 
For our purpose , we will assume that every internal node in an elementary tree has exactly  2 children . 
Each node in a tree is represented by a tuple < tree  , node index , label > . ( For brevity , we will refer to a node with a single variable m where ever there is no confusion  ) A good introduction to TAGs can be found in ( Partee , et al ,  1990) . 
3 Context Free recognition in
O(M(n )) Time
The CFG G = ( N , ~, P , A1), where
N is a set of N on terminals A1, A2, . ., Ak , is a finite set of terminals,
P is a finite set of productions,
A 1 is the start symbol is assumed to be in the Chomsky Normal Form  . 
Valiant ( 1975 ) shows how the recognition problem can be reduced to the problem of finding Transitive Closure and how Transitive Closure can be reduced to Matrix Multiplication  . 
Given an input string a za2 . . . . an E ~* , the recursive algorithm makes use of an ( n + l ) ?  ( n + l ) upper triangular matrix b defined by hi , i+1 = AkI(Ak--*a , ) EP , bi , j = ? , for ji + 1 and proceeds to find the transitive closure b + of this matrix  . ( If b + is the transitive closure , then AkEb .  + . ?: ~ Ak-~ai . . . . aj1) $ , JInstead of finding the transitive closure by the customary method based on recursively splitting into disjoint parts  , a more complex procedure based on ' splitting with overlaps ' is used  . The extra cost involved in such a strategy can be made almost negligible  . The algorithm is based on the following lemma Lemma : Let b be an n xn upper triangular matrix  , and suppose that for any r > n/e , the transitive closure of the partitions\[1<i , j < r \] and\[n-r<i , j < n \] are known . Then the closure of b can be computed by I . performing a single matrix multiplication , and 2 . finding the closure of a 2 ( n-r )  ? 2 ( n-r ) upper triangular matrix of which the closure of the  partitions\[1 < i , j < n-r\] and\[n-r<i , j < 2(n-r )\] are known . 
Proof : See ( Valiant , 1975) for details
The idea behind ( Valiant ,  1975 ) is based on visualizing AkEb+j as spanning a tree rooted at the node Ak with l ~ aves aithrough aj  -1 and internal nodes as nonterminals generated from Ak according to the productions in P  . Having done this , the following observation is made : Given an input string al  .   .   . a , and 2 distinct symbol positions , i and j , and a nonterminal Ak such that AkEb + . , where i '< i , j '> j , then 3 a non-
IP3 terminal Ak , which is a descendent of Ak in the b + . where tree rooted at Ak , such that Ak , Eid'i " < i , j "> j and Ak , has two children Ak ~ and Ak2 such that Ak ~ Eb + , and Ak2Eb + .   . with i < s < j . 
A k , can be thought of as a minimal node in this sense . (The descendent relation is both reflexive and transitive  ) Thus , given a string al .   .   . a , of length n , ( sayr = 2/3) , the following steps are done :
Figure 2: Adjunction Operation k t1 . Find the closure of the first 2/3, i . e . all nodes spanning trees which are within the first  2/3   . 
2 . Find the closure of the last 2/3, i . e . all nodes spanning trees which are within the last  2/3  . 
3 . Doacomposition operation ( i . e . matrix multiplication ) on the nodes got as a result of Step 1 with nodes got as a result of Step 2  . 
4 . Reduce problem size to a z . . . an/zal+2n/3 . . . an and find closure of this input . 
The point to note is that in step 3 , we can get rid of the mid 1/3 and focus on the remaining problem size . 
This approach does not work for TALs because of the presence of the adjunction operation  . 
Firstly , the data structure used , i . e . the 2-dimensional matrix with the given representation , is not sufficient as adjunction does not operate on contiguou strings  . Suppose a node in a tree dominates a frontier which has the substring aiaj to the left of the foot node and akat to the right of the foot node  . These substrings need not be a contiguous part of the input  ; in fact , when this tree is used for adjunction then a string is inserted between these two suh strings  . Thus in order to represent a node , we need to use a matrix of higher dimension , namely dimension 4 , to characterize the substring that appears to the left of the foot node and the substring that appears to the right of the foot node  . 
Secondly , the observation we made about an entry Eb+is no longer quite true because of the presence of adjunction  . 
Thirdly , the technique of getting rid of the mid 1/3 and focusing on the reduced problem size alone , does not work as shown in figure 3: Suppose 3' is a derived tree in which 3 a node r nonwhich adjunction was done by an auxiliary treeft  . Even if we are able to identify the derived tree 71 rooted at m , we have to first identify fl before we can check for adjunction  , fl need not be realised as a result of the composition operation involving the nodes from the first and last  2/3's   , ( sayr = 2/3) . 
Thus , if we discard the mid1/3 , we will not be able to infer that the adjunction had indeed taken place at node m  . 
4 Notations
Before we introduce the algorithm , we state the notations that will be used . 
We will be making use of a 4-dimensional matrix A of size ( n + 1 ) x ( n + 1 ) x ( n + 1 ) x ( n + 1 )  , where n is the size of the input string . 
( Vijayashanker , Joshi , 1986) Given a TAGG and an input string a za2 . .an , n > 1 , the entries in A will be nodes of the trees of G . We say , that a node m (=<0 , node index , label >) EA(i , j , k , l ) iffm is a node in a derived tree 7 and the subtree of 7 rooted at m has a yield given by either ai+l . . . ajXak+l . . . al(where X is the foot node of r/ , j < k ) or ai + l . . . . az ( when j = k) . 
If a node mEA(i , j , k , l , we will refer to masspanning a tree ( i , j , k , l) . 
When we refer to a nodem being realised as a result of composition of two nodes ml and rnP  , we mean that 3 an elementary tree in which m is the parent of ml and  m2  . 
A Grown Auxiliary Tree is defined to be either a tree resulting from an adjunction involving two auxiliary trees or a tree resulting from an adjunction involving an auxiliary tree and a grown auxiliary tree  . 
Given a node m spanning a tree ( i , j , k , l ) , we define the last operation to create this tree as follows : if the tree  ( i , j , k , l ) was created in a series of operations , which also involved an adjunction by an auxiliary tree  ( or a grown auxiliary tree )   ( i , Jl , k z , l ) onto the node m , then we say that the last operation to create this tree is an adjunction operation  ; else the last operation to create the tree ( i , j , k , l ) is a composition . 
The concept of last operation is useful in modelling the steps required  , in a bottom-up fashion , to create / ,  '3 '
Derived tree a tree.
5 Algorithm
Given that the set of initial and auxiliary trees can have leaf nodes labelled with e  , we do some preprocessing on the TAGG to obtain an Association List  ( ASSOCLIST ) for each node . ASSOCLIST(m ) , where m is a node , will be useful in obtaining chains of nodes in elementary trees which have children labelled ~  . 
Initialize ASSOCLIST(m ) = ? , Vm , and then call procedure MAKELIST on each elementary tree  , in a topdown fashion starting with the root node . 
Procedure MAKELIST(m)
Begin 1 . If m is a leaf then quit 2 . If m has children ml and me both yielding the empty string at their frontiers  ( i . e . m spans a subtree yielding e ) then
ASSOCLIST(ml ) = ASSOC
LIST ( m ) um)
ASSOCLIST(m2) = ASSOC
LIST ( m)U(m3 . If m has children m1 and me , with only me yielding the empty string at its frontier  , then
ASSOCLIST(ml ) = ASSOC
LIST ( m ) um)

We initially fill A(i , i + l , i + l , i + l ) with all nodes from Smt , Vml , where S , ~1 = mlOAS-SOCLIST(ml) , ml being a node with the same label as the input hi+l  , for 0 < i < n1 . We also fill A(i , i , j , j ) , i < j , with nodes from S , ~2 , Vm2 , where S in 2=me ) tJASSOCLIST(me ) , me being a foot node . All entries A(i , i , i , i ) , 0 < i < n , are filled with nodes from Sraa , Vm3 , where S , n3 = m3UAS-
SOCLIST ( mS ), m3 having label ?.
Following is the main procedure , Compute Nodes , which takes as input a sequencer lr2 . . . . . rp of symbol positions ( not necessarily contiguous )  . The procedure outputs all nodes spanning trees ( i , j , k , O , with i , 1 Erl , r2 . . . . . ~' ip and j , kErl , rIJrZ, . .  . , rp . 
The procedure is initially called with the sequence  012  . .n corresponding to the input string aa . . . . . an . 
The matrix A is updated with every call to this procedure and it is updated with the nodes just realised and also with the nodes in the ASSOC LISTs of the nodes just realised  . 
Procedure Compute Nodes ( rlr 2.... rp)
Begin 1 . If p = 2, then a . Compose all nodes EA(rl , j , k , re ) with all nodes EA ( re , re , re , re ) , r t < j < k < r e . 
Update A .
b . Compose all nodes EA(rl , rl , rl , rx ) with all nodes EA(rt , j , k , r2) , r t < j < k < r e . 
Update A .
e . Check for adjunctions involving nodes realised from steps a and b  . Update A . 
d . Return 2. ComputeNodes(rlr2.....rep/a).
3. Compute Nodes ( rl+p/z . . . . . rp).
4 . a . Compose nodes realised from step 2 with nodes realised from step 3  . 
b . Update A .
5 . a . Check for all possible adjunctions involving the nodes realised as a result of step  4  . 
b . Update A .
6 . Compute Nodes ( rlre . . . rp/arl+2p/a . . . rp ) Steps la , lb and 4a can be carried out in the following manner : Consider the composition of node ml with node me  . For step 4a , there are two cases to take care of . 
Case 1
If nodeml in a derived tree is the ancestor of the foot node  , and no deme is its right sibling , such that ml 6A(i , j , k , l ) and m2EA(l , r , r , s ) , then their parent , say node m should belong to A(i , j , k , s ) . 
This composition of ml with me can be reduced to a boolean matrix multiplication i the following way  :   ( We use a technique similar to the one used in ( Ra-jasekaran , 1995)) Construct wo boolean matrices B1 , of size (( n4-1)2p/3) ?( p/3) and Be , of size ( p/3) x(p/3) . 
Bl(ijk , l ) = 1 iff mlEA(i , j , k , I ) and iErl ,   . ., rv/3 and 1 E  rl+p/3, . . r2p/3 = 0 otherwise
Note that in B10 < j < k < n.
BeEs ) = 1 iff meeA(I , r , r , s ) and 1 Er1 + ;13 ,   . . rep/3 and s E  r l+ep/3 , . . , rp-- 0 otherwise Clearly the dot product of the ijkth row of  B1 with the sth column of Be is a 1 iff mEA ( i , j , k , s ) . 
Thus , update A(i , j , k , s ) with mUASSOCLIST(m ) . 
Case 2
If no deme in a derived tree is the ancestor of the foot node  , and nodem l is its left sibling , such that mlEA(i , j , j , l ) and m2EA(l , p , q , r ) , then their parent , say node m should belong to A(i , p , q , s ) . 
This can also be handled similar to the manner described for case  1  . Update A(i , p , s ) with mU
ASSOCLIST(m).
Notice that Case 1 also covers step la and Case 2 also covers step lb . 
Step 5a and Step lc can be carried out in the following manner : We know that if a node mEA  ( i , j , k , i ) , and the rootml of an auxiliary tree EA(r , i , i , s ) , then adjoining the tree 7/ , rooted at ml , onto the node m , results in the nodem spanning a tree ( rj , k , s ) , i . e . m
EA(r , j , k , s).
We can essentially use the previous technique of reducing to boolean matrix multiplication  . Construct two matrices C1 and Ce of sizes ( p2/9 ) x ( n + 1 ) 2 and ( n + 1 ) 2x ( n + 1 )  2 , respectively , as follows : Cl(ii , jk ) = 1 iff3ml , root of an auxiliary tree EA(i , j , k , l ) , with same label as m and
Cl(il , jk ) = 0 otherwise
Note that in CI i Erl, .   . , rpls , iErl+2p/3, . ., rp , and 0 _< j < k < n . 
Ce(qt , rs ) = 1 if fmEA(q , r , s , t)--0 otherwise
Note that in C20 < q < r < s < n.
Clearly the dot product of the iith row of C1 with the rsth column of Ce is a 1 iff mEA ( i , r , s , l ) . 
Thus , update A(i , r , s , l ) with mUASSOCLIST(m ) . 
The input string ala2 . . . an is in the language generated by the TAGG iff 3 a node labelled S in some
A(O , j , j , n ), 0 <_j < n.
6 Complexity
Steps la , lb and 4 a can be computed in

Steps 5 a and le can be computed in

If T ( p ) is the time taken by the procedure Compute
Nodes , for an input of size p , then
T ( p ) = 3T (2p/3) 4-O(n2M(p )) 4-
O (   ( ne/pe ) eM ( p e )   ) where n is the initial size of the input string . 
Solving the recurrence relation , we get T ( n)-

7 Proof of Correctness
We will show the proof of correctness of the algorithm by induction on the length of the sequence of symbol positions  . 
But first , we make an observation , given any two symbol positions ( r ~ , rt ) , rt > r ~ 41 , and a node m spanning a tree ( i , j , k , l ) such that i < rs and i_>rt with j and k in any of the possible combinations as shown in figure  4  . 
3 a node m ' which is a descendent of the node m in the tree  ( i , j , k , l ) and which either EASSOCLIST ( ml ) or is the same as ml , with ml having one of the two properties mentioned below :  1  . ml spans a tree ( il , jl , kl ,  11 ) such that the last operation to create this tree was a composition operation involving two nodes me and  m3 with mespanning ( ix , J2 , k2 , 12) and m3 spanning (12 , j3 , ks , ix ) . ( with(r , < l ~ . < rt ) , 01 <- r , ) , ( rt < !1) and either ( j2 = kz , j3 = jl , k3=kl ) or ( j2 = jl , k2 = kl , j3=k3)) 2 . ml spans a tree ( il , jl , kl , ll ) such that the last operation to create this tree was an adjunction by an auxiliary tree  ( or a grown auxiliary tree )   ( i l , j2 , k e , Ix ) , rooted at node me , onto the node ml spanning the tree ( j e , jl , kl , k2 ) such that no deme has either the property mentioned in  ( 1 ) or belongs to the ASSOCLIST of a noders rtj k  4 jj kj kkj kofj and k being considered which has the property mentioned in  ( 1 )  .   ( The labels of ml and me being the same ) Any node satisfying the above observation will be called a minimal node w  . r . t , the symbol positions(r ,, r0 . 
The minimM nodes can be identified in the following manner  . If the node m spans ( i , j , k , l ) such that the last operation to create this tree is a composition of the form in figure ha  , then mtOASSOCLIST(m ) is minimal . Else , if it is as shown in figure 5b , we can concentrate on the tree spanned by node ml and repeathe process  . But , if the last operation to create ( i , j , k , 1) was an adjunction as shown in figure 5c , we can concentrate on the tree ( il , j , k , 11) initially spanned by node m . If the only adjunction was by an auxiliary tree , on node m spanning tree ( Q , j , k , lx ) as shown in figure 5d , then the set of minimal nodes will include both m and the rootml of the auxiliary  , tree and the nodes in their respective ASSOC LISTs  . But if the adjunction was by a grown auxiliary tree as shown in figure he  , then the minimal nodes include the roots of /31 , /32 ,   . .,/3s , 7 and the node m . 
Given a sequence < r l , r2, .   .   , rp > , we call ( rq , r ~+ l ) a gap , iff rq+l ? rq+1 . Identifying minimal nodes w . r . t , every new gap created , will serve our purpose in determining all the nodes spanning trees  ( i , j , k ,  1) , with i , lerl , r2 ,   . ., rp . 
Theorem : Given an increasing sequence < r l , r2, . ., rp > of symbol positions and given a . V gaps(rq , rq+l ) , all nodes spanning trees ( i , j , k , l with r q < i < j < k < l < r q + l b . V gaps(rq , rq+l ) , all nodes spanning trees ( i , j , k , l ) such that either rq < i < rq + lorr q < l < rq + l c  . V gaps(rq , rq+l ) , all the minimal nodes for the gap such that these nodes span trees  ( i , j , k , l ) with i , lErl , r2 ,  .   .   , rp and i <_ 1 in addition to the initialization information , the algorithm computes all the nodes spanning trees  ( i , i , k , O with ( i , l ~ r ~ , r~ ,  . .,rp  and i _< i < k<l . 

Proof:
Base Cases :
For length = 1 , it is trivial as this information is already known as a result of initialization  . 
For length = 2 , there are two cases to consider : 1 . r2 = rl+1 , in which case a composition involving nodes from A  ( rl , rl , rl , r l ) with nodes from A(r l , r2 , r2 , r2) and a composition involving nodes from A(rl , r2 , r2 , r2) with nodes from A(r2 , r2 , r2 , r2) , followed by a check for adjunction involving nodes realised from the previous two compositions  , will be sufficient . Note that since there is only one symbol from the input  ( namely , ar ~) , and because an auxiliary tree has at least one label from ~  , thus , checking for one adjunction is sufficient as there can be at most one adjunction  . 
2. r2~rl+1, implies that ( rl , r2) is a gap.
Thus , in addition to the information given as per the theorem  , a composition involving nodes from A(rl , j , k , r2) with nodes from A(r2 , r2 , r2 , r2) and a composition involving nodes from A(rl , rl , rl , r l ) with nodes from A(r l , j , k , r2) , ( rl < j < k < r2) , followed by an adjunction involving nodes realised as a result of the previous two compositions will be sufficient as the only adjunction to take care of involves the adjunction of some auxiliary tree onto a node m which yields e  , and mEA(rl , rl , rl , r l ) or mEA(r2 , r2 , r2 , r2) . 
Induction hypothesis : V increasing sequence < rl  , r2 ,   . ., r ~ > of symbol positions of length < p , ( i . eq < p ) , the algorithm , given the information as mrrst ( ab ) m ( 5c ) mauxiliaryA ? treeo ~ ,   . ~// // // 2X grow . 
tree/////~k // ~ iil'jk'll!(Se)iz
I ( M ) root of auxiliary ratree has property tree ~// /J / / ~ i -' i  1 ' l 1   1 
Grown aux tree formed by adjoining
Ps " P2 Plontoroot of grown aux tree 7
Root of ~1 has property shown in ( Sa )
Figure 5: Identifying minimal nodes required by the theorem  , computes all nodes spanning trees ( i , j , k , l ) such that i , lerl , r2 ,   . ., rq  and i < j < k < I . Induction : Given an increasing sequence < r l , r  ~ ,   . . , rp , rp + l > of symbol positions together with the information required as per parts a  , b , c of the theorem , the algorithm proceeds as follows : 1 . By the induction hypothesis , the algorithm correctly computes all nodes spanning trees  ( i , j , k , i ) within the first 2/3 , i . e , i , lErt , r2, . ., r2(p+D/3  and i < l . By the hypothesis , it also computes all nodes ( i ' , j , k ' , l ') within the last 2/3 , i . e,i ~,! ~ Erl+(p + l)/3, . ., rp+z  and i ' < i' . 
2 . The composition step involving the nodes from the first and last  2/3 of the sequence < r l , r2 ,   . . , rp , rp+i > , followed by the adjunction step captures all nodes m such that either a  . m spans a tree ( i , j , k , l ) such that the last operation to create this tree was a composition operation on two nodes ml and  m2 with ml spanning ( i , j ' , k ; l ' and me spanning ( i ; j " , k" , l ) . ( withi Erl , r2, . ., r(p+l)/3 , i E  rl+(p+l)/3, . .,r2(p+D/3  and I E ! ri+2(p+z)/3, . . rp+z , and either ( j '= k , j "= j , k "= k ) or ( j '= j , k '= k , j "= k ')) . 
b . m spans a tree O , J , k , l ) such that the last operation to create this tree was an adjunction by an auxiliary or grown auxiliary tree  ( i , j' , k' , l ) , rooted at node mI , onto the node m spanning the tree ( j ' , j , k , k ' ) such that node ml has either the property mentioned in  ( 1 ) or it belongs to the ASSOCLIST of a node which has the property mentioned in  ( 1 )  .   ( The labels of m and ml being the same ) Note that , in addition to the nodes m captured from a or b , we will also be realising nodes E
ASSOCLIST(m).
The nodes captured as a result of 2 are the minimal nodes with respect to the gap ( r ( p+l ) / a , rl+2 ( p+l ) /3 ) with the additional property that the trees ( i , j , k , l ) they span are such that iErl , r2 ,   . ., r ( p+l ) \ ]3  and l E  r l+2(p+l ) \ ]3 , . ., rp+l . 
Before we can apply the hypothesis on the sequence < rx  , r2 ,   . ., r(p+t)/3, rl+2(p+l)\[3, . . rp+l > , we have to make sure that the conditions in par tsa  , b , c of the theorem are met for the new gap ( r ( p+1 ) /3 , rl+2(p + l)/3) . It is easy to see that conditions for parts a and baremet for this gap  . We have also seen that as a result of step 2 , all the minimal nodes w . r . t the gap(r(p + x)/3 , rl+2(p + l)/3) , with computed . Thus applying the hypothesis on the sequence < r l  , r2 ,   . ., r(p+l)\[3, r l+2(p+l ) /3, . . rp+l > , the algorithm in the end correctly computes all the nodes spanning trees  ( ij , k , 1) with i , lErl , r2 ,  . .,rp+x  and i < j<k<l . D 8 Implementation The TAL recognizer given in this paper was implemented in Scheme on a SPARC  station-10/30  . 
Theoretical results in this paper and those in ( Ra-jasekaran ,  1995 ) clearly demonstrate that asymptotically fast algorithms can be obtained for TAL parsing with the help of matrix multiplication algorithms  . The main objective of the implementation was to check if matrix multiplication techniques help in practice also to obtain efficient parsing algorithms  . 
The recognizer implemented two different algorithms for matrix multiplication  , namely the trivial cubic time algorithm and an algorithm that exploits the sparsity of the matrices  . The TAL recognizer that uses the cubic time algorithm has a runtime comparable to that of Vijayashanker-\]oshi's algorithm  . 
Below is given a sample of a grammar tested and also the speedup using the sparse version over the ordinary version  . The grammar used , generated the TAL anbncn . This grammar is shown in figure 1 . 
Interestingly , the sparse version is an order of magnitude faster than the ordinary version for strings of length greater than  7  . 
i \[ String a beaabbcc



Speedup\[13 . 1 6 . 1 aab cabe No 8 . 0 abaca bacNo 11 . 7 aaabbbcc Yes 11 . 4 The above implementation results suggest hat even in practice better parsing algorithms can be obtained through the use of matrix multiplication techniques  . 
9 Conclusions
In this paper we have presented an O ( M ( n2 ) ) time algorithm for parsing TALs , n being the length of the input string . We have also demonstrated with our implementation work that matrix multiplication techniques can help us obtain efficient parsing algorithms  . 

This research was supported in part by an NSF Research Initiation Award  CCR-92-09260 and an ARO grant DAAL03-89-C-0031  . 

D . Coppersmith and S . Winograd , Matrix Multiplication Via Arithmetic Progressions  , in Proc . 
19th Annual ACM Symposium on Theory of Computing ,  1987 , pp .  16 . Also in Journal of Symbolic Computation , Vol . 9, 1990, pp .  251-280 . 
S . L . Graham , M . A . Harrison , and W . L . Ruzzo , On Line ContextFree Language Recognition in Less than Cubic Time  , Proc . ACM Symposium on Theory of Computing , 1976, pp .  112-120 . 
A . K . Joshi , L . S . Levy , and M . Takahashi , Tree Adjunct Grammars , Journal of Computer and System Sciences ,  10(1) ,  1975 . 
A . K . Joshi , K . Vijayashanker and D . Weir , The Convergence of Mildly Context-Sensitive Grammar Formalisms  , Foundational Issues of Natural Language Processing  , MIT Press , Cambridge , MA ,  1991 , pp .  31-81 . 
A . Kroch and A . K . Joshi , Linguistic Relevance of Tree Adjoining Grammars , Technical Report MS-CS-85-18 , Department of Computer and Information Science , University of Pennsylvania ,  1985 . 
M . Palis , S . Shende , and D . S . L . Wet , An Optimal Linear Time Parallel Parser for Tree Adjoining Languages  , SIAM Journal on Comput in # , 1990 . 
B . H . Partee , A . Ter Meulen , and R . E . Wall , Studies in Linguistics and Philosophy , Vol . 30, Kluwer
Academic Publishers , 1990.
S . Rajasekaran , TALParsing in o(n6) Time , to appear in SIAM Journal on Computing ,  1995 . 
G . Satta , Tree Adjoining Grammar Parsing and Boolean Matrix Multiplication  , to be presented in the 31st Meeting of the Association for Computational Linguistics  ,  1993 . 
G . Satta , Personal Communication , September 1993 . 
Y . Schabes and A . K . Joshi , An Earley-Type Parsing Algorithm for Tree Adjoining Grammars  , Proc . 
2 6th Meeting of the Association for Computational Linguistics  ,  1988 . 
L . G . Valiant , General ContextFree Recognition in Less than Cubic Time  , Journal of Computer and System Sciences ,  10 , 1975 , pp .  308-315 . 
K . Vijayashanker and A . K . Joshi , Some Computational Properties of Tree Adjoining Grammars  , Proc .   2~th Meeting of the Association for Computational Linguistics  ,  1986 . 

