Group Theory and Linguistic Processing *
Marc Dymetman
Xerox Research Centre Europe
6, chemin de Maupertuis
38240 Meylan , France
Marc . Dymetman@xrce.xerox , com
1 Introduction
There is currently much interest in bringing together the tradition of categorial grammar  , and especially the Lambek calculus ( Lambek ,  1958) , with the more recent paradigm of linear logic ( Girard , 1987) to which it has strongties . One active research area concerns the design of non-commutativersions of linear logic  ( Abr-usci , 1991; Rdtor 6 ,  1993 ) which can be sensitive to word order while retaining the hypothetical reasoning capabilities of standard  ( commutative ) linear logic that make it so well-adapted to handling such phenomena as quantifier scoping  ( Dalrympl et al . , 1995) . 
Some connections between the Lambek calculus and group structure have long been known  ( van Benthem ,  1986) , and linear logic itself has some aspect strongly reminiscent of groups  ( the producer/consumer duality of a formula A with its linear negation Aa-  )  , but no serious attempt has been made so far to base a theory of linguistic description solely on group structure  . 
This paper present such a model , G-grammars ( for " group grammars ") , and argues that : ? The standard group-theoretic notion of conjugacy  , which is central in G-grammars , is well-suited to a uniform description of commutative and non-con-commutative aspects of language  ; ? The use of conjugacy provides an elegant approach to long-distance dependency and scoping phenomena  , both in parsing and in generation ; ? G-grammars give asymmetrical account of the semantics-phonology relation  , from which it is easy to extract , via simple group calculations , rewriting systems computing this relation for the parsing and generation modes  . 
2 Group Computation
A MONOIDAI is a set M together with a product M ?   31  --+  , ll , written ( a , b ) ~+ ab , such that : ? This product is associative ; ? There is an element 1EM ( the neutral element ) with la = al = a for all a 6M . 
* This paper is an abridged version of Group Theory and Grammatical Description  , TR-MLTT-033 , XRCE , April 1998 ; available on the CMP-LG archive at the address : http://xxx  . lanl . gov/abs/cmp-

AGROUP is a monoid in which every elementa has an inverse a  -1 such that a-la = a a -1 -- l . 
APREORDER on a set is a reflexive and transitive relation on this set  . When the relation is also symmetrical , that is , R(x , Y ) ~ R(y , x ) , then the preorder is called an EQUIVAL ENCE RELATION  . When it is antisymmetrical , that is that is , R(x , Y ) AR(y , x ) ~ x = Y , it is called a
PARTIAL ORDER.
A preorder R on a group G will be said to be COM -PATIBLE with the group product iff  , whenever R(x , Y ) and R(x ' , y ') , then R(x x ' , yy ') . 
Normal submonoids of a group . We consider a compatible preorder notated x -4 y on a group G . The following properties , for any x , yEG , are immediate : x-+y ? : ~ xy-l-41 ; x-4 y?0 y-l-4 x1 ; x-41 ?: v1-4x-~ ; x-41:::? , yxy-l-41 , for any yEG . 
Two elements x , x ' in a group G are said to be CONJU-GATE if there exists y  6 G such that x '= y x y -1  . The fourth property above says that the set A , /of elements x 6 G such that x -41 is a set which contains along with an element all its conjugates  , that is , a NORMAL subset of G . As M is clearly a submonoid of G , it will be called a NORMAL SUBMONOID of G . 
Conversely , it is easy to show that with any normal submonoid M of G one can associate a preorder compatible with G  . Indeedlet's define x-+y as xy-16M . The relation --~ is clearly reflexive and transitive  , hence is a preorder . It is also compatible with G , for if xl--)-yl and x2-4y_~ , then xly1-1 , x2 yg . -1 and yl(x~y2-1) y1-1 are inM ; hence XlX2 y ~ . -ly1-1: xlyl-lylx ~ . y2-1y1-1 is in M , implying that XlX2-4yly : , that is , that the preorder is compatible . 
If S is a subset of G , the intersection of all normal submonoids of G containing S  ( resp . of all subgroups of G containing S ) is a normal submonoid of G ( resp . a Jln general M is not a subgroup of G . It is iff x~y implies Y--+ x , that is , if the compatible preorder--~ is an equivalence relation  ( and , therefore , a CONGRUENCE ) on G . When this is the case , M is a NORMAL SUBGROUP of G . This notion plays a pivotal role in classical algebra  . Its generalization to submonoids of G is basic for the algebraic theory of computation presented here  . 
348 normal subgroup of G ) and is called the NORMAL SUB-MONOIDCLO SURENM ( S ) of S in G ( resp . the NORMAL SUBGROUPCLO SURENG(S ) of S in G ) . 
The free group over %' . We now consider an arbitrary set V , called the VOCABULARY , and we form the socalled SETOFATOMSONW , which is notated Vt_JV -1 and is obtained by taking both elements v in V and the formal inverses  v1 of these elements . 
We now consider the set F ( V ) consisting of the empty string , notated 1 , and of strings of the form zxx ~ . . . .:e ,, where zi is an atom on V . It is assumed that such a string is REDUCED , that is , never contains two consecutive atoms which are inverse of each other : no substring  vv-1 or v1 v is allowed to appear in a reduced string . 
When a and fl are two reduced strings , their concatenation c~fl can be reduced by eliminating all substrings of the form vv-  1 or v- 1 v . It can be proven that the reduced string 7 obtained in this way is independent of the order of such eliminations  . In this way , a product on F(V ) is defined , and it is easily shown that F ( V ) becomes a ( non-commutative ) group , called the FREEGROUP over
V ( Hungerford , 1974).
Group computation . We will say that an ordered pair GCS = (~ , R ) is a GROUPCOMPUTATIONSTRUCTURE if : 1 . V is a set , called the VOCABULARY , or the set of
GENERATORS 2 . R is a subset of F(V ) , called the LEXICON , or the set of RELATORS . 2 The submonoid closure NM ( R ) of R in F ( V ) is called the RESULT MONOID of the group computation structure GCS  . The elements of NM(R ) will be called COMPU-
TATION RESULTS , or simply RESULTS.
If r is a relator , and if ct is an arbitrary element of F(V ) , then ct , rc  ~ -1 will be called a QUASI-RELATOR of the group computation structure  . It is easily seen that the set RN of quasi -relators i equal to the normal subset closure of R in F  ( V )   , and that NM(RN ) is equal to

A COMPUTATION relative to GCS is a finite sequence c =  ( rl .   .   .   . , rn ) of quasi-relators . The product rx ? ? ? r , , in F ( V ) is evidently a result , and is called the RESULTOFTHECOMPUTATION c . It can be shown that the result monoid is entirely covered in this way : each result is the result of some computation  . A computation can thus be seen as a " witness " , or as a " proof " , of the fact that a given element of F ( V ) is a result of the computation structure . 3 For specific computation tasks , one focusses on results of a certain sort , for instance results which express a relationship of input-output  , where input and output are 2 For readers familiar with group theory , this terminology will evoke the classical notion of group PRESENTATION through generators and relators  . The main difference with our definition is that , in the classical case , the set of relators is taken to be symmetrical , that is , to contain r-1 if it contains r . When this additional assumption is made , our preorder becomes an equivalence rlation . 
3The analogy with the view in constructive logics is clear  . There what we call a result is called a formula or at bpe  , and what we call a computation is called a prot ~ jjohn  -1   1 louise -1 pparts raman -1 
Wwoman-1
A-Ir(A ) ran-1
A-Is(A,B)B-I saw-I
E-Ii(E , A ) A-Iin-It(N ) N-I the-Iev(N , X , P\[X\] ) p\[x\]-1~-iXN-Iever ) '- asm ( N , X , P\[X\] ) p\[x\]-1~-iXN-1 some-xN-Itt ( N , X , P\[X\] ) p\[X\]-Ia-IX ~ that-I Figure 1 : AG-grammar for a fragment of English assumed to belong to certain object types  . For example , in computational linguistics , one is often interested in results which express a relationship between a fixed semantic input and a possible textual output  ( generation mode ) or conversely in results which express a relationship between a fixed textual input and a possible semantic output  ( parsing mode )  . 
If GCS = ( V , R ) is a group computation structure , and if A is a given subset of F(V ) , then we will call the pair GCSA = ( GCS , A ) aGROUPCOMPUTATIONSTRUCTUREWITHACCEPTORS . We will say that A is the set of acceptors , or the PUBLICINTERFACE , of GCSA . A result of GCS which belongs to the public interface will be called a PUBLICRESULT of GCSA  . 
3G-Grammars
We will now show how the formal concepts introduced above can be applied to the problems of grammatical description and computation  . We start by introducing a grammar , which we will call a G-GRAMMAR ( for " Group Grammar " )  , for a fragment of English ( see Fig . 

AG-grammar is a group computation structure with acceptors over a vocabulary V = V logU~/pho ~ consisting of a set of logical forms l/~og and a disjoint set of phonological elements  ( in the example , words ) l/~ho , , . Examples of phonological elements are john , saw , ever ) . , , examples of logical forms j , s(j ,  1)  , e v ( r e , x , sra(w , y , s(x , y ))) ; these logical forms can be glossed respectively as " john "  , " john saw louise " and " for every man x , for some wo many , xsawy " . 
The grammar lexicon , or set of relators , R is given as a list of " lexical schemes " . An example is given in Fig .  1 . 
Each line is a lexical scheme and represents a set of re-lators in F  ( V )   . The first line is a ground scheme , which corresponds to the single relator j john-1 , and so are the next four lines . The fifth line is a non-ground scheme , which corresponds to an infinite set of relators , obtained by instanciating the term metavariable A  ( notated in uppercase ) to a logical form . So are the remaining lines . 
We use Greek letters for expression metavariables such as a  , which can be replaced by an arbitrary expression of F  ( V )   ; thus , whereas the term metavariables A , B . . . . . 
range over logical forms , the expression metavariables , ~ , fl . . . . . range over products of logical forms and phono -The notation p\[x \] is employed to express the fact that a logical form containing an argument identifier x is equal to the application of the abstraction P to x  . The metavariable X in p\[X\] ranges over such identifiers  ( x , y , z . . . . ) , which are notated in lower case italics ( and are always ground )  . The metavariable pranges over logical form abstractions missing one argument  ( for instance Az . s(j,z )) . When matching metavariables in logical forms , we will allow limited use of higher-order unification  . For instance , one can match P\[X\]to-~(j , x ) by taking P = Az . s(j,z ) and X = x . 
The vocabulary and the set of relators that we have just specified define a group computation structure GCS =  ( I , , _R ) . We will now describe a set of acceptors A for this computation structure  . We take A to be the set of elements of F ( V ) which are products of the following form :
SlI/n-l Wr~_1-1 .   .   . IV1-1 where S is a logical form ( S stands for " semantics " )  , and where each II ' ; - is a phonological element ( W stands for "' word " )  . The expression above is a way of encoding the ordered pair consisting of the logical form S and the phonological string  111 l , I ) .   .   . l . I ; ~( that is , the inverse of the product l , Vn-11 Vn-1-I .   .   . I . V1-1) . 
A public result SW n-l Wn_l-1 .   .   . t'Iq -1 in the group computation structure with acceptors  ( ( V , R ) , A ) -- the G-grammar--will be interpreted as meaning that the logical form S can be expressed as the phonological string  IV1 l'l:~' . . lYn . 
Let us give an example of a public result relative to the grammar of Fig  .  1 . 
We consider the relators ( instanciations of relator schemes ) : rl = j-1 s ( j , 1) r , _=1 louise-1r3=j john-t
I - 1   saw-1 and the quasi-relators : '- irl ' = jrl 3   r2  ' =  ( jsan , ) r2r3'=r3j saw)-i
Then we have : rl'r2'r3'=jj1s(j , l ) i-I saw-1 j-Ij saw 1 louise-1 saw-1 . j-1j john-1 = s(j , 1  ) louise-1 saw-1 john-x which means that s ( j ,  1  ) louise-Isaw-ljohn- 1 is the result of a computation ( r ~' , r2' , r3') ? This result is obviously a public one , which means that the logical forms ( j ,  1  ) can be verbalized as the phonological string john saw louise  . 
4Expression metavariables are employed in the grammar for forming the set of conjugates c ~ e : cp  ~-1 of certain expression sezp ( in our example , earp is ovN , X , P\[X\])P\[X\]-1 , sm(N , X , P\[X\])P\[X\]-1 or X ) . Conjugacy allows the enclosed material expto move as abh  , ck in expressions of F(V ) , see sections 3 . and 4 . 
j ~ john i ~ louisep ~ parism ~ man w ~ woman r ( A ) - ~ Arans ( A , B ) - ~ A saw Bi(E , A ) - ~ E in A t ( N ) - - ~ the Nev(N , X , P\[X \]) ~ ce-1sm(N , X , P\[XI) . . . xcr-1tt(N , X , P\[X\] ) eveo'NX-a ocP\[X\]someNX -1 aP\[X\]
N that a-aX-1c~P\[X\]
Figure 2: Generation-oriented rules 4 Generation Applying directly , as we have just done , the definition of a group computation structure in order to obtain public results can be somewhat unintuitive  . It is often easier to use the preorder --+ . If , for a , b , c6F ( V ) , abc is a rela-tor , then abc--+1 , and therefore b--+a-lc-1 . Taking this remark into account , it is possible to write the relators of our G -grammar as the " rewriting rules " of Fig  .  2 ; we use the notation ----" instead of --+ to distinguish these rules from the parsing rules which will be introduced in the next section  . 
The rules of Fig . 2 have a systematic structure . The left hand side of each rule consists of a single logical form  , taken from the corresponding relator in the G -grammar  ; the right hand side is obtained by " moving " all the renmining elements in the relator to the right of the arrow  . 
Because the rules of Fig .   2 privilege the rewriting of a logical form into an expression of F  ( V )   , they are called generation-oriented rules associated with the G-grammar  . 
Using these rules , and the fact that the preorder is compatible with the product of F  ( V )   , the fact that s(j ,  1  ) louise-lsaw-ljohn- 1 is a public result can be obtained in a simpler way than previously  . We have : s(j , l)j~john1~louisejsaw1 by the seventh , first and second rules ( properly instanci-ated ) , and therefore , by transitivity and compatibility of the preorder : s  ( j , 1) ~ jsaw1 john saw1 ~ john saw louise which . proves that s(j , 1) --- ~ john saw louise , which Isequivalent to saying that s(j ,  1 ) louise-1 saw-l john-1 is a public result . 
Some other generation examples are given in Fig .  3 . 
The first example is straightforward and works similarly to the one we have just seen : from the logical form  5  . ( s(j ,  1 )  , p ) one can derive the phonological string john saw louise in paris  . 
350 i(s(j,l ), p)-~s(j,l ) in p_ . x j saw 1 in p--~john saw 1 in pjohnsawlouise in pjohnsawlouise in parisev  ( m , x , sm(w , y , s(x , y ))) -- ~ ct-I every mx-Ic~sm(w , y , s(x , y )   ) 0-1 every mx-1o~19-1 somewy1/3s ( x , y ) --- , cr -~ every man x -1 a /31 somewom any -1   /3 xsawya -1 every man x -1 axsaw some woman ( by taking/3= saw-1x-1 ) __x every man saw some woman ( by taking a = 1 ) sm ( w , y , ev(m , x , s(x , y ))) . _~/3-isomewy1/3ev(m , x , s(x , y )   )   ) /3-I some wy-1/9 ce-1ever ) ' mx-1ces ( x , y)--~/3-1 some wo many-1flc ~-1 ever ) , manx -1 cexsawy /3   -1 somewom any -1   /3 every mans awy ( by taking a = 1 )   . -- , every man saw some woman ( by taking/3= saw-1man-a every-1 ) 
Figure 3: Generation examples merit , quantified noun phrases can move to whatever place is assigned to them after the expansion of their " scope " predicate  , a place which was unpredictable at the time of the expansion of the quantified logical form  . 
The identifiers act as " target markers " for the quantified noun phrase : the only way to " get rid " of an identifier x is by moving z  -1   , and therefore with it the corresponding quant if ied noun phrase  , to a place where it can cancel with z . 
5 Parsing
To the compatible preorder ~ on F ( V ) there corresponds a " reverse " compatible preorder ---  , defined as a --- , biffb ~ a , or , equivalently , a-1__+b-1 . The normal submonoid M ' in F ( V ) associated with --- , is the inverse monoid of the normal submonoid M associated with ~  , that is , M ' contain saiffM contains a-1 . 
It is then clear that one can present he relations : jjohn-i--+  1 
A-Ir(A ) ran-I-+1 sm(N , X , P\[X\] ) P\[X\]-I~-IXN-i some-l-+etc . 
in the equivalent way : john j-1 . _  .   , 1 ranr ( A ) -IA---71 some Nx-lo'P\[X\]etc . 
sm(N,X,P\[X\])-1~-1-v1
Long-distance movement and quantifiers The second and third examples are parallel to each other and show the derivation of the same stringever ' man saw some woman from two different logical forms  . The penultimate and last steps of each example are the most interesting  . In the penultimate step of the second exam-ple , /3 is instanciated to saw-1x-1 . This has the effect of " moving " as a whole the expression some wo many -~ to the position just before y  , and therefore to allow for the cancellation of y -* and y  . The net effect is thus to " replace " the identifiery by the string some woman  ; in the last step c ~ is instanciated to the neutral element  1  , which has the effect of replacing x by ever ' man  . In the penultimate step of the third example , a . is instanciated to the neutral element , which has the effect of replacing x by every man ; then fl is instanciated to saw-1man-levery-1 , which has the effect of replacing y by some woman . 
Remark . In all cases in which an expression similar to a al  .   .   . a ma-1 appears ( with the ai arbitrary vocabulary elements )  , it is easily seen that , by giving a an appropriate value in F(V ) , the al .   .   . amcan move arbitrarily to the left or to the right  , but only together in solidarity ; they can also freely permute cyclically , that is , by giving an appropriate value to a , the expression aal .   .   . a ma-l can take on the value a kak+l .   . - a , , , al ?? , ak-1 ( other permutations are in general not possible )  . The values given to the or , fl , etc . , in the examples of this paper can be understood intuitively in terms of these two properties  . 
We see that , by this mechanism of concerted move-john--~j louise ---  , 1 paris - - - , pman-- , mwoman- . -- , Wran-=A-1r(A ) saw-vA-Is(A , B ) B-I in -- , E-Ii(E , A ) A-I the--7 t ( N)N-I ever ) '-- , oev ( N , X , P\[X \]) some - - , c ~ sm(N , X , P\[X \]) that-vN-Itt(N , X , P\[X \]) p\[x\]-I~-IXN-I
P\[X\]-a~-1XN-Ip\[x\]-1~-IX
Figure 4: Parsing-oriented rules
Suppose now that we move to the right of the --7 arrow all elements appearing on the left of it , but for the single phonological element of each relator  . We obtain the rules of Fig .  4 , which we call the " parsing-oriented " rules associated with the G-grammar  . 
By the same reasoning as in the generation case , it is easy to show that any derivation using these rules and leading to the relation PS--  , LF , where PS is a phonological string and LF a logical form  , corresponds to a public result LFPS -1 in the G-grammar . 
A few parsing examples are given in Fig .  5 ; they are the converses of the generation examples given earlier  . 
In the first example , we first rewrite each of the phonological elements into the expression appearing on --  , jA-1 s(A , B)B-1iE-a-- , s(j , B ) B-I1E-Ii(E , p ) -- , s(j , l)E-Ii(E , p ) -- , i(s(j , l ) , p)i(E , C)C-apever 3 , mans awso me woman ?- , crev(N , x , P\[x\] ) P\[x\]-Ia-1XN-1mA-1s ( A , B ) B-1/3 sm(M , y , Q\[y\])Q\[y\]-i--- , ~ ev(m , x , P\[x\])Plx\]-ao~-1xA-xs(A , B ) B-1/3 sm(w , y , Q\[y\])Q\[yl-a/31 y--- , xA-aev(m , x , P\[x\])P\[x\]-Is(A , B ) B-1/3 sm(w , y , Q\[y\])Q\[y\]-i/3ay- , xA-1ev(m , x , P\[x \]) P\[x\]-as(A , B)Q\[y\]-ism(w , y , Q\[y\])B-1y-- , ev(m , x , P\[xl)P\[x\]-as(x , y)Q\[y\]-asm(w , y , Q\[y\]) and then either : --- , ev(m , x , P\[xl)P\[xl-asm(w , y , s(x , y )) -- , ev(m , x , sm(w , y , s(x , y )) or : --- , ev(m , x , sO < , y )) Q\[y\]-ism(w , y , Q\[y\])sm(w , y , ev(m , x , s(x , y))
Figure 5: Parsing examples ~-* yM-lw the right hand side of the rules  ( and where the metavariables have been renamed in the standard way to avoid name clashes  )  . The rewriting has taken place in parallel , which is of course permitted ( we could have obtained the same result by rewriting the words one by one  )  . We then perform certain unifications : A is unified with j  , C with p ; then B is unified to 1 . 5 Finally E is unified with s(j , i ) , and we obtain the logical form ?( s(j ,  3 . ), p ) . In this last step , it might seem feasible to unify v . to ?( E , p ) instead , but that is in fact forbidden for it would mean that the logical form - i  ( E , p ) is not a finite tree , as we do require . This condition prevents " self-cancellation " of a logical form with a logical form that it strictly contains  . 
Quantifier scoping In the second example , we start by unifying m with N and w with M ; then we " move " P\[x\]-1 next to s(A , B ) by taking a = xA-1 ; 6 then again we " move " Q\[y\]-1 next to s ( A , B ) by taking f l = B sm(w , y , Q\[y\])-1 ; x is then unified with A and y with B . This leads to the expression : ev(m , x , P\[x\])P\[x\]-ls(x , y)Q\[y\]-lsm(w , y , Q\[y \]) where we now have a choice . We can either unify s(x , y ) with Q\[y\] , or with P\[x\] . In the 5Another possibility at this point would be to unify 1 with E rather than with E . This would lead to the construction of the logical form i  (  1 , p ) , and , after unification of E with that logical form , would conduct to the outputs(j , i(1 , p )) . If one wants to prevent this output , several approaches are possible . The first one consists in typing the logical form with syntactic ategories  . The second one is to have some notion of logical -form wellformedness  ( or perhaps interpretability ) disallowing the logical forms i (  1 , p)\[louise in paris\]ori(t(w ) , p)\[(the woman ) in paris\] , although it might allow the form t(i(w , p ))\[ the ( woman in paris )\] . 
t ' We have assumed that the metavariables corresponding to identifiers in P and Q have been instanciated to arbitrary  , but different , values x and y . See ( Dy , netman , 1998) for a discussion of this point . 
first case , we continue by no wunifying PIx\]with sm(w , y , s(x , y )) , leading to the outpute v(m , x , sm(w , y , s(x , y ))) . In the second case , we continue by no wunifying Q\[y\]withev(m , x , s(x , y )) , leading to the outputs m(w , y , ev(m , x , s(x , y )) . The two possible quantifier scopings for the input string are thus obtained  , each corresponding to a certain order of performing the unifications  . 

Thanks to Christian Retor 6 , Eric de la Clergerie , Alain Lecomte and Aarne Ranta for comments and discussion  . 

V . M . Abrusci .  1991 . Phase semantics and sequent calculus for pure non -commutative classical in ear logic  . 
Journal of Symbolic Logic , 56(4).
M . Dalrymple , J . Lamping , EPereira , and V . Saraswat . 
1995. Linear logic for meaning assembly . In Proc.
CLNLP , Edinburgh.
Marc Dymetman .  1998 . Group computation and its applications to linguistic description  . ( in preparation ) . 
J . Y . Girard .  1987 . Linear logic . Theoretical Computer
Science , 50(1).
Thomas W . Hungerford . 1974. Algebra . Springer-

J . Lambek .  1958 . The mathematics of sentence structure . American Mathematical Monthly , 65:154-168 . 
C . R4 to r&1993 . Rd seauxet sdquents or donn~s . Ph . D . 
thesis , Univ . Paris 7.
Johan van Benthem .  1986 . Essays in Logical Semantics . 
D . Reidel , Dordrecht , Holland.

