ONTHEDECIDABILITY OFFUNCTION ALUNCER TAINTY*
Rolf Backofen
German Research Center for Artificial Intell igence  ( DFKI ) 
W-6600 Saarbrficken , Germany
back of en@df ki.uni-sb.de
Abstract
We show that feature logic extended by functional uncertainty is decidable  , even if one admitscyclic descriptions . We present an algorithm , which solves feature descriptions containing functional uncertainty in two phases  , both phases using a set of deterministic and nondeterministic rewrite rules  . We then compare our algorithm with the one of Kaplan and Maxwell  , that does not cover cyclic feature descriptions . 
1 Introduction
Feature logic is the main device of unification grammars  , the currently predominant paradigm in computation a linguistics  . More recently , feature descriptions have been proposed as a constraint system for logic programming  ( e . g . see\[llD . They provide for partial descriptions of abstract objects by means of functional attributes called features  . 
Formalizations of feature logic have been proposed in various forms  ( for more details see\[3\] in this volume )  . We will follow the logical approach introduced by Smolka  \[9  ,  10\] , where feature descriptions are standard first order formulae interpreted in first order structures  . In this formalization features are considered as functional relations  . Atomic formulae ( which we will call atomic constraints ) are of either the form A ( x ) or zfy , where x , y are first order variables , A is some sort predicate and f is a feature ( written in infix notation )  . The constraints of the form xfy can be generalized to constraints of the form xwy  , where w = fl- .   . fn is a finite feature path . 
This does not affect the computational properties.
In this paper we will be concerned with an extension to feature descriptions  , which has been introduced as " functional uncertainty " by Kaplan and Zaenen  \[7\] and Kaplan and Maxwell \[5\]  . This formal device plays an important role in the framework of LFG in modelling so called long distance dependencies and constituent coordination  . For a detailed linguistic motivation see\[7\] , \[6\] and\[5\] ; a more general use of functional uncertainty can be found in  \[8\]  . 
Functional uncertainty consists of constraints of * This work was supported by a research grant  , ITW 90020 , from the German Bundesministeriumffir Forschung und Technologic to the DFKI project DISCO  . 
I would like to thank Jochen Dhrre , Joachim Niehren and Ralf Treinen for reading draft version of this paper  . For space limitations most of the proofs are omitted  ; they can be found in the complete paper \[2\] the form xLy , where L is a finite description of a regular language of feature paths  . A constraint xLy holds if there is a path wEL such that zwy holds  . Under this existential interpretation , a constraint xLy can be seen as the disjunction = I  ,  . , , exLyL . 
Certainly , this disjunction may be infinite , thus functional uncertaint yields additional expressivity  . 
Note that a constraint zwy is a special case of a functional uncertainty constraint  . 
To see some possible application of functional uncertainty we briefly recall an example that is given in Kaplan and Maxwell  \[5  , page 1\] . Consider the topicalized sentence Mary John telephoned yesterday  . 
Usings as a variable denoting the whole sentence , the LFG-like clauses topic xAs obj x specifies that in sMary should be interpreted as the object of the relation telephoned  . The sentence could be extended by introducing additional complement predicates  , as e . g . in sentences like Mary John claimed thai Bill telephoned  ; Mary John claimed thai Bill said that .   .   . Henry telephoned yesterday; .   .   .   . For this family of sentences the clausess topic xAs compobj x  , stopic xAs comp corn pobj x and so on would be appropriate  ; specifying all possibilities would yield an infinite disjunction  . This changes if we make use of functional uncertainty allowing to specify the above as the single clauses topic xAs comp * objx  . 
Kaplan and Maxwell \[5\] have shown that consistency of feature descriptions is decidable  , provided that a certain aey clicity condition is met  . More recently , Banderethi . \[1\] have proven , that consistency is not decidable if we add negation  . But it is an open problem whether consistency of feature descriptions without negation and without additional restrictions  ( such as acyclicity ) is decidable . In the work presented here we show that it indeed is decidable  . 
2'\] ? he Method
We will first briefly describe the main part of solving the standard feature terms and then turn to their extension with functional uncertainty  . 
Consider a clause ? = xplylAxpzy2 ( from now on we will refer to pure conjunctive formulae as clauses  )  . 
A standard method for solving feature terms would rewrite ? in order to achieve a solved form  . This rewriting depends on the paths Pl and Pz . If Plequals Pz , we know that yl and Y2 must be equal . 
This implies that ? is equivalent toxply xAyl-- Y z  . If form ? equivalently into the formula explyiA YlP'Y2  . 
The reverse case is treated in a similar ' fashion . If neither prefix or equality holds between the paths  , there is nothing to be done . By and large , clauses where this holds for every x and every pair of different constraints xp ~ y and  xp2z are the solved forms in Smolk a \[9\]  , which are consistent . 
If we consider a clause of the form ? = zL~y ~ A zL2y  ~ , then we again have to check the relation between ys and y ~  . But now there is in general no unique relation determined by ?  , since this depends on which paths p ~ and P2 we choose out of L ~ and L ~ . Hence , we have to guess the relation between pl and p ~ before we can calculate the relation between yl and y ~  . However , there is a problem with the original syntax , namely that it does not allow one to express any relation between the chosen paths  ( in a later section we will compare our algorithm to the one of Kaplan/Maxwell  , thus showing where exactly the problem occurs in their syntax  )  . Therefore , we extend the syntax by introducing socalled path variables  ( written c ~ , fl , a ' ,   .   .   .  )  , which are interpreted as feature paths ( we will call the other variables first order variables  )  . Hence , if we use the modified subterm relation xo~y and a restriction constrain to ~~ L  , a constraint xLy can equivalently be expressed as xayAa ~ L  ( 4 new )  . The interpretation of xay is done in two steps . Given a valuation V ~ , of the path variables as feature paths , a constraint = c~y in ? is substituted by xV ~ , ( cQ y . This constraint is then interpreted using the valuation for the first order variables in the way such constraints are usually interpreted  . 
By using this extended ( two-sorted ) syntax we are now able to reason about the relations between different path variables  . In doing so , we introduce additional constraints c~-fl ( equality )  , o ~~ fl(prefix ) and c~flfl(divergence) . Divergence holds if neither equality nor prefix holds  . Now we can describe a normal form equivalent to the solved clauses in Smolka's work  , which we will call pre-solved clauses . A clause ? is pre-solved iff for each pair of different constraint xayl and  x~y2 in ~ b there is a constraint a I\]~in ? . 
We call this clauses pre-solved , since such clauses are not necessarily consistent  . It may happen , that the divergence constraints together with the restrictions of form a ~ L are inconsistent  ( e . g . think of the clause a ~ f + A ~ ~ ff + A ( ~ flfl )  . But pre-solved clauses have the property , that if we find a valuation for the path variables  , then the clause is consistent . 
Our algorithm first transforms a clause into a set of pre-solved clauses  , which is ( seen as a disjunction ) equivalent to the initial clause . In a second phase the pre-solved clauses are checked for consistency with respect to the path variables  . In this paper we will concentrate on the first phase  , since it is the more difficult one . 
Before looking at the technical part we will illustrate the first phase  . For the rest of the paper we will write clauses assets of atomic constraints  . Now consider the clause 7= xay , al ~ L1 , xflz , fl~L2 . 
The first step is to guess the relation between the path variables c ~ and f t  . Therefore ,   7 can be expressed equivalently by the set of clauses  71  =  4   , ) ~ u 773 = ~ ~ ~ u 772 = , ~- ~ u 774 = ~- ~ , ~ u7 The clause 71 is pre-solved . For the others we have to evaluate the relation between a and \] Y  , which is done as follows . For 72 we substitute/~byot and zbyy , which yields y "-- z , xay , o ~ EL 1 , aEL2 . 
We keep only the equality constraint for the first order variables  , since we are only interested in their valuation . Combining 4~L 1 , a ~ L2 to 4~ ( L1f ' ) L2 ) then will give us the equivalent pre~solved clause For  73 we know that the variable/3 can be split into two parts , one of them covered by 4 . We can use concatenation of path variables to express this  , i . e . we can replace fl by the term c ~ . fl ', where ~' is new . Thus we get the clause 7~-xc~y , a ~ L1 , yfl'z , c  ~ . fl'~L2 , The only thing that we have to do additionally in order to achieve a pre-solved clause is to resolve the constraint a  . /~ ~ ~ ~ L2 . To do this we have to guess a socalled decomposition P  , S of L2 with P . SC_L2 such that a ~ P and \]~'~ S . In general , there can be an infinite number of decompositions  ( think of the possible decompositions of the language f ' g  )   . But as we use regular languages , there is a finite set of regular decompositions covering all possibilities  . Finally , reducing c~~L ~ , ~ ~ P to ~ ~ ( L1nP ) will yield a pre-solved clause . 
Note that the evaluation of the prefix relation in  73 has the additional effect of introducing a new constraint y~z  . This implies that there again may be some path variables the relation of which is unknown  . 
Hence , after reducing the terms of form a --"\] ~ or ~ fl we may have to repeat the nondeterministic choice of relations between path variables  . In the end , the only remaining constraints between path variables will be of the form a flft  . 
We have to consider some additional point , namely that the rules we present will ( naturally ) loop in some cases . Roughly speaking , one can say that this always occurs if a cycle in the graph coincides with a cycle in the regular language  . To see this let us vary the above example and let  7 now be the clause xax , c ~ ~ f , xflz , fl~f'g . Then a possible looping derivation could be 1 . add a4\]~:44fl,xax,a~f,xflz,fl~f*g2 . split flinto af ~':3 . decompose c ~ -/ ~ If ' g := ~ , ~ f , ~ f ~' ~ , a ~ f * , Z ' ~ f*g = ~ z , ~ I , ~/ ~ ~' z , ~' ~ y * g However , we will proof that the rule system is quasi -terminating  , which means that the rule system may cycle , but produces only finitely many different clauses  ( see\[4\] )  . This means that checking for cyclic derivations will give us an effective algorithm  . 
Quasi-termination is achieved by the following measures : first we will guarantee that the rules do not introduce additional variables  ; second we restrict concatenation to length 2 ; and third we will show that the rules system produces only finitely many regular languages  . In order to show that our rewrite system is complete  , we also have to show that every solution can be found in a pre-solved clause  . 
3 Preliminaries
Our signature consists of a set of sorts S(A , B ,   .   .   . ), first order variables X(z , y, .   .   . ), path variables 79(a , /3, .   .   . ) and features Jr(f , g, .   .   .  )  . We will assume a finite set of features and in finite sets of variables and sorts  . A path is a finite string of features . A path u is a prefix of a path v ( written u~v ) if there is a nonempty path w such that v = uw . Note that is neither symmetric nor reflexive . Two paths u , v diverge ( written unv ) if there are features f , g with f ~ g and possibly empty paths w , wl , w2 such that u = wfw ~ Av = wg w2 . Clearly , n is a symmetric relation . 
Proposition 3 . 1 Given two paths u and v , then exactly one of the relations u = v , u . ~v , u~-voru IIv holds . 
A path term ( p , q .   .   .   .   ) is either a path variable a or a concatenation of path variables a  . fl . We will allow complex path terms only in divergence constraints and not in prefix or equality constraints  . Hence , the set of atomic constraints is given by e ~ A z sort restriction z ":- y agreement zf ~  .   .   .   .   . fnY subterm agreement 1 zo~y subterm agreement 2 p ~ L path restriction p fiq divergence ~ \[3 prefix c ~- fl path equality We exclude empty paths in subterm agreement since xey is equivalent ox-y  . Therefore , we require fl " .   .   . ' fnE~r + and LC_jr + . 
A clause is a finite set of atomic constraint denoting their conjunction  . We will say that a path term a . fl is contained ( or used ) in some clause ? if ? contains either a constraint a-fl ~ L or a constraint a  . fltiq ) Constraints of the form p ~ L , pflq , a : ~ fl and c~-fl will be called path constraints  . 
An interpretation Z is a standard first order structure  , where every feature f ~ ~ is interpreted as a binary  , functional relation Fz and where sort symbols We will not differentiate between pflq and q~p  . 
are interpreted as unary , disjoint predicates ( hence AzOBz = 0 for A5 ? B )  . Avaluation is a pair ( Vx , VT ~) , where Vx is a standard first order valuation of the variables in X and V v is a function V~v : P- --+ ~'+  . We define V~,(a . fl ) to be VT , (a)V~ , (13) , The validity of an atomic constraint in an interpretation  2" under a valuation ( Vx , V  ~ , ) is defined as follows : ( Vx , V  ~ , ) ~ zAx : ?=: ~ Vx(x)eAz(Vx , Vr ) Pz = - Y : ?= ~ V x (=) = V x ( U ) ( vx , vr)~zzpy(vx , vv)~z = . u(vx , vT ~) ~ zpeL(Vx , VT ~) ~ zpbq : ? = , vx(~)F ? 0 .   .   . oF , ~ V x(y ) : ? := ~( V x , Vv ) ~ z?V v(a ) y : ?== ~ V ~ , ( p ) CL:?::~Vp(p ) oVT~(q ) for a Cu , k , --"  , where p is the path fl " .   .   . ' f , and F/z are the interpretations of fi in Z . 
For a set ~ CX we define = ? to be the following relation on first order valuation : 
V x=~V/~iffWe~:Vx(~)=V/~(x).
Similarly , we define = ~ with 7 rC79 for path valuations . Let 0 C_XU79 be a set of variables . For a given interpretation 7:we say that a valuation ( Vx , V  ~ ) is a O-solution of a clause ? in 2" if there is a valuation ( V  ~ , V ~) in 2" such that Vx = a'n e V ~: , V p = ~ , no V ~ and ( V ~: , V ~) ~ z ? . The set of all 0-solutions of ? in 2: is denoted by \[?\] ~ . We will call X-solutions just solutions and write \[?\] z instead of\[?\]  , ~ . 
For checking satisfiability we will use transformation rules  . A rule R is O-sound ?--* n 7 \[?\] zD \[7\]~ z for every interpretation 2"  . R is called O-preserving if ?"+ R 3' : ?"\[?\] ZC \[7\]~  . R is globally
O-preserving if \[?\] zC_U \[7\]$-?--*n7   4 The First Phase 4  . 1 A Set of Rules Recall that we have switched from the original syntax to a  ( two-sorted ) syntaxby translating constraints zLy into zay , ~ ~ L , where a is new . The result of the translation constitutes a special class of clauses  , namely the class of prime clauses , which will be defined below . Hence , it suffices to show decidability of consistency of prime clauses  . They are the input clauses for the first phase . 
Let ? be some clause and z , y be different variables . We say that ? binds y t0 z if z-yE ? and y occurs only once in ? . Here it is important hat we consider equations as directed  , i . e . we assume that z -" y is different from y-x . We say that ? eliminates y if ? binds y to some variable x  . A clause is called basic if 1 . x-y appears in ? iff ? eliminates y , 2 . For every path variable a used in ? there is at most one constraint zc~yE ?  . 
203 ( Eq)c~-/3 , zay , x/3z ) U?v-z , ~vu?\[/3 . ---, ~ . --u \] ( Pre ) ' ~" ~/ 3'z ~ y , x/3z ) U ? x ~ , vuv/3zu ?\[/3 . - ~ . /3\](Join)a ~ L , ~ ~ L'U?L:/:L' , ~ ~( LnL')U ? ( Divl ) afi/3') Ua . /3fi/3'U ? ~ ii yu?(Div2)a-/3fi ~ . /3' U ? /3 fiyu ?
J _ ( DC lash l ) a'/3 fi aU?_L ( DC lash 2 ) o ~ fia U ?
J_(Empty)a ~0) O?_L
Figure 1: Simplification rules . Note that ( Pre ) does not introduce a new variable . 
A basic clause ? is called prime if ? does not contain an atomic constraint of the form pflq  , c~-~/3 or ot-/3 . Every clause ? in the original Kaplan/Maxwell syntax can be translated into a prime clause  7 such that ? is consistent iff 9' is consistent . 
Now let's turn to the output clauses of the first step  . A basic clause is said to be pre-soived if the following holds :  1  . Ax 6? and Bz 6?5 implies A-B . 
2. c~dL6? and adL'6 ? implies L = L*.
Furthermore , ad O is not in ?.
3. a-/3, c~-/3 or a ~/3 are not contained in ?.
4. afl/36? iff a ~/3, x(~y6? and z/3z 6?.
Lemma 4 . 1 A pre-soived clause ? is consistent iff there is a path valuation V ~  , with VT~~Cp , where Cp is the set of path constraints in ~ . 
Now let's turn to the rule system . As we have explained informally , the first rule adds non-deterministiely relational constraints between path variables  . In one step we will add the relations between one fixed variable a and all other path  vari-ables/3 which are used under the same node x as a . 
Furthermore , we will consider only the constraints -/3 , c ~ f l /3 and a ~ /3 and not additionally the constraint a 9/3  . 
For better readability we will use pseudocode for describing this rule  ( using the usual don't care/don't know distinction for nondeterminism  ) :  ( Path Rel ) 
Choose x6 l ) arsx (?) ( don't care)
Choose xay 6? ( don't know )
For each x/3z   6 ? with c ~ #/3 and c ~ fl/3 ~? add a 6~/3 with 5Z   6   -  ,  4~ , fl ( don't know ) " don't care nondeterminism " means that one is free to choose an arbitrary alternative at this choose point  , whereas " don't know " means that one has to consider every alternative in parallel  ( i . e . for every alternative of the don't care nondeterminisma clause ? is equivalent to the set of all don't know alternatives that can be generated by applying the rule to ?  )  . Note that the order of rule application is another example for don't care nondeterminism in our rule system  . 
Although we have restricted the relations 6~ to- ,  :( , u , this rule is globally preserving since we have nondeterministically chosenzay  . To see this let ? beaclause , 27 be an interpretation and ( Vx , VT ~) be avaluation in 27 with ( Vx , V ~) ~ z ? . To find an instance of ( Path Rel ) such that ( Vx , V  ~ , ) ~ z 7 where 3' is the result of applying this instance , we choose xay 6? with V ~ ( a ) is prefix minimal in v ~@1~/3z ~? . 
Then for each x/3z   6 ? with a #/3 and ~ fi /3 ~? we add a 6~   /3 where Vp ( a ) o ~ V  ~ ( /3 ) holds . Note that 5   0 equals ~ will not occur since we have chosen a path variable a whose interpretation is prefix minimal  . Therefore , the restriction 6~6- , k , fi is satisfied . 
We have defined ( Path Rel ) in a very special way.
The reason for this is that only by using this special definition we can maintain the condition that concatenation of path variables is restricted to binary concatenation  . Eg . assume that we would have added both /31 " ~ O ~ and a : ? /32 to a clause 7  . Then first splitting up the variable a into /31 . a ' and then 132 into a . / 3~ will result in a substitution of/32 in 7   by/31"a"/3~  . By the definition of ( Path Rel ) we have ensured that this does not occur . 
The second nondeterministic rule is used in the decomposition of regular languages  . For decomposition we have the following rules : ( DecClash ) a . /3 ~ LO ? we Lll wl > 1=g_L ( Lang Decn ) a . f l ~ L ) U ? P . SCLo ~ PU/3~SU ? where P , S , LCF + and A is a finite set of reg . languages with L , P , S6A . L must contain a word w with \[ w\[>1 . 
The clash rule is needed since we require regular languages not to contain the empty path  . The remaining rules are listed in Figure 1 . 
We use A in ( LangDecA ) as a global restriction , i . e . for every A we get an different rule ( Lang DecA )   ( and hence a different rule system 7~ A )  . This is done because the rule system is quasi -terminating  . By restricting ( Lang Deca ) we can guarantee that only finitely many regular languages are produced  . 

For ( LangDec ^ ) to be globally preserving we need to find a suitable pair P  , S in A for every possibl evaluation of (~ and \]3 . Therefore , we require A to satisfy
VLEA , Vwl , w2~e:\[WlW2EL = : ~
BP , SeA : ( P . SC_LAW lEPA w2eS)\].
We will call A closed under decomposition if it satisfies this condition  . Additionally we have to ensure that LEA for every L that is contained in some clause ?  . We will call such a set AC-closed . Surely , we will not find a finite A that is closed under decomposition and C-closed for arbitrary ?  . But the next lemma states some weaker condition that suffices  . We say that 7 is a (? , Ti A ) -derivative if 7 is derivable from C by using only rules from 7~h   . If R ^ is clear from the context , we will just say that 7 is a

Lemma 4 . 2 1 . If A is C-closed and closed under intersection , then A is 7-closed for all ( C , T ~ h)-derivaLives 7 . 
2 . For every prime clause C there is a finite A such that A is C-closed and closed under intersection and decomposition  . 
The proof of this lemma ( containing the construction of the set A ) can be found in the appendix . 
4 . 2 Completeness and Quas i - Terminat ion The rule system serves for an algorithm to transform a prime clause into an equivalent set of pre-solved clauses  . The rules are applied in arbitrary order until a pre-solved clause has been derived  . If one of the nondeterministic rules is applied , a clause is substituted by a whole set of clauses  , one for each of the don't know alternatives . Since the rule system is quasi-terminating , we may encounter cycles during the application of the rules  . In this case we skip the corresponding alternative  , since every pre-solved clause that can be produced via acyclic derivation can also be produced via a derivation that does not contain a cycle  . 
Theorem 4 . 3 Let ? be a prime clause . If A is C-closed , closed under intersection and decomposition , then \[\[ C\]z = U . y ~\[\[7\] z for every interpretation Z , where ? b is the set of pre-solved ( C , T ~^)- derivatives . 
The set (9 is finite and effectively computable.
To prove this theorem we have to show that the rule system is sound and complete  . Sound means , that we do not add new solutions during the processing  , whereas complete means that we find all solutions in the set of pre-solve derivatives  . 
For the completeness it normally suffices to show that  ( 1 ) every rule preserves ( or globally preserves ) the initial solutions and ( 2 ) the pre-solved clauses are exactly the T~h -irreducible clause  ( i . e . if a clause is not pre-solved , the none rule applies ) . But in our case this is not sufficient as the rule system is quasi-terminating  . A prime clause ? may have a solution Vx which is a solution of all  ( C , T~A)-derivatives in some cyclic derivation , but cannot be found in any pre-solved (? , T ~ h)-derivative . We have to show that this cannot happen . Since this part of the proof is unusual , we will explain the main idea ( see the appendix for a more detailed outline of the proofs  )  . 
Let ? be some ( consistent ) prime clause and let VxE~?\]z for some Z . Then there exists a path valuation Vp such that ( Vx , V ~) ~ z ? . We will find a pre-solved C-derivative that has Vx as a solution by imposing an additional control that depends on V ~  ,  . 
This control will guarantee ( 1 ) finiteness of derivations ,   ( 2 ) that each derivation ends with a pre-solved clause  ,   ( 3 ) the initial solution is a solution of every clause that is derivable under this control  . Since the ( Pre ) rule does not preserve the initial path valuation V  ~  ,   ( recall that the variable fl is substituted by the term a  . ~) , we have to change the path valuation V ~ , every time ( Pre ) is applied . It is important to notice that this control is only used for proof purposes and not part of the algorithm  . For the algorithm it suffices to encounter all pre-solve de-derivatives  . 
To understand this control , we will compare derivations in our syntax to derivations in standard feature logic  . Recall that we have a two-level interpretation . A constraint xay is valid under Vx and V ~ if xV ~ ( c~ ) y is valid under Vx . Hence , for each clause ? and each valuation Vx , Vp with C valid under Vx and Vp there is a clause Cv ~ in standard feature logic syntax  ( not containing functional uncertainty ) such that ? v ~ is valid under Vx . E . g . for the clause xax , a ~ f , xflz , fl~f*g and a path valuation V ~ , with VT , ( a ) = f and V ~ , ( j3) = g the clause Cv ~ , is x fx , x g y . The control we have mentioned requires ( by and large ) that only those rewrite rules will be applied , that are compatible to the clause Cv ~ and thus preserve Vx  . If one of the rules ( Eq ) or ( Pre ) is applied , we also have to rewrite Cv ~ . Taking the above example , we are only allowed to add a lifl to C ( using ( Path Rel ) ) , since ev ~ is already in pre-solved form . 
Now let's vary the example and let Vp be a path valuation with V ~  , ( a ) = f and V ~ , ( f ~) = Hg . Then we have to add a ~/3 in the first step , since this relation holds between a and ft . The next step is to apply ( Pre ) on a : ~/3 . Here we have to rewrite both ? and Cv ~ . Hence , the new clauses ?1 and evv are xax , a ~ f , x/3z , a . /3 ~ f * g and x f x , x f g y respectively . Note that the constraint x ffgy has been reduced tox fgy by the application of  ( Pre )  . 
Since in finite derivations must infinitely often use  ( Pre )  , this control guarantees that we find a pre-solved clause that has Vx as a solution  . 
5 The Second Phase
In the second phase we have to check consistency of pre-solved clauses  . As we have mentioned , a pre-solved clause is consistent if we find some appropriate path valuation  . This means that we have to check the consistency of divergence constraints of the formal fi  a2 together with path restrictions vaid under some valuation V ~  , if there are ( possibly empty ) words w , wl , w2 and features'f~g such that V ~ , ( al ) = WfWl and V ~ , ( c~2) = wg w2 . This definition could directly be used for a rewrite rule that solves a single divergence constraint  , which gives usal fict 2U ? f  #g ,  ~ , ~12 new where ?'= ?\[ al ~--/? . a ~, a2 ~/3 . a ~\] . By the application of this rule we will get constraints of the form  j3  . a ~ ~ L1 and fl . a ~ ~ L2 . Decomposing these restriction constraints and joining the corresponding path restrictions for ~ and ~  , ~ will result in fl ~ ( PlnP2) , ~i ~( S ~ : * ns ,  )  ,   , ~( g ~'* MS2) with PI . S~CL ~ and P2 . S2C_L ~, which completes the consistency check . 
Additionally , one has to consider the effects of introducing the path terms / ~  . a  ~ . The main part of this task is to resolve constraints of the form fl  . tr  ~ litr . 
There are two possibilities : Either a has als of ~ as an prefix  , in which case we have to add f l ~ a ; or fl is not a prefix of c ~ , which means that we have to add c~flft . After doing this , the introduced prefix constraints have to be evaluated using  ( Pre )  .   ( In the appendix we present a solution which is more appropriate for proofing termination  )  . 
6 Kaplan and Maxwell's Method
We are now able to compare our method with the one used by Kaplan and Maxwell  . In our method , the nondeterministic addition of path relation and the evaluation of these relations are done at different times  . The evaluation of the introduced constraints c ~ -flando ~: ? flared one after  ( Path Rel ) in the first phase of the algorithm , whereas the evaluation of the divergence constraints is done in a separate second phase  . 
In Kaplan and Maxwell's algorithm all these steps are combined into one single rule  . Roughly , they substitute a clause xL~y , xL2z , O?non-deterministicly by one of the following clauses : ~ x  ( L~f3L~ ) y , x-yU?x(L~f3P ) y , ySzU ? P . SC_L~x(L~NP)z,zSyU?P . SCL1 x(P1 NP2) u,u(f . S1) y , u(g . S2) zU ? with PI'f'S ~ C_L ~ , P2"g'S ~ C_L ~ , f#g , u new Recall that X Lly ,   xL2z is expressed in our syntax by the clause 3' = xay , o ~ ~ L1 , x  ~ z , j ~ ~ L2 , which is the example we have used on page 2 . The first three cases correspond exactly to the result of the  2This is not the way their algorithm was originally described in  \[5\] as they use a slightly different syntax . 
Furthermore , they don't use nondeterministic rules , but use a single rule that produces a disjunction  . However , the way we describe their method seems to be more appropriate in comparing both approaches  . 
derivations that have been described for 72 , 73 and 3'4 . By and large , the last case is achieved if we first add c ~\[ I ~ to  3' and then turn over to the second phase as described in the last section  . 
The problem with Kaplan/Maxwell's algorithm is that one has to introduce a new variable u in the last case  , since there is no other possibility to express divergence  . If their rule system is applied to a cyc!ic description  , it will not terminate as the last part introduces new variables  . Hence it cannot be used for an algorithm in case of cyclic descriptions  . 
The delaying of the evaluation of divergence constraint may not only be useful when applied to cyclic feature descriptions  . As Kaplan and Maxwell pointed out , it is in general useful to postpone the consistency check for functional uncertainty  . With the algorithm we have described it is also possible to delay single parts of the evaluation of constraints containing functional uncertainty  . 
Appendix
Proof of Lemma 4 . 2 . The first claim is easy to prove . For the second claimlet L1, .   .   .   , LnCP ( ~+ ) be the set of regular languages used in ? and let  . Ai = ( Q . 4 ~, i . 4 ~, cra ~, F in . 4 ~) be finite , deterministic automatons such that . Ai recognizes Li . For each . A i w e d e f i n e d e c ( . Ai ) to be the set dee ( A /) = L~\]p , qEQJ t , , whereL ~ =  w E 2 "+ I a~ , (p , w ) = q . It is easy to show that dec( . Ai ) is a set of regular languages that contains Li and is closed under decomposition  . 
Hence , the set A0 =\ [ . Jinx dec ( Ai ) contains each Li and is closed under decomposition  . Let A =  f i ( A0 ) be the least set that contains A0 and is closed under intersection . Then A is finite and e-closed , since it contains each Li . 
We will prove that A is also closed under decomposition  . Given some LEA and a word w = wlw2EL , we have to find an appropriate decomposition P , S in A . Since each L in A can be written as a finite mL intersection L = Nk = li ~ where Lik is in  A0  , we know that w = wlw2 is in Li ~ for 1 . .m . As A0 is closed under decomposition , there are languages Pi ~ and Si ~ for k = 1 . .m with wl E Pi ~, w2 E Si ~ and Pik'Sik C Li ~ . Let P = M~n = lP ik and S = s,~ . 
Clearly , wl6P , w26S and P . SCL . Furthermore , P , S6A as A is closed under intersection . This implies that P , S is an appropriate decomposition for
WlW2.I"1
A.1 Phase I : Soundness , Completeness and

Proposition A . 1 The rule ( Path Rel ) is XU12-sound and globally XU12-preserving . If A is closed under decomposition , then ( LangDec ^ ) is XU12-sound and globally XUIJ-preserving . The ( Pre ) rule is X-sound and X-preserving . All other rules are
XU 13-sound and XU 13-preserving.

Next we will prove some syntactic properties of the clauses derivable by the rule system  . For the rest of the paper we will call clauses that a rederivable from prime clauses admissible  . 
Proposition A . 2 Every admissible clause is basic . 
Ira-~13 , o ~--\[3 or c ~ ( I13 is contained in some admissible clause ? , then there is a variable z such that zc~y and z flz is in ?  . 
Note that ( by this proposition ) ( Pre ) ( resp .   ( Eq ) ) can always be applied if a constraint c ~ 4 \[3 ( resp . 
-/3) is contained in some admissible clause . The next lemma will show that different applications of  ( Pre ) or ( Eq ) will not interact . This means the application of one of these rule to some prefix or path equality constraint will not change any other prefix or path equality constraint contained in the same clause  . This is a direct consequence of the way ( Path P~el ) was defined . 
Lemma A . 3 Given two admissible clauses 7 , 7' with 7---~ r7' and r different from ( Path Rel )  . Then c ~"-13 E 7' ( resp . ~413 E7I ) implies ~--13E7 ( resp . a:?\[3E7) . Furthermore , if a . 13 is contained in 7', then either a . flora - ~13 is contained in 7 . 
Note that this lemma implies that new path equality or prefix constraints are only introduced by  ( Path Rel )  . We can derive from this lemma some syntactic properties of admissible clauses which are needed for proving completeness and quasi-termination  . 
Lemma A . 4 If ? is an admissible clause , then 1 . If c~:<13 is contained in ? , then there is no other prefix or equality constraint in ? involving  13  . 
Furthermore , neither 13 . \[3 ~ nor 13 ~ . \[3 is contained in ? . 
e . ira . 13 fi 13' is in ? , then either 13' equals a or ? contains a constraint of form af i  t3'  , a-13' or : ~~' . 
The first property will guarantee that concatenation does not occur in prefix or equality constraints and that the length of path concatenation is restricted to  2  . The second property ensures that a constraint c ~ . 13 fi 13' is always reducible . 
Theorem A . 5 For every finite A the rule system 7~a is quasi-terminating . 
Proof . The rule system produces only finitely many different clauses since the rules introduce no additional variables or sort symbols and the set of used languages if inite  . Additionally , the length of concatenation is restricted to 2 . \[\] Lemma A . 6 There are no infinite derivations using only finitely many instances of  ( Pre )  . 
Since the rule system is quasi-terminating , the completeness proof consists of two parts . In the first part we will proof that pre-solved clauses are just their reducible clauses  . In the second part we will show that one finds for each solution Vx of a prime clause ? a pre -solve de-derivative  7 such that Vx is also a solution of 7  . 
Theorem A . 7  ( Completeness I ) Given an admissible clause ? ~ _1_ such that ? is not in pre-solved form . If A is e-closed and closed under decomposition , then ? is T~A-reducible . 
Theorem A . 8  ( Completeness II ) For every prime clause ? and for every A that is e-closed  , closed under decomposition and intersection we have 
I?\]_cUb\]z7E pre-solved(? , R ^) where pre-solved (? , R ^) is the set of pre-solved (? , RA)-derivatives . 
Proof ( Sketch ) We have to show , that for each prime clause ? and each Vx , V  ~ , Z with ( Vx , V ~) ~ z ? there is a pre-solved (? , T~A)-derivative 7 such that VxE~7\]z . We will do this by controlling derivation using the valuation  ( Vx , VT ~) . The control will guarantee finiteness of derivations and will maintain the first completeness property  , namely that their reducible clauses are exactly the pre-solved clauses  . 
We allow only those instances of the nondeterministic rules  ( Path Rel ) and ( Lang DecA )  , which preserve x actly the valuation ( Vx , V ~) . That means if ( Vx , V~)~z ? and ?--~ r7 for one of these rules , then ( Va ' , V ~) ~ z7 must hold . Note that the control depends only on VT, . E . g . for the clause ? = x c ~ y , a ~ L1 , x13 z , 13 ~ L2 and arbitray Z , Vx this means that if VT , ( a ) = f , V  ~ , (13) = g and ( Vx , VT , ) ~ z ? , the rule ( Path Rel ) can transform ? only into a h13 U ? . 
If V ~ , satisfies V ~ , ( tr ) 7~ V ~ ,   ( 13 ) for ~ different from fl with z cryE ? and 213z E ? , we cannot add any prefix constraint using this control  . Hence , ( Pre ) cannot be applied , which implies ( by lemma A . 6 ) that in this case there is no infinite controlled erivation  . We will call such path valuations prefix-free with respect o ?  . 
If V ~ , is not prefix-free , then ( Pre ) will be applied during the derivations . In this case we have to change the path valuation  , since ( Pre ) is not P-preserving . 
If ( Vx , V  ~ ) ~ z ? = ak13U ? and we apply ( Pre ) on cr -~ fl yielding 7 , the nth evaluation V ? with v ( 13 ) = and = for  #will satisfy ( Vx , pz % We will use for controlling the further derivations  . 
If we change the path valuation in this way , there will again be only finite derivations . To see this , note that every time ( Pre ) is applied and the path valuation is changed , the valuation of one variable is shortened by a nonempty path  . As the number of variables used in clauses does not increase  , this shortening can only be done finitely many times  . This implies , that ( Pre ) can only finitely often be applied under this control  . Hence ( by lemma A . 6) , there are again only finite controlled erivations  .   1:3 We will first do a minor redefinition of divergence  . 
We say that two paths u , v are directly diverging ( written uu0v ) if there are features f~g such that uEf /'* and v  6 g /'* . Then unv holds if there are a possible empty prefix w and paths u '  , v ' such that u = wu ' and v = wC and u'n0v' . 
We will reformulate the reduction of divergence constraints in order to avoid constraints of form a  . flfifl ' . Handling such constraints would make the termination proof somewhat complicated  . For the reformulation we use a special property of pre-solved clauses  , namely that a fiflis in a pre-solved clause ? iff zay and zflz is in ?  . Hence , if afi /? and ~ fidf is in ? , then a I idf is also in ? . This implies , that we can write ep as fi(At ) ~ .   .   . ~ fl(A , ) t9? , where f l ( A ) is a syntactic sugar for f i ( A ) = afia ' I a #a'A a , a '6 A , As ,   .   .   .   , An are disjoint sets of path variables and ? does not contain divergence constraints  . Note that for every Ai = al , .   .   . , a , there are variables x , Yt, .   .   . , yn such that xaty t, .   .   . , x ~ , y , C_? . Now given such that a constraint fi(A) , we assume that a whole set of path variables A1 CA diverges with the same prefixft . That means we can replace fl(At ) Cfl(A ) by
A s = f l . A ', Ofi0(A ~), where flisnew , A ~= a ~, .   .   . , a ~ is a disjoint copy of A1 = or 1, .   .   . , an and A-fi . A ~ is an abbreviation for the clause al-fl ' a  ~  ,   .   .   . , c~,-fl . a~ . 
fl0(A ) is defined similar to fl(A ) . Assuming additionally that the common prefix fl is maximal implies that flfla holds for a E  ( A-A1 )   . If we also consider the effects of A1 = fl'A'l on the subtermagreements in ? that involves variables of At  , then we result in the following rule : . A , Y x Ufi ( A ) u ( Red 1 ) xflzUzA'IY 1 Ufi0 ( A  ~ ) UI i ( flUA2 ) U ?' where ?'= ?\[ al~--fl'a ~ ,   .   .   . , a , ~ fl . a '\], AI~A2=A , IAll > 1 and z , fl new . A ~ is a disjoint copy of A1 . xAtY1 is short for zalm, .   .   . , za , y, . ? may not contain constraints of form 6 . 6 ~ Lin ? . 
Note that we have avoided constraints of the form a-fl fifit The rules  ( Reds ) fl ( A ) U % b f i 0 ( A ) U ? u ? ( so , v ) of ~#f ~ , for a  #~' together with the rules ( LangDech) ,   ( Join ) and ( Empty ) completes the rule system 7~? iv .   ( Reds ) is needed as path variables always denote nonempty paths  . We will view ( Redz ) and ( Red 2 ) as one single rule ( Reduce )  . 
A clause ~ is said to be solved if (1) a . fl ~ L and ot ~0 is not inep ; (2) a ~ L1 in ep and a ~ L ~ inepimplies Lz = L2 ;   ( 3 ) ? does not contain constraints of form a flfl , aIi0fl , oL : < fl , or a-"fl ; and (4) for every xay , z/~z_C ~ with a ?/? there are features f  #g with a ~ fLs  , fl~gL2_C ? . It is easy to see that every solved clause is consistent  . Note that every solved clause is also prime . 
Lemma A . 9 The rules ( Reduce )  =  ( Redt )  +  ( Reds ) and ( Solv ) are X-sound and globally X-preserving . Furthermore , 7~s?lvisterminating . 
Lemma A . 10 Let ? be a pre-soived clause . If Aise-closed , closed under intersection and decomposition , then a (? , TiS ? lv ) -derivative different from 1 is irreducible if and only if it is solved . 
Finally we can combine both phases of the algorithm  . 
Theorem A . 11 Consistency of prime clauses is decidable . 
References\[1\]F . Baader , H . -J . Bfirckert , B . Nebel , W . Nutt , and G . Smolka . On the expressivity of feature logics with negation  , functional uncertainity , and sort equations . Research Report RR-91-01, DFKI , 1991 . 
\[2\]R . Backofen . Regular path expressions in feature logic . Research Report RR-93-17, DFKI , 1993 . 
\[3\]R . Backofen and G . Smolka . A complete and recur-sire feature theory . In Proc . of the 31th ACL , 1993 . 
this volume.
\[4\]N . Dershowitz . Termination of rewriting . Journal of Symbolic Computation , 3:69-116, 1987 . 
\[5\]R . M . Kaplan and J . T . Maxwell III . An algorithm for functional uncertainty . In Proc . of the 12th COLING , pages 297-302 , Budapest , Hungary ,  1988 . 
\[6\]R . M . Kaplan and A . Zaenen . Functional uncertainty and functional precedence in continental west germanic  . In H . Trost , editor ,  4-  ( gsterreichische Artificial-lnteiligence-Tagung : Wiener Workshop-Wissens basierte Sprachverarbeitung  , pages 114-123 . 
Springer , Berlin , Heidelberg , 1988.
\[7\] R . M . Kaplan and A . Zaenen . Long-distance dependencies , constituent structure , and functional uncertainty . In M . Baltin and A . Kroch , editors , Alternative Conceptions of Phrase Structure . University of
Chicago Press , Chicago , 1988.
\[8\]B . Keller . Feature logics , in finitary descriptions and the logical treatment of grammar  . Cognitive Science Research Report 205 , Univerity of Sussex , School of Cognitive and Computing Sciences ,  1991 . 
\[9\]G . Smolka . A feature logic with subsorts . LILOG-Report 33 , IBM Deutschland , Stuttgart ,  1988 . 
\[10\]G . Smolka . Feature constraint logics for unification grammars  . Journal of Logic Programming , 12:51-87, 1992 . 
\[11\]G . Smolka and R . Treinen . Records for logic programming . In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming  , pages 240-254 , Washington , DC ,  1992 . 

