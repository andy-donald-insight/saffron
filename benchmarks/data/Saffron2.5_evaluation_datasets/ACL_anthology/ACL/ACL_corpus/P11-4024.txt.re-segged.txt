Proceedings of the ACL-HLT 2011 System Demonstrations , pages 139?144,
Portland , Oregon , USA , 21 June 2011. c?2011 Association for Computational Linguistics
An Interface for Rapid Natural Language Processing Development in UIMA Balaji R . Soundrarajan , Thomas Ginter , Scott L . DuVall VA Salt Lake City Health Care System and University of Utah balaji@cs.utah.edu , { thomas.ginter , scott.duvall}@utah.edu Abstract
This demonstration presents the Annotation Librarian , an application programming interface that supports rapid development of natural language processing ( NLP ) projects built in Apache Unstructured Information Management Architecture ( UIMA ). The flexibility of UIMA to support all types of unstructured data ? images , audio , and text ? increases the complexity of some of the most common NLP development tasks . The Annotation Librarian interface handles these common functions and allows the creation and management of annotations by mirroring Java methods used to manipulate Strings . The familiar syntax and NLP-centric design allows developers to adopt and rapidly develop NLP algorithms in UIMA . The general functionality of the interface is described in relation to the use cases that necessitated its creation . 1 Introduction In the days when public libraries were the center of information exchange , the job of the librarian was to serve as an interface between the complex library system and the average user . The librarian made it possible for one to access specific sources of information without memorizing the Dewey Decimal System or flipping through the card catalog . Analogous to the great librarians of yesteryear , the Annotation Librarian serves the average Java developer in the creation and management of annotations within natural language processing ( NLP ) projects built using the open source Apache Unstructured Information Management Architecture ( UIMA)1. Many NLP tasks are performed in processing steps that build upon one another . Systems designed in this fashion are called pipelines because 1 Apache UIMA is available from http://uima.apache.org/
text is processed and then passed from one step to the next like water flowing through a pipe . Each step in the pipeline adds structured data on top of the text called annotations . An annotation can be as simple as a classification of a span of text or complex with attributes and mappings to coded values . As pipeline systems have caught on , the ability to standardize functionality in and even across pipelines has emerged . UIMA provides a powerful infrastructure for the storage , transport , and retrieval of document and annotation knowledge accumulated in NLP pipeline systems ( Ferrucci 2004). UIMA provides tools that allow testing and visualizing system results , integration with Eclipse2, and use of standard XML description files for maintainability and interoperability . Because UIMA provides the underlying data model for storing metadata and annotations with document text and the interface for interacting between processing steps , it has become a popular platform for the development of reusable NLP systems ( D?Avolio 2010, Coden 2009, Savova 2008). The most notable example of UIMA capabilities is Watson , the question-answering system that competed and won two Jeopardy ! matches against the all-time-winning human champions ( Ferrucci 2010). In addition to its successful implementations in NLP , UIMA supports all types of unstructured information ? video , audio , images , etc ? and so all UIMA constructs generalize beyond text . While handling multiple data types increases the utility of the framework , developers new to UIMA may feel they need to understand the entire framework before being able to distinguish and focus solely on text . The Annotation Librarian aids both novice and experienced UIMA developers by providing intuitive and NLP-centric functionality.
2 Eclipse Development Platform is available from http://www.eclipse.org cation techniques . Identifying mentions of prescriptions in a document using regular expressions , for example , would require hundreds of thousands of patterns for names of medicines and have to account for misspelling , abbreviations , and acronyms . Regular expressions are commonly used to solve simple NLP tasks , though , and can be utilized as part of a more complex information extraction strategy , such as understanding the context in which a term is used in the text ( Garvin 2011, McCrae 2008, Frenz 2007, Chapman 2001). Negex ( Chapman 2001) is an algorithm for identifying words before or after a term that suggest , for example , that a particular symptom is not present in a patient : ? the patient has no fever .? Other methods for understanding the context around terms include the use of an inclusion and exclusion list ( Akbar 2009), temporal locality search ( Grouin 2009), window search ( Li 2009), and combinations of the above techniques ( Hamon 2009). The Annotation Librarian allows patterns to be built using existing annotations along with document text . This functionality combines the power of finding concepts that require complex means with the simplicity of regular expressions . The syntax mirrors that of the Java Pattern3 and Matcher4 classes , but allows for an extended regular expression grammar to identify Annotations . Pattern matching is accomplished in three phases : the input pattern is compiled , the document and annotations are analyzed for matches , and matches are returned along with span information . A project identifying positive microbiology cultures will illustrate the use of pattern matching with the Annotation Librarian . Clinicians order microbiology cultures to determine whether a patient has a bacterial infection and which antibiotics would be most effective at treating the infection . Susceptibility is the measure of whether an antibiotic can effectively treat an organism or whether the organism is resistant to it . A sample of microbiology report text is shown in Figure 1 and visualized annotations for the same sample are shown in Figure 2. 3 Documented at http://download.oracle.com/javase/6/docs/api/java/util/regex / Pattern.html 4 Documented at http://download.oracle.com/javase/6/docs/api/java/util/regex / Matcher.html Figure 2: Annotated Report To demonstrate pattern matching in this sample , the simple pattern of a drug annotation followed by an equals sign and then by a susceptibility annotation will be used . 3.1 Pattern Compilation The pattern matching process begins when a new instance of an AnnotationPattern is created from the static compile method . AnnotationPattern is analogous to the Java Pattern3 class . AnnotationPattern susceptibilityPattern = AnnotationPattern.compile(?pattern ?); The method takes advantage of the UIMA implementation of annotations . Each annotation is an instance of a class that inherits from the UIMA class Annotation5. UIMA allows developers to create new types of annotations ( in this example Organism , Antibiotic , and Susceptibility ) that become Java classes.
5 Documented at http://uima.apache.org/d/uimaj-2.3.1/api/index.html The compile method input string pattern uses XML tags to represent Annotation classes and tag attributes to denote the name of method calls and return values in the format of : < AnnotationClass methodName=?expected value ? /> When the extra constraint of matching on some method return values is not needed , the tag attribute is left blank . Portions of the pattern that are not contained in XML tags are compiled as Java regular expressions . For our example , the input pattern would be : < Antibiotic /> = < Susceptibility /> or further constrained as : < Antibiotic getMedName=?ciprofloxacin ? /> = < Susceptibility getValue=?S ? /> which would only match if the particular medication ( ciprofloxacin ) and susceptibility ( S ) matched as well . The pattern is converted into a finite state machine ( FSM ) in a process described by Fegaras (2005). With our pattern , a four-state FSM would be generated . To arrive in State 1, an Antibiotic annotation must match . To arrive in State 2, a regular expression for ?=? must match . The Final State is reached when a matching Susceptibility annotation is found . Any other input would result in a transition back to the Start State.
Figure 3: FSM for Antibiotic Susceptibility 3.2 Match Analysis The second phase of pattern matching processes the document text and annotation set to determine if any matches can be found . This phase is triggered by a call to the static matcher method that returns a new instance of an AnnotationMatcher object . AnnotationMatcher is analogous to the Java Matcher4 class . AnnotationMatcher suscMatcher = susceptibilityPattern.matcher(cas ); This phase just checks to ensure that each annotation type has at least one instance in the document . Otherwise , a pattern match is not possible . Here , the cas parameter refers to the UIMA Because ? systolic function ? can be used to report ejection fraction , but only when referring to the left side of the heart , it was important to retrieve the section annotations and check the header.
Figure 4: Annotated Echocardiogram Report 5 Annotation Modification The annotation modification methods allow previous annotations to be altered by trimming whitespace and removing punctuation . While these are trivial tasks performed on Java Strings , an annotation is just a pointer to the text . Updating the annotation with the correct character span requires understanding of UIMA functions and can introduce errors if not done carefully . The Annotation Librarian ensures accuracy by handling these tasks with straightforward programmatic calls . trim ( Annotation annotation ) removePunctuation ( Annotation annotation ) Identifying the organisms from the microbiology reports relied on splitting template text . The project described in Section 3 for pattern matching utilized the Annotation Librarian functionality to clean up spurious characters and whitespace included in annotations . 6 Span Overlap This set of methods describes how annotations relate to each other spatially by answering questions such as : Does one annotation completely contain the other ? Do the annotations overlap in the text ? Do they both cover the same span of text ? overlaps ( Annotation a1, Annotation a2 ) contains ( Annotation a1, Annotation a2 ) coversSameSpan ( Annotation a1, Annotation a2 ) Figure 5: Medication Extraction Use Case 7 Relative Position The relative position methods allow developers to access annotations based on their position in the text to each other . These methods can determine the next or previous adjacent annotation or the text that exists between two annotations . Often , a task required determining which concepts were found in the same sentence or finding all concepts in a certain section . Methods in this set provide functionality to find annotations that covering the span of another annotations or all annotations contained within the span of another annotation . getContainingAnnotations ( Annotation a1 ) getNextClosest ( Annotation a1 ) getPreviousClosest ( Annotation a1 ) getTextBetween ( Annotation a1, Annotation a2 ) As part of a project to determine coreference in disease outbreak reports , the ability to determine relative position facilitated coreference resolution . It was also necessary to determine relationships between certain types of annotations from the window of the text . The Annotation Librarian simplified the task of determining colocation by providing the functionality within a single method call . Text between two Annotation objects was similarly identified with a single method call.
Figure 6: Disease Outbreak Reports Use Case 8 Conclusion The Annotation Librarian was developed and modified over a number of different NLP use cases . Because of the diversity of tasks in each of these use cases , the toolkit includes functionality common to various types of NLP system development . It includes over two-dozen functions that were used more than one hundred times in each of the four systems listed above . Use of this interface reduced the amount of repeated code ; it simplified common tasks , and provided an intuitive interface for NLP-centric annotation management without requiring the presence of an NLP developer who has intimate knowledge of the UIMA data structure . The extended capability provided by the pattern matching methods allows system developers to capitalize on the pipeline approach to NLP development in determining patterns . The ability to use annotations along with text significantly increases the types of patterns that can be identified without complex regular expressions . 9 Future Plans The Annotation Librarian has been enhanced over the course of a number of biomedical NLP use cases and we plan to continue to enhance the interface as new use cases arise . Some planned enhancements include performance improvements and expanding the AnnotationPattern input pattern syntax to include regular expressions for method return values and annotation class names . We plan to provide additional functionality such as pattern frequency counts . We see the ability for the Annotation Librarian to help identify patterns through active learning or based clinical information extraction system . LREC 2008: Towards enhanced interoperability for large HLT systems : UIMA for NLP . Jennifer H . Garvin , Brett R . South , Dan Bolton , Shuying Shen , Scott L . DuVall , Bruce Bray , Paul Hei-denreich , Matthew H . Samore , and Mary K . Goldstein . 2011. Automated Extraction of Ejection Fraction ( EF ) for Heart Failure ( HF ) from VA Echocardiogram Reports . Department of Veterans Affairs Health Services Research and Development National Meeting . 2011 Feb 16. John McCrae , Nigel Collier . 2008. Synonym set extraction from the biomedical literature by lexical pattern discovery . BMC Bioinformatics . 2008 Mar 24;9:159. Leonard W . D'Avolio , Thien M . Nguyen , Wildon R . Farwell , Yong Chen , Felicia Fitzmeyer , Owen M . Harris , Louis D . Fiore . 2010. Evaluation of a generalizable approach to clinical information retrieval using the automated retrieval console ( ARC ). J Am Med Inform Assoc . 2010 Jul-Aug;17(4):375-82. Leonidas Fegaras . 2005. Converting a Regular Expression into a Deterministic Finite Automaton . http://lambda.uta.edu/cse5317/notes/node9.html . Pulled February 2011. Saiful Akbar , Thomas Brox R?st , Laura Slaughter , and ? ystein Nytr ?. 2009. Extracting Medication Information from Patient Discharge Summaries . i2b2 Workshop in conjunction with the AMIA Annual Symposium , San Francisco , CA ; November 13, 2009. Thierry Hamon and Natalia Grabar . 2009 . Concurrent linguistic annotations for identifying medication names and the related information in discharge summaries . i2b2 Workshop in conjunction with the AMIA Annual Symposium , San Francisco , CA ; November 13, 2009. Wendy W . Chapman , Will Bridewell , Paul Hanbury , Gregory F . Cooper , and Bruce G . Buchanan . 2001. A Simple Algorithm for Identifying Negated Findings and Diseases in Discharge Summaries . Chapman WW , Bridewell W , Hanbury P , Cooper GF , Buchanan BG . J Biomed Inform . 2001 Oct;34(5):301-10. Zuofeng Li , Yonggang Cao , Lamont Antieau , Shashank Agarwal , Qing Zhang , and Hong Yu . 2009. Extracting Medication Information from Patient Discharge Summaries . i2b2 Workshop in conjunction with the AMIA Annual Symposium , San Francisco , CA ; November 13, 2009.
144
