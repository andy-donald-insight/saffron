A Unification Method for Disjunctive Feature Descriptions 
Robert T . Kasper
USC/Information Sciences Institute
4676 Admiralty Way , Suite 1001
Marina del Rey , CA 90292

Electrical Engineering and Computer Science Department 
University of Michigan
Abstract
Although disjunction has been used in several unification-based grammar formalisms  , existing methods of unification have been unsatisfactory for descriptions containing large quantities of disjunction  , because they require exponential time . This paper describes a method of unification by successive approximation  , resulting in better average performance . 
1 Introduction
Disjunction has been used in sever Munlfication -based grammar formalisms to represent alternative structures in descriptions of constituents  . Disjunction is an essential component of grammatical descriptions in Kay's Functional Unification Grammar  \[6\]  , and it has been proposed by Karttunen as a Linguistically motivated extension to PATR-II  \[2\]  . 
In previous work two methods have been used to handle disjunctive descriptions in parsing and other computational applications  . 
The first method requires expanding descriptions to dis-\]unctl've normal form  ( DNF ) so that the entire description can be interpreted as a set of structures  , each of which contains no disjunction . This method is exemplified by Definite Clause Grammar  \[8\]  , which eliminates disjunctive terms by expanding each rule containing disjunction into alternative rules  . It is also the method used by Kay \[7\] in parsing FUG . 
This method works reasonably well for small grammars  , but it is clearly unsatisfactory for descriptions containing more than a small number of disjunctions  , because the DNF expansion requires an amount of space which is exponential in the number of disjunctions  . 
The second method , developed by Karttunen\[2\] , uses constraints on dlsjuncts which must be checked whenever a die-junct is modified  . Kart tunen's method is only applicable to value disjunctions  ( i . e . those disjunctions used to specify the value of a single feature  )  , and it becomes complicated and inefficient when disjuncts contain nonlocal dependencies  ( i . e . 
values specified by path expressions denoting another feature  )  . 
In previous research \[4 , 5\] we have shown how descriptions of feature structures can be represented by a certain type of logical formula  , and that the consistency problem for disjunctive descriptions is NP-complete  . This result indicates , according to the widely accepted mathematical assumption that P~NP  , that any complete unification algorithm for disjunctive descriptions wiU require exponential time in the worst case  . However , this result does not preclude algorithms with better average performance  , such as the method described in the remainder of this paper  . This method overcomes the shortcomings of previously existing methods  , and has the following desirable properties : 1 . It appUes to descriptions containing general disjunction and nonlocal path expressions  ;  2 . It delays expansion to DNF ; 3 . It can take advantage of fast unification algorithms for non-disjunctive directed graph structures  . 
2 Data Structures
The most common unification methods for non -disjunctive feature structures use a directed graph  ( DG ) representation , in which arcs are labeled by names of features , and nodes correspond to values of features . For an introduction to these methods , the reader is referred to Shieber's survey \[11 I . In the remainder of this section we will define a data structure for disjunctive descriptions  , using DG structures as a basic component . 
In the following exposition , we will carefully observe the distinction between feature structures and their descriptions  , as explained in \[4\] . Feature structures will be represented by DGs , and descriptions of feature structures will be represented by logical formulas of the type described in  \[4 I . The
TOP~<Px > , .   .   .   , < P , ~ >! ~^?  , / , V ? , denoting no information ; denoting in co~istent information ; where a EA , to describe atomic values ; where lEL and ~ EFDL , to describe structures in which the feature labeled by I has a value described by ~  ; where each pCEL ? , to describe an equivalence class of paths sharing a common value in a feature structure  ; where @ , ? EFDL ; where @ , ? EFDL . 
Figure I : Syntax of FDL Formulas.
syntax for formulas of this feature description logic  ( hereafter called FDL ) is given in Figure 1 . IN ote , in particular , that disjunction is used in descriptions of feature structures  , but not in the structures themselves . 
As we have shown ( see\[9\] ) that there is a unique minimal satisfying DG structure for any nondisjunctive FDL formula  , we can represent the parts of a formula which do not contain any disjunction by DGs  . DGs are a more compact way of representing the same information that is contained in a FDL formula  , provided the formula contains no disjunction . 
Let us define an unconditional conjunct obea conjunct of a formula which contains no occurrences of disjunction  . 
After path expansion any formula can be put into the form : u co~j^disj ~ A  .   .   . Adisy , , , where u conj contains no occurrences of disjunction  , and each disj ? , for 1~i ~ m , is a disjunction of two or more alternatives . The , ~ conj part of the formula is formed by using the commutative law to bring all unconditional conjuncts of the formula together at the front  . Of course , there may be noun conditional conjuncts in a formula  , in which case u coaj would be the formula NIL . 
Each disjunct may be any type of formula , so disjuncts can also be put into a similar form , with a Llun conditional conjuncts grouped together before all disjunctive components  . 
Thus the disjunctions of a formula can be put into the form  ( ~ conj ~^ disA ~^ .   .   . ^ d is A , ) v .   .   . v(uconj , , ^ disj , , ~^ .   .   . ^ d l s j , , ) . 
The embedding of conjuncts within disjuncts is preserved  , but the order of conjuncts may be changed . 
The unconditional conjuncts of a formula contain information that is more definite than the information contained in disjunctions  . Thus a formula can be regarded as having a definite part  , containing only unconditional conjuncts , and an indefinite part , containing a set of disjunctions . The definite part contains no disjunction , and therefore it may be represented by a DG structure  . To encode these parts of a formula , let us define a feature-description as a type of data structure  , having two components : ILetA and L be sets of symbols which are used to denote atomic values and feature labels  , respectively . 
Figure 2: AND/OR graph representation of a feature description  . 
defl , nte:a DG structure ; indefinite : a SET of disjunctions , where each disjunction is a SET of feature . descriptlon . s . 
It is poesibh to convert any FDL formula into a feature-description structure by a simple automatic procedure  , a . s described in \[5\] . This conversion does not add or subtract any information from a formula  , nor increase its size in any significant way . It simply identifies components of the formula which may be converted into a more el ~ cient representation as DG structures  . 
A feature-descriptlon is conceptually equivalent to a special kind of AND/OR graph  , in which the terminal nodes are represented by DG structures  . For example , an AND/OR graph equivalent to the formula ,  4 , 0^(?1v , / , 2) ^ (~ , 3 v?4v(Ca^(?ov?7))) is shown in Figure 2 . In the AND/OR graph represent a-tl on , each AND-node represents a feature-description . The first outgoing arc from an AND-node represents the definite component of a feature -description  , ad the remaining out go-Lugarcs represent the indefinite component  , Each OR-node represents a disjunction . 

Function I/N\]FY-DES C(f , g ) Returns feature . description : where f and g are feature -descriptions  . 
I . Unify definite components.
Let new-def=UNIFY-DGS(f . definite , g . definite) . 
If new-def = TOP , then return ( failure).
Let desc = a feature-description with : desc . definite=new-def , desc . indefinite=f . indefinite tdg . indefinite . 
If desc.in definite = $,
Then return ( desc);
Else begin ; 2 . Check compatibility of indefinite components with new-def  . 
Let new-desc = CHECK-INDEF(desc , new-def).
If new-desc = failure , then return ( failure ); 3 . Complete ez hat ~ tiv ? consistency checking , if necessary . 
Else if new-desc.in definite=$
OR if complete checking is not required,
Then return ( new-desc);
Elsebegin;
Let n = 1.
Repeat while n < cardinallty of new-desc . indefinite:new-desc := NWISE-CONSISTENCY ( new-desc , n ) . 
n := n + l.
return ( new-desc).


Figure 3: Unification algorithm for feature-descriptions . 
3 The Algorithm : Unification by Successive Approximation In this section we will give a complete algorithm for unifying two feature  . descriptions , where one or both may contain disjunction . This algorithm is designed so that it can be used as a relatively efficient approximation method  , with an optional step to perform complete consistency checking when necessary  . 
Given two feature-descriptions , the strategy of the unification algorithm is to unify the definite components of the descriptions first  , and examine the compatibility of indefinite components later  . Disjuncts are eliminated from the description when they are inconsistent with definite information  . This strategy avoids exploring dlsjuncts more than once when they are inconsistent with definite information  . 
The exact algorithm is described in Figure 3 . It has three major steps . 
In the first step , the definite components of the two descriptions are unified together  , producing a DG structure , new-def , which represents he definite information of the result  . This step can be performed by existing unification algorithms for DGs  . 
In the second step , the indefinite components of both descriptions are checked for compatibility with new-def  , using the function CHECK-INDEF , which is defined in Figure 4 . 
CHECK-IN\]DEF uses the function CHECK-DISJ , defined in Figure 5 , to check the compatibility of each disjunction with the DG structure given by the parameter con & The compatibility of two DGs can be checked by almos the same procedure as unification  , but the two structures being checked are not actually merged as they are in unification  . 
In the third major step , if any disjunctions remain , and it is necessary to do so , disjuncts of different disjunctions are considered in groups  , to check whether they are compatible together . This step is performed by the function NWISE-
CONSISTENCY , defined in Figure 6.
When the parameter r ~ t o N WISE , -CONSISTENCY has the value 1 , then one disjunct is checked for compatibility with all other disjunctions of the description in a pairwise manner  . The pairwise manner of checking compatibility can be generalized to groups of any size by increasing the value of the parameter n  . 
While this third step of the algorithm is necessary in order to insure consistency of disjunctive descriptions  , it is not necessary to use it every time a description is built during a parse  . In practice , we find that the performance of the algorithm can be tuned by using this step only at strategic points during a parse  , since it is the most inefficient step of the al -where deac is a feature-description  , and cond is a DG . 
Let in def = desc . indeflnite ( a set of disjunctions ) . 
Let new-def = desc . deflnite(aDG).
Let unchecked-parts ~ true.
While unchecked-parts , begin ; unchecked-parts := false . 
Let new-indef = ~.
For each disjune tiort in in def."
Let compatible-disjuncts = CHECK-DISJ ( disjunction , cond ) . 
If cardinality of compatible-disjuncts is: 0 : Return ( failure )  ;   1 : Let disjunct----single element of compatible -disjuncts  . 
new-def:---UNIFY-DGS(new-def , disjunct . deflnite) . 
new oindef:=new-indeftJ disjunct.indefl nite.
unchecked-parts := true ; otherwise : new-indef:ffine wo indef U compatible-disjunct a  . 
Prepare to check remaining disjunctions for compatibility with new-def  . 
cond := new-def.
in def:~new-indef.
end ( while loop).
Let newodes c~=make feature-description with : new-desc  . deflnite----new-def , new . desc . indeflnite----new-indef . 
Return ( new-desc).
Figure 4: Algorithm to check compatibility of indefinite parts of feature-descriptions with respect to a condition DG  . 
Function CHECK-DISJ(disj , cord )   Return8 disjunction : where disj is a disjunction of feature-descriptions  , and cond is a DG . 
Let new-disj = 0 ( a set of feature-descriptions).
For each disjunct in disj :
If DGS-COMPATIBLE ? ( cond , disjunct . definite),
Then if disjunct . indeflnite = $,
Then new-disj := new-disj t9 disjunct;
Elsebegin;
Let new-disjunct : CHECK-INDEF ( disjunct , cond ) . 
If new-disjunct ~ failure , then begin ; new-disj := new-disjt 9 new-dlsjunct . 


Return ( new-disj).
Figure 5: Algorithm to check compatibility of dis junctions with respect to a condition DG  . 

Funetlon NWISE-CONSISTENCY(desc , n ) Returns feature-description : where desc is a feature-description  . 
If number of disjunctions in desc.in definite_<n,
Then Return ( desc).
Let def = desc . definite.
Let in def = desc . in definite.
Let new-indef = ~.
While disiunctions remain in indef:Let di siunction ---- remove one disjunction from indef  . 
Let new-disj = ~.
For each dlsjuTtct in disjunction : Let dis junct-def----UNIFY-DGS  ( def , disiunct . definite ) . 
Let disjunct-indef----disjunet . indefinite U in defUnew-indef . 
Let hyp-desc = make feature-description with : hyp-desc  . definite=disjunct-def , hyp-desc . in definite----disiun et-indef . 
If n = 1,
Then let new-desc = CHECK-INDEF ( hyp-desc , disjunct-def ) . 
Elselet new-desc = NWISE-CONSISTENCY(hyp-desc , n-l ) . 
If new-desc ~ failure,
Then new-disj := new-disjt J(new-desc.
If cardinality of new-disj is:
O : Return ( failure) ; 1: Let new-desc=single element of new-disj . 
def:=new-desc.de finite.
indef := new-dese.in definite.
new-indef := ? ; otherwise: ( keep this disjunction in result ) new-indef := new-indefUnew-disj . 
Let result-desc = make feature-descript i on with : result-desc  . definite = def , result-desc . indefinite=new-indef . 
Return ( result-desc).
Figure 6: Algorithm to check compatibility of dis junctions of a description by checking groups of n disjunctions  . 
gorithm . In our application , using the Earley chart parsing method , it has proved best to use NWISE-CONSISTENCY only when building descriptions for complet edges  , but not when building descriptions for active edges  . 
Note that two feature-descriptions do not become permanently linked when they are unified  , unlike unification for DG stuctures . The result of unifying two descriptions i a new description  , which is satisfied by the intersection of the sets of structures that satisfy the two given descriptions  . The new descriptlon contains all the information that is contained in either of the given descriptions  , ubtracting any disjuncts which are no longer compatible  . 
4 An example
In order to illustrate the effect of each step of the algorithm  , let us consider an example of unifying the description of a known constituent with the description of a portion of a grammar  . This exemplifies the predominant type of structure building operationeeded in a parsing program for Functional Unification Grammar  . The example given here is deliberately simple , in order to illustrate how the algorithm works with a minimum amount of detail  . It is not intended as an example of a linguistically motivated grammar  . 
Let us trace what happens when the two descriptions of Figure  7 are given as inputs to the function UNIFY-DESC . 
Figure 8 shows the feature-description which results after step  1 of the algorithm . The definite components of the two descriptions have been unified  , and their indefinite components have been conjoined together  . 
In step 2 of the algorithm each of the disjuncts of DESC . INDEFINITE is checked for compatibility with DESC . DEFINITE , using the function CHECK-IN'DEF . In this case , all disjuncts are compatible with the definite information  , except for one ; the disjunct of the third disjunction which contains the feature Number : Sing  . This disjunct is eliminated , and the only remaining disjunct in the disjunction  ( i . e . , the disjunct containing Number : PI ) is unified with DESC . DEFINITE . The result after this step is shown in Figure 9 . The four disjuncts that remain are numbered for convenience  . 
In step 3 , NWISE-CONSISTENCY is used with 1 as the value of the parameter n . A new description is hypothesized by unifying disjunct  ( 1 ) with the definite component of the description ( i . e . , NEW-DESC . DEFINITE ) . Then disjuncts ( 3 ) and ( 4 ) are checked for compatibility with this hypothesized structure :  ( 3 ) is not compatible , because the values of the Transitivity features do not unify  . Disjunct (4) is also incompatible , because it has Goal : Person:3 , and the hy-
DEFINITE=\[Rank:Clause\]
Sub\]:Caes:Nora
INDEFINITE = (  \[  Yo4ca : Paa ~ dus Transitivity : Trana ~< Sub\]> , < Goal >\]
Traneitlvity : Intran $
Actor : Person:3
Number : Sing
Sub\]:Number:Sing
V %
V ' I
Vo ~ cs : Actiu , , ~< Sub \] >, < Actor > ! J
Goal : Pereon:3
Number : Pl\]
S~\]:Number : Pl
SUBJECTCONSTITUENT :
Lez : y ' all \]
DEFINITE=Sub\]:Person:2
Number : Pl
INDEFINITE=NIL
Figure 7: Two descriptions to be unified.
pothesize description has ~< Sub\]> , < Goal > l , along with Sub\]:Person:2 . Therefore , since there is no compatibled ls junct among ( 3 ) and ( 4 )  , the hypothesis that ( 1 ) is compatible with the rest of the description has been shown to be invalid  , and (1) can be eliminated . It follows that disjunct ( 2 ) should be unified with the definite part of the description  . Now disjuncts ( 3 ) and ( 4 ) are checked for compatibility with the definite component of the new description :  ( 3 ) is no longer compatible , but (4) is compatible . Therefore , (3) lseliminated , and (4) is unified with the definite information . 
No disjunctions remain in the result , as shown in Figure 10 . 
5 Complexity of the Algorithm
Referring to Figure 3 , note that the function LrNIF ?- DESC may terminate after any of the three major steps  . After each step it may detect inconsistency between the two descriptions and terminate  , returning failure , or it may terminate because no disjunctions remain in the descrlption  . Therefore , it is useful to examine the complexity of each of the three steps independently  . 
Let n represent the total number of symbols in the combined description f^g  , and d represent he total number of disjuncts ( in both toplevel and embedded is junctions ) contained in fAg . 
Step I . This step performs the unification of two DG structures  . Ait-Kaci \[11 has shown how this operation can be performed in almost linear time by the UNION/FIND algorithm  . 
Its time complexity has an upper bound of O ( n log n )  . Since an unknown amount of a description may be contained in the definite component  , this step of the algorithm also requires
O(n logn ) time.
Slop ~ . For this step we examine the complexity of the function CHECK-INDEF  . There are two nested loops in CHECK-INDEF , each of which may be executed at most once for each disjunct in the description  . The inner loop checks the compatibility of two DG structures  , which requires no more time than unification . Thus , in the worst case , CHECK-
INDEF requires O(d2n logn ) time.
Step 8 . NWISE-CONSISTENCY requires at most 0(2~/~) time . In this step , NWISE-CONSISTENCY is called at most ( d/2 ) -1 times . Therefore , the overall complexity of step 30(2"/2) . 
Discussion . While the worst case complexity of the entire algorithm i  ,  0(2~) , an exponential , it is significant hatit often terminates before step  3  , even when a large number of dlsjunct lons are present in one of the descriptions  . Thus , in many practical cases the actual cost of the algorithm is bounded by a polynomial that is at most  d2n log n . Since must be less than n , this complexity function is almost cubic . 
Even when step 3 must be used , the number of remaining disjunctions is often much fewer than  d/2  , so the exponent i , usually a small number . The algorithm performs well in most cases , because the three steps are ordered in increasing complexity  , and the number of disjunctions can only decrease during unification  . 
6 Implementation
The algorithm presented in the previous sections has been implemented and tested as part of a general parsing method for Systemic Functional Grammar  , which is described in 13\] . The algorithm was integrated with the structure building module of the PATR-II system  \[10\]  , written in the Zetalisp programming language . 
While the feature-description corresponding to a grammar may have hundreds of disjunctions  , the descriptions that result from parsing a sentence usually have only a small number of disjunctions  , if any at all . Most disjunctions in a systemic grammar represent possible alternative values that some particular feature may have  ( along with the grammatical consequences entailed by choosing particular values for the feature  )  . In the analysis of a particular sentence most features have a unique value  , and some features are not present at all . 
When disjunction remains in the description of a sentence after parsing  , it usually represents ambiguity or an underspecified part of the grammar  . 
With this implementation of the algorithm , sentences of up to I0 words have been parsed correctly , using a grammar which contains over 300 disjunctions . The time required for most sentences is in the range of  10 to 300 seconds , running on lisp machine hardware . 
The fact that sentences can be parsed at all with a grammar containing this many disjunctions indicates that the algorithm is performing much better than its theoretical worst case time of O  ( 2d )  . 2 The timings , shown in Table 1 , obtained from the experimental parser for systemic grammar also indicate that a dramatic increase in the number of disjunctions in the grammar does not result in an exponential increase in parse time  . Gos is a grammar containing 98 disjunctions , 2 Consider , 2300 ~2 s ? , and 2 s ? is taken to be a rough estimate of the number of particles in the universe  . 

DES C . DEFINITE =
Rank : Clause
Case : Nora
Lee : y ' all
Sub\]:Person:2
Number : Pl
DESC . INDEFINI . TE =
Voice : Passive
Transitivity : Trans\[<Sub\]> , < Goal >\]
Transitivity : In trans
Actor : Person:3
Number : Sing
Sub\]:Number:SingvE1)\[<Sub\]> , < Actor>\]\[Transitivity:Transt )
V Goal : Person: 3 \[Number:Pl\]?Sub\]:Number:Pl Figure 8: UNIFY-DESC : After step 1   ( UNIFY-DGS )  . 
NEW-DES C . DEFINITE =
Rank : Clause
Case : Nora
Lee : y ' all
Sub\]:Person:2
Number : PI
Number : PI
NEW-DESC . INDEFINITE =
Voice : Passive ( 1 ) Transitivity : Trans\[<Sub\]> , < Goal >\]
Transitivity : In trans ( 3 ) Actor : Person:3
Voice:Active\])v(2)~<Suby >, < Actor >\]
V(4) Goal : Person:3
Figure 9: UNIFY-DESC : After step 2 ( CHECK-INDEF) . 
Rank : Clause
Case : Nora
Lee : y ' all
Sub\]:Person:2
NEW-DES C . DEFINITE = Number : Pl
Number : Pl
Voice : Active\[<Subj >, < Actor >\]
Transitivity : Trans
Goal : Person:3
NEW-DESC . INDEFINITE=NIL
Figure 10: UNIFY-DESC : After step 3 ( NWISE-CONSISTENCY )  . 

Sentence GosG 44o
Nigel has been speaking English .  22 . 9 144" . 3 Nigel has been speaking English tome .  28 . 6 203 . 5 Table i : Timings obtained from a systemic parser  . 
and G , , o is a grammar containing 440 disjunctions . The total time used to parse each sentence is given in seconds  . 
7 Conclusions
The unification method presented here represents a general solution to a seemingly intractable problem  . This method has been used successfully in an experimental parser for a grammar containing several hundred disjunctions in its description  . Therefore , we expect hat it can be used as the basis for language processing systems requiring large grammatical descriptions that contain disjunctive information  , and refined as necessary and appropriate for specific applications  . 
While the range of speed achieved by a straightf Qrward implementation fthis algorithm is acceptable for grammar testing  , even greater efficiency would be desirable ( and necessary for applications demanding fast realtime performance  )  . 
Therefore , we suggest wo types of refinement to this algorithm as topics for future research : using heuristics to determine an opportune ordering of the dlsjuncts within a description  , and using parallel hardware to implement the compatibility tests for different disjunctions  . 

I would like to thank Bill Rounds , myadvisor during graduate studies at the University of Michigan  , for hie helpful criticism of earlier versions of the algorithm which is presented here  . I would also like to thank Bill Mann for suggestions during its implementation at USC /ISI  , and Stuart Shieber for providing help in the use of the PATR-II system  . 
This research was sponsored in part by the United States Air Force Office of Scientific Research contracts  FQ8671-84-01007 and F49620-87-C  . -0005 , and in part by the United States Defense Advanced Research Projects Agency under contract  MDA903-81-C-0335  ; the opinions expressed here are solely those of the author  . 
\[3\] Kasper , R . Systemic Grammar and Functional Unification Grammar  . In J . Benson and W . Greaves , editors , Systemic Functional Perspectives on Discourse : Selected Papers from the  12 t ~ International Systemics Wor ~ hop , Norwood , New Jersey : Ablex ( forthcoming ) . 
\[4\] Keeper , R . and W . Rounds . A Logical Semantics for Feature Structures . In Proceedings of the 24 eh Annual Meeting of the Association for Computational Linguistics  , Columbia University , New York , N ' Y , June 1013 ,  1986 . 
\[5\] Keeper , R . Feature Structures : A Logical Theory ~ ith Application to Language Analysis  . PhD dissertation , University of Michigan , 1987 . 
\[6\] Kay , M . Functional Grammar . In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society  , Berkeley Linguistics Society , Berkeley , California , 
February 1719, 1979.
\[7\] Kay , M . Parsing in Functional Unification Grammar . In D . Dowty , L . Karttunen , and A . Zwicky , editors , Natural Language Parsing . Cambridge University Press , Cambridge , England ,  1985 . 
\[8\] Perelra , F . C . N . and D . H . D . Warren . Definite clause grammars for language analysis - a survey of the formalism and a comparison with augmented transition networks  . Artificial Intelligence , 13:231-278, 1980 . 
\[9\] Rounds , W . C . and R . Keeper . A Complete Logical Calculus for Record Structures Representing Linguistic Information  . Symposium on Logic in Computer Science . 
IEEE Computer Society , June 1618, 1986.
\[101 Shieber , S . M . The design of a computer language for linguistic information  . In Proceedings of the Tenth International Conference on Computational Linguistics : COLING  84  , Stanford University , Stanford , California , July 27 ,  1984 . 
\[11\]Shieber , S . M . An Introduction to Unification-based Approaches to Grammar  . Chicago : University of Chicago Press , CSLI Lecture Notes Series ,  1986 . 
References\[1\]Ait-Kaci , H . A New Model of Computation Based on a Calculus of Type Subsumption  . PhD thesis , University of
Pennsylvania , 1984.
\[2l Karttunen , L . Features and Values . In Proceedings of the Tenth International Conference on Computational Linguistics : COLING  8~  , Stanford University , Stanford , 
California , July 27, 1984.

