FiniteState Transducers
Approximating Hidden Markov Models
Andrd Kempe
Rank Xerox Research Centre-Grenoble Laboratory
6 , chemin de Maupertuis- 38240 Meylan-France andre , kempe ? grenoble , rxrc . xerox , com http://www . rxrc . xerox , com/research/mltt
Abstract
This paper describes the conversion of a
Hidden Markov Model into a sequential transducer that closely approximates the behavior of the stochastic model  . This transformation is especially advantageous for part-of-speech tagging because the resulting transducer can be composed with other transducers that encode correction rules for the most frequentagging errors  . 
The speed of tagging is also improved . The described methods have been implemented and successfully tested on six languages  . 
1 Introduction
Finite state automata have been successfully applied in many areas of computational linguistics  . 
This paper describes two algorithms 1 which approximate a Hidden Markov Model ( HMM ) used for part-of-speech tagging by a finite-state transducer  ( FST )  . These algorithms may be useful beyond the current description on any kind of analysis of written or spoken language based on both finite-state technology and HMMs  , such as corpus analysis , speech recognition , etc . Both algorithms have been fully implemented . 
An HMM used for tagging encodes , like a transducer , a relation between two languages . One language contains sequences of ambiguity classes obtained by looking up in a lexicon all words of a sentence  . The other language contain sequences of tags obtained by statistically disambiguating the class sequences  . From the outside , an HMM tagger behaves like a sequential transducer that deterministically  1There is a different ( unpublished ) algorithm by Julian M . Kupiec and John T . Maxwell(p . c . ) . 
maps every class sequence to a tag sequence , e . g . :\[ DET , PRO\]\[ADJ , NOUN\]\[ADJ , NOUN\] . . . . . . \[ END \] ( i)
DET ADJ NOUN . . . . . . END
The aim of the conversion is not to generate FSTs that behave in the same way  , or in as similar away as possible like IIMMs , but rather FSTs that perform tagging in as accurate a way as possible  . The motivation to derive these FSTs from HMMs is that HMMs can be trained and converted with little manual effort  . 
The tagging speed when using transducers i up to five times higher than when using the underlying HMMs  . The main advantage of transforming an HMM is that the resulting transducer can be handled by finite state calculus  . Among others , it can be composed with transducers that encode : ? correction rules for the most frequent tagging errors which are automatically generated  ( Brill , 1992; Roche and Schabes ,  1995 ) or manually written ( Chanod and Tapanainen ,  1995) , in order to significantly improve tagging accuracy  2  . 
These rules may include long-distance dependencies not handled by HMM taggers  , and can conveniently be expressed by the replace operator  ( Kaplan and Kay , 1994; Karttunen ,  1995;
Kempe and Karttunen , 1996).
? further steps of text analysis , e . g . light parsing or extraction of noun phrases or other phrases  ( Ait-Mokhtar and Chanod ,  1997) . 
These compositions enable complex text analysis to be performed by a single transducer  . 
An IIMM transducer builds on the data ( probability matrices ) of the underlying HMM . The accuracy 2Automatically derived rules require less work than manually written ones but are unlikely to yield better results because they would consider relatively limited context and simple relations only  . 
4 60 of this data has an impact on the tagging accuracy of both the HMM itself and the derived transducer  . 
The training of the HMM can be done on either a tagged or untagged corpus  , and is not a topic of this paper since it is exhaustively described in the literature  ( Bahl and Mercer , 1976; Church ,  1988) . 
An HMM can be identically represented by a weighted FST in a straightforward way  . We are , however , interested in non-weighted transducers . 
2n-Type Approximation
This section presents a method that approximates a  ( lst order ) HMM by a transducer , called n-type approximation 3 . 
Like in an HMM , we take into account initial probabilities ~ r , transition probabilities a and class ( i . e . 
observation symbol ) probabilities b . We do , however , not estimate probabilities over paths . The tag of the first word is selected based on its initial and class probability  . The next tag is selected on its transition probability given the first tag  , and its class probability , etc . Unlike in an HMM , once a decision on a tag has been made , it influences the following decisions but is itself irreversible  . 
A transducer encoding this behaviour can be generated as sketched in figure  1  . In this example we have a set of three classes , Cl with the two tags tn and t12 , c2 with the three tags t21 , t22 and t23 , and c3 with one tagt 31 . Different classes may contain the same tag , e . g . t12 and t2s may refer to the same tag . 
For every possible pair of a class and a tag ( e . g . 
Cl : t12 or I ' ADJ , NOUN\]:NOUN ) a state is created and labelled with this same pair  ( fig .  1) . An initial state which does not correspond with any pair  , is also created . All states are final , marked by double circles . 
For every state , as many outgoing arcs are created as there are classes  ( three in fig .  1) . Each such arc for a particular class points to the most probable pair of this same class  . If the arc comes from the initial state , the most probable pair of a class and a tag ( destination state ) is estimated by : argrnk axpl ( ci , t i  h ) ----7 r ( tik ) b ( ciltik )   ( 2 ) If the arc comes from a state other than the initial state  , the most probable pair is estimated by : argmax p2 ( ci , tik ) = a(tlklt p , eoio ~ , ) b(ciltik ) (3) In the example ( fig . 1) cl : t12 is the most likely pair of class cl , and c2:t23 the most likely pair of class e2 a Name given by the author . 
when coming from the initial state , and c2  :  t21 the most likely pair of class c2 when coming from the state of c3  :  t31  . 
Every arc is labelled with the same symbol pair as its destination state  , with the class symbol in the upper language and the tag symbol in the lower language  . E . g . every arc leading to the state of cl : t12 is labelled with Cl : t12  . 
Finally , all state labels can be deleted since the behaviour described above is encoded in the arc labels and the network structure  . The network can be minimized and determinized . 
We call the model an nl-type model , the resulting FST an nl-type transducer and the algorithm leading from the HMM to this transducer  , an nl-type approximation of a 1st order HMM . 
Adapted to a 2nd order HMM , this algorithm would give an n2-type approximation . Adapted to a zero order HMM , which means only to use class probabilities b , the algorithm would give an nO-type approximation . 
n-Type transducers have deterministic states only.
3 s-Type Approximation
This section presents a method that approximates an HMM by a transducer  , called s-type approximation 4 . 
Tagging a sentence based on a 1st order HMM includes finding the most probable tag sequence T given the class sequence C of the sentence  . The joint probability of C and T can be estimated by : p  ( C , T ) = p(cl . . . . Cn , t l . . . . tn ) =
Its ) 12Ia(t , lt_l)ItOi = 2(4)
The decision on a tag of a particular word cannot be made separately from the other tags  . Tags can influence ach other over a long distance via transition probabilities  . Often , however , it is unnecessary to decide on the tags of the whole sentence at once  . 
In the case of a 1st order HMM , unambiguous classes ( containing one tag only ) , plus the sentence beginning and end positions , constitute barriers to the propagation of HMM probabilities  . Two tags with one or more barriers in between do not influence ach other's probability  . 
4 Name given by the author.
461 classes r-tags of classes 22 ~
Figure 1: Generation of an nl-type transducer 3 . 1s-Type Sentence Model To tag a sentence , one can split its class sequence at the barriers into subsequences  , then tag them separately and concatenate them again  . The result is equivalent othe one obtained by tagging the sentence as a whole  . 
We distinguish between initial and middle subsequences  . The final subsequence of a sentence is equivalent o a middle one  , if we assume that the sentence nd symbol ( . or ! or ? ) always corresponds to an unambiguous class c ~ . This allows us to ignore the meaning of the sentencend position as an HMM barrier because this role is taken by the unambiguous class cuat the sentence nd  . 
An initial subsequence Ci starts with the sentence initial position  , has any number ( incl . zero ) of ambiguous classes ca and ends with the first unambiguous class c ~ of the sentence  . It can be described by the regular expression S :
Ci = ca * (5)
The joint probability of an initial class subsequence Ci of length r  , together with an initial tag subsequence ~ , can be estimated by : rp(C , , ~1~) = r(tl ) b(cl\]tl ) . Ha ( tj \] tj_l ) b ( cjItj )   ( 6 )   j=2 A middle subsequence Cm starts immediately after an unambiguous class cu  , has any number ( incl . 
SRegular expression operators used in this section are explained in the annex ? zero  ) of ambiguous classes ca and ends with the following unambiguous class c~: 
Cm = ca * c ~ (7)
For correct probability estimation we have to include the immediately preceding unambiguous class cu  , actually belonging to the preceding subsequence CiorCm  . We thereby obtain an extended middle subsequence 5: = % ca * ( 8 ) The joint probability of an extended middle class subsequence C ~ of lengths  , together with a tag subsequence Tr ~ , can be estimated by : $ p(c ? , 7?) = b(clltl) . I-\[a(tjltj_)b(cjlt ) (9) j=23 . 2 Construct ion of an s - Type Transducer To build ans-type transducer  , a large number of initial class subsequences Ci and extended middle class subsequences C~n are generated in one of the following two ways :  ( a ) Extraction from a corpus Based on a lexicon and a guesser  , we annotate an untagged training corpus with class labels  . From every sentence , we extrac the initial class subsequence C i that ends with the first unambiguous class c ~  ( eq . 
5) , and all extended middle subsequences C~n ranging from any unambiguous class cu  ( in the sentence ) to the following unambiguous class ( eq .  8) . 

A frequency constraint ( threshold ) may be imposed on the subsequences lection , so that the only subsequences retained are those that occur at least a certain number of times in the training corpus  6  . 
( b ) Generation of possible subsequences Based on the set of classes  , we generate all possible initial and extended middle class subsequences  , Ci and C , e , ( eq . 5, 8) up to a defined length . 
Every class subsequence Ci or C~is first disambiguated based on a  1st order HMM , using the Viterbi algorithm ( Viterbi , 1967; Rabiner , 1990) for efficiency , and then linked to its most probable tag subsequence ~ or T ~ by means of the cross product operation S : Si--Ci  . x . T/----c1:tlc2:t2 .   .   .   .   .   . Cn : tn (10) 0 1) e . eS ~ = C ~ . x . 7 ~= el . t1 c2: t2 . . . . . . c , : t , In all extended middle subsequences S~n , e . g . :
S~-C~_(12)\[DET\]\[ADJ , NOUN\]\[ADJ , NOUN\]\[NOUN\]
DET ADJADJ NOUN the first class symbol on the upperside and the first tag symbol on the lower side  , will be marked as an extension that does not really belong to the middle sequence but which is necessary to disambiguate it correctly  . Example (12) becomes : s ? == (13) TOO . \[DET\]\[ADJ,NOUN\]\[ADJ,NOUN\]\[NOUN\]
O . DET ADJADJ NOUN
We then build the union uSi of all initial subsequences Si and the union uS~n of all extended middle subsequences S  , e = , and formulate a preliminary sentence model : uS ? = ~ S  , uS ? ~* ( 14 ) in which all middle subsequences S ? are still marked and extended in the sense that all occurrences of all unambiguous classes are mentioned twice : Once unmarked as cuattheen d of every sequence Ci or COn  ,   0 at the beginning and the second time marked as c u of every following sequence C ?  . The upper side of the sentence model uS ? describes the complete  ( but 6The frequency constraint may preven the encoding of rare subsequences which would encrease the size of the transducer without contributing much to the tagging accuracy  . 
extended ) class sequences of possible sentences , and the lower side of uS ? describes the corresponding  ( extended ) tag sequences . 
To ensure a correct concatenation of initial and middle subsequences  , we formulate a concatenation constraint for the classes :  0 = N\[-*\[% ( 15 ) 
J stating that every middle subsequence must begin  0 with the same marked unambiguous class % ( e . g . 
0 . \[ DET \]) which occurs unmarked as c~(e . g . \[ DET\] ) at the end of the preceding subsequence since both symbols refer to the same occurrence of this unambiguous class  . 
Having ensured correct concatenation , we delete all marked classes on the upper side of the relation by means of and all marked tags on the lower side by means of By composing the above relations with the preliminary sentence model  , we obtain the final sentence model S :
S = D c.o.R c.o.uS?.o.Dt(18)
We call the model ans-type model , the corresponding FST ans-type transducer , and the whole algorithm leading from the HMM to the transducer  , ans-type approximation of an HMM . 
The s-type transducer tags any corpus which contains only known subsequences  , in exactly the same way , i . e . with the same errors , as the corresponding HMM tagger does . However , since ans-type transducer is incomplete , it cannot tag sentences with one or more class subsequences not contained in the union of the initial or middle subsequences  . 
3 . 3 Complet ion of an s - Type Transducer An incompletes-type transducer S can be completed with subsequences from an auxiliary  , completen-type transducer N as follows : First , we extract heunion of initial and the union of extended middle subsequences  , uueSi and sSm from the primary s-type transducer S  , and the unions ~ Si extract the union ? Si of initial subsequences we use the following filter : Fs  , =\[\< c ~ , t>\]*<c- , 0\[?:\[\]\]* (19) where ( c , , t ) is the l-level format 7 of the symbol pair cu : t . The extraction takes place by usi =\[ N . 1L . o . Fs , \] . l . 2L ( 20 ) where the transducer N is first converted into l -level format  7  , then composed with the filter Fs , ( eq . 
19) . We extract the lower side of this composition , where every sequence of N . 1L remains unchanged from the beginning up to the first occurrence of an unambiguous class c  ,  . Every following symbol is mapped to the empty string by means of \[?:\[\]\]  . 
( eq .  19) . Finally , the extracted lower side is again converted into 2-level format 7  . 
The extraction of the unionuSe of extended mid -die subsequences is performed in a similar way  . 
We then make the joint unions of initial and extended middle subsequences  5 : U~/UOOU:I\[\]\] ( 21 ) - - ~ Si . o . ~SiUeUeUeUe =\[, Sm . us . , , s in I\[(22)-\] . o . \]In both cases ( eq . 21 and 22 ) we union all subsequences from the principal model S  , with all those subsequences from the auxiliary model N that are not in S  . 
Finally , we generate the completed s+n-typc transducer from the joint unions of subsequences uSi and uS ~ n  , as decribed above ( eq .  1418) . 
A transducer completed in this way , disambiguates all subsequences known to the principal incompletes-type model  , exactly as the underlying HMM does , and all other subsequences as the auxiliary n -type model does  . 
4 An Implemented Finite-State

The implemented tagger requires three transducers which represent a lexicon  , a guesser and any abovementioned approximation of an HMM  . 
All three transducers are sequential , i . e . deterministic on the input side . 
Both the lexicon and guesser unambiguously map a surface form of any word that they accept to the corresponding class of tags  ( fig . 2, col . 1 and 2 ) : ~ l-Level and 2-level format are explained in the an-flex . 
First , the word is looked for in the lexicon . If this fails , it is looked for in the guesser . If this equally fails , it gets the label\[UNKNOWN\]which associates the word with the tag class of unknown words  . Tag probabilities in this class are approximated by tags of words that appear only once in the training corpus  . 
As soon as an input token gets labelled with the tag class of sentence nd symbols  ( fig . 2:\[SENT\]) , the tagger stops reading words from the input . At this point , the tagger has read and stored the words of a whole sentence  ( fig . 2, col .  1 ) and generated the corresponding sequence of classes  ( fig . 2, col .  2) . 
The class sequence is now deterministically mapped to a tag sequence  ( fig . 2, col . 3) by means of the HMM transducer . The tagger outputs the stored word and tag sequence of the sentence  , and continues in the same way with the remaining sentences of the corpus  . 
The\[AT\]AT share\[NN , VB\]NN of\[IN\]IN tripled\[VBD , VBN\]VBD within\[IN , RB\]IN that\[CS , DT , WPS\]DT span INN , VB , VBD\]VBD of\[IN\]IN time INN , VB\]NN\[SENT\]SENT
Figure 2: Tagging a sentence 5 Experiments and Results This section compares different n-type and s-type transducers with each other and with the underlying 

The FSTs perform tagging faster than the HMMs.
Since all transducers are approximations of HMMs , they give a lower tagging accuracy than the corresponding HMMs  . However , improvement in accuracy can be expected since these transducers can be composed with transducers encoding correction rules for frequent errors  ( sec .  1) . 
Table 1 compares different rans ducers on an English test case  . 
The s+nl-type transducer containing all possible subsequences up to a length of three classes is the most accurate  ( table 1 , last line , s + nl-FST (~3):95 . 95%) but M so the largest one . A similar rate of accuracy at a much lower size can be achieved with the s+nl-type  , either with all subsequences up to a accuracy in %   96  . 7 7 tagging speed in words/sec 4   590 transducer size creation time  #states  #arcs 1   297   71   21   087   927   203   853   2   675   564   887   4   709   976   785   476   107   728   211   52   624   154   41   598   2   049   418   536   799   167   952   432   96   712   9   796   1   311   962   92   463   13   681   113   n0-FST   83  . 53 2058 216 secnl-FST 94 . 191724417 secs+nl-FST (20K , F1) 94 . 7413 5753 mins+nl-FST (50K , F1) 94 . 92 12760 10 mins+nl-FST (100K , F1) 95 . 051203823 mins+nl-FST(100K , F2) 94 . 76 141782 mins+nl-FST (100K , F4) 94 . 601417876 secs+nl-FST (100K , F8) 94 . 491387062 sees+nl-FST(1M , F2) 95 . 67113937 mins+nl-FST(1M,F4) 95 . 36111934 mins+nl-FST(1M,FS ) 95 . 09135753 mins+nl-FST (<2) 95 . 06818039 mins+nl-FST (<3) 95 . 9548704 7 h
Language : English
Corpora : 19944 words for HMM training , 19934 words for test
Tagset : 74 tags 297 classes
Types of FST ( FiniteState Transducers ): nO , nln0-type ( with only lexical probabilities ) or nl-type ( sec . 2) s+nl(100K,F2) s-type(sec .  3) , with subsequences of frequency > 2 , from a training corpus of 100000 words ( sec .  3 . 2a ), completed with nl-type ( sec .  3 . 3) s+nl(<2) s-type(sec .  3) , with all possible subsequences of length_< 2 classes ( sec .  3 . 2b ), completed with nl-type ( sec .  3 . 3) Computer : ultra 2 , 1 CPU , 512 MBytesphysical RAM ,  1 . 4G Bytes virtual RAM Table 1: Accuracy , speed , size and creation time of some HMM transducers length of two classes  ( s + nl-FST ( 5 2 ) : 95 . 06 % ) or with subsequences occurring at least once in a training corpus of  100   000 words ( s + nl-FST ( lOOK , F1):95 . 05 %) . 
Increasing the size of the training corpus and the frequency limit  , i . e . the number of times that a subsequence must at least occur in the training corpus in order to be selected  ( sec .  3 . 2a ) , improves the relation between tagging accuracy and the size of the transducer  . E . g . the s+nl-type transducer that encodes subsequences from a training corpus of  20   000 words ( table 1 , s + nl-FST (20K , F1):94 . 74 % , 927 states , 203853 arcs ) , performs less accurate tagging and is bigger than the transducer that encode sub-sequences occurring at least eight times in a corpus of  1   000   000 words ( table 1 , s + nl-FST (1M , F8):95 . 09%, 432 states , 96712 arcs) . 
Most transducers in table 1 are faster then the underlying HMM ; then 0-type transducer about five times . There is a large variation in speed between SSince  n0-type and nl-type transducers have deterministic states only  , a particular fast matching algorithm can be used for them  . 
the different ransducers due to their structure and size  . 
Table 2 compares the tagging accuracy of different transducers and the underlying HMM for different languages  . In these tests the highest accuracy was always obtained by s-type transducers  , either with all subsequences up to a length of two classes  9 or with subsequences occurring at least once in a corpus of  100   000 words . 
6 Conclusion and Future Research
The two methods described in this paper allow the approximation of an HMM used for part-of-speech tagging  , by a finite-state transducer . Both methods have been fully implemented . 
The tagging speed of the transducer siup to five times higher than that of the underlying HMM  . 
The main advantage of transforming an HMM is that the resulting FST can be handled by finite  9A maximal length of three classes is not considered here because of the high increase in size and a low increase in accuracy  . 
465.... HMM-'n0-FST nl-FST
English 96 . 77 83 . 53 94 . 19 s+nl-FST (20K , F1) 94 . 74 s+nl-FST (50K , F1) 94 . 92 s+nl-FST (100K , F1) 95 . 05 s+nl-FST (100K , F2) 94 . 76 s?nl-FST (100K , F4) s+nl-FST (100K , F8) 94 . 60 94 . 49: HMM train . crp .   (  #w d ) '" test corpus (  #words ) s + nl-FST ( < 2 )  95 . 0 6   19   944   19   934  #tags 74  #classes 297 accuracy in %
I Dutch I French I German
I 94"76\[98"65197 . 62 81 . 99 91 . 13 91 . 58 98 . 18 92 . 17 98 . 35 92 . 24 98 . 37 92 . 36 98 . 37 92 . 17 98 . 34 92 . 02 98 . 30 91 . 84 98 . 32 92 . 25 98 . 3 7   26   386   22   622   10   468   6   368   47   45   230   287 \[ Types of FST ( FiniteState Transducers )  :
Portug . Spanish\[97 . 12 97 . 60 82 . 97 91 . 03 93 . 65 94 . 49 96 . 19 96 . 46 95 . 23 96 . 71 95 . 57 95 . 81 95 . 51 95 . 29 96 . 33 96 . 49 96 . 56 96 . 42 96 . 27 96 . 76 96 . 87 96 . 74 96 . 64 95 . 02 96 . 23 96 . 54 95 . 92 96 . 50 96 . 9 0   91   060   20   956   16   221   39   560   15   536   15   443   66   67   55   389   303   254 cf . table 1 I Table 2: Accuracy of some HMM transducers for different languages state calculus  1? and thus be directly composed with other transducers which encode tag correction rules and /or perform further steps of text analysis  . 
Future research will mainly focus on this possibility and will include composition with  , among others : ? Transducers that encode correction rules  ( possibly including long-distance dependencies ) for the most frequentagging errors , ill order to significantly improve tagging accuracy  . These rules can be either extracted automatically from a corpus  ( Brill ,  1992 ) or written manually ( Chanod and Tapanainen ,  1995) . 
? Transducers for light parsing , phrase extraction and other analysis ( A'/t-Mokhtar and Chanod ,  1997) . 
An HMM transducer can be composed with one or more of these transducers in order to perform complex text analysis using only a single transducer  . 
We also hope to improve then-type model by using lookahead to the following tags  11  . 

I wish to thank the anonymous reviewers of my paper for their valuable comments and suggestions  . 
I am grateful to Lauri Karttunen and Gregory Grefenstette  ( both RXRC Grenoble ) for extensive and frequent discussion during the period of my work  , as well as to Julian Kupiec ( Xerox PARC ) and Mehryar Mohri ( AT&:T Research ) for sending me some interesting ideas before I started  . 
Many thanks to all my colleagues at RXRC Grenoble who helped mein whatever respect  , particularly to Anne Schiller , Marc Dymetman and Jean-Pierre Chanod for discussing parts of the work  , and to Irene Maxwell for correcting various versions of the paper  . 
l ? A large library of finite-state functions is available at Xerox  . 
11 Ongoing work has shown that , looking a head to just one tag is worthless because it makes tagging results highly ambiguous  . 

References ANNEX : Regular Expression Operators Ait-Mokhtar  , Salah and Chanod , Jean-Pierre (1997) . Incremental Finite State Parsing . In the Proceedings of the 5th Conference of Applied Natural Language Processing  . ACL , pp .  7279 . 
Washington , DC , USA.
Bahl , Lalit R . and Mercer , Robert L .  (1976) . Part of Speech Assignment by a Statistical Decision Algorithm  . In IEEE international Symposium on $ A Information Theory  . pp .  8889 . Ronneby . 
Brill , Eric (1992) . A Simple Rule-Based Part-of--A Speech Tagger . In the Proceedings of the 3rd conference on Applied Natural Language Processing  , \ app .  152-155 . Trento , Italy . 
Chanod , Jean-Pierre and Tapanainen , Pasi (1995) . A * Tagging French-Comparing a Statistical and a Constraint Based Method  . In the Proceedings of A+the 7th conference of the EACL , pp .  149-156 . 
ACL . Dublin , Ireland . a -> b
Church , Kenneth W .  (1988) . A Stochastic Parts Program and Noun Phrase Parser for Unrestricted Text  . In Proceedings of the 2nd Con-a <- bference on Applied Natural Language Processing  . 
ACL , pp . 136143.

Kaplan , Ronald M . and Kay , Martin (1994) . Regular Models of Phonological Rule Systems . In ( a , b ) Computational Linguistics . 20:3, pp .  331-378 . 
Karttunen , Lauri (1995) . The Replace Operator . R . u In the Proceedings of the 33rd Annual Meeting R .   1 of the Association for Computational Linguistics . hB
Cambridge , MA , USA . cmp-lg/9504032
AIB
Kempe , Andrd and Karttunen , Lauri (1996) . Par-A ~ Ballel Replacement in Finite State Calculus  . In A-B the Proceedings of the 16th International Conference on Computational Linguistics  , pp .  622-627 . h . x . B
Copenhagen , Denmark . crap-lg/9607007
Rabiner , Lawrence R .  (1990) . A Tutorial on Hid-R . o . q den Markov Models and Selected Applications in it  . lL Speech Recognition . In Readings in Speech Recognition ( eds . A . Waibel , K . F . Lee ) . Morgan Kaufmann Publishers , Inc . San Mateo , CA . , USA . 
A . 2L Roche , Emmanuel and Schabes , Yves (1995) . Deterministic Part-of-Speech Tagging with Finite -Oorf\]State Transducers  . In Computational Linguistics .  ?
Vol . 21, No . 2, pp . 227-253.
Viterbi , A . J .  (1967) . Error Bounds for Convolutional Codes and an Asymptotical Optimal Decoding Algorithm  . In Proceedings of IEEE , vol . 
61, pp . 268-278.
Below , a and b designate symbols , A and
B designate languages , and R and q designate relations between two languages  . More details on the following operators and pointers to finite-state literature can be found in http://www  . rxrc . xerox , com/research/mltt/fstContains . Set of strings containing at least one occurrence of a string from A as a substring  . 
Complement ( negation ) . All strings except those from A . 
Term complement . Any symbol other than a.
Kleene star . Zero or more times h concatenated with itself . 
Kleene plus . One or more times A concatenated with itself . 
Replace . Relation where every a on the upperside gets mapped to abon the lower side  . 
Inverse replace . Relation where every b on the lower side gets mapped to anaon the upper side  . 
Symbol pair with a on the upper and b on the lower side  . 
1-Level symbol which is the 1-1eve ! form ( . 1L ) of the symbol pair a : b . 
Upper language of R.
Lower language of R.
Concatenation of all strings of A with all strings of tl  . 
Union of A and B.
Intersection of A and B .
Relative complement ( minus ) . All strings of A that are not in B . 
Cross Product ( Cartesian product ) of the languages A and B . 
Composition of the relations R and q.
1-Level form . Makes a language out of the relation R . Every symbol pair becomes a simple symbol . ( e . g . a:b becomes ( a , b ) and a which means a : a becomes ( a , a )) 2- Level form . Inverse operation to . 1L(R . 1L . 2L = R ) . 
Empty string ( epsilon).
Any symbol in the known alphabet and its extensions 
