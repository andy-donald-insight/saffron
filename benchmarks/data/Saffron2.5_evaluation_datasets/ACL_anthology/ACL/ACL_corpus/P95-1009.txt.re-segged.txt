User-Defined Nonmonotonicity in Unification -Based Formalisms 
Lena Str ~ Smb~ick
Department of Computer and Information Science
LinkSping University
S-58185 Link Sping , Sweden
lest r~ida , liu.so
Abstract
A common feature of recent unification -
based grammar formalisms is that they
give the user the ability to define his own structures  . However , this possibility is mostly limited and does not include nonmonotonic operations  . In this paper we show how nonmonotonic operations can also be user-defined by applying default logic  ( Reiter ,  1980 ) and generalizing previous results on nonmonotonic sorts  ( Young and
Rounds , 1993).
1 Background
Most of the more recent unification-based form a -lisms  , such as TFS ( Emele and Zajac ,  1990) , UD ( Johnson and Rosner ,  1989) , CUF ( DSrre and Eisele ,  1991) , and FLUF ( Str Smb~ick ,  1994) , provide some possibility for the user to define constructions of his own  . This possibility can be more or less powerful in different formalisms  . There are , however , several constructions proposed as desirable x tensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms  . 
One such class of constructions it hose that have some degree of nonmonotonic behaviour  . Examples of such constructions are any-values , default-values , and some constructions ( e . g . constraining equations , completeness and coherence ) used in LFG ( Kaplan and Bresnan ,  1983) . 
This paper describes a method that permits the user to define such nonmonotoni constructions  . 
This is done through generalizing the work on nonmonotonic sorts  ( Young and Rounds ,  1993) . This generalization results in a default logic similar to  ( Reiter ,  1980) , but where subsumption and unification are used instead of logical truth and consistency  . 
There are three main advantages to Young and Rounds ' work compared with other approaches to default unification  ( Bouma , 1990; Bouma , 1992; Russel et al ,  1992 ) which justify choosing it as a starting point for this work  . The first is the separation of definite and default information  , where Young and Rounds are more distinct than the other  . The second is that the nonmonotonic unification operation used is order independent  . This is achieved by separating the unification operation from computing the nonmonotonic extension  , which Young and Roundscall explanation . This suggests that all the user needs to define when generalizing the approach is how a sort is explained  . Finally , there is a close relationship to Reiter's ( 1980 ) default logic . 
This paper starts by providing the minimal properties required of a unification-based formalism when extending with nonmonotonic definitions  . I then describe the approach of user-defined nonmo-notonicity and illustrate how some commonly used nonmonotonic constructions can be defined within it  . Finally I conclude with a discussion of the relation to Reiter's default logic and computational properties of the approach  . 
2 Preliminaries
There are two main properties that will be assumed of a unification-based formalism in order to extend it with the possibility of defining nonmonotonic constructions  . The first , and most important , is that we require a subsumption order on the set S of objects denoted by the formalism  . Secondly it should be possible to define inheritance hierarchies on the linguistic knowledge described by the formalism  . 
On every plausible subsumption order that can be used is the ordinary subsumption lattice of feature structures  . It is , however , possible to use some other kind of subsumption order if that is more suitable for the domain to be modelled by the formalism  . Examples of other subsumption orders that might be useful are typed feature structures  , feature structures extended with disjunction , or simply an order based on sets and set inclusion  . 
In this paper the notation a Ub is used whene-ver a subsumes b  ( i . e . whenever a " is more specific than " or " contains more information than " b  )  . Consequently , aI'-b is used whenever a_b but a ? b . 
The subsumption order is assumed to be a semi-a N b  , corresponding to the greatest lower bound , for every pair of elements within it . The element corresponding to the bottom of the order relation is denoted fail and represents inconsistent information or unification failure  . 
The second constraint placed on the formalism , the possibility of defining an inheritance hierarchy  , is not essential for the definition of nonmonotonic operations  . It is , however , very useful when defining nonmonotonic constructions  . The following notation will be used for describing an inheritance hierarchy  . 
class the name of the class ; is a its parent in the hierarchy ; requires a structure . 
Thus , each member in the inheritance hierarchy is called a class  , which is defined by giving it a name and a parent in the hierarchy  . It is also possible to define some constraints , called requirements , which must hold for a class . These requirements can be both structures in the subsumption order and nonmonotonic rules  . The constraints on classes are inherited through the hierarchy  . Every object in a class is assumed to contain at least the information given by the constraints pecified for it and all its ancestors  . 
For simplicity multiple inheritance between classes will not be allowed  . This means that two classes where none of them is a subclass of the other  , will always be considered inconsistent and thus yield a failure when unified  . 
3 User-Defined Nonmonotonicity
I will now describe how the work by Young and Rounds can be generalized to allow the user to define nonmonotonic constructions  . The main idea in their approach is that each node in a feature structure consists of a nonmonotonic sort  . Such sorts can contain two different kinds of information  , the ordinary monotonic information and a set of defaults  . If we assume that fl is defined as a default in Young and Rounds ' work then it is interpreted according to the rule : if it is consistent to believe  #then believe #  . In Reiter's default logic this is expressed with the following normal default rule  . 

In this paper I want to allow the user to use other forms of nonmonotonic nferences and not only the normal default rule given above  . Therefore , I will consider the general form of default rules  . An intuitive reading of a general default rule is  , if a is believed and it is consistent o believe # then believe  7  . In default logic this is usually expressed as nic rules are going to be interpreted in a unification framework  . In ( Reiter ,  1980) , a rule like the one above could be applied whenever a is true and  #is consistent with the information we already have  . 
If we assume that V represents the information already given this means that the default rule can be applied whenever Y Ca and Y II  #does not yield unification failure  . When the rule is applied the new information obtained would be  1/Iq   7  . 
In the approach described in this paper , the user is allowed to define the actual nonmonotonic rule that should be used for a particular operation by using the following syntax  . 
nonmon name ( parameter 1, .   .   . parameter n ) : when a :#=>7 In the syntax given above name assigns a name to the defined rule  , and thus allows the user to use nonmonotonic information when defining linguistic knowledge  . The parameters in the rule definition are variables  , which can be used within the actual default rule at the end of the description  . The user is assumed to assign the nonmonoto-nic information contained in this rule to hisling ui -stic knowledge by using an expression of the form narne  ( pararneter l ,   .   .   . parameter n ) . 
The when slot in the rule allows the user to decide when the rule is going to be applied  , or in Young and Rounds'terminology , explained . I will make use of two values for the when-slot , immediate and posterior . Immediate means that the nonmonotonic rule is going to be applied each time a full unification task has been solved or whenever all information about an object in the defined inheritance hierarchy has been retrieved  . Posterior explanation means that the explanation of the rule is postponed until reaching the result of some external process  , for example , a parser or generator . There is howe-ver no hinder in excluding the use of other values here  . One could , for example , imagine cases where one would want different nonmonotonic rules to be explained after a completed parse  , a generation , or after resolving discourse referents . 
Note that although the when slot in the definition of a nonmonotonic rule allows the user to define when his rule is going to be applied we will still have an order independent nonmonotonic unification ope-rator  . This is the case because we follow Young and Rounds ' approach and separate the unification ope-ration from the explanation of a nonmonotonic rule  . 
Therefore , what affects the final result of a computation is when one chooses to explain default rules and not the order of the unification operations occurring between such explanations  . 
644 Formal Definitions
In this section I provide give the formal definitions for nonmonotonic sorts and how nonmonotonic sorts are unified and explained  . The definitions are gene-ralizations of the definitions in Young and Rounds  ( 1993 )  . The notation a- , ~ b is used to denote the fact that a I1 b does not yield unification failure . 
A nonmonotonic sort is a structure containing both information from the basic subsumption order and information about default rules to be explained at a later point in the computation  . 
Definition 1 A nonmonotonic sort is a pair ( s , A ) where sES and A is a set of nonmonotonic rules of the form  ( w , a : fl == ~3') where w is an atom and a , fl and 3' ES . It is assumed that for each nonmonotonic rule 3' _C fl , a -- , s , fl , ~ s , and 713s Cs . 
As seen by the definition a nonmonotonic sort is considered to be a pair of monotonic information from the subsumption order and nonmonotonic information represented as a set of nonmonotonic ru-les  , The user can assign nonmonotonic nformation to a nonmonotonic sort by calling a nonmonotonic definition as defined in the previou section  . The actual nonmonotonic rule occurring within the sort is a pair consisting of the when slot and the last part of the nonmonotonic definition  , with the parameter variables instantiated according to the call made by the user  . 
The second part of this definition contains some well-foundedness conditions for a nonmonotonic sort  . The first condition ( 3'_C ~ ) is a restriction similar to the restriction to normal default rules in Reiter's  ( 1980 ) default logic . This restriction ensu-res that the application of one default rule will never cause previously applied default rules to be inappli-cable  . This makes the procedure for application of defaults more efficient and will be further discussed in section  6  . 
The next two conditions in the definition , a , - , s and fl~s , guarantee that the default rule is or can be applicable to the nonmonotonic sort  . The reason for only checking that a ~ s instead of sCais that future unifications can restrict the value of s into something more specific than a and thus may make the default rule applicable  . 
The last condition on a nonmonotonic sort , 3' Usrs , may seem superfluous . The reason for including it is to ensure that applying the default actually restricts the value of the sort  . Otherwise the default rule would have no effect and can be removed  . Note in particular that the above conditions on a nonmo-notonic sort implies that  7 may be fail . 
Given the unification operation of objects within the subsumption order and the definition of nonmo -notonic sorts it is possible to define an operation for nonmonotonic unification  . 
Definition 2 The nonmonotonic unification ( n  ~ v ) of two nonmonotonic sorts ( sl , A1) and ( s2 , A2) is the sort ( s , A ) where $ S~S 117$2 and , A = did = ( w , tr : fl : : ? ,  7) , de A1U
A2, a ., ~ s , ~, ..s , and Ttqst-s
The nonmonotonic unification is computed by computing the unification of the monotonic parts of the two sorts and then taking the union of their nonmonotonic parts  . The extra conditions used when forming the union of the nonmonotonic parts of the sorts are the same as in the definition of a nonmo-notonic sort and their purpose is to remove nonmo-notonic rules that are no longer applicable  , or would have no effect when applied to the sort resulting from the unification  . 
It is important onote that this generalization of the original definition of nonmonotonic unification from Young and Rounds  ( 1993 ) preserves the pro-perty of order independence for default unification  . 
When using nonmonotonie sorts containing nonmonotonic rules  , we also need to know how to merge the monotonic and nonmonotonic information within the sort  . I will use the terminology w-application for applying one nonmonotonic rule to the sort and w -ezplanation when applying all possible rules  . 
Definition 3 The nonmonotonic rule ( w , c ~: fl = ? ,  7 ) is w-applicable to sES if : ? sI--Ot?s .   .   . flors = fail ? slqTl-sors = fail The result of the w-application is  3'   I'1 sNote that the winw-application should be considered as a variable  . This means that only nonmonotonic rules whose first component is w are considered and that it is possible to choose which nonmonoto-nic rules should be applied in a particular point at some computation  . 
In addition note that the restriction that 7 --- in all nonmonotonic rules and the special cases for s = fail ensures that the application of one nonmonotonic rule never destroys the applicability of a previously applied rule  . This reduces the amount of work required when computing a w-explanation  . 
Based on these observations , a sufficient condition for w-explanation is defined as follows  . 
Definition 4 tisaw-ezplanation of a nonmonotonic sort ( s , A ) if it can be computed in the following way : 1 . If s = failor nod EA is w-applicable then t = selse  2  . Ch , ,ose a d = ( w , cr : fl = ? , 7) EA such that disw-applicable to s . 
3. Let s = sl'lT and go to 1.

As shown by the definition , aw-explanation is computed by choosing one w -applicable default rule at a time and then applying it  . Since the definition of w-applicability and the condition that  7 -in all nonmonotonic rules ensures that whenever a nonmonotonic rule is applied it can never be in app-licable  , there is no need to check if the preconditions of earlier applied nonmonotonic rules still hold  . 
Note also that the choice of which nonmonotonic rule to apply in each step of a w-explanation is nondeterministic  . Consequently , it is possible to have conflicting defaults and multiple w-explanations for a nonmonotonic sort  . 
Note also that the result of aw-explanation is allowed to be fail  . Another option would be to interpret . fail as if the application of the nonmonotonic rule should not be allowed  . However , as seen in the next section , for many uses of nonmonotonic extensions within unification-based formalisms  , the aim is to derive failure if the resulting structure does not fulfill some particular conditions  . This makes it important to allow fail to be the result of applying a nonmonotonic rule  . 
5 Examples
In this section I will show how some of the most common nonmonotonic extensions to unification -based grammar can be expressed by defining rules as above  . I will start with defining default values . 
This is done by defining a nonmonotonic rule default for the class value  , which is assumed to be the most general class in a defined hierarchy  . The rule defi-ned here is treated as the one in ( Young and Rounds ,  1993) . 
class value ; nonmon default(X ): immediate : X =>

This default rule can be used when defining verbs.
The rule is used for stating that verbs are active by default  . I also define the two Swedish verbs skickade ( sent ) and skickades ( was sent ) to illustrate how this rule works . 
class verb ; is a value ; requires\[form:default(active)\] . 
class skick ade ; is a verb ; requires\[lex:skicka\] . 
class skickades ; is a verb ; requires\[lex:skicka , form : passive \] . 
While retrieving the information for these two verbs we will obtain the following two feature structures containing nonmonotonic sorts : 
For skicka de:\[lex:skicka , form : (\[ I , ( immediate , : active active )) 3
For skickades :\[ lex:skicka , form : ( passive , ( immediate , : active : : ~ active ) )\] Since I have used immediate for the when-slot in the definition of the default rule  , this nonmonotonic rule will be applied immediately after retrieving all information about a verb in the hierarchy  . For the two structures above , the default rule can be app-lied for skickade , since active is consistent with D , but not for skickades , since active and passive are inconsistent . The result after applying immediate-explanation to the two structures above is shown below  . 
For skicka de:\[lex:skicka , form:active\]
For skickades :\[ lex:skicka , form : passive \] Another nonmonotonic operation that has been used in LFG  ( Kaplan and Bresnan ,  1983 ) is the value constraint ( = e ) used to check whether a substructure has a particular value after a completed parse  . The definition of value constraints as a nonmonotonic rule makes use of negation  , interpreted as negation as failure . 
class value ; nonmon=c(X ): posterior : -~ X => fail . 
One use of value constraints in LFG is to assert a condition that some gramma rules can only be used for passive sentences  . I will here assume that a representation for verbs where passive verbs have the value passive for the attribute form  , but where other verbs have no value for this attribute  . In the syntax used in this paper the constrMnt hata particular gramma rule can only be used for passive verbs would be expressed as below : \[ form := c  ( passive ) \] This would result in the nonmonotonic sort : \[form :  ( \[\] , ( posterior , : ~ passive fail ) )3 As seen by the definition of = c , the explanation for this nonmonotonic sort is postponed and is assu-med to be computed after finding a parse for some sentence  . This implies that the only case where this rule would not apply  , and thus not give fail as a result , is when the value of form actually is passive . 
For all other values of form , we would have something that is consistent with ~ passive and thus the nonmonotonic rule will derive failure when applied  . 

The next nonmonotonic structure I want to discuss is any-values  . The inheritance hierarchy is used to be able to define any-values in a simple way  . 
class value.
class none ; is a value.
class any_value ; is a value.
nonmonany (   ) : posterior : any_no_value=>fail . 
classany_no_value ; is a any_value.
In this small hierarchy it is assumed that all possible values of a structure is a subtype of value  . We then divide this into none , which represents that a structure cannot have any value and any_value which contains all actual values  . The class any_value is then further divided into a class called any_no_value  , which only contains this single value , and the actual values of a structure . The class any_no_value should not be used when defining linguistic knowledge  . However , when applying the default rule a value that has not been instantiated is compatible with this any_no_value  . Therefore the default rule can make the conclusion that the structure is inconsistent  , which is what we desire . Note that , as soon as a value has been further instantiated into a ' real ' value  , it will no longer be consistent with any_no_value  , and the nonmonotonic rule cannot apply . Two examples will further illustrate this . 
The nonmonotonic sort : (0 , ( posterior , : any_no_value fail ) ) will be posterior-explained to : fail
While the sort : (\[ lex:kalle\] , ( posterior , : any_no_value ~ fail ) ) will be posterior-explained to : \[ lex : kalle \] The last nonmonotonic operations I want to discuss are completeness and coherence as used in LFG  . 
To be able to define these operations I assume the inheritance hierarchy above  , without the nonmonotonic definition of any . I will , instead , make use of the two nonmonotonic definitions below  . 
class value ; nonmon coherence ( A ) : immediate:\[A:none\]=>\[A : none\] ; nonmon completeness ( A ) : posterior :\[ A : any_no_value \] => fail . 
The first of these rules is used to check coherence  , and the effect is to add the value none to each attribute that has been defined to be relevant for coherence check  , but has not been assigned a value in the lexicon . The second rule is used for checking completeness and it works similarly to the any-definition above  . 
Finally , I will show how a fragment of a lexicon can be defined according to these rules  . Note that in the definition of the transitive verb  , the value any_value is given to the appropriate attributes  . This means that they are inconsistent with none , and thus , the coherence rule cannot be applied . 
concept verb ; is a any_value ; requires coherence ( subj ) A coherence ( obj ) A . . . ; requires completeness ( subj ) A completeness ( obj ) A . . . .
concept transitive verb ; is a verb ; requircs\[subj:any_value , obj:any_value\] . 
6 Relation to Default Logic
In this section I will discuss the relation of this work to Reiter's  ( 1980 ) default logic . There will also be some discussion on the computational properties and limitations of the given approach  . 
Compared with Reiter's default logic , our notion of nonmonotonic sorts corresponds to default theories  . Unification of nonmonotonic sorts would then correspond to merging two default theories into one single theory and our notion of explaining a nonmo-notonic sort corresponds to computing the extension of a default theory in default logic  . 
In default logic there is often a restriction to normal-default theories since nonnormal default theories are not even semi-decidable  . The restriction in our nonmonotonic rules that 7 Cfl is similar to the restriction into normal default rules and captures the important property  , that the application of one nonmonotonic rule should not affect the applicability of previously applied rules  . The decidability of the nonmonotonic rules defined here is  , however , highly dependant on the given subsumption order . 
In particular it is dependent on having a decidable unification operation and subsumption check  . 
As mentioned previously there is with nonmonoto -nicsorts  , as well as normal default logic , a possibility of conflicting defaults and thus multiple nonmonotonic extensions for a structure  . One difference is that nonmonotonic sorts allow that the application of a nonmonotonic rule leads to fail  , i . e . an inconsistent structure , while default logic does not allow this outcome . However , since fail is allowed as a valid explanation for a nonmonotonic sort  , there is , as nation for a sort . 
The two following examples will illustrate the difference between on monotonic rules giving multiple extensions and nonmonotonic rules giving a single explanation fail  . 
Example a : In : l\]:\[ c:2\] \[ a:lb:l\]\[ b:2   e:2\] 
Example b :\[ a:l\]:\[ b:21 \[ a:lb:l\]\[ a:2   b:2\] In example a the application of one rule , does not make the other inapplicable . Thus the only explanation for a structure is achieved by applying both these two rules and results in fail  . In example b , however , the application of one of the rules would block the application of the other  . Thus , in this case there are two explanations for the structure dependant on which of the rules that has been app-lied first  . Note that even though there is an order dependency on the application order of nonmonoto -nicrules this does not affect the order in dependency on nonmonotonic unification between application of nonmonotonic rules  . 
Allowing multiple extensions gives a higher computational complexity than allowing only theories with one extension  . Since it is the user who defines the actual nonmonotonic theory multiple extensions must be allowed and it must be considered a task for the user to define his theory in the way he prefers  . 
7 Improvements of the Approach
I will start with two observations regarding the definitions given in section  3  . First , it is possible to generalize these definitions to allow the first component of a nonmonotonic sort to contain substructures that are also nonmonotonic sorts  . With the generalized versions of the definitions explanations that simultaneously explain all substructures of a nonmonotonic sort will be considered  . Note that the explanation of default rules at one substructure might affect the explanation of rules at other substructures  . Therefore the order on which nonmonotonic rules at different substructures are applied is important and all possible application orders must be considered  . 
Considering unification of nonmonotonic sorts it is not necessary to simplify the nonmonotonic part of the resulting sort  . A = AiU A2 can be defined as an alternative to the given definition  . This alternate definition is useful for applications where the simplification of nonmonotonic sorts by each unification is expected to be more expensive than the extra work needed to explain a sort whose nonmonotonic part is not simplified  . 
As stated previously , nonmonotonic sorts allow multiple explanations of a nonmonotonic sort  . If desired , it would be fairly easy to add priorities to the nonmonotonic rules  , and thus induce a preference order on explanations  . 
One further example will illustrate that it is also possible to define negation as failure with nonmonotonic rules  . An intuitive interpretation of the defined rule below is that if X is believed  ( 1/EX )  , failure should be derived . 
nonmonnot(X ): immediate X => fail;
However , if this definition is to be really useful we must also allow one definition of a nonmonoto-nic rule to make use of other nonmonotonic rules  . 
In our original definition we said that the nonmo -notonic rule above should be applied if Y  , ~-- X . 
This can be generalized to the case where -- X is a nonmonotonic rule if we extend the definition of -~ to also mean that the application  ( or explanation ) of the not rule at this node does not yield failure  . 
However , this generalization is outside default logic . 
Therefore , its computational properties are unclear and needs more investigation  . 
8 Conclusion
In this paper I have proposed a method allowing the user to define nonmonotonic operations in a unification-based grammar formalism  . This was done by generalizing the work on nonmonotonic sorts  ( Young and Rounds ,  1993 ) to allow not only normal defaults rules but general default rules that are defined by the user  . The method has a very close relation to Reiter ( 1980 )  . We also noted that the method can be applied to all domains of structures where we have a defined subsumption order and unification operation  . 
The generality of the approach was demonstrated by defining some of the most commonly used nonmo -notonic operations  . We also gave formal definitions for the approach and provided a discussion on its computational properties  . 

This work has been supported by the Swedish Research Council for Engineering Sciences  ( TFR )  . I would also like to thank Lars Ahrenberg and Pa -trick Doherty for comments on this work and Mark A  . Young for providing me with much-needed information about his and Bill Rounds ' work  . 
References
Gosse Bouma .  1990 . Defaults in Unification Grammar . in Proceedings of ~ he 1990 Conference of ~ he 165-172  . 
Gosse Bouma .  1992 . Feature Structures and Nonmonotonicity . Computational Linguistics 18(2):183-203 . 
Jochen D6rre and Andreas Eisele .  1991 . A Comprehensive Unification-Based Grammar Formalism  . 
DYANA Report-Deliverable R3.1B . January 1991.
Martin C . Emele , and Remi Zaja ? .  1990 . Typed Unification Grammars . In Proceedings of the Igth International Conference on Computational Linguistics  , Vol . 3, pages 293-298, Helsinki , Finland . 
Rod Johnson and Michael Rosner .  1989 . A Rich Environment for Experimentation with Unification Grammars  . In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics  , pages 182-189 , Manchester , England . 
R . Kaplan and J . Bresnan .  1983 . A Formal System for Grammatical Representation . In : JBresnan ( ed . ) , The Mental Representation of Grammatical Relations  . MIT Press , Cambridge , Massachusetts . 
Ray Reiter . 1980. A Logic for Default Reasoning.
In Artificial Intelligence , 13:81-132.
Graham Russel , Afzal Ballim , John Carrol and Susan Warwick-Armstrong .  1992 . A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons  . Computational Linguistics 18(3): 311-337 . 
Lena Str6mb/ick .  1994 . Achieving Flexibility in Unification Grammars . In Proceedings of the 15th International Conference on Computational Linguistics  , Vol . 3, pages 842-846, Kyoto , Japan . 
Mark A Young and Bill Rounds .  1993 . A Logical Semantics for Nonmonotonic Sorts . In Proceedings of the 1993 Conference of the Association for Computational Linguistics  , pages 209-215
