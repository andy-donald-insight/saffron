TRANS LATING ENGLISH INTOLOGICAL FORM'
Stanley J . Rosenscbein
Stuart M , Shieber

A scheme for syntax-directed translation that mirrors compositional model theoretic semantics i discussed  . The scheme is the basis for an English translation system called PArR and was used to specify a semantically interesting fragment of English  , including such constructs as tense , aspect , modals , and various iexically controlled verb complement sructures  . PATR was embedded in a question-answering system that replied appropriately to questions requiring the computation of logical entailments  . 
IINTRODUCTION
When contemporary linguists and philosophers speak of " semantics  , " they usually mean m0del-theoretic semantics -- mathematical devices for associating truth conditions with Sentences  . 
Computational linguists , on the other hand , often use the term " semantics " to denote a phase of processing in which a data structure  ( e . g . , a formula or network ) is constructed to represent the meaning of a sentence and serve as input to later phases of processing  . A better name for this process might be " translation " or " traneduction  . " ) Whether one takes " semantics " to be about model theory or translation  , the fact remains that natural languages are marked by a wealth of complex constructions -- such as tense  , aspect , moods , plurals , modality , adverbials , degree terms , and sentiai complemonts -- that make semantic specification a complex and challenging endeavor  . 
Computer scientists faced with the problem of managing software complexity have developed strict design disciplines in their programming methodologies  . One might speculate that a similar requirement for manageability has led linguists  ( since Montague , at least ) to follow a discipline of strict compositiouality in semantic specification  , even though model * theoretic semantics permedoes not demand it  . 
Compositionaiity requires that the meaning of a p brase be a function of the meanings of its immediate constituents  , a property that allows the grammar writer to correlate syntax and semantics on a rule-by-rule basis and keep the specification modular  . Clearly , the natural analogue to compositionality in the case of translation is syntax-directed translation  ; it is this analogy that we seek to exploit . 
We describe a syntax-directed translation scheme that bears a close resemblance to model theoretic approaches and achieves a level of perspicuity suitable for the development of large and complex grammars by using a declarative format for specify in grammar rules  . In our formalism , translation types are associated with the phrasal categories of English in much the way that logical-denotation types are associated 
Artificial Intelligence Center
SRI International 333 Raveoswood Avenue
Menlo Park , CA 94025 with phrasal categories in model theoretic semantics  . The translation ' types are classes of data objects rather than abstract denotations  , yet they play much the same role in the translation process that denotation types play in formal semantics  . 
In addition to this parallel between logical types and translation types  , we have intentionally designed the language in which translation rules are stated to emphasize parallels between the syntax-directed translation and corresponding model theoretic interpretation rules found in  , say , the GPSG literature \[ Gazdar , forthcoming \] . In the GPSG approach , each syntax rule has an associated semantic rule ( typically involving functional application ) that specifies how to compose the meaning of a phrase from the meanings of its constituents  . 
In an analogous fashion , we provide for the translation of a phrase to be synthesized from the translations of its immediate constituents according to a local rule  , typically involving symbol/c application and ~- conversiou  . 
It should be noted in passing that doing translation rather than model theoretic interpretation ffers the temptation to abuse the formalism by having the " meaning "  ( translation ) of a phrase depend on syntactic properties of the translations of its constituents -- for instance  , on the order of conjuncts in a logical expression  . There are several points to be made in this regard  . First , without severe a priori restrictions on what kinds of objects can be translations  ( coupled with the associated strong theoretical claims that such restrictions would embody  ) it seems impossible to prevent such abuses . Second , as in the case of programming languages , it is reasonable to mmume that there would emerge a set of stylistic practices that would govern the actual form of grammars for reasons of manageability and esthetics  . Third , it is still an open question whether the model * theoretic program of strong compositiouality will actually succeed  . Indeed , whether it succeeds or not is of little concern to the computational linguist  , whose systems , in any event , have no direct way of using the sort of abstract model being proposed and whose systems must  , iu general , be based on deduction ( and hence translation ) . 
The rest of the paper discusses our work in more detail  . 
Section II presents the grammar formalism and describes PATR  , an implemented parsing and translation system that can accept a grammar in our formalism and uses it to proces sentences  . Examples of the system's operation , including its application in a simple deductive question-answering system  , are found in Section HI . Finally , Section IV describes further extensions of the formalism and the parsing system  . Three appendices are included : the first contain sample grammar rules  ; the second contains meaning postulates ( axioms ) used by the question-answering system ; the third presents a sample dialogue session . 
" This research wns supported by the Defense Advanced Research Projects Agency under Contract  N000SO-SO-C  . -0575 with the Naval Electronic Systems Conun and . 
The views and conclusions contained in this document are those of the authors and should not be interpreted ns representative of the ol ~ cial policies  , either expres ~ . d or implied , of the Defense Ad~eanced Research Projects Agency or the United States 

il AGRAM MAR FOR MALISM
A General Characterization
Our grammar formalism is beet characterized as n specialized type of augmented contextfree grammar ? That is  , we take a grammar to be a set of context-fres rules that define a language and associate structural descriptions  ( parse trees ) for each sentence in that language in the usual way  . Nodes in the parse tree are assumed to have a set of features which may assume binary values  ( True or False )  , and there is a distinguished attribute -- the " translation ' -- whoee values range over a potentially infinite set of objects  , i . e . , the translations of English phrases . 
Viewed more abstractly , we regard translation as a binary relation between word sequences and logical formulas  . The use of a relation is intended to incorporate the fact that many word sequences have several logical forms  , while some have none at all . 
Furthermore , we view this relation as being composed ( in the mathematical sense ) of four simple relations corresponding to the conceptual phases of analysis :  ( 1 ) LEX ( lexical analysis )  , (2) PARSE ( parsing ) , (3) ANNOTATE(assignment of attribute values , syntactic filtering ) , and (4) TRANSLATE ( translation proper , i . e . , synthesis of logical form ) . 
The domains and ranges of these relations are as follows: 
Word Sequences - LEX -*
Morpheme Sequences - PARSE -*
Phrase Structure Trees-ANN OTATE -*
Annotated Trees-TRANS LATE-*
Logical Form
The relational composition of these four relations is the full translation relation associating word sequences with logical forms  . The subphases too are viewed as relations to reflect the inherent nondeterminism of each stage of the process  . For example , the sentence = a hat by every designer sent from Paris was felt " is easily seen to be nondeterministic in LEX  ( ' felt ' )  , PARSE ( poetnominal modifier attachment ) , and
TRANSLATE ( quantifier scoping).
It should be emphasized that the correspondence b tween processing phases and these conceptual phases is loose  . The goal of the separation is to make specification of the process perspicous and to allow simple  , clean implementations . An actual system could achieve the net effect of the various stages in many ways  , and numerous op-timizatious could been visioned that would have the effect of folding back later phases to increasefficiency  . 
B The Relations LEX , PARSE , and ANNOTATE We now describe a characteristic form of specification ap- 
RULES : constant corn , '-(~ e(XQCX xCPCQ x )))))
S--*NP VP
Truss : VP'\[NP'\]
VP-*T~qSEV
Aano:\[-~Transitivo(V)\]
Tr ,=,: couP'\[~'\]t ~'\] lEXICON :
If -* John
Aano:\[Proper(W)\]
Truss : John
TENSE - * & put
Trash : ( X x C past X ))

A non:\[-~Trasnitivn(V)\]
Trnn : C~x Canx ))
Figure 1: Sample specification of augmented phrase structure grammar propriate to each phase and illustrate how the word sequence " John went " is analyzed by stages as standing in t be translation relation to "  ( past ( gojohn ) )" according to the ( trivial ) grammar presented in
Figure 1.
Lexieal analysis is specified by giving a kernel relation between individual words and morpheme sequences I  ( or equivalently , a mapping from words to sets of morpheme sequences  )  , for example :
John -* ( john ) : vent -* ( kput go ) : persuaded -+ ( k put persuade ) o ( kppl persuadn ) : The kernel relation is extended in a standard fashion to the full LEX relation  . For example , " went " is mapped onto the single morpheme sequence  ( & past go )  , and " John " is mapped to ( john ) . Thus , by extension , " John went " is transformed to ( John & postgo ) by the lexical analysis phase . 
Parsing is specified in the usual manner by a contextfree grammar  . Utilizing thee on text , -free rules presented in the sample system specification shown in Figure  1  ,   ( John 8cpastgo ) is transformed into the parse tree ( S ( NP john ) 
C~(r  ~ rs Et put)

Every node in the parse tree has a set of associated features  . 
The purpo6e of ANNOTATE is to relate the bate parse tree to one that has been enhanced with attribute values  , filtering out three that do not satisfy stated syntactic restrictions  . These restrictions are given as Boolean expressions associated with the contextfree rules  ; a tree is properly annotated only if all the Boolean expressions corresponding to the rules used in the analysis are simultaneously true  . Again , using the rules of Figure 1 , l of course , more sophisticated spprote he ~ to morpholosles l sualysls would seek to analyze the LEX relgtion more fully  . See , for example , ~ Kartunnen , lgS2J gad\[K splan ,  19811 . 
( s ( SP john )   ( W ( ~ a put )   ( V go ) )  ) is transformed into ( S ( NP : Proper john )   ( W :" ~ Trandlive ( ~ ~ aet )   ( V :- Transitive go ) ) ) 
C The Relation TRANS LATE
Logical-form synthesis rules are specified as augments to the contextfree grammar  . There is a language whose expressions denote translations  ( yntactic formulas )  ; an expression from this language is attached to each contextfree rule and serves to define the composite translation at a node in terms of the translations of its immediate constituents  . In the sample sentence , TENSE ' and V ' the translations of TENSE and V respectively  ) would denote the )  , -expressions specified in their respective translation rules  . VP ' the translation of the VP ) is defined to be the value of ( SAP ( SAPCOMP'TENSE' ) V ' )  , where COMF ' is a constant k-expression and SAP is the symbolic-application operator  . This works out to be ( kX\[past(goX ))) . Finally , the symbolic application of VP'toN'P'yields ( past ( go John ) ) .   ( For convenience we shallhence for thuse square brackets for SAP and designate  ( SAP a ~ ) by a\[~\] . ) Before describing the symbolic-application perator in more detail  , it is necessary to explain the exact nature of the data objects serving as translations  . At one level , it is convenient to think of the translations as X-expressions  , inceX-expressions are a convenient notation for specifying how fragments of a translation are substituted into their appropriate operator -operand positions in the formula being assembled -especially when the composition rules follow the syntactic structure as encoded in the parse tree  . There are several phenomena , however , that require the storage of more information at a node than can be represented in a bare k -expression  . Two of the most conspicuous phenonema of this type are quantifier scoping and unbounded epen -dencies  ( " gaps " )  . 
Our approach to quantifier scoping has been to take a version of Cooper's storage technique  , originally proposed in the context of model -t beoretic semantics  , \[ Cooper , forthcoming\[and adapt it to the needs of translation  . For the time being , let us take translations to be ordered pairs whose first component  ( the head ) is an expression in the target language , characteristically ak-expression . The second component of the pair is an object called storage  , a structured collection of sential operators that can be applied to a sentence matrix in such awayas to introduce a quantifier and " capture " a free variable occurring in that sentence matrix  . 2 For example , the translation of " a happy man " might be < m , (XS(somem(and(manm ) ( happym )) S )) > . s Here the head is m ( simply a free variable ) , and storage consists of the X-expression ( kS 2in the sample grammar presented in Appendix A , the storage . formlng operation is notated m k . mbd . 
3 Followlng\[Moore , lO80 ~ , a quantified expression is of the form ( quauti6er , variable , restriction , body ) . . . ) . If the verb phrase " sleeps ~ were to receive the translation <  ( X X ( sleep X ) ) , ~>( i . e . , a unary predicate as head and no storage ) , then the symbolic application of the verb phrase translation to the noun phrase translation would compose the heads in the usual way and take the " uniou " of the storage yielding <  ( sleep m )  , ( kS ( somem ( and ( manm ) ( happy m )) S )) > . 
We define an operation called ~ pull . s , " which has the effect of " pulling " the sentence operator out of storage and applying it to the head  . There is another pull operation , pull . v , which operates on heads representing unary predicates rather than sentence matrices  . 
When pull . s is applied in our example , it yields < ( some m ( and ( manm ) (happy m ) )  ( sleep m ) ) , ~b > , corresponding to the translation of the clause ~ a happy man sleeps  . " Note that in the process the free variable m has been " captured  . " In model theoretic semantics this capture would ordinarily be meaningless  , although one can complicate the mathematical machinery to achieve the same effect  . Since translation is fundamentally a syntactic process  , however , this operation is well-defined and quite natural . 
To handle gaps , we enriched the translations with a third component : a variable corresponding to the gapped position  . For example , the translation of the relative clause " . , . \[ that \] he mans aw " would be a triple : < ( past ( see XY ) ) , Y , ( kS(theX(manX )$)) > , where the second component , Y tracks the free variable corresponding to the gap  . At the node at which the gap was to be discharged  , X-abstraction would occur ( as specified in the grammar by the operation " uugap '  ) producing the unary predicate ( XY ( past ( see XY ) ) )  , which would ultimately be applied to the variable corresponding to the head of the noun phrase  . 
It turns out that triples consisting of ( head , var , storage ) are adequate to serve as translations of a large class of phrases  , but that the application operator needs to distinguish two subcases  ( which we call type A and type B objects )  . Until now we have been discussing type A objects , whose application rule is given ( roughly ) as < hal , vat , san>l < hal ' , vat' , san'>\[-~<(hdhd ') , varLIvar ' , sto i3 sto '> where one of vator vat ' must be null . In the ease of type B objects , which are assigned primarily as translations of determiners  , the rule is < hd , var , san>\[<hd ' , var' , sto '>\] = < var , var ' , hd(hd')Us to Usto '> For example , if the meaning of " every " is every ' ~- < ( kP ( XS ( every X ( PX ) S ) ) )  , X , ~b > and the meaning of ~ man " is man'----< man  ,  ~ , ~> then the meaning of " every man " is every '\ [ man'\]=  ( X ,  ? , (XS(manX)S ) > , as expected . 
Nondeterminismenters in two ways . First , since pull opera , tions can be invoked nondeterministically t various nodes in the parse tree  ( as specified by the grammar )  , there exists the possibility of computing multiple scopings for a single contextfree parse tree  . ( See Section III . B for an example of this phenomenon . ) In addition , the grammar writer can specify explicit nondeterminism by associating several distinct ranslation rules with a single contextfree production  . 
In this case , he can control the application of a translation schema by specifying for each schema guard  , a Boolean combination of features that the nodes analyzed by the production must satisfy in order for the translation schema to be applicable  . 
D Implementation of a Translation System The techniques presented in Sections H  . B and II . C were implemented in a parsing and translation system called PATR which was used as a component in a dialogue system discussed in Section III  . B . 
The input to the system is a sentence , which is preprocessed by a lexical analyzer . Parsing is performed by a simple recursive descent parser  , augmented to add annotations to the nodes of the parse tree  . 
Translation is then done in a separate pass over the annotated parse tree  . Thus the four conceptual phases are implemented as three actual processing phases  . This folding of two phases into one was done purely for reasons of efficiency and has no effect on the actual results obtained by the system  . Functions to perform the storage manipulation , gaph and ling , and the other features of translation presented earlier have all been realized in the translation component of the running system  . 
The next section describes an actual grammar that has been used in conjunction with this translation system  . 
IIIEX PERIMENTS INPRODUCING ANDUSING
LOGICAL FORM
AA Working Grammar
To illustrate the ease with which diverse semantic features could be handled  , a grammar was written that defines a semantically interesting fragment of English along with its translation into logical form\[Moore  ,  1981\] . The grammar for the fragment illustrated in this dialogue is compact occupying only a few pages  , yet it gives both syntax and semantics for moda is  , tense , aspect , passives , and lexically control-led infinitival complements  .   ( A portion of the grammar is included as Appendix A  . ) 4The full test grammar , Io , ~ely based on DIAGRAM\[Robinson ,   1982\] but restricted and modified to reflect changes in a ~ proach  , was the grammar used to specify the translations of the sentences in the sample dialogue of Appendix C  . 
BAn Example of the System's Operation The grammar presented in Appendix A encodes a relation between sentences and expressions in logical form  . We now present a sample of this relation , as well as its derivation , with a sample sentence : " E very man persuaded a woman to go  . " Lexical analysis relates the sample sentence to two morpheme streams : every man & ppi persuade a woman to go  4Since this is just a small portion of the actual grammar selected for expository purposes  , many of the phrasal categories and annotations will seem unmotivated and needlessly complex  . These categories and annotations m'e utilized elsewhere in the test grammar  . 
*, every man , ~ past persuade a woman to go.
The first is immediately eliminated because there is no contextfree parse for it in the grammar  . The second , however , is parsed as \[ S ( SDEC ( NP ( DETP ( DDET ( VET every ) ) ) 
C~uCN0m~V ( SOUNCsre , a ) ) ) ) )   ( Pn~ICar ~ ( * u ~ ( TE~Ekpaat ) )  ( VPP ( V ? C V ? T ( Vpersuado ) ) )   ( ~  ( DET ? CA a ) )  ( ~ u ( N nm ~ ( ~ vtmCN womm ) ) ) ) )   ( INFINITIVE ( TO to ) 
CV ~ Cv?CWTCV go\]
While parsing is being done , annotations are added to each node of the parse tree  . For instance , the NP-*DETPNOM rule includes the annotation rule AGREE  ( NP , DETP , Definite ) . AGREE is one of a set of macros defined for the convenience of the grammar writer  . This particular macro invocation is equivalent to the Boolean expression Definite  ( NP ) ~Definite ( DETP )  . Since the DETP node itself has the annotation Definite as a result of the preceding annotation process  , the NP node now gets the annotation Definite as well oAt the bottom level  , the Definite annotation was derived from the lexical entry for the word " eves y '  . s The whole parse tree receives the following annotation :\[ SCb'~O  ( lqP : Delinite ( DETP:DeBnite
CDDET:DeBnite(DET:DeBuite eve1"y)))
CNOU(stump CNO~CSm~)))))
CPR~ICATECAU ~ CTENSE~put ) )  ( VP PC VP : Active ( VPT : Active , Ttansitlve , Takes ln ? ( V : Active , Transitive , Takes fn\[porsuade )) 0~'( DET ? CA a))
CNOUC ~ la ' ~ C ~ mlC ~ , , on ~)))))
CD r ~ ISZTZ'W ( TO to )   ( v PP ( w : Active ( VPT : Active
Cv : Active sol
Finally , the entire annotated parse tree is traversed to assign translations to the nodes through a direct implementation f the process described in Section II  . C .   ( Type A and B objects in the following examples are marked with a prefix ' A : ' or ' B :'  . ) For instance , the VP node covering ( persuade a woman to go ) , has the translation rule VPT'\[N'P'\]\[INFINITIVE  '\]  . When this is applied to the translations of the node's constituents  , we have CA:CAX CAP ( ~ T ( persuade ? X ( PX ) ) ) ~ \[ , CA : X2 .  ~, . C ~ S ( some X2C womu X2 ) S ) )~\] \[ cA : ( ~ xC  ~ x ) )~\] which , after the appropriate applications are performed , yields CA:CAP(~Y ( persuade YX2CPX2)))) .  ~ , ( AS(some X2(~-X2) S )) ~5Note that , although the annotation phase was described and is implemented procedurally  , the process actually used guarantees that the resulting annotation is ex "" ty the one specifie de claratlve ~ y by the annotation rules  . 
\[ o , :  ( Ax ( gox ) )>\] = CA : ( )/?  ( persuade TX2 ( go X2 ) ) )  . ~ b ,
CAS ( some X2 ( roman X2) S )) ~
After the past operator has been applied , we have < A:CAT ( pant ( per sum de Y X 2 ( go X2 ) ) ) ) . ~ b ,
CAS ( some X2(~znuX2)S )))
At this point , the pull operator ( pull . v ) can be used to bring the quantifier out of storage  , yielding 6< A:CAY ( some ~2 ( womb\]\[2 )   ( pant ( peramadoT ~ ( go Y g ) ) ) ) )  . 
This will ultimately result in " a woman " getting narrow scope  . The other alternative is for the quantifier to remain in storage  , to be pulled only at the full sentence lvel , resulting in the other scoping . In Figure 2 , we have added the translations to all the nodes of the parse tree  . 
Nodes with the same translations as their parents were left unmarked  . 
From examination of the S node translations , the original sentence is given the fully-scoped translations  ( every X2 ( man \] ( 2 )   ( some Xi ( woman Xi )   ( paSt ( persuade % , 9X ! ( goXl )   )   )   )   ) and ( some XI ( vo ~ Xl )   ( every X ~2 ( nan X2 )   ( pant ( persuade X2 Xl ( goXl )   ) ) )   ) 
CA Simple Question-Answering System
As mentioned in Section I , we were able to demonstrate he semantic a pabilities of our language system by assembling a small question-answering system  . Our strategy was to first translate English into logical formulas of the type discussed in \[ Moore  ,  1981\] , which were then postprocessed into a form suitable for a first-order deduction system  .  7  ( Another possible approach would have been to translate directly into first-order logic  , or to develop direct proof procedures for the non -first-order language  . ) Thus , we were able to integrate all the components into a question-answering system by providing a simple control structure that accepted an input  , translated it into logical form , reduced the translation to first-order logic , and then either asserted the translation i the case of declaratives ntences or attempted to prove it in the case of interrogatives  . ( Only yes/no questions have been implemented . ) The main point of interest is that our question -answering system was able to handle complex semantic entailments involving tense  , modality , and so on -- that , moreover , it was not restricted to extensional evMuation in a database  , as with conventional question-answering systems . For example , our system was able to handle the entailments of sentences like John could not have been persuaded to go  . 
(The transcript of a sample dialogue is included as Appendix C  . ) 6 For convenience , when a final constituent o1'a translation is ~ it is often not written . Thus we could have written < A : ( kY ( some . . . )  . . . ) > in this cue . 
7We used a connection graph theorem prover written by Mark Stickel \[ Stlckel  , forthcoming \] . 
( S :< A : ( pant(persuadeXIX2(go ~))). ~.
(A S ( every X1 ( nan X1 ) S ) )  ( ) ~ S ( some ~ ( veto \]\[2 ) S ) )> , < A : ( some \]\[2 ( ~man X2 )   ( past C persua4e X1Y , 2(goYo )))) 0 ~ . 
(~ 8  ( every Zl ( man \]\[ I ) S ) )> < A : ( every X2Cn an X2 )   ( some XI ( woman X1 )   ( pant ( persuade X2 Xl ( go Y ~ ) )  ) ) ) > cA : ( souXl ( wuan X1 )   ( every \]\[2 ( man X2 )   ( pant ( p0rsua de X2li ( go \]\[2 ) )  )  >  ( SV ~ ( NP :< A : Xl .  ~ .   ( AS ( every Xl ( muXl ) S ) ) ) CDKTP : ?~: CAP ( ~ S ( every X ( PI ) S ) ) )  . 
X  ~ ( DDET ( DET every ) ) )   ( NDU:cA:CAX ( man X ) ) )   ( None ( Nmm ( xm~n ) ) ) ) )   ( PREDICATE : < A : ( AX ( past ( persuade Y X 2 ( go X2 ) ) ) ) . ~ b . 
CAS ( some X2 ( woma X2) S))) , < X:CAX ( son X2 ( woean X2 )   ( pant ( persuade Y X 2 ( go X2 ) ) ) ) )  . 
( AU~P:o ,: CAPCAX(pant(Px )))) >
C ' X ' ~ a ~ , , . t ) )  ( VP P :< A : ( A ? ( persuade ?\]\[2 ( go \]\[2 ) ) )  . ~ b . 
CAS ( some X2 ( wn--X2 ) S ) )~  ( VP ( VP T : cA : ( X X
CAP ( )~ Y ( persuade ? X ( P ? ) ) ) )  ( V persuade ) ) )   ( ~: cA:X2 .  ~ , CAS ( some X2 ( wona Z2 ) S ) )~  ( DETP:<S : ( kP ( AS ( SoNX ( PX ) S ) ) )  . 

CA n ) )  ( ~ li: ( A : ( X X ( womm X ) )>  ( N0 ~ ( N 0uw ( w , mm  ~ ) ) ) ) )   ( INFINITIVE ( TO : none to )   ( VPP:ca: ( > , X(goX )) > ( w(vPT(vso \] Figure 2: . Node-by-node translation of a sample sentence The reduction of logical form to first-order logic  ( FOL ) was parameterized by a set of recursive xpansions for the syntactic elements of logical form in a manner similar to Moore's use of an sxiomatization of a modal anguage of belief  . \[ Moore , 1980\]For example , ( pastP ) is expanded , with respect to a possible world w , as ( some w2( and ( past w2w ) < P , w2>)) where " < P , w 2>" denotes the recursive FOL reduction of P relative to the world  w2  . The logical form that was derived for the sample sentence " John went ~ therefore reduces to the first-order sentence  ( some w ( and ( past wREALWORLD ) (go w John ) ) )  . 
More complicated illustrations of the results of translation and reduction are shown in Figure  3  . Note , for example , the use of restricted quantification iLF and ordinary quantification iFOL  . 
To compute the correct semantic entailments , the deduction system was preloaded with a set of meaning postulates  ( axioms ) giving inferential substance to the predicates a sociated with lexical items  ( see
IM rffT : everyntanus ~ behappyiF : ( every X ( mX )   ( tacosnry ( tad ( happy X )   ( thlng X ) ) ) )
FOL : ( every x0172 ( implies ( mtuREAL WORLD xOI 72 )   ( overywO 173 ( implies ( posn BEAL gORLD ~173 )   ( tad ( happy ~ O175 zOt 72 )   ( ~ hi~Ot73 z01 72 )   )   )   )   )   ) 
II ~ UT : bill persuaded john to goi F : ( ptat ( porsut de bill john ( gojohn ) ) ) 
FOL:(somes0175 ( ud(pant w0175 RF . .ALQP . LD )   ( souwOrTS ( Imd ( perma a dew0175 bill John wOlT ? )   ( gow Ol Te John ) ) ) ) ) Figure 3: Translation to LF and Reduction to FOL
Appendix B).
IVFURTHEREXTENSIONS
We are continuing to refine the grammar formalism and improve the implementation  . Some of the refinements are intended to make the annotations and translations easier to write  . Examples include : Allowing nonbinary features , including sets of values , in the annotations and guards ( extending the language to include equality and set operations  )  . 
Generalizing the language used to specify synthesis of logical forms and developing a more uniform treatment of translation types  . 
Generalizing the " gap * variable feature to handle arbitrary collections of designated variables by using an " environment " mechanism  . This is useful in achieving a uniform treatment of free word order in verb complements and modifiers  . 
In addition , we are working on extensions of the syntactic machinery  , including phrase-linking grammars to handle displacement phenomena\[Peters  ,  1981\] , and methods for generating the augmented phrase structure grammar through a metarule formalism similar to that of \[ Konolige  ,  1980\] . We have also experimented with alternative parsing algorithms  , including a chart parser \[ Bear ,   197g \] adapted to carry out annotation and translation in the manner described in this paper  . 

Bear , John , and Lanri Karttunen . PSG : A Simple Phrase Structure Parser . Texas Linguistic Forum , vol .  14 .  1979 . 
Cooper , Robin . Quantification and Syntactic Theory . Forthcoming . 
Reidel , Dordrecht.
Gazdar , Gerald . Phrase Structure Grammar . To appear in Jacobsen , O . and G . K . Pullum ( eds . ) On the Nature of Syntactic

Kaplan , R . M . , and Martin Kay . Personal communication .  1981 . 
Karttunen , Lauri , Rebecca Root , and Hans Uszkoreit . Morphological analysis of Finnish by computer . Paper presented at the ACL session of the 1981 LSA Annual Meeting , New York , December 1981 . 
Konolige , Karl . Capturing linguistic generalizations with metarules in an annotat  . d phrase-structure grammar . Proceedings of the 18th Annual Meeting of the Association for Computational Linguistics  , University of Pennsylvania , Philadelphia , June 1980 . 
Moore , Robert C . Problems in Logical Form . Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics  , Stanford University , Pale Alto , June ,  1981 . 
Moore , Robert C . Reasoning About Knowledge and Action . SRI International , Technical Note 191 . October , 1980 . 
Peters , Stanley , and Robert W . Ritchie . Phrase Linking Grammars . 
December 1981. Unpublished manuscript.
Robinson , Jane . DIAGRAM : A Grammar for Dialogues ? Communications of the ACM  , ~5:1 ( January ,  1982) 27--47 . 
Stickel , Mark . A Non-Clausal Connection Graph Resolution Theorem
Proving Program . Forthcoming.
APPENDIXA . Sample Grammar Rules
The following is a portion of a test grammar for the PATR English translation system  . Only those portions of the grammar utilized in analyzing the sample sentences in the text were included  . 
The full grammar handles the following constructs : medals  , adjec-rivals , tense , predicative and nonpredicative copulatives , adverbials , quantified noun phrases , aspect , NP , PP , and infinitival complements , relative clauses , yes/no questions , restricted wh-questions , noun-noun compounds , passives , and prepositional phrases as predicates and ad * jectivals  . 
a ~ smffiamumamGrlmlN , rhles ? . m  ~ .   .   .   . ~mssmtmCone~mtEQ ' ? curry(X , ,AIIBDA ( X ?) ( equal X ?))
Coast & at PASS'8 < A : ( LA ~ DAP ( LAIEDAX ( ( P X ) T ) ) )  . NIL , ( IIX . IIBD ( QUOTE ( LAII BDAS ( some T ( thing Y ) S ) ) ) ) >
Constant PhSSIIF '? < A : ( LAM ~ ) AP ( LAMBDAI ( ~& x ( ( ( Px ) I )  ? ) ) ) )  . NIL , ( MI ( . MBD(QUOTE(IAMBDASC some ? ( thing ?) S )) >
AUXP->TENSE;


DDET->DET :
Annotation :\ [ Defiaite(DDET)\]


DETP->A;
Annotation :\[ ~ Definite(DETP)\]


DETP->DDET ;
Annotation : \[ AGREE(DET ?. DDET , Definite)\]


II~INITIV~-~TOVPP;
Annotation : \[ AGREECINFINITIVE . VPP , G * ppy . h)\]
Translation : pull . v(VPP')
NON->NO~qD;
Annotation :\[ AOREE(NOM . NOMHD . O~ppy)\]


NOMHD-)NOUN ;


NOUN->N ;


NP-)DE?P ~ M;
Annotation : \[ AOP ~ CNP . NOM . Gappy ) \]\[ Predicative ( NP ) % / ~ Predicative ( NP ) \]\[ AGREE ( N  ~ . DETP , Definite )\]
Translation : ~ Predica ~ ive ( ~ ) : DET~'\[NOM'\]Definite ( NP ) A Predicative ( NP ) : E~'\[DETP'\[NQM'\]\]~Definite ( NP ) ? Predicative ( NP ) : NON '
PREDICATE->AU\]~~;
Annotation : \[ AORE ~ ( PREDICATE . VPP . Active . 0 appy . ~ h)\]
Translation : pull.v(A ~ '\[ VPP'\])
S-)SDEC;
Annotation :\[ ~ Oappy(.~'~EC)\]\[~(~EC)\]
Translation :
SDEC'&DEC-)NPPREDICATE;
Annotation : \[0 appy ( NP ) VG appy ( I~DICATE )  ?- ) G ~ p p y ( S ) EC ) \]\[~ Predicative ( NP ) \]\[ h ( N  ~ ) ~/ b ( PREDICATE ) <=> Wb ( SDEC )  \] \[ -  ( Onppy ( NP ) a Onppy ( PKEDICATE ) ) \]
Truslation : pull.s(PR~DICATE'\[NP'\])
VP-,VPT;
Annotation : \[ ~ TrLnsitive ( VPT ) \]\[-TL keelnZCV ~ T ) \]\[ Active ( VPT ) \]\[ Active CVP )  \]


VP->VPTNPI~FINITIVE;
Annotation : \[ Takes lnf ( VPT ) \]\[ Transitive ( VPT ) \]\[~P ~ , dicativ , (~)\]\[AOP~:~(~ . VPT . Active ) \]\[ Wh ( NP ) %/ Wh ( INFmITIW ) ~-* Wh ( VP ) \]\[ IY ( lctive ( VPT )  . 
((O&ppy(~)~/Oappy(~INITIVE)) , =) Sappy (% ~ D )) , ( ~ Oappy(~T ) kOappy(NP )))\]

Active (%?): pulI . v ( % ~ OT?\[NP'\]\[I~INITI ~'\] ) ~ Active ( VP ) : pull . v(P~Sl~'~T'\]\[INFINITIVE'\])
V ~ - ~ VP ;
Annotation :\ [ a ~( v l ~ . VP , Gappy . h)\]\[Active(VP)\]


VPT->V ;
Annotation : \[ AOREE(VPT . V . Active . Transitive . T ~ kenInf)\]


N->nan:
Translation : ? a:mum , NIL , NIL)
Translation : ? A : ~ man . NIL , NIL)
DET-)every:
Annotation :\[ Definite(DET)\]
Translation : ( B : ( LAI ~ AP ( LAMBDAS ( every X ( PX ) S ) ) )  . X . NIL ?
A-~&;
Translation : ~ B: ( IA~mDAP ( ~DAS ( some X ( PX ) S ) ) )  . X , NIL ?
V - ~ persuade;
Annotation : \[ Transitive ( V ) \]\[ Active ( V ) ~/ ~ Active ( V ) \]\[ TL keslnf ( V )  \]
Translation : curry ( LAIf BDA ( XPY )   ( persuade Yl ( PX ) ) ) 
V -> go ;
Annotation : \[~ Traneitive ( V ) \]\[-TskesZ ~ CV ) \]\[ Active CV )  \]
Translation : < A : go , NIL . NIL
TENSE -> & past;
Translation : curry ( LAI ~ A ( PX )   ( past ~ X ) ) ) 
APPENDIXB . Meaning Postulates ( every ? ( everyu ( iff ( pant ? u )   (   . or ( putu ?\] ( eTery ? ( someu ( put ? U ) ) ) \[ every ? ( every ? ( every y ( everyz ( implies ( promise ? ? y z )   ( put ? z \]\ [ every ? ( every ? ( every y ( everyz ( implies ( persuade ? ? yz )   ( pant ? z \] ( every ? ( every ? ( thing ? x )   )   ) \[ every ? ( every x ( everyz ( implies ( want?s z )   ( put ? z\] ( every ? ( pose ? v ) ) \[ every v ( everyu ( implies ( pant ? u )   ( pose ? u ) \[ every ? ( everyu ( every v ( implies ( and ( pant l ? u )   ( pantluv ) )  ( pant2 ? v\]\[every ? ( everyz ( implies ( past 2 ? z )   ( pant ? z \]\ [ every v ( everyz ( if ! ( past ? z )   ( put l ? z \] ~ is john a happy man

?> noman could have hidden a book

>) did john hide a book

> ~ bill hid a book

? ~ is billaman

~> wwj ohn a sum
I don't know.
>> every ? an ? ill be an an

>) ? illjoh ? nan

~, bill persuaded john to go

?> could john have been persuaded top

>>? illjohn be persuaded to go
I do n ' t k n e e .
APPENDIXC . Transcript of Sample Dialo ~ ue ? ~ john is happy

~ is john happy

>> is john a happy m n n
I do n't k no ? .
>> john is a mannK .
