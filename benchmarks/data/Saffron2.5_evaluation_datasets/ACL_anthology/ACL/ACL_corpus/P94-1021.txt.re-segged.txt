Constraint-Based Categorial Grammar
Gosse Bouma and Gertjan van Noord
Alfa-informatic and
Behavorial and Cognitive Neurosciences,
Rijksuniversiteit Groningen
gosse , vannoord@let.rug.nl
Abstract
We propose a generalization f Categorial Grammar in which lexical categories are defined by means of recursive constraints  . In particular , the introduction of relational constraints allows one to capture the effects of  ( recursive ) lexical rules in a computationally attractive manner  . We illustrate the linguistic merits of the new approach by showing how it accounts for the syntax of Dutch cross-serial dependencies and the position and scope of adjuncts in such constructions  . Delayed evaluation is used to process grammars containing recursive constraints  . 
1 Introduction
Combinations of Categorial Grammar ( co ) and unification naturally lead to the introduction of polymorphic categories  . Thus , Kart tunen (1989) categorizes NP's as X/X , where x is a verbal category , Zeevatelal . (1987) assign the category X/(NP\X ) to NP's , and Emms ( 1993 ) extends the Lambek-calculus with polymorphicate -gories to account for coordination  , quantifier scope , and extraction . 
The role of polymorphism has been restricted , however , by the fact that in previous work categories were defined as feature structures using the simple  , nonrecursive , constraints familiar from feature description languages such as PATR  . Relational constraints can be used to define a range of polymorphicategories that are beyond the expressive capabilities of previous approaches  . 
In particular , the introduction of relational constraints captures the effects of  ( recursive ) lexical rules in a computationally attractive manner  . The addition of such rules makes it feasible to consider truly ' lexicalist ' grammars  , in which a powerfulexical component is accompanied by a highly restricted syntactic ompo -nent  , consisting of application only . 
2 Recursive Constraints
IncG , many grammatical concepts can only be defined recursively  . Dowty ( 1982 ) defines grammatical function such as subject and object as being the ultimate and penultimate ' argument-in ' of a verbal category  . Hoeksema ( 1984 ) defines verbs as exocentric at-egories reducible to s  . Lexical rules frequently refer to such concepts . For instance , a categorial lexical rule of passive applies to verb selecting an object and must remove the subject  . 
In standard unification-based formalisms , these concepts and the rules referring to such concepts cannot be expresse directly  . 
2.1 Subject-verb agreement
Consider a categorial treatment of subject verb agreement with intransitive  ( NP\[NOM\]\S ) and transitive ( ( NP\[NOM\]\S ) /NP\[ACC\] ) verbs defined as follows: ( 1 ) lez ( walks , X):-iv(X) . 
/ez(kisses,X):-tv(X).
vat\[eats\]iv ( dir '\' arg\[cat np\] ) " case no raiv ( valdir'/'vat\[cats\]dir'\'arg\[cat np \] case nomarg\[calnp\]case a CESubject-verb agreement can be incorporated easily if one reduces agreement to a form of subcategorization  . 

If , however , one wishes to distinguish these two pieces of information  ( to avoid a proliferation of subcategorization types or for morphological reasons  , for instance ) , it is not obvious how this could be done without recursive constraints  . For intransitive verbs one needs the constraint that  ( argagr ) = Agr ( where Agr is some agreement value )  , for transitive verbs that ( valargagr ) = Agr , and for ditransitive verbs that ( valval argagr ) = Agr . The generalization is captured using the recursive constraints v_agreement  ( 2 )  . In (2) and below , we use definite clauses to define lexical entries and constraints  . 
Note that lexical entries relate words to feature structures that are defined indirectly as a combination of simple constraints  ( evaluated by means of unification ) and recursive constraints . 1 (2) lex ( walks , X ) :- iv(X ) , sv_agreement(sg3 , X ) . 
lex(kisses , X ) :- tv(X ) , sv_agreement(sg3 , X ) . 
sv-agreement(Agr'\[catnp\]agrAgr\S).
sv_agreement(Agr , Y\X):-sv_agreement(Agr , X ) . 
Relational constraints can also be used to capture the effect of lexical rules  . In a lexicalist theory such as cG , in which syntactic rules are considered to be universally valid scheme's of functor-argument combination  , lexical rules are an essential tool for capturing language-specific generalizations  . As Carpenter (1991) observes , some of the rules that have been proposed must be able to operate recursively  . Predicative formation in English , for instance , uses a lexical rule turning a category reducible to vP into a category reducing to a vP-modifier  ( vP\vP )  . As avP-modifier is reducible to vP , the rule can ( and sometimes must ) be applied recursively . 
2.2 Adjuncts as arguments
Miller ( 1992 ) proposes a lexical rule for French nouns which adds an  ( modifying ) adjective to the list of arguments that the noun subcategorizes for  . Since a noun 1We use X/Y and Y\X as shorthand for dir '/' argY and dir '  , respectively and S , NP , and Adj as ' typed argY variables ' of type\[ cats\]  , \[ cat np\] , and\[catadj\] , respectively . 
can be modified by any number of adjectives , the rule must be optional as well as recursive . The advantages of using a lexical rule in this case is that it simplifies accounting for agreement between ouns and adjectives and that it enables an account of word order constraints between arguments and modifiers of a noun in terms of obliqueness  . 
The idea that modifiers are introduced by means of a lexical rule can be extended to verbs  . That is , adjuncts could be introduced by means of a recursive rule that optionally adds these elements to verbal categories  . 
Such a rule would be an alternative for the standard categorial analysis of adjuncts as  ( endocentric ) functors . 
There is reason to consider this alternative.
In Dutch , for instance , the position of verb modifiers is not fixed . Adjuncts can in principle occur anywhere to the left of the verb:  2   ( 3 ) a . dat Johano pzettelij keenon geluk that J . deliberately an accident vero or zaakt causes that J  . deliberately causes an accident b . dat Johan Marieopzette lijk that J . M . deliberately geen cade augeeft no present gives that J  . deliberately gave M . no present There are several ways to account for this fact  . One can assign multiple categories to adjuncts or one can assign a polymorphicategory x/x to adjuncts  , with x restricted to ' verbal projections ' ( Bouma ,  1988) . 
Alternatively , one can assume that adjuncts are not functors , but arguments of the verb . Since adjuncts are optional , can be iterated , and can occur in several positions , this implies that verbs must be polymorphic . The constraint add_adjuncts has this effect , as it optionally adds one or more adjuncts as arguments to the ' initial ' category of a verb :   ( 4 ) iex ( veroor zaken , X ) :- add_adjuncts(X , NP\(NP\S )) . 
lex(geven , X ) :- add_adjuncts(X , NP\(NP\(NP\S ))) . 
add_adjuncts(S ,).
add_adjuncts(Adj\X,Y ):- add_adjuncts(X,Y).
add_adjuncts(dirD , dirD):-argA argA add_adjuncts(X , Y ) . 
2As we want to abstract away from the effects of ' verb-second '  , we present only examples of subordinate clauses . 

This constraint captures the effect of applying the following  ( schematic ) lexical rule recursively : ( 5 ) xl\ . . . \xi\x,+l\ . . . \s/Y1 . . . Y , #X I\ .   .   . \XikAdjkXi + l\ .   .   . \S/Y1 .   .   . Y . 
The derivation of ( 3a ) is given below ( where X = ~ Y indicates that add_adjuncts ( Y , X ) is satisfied , and IV----

(6) ... J . opzettelij keenon geluk
NP ADJ NP vero or zaak t

NP\(ADJ\IV )



An interesting implication of this analysis is that in a categorial setting the notion ' head ' can be equated with the notion ' main functor '  . This has been proposed by Barry and Pickering ( 1990 )  , but they are forced to assign a category containing Kleene-star operators to verbal elements  . The semantic counterpart of such category -assignments is unclear  . The present proposal is an alternative for such assignments which avoids introducing new categorial operators and which does not lead to semantic complications  ( the semantics of add_adjuncts is presented in section  3  . 3) . Below we argue that this analysis also allows for a straightforward explanation of the distribution and scope of adjuncts in verb phrases headed by a verbal complex  . 
3 Cross-Serial Dependencies
In Dutch , verbs selecting an infinitival complement ( e . g . 
modals and perception verbs ) give rise to so called cross-serial dependencies . The arguments of the verbs involved appear in the same order as the verbs in the ' verb cluster ' :   ( 7 ) a . 

datAn1 Bea2 will kussen ~.
datAnBea wants to kiss that An wants tokiss Bea dat  An1   Bea2   Cor3 Will dat An Bea Corwants zien2   kussen3  . 
to seek is s that Anwants to see Beakiss Cor The property of forming cross-serial dependencies is a lexical property of the matrix verb  . If this verb is a ' trigger ' for cross-serial word order  , this order is obligatory , whereas if it is not , the infinitival complement will follow the verb :   ( 8 ) a . * datAnwil Beakussen . 
b . dat Anzich voornam Beathat An Refl . planned Beatekussen . 
to kiss that An . planned to kiss Beae . * datAnzichBeavoornamtekussen . 
3.1 Generalized Division
Categorial accounts of cross-serial dependencies initially made use of a syntactic rule of composition  ( Steedman ,  1985) . Recognizing the lexical nature of the process , more recent proposals have used either a lexical rule of composition  ( Moortgat ,  1988 ) or a lexical rule of ' division ' ( Hoeksema ,  1991) . Division is a rule which enables a functor to inherit the arguments of its argument  :3 X/Y :: ? , ( X/Z ,   .   .   . IZ , , ) I(Y/Z .   .   . IZ , ) To generate cross-serial dependencies , a ' disharmonic'version of this rule is needed :   ( 9 ) x/v ( zA . . . z . \x)/(zA . . , z . \Y ) Hoek sema proposes that verbs which trigger cross -serial word order are subject to  ( 9 ) :  ( 10 )   .   .   . An Beawilkussen
NP NP IV/IVNP\IV #( NP\IV)/(NP\IV)


In a framework using recursive constraints , generalized disharmonic division can be implemented as a recursive constraint connecting the initial category of such verbs with a derived category :  ( 11 ) lez ( willen , X ) :- cross_serial(X , ( NP\S)/(NP\S )) . 
lez(zien , X ) :- cross_serial(X , ( NP\(NPkS))/(NP\S )) . 
lez(voornemen , ( NP refl\(NP\S ))/( NP\S )) . 
a Argument inheritance is used in HPSG to account for verb clustering in German  ( Hinrichs and Nakazawa ,  1989) . 
The rlPSG analysis is essentially equivalent to Hoek sema's account  . 
149 (12) cross_serial(Out , In ) :- division(Out , In ) , verb_cluster ( Out ) . 
division(X , X).
division(Z\X)/(Z\Y ) , X '/ Y'):-division(X/Y , X '/ Y ') . 

Only verbs that trigger the cross-serial order are subject to the division constraint  . This accounts immediately for the fact that cross -serial orders do not arise with all verbs selecting infinitival complements  . 
3.2 Verb Clusters
The verb_cluster constraint ensures that cross -serial word order is obligatory for verbs subject to cross_serial  . To rule out the ungrammatical (8a ) , for instance , we assume that Beakussen is not a verb cluster . The verb kussen by itself , however , is unspecified for vc , and thus (7a ) is not excluded . 
We do not assume that cross-serial verbs take lexical arguments  ( as has sometimes been suggested )  , as that would rule out the possibility of complex constituent so the right of cross-serial verbs altogether  . If one assumes that a possible bracketing of the verb cluster in  ( 7b ) is\[wil\[zienkussen\]\] ( coordination and fronting data have been used as arguments that this is indeed the case  )  , a cross-serial verb must be able to combine with nonlexical verb clusters  . Furthermore , if a verb selects a particle , the particle can optionally be included in the verb cluster  , and thus can appear either to the right or to the left of a governing cross-serial verb  . For a verb cluster containing two cross-serial verbs  , for instance , we have the following possibilities : (13) a . datAnBeaheeft durvenaan that AnBea hasdared part  . 
tesprekent ospeak that An has dared to speak to Bea  . 
b . datAnBeaheefta an durventespreken.
c . datAnBeaaanheeft durventespreken.
A final piece of evidence for the the fact that cross-serial verbs may take complex phrases as argument stems from the observation that certain adjectival and preposition alr guments can also appear as part of the verb cluster :  ( 14 ) datAnditaan Beah add uidelijk that Ant his to Beahas clear gemaakt made thai An had made this clear to BeaCross-serial verbs select a + vc argument  . Therefore , all phrases that are not verb clusters must be marked-vc  . In general , in combining a ( verbal ) functor with its argument , it is the argument hat determines whether the resulting phrase is-vc  . For instance , NP-arguments always give rise to-VC phrases , whereas particles and verbal arguments do not give rise to-vc phrases  . This suggests that NP's must be marked-vc , that particles and verbs can remain unspecified for this feature  , and that in the syntactic rule for application the value of the feature vc must be reentrant between argument and resultant  . 
3  . 3 The d is t r ibut ion and scope o f ad juncts The analysis of cross-serial dependencies in terms of argument inheritance interacts with the analysis of adjuncts presented in section  2  . 2 . If a matrix verb inherits the arguments of the verb it governs  , it should be possible to find modifiers of the matrix verb between this verb and one of its inherited arguments  . This prediction is borne out (15a ) . However , we also find structurally similar examples in which the adjunct modifies the governed verb  ( 15 b )  . Finally , there are examples that are ambiguous between a wide and narrow scope reading  ( 15 c )  . We take it that the latter case is actually what needs to be accounted for  , i . e . example such as ( 15 a ) and ( 15 b ) are cases in which there is a strong preference for a wide and narrow scope reading  , respectively , but we will remain silent about the ( semantic ) factors determining such preferences . 
(15) a . datFrits Marie volgens mijlijkt that F . M . tome seem steont wijken . 
to avoid
It seems tome that F . avoids M.
b . datFrits Marieopzette lijklijkt that F . M . deliberately seem steont wijken . 
to avoid
It seems that F . deliberately avoids M.
c . datFrits Marie delaat stetij dlijkt that F . M . lately seem steont wijken . 
to avoid
It seems lately as if F . avoids M.
It seems as if F . avoids M . lately
On the assumption that the lexical entries for lijkene nontwijken areas in  ( 16 )  , example ( 15 c ) has two possible derivations ( (17 ) and ( 18 ) ) . Procedurally speaking , the rule that adds adjuncts can be applied either to the matrix verb  ( after division has taken place ) or to the ited ' by the matrix verb . Assuming that adjuncts take scope over the verbs introducing them  , this accounts for the ambiguity observed above . 
(16) lex(lijken , Verb ) :- add_adjuncts(Verb , Verb ') , cross_serial ( V erb ' , ( NP\S)/(NP\S )) . 
lex(on twijken , Verb ) :- add_adjuncts(Verb , NP\(NP\S )) . 
(17)... delaat stetij dlijkt
ADJIV/IV teont wijken

TV/TV(AD&TV)/TV

TV (18) . . . delaat stetij dlijktte on twijken
ADJIV/IVTV(ADJ\TV)/(ADJ\TV ) ADJ\TV


The assumption that adjunct scope over the verbs introducing them can be implemented as follows  . We use a unification-based semantics in the spirit of Pereira and Shieber  ( 1987 )  . Furthermore , the semantics is head-driven , i . e . the semantics of a complex constituent is reetrant with the semantics of its head  ( i . e . the functor ) . The feature structure for a transitive verb including semantics  ( taking two NP's of the generalized quantifier type  ( ( e , t ) , tas argument and assigning wide scope to the subject  ) is: ( 19 ) valdir'Varg\[\[cats\]dir ' V\[cat np \]   ar9 sem ( X ^ Sobj ) ^Ss , ,bj cat np \] sem ( Y^kiss(X , V )) A SobjsemSsubiT V Thus , a lexical entry for a transitive verb can be defined as follows  ( where TV refers to the feature structure in 19 ) :  ( 20 ) /ez ( kussen , X ) :- add_adjuncts(X , TV ) . 
The lexical rule for adding adjuncts can now be extended with a semantics :  ( 21 ) add_adjuncts ( \[semSx\]x'\[semSy\]y ) :- add_adj ( X , Y , Sx , Sy ) . 
add_adj(S , S , Sem , Sem).
valX dir ' V add_adj(arg\[add_adj(X , cat adj\]sereSy^SA
Y , Sx , Sa).
, Y , Sx , Sy ) :-\[ va , x\]\[va , Y \] add_adj(dir D , dir D , Sx , Sr ) :- argA argA add_adj(X , Y , Sx , Sy ) . 
Each time an adjunct is added to the subcategorization frame of a verb  , the semantics of the adjunct is ' applied ' to the semantics as it has been built up so far  ( Sy )  , and the result ( SA ) is passed on . The final step in the recursion unifies the semantics that is constructed in this way with the semantics of the ' output ' category  . 
As an adjunct A1 that appears to the left of an adjunct A2 in the string will be added to the subcategorization frame of the governing verb after As is added  , this orders the ( sentential ) scope of adjuncts according to left-to-right word order  . Furthermore , since the scope of adjuncts is now part of a verb 's lexical semantics  , any functor taking such a verb as argument ( e . g . verbs selecting for an infinitival complement ) will have the semantics of these adjuncts in its scope  . 
Note that the alternative treatments of adjuncts mentioned in section  2  . 2 cannot account for the distribution or scope of adjuncts in cross-serial dependency constructions  . Multiple ( i . e . a finite number of ) categorizations cannot account for all possible word orders  , since division implies that a trigger for cross -serial word order may have any number of arguments  , and thus , that the number of ' subcategorization frames ' for such verbs is not fixed  . The polymorphic solution ( assigning adjuncts the category x/x ) does account for word order , but cannot account for narrow scope readings , as the adjunct will always modify the whole verb cluster  ( i . e the matrix verb ) and cannot be made to modify an embedded verb only  . 
4 Processing
The introduction of recursive lexical rules has repercussions for processing as they lead to an infinite number of lexical categories for a given lexical item or  , if one branching derivations of unbounded length . In both cases , a parser may not terminate . One of the main advantages of modeling lexical rules by means of constraints is that it suggests a solution for this problem  . 
A control strategy which delays the evaluation of constraints until certain crucial bits of information are filled in avoids non-termination adin practice leads to grammars in which all constraints are fully evaluated at the end of the parse-process  . 
Consider a grammar in which the only recursive constraint is add_adjuncts  , as defined in section 2 . 2 . The introduction of recursive constraints in itself does not solve the non-termination problem  . If all solutions for add_adjuncts are simply enumerate during lexical lookup an infinite number of categories for any given verb will result  . 
During processing , however , it is not necessarily the case that we need to consider all solutions  . Syntactic processing can lead to a ( partial ) instantiation of the arguments of a constraint . If the right pieces of information are instantiated  , the constraint will only have a finite number of solutions  . 
Consider , for instance , a parse for the following string . 
(22) ... J . opzettelij keenon gelukvero or zaakt
NP ADJ NP Verb




Even if the category of the verb is left completely open initially  , there is only one derivation for this string that reduces to S  ( remember that the syntax uses application only )  . This derivation provides the information that the variable Verb must be a transitive verb selecting one additional adjunct  , and with this information it is easy to check whether the following constraint is satisfied : add_adjuncts  ( NP\ ( ADJ\ ( NP\S )   )  , NP\(NP\S )) . 
This suggests that recursive constraints should not be evaluated during lexical lookup  , but that their evaluation should be delayed until the arguments are sufficiently instantiated  . 
To implement this delayed evaluation strategy , we used the block facility of Sicstus Prolog . For each recursive constraint , a block declaration defines what the conditions are under which it may be evaluated  . The definition of add_adjuncts ( with semantics omitted for readability )  , for instance , now becomes : ( 23 ) add_adjuncts ( \[ argArg\]x , Y ) :- add_adjuncts(X , Y , Arg ) . 
?- block add_adjuncts (?, ?,-).
add_adjuncts(S , ,_).
add_adjuncts(Adj\X , Y , _):-add_adjuncts(X , Y ) . iv y , x\]\[w , Y \] add_adjuncts(dirD , dir D ,  . A . ) :- argA argA add_adjuncts(X,Y ) . 
We use add_adjuncts~2 to extract the information that determines when add_adjuncts/3 is to be evaluated . The block declaration states that add_adjuncts/3 may only be evaluated if the third argument ( i . e . the argument of the ' output ' category ) is not a variable . 
During lexicalook-up , this argument is uninstantiated , and thus , no evaluation takes place . As soon as a verb combines with an argument , the argument category of the verb is instantiated and  add_adjuncts~3 will be evaluated . Note , however , that calls to add_adjuncts ~3 are recursive , and thus one evaluation step may lead to another call to  add_adjuncts~3  , which in its turn will be blocked until the argument has been instantiated sufficiently  . Thus , the recursive constraint is evaluated incrementally  , with each syntactic application step leading to a new evaluation step of the blocked constraint  . 
The recursion will stop if an atomic category s is found  . 
Delayed evaluation leads to a processing model in which the evaluation of lexieal constraints and the construction of derivational structure is completely intertwined  . 
4.1 Other strategies
The delayed evaluation techniques discussed above can be easily implemented in parsers which rely on backtracking for their search  . For the grammars that we have worked with , a simple bottom-up ( shift-reduce ) parser combined with delayed evaluation guarantees termination of the parsing process  . 
To obtain an efficient parser more complicated search strategies are required  . However , chart-based search techniques are not easily generalized for grammars which make use of complex constraints  . Even if the theoretical problems can be solved ( Johnson , 1993; DSrre , 1993) severe practical problems might surface , if the constraints are as complex as the ones proposed here  . 
As an alternative we have implemented chart-based parsers using the ' non-interleaved pruning ' strategy  ( terminology from ( Maxwell III and Kaplan ,  1994)) . 

Using this strategy the parser first builds a parse-forest for a sentence on the basis of the contextfree backbone of the grammar  . In a second processing phase parses are recovered on the basis of the parse forest and the corresponding constraints are applied  . This may be advantageous if the contextfree backbone of the grammar is ' informative ' nough to filter many unsuccessful partial derivations that the parser otherwise would have to check  . 
As clearly a CUG grammar does not contain such an informative contextfree backbone a further step is to use ' selective feature movement '  ( cf . again ( Maxwell III and Kaplan , 1994)) . In this approach the base grammar is compiled into an equivalent modified grammar in which certain constraints from the base grammar are converted to a more complex contextfree backbone in the modified grammar  . 
Again , this technique does not easily give good results for grammars of the type described  . It is not clear at all where we should begin extracting appropriate features for such a modified grammar  , because most information passing is simply too ' indirect ' to be easily compiled into a contextfree backbone  . 
We achieved the best results by using a ' h and -fabricated ' contextfree grammar as the first phase of parsing  . This contextfree grammar builds a parse forest that is then used by the ' real'grammar to obtain appropriate representation  ( s ) for the input sentence . This turned out to reduce parsing times considerably  . 
Clearly such a strategy raises questions on the relation between this contextfree grammar and the CUG grammar  . The contextfree grammar is required to produce a superset of the derivations allowed by the CUG  . 
Given the problems mentioned above it is difficult to show that this is indeed the case  ( if it were easy , then it probably would also be easy to obtain such a contextfree grammar automatically  )  . 
The strategy can be described in somewhat more detail as follows  . The contextfree phase of processing builds a number of items defining the parse forest  , in a form a that can be used by the second processing phase  . 
Such items are four-tuples ( R , Po , P , n ) where R is a rule name ( consistent with the rule names from the CUG )  , P0 , Pare string positions and D describes the string positions associated with each daughter of the rule  ( indicating which part of the string is covered by that daughter  )  . 
Through a head-driven recursive descen the second processing phase recovers derivations on the basis of these items  . Note that the delayed evaluation technique for complex constraints is essential here  . Alternative solutions are obtained by backtracking  . If the first phase has done a good job in pruning many failing search branches then this is not too expensive  , and we do not have to worry about the interaction of caching and complex constraints  . 
5 Final Remarks
In sections 2 and 3 we have sketched an analysis of cross-serial dependency constructions and its interaction with the position and scope of adjuncts  . The rules given there are actually part of a larger fragment that covers the syntax of Dutch verb clusters in more detail  . The fragment accounts for cross-serial dependencies and extraposition constructions  ( including cases of ' partial'extraposition )  , infinitivus-pro-participio , modal and participle inversion , the position of particles in verb clusters , clitic climbing , partial vp-topicalization , and verb second . In the larger fragment , additional recursive constraints are introduced , but the syntax is still restricted to application only  . 
The result of Carpenter ( 1991 ) emphasizes the importance of lexical rules . There is a tendency in both CG and HPSG to rely more and more on mechanisms  ( uch as inheritance and lexical rules or recursive constraints  ) that operate in the lexicon . The unrestricted generative capacity of recursive lexical rules implies that the remaining role of syntax can be extremely simple  . In the examples above we have stressed this by giving an account for the syntax of cross-serial dependencies  ( a construction that is , given some additional assumptions , not contextfree ) using application only . In general , such an approach seems promising , as it locates the sources of complexity for a given grammar in one place  , namely the lexicon . 

Guy Barry and Martin Pickering .  1990 . Dependency and coordination i categorial grammar . In G . Barry and G . Morrill , editors , S~udies in Categorial Grammar . University of Edinburgh . Edinburgh Working
Papers in Cognitive Science 5.
Gosse Bouma .  1988 . Modifiers and specifiers in categorial unification grammar  . Linguistics , 26:21-46 . 
Bob Carpenter .  1991 . The generative power of categorial grammars and head-driven phrase structure grammars with lexical rules  . Computational Linguistics , 17(3):301-313 . 
Jochen D Srre .  1993 . Generalizing earley deduction for constraint -based grammars  . In Jochen Do ~ rre , editor , Computational Aspects of Constraint-Based Linguistic Description  . Dyana-2 Deliverable R1 . 2 . A . 

David R . Dowty .  1982 . Grammatical relations and montague grammar . In Pauline Jacobson and Geoffrey Pullum , editors , The Nature of Syntactic Representation , pages 79-130 . Reidel , Dordrecht . 
Martin Emms .  1993 . Parsing with polymorphism . In Sixth Conference of the European Chapter of the Association for Computational Linguistics  , pages 120-129 . 
Erhard Hinrichs and Tsuneko Nakazawa .  1989 . Flipped out : AUX in German . In Papers from the 25th Annual Regional Meeting of the Chicago Linguistic Society  , pages 187-202 . Chicago Linguistics Society,

Jack Hoeksema .  1984 . Categorial Morphology . Ph . D . 
thesis , Groningen University.
Jack Hoeksema .  1991 . A categorial theory of reanalysis phenomena , ms . RUG Groningen . 
Mark Johnson .  1993 . Memoization in constraint logic programming . Paper presented at the First Workshop on Principles and Practice of Constraint Programming  , April 2830 , Newport , Rhode Island . 
Lauri Karttunen .  1989 . Radic M lexicalism . In Mark R . 
Baltin and Anthony S . Kroch , editors , Alternative Conceptions of Phrase Structure , pages 43-65 . University of Chicago Press . 
John T . Maxwell III and Ronald M . Kaplan .  1994 . The interface between phrasal and functional constraints  . 
Computational Linguistics , 19(4):571-90.
Philip Miller .  1992 . Clitics and Constituents in Phrase
Structure Grammar . Garland , New York.
Michael Moortgat .  1988 . Categorial Investigations . 
Ph.D . thesis , University of Amsterdam.
Fernando C . N . Pereira and Stuart M . Shieber .  1987 . 
Prolog and Natural Language Analysis . Center for the Study of Language and Information Stanford  . 
Mark Steedman .  1985 . Dependency and coordination in the grammar of Dutch and English  . Language , 61:523-68 . 
Henk Zeevat , Ewan Klein , and Jo Calder .  1987 . Unification categorial grammar . In Nicholas Haddock , Ewan Klein , and Glyn Morrill , editors , Categorial Grammar , Unification Grammar and Parsing . Centre for Cognitive Science , University of Edinburgh . 
Volume 1 of Working Papers in Cognitive Science.

