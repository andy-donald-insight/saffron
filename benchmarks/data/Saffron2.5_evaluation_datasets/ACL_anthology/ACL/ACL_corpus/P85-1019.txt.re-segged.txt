Semantic Case frame Parsing and Syntactic Generality 
Philip J . Hayes . Peggy M . Andersen . and Scott Safier
Carnegie Group Incorporated
Commerce Courtat Station Square
Pittsburgi ' ~. PA 15219 USA

We nave implemented a restricted . : lommn parser called Plume " MBuilding on previous work at Carneg = e-Mellon Unfvers = tye  . g .  \[4, 5 .  81 . Plumes approacn too ars = ng~s based on semantic case framem stant ~ a ~ on Th~sn as the advantages of effic = encyongrin ~ atical  , nput . and robustness in the face of ungrammatm caltnput Wh ~ le Plume ~ swell adapted to s = mp te  , :; ~ ectaratwe and ~ mperat=ve utterances , it handles 0ass=yes relatmve clauses anti = nter rogatives in an act nocmanner leading to patciny syntact=c coverage Th~spa Oe  , oulhnesPlume as = tCurrently exfsts and descr , Oesourd et aded de s=gn for extending Plume to handle passives rela~ve clauses  , and = nterrog at lves~n a general manner 1 The Plume Parser Recent work at Carnegie Mellon Umvers = lyeg  .  \[4 .   51 hassinown semant tccase frame=n stant ~ ation to be an  , ghly robust and efficient method of parsing restricted domain ~  n0ut   . In tn~S approach ~0 parsing , a case frame grammar contains lhedoma ~ n-soecific semantic informat = on  , a na " the pars = ng program contains general syntact = cknowledge Input  , smapped on tome grammar using m = s budt-~n syntact = cknowledge nave chosen m=s approach for Plume ":' Ma commercial restricted domam parser ~ because of ~ tsadvantages = n efficfency and robustness Let us take a simple example from a natural language interface  , called NLVMS . thai we are developing under a 1More0:eccs elv . PhjmeTM , smen4 me , ) t lne run-hl t le ~ vstem TM assoclalecl N~m Language Craft an mlegraler Jenvl rollmenl for meoeve too menl of nalura I language  , nteHaces " hePlUm ? 10arser Nnlch translaes Eng#lsl ' llil ~ UIqn to case trame , nslances ,   . samalot comDoneiItottt ~ = srurl-tlme system The dinermal Or-  , 3 111OG~te~H tratislale sire case frame ~ nslance ~ into aoDIical of lspec if IC ! anguaqes  . in JlO Olhonto the Plumer un-brae system , ta . guaqe Craft , nc ! uoes grammar development ~ O Ol S , n cludlng- . 1-; lrH , : h Jre Oedll Or . ln~ltracing , 1ha , ~ ert . 3rmancer neasute menl rOi ) ~ S~r ~ lnPlume Ji ~ a ~ Jltq , ia qeCraftate crOOuctS , It Carnegie Group . ~ . d , Jleu , telltly i , Ire ' ~ lrlrle Or ~ tease Plume . \] n ~ Language CI , If tIt@ , , , Id  ~ , ,Idr v '~ , ' , t\]ot . 1 . + gle:3 ~ , )HO ' ncotoorafe~l contract with Digital Equipment Corporation NLV MS  , sant nter face to Digltal's VMS ~ operating system for '  . /AX ~ computers 2 The Plume grammar for . th~s , ntertace contains the follow=ng semantic case frame  3 correspond = ng ? othe copy command of VMS : \[* copy *: cf-type clausal : header copy:cases  ( file-to-copy:filler*file*:posit ional Direct-Object  )   ( source : filler * directory *: marker from I out of  )   ( destination : filler * file * I * directory *: marker to I into I inlon to  ) \] This defines a case frame called " copy " w~th mreecases : file-to-copy  , source , and destination The hie-to-copy case , s filled by a noioiect of type " file " and appears = n the input as a directoblect Source  , sfilled 0y a " d~rectory " and should appear in me~nput as a preposmonal phrase preceded or marked by the prepos  , t ~ ons " from " or ' out of " Oestinat = on is filled by a " file " or " clirectory " and ~ smarked by " to '  . " into ' . or " onto " Finally the copy command itself is recognized by the header word  , ndicated above ( by header ) as " copy " Using miscase frame . Plume can parse , n 0 uts like:
Copyfop Oaroutot\[x /, nro\[y ~
From\[x\]to\[yJ cooyfopo artoooarcoDy/ rom\[x/ro\[y /  2VMS an OVAX are ? raOemark5 of Olg = talEQu . omen ! Cor Dorallon \] Th . s is as . npiltle O . : e , slols , ~ trner . L ~ e ,, ~ . ~ e . I . .'~, . IIh / ~ fnegral nmar . 

In essence . Plume's parsing algorithm + StOfind a case frame header  , in this case " copy " and use the associated case frame  , " copy " to guide the rest of the parse . Once the case frame has been identified Plume looks for case markers  , and then parses the associated case filler directly following the marker Plume also tnesto parse pomtionally specified cases  , like directOble Ct . in the usual position in the sentence- immediately following the header for direct object  . Any input not accounted for at the end of this procedure is matched against any unfilled cases  , so that cases that are supposed to be marked can be recognized without their markers and pos = tionally indicated cases can be recognized out of their usual positions  , This flemble . 
interpretive style of matching case frames against the input allows Plume to deal with the kind of variation in word order illustrated in the examples above  . 
The above examples implied there was some method to recognize files and direct ones They showed only atomic file and directory descriptions  , but Plume can also deal with more complex ObleCt descnptions In fact  , in Plume grammars , obiects as well as actions can be described by case frames  . For instance , here = s the case frames used to define a file for NLV MS\[*f~le*:  . cf-type nominal : header file ': name ? ( % period ~ extension ) : cases ( name : assign edpt name )   ( extension : assign edpt extension : marker wri tten in : adjective < language >: filler < language >  )   ( creator : filler * person *: marker created by  )   ( directory : filler * directory *: marker in ) \]4 nrmesyntax used ,  . ',, . nVMS . chrector lesare , ncl . calecl Dysau are

5 ~ qa ~, ~~, mOl , lUtl~e, . \] ulOmall < all v + e , : oqn , zes " l ~ . te , mmer ?, 4rl , 1:lual ~ hl , er ~; as Soclaled ? . , fn ~ totnmal , a ~ f ' ~ tf ~ e5 This case frame allows Plume to recogn , zefile descriptions like : 6 fop fop . Par
The file created Oy John
The fortran file in ix/created Oy Joan
The case frame notation and parsing algorithm used here are very similar to those described above for clause level input  . 
The significant differences are additions related to the : a diective and : assigned p attributes of some of the cases above  . While Plumenor mally only looks for fillers after the header in nominal case frames an a diective attnbute of a slot tells Plume that the SlOtfi l let may appear before the header  . 
An : assigned pattribute allows cases to be filled through recognition of a header+This is generally useful for proper names  , such as fop and foo . bar . In the example above . 
the second alternat we header contmns two ' . , ar ~ ables name and ' extension . that can each match any s = ng Je . vorcI . The ClUeSt = on mark Indicates opt = on al~ty , so that meheader can be either a single word or a word followed Dvaper=pal and another word  . The first wOrd , sasmgned to the ~' a na Ole ' name . and IResecond ( if = t = smere ~ to the vanaOle ! extension If ' name or ' extension are matched  , , vnde recognizing a file header , their values are placed , n the name and extenmon cases of " hie " w , ln the above mod , ficat , on sP ~ ume can parse nom qna , case frame sumng the same algor ~ ttnm that ~ t uses for clausal case frames that account for complete sentences  . However there are some interactions between the two levels of parsing  . In particular , mere can be ambiguity about where to attach marked cases ? For anstance  . In:
Copyme for tranfile , n\[ , :/ to\[y /" ~ n\[x r " could e , her fill the directory case of the hie described as ' the for tranhie or could fill the dest + natBon case of the whole copy command  . The second interpretation does not work at the global level because the only place to put " to \ [ y "  , stn that same destination case However . at the time the file descrlpt , onts parsed , tins information is not avadable and so both possible attachments must be considered In general  , if Plume is able to fill a case of a nor a , halcase frame from a which that attachment is not made  . When all input has I~een parsed . Plume retains only t~ose parses t ~ at succeed at the global level  , i . e . . consume all of the input . Others are discarded . 
The current implementation of Plume is based on the nominal and clausal level case frame instant = ation algorithms descnPed above  . Us = ng these algor = thms and are str = cted clommn grammar of case frames like the ones ShO Wn above  . 
Plume can parse aw ~ de variety of ~ m Derat ~ ve and declarative sentences relevant to that doma=n  . However . 
there remain significant gaps , n~ts coverage . Interrogatives are not handled at all : + passives are covered only if mey are explicitly specified = n the grammar ancl relative clauses can only be handled by pretending they are a form of prepos=t=onal phrase The regular and predictable relatt on sn~p between s~mple statements  . ? ~ uestions and relal we clauses and between act =ve and passive sentences ~ s  , veilknown A parser wmcil purports to tnterpret a do hlaln specific tanguage specification using a builtin knowledge of symaxSh Ould account for tills regularity = na general way The current implementer = on of Plumeil as no mecnamsm for doing tn~s  . Eacil ~ n dividual possiD dity for questions relative clauses and passives must be explicitly specified  , n the grammar F or instance , to handle reduced relative clauses as = n " the file created by jim  .   .   .   . created by " ~ sh Sted as a case marker ( compound prepositlor lltn the creator slot of file  . mark+nga description of the creator To handle full relat = ves the case marker must be specified as something hke  "3  ( which < be > ) created by " .   '3 Wh=ie misallows Plume to recognize + the file which was created by Jim "  , " the file created by Jim " . or even " the file created by Jimon Mondav ~ t breaks down on something like " the file created on Monday by Jim ' because the case marker " created by's no longer a unll Moreover using the current techniques  . Plume Sabdtly to ? rhR Curren ! , rno left l~nt ; ~ llon , ) 1PIIIIII@" . * as- . ~ lef/l ~ , ) r , ~ tVt ' nF , iI'l , ) dOI , ,  , I ,   . a seft ,) me ,, 1 . - .  ~  . ti11 laii , -~  ~1 recognize the above inputs=s completely unrelated tO = tsabditytO recognize inputs like : the fi/eJim created on Mon  ( Tay the person that the file was crearectov on Monday the day on which Jim created rneme If an interface could recogmze any of these examptes + t might seem unreasonable to au Ser that ~ t could not recognize all of the others Moreoverg ~venany of the above examples  , a user might reasonaPly expect recogmt = on of related sentence level inputs hke 
Create the hie on Monday '
J ~ m created the hie on Monday
Dt ~ J ~ m create the hie on Moneay ?
Was the hie create ( lIoyJ ~ mon Monclay ~
Who created the hie on Monday ?
What day was the hie created on ?
The current , mplememation of Plume has no means of guaranteeing such regularity of coverage  . Of course , this problem of patcl ~ y syntactic coverage is not new for restricted doma=n parsers  . The lack Of syntactic generality of the original semantic grammar  3\] for the Sophie system 21 led tO the concept of cascaded ATNs 10 and the RUS parser 1 I , A progress = on w = t lns = milar goals occurred from the LIFER system  \[91 to TEAM 6\] and KLAUS \[7\]  . 
The bas = coDstacle to a ch~evmgSyntactic generality ~ n these network-based approaches was meway syntactic and semantic information was m = xed together+n the grammar networks  . The sOlutions , therefore , rested on separating the syntact = c and semant tc reform at = on  . Plume already incorporates just meseparation of syntax and semantics necessary for syntactic generahly general syntactic knowledge resides in the parser whde semantic = n format = on resides ~ n the grammar This suggests that syntactic generahty ~ na System like Plume can be a cn reved Qv  , morowng the parsers case frame , nstant tatJonalgOrithms . vHnou3n ~, . malor changes to a rammar Content , n terms of me above example s = nvo~wng ; reafe=t suggests . ." Je can use a s4ngle " create " , ,:3seframe to nandte . ~ 11 the examples We Simply need to prow desu Hable extensions to the existing case framens lant latt on algoNthms In the next section we present a detaded desz gn for such extensaons  2  . Providing Plumewtth Syntactic Generality As descr = bed above  . Plume can currently use clausal declaratwe utterances in the active voice  . This section describes our design for extending Plume so that relative and interrogative uses of clausal case frames in passive as well as active voice can also De recognized from the same information  . 
We will present our general design by showing how it operates for the following " create " case frame in the context of NLVMS\[*create*: cf-type clausal : header < create >: cases  ( creator : filler * person *: positional Subject  )   ( create e:filler * file *: positional Direct-Object  )   ( creation-date:filler*date *: marker on ) \] Notet Nat symbols in angle brackets represent nonterminals  , na conmxt-free grammar ( recogmzed by Plume using o attern matching techn , ques ) In Ine case frame def in , tlon above < create > matches all mor Dnologl cal vat = ants of the verio ' create "  , ncluding " create '' creates '' created " and ' creating " impugn not combound tenses + ~ ke  . s : real , ng ' see below ) . Using meex , st = ngPlume:n,s . ': ouid 3 olv 9 . 1lOW uS tO recognize simple ~ mperallves and actwe ~ eclarat  , vesllke
Create ~ oo Oar on Monia av2m creale cI to t ) oar on Mor ~ Uay 2 . IP assives Plume recog n , zespasture sentences lhrough~tS processing of the \] erO cluster + ethema ~ n verb plus me sequence of modal and auxiliary  . ' erD , mmed lalely preceding it . Once memain verb has been located a sl0ecsal verb cluster processing mechanvs mreads me verb cluster and determines from il whether me sentence tsact tveor passive ' j The parser record still s = n formatic n in a special case called "% voice "  . 
If a sentence is found to be achvethe standard parsing algor  , hm described above , s used If = t is found to be passive , the standard algorithm~s used with the modification that the parser looks for the direct object or the indirect object ~? in the subject positron  , and for the subject as an optional marked case with the case marker " by "  . Thus . 
given the " create " case frame above , the follow , rigpassive sentences could be handled as well as their active counterparts  . 
Fopoar was cream d by Jim
FOO oar COuto /' lave deet ~ r Fateoovj , m
FO0o ar,s Oe , ng(reate~l~v ~, m
Fop Oar was created on MGn clay 22 . Relative clauses The detailed design presented below allows Plume to use the " create " case frame to parse nominals hke : the tile J~m creare clon Monclav the person tna ~ the tile was create do yon Monday the day on vvn ~ chJtm create  ( :/ tl~ehieTO dotins . we ~ ntroduce the conceDt of a relative case A relative case is a link back from the case frames for the objects that fill the cases of a clausal case frame to mat clausal case frame  . A grammar preprocessor generates are lat we case automatically from each case of a clausal case frame  , associating , t ' Nlth the nominal case frame . ~ at fills the case in me clausal case frame . Relative cases rionot need to be spemfied by the grammar writerFor instance  , a relative case , s generaled from the createe case of " create " and rnctuded in the " hie " case frame  . ItlOOkSlike this :\[* file * ( : relative-cf * create *: relative-case-name create e:marker < create >\]  911 also cleler rrllnesI~lelenseolme sentence and whelne ?  , ls , Jllfltrrt all veorneq all Ve IOS n , Iu ~ ere , sacase . ~, lnaOoSlhO . alm q . ecboiolecI $1 olme,?lGitec ! . ~DleCt is dl lowe Oloi Jasslv , ze Ne . : air thus uoder slano-;e~le , ~<' es!IW ~" MaIV , VaS ~ i Vellaboow " , iOlnI " , ~ive ' . Ise ! ~ , 3 me , - , ?1113 oln af \] if ~ ,  - '  , ~ lecl , llt(~ , \] ii , it(~it'ecl ) llel , ~l ' ~' ~ ie Similar relative cases are generated in the " person " case frame for the creator case  . and in the " date " case frame for the creation -date case  . differing only in : relative-case-name Relative cases are used s~mdarly to the ordinary marked cases of nominal case frames  . In essence , ff the parser ~ spars mgan on , nat case frame ~ nd finds the marker of one of ~ ts relative cases  , then it tries to instanhate the : relative-cfIt perform stms instant lon~n the same way as  , fmere lat we . cf were a toplevel clausal case frame and the word that matched the header were  , is main verb . An ~ mportan ! d = fference ~ s that it nevertries to fill the case  , , , , nose name ~ s g=ven by relative-case-name That case=s hlled by the nommal case frame which contams the relative case Formstance  , suppose the parser=stry Cng to process . 
7" he file J~m create clon Moncla V
And suppose that ~ thas already located " file ' and used that to determine  , t , s~nstanhat , nga " file " nominal case frame It~s able to match a ga  , nst ' created " ~ me?marker of the relative case frame of " hie'shown above  . It then ~ ries to ~ nstanhate mere lat we . cf " create " using ~ tS standard tecnm dues except real ~! does not try to fill create e the case of " create " specff = eo as the relall ve-case-name Th ~smstanr ~ at ~ on succeeds wllh " Jim ' gong = nip creator and " on Monday " bemg used to hll creatmn-date The parser then uses  ( apomter to ) the nommat case frame currently being instant ~ated  . " file " to fill create e , the:relative-case-name case of " create " and the newly created instance of " create " is attached to this mstance of " file " as a modifier ab  . 
~tnever looks any further left , n the ~ nout than the header of the nom = r'al case frame or  , f , t ~ as already parsed anyomer Oos ' . -r ~ ommat cases of the nommal case frame no further left than the r~gh than dendot  ; them it COnsumes . but Otherwise ignores any relat we pronouns iw no . , vn  ~; . m  ~ , . , n~n rr~ar ~ that ~ mmediately precede the segment used to instantiate the relatwe-cf Tnlg ~ neans rna ~  3/i words , including " thar " . ~ vdl~e 3ccounrec  #or ~ n " t / le fi let t l at J im create c . : . ) t ~ ~/ lonclay " it does not try to fill the case specified by the relative-case-name ~ n the relative-of := nstead tmscase is filled by  ( a Oomterto ) the Or~g = nal nommal case frame tnstance : d . ff the relal=ve-case . name specifies a marked case rather than a position alone tn the relative  . of then ~ tscase marker can De consumed , but omerwts e~gnored . durm gmstan hata on of me relat we . cf This 3110 w3UStO deal wlln " on ~ nme . gate Jim created ~ he hie on " or " the care un whl cnj im created the file '  3 Pass we relalave clauses ( eg . " I he file that was created on Monday " t can generally be handled using the same mechanisms used Iorpass we sat the main clause level However tn relative clauses  , passives may sometimes berecIuce c/byom~thng the usual auxihary verb to be  ( and the relat=ve pronoun ) as ~ n : the file create ( lon Monday To account for such reduced relative clauses  , the verb cluster processor will produce approonate additional readings of the verio clusters  , nrelahve clauses for which the relative pronoun JSm~ssmg This may lead to multl Oleoarses  , m cludmgone for the above examples ~ mdar to the correct one for : the file Jot ~ ncrea\[e ~ on Monclay These amb = guaties wdl Detakencare of by Plumes standard ambiguity reduction methods More comotetely  . Plumes at gor ~ mm for relat tve clauses ~ s : 1 . When processing a nommal case frame . Plumescans for the ; markers of lhere latve cases of the nominal case frame at the same t ~ meas\[t scans for the regular case marker sol : that nominal case frame  2  . If it finds a marker of a relat we case . ~ truestoins t ~ ilnt late the relaltve . cflust as though if were the Top-level clausal case tame and the header were ~ tsmmn'/erb  .  ~ . x cept mat : 2 \] interrogatives in addmon to handling passaves 3no - e ? ahve : lauses . 
also wish he = n formatlon ~ nme " c'eate -" ase frame hanclle ~ nter rog at lvest nvolvl ng " create ' ~ cn  3s   , reto~1CJim create mehl ~ . ~ nMG ; I , I \] V'W , a Sr/le/liecre3teo OVJ ~ mor ' . 4L , ", I . \]/~,/ I/hoc . reare(~the hieOn~f,unc,av '
What clay was the hiecrejle C,:
The prtmary diffiCulty for Plume . , . ,~ ln mterrogatwes ~ s that 3S these examoles Sh Owme number of variations in stanclard COn Stituent order is much greater than for tmperatives and depending on whether the question is yes/no or wh : on which auxiliary verb~s used : on whether the voice is active or passive : and for wh questions  , on which case is queried . 
On the other hand . apart from var ) ations in the order an clplacement of marked cases  , there is only one standard constituent order for = mperatives and only two for declaratives  ( corresponding to active and passive voice )  . We have exl~lO = teclth=s low variability by building knowledge of the imperative and declarative order into Plumes parsing algorithm  . However this is impractical for the larger number of variations as sociale cl with interrogatives  . 
Accordingly , we have designed a more data , driven approach This approach involves two Passes through the inpul : the first categorizes the input into one on several primary input categories in cluOing yesno questions  , several kinds of wh-cluestions , statements , or ~ mperat = ves . The second Pass performs a detaded parse of me input based on the ctassfficat = on made in the first Pass  . The rules used contambas = csyntactic ~ n format = on  al3out Enghsn . and will rema , n constant for any of Plumes restricted domam grammars of semantic case frames for Enghsh The first level of process = rig+nvolves an ordered set of r~D-/evel patterns  . Each too . level pattern corresponds tO one of the primary = nput categor = esment ~ one clador eTh=s classificatory match mgc ~ oes not attempt to match every +  , vord+n the input sentence but only to do the ram=mum necessary to make the class dicat = on  . Most of the relevant , n format ~ on is found at the beg=nnmg of the ~ n Duts  . Inioart = cular , the toplevel patterns make use of the fronted aux = liary verb and wh-worclstn questions  . 
A Swell as classffymg the input , th ~ stoplevel match , s also use ci to determ me the i clenttty of the case frame To be = nstant = ated  . Th = s = S = moortant to dO at this stage because the deta  , led recognmon Ln these conclphase tsneav=ly de ~ enclent on the ~ clent = ty of his toplevel case trame The special symbol  . Sver O . that appears exactly once = n all toplevel patterns  , matches a heacler of any clausal case frame We call trte case frame whose heacle rismat cnecl by Sver O the primary case trame for that input  . 
The second more detailed parsing phase is organized relative to the primary case frame Associated with each toplevel pattern  , there is a corresponding parse femo/ate . A parse template specifies which parts of the primary case frame will ' be found in unusual positions and which parls the default parsing process  ( the one for declar at = ves and imperatives ) can be used for . 
A simplified example of a toplevel pattern for a yesno question is : ~< aux >  ( -  ( $ ver D !! < aux > ) ~  ( &s Sver Oj Srest This top . level pattern w = ll match inputs hke . me follow mg :
D ~ J im create fop ~
Was fop creafe clO yJ~m ?
The first element of the above toplevel pattern ~ san auxiliary verlo  , represented Dymenon-term mal < aux > Th~s aux diary~s remembered and used by the ve to cluster processor  ( as though ~ t were the first aux d ~ ary ~ n the cluster  ) to determine tense and voice . AcCOrChngtO the next part of the pattern , some word that ts not a verb or a naux ~ hary must appear after the fronted aux diary and before the mare verb  ( is the negation operator , and ! ! marks a dislunction ) . Next . the scanmng operator & , ~tetls the hatcher to scan until it finds $ vero which matches the header of any clausal case frame F ~ nally  . Srest matches the remaim ng ~ nDut . 
If the toplevel pattern successfully matches . Plume uses the assoc ~ a tecl Parse template to clirect ~ ts more detaded process mg of the ~ npul  . The goal of this second pass through the input ~ stomstantiate the case frame corresponding to the heacler matched by Sverlo in the top level pattern  , The concept of a kernel-case trame is important to this stage of process mg  . A kemel-case frame Corresponcls to that part of an ~ n put that can be processect according to the algorithm already budtintoPlume for declarative and imperative Sentences  , PIhlfhl ~ ~ allern .   . ' ~ nly ii1OuIS wrlefet l ~ etronfe clauxlllarv . ?+  , ' he first wor O , ~ rh ~ sentence are alloweot ' herrl () re " , '+ = nplex ~ anerr ; ~ al , sach Jally . lsecIP ) vPfLIIn~dllc)ws of euu ~ l fiol ) dll . ~/ i  ~ l , fke0 " ases ' , ~ ioneari ~ lihalivas , , felt pattern for yes/no questions is : aux kernel-casetrame +  ( : query ) This template tells the parser that the input consists of the auxiliary verb matched in the first pass followed by a : kernel-case frame  . For example . ~ n :
O ; dJ~m create fop ~ the auxtliary verb . " did " appears hrst followed by a kernel -case frame  . " Jim create fop " Note ~ ow the kernel-case frame looks exactly like a declarative sentence  , and so can be parsed according to the usual declarative/imperative parsing algorithm In addition to spec : ficat Jon of where to find components of the primary case frame a parse lemplate ~ ncludes annotations  ( indicated by a plus sign ) in the above template for yes/no questions , there=Slust one annotatton-~uery . Some annotations , hkethi Sone , ndl cate what type of input has been found , while others direct the processing of the parse template  . Annotations o ! the first type record which case is being queried ~ nwn quest fons  , mat ~ s . which case , s associated w,m the wh word . Wh questions thus include one of the following annotat Tons Su Olect-query  . 
Prelect-query . and mar~ea-case-que ~ Marked case queries correspond to examples like: 
On what day d~dJ~m create too ?
What dayd~dJim create/oo on ~ in which a case marked by a preposition iS  13eing asked a Pout . A Sillustrated here mecase marker in such queries can either precede the wn word or appear somewhere  . after the ver O . To deal w ; m this , meparse template for marked case quenes has the annotation tlo a ~ na-case-marker  . This annotation ~ s of the second type thai , s = t affects the way Plume processes the associated parse template  . 
Some toplevel patterns result ~ n two poss = bdmlles for parse templates  , For example , the follow = no toplevel pattern < , '/ n . ' Nor O > < at . ix > i(Sv  ~ r to ii . -- at . ix > ~$ vf ~ rt ~$', f = . ~t could match an Oble Ct query or a marked case query  , ~ ncluding the following:
What did Jsm create ~
By whom was fop created ? sz
Who was fop created Oy ?
These ~ nputs cannot be satisfactor dy discriminated Oy a toplevel pattern  , so the above toplevel pattern has twO different parse templates associated with it : wt~-ob/ect aux kemel-case frame ?  ( o Olecr . query ~ wig-marked-case-tiller aux kernel -case frame +  ( roamed-case-query float~ng-case-mar~er . 
When the above toplevel pattern matches . Plumetries to parse the input using both of these parse templates  , in general , only one wil ! succeed Ln accounting for all me input  , so the amb ~ gu dyw dl De eliminated by the methods already built ~ ntoPlume  . 
The method of parsing interrogatives presented above allows Plume to handle a wide variety of interrogatwes ~ na very general way using domain specific semantic case frames  . 
The writer of the case frames does not have to worry about whether they willioe used for ~ mperative  . declarative , or interrogative sentences . ( or in relat wve clauses ) . He is free to concentrafe on the domain-specific grammar  . In addition . 
the concept of the kernel-case frame allows Plume to use the same efficient case frame-based parsing algorithm that = t used for declarative and imperative sentences to parse malor subparts of questions  . 
3. Conclusion
Prey , puS work ( e . g .  \[4 .  5 . 81/3 no exoer , ence . , vd hour current rmolement at ~ on of Plume . Carnegie ' Groups semantic case frame parser , has ~ nown semantic case frame instanl = ation to be an efficient and mgnlyroloust method of parsing restncte cl dommnt nout However hke other methods of parsing tleawly deoendent on restricted domain semantics these  , nmal attempts at parsers based on semantic case frame=n slant  ; al ~ on suffer from palcny syntactic coverage . 

After first describing the current ~ mplementation of Plume  , this paper presented a detaded design for endowing Plume with much broader syntact = c coverage including passives  . 
interrogatives , and relat=ve clauses . Relative clauses are accommodated through some grammar preprocessing and a minor change in the processing of nominal case frames H and ling of interrogatives relies on a set of rules for classifying inputs into one of a limited number of types  . 
Each of these types has one or more associated parse templates which guide the subsequent detailed parse of the sentence  , As the final version of this paper is prepared ( late April ,  1985) . the handling of passives and interrogatives has already been implemented in an internal development version of Plume  . and relative clauses are expected to follow

Though the above methods of incorporating syntactic generality into Plume do not Cover all of English syntax  . 
trey show that as = gnffi cant degree of syntactic generality can Ioe provided straightforwardly t :  ) ya domain specific parser dr tven from a semantic case frame grar pmar 
References 1 . Bobrow . RJ . The RUS System 8 BN Report 3878 . 
Bolt . Beranek . and Newman .  1978 2 . Brown . J . S and Burton , RR Multiple Representations of Knowledge for Tutorial Reasomng  . In Representation and Understanding Bobrow . 0G and Collins , A . . Ed . , Academic Press . New York .  1975 . pp . 

3 . Burton , R . R . Semantic Grammar An Engineering Technique for Constructing Natural Language Understanding Systems  . BBN Report 3453 . Bolt . 8eranek , and Newman . 
Inc . . Cambridge . Mass . . Oecember . 1976.
4 . Carbonell . J . G . . Boggs . W . M . Mauldin , M . L . . and Anick , P . G . The XCALIBUR Prolect : A Natural Language Interface to Expert Systems  . Proc . Eighth Int . Jr . Confon Artificial Intelligence . Karlsruhe . August .  1983 . 
5 . Carbonetl . J . G . and Hayes PJ . " Recovery Strategies for Parsing Extragrammatical Language " Comoutat ~ ona / 
Lingulstscs 10 (1984).
6 . Grosz , B . J . TEAM : A Transportable Natural Language Interface System Proc  . Confon Applied Natural Language Processing , Santa Mon , ca . February 19837 . Haas . N and Hendnx . GG . An Approach to Acclu Jrmg and Applying Knowledge Proc  . Natton at Conference of the American Assoc=ation for Artific = al Intelligence  . Stanford
University . August .  1980 . pp .  235-239 8 . Hayes , PJ . and Carbonetl . JG . Multt-Strategy Parsing and its Role ~ n Robust Man-Machine Commun=cat=on  . 
Carneg = e-Metlon Umvers = ty Computer Sc=ence Oepartment  , 
May , 1981.
9 . Hendnx . G . G . Human Engineering for Applied Natural Language Process = ng  . Proc Fift ~ Int . Jr . Conf on Art = fvctai
Intelligence , MIT .  1977 . pp .  183-191 10 . Woods . W . A , " Cascaded ATN Grammars ' Arnertc3r ~Journal of Computational Linguistics 6  . 1 ( August 1980 Y1-t2
