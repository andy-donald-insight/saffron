DEF AULTSINUNIFICATION GRAMMAR
Gosse Bouma
Research Institute for Knowledge Systems
Postbus 463,6200 ALM aa.q trlcht . The Netherlands
e-mall : gosse@riksnl.uucp

Incorporation of defaults in grammar formal is ms is important for reasons of linguistic adequacy and grammar organization  . In this paper we present an algorithm for handling default information in unification grammar  . The algorithm specifies a logical operation on feature structures  , merging with the nondefault structure only those parts of the default feature structure which are not constrained by the nondefault structure  . We present various linguistic applications of default unification  . 
LINTRODUCTION
MOTIVATION . Thereatwo , not quite unrelated , reasons for incorporating defaults mechanisms into a linguistic formalism  . First , linguists have often argued that certain phenomen are described most naturally with the use of rules or other formal devices that make use of a notion of default  ( see , for instance , Gazdar 1987) . The second reason is that the use of defaults simplifies the development of large and complex grammars  , in particular , the development of lexicons for such grammars ( Evans & Gazdar 1988 )  . The latter suggests that the use of defaults Is of particular relevance for those brands of Unification Grammar  ( UG ) that are lexicalist , that is , in which the lexicon is the main source of g rammatical information  ( such as Categorial Unification Grammar ( Uskorelt 1986 , Calder et al 1988 ) and Head-driven Phrase Structure Grammar ( Pollard & Sag 1987 ) ) . 
We propose a method for incorporating defaults Into UG  , in such a way that It both extends the linguistic adequacy of UG and supports the formulation of rules  , templates and lexical entries for many unification-based theories  . In the next section , we define default unification , a logical operation on feature structures . It is defined for a language . FM/ ,  ~ , which is in many respects identical to the language FML as defined in Kasper & Rounds  ( 1986 )  . Next , we come to linguistic applications of default unification  . A linguistic notation is introduced , which can be used to describe a number of linguistically interesting phenomena  , such as feature percolation . 
coordination , and many aspects of inflectional morphology . Furthermore . it can be used in the sense of Fllcglnger et al ( 1985 ) to define exceptions to rules , non-monotonic specialization of templates or irregular lexlcal entries  . 
BACKGROUND . There are several proposals which hint at the possibility of adding default mechanisms to the linguistic formalisms and theories Just mentioned  . The fact that GPSG ( Gazdar et al , 1985) makes heavy use of defaults , has led to some research concerning the compatibility of GPSG with a formalism such PATR -II  ( Shieber 1986a ) and concerning the logical nature of the mechanisms used in GPSG  ( Evans 1987 )  . Shieber (1986a ) proposes an operation . rid conservatively , which adds information of a feature structure A to a feature structure B  , in as far as this information is not in conflict with information In B  . Suggestions for similar operations can be found in Shivber  ( 1986b:59-61 )   ( the overwrite option of PATR-II ) and Kaplan ( 1987 )   ( priority union )  . Fllckinger et al ( 1985 ) argue for the incorporation of default in her it ance mechanisms In UG as an alternative for the template system of PATR-II  . 
A major problem with attempts to define an operat ion such as default unification for complex feature structures  . Is that there are at least two ways to think about this operation  . It can be defined as an operation which Is like ordinary unification  , with the exception that In case of a unification failure  , the value of the non-default features t ructure takes precedence  ( Kaplan 1987 , Shieber 1986a ) . 
Another option Is not to rely on unification failure  , but to remove default information about a feature f already if the nondefault feature structure constrains the contents of f in some way  . This view underlies most of the default mechan is ms used in GPSG  1   . The 1Actually , in GPSG both notions of default unification are used  . In Shleber's ( 1986 a ) formulation of the of the FootFeature Principle , for example , the operation add conservatively ( which normally relies on unification failure ) is restricted to features that are free ( i . e . uninstant lated and not covarying with some other feature  )  . 
1 65 distinction between the two approaches is especially relevant for reentrant feature values  . 
The definition presented in the next section is defined as an operation on arbitrary feature structures  , and thus it is more general than the operations odd conservatively or over write  , in which only one sentence at a time ( say , < X 0 head >= < X 1 head > or < subject case >= nominative \] is added to a feature description  . 
An obvious advantage of our approach is that over writing a structure F with  1 ~ is equivalent to adding F as default information to F '  . Default unification , as defined below , follows the approach in which default information is removed if it is constrained in the nondefault structure  . This decision is to a certain extent l inguistically motivated  ( see section 3 )  , but perhaps more important is the fact that we wanted to avoid the following problem  . For arbitrary feature structures , there is not always a unique way to resolve a unification conflict  , nor is it necessarily the case that one solution subsumes other solutions  . Consider for instance the examples in ( I ) . 
(1 ) default nondefaulta < f>ffia < f >=< g><g > = bb  . < f >=< g><f>f a<g>ffibTo resolve the conflict  , in Ca ) , either one of the equations could be removed . In ( b) , either the fact that < g >= b or the reentrancy could be removed  ( in both cases , this would remove the inpll c it fact that < f > = b  )  . An approach which only tries to remove the sources of a unification conflict  , will thus be forced to make arbitrary decisions about the outcome of the default unification procedure  . At least for the purposes of grammar development  , this seems to be an undesirable situation 1 . 
2. DESCRIPTION OF THE ALGORITHM
THELANGUAGEFML * . Default unification is defined in terms of a formal language for feature structures  , based on Kasper&Rounds'(1986) language FML . FML * does not contain disjunction , however , and furthermore , equations of the form /: f ( where ? ~ is an arbitrary formula ) are replaced by equations 1However , in Evans ' ( 1987 ) version of Feature Specification Defaults , it is simply allowed that a category description has more than one's table expansion '  . 
of the form < p > : ? x ( where a is atomic or NIL or

(2) ~~ FML *

TO Paa ? A ( the set of atoms ) < p > : apeL * ( L the set of labels ) and a ? AuTOP , NIL\[<pl > ,  . .,<pn >\] each P ie L * ? ^ ? ?,? ? FML*
We assume that feature structures are represented as directed acycll cgraphs  ( dags )  . 
The denotation D ( ? ) of a formula ? is the minimal element w , r . t , subsumption 2 in the set of dags that satisfy it . The conditions under which a dagD satisfies a formula of FML *  ( where D/<p > is the dag that is found if we follow the path p through the dag D  ) are as follows: ( 3 ) S ~- WmTZCSO rFML ? a D ~ NIL always b . D~TOP never cD~a if Df ad D~<p > : a if D /< p > is defined  3 and
D / < p > ~ a , e . DJ = ?^X ffD~b and DR?D~\[<pl > , . .,<pn >\] if the values of all
Pl(I_<I<n ) are equivalent.
NORMAL FOR MREQUIREMENTS . Default unification should be a semantical ly well-behaved operation  , that is , the result of this operation should depend only on the denotation of the formula's involved  . Since default unification is a non-monoton ic operation  , however , in which parts of the default information may disappear  , and since there are in general many formulae denoting the same dag  , establishing this is not completely trivial  . In particular , we must make sure that the formula which provides the default information is in the following normal form:  2 A dag D subsumes a dag D ' if the set of formulae satisfying D ' contains the set of formulae satisfying D  ( Eisele & D Srre .  1988: 287 . 
3D/<l > is defined iff Ie Dom(D).
D/<Ip > is defined iffD/ , <l > and D '/ < p > are defined , where D ' = D/<I > . 
166 (4) FML " Normal Form
A formula S is in FML * NF iff : a VE/nS , < P lP2>:a in S : < pl > eE "-> VP3EE  :<  P3P2>:u in Sl~~EI , E2 in S : < plP2 > EE2 , < pl > EE1 --> ~ P36E1:<p3P2>EE2c . VE in S , there is no < p > eE , such that < pl > is re~ll , ed in S . 
dVE in S , there is no < p > eE such that < p > : a ( aeA ) is in S . 
(5) B
A path < pl > is realized in Slff < pr > is defined in D  ( @  ( l , rEL ) ( cf . Elsele & D0n-e , 1988:288) . 
For every formula S in FML * , there is a formula S ' in FML * NF . which is equivalent o it w . r . tunification , that is , for which the following holds : (6) ~/7 . eFML*:S^7 . ~ TOP ? ~ S'^7 . ~ TOP Note that this does not imply that S and S ' have the same denotation  . The two formulae below , for example , are equivalent w . r . t . 
unification , yet denote different dags : (7) a . <: f>:a^\[<f >,< g>\]b . < f>:a^<g>:a For conditions (4a , b ) , it is easy to see that (6) holds ( it follows , for instance , from the equivalence laws ( 21 and ( 22 ) in Kasper & Rounds ,  1986: 261) . Condition ( 4c  can be met by rep lac ing every occurence of an equivalence class \[< pl>  ,  . . , < pn>\]in a formula S by a conjunction of equ ivalences\[<  p11>  ,  . . , < pnl >\] for every < pi/> ( 1 < i < n realized in D ( S . For example , if L =  f , g ) , ( Sb is the NF of ( Sa ) . 
8) a\[<f >, < g>\]^<ff>:NiLb . \[<ff > , < gf>\]^[<fg > , < gg >\]^~: NIL Condition ( 4d  can be met by el iminating equivalence classes of paths leading to an atomic value  . Thus , ( To ) is the NF of (7a ) . Note that the effect of (4c , d ) is that the value of every path which is member of some equivalence class is NIL  . 
A default formula has to be in FML " NF for two reasons  . First , all information which is implicit in a formula , should be represented explicitly , so we can check easily which parts of a formula need to be removed to avoid potential unif ication conflicts with the nondefault formula  .   . This Isguaranteed by (4a , b) . 
Second , all reentrant paths should have NIL as value . This is guaranteed by (4c , d ) and makes it possible to replace an equivalence class by a weaker set of equat/on s  , in which arbitrary long extensions of the old path names may occur  ( if some path would have a value other than NIL , certain extensions could lead to inconsistent results  . 
LAWSFORDEF AULTUNIFICATION . Default unification is an operation which takes two formulas as arguments  , representing default and nondefault informat/on respectively  . The dag denoted by the resultant formula is subsumed by that of the non-default argument  , but not necessarily by that of the default argument  . 
The laws for default unification ( defined as Default ~ Non-default = Result , where Default is in FMLS-NF \] are listed below . 
(9) D ~ AULTUN a ~ C . ATSOm : aSeNIL = S
SeTOP=TOP
NIL(BS = ~ b
TOP ~ BS = Sb . a ~ S = S
S~a = ac . < p > : a ~ S = S , ffD(S ) I=<P'>:a , p ' a preflx of p , aeA . 
= ~, if D(SI = < pp ' > : a.
= ~, ff3p'EE : D(O ) I = E and p ' is a prefix of p.
= < p > : a ^ S , otherwise.
cLEG ) S = F~E // ~ where E ' is < p > ~ EID ( S ) ~E ' and p'eE'u < p > eEID ( S ) ~< p '> : a ( p ' a prefix of p , aeA ) and Z is < p ' > lD(S ) l = < p p ' > : a . 
and p~E .
e . (? A ~)( B ~=$ , ffyA ~= TOP , =( W ( B ?) A(X ~ B ? , otherwise . 

This definition of default unification removes all default information which might lead to a unif ication conflict  . Furthermore , it is designed in such a way that the order in which information is removed is irrelevant  ( note that otherwise the second case in ( 9e ) would be invalid )  . The first two cases of ( 9c ) are needed to remove all sentences < p > : a , which refer to a path which is blocked or which cannot receive an atomic value in ?  . The third case in ( 9c ) is needed for situation such as ( I0 )  . 
( I0) (< fg > : a ^ < hg > : b ) (9\[<f > , < h>\]In (9d ) , we first remove from an equivalence class all paths which have a prefix that is already in an equivalence class or which has an atomic value  . The result of this step is EE ' . 
Next , we modify the equivalence class , so that it allows exceptions ( i . e . the posslbtlity of non-unifiable values ) for all paths which are extensions of paths in EE ' and are defined in ?  . We can think of modified equivalence classes as abbreviations for a set of  ( unmodified ) equivalence classes : ( 11 ) \[< pl > . . . . < pn >\ ] / / Z = ? , where ~ is the conjunction of all equivalence classes\[<plpl >  . . . . < pnpl >\] . such that pl is not defined in Z , but prisinz , for some l , re

An example should make this clearer : (12)\[<f > , <g> , < h > l(9(<g > : aA < fg > : b ) = l < f > , < h>l//<g>A(<f>:a^<fg>:b) . 
The result of default unification in this case is that one element  ( < g > is removed from the default equiva lence class since it is constrained in by the nondefault information  . 
Furthermore , the equivalence is modified , so that it allows for exceptions for the paths < fg > and < hg >  . Applying the rule in ( II ) , and assuming that L =  f , g , h , we conclude that (13)\[< f > , < h>\]//<g >=\[< ff > , < hf>\]A\[<fh > , < h h >\] . 
Note that the replacement of modified equivalence classes by ordinary equivalence classes is always possible  , and thus the result of ( 9 el ) is equivalent to a formula in FML * . 
Finally . ( ge ) says that . given a consistent default formula , the order in which default information is added to the non-default formula is unimportant  .  1  ( This does not hold for inconsistent default formulae  , however , since default unification with the individual conJuncts might filter out enough information to make the resultant formula a consistent extension of the non-defauR formula  , whereas
TOPO ? = ?.
The monotonlclty properties of default unification are listed below where < is subsumption :  ( 14 a , ~ X ^ , ( but not X ~ X ^*) b . X -< X ' ~ ( X ^@ ~0C'^~ )   ( but not ? s ? ' ~ ( g ^? )  <_  ( X ^?' )   )   ( 14 a ) says that default unification is monton lc add it ion of information to the non-default information  .   ( 14 b ) says that the function as a whole is monotonic only w  . r . t , the default argument : adding more default information leads to extensions of the result  . Adding non-default information is non -monotonic  . 
however , as this might cause more of the default info rmation to get removed or over written  . 
The laws in ( 9 ) prove that formulae containing the ( 9-operator can always be reduced to standard formulae of FML *  . This implies that formulae using the ( 9-operator can still be interpreted as denoting dags  . Furthermore , it follows that addition of default unification to a unification-based formalism should be seen only as a way to increase the expressive power of tools used in defining the grammar  ( and thus . according to D6rre et al ( 1990 ) default unification would be an ' offline ' extension of the formalism  , that is , its effects can be computed at compile time ) . 
ANOTEONIMPLEMENTATION . We have implemented default unification in Prolog  . 
Feature structures are represented by open ended lists  ( containing elements of the form label = Value )  , atoms and variables to represent complex feature structures  , atomic values and reentrancies respectively ( see Gazdar & Mellish ,  1989) . This implementation has the advantage that it is corresponds to 
FML * NF .
1 This should not be confused with the ( invalid ) statement that ? ( 9  ( X ( 9 ~= X ( 9  ( V ( 9? )  . 
168 (15) a . If = X , gfXlY\]b . \[f = a , g = aI_Y\]c . \[f =\[ h = aIXl\] , g =\[ hfaIXI\]I_Y\]d\[f=\[h = aIX l , g=\[h= . _ZIX1\]IY \] If we unify ( 15 a ) with\[\[=al_Yl\] . we get (15b ) , in which the value of g has been updated as well Thus  , the requirements of (4 a , b ) are always met , and furthermore , the reentrancy as such between f and g is no longer visible  ( condition 4c )  . If we unify(I5a ) with U'=\[h = aIX2)IY3\] , we get (15c ) , in which the variable X has been replaced by X1 , which can be interpreted as ranging over all paths that are realized but not defined under f  ( condlt lon ( 4d ) ) . Note also that this representation has the advantage that we can define are entrancy for all realized features  , without having to specify the set of possible features or expanding the value off into a list containing all these features  . If we default unify ( 15 a ) with\[f =\[ hffial_X2II_X , 3\] as nondefault information , for instance , the result is representable as (15d ) . The reentrancy for all undefined features under f is represented by  X1  . The constant NIL of FML * is represented as a Prolog variable  ( _Z in this case )  . Thus , the seemingly space consuming procedure of bringing a formula into FML * NF and transforming the output of  ( 9 d ) into FML * is avoided completely . The actual default unification procedure is a modified version of the merge operation defined in  D6rre & Elsele ( 1986 )  . 
3. LINGUISTICAPPLICATIONS
Default unification can be used to extend thes t and ard PATR-II  ( Shieber et al . 1983) methods for defining feature structures . In the examples , we freely combine default and nondefault information  ( prefixed by I ' ) in template definitions . 
(16) a . DET : ( l < catarg > ffiNt < catval > ffiNP < cat dir > = right < catarg >= < catval > < catval num > = sg < catval case >= nom  )  . 
b . NP : (< cat >= noun < bar>ffi2).
c.N : (< cat >= noun < bar >=1).
(16 ) describes a fragment of Categorlal Unification Grammar  ( Uszkorelt . 1986, Calder et al 1988 . Bouma .  1988) . The corresponding feature structure for a definition such as  ( 16 a ) information and all nondefault information is unified separately  , which results in two feature-structures (17 a , b ) . The resulting two feature structures are merged by means of default unification  ( I7c )  . 
(\]7)\]\] case=nora a . dir = rightt-arg=<1>b . Elt ?"' IIvaJ = bar=cat=\[cat=:\]
Largbar = c.
ml catffimr ? . ,=\]lbar=2valffi1/num
L cased irf firightr , , , , , = 2r , ,\] I bar arg ffi 1 / nu m - Lease m m m In ( 17 c ) the equivalence < catval >= < cat an3> had to be replaced by a weaker set of equivalences  , which holds for all features undervalor arg . except cat and bar . We represent his by using \[\]- bracketed indices  , instead of <> and by marking the attributes which are exceptions in ix  ) / ( \[ italic .   . 
T Wo things are worth noticing . First of all , the unifica U on of nondefault information prior to merging it with the nondefault information  , guarantees that all default information must be unifiable  , and thus it eliminates the possibility of inheritance conflicts inside template definitions  . Second , the distinction between default and nondefault information is relevant only in definitions  , not in the corresponding feature structures . This makes the use of the T-operator completely local : if a definl U on contains a template  , we can replace this template by the corresponding feature structure and we do not need to worry about the fact that this template might contain the 

The notation Just introduced increases the expressive power of standard methods for the description of feature structures and can be used for an elegant treatment of several linguis Uc phenomena  . 
NON-MONOTONICINHERITANCE OF INFORMATION IN TEMPLATES  . The use of default unification enables us to use templates even in those cases where not all the information in the template Is compatible with the information already present in the definition  . 
German transitive verbs normally take an accusative NP as argument but there are some verbs which take a dative or genitive NP as argument  . This Iseasily accounted for by defining the case of the argument of these verbs and lnherittng all other Information from the template ~ r  . 
(\]8) a . " IV : ( < catval >= VP < catarg > ffiNP < cat arg case >= acc  )  . 
b.he\]fen(Whelp ): ( TV
I < catarg case > ffidat).
gedenken ( to c~nmem~ate )   ( TV ! < catarg case >= gen )  . 
SPECIALIZATION OFREENTRANCIES . An important function of default unification is that It allows us to define exceptions to the fact that two reentrant feature structures always have to denote exactly the same feature structures  . 
There Is a wide class of linguistic construct ions which seems to require such mechanisms  . 
Specifiers in CUG can be defined as functors which take a constituent of category C as argument  , and return a constituent of category C , with the exception that one or more specific feature values are changed  ( see Bach ,  \]983 , Bouma ,  \]988) . Examples of such categories are determiners ( see ( \]6 a ) ) , complementizers and auxiliaries . 
(\]9) a . that : ( < catyah=<catarg > < catarg >= S < cat arg vform >= fin  1<cat arg comp >= none l < catval comp >= that )  . 
b . will: ( < catval >= < catarg > < catrag >= VP < cat val >= VP  1<cat argvform > ffibsel < catvalvform > ffifin )  . 
Note that the equation < catval >= < catarg > will cause all additional features on the argument which are not explicitly mentioned In the nondefault part of the definition to percolate up to the value  . 
Next , consider coordination of NPs.
(20 )   X0 --> X\] X2Xo  <  X2 cat > ffi conJ ? X0> ffi<XI>?Y , O>ffi~< g0 cat > = np < X 2 w form > ffi and kX0 num > ffiplu
I < X1 num >= NIL!<X2 num > ffiNIL).
20 ) could be used as a rule for conjunction of NPs in UG  . It requires identity between the mother and the two coordinated elements  . 
However , requiring that the three nodes be unifiable would be to strict  . The number of a conjoined NPIs always plural and does not depend on the number of the coordinated NPs  . 
Furthermore , the number of two coordinated elements need not be identical  . The nondefault information in ( 20 ) takes care of this . 
The effect of this statement Is that adding the default in form aU on <  X0> = < XI > and < gO > ffi < X3> will result in a feature structure in which XO , X1 and X3 are unified , except for their values for < num > . We are not interested in the ruan-values of the conJuncts  , so they are set to N/L which should be interpreted as in section  2  )  . The hum-value of the result is always p/u . 
INFLECTION ALMORPHOLOGY . When seen from a CUG perspective , the categories of inflectional affixes are comparable to those of specifiers  . 
The plural suffix-s for forming plural nouns can  , for instance , been coded as a function from ( regular ) singular nouns into Identical , but plural , nouns . Thus . we get the following categorization : ( 21 ) - s : ( < catval >= < catarg > < catarg cat > ffi noun < catarg class >= regularl < catarg num > ffisgl < catvalHum >= plu  )  . 
Again , all additional information present on the argument which Is not mentioned in the non-defau lt part of the definition  , Is percolated up to the value automatically . 
I , EXICAL DEF AULTS . The lexical feature specification defaults of GPSG can also be incorporated  . Certain information holds for most lexlcal items of a certain category  , but not for phrases of thls category . A unifl clatlon-based grammar that includes a morphological component  ( see , for instance , Calder , 1989 and Evans & Gazdar ,  1989) , would probably list only ( regular ) root forms as lexlcal items . For regular nouns , for instance , lexicon . Such information can be added to lexicondef in it ions by means of a lexl cal default rule:  22  ) v . N ==> (3SG < class >= regular b . ( x ~ vffiN . 
sheep = ( N < mum >= NIL < class >= irregular.
The interpretation of A = => B is as follows : If the definition D of a lexical item is unifiable with A  , than extend D to B(BD . Thus , the lexlcal entry cow would be extended with all the information in the default rule above  , whereas the lexical entry for sheep would only be extended with the information that < person > =   3  . Note that adding the default information to the template for N directly  , and then overwriting it in their regular cases is not a feasible alternative  , as this would force us to distinguish between the template N if used to describe nouns and the template N if used in complex categorie such as NP/N or N/N  ( i . e . 
for determiners or adjectives it is not typically the case that they combine only with regular and singular nouns  )  . 
& CONCLUSIONS
We have presented a general definition for default unification  . The fact that It does not focus one the resolution of feature conflicts alone  , makes it possible to define default unificat ion as an operation on feature structures  , rather than as an operation adding one equation at atlme to a given feature description  . This generalization makes it possible to give a uniform treatment of such things as adding default Information to a template  , over writing of feature values and lexical default rules  . We believe that the examples in section 3 demonstrate hat this is a useful extension of UG , as it supports the definition of exceptions , the formulation more adequate theories of feature percolation  , and the extension of UG with a morphological component  . 

Bach , Emmon 1983 Generalized Categorial
Grammars and the English Auxiliary . In
F . Heny and B . R/chards ( eds .) Linguistic
Cateyor/es , Vol II , Dordrecht , Reidel.
Bouma , Gosse 1988 Modifiers and Specifiers in Categorlal Unif ication Grammar  , 
Lingu/st/cs , vo 126, 21-46.
Calder , Jonathan 1989 Paradigmatic
Morphology . Proceedings of the fourth
Conference of the European Chapter of the ACL , University of Manchester , Institute of Science and Technology ,  58-65 . 
Calder , Jo ; Klein , Ewan & Zeevat , Henk 1988 Unification Categorial Grammar : a concise , extendable grammar for natural language processing  . Proceedings of
Collng 1988, Hungarian Academy of
Sciences , Budapest , 83-86.
DO rre , Jochen ; Eisele , Andreas ; Wedekind , Jflrgen ; Calder , Jo ; Reape , Mike 1990A
Survey of Lingustf cally Motivated extensions to Unlficatlon-Based 
Formalisms . ESPRIT Basic Research
Action 3175, Deliverable R3.I.A.
Eisele , Andreas & D6rre , Jochen 1986 A
Lexlcal-Functlonal Grammar System in
Prolog . Proceedings of COLING86,
Institut f Qrangew and te Kommunika Uons-und Sprach forschung  , Bonn ,  551-553 . 
Eisele , Andreas & D6rre , Jochen 1988
Unification of Disjunctive Feature Descript ions  . Proceedings of the 26th
Annual Meeting of the Association for
Computational Linguistics , State
University of New York , Buffalo , NY , 286-294.
Evans , Roger 1987 Towards a Formal specification of Defaults in GPSG  . In E . 
Klein & J . van Benthem ( eds . ), Categories , Polymorphlsm and Unification . University of Edinburgh , Edinburgh / University of
Amsterdam , Amsterdam , 73-93.
Evans , Roger & Gazdar , Gerald 1989 Inference in DATR . Proceedings of the fourth
Conference of the European Ch pater of the ACL , University of Manchester , Institute of Science and Technology ,  66-71 . 
Fllckinger , Daniel ; Pollard , Carl & Wasow , Thomas 1985 Structure-Sharlng In I . exical Representation . Proceedings of the 23rd
Annual Meeting of the Association for
Chicago , Chicago , Illinois , 262-267.
Gazdar , Gerald 1987 Linguistic Applications of
Default Inheritance Mechanisms . In P.
Whitelock , H . Somers , P . Bennett , R,
Johnson , and M . McGee Wood ( eds.),
Linguistic Theory and Computer
Applicatfons . Academic Press , London , 37-68.
Gazdar , Gerald ; Klein , Ewan : Pullum , Geoffry;
Sag , Ivan 1985 Generalized Phrase
Structure Grammar . Blackwell , London.
Oazdar , Gerald & Mellish , Chris 1989 Natural
Language Processing in Prolog . An introduction to Computational Linguistics . Addison-Wesley , Reading , M/L Kaplan , Ronald 1987 Three seductions of Computational Psycholinguistics  . In P . 
Whitelock , H . Somers , P . Bennett , R,
Johnson , and M . McGee Wood ( eds.),
Linguistic theory and Computer
Applications . Academic Press , London , 149-188.
Kasper , Robert & Rounds , William 1986 A
Logical Semantics for Feature Structures.
Proceedings of the 26th Annual Meeting of the Association for Computational 
Linguistics , Columbia University , New
York , NY , 257-266.
Pollard , Carl & Sag , Ivan 1987 Information-
Based Syntax and Semantics , vol I:
Fundamentals , CSLI Lecture Notes 13,
University of Chicago Press . Chicago.
Shieber , Stuart ; Uszkorelt , Hans ; Perelra,
Fernando ; Robinson , Jane ; & Tyson,
Mabry 1983 The Formalism and
Implementation fPATR-II . In B . Grosz &
M . SUckel(eds .) Research on Interactive
Acquisition and Use of Knowledge , SRI
International , Menlo Park , Ca.
Shieber , Stuart 1986 a A Simple
Reconstruction of GPSG . Proceedings of
COL/NG 1986. Instl tutf ( I range wandte
Kommunikations - und Spraehforschung,
Bonn , 211-215.
Shieber , Stuart 1986b An Introduction to
Unlfl cat lon-based Approaches to
Grammar . CSLI Lecture Notes 4,
University of Chicago Press , Chicago.
Uszkoreit , Hans 1986 Categorlal Unification
Grammars . Proceedings of COIINO 1986.
In stltutf Qrange wandte
Kommunikations - und Sprach forschung,
Bonn , 187-194.

