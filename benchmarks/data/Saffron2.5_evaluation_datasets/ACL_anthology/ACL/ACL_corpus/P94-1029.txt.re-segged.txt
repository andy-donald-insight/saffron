ANEXTENDED THEORY
OF HEAD-DRIVEN PARSING
Mark-Jan Nederhof *
University of Nijmegen
Department of Computer Science
Toernooiveld , 6525 ED Nijmegen
The Netherlands
markjan ? cs,kun.nl

We show that more head-driven parsing algorithms can he formulated than those occurring in the existing literature  . These algorithms are inspired by a family of left -to-right parsing algorithms from a recent publication  . We further introduce a more advanced notion of " head-driven parsing " which allows more detailed specification of the processing order of nonhead elements in the right hand side  . We develop a parsing algorithm for this strategy , based on LR parsing techniques . 
Introduction
According to the head-driven paradigm , parsing of a form a language is started from the elements within the input string that are most contentful either from a syntactic or  , more generally , from an information theoretic point of view . This results in the weakening of the left-to -right feature of most traditional parsing methods  . Following a pervasive trend in modern theories of Grammar  ( consider for instance \ [5 ,  3 ,  11\] ) the computation a linguistics community has paid large attention to the head-driven paradigm by investigating its applications to contextfree language parsing  . 
Several methods have been proposed so far exploiting some nondeterministic head-driven strategy for contextfree language parsing  ( see among others\[6 ,  13 ,  2 ,  14\]) . All these proposals can be seen as generalizations to the head-driven case of parsing prescriptions originally conceived for the left-to-right case  . The methods above suffer from deficiencies that are also noticeable in the left-to-right case  . In fact , when more rules in the grammar share the same head element  , or share some infix of their right hand side including the head  , the recognizer nondeterministically guesses a rule just after having seen the head  . In this way analyses that could have been shared are duplicated in the parsing process  . 
Interesting techniques have been proposed in the left-to-right deterministic parsing literature to overcome redundancy problems of the above kind  , thus reducing * Supported by the Dutch Organisation for Scientific Research  ( NWO )  , under grant 00-62-518
Giorgio Satta
Universith di Padova
Dipartimento di Elettronica e Informatica via Gradenigo  6/A   , 35131 Padova
Italys atta@dei , unip d , it the degree of nondeterminism of the resulting methods  . 
These solutions range from predictive LR parsing to LR parsing  \[15  ,  1\] . On the basis of work in \[8\] for nondeterministic left-to-right parsing , we trace here a theory of head-driven parsing going from crude topdown and head-corner to more sophisticated solutions  , in the attempt to successively make more deterministic the behaviour of head-driven methods  . 
Finally , we propose an original generalization of head -driven parsing  , allowing a more detailed specification of the order in which elements of a righthand side are to be processed  . We study in detail a solution to such a head -driven strategy based on LR parsing  . Other methods presented in this paper could be extended as well  . 
Preliminaries
The notation used in the sequel is for the most part standard and is summarised below  . 
Let D be an alphabet ( a finite set of symbols ) ; D + denotes the set of all ( finite ) nonempty strings over D and D * denotes D+Uc , where c denotes the empty string . Let R be a binary relation ; R + denotes the transitive closure of R and R * denotes the reflexive and transitive closure of R  . 
A context = free grammar G = ( N , T , P , S ) consists of two finite disjoint sets N and T of nonterminal and terminal symbols  , respectively , a start symbol SEN , and a finite set of rules P . Every rule has the form A ~ a , where the left hand side ( lhs ) A is an element from N and the righthand side ( rhs ) e ~ is an element from V + , where V denotes ( NUT ) .   ( Note that we do not allow rules with empty right hand sides  . This is for the sake of presentational simplicity  . ) We use symbols A,B,C, .   .   . to range over N , symbols X , Y , Z to range over V , symbols a , /3 ,  7  .   .   .   . to range over V *, and v , w,z, .   .   . to range over T * . 
In the contextfree grammars that we will consider , called head grammars , exactly one member from each rhs is distinguished as the head  . We indicate the head by underlining it , e . g . , we write A--*aX fl . An expression A--+ cr7/3 denotes a rule in which the head is some member within  7- We define a binary relation ~ such Relation ( >* is called the head-corne relation . 
For technical reasons we sometimes need the augmented set of rules PI  , consisting of all rules in P plus the extra rule S ~ ~  . kS , where ff is a fresh nontermi-hal , and 3_ is a fresh terminal acting as an imaginary zeroth input symbol  . The relation p , t is extended to a relation -- . on V*xV * as usual . We write ~ P-~ 6 whenever 7  "-'*  6 holds as an extension of pEP ? We write 7t"P2"'~"   6 if 7  ~  61  ~  6 P " 2""   "6~-x  --- , 6 For a fixed grammar , a head-driven recognition algorithm can be specified by means of a stack automaton a =  ( T , alph , Init(n ) ,  ~-- , , Fin(n )) , parameterised with the length n of the input . In A , symbols T and Aiph are the input and stack alphabets respectively  , lair(n ) , Fin ( n ) E Alph are two distinguished stack symbols and ~ is the transition relation  , defined on Alph+x Alph + and implicitly parameterised with the input  . 
Such an automaton manipulates stacks FEAiph+ ,   ( constructed from left to right ) while consulting the symbols in the given input string  . The initial stack is Init(n ) . Whenever F ~ Fr holds , one step of the automaton may , under some conditions on the input , transform a stack of the form F " F into the stack F"F ~  . 
In words , F ~ F ~ denotes that if the topmost few symbols on the stack are F then these may be replaced by the symbols I '  . Finally , the input is accepted whenever the automaton reaches stack F in  ( n )  . Stack automata presented in what follows act as recognizers  . Parsing algorithms can directly be obtained by pairing these automata with an output effect  . 
A family of head-driven algorithms This section investigates the adaptation of a family of left-to-right parsing algorithms from  \[8\]  , viz . topdown , left-corner , PLR , ELR , and LR parsing , to head grammars . 
Top-down parsing
The following is a straightforward adaptation of topdown  ( TD ) parsing \[1\] to head grammars . 
There are two kinds of stack symbol ( items ) , one of the form \[ i , A , j \] , which indicates that some subderivation from A is needed deriving a substring of ai+l???aj  , the other of the form \[ i , k , A--*a ?7?/3 , m , j \] , which also indicates that some subderivation from A is needed deriving a substring of ai+l ??? aj  , but specifically using the rule A--~ot7/3 , where 7-'-~* ak+x .   .   . a , n has already been establish e ~ . Formally , we have 1~D =\[ i , A , j\]li<jIf ?=\[ i , k , A -* a . y . fl , m , j\]IA--~aZ/3EP~Ai<k<m <_j ) AIK or lthm 1 ( Head-drlven topdown ) a ~ = ( T , I~DUITD , 1nit(n ) ,  ~-* , Fin(n )) , where Init(n ) = \[-1 ,  -1  , S'---*?3_?S ,  0 , n \] , Fin(n ) = \[-1 ,  -1  , S'--**3S* , n , n \] , and the transition relation ~-~ is given by the following clauses  . 
0\[i , A , j\]~\[i , A , j \]\[ i , B , j \] where there is A ~ a B__fl Ept 0 a\[i , k , A - - - , a ?7* B/3 , m , j \] ~ - , \[ i , k , A - - - , a ?7? B/3 , m , j \]\[ m , B , j \]0 b\[i , k , A---*a B?7*/3 , m , j \]\[ i , k , A ~ a B ?7*/3 , m , j \]\[ i , B , k\]1\[i , A , j\]~--*\[i , k-l , A---*a . a ? /3 , k , j \] where there are A ~ a a flEp t and k such that i < k_<j and ak = a  2a \[ i , k , A---*a ?7* a\[3 , m , j\]~-~\[i , k , A ~ a ? 7a */3 , m + 1 , j \] providedm < j and am+l = a 2b Symmetric to 2a   ( eft0a and 0b ) 3\[i , A , j \]\[ i' , k , B ~ ? 6? , m , j '\] ~\[ i , k , a ~ a ? B * fl , m , j \] where there is A ~ a BB flEP ? ( i = i ~ and j = f are automatically satisfied ) 4 a\[i , k , A---*a ?7* B\[3 , m , j \]\[ i' , k ' , B--*?6 ,   , m ' , j '\]\[ i , k , A ~ c ~?7 B ? fl , m ' , j \] providedm = k ' ( m = i ' and j = j ' are automatically satisfied )   4b Symmetric to 4a We call a grammar head-recursive if A~+A for some A  . Head-driven TD parsing may loop exactly for the grammars which are head-recursive  . Head reeursion is a generalization of left recursion for traditional TD parsing  . 
In the ease of grammars with some parameter mechanism  , topdown parsing has the advantage over other kinds of parsing that topdown propagation of parameter values is possible in collaboration with contextfree parsing  ( eft the standard evaluation of definite clause grammars  )  , which may lead to more efficient processing . This holds for left-to-right parsing as well as for head-driven parsing  \[10\]  . 
Head-corner parsing
The predictive steps from Algorithm 1 , represented by Clause 0 and supported by Clauses 0a and 0b   , can be compiled into the head-corner relation ~)* . This gives the head-corner ( HC ) algorithm below . The items from ITD are no longer needed now . We define IHc = If D . 
Algorithm 2 ( head-corner )
A ~ t c = ( T , IHc , Init(n ) ,  ~-* , Fin(n )) , where Init(n ) = \[-1 ,  -1  , S'~?3-?S ,  0 , n \] , Fin(n ) = \[-1 ,  -1  , S'--~?IS = , n , hi , and ~ is given by the following clauses . ( Clauses lb , 2b , 3b , 4 bare omitted , since these are symmetric to la , 2a , 3a , 4a , respectively . ) la\[i , k , a --* ao T ? B/3 , m , j\]~--~\[i , k , A---*a ?7 ? B/3 , m , j \]\[ m , p-1 , C ~ r l . a . O , p , j \] where there are C ~ r/a0 Ept and p such that m < p < j and ap = a and C ~* B\[i  , k , A--*a*-/a*13 , m + 1 , j \] provided m < j and a m + l - - - - a3 a\[i , k , D ~ a * 7* A13 , m , j \]\[ i' , k ' , B  ~ . 6  . , ra ', jq~- . 
\[ i,k,D--~o ~ . 7 . A13, rn,j\]\[i',k',C--~~ . B . 8  , rn ' , j '\] providedm = ? , where there is C --* r/_B0 Ept such that C <>* A ( j = j ' is automatically satisfied ) 4 a\[i , k , A  ~ a . 7  . B 13,m,j\]\[i ', k ', B---* . 6  .   , m ' , j '\]\[ i , k , A ~ a*' IB * 13 , m ' , j \] providedm = k ~ ( m = i ' and j = j ' are automatically satisfied  ) Head-corner parsing as well as all algorithms in the remainder of this paper may loop exactly for the grammars which are cyclic  ( where A---~+A for some A )  . 
The head-corner algorithm above is the only one in this paper which has already appeared in the l iterature  , in different guises \[6 ,  13 ,  2 ,  14\] . 
Predictive HI parsing
We say two rules A--*al and B--* ~2 have a common infixaifal = 1310?-/1 and a2  =  132  ( :~-/2 , for some 131 , 132 , 71 and -/2 . The notion of common infix is an adaptation of the notion of common prefix  \[8\] to head grammars . 
If a grammar contains many common infixes , then HC parsing may be very nondeterministie ; in particular , Clauses 1 or 3 may be applied with different rules C--- 0_a0 Eptor C - - - * r/__B0 EP ~ for fixed a or B . 
In \[15\] an idea is described that allows reduction of nondeterminism in case of common prefixes and left-corner parsing  . The resulting algorithm is called predictive LR  ( PLR ) parsing . The following is an adaptation of this idea to HC parsing  . The resulting algorithm is called predictive H I  ( PHI ) parsing . ( HI parsing , to be discussed later , is a generalization of LR parsing to head grammars  . ) First , we need a different kind of item , viz . of the form \[ i , k , A--~7 , re , j \] , where there is some rule A--*a_713 . With such an item , we simulate computation of different items \[ i  , k , A--*(~*7*13 , re , j\]E IHc , for different a and 13 , which would be treated individually by an HC parser  . Formally , we have IPm = \[ i , k , A - - , % m , j \] lA-- , ctT_13 EP?Ai<_k<m <_j
Algorithm 3 ( Predictive HI )
APHI = ( T , IPHI , lnit(n ) ,  ~-~ , Fin(n )) , where Init(n ) = \[-1 ,  -1  , S'---*_1_ ,  0 , n \] , Fin(n ) = \[-1 ,  -1  , S ' ~ IS , n , n \] , and ~-* is given by the following ( symmetric " b-clauses " omitted )  . 
la\[i , k , A - - - * % m , j\]~-*\[i , k , A ~% m , j \]\[ m , p-1 , C - -* a , p , j \] where there are C~y_a0 , A - - - * aTB13 ~pt and p such that m < p < j and ap = a an ( :\] CO*B2a\[i , k , A--*7 , m , j \] . - . \[ i , k , A--*T a , m + 1 , j \] provided m < j and am + ~= a , where there is A--*a T_ . a 13~pt3a\[i , k , o -~% m , j \]\[ i' ,  ~' , B - ~ ~ , m ' , j '\]\[ i , k , D - - - * 7 , m , j \]\[ i' , k ' , C -+ B , m ' , j'\]providedm=i ' and B--*6Ept , where there are D--*a_TA 13 , C---*q_B0 Ept such that C <>* A4 a\[i , k , A---*7 , m , j \]\[ i' , k ' , B  ~6 , m ' , j '\]\[ i , k , A - - - , -/ B , m ' , j \] provided m = k ' and B ~_6 Ept , where there is
A.---.~7_.B flEpt
Extended HI parsing
The PHI algorithm can process simultaneously a common infix a in two different rules A--*  131_~-/1 and A--* 132_~72  , which reduces nondeterminism . 
We may however also specify an algorithm which succeeds in simultaneously processing all common infixes  , irrespective of whether the lefthand sides of the corresponding rules are the same  . This algorithm is inspired by exlended LR ( ELR ) parsing \ [12 , 7\] for extended contextfree grammars ( where right-hand sides consist of regular expressions over V  )  . By analogy , it will be called extended HI(EHI ) parsing . 
This algorithm uses yet another kind of item , viz . 
of the form \[ i , k , A1, A ~, .   .   .   , Ap--*-/ , m , j \] , where there exists at least one rule A--* a_713 for each AE A1  , Au ,   .   .   . , Ap . With such an item , we simulate computation of different items \[ i  , k , A - -* a*-/*13 , m , j\]EI He which would be treated individually by an HC parser  . Formally , we have
IEm=\[i , k , zx--+-/ , m , j\]I0 CACAIA - - - , a-/13 EPtAi <_k < m<j
Algorithm 4 ( Extended HI )
AEH1 = ( T , IEHI , Init(n ) ,  ~-* , Fin(n )) , where Init(n ) = \[-1 ,  -1  , S ' --+ . 1_ ,  0 , n \] , Fin(n ) = \[-1 ,  -1  , S ' ~_l_S , n , n \] , and ~-~ is given by : la\[i , k , A - - - * % m , j \]\[ i , k , A - - . % m,j\]Ira,p-1,A'--- . a , p , j \] where there is p such that m < p < j and a p = a and A ' = C\[q c ~  71a_O  , A--~a T_B flEpI(AE
AAC < ~* B ) is not empty 2 a\[i , k , A - - - ~% m , j\]~\[i , k , A'---*Ta , m + 1 , j \] providedra < j and am+a = a and A '= AEA \[ A--*a'/aftEpt is not empty  3a \[ i , k , A--+7 , m , j \]\[ i' , k ' , A'---*6 , m ' , j'\]~-+\[i , k , A - -+ % m , j \]\[ i' , k ' , A " --- , B , m ' , j '\] provided rn = i ' and B --* tiEpt for some BEA ' such that A "= C\]  3C  ---+  yB6  , D---*a T_A ~ Ept ( DEAAC <>* A ) is not empty 4 a\[i , k , A - . % m , j \]\[ i' , k ' , A ' ~ a , ,n ' , j '\]\[ i , k , h "-+-/ B , m ' , j \] provided m = k ' and B - - - + 6_ Epl for some BEA ' such that A "= AEAIA  ---+   crTB13 Ept is not empty sets A from the items . This results in common infix ( CI ) parsing , which is a generalization of common prefix parsing  \[8\]  . CI parsing does not satisfy the correct subsequence property  , to be discussed later . For space reasons , we omit further discussion of CI parsing . 
HI parsing
If we translate the difference between ELR and LR parsing  \[8\] to head-driven parsing , we are led to HI parsing , starting from EHI parsing , as described below . The algorithm is called HI because it computes head-inward derivations in reverse  , in the same way as LR parsing computes rightmost derivations in reverse  \[1\]  . Head-inward derivations will be discussed later in this paper  . 
Ill parsing uses items of the form \[ i , k , Q , m , j \] , where Q is a nonempty set of " double-dotted " rules A--*a *  3' * f t . The fundamental difference with the items in I EH l is that the infix  3' in the right hand sides does not have to be fixed . Formally , we have
IHI=\[i,k,Q,m,j\]\[$cQCA--a . 7  . B\]A--*aT_~EP ~ ) ^ i < k < m < j We explain the difference in behaviour of Ill parsing with regard to EHI parsing by investigating Clauses la and  2a of Algorithm 4  .   ( Clauses 3a and 4a would give rise to a similar discussion . ) Clauses la and 2 a both address some terminal ap , with m < p < j . In Clausela , the case is treated that a p is the head ( which is not necessarily the leftmost member ) of arhs which the algorithm sets out to recognize  ; in Clause 2a , the case is treated that a p is the next member of arhs of which some members have already been recognized  , in which case we must of course have p = m + 1 . 
By using the items from I t4r we may do both kinds of action simultaneously , provided p = m + 1 and a p is the leftmost member of somerhs of some rule  , where it occurs as head ) The lhs of such a rule should satisfy a requirement which is more specific than the usual requirement with regard to the head-corner relation  . 2 We define the left head-corner relation ( and the right head-corner relation , by symmetry ) as a subrelation of the head-corner relation as follows  . 
We define : B/A if and only if A---*Bo ~ for some a  . The relation Z * now is called the left head -corner relation  . 
We define go to right l(Q,X ) = C~~ . x . oIc ~ , lEoePt^3A--*a*7*B~EQ ( C <>* B ) goloright 2 ( Q , X ) = lIfap is not the leftmost member , then no successful parse will be found , due to the absence of rules with empty right hand sides  ( epsiion rules )  . 
2Again , the absence of epsilon rules is of importance here  . 
C ~. X . O\[C ~ X . OEPtA
SA-- . a . 7  . BflEQ(C/*B)UA  ~ a . TX . ~\[ A  ~ a . ' r .   X3E Q and assume symmetric definitions forgo to lefl 1 and go to left ~ . 
The above discussion gives rise to the new Clauses la and  2a of the algorithm below . The other clauses are derived analogously from the corresponding clauses of Algorithm  4  . Note that in Clauses 2a and 4a the new item does not replace the existing item , but is pushed on top of it ; this requires extra items to be popped off the stack in Clauses  3a and 4a   .  3
Algorithm 5 ( HI )
Am = ( T , IHz , Init(n ) , ~" hFin(n )) , where lnit(n ) = \[-1 ,  -1  , S'--+*\]-*S , O , n \] , Fin(n ) = \[- i ,  -1  , S ' - ~* . kS . , n , n \] , and ~ defined : la\[i , k , Q , m , j\]~\[i , k , Q , m , j \]\[ m , p-1 , Q' , p , j \] where there is p such that m + 1 < p_<j and ap = a and Q '= go to right l ( Q , a ) is not empty 2a\[i , k , Q , m , j\]~-~\[i , k , Q , m , j \]\[ i , k , Q ' , m + 1 , j \] provided m < j and am+l = a and Q ' = go to right ~  ( Q , a ) is not empty 3a\[i , k , Q , m , j \] Ii .   .   . I , _l\[i ' , k ' , Q ' , m ' , j '\]\[ i , k , Q ,   . ~ , ~\]\ [ i' ,  ~' , Q " , m ' , j '\] provided m < k ' , where there is B---** X1 .   .   . X r*EQ ' such that Q "= go to right i(Q , B ) is not empty 4 a\[i , k , Q , m , j \] I ~ . . . I , _ ~\ [ i ' , k ' , Q ' , m ' , j '\]\[ i , k , Q , m , j \]\[ i , k , Q " , m ' , j \] providedm = k ' or k = k ' , where there is B ~* X1 .   .   . X r ? EQ ' such that Q "= go to righl ~( Q , B ) is not empty We feel that this algorithm has only limited advantages over the EHI algorithm for other than degenerate head grammars  , in which the heads occur either mostly leftmost or mostly rightmost in right hand sides  . In particular , if there are few sequences of rules of the form A ---* A___Lai  , Ax ~ A__2 ot 2 ,  . . . ,Am-1 --~ Amain , or of the form A--- , alA__i , A1-' , a2A__g ,  . . . , A , ~- i ~ amAin , then the left and right head-corner relations are very sparse and HI parsing virtually simplifies to EHI parsing  . 
In the following we discuss a variant of head grammars which may provide more opportunities to use the advantages of the LR technique  . 
A generalization of head grammars The essence of head-driven parsing is that there is a distinguished member in each rhs which is recognized first  . Subsequently , the other members to the right and to the left of the head may be recognized  . 
An artifact of most head-driven parsing algorithms is that the members to the left of the head are recognized  3In  ? ? ?  I~-1 represent a number of items , as many as there are members in the rule recognized  , minus one . 
213 strictly from right to left , and vice versa for the members to the right of the head  ( although recognition of the members in the left part and in the right part may be interleaved  )  . This restriction does not seem to be justified , except by some practical considerations , and it prevents truly nondirectional parsing . 
We propose a generalization of head grammars in such a way that each of the two parts of arhs on both sides of the head again have a head  . The same holds recursively for the smaller parts of the rhs  . The consequence is that arhs can be seen as a binary tree  , in which each node is labelled by a grammar symbol  . The root of the tree represents the main head . The lefts on of the root represents the head of the part of the rhs to the left of the main head  , etc . 
We denote binary trees using a linear notation . For example , if a and /5 are binary trees , then ( cOX ( f 0 denotes the binary tree consisting of a root labelled X  , a left subtree a and a right subtreeft . The notation of empty ( sub ) trees ( e ) may be omitted . The relation --** ignores the head information as usual  . 
Regarding the procedural aspects of grammars , generalized head grammars have no more power than traditional head grammars  . This fact is demonstrated by a transformation r head from the former to the latter class of grammars  . A transformed grammar head ( e ) contain special nonterminals of the form\[c ~\] , where c ~ is a proper subtree of somerhs in the original grammar G =  ( T , N , P , S ) . The rules of the transformed grammar are given by : A--*\[a\]X\[fl \] for each A---*  ( a ) X ( f0 ? P\[ ( a ) X ( /~ ) \] ~ In \] X\[fl \] for each proper subtree ( a ) X ( fl ) of arhs in G where we assume that each member of the form \[ e \] in the transformed grammar is omitted  . 
It is interesting to note that vh , ~d is a generalization of a transformation vt , ~o which can be used to transform a contextfree grammar into two normal form  ( each rhs contains one or two symbols )  . A transformed grammar rt~o ( G ) contains special nonterminals of the form\[a\] , where c ~ is a proper suffix of arhs in G . The rules of r two ( G ) are given by
A--~X\[a \] for each A---*X a ? P\[X ? ~\]- -* X\[a \] for each proper suffix Xa of arhs in G where we assume that each member of the form \[ e \] in the transformed grammar is omitted  . 
HI parsing revisited
Our next step is to show that generalized head grammars can be effectively handled with a generalization of HI parsing  ( generalized HI ( GHI ) parsing )  . This new algorithm exhibits a superficial similarity to the  2-dimensional LR parsing algorithm from \[16\]  . For a set Q of trees and rules , 4 closure ( Q ) is defined to be 4It is interesting to compare the relation between trees and rules with the one between kernel and nonkernel items of LR parsing  \[1\]  . 
the smallest set which satisfies closure ( Q ) D_QUA - - ~ ( a ) X ( g ) ? P \] ( 7 ) A ( ~ f ) ? closure ( Q ) v
B ? cl0sure(Q )
The trees or rules of which the main head is some specified symbol X can be selected from a set Q by go to  ( Q , x ) = ( t?QIt == A- . 
In a similar way , we can select trees and rules according to a left or right subtree  . 
go to left ( Q , ~ ) = t?QIt = ( ~ ) X ( ~ ) v t = A --* ( a ) X ( /3 ) We assume a symmetric definition forgo to right . 
When we set out to recognize the left subtrees from a set of trees and rules  , we use the following function . 
left(Q ) = closure(cr\[(~)X (/5) ? Qv
A--*(a ) X (/~) ? Q)
We assume as ~, mmetric definition for right.
The set I all1 contains different kinds of item : ? Items of the form\[i  , k , Q , m , j \] , with i < k < m < j , indicate that trees ( a ) X ( fl ) and rules A---* ( a ) X ( ~ ) in Q are needed deriving a substring of ai+l . . . aj , where X - - - ~* ak + x .   .   . a , ~ has already been established . 
? Items of the form\[k , Q , m , j \] , with k < m < j , indicate that trees ( cOX ( fl ) and rules A ~ ( a ) X ( fl ) ill V are needed deriving a substring of a k + l . ?? aj , where ( ~ X - - - ~* ak + l .   .   . a , , has already been established . 
Items of the form \[ i , k , Q , m \] have a symmetric meaning . 
? Items of the form\[k , t , m \] , with k < m , indicate that 7"-'** ak+l . . . am has been established for tree t = 7 or rule t = A --* 7  . 
Algorithm 6 ( Generalized HI parsing ) AGH1 = ( T , IG in , Init(n ) ,  ~--~ , Fin(n )) , where Init(n ) : \[-1 , S'--*_L(S) , O , n \] , Fin(n ) = \[-1 , S'---*_L(S) , hi , and ~-* defined : la\[i , k , Q , m , j\]~--*\[i , k , O' , m \] provided Q '= go to right(Q , e ) is not empty lb\[i , k , Q , m , j \] . -- , \[ k , Q' , m , j \] provided Q '= go to left(Q , c ) is not empty lc\[k , Q , m , j \] , --*\[ k , t , m \] provided t ? go to right(Q , e)ld\[i , k , Q , m\]~\[k , t , m \] provided t ? go to left ( Q , ~) 2a\[i , k , Q , m , j\]~\[i , k , Q , m , j \]\[ m , p-1 , Q' , p , j \] where there is p such that m < p < j and Q ' = go to  ( right ( Q )  , ap ) is not empty 2b\[i , k , Q , m , j\]~\[i , k , Q , m , j \]\[ i , p-1 , Q' , p , k \] where there is p such that i < p < k and Q ' = go to  ( lefl ( Q )  , av ) is not empty\[-1 , S'\[-1 , S'\[-1 , S'\[-1 , S'\[-~ , s'--*_L(S ) ,  0 , 4\]_L(S) ,  0 ,  4\] \[0 ,  3 , S - - - , (( c)A(b )) s , S~(A(d )) s , S---*(B ) s ,  4 , 4\]-+J_(S) ,  0 ,  4\] \[0 ,  3 , S-+((c)A(b )) s , S - - - , ( A(d )) s , S-~(B ) s ,  4\]  . L(S ) ,  0 ,  4\] \[0 ,  3 , S~((c)A(b )) s , S---*(A(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , A  ~ a ,  2 ,  3\] ---*  . I_(S ) ,  0 ,  4\] \[0 ,  3 , S~((c)A(b )) s , S---*(m(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , A---*a ,  2\] \[-1 , S ' --* . L(S ) ,  0 ,  4\] \[0 ,  3 , S~((c)A(b )) s , S---*(A(d )) s , S~(B ) s ,  4\] \[1 , A--~a ,  2\] \[-1 , S ' ~ . L(S ) ,  0 ,  4\] \[0 ,  3 , S---*((c)A(b )) s , S---*(A(d )) s , S~(B ) s ,  4\] \[0 ,  1 , ( c)A(b ) , A(d ) , g(b ) ,  2 ,  3\] \[  .   .   .  \] \[0 ,  3 , S---*((c)A(b )) s , S---*(A(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , ( c)m(b ) , A(d ) , A(b ) ,  2 ,  3\] \[2 ,  2 , b ,  3 ,  3\] \[  .   .   .  \] \[0 ,  3 , S~((c)A(b )) s , S---*(A(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , ( c)A(b ) , A(d ) , A(b ) ,  2 ,  3\] \[2 , b ,  3\] \[  .   .   .  \] \[0 ,  3 , S-+((c)A(b )) s , S - --*( g(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , ( c)A(b ) , m(b ) ,  3\] \[  .   .   .  \] \[0 ,  3 , S--~((c)A(b )) s , S~(A(d )) s , S~(B ) s ,  4\] \[0 ,  1 , ( c)A(b ) , A(b ) ,  3\] \[0 ,  0 , c ,  1 ,  1\] \[-1 , S ' --* . L(S ) ,  0 ,  4\] \[0 ,  3 , S --*(( c)A(b )) s , S--~(A(d )) s , S---*(B ) s ,  4\] \[0 ,  1 , ( c)A(b ) , A(b ) ,  3\] \[0 , c ,  1\] \[-1 , S'--~J-(S ) ,  0 ,  4\] \[0 ,  3 , S~((c)A(b )) s , S---*(A(d )) s , S --*( B ) s ,  4\] \[0 , ( c)A(b ) ,  3\] \[- 1 , S'--*_L(S) , O ,  41 \[0 , S --*(( c)A(b )) s ,  4\] \[-1 , S'--*?(S ) , O ,  4\] \[0 , 0 , S , 4 , 4\] \[-1 , 5" ~ J_(S) , O ,  4\] \[0 , S , 4\]\[-l , S ' -- , _L(S ) ,  4\]
IClause 3ala3 blald 7b2ala , ld4 a3 bla , ld5b5 b7 ala , ld5a
Figure 1: Generalized HI parsing 3a\[k , Q , rn , j \] ~ - , \[ k , Q , m , j\]\[rn , p-1 , Q' , p , j \] where there is p such that m < p_<j and Q' - golo  ( righl ( Q )  , ap ) is not empty 35\[i , k , Q , m\]~--*\[i , k , Q , m\]\[i , p-1 , Q ' , p , k \] where there is p such that i < p < k and Q ' = go to  ( iefl ( Q )  , ap ) is not empty 4 a\[i , k , Q , m , j\]\[k' , 7 , m '\] ~- . \[ i , k , Q' , m '\] providedm = k ' , where Q ' = go to right(Q , 7) 4b Symmetric to 4a ( of . 2a and 2b ) 5a\[k , Q , m , j \]\[ k ' ,  7 , m'\]*--*\[k , t , rn '\] providedm = k ~ , where tE9o to right(Q , 7) 5b Symmetric to 5a ( cf . 3a and 3b ) 6 a\[i , k , Q , m , j \]\[ k ' , A---*7 , rn'\]~-~\[i , k , Q , m , j \]\[ m , k ' , Q ' , m ' , j \] provided m < k ' , where Q ' = goto(right(Q ) , A ) 6b Symmetric to 6 a 7 a\[k , Q , m , j\]\[k' , A---*7 , m'\]~--*\[k , Q , m , j \]\[ m , k ' , O ' , m ' , j \] provided rn_<k ' , where Q ' = goto(righl(Q ) , A )   7b Symmetric to 7a The algorithm above is based on the transformation r head  . It is therefore not surprising that this algorithm is reminiscent of LR parsing  \[1\] for a transformed grammar rt ~ oo ( G )  . For most clauses , a rough correspondence with actions of LR parsing can be found : Clauses  2 and 3 correspond with shifts . Clause 5 corresponds with reductions with rules of the form\[X a \] ---  , X\[a \] in r two ( G ) . Clauses 6 and 7 correspond with reductions with rules of the form A--*X\[a \] in r two  ( G )  . For Clauses 1 and 4 , corresponding actions are hard to find , since these clauses seem to be specific to generalized head-driven parsing  . 
The reason that we based Algorithm 6 on rhea a is twofold . Firstly , the algorithm above is more appropriate for presentational purposes than an alternative algorithm we have in mind which is not based on " /' head  , and secondly , the resulting parsers needless sets Q . 
This is similar in the case of LR parsing .   5 Example 1 Consider the generalized head grammar with the following rules : 
S--~((c)A(b )) s\](A(d )) sI(B ) s
A  ~ a
B-~A ( b)
Assume the input is given by a la2a3a4=cabs . The steps performed by the algorithm are given in Figure  1  . 

Apart from HI parsing , also TD , tIC , PHI , and EHI parsing can be adapted to generalized head-driven parsing  . 
Correctness
The head-driven stack automata studied so far differ from one another in their degree of nondeterminism  . 
In this section we take a different perspective . For all these devices , we show that quite similar relations exist between stack contents and the way input strings are visited  . Correctness results easily follow from such characterisations  .   ( Proofs of statements in this section are omitted for reasons of space  . ) Let G = ( N,T , P , S ) be a head grammar . To be used below , we introduce a special kind of derivation . 
sit is interesting to compare LR parsing for a contextfree grammar G with LR parsing for the transformed grammar r two  ( G )  . The transformation has the effect that a reduction with a rule is replaced by a cascade of reductions with smalle rules  ; apart from this , the transformation does not affect the global runtime behaviour of LR parsing  . More serious are the consequences for the size of the parser : the required number of LR states for the transformed grammar is smaller  \[9\]  . 

PS ~2~3 , 0X 3 , 1 ~3 , 1 X3 , 2 ~3 , 2X 3 , 3 ~3 , 3 Figure 2: A head-outward sentential form derived by the composition of a-derivations Pi  , 1 < i < 3 . The starting place of each a-derivation is indicated  , each triangle representing the application of a single production  . 
Definition 1 Aa-derivation has the form
Ap ~ p2 . . p ~ - ~ 70 B 71
P . ---+70 ar/flV1 p "-+"/0 cl~z/~71 , (1) where Pl , P2 .   .   .   .   , Ps are productions in pt , s > 1 , Pi rewrites the unique nonterminai occurrence introduced as the head element of  pi1 for 2 < i < S , p , =(Bc ~) and pEP * rewrites t1 into zET + . 
The indicated occurrence of string 7/ in ( 1 ) is called the handle of the a-derivation . When defined , the rightmost ( leftmost ) nonterminal occurrence in a ( /~ , respectively ) is said to be adjacent to the handle . The notions of handle and adjacent nonterminal occurrence extend in an obvious way to derivations of the form  CA0 L ?70Z710   , where A : -- , 70 z71 is a a-derivation . 
By composing a-derivations , we can now define the class of sentential forms we are interested in  . ( Figure 2 shows a case example . ) Def in i t ion 2 A head-outward sential form is obtained through a derivation 
PlS---,71,0zl , t71, 1
P2---+"f2,0X2,1.),2,1X2,2~,2,2

Vq,OT . q , lVq , lXq , 2Vq , 2"''\[q , q-lZq , qVq , q(2) where q > 1 , each Pi is a a-derivation and , for 2 < i < q , only one string 7 i-l , j is rewritten by applying Pi at a nonterminal occurrence adjacent to the handle of  pi1  . 
Sequence Pl , p ~, .   .   . , pq is said to derive the sentential form in (2) . 
The definition of head-outward sential form suggests a corresponding notion of head-outward derivation  . Informally , a head-outward derivation proceeds by recursively expanding to a terminal string first the head of a rule  , and then the remaining members of the rhs , in an outward order ? Conversely , we have head-in ward ( HI ) derivations , where first the remaining members in the rhs are expanded  , in an inward order ( toward the head ) , after which the head itself is recursively expanded  . Note that HI parsing recognizes a string by computing an HI derivation in reverse  ( of . Lit parsing ) . 
Let w = axa2? . -an , n > 1, be a string over T and let a 0= . 1_ . For-1 < i < j < n , we write ( i , j \] ,   , to denote substring ai+l???aj . 
Theorem 1 For Aone of Anc , APH1 or AEH ~ , the following facts are equivalent : ( i ) A reaches a configuration whose stack contents are 
IlI~...lq,q > 1, with
I t =\[ i t , k t , At---+at*Ot*fit , mt , jt\]or h =\[ it , k t , At---+~h , mt , j t \] or
I t =\[ i t , k t , At ~~? t , mt , j t \] for the respective automata , I < t < q ; ( it ) a sequence of a-derivations Pl , P2 ,   .   .   .   , P q , q >_1 , derives a head-outward sential form "/'0 ( k  ~ r ( 1 )  , mr(1)\]w71(k . (2) , rn ~ (2)\] wY2 ? ? ? ?"" Tq-1(kTr(q) , m ~ r(q)\]w ~ / q where lr is a permutation of 1 .   .   .   .   , q , P thas handle ~? t which derives ( kTr(t) , m ~ r(t)\]w , I < t < q , and m~(t-1) < kTr(t ) , 2 < t < q . 
As an example , an accepting stack configuration \[-1 ,  -1  , Sl ---* ? IS .   , n , n \] corresponds to a a-derivation ( S'---+IS ) p , pEP + , with handle_I_S which derives the head-outward sentential form  70  ( -1 , n\]~71=_l_w , from which the correctness of the head-corner algorithm follows directly  . 
If we assume that G does not contain any useless ym-bols  , then Theorem 1 has the following consequence , if the automaton at some point has consulted the symbol sail  , ai2 ,   .   .   . , aim from the input string , il .   .   .   .   . im increasing indexes , then there is a string in the language generated by G of the form voai ~ v l  .   .   . vm_lai,~vm . 
Such a statement may be called correct subsequence property  ( a generalization of correct prefix property\[8\] )  . 
Note that the order in which the input symbols are consulted is only implicit in Theorem  1   ( the permutation 7 r ) but is severely restricted by the definition of head-outward sential form  . A more careful characterisation can be obtained , but will take us outside of the scope of this paper  . 
The correct subsequence property is enforced by the  ( topdown ) predictive feature of the automata , and holds also for ATD and AHI . Characterisations similar to Theorem 1 can be provided for these devices . We investigate below the GHI automaton . 
For an item IE 1GU t of the form \[ i , k , Q , m , j \] , \[ k , Q , m , j \] , It , k , Q , m\]or\[k , t , m \] , we say that k ( m respectively ) is its left ( right ) component . Let N~be We need a function yld from reachable items in I am into  ( N't OT ) * , specified as follows . If we assume that ( cQX ( fl ) EQvA ~ ( t  ~ ) X ( /3 ) EQ and t = ( a ) X ( /3 ) V t = A --* ( a ) X ( ~3 )  , then
X if /=\[ i , k , Q , m , j\]yld(I ) =\[ a\]X if I =\[ k , Q , m , j\]
X\[fl \] if I =\[ i , k , Q , m\]\[a\]X\[fl\]ifI=\[k , t , m \] It is not difficult to show that the definition of yld is consistent  ( i . e . the particular choice of a tree or rule from Q is irrelevant  )  . 
Theorem 2 The following facts are equivalent : ( i ) AcHl reaches a configuration whose stack contents are IlI ~  .   .   . Iq , q > 1 , with k t and m t the left and right components , respectively , of It , and yld(It ) = Yt , for l < t < q ; ( it ) a sequence of tr-derivations Pl , P2 ,  . .  .   , P q , q > 1 , derives in rh ~ a a ( G ) a head-outward sential form 7 o ( k~r ( 1 )  , m , r(1)\]w"Y1(kr(2) , mr(2)\]w72 ? ? ? "'" 7q-1(k~-(q ) , m~(q)\]w')'q where ~ r is a permutation of 1 ,  .   .   .   , q , P thas handle t it which derives ( k ~( t ) , m , ~( t)\]w , 1 < t < q , and rex(t-l ) <_kx(t ) , 2 < t < q . 

We have presented a family of head-driven algorithms : TD  , I/C , Pill , EHI , and HI parsing . The existence of this family demonstrates that head-driven parsing covers a range of parsing algorithms wider than commonly thought  . 
The algorithms in this family are increasingly deterministic  , which means that the search trees have a decreasing size  , and therefore simple realizations , uchas backtracking , are increasingly eff?cient . 
However , similar to the left-to-right case , this does not necessarily hold for tabular realizations of these algorithms  . The reason is that the more refined an algorithm is  , the more items represent computation of a single subderivation  , and therefore some subderivations may be computed more than once  . This is called redundancy . Redundancy has been investigated for the left-to -right case in  \[8\]  , which solves this problem for ELR parsing . Head-driven algorithms have an additional source of redundancy  , which has been solved for tabular I-IC parsing in  \[14\]  . The idea from \[14\] can also be applied to the other head-driven algorithms from this paper  . 
We have further proposed a generalization of head -driven parsing  , and we have shown an example of such an algorithm based on LR parsing  . Prospects to even further generalize the ideas from this paper seem promising  . 
References\[1\]A . V . Aho , R . Sethi , and J . D . Ullman . Compilers : Principles , Techniques , and Tools . Addison-
Wesley , 1986.
\[2\]G . Bouma and G . van Noord . Head-driven parsing for lexicalist grammars : Experimental results  . In Sixth Conference of the European Chapter of the 
ACL , pages 71-80, April 1993.
\[3\]G . Gazdar , E . Klein , G . Pullum , and I . Sag . Generalized Phrase Structure Grammar . Harvard University Press , Cambridge , MA , 1985 . 
\ [4\] Third International Workshop on Parsing Technologies  ( IWPT3 )  , Tilburg ( The Netherlands ) and
Durbuy ( Belgium ), August 1993.
\[5\]R . Jackendoff . Xbar Syntax : A Study of Phrase Structure . The MIT Press , Cambridge , MA , 1977 . 
\[6\] M . Kay . I/ead-driven parsing . In International Parsing Workshop ' 89 , pages 5262 , Pittsburgh ,  1989 . 
\[7\] R . Leermakers . How to cover a grammar . In 27th Annual Meeting of the ACL , pages 135-142 , June 1989 . 
\[8\] M . J . Nederhof . An optimal tabular parsing algorithm . In this proceedings . 
\[9\] M . J . Nederhof and J . J . Sarbo . Increasing the applicability of LR parsing . In \[4\], pages 187-201 . 
\[10\]G . van Noord . Reversibility in Natural Language Processing . PhD thesis , University of Utrecht , 1993 . 
\[11\]C . Pollard and I . Sag . Information-Based Syntax and Semantics , volume 1: Fundamentals . CSLI Lecture Notes Series No .  13 , Center for the Study of Language and Information , Stanford University , 
Stanford , California , 1987.
\[12\]P . W . Purdom , Jr . and C . A . Brown . Parsing extended LR(k ) grammars . Acta Informatica , 15:115-127, 1981 . 
\[13\]G . Satta and O . Stock . Head-driven bidirectional parsing : A tabular method  . In International Parsing Workshop ' 89 , pages 4351 , Pittsburgh ,  1989 . 
\[14\]K . Sikkel and R . op den Akker . Predictive head-corner chart parsing . In\[4\], pages 267-276 . 
\[15\]E . So is a lon-Soininen and E . Ukkonen . A method for transforming grammars into LL ( k ) form . Acta
Informatica , 12:339-369, 1979.
\[16\]M . Tomita . Parsing 2-dimensional language . In M . Tomita , editor , Current Issues in Parsing Technology , chapter 18 , pages 277-289 . Kluwer Academic Publishers , 1991 . 

