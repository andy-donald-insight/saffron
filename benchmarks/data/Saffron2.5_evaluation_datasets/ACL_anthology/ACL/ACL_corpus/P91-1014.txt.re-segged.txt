Polynomial Time and Space Shift-Reduce Parsing
of Arbitrary Context-free Grammars.*
Yves Schabes
Dept . of Computer & Information Science
University of Pennsylvania
Philadelphia , PA 19104-6389, USA
email : schabes ~ linc.cis.upenn.edu
Abstract
We introduce an algorithm for designing a predictive left to right shift-reduce nondeterministic pushdown machine corresponding to an arbitrary unrestricted contextfree grammar and an algorithm for efficiently driving this machine in pseudo-parallel  . The performance of the resulting parser is formally proven to be superior to Earley's parser  ( 1970 )  . 
The techniquemployed consists in constructing before runtime a parsing table that encodes a nondeterministic machine in the which the predictive behavior has been compiled out  . At runtime , the machine is driven in pseudo-parallel with the help of a chart  . 
The recognizer behaves in the worst case in O ( IGI2n3 ) -time and O ( IGIn2 ) -space . However in practice it is always superior to Earley's parser since the prediction steps have been compiled before runtime  . 
Finally , we explain how other more efficient variants of the basic parser can be obtained by determinizing portions of the basic nondeterministic pushdown machine while still using the same pseudo -parallel driver  . 
1 Introduction
Predictive bottom-uparsers ( Earley , 1968; Earley , 1970; Graham et al ,  1980 ) are often used for natural language processing because of their superior average performance compared to purely bottom-up arsers * We are extremely indebted to Fernando Pereira and Stuart Shleber for providing valuable technical comments during discussions about earlier versio/m of this algorithm  . We are also grateful to Aravind Joehi for his support of this research  . We also thank Robert Frank . All remaining errors are the author's responsibility alone  . This research wa ~ partially funded by ARO grant DAAL03-89-C0031PRI and DARPA grant N00014-90-J-1863  . 
such as CKY-style parsers ( Kasami , 1965; Younger ,  1967) . Their practical superiority is mainly obtained because of the topdown filtering accomplished by the predictive component of the parser  . Compiling out as much as possible this predictive component before runtime will result in a more efficient parsers olong as the worst case behavior is not deteriorated  . 
Approaches in this direction have been investigated  ( Earley , 1968; Lang , 1974; Tomita , 1985; Tomita ,  1987) , however none of the missatisfying , either because the worst case complexity is deteriorated  ( worse than Earley's parser ) or because the technique is not general . Furthermore , none of these approaches have been formally proven to have a behavior superior to wellknown parser such as Earley's parser  . 
Earley himself ( \[1968\] pages 69-89 ) proposed to pre-compile the state sets generated by his algorithm to make it as efficient as LR  ( k ) parsers ( Knuth ,  1965 ) when used on LR ( k ) grammars by precomputing all possible state sets that the parser could create  . However , some contextfree grammars , including most likely most natural language grammars  , cannot be compiled using his technique and the problem of knowing if a grammar can be compiled with this technique is undecidable  ( Earley\[1968\] , page 99) . 
Lang ( 1974 ) proposed a technique for evaluating in pseudo -parallel nondeterministic pushdown automata  . Although this technique achieves a worst case complexity of O  ( n3 ) -time with respect to the length of input , it requires that at most two symbols are popped from the stack in a single move  . When the technique is used for shift-reduce parsing  , this constraint requires that the contextfree grammar is in Chomsky normal form  ( CNF )  . As far as the grammar size is concerned , an exponential worst case behavior is reached when used with the characteristic LR  ( 0 ) Tomita ( 1985 ;  1987 ) proposed to extend LR ( 0 ) parsers to nondeterministic contextfree grammars by explicitly using a graph structured stack which represent shepseudo-parallel evaluation of the moves of a nondeterministic LR  ( 0 ) pushdown automaton . 
Tomita's encoding of the nondeterministic pushdown automaton suffers from an exponential time and space worst case complexity with respect othe input length and also with respect o the grammar size  ( Johnson \[1989\] and also page 72 in Tomita \[1985\]  )  . Although Tomita reports experimental data that seem to show that the parser behaves in practice better than Earley's parser  ( which is proven to take in the worst case O ( \[G\[2n3 ) -time )  , the duplication of the same experiments shows no conclusive outcome  . 
Modifications to Tomita's algorithm have been proposed in order to alleviate the exponential complexity with respect othe input length  ( Kipps , 1989) but , according to Kipps , the modified algorithm does not lead to a practical parser  . Furthermore , the algorithm is doomed to behave in the worst case in exponential time with respect othe grammar size for some ambiguous grammars and inputs  ( Johnson ,  1989) . 2 So far , there is no formal proof showing that the Tomita 's parser can be superior for some grammars and inputs to Earley's parser  , and its worst case complexity seems to contradict he experimental data  . 
As explained , the previous attempts to compile the predictive component are not general and achieve a worst case complexity  ( with respect to the grammar size and the input length  ) worse than standard parsers . 
The methodology we follow in order to compile the predictive component of Earley's parser is to define a predictive bottom-up pushdown machine equivalent to the given grammar which we drive in pseudo-parallel  . Following Johnson's (1989) argument , any parsing algorithm based on the LR ( 0 ) characteristic machine is doomed to behave in exponential time with respect othegrammar size for some ambiguous grammars and inputs  . This is a result of the fact that the number of states of an LR  ( 0 ) characteristic machine can be exponential and that there are some grammars and inputs for which an exponential number of states must be reached  ( See Johnson \[1989\] for examples of such grammars and inputs )  . One must therefore design a different pushdown machine which  1 The same arguraent for the exponential graramar size complexity of Tomita's parser  ( Johnson , 1989) holds for Lang's technique . 
2 This problem is particularly acute for natural language processing since in this context he input length is typically small  ( 1020 words ) and the granunar size very large ( hundreds or thousands of rules and symbols )  . 
can be driven efficiently in pseudo-parallel.
We construct a nondeterministic predictive pushdown machine given an arbitrary contextfree grammar whose number of states is proportional to the size of the grammar  . Then at runtime , we efficiently drive this machine in pseudo -parallel  . Even if all the states of the machine are reached for some grammars and inputs  , a polynomial complexity will still be obtained since the number of states is bounded by the grammar size  . We therefore introduce a shift-reduced river for this machine in which all of the predictive component has been compiled in the finite state control of the machine  . The technique makes no requirement on the form of the contextfree grammar and it behaves in the worst case as well as Earley's parser  ( Earley ,  1970) . The pushdown machine is built before runtime and it is encoded as parsing tables in the which the predictive behavior has been compiled out  . 
In the worst case , the recognizer behaves in the same O ( \[Gl2nS ) -time and O ( \[G\[n2 ) -space as Earley's parser . However in practice it is always superior to Earley's parser since the prediction steps have been eliminated before runtime  . We show that the items produced in the chart correspond to equivalence classes on the items produced for the same input by Earley's parser  . This mapping formally shows its practical superior behavior  . 3 Finally , we explain how other more efficient variants of the basic parser can be obtained by determinizing portions of the basic nondeterministic pushdown machine while still using the same pseudo -parallel driver  . 
2 The Parser
The parser we propose handles any contextfree grammar  ; the grammar can be ambiguous and need not be in any normal form  . The parser is a predictive shift-reduce bottom-up arser that uses compiled topdown prediction information in the form of tables  . Before runtime , a nondeterministic pushdown automaton ( NP DA ) is constructed from a given contextfree grammar . The parsing tables encode the finite state control and the moves of the NPDA  . At runtime , the NPDA is then driven in pseudo-parallel with the help of a chart  . We show the construction of a basic machine which will be driven nondeterministically  . 
In the following , the input string is w--al .   .   . an and the contextfree grammar being considered is G =  ( ~ , NT , P , S ) , where ~ is the set of terminal 3The characteristic LR ( 0 ) machine is the result of determinizing then ~ a cld ne we introduce  . Since this procedure introduc exponentially more states  , the LR (0) machine can be exponentially large . 
107 symbols , NT the set of nonterminal symbols , Pa set of production rules , S the start symbol . We will need to refer to the subsequence of the input string w = az  .   .   . a N from position i to j , w\]i , j \] , which we define as follows : fai+l . . . aj , if i < jw \] i , ~\] I ,  ?  , if i >_j We explain the data structures ued by the parser  , the moves of the parser , and how the parsing tables are constructed for the basic NPDA  . Then , we study the formal characteristics of the parser . 
The parser uses two moves : shift and reduce . As in standard shift-reduce parsers , shift moves recognize new terminal symbols and reduce moves perform the recognition of an entire contextfree rule  . However in the parser we propose , shift and reduce moves behave differently on rules whose recognition has just started  ( i . e . rules that have been predicted ) than on rules of which some portion has been recognized  . This behavior enables the parser to efficiently perform reduce moves when ambiguity arises  . 
2 . 1 Data - St ructures and the Moves of the Parser The parser collects items into a set called the chart  , C . Each item encodes a wellformed substring of the input  . The parser proceeds until no more items can be added to the chart C  . 
An item is defined as a triple ( s , i , jl , where s is a state in the control of the NPDA , i and j are indices referring to positions in the input string  ( i , jE\[0 , n \]) . 
In an item ( s , i , j ) , j corresponds to the current position in the input string and i is a position in the input which will facilitate the reduce move  . 
A dotted rule of a contextfree grammar G is defined as a production of G associated with a dot at some position of the righthand side : A ~ a ? / ~ with 
A--~a flEP .
We distinguish two kinds of dotted rules . Kernel dotted rules , which are of the form A ~ a ? fl with a non empty  , and non-kernel dotted rules , which have the dot at the leftmost position in the right hand side  ( A--~?1~ )  . As we will see , non-kernel dotted rules correspond to the predictive component of the parser  . 
We will later see each states of the NPDA corresponds to a set of dotted rules for the grammar G  . 
The set of all possible states in the control of the NPDA is written S  . Section 2 . 2 explains how the states are constructed . 
The algorithm maintains the following property ( which guarantees its soundness ) 4: if an item ( s , i , j ) is in the chart C then for all dotted rules A ~ a of lEs the following is satisfied :  ( i ) if a E ( EUNT )  + , then B7E(NTU~)* such that S~w\]o , i \] A 7 and a = := ~ w \] ~ d\] ; ( ii ) if a is the empty string , then B7E(NTO ~)* such that S = ~ w\]0 . /\] A7 . 
The parser uses three tables to determine which move  ( s ) to perform : an action table , ACTION , and two go to tables , the kernel go to table , GOTOk , and the non-kernel go to table , GOTOnk . 
The go to tables are accessed by a state and a nonterminal symbol  . They each contain a set of states : GOTO~(s , X ) = r , GOTOnk(s , X ) = r ' with r , rt , sES , XENT . The use of these tables is explained below . 
The action table is accessed by a state and a terminal symbol  . It contains a set of actions . Given an item , ( s , i , j ) , the possible actions are determined by the content of ACTION  ( s , aj+x ) where aj+l is the j+1 thin put token . The possible actions contained in ACTION(s , aj+l ) are the following : ? KERNEL SHIFTst , ( ksh(st ) for short ) , for stES . A new token is recognized in a kernel dotted rule A--*a ? aft and a push move is performed  . 
The item ( sI , i , j+1) is added to the chart , since a a spans in this case w\]i , j+l\] . 
? NON-KERNEL SHIFTst , ( nksh(sI ) for short) , for stES . A new token is recognized in a non-kernel dotted rule of the form A--*? aft  . The item ( s ' , j , j+1) is is added to the chart , since a spans in this case wl jj+x\]?REDUCEX  ---  . fl , ( red(X---*fl ) for short) , for X--*~EP . The contextfree rule X--*/~ has been totally recognized  . The rule spans the substring ai+z . .  . aj . For all items in the chart of the form ( s ~ , k , i ) , perform the following two steps :- for all rlE GOTOk  ( s' , X ) , it adds the item ( ra , k , j ) to the chart . In this case , a dotted rule of the form A ~ a ? X fl is combined with X--*fl ? to form A---*a X ?/ ~  ; since a span sw\]k , i \] and X spans w li , j \] , a X spansw\]k , j\] . 
-for all r2EGOTOnk(st , X ) , it adds the item ( r2 , i , j ) to the chart . In this case , a dotted rule of the form A~?X f~is combined with X--~fl ? to form A ~ X ? / ~  ; in this case X spans w\]idl-4This property holds for all machines derived from the basic 


The recognizer follows : begin (* recognizer *)
Input : al *?? an


GOT Onk start E , 9 . ~ C , q ( * input string * )   ( * action table * )   ( * kernelgo to table * )   ( * non-kernelgo to table * )   ( * start state * )   ( * set of final states * ) Output : acceptance or rejection of the input string  . 
Initialization : C := ( start , O , 0)
Perform the following three operations until no more items can be added to the chart C :  ( 1 ) KERNELSHIFT : if ( s , i , j ) 6 Can difks h(s ') 6 ACTION(s , aj+I ) , then ( s ' , i , j+1) is added to C . 
(2) NON-KERNEL SHIFT : if ( s , i , j)eCandifnksh(s ') EACTION(s , aj+I ) , then ( s ' , j , j+1) is added to C . 
(3) REDUCE : if ( s , i , j ) EC , then for all X--~j3s . t . red(X ~ ~) 6 ACTION(s , aj+t ) and for all ( s ' , k , i ) EC , perform the following : ? for all rl 6GOTO~(s ' , X ) , ( rl , k , j ) is added to C ; ? for all r2EGOTOnk(s' , X ) , ( r  ~ , i , j ) is added to C . 
If ( s , O , n ) I(s , O , n ) 6 C and se . r .   then return acceptance otherwise return rejection  . 
end (* recognizer *)
In the above algorithm , nondeterminism arises from multiple entries in ACTION  ( s , a ) and also from the fact that GOTOk(s , X ) and GOTOnk(s , X ) con-tain a set of states . 
2  . 2 Const ruct ion o f the Pars ing Tab les We shall give an LR  ( 0 ) -like method for constructing the parsing tables corresponding to the basic NPDA  . 
Several other methods ( such as LR(k)-like , SLR ( k ) -like ) can also be used for constructing the parsing tables and are described in  ( Schabes ,  1991) . 
To construct the LR ( 0 ) -like finite state control for the basic nondeterministic pushdown automaton that the parser simulates  , we define three functions , closure , go to k and go to n k . 
If s is a state , then closure ( s ) is the state constructed from s by the two rules :   ( i ) Initially , every dotted rule in s is added to closure ( s ) ;   ( ii ) If A--*a ? B/~is in closure ( s ) and B --*7 is a production , then add the dotted rule B --* e7 to closure ( s )   ( if it is not already there )  . This rule is applied until no more new dotted rules can be added to closure  ( s )  . 
If s is a state and if X is a nonterminal or terminal symbol  , go tok(s , X ) and go to nk(s , X ) are the set of states defined as follows : go to k ( s , X ) = closure ( A?A-*?X Zesanda E ( Z3UNT ) + go to nk ( s , X ) = closure(AX . ,8 ) ) 1 A?s The got of unctions we define differ from the one defined for the LR  ( 0 ) construction it wo ways : first we have distinguished transitions on symbols from kernel items and non-kernel items  ; second , each state in go to ~( s , X ) and gOtOn~(S , X ) contains exactly one kernel item whereas for the LR  ( 0 ) construction they may contain more than one . 
We are now ready to compute the set of states , 9 defining the finite state control of the parser . 
The SETOFSTATESCONSTRUCTION is constructed as follows : procedure states  ( G ) begin S := closure ( S - - ,   . ~IS-*ae P ) repeat for each states in 8 for each XEr~uNT terminal for each rEgotok ( s , X ) Ugoton ~( s , X ) addr to Suntil no more states can be added to  8 end PARSING TABLES . Now we construct the LR ( 0 ) parsing tables ACTION , GOTOk and GOTOnk from the finite state control constructed above  . Given a contextfree grammar G , we construct ~ q , the set of states for G with the procedure given above  . We construct the action table ACTION and the go to tables using the following algorithm  . 
begin ( CONSTRUCTION OF THE PARSING TABLES )
Input : A contextfree grammar
G = ( Y , , NT , P , S).
Output : The parsing tables ACTION , GOTOk and GOTOnk for G , the start state start and the set of final states  ~'  . 

Step 1 . Construct 8= so , .   .   . , sin , the set of states for G . 
Step 2 . The parsing actions for state si are determined for all terminal symbols a E ~ as follows:  ( i ) for all regotok ( si , a ) , add ksh(r ) to
ACTION(si , a ); ( ii ) for all rEgoto , k ( si , a ) , add nksh(r ) to to
ACTION(si , a ); ( iii ) if A--*a * is in si , then addred ( A--*a ) to ACTION(si , a ) for all terminal symbola and for the endmarker  $  . 
Step 4 . The kernel and non-kernel go to tables for state si are determined for all nonterminal symbols X as follows:  ( i ) VXENT , GOTO~(si , X ) := go to k(si , X )( ii)VXENT , 
GOTOnk(si,X):--gotonk(si,X)
Step 3 . The start state of the parser is start := ciosure ( S --* . a IS--~a ~ _P ) Step 4 . The set of final states of the parser is Y := s e  SI3 S--*a 6 Ps . t . S - - . a . Esend ( CONSTRUCTION OF THE PARSING TABLES ) Appendix A gives an example of a parsing table . 
3 Complexity
The recognize requires in the worst case O ( \[GIn2 ) -space and O ( \[G\[2na ) -time ; n is the length of the input string , \]GI is the size of the grammar computed as the sum of the lengths of the right hand side of each productions :\[ GI = E\[aI  , where la \] is the length of a . 
A -* aEP
One of the objectives for the design of the nondeterministic machine was to make sure that it was not possible to reach an exponential number of states  , a property without which the machine is doomed to have exponential complexity  ( Johnson ,  1989) . First we observe that the number of states of the finite state control of the nondeterministic machine that we constructed in Section  2  . 2 is proportional to the size of the grammar , IG\[ . By construction , each state ( except for the start state ) contains exactly one kernel dotted rule . Therefore , the number of states is bounded by the maximum number of kernel rules of the form A--*ao/~  ( with a nonempty )  , and is O(IGI ) . 
We conclude that the algorithm requires in the worst case O  ( IGIn~ ) -space since the maximum number of items ( 8 , i , j ) in the chart is proportional to IGIn 2 . 
A close look at the moves of the parse reveals that the reduce move is the most complex one since it involves a pair of states  ( s , i , j ) and ( s' , k , j / . This move can be instantiated at most O ( IGI2nS ) -time since i , j , kE\[0 , n \] and there are in the worst case O ( IGI ~ ) pairs of states involved in this move .   5 The parser therefore behaves in the worst case in O  ( IGI2nS ) -time . 
One should however note that in order to bound the worst case complexity as stated above  , arrays similar to the one needed for Earley's parser must be used to implement efficiently the shift and reduce moves  . 6As for Earley's parser , it can also be shown that the algorithm requires in the worst case O  ( IGI2n2 ) -time for unambiguous contextfree grammars and behaves in linear time on a large class of grammars  . 
4 Retrieving a Parse
The algorithm that we described in Section 2 is a recognizer . However , if we include pointers from an item to the other items  ( to a pair of items for the reduce moves or to an item for the shift moves  ) which caused it to be placed in the chart , the recognizer can be modified to record all parse trees of the input string  . 
The representation is similar to a shared forest.
The worst case time complexity of the parser is the same as for the recognizer  ( O ( \[GI2n3 ) -time ) but , as for Earley's parser , the worst case space complexity increases to O ( \[G\[2n3 ) because of the additional bookkeeping . 
5 Correctness and Comparison with Earley's Parser We derive the correctness of the parser by showing how it can be mapped to Earley's parser  . In the process , we will also be able to show why this parser can be more efficient han Earley's parser  . The detailed proofs are given in ( Schabes ,  1991) . 
We are also interested informally characterizing the differences in performance between the parser we propose and Earley's parser  . We show that the parser behaves in the worst scenario as well as Ear-ley's parser by mapping it into Earley's parser  . The parser behaves better than Earley's parser because it has eliminated the prediction step which takes in the worst case O  ( \]GIn ) -time for Earley's parser . Therefore , in the most favorable scenario , the parser we SKerael shift and non-kernel shift moves require both at most O  ( IGIn 2 ) -time . 
6 Due to the lack of space , the details of the implementation are not given in this paper but they are given in  ( Schabes ,  1991) . 
110 propose will require O ( IGln ) less time than Earley's parser . 
For a given contextfree grammar G and an input string al  .  -  . an , let C be the set of items produced by the parser and Cear Zey be the set of items produced by Earley's parser  . Earley's parser ( Earley , 1970) produces items of the form ( A---*a * ~ , i , j ) where A--*a ?~ is a single dotted rule and not a set of dotted rules  . 
The following lemma shows how one can map the items that the parser produces to the items that Ear-ley's parser produces for the same grammar and input : Lemma  1 If Cs , i , j ) EC then we have: ( i ) for all kernel dotted rules A ~ a ? ~ Es , we have CA~ct ? ~ , i , j ) E Cear Iey ( ii ) and for all non-kernel dotted rules A--- , * j3 Es , we have CA ~? ~ , j , j ) E Cearaev The proof of the above lemma is by induction on the number of items added to the chart C  . 
This shows that an item is mapped into a set of items produced by Earley's parser  . 
By construction , in a given states ES , non-kernel dotted rules have been introduced before runtime by the closure of kernel dotted rules  . It follows that Ear-ley's parser can require O ( IGln ) more space since all Earley's items of the form C A ~? a  , i , i ) ( iE\[0 , n \] ) are not stored separately from the kernel dotted rule which introduced them  . 
Conversely , each kernel item in the chart created by Earley's parser can be put into correspondence with an item created by the parser we propose  . 
Lemma 2 If CA--*a?fl , i , j ) E Cear Zev and if (~ #e , then Cs , i , j ) eC where s = closure ( A  ~ a ? f l ) . 
The proof of the above lemma is by induction on the number of kernel items added to the chart created by Earley's parser  . 
The correctness of the parser follows from Lemma 1 and its completeness from Lemma 2 since it is wellknown that the items created by Earley's parser are characterized as follows  ( see , for example , page 323 in Aho and Ullman \[1973\] for a proof of this invariant ) : Lemma 3 The item CA-- . a ? fl , i , j ) E Ceartey if and only if , STE(VNTUVT ) * such that S " ~ W\]o , i \] X T and X == c , FA = ~ w\]ij \] A . 
The parser we propose is therefore more efficient than Earley's parser since it has compiled out prediction before runtime  . How much more efficient it is , depends on how prolific the prediction is and therefore on the nature of the grammar and the input string  . 
6 Optimizations
The parser can be easily extended to incorporate standard optimization techniques proposed for predictive parsers  . 
The closure operation which defines how a state is constructed already optimizes the parser on chain derivations in a manner very similar to the techniques originally proposed by Grahameta \]  . (1980) and later also used by Leiss (1990) . 
In addition , the closure operation can be designed to optimize the processing of nonterminal symbols that derive the empty string in manner very similar to the one proposed by Graham et al  ( 1980 ) and Leiss ( 1990 )  . The idea is to perform the reduction of symbols that derive the empty string at compilation time  , i . e . include this type of reduction in the definition of closure by adding  ( iii ) : If s is a state , then closure ( s ) is now the state constructed from s by the three rules :  ( i ) Initially , every dotted rule in s is added to closure ( s ) ; ( ii ) if A~a . B f l is in closure ( s ) and B~7 is a production , then add the dotted rule B~?7 to closure ( s )   ( if it is not already there )  ; ( iii ) if A~a . B ~ is in closure(s ) and if B = ~ e , then add the dotted rule A ~ a B ? ~ to closure ( s )   ( if it is not already there )  . 
Rules ( ii ) and ( iii ) are applied until no more new dotted rules can be added to closure  ( s )  . 
The rest of the parser remains as before.
7 Variants on the basic ma-chine
In the previous section we have constructed a machine whose number of states is in the worst case proportional to the size of the grammar  . This requirement is essential to guarantee that the complexity of the resulting parser with respect othegrammar size is not exponential or worse than O  ( IGI2 ) -time as other wellknown parsers . However , we may use some nondeterminism in the machine to guarantee this property  . The nondeterminism of the machine is not a problem since we have shown how the nondeterministic machine can be efficiently driven in pseudo-parallel  ( in O ( \[G\[2n3 ) -time )  . 
We can no wask the question of whether it is possible to determinize the finite state control of the machine while still being able to bound the complexity of the parser to O  ( \[Gl2n3 ) -time . Johnson ( 1989 ) exhibits grammars for which the full determinization leads to a parser with exponential complexity  , because the finite state control has an exponential number of states and also because there are some input string for which an exponential number of states will be reached  . However , there are also cases where the full determ in ~ation either will not increase the number of states or will not lead to a parser with exponential complexity because there are no input that require to reach an exponential number of states  . We are currently studying the classes of grammars for which this is the case  . 
One can also try to determinize portions of the finite state automaton from which the control is derived while making sure that the number of states does not become larger than O  ( IGI )  . 
All these variants of the basic parser obtained by determinizing portions of the basic nondeterministic pushdown machine can be driven in pseudo-parallel by the same pseudo-parallel driver that we previously defined  . These variants lead to a set of more efficient machine since the nondeterminism is decreased  . 
8 Conclusion
We have introduced a shift-reduce parser for unrestricted contextfree grammars based on the construction of a nondeterministic machine and we have formally proven its superior performance compared to 
Earley's parser.
The technique which we employed consists of constructing before runtime a parsing table that encodes a nondeterministic machine in the which the predictive behavior has been compiled out  . At runtime , the machine is driven in pseudo-parallel with the help a chart  . 
By defining two kinds of shift moves ( on kernel dotted rules and on non-kernel dotted rules  ) and two kinds of reduce moves ( on kernel and non-kernel dotted rules )  , we have been able to efficiently evaluate in pseudo-parallel the nondeterministic pushdown machine constructed for the given contextfree grammar  . 
The same worst case complexity as Earley's recognizer is achieved : O  ( IGl2na ) -time and O ( IG\]n2 ) -space . However , in practice , it is superior to Earley's parser since all the prediction steps and some of the completion steps have been compiled before runtime  . 
The parser can be modified to simulate other types of machines  ( such LR ( k ) -like or SLR-like automata )  . 
It can also be extended to handle unification based grammars using a similar method as that employed by Shieber  ( 1985 ) for extending Earley's algorithm . 
Furthermore , the algorithm can be tuned to a particular grammar and therefore be made more efficient by carefully determinizing portions of the nondeterministic machine while making sure that the number of states in not increased  . These variants lead to more efficient parsers than the one based on the basic nondeterministic pushdown machine  . Furthermore , the same pseudo-parallel driver can be used for all these machines  . 
We have adapted the technique presented in this paper to other grammatical formalism such as tree -adjoining grammars  ( Schabes ,  1991) . 
Bibliography
A . V . Aho and J . D . Ullman .  1973 . Theory of Parsing , Translation and Compiling . VolI : Parsing . 
Prentice-Hall , Englewood Cliffs , NJ.
Jay C . Earley .  1968 . An Efficient ContextFree Parsing Algorithm . Ph . D . thesis , Carnegie Mellon University , Pittsburgh , PA . 
Jay C . Earley .  1970 . An efficient contextfree parsing algorithm . Commun . ACM , 13(2):94-102 . 
S . L . Graham , M . A . Harrison , and W . L . Ruzzo .  1980 . 
An improved contextfreer cognizer . ACM Transactions on Programming Languages and Systems  ,  2(3):415-462 , July . 
Mark Johnson .  1989 . The computational complexity of Tomlta's algorithm  . In Proceedings of the International Workshop on Parsing Technologies  , 
Pittsburgh , August.
T . Kasami .  1965 . An efficient recognition and syntax algorithm for contextfree languages  . Technical Report AF-CRL-65-758 , Air Force Cambridge Research Laboratory , Bedford , MA . 
James R . Kipps .  1989 . Analysis of Tomita's algorithm for general contextfree parsing  . In Proceedings of the International Workshop on Parsing 
Technologies , Pittsburgh , August.
D . E . Knuth .  1965 . On the translation of languages from left to right  . Information and Control , 8:607-639 . 
Bernard Lang .  1974 . Deterministic techniques for efficient nondeterministic parsers  . In Jacques Loeckx , editor , Automata , Languages and Programming , 2nd Colloquium , University of Saarbr ~ cken . Lecture Notes in Computer Science,
Springer Verlag.

Hans Leiss .  1990 . On Kilbury's modification of Ear-ley's algorithm . ACM Transactions on Programming Languages and Systems  ,  12(4):610-640 , October . 
Yves Schabes .  1991 . Polynomial time and space shift-reduce parsing of contextfree grammars and of tree-adjoining grammars  . In preparation . 
tte

Stuart M . Shieber .  1985 . Using restriction to ex- 1 tend parsing algorithms for complex-feature -based  2 formalisms . In 23 rd Meeting of the Association 3   4 for Computational Linguistics ( ACL'85 )  , Chicago , s

Masaru Tomita .  1985 . Efficient Parsing for Natural Language , A Fast Algorithm for Practical Systems . 
Kluwer Academic Publishers.
Masaru Tomita .  1987 . An efficient augmented-context-free parsing algorithm  . Computational
Linguistics , 13:31-46.
D . H . Younger .  1967 . Recognition and parsing of contextfree languages in time n  3  . Information and
Control , 10(2):189-208.
AAn Example
We give an example that illustrates how the recognizer works  . The grammar used for the example generates the language L =  a  ( ba ) n l n >_O and is in finitely ambiguous :
S--. SbS

S--, a
The set of states and the got of unction are shown in Figure  1  . In Figure 1 , the set of states is 0 ,  1 ,  2 ,  3 ,  4 ,  5 . We have marked with a sharp sign ( ~ ) transitions on a non-kernel dotted rule . If an arc from 51 to 52 is labeled by a non-sharped symbol X , then s2 is ingo to t(Sl , X ) . If an arc from sl to 52 is labeled by a sharped symbol X ~ , then 52 is in got on t(Sx , X ) . 
14$ ~"( S-~S'b$)s CL"~rS--~Sb'S~--TLi . Sb , - . > --~* S/
IS-~S , --#- aJ --> SbS-)
Figure 1: Example of set of states and got of unction . 
The parsing table corresponding to this grammar is given in Figure  2  . 
ACTION . k , h(3) red(S--*S)red(S~a)nksh(3) red(S--*SbS)
IbI$ksh(4), ~ d(S-- . S ), ~ a(S- . S ), ~ d(S - - . ,),, d(s-~,) red(S-~5bS)red(S . --*~ SbS')



Ok
S5)
Figure 2: An LR ( 0 ) parsing table for L =  a ( ba ) " In ~0 . The start state is 0 , the set of final states is 2 ,  3 ,  5 . $ stands for the endmarker of the input string . 
The input string given to the recognizer is : ababa $  ( $ is the endmarker )  . The chart is shown in Figure 3 . In Figure 3 , an arc labeled by s from position i to position j denotes the item  ( s , i , j ) . The input is accepted since the final states 2 and 5 span the entire string ( (2 ,  0 , 5) EC and (5 ,  0 , 5) EC ) . Notice that there are multiple arcs subsuming the same substring  . 
aababa abababa items in the chart (0 , O , 0 I(3 , 0 , 1) (2 , 10 , 1) (1 , 0 , 1) 14 , 0 , 2) (3'2'3) (2'0'3) (2'2 l ,  3) (1 , 0 ,  3)(1 , 2 ,  3)15 , 0 , 3) (4 , O ,  4 ) (4  ,  2 ,  4) (3 , 4 , 5) (2 , 0 , 5) (2 , 2 , 5) (2 , 4 , 5) (1 , 0 , 5) (1 , 2 , 5) (1 , 4 , 5) (5 , 0 , 5)(5 , 2 , 5)
Figure 3: Chart created ~ r the inputo al b2a3b4ah$  . 
Oo

SI1,2)1,2
