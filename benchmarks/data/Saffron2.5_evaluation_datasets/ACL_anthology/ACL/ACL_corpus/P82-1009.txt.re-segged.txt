THEORETICAL/TECHNICALIS SUESINN A TURALL ANGUAGE A CCESS TO DAT A BASES 
S.R . Petrick
IBM T.J . Watson Research Center

In responding to the guidelines established by the session chairman of this panel  , three of the five topic she set forth will be discussed  . These include aggregate functions and quantity questions  , querying semantically complex fields , and multi-file queries . As we will make clear in the sequel , the transformational apparatus utilized in the TQA Question Answering System provides a principled basis for handling these and many other problems in natural language access to databases  . 
In addition to considering some subset of the chairman's five problems  , each of the pane lists was invited to propose and choose one issue of his/her own choosing  . If time and space permitted , I would have chosen the subject of extensibility of natural language systems to new applications  . In light of existing restrictions , however , I have chosen a more tractable problem to which I have given some attention and in whose treatment I am interested  ; this is the translation of quantified relational calculus expressions to a formal query language such as SQL  . 
AGGREGATEFUNCTIONS ANDQUANTITY QUESTIONS Questions such as " How many employees are in the sales department ? " must be mapped into three radically different database query language expressions depending on how the database is set up  . It may heap propriate to retrieve a prestored total number of employees from a NUMBER-OF -EMPLOYEES field of a DEPART MENT file  , or to count the number of records in an EMPLOYEE file that have the value SALES in the DEPARTMENT field  , or , if departments are broken down into offices with which are associated the total numbers of employees employed therein  , to total the values of the NUMBER-OF-EMPLOYEES field in all the records for offices in the sales department  . 
In the TQA System there are a number of different levels of representation of a given query  . The grammar which assigns structure to a query has some core components which are essentially application-independent  ( e . g . , the cyclic and post-cyclic transformations ) and has other components that are application -dependent  ( e . g . , portions of the lexicon and precyclic transformations  )  . Surface structures are mapped by the application -independent postcyclic and cyclic transformations into a relatively deep structural level which is referred to as the underlying structure level  . In this representation , sentence nodes are expanded into a verb followed by a sequence of noun phrases  , and the representation of reference is facilitated by the use of logical variables XI  , X2 ,   . . . . The underlying structure corresponding to the previously cited example sentence would be something like the following  ( suppressing details ) : LOCATED WHSOME MANY EMPLOYEE X1 SALE SDE PART MENT Now , depending on feature information associated with the lexical items in the two NP's  , application-specific precyclic transformations can be formulated to map this underlying structure into any of three query structures that directly reflect the three data structures and corresponding formal queries previously discussed  . Rather than sketching query structures that could be produced for this example  , let me be more specific by substituting the actual treatment of two similar sentences currently treated by the TQA System land-use application  . 
These are the sentences : ( i ) " How many parking lots are the reinward 1 block 2?"   ( 2 ) " How many parking spaces are the reinward 1 block 2?" In the current database , individual lots are identified as being parking lots by al and use code relation LUC F  , which has attributes that include JACCN ( parcel account number ) and LUC ( l and use code )  . Parking lots have an LUC value of 460 . Another relation , PARCFL , has attributes which include JACCN and JPRK ( the number of parking spaces on a given parcel )  . 
The underlying structures assigned to both these sentences are nearly identical  , differing only in the lexical distinctions between " parking lot " and " parking space "  . The common structure is very much like that of the previously given tree structure except that PARKINGLOT or PARKING SPACE  ( together with their associated features ) replaces EMPLOYEE , and the second NP dominates the string " WARD 1 BLOCK 2"  . The feature + UNIT on a node that dominates PARKING SPACE is not found in the corresponding structure involving PARKING LOT  , and this feature ( together with a number of other structural prereq -transformations  . The action of those two transf-ormations is roughly indicated by the following sequence of bracketted terminal strings  ( the actual trees together with all their features would take up much more space  ) :  ( BDLOCATED ( ( WH SO ~ MANY )   ( PARKING SPACEX3 ) )  ( ( WARD i )   ( BLOCK 2 ) ) BD ) 
TOTPUNIT . >  ( BDT OTAL ( ( WH SOME )   ( THINGX 46 ) )  ( THE ( X3 ( BDP ARKING SPACE
X3((WARDI ) ( BLOCK2)) BD ))) BD)
LOT INS2-> ( BDT OTAL ( ( WH SOME )   ( THINGX 46 ) )  ( THE ( X3 ( BDP ARKING SPACE
X3(THE((LOTX48) ( BDLOCATED
X48 (( WARDi ) ( BLOCK2))
B D ))) B D ))) B D )
Note that the lot ~ nsertion transformation LOTINS2 has produced structure of the type which is more directly assigned to the input query  , "What is the total number of parking spaces in the lots which are located in ward  1 block 2?"  . This structure is then further transformed by a transformation LOCATION that replaces the abstract verb LOCATED by a verb  ( WBLOCK in this instance ) which corresponds to an existing database relation  . 
LOCATION -> ( BDT OTAL ( ( WH SOME )   ( THINSX 46 ) )  ( THE ( X3 ( BDP ARKING SPACE
X3 ( THE ( ( LOT X48 )   ( BDWBLOCK ( ( WARD i )   ( BLOCK 2 ) )

B D ))) B D ))) B D )
The latter structure is mapped via the TQAK nuth attribute grammar formalism into the logical form  :   ( set x ' X46' ( total X46 ( bag x ' X3' ( set x ' X48' ( and ( RELATION ' PARCFL' ( JPRKJ ACCN )  ' ( x3 x48 )  ' ( = = )   )   ( RELATION ' PARCFL' ( WBLOCKJACCN' ( ' 100 200 X 48 )  ' ( = = ) ) ) ) ) ) ) This logical form is in a set domain logical calculus to be discussed later in the paper  . Roughly , it denotes the set of elements X46 such that X46 is the sum of the members of the bag ( like a set , but with possible duplicate elements ) of elements X3 such that a certain set is not empty , namely the set of elements X48 such that X48 is the account number ( JACCN ) of a parcel whose number of parking spaces ( JPRK ) is X3 and whose ward block ( WBLOCK ) is 100 200 . 
The expression ( RELATION ' PARCFL' ( JPRKJ ACCN )  ' ( X 3 X 48 )  ' ( == )   ) in the above logical form denotes the proposition that the relation formed from the PARCFL relation by projecting over the attributes JPRK and JACCN contains the tuple  ( X 3 X 48 )  . The logical form is straightforwardly translated by means of a LISP program whose details we will not concern ourselves within to the SQL query : 
SELECTSUM ( A . JPRK)
FROM PARCFLA
WHEREA . WBLOCK='100 200';
The other structure ( for the sentence with PARKINGLOT ) lacks the triggering feature + UNIT , and hence . transformations TOTPUNIT and LOTINS2 do not apply ; furthermore , the LOCATION transformation applies to the original instance of the verb LOCATED rather than the copy of LOCATED introduced by the lot insertion transformation  LOTINS2 in the analysis of the previous sentence : ( BDLOCATED ( ( WE SOME MANY )   ( ( PARKING LOT 460 ) X3 ) )  ( ( WARD i )   ( BLOCK 2 ) ) BD ) 
LOCATION -> ( BDWBLOCK ( ( WARD I )   ( BLOCK 2 ) )  ( ( WH SOME MANY )   ( ( PARKING_LOT 460 ) X3 ) ) BD ) This structure is mapped via the Knuth attribute grammar into the logical form :  ( set x ' X48' ( quantity X48 ( set x ' X3' ( and ( RELATION ' PARCFL' ( WBL OCK JAC CN )  ' ( ' 100 200 X 3 )  ' ( == )   )   ( RELATION ' LUCF' ( LUCJ ACCN )  ' ( '0460 X3 )  '  ( == ) )  )   )   )   ) query :
SELECTCOUNT ( UNIQUEA . JACCN)
FROM PARCFLA , LUCFB
WHEREA oJ ACCN = B . JAC CN
ANDB?LUC='0460'
ANDA . WBLOCK='100 200' ; ~ qlepoints to be made with respect to this treatment are that the information indicating differential  , database-specific treatment can be encoded in lexical features  , and that differential treatment itself can be implemented by means of pre-cyclic transformations which are formally of the same type that the TQA system uses to relate underlying to surface structures  . The features , such as + UNIT in our example , are principled enough to permit their specification by a database administrator with the help of an online application customization program  .   ( + UNIT is also required in lexical items such as DWELLINGUNITS and STORIES  )  . 
If the database organization had been different , simple lexical changes could have been made to trigger different sequences of transformations  , resulting in structures and ultimately SQL expressions appropriate for that database organization  . In this way , it would be easy to handle such database organizations as that in which the total number of parking lots and/or parking spaces is stored for each ward block  , and that in which such totals are stored for each split block which is included within a given ward block  . 
QUERYINGSE~IANTICALLY COMPLEX FIELDS
In posing this problem , the session chairman pointed out that natural language query systems usually assume that the Concepts represented by database fields will always be expressed in English by single words or fixed phrases  . He cited as an example the query " Is John Jones a child of an alumnus ? " where " child of an alumnus " is a fixed phrase expressing the binary relation with attributes APPLICANT  ( whose values are the names of applicants ) and CHILD-0F-ALUMNUS ( whose values are either T or F )  . He further noted that related queries such as " Isone of John Jones ' parents an alumnus ? " or " Did either parent of John Jones attend the college ?  ) " require some different treatment . 
The approach we have taken in TQA is , insofar as possible , to provide the necessary coverage to permit all the locutions that are natural in a given application  . The formalism by which this is attempted is , once again , the transformational apparatus . Transformations often coalesce queries which have the same meaning but differ substantially in their surface forms into common underlying or query structures  . There is ~ however , no requirement that this always be done , so such queries are sometimes mapped into logically equivalent rather than identical query structures  . In either case , the transformational formalism provides a solid basis for assigning very deep semantic structures to a wide spectrum of surface sentence structures  . The extent to which we have been successful in allowing broad coverage of logically equivalent alternative statements of a query is difficult to quantify  , but we believe that we have done well relative to other efforts for two reasons :  ( I ) We have made an effort to cover as many underlying relations and their surface realizations as possible in treating a given application  , and ( 2 ) The transformational formalism we use is effective in providing the broa ~ coverage which reflects all the allowable interactions between the syntactic phenomena treated by a particular grammar  . 
MULTI-FILE QUERIES
This problem deals with multi-file databases and the questions of which files are relevant to a given query and how they should be joined  . This " problem " is one which is often raised , and which invariably reflects a quick-and-dirty approach to syntactic and semantic analysis  . Within a framework such as that provided by the transformational apparatus in TQA  , this problem simply doesn't arise . More accurately , it is a problem which doesn't arise if an adequate grammar is produced that assigns structure of the depth of the TQA System's query structures  . This , of course , is no easy task , but it is one which is central to the transformational grammar-based approach ~ and its successful treatment does provide a principled basis for eliminating a number of potential difficulties such as this multi-file query problem  . 
To see why this is so , let us consider how , for a given query , relations are identified and joined in TQA . As we have already indicated , TQA underlying structures and query structures consist of sentence nodes which dominate a verb followed by a sequence of noun phrases  . These simple structures are joined together to form a complete sentence structure through the use of additional phrase structure rules which indicate conjunction  , relative clause-main clause connection , etc . Query structure verbs correspond , for the most part , to database relations , and the noun phrase arguments of those verbs correspond to attributes of their a ~ sociated relations  . 
Furthermore , query structures contain logical variables which serve the function of establishing reference  , including identity of reference . Thus if the query structure assigned to a query identifies two  ( or more ) relations which have attributes whose values are the same logical variable  , we have an indication that it is those attributes over which the relations should be joined  . 
An example should make this clearer . Consider the query structure which TQA assigns to the sentence " What is the zone of the vacant parcels in subplan-ning area  410?" which is irrelevant to the subsequent discussion in the structure below  . )
INP-,
IDETIN~x4/:/\
THENOM/SIB-
SUBPLAN_AREA410 X8LUC 910 X8
This structure represents the set of elements X4 such that X4 is the zone of an element of the set of lots X8 such that the l and use code ( LUC ) of X8 is 910 and the subplanning area ( SUBPLAN_AREA ) of X8 is 410 . The structure is mapped in straightforward fashion by a Knuth attribute grammar translation procedure into the set domain relational calculus expression :  ( set x ' X4' ( set x ' X8' ( and ( RELATION ' ZONEF' ( ZONEJ ACCN )  ' ( X4 XS )  ' ( = = )   )   ( RELATION ' GEOBASE *' ( SUBPLAJ ACCN )  ' ( '410 XS )  ' ( == )   )   ( RELATION ' LUCF' ( LUCJ ACCN )  ' ( '910 X8 )  ' ( = = ) ) ) ) ) ) Each deep ( query structure ) verb such as ZONE has associated with it ( by means of a translation table entry ) a relation , which is usually the projection of an existing database relation  . Thus instead of translating a portion of the above tree to  ( ZONEX4 X8 )  , an expression which is true if X4 is the zone of the parcel whose account number is XS  , the translation table is used to produce ( RELATION ' ZONEF' ( ZONEJ ACCN )  ' ( x4 xs )  ' ( = = )   ) which is true if the projection of the ZONEF relation over attributes ZONE and JACCN  ( account number ) contains a tuple ( X4 XS )  . 
The conjunction of three relations with a common JACCN attribute value of  X8 indicates that the three relations are to be joined over the attribute JACC ~' There is  , however , one complication in translating the relatiorul calculus expression above into a formal query language such as SQL  . The relations ZONEF and LUCF are existing database relations  , but there is no relation GEOBASE * in the database  , giving the subplanning area of specific parcels . 
Instead , the PARCEL relation gives the split block ( SBL OCK ) of a given parcel ( JACCN ) and the GEOBASE relation gives the subplanning area  ( SUBPLA ) of all the parcels within a given split block ( SBL OCK )  . 
There are at least three solutions to the problem of bridging the gap between relational calculus expressions such as this and appropriate formal query language expressions  . These are: ( i ) Write a precyclic database-specific split block insertion transformation which assigns query structure corresponding to the query  , "What are the zones of the vacant parcels which are located in split-blocks in subplanning area  410?"   ( 2 ) S to reinformation that permits replacing expressions involving virtual relations such as  ( RELATION ' GEOBASE *' ( SUBPLAJ ACCN )  ' ( '0410 XS )  ' ( == )   ) by existentially quantified expressions involving only real database relations such as:  ( set x ' X III ( and ( RELATION ' PARCFL' ( SBL OCK JAC CN )  '  ( X 1 1 1 X S )   ,   ( = = )   )   ( RELATION ' GEOBASE' ( SUBPLAS BLOCK )  ' ( '410 Xl II )  ' ( == )   )   )   ( 3 ) Make the database administrator ( DBA ) responsible for providing a formal query language definition of the virtual relations produced  . In this case that would take the form of defining GEOBASE * as the appropriate join of projections over GEOBASE and PARCFL  . 
All three solutions have been implemented in the TQA System and used in specific cases as seems appropriate  . For a database system with the definitional facilities available in SQL  , solution ( 3 ) is particularly attractive because it is the type of activity with which database administrators are familiar  . Solutions ( I ) and ( 2 ) were also implemented at various times for examples such as the one in question  , leading to the following SQL query :
SELECTUNIQUEA.ZONE , A . JACCN
FROM ZONE FA , GEOBASEB , PARCFLC , LUCFD
WHEREA . JAC CN=C . JAC CN
AND C . JAC CN=D . JAC CN
ANDB.SBLOCK = C.SBLOCK
AND D.LUC='0910'
ANDB . SUBPLA = '4100' ;   ( We note for the careful reader that '0910' and '4100' are not misprints , but the discussion of how such normalization can be automatically achieved from DBA declarations is outside the scope of the present paper  . ) EXPRESSIONS TO FORMAL QUERY LANGUAGE EQUIVALENTS In this section we consider a problem of our own choosing  . In most of the existing relational calculus formalisms  , use is made of logical variables and some type of universal and existential quantifiers  . 
Early versions of TQA were typical in this respect . 
The version of TQA which was tested in the White Plains experiment  , for example , made use of quanti-fiefs FORATLEAST and FORALL whose nature is best explained by an example  . The lozical form assigned to the previously considered sentence was  , at one time : ( set x ' X4' ( for at least i ' XII2 ( set x ' X8' ( and ( RELATION ' GEOBASE *' ( SUBPLAJ ACCN )  ' ( '410 XS )  ' ( == )   )   ( RELATION ' LUCF' ( LUCJ ACCN )  ' ( '910 X8 )  ' ( = = )   )   )   )   ( RELATION ' ZONEF' ( ZONEJ ACCN )  '  ( X4X 112 )  '  ( == ) )  )   ) This logical form denotes ( roughly ) the set of zones X4 such that for at least one element XII2 of the set of parcels X8 which are in subplanning area 410 and have al and use code of 910  , parcel XII2 is in zone X4 . In simple examples such as this , where only existential quantification of logical forms is involved  , there is no problem in translating to a formal query language such as SQL  . However , when various combinations of existential and universal quantification are involved in a logical form  , the corresponding quantification-indicating constructs to be used in the formal query language translation of that logical form is not at all obvious  . An examination of the literature indicates that the arguments used in establishing the completeness of query languages offer little or no guidance as to the construction of a practical translator from relational calculus to a formal query language such as SQL  . Hence , the approach used in translating TQA logical forms to corresponding SQL expressions will be discussed  , in the expectation of eliciting explanations of how the translation of quantification is handled in other systems  . 
We begin by observing that a logical form ( for at least 1X l ( set xX2 ( fX2 ) )  ( gEl ) )  ( which denotes the proposition that for at least one Xl which belongs to the set of elements  X2 such that f ( X2 ) is true , g ( Xl ) is true ) is equivalent to the requirement of the non -emptiness of the set  ( I )   ( set x ' Xl ' ( @ nd ( fXl )   ( gXI ) ) ) 
Similarly ,   ( for all X1 ( a et x X 2 ( fX2 ) )  ( gXl ) )  ( which denotes the proposition that for all X1 in the set of elements X2 such that f ( X2 ) is true , g(Xl ) is true ) , is equivalent to a requirement of the emp-tiness of the set  ( 2 )   ( set x ' XI' ( and ( fXl )   ( not ( gXl ) ) ) ) Conversion of expressions with universal and existential quantifiers is then possible to expressions involving only set notation and a predicate involving the emptiness of a set  . The latter type of expressions are called set domain relational calculus expressions  . 
Fortunately , SQL provides operators EXISTS and NOTEXISTS which take as their argument an SQL SELECT expression  , the type of expression into which logical forms of the type  ( set x ' XI . . . ) are translated . A recursive call to the basic logical form-to-SQL translation facility then suffices to supply the SQL argument of EXISTS or NOTEXISTS  . 
It is worth noting that , under certain circumstances which we will not explore here  , the " ( set xX2"portion of an embedded expression ( set x ' X2 ( fX2 ) ) can be pulled forward , creating a prefix-normal-form-like expression of the type  ( set x ' Xl ( set x ' X2 . . .  )) , and the logical variables that can be pulled all the way forward correspond to information implicitly requested in English queries  . 
The values which satisfy these variables should also be printed to satisfy users ' implicit requests for information  . For example , in our previously considered query " What are the zones of the vacant parcels in sub-planning area  410?" one probably wants the parcels identified in addition to their zones  . Translation to the form of set domain relational calculus used in TQA then provides a basis for either taking the initiative in automatically printing these implicitly requested values or for engaging in a dialog with the user to determine whether they should be printed  . 
As a final example of this method of translating quantified logical forms  , consider the sentence " What gas stations are in award in which there is no drug store ? " The logical form initially assigned by TQA to this sentence is '  ( and ( RELATION ' LUCF' ( LUCJ ACCN )  '  ( '0553 X2 )  ' ( == )   )   ( for at least I ' X 81 ( set x ' X7 ( for all ' XS0 ( set x ' X13 ( RELATION ' LUCF' ( LUCJ ACCN )  ' ( '0591 XI3 )  ' ( = = )   )   )   ( RELATION ' PARCFL' ( WARDJACCN )  '  ( X 7 X S 0 )  ' ( -== )   )   )   )   ( RELATION ' PARCFL' ( WARDJACCN )  '  ( XS lX2 )  '  ( == ) )  )   )   ) which is translated to the set domain logical form :  ( set x ' X2' ( set x ' X 7' ( and ( RELATION ' PARCFL' ( WARDJACCN )  '  ( x7 x z )  ' ( == )   )   ( not ( set x ' X13' ( and ( RELATION ' PARCFL' ( WARDJACCN )  '  ( X7 El3 )  ' ( == )   )   ( RELATION ' LUCF' ( LUCJ ACCN )  '  ( '0591 XI3 )  '  ( == ) )  )   )   )   ( RELATION ' LUCF' ( LUCJ ACCN )  ' ( '0553 X2 )  '  ( = = )   )   )   )   ) 
The latter form translates easily expression :
SELECTUNIQUEA . JACCN , A . WARD
FROM PARCFLA , LUCFB
WHEREA . JACCN=B . JACCN-ANDB . LUC='0553'
ANDNOTEXISTS(SELECTUNIQUEC . JACCN
FROM PARCFLC , LUCFD
WHEREC . WARD = A . WARD
AND C.JACCN = DoJACCN
AND D.LUC='0591'); into the SQL

Astrahan , M . M . ; Blasgen , M . W . ; Chamberlin , D . Do ; Eswaran , K . P . ; Gray , J . N . ; Griffiths , P . P . ; King , W . F . ; Lories , R . A . ; McJones , J . ; Mehl , J . W . ; Put-zolu , G . R . ; Traiger , I ; L . ; Wade , B . W . ; and Watson , V . , " System R : Relational Approach to Database Management  , " ACM Transactions on Database Systems ~ Vol . i , No . 21, June , 1976, pp . 

Damerau ~ F . J . , " Advantages of a Transformational Grammar for Question Answering  , " Proc . 5th IJCAI ~
Vol . i , 1977, p ? 192.
Damerau , F . J . , " Operating Statistics for The Trans-formational Question Answering System  , " American Journal of Computational Linguistics ~ Vol  . 7, No . 
it January-March 1981, pp . 30-42.
Petrick , S . R . , " Semantic Interpretation in the Request System , " in Computational and Mathematical Linguistics , Proceedings of the International Conference on Computational Linguistics  , 
Pisa , 27/VIII-I/IX 1973, pp . 585-610.
Petrick , S.R.,

Development ~314-325.
" On Natural Language Based Computer
IBM Journal of Research and
Vol . 20, No . 4, July 1976, pp.
Petrick , S . R . " Field Testing the Transformational Question Answering  ( TQA ) System , " Proc . 19th Ann . 
Mtg . of the ACL~June 1981, pp . 3536.
Plath , W . J . , " REQUEST : A Natural Language Question -Answering System  , "IBM Journal of Research and Development ~ Vol . 20, No . 4, July 1976, pp .  326-335 . 

