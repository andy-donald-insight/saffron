Towards Abstract Categorial Grammars
Philippe de Groote
LORIAUMR no 7503 ? INRIA
Campus Scientifique , B . P .   239   54506 V and ? uvrele`s Nancy Cedex ? France de groote @loria  . fr

We introduce a new categorial formalism based on intuitionistic linear logic  . 
This formalism , which derives from current type-logical grammars , is abstract in the sense that both syntax and semantics are handled by the same set of primitives  . As a consequence , the formalism is reversible and provides different computational paradigms that may be freely composed together  . 
1 Introduction
Type-logical grammars offer a clearcut between syntax and semantics  . On the one hand , lexical items are assigned syntactic categories that combine via a categorial logicak into the Lambek calculus  ( Lambek ,  1958) . On the other hand , we have so called semantic recipes , which are expressed as typed ?- terms . The syntax-semantics interface takes advantage of the Curry-Howard correspondence  , which allows semantic readings to be extracted from categorial deductions  ( van Benthem ,  1986) . These readings rely upon a homomorphism between the syntactic categories and the semantic types  . 
The distinction between syntax and semantics is of course relevant from a linguistic point of view  . This does not mean , however , that it must be wired into the computational model  . On the contrary , a computational model based on a small set of primitives that combine via simple composition rules will be more flexible in practice and easier to implement  . 
In the type-logical approach , the syntactic contents of a lexical entry is outlined by the following patern : < atom > : < syntactic category > On the other hand  , the semantic content so beys the following scheme : <?- term >: < semantic type > 
This asymmetry may be broken by : 1 . allowing ?- terms on the syntactic side ( atomic expressions being , after all , particular cases of ?- terms ) ,  2 . using the same type theory for expressing both the syntactic categories and the semantic types  . 
The first point is a powerfull generalization of the usual scheme  . It allows ?- terms to be used at a syntactic level  , which is an approach that has been advocated by ( Oehrle ,  1994) . The second point may be satisfied by dropping the non-commutative  ( and non-associative ) aspects of categorial logics . This implies that , contrarily to the usual categorial approaches , word order constraints cannot be expressed at the logical level  . 
As we will see this apparent loss in expressive power is compensated by the first point  . 
2 Definition of a multiplicative kernel
In this section , we define an elementary grammatical formalism based on the ideas presented in the introduction  . This elementary formalism is founded on the multiplicative fragment of linear logic  ( Girard ,  1987) . For this reason , we call it a multiplicative kernel . Possible extensions based on other fragments of linear logic are discussed in 
Section 5.
2.1 Types , signature , and ?- terms
We first introduce the mathematical apparatus that is needed in order to define our notion of an abstract categorial grammar  . 
Let A be a set of atomic types . The set T ( A ) of linear implicative types built upon A is inductively defined as follows:  1  . if a ? A , then a ? T ( A ); 2 . if ?, ? ? T ( A ), then (????) ? T(A) . 
We now introduce the notion of a higher-order linear signature  . It consists of a triple ? = ? A , C , ??, where : 1 . A is a finite set of atomic types ; 2 . C is a finite set of constants ; 3 . ? : C ? T ( A ) is a function that assigns to each constant in C a linear implicative type in T  ( A )  . 
Let X be a in finite countable set of ?- variables.
The set ? ( ? ) of linear ?- terms built upon a higher-order linear signature ? = ? A  , C , ? ? is inductively defined as follows : 1 . if c ? C , then c ? ?(?); 2 . if x ? X , then x ? ?(?); 3 . if x ? X , t ??(?) , and x occurs free intexactly once , then (? x . t ) ? ?(?); 4 . if t , u ??(?) , and the sets of free variables of t and u are disjoint  , then ( tu ) ??(?) . 
? ( ? ) is provided with the usual notion of capture avoiding substitution  , ?- conversion , and ?- reduction ( Barendregt ,  1984) . 
Given a higher-order linear signature ? = ? A , C ,  ?? , each linear ?- term in ? ( ? ) may be assigned a linear implicative type in T ( A )  . This type assignment obeys an inference system whose judgements are sequents of the following form : ? ? ? t : ? where:  1  . ? is a finite set of ?- variable typing declarations of the form ? x : ??  ( with x ? X and ? ? T ( A ) ) , such that any ?- variable is declared at most once  ;  2 . t ??(?); 3 . ? ? T ( A ) . 
The axioms and inference rules are the following : ? ? c : ?  ( c )   ( cons ) x : ? ? ? x : ? ( var )  ? , x : ? ? ? t : ?( abs ) ? ? ?( ? x . t )  :  ( ??? ? ) ??? t : ( ??? ? ) ??? u : ? ( app )  ? , ??? ( tu ) : ?2 . 2 Vocabulary , lexicon , grammar , and language We now introduce the abstract notions of a vocabulary and a lexicon  , on which the central notion of an abstract categorial grammar is based  . 
A vocabulary is simply defined to be a higher -order linear signature  . 
Given two vocabularies ?1 = ? A1 , C1 , ?1? and ?2 = ? A2 , C2 ,  ?2? , a lexicon L from ?1 to ?2 ( innotation , L : ?1? ?2) is defined to be a pair L = ? F , G ? such that : 1 . F : A1 ? T ( A2 ) is a function that interprets the atomic types of  ?1 as linear implicative types built upon A2  ;  2 . G : C1?? ( ?2 ) is a function that interprets the constants of ?1 as linear ?- terms built upon ?2  ;  3 . the interpretation functions are compatible with the typing relation  , i . e . , for any c ? C1 , the following typing judgement is derivable : ??2 G ( c ) : F ? ( ?1 ( c ) ) , where F ? is the unique homomorphic extension of F  . 
As stated in Clause 3 of the above definition , there exists a unique type homomorphism F?:T ( A 1 ) ? T ( A2 ) that extends F . Similarly , there exists a unique ?- term homomorphism G ?:  ?  ( ?1 )  ? ? ( ?2 ) that extends G . In these-quel , when ? L ? will denote a lexicon , it will also denote the homorphisms F ? and G ? induced by this lexicon  . In any case , the intended meaning will be clear from the context  . 
Condition 3 , in the above definition of a lexicon , is necessary and sufficient to ensure that the homomorphisms induced by a lexicon commute with the typing relations  . In other terms , for any lexicon L : ?1  ?  ?2 and any derivable judgement x0  :  ?0  ,   .   .   .   , xn : ? n ??1 t : ? the following judgement x0 : L ( ?0 )  ,   .   .   . , xn:L(?n ) ? ?2L(t):L (?) is derivable . This property , which is reminiscent of Montague?s homomorphism requirement  ( Montague , 1970b ) , may be seen as an abstract realization of the compositionality principle  . 
We are now in a position of giving the definition of an abstract categorial grammar  . 
An abstract categorial grammar ( ACG ) is a quadruple G = ??1 , ?2 , L , s ? where : 1 . ?1 = ? A1 , C1 , ?1? and ?2 = ? A2 , C2 , ?2? are two higher-order linear signatures ;   ?1 is called the abstract vovabulary and ?2 is called the object vovabulary ;  2 . L : ?1  ?  ?2 is a lexicon from the abstract vovabulary to the object vovabulary  ;  3 . s?T ( A1) is a type of the abstract vocabulary ; it is called the distinguished type of the grammar  . 
Any ACG generates two languages , an abstract language and an object language . The abstract language generated by G ( A ( G ) ) is defined as follows : A ( G ) = t ? ? ( ?1 ) ? ?1 t : s is derivable In words , the abstract language generated by G is the set of closed linear ?- terms  , built upon the abstract vocabulary ?1 , whose type is the distinguished types . On the other hand , the object language generated by G ( O ( G ) ) is defined to be the image of the abstract language by the term homomorphism induced by the lexicon L : O  ( G ) = t ? ? ( ?2 ) ? u?A ( G )  . t = L ( u ) It may be useful of thinking of the abstract language as a set of abstract grammatical structures  , and of the object language as the set of concrete forms generated from these abstract structures  . 
Section 4 provides examples of ACGs that illustrate this interpretation  . 
2.3 Example
In order to exemplify the concepts introduced so far  , we demonstrate how to accomodate the PTQ fragment of Montague  ( 1973 )  . We concentrate on
Montague?s famous sentence :
John seeks a unicor n (1)
For the purpose of the example , we make the two following assumptions : 1 . the formalism provides an atomic type ? string ? together with a binary associative operator ?+?  ( that we write as an infix operator for the sake of readability  )  ;  2 . we have the usual logical connectives and quantifiers at our disposal  . 
We will see in Section 4 and 5 that these two assumptions , in fact , are not needed . 
In order to handle the syntactic part of the example  , we define an ACG ( G12) . The first step consists in defining the two following vocabularies :  ?1 = ? n , np , s , J , Sre , Sdicto , A , U , J7 ? np , Sre7?(np??(np??s)) , 
Sdicto 7?( np ? ?( np ? ? s)),
A7? ( n ? ? np) , U7 ? n ? ?2 = ? string , John , seeks , a , unicorn , John 7? string , seeks 7? string , a 7? string , unicorn 7? string ? Then , we define a lexicon L12 from the abstract vocabulary ?1 to the object vocabulary ?2: 
L 12 = ? n 7? string , np 7? string , s 7? string , J7? John , 
Sre7??x.?y.x+seeks+y,
Sdicto7??x.?y.x+seeks+y,
A7? ? x.a+x ,
U7 ? unicorn ?
Finally we have G12 = ??1, ?2, L12, s?.
The semantic part of the example is handled by another ACG  ( G13 )  , which shares with G12 the same abstract language . The object language of this second ACG is defined as follows:  ?3 = ? e , t , JOHN , TRY-TO , FIND , UNICORN , JOHN 7? e , 
TRY-TO 7?( e ? ?(( e ? ? ? t )),
FIND 7 ?( e ? ?( e ? ? t )),
UNICORN 7? ( e??t ) ?
Then , a lexicon from ?1 to ?3 is defined : L13 = ? n 7?   ( e ? ? t )  , np7?(( e ? ? t ) ? ? t ) , s 7? t , J 7? ? P . PJOHN,
Sre 7? ? P . ? Q . Q(?x . P (? y . TRY-TO y(?z . FIND zx )),
Sdicto 7? ? P . ? Q . P (? x . TRY-TOx (? y . Q(?z . FIND yz ))),
A7? ? P . ? Q.?x.Px?Qx,
U7? ? x.UNICORN x ?
This allows the ACGG13 to be defined as ??1 , ?3 , L13 , s ? . 
The abstract language shared by G12 and G13 contains the two following terms :
SreJ(AU ) (2) SdictoJ(AU ) (3)
The syntactic lexiconL12 applied to each of these terms yields the same image  . It ?- reduces to the following object term :
John+seeks+a+unicorn
On the other hand , the semantic lexicon L13 yields the dere reading when applied to ( 2 ) : ? x . UNICORN x ? TRY-TOJOHN(?z . FIND zx ) and it yields the dedicto reading when applied to  ( 3 ) : TRY-TOJOHN ( ? y . ? x . UNICORN x?FIND yx ) Our handling of the two possible readings of ( 1 ) differs from the type-logical account of Morrill ( 1994 ) and Carpenter ( 1996 )  . The main difference is that our abstract vocabulary contains two constants corresponding to seek  . Consequently , we have two distinct entries in the semantic lexicon  , one for each possible reading . 
This is only a matter of choice . We could have adopt Morrill?s solution ( which is closer to Montague original analysis ) by having only one abstract constant S together with the following type assignment : 
S7?(np ? ?((( np??s ) ? ? s))
Then the types of J and A , and the two lexicons should be changed accordingly  . The semantic lexicon of this alternative solution would be simpler  . 
The syntactic lexicon , however , would be more involved , with entries such as:
S7? ? x.?y.x+seeks+y(?z.z)
A7? ? x . ? y . y ( a+x )   3 Three computational paradigms Compositional semantics associates meanings to utterances by assigning meanings to atomic items  , and by giving rules that allows to compute the meaning of a compound unit from the meanings of its parts  . In the type logical approach , following the Montagovian tradition , meanings are expressed as typed ?- terms and combine via functional application  . 
Dalrymple et al ( 1995 ) offer an alternative to this applicative paradigm  . They present a deductive approach in which linear logic is used as a glue language for assembling meanings  . Their approach is more in the tradition of logic programming  . 
The grammatical framework introduced in the previous section realizes the compositionality principle in a abstract way  . Indeed , it provides compositional means to associate the terms of a given language to the terms of some other language  . Both the applicative and deductive paradigms are available  . 
3.1 Applicative paradigm
In our framework , the applicative paradigm consists simply in computing  , according to the lexicon of a given grammar , the object image of an abstract term . From a computational point of view it amounts to performing substitution and ?- reduction  . 
3.2 Deductive paradigm
The deductive paradigm , in our setting , answers the following problem : does a given term  , built upon the object vocabulary of an ACG , belong to the object language of this ACG . It amounts to a kind of proof-search that has been described by Merenciano and Morrill  ( 1997 ) and by Pogodalla ( 2000 )  . This proof-search relies on linear higher-order matching  , which is a decidable problem ( de Groote ,  2000) . 
3.3 Transductive paradigm
The example developped in Section 2 . 3 suggests a third paradigm , which is obtained as the composition of the applicative paradigm with the deductive paradigm  . We call it the transductive paradigm because it is reminiscent of the mathematical notion of transduction  ( see Section 4 . 2) . 
This paradigm amounts to the transfer from one object language to another object language  , using a common abstract language as a pivot . 
4 Relating ACGs to other grammatical formalisms In this section  , we illustrate the expressive power of ACGs by showing how some other families of formal grammars may be subsumed  . It must be stressed that we are not only interested in a weak form of correspondence  , where only the generated languages are equivalent  , but in a strong form of correspondence , where the grammatical structures are preserved . 
First of all , we must explain how ACGs may manipulate strings of symbols  . In other words , we must show how to encode strings as linear ?- terms  . The solution is wellknown : it suffices to represent strings of symbols as compositions of functions  . Consider an arbitrary atomic type ? , and define the type ? string ? to be (????) . 
Then , a string such as ? abbac ? may be represented by the linear ?- term ? x  . a(b(b(a(cx ))) , where the atomic strings ? a ? , ? b ? , and ? c ? are declared to be constants of type ( ? ?? ? )  . In this setting , the empty word (  ) is represented by the identity function ( ? x . x ) and concatenation ( + ) is defined to be functional composition ( ? f . ? g . ? x . f(gx )) , which is indeed an associative operator that admits the identity function as a unit  . 
4.1 Context-free grammars
Let G = ? T , N , P , S ? be a contextfree grammar , where T is the set of terminal symbols , N is the set of nonterminal symbol , P is the set of rules , and S is the start symbol . We write L(G ) for the language generated by G . We show how to construct an ACGGG = ??1 , ?2 , L , S ? corresponding to G . 
The abstract vocabulary ?1 = ? A1 , C1 , ?1 ? is defined as follows : 1 . The set of atomic types A1 is defined to be the set of nonterminal symbols N  . 
2 . The set of constants C1 is a set of symbols in 1-1-correspondence with the set of rules P . 
3 . Let c ? C1 and let ? X ??? be the rule corresponding to c .   ?1 is defined to be the function that assigns the type [[?]] X to c  , where [[?]] X obeys the following inductive definition :  ( a ) [[ ]] X = X ; (b ) [[ Y ?]] X = ( Y ? ? [[?]] X) , for Y ? N ; ( c ) [[ a ?]] X = [[?]] X , for a ? T . 
The definition of the object vocabulary ?2 = ? A2 , C2 , ?2 ? is as follows : 1 . A2 is defined to be ? . 
2 . The set of constants C2 is defined to be the set of terminal symbols T . 
3 .   ?2 is defined to be the function that assigns the type ? string ? to each c ?  C2  . 
It remains to define the lexicon L = ? F,G?:1 . F is defined to be the function that interprets each atomic type a ?  A1 as the type ? string ? . 
2 . Let c ? C1 and let ? X ??? be the rule corresponding to c . G is defined to be the function that interprets c as ?  x1   .   .   .   . ? xn . ?, where x1 .   .   . xn is the sequence of ?- variables occurring in ? , and ? is inductively defined as follows : ( a )  = ? x . x ; ( b)Y ? = y + ? , for Y ? N , and where y is a fresh?-variable ; ( c ) a ? = a + ? , for a ? T . 
It is then easy to prove that GG is such that : 1 . the abstract language A ( GG ) is isomorphic to the set of parse-trees of G . 
2 . the language generated by G coincides with the object language of GG  , i . e . , O(GG ) =

For instance consider the CFG whose production rules are the following : 
S ? ,
S?aSb , which generates the language an bn . The corresponding ACG has the following abstract language  , object language , and lexicon : ?1 = ? S , A , B , A7 ? S , B7?((S ? ? S ) ? ?2 = ? ? , a , b , a 7? string , b 7? string ?
L = ? S 7? string , A 7? ? x . x,B7? ? x . a+x+b ? 4 . 2 Regular grammars and rational transducers Regular grammars being particular cases of contextfree grammars  , they may be handled by the same construction . The resulting ACGs ( which we will call ? regular ACGs ? for the purpose of the discussion  ) may be seen as finite state automata . The abstract language of a regular ACG correspond then to the set of accepting sequences of transitions of the corresponding automaton  , and its object language to the accepted language . 
More interestingly , rational transducers may also be accomodated . Indeed , two regular ACGs that shares the same abstract language correspond to a regular language homomorphism composed with a regular language inverse homomorphism  . 
Now , after Nivat?s theorem ( Nivat ,  1968) , any rational transducer may be represented as such a bimorphism  . 
4.3 Tree adjoining grammars
The construction that allows to handle the tree adjoining grammars of Joshi  ( Joshi and Schabes ,  1997 ) may be seen as a generalization of the construction that we have described for the contextfree grammars  . Nevertheless , it is a little bit more involved . For instance , it is necessary to triplicate the nonterminal symbols in order to distinguish the initial trees from the auxiliary trees  . 
We do not have enough room in this paper for giving the details of the construction  . We will rather give an example . Consider the TAG with the following initial tree and auxiliary tree: 
S 
SNA





CaS






BdbS ? NA c
It generates the noncontextfree language anbncndn  . This TAG may be represented by the
ACG , G = ??1 , ?2 , L , S ? , where : ?1 = ? S , S ? , S ? ? , A , B , C , A7?((S ? ??? S ?)? ? S) , 
B7?(S ? ???(( S ? ??? S ?)? ? S ?),
C7?(S ? ? ? ? S ?) ? ?2 = ? ? , a , b , c , d , a 7? string , b 7? string , c7? string , d 7? string ?
L = ? S 7? string , S ? 7? string,
S ? ? 7 ? string , A 7? ? f.f(?x.x),
B 7? ? x.?g . a + g(b+x+c ) + d,
C7? ? x.x ?
One of the keystones in the above translation is to represent an adjunction node A as a functional parameter of type A ? ?? ? A ?  . Abrusci et al ( 1999 ) use a similar idea in their translation of the TAGs into non-commutative linear logic  . 
5 Beyond the multiplicative fragment
The linear ?- calculus on which we have based our definition of an ACG may be seen as a rudimentary functional programming language  . The results in Section 4 indicate that , in theory , this rudimentary language is powerful enough . Nevertheless , in practice , it would be useful to increase the expressive power of the multiplicative kernel defined in Section  2 by providing features such as records , enumerated types , conditional expressions , etc . 
From a methodological point of view , there is a systematic way of considering such extensions  . 
It consists of enriching the type system of the formalism with new logical connectives  . Indeed , each new logical connective may be interpreted , through the Curry-Howardi somorphism , as a new type constructor . Nonetheless , the possible additional connectives must satisfy the following requirements :  1  . they must be provided with introduction and elimination rules that satisfy Prawitz?s inversion principle  ( Prawitz ,  1965 ) and the resulting system must be strongly normalizable  ;  2 . the resulting term language ( or at least an interesting fragment of it ) must have a decidable matching problem . 
The first requirement ensures that the new types come with appropriate data constructors and discriminators  , and that the associated evaluation rule terminates  . This is mandatory for the applicative paradigm of Section  3  . The second requirement ensures that the deductive paradigm  ( and consequently the transductive paradigm ) may be fully automated . 
The other connectives of linear logic are natural candidates for extending the formalism  . In particular , they all satisfy the first requirement . On the other hand , the satisfaction of the second requirement is , in most of the cases , an open problem . 
5.1 Additives
The additive connectives of linear logic ?&? and ? ? ? corresponds respectively to the cartesian product and the disjoint union  . The cartesian product allows records to be defined  . The disjoint union , together with the unit type ?1? , allows enumerated types and case analysis to be defined  . Consequently , the additive connectives offer a good theoretical ground to provide ACG with feature structures  . 
5.2 Exponentials
The exponentials of linear logic are modal operators that may be used to go beyond linearity  . In particular , the exponential ?!? allows the intuition-istic implication ??? to be defined  , which corresponds to the possibility of dealing with nonlinear ?- terms  . A need for such nonlinear ?- terms is already present in the example of Section  2  . 3 . Indeed , the way of getting rid of the second assumption we made at the beginning of section  2  . 3 is to decl are the logical symbols ( i . e . , the existential quantifier and the conjunction that occurs in the interpretation of A in Lexicon  L13  ) as constants of the object vocabulary ?3 . Then , the interpretation of A would be something like : ? P  . ? Q . EXISTS(?x . AND(Px ) ( Qx )) . 
Now , this expression must be typable , which is not possible in a purely linear framework  . Indeed , the ?- term to which EXISTS is applied is not linear  ( there are two occurrences of the bound variable x  )  . Consequently , EXISTS must be given (( e?t ) ? ? t ) as a type . 
5.3 Quantifiers
Quantifiers may also play apart . Uses of first-order quantification , in a type logical setting , are exemplified by Morrill (1994) , Moortgat (1997) , and Ranta (1994) . As for second-order quantification , it allows for polymorphism . 
6 Grammars as first-class citizen
The difference we make between an abstract vocabulary and an object vocabulary is purely conceptual  . In fact , it only makes sense relatively to a given lexicon  . Indeed , from a technical point of view , any vocabulary is simply a higher-order linear signature  . Consequently , one may think of a lexicon L12  :  ?1  ?  ?2 whose object language serves as abstract language of another lexicon  L23  :  ?2  ?  ?3  . This allows lexicons to be sequentially composed . Moreover , one may easily construct a third lexicon L13  :  ?1  ?  ?3 that corresponds to the sequential composition of  L23 with L12  . From a practical point of view , this means that the sequential composition of two lexicons may be compiled  . From a theoretical point of view , it means that the ACGs form a category whose objects are vocabularies and whose arrows are lexicons  . This opens the door to a theory where operations for constructing new grammars from other grammars could be defined  . 
7 Conclusion
This paper presents the first steps towards the design of a powerful grammatical framework based on a small set of computational primitives  . The fact that these primitives are wellknown from programming theory renders the framework suitable for an implementation  . A first prototype is currently under development . 

M . Abrusci , C . Fou quere ?, and J . Vauzeilles .  1999 . 
Tree-adjoining grammars in a fragment of the Lambek calculus  . Computational Linguistics , 25(2):209?236 . 
H . P . Barendregt .  1984 . The lambda calculus , its syntax and semantics . North-Holland , revised edition . 
J . van Benthem .  1986 . Essays in Logical Semantics . 
Reidel , Dordrecht.
B . Carpenter .  1996 . Type-Logical Semantics . MIT Press , Cambridge , Massachussetts and London

M . Dalrymple , M . Lamping , F . Pereira , and V . Saraswat .  1995 . Linear logic for meaning assembly . In G . Morrill and D . Oehrle , editors , Formal Grammar , pages 75?93 . Fo LLI . 
J . -Y . Girard .  1987 . Linear logic . Theoretical Computer Science , 50:1?102 . 
Ph . de Groote .  2000 . Linear higher-order matching is NP-complete . In L . Bachmair , editor , Rewriting Techniques and Applications , RTA?00 , volume 1833 of Lecture Notes in Computer Science , pages 127?140 . Springer . 
A . K . Joshi and Y . Schabes .  1997 . Tree-adjoining grammars . In G . Rozenbergan A . Salomaa , editor , Handbook of formal languages , volume 3 , chapter 2 . Springer . 
J . Lambek .  1958 . The mathematics of sentence structure . Amer . Math . Monthly , 65:154?170 . 
J . M . Merenciano and G . Morrill .  1997 . Generation as deduction on labelled proofnets . In C . Retore ? , editor , Logical Aspects of Computational Linguistics , LACL ?96 , volume 1328 of Lecture Notes in Artificial Intelligence , pages 310?328 . Springer Verlag . 
R . Montague . 1970a . English as a formal language . 
In B . Visentini et al , editor , Linguagginella So-cieta ` enella Tecnica , Milan . Edizioni di Commu-nita ` . Reprinted : ( Montague , 1974, pages 188?221) . 
R . Montague . 1970b . Universal grammar . Theoria , 36:373?398 . Reprinted : ( Montague , 1974, pages 222?246) . 
R . Montague .  1973 . The proper treatment of quantification in ordinary english  . In J . Hintikka , J . Moravcsik , and P . Suppes , editors , Approaches to natural language : proceedings of the  1970 Stanford workshop on Grammar and Semantics , Dordrecht . 
Reidel . Reprinted : ( Montague , 1974, pages 247?270) . 
R . Montague .  1974 . Formal Philosophy : selected papers of Richard Montague  , edited and with an introduction by Richmond Thomason  . Yale University

M . Moortgat .  1997 . Categorial type logic . In J . van Benthem and A . ter Meulen , editors , Handbook of Logic and Language , chapter 2 . Elsevier . 
G . Morrill .  1994 . Type Logical Grammar : Categorial Logic of Signs . Kluwer Academic Publishers,

M . Nivat .  1968 . Transduction des langages de Chomsky . Annales del ? Institut Fourier , 18:339?455 . 
R . T . Oehrle .  1994 . Term-labeled categorial type systems . Linguistic & Philosophy , 17:633?678 . 
S . Pogodalla .  2000 . Generation , Lambek Calculus , Montague?s Semantics and Semantic ProofNets . In Proceedings of the 18th International Conference on Computational Linguistics  , volume 2 , pages 628?634 . 
D . Prawitz .  1965 . Natural Deduction , A Proof-Theoretical Study . Almqvist & Wiksell , Stockholm . 
A . Ranta .  1994 . Type theoretical grammar . Oxford
University Press.
