Multiple Default Inheritance in a Unifica tion-Based 
Graham Russell
John Carroll *
Susan Warwick-Armstrong
ISSCO , 54 route desAcacias,
1227 Geneva , Switzerland

Lexicon

A formalism is presented for lexical specification in unification-based grammars which exploits defeasible multiple inheritance to express regularity  , sub-regularity , and exceptions in classifying the properties of words  . Such systems are in the general case intractable ; the present proposal represents an attempt to reduce complexity while retaining sufficient expressive power for the task at hand  . Illus-trative examples are given of morphological analyses from English and German  . 
1 Introduction
The primary task of a computational lexicon is to associate character strings representing word forms with information able to constrain the distribution of those wordforms within a sentence  .   1 The organization of a lexicon requires the ability  , on the one hand , to make general statements about classes of words  , and , on the other , to express exceptions to such statements affecting individual words and subclasses of words  . These considerations have provoked interest in applying to the lexicon AI knowledge representation techniques involving the notions of inheritance and default  .   2 The sys-*current address : Cambridge University Computer Laboratory  , New Museums Site , Pembroke Street , Cambridge
CB23 QG , UK.
OWe are indebted to Af- . al Ballim , Mark Johnson , and anonymous referees for valuable comments on this paper  . 
t in the general case , the relation between forms and information is many-to-many  ( rather than one-to-many as often assumed ) and this observation has influenced the choice of facilities incorporated within the system  . See 3 . 2 below for an example of how distinct forms share identical morphosyntactic specifications  . 
2See e . g . Daelemaus and Gazdareds . (1990), and the references in Gazdar (1990) . The work of Hudson ( 1984 ) extends this general approach to sentence syntax . 
tem described here is part of the ELUs unification grammar development environment intended for research in machine translation  , comprising parser , generator , transfer mechanism and lexical components . The user language resembles that of PATR-II ( Shieber ,  1986) , but provides a larger range of data types and more powerful means of stating relations between them  . Among the requirements imposed by the context within which this system is used are  ( i ) the ability to both analyse and generate complex wordforms  ,   ( ii ) full integration with existing parts of the ELU environment  , and ( iii ) the ability to accommodate a relatively large number of words  . 
2 Classes and Inheritance
An ELU lexicon consists of a number of ' classes ' , each of which is a structured collection of constraint equations and macro calls encoding information common to a set of words  , together with links to other more general ' superc\]asses '  . For example , if an ' intransitive ' class is used to express the common syntactic properties hared by all intransitive verbs  , then particular instances of intransitive verbs can be made to inherit this information by specifying the ' intransitive ' class as one of their superclasses-it then becomes unneces-saw to specify the relevant properties individually for each such verb  . The lexicon may be thought of as a tangled hierarchy of classes linked by inheritance paths  , with , at the most specific level , lexicai classes and , at the most general , classes for which no super classes have been defined  , and which therefore inherit no information from elsewhere  . 
S " Environnement Linguistiqued ' Unlfication " - see Estival  ( 1990 )  , and , for a description of the earlier UD system on which E~u is based  , Johnson and Rosner (1989) . 

Lexical entries are themselves classes ,   4 and any information they contain is standardly specific to an individual word  ; lexical and nonlexical classes differ in that analysis and generation take only the former as entry points to the lexicon  . 
Inheritance of a feature value from a superclass may be overridden by a conflicting value for that feature in a more specific lass  . This means , for example , that it is possible to place in the class which expresses general properties of verbs an equation such as '<* aux >= no '  ( i . e . " typical verbs are not auxiliaries ") , while placing the contradictory specification '<* aux >= yes ' ins subclass from which only an Tiliaries inherit  . The ability to encode exceptional properties of lexical items is extremely attractive from the linguistic point of view  ; the lower the position in the hierarchy at which the property appears  , the more exceptional it may be considered . 
A class definition consists of the compiler directive '  #Class '  ( for a non-lexicai class ) or '  #Word ' ( for a lexical class )  , followed by the name of that class , a possibly empty list of direct superclasses , a possible empty ' main ' or default equation set  , and sereor more ' variant'equation sets . The superclass declaration states from which classes the current class inherits  ; if more than one such superclass is specified , their order is significant , more specific classes appearing to the left of more general ones  . If the current class is one of the most general in the lexicon  , it inherits no information , and its superclass list is empty . 
Following the superclass declaration are sere or more equations representing default information  , which we refer to as the ' main'equation set . These may be overridden by e on tlleting information in a more specific class  . Each equation in a main set functions as an independent constraint  , in ams nner which will be clarified below . 
Variant equation sets , loosely speaking , corre-spend to alternatives at the same conceptual level in the hiersrchy  , and in msny cases reflect the traditionalides of ' paradigm '  . Equations within a variant set are absolute constraints  , in contras to those in the main set ; if they conflict with informs-tion in a more specific class  , failure of unification occurs in the normal way . Also , unlike the main set , each variant set functions as a single , possibly complex , constraint ( see section 2 . 2) . A feature 4Thus no distinction is made between classes and ' instances '  , as in e . g . KL-ONE ( Schmolse and Lipkis ,  1983 ) structure is created for each variant set that successfully unifies with the single structure arising from the main set  . Each variant set is preceded by the vertical bar ' \['  . The order of variant sets within a class is not significant  , although , if a main set is employed , it must precede any variant sets . 
The following simplified example illustrates the form and interaction of class definitions  . In equs . 
tions , unification variables have initial capitals , and negation of constants is indicated by '' . ' kk ' is the string concatenation operator-an equation of the form X = Ykk Z unifies X nondeterministi-cally with the result of concatenating ? and Z  . 
 #Word walk ( Intransitive Verb ) < stem >= walk#Class Intransitive ( ) < sub?at > = \ [ Sub J \ ] <$ nbJ ca t > = np # Class Verb  ( ) < aOX > m no < cat > m V
I < tense >= past < ~ on O = < stem > kked
I=presont < form >= < steu Okksi<aSr >=" s83 < tense>-present < form >= < stem > The lexies l class walk is declared as having two direct superclasses  , Intransitive and Verb ; its main set contains just one equation , which sets the value of the feature stem to be walk  . 
Intransitive has no direct super classes , and its main equation set assigns to the value of subcatalist with one element  , a feature structure in which the value of cat is rip  . Neither walk nor Intransitive hassny variant equation sets  . 
Verb , by contrast , has three , in addition to two main set equations . The latter assign , by default , the values of cat and aux . The three variants accounted for by this example are the past tense verb  , in which the value of form unifies with the result of concaten at in  8 the value of stem with the string'ed' , the third person singular form , in which the suffix string is ' s ' , and the form representing other combinations of person and number in the present tense  ; in the last case , the form value is simply identical to the stem value  .   5   5We ignore for the moment the question of mor -phogrs phemic effects in sufllx stion-seesect ion  3  . 3 below . 
216 2.1 Class Precedence
In an ELU lexicon , a class may inherit directly from more than one superclass  , thus permitting ' multiple inheritance ' ( Touretsky , 1986:7 ft . ) , in contrast to ' simple inheritance ' in which direct inheritance is allowed from only one superclass at a time  . The main advantage that multiple inheritance offers over simple inheritance is the ability to inherit several  ( orthogonal or complementary ) sets of properties from classes in more than one path through the hierarchy  . In the lexical context , it has often been observed that morphological nd syntactic properties are essentially disjoint  ; the subeategorisation class of a verb is not predictable from its conjugation class  , and vice versa , for example . Multiple inheritance permits the two types of information to be separated by isolating them in distinct subhierarchies  . 
The question to be resolved in systems employing multiple inheritance is that of precedence : which of several superclasses with conflicting properties is to be inherited from ? ELU employs the class precedence algorithm of the Common Lisp Object System  ( CLOS ) to compute a total ordering on the superclasses of a lexics l class  , s The resulting ' class precedence list ' ( CPL ) contains the class itself and all of its superclasses  , from most specific to most general , and forms the basis for the defaulting behaviour of the lexicon  . As an example , consider the following lexicon :  #Word It ( B D )  #Class B ( C ) 
ZClass C ( Y )  #Class D ( E )  #Class E ( P )  #Class F ( ) Here , the superclass declarations embody the or-der in 8 constraints A < B , A < D , B < D , B < C , C < F , D < E , and E < F ; from these are derived a total order assigning to the lexical class A the CPL  ( A , B , C , D , E , F ) . 
2.2 Inheritance of Properties
A lexical class such as walk in the example above corresponds to a family of feature structures  . Here , as in most analyses , members of this family represent morphosyntactically distinct realizations of a single basic lexeme  . Consulting the lexicon involves determining membership of the set of feature structures associated with a given lexical class  ; sSeeSteele (1990:782 ff . ) for details of the aIgorithm , and Keene (1989:118 ff . ) for discussion . In circumstances where no such total ordering is possible  , the system reports an error . 
the precedence relation encoded in the CPL controls the order in which defeasible information is considered  , each class in the CPL adding first default and then nondefault information to each FS produced by the previous class  . 
More formally , we define defaultez tension , superclassez tension , and globale z~e~sion as follows : 7 ( 1 ) The defaultez tension of a FS~with respect to a set of FSs ? is if U  ( ~ bU  ~ ) : f :_1_ , and . 1_otherwise . 
(2 ) The superclassez ~ ension of a FS~b with respect to a class chaving a main equation set M and variant sets Vl  ,   .   .   . v , is the set
I~beJ . , where M s is the smallest set of FSs such that each mEM describe some m ~ EMs  , ? ~ s is the default extension of ~ b with respect o Me  , and v ~ is the feature structure described by vl . We refer to this set as E(~b , c) . 
(3) The globalez tensio ~ , of a lexlcvd class having the CPL(cl ,   .   .   . c , ) is F ~ , where Fo = T , and r , > 0 = U~IVY , ~ r , _l , ? = E(~ , c , ) . 
With regard to ( I ) , each of the FSs in W that can unify with ~ b does so-those that cannot  , because they conflict with information already present  , are ignored . The condition requiring ~ to be unifiable with the result of unifying the elements of ? takes account of the potential order-sensitivity of the de-faulting operation-only those main sets having this property can be applied without regard to or-def  . If this condition is met then the application of defaults always succeeds  , producing a feature structure which , if no member of the default set is applicable , is identical to ~ b . This interpretation of default unification is essentially that of Bouma  ( 1990 )  . 
The superclass extension E ( ~ , c ) is formed by applying to ~ any default equations in the main set of c  , and then applying to the result each variant set inc  ; for variant sets Vl ,  . .  . v , , , the result of this 7'A UB ' here denotes the unification of A and B , ' T ' denotes the most general , ' empty'FS , which unifies with all others , and '_L' denotes the inconsistent FS , equated with failure of unification . 
217 second stage is the set of FSs@1, . . . @~ , where each ~ is the result of successfully unifying ~ b with some different vj  . 
To speak in procedural terms , the global extension of a lexicai class L with the CPLC is computed as follows : T is the empty FS which is input to C  ; each c ~ in C yields as its superelass extension a set of FSs  , each member of which is input to the remainder of C  , ( c ~+ l ,   .   .   . c , ) . The global extension of L is then the yield of the most general class in its CPL-expressed in a slightly different way  , the global extension of L is the result of applying to T the CPL of L  . 
It is possible to exert quite fine control over inheritance  ; one property may override another when assigned in a main equation set  , but cause failure when assigned in a variant set . Normally , variant sets are defined so as to be mutually exclusive  ; a FS that unifies with more than one of the variant sets is in effect multiplied  , s The inheritance systems of Calder ( 1989 ) and Flickinger ( 1987 ) make use of lexical rules - the ELU lexicon does not provide such devices  , although some of their functionality may be reproduced by the variant set mechanism  . 
The approach described here differs from some previous proposals for default inheritance in unification-based lexicons in that the process of building FSs is monotonic-classes may add information to a FS  , but are unable to remove or alter it . Thus , given a CPL(ci , .   .   . c .  )  , any FSF admitted by a class c~subsumes every FS that can be created by applying to F the classes  ( c ~+ I ,   .   .   . c , ~), mn . Karttunen ( 1986 ) and Shieber ( 1986 ) describe systems in which FSs may be modified by default statements in such a way that this property does not automatically hold  . These schemes permit default statements to override the effect of earlier statements  , whereas default information in the
ELU lexicon may itself be overridden.
We now turn to some examples illustrating the r61e of defeasible inheritance in the lexicon . 
3 Example Analyses 3 . 1 German Separab le Verbs Two large classes of German verbs are these parable and inseparable prefixed compound verbs  . 
The former are of interest syntactically because , as their name suggests , the prefix is a bound SSee3 . 2 below for a case where such multiple matches are desirable  . 
morpheme only in certain syntactic environments , namely when the verb is untensed or head of a verb-final clause  . 9 Members of both classes share morphological , but not necessarily syntactic , properties of the verb which corresponds in form to their stem  . These parable-prefix verb weglau/en ( ' runaway ' ) and inseparable verlau/en ( ' elapse ' ) are two such verbs , which the lexicon should be able to relate to their apparent stem lau/en  ( ' run ' )  . 
Since word definitions are classes , they can be inherited from like any nonlexical class  . Thus the lexical classes verl aufen and we glaufen may inherit from lanfen  , itself a lexical class : x ? #Wordwoglau ~ on ( we slau ~ on ) < s ~= we glaufen  #Word vorl aufs n ( vetlaufs n ) < S ~ ivorla ~ en  #Class wes ( separable ) < morph prolix >= wog#Class vet ( non_sopLTabls ) < morph prefix >= vet  #Word lau ~ en ( verb ) 
Base_stun=lauf<s mu >= lauf on  #Class non_separable  ( )
Proflx = < morph prefix >  #Classs spazablo Ol
Prefix = < morph prsfix > < lyn 4~v > = no < syain , l >= " tn , f

Proflx = '' < synInv >= yos . < synia ~ l >= " la . f
I  #Class
Prefix = < moxph profix > < syn in ~ l >= ~ verbO < cat > mv 
Prefix = '' < morph pref ~ x >=
Prefix && < syn4.e1>=inf<form >= P_be && on
I < form >= P_bsk&?<syninfl >= prss_Indic_s8_l   9Within the syntactic analysis assumed here , the distri-bution of verbs is controlled by a binary feature in v  , whose value in these contexts is no . 
leanumber of simplifications have been made here ; \] aufen is in reality a member of a subclass of the strong verbs  , and the verb class itself has been truncated , so that it accounts for only bare infinitive and first person singular present tense indicative forms  . Past participle formation also interacts with the presence of separable and inseparable prefixes  . 

The lexical classes we glaufen and verl auf en each have two immediate superclasses  , containing information connected with the prefix and stem  . 
The classes weg and vet set the value of the morph : prefix path of the verb  ( overriding the value given in the main set of verb  )  , and specify inheritance from these parable and non  . separable classes respectively . The former of these unifies the variable Pref ix with either the empty string  ( in the case of tensed ' inverted ' verbs ) or the value of morph : prefix ( for other variants )  , while the latter sets the value uniquely for all forms of the verb in question  . As the value of sere is fixed in the main equation set of wegl aufen and verl aufen  , the corresponding equation in laufen is overrid den  , but Base . stem unifies with lauf . Finally , in verb , the main set supplies default values for Pref ix and morph : prefix  ( which in the cases under consideration will not be applicable  )  , unifies P_bs with the result of concatenating the strings Prefix and Base_stem  , and for each value of syn in fl assigns to form the concatenation of P_bs with the appropriate sufft x string  . 
Values for sere ( antics ) are provided in main set equations ; those in wegl aufen and verl aufen are thus correctly able to override that in laufen  . 
3.2 English Irregular Verbs
In most cases , lexical items that realize certain morphosyntactic properties in irregular forms do not also have regular realizations of those properties  ; thus * sinked is not a wellformed alternative to sank or sunk  , on the analogy of e . g . walked . 
This phenomenon has frequently been discussed in both theoretical and computational morphology  , under the title of ' blocking ' , and it appears to provide clear motivation for a default-based hierarchical approach to lexical organization  . 11 There are exceptions to this general rule , however , and inheritance mechanisms must be sufficiently flexible to permit deviation from the strict behaviour illustrated above  . 
Consider the small class of English verbs including dream  , lean , learn and burn ; these have , for many speakers , alternate past finite and past participle forms : e  . g . dreamed and dreamt . The following fragment produces the correct pairings of strings and feature structures  , the written form of the word being encoded as the value of the formll See e  . g . Calder (1989) . 
feature : 12  #Word walk ( verb ) < bass >= walk  #Word sink ( verb ) < bass >= sink
P_Fin_Form = silk
PSP_Form = sunk  #Word dream ( dual-past verb ) < base >= dream  #Class dual-past 0

PSP_Form=<base > k&t
P_Fin_Form=<bass > & k t ~ morph >= past t in lts/past non ~ in its 
I  #Class verb () < o a t >= v
PSP_Porm=<bass > It&sd
P_Fin_Form=<bass > & kod
J < morplO = present_nones3 < ~ or m ~= < bass > < morph >= prsssnt_ss3 < ~ or m >= < bass > & k s ~ r p h ~- p t s t n on : e inito < form >= PSP_Fozm<nOXl~lO  . p t s t f l n l t s < f o ~ O = p_F4e_Fo~n The main set equations in s/nk override those in its superclass verb  , so that the variants in the latter class which give rise to past participle and past tensed forms associate the appropriate information with the strings sunk and sank  , respectively . The class walk , on the other hand , contains nothing to pre-emp the equations in verb  , and so its past forms are constructed from its value for base and the suffix stringed  . 
The lex/cai class dream differs from these in hay -ing as one of its direct superclasses dual- past  , which contains two variant sets , the second of which is empty ( recall that variant sets are preceded by the vertical bar'I'  )   . Moreover , this class is more specific than the other superclass verb  , and so its equations assigning to PaP_Form and P_Fin_Form the string formed by concatenating the value of base and t have precedence over the contradictory statements in the main set of verb  . 
Note that this set alo includes a disjunctive constraint to the effect that the value of morph in this FS must be either past finite or past nonfinite  . 
The dual_past class thus describes two feature IZA gain  , the analysis ketched here is simplified ; several variants within the verb class have been omitted  , and all in-fleetional information is embodied as the value of the single feature morph  . 
219 structures , but adds no information to the second . The absence of contradictory specifications permits the equations in the main set of verb to apply  , in addition to those in the first variant set of dual-past  . The second , empty , variant set in dual-past permits this class also to inherit all the properties of its superclass  , i . e . those of regular verbs like walk ; among these is that of forming the two past forms by suffixinged to the stem  , which produces the regular dreamed past forms . 
3.3 Word Form Manipulation
The string concatenation operator '&&' allows the lexicon writer to manipulate wordforms with ELU equations and macros  . In particular , & t can be used to add or remove prefixes and suE3xes   , and also to effect internal modifications , such as German Umlaut , by removing a string of characters from one end , changing the remainder , and then replacing the first string . In this section we show briefly how unification , string concatenation , and defensible inheritance combine to permit the analysis of some of the numerous orthographic changes that accompany English inflectional sufftxation  . 
The inflectional paradigms of English nouns , verbs , and adjectives are complicated by a number of orthographic effects  ; big , hop , etc . undergo a doubling of the final stem character in e  . g . bigger , hopped , stems such as / oz , bush , and arch take an epenthetic ? before the plural or third singular presents u if l x s  , stem-finalie becomes y before the present participles u if L ~ ing  , and so on . Pe-ripheral alternations of this kind are accomplished quite straightforwardly bmacros like those in the following lexicon fragment  ( in which invocations of user-defined macros are introduced by ':  , ): is
Final_Sibilant ( Strins ) $ trin$=_I ~ eh/c ~ / e/x/s

String = ~ reft xI~y
Prefix = & k b/c/4/~/g/h/j/k/i/m/n/p/r/s/t/v/w/x/z  #Word try ( verb_spe11 ~ ) < base >= try  #Word watch ( verb_spe\] . I/a8)<base >= watch 13 As before , this iss somewhat sbbre~sted version of sfull descrip ~ on  ; the verb and vo ~ bJpolliag classes require additional variant sets to account for other morphosynts c ~ c prope ~ es  . Others t ~ ng-predic stem acros , in particular OK , must be defined in order to ester for the ~ range of spelling changes observed in verbal inflee ~ on  . 
 #Class verb_spelling ( verb )
I ! Final_T (< base >, P )
Base_P_PSP = P && i
Base_3SG = P&kie
J ! F ~ al_Si bilant(<bae e >)
Base_3SG=<base > k & ?
I ! OK(<base >) #Class verb () < cat >= v
Base_3SG=<base >
Baso_P_PSP=<bass >
PSP_Form-Baso_P_PSP k&od
SG3_FozmffiBase_3SGk&s
J ! Sing3<form >= SG3_Form
I ; Past NonFin < form >= PSP_Form
Two macros definitions are shown here ; Final_?is true of a pair of strings String and Prefix iff String consists of Prefix followed by y and the final character of Pref ix is one of the set denoted by the disjunction b / c  .   .   , z , while Final_Sibilant is true of a given string iff that string terminates in sh  , ch , s , z , or z . OK is a macro which is true of only those strings to which neither Final  . Sibilant nor
Final_Yapply.
The class verb Jpell J . ng contains three variant equation sets , the first two of which assign values to variables according to the form of the string which is the value of the base feature  . If Final_?is applicable , Base . P-PSP is unified with the concatenation of the second argument to the macro  ( e . g . tr ) and is , while Base_3SG is unified with e . g . trandi . 
If FJ . na1 . Sl bilant is applicable , then Base . 3SG is unified with the concatenation of the value of base  ( e . g . watch ) and e . If neither of these is applicable ( because the base string does not match the patterns in the macro definitions  )  , the variables are bound not within this class , but in the main equation set of its superc\]ass verb  . Here , their values are unified directly with that of base  , and the eventual values of the form feature result from concatenation of the appropriate suiflx strings  , giving values of watched , watches , tried , and tries . 
4 Summary
The lexicon system presented above is fully integrated into the ELU environment  ; in particular , the result of analysis and the starting point for generation is the same type of feature structure as that produced by ELU grammars  , and the equa-used elsewhere in a linguistic description  , being able to exploit reentrancy , negation , disjunction , direct manipulation of lists , etc . 
For the purpose of experimenting with the structure of the class hierarchy and the distribution of information within individual classes  , the lexicon is held in memory , and is accesse directly by means of an exhaustive search  . Once a stable description is achieved , and the coverage of the lexicon increases , a more efficient access mechanism exists , in which possible word forms are precomputed , and used to index into a disk file of class definitions  . 
We have presented an implemented treatment of a framework for lexical description which is both practical from the perspective of efficiency and attractive in its reflection of the natural organization of a lexicon into nested and intersecting en-eralizations and exceptions  . The system extends traditional unification with a multiple default inheritance mechanism  , for which a declarative semantics is provided . 

Boums , G . (1990) " Defaults in Unification Grammar , " Proceedings of the ~ Sth Annual Meeting of the Association for Computational Linguistics  , Pittsburgh , June 6th-9th .  165-172 . 
Calder , J . (1989) " Paradigmatic Morphology , " Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics  , Manchester , April 10th-12th .  $8-65 . 
Daelemans , W . and G . Gazdar , eds .   ( 1990 ) Inheritance in Natural Language Processing : Workshop Proceedings  . ITK , Tilbut 8University . 
Estival , D . (1990) " ELU User Manual " . Technical
Report 1, ISSCO , Geneva.
Flickinger , D . P .   ( 1987 ) " Lexical Rules in the Hierarchical Lexicon , " PhD Thesis , Stanford University . 
Gasdar , G . (1990) " An Introduction to DATR , " in R . Evans and G . Gasdar ( eds . ) The DATR Papers : February I990 . Cognitive Science Research Paper CSRP 139 , School of Cognitive and Computing Sciences , University of Sussex . 

Hudson , R.A . (1984) Word Grammar . Oxford :

Johnson , R . and M . Rosner ( 1989 ) " A Rich Environment for Experimentation with Unification Grammars  , " Proceedings of the Fourth Conference of the European Chapter of the Association  . for Computational Linguistics , Manchester , April 10th-12th .  182-189 . 
Karttunen , L .   ( 1986 ) "D-PATR : A Development Environment for Unification-Based Grammars  , " Proceedings of the llthlnterna . 
tional Conference on Computational Linguis.
tics , Bonn , August 25th-29 th . 74-80.
Keene , S .   ( 1989 ) Object-Oriented Programming in Common Lisp . Reading , Massachussetts :

Schmolse , J . G . and T . A . Lipkis ( 1983 ) " Classification in the KL-ONE Knowledge Representation System  , " Proceedings of the Eighth International Joint Conference on Artificial Intelligence  , Karlsruhe , West Germany .  330-332 . 
Shieber , S . M .   ( 1986 ) An Introduction to Unifi-cation-Based Approaches to Grammar  . CSLI Lecture Notes no . 4, Stanford University . 
Steele , G . L .   ( 1990 ) Common Lisp : The Language ( second edition )  . Bedford , Massachussetts : Digital Press . 
Touretsky , D . S . (1986) The Mathematics of Inheritance Systems . London : Pitman Publishing . 

