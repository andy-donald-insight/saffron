Another Facet of LIG Parsing
Pierre Boullier

BP 105
78153 Le Chesnay Cedex , France
Pierre . Boullier@inria . fr

In this paper 1 we present a new parsing algorithm for linear indexed grammars  ( LIGs ) in the same spirit as the one described in ( Vijay-Shanker and Weir , 1993) for tree adjoining grammars . For a LIGL and an input string x of length n , we build a nonambiguous contextfree grammar whose sentences are all  ( and exclusively ) valid derivation sequences in L which lead to x . We show that this grammar can be built in ( 9 ( n 6 ) time and that individual parses can be extracted in linear time with the size of the extracted parse tree  . 
Though this O ( n 6 ) upper bound does not improve over previous results  , the average case behaves much better . Moreover , practical parsing times can be decreased by some statically performed computations  . 
1 Introduction
The class of mildly context-sensitive languages can be described by several equivalent grammar types  . 
Among these types we cannotably cite tree adjoining grammars  ( TAGs ) and linear indexed grammars ( LIGs )  . In ( Vijay-Shanker and Weir , 1994) TAGs are transformed into equivalent LIGs . Though context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism  , from a computational point of view , many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance  . For example , quoted from ( Schabes and Shieber ,  1994 ) " The LIG version of TAG can be used for recognition and parsing  . Because the LIG formalism is based on augmented rewriting  , the parsing algorithms can be much simpler to understand  1See   ( Boullier , 1996) for an extended version . 
87 and easier to modify , and no loss of generality is incurred " . In ( Vijay-Shanker and Weir ,  1993 ) LIGs are used to express the derivations of a sentence in TAGs  . In ( Vijay-Shanker , Weir and Rainbow ,  1995 ) the approach used for parsing a new formalism , the DTree Grammars ( DTG ) , is to translate a DTG into a Linear Prioritized Multiset Grammar which is similar to a LIG but uses multisets in place of stacks  . 
LIGs can be seen as usual contextfree grammars ( CFGs ) upon which constraints are imposed . These constraints are expressed by stacks of symbols associated with nonterminals  . We study parsing of LIGs , our goal being to define a structure that verifies the LIG constraints and codes all  ( and exclusively ) parse trees deriving sentences . 
Since derivations in LIGs are constrained CF derivations  , we can think of a scheme where the CF derivations for a given input are expressed by a shared forest from which individual parse trees which do not satisfied the LIG constraints are erased  . Unhappily this view is too simplistic , since theer asing of individual trees whose parts can be shared with other valid trees can only be performed after some unfolding  ( unsharing ) that can produced a forest whose size is exponential or even unbounded  . 
In ( Vijay-Shanker and Weir ,  1993) , the context-freeness of adjunction in TAGs is captured by giving a CFG to represent the set of all possible derivation sequences  . In this paper we study a new parsing scheme for LIGs based upon similar principles and which  , on the other side , emphasizes as ( Lang , 1991) and ( Lang ,  1994) , the use of grammars ( shared forest ) to represent parse trees and is an extension of our previous work  ( Boullier ,  1995) . 
This previous paper describes a recognition algorithm for LIGs  , but not a parser . For a LIG and an input string , all valid parse trees are actually coded into the CF shared parse forest used by this recognizer  , but , on some parse trees of this forest , the checking of the LIG constraints can possibly failed  . 
At first sight , there are two conceivable ways to extend this recognizer into a parser :  1  . only " good " trees are kept ; 2 . the LIG constraints are Ire-\]checked while the extraction of valid trees is performed  . 
As explained above , the first solution can produce an unbounded number of trees  . The second solution is also uncomfortable since it necessitates the reeval-uation on each tree of the LIG conditions and  , doing so , we move away from the usual idea that individual parse trees can be extracted by a simple walk through a structure  . 
In this paper , we advocate a third way which will use ( see section 4 )  , the same basic material as the one used in ( Boullier ,  1995) . For a given LIGL and an input string x , we exhibit a nonambiguous CFG whose sentences are all possible valid derivation sequences in L which lead to x  . We show that this CFG can be constructed in ( . 9 ( n 6 ) time and that individual parses can be extracted in time linear with the size of the extracted tree  . 
2 Derivation Grammar and CF
Parse Forest
In a CFG G = ( VN , VT , P , S ) , the derives relation is the set ( a Ba' , aj3a ') IB--~j3e PAV=GVNUVTA a , a ~ EV * . A derivation is a sequence of strings in V * s . t . the relation derives holds between any two consecutive strings  . In a rightmost derivation , at each step , the rightmost nonterminal say B is replaced by the right hand side  ( RHS ) of a B-production . Equivalently if a 0 ~ . .  . ~ an is GG arightmost derivation where the relation symbol is overlined by the production used at each step  , we say that r l .   .   . rn is a rightmostao/a~-derivation . 
For a CFG G , the set of its rightmost S/x-derivations , where xEE(G ) , can itself be defined by a grammar . 
Definition 1 Let G = ( VN , VT , P , S ) be a CFG , its rightmost derivation grammar is the CFGD = ( VN , P , pD , S ) where pD_~A0--~A1 .   .   . A q r I r - - - A o - - + wo Alw l .   .   , wq_lAqwqEPA wiEV ~ AAjEL From the natural bijection between P and pD  , we can easily prove that
L :( D ) = r ~ .   .   . rl Irl .   .   . rn is a rightmost S/x-derivation iG ~ This shows that the rightmost derivation language of a CFG is also CF  . We will show in section 4 that a similar result holds for LIGs . 
Following ( Lang ,  1994) , CF parsing is the intersection of a CFG and a finite-state automaton  ( FSA ) which models the input string x2 . The result of this intersection is a CFG Gx-- ( V  ~ , V  ~ , px , ISIS ) called a shared parse forest which is a specialization of the initial CFG G =  ( V  ~ , VT , P , S ) to x . Each produc-JE px , is the production riEP up to some tion ri nonterminal renaming  . The nonterminal symbols in V ~ are triples denoted\[A \] ~ where AEVN  , and p and q are states . When such a nonterminal is productive , \[ A\]q:~w , we have qE5 ( p , w ) . 
G  ~
If we build the rightmost derivation grammar associated with a shared parse forest  , and we remove all its useles symbols , we get a reduced CFG say D ~ . 
The CF recognition problem for ( G , x ) is equivalent to the existence of an \[ S\]~ -production in Dx  . Moreover , each rightmost S/x-derivation in G is ( the reverse of ) a sentence in E ( D * )  . However , this result is not very interesting since individual parse trees can be as easily extracted directly from the parse forest  . This is due to the fact that in the CF case , a tree that is derived ( a parse tree ) contains all the information about its derivation  ( the sequence of rewritings used ) and therefore there is no need to distinguish between these two notions  . Though this is not always the case with nonCF formalisms  , we will see in the next sections that a similar approach  , when applied to LIGs , leads to a shared parse forest which is a LIG while it is possible to define a derivation grammar which is CF  . 
3 Linear Indexed Grammars
An indexed grammar is a CFG in which stack of symbols are associated with nonterminals  . LIGs are a restricted form of indexed grammars in which the dependence between stacks is such that at most one stack in the RHS of a production is related with the stack in its LHS  . Other nonterminals are associated with independant stacks of bounded size  . 
Following ( Vijay-Shanker and Weir , 1994) Definition 2L = ( VN , VT , VI , PL , S ) denotes a LIG where VN , VT , VI and PL are respectively finite sets of nonterminals  , terminals , stack symbols and productions , and S is the start symbol . 
In the sequel we will only consider a restricted 2if x = al .   .   . as , the states can be the integers 0 . .  . n , 0 is the initial state , n the unique final state , and the transition function 5 is s . t . iE5(i--1, a ~) and iE5(i , ~) . 
8 8 form of LIGs with productions of the form PL = A0 --+ wUA (  . .a ) --+ P lB ( .   . a ') r2 where A , B ? VN , W?V ~ A0 <\[ w\[<2 , aa ' ? V ; A0 <\ [ aa '\[ <1 and r , r2?vu(u(c01 c ? An element like A( . .a ) is a primary constituent while C0 is a secondary constituent . The stack schema ( . . a ) of a primary constituent matches all the stacks whose prefix  ( bottom ) part is left unspecified and whose suffix ( top ) part is a ; the stack of a secondary constituent is always empty  . 
Such a form has been chosen both for complexity reasons and to decrease the number of cases we have to deal with  . However , it is easy to see that this form of LIG constitutes a normal form  . 
We user0 to denote a production in PL , where the parentheses remind us that we are in a LIG ! The CF-backbone of a LIG is the underlying CFG in which each production is a LIG production where the stack part of each constituent has been deleted  , leaving only the nonterminal part . We will only consider LIGs such there is a bijection between its production set and the production set of its CF-backbone  3  . 
We call object the pair denoted A ( a ) where A is a nonterminal and ( a ) a stack of symbols . Let Vo = A(a)\[A ? VNA a?V ; be the set of objects . We define on ( VoLJVT ) * the binary relation derives denoted = ~ ( the relation symbol is sometimes
L overlined by a production ): rA(a"a)r

IiA () = ~ wrlA()r2''FlWF2

In the first above element we say that the object B  ( a " a ~ ) is the distinguished child of A ( a " a )  , and if F1 F2 = C0 , C0 is the secondary object . A derivation F~, .   .   . , Fi , Fi+x, .   .   .   , Ft is a sequence of strings where the relation derives holds between any two consecutive strings The language defined by a LIGL is the set : ?  ( L ) = x\[S0:=~xAx?V ~

As in the CF case we can talk of rightmost derivations when the rightmost object is derived at each step  . Of course , many other derivation strategies may be thought of  . For our parsing algorithm , we need such a particular derives relation . Assume that a tone step an object derives both a distinguished  3rp and rp0 with the same indexp designate associated productions  . 
child and a secondary object . Our particular derivation strategy is such that this distinguished child will always be derived after the secondary object  ( and its descendants )  , whether this secondary object lays to its left or to its right  . This derives relation is denoted = ~ and is called linear  4  . 
l , L
A spine is the sequence of objects Al(al )? . . Ai(ai ) Ai+l (~ i+1) . . . A p(ap ) if , there is a derivation in which each object Ai+l ( ai+l ) is the distinguished child of Ai ( ai )   ( and therefore the distinguished descendant of Aj ( aj )  , 1 <_j <_i ) . 
4 Linear Derivation Grammar
For a given LIGL , consider a linear SO~x-derivation so .   .   .   .   .   . = t,Lt,Ll,L The sequence of productions rl 0 .   .   . riO .   .   . rnO ( considered in reverse order ) is a string in P ~ . The purpose of this section is to define the set of such strings as the language defined by some CFG  . 
Associated with a LIGL = ( VN , VT , VI , PL , S ) , we first define a bunch of binary relations which are borrowed from  ( Boullier ,  1995) -4 , -=( A , B )\ [ A ( . .) ~ r , B ( .   . ) r ~ ePL-~=(A,B)IA ( . . ) -~ r lB ( .   . ~) r2ePL >-=( A,B)I4 rxB ( . .)r2 e PL
I -~= ( A1 , A p )\[ A10 = ~ rlA , () r ~ and A , 0 q - L is a distinguished escendant of A1 O Thel-level relation simply indicate , for each production , which operation can be apply to the stack associated with the LHS nonterminal to get the stack associated with its distinguished child  ;  ~  in1   1 ping of 3'-If we look at the evolution of a stack along a spine  A1   ( ax )   .   .   . Ai(ai)Ai+x(ai+x ) .   .   . A p(ap ) , between any two objects one of the following holds : OLi ~  O~i+1  , Oli3 , ~ OLi + I , or ai = ai + l ~ . 
The-O-relation select pairs of nonterminals + ( A 1 , Ap ) s . t . al = ap = e along nontrivial spines . 
4linear reminds us that we are in a LIG and relies upon a linear  ( total ) order over object occurrences in a derivation . See ( Boullier , 1996) for a more formal definition . 

If the relations >- and ~ are defined as >-=>-++ 1   7   "/7 U ~-~- and ~---- U Tev ~"<>' , we can see that the +1   1+ following identity holds
Property 1--?,-=-? . -U~U-K>--~,-Uw . ,--~-+ 1 1 + + In ( Boullier ,  1995 ) we can found an algorithms which computes the -~ , >- and ~ relations as the ++ composition of - , ? , - , - ~ and ~- in O(IVNI3) time . 

Definition 3 For a LIGL = ( VN , VT , V z , PL , S ) , we call linear derivation grammar ( LDG ) the CFGDL ( or D when L is understood ) D = ( VND , V D , pD , SD ) where ? VD =\[ A\]IA ? VNU\[ApB\]IA , B ? VNA p ? 7 ~ , and ~ is the set of relations ~ , -? , - , ' Y11 ? VTD = pL?S ?=\[ S\]?Below ,  \[  F1F2\] symbol \ [ X\] when FIF2 = stringe when F1F2 ? V  ~ . 
being denotes either the nonterminal
X 0 or the emptypo is defined as \[ A\]-+r 0 IrO = AO-~w ? PL ( 1 ) 
U\[A\]-+r0\[A+-~B\]I r0=B0-+w?PL ( 2 ) 
UI\[A + ~- C\]~\[rlr~\]r0I r0 = A( . .) ~ r , c ( .   .   ) r : ? PL ( 3 ) u\[A + -~ C\]--+\[A ~ C\] ( 4 ) u\[Ac\]\[Bc\]\[rlr:lr0Ir0=AC ) rls (  . . ) r2? PL ( 5 )   ( 6 ) U\[A+-~C\]->\[B~C\]\[A~B\]U\[A~C\] ~\[ B~-c\]\[rl  r2  \ ]  r0 I+r 0 = A (  . .) ~ r lB ( .   . ~) r2?PL (7) 5Though in the referred paper , these relations are defined on constituents , the algorithm also applies to nonterminals . 
6In fact we will only use valid nonterminals \[ ApB \] for which the relation p holds between A and B  . 
U\[A~C\]~\[rlr~\]r0I-I-r0 = A( . .7) ~ r l c ( .   .   ) r ~ ? PL ( 8 ) U\[A ~-+ C\]--~\[F1 F2\] r0\[A ~ S\]lr0 = B (  . .-y ) r l c ( .   . ) r ,  ?  ( 9 ) The productions in pD define all the ways linear derivations can be composed from linear subderivations  . This compositions rely on one side upon property 1   ( recall that the productions in PL , must be produced in reverse order ) and , on the other side , upon the order in which secondary spines ( the rlF2-spines ) are processed to get the linear derivation order . 
In ( Boullier ,  1996) , we prove that LDGs are not ambiguous ( in fact they are SLR ( 1 ) ) and define ? ( D ) = nO .  -  . r-OISO r ~) .   .   . r_~)xl,Lf . ,L
A x 6? ( L)
If , by some classical algorithm , we remove from D all its useless symbols , we get a reduced CFG say D '= ( VND' , VTD ' , pD ' , SO ') . In this grammar , all its terminal symbols , which are productions in L , are useful . By the way , the construction of D ' solve the emptiness problem for LIGs : L specify the empty set iff the set VTD ' is empty  7  . 
5 LIG parsing
Given a LIGL:(VN , VT , V z , PL , S ) we want to find all the syntactic structures associated with an input string x  6 V  ~ . In section 2 we used a CFG ( the shared parse forest ) for representing all parses in a CFG . In this section we will see how to build a CFG which represents all parses in a LIG  . 
In ( Boullier ,  1995 ) we give a recognizer for LIGs with the following scheme : in a first phase a general CF parsing algorithm  , working on the CF-backbone builds a shared parse forest for a given input string x  . 
In a second phase , the LIG conditions are checked on this forest . This checking can result in some subtree ( production ) deletions , namely the ones for which there is no valid symbol stack evaluation  . If the resulting grammar is not empty , then x is a sentence . 
However , in the general case , this resulting grammar is not a shared parse forest for the initial LIG in the sense that the computation of stack of symbols along spines are not guaranteed to be consistent  . Such invalid spines are not deleted during the check of the LIG conditions because they could be  7In   ( Vijay-Shanker and Weir ,  1993 ) the emptiness problem for LIGs is solved by constructing an FSA  . 
9 0 composed of sub-spines which are themselves parts of other valid spines  . One way to solve this problem is to unfold the shared parse forest and to extract individual parse trees  . A parse tree is then kept iff the LIG conditions are valid on that tree  . But such a method is not practical since the number of parse trees can be unbounded when the CF-backbone is cyclic  . Even for noncyclic grammars , the number of parse trees can be exponential in the size of the input  . Moreover , it is problematic that a worst case polynomial size structure could be reached by some sharing compatible both with the syntactic and the % emantic " features  . 
However , we know that derivations in TAGs are contextfree ( see ( Vijay-Shanker , 1987)) and ( Vijay-Shanker and Weir ,  1993 ) exhibits a CFG which represents all possible derivation sequences in a TAG  . 
We will show that the analogous holds for LIGs and leads to an O  ( n 6 ) time parsing algorithm . 
Definition 4 Let L = ( VN , VT , VI , PL , S ) be a LIG , G = ( VN , VT , PG , S ) its CF-backbone , x a string in E(G ) , and G~=(V  ~ , V~ , P~ , S ~) its shared parse \] orest for x . We define the LIGed forest for x as being the LIG L ~ =  ( V  ~ r , V  ~ , VI , P  ~ , S ~) s . t . Gz is its CF-backbone and its productions are the production so \] P ~ in which the corresponding stack-schemaso \] L have been added  . For example rg0 =\[ AI~( . .~) -4 \[ BI( . .~' ) \ [C\]~0 eP~iffJ krq=\[A\]k -4 \[B\]i\[C\]jeP ~ Arp = A -4 B Ce
GA rpO = A(..~)-4B(..~') C0en.
Between a LIGL and its LIGed forest L~for x , we have : x~? ( L ) ? == ~ xCf ~ ( L  ~ ) If we follow ( Lang ,  1994) , the previous definition which produces a LIG ed forest from any L and x is a  ( LIG ) parser S : given a LIGL and a string x , we have constructed a new LIGL ~ for the intersection Z  ; (L)C)x , which is the shared forest for all parses of the sentences in the intersection  . However , we wish to go one step further since the parsing ( or even recognition ) problem for LIGs cannot be trivially extracted from the LIGed forests  . 
Our vision for the parsing of a string x with a LIGL can be summarized in few lines  . Let G be the CF-backbone of L , we first build G~the CFG shared parse forest by any classical general CF parsing algorithm and then Lx its LIG ed forest  . Afterwards , we build the reduced LDGDL~associated with L ~ as shown in section  4  . 
S of course , instead of x , we can consider any FSA . 

The recognition problem for ( L,x ) ( i . e . is x an element of ? ( L ) ) is equivalent to the non-emptiness of the production set of OLd  . 
Moreover , each linear SO~x-derivation in L is ( the reverse of ) a string in ff . (DL*)9 . So the extraction of individual parses in a LIG is merely reduced to the derivation of strings in a CFG  . 
An important issue is about the complexity , in time and space , of DL  ~ . Let n be the length of the input string x . Since G is in binary form we know that the shared parse forest Gx can be build in O  ( n3 ) time and the number of its productions is also in O  ( n3 )  . Moreover , the cardinality of V ~ is O(n2) and , for any given nonterminal , say\[A\]q , there are at most O(n ) \[ A \] g-productions . Of course , these complexities extend to the LIGed forest Lz . 
We now look at the LDG complexity when the input LIG is a LIGed forest  . In fact , we mainly have to check two forms of productions ( see definition 3 )  . 
The first for misproduction ( 6 )   ( \[A+-~C\]-+\[B+C\]\[A~-0B\] )  , where three different nonterminals in VN are implied  ( i . e . A , B and C ) , so the number of productions of that form is cubic in the number of nonterminals and therefore is O  ( n6 )  . 
In the second form ( productions (5) , (7) and (9)) , exemplified by \[ A~C\] -4 \[ B  ~ c\]\[rlr2\]r   ( ) , there ? are four nonterminals in VN(i . e . A , B , C , and X if FIF2 = X0 ) and a production r0 ( the number of relation symbols ~ is a constant )  , therefore , the ? number of such production seems to be of fourth degree in the number of nonterminals and linear in the number of productions  . However , these variables are not independant . For a given A , the number of triples ( B , X , r0) is the number of A-productions hence O(n ) . So , at the end , the number of productions of that form is O(nh ) . 
We can easily check that the other form of productions have a lesser degree  . 
Therefore , the number of productions is dominated by the first form and the size  ( and in fact the construction time ) of this grammar is 59 ( n6 )  . 
This ( once again ) shows that the recognition and parsing problem for a LIG can be solved in  59  ( n 6 ) time . 
For a LDGD = ( V D , V D , pDSD ) , we note that for any given nonterminal AEVND and string a E ?:  ( A ) with\[a\[>_2 , a single production A -4   X1X2 or A -4   X1X2X3 in pD is needed to " cut " a into two or three nonempty piecesal  ,  0"2 , and 03 , such that ? In fact , the terminal symbols in DL~axe productions in L  ~   ( say Rq ( ) )  , which trivially can be mapped to productions in L  ( here rp ( ) )  . 
X i ~ a , except when the production form num-
Dbet (4) is used . In such a case , this cutting needs two productions ( namely ( 4 ) and ( 7 ) ) . This shows that the cutting out of any string of length l  , into elementary pieces of length 1 , is performed in using O(l ) productions . Therefore , the extraction of a linear so ~ x-derivation iL is performed in time linear with the length of that derivation  . If we assume that the CF-backbone G is non cyclic  , the extraction of a parse is linear in n . Moreover , during an extraction , since DL = is not ambiguous , at some place , the choice of another A-production will result in a different linear derivation  . 
Of course , practical generations of LDGs must improve over a blind application of definition  3  . One way is to consider a topdown strategy : the X -productions in a LDG are generated iff X is the start symbol or occurs in the RHS of an already generated production  . The examples in section 6 are produced this way . 
If the number of ambiguities in the initial LIG is bounded  , the size of DL = , for a given input string x of length n , is linear in n . 
The size and the time needed to compute DL . are closely related to the actual sizes of the -< ~-  , >- and ++ relations . As pointed out in ( Boullier ,  1995) , their O ( n4 ) maximum sizes seem to be seldom reached in practice  . This means that the average parsing time is much better than this  (  . .9(n 6) worst case . 
Moreover , our parsing schemal low to avoid some useless computations  . Assume that the symbol \[ A ~ B\] is useless in the LDGDL associated with the initial LIGL  , we know that any nonterminals . t . \[\[ A\]+-~\[B\]~\] is also useless in DL = . Therefore , the static computation of a reduced LDG for the initial LIGL  ( and the corresponding -?- , >- and . ~++ relations ) can be used to direct the parsing process and decrease the parsing time  ( see section 6 )  . 
6 Two Examples 6.1 First Example
In this section , we illustrate our algorithm with a LIGL--(S , T\] , a , b , c ,  7~ ,  75 , O'c , PL , S ) where PL contains the following productions : ~ 0 : s (   .   . )-+ s( .   . eo ) ~ r30: s( .   . ) --+ S ( . .%)c rhO : T( . .7~) --+ aT ( . .) rT0 = T ( . .%) -+ cT ( . .) r20 = S ( . .) --+ S( . .Tb)b r40 = S ( . .) --+ T ( . .) r60 = T ( .   . %) -+ bT ( . . )   rs0  =  T0 --+ c It is easy to see that its CF-backbone G , whose
S -+ S a S - ~ S b S -+ S c S - ~ T
T-aTT-+bTT-~cTT-+c defines the language  ?  ( G ) = wcw'Iw , w ' 6 a , b , c \]* . We remark that the stacks of symbols in L constrain the string w ' to be equal to w and therefore the language ?  ( L ) is wcwIw6a , b , c \]* . 
We note that in L the key part is played by the middlec  , introduced by production rs 0 , and that this grammar is nonambiguous , while in G the symbol c , introduced by the last production T~c , is only a separator between w and w ' and that this grammar is ambiguous  ( any occurrence of c may be this separator )  . 
The computation of the relations gives : += ( S , T ) = ~= ~= ( s , s ) 1119% " Tb~c > =>-= ~( T , T\]\]111 +=( S , T ) += ( S , T ) 9' a 9'5'7 c > . -=>-=>-=( T , T ) , ( S , T ) +++ The production set pD of the LDGD associated with L is :\[ S\]--+  rs0\[S -~+ T\] ( 2 ) 
ISTT\]-+~0 ( 3 ) \[S+-~T\]--+\[S~T\] ( 4 ) 
IS~T\]--+\[S~T\]rl 0 ( 7 ) \[ S~T\]--+\[S , ~ T\]r 20 ( 7 ) \[ S~T\]=-+IS~-T\]ra 0 ( 7 ) +\[ S~T\]-=+rh ( )\[S +-~ T \] ( 9 ) 
IS~:+T\]+~ (   ) \[ S~T\] ( 9 ) \[S~T\]--+rT0\[S-~+T\] ( 9 ) The numbers ( i ) refer to definition 3 . We can easily checked that this grammar is reduced  . 
Let x = ccc be an input string . Since x is an element of ?( G ) , its shared parse forest Gx is not empty . Its production set P~is:rl=\[s\]~-+\[ s\]~cr ~=\[ S\]o ~-+\[ S\]~c  r4 ~=\[ s\]~--+IT\] 1 r ~=\ [ T \] I 3 --+ c\[T \] 3 r 9 =\[ T\]~=+c\[T \] 2   ~1 =\[ T\]~-+cr ~=\[ S\]~-+\[T\]o ~ r44 =\[ S\]~--~\[T\]o 2 r ~=\[ T\]3o  =-+  c\[T\]31 rs =\[ T\] 3 --+ crs 1? =\[ T\]~--+cWe can observe that this shared parse forest denotes in fact three different parse trees  . Each one corresponding to a different cutting out of x = wcw'  ( i . e . 
w = ~ and w'=ce , or w : c and w ' = c , or w = ec and w'=g ) . 
The corresponding LIGed forest whose start symbol is S *=\[ S\]~ and production set P ~ is:  r~0 =\[ S\]o % . )-~\[ s\]~( . .%)? ~0 = IS\]0% . )-, IT\]o % . ) ~0 =\[ S\]o % . ) ~\[ S\]o ~( . .%)c ~40 = \[ s \]~( . .) -~ IT\]o % . ) ~0 = ISIS ( . .) ~ \[ T \]~( . .) r60 T 3 = \ [ \ ]0( .   . %)-~~\[T\]~( . .) r~0 : \[ T\]3( . .%) ~ c\[T\]23( . .) rsS0 = \[ T \]~ 0 --+ c r~0 = \[ T\]o % . %) -~ c\[T\]~( . . )   r~?0 :\[ T \] ~ 0 -+ e ~0  = \[  T\]~0 - ~ cF or this LIGed forest the relations are : " ) ' c>-__=_+ ( (\[ S\]o a , \[ T\]oa ) , (\[ S\]o2 , \[ T\]o2) , (\[ S\]o1 , \[ T\]ol ) ( IsiS , \[ s\]o ~) , (\[ S\]o ~ , IsiS)(\[T\]o3 , \[ T\]~) , (\[ T\]3 , \[ T\]23) , (\[ T\]o2 , \[T\]2)(\[s\]~0 , \[ T\]~)-? . -  ( 3 ~ The start symbol of the LDG associated with the LIGed forest L * is \[\[  S\]o3\]  . If we assume that an A-production is generated iff it is an \[\[  S\]o3\]-production or A occurs in an already generated production , we get :\[\[ S\]o ~\]~~? ( )\[\[ s \]~ + \[ T \]~\] ( 2 ) \[\[S\]~+~\[T\]~\]-+\[\[S\]o ~ ~\[ Th ' \]   ( 4 ) \[\[ S\]a ~- . \[TIll-+\[\[S\]o2~2\[T\]~\]r ~ ( )  ( 7 ) +\[\[ S\]o ~~: +\[ T\]~\]-~~ ( )\[\[ S\]o ~ ~+ \[ T\]o ~1 ( 9 ) \[\[ S\]~~\[T\]~\]~~0 ( 3 ) This CFG is reduced . Since its production set is nonempty , we have cccE~(L ) . Its language is r~?0 r90 r4 ( ) r ~ 0 which shows that the only linear derivation in L is S  ( ) ~ ) S ( % ) cr  ~ ) T ( Tc ) Cr = ~ ) t , Lt , Ll , LeT ( ) c ~) ccc . 
g , L we remark that though T~2T , T  ~ T , and T ~ T , +++ the nonterminals IT ~ T\] , \[T ~ T\] , and IT~:T\]are ++ not used in pp . This means that for any LIGed forest L ~ , the elements of the form (\[ Tip q , \[ T\]~: ) do not " ) ' a need to be computed in the ~+ ,  ~+  , and ~:+ relations since they will never produce a useful nonterminal  . 
In this example , the subset ~: of ~: is useless.
1-b
The next example shows the handling of acyclic grammar  . 
6.2 Second Example
The following LIGL , where A is the start symbol : rl ( ) = A( . .) ~ A ( . .%) r2() = A ( . .) ~ B ( . .) r30 = B ( .   . %)-~ B ( . . ) r40 = B0~aiscyclic ( we have A = ~ A and B = ~ B in its CF-backbone )  , and the stack schemas in production r l 0 indicate that an unbounded number of push % actions can take place  , while production r3   0 indicates an unbounded number of pops . Its CF-backbone is unbounded ambiguous though its language contains the single string a  . 
The computation of the relations gives : -~-= ( A , B ) += ( d , B ) 7a ~-= ( A , B ) , ( B , B ) + The start symbol of the LDG associated with L is\[A \] and its production set pO is :\[ A\]  -+   r40\[A +- ~ B\] ( 2 ) \[A+~B\]-+r20 ( 3 ) \[A + ~- B\]~\[A ~ B\] ( 4 ) \[A ~ B\]-~\[A ~ B\]rl 0 ( 7 ) +\[A~2B\]-~r30\[A + ~- B\] ( 9 ) + We can easily checked that this grammar is reduced  . 
We want to parse the input string x--a(i . e . find all the linear SO/a-derivations ) . 
Its LIGed forest , whose start ==\[ Aft ( .   . ) ==\[ B\]o0
For this LIGed . <,-+" t ,*+ symbol is\[A\]~is:-,\[Aft( . .%) \[ B \]~( . .) --+ \[ B \]~( . .) a forest L x , the relations are : ( JAIL = (\[ Aft , \[ Aft ) = ? (\[ Aft , -= (\[ Aft , \ [ B\]ol ) = (\[ A \] ~ , \[B\]~) , ( IBIS , \[B\]~ ) The start symbol of the LDG associated with Lx is\[\[A\]~\]  . If we assume that an A-production is generated iff it is an \[\[ A\]~\]-production or A occurs in an already generated production  , its production set is :\[\[ AI~\]-+r ~ ( )\[\[A \]~ +-~ \[ S \] 11 ( 2 ) \[\[A\]~-+\[B\]~\]-+r22 0 ( 3 ) \[\[A\]~+-~\[ B\]01\] ~\[\[ A \] o 1 ~\[ B\]o 1\]   ( 4 ) \[\[ A \] ~ ~ . \[B\]01\]-+\[\[A\]~~~:\[B\]~\]rI0 ( 7 ) +\[\[ A\]~~+\[B\]~\]--4 r3 ( )\[\[A\]l o ~ \[ S\]10\] ( 9 ) This CFG is reduced . Since its production set is nonempty , we have a 6? ( L) . Its language is r4 ( )r\] ( ) ) kr ~ Or ~ Ok\]0 < k ) which shows that the only valid linear derivations w  . r . t . L must contain an identical number k of productions which push  7a   ( i . e . the production r l 0 ) and productions which pop 7 a ( i . e . the production r3()) . 
As in the previous example , we can see that the element \[ S\]~\[B\]~is useless  . 
+ 7 Conclusion
We have shown that the parses of a LIG can be represented by a nonambiguous CFG  . This representation captures the fact that the values of a stack of symbols is well parenthesized  . When a symbol 3' is pushed on a stack at a given index at some place  , this very symbol must be popped some place else , and we know that such ( recursive ) pairing is the essence of context-freeness . 
In this approach , the number of productions and the construction time of this CFG is at worst O  ( n6 )  , tions . Moreover , static computations on the initial LIG may decrease this practical complexity in avoiding useless computations  . Each sentence in this CFG is a derivation of the given input string by the LIG  , and is extracted in linear time . 

Pierre Boullier .  1995 . Yet another ( _O ( n 6 ) recognition algorithm for mildly context -sensitive languages  . In Proceedings of the fourth international workshop on parsing technologies  ( IWPT'95 )  , Prague and Karlovy Vary , Czech Republic , pages 34-47 . See also Research Report No2730 at http:I/www . in ria , fr/R2~T/R~-2730 . html , INRIA-Rocquencourt , France , Nov . 1995, 22 pages . 
Pierre Boullier .  1996 . Another Facet of LIG Parsing ( extended version ) . In Research Report NoP858 at http://www , in ria , fr/RRKT/KK-2858 . html , INRIA-Rocquencourt , France , Apr . 1996, 22 pages . 
Bernard Lang .  1991 . Towards a uniform formal framework for parsing . In Current Issues in Parsing Technology , edited by M . Tomita , Kluwer Academic Publishers , pages 153-171 . 
Bernard Lang .  1994 . Recognition can be harder than parsing . In Computational Intelligence , Vol . 
10, No . 4, pages 486-494.
Yves Schabes , Stuart M . Shieber .  1994 . An Alternative Conception of Tree-Adjoining Derivation  . 
In ACL Computational Linguistics , Vol . 20, No.
1, pages 91-124.
K . Vijay-Shanker .  1987 . A study of tree adjoining grammars . PhD thesis , University of Pennsylvania . 
K . Vijay-Shanker , David J . Weir .  1993 . The Used of Shared Forests in Tree Adjoining Grammar Parsing  . In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics  ( EACL'93 )  , Utrecht , The
Netherlands , pages 384-393.
K . Vijay-Shanker , David J . Weir .  1994 . Parsing some constrained grammar formalisms . In ACL Computational Linguistics , Vol . 19, No . 4, pages 591-636 . 
K . Vijay-Shanker , David J . Weir , Owen Rambow.
1995 . Parsing D Tree Grammars . In Proceedings of the fourth international workshop on parsing technologies  ( IWPT'95 )  , Prague and Karlovy
Vary , Czech Republic , pages 252-259.
