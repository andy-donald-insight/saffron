New Approaches to Parsing Conjunctions Using Prolog 
S and , way Fong
Robert C . Berwick
Artificial hitelligence Laboratory

545 Technology Square
C , ' umbridge MA02t39, U.S.A.

Conjunctions are particularly difficult to parse in traditional  , phra . se-based gramniars . This paper shows how a different representation , not b . xsed on tree structures , markedly improves the parsing problem for conjunctions  . 
It modifies the union of phra . semarker model proposed by Goodal I\[19811 , where conjllnction is considered a stile linearization of a three-dimensional union of a non-tree I  )  , ' med phrase marke representation . APItOLOG grantm~tr for conjunctions using this new approach is given  . It is far simpler and more transparent than a recent phr~e-b~qed extraposition parser conjunctions by Dahl and McCord  \[1984\]  . 
Unlike the Dahl and McCor , Ior ATNSY SCON Jappr ~ ach , no special trail machiner yi . ~needed for conjunction , beyond that required for analyzing simple sentences  . While oi cont parable ? tficiency , the new ~ tp proach unifies under a single analysis a host of related constructions : respectively sentences  , right node raising , or gapping . Another , ' ulvan-rage is that it is also completely reversible  ( without cuts )  , and therefore can be used to generate sentences . 
John and Mary went to tile pictures
Ylimplc constituent coordhmtion
Tilefox and tile hound lived in tilefox hole and kennel respectively CotJ stit  , wnt coordination " vith r . he'resp ~ ctively'reading John and I like to program in Prolog and Hope Simple constitm vR co ~rdinatioubutc  , ~ , have a collective or n . sp , ~' tively reading
John likes but I hate banan as ~) tl-c , mst itf ~ ent coord in , ~tion
Bill designs cars and Jackaeroplanes
Gapping with ' resp,~ctively'reading
The fox . the honnd and the horse all went to market
Multiplec , mjunets * John sangloudly and a carol
Violatiofl of coordination of likes * Wire ( lid Peter see and tile car ? V/o/atio/i of roisrd J  ) l = ltestr ?/?' trlz'e constr . ~ int *1 will catch Peter and John might the car Gapping , hut compon cztt ~ cnlen ccsc . ntain unlike auxiliary verbs ? Ti represident left before noon and at  2  . Gorbachev

The problem addressed in this paper ~ s to construct  , ~gr ; unmatical device for lumdling cooLdination in natural language that is well founded in lingui  . ~ tictheory and yet computationally attractive . ' the linguistic theory , should be powerful enough to describe , ~ll of thel ) he nome nonin coordi:tation , hut also constrained enough to reject all u . 'l-gr ; unmatical examples without undue complications . It is difficult to ; tcl deve such ; tline h ; dancc-csp cci , dly since the term grammatical itself is hil , hlysubj ccl . ive . Some examples of the kinds of phenolr-enonth : tt must l  ) eh ; mdh . daresh . ,' . wlhifig . t'\['he theory shouhl Mso be . ~menable to computer hnpien : ellt ~ tion . For example , tiltrepreseuli ~ tion of the phrase , marker should be , ' onducive to Imth?le ~ u ! process description antlefficient implementation of the associated operations as defined iuthelinguistic theory  . 
Fig 1: Example Sentences
The goal of the computer implementation is to pro -d  , ceadevice that can both generate surface sentences given  ; t phrase in arke representation ad derive a phrase marker represcnt  ; Ltion given a surface sentences . Th chuple menta-lion should bc ~ efficient as possible whilst preserving the essential properties of the linguistic theory  . We will present a nir , ph:n , cut , ' ttion which is transparent to the grammax and pcrliapsclemler & morenmdular than other systems such  , ~ the int , :rpreter for the Modil h:r Structure Cram- , , , ar . ~( MSG . , ) of l ) all l&McCord\[1983 I . 
"\]' lie NISG systen l will be compared with ~ shnpliGedirn l  ) lenlenl . ; ~ tion of tile proposed device . A table show in K tile execution thne of both systems for some sample sen-disadvantages of our device will be discussed in relation to the MSG implementation  . 
Finally we can show how the simplifled device can l  ) e extended to deal with the issues of extending the system to handlenml tiple conjuncts ~ d strengthening the constraints of the system  . 
This representation of a phrase marker is equivalent to a proper subset of the more common syaxt actic tree representation  . This means that some trees may not be representable by an RPM and all RPMs may be recast as trees  . ( For exmnple , trees wit . h shared nodes representing overlapping constituents are not allowed  . ) An example of a valid RPM is given in fig .  3 :-
The RPM Representation
The phrase marker representation used by the theory described in the next section is essentially that of the Reduced Phrase Marker  ( RPM ) of L , ' mnik & Kupin\[1977\] . A reduced phrase maxker c , ' m be thought of imaset consist -" ing of monostrings  , ' rodatermiual striltg satisfying certain predicates  . More formally , we haws ( fig .  2) :-
Sentence : Alice saw 13 ill
RPM representation : S . Alice . saw . Bill . NP . saw . Bill . Alice . V . Bill . 

Fig 3: A a example of RPM representation
Let E and N denote the set of terminals and nonterminals respectively  . 
Let ~ o , ~, xE : ( TI . UN)'.
Let z , y , zEZ'.
Let A be a single nonterminal.
Let P be an arbitrary set.
Then ~ o is a monostrmg w . r.t . ~& N if ~ oE

Suppose ~ o = zAz and that ~ o , $6: P where P is a some set of strings . We can also define the following predicates : - y is a * ~ oinP if xyzEP dominates ~ b in P if ~ b = zXy  . X  #0 and x#A . 
W precedes v ) in P if 3 ys.t . y is a * ~ o in P .
~b = zvX and X#z.
Then :-
P is an RPM if 3A , zs.t.A,z ~. P and
V~O , ~ 0 C_P then dominates ~ o in P or ~ o dominates ~ b in P or ~ b precedes ~ in P or ~  , , precedes ~ b in P . 
Fig 2: Delinitioa of a zlRPM linguistic theory described in the next section  . The set representation ha . ssomed csir ; d ~ M advantages over a tree representation i terms of b  . th simplicity of description and implementation f the operations  . 
Good all's Theory of Coordination
Good all's idea in his draft thesis\[Good all ??\] wa  . stoext , md the definition of I . a . snik ~ mdt(upin's RPM to cover coordiuation . The main idea behind this theory is to apply tilt  . notion that coordination remdts from * heunion of phr  , ~emarkers to the reduced I ) hrmse marker . Since RPMs axe sets , this h , ' m the desirable property that the union of RI'Ms wouhl just be the fall tiliar set union operation  . For a computer in tplemeutation , these tunion operation can be realized inexpensively  . In contr , -Lst , the corresponding operation for trees would necessitate a much less simple and efficient union operation than set union  . 
However , the original definition of the R . PM did not ~ nv is age the union operation necessary for coordination  . "\[' he RPM w~used to represent 2-dimensional structure only . But underset union the RPM becomes a representation of  3-dimensional structure . The admissibility predicates dominates zmd precedes delined on a set of monustrings with a single nonterminal string were inadequate to describe  3-dimensional structure . 
B ; ~ i cally , Good all's original ideaw ~ to extend the dominates ~ m  ( l precedes predicates to handle RPMs under the set union operation  . This resulted in the relations e-dominates , ' rode-precedes , xs shown in fig . 4:-Assuming the definitions of fig . 2 and in addition let ~ , f2 , 0E(~ON ) " and q , r , s , t , uE\]~' , then ~ oe-dominates x binP if ~ dominates ~ bI in P  . X = w = ~' . e ~/ f l = X b and = -- g in P . 
~ oe-precedes X bin Pify lea * ~ oin P . vlea * in P . qgr-~s,~t in P . y ~ q grandu ~ ~ t where the relation - ( terminal equiralence ) is defined as :- z----p in P if x zw EP and x yo ~EP 
Figure 4: Extended definitions
This extende definition , in particular-the notion of equivalence forms the baals of the computational device described in the next section  , l lowever since the size of " the RPM may be large  , a direct implementation of the above definition of equivMence is not computation Mlyfe  , ' tsible . In the actual system , an optimized but equivalent alternative definition is used  . 
Although these definitions suffice for most examples of coordination  , it is not sufficiently constrained enough to rejects to neung r  , ' mzmatical examples . For exaanple , fig .   5 gives the RPM representation f "* John sang loudly and a carol " in terms of the union of the RPMs for the two constituent sentences : - 
Johnsangloudly
John sanga carol John . sang . loudly , S,
John . V . Ioudly , John . VP,

NP . sang . loudly John . sang.a.carol , S,
John . V . a . carol , John . VP,

NP . sang . a . caroi ( When thcse two I\[PM . q are merged some of the elements o\[the set do not satisfy La  . snik & gupin ' ~ ongim dde A-uitiou-thc . ~ e\[rdrsarc :-) John . sang . loudly . Johnsanff . a . carol John . V . loudly . John . V . a . carol NP . sang . loudly . NP . sang . a . carol(N , m . o\[the show:I~xirs . ~ lt / . s t'y thee-dominates pr w/i-rate-but L hcy all . ~tisfye-precedes and hence the sen-tcm:eJsac ~ eptc ~ las  . ~, RI'M . )
Fig . 5: An example ot " union o\[RPMs
The above example indicates that the extended RPM definition of Good all Mlows some ungrammatical sentences to slip through  . Although the device preseuted in the next section doesn't make direct use of the extended definitions  , the notion of equivMence is central to the implementation  . 
The basic system described in the next section does have this deficiency but a less simplistic version described later is more constrained-at the cost of some computational efficiency  . 
Linearization and Equivalence
Although a theory of coordination hambeen described in the previousections-in order for the theory to be put into practice  , there remain two important questions to be answered : -? I-low to produce surface strings from a set of sentences to be conjoined ?? tlow to produce a set of simple sentences  ( i . e . sentences without co , junct . ions ) from ~ conjoined surface string ? This section will show that the processes ot "// n-e~zation and finding equivalences provide an answer to both questions  . For simplicity in the following discussion , we assume that the number of simple sentences to be conjoined is two only  . 
The processes of linearization ~ md 6riding equivalences for generation can be defined as : - Given a set of sentences and a set of candidates which represent the set of conjoinable pairs for those sentences  , llnearizatinn will output one or more surface strings according to a fixed procedure  . 
Given a set of sentences , find in ff equivalences will prodnce ase to ( conjoinable pairs according to the definition of equivalence o  #the linguistic theory  . 
\[;' or genera . Li on the second process ( linding equivalences ) iuca Jled first to generate a set of ( : andidates which is then used in the first , process ( linearization ) to generate thes . rf ace strings . For parsing , the definitions still hold-but the processes are applied in reverse order  . 
To illustrate the procedure for linearization , consider the following example of a set of simple sentences  ( fig .  0) : . 
120 John like dice cream . Mary liked chocolate ~ t of . ~ implesenteuces John . Mary . ice cream . chocolate set , ff ctm joinable pairs Fig 6: Example of a set of simple sentences Consider tile plan view of the  3-dimensional repre-a entation of the union of the two simple sentences shown in fig  .  7 :-"~ . ~ ice cream John liked
Mary .-~--chocolate
Fig 7: Example o\[ 3-dimensional structure The procedure of linearization would t ~ tke the foi-l  . wing path shown by the arrows in fig .  8 :-
John . ~ ~.- cream
M~--""chocolate
Fig 8: Rxample of linearization
F~dlow in K the path shown we obtain the surface siring " John and Mary like dice cream and chocolate "  . 
The set of conjoinable pairs is produced by the process of \[ inding equivalences  . The definition of i : quivalence as given in the description of the extended RPM requires the general  . ion of the combined R . PM of the constituent sen-lances . However it can be shown \[ I , ' ong ??\] by considering the constraints impc , sed by the delinitions of equivalence and l in c : trization  , that tile same set of equivalenterminal string . ~ can be produced just by using the terminal strings of the RI*M alone  . There ; tre consider ; Lble savings of compu-tatioaal resources in not having to compare every element of the set with every other elemento generate all possible equivalent strings - which would take O  ( n  ~ ) time-where n is the cardinality of the set . The corresponding term for the modified definition  ( given in the next sectiou ) is O ( 1 )  . 
The Implementation in Prolog
This section describes a runnable specification written in Prolog  . The specification described also forms the basis for comparison with the MSG interpreter of Dahl aud Me-Cord  . The syntax of the clauses to be presented is similar to the  Dec-10 Prolog\[Bowen et a1  . 19821 version . The main differences are :-? The symbols %" and ~ , " have been replaced by the more meaningful reserved words " if " and " and " respectively  . 
? The symbol " . " is used , as the list constructor and " nil " is , , sed to represent he empty list . 
?  , in an example , a Prolog clause may have the fornt : - a(XV . . . Z ) irb(Uv . . . W ) a ~ dc(RS . . . T ) where a , b&c are predicate names and R , S, . . . , Z may represent variables , constants or terms . ( Variables are , listinguished by capitalization of the first character in the variable name  . ) The intended logical reading of tile clause is : -" a " holds if " b " and " c " both hold for consistent bindings of the arguments 
X , Y , . . . , Z , U , V, . . . , W,R,S, . .  .   , T ? C mnments ( shown in italics ) may be interspersed between tile argamaents in a clause  . 
Parse and Generate
In tile previous section tile processes of linearization and linding equivalences are described  ; mtile two components necessary for parsing and generating conjoined sen-testes  . We will show how Lhese processes can be combined to produce a parser and a generator  . The device used for comparison with Dahl & McCord scheme is a simplified version of the device presented in this section  . 
First , difference lists are used to represent strings in the following sections  . For example , the pair ( fig .  9) :-
Figg : Example of a difference list is a difference list representation of the sentence " John like dice cream "  . 
We can : to wintroduce two predicates linearize and equivale ut palrs which correspond to the processes uflia-earization uJl  ( lliuding equivalences respectively ( fig .  10 ) :- linearize ( pairs S1 Eland 52   E2 candidates Set yivcs Sentence ) Linearize hohls when a pair of difference lists  ( S1 . EL&S2 . E2)) and a set , , f candidates ( Set ) arc consistent with the string ( Sentence ) as dellned by the procedure given in the previous section  . 
equivahmt pairs ( XYfi'omS1$2)
Equivalent pair shohls when a ~ uh string X of S1 is equivalent to a substring Y of $2 accord htg to the delinition of equivalence in the linguistic theory  . 
The definitions fi~r parsing , ' utd generating are almost logically equivalent . I lowever the subgoals for p~s-ing are in reverse order to the subgoals for generating-since the Prolog interpreter would attempt to solve the subgoals in a left to right manner  . Furthc'r more , the subset relation rather than set equality is used in the definition for parsing  . We can interprethe two definitions ~ follows ( fig . t2 ) :- Generate holds when Sentence is the conjoined sentence resulting /' ram the linearization of the pair of dil Ference lists  ( Sl . nil ) and (52 . 
nil ) using as candidate pairs for conjoining , these to ? nonredundant pairs of equivalent terminal strings  ( Set )  . 
Parse holds when Sentence is the conjoined set , tence resulting from the linearization of the pair of dilference lists  ( S1 . El ) anti($2 . E2 ) provided that the set of candidate pairs for conjoining  ( Subset ) is a subset of the set of pairs of equivalent terminal strings  ( Set )  . 
Fig 12: Logic alreadhtg for generate & parse Fig 10: Predicate sllneari ~ . e & equivalent pairs Additionally , let the mete-logical predicate ~ et of as in " set of  ( l ~ lement Goal Set ) " hohl when Set is composed of chin , eats c~f the form Elementant i that Set contains all in  , : auccs of Element I , hat satisfy the goal Goal . The predicates generate can now be defined in terms of these two processes as folluws  ( lig . tt):-generate(Sentence from St52) if sctol(X . Y . nilin equivalent pairs ( XY from SI $2 ) is Set ) and linearize ( pair ~: Stnilanti S2 nil can didtttesSet 9ires Sentence ) parse ~ Sentence 9iot a 9S1 El ) if Ij nearize ( pairs SIE1 avd $2 E2 candidate . ~ SuhSet 9 ives Sentence ) nnd sctot(X . ? nilincquivalent pairs ( XY from S1 $2 ) i a Set ) Fig 1!: Prologd clinition for generate ~ . parse The subset relation is needed for the above definition of parsing hecause it can be shown \[ Fong ? ? l that the process of linearization is more constrained  ( in terms of the p ,  . rn~issible conjoinable pairs ) than the process of tinding eqnivalences . 
Linearize
We can als of a shionalogic specification for the process of line ~ tt'izatiou in the same manner  . In this section we will describe the cases corresponding to each Prolog clause necessary in the specification of \[ in earization  . However ,   , ' orsit nplicity the actual Prolog code is not shown here  .   ( See Appendix At br the delinition of predicate I in earize  . ) Ill the following discussion we assume that tile template for predicate I in earize has the form " linearize  ( pairs SlEl and 52E2r and , tides Set gives Sentence ) " shown previously in tig . I0 . There are three independent cases to con : rider durivg ! in cariz ~ tionf-t  . The BaseCase . 
If the two , lilrcrence tist ~( S1 . El & S2 . E2 ) are both empty then the conjoined string ( Sentence ) is also entpty . This siml , lysta . test hat if two empty strings arc conjoint : d then the rest t it is also an empty string  . 
1222. Identical Leading Substrlngs.
The second case occurs wheTt the two ( non-eml ) t y ) difference lists have identical eading nonempty substrings  . Then the coni-ined string is identical to the concatenation of that leading substring with the lin-eari ~  . a tion of the rest of th ,: two difference lists . For example , consider the linearization of the two flag-ments " likes Mary " and " likes Jill " as shown in fig  .  13  .   . 
likes Mary . likes Jill which can be . lineariz ~: da ~:- likes X where X is the linearization of strings Mary  . Jilll ' Tg . 13: Example of identical leading substrings 3 . Conjohfing . 
The last case occurs when the two pairs of ( qon-empty ) difference lists have no common leading substring  , llere , the conjoined string will be the co , t-catenation f the co . junctinn of one of the pairs from the candidate set  , with the conjoined sqring resulting fr~nl the line  ; trization of the two strings with their respective candidate substrings deleted  . For example , consider the linearization-f the two sentences " John likes Mary " ait d " Bill likes Jill " a ~ shown in fig  . 14:-John likes Mary . Bill likes Jill Giventh , t the . ~ elertt : , l , ', ltdi , l , tclmir is John . Bill , the c , , s j , , , ' , , : , l : , r t d t , ,' e ~; : , ul . lIw : - what linearizations the system would produce for an example sentence  . Consider the sentence " John and Bill liked
Mary " ( fig .  15 ) :- John and Bill liked Mary would produce the string:  . 
John and Billliked Mary.
John and Bill liked Mary with candidate set Johnliked Mary  , Bill liked Mary with candidate set ( John , Bill ) John Mary . Bill liked Mary with candidate set ( John . Billliked ) John . Bill liked Mary with candidate set ( John . Billliked Mary )
Fig . 15: Example of linearizations
All of the strings , ' ire then passed to the predicate find equiva lences which shou hl pick out the second pair of strings as the only grammatically correct linearization  . 
Finding Equiw dences ( . ; ood all's delinition of eqnivalence w , ' ~ s that two terminal strings were said to be equivalent if they h  ; ul the same left and right contexts . Furthermore we had previously a . s-sertcdth ; ~t the equivale ut pairs couhl be lroduced without ~ earching the whole RI'M  . For example consider the equiv-ah . nt lernnim d strings in the two sentences " Alice saw Bill " an  , J " Mary saw Bill " ( fig . 16):-John and Bill X . where X is tl ~ elinearization of ~; trin ~ , slikes Mary , likes . Jill Fig . 1, 1:\['; xaml~ic of ,:, mj , iui , g . . mh . st , rin , , , , . , ; There are S, . hCi , ul ~ h ~, . c . t ; dic . = d,:t ; tilsLhatared lf-r,~re . t for parsi . gtc~g e , er : t t in K . ( ~ ecal~l ~, ndi . ' cA . ) llowcver the fierce cases : u'e the sanonc for hoth  . 
We cast illusl , r ; ll . e the : t l ~? ~ v , ; dc : llntili , m by she=wing Alice saw Bill . Mary saw Bill would prt . hwr the , equiwdrnt pairs : - Alice saw Bill . Mary saw Bill Alice , Mary Alice saw . Mary sawl " ig .   16: l ' Jx a tuple of equivalent pairs W calso make tile rollowing restriction  . ~on Goodall's definition : - X-'=x xfl & Y--xY f '/  , then X& .   1"~ should be the strongest possible left ~ right contexts respectively-provided x&yaxe both nonempty  . In the above example , x--nil and fl="saw Bill " , so the first a . ud the third pairs produced are redundant . 
In general , a pair of terminal strings are redundant if they have the form  ( uv , uw ) or ( uv , zv ) , in which case-they may be replaced by the pairs  ( v , w ) ~ ad(u , z ) respectively . 
? I a Good all's definition any two terminal strings themselves are also a pair of equivalent erminal strings  ( whe , X&f2 , are both , ull ) . We exclude this case it produce simple string concatenation of sentences  . 
The above restrictions imply that in fig . 16 the only remai , ing equivalent pair ( Alice . Mary ) is the correct one fort l , is example . 
However , before fiuding eq , ivalent pairs for two simple zenlences , the it to cess , , f f iml i , g , quiv . ,lel , ces , nlust check that the twose , tt , ; ncesate actually gral , tlllatical . We ; msuunethntare cot ; nizer/i , arser ( e . g . a predicate parse ( SE l ) alremly exists for determining the grammatical ity of ~ it nple ~ entenccs  . Since the proct'ss only requires a yes/no answer to gramnmtic  ; dity , any parsing or recognition sys-l . e ; , tf , , r simple sentences can be used . 
We can now specify al , redicate lind candi ( lates ( XYSI $2 ) that hohls when X . Y is an equiw , hmt pair front the two grantmatical simple . : e , te , cesSI .  $2  . ~f , llows(li ! , ? .  17 ) :-findcandidates ( X and Y in SI and $2 ) irparse ( Slnil ) ilnld parse ( S2 nil ) and eqlniv ( XYSL $2 ) wh ,  . rceqt , iv is , h'f it ~, ' d as: . 
~q . iv ( X Y X1 Y I ) if append 3 ( ChiXOmega Xl ) and tern finals ( X ) and append 3 ( C . hiYOmegaYI ) and terminals(Y ): v h , ' r , ': q , t , ' , , , IS(L!L2I . .'~ L 1) h,,hls wh, . nL . Ii : ", ', l,ml ; oth, . c ', , tJ , ' nl,'t ~; tli , , tl , , fI . I . L2 . ~: 1 . 3 . h'rmin zd . ~( X ) holds when X i . ' ~ nli . .t ,,1' t,'rtztinnl . ~ yml , , , Isouly Fig . l7: Logic delit , itiol z . fFi . : l c n t l d i r h , Les Then the predicate find cquivalencosi simply defined  ; t ~( fig .  18 ) :- find equivalences ( X and Y in S1 and $2 ) if find candidates ( X and Y in S1 and $2 ) and not redundant ( XY ) wl . ,re redundant implements the two restrictions described  . 
Fig . 18: Logic definition of Findeq , ivalences
Comparison with MSGs
The following table ( fig .  19 ) givestile execution times in millise conds for the parsing of some sample sentences mostly taken from Dahl  0~ McCor ( l\[1983\] . Both systems were executed using Dec-20 Prolog . The times shown for the MSG interpreter is hazed on the time taken to parse  , ' rod buihl the syntactic tree only-the time for the subsequent transformations w  , -~ snot ,   , chided . 
Sample/MSGRP Mences J system device
Eachm ; ulate an apish ?; ~ . lld ; tpear\[662292 . Iolmat , , ~ lt appl , , and a pear \[ 613 233 f Z~k ; t , I ; Ll , ll ; 1WOIIU ~ . , , ~ il Wo ; i ' htrttill IE iit ' hll , ; lll ; tlll , ' a ch wll , l l t t a t (' l , " mpple
J , ~ hllsaw and the woman heardaa , lhat laughed . \] ohndrov, . I he carthrough and ct)m~h . lt ' ly demolishe , la window " r h , , woa , t ; t l , wit , ) gav("al ) , ~ okto . John and dr , we ; L carthrough . 'L window laugh ~ l . h , hn . ~awthe , ltltll . hiLtMary . ~aw and Billgay, . abo , , kt , , hutght~d . l . hnt . ~aw the manl hatlu . ; trd the wotn a Hrharl attglu ' d and ~ aw Bill
Th , . , , tanlh ; dMary saw and h( . ard ~; LVI ', ' ~ . ll ;) . lllll " t,I , , ;\[ l'h~vi Hlla \[ ~ . h , htlmtwa/uulMary . ~awthered pear 319   506   320   503   788   83'i   275   1032 
I--10073375 . 1393 It 636323 isot , 9~,726770i ! Fig . ld : TimingsFor some sample sentences From tile timings we can conclude that the pro-po  . .:ed device is comparable to the MSC , system in terms-f comt , ttati , Jn : dell lciency , l lowever , there are some other advantages s , ,ch as :-? Transparency of the grammar - There is no need for phrmsal rules such  . -m " S ~ S and S " The device also allows ,   , m-phr ~ al conjunction . 
* Since no special grammar or particular phr ~ e marker representation is required  , any par . , ; er can be used-thed cvicc'only requires an acctpt/reject answer  . 
1 24 ? The specification is uot biased with respect to liars-ing or generation  . The iniplement : ition is reversible allowing it to generate a ay sentence it can parse and vice versa  . 
? Modularity of the device . The granimaticallty of sen-testes with conjunctiou is determined by the definition of equivalence  . For instance , if needed we can filter the equivalent terlninals using semantics  . 
A Note on SYSCONJ
It is worthwhile to compare the phr ; memarker approach ti the Aq . 'N-ba . sed SYSCON . Iinechanisln . Like SYSCONJ ~ OUr analysis is extragrammatical : we do not tanl per with the h  , sicgramnlar , but add a new cnniponent * . hat handles conjunction . Unlike SYSCONJ , our approach is based on a precise definition of " equiw dentlhrztse ~" that atten lptstaunify urider one analysis nlany dill ' eren types of coordination phen  , mena . : ~ YSi ~ , ONJ relied ou a rather conipticated , interrupt-driven method that restarted sentence ~ malys is in SOllt C previously recorded m  ; t chine coiilil ~ qiration , but with the input sequence following the conjunction  . This cap-turcs part of the " multillleplanes " analy:ds of the phrase marker  , ' tp proach , but without a precise notion of equivalent phr , ' l~es . Perhaps ~ a result , SYSCONJ handled only ordinary conjunction , ali(l\[tot respectively or gapping reading ~ . In our appr-: , h , a simple change to the lincarization process allow sll~t ~ l handle gapping  . 
Extensions to the Basic Device
The device described in the previ , lussection is a . ~ ilu-plified version for roughelliilll ; irist in wii . h the MS ~ inter-In ' ctct " . l lowever , the systClllC ; ille . tsily hegc ii craliz cd to h~uid lenlultiple conjunct z  . The only , uhliti . nalphase require diatogelicrate telnpl:tte ~ for nluttlph : rc : ulings  . Also , gallpillg can lie handled just lly adding clauses tll the deft-ni fioll of linearize-which allows : l dilferent path from that of fi ~  . 8 to be taken . 
The ~ i inll lilied devicell V rui its ~ l l l l i l  .  , . ,( ainllh~s of un-gr ; liillii ; l l i ? : t l ~ . l . il!l,nfl . sI . , , h , rll ; U ' <' ed as if t in ' i - - or ( lig .  5) , The inildularity ~ f the systelllall . wsits ( ) ciln . .itr;tin the dcli i i i i . icliiofeClUiv:th,qlcl~stillI'lirl . hl . r . The c?tcndcl\[dellni-ticlnsin ( 141 ~ lthdl's draft l , hcorywci-elicitii ichilled iiih is the-si ~ ;  ( ;  , i ,  . la 11144 ilir P ~ lilll ; lllyhl,vi' . liSeit w:usliill CO li . '- itraille den ~ liigh . Ilnweverinlii . ~ I . hl~sishelll ' llll ~ lsesilliol her:le fini-t ionelf  !4rani liial . ic ; dityilshil ~ II . l  ~ Ms . This dell iiitill n cltnlielisctlt . oc ~ li is traini ~ Cl ii iv . -tl clice . ,; till I'ilrl , lierill Clllr systelliatal OSS fifSiillle crllil:ieni:y  ; l l l d g e l i l r l ' ; ilil . y . For ( ~ Xltlllile , then ~ quircd ; td ditional predicate will need to ni ; tke explicit use of the colnbined RPM . The refilre , a parser will need to produce aI1 . PM representation as its phr , ~ zemarker . The modifications necessary to produce th , , representation is shown hi appemlix B . 

This work describes research clone at the Artificial Intelligence Laboratory of the Massachusetts Institute of Technology  . Sitpport for the Laboratory's artificial intelligence rese  , ' u'c has been provided in part by the Advanced Research Projects Agency of the Depitrt nlent of Defense under Office of NavalRe ' ~ earch contract  N000t-I-80-C-0505  . 
The first author is also filn dnd by a scholarship from the 
Kennedy Memorial Trust.

Bow~ . n  ~ . tal:D . L . Bowo , led . ), L . Byrd , F . C . N . Pert , ira , L . M . 
P,,r( . ira , D . H . I ) . Warre : l . Doc system-lOP rolog User's Man-ira 1 . Hniversity of Edinburgh . t982 . 
Dahlf 4McCord:V . Dahl and M . C . McCord . Tr catiiig Coordination in I aigie Gramtnars . Anit . ric ~ uiJournal of Compu-taii ~ lnal Linguistics . Vol .  9 . No . 2(t983) . 
.Piing . ')?:  . % mdiwayl " ong . To appear in S,'t,L thesis -" . ~ pccifying
C ,, Jrdinatioliill L~lgic "-1985
Goodall ?? . . Grant Todd (; . , . lall . Draft-Chapter 3 ( sections 2 . 1 . 
to 2.7)-C , , irdination.
Goodall . ~ . ~: (; ralit To , hi (: oolhdl , P:lrnlh . lStrltctnr ?, siil , ~ yiltax . 
Ph . D thesis . Uniw . rsity(if CMifi Jruia . San Di . go(tO8,U . 
Lasnik\[ . : Kupin : I1 . La . ~ uikiuid . I . \[~ up in . Ar ~' strictive th ?, or y + J tir . ' iosfi , r' . i latiot l ; d gr ; Imiilar . Th('or ~ . tical I . inl 4 ui : itics , I (19771 . 
Appendix A : Linearization
Thl " fiill Pr . h~gSl l ~ . ilh . ; i i i l n i f l w t h l , l l r l . dicail , lineai ' izei ~ givl . nlll . l(iw . 
/Linenrize f . rg ~' ncr . tion / / tcrmin , din ~) r . n , lition/liu('arizt ' ( pairs SI , '-; I and $2$2 candidates \[ , i . ~ t?liililtyllil ) if lill nvar(l , is /)/ apldicrt thlemhcn , yr . have tlt ' Oltlllliitl . ~ i/lb21/rilltJ/lilil ' . ' triZ ~' ( lulir . ~ SI1'\]1 an , l$2I , ', 9 . 
?lllidid/i/e . 1 List yivtnf !, ~ l . nl,l . llCl ~) if V ; lf~l'lll , lql ? ~) illldnot ~ llllii '( ~ lll . ll ~ ) iliUIlOl ~ illlll!~a . ,I ~ ) and not same ( Simil ~ annil ) and remove Siutih ~ x from St leaving NewS\[ ) and r , ,nove(Siulilar f om $2 lenving NewS2) and line . ' u ' ize pairs NewS1El , rodNewS2E2 candidates List~li , ,ing RestOfSentenee ) and appeud(Similmr RestOl~ ,  . ntenee Seutenee ) /conjoint wo substring a/lim:a rize ( pairs HIEl and $2E ; 2 candidates List giving Sentence ) if var ( Sentence ) attduteutber ( Candl . Cand2 . nilofList ) and not same ( StasEl ) and not same ( S2 as E2 ) and remove ( Coatit from S1 leaving NewSI and removtr ( Calt d2 from $2 l , mvingNewS2) and coltjoin(li . ~ tC and l . Cmtd2 . niluning ' ~ md ' giving Conjoint , l ) and ( lclete(C and t . Coatd2 . nil from List leavin ~ New List ) and linearize ( pair nNi , wSI1~1 and NewS2I~2 candidates Newl , i ~ t yiving Restot ' Sentence ) and append ( Conjoined Rest of S (  , stteuce Sntence ) /Linearize for par  #ing // Terminating cane / in earize  ( pair . qnilnil and nilnil candidates List . giving nil ) if var(List ) anti:am, . (l . ista . sall ),/ Case far common . suh strinf /,/ lill ? . ;,:'it . tr(pairs(' . , , n , mon . N, . wSl nilarid ('( ltllt , lotI . NewS2nil randidate . ~List giving Sentence ) if n , , . wu'(S , . nt? . , w , . : l l l d . ; , ttt'(~t ) Vliltit*Vn . R?' . '-l()f ~'~ t'tthl ! , ' , ' ? , :+~?' Iltt'IICC); , , , 1 li ,  . .arizt,il,air . ~N,~w . qlnil and NewS 2nil caadid ttlcsI . isly , vinyRest()lSentt'tlce)/C' , tne for , ' , , , d , ,in / lilwarizvIl ,  . ir . n . q\[nil?t?t,'l ~ 2 uiralt did qle . s\['~, h'tttt'ltt . f . .t'st , fivinq ` Ht'ittcqtt:e  if ,,, . ., va,'(~,',tt(',tce ) and : tl)l),',,d : ( h,,, . ioi , te , I , lh . stt)f:q, . ,tt, . , , c, . ~/ i , , in ~ S , . ttLt . , , c ? . ) and , ', , , lj , , i , , ( li . ~ll ' lh ', , , , ' , , l , t . ~i , t ! l '; o , ,l " : l , , , irtrJ(h , ttj , hne , l ) and ~ illii ,  . ( l '; h . i,ii . , il . , i . s(:midl . (:at,,12 . uil ) and uot ~ ai , ir(f  ~ a , idt , i . snil ) and n ,) t ~ a,n,'(f:m,d2, t . snil ) and lim . ,triz, . ( patr . ~ N , . wS ! nil and N , , w,H2nil , . utt ditlates I . ?' . ~1 giving R . *' ~ I()I'St'IIt ? ' II , '?') and ; qq-' , td (' and lN , ' wHI , HI ) and ; , pl -' , vlH'a , ,12 N , ,wH2 , H2)/ , lpp , : tttl*i . s , 1 . spi ' rirtlft , rttti , f . , q , p , : , td~'t(m/t that the Jir . ~lliMma,~lb + " rton . , : tttply:q)p , . n,I'(\[h':vl . = tilto"\[';tilyimnt/Ih . ;uI . T ; f i l ) : t p p , . t =, l(I . 'ir~t . Hec,,,d . ():l . .r :: to Till 9tvi ,,/ Fir . ~t . Re . ~Q if : H~l , . tt,l'`Hvc~md . () lh('rsl ,, " l '; ilgiving I h ' . ~ t ) eil , fibu '( ; tii/onil cornn , ~ , lnil ~ t t , ,il;~t'llh';td 1 . I '; dltlo I\[, . ;Ld2 . T , il : 2 common nil ) if . , to t : ; . m , '( I h . adlaaIh '; ul21-it ttil;u'(\[l , . ;ul . ' r ; dlt tolh . ; . I . T ; t i l 2 , . or nmou\[h . mI . R e , t ) if . -hml;zr ('\['; dlllo"\[';d12c ,   ,   , a , n Ilcst/conjoiniare wer . sible/conjoin(lint\[;'irat . Second . ail using Conj , mct giving Conjoined ) if nonwtr ( First ) and nonvar ( Second ) and a pl~end ( 1 ; ' irstConj , mct . Sceond Conjoined ) conjoin ( lintFirst . S~ . wond . uilu . ~ in 9Conjunct giving Conjoiued ) if n , mvar(Conjoined ) attdappend(FirstConjunct . Second Conjoined ) remove ( nil/reinList leavin ~ List remove ( Ih , ad . ' rail from lI ,, ~ x(l . Re~t leaving List ) if remove ( Tail from Rest leaving List ) delete I lead from nillenving nil ) delete ( Head from II , ratl . T , tilleaving Tail ) delete ( fiend frum First . Rest leaving First . Tail ) if not sa , , , , . lI , ! a dan First ) and delete h , ,ul from Rest leaving Tail
Appendix B : Building the RPM
ARP Mrv\[)res, . utali . n , ' mlb ( . Imilt by adding three extraim ramt , t , ,rs to em'h ;; ra . t tmm "'11 h,f)~()ht . r with a call t : oa con-cat . enat . i , mroutine . F , ~ rexaml ) k ', c , msiderth( . verb phra . se " likedMary " fr , , nhe . ~ imph . semem ', . "' John liked Mary " . Thell to noa-trin ~ c-rr , , . ~l ), mdi , tgt . ,~ the mmn-t('rmin;d VP is (' , ) r , structe , l by taking the h . ftm . I righteout , exls . f " liked Mary ; rod placing the non-h . rn , in ids yl = d ),, IVP in l . ,Iwt~ . n them . In geueral , we have ~ . melhing of the form :- phr ; L ~ e ( from Point t to Point2   unin9 Start to End !/ iv/n9 MS . RPM ) if is phrase ( Pointt ,   Point2 RPM and buhlmonostring Start Point lp it = #' VP "
Point 2 End MS ) wirer, . , lilfer once pairs Start . Point t . Point 2 . Endaal Start . Endrepr . s4 . nt the left , ', mt ( . xt . the right context lind the . . ent, . twe string rcsp , ~' tively . Th , " c(mc ; ~ retmtion routim : build-monostring is just : - build monostring  ( Start Point \[ l , ht  #NonTermia al
Point 2 End MS ) if append ( Point lLeftStart ) and append ( Point 2 Right End ) and append ( Lelt Non Termina I . Right MS )
