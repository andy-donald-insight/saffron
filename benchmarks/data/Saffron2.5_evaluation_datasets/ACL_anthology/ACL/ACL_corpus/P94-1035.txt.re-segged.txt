An Attributive Logic of Set Descriptions
Set Operations
Suresh Manandhar
HCRC Language Technology Group
The University of Edinburgh
2 Buccleuch Place
Edinburgh EH8 9LW , UK
Internet : Suresh . Manandhar@ed.ac.uk

Abstract
This paper provides a model theoretic semantics to feature terms augmented with set descriptions  . We provide constraints ospecify HPSG style set descriptions  , fixed cardinality set descriptions , et-membership constraints , restricted universal role quantifications , et union , intersection , subset and disjointness . A sound , complete and terminating consistency checking procedure is provided to determine the consistency of any given term in the logic  . It is shown that determining consistency of terms is a NP-complete problem  . 
Subject Areas : feature logic , constraint-based grammars , HPSG1 Introduction
Grammatical formalisms such as HPSG\[Pollard and Sag  , 1987\]\[ Pollard and Sag , 1992\] and LFG\[Kaplan and Bresnan ,   1982\] employ feature descriptions \ [ Kasper and Rounds , 1986\]\[Smolka ,   1992\] as the primary means for stating linguistic theories  . 
However the descriptive machinery employed by these formalisms easily exceed the descriptive machinery available in feature logic\[Smolk a  ,  1992\] . Furthermore the descriptive machinery employed by both HPSG and LFG is difficult  ( if not impossible ) to state in feature based formalism such as ALE\ [ Carpenter  ,  1993\] , TFS\[Zajac , 1992\] and CUF\[D6rre and Dorna ,   1993\] which augment feature logic with a type system . 
One such expressive device employed both within LFG\[Kaplan and Bresnan  ,   1982\] and HPSG but is unavailable in feature logic is that of set descriptions  . 
Although various researchers have studied set descriptions  ( with different semantics ) \[ Rounds , 1988\]\[ Pollard and Moshier , 1990\] two issues remain unaddressed . Firstly there has not been any work on consi -stency checking techniques for feature terms augmen-ted with set descriptions  . Secondly , for applications within grammatical theorie such as the HPSG forma-lism  , set descriptions alone are not enough since descriptions involving set union are also needed  . Thus to adequately address the knowledge representation needs of current linguistic theories one needs to provide set descriptions as well as mechanisms to manipulate these  . 
In the HPSG grammar for ma-lism\[Pollard and Sag ,  1987\] , set descriptions are employed for the modelling of socalled semantic indices  ( \[ Pollard and Sag , 1987\] pp .  104) . The attribute INDS in the example in ( 1 ) is a multivalued attribute whose value models a set consisting of  ( at most ) 2 objects . 
However multivalued attributes cannot be descri -bed within feature logic\[Kasper and Rounds  , 1986\]\[Smolka ,  1992\] . 

IoDREL--4 ? ~ TIs ~ R\[\]/
Ls ' ~ E ~ wJ\[NDSIRESTINAME ~ and y\]\[' IRESTINAME kimII ? 
LLN*M"DJILLJJJ
A further complication arises since to be able to deal with anaphoric dependencies we think that set memberships will be needed to resolve pronoun dependencies  . Equally , set unions may be called for to incrementally construct discourse referents  . Thus set-valued extension to feature logic is insufficient on its own  . 
Similarly , set valued subcategorisation frames ( see ( 2 ) ) has been considered as a possibility within the HPSG formalism  . 
(2 ) believes = IYNILOCISUBCAT ~\[\[ SYN ~LOOIHEADICATv\]But once set valued sube a tegorisation frames are employed  , a set valued analog of the HPSG subcategorisation principle too is needed  . In section 2 we show that the set valued analog of the subcategorisation principle can be adequately described by employing a disjoint union operation overset descriptions as available wit-hin the logic described in this paper  . 
2 The log ic o f Set descr ip t ions In this section we provide the semantics of feature terms augmented with set descriptions and various constraints over set descriptions  . We assume an alphabet consisting of x , y , z, .   .   . 6)2 the set of variables ; f , g, .   .   . EY : the set of relation symbols ; el , c2, . . . EC the set of constant symbols ; A,B,C, .   .   . 67) the set of primitive concept symbols and a , b ,   .   .   .  6  . At the set of atomic symbols . Furthermore , we require that /, TET ' . 

The syntax of our term language defined by the following BNF definition : P > xI atcIC\[- ~ xI-~a\[-~c\[-~C 
S , T ->
Pf : T feature term
Sf : Texistential role quantification
Vf : Puniversal role quantification f : T1, .   .   . , Tn set description fT1, .   .   , Tn = fixed cardinality set description f : g ( x ) U h ( y ) unionf:g ( x ) rqh ( y ) intersection f : ~ g ( x ) subset f ( x ) #g ( y ) disjointness
SIqT conjunction where S,T,T1, .   .   .   , Tn are terms ; a is an atom ; c is a constant ; C is a primitive concept and f is a relation symbol  . 
The interpretation of relation symbols and atoms is provided by an interpretation Z  =</4 II > where/41 is an arbitrary nonempty set and I is an interpretation function that maps :  1  . every relation symbol f ? ~" to a binary relation fl  C_/4I   x/4I   2  . every atoma ? . At to an element aI ? blx
Notation : ? Let if ( e ) denote the set e '\[ ( e , e ' ) ? if ? Let fI ( e ) Tmeanfl ( e )  =  0 Z is required to satisfy the following properties  :   1  . if al~a2 then all#hi2(distinctness)2 . for any atoma ? At and for any relation f ? ~" there exists no e ? U  1 such that ( a , e ) ? fl ( atomicity ) For a given interpretation Z an Z-assignment a is a function that maps :  1  . every variable x ?\]2 to an element a ( x )  ? 141 2 . every constant c ? C to an element a ( c ) ?/41 such that for distinct constants Cl , c2:a(cl )  #a(c2) 3 . every primitive concept C ? 7 ) to a subset a ( C ) C/41 such that : ? ~ ( _L ) = 0 ? a ( T )   =/41 The interpretation of terms is provided by a denotation function \[\[  . \]\] z , a that given an interpretation Z and an Z -assignment a maps terms to subsets  of/41  . 
The function \[ . \]\] z , a is defined as follows : ~ x ~ z , " =  , ~( x)\[\[a\]\]Z , ~= aI\[cK '"= a(e)
Iv\]z , ~=~( c)
If : T\]z'"=e ?/411 he'?/4i:fZ ( e ) = e'A e'?~T\]z'e \[3f : T~:r'a = e? /4 llqe '? /4   ( l : ( e , e ') ? f ! A e ' ? IT \] z '"
IVf:T\]\]z'~=e?W'lye'?/41:(e , e ') ? f1 = ~ e ' ? If T\]z '"
U : T , , .   .   . , T~K,"=e EUI\[9el, .   .   . , ge~eUI : f1(e ) = el , . . . , e , ^ eleIT1\]z'aA .   .   . A e,~?\[T,~\]z'~
If : T1, .   .   . , Tn =\] z'a = e?/4II9el, .   .   .   , ge~?/4I : If l(e ) l = nAfI(e ) = el ,   .   .   . , enAel ?\[ Tx\]Z'aA .   .   . Ae~?\[T,\]z '"
If : g ( x ) U h ( y ) \]\] z'a = e?LIIIfl ( e ) = gl ( a ( x ) ) U hI ( a ( y ) )
If : g ( x ) Nh ( y ) \] z'a = e?/41\[fi ( e ) = gi ( c  ~ ( x )   ) rqhl ( c  ~ ( y )   )  
If : ~_g(x ) lz , ~' = e?u ~ If ( e ) ~ g1 ( ~ ( x ) ) if ( x ) #g ( y ) \]\]z , c ~= ?0 iff l ( a ( x ) ) n gl ( a ( y ) ) # O ? U I if f1 ( a ( x ) ) A g1 ( a ( y ) ) = 0 IS rl T \]\] z , a =\[\[ S\]\]z , a N\[T\]\]z , a\[-~T ~ , "= U'-\[T ~ z , " The above definitions fix the syntax and semantics of every term  . 
It follows from the above definitions that :
I : T -/: T-I : T =
Figure 1
Although disjoint union is not a primitive in the logic it can easily be defined by employing set disjointness and set union operations : f : g  ( x ) eJh ( y ) = de/g ( x ) #h ( y ) ~ qf:g ( x ) U h ( y ) Thus disjoint set union is exactly like set union except that it additionally requires the sets denoted by g  ( x ) and h ( y ) to be disjoint . 
The set-valued description of the subcategorisation principle can now be stated as given in example  ( 3 )  . 
(3) Subcategorisation Principle
SYN , LOCY\]\]
TRSXn\[HL-DTR\[SYN\[LOC\[SUBCATc-dtrs ( X ) ~ subcat ( Y ) The description i ( 3 ) simply states that the subcat value of the H-DTR is the disjoint union of the subcat value of the mother and the values of C-DTRS  . Note that he disjoint union operation is the right operation to be specified to split the set into two disjoint subsets  . 
Employing just union operation would not work since x = F : TAC ~  ( DFeat ) x = F : yAy = TACsify is new and T is not a variable and Franges over Sf  , fx = Vf : ~ AC ~ ( D For all ) x = Vf : yAy = ~ ACsify is new and ~ ranges over a , c . 
( DSet)x = f : Ti , .   .   . , T~AC~x = I : l, .   .   . , x ~^ xl = T1^ .   .   . ix ~ = T ~ ACs if xi , .   .   .   , xn are new and at least one of Ti : 1 < i < n is not a variable x = f : T i ,   .   .   . , T , = ACs(DSetF)x = f : Xl, .   .   . , xnAX = f : Xl, .   .   . , Xn = AX1 = T1^ .   .   . ixn = TniCs if xi , .   .   .   , x  ~ are new and at least one of Ti : 1 < i < n is not a variable x = SNTAC , ~(DConj)x = Six = TAgs
Figure 2: Decomposition rules it would permit repetition between members of the SUBCAT attribute and C -DTRS attribute  . 
Alternatively , we can assume that N is the only multivalued relation symbol while both SUBCAT and C-DTRS are single-valued and then employ the intuitively appealing subcategorisation principle given in  ( 4 )  . 
(4) Subcategorisation Principle
TRS\[H-DTRISYNILOCISUBCATINN(X)~N(Y)
C-DTR SX
With the availability of set operations , multivalued structures can be incrementally built  . For instance , by employing union operations , semantic indices can be incrementally constructed and by employing members-hip constraints on the set of semantic indices pronoun resolution may be carried out  . 
The set difference operation f : g ( y ) - h ( z ) is not available from the constructs described so far  . However , assume that we are given the term xRf : g ( y ) - h ( z ) and it is known that hZ ( ~ ( z ) ) C_ gZ ( a ( y ) ) for every interpretation 27 , ( ~ such that \[ xRf:g(y)-h(z)~z , ~ ? 0 . 
Then the term xNf : g ( y ) - h ( z )   ( assuming the obvious interpretation for the set difference operation  ) is consistent iff the term y\[\]g:f ( x ) t ~ h ( z ) is consistent . 
This is so since for sets G , F , H:G-F=HAFCGi \]: fG=FWH . See figure 1 for verification . 
3 Consistency checking
To employ a term language for knowledge representation tasks or in constraint programming languages the minimal operation that needs to be supported is that of consistency checking of terms  . 
A term T is consistent if there exists an interpretation  2: and an/:-assignment ( ~ such that \[ T\]z'a ~0 . 
In order to develop constraint solving algorithms for consistency testing of terms we follow the approaches in \[ Smolka  , 1992\]\[Hollunder and Nutt ,  1990\] . 
A containment constraint is a constraint of the form x = T where x is a variable and T is an term  . 
Constraint simplification rules-Ix = yACs  ( SE quals ) x = yA\[x/y\]Cs if x~y and x occurs in Cs ( SConst ) x = ~ A y = ~ ACs x = yAx = ~ ACs where ~ ranges over a , c . 
(SFeat ) x = f : yAx = F : zZACs x = /: yAy = ACs where F ranges over f  , 3f , Vf ( SExists ) x = g f : yAx = Vf : zAC ~ x = f : yAy = zACs ( SF or all E ) x = V__\]:CAx = 9 f : yAC ~_x = V/:CAx = 3 /: yAy = CAC ~ if C ranges over C , - ~ C , - ~ a , -- c , - ~ z and
CsVy = C.
Figure 3: Constraint simplification rules-IIn addition , for the purposes of consistency checking we need to introduce disjunctive constraints which are of the form x--Xl U  . . . Ux , ~ . 
We say that an interpretation Z and an/-ass ignment a satisfies a constraint K written  27  , a ~ K if . 
? Z,a~x = Tv = ~ a(x ) E\[T ~ z'a?Z,a~x = xl U .   .   . Uxn .  : ~  . a(x ) = a(x i ) for some x i : l < i < n . 
A constraint system Cs is a conjunction of constraints  . 
We say that an interpretation 27and an Z-assignment a satisfy a constraint system Cs iff Z  , a satisfies every constraint in Cs . 
The following lemma demonstrates the usefulness of constraint systems for the purposes of consistency checking  . 
Lemma 1 An term T is consistent iff there exists a variable x  , an interpretation Z and an Z-assignment a such that Z  , a satisfies the constraint system x = T . 
Now we are ready to turn our attention to constraint solving rules that will allow us to determine the consistency of a given constraint system  . 

Constraint simplification rules-II ( SSet F ) x = F : yAx = f : Xl ,   .   .   . , xnAC8x = f : yAy = xlA .   .   . A y = xnACs where F ranges over f , Vf ( SSet ) x = f : yAC8x = f : yAC8 ( SD up ) x = f : Xl ,   .   .   . , xi , .   .   . , xj , .   .   . , x,~AC8x = f : Zl, .   .   . , x , .   .   .  ,  .   .   .   , x , ^ C8 if xi--xi ( SF or a U ) x = Vf:CAx = f : xl ,   .   .   .   , xnAC8 x = f :=- C^C8 if C ranges over C , - ~ C , - ~ a , - ~ c , - ~ z and there exists xi : 1 < i < n such that Cs ~1 xi = C . 
x = Bf:yAx = f : Xl, . . . , x,~AC8(SSetE)x = f : Xl, .   .   . , x,~Ay = xlU .   .   . UxnAC8 ( SSetSet ) X = f : Xl, .   .   . , XnAX = f : yl , .   .   . , ymAC8x = I : Xl = Yl II .   .   . IIYm ^? .   . ^ Xn = Yl II .   .   . IIymAYl----xz\[J . . ? II xn A .   .   . AYm = Xl II .   .   . IIx nA68 where n_<mx = xIII .   .   . UxnACs(SD is ) x = XlM .   .   . IJx ~ Ax = xiA C8 if l < i < n and there is no xj , 1 < j < n such that C8F x = x :
Figure 4: Constraint
We say that a constraint system C8 is basic if none of the decomposition rules ( see figure 2 ) are applicable to c8 . 
The purpose of the decomposition rules is to break down a complex constraint into possibly a number of simpler constraints upon which the constraint simplification rules  ( see figures 3 , 4 and 5 ) can apply by possibly introducing new variables . 
The first phase of consistency checking of a term T consists of exhaustively applying the decomposition rules to an initial constraint of the form x = T  ( where x does not occur in T ) until no rules are applicable . 
This transforms any given constraint system into basic form  . 
The constraint simplification rules ( see figures 3 , 4 and 5 ) either eliminate variable equalities of the form x = y or generate them from existing constraints  . However , they do not introduce new variables . 
The constraint simplification rules given in figure  3 are the analog of the feature simplification rules provided in \[ Smolka  ,  1991\] . The main difference being that our simplification rules have been modified to deal with relation symbols as opposed to just feature symbols  . 
The constraint simplification rules given in figure  4 simplify constraints involving set descriptions when they interact with other constraint such as feature constraints-rule  ( SSet F )  , singleton sets-rule ( SSet ) , duplicat elements in a set-rule ( SDup ) , universally quantified constraint-rule ( SF or all )  , another set description-rule ( SSetSet ) . Rule ( SD is ) on the other hand simplifies disjunctive constraints  . Among stall simplification rules - II the constraint simplification rules in figures  3 and 4 only rule ( SD is ) is nondeterministic and creates a nary choice point  . 
Rules ( SSet ) and ( SD up ) are redundant as comple-teness ( see section below ) is not affected by these rules . 
However these rules result in a simpler normal form  . 
The following syntactic notion of entailment is employed to render a slightly compact presentation of the constraint solving rules for dealing with set operations given in figure  5  . 
A constraint system Cs syntactically entails the ( conjunction of ) constraint ( s ) ? if CsF ? is derivable from the following deduction rules :  1  . ? AC8F?2 . C~F x = x3 . C s F x = y > C s F y = x 4 . CsFx = yACsFy = z > CsFx = z5 . C s F x = -~ y > C ~ F y = -~ x 6 . C s F x = f : y > C s F x = 3 f : y 7 . C s F x = f : y > C s F x = V f : y 8 . CsFx = I : .   .   . , xi , .   .   .  >  C~Fz=3I : zi Note that the above definitions are an incomplete list of deduction rules  . However C~I-?implies C~~?where ~ is the semantic entailment relation defined as for predicate logic  . 
We write C8 t /? if it is not the case that C~I-? . 
The constraint simplification rules given in figure  5 deal with constraints involving set operations . Rule ( C _ ) propagates g-values of y into I-values of x in the presence of the constraint x = f :_D g  ( y )  . Rule ( c_ ) x =  if: ( ULeft ) x = if CsConstraint simplification ru les x = f : Dg  ( y ) AC~f:D g ( y ) A z=3 f:Yi ACs
F/x = 3f : yi and
Fy = 3g : yix = I : g ( y ) uh ( z ) Af : g ( y ) Wh ( z ) Ax = f : Dg ( y ) ACs ~/ x = f : Dg ( y )   ( URight ) x = f : g ( y ) U h ( z ) ACsx = f : g ( y ) U h ( z ) Ax = f:D h ( z ) ACs if CsVz = f :__D h ( z )   ( U Down ) x = f : g ( y ) U h ( z ) ACsx = f : g ( y ) U h ( z ) A y = 3g : xiIz = 3h : xiACs if : ? C~/y=3g:x i and ? Cst / z=3h:x i and ? C~l- x=3f : xi ( n Down ) = f : g ( y ) nh ( z ) Ax = f : g ( y ) nh ( z ) Ay = 3g : xiAz = 3h : xiAC if : ? ( Cs\[/y = 3g : xi or CsVz = 3h : xi ) and ? C~F x = 3 f : x~x = f : g ( y ) nh ( z ) ACs ( nUp ) x = f : g ( y ) nh ( z ) A x = 3 f : xiACs if : ? Cs ~ x=3f : xi and ? CsFy=3g:x i and ? C~Fz=3h:x i Figure 5: Constraint solving with set operations ( ULeft )   ( correspondingly Rule ( URight ) ) adds the constraint x = f :_D g ( y )   ( correspondingly x = f : D h ( z ) ) in the presence of the constraint x = f : g ( y ) U h ( z )  . Also in the presence of x = f : g ( y ) U h ( z ) rule ( U Down ) non-deterministically propagates an I-value of x to either ang-value of yo ranh-value of z  ( if neither already holds )  . The notation y = 3g : xi\]z = 3h : xi denotes a non-deterministic choice between y =  3g : x ~ and z = 3h : xi . Rule ( n Down ) propaga-tesanf-value of x both a sag-value of y and h-value of z in the presence of the constraint x = f : g  ( y ) nh ( z )  . 
Finally , rule ( nUp ) propagates a common g-value of y and h-value of z as an f-value of x in the presence of the constraint x = f : g  ( y ) nh ( z )  . 
4Invariance , Completeness and
Termination
In this section we establish the main results of this paper-namely that our consistency checking procedure for set descriptions and set operat ions is invariant  , complete and terminating . In other words , we have a decision procedure for determining the consi-stency of terms in our extended feature logic  . 
For the purpose of showing invariance of our ru -les we distinguish between deterministic and nondeterministic rules  . Among stall our rules only rule ( SD is ) given in figure 4 and rule ( U Down ) are non-deterministic while all the other rules are determini-stic  . 
Theorem 2 ( Invariance ) 1 . If a decomposition rule transforms Cs to C~s then Cs is consistent iff C~is consistent  . 
2 . Let Z , a be any interpretation , assignment pair and let Cs be any constraint system  . 
? If a deterministic simplification rule transforms 
Cs to C's then : iff pc "? If a nondeterministic simplification rule applies to Cs then there is at least one nondeterministic choice which transforms Cs to C's such that : z  , apiff z , apc ; A constraint system Cs is in normal form if no rules are applicable to Cs  . 
Let succ(x , f ) denote the set : succ(x , f ) = yI c8 x = 3 f : yA constraint system Cs in normal form contains a clash if there exists a variable x in  C8 such that any of the following conditions are satisfied :  1  . C~F x = al and C~F x = a2 such that al~a22 . CsFx = cl and CsFx = c2 such that cl~c23 . CsFx = S and CsFx = - , S where S ranges over x , a , c , C . 
4 . CsFx = 3f : y and CsFx = a5 . C ~ F f(x ) ? g(y ) and succ(x , f ) nsucc(y , g ) 7~6 . C ~ F x = f : xz , .   .   .   , xn = and I succ(x , f ) I < n If Cs does not contain a clash then C~is called clash-free  . 
The constraint solving process can terminate as so on as a clash-free constraint system in normal form is fo-und or alternatively all the choice points are exhau-sted  . 
The purpose of the clash definition is high l ighted in the completeness theorem given below  . 
For a constraint system Cs in normal form an equivalence relation ~_ on variables occurring in Cs is defined as follows : x-~y if C~F x = y F or a variable x we represent its equivalence class by Theorem  3   ( Completeness ) A constraint system Cs in normal form is consistent iff Cs is clash-free  . 
ProofSketch : For the first part , let C~bea constraint system containing a clash then it is clear from the definition of clash that there is no interpretation Z and 
Z-assignment a which satisfies Cs.
Let C~bea clash-free constraint system in normal form  . 
We shall construct an interpretation 7~=< L/R, . R >
Let UR = VU , 4tUC.
The assignment function a is defined as follows : 1  . For every variable x in ) 2  ( a ) if C8-x = a then ~ ( x ) = a ( b ) if the previous condition does not apply then ~ ( x ) = choose ( Ix\] ) where choose ( \[ x\] ) denotes a unique representative ( chosen arbitrarily ) from the equivalence class\[x\] . 
2 . For every constant c in C : ( a ) if CsFx = c then a ( c )  =  ( ~ ( x )   ( b ) if c is a constant such that the previous condition does not apply then  ( ~ ( c ) -- c3 . For every primitive concept C in P := I C8 x = The interpretation function . n is defined as follows : ? fR(x ) = succ ( , f ) ? aR = aIt can be shown by a case by case analysis that for every constraint K in C~:  7~  , a ~ K . 
Hence we have the theorem.
Theorem 4 ( Termination )
The consistency checking procedure terminates in a finite number of steps  . 
ProofSketch : Termination is obvious if we observe the following properties :  1  . Since decomposition rules break down terms into smaller ones these rules must terminate  . 
2 . None of the simplification rules introduce new variables and hence there is an upper bound on the number of variables  . 
3 . Every simplification rule does either of the following :  ( a ) reduces the ' effective ' number of variables . 
A variable x is considered to be ineffective if it occurs only once in Cs within the constraint x = y such that rule  ( SE quals ) does not apply . A variable that is not ineffective is considered to be effective  . 
( b ) adds a constraint of the form x = C where C ranges over y  , a , c , C , - ~ y , - ~ a , - ~ c , - ~ C which means there is an upper bound on the number of constraints of the form x = C that the simplification rules can add  . This is so since the number of variables , atoms , constants and primitive concepts are bounded for every constraint system in basic form  . 
( c ) increases the size of succ(x , f ) . But the size of succ(x , f ) is bounded by the number of variables in Cs which remains constant during the application of the simplification rules  . Hence our constraint solving rules cannot indefinitely increase the size of succ  ( x , f ) . 
5 NP-completeness
In this section , we show that consistency checking of terms within the logic described in this paper is NP -complete  . This result holds even if the terms involving set operations are excluded  . We prove this result by providing a polynomial time translation of the wellknown NP-complete problem of determining the satisfiability of propositional formulas\[Garey and Johnson  ,  1979\] . 
Theorem 5 ( NP-Completeness ) Determining consistency of terms is NP-Complete . 
Proof : Let ? be any given propositional formula for which consistency is to be determined  . We split our translation into two intuitive parts : truth assignment denoted by A  ( ? ) and evaluation denoted by r ( ? )  . 
Let a , b, .   .   . be the set of propositional variables occurring in ?  . We translate very propositional variable a by a variable x a in our logic  . Let f be some relation symbol . Let true , false be two atoms . 
Furthermore , let xl , x2, .   .   , be a finite set of variables distinct from the ones introduced above  . 
We define the translation function A (?) by:
A (?) = f : true , falsen3f : xanSf:x bn .   .   . n3f:xln3f:x2n . . . 
The above description forces each of the variable X a  , X b ,  . . . and each of the variables xl , x2, .   . , to be either equivalent to true or false . 
We define the evaluation function T (?) by := xo
T ( S&T ) = T ( S ) nr(T )
T ( SVT ) = x in 3f : (\] : ~( S) , r(T ) n3f : xi ) where xi6x l , x2 ,   .   .   . is a new variable r ( ~ S ) = x in 3f : ( r ( S ) n  ~ z  ~ ) where x i6 x l , x2 ,  .   .   . is a new variable Intuitively speaking T can be understood as follows  . 
Evaluation of a propositional variable is just its value  ; evaluating a conjunction amounts to evaluating each of the conjuncts  ; evaluating a disjunction amounts to evaluating either of the disjuncts and finally evaluating a negation involves choosing something other than the value of the term  . 
Determining satisfiability of ? then amounts to determining the consistency of the following term  :   3 f : A ( ? ) n3f : ( truenr ( ? ) ) Note that the term truenT ( ? ) forces the value of T ( ? ) to be true . This translation demonstrates that determining consistency of terms is NP-hard  . 
On the other hand , every deterministic completion of our constraint solving rules terminate in polynomial time since they do not generate new variables and the number of new constraints are polynomially bounded  . 
This means determining consistency of terms is NP - easy  . Hence , we conclude that determining consistency of terms is NP-complete  . 
6 T rans la t ion to Sch6nf in kel-Bernays class The Schhn finkel-Bernays class  ( see\[Lewis ,  1980\] ) consists of function-free first-order formulae which have  3xt   .   .   . xnVyl ? . .  ym6 In this section we show that the attributive logic developed in this paper can be encoded within the SchSn finkel-Bernays subclass of first -order formulae by extending the approach developed in \[ Johnson  ,  1991\] . 
However formulae such as Vf : ( 3 f : ( Vf:T ) ) which involve an embedded existential quantification cannot be translated into the SchSn finkel-Bernays class  . This means that an unrestricted variant of our logic which does not restric the universal role quantification cannot be expressed within the SchSn finkel-Bernays class  . 
In order to put things more concretely , we provide a translation of every construct in our logic into the 
SchSn finkel-Bernays class.
Let T be any extended feature term . Let x be a variable free in T . Then T is consistent iff the formula ( x = T )   6 is consistent where 6 is a translation function from our extended feature logic into the SchSn finkel-Bernays class  . Here we provide only the essential definitions of  6: ?? = x#a ? ( x = f:T ) ~ = f ( x , y ) &( y = T ) ~ ~ Vy '( f(x , y ' ) -+ y = y ' ) where y is a new variable ? ( x = qf:T ) ~ = f ( x , y )  &  ( y = T ) ' ~ where y is a new variable ? ( x = Vf : a ) ~= Vy ( f ( x , y ) - - + y = a )  ?  ( x = Vf : ~ a ) ~= Vy ( f ( x , y ) . - + y#a ) ?( x = f : T1, .   .   . , Tn ) ~-- f(X , Xl ) & .   .   . ~f(X,Xn ), ~ Vy(f(x , y)--~y = XlV .   .   . Vy = xn)&(xl = T1)& .   .   . &( zl = where Xl, .   .   .   , Xn are new variables ? ( x = f : g ( y ) U h ( z ) ) ~ = Vxi ( f ( x , xi)-'+g(y , xi)V h(z , xi )) ~:
Vy , ( g(y , Yi)-4f(x , Yi )) &
V zi ( h(z , zi)-+f(x , zi ) ) ?  ( x = f : ( y ) #g ( z ) ) ~ = Vyiz j ( f ( y , yi ) & g(z , zi ) --+ Yi #zi )  ?  ( x = SlqT )  '~= ( x = S )  ~ &  ( x = T ) ~ These translation rules essentially mimic the decomposition rules given in figure  2  . 
Furthermore for every atoma and every feature f in 
Twe need the following axiom : ? Vax(-~f(a , x )) For every distinct atoms a , b in T we need the axiom : ? a  #b Taking into account the NP-completeness result established earlier this translation identifies a NP-complete subclass of formulae within the SchSn finkel -Bernays class which is suited for NL applications  . 
7 Related Work
Feature logics and concept languages such as KL-ONE are closely related family of languages \[ Nebel and Smolka  ,  1991\] . The principal difference being that feature logics interpret attributive labels as functional binary relations while concept langua-ges interprethem as just binary relations  . However the integration of concept languages with feature logics has been problematic due to the fact the while path equations do not lead to increased computatio-nal complexity in feature logic the addition of role-value-maps  ( which are the relational analog of path equations  ) in concept languages causes undecidabi-lity\[ Schmidt-Schant3  ,  1989\] . This blocks a straightforward integration of a variable-free concept language such as ALC\[ Schmidt-Schan B and Smolka  ,   1991\] with a variable-free fature logic\[Smolk a ,  1991\] . 
In \[ Man and hax , 1993\] the addition of variables , feature symbols and set descriptions to ALC is investigated providing an alternative method for integrating concept languages and feature logics  . It is shown that set descriptions can be translated into the socalled " number estrictions " available within concept langu-ages such as BACK\[y on Luck et al  ,  1987\] . However , the propositionally complete languages ALV and ALS investigated in \[ Manandhar  ,   1993\] are PSPACE-hard languages which do not support set operations  . 
The work described in this paper describes yet another unexplore dimension for concept languages -that of a restricted concept language with variables  , feature symbols , set descriptions and set operations for which the consistency checking problem is within the complexity class NP  . 
8 Summary and Conclusions
In this paper we have provided an extended feature logic  ( excluding disjunctions and negations ) with a range of constraints involving set descriptions  . These constraints are set descriptions , fixed cardinality " set descriptions , set-membership constraints , restricted universal role quantifications , et union , set intersection , subset and disjointness . We have given a model theoretic semantics to our extended logic which shows that a simple and elegant formalisation of set descriptions is possible if we add relational attributes to our logic as opposed to just functional attributes available in feature logic  . 
For realistic implementation of the logic described in this paper  , further investigation is needed to develop concrete algorithms that are reasonably efficient in the average case  . The consistency checking procedure described in this paper abstracts away from algorithmic considerations and clearly modest improvements to the basic algorithm suggested in this paper are feasible  . 
However , a report on such improvements i beyond the scope of this paper  . 
For applications within constraint based grammar formalisms such as HPSG  , minimally a types y-stem\[Carpenter ,   1992\] and/or a Horn-like extension \ [ HShfeld and Smolka  , 1988\] will be necessary . 
We believe that the logic described in this paper provides both a better picture of the formal aspects of employ set descriptions and at the same time gives a basis for building knowledge representation tools in order to support grammar development within these formalisms  . 
9 Acknowledgments
The work described here has been carried out as part of the EC funded project  LRE-61-061 RGR ( Reusa-bility of Grammatical Resources )  . A longer version of the paper is available in \[ Erbach et al  ,  1993\] . The work described is a further development of the aut-hor's PhD thesis carried out at the Department of Artificial Intelligence  , University of Edinburgh . I thank my supervisors Chris Mellish and Alan Smaill for their guidance  . I have also benefited from comments by an anonymous reviewer and discussions with Chris Brew  , Bob Carpenter , Jochen DSrre and Herbert Ruessink . 
The Human Communication Research Centre ( HCRC ) is supported by the Economic and Social Research
Council ( UK).
References\[Carpenter , 1992\] Bob Carpenter . The Logic of Typed Feature Structures . Cambridge University Press , 1992 . 
\[Carpenter , 1993\] Bob Carpenter . ALE : Attribute Logic Engine Users Guide , Version / ~ . Technical report , Car-negie Mellon University , Pittsburgh , PA 15213 ,  1993 . 
\[ DSrre and Dorna , 1993\] Jochen D Srre and Michael Dorna . CUF : A Formalism for Linguistic Knowledge Representation  . Dyana-2 deliverable , IMS , Stuttgart,
Germany , August 1993.
\[Erbach et al , 1993\] Gregor Erbach , Mark van der Kraan , Suresh Manandhar , M . Andrew Moshier , Herbert Rues-sink , and Craig Thiersch . Specification of Data types . 
In Deliverable D . B of LRE-61-061" The Reusability of
Grammatical Resources ".1993.
\[Garey and Johnson , 1979\] M . R . Garey and D . S . Johnson . Computers and Intractability : A Guide to the Theory of NP-Completeness  . Freeman , San Francisco , 1979 . 
\[ HShfeld and Smolka , 1988\] Markus H Shfeld and Gert Smolk a . Definite relations over constraint languages . LI-LOG Report 53 , IBM Deutschland , Stuttgart , Germany , 
October 1988.
\[ Hollunder and Nutt , 1990\]B . Hollunder and W . Nutt . 
Subsumption Algorithms for Concept Languages . Rese-arch Report RR-90-04 , German Research Center for Artificial Intelligence  ( DFKI )  , Stuhls at zenhaus weg3 ,  6600
Saarbr/icken 11, Germany , 1990.
\[ Johnson , 1991\] Mark Johnson . Features and Formulae . 
Computational Linguistics ,  17(2):131-151 , June 1991 . 
\[Kaplan and Bresnan , 1982\] Ronald M . Kaplan and Joan Bresnan . Lexical-Functional Grammar : A formal system for grammatical representation  . IJoan Bresnan , editor , The Mental Representation of Grammatical Relations  , pages 173-281 . MIT Press , Cambridge , Massachussets , 1982 . 
\[Kasper and Rounds , 1986\] Robert Kasper and William Rounds . A logical semantics for feature structures . In 24th Annual Meeting of the Association for Computational Linguistics  , Columbia University , New York , pages 257-265 ,  1986 . 
\[Lewis , 1980\] Harry R . Lewis . Complexity Results for Classes of Quantificational Formulae  . Journal of Computer and System Sciences ,  21:317-353 ,  1980 . 
\[ Manandhar , 1993\] Suresh Manandhar . Relational Extensions to Feature Logic : Applications to Constraint Based Grammars  . PhD thesis , Department of Artificial Intelligence , University of Edinburgh ,  1993 . 
\[Nebel and Smolka , 1991\] Bernhard Nebel and Gert Smolk a . Attributive description formalisms and the rest of the world  . Research Report RR-91-15 , German Research Center for Artificial Intelligence  ( DFKI )  , 
Saarbr/icken , Germany , May 1991.
\[Pollard and Moshier , 1990\] Carl J . Pollard and M . Drew Moshier . Unifying partial descriptions of sets . In Phi-lip P . Hanson , editor , Information , Language and Cognition . University of British Columbia Press , Vancouver , Canada ,  1990 . Vancouver Studies in Cognitive Science , no .  1 . 
\[ Pollard and Sag , 1987\] Carl Pollard and Ivan Andrew Sag . Information-Based Syntax and Semantics : Volume 1 Fundamentals , volume 13 of Lecture Notes . Center for the Study of Language and Information , Stanford , CA ,  1987 . 
\[ Pollard and Sag , 1992\] Carl Pollard and Ivan Andrew Sag . Head-driven Phrase Structure Grammar : Volume 2 . MIT Press , 1992 . Forthcoming . 
\[ Rounds , 1988\] William C . Rounds . Set values for unification-based grammar formalisms and logic programming  . Technical report , Center for the Study of Language and Information , Stanford , CA ,  1988 . 
\[Schmidt-SchauB and Smolka , 1991\] Manfred Schmidt-Schaufl and Gert Smolk a . Attributive Concept Descriptions with Unions and Complements  . Artificial Intelligence , 48:1-26, 1991 . Also available as IWBS Report 68 , IBM Germany , Scientific Center , IWBS , Stuttgart , Germary , June 1989 . 
\ [ Schmidt-Schaufl , 1989\] Manfred Schmidt-Schaufl . Sub-sumption in KL-ONE is undecidable . In First International Conference on Principles of Knowledge Representation and Reasoning  , KR'89 , Toronto , Canada , pages 421-431 , May 1989 . 
\[Smolka , 1991\] Gert Smolka . A feature logic with subsorts . 
In Jfirgen Wedekind and C . Rohrer ( eds . ), editors , Unification in Grammar . MIT Press , 1991 . Also appeared as LILOG Report no . 33, IWBS , IBM Deutschl and . 
\[Smolka , 1992\] Gert Smolka . Feature constraint logics for unification grammars  . Journal of Logic Programming , 12:51-87, 1992 . 
\[vonLuck et al , 1987\]K . von Luck , B . Nebel , C . Pelta-son , and A . Schmiedel . The Anatomy of the BACK Sy-stem . KIT Report 41 , Department of Computer Science , Technische Universit ~ t Berlin , Berlin , Germany ,  1987 . 
\[Zajac , 1992\]R ~ miZajac . Inheritance and Constraint-Based Grammar Formalisms  . Computational Linguistics , 18(2):159-182, 1992 . 

