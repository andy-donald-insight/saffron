An alternative LR algorithm for TAGs
Mark-Jan Nederhof

Stuhls at zenhaus weg3
D-66123 Saarbr/icken , Germany
E-marl:nederhof@dfki.de
Abstract
We present a new LR algorithm for tree-adjoining grammars  . It is an alternative to an existing algorithm that is shown to be incorrect  . 
Furthermore , the new algorithm is much simpler , being very close to traditional LR parsing for contextfree grammars  . The construction of derived trees and the computation of features also become straightforward  . 
1 Introduction
The efficiency of LR ( k ) parsing techniques ( Sippu and So is a lon-Soininen ,  1990 ) appears to be very attractive from the perspective of natural language processing  . This has stimulated the computational linguistics community to develop extensions of these techniques to general contextfree grammar parsing  . The best-known example is generalized LR parsing ( Tomita ,  1986) . 
A first attemp to adapt LR parsing to tree -adjoining rammars  ( TAGs ) was made by Schabes and Vijay-Shanker ( 1990 )  . The description was very complicated however , and not surprisingly , no implementation f the algorithm seems to have been made up to now  . Apart from presentational difficulties , the algorithm as it was published is also incorrect  . Brief indications of the nature of the incorrectness have been given before by Kinyon  ( 1997 )  . There seems to be no straightforward way to correct the algorithm  . 
We therefore developed an alternative to the algorithm from Schabes and Vijay-Shanker  ( 1990 )  . This alternative is novel in presentational aspects  , and is fundamentally different in that it incorporates reductions of subtrees  . 
The new algorithm has the benefi that many theoretically and practically useful properties carry over from the contextfree case  . For example , by making a straightforward translation from TAGs to linear indexed grammars  , one may identify computations of the parser with rightmost derivations in reverse  . Also the extensions needed for construction of parse trees  ( or " derived trees " as they are often called for TAGs  ) and the computation of features are almost identical to the corresponding extensions for contextfree LR parsing  . 
Section 2 discusses our notation . The algo-rithm for constructing the LR table is given in Section  3  , and the automaton that operates on these tables is given in Section  4  . Section 5 first explains why the algorithm from Schabes and Vijay-Shanker  ( 1990 ) is incorrect , and then provides an example of how our new algorithm works  . Some extensions are discussed in Section 6 , and the implementation in Section 7 . 
2 Notation
For a good introduction to TAGs , the reader is referred to Joshi (1987) . In this section we merely summarize our notation . 
A tree-adjoining grammar is a 4-tuple ( Z , NT , I , A ) , where ~ is a finite set of terminals , I is a finite set of initial trees and A is a finite set of auxiliary trees  . We refer to the trees in IUA as elementary trees  . The set NT , a finite set of nonterminals , does not play any role in this paper . 
Each auxiliary tree has a distinguished leaf , call the foot . We refer to the foot of an auxiliary tree tas F t  . We refer to the root of an elementary tree tas R t  . The set of all nodes of an elementary tree t is denoted by At  ( t )  , and we define the set of all nodes in the grammar by 
A t = U , ruAAt(t).
For each nonleaf node N we define children ( N ) as the list of children nodes . For other nodes , the function children is undefined . 
The dominance relation < J * is the reflexive and fined by N < ~ M if and only if children  ( N ) = aMf ~ , for some ~ , f ~ EA /'* . 
Each leaf N in an elementary tree , except when it is a foot , is labelled by either a terminal from Z or the empty string e  . We identify such a node N labelled by a terminal with that terminal  . Thus , we consider 2: to be a subset of Af , IF or now , we will disallow labels to be e , since this causes a slight technical problem . We will return to this issue in Section 6 , For each node N that is not alea for that is a foot  , we define Adjunct ( N ) as the set of auxiliary trees that can be adjoined at N  . This set may contain the element nilto indicate that adjunction at that node is not obligatory  . 
An example of a TAG is given in Figure 1.
There are two initial trees , alanda2 , and one auxiliary treef LF or each node N , Adjunct ( N ) has been indicated to the right of that node , unless Adjunct(N ) = nil , in which case that information is omitted from the picture  . 
3 Construction of the LR table
For technical reasons , we assume an additional node for each elementary tree t  , which we denote by T . This node has only one child , viz . 
the actual root node Rt . We also assume an additional node for each auxiliary tree t  , which we denote by_L . This is the unique child of the actual foot node F t  . The domain of the function children is extended to include foot nodes  , by defining children ( Ft ) = _L , for each tEA . 
For the algorithm , two kinds of tree need to be distinguished : elementary trees and subtrees of elementary trees  . A subtree can be identified by a pair ( t , N ) , where t is an elementary tree and N is a node in that tree  ; the pair indicates the subtree of t rooted at N . The set of all trees needed by our algorithm is given by : T = IUAU  ( t , N ) It EIUA , NEAf(t ) From here on , we will use the symbolt exclusively to range over IUA  , and r to range over
T in general.
1 With this convention , we can no longer distinguish between different leaves in the grammar with the same terminal abel  . This merging of leaves with identical a-bels is not an inherent part of our algorithm  , but it simplifies the notation considerably . 
For each ~ ET , we may consider a part of the tree consisting of a node N in ~- and the list of its children nodes  7  . Analogously to the notation for contextfree parsing  , we separate the list of children nodes into two lists  , separated by a dot , and write N--~a?f ~ , where a/~=7 , to indicate that the children nodes in a have already been matched against a part of the input string  , and those in fl have as yet not been processed . 
The set of such objects for an elementary tree t is given by: 
P t = ( T ~ . fl)Iafl = RtU(N--~a?f ~) INEAf(t) , children ( N ) = aft
For subtrees ( t,M ) we define:
P(t , M ) = ( N~(~?t ~) IM < FN , children ( N )  =  a/3 Such objects are attached to the trees ~ ET to which they pertain  , to form the set of items :
Items =\[ T,g--~a?fl\]IreT,(Y-+(~ . fl ) EP ~ A completed item is an item that indicates a completely recognized elementary tree or subtree  . Formally , items are completed if they are of the form\[t , T ~ Rt ?\] or of the form \[( ( t , N ) , N -+ a?\] . 
The main concept needed for the construction of the LR table is that of LR states  . These are particular elements from 2 Items to be defined shortly . 
First , we introduce the function closure from 2 Items to 2 Items and the functions go to and go to ? from 2 Items x J ~ f to 2 Items . For any qC_Items , closure ( q ) is the smallest set such that : 1 . qC closure(q ); 2 . \[ r , N--~o ~? M/~\]E closure(q) , nilEAdjunct ( M ) and children ( M ) = 7 implies\[%M-+?7\]E closure ( q )  ;  3 . \[ r , N -+ ( ~? ME \] E closure ( q ) and tEAdjunct ( M ) implies\[t , T-~?Rt\]E closure(q ); 4 .  \[~- , Ft--~?_L\]E closure(q) , tEAdjunct(N ) , NEAf(t ~) and children(N ) = 7 implies\[(t ~ , N ) , N-~?7\]E closure(q ); and 5 . k , i7 . \] e closure ( q ) and k , NaM?8\]E Item simplies\[T , N -+ aM ? fl \] E closure ( q) . 
The clauses 1thru4 are reminiscent of the clo-b ( a2 ) 
U(Z ) de
Figure 1: A tree-adjoining grammar.
dN2 Teb '
Figure 2: An incorrect " parse tree " ( Section 5) . 
sure function for traditional LR parsing . Note that in clause 4 we set out to recognize a subtree ( t ' , N ) of elementary tree tqClause 5 is unconventional : we traverse the tree ~- upwards when the dot indicates that all children nodes of M have been recognized  . 
Next we define the function go to , for any qCItems , and any ME ~7 or MEAf such that Adjunct ( M ) includes at least one auxiliary tree . 
goto(q , M ) = \[ T , N - - + aM , , ~\] \[ \[ T , N--~a ? Mfl\]E closure ( q ) The function go to ? is similar in that it shifts the dot over a node  , in this case the imaginary node J_which is the unique child of an actual foot node Ft  . However , it only does this if t is a tree which can be adjoined at the node that is given as the second argument  . 
goto?(q,M ) = \[7, Ft--~_1_ . \] I\[T,Ft"-+? . k\]E closure(q)AtEAdjunct(M )
The initial LR state is the set q in --\[ t , T -+ , , Rt \] \] t e I  We construct he set Q of all LR states as the smallest collection of sets satisfying the conditions :  1  . q in E0,; 2 . qEQ , MEA /" and q'=go to(q , M ) ~@ imply q~EQ ; and 3 . qEQ , MEA /" and q'=go to?(q , M ) ~ 0 imply q ' EQ . 
An LR state is final if its closure includes a completed item corresponding to an initial tree : 
Q1~n = qEQI closure(q ) n\[t , TR , -\] IteZ )  #  ?0 Final LR states indicate recognition of the input  . Other completed items give rise to a reduction , a type of stack manipulation by the LR automaton to be defined in the next section  . As defined below , reductions are uniquely identified by either auxiliary trees to r by nodes N obtained from the corresponding completed items  . 
reductions(q ) = teA\[\[t,T--+Rt . \]E closure(q ) UNE . hf\[\[(t,N ), N--+a . \] E closure ( q ) For each node N in a tree , we consider the set CS ( N ) of strings that represent horizontal cross -sections through the subtree rooted at N  . 
If we do not want to include the cross-section through N itself  , we write CS(N ) + . A cross-section can also be seen as the yield of the subtree after removal of a certain number of its subtrees  . 
For convenience , each node of an auxiliary tree ( or subtree thereof ) that dominates a foot node is paired with a stack of nodes  . The intuition behind such as tack of nodes \[ N1 ,   .   .   .   , Arm\] is that it indicates a path , the socalled spine , through the derived tree in the direction of the foot nodes  , where each N i , with 1<_i < m , is a node at which adjunction has taken place . 
Such stacks correspond to the stacks of linear indexed grammars  . 
The set of all stacks of nodes is denoted by A/'* . The empty stack is denoted by \[\] , and stacks consisting of head H and tailTare denoted by \[ HIT\]  . We define :
M =  u (  x2 ( *  ) and we simultaneously define the functions CS and CS + from Afto  2 " ~" as the least functions ? CS ( N ) + C_C S ( N )  , for each N ; ?( N , L ) ? CS(N ) , for each N such that N < ~* l , and each L ? A f *; ? N ? CS(N ) , for each N such that -~( N < ~* l) ; and ? for each N , children(N ) = MI""Mm and xl?CS(M1) ,  . .  . , xrn?CS(Mm ) implies zl ' " Xm?CS+(N) . 
4 The recognizer
Relying on the functions defined in the previous section  , we now explore the steps of the LR automaton , which as usual reads input from left to right and manipulates a stack  . 
We can divide the stack elements into two classes . One class contains the LR states from Q , the other contains elements of A4 . A stack consists of an alternation of elements from these two classes  . More precisely , each stack is an element from the following set of strings  , given by a regular expression :
S = qi , (. MQ )*
Note that the bottom element of the stack is always q in  . We will use the symbol A to range over stacks and substrings of stacks  , and the symbol X to range over elements from A4 . 
A configuration ( A , w ) of the automaton consists of a stack A ?$ and a remaining input w  . 
The steps of the automaton are given by the binary relation t-on pairs of configurations  . There are three kinds of step : shift ( Aq , aw)b(Aqaq ' , w ) , provided q '= go to(q , a ) ? 0 . 
reduce subtree ( AqoXlqlX2q2 . . . Xmqm , w)~-(Aq0(-k , \[Y\[n\]) q' , w ) , provided g ? reductions ( qm ) , X 1 .   .   . Xm?CS+(N ) and q'=go to?(qo , N ) ~0 , where L is determined by the following . If for some j(1 < j <_m ) X j is of the form ( M , L ) then this provides the value of
L , otherwise we set L =\[\] . ~ reduce auxtree(AqoXlqlX2q2 .   .   . X rnqm , W ) F-(A q o X q ~ , w ) , provided t ? reductions ( qm ) , X 1 .   .   . Xm?CS(Rt ) and q'=go to(qo , N ) ~ O , where we obtain node N from the ( unique ) Xj ( 1_<j_<m ) which is of the form ( M , \[NIL\]) ,   2Exactly in the case that N dominates a footnote will ( exactly ) one of the X j be of the form ( M , L ) , some M . 
and set X = N if L--\[\] and X = ( N , L ) otherwise ) The shift step is identical to that for contextfree LR parsing  . There are two reduce steps that must be distinguished  . The first takes place when a subtree of an elementary tree t has been recognized  . We then remove the stack symbols corresponding to a cross-section through that subtree  , together with the associated LR states . We replace these by 2 other symbols , the first of which corresponds to the foot of an auxiliary tree  , and the second is the associated LR state . In the case that some node M of the cross-section dominates the foot of t  , then we must copy the associated list L to the first of the new stack elements  , after pushing N onto that list to reflect hat the spine has grow none segment upwards  . 
The second type of reduction deals with recognition of an auxiliary tree  . Here , the head of the list\[NIL\] , which indicates the node at which the auxiliary tree t has been adjoined according to previous bottom-up calculations  , must match a node that occurs directly above the root node of the auxiliary tree  ; this is checked by the test q ' = goto(qo , N ) ~0 . 
Input v is recognized if ( q in , v ) ~-* ( q in Aq , ?) for some A and qEQ/~ ,  . Then A will be of the form X lql X2 q2"'" qm-lXm , where X1 . ." Xm E
CS(Rt ), for some teI.
Up to now , it has been tacitly assumed that the recognizer has some mechanism to its disposal to find the strings XI""X mECS  ( R t ) and XI""XmECS+ ( N ) in the stack . We will now explain how this is done . 
For each N , we construct a deterministic finite automaton that recognizes the strings from CS+  ( N ) from right to left . There is only one final state , which has no outgoing transitions . 
This is related to the fact that CS+ ( N ) is suffix-closed . A consequence is that , given any stack that may occur and any N , there is at most one string XI'"X mECS+ ( N ) that can be found from the top of the stack downwards  , and this string is found in linear time . For each t EIUA we also construct a deterministic finite automaton for CS  ( R t )  . The procedure for tEI is given in Figure 3 , and an example of its application is given in Figure  4  . The procedure for tEA is 3Exactly in the case that N dominates a footnote will
L ?\[\].
949 let K = 0, 7"= ~; let . s = fresh_state , f = fresh_state ; make_fa(f , R t , s ) . 
procedure make_fa(ql , M , q0): let 7"=7"U(qo , M , ql ) ; if children ( M ) is defined then make_fa_list ( ql , children ( M ) , q0) end proc . 
procedure make_fa_list(ql , Ms , q0): if ~= ~ then make_fa(ql , M , qo ) else let q = fresh_state ; make_fa_list(q , aq0); make_fa(ql , M , q ) end proc . 
procedure fresh_state 0: create some fresh object q ; let K = KtJq ; return q end proc . 
Figure 3: Producing a finite automaton ( K , N , T , s , f ) that recognizes CS(Rt ) , given some tEI . K is the set of states , Nacts as alphabe there , 7" is the set of transitions , s is the initial state and f is the ( only ) final state . 
similar excep that it also has to introduce transitions labelled with pairs  ( N , L ) , where N dominates a foot and L is a stack in Af * ; it is obvious that we should not actually construct different transitions for different L E  . hf * , but rather one single transition ( N ,  _) , with the placeholder "_" representing all possible LEAf *  . 
The procedure for CS+ ( N ) can easily be expressed in terms of those for CS ( Rt )  . 
5 Extended example
For the TAG presented in Figure 1 , the algorithm from Schabes and Vijay-Shanker ( 1990 ) does not work correctly . The language described by the grammar contains exactly the strings abc  , a ' b'c ~ , adbec , and a'db'ecq The algorithm from Schabes and Vijay -Shanker  ( 1990 ) however also accepts adb'ec ' and a ~ d be c . In the former string , it acts as if it were recognizing the ( ill-formed ) tree in Figure 2: it correctly matches the part to the " south " of the adjunction to the part to the " northeast "  . Then , after reading c' , the information that would indicate/Figure 4: Example of the construction for CS ( R1 )  , where R1 is the root node of ~1 ( Figure 1) . 
whether a or a ' was read is retrieved from the stack  , but this information is merely popped without investigation  . Thereby , the algorithm fails to perform the necessary matching of the elementary tree with regard to the part to the " northwest " of the adjunction  . 
Our new algorithm recognizes exactly the strings in the language  . For the running example , the set of LR states and some operations on them are shown in Figure  5  . Arrows labelled with nodes N represent the go to function and those labelled with ?  ( N ) represent the go to ? function . The initial state is 0 . The thinlines separate the items resulting from the go to and go to ? functions from those induced by the closure function  .   ( This corresponds with the distinction between kernel and nonkernel items as known from contextfree LR parsing  . ) That correct input is recognized is illustrated by the following : 
Stack Input Step 0 adbecshifta
Oa1dbec shift d
O ald 5 bec shift b
O ald5 b7e creduce N10 ald5 (? , \[N1\])9ec shifte0ald5(? , IN1\])9 el0 creduce/30 alN13 c shift c
Oa 1N 13c6 accept
Note that as soon as all the terminals in the auxiliary tree have been read  , the " south " section of the initial tree is matched to the " northwest " section through the got of unction  . Through subsequent shifts this is then matched to the " northeast " section  . 
This is in contras to the situation when incorrect input  , such as adb ~ ec ~ , is provided to the 1\[~2 , N2~"b'\]1\[/3 , T ~ Aft\]12 ~ b'~o ~2 , N2-->b'-\]\]\[_\[~2 ,   R2  ~  a'N2 ? c'\]~ i~2  -* ~'  N2 ? c'\] 13 b ' 1  \[  o~2  , R2-+a'N2 c' , 1 I\[c ~ 2 , T ~ R2*\]\]\[(o~2 , N2) , N2 ~ b' , \[ a2 , T--+*R21\[o zl , RI-~*a Nlc\]\[o ~2 , R2-~*a'N2c\[/3 , Rfl--~d*Fe\]\[/3 , F --+*_1 . \]\[( cq , N 1 ) , NI"-+?b\]\[(a2 , N2) , N2-+*b'\]\[/3 , F ~_  L . \]\[/3, Rf--+dF?e\]1 oIe\[/3, Rf-+dFe . \]\[/3,T~Rf . \]\[ OZl , N1"-)"*b\]\[/3 , T-~?R~\]/\[/3 , Rf-~*dFe\] .  /  . \[ b~b,\]
R1"-~aN t?c\]\[olt , RI--+aNt*c\]\]6 ~ cc\[al , R1-~a Nlc*\]\[O(1 , T --) . R1 . \]
Figure 5: The set of LR states.

Stack 0 ald 5
O ald 5b '80 ald 5(? , \[~\]) 90 ald 5(? , \[~\])9 el0
Input Step adb'ecI shift adblecI shiftdbl ecI shift btecI reduce  N2 ec'shifte
Ct
Here , the computation is stuck . In particular , a reduction with auxiliary tree/3 fails due to the fact that go to ( 1 , N2) - - - 0 . 
6 Extensions
The recognizer can be turned into a parser by attaching information to the stack elements from  . ~4 . At reductions , such information is gathered and combined , and the resulting data is attached to the new element from Iv\[that is pushed onto the stack  . This can be used for computation of derived trees or derivation trees  , and for computation of features . Since this technique is almost identical to that for the contextfree case  , it suffices to refer to existing literature , e . g . Aho et al (1986, Section 5 . 3) . 
We have treated a classical type of TAG , which has adjunction as the only operation for composing trees  . Many modern types of TAG also allow tree substitution ext to adjunction  . Our algorithm can be straightforwardly extended to handle tree substitution  . The main changes that are required lie in the closure function  , which needs an extra case ( much like the corresponding operation in contextfree LR parsing  )  , in adding a third type of got of unction , and in adding a fourth step , consisting of reduction of initial trees , which is almost identical to the reduction of auxiliary trees  . The main difference is that all Xj are elements from Af  ; the X that is pushed can be a substitution node or a nonterminal  ( see also Section 7 )  . 
Up to now we have assumed that the grammar does not assign the empty string as label to any of the leaves of the elementary trees  . 
The problem introduced by allowing the empty string is that it does not leave any trace on the stack  , and therefore CS ( R t ) and CS+ ( N ) are no longer suffix-closed . We have solved this by extending items with a third component E  , which is a set of nodes labelled with ? that have been traversed by the closure function  . Upon encountering a completed item IT , N - - + ~* , E \] , a reduction is performed according to the sets CS ( R t , E ) or CS+(N , E ) , which are subsets of CS(Rt ) and CS+(N ) , respectively , containing only those cross-sections in which the nodes la-tomaton for such a set is deterministic and has one final state  , without outgoing transitions . 
7 Implementation
We have implemented the parser generator , with the extensions from the previous section . 
We have assumed that each set Adjunct ( N ) , if it is not nil , depends only on the nonterminal label of N . This allows more compact storage of the entries goto ?  ( q , M ): for a fixed state q and nonterminal B , several such entries where M has B as label can be collapsed into a single entry goto ~  ( q , B ) . The got of unction for tree substitution is represented similarly  . 
We have constructed the LR table for the English grammar developed by the XTAG project at the University of Pennsylvania  . This grammar contains 286 initial trees and 316 auxiliary trees , which together have 5950 nodes . There are 9 nonterminals that allow adjunct ? on , and 10 that allow substitution . There are 21 symbols that function as terminals . 
Our findings are that for a grammar of this size , the size of the LR table is prohibitively large . The table represented as a collection of unit clauses in Prolog takes over  46 MB for storage . The majority of this is needed to represent the three got of unctions  , which together require over 2 . 5 million entries , almost 99% of which is consumed by go to , and the remainder by go to x and the got of unction for tree substitution  . The reduction functions require almost 80 thousand entries . There are 5610 LR states . The size of the automata for recognizing the sets CS  ( R t , E ) and CS+(N , E ) is negligible : together they contain just over 15 thousand transitions . 
The time requirements for generation of the table were acceptable : approximately  25 minutes were needed on a standard main frame with moderate load  . 
Another obstacle to practical use is the equivalent of hidden left recurs ? on known from traditional LR parsing  ( Nederhof and Sarbo ,  1996) , which we have shown to be present in the grammar for English  . This phenomenon precludes realization of nondeterminism by means of backtracking  . Tabular realization was investigated by Nederhof ( 1998 ) and will be the subject of further research . 

A noop Sarkar provided generous help with making the XTAG available for testing purposes  . 
Parts of this research were carried out within the framework of the Priority Programme Language and Speech Technology  ( TST )  , while the author was employed at the University of Groningen  . The TST-Programme is sponsored by NWO ( Dutch Organization for Scientific Research )  . This work was further funded by the German Federal Ministry of Education  , Science , Research and Technology ( BMBF ) in the framework of the VERB MOBIL Project under Grant  01 
IV 701 V0.
References
A.V . Aho , R . Seth ?, and J . D . Ullman . 1986.
Compilers : Principles , Techniques , and
Tools . Addison-Wesley.
A . K . Josh ? .  1987 . An introduction to tree adjoining grammars . In A . Manaster-Ramer , editor , Mathematic so/Language , pages 87-114 . John Benjamins Publishing Company . 
A . Kinyon .  1997 . Un algorithmed ' analyse LR ( 0 ) pour les grammaires d ' arbres adjoints lexical is @ es  . In D . Genthial , editor , Qua-tri~me conf drence annuelle sur Le Traitement Automatique du Langage Naturel  , Acres , pages 93-102 , Grenoble , June . 
M . -J . Nederhof and J . J . Sarbo .  1996 . Increasing the applicability of LR parsing . In H . Bunt and M . Tomita , editors , Recent Advances in Parsing Technology , chapter 3 , pages 35-57 . Kluwer Academic Publishers . 
M . -J . Nederhof .  1998 . Linear indexed automata and tabulation of TAG parsing  . In Actes despremikres journ desurla Tabulation en Ana-lyse Syntaxiquet Ddduction  ( Tabulation in Parsing and Deduction )  , pages 19 , Paris , 
France , April.
Y . Schabes and K . Vijay-Shanker .  1990 . Deterministic left to right parsing of tree adjoining languages  . In 28th Annual Meeting of the
ACL , pages 276-283.
S . Sippu and E . Soisalon-Soininen . 1990.
Parsing Theory , Vol . II:LR(k ) and LL(k ) Parsing , volume 20 of EATCS Monographs on Theoretical Computer Science  . Springer-

M . Tomita . 1986. E\]ficient Parsing for Natural
Language . Kluwer Academic Publishers.

