Deriving Transfer Rules from Dominance-Preserving Alignments 
Adam Meyers , Roman Yangarber , Ralph Grishman,
Catherine Macleod , Antonio Moreno-Sandovalt
New York University
715 Broadway , 7th Floor , NY , NY 10003, USA
t Universid ad Aut 6 no made Madrid
Cantoblanco , 28049-Madrid , SPAIN
meyers/roman/grishman/macleod?cs,nyu.edu
sandoval ? lola , lllf.uam.es
1 Introduction
Automatic acquisition of translation rules from parallel sentence-aligned text takes a variety of forms  . Some machine translation ( MT ) systems treat aligned sentences as unstructured word sequences  . Other systems , including our own (( Grishman , 1994) and ( Meyers et al ,  1996)) , syntactically analyze sentences ( parse ) before acquiring transfer rules ( cf . ( Kajiethi . , 1992), ( Matsumotoethi . , 1993), and ( Kitamura and Matsumoto , 1995)) . This has the advantage of acquiring structural as well as lexical correspondences  . A syntactically analyzed , aligned corpus may serve as an example base for a form of example-based NIT  ( cf . ( Sato and Nagao ,  1990) , ( l(aji et al ,  1992) , and ( Furuse and Iida .  1994)) . 
This paper 1 describes: ( 1 ) an efficient algorithm for aligning a pair of source/target language parse trees  ; and ( 9 ) a procedure for deriving transferules from this alignment  . Each transferule consists of a pair of tree fragments derived by " cutting up " the source and target trees  . A set of transfer rules whose lefthand sides match a source language parse tree is used to generate a target language parse tree from their set of right hand sides  , which is a translation of the source tree . This technique resembles work on NIT using synchronous Tree-Adjoining 
Grammars ( cf . ( Abeille et al . 1990)).
The Proteus translation system learns transfer rules from pairs of aligned source and target regularized parses  , Proteus's representation f predicate argument structure  ( cf . Figure 1) .   2 Then it uses these transfer rules to map source tan-l We thank Cristina Olmeda Moreno for work on parsing our Spanish text  . This research was supported by National Science Fotmdation Grant  IRI-9303013  . 
2 Regularized parses ( henceforth , " parse trees " ) are like F-structures of Lexical Ftmction Grammar  ( LFG )  , except , hata dependency structure is used . " guage regularized parses generated by our source language parser into target language regularized parses  . Finally a generator converts target regularized parses into target language sentences  . 
An alignment f is a 1-to-1 partial mapping from source nodes to target nodes  . We consider only alignments which preserve the dominance relationship : If node a dominates node b in the source tree  , then f(a ) dominates f(b ) in the target ree . In Figure 1 . source nodes . 4 . 
B , C and Dmap to the corresponding target nodes , marked with a prime , e . g . , f(A ) = A' . 
The alignment may be represented by the set ( d , A ') , ( B , B ') , ( C , C ') , ( D , D ') . We can assign a score to each alignment f , based on the ( weighted ) number of pairs in f ; finding the best alignmen translates into finding the alignment with the highest score  . Our algorithms are based on ( Farach et al , 1995) and related work . 
We needed efficient alignment algorithms because :   ( 1 ) Corpusbased training requires processing a lot of text  ; and ( 2 ) An exhaustive search of all alignments i too computationally expensive for realistically sized parse trees  . 
Eliminating dominance violations greatly reduced our search space  . Similar work ( e . g . , ( Matsumotoethi . , 1993)) considers all possible matches . Although . our system cannot account for actual dominance violations in a given bitext  , there are no such violations in our corpus and many hypothetical cases can be avoided by adopting the appropriate grammar  . Cases of adjuncts aligning with heads and vice versa are not dominance violations if we replace our dependency analysis with one in which internal nodes have category labels and the head constituents are marked by HEAD arcs and we assume the following Categorial Grammar  ( CG ) style analyses . Suppose that verb ( V i ) maps to adverb ( A'I ) and adverb ( A2 ) maps to verb ( V ' 2 )  , where ("' D = voiver ~ .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  "~  .   .   .   .   . iiiiii: . . . . . . . . . . . . . . . . . . . . . .
Excelvuel vea calcular valores en librode trabajo Excelre calculates values in work book 
Figure l : A Pair of Aligned Trees
A2 modifies V1 and A'l modifies V'2 . We assume the following structures :\[ VP\[ VP1   V1   . . . \]A2\] and\[VP\[VP2V'2 .   .   . \]A'I\] . No dominance violation exists because no dominance relation holds between VI and  A2 or V'2 and A'LY . 
Matsumoto(p . c . ) notes that the subordinate clause of a source sentence may align with the main clause of a target language and vice versa  , e . g . , X after Y aligns with Y ' before X ' . where X , X ', Y and Y ' are all clauses . Assuming a CG style analysis , \[SX\[afterY\]\]aligns with\[SY"\[ before X'\]\] with no dominance violations  . 
2 The Least-Common-Ancestor
Constraint
Our earlier tree alignment algorithms ( cf . ( Meyers et al ,  1996 ) ) were designed to produce alignments which preserve the least common ancestor relationship : If nodes a and b map into nodes a '= f  ( a ) and b '= f ( b )  , then f(LCA(a , b )) = LCA(f(a ) , f(b )) = LCA(a ' , b ') . The least common ancestor ( LCA ) of a and b is the lowest node in the tree dominating both a and b  . The LCA-preserving approach imposes limitations on the quality of the resulting alignments  . \[ n Figure 1 , the LCA-preserving algorithm will match node E with node D ' and report that as the best match overall  . The score S(D ; D ' I would take into account only the match ( E , D ~) , which in turn includes ( B , B ') and ( C , C ') . ( S(D , D ' ) would be penalized for collapsing the arc from D to E  . ) We seek a better alignment scheme , in which the score S(D , D ') could benefit from S(A , A ') . 
We are willing to pay a small penalty to collapse the path from D to E  , and align the resulting structure . This leads to new algorithms where the LeA -preserving restriction is replaced by the weaker  , dominance-preserving constraint . The rationale behind allowing an edge , say ( v , u ) to be collapsed when matching two nodes v and v ~ , is that we may find some children of u which correspond well to some children of v '  , while other children of v correspond well to other children of v '  . ( This is not possible if LCA's are preserved . ) The algorithm relies on the assumption that two different children of v will not match well with the same child of v '  . 
3 The Dominance-Preserving
Algorithm
Let T and T ' be the source and the target trees.
We use a dynamic programming algorithm to compute , in a bottom-up fashion , the scores for matching each node in T against each node in T '  . 
There are O(n2) such scores , n = max(IT\[ , IT'\]) is number of nodes in the trees . Let the d(v ) be the degree of a node v . We denote children of u by v i , i = 1, .   .   . , d(v ), and arc(v , v ) by if . 
For all pairs of nodes vET and v'ET ' , the algorithm computes the score function S(v , v ') . 
S(v , v ~ ) corresponds to the best match found between the subtrees rooted at v in T and at v ~ in T '  . The values of S are stored in a . \[ T\[xIT'I matrix , also denoted by S . \[nitially , we fill the matrix S with undefined values , and invoke the procedure SCORE dom , described below , to compute S(root(T ) , root(T ')) , the score for matching the root nodes of the trees  . During the computation of the score for the roots  , the procedure recursively finds the best-scoring matches for all the nodes in the trees  . This yields the best alignment of the entire trees  . 
Tablel ( a ) shows the values of S for the trees in Figure 1 . Whenever we compute a score fox " internal nodes , we also record the best way of pairing up their children in Table l  ( b )  .   3 The 3 Children pairings include child/child pairs and par-ent/child pairs :  ( D . D ')' s pairing is(A,A'),(E,D') . 
844 alignment , implicit in these children pairings , is used in a later phase ( Section 4 ) to recover the alignment for the entire trees . 
Procedure SCORE dorn : For a pair of nodes , ( v , v ~) , recursively compute the score S(v , v ' ) : Construct an intermediate child-scoring matrix M = M  ( v , v ') , for the children of v and v ~ ; the dimensions of M are ( d ( v ) + i ) x ( d ( v ' ) + t )  . 
That is , the number of rows in M is one more than the number of children of v  , and the number of columns is one more than number of children of v ?  . V ~ relabel row d ( v ) +1 and column d ( v ~ ) +1 with a "*" . Fill the matrix M : 1 . V i , j , where 1 <_i <_d(v) , t < j <_ d ( ? ) compute the corresponding entry in Mij : The function Lex  , ~od~ . (v , v ~ )  >_ 0  ( used below ) is the quality of translation , i . e . the measure of how closely the label ( word ) at source node v corresponds to the label at target node v ~ in the bilingual dictionary  , and Lex ~ c(ff , ff  ~ ) >__0 is the corresponding measure for arc labels . 
2 . Fill the last column as follows : Vi , where t <_i < d(v ) compute the entries :
Mi . = S(vi , v')-Pen(ffi)
Pen ( ffi ) >_0 is the penalty for collapsing the edge ffi , which depends on the value of the label of that edge  . 
3 . Symmetrically , Vjs . t . t_<j <_ d ( v ~ ) fill the last row with the entries :
M . j = S(v , v ;) - Pen(~;)4 . The entry M . . is disfavored : ~,' l ~ . = - ~ c For example , during the calculation of the scores S(D , D ') and S(E , D ') from Tablet ; the corresponding matrices M(D , D ~) and M(E , Dt ) are filled in as in Table 2 . The proper values for the parameter functions used above  , such as the penalty function Pen and the translation in ea-sures  , are chosen empirically , and constitute the tunable parameters of the procedure  . Normally , we will expect hat the values of Lexr , ode will be much larger than the values of Lex~rc and Pen  . 
In the example we used the following settings : 1 . Lex node = 100 for an exact translation , as for ( , 4 ,   . 4'),(B , Bt ) and ( C,C'), and 0 otherwise . 
2 . all values of Lex~care set to zero 3 . all penalties Pen are set to 1Now , using the values in M , compute the score for matching v and ?: S(v , v ') = Lex , ~ od ~( V , v ') + max ~ iYI~j (1)
PEEP(i , j ) EP
Here P is a legitimate pairing of v and its children against v ' and its children  . A legitimate pairing P is a set of elements of the matrix M  . 
that conform to the following conditions : 1 . each row and each column of M may contribute at most one element to P  , except that the row and the column labeled*may contribute more than one element oP  2  . if P contains an element Mij corresponding to the node pair  ( w . w') , and some child node u appears in the Children -Pairing for  ( w , w') , then the row or column of u may not contribute any elements to P  . 
We use / . 7) = ?7)( v . v ' ) to denote the set of all legitimate pairings . There are O(d !) such pairings , where d is the greater of the degrees of u and v  '  . The summation in ( l ) ranges over all the pairs ( i , j ) that appear in a legitimate pairing PE / . 7) ( v , v ') . We evaluate this summation for all O ( d ! ) legitimate pairings in / . 7) , and then select the pairing P be ~ t with the maximum score  . 
P best is then stored in the Children-Pairing matrix entry for  ( v , v ') . 
Table 2 shows how scores are calculated . The best score for S(E , D ~) is 200 , the sum of the scores for ( B , B ') and ( C , C ') . S(D . D ') = 299 = S(A , A ') + S(E , D ') - t , a penalty of t for collapsing the edge from D to E  . 
We can reduce the computation time of the max term in  ( 1 )  , if we do not consider all O ( d ! ) pairings of the children of v and v ' . Instead of exhaustively computing the maximal -scoring pairing P best in  ( t )  , we can build it in a greedy fashion : successively choosthed highest-scoring  , mutually disjoint pairs from the O ( d2 ) possible pairs of children of v and v ' . 
1. Initialize the set of highest scoring pairs
Pb , = ~ te-02 . Phi . ste-P best u(i , j ) where Mij is the next largest entry in the matrix  , which that satisfies both conditions 1 and 2 of legitimate pairings

Target Nodes
A'B'C"D'A'
A 100000A
B010000 B
C00t000 Source C
D000299 Nodes D
E0002 OOE
F0 000 F
Target Nodes
B ' C'D'-(d , A ') ( E , D ')-( B , B ') ( C , C ') Table 1: ( a ) A Final Score Matrix ; (b ) Children-Pairing Matrix

Chil-dren
Target Childrent : A ' 2: B ' 3: C '*: D't:B 0   100   0   99   2: C 0   0   100   99 *: E 0   99   99  -~
The ScoreS(t = tO0+tO0--200


Target Children 1: A ' 2: B ' 3: C '*: D' 1: A 100   0   0   99   2: E 0   99   99   199 *: D 99   98   98 - oc
The ScoreS(=t99+100=299
Table 2: Computing Child-Scoring Matrices 3 . Repeat the above step until no more pairs can be added to P best  , at most d times . 
where d = min(d(v ), d(vl)).
4. Compute the result:
S(V,Y') - - LeZ node(V . V ')-4:-~(i , j)ePb, . ~ , : tii J The greedy algorithm aligns trees with n nodes and maximal degreed in O  ( n2d2 ) time . 
4 Acquiring Transfer Rules
This section describes the procedure for deriving transferules from aligned parse trees  . 
First , the best-scoring alignment is recovered from the Children-Pairing matrix  , ( Table t ( b )) .   4 Start by including the root node-pair in the alignment  , ( here(D , DI )) . Then , for each pair ( v , v ~) already in the alignment , repeat the following steps , until no more pairs can be added to the alignment  :   ( t ) lookup the Children : Pairing for ( v . v '); (2) for each pair in the children-pairing , if it does not include either v or v ~ , add the pair to the alignment , ( e . g . ( A , At ), etc . ) . 
4When sentences in the bitext have multiple parses  , we align structure sharing forests of trees . If one pair of trees has the highest scoring alignment  , we acquire transferules from that alignment . When more than one pair of trees tie for the highest score  , we acquire transfer rules from the set of pairs of aligned subtrees which are shared by each of these high scoring alignments  . 
In the running example , the final alignment ( FA ) is ( D , D ') , ( A , A ') , ( B , S ') , ( C , C ') . 
Based on this alignment we can " chopup " the trees into fragments  , or substructures (( Matsumotoethi . , 1993)) , where each substructure of a tree is a connected group of nodes in the tree  , together with their joining arcs . In Figurei , dashed arrows connect aligned pairs of source and target substructures  . These correspondences become our transferules . 
For each pair of aligned nodes ( v , v ') in FA , there is a pair of substructures in Figure t such that v and v ~ are the roots of the source and target substructures  . These substructures include all unaligned source and target nodes v ~ and ' below v and v '  , which have no intervening Vu aligned nodes yor y ' dominating v  , or v ~ u . 
The transfer rules derived from Figuret may be written as follows:  1  . < root : Excel > --+ < root : Excel > 2 . < root : valores > ~< root : values > 3 . < root : libro , de:trabajo>-+<root:work book > 4 . < root : volver , subj:xl , a : < root : calcular , obj : x2 , en : x3 > > < root : recalculate ; subj:Tr(xl ) , obj:
Tr(x2), in : Tr(x3) >
Each substructure is represented as a list con -value pairs  . An arc ( role ) al with head ( value ) his written as al : h , where h is a fixed label ( word ) , a substructure or a variable . If the source substructure has n of the leaves labeled with variables x l  ,  ? ? . , x  ~ , the target will have n of the leaves labeled with Tr  ( xl )  ,  . . . , Tr(x ~) , where Tr(x ) is the texical translation function . 
This general structure allows us to capture relations between multiword expressions in the source and target languages  . 
5 Translation
The described procedure for acquisition of transfer rules from corpora is the basis for our translation system  . A large collection of transferules are collected from a training corpus  . When new text is to be translated , it is first parsed . The source tree is matched against helefthand sides of the transfer rules which have been collected  . 
If a set of transfer rules whose lefthand sides match the parse tree is found  , the corresponding target structure is generated from the right hand sides of these transfer rules  . Typically , several sets of transfer rules meet this criterion  . They are ranked by their frequency in the training corpus  . Once a target tree has been produced , it is converted to a word sequence by a target language generator  . We have applied this approach to the translation of Microsoft Help files in English and Spanish  . The sentences are moderately simple and quite parallel in structure  , which has made the corpus suitable for our initial system development  . To date , we have been using a training corpus of about 1 , 000 sentences , and a test corpus of about 100 sentences . 
6 Evaluation
Real evaluation of performance of MT systems is time consuming and subjective  . Nevertheless , some evaluation system is needed to insure that incremental changes are for the better  , or at least , are not detrimental . We measured the success of our translation by how closely were produced Microsoft's English  ( target language ) text . Our evaluation procedure computes the ratio between  ( a ) the complement of the intersection set of words in our translation and the actual Microsoft sentence  ; and ( b ) the combined lengths of these two sentences . An exact translation gives a score of 0 . If the system generates the sentence " A B C D E " and the actual sentence is " ABCF "  , the score is 3/9 ( the length of DEF divided by the combined lengths of ABCDE and ABCF  . ) The dominance-preserving version of the program produced output for  88 out of 91 test sentences . The average score for these 88 sentences was 0 . 29:0 . 21 due to incorrect word matches and 0 . 0 8 due to failure to translate because insufficient confidence levels were reached  . The LCA-preserving version produced output for only  83 sentences with an average score of over 0  . 30: about 0 . 23 due to incorrect word matches and about 0 . 08 due to insufficient confidence levels . This crude scoring technique suggests that the dominance-preserving algorithm improved our results : more sentences were translated with higher quality  . One limitation of this scoring technique is that paraphrases are penalized  . An imperfect score ( even . 20) may signify an adequate translation . 
References
A . Abeille , Y . Schabes . and A . K . Joshi .  1990 . 
Using Lexicalized Tags for Machine Translation . In COLING90 . 
M . Farach , T.M . Przytycka , and M . Thorup.
1995 . On the agreement of many trees . Information Processing Letters , 55:297-301 . 
O . Furuse and H . lida .  1994 . Constituent Boundary Parsing for Example-Based Machine Translation  . In COLING94 . 
R . Grishman .  1994 . lterative Alignment of Syntactic Structures for a Bilingual Corpus : In Proceedings of the Second Annual Workshop for Very Large Corpora  , Tokyo . 
H . Kaji , Y . Kida , and Y . Morimoto . 1992.
Learning Translation Templates fi'om Bilingual Text  . In COLING92 . 
M . Kitamura and Y . Matsumoto .  1995 . A Machine Translation System based on Translation Rules Acquired from Parallel Corpora  . In

Y . Matsumoto , H . Ishimoto . T . Utsuro , and M . Nagao .  1993 . Structural Matching of Parallel Texts . In ACL93 . 
A . Meyers , R . Yangarber , and R . Grishman.
1996 . Alignment of Shared Forests for Bilingual Corpora  . In COLING96, pages 460-465 . 
S . Sato and M . Nagao .  1990 . Toward Memory-based Translation . In COLING90, volume 3, pages 247-252 . 

