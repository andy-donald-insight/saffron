SOME COMPUTATION ALPROPER TISS
OFTREE ADJOINING GGAMM . ~. S*
K . Vijay-Shank ~" and Aravind K . Jouhi
Department of Computer and Information ~ e ience 
Room 288 Moore School/D2
University of Pennsylvania
Philadelphia ~ PA 191Ct

Tree Adjoining Grammar ( TAG ) is u formalism for natural language grammars . Some of the basic notions of TAG's were introduced in\[Jo~hi  , Levy , madTakakashiI ~' Sl and by\[Jo~hi , l~l . 
A detailed investigation of the linguistic relevance of TAG's has been carried out in IK roch and Joshi  , 1985~ . In this paper , we will describe some new results for TAG's , espe?ially in the following areas : ( I ) parsing complexity of TAG's , (2) some closure results for TAG's , and (3) the relationship to Head grammars . 
1 . INTRODUCTION lnvestigatiou of constrained grammatical system from the point of view of their linguistic & leqnary and their computational tractability has been a mnj or concern of computational linguists for the last several years  . Generalized Phrase Structure grammars ( GPSG ) , Lexical Functional grunmm ( LFG ) , Phrm ~ Linking grammars ( PLG ) , and Tree Adjoining grammars ( TAG ) are some key examples of grammatical systems that have been and still continue to be investignted along theme lines  . 
Some of the bask notions of TAG's were introduced in\[Joahi  , Levy , and Takahashi , 1975\] and\[Jo~hi , 198 , 3I . Some pretiminav/investigations of the linguistic relevance and some computational proper ties were also carried out in\[Jo~hi  , l ~ S3I . More recently , a detailed iuvestigution of the linguistic relevance of TAG's were carried out by \[ Kro~h and Joshi  ,  19851 . 
In this paper , we will des?ribe some new results for TAG's , especially in the following areas : ( I ) parsing complexity of TAG's , (2) some closure results for TAG's , and (3) the relationship to Head grammar * . These topics will be covered in Sections 3 ,  4 , and $ respectively . In section 2 , we will give an introduction to TAG's . In section 6 , we will state some properties not discussed here . A detailed exposition of these results is given in\[Vijay-Sbuh ~ and Joahi  , 1985\[ . 
* This work wupt rt is J~su . ~ported by NSP Gr ~ u ~* Mk ' TS-4~IOII 6 . ~' ~ R,MCS 42-07 . ~94 . We wtat to thank ClrPol ! ard . Kelly Rozeh , David Se~tad David Weu' . We have be Deflt ~ lenormously I:yv*/uablodi ~* eo ~ iotc with them  . 
822. TREE ADJOINING GGAMMARS--TAG's
We now introduce tree adjoining grammars ( TAG's ) . TAG's are more powerful than CFG's , botb weakly and strongly , lTAG's were first introduced in\[Joshi , Levy , and Takahashi , 1975 J and\[Joehi , 1983 I . We include their description in this ~* ction to make the paper ~ lf-contalned  . 
We can define a tree adjoining grammar as follows . A tree adjoining grammar G is a paw ( i , A ) where i is a set of initial trees , and A is a set of auxiliary trees . 
A tree als an initial tree if it is of the form
GII

I \
I \ eE . r ~ l\
I\l
That m , the root node of a is labelled S and the frontier nodes are all terminal symbob  . The internal nodes are ~11 nonterminals . 
A tree ~ is an acxiliar ? tree if it is of the form ~= X 
I \
I \
I\wle = E
I \ ... .. X .....
V ! V ~
That is , the root node of ~ is labelled with a : on -terminal X and the frontier nodes are all labelled with terminal symbols except one which is labelled X  . The node labelled by X on the frontier will be c ~ dl ~ l the foot node of ~  . The frontiers of initial trees belong to r -* , whereas the frontiers of the auxiliary trees belong to ~ N~U ~'+ N'-'*  . 
~/ e will now define a compoeition operation called adjoining  ,   ( or adlunetion ) which compo6es an auxiliary tree ~ with a tree 3' . 
Let 3' be a tree with a node n labelled X and let ~ be an auxiliary tree with the root labelled with the same symbol X  . ( Note that mnst have , by definition , a node ( and only one ) labelled X on the frontier . ) IGr~nm~u Ol tad G2 mmw * aJtly equivuJ * a * if the for int It a CU * ll * of GI  , I ~ Gimtim J ~ in ? lua?un4pD ot G~~ G2b GItadG:I * . , , *  , troo?ly * quivu Jeot they mmmk l7eq ~ , ivuJe Ittad foretch wUIE , ( GI)~eL(G2) , both Gitad G2 the strneit I~l ~ urld deller iptioll to v . A ~ mrG is ~ lyule qoa ~ for tIPtriDlllMl~ql ~~* if UGI amLG  ~1 Itt'OO?~I~deql\]otdl for bifL ( G ) mhtadforelg ' bwisI ~ G*~iglmam ?* ppmpdm e  , ttuctural description to m . The 8oti ~ a 0 ( ItrOu ?* dequtcT ~ undoobtodlY notpmciNbecsmn it deport  , 4* ol the notion0 ~ zpp~pfiato*tntttu~de ~ . * riptioml Adjoining can now be defined as follows . If  #is adjoined to at the node n then the resulting tree " T t ' is as shown in Fig  .  2 . 1 below . 
7 = ~: $ X / \ / \ / \ / \ node / X \ / \ n I I \ \ - - - X - - - t  3"  =
S/\3'/\~'~vithout
IX\t--/\--/\--x--/\/\+--
FiKure 2.1
The treet dominnted by X in 3' is excised , ~ is inserted at the node n in "7 and the tree t is attached to the foot node ( lab*lled X ) of ~ , i . e . , ~ is inserted or adjoined to the node n in 3' pushing tdownwards , Note that ~ ljoinm g is not a suJmtitutio a operation  . 
We will now define
T ( G ) : The set of alJ trees derived in G starting from initial trees in I  . This set will be called the tree set of G . 
L ( G ) : The set of all terminal strinp which uppe'mr in the frontier of the trees in TIG  )  . This set will be called the string language ( ~r langtiage ) of G . If L is the string language of sTAGG then we say that L is a Tree-Adjoin in ~ I  . angllage ( TAL ) . The relationship between TAG's , contextfree grammmm , and the corresponding string languages can be summarised as follows  ( \[ Joehi , Levy , and Takahashi ,  1975\] , \[ Joshi ,  19831) . 
Theorem 2 . 1: For every contextfree grammar , G ' , there is so equivalent TAG , G , both weakly and strongly . 
Theorem 2 . 2: For every TAG , G , we have the following si to a tious : a . LeG ) is contextfree 3nd there is a contextfree grammar G ' that is strongly  ( cud therefore weakly ) equivalent o



L ( G ) is contextfree and there is 4o coutext ~ freegramma ~ G ' that is equivalent oG . Of course , there must be n contextfree grmmmar that is weakly equivalent to G  . 
L(G ) is strictly context-sensitive . Obviously in this cue , there is no context-freogrammar that is weakly equivalent to G  . 
Part8Ca)~d(e ) of Theorem 2 . 2 appear in (\ [ Jushi , Levy , and Tskahacbi , 19T 5\]) . Pact(b ) is implicit im that paper , but it is impor * ut to state it explicitly as we have done here because of  it8 linguistic significance . ~ mmple2 . 1 illustrates part Ca ) . We will now illustrate p,1~(b ) and ( e) . 
Example 2.2: Let GJ(I , A ) where !:
A ? ~ t = ~ t : e$T
I\I\nT tS
I\I \ lbIb
ST
Let us looks tsome der tvt lons tnG.
" TO : ~:

Ie 3'2 =
Sa/T\/I\/nS\~='I\\
IIb\?T__~....I ~
Ib

Ie~t$/\uT
I\$bi
U ~ t 71  ==  3'0 with ~ I 3'=  =*  3'1 with ~ adjoined at Sam indicated in " f0  . adjoined at T as indicated in ~ . .
Clearly . L(G ), the string language of G is
L - - , . eb . /Q > o which is a contextfree language . Thus , there must exist a context-tree grammar , G ' , which is at least we ~ tkly equivalent to G . \[ t cam be shown however that there is no context  . flee grammar G ' which is strongly equivalent to G  , i . e . , T ( G)I-T ( G') . This follows from the fat that the set T ( G )   ( the tree ~ et of G ) is non-r~o , ~ nizable .  * . e . , there is an finite s t~e bottom-up tree automaton that can recognize precisely T  ( G )  . Thus sTAG ma ~" ~_z contextfree language , ~ ign structural de ~ riptious to the strinAs that cannot be usi~ned by ~ contextfree ~ rammn r  . 
F . ~ xample 2.3: Let G , m(I , A ) where $
I@#t = #==
ST
I\I\m TaS
II\II\
II\II\b ScbTc 8, 3
The precise definition of L ( G ) is as follows : L ( G ) =- Lt = . w?ca/n>o , w is a string of a ' s and b's such that ( 1 ) the number o ( u's I = , the number o(b's--n , and (2) for any initial sube triag of w , the number of a ' s > the number o(b's . LI is a strictly context-sensitive language ( i . e . , s context , , sensitive language that i , not contextfree ) . This can be shown as follows . Intersecting L with the regular language a * b * ? c * results in the language  1~== aabneca/n >>_o=-LtNa'b'ec"i ~ i ~ wellknown strictly context-sensitive language  . The result of intersecting a contextfree language with a regular language is always a contextfree language  ; hence , Lt is not a contextfree language . It is thus a strictly context-feusitive language . Example 2 . 3 thus illustrates part ( e ) of Theorem 2 . 2 . 
TAG's have more power than CFG's . However , the extra power is quite limited . The language Lt bag equal number of a's , b's a ~ d c's ; however , the s's and b's are mixed in a certain way . The Itm guage I ~ is similar to Lt , except that a ' scome before all b's . 
TAG's as defined so far are not powerful enough to generate Lt  . 
This can be seen as follows . Clearly , for any TAG for I . ~ , each initial tree must contain equal number of a ' s  , b's and c's ( including sero ) , so deach auxiliary tree must also contain equal number of a's  , b's and c's . Further in each cue the a's must precede theb's . Then it i ~ easy to see from the grammar of Example  2  . 3 , that it will not be po~ible to avoid getting the a ' s and b's mixed  . However , Lt can be generated by a TAG with local constraints  ( see Section 2 . 1 The socalled copy language . 
t . -we wlw , ~ b " also cannot be generated by sTAG , however , again , with local constraints . It is thus clear that TAG's can generate more than contextfree languages  . It can be shown that TAG's cannot generate all context  , -sensitive languages \[ Jmhi , lg84 J . 
Although TAG's are more powerful than CFG's , this extra power is highly constrained and apparently it is just the right kind for characterizing certain structural descriptions  . TAG's share almost all the formal properties of CFG's  ( more precisely , the corresponding classes of language , ) .  ~ . we shal J see in Net in * 4 of this paper and \[ Vijay-Shankarnd Joehi , 1985 J . In addition , the string languages of TAG's can also be parsed in polynomial time  , in part kular is O(nS . 
The parsing algorithm is described is detail in section  3  . 
  . 1  . TAG's with Lanai Constraints on Ad , Joln ln The adjoining operation as def'med in Seetion  2  . 1 is " contextfree ' . Au auxiliary tree , say,
X/\
I \
I\---X--- is adjoinable to street at a node  , say , n , if the label of that node is X . Adjoining does not depend on thn context ( tree context ) around the node n . In this sense , adjoining is contextfree . 
In \[ Jmhi , 19831 , I~al constraints on adjoining similar to those investigated by \[ Joshi and Levy  , 1977\] were considered . These are a generalization of the context -sensitive constraint studied by \ [ Peters and Ritchie  , 1~9\] . It was so on recognized , however , that the full power of these constraints was never fully utilized  , both in the linguistic context as well as in the " formal languages ' of TAG's  . 
The socalled proper analysis contexts and domination contexts  ( as defined in \[ Jmhi and Levy , 197 T\])as used in\[Joshi , 1 983J always turned out to be such that the context elements were always in a specific elementary tree i  . e . , they were further localized by being in the same elementary tree  . Based on this observation and a suggestion in \[ Jaehi  , Levy and Takahashi , 1975\] , we will deseribe a new way of introducing local constraints  . This approach not only captures the insight stated above  , but it is truly in the spirit of TAG's . The earlier approach was not so , although it was certainly adequate for the investigation in \[ Jmhi  , 1983 J . A precise characterization f that approach still remains an open problem  . 
G--(I , A ) be a TAG with local constraints if for each elementary treetElt  . JA , and for each node , n , in t , we specify the set ~ of auxiliary trees that nan be adjoined at the node n  . Note that if there is no constraint then all auxiliary trees are adjoinable at n  ( of course , only those whose root has the same label as the label of th * nodes  )  . Thus , in general , ~ is a subset o ( the set of all the auxiliary trees adjoiuable at n  . 
We will adopt the following conventions.
1 . Since . by definition , no auxiliary trees are adjoinable to a node labelled by a terminal symbol  , no constraint has to be stated for node labelled by a terminal  . 
2 . If there is no constraint , i . e . , all auxiliary trees ( with the appropriate root label a readioinable at a node  , say , u , then we will not state this explicitly . 
3 . if no auxiliary trees are adjoinable at a node n , then we will write the constraint as ($ ~ , where $ denotes the null set . 
We will al E . ~ allow for the possibility that for a node at least one adjoining is obligatory  , of course , from the set of all ixxmible auxiliary trees adjoiuable at that node  . 
Hence , a TAG with Meal constraints i defined as follows . G = ( I , A ) is a TAG with local constraints dr for each node , n . in each tree t , be speeify one ( and only one ) of the following constraints . 
1 . S , I oetive Adjoin in ~ ~ . qA : ) Only uspecified subset of the set of all auxiliary trees are adjoinable at u  . SA is w-linenaa ( C) , where C is u subset of the set of all auxiliary trees adjoisable at n  . 
If C equals the set of all auxiliary trm adjoinable at n  , then we do not explkitly state this at the node n . 
2 . Null Adjoining ; ( NA :) No auxiliary treeia adjoinable at the , , ode N . NA will be written u(~) . 
3 . Obli ~ at in ~ Adjoining ; OA : ) At least one ( out of all the auxiliary trees adjoiss bleat a ) must be adjoined at n . 
OA is written as ( OA) . or as O ( C ) where C is a subeet of the set of all suxifiacy trees adjoisable at u  . 
I ~--~ amp ~2 . 4: Let G == ( I ~ . ) beuTAG with I~constraints where
I : aIt
SC~)/\~tsS(B2)
II ab
I\I\
I\I\aS(?~)(?~) Sh
In at no anxiliary trees can be adjoined to the root node  . Only ~ t is adjoinable to the left S node at depth  1 and only ~= is adjoinable to the right S node at depth  1  . In ~ t only BI is adjoinuhie at the root node and uo auxiliary trees a tead joinable at the ~  . ~, ~' node . Similarly for ~2 . 
We must now modify our definition of adjoining to take careo  ( the local constraints , given a tree "7 with a node , say , is , labelled A and given an auxiliary tree , say , /J , with the root node labelled A , we define adjoining as follows . ~ is adjoinable to " y at the node n if BE ~ , where ~ is the constraint associated with the node u in  "7  . The result of adjoining d to ~ will be as defined in earlier  , excep that the constraint C ~ . ~sociated with u will be replaced by C ' , the constraint?s sociated with the root node or b and by C '  , the constraint associated with the foot node of ~ . Thus , given " T : ~=
S/\ node n
Ik(C )
I/\
I/\\
II\\
The resultant tree "7' is k ( C ' )  / \ / \ / \ / \ / \  ( C ' ) q , ' I
S/\/\/\/kCC' ) //\\---/\---/\/ A ( C ' )  / / \ \ - -  . /\---/\ We aboad opt the convention that any derived tree with a node which has an OA constraint associated with it will not be included in the tree set associated with a TAG  , G . The string language L of G is then defined as the get of all terminal strings at all trees derived in G  ( starting with initial tre ~ ) whk h have on OA constraints left-in them . 
Example 2 . 5: Let G == ( I , A ) be a TAG with local constraints where : Of--
A : 8=
S(~)/I/I a S/1\/1\hI ?
S(?~)
There are no constraints in at . In ~ no auxilias T trees are adjoina bie at the root node and the foot node and for the center S node there are an constraints  . 
Starting with at and adjoining ~ to at at the root node we obtain ? = 
S(~)
II
II a S
II\
II\b Ic
S (?)


Adjoining ~ to the ceuter S node ( the only node at which adjunction can be made ) we have " I':am
S(~)
II
II , ~ . .~ j " (~ , )  , '/ I " taS ~ ~/ It\ ; /1\/bI?/t'----?'1~--/1\hIe
S(?~)
Il
Itia easy to ~ . e that G generates the string language
L = a ? b'ec'lu > O
Other languages such as L '== aal In ~_~1 , L "== aa = In ~__ 1 aim cannot be generated by TAG's . This is because the strings of a TAL grow linearly  ( for a detailed definite of the property called " contact growth " property  , see\[Jmhi , 1983 I . 
For those familiar with \[ Joehi ,  19&3\] , it is worth pointing out that the SA constraint is only abbreviating  , i . e . , it does not affect the power of TAG's . The NA and OA constraints however do affect the power of TAG's  . This way of looking at local constraints has only greatly simplified their statement  , but it has also Mlowed us to capture the insight that the ' locality ' of the constraint in statable in terms of the elemental/trees themselves ! 
S.2. Simple Llngulntle Exmmphm
We now give a couple of Unguistie examples . Readers may refer ~ o\[Krocb and Joshi , 1985\] for detads . 
I , Starting with ~ fl~mat which is an initial tree and then adjoining  ~1   ( with appropriate lxiea J insertions ) at the indicated node in at , we obtain " ~ : ~ . 
85"~t = Ot =
S/\ ~. VP/\l\
DET ~1 V IP
III\
IIII\~hngirlIDETItmIInsealer the gX rl~nt sen/or  ~1 = mid/\
MP$/\/\~P VP
I/\?YMp
II ant , l

BL 11$/\/\~Mp ~ VP/\~I\~\\~I\
MP\\V ~ P/\,S~I/\
DET 11;/\~ts VET !
Iitlm S\II the girl IlVp/\\\asen /or 
VP\
II/\x
II\notIx ~" pt\\II
The glrl whone tBLllt,*nsealer2 . Starting with the initial tree 3't = a ~ and adjoining 0~ at the indicated node in a , we obtain 7~-3'1 = (~2="~2 = 02 =* S0(02) S ,  / \ / \
MP~pliP VP
I/\I/1\
PROTO~PW/I\/\IVMPS(h)
Vh ' P John I\
IIl\tnvlr , nI persuaded g
II
Iltry B1 11
PRO to invite "1\\
INpyp ~
I /! II\',
IIVMP , ~'(@)
JJoinII . 7\i Ig ~ wv ~
I persuaded I . ~ I/\
XI~ITOVP\i ~ PRO/\% . . Bill ~ V l(P .   .   .   . II
Lnvtt , 1
Iiltr ~
John poma de de LI 1~o X nv Lte M~ry
John persuaded B2 11S
Note that the initial tree cz 2 is not a matrix sentence . In order for it to become a matrix sentence , it must undergo a madjuuction at its root node , for example , by the auxiliary tree ~2 as shown above . 
Thus . for a 2 we will specify a local constraint O ( ~2 ) for the root node , indicating that a 2 requires for it to undergo a madjuuction at the mot node by an auxiliary tree  02  . In a fuller grammar there will be , of course , some alternatives in the scope of O() . 
3. PARSING TREE-ADJOINING
LANGUAGES a.l.l ) efl nlt lonm
We will give a few additional definitio M . Theses renotnecessaW for defining derivations in a TAG as defined in section  2  . 
However , they are introduced to help explain the parsing algorithm and the proofs for some of the closure properties of TAL's  . 
DEFINITION 3 . 1 Let 3', 3" be two tre ~ . We say " r\[--" 3" if in 3' we adjoin an auxiliary tree to obtain 3"  . 
I '-* is the reflexive , transitive closure of \]--- . 
DEFINITION 3 . 2  3" is called a derived tree if 7 I --* 3" for some elementary tree %' We then say " ~' ED ( 'I )  . 
The frontier of any derived tree 3' belongs to either ~~ ~ UN ~ if 7E D (  , ~) for some auxiliary tree 0 . or to ~ if 3' EDq cr ) for some initial tree a . Note if "; , ED(a ) for some initial tree ~ , then 3' is a imasentent taltree . 
If 0 is an auxiliary tre ~ , "7 ED ( 0 ) and the frontier of 3' is wIXw 2 X is a nootermins J . wl . w2E~r ~' ) then the le~node having this nonterminal symbol X at the frontier is called the foot of  3'  . 
Sometimes we will be loosely using the phrase " adjoining with a derived tree "  "7 ED ( ~ ) for some auxiliary tree 0 . What we mean is that suppose we sd joind at some nc ~ le and then sLd join within t ~ and so on  , we can derive the desired derived tree ED ( 0 ) which uses the same adjoining sequence and use this resulting tree to " adioin " at the original node  . 
3.3. The Psrsi.s Alsorlthm
The ~ igorithm , we present here to parse Tree-Adjoining Languages TAL ~  )  , is smodification of the CTK algorithm ( which is described in detailiu\[Abe and UII man , 1073 D , which uses , , dynamic programming technique to parse CFL's . For the sake of making our description of the parsing algorithm simpler  , we shall present he algorithm for parsing without considering local constraints  . We will laters how how to handle local constraints  . 
We shalls . ~ ume that any node in the elementary trees in the grammar has at mos ? two children  . Thm assumption c~m be made without any loss of generality  , because it can be easily shown that for any TAGG the reman equivalent TAGGI such that a my node in a my elementary tree in G t has at mmt two children  . A similar assumption is made in CYK algorithm . We use the term sancestor r and descend ~ at , throughout the paper ms & transitive and reflexive relation  , for example , the foot node may be called the ancestor of the foot and s  . 
The ~ lgoritbm works am follows . Let st . . . % be the input to be posed . We use a fom ~ limeoaio aalrray A ; each element of thesr rny cont4uiu a subset of the nodes o ( derived trm . We say a node X of a derived tree 3" belongs to A ( i , j . k , l JiJrX dominates a subtree o ( 3' whose frontierm given by either = q + a . . . a qYak+i . . .  ~  ( where the foot node of 3'~ labelled by Y ) or ~ q+t-- . ~( i . e . , j , , - k . ~;-(i , j , k , I ) refer to the positions between the input symbols and range over  0 through u . If i == 5 say . the , , it refers to the gap between as and as . 
Initially , we fill Ali , i + l , t + l , i + l \] with those nodes in the frontier of the elementary trees whose label is the same as the input ai+t for  0 < i < n - l . The foot nodes of auxiliary trees will belong to
MIA(i , i , j , jl , such that i_<j.
We are now in a position to fill in 311 the elements of the array A . There are five c~mes to be considered . 
Case 1 . We know that if a node X in a derived tree is the ancestor of the foot node  , and node Y is its right sibling , such that XEA\[i , j , k , II and YEA\[l , m . m , nJ , then their parent , say . Z should belong to A(i , j , k , n\[, see Fig 3 . 1a . 
Case 2 . If the right sibling Y is the ancestor of the foot node such that it belongs to All  , m , n , pJ and its left sibling X belongs to Ai . j . j . lJ , then we know that the parent Z of X and Y belongs to 
Ai,m , n.p , see Fig 3.1 b
Case 3 . If neither X nor its right sibling Y are the ancestors of the foot node  ( or there is no foot node ) then if XEA\[i , J , j , ll and YEA\[I . m . m , nJ then their parentZ belongs to A\[ioj , j,n\[ . 
Came 4 . If ? node Z has only one child X , and if XEA\[i , j , k , l \] , then obviously ZEAi , j , k , ll . 
Ca~e5 . If 3 node XEAIi . j , k , ll , and the root Y of a derived tree "7 having the same label as that of X , belongs to A\[m , i , l . uI , then adjoining " tatX makes the resulting node to be in AIm  , Lk , nl , see Fig 3 . 1c . 
( , ) X "
I \
I \
I \
I \
IZ'\//\\
I/\\
II\\?/V'Y'\//\/\\//\/\\
II\I\\
I ! IIIIt jk1 ? ?( b)x'
I \
I \
I \
I \
IZ'\//\\//\\//\\/V'Y'\/\ I\\//\/\\ 
I/\I\\ .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . X ' .   .   .   .   .   .   .   . 
IIIIIJiJ1 anp ( c ) Y /%/\/\/\/\/\/\/\ .   .   .   .   .   .   .   .   .   . X .   .   .   .   .   .   .   . 

I/\I n/\?/\/\
IIII iJkI
Pill?re3._~I
Although we have stated that the elements of the array contain  3 subset of the nodes of derived trees , what really goes in the reape the addresses of nodes in the elementary trees  . Thus the the size of any set is bounded by a constant  , determined by the grammar . It is hoped that the presentation of the sdgorithm below will make it clear why we do so  . 
3.3. The adl ~ or ithm
The complete algorithm is given below
StepIFori = Oton-I step I do
Step 2 put all node ? in the frontier of e lemnnts rytr ~ who sol~bel  18 ~* tInA\[i . i ? l . i * l . i * l \] . 
Step 3 Fori : Ot on-Is top t do
Step 4 for J : lton-I stop 1 do Step 8 put foot nodes of all auxiliary trees in
Xtt.:.J.J\]
Step 6 For 1:0 ton step I do
Step 7 Fori : l to 0 step-I do
Step 8 For J = i to 1 step I do
Step 9 For k = l to J step-1 do
Step I0 do Cue 1
Step It do Cue2
Step 12 do C~O3
Step 13 do Cue 5
Step 14 do Cue 4
Step 1S Accept if root of somn initial tree EA\[ O  . J , j , n \] , 0 ~ J ~ _ n where ,   ( a ) Case I corresponds to situation where the left sibling is the ancestor of the foot node  . The parent is put in A\[i , j . k . l I if the left sibling is in A\[i , j . k . mI and the right sibling is in Am . p , p , l , where k ~_m < I,m_~p,p ~_I . Therefore Came Imwritten as
For ask to 1-I ~topI do for p = a to I step I do if there i s ? left sibling in A\[t  . J . k . n \] and the right sibling in A\[n . p . p . 1\] sat i s fy ing appropr ia te res t r i c t ionn then put the i r parent in A\[i  , j , k . i\] . 
( b ) Case 2 corresponds to the case where the rightsibliog is the ancestor  , ~ f the foot node . If the left sibling is in A\[i , m . m . pl and the . ghtsibling is in A(p , j , k . II , i--m < p and p~j , then we put their parent in A\[i , j , k , lI . This may be written as
For n : l to J - t stop 1 do
For p = u-t to J step 1 do for ?11 left 8 iblin p in A ( t . n . n , p \] and riKht8i blinp in A\[p . J . k . l \] satlsfyins ? p proprlat n rHC rlct lon8 put ~ heix parents in A ? , j , k . 1 \ ]  . 
87  ( c ) Case 3 corresponds to the cane where ? either children a teance stors of the foot ? ode  . If the left sibling EA\[i , j , j , ml and the right sibling EA(m , p , p01\[then we can p at the parent in A\[i , j , j , lJ if it is the c ~ ,   . that ( i < j_<mori ~ j < m ) and ( m < p ~ lot m_<p < )   , This may be written aefo~s : Jt , ol-tst , upI do for p : J to 1? ~* ptd of ? r . 11 left , sLbl LnKg in A\[i . J , J , n \] and right , sibling si ? A(n , p , p , 1\]?at1?fy1 . nlgt , heap propriate rant , rXcC io ? ? pot their pg wuat , XaA(/ . J . J . I \] . 
( e ) Came 5 correspo?ds to adjoining . If X is n node in A\[m , j , k , pJ  and Y is the root of a a ? xiliary tree with same symbol as that of X  , such that Y is in A\[i , m , p , I \] ( ( i <_ m _< p < ior i < m_< p <_ l Jand ( m < j<k ~ porto~j ~_k < p ) J . This may be writte ? as for ? = ? coJ 8t*p t do for p = u ~ oI stop t do tft node XEA\ [ a  . J . k . p \] and t , heroot , of tuxll X ary tree ~ . ? Ink\[t , a . p,l\]t , heuput,XXnA(i . J , k , l \] Case 4 corresponds to the case where s?ode Y has only one child XIfXEA ~ i  , j , k , ll then put Y in A\[i , j , k , l\[ . Repe~t Case 4 again if Y hasussiblings . 
3 . 4 . Complexity of the Alsorlthm It is obvious that steps  I0 through 15   ( cases a e ) are completed in 0 ( ?-* )  , beta ? an the different cases have at most two nested for loop statements  , the iterating variables taking values in the range  0 thro ? ghu . They are repeated ut most 0(?4) times , because o ( the four loop statements i ? steps 6 through 9 . The initialization phase ( steps 1 through 5 ) has a time complexity of 0 (  ? + ? :  )  == 0 ( ?2 )  . 
Step 15 is completed in O(?) . Therefore , the time complexity of the parsing algorithm is O ( ?S )  . 
3 . 5 . Cot , ~ . et nem of tha Allorlthm The main issue in proving the algorithm correct  , is to show that while computing the contents of an element of the array A  , we must have already determined the contents of other elements of the array needed to correctly complete this entry  . We can show this inductively by considering each cue individually  . We give an ; . u formal argument below . 
Case h We need to know the co?tents of A\[i,j,k . m\[,A\[m,p,p,I \] where m<I,i<m . when we are trying to compute the co?tents or Aii . j , k , l\[ . Since I is they & riable itererated i ? the outermost loop  ( step 6 )  , we can assume ( by indnctio ? hypothesis ) that for all m < I and for all p , q , r , the coate ? ts of A\[p , q , r , mJ are already computed . Hence , the contents of A\[i , j , k , mJ are known . Similarly , for all m > i , and for all p , q , and r <_ . l , A\[m , p , q , rJ would have been computed . Thus , A\[m , p , p , iI would also have bee ? computed . 
Case 2: By ssimilar ream ? lag , the co?tents of A(i , m , m , pJ and A\[p , j , k , lI are known since p < I and p > i . 
Case 3: Woe?we are trying to camp ? rethe contents of some Aii  , j , j , lJ , we need to know the nodes in A(i , j~i , pJ and A\[p , q , q , l\[ . , Notej > i or j < I . tlence , we know that the co?tents of A\[i,j . i , pj and A(p , q , q , l \] would have bee ? compared already . 
Came 5: The co?tents of A\[i , m , p , iJ and A(m , j , k , pJ must be k ? ow ni ? order to compote A(i , j , k , l\[ , where ( i _ < m ~ p < I or i < m < p _ < l ) aad ( m_<j_<k < porto<j_<k_<p )   . Since either m > i or p < I , contents of Alm , j , k , pl will be know ? . 
Similarly , since either m < j or k < p , the co?re?re of A(i , m , p , lI would have been comp?tcd . 
3. S . Pmmlug with Loead Const ~ mlnt 4
So far , we have a ~ , samed that the give ? grammar has ? olocal constraints  , If the grammar has local constraints , it is easy to modify the above algorithm to take care of them  . Note that in Ca~e5 , if an adjunctio ? occurs at a ? ode X , we add X again to the element of the array we are computing  . This seems to be in co?trust with our definition of how to associate local constraints with the ? odes in a se?te ? tial tree  . We should have added the root of the auxiliary tree instead to the element of the array being computed  , since so faru the local constraints are concerned  , this ? ode decides the local constraints at this node in the derived tree  . However , this scheme cannot be adopted in oar algorithm for obvious reasons  . We let pairs of the form ( g , C ) belong to elements of the array , where g is -- before and C represents the local constraints to be associated with this ? ode  . 
We then alter the algorithm as follows . If ( X , CI ) refers to a uode at which we attempt to adjoin with an auxiliary tree  ( whose root is denoted by ( Y , Cs )) . the ? a di?nctio ? would determined by CI . 
If adjunctio ? is allowed , then we can add ( X , Cs ) in the corresponding element of the array . In cases I through 4 , we do not attempto add a new element if anyone of the children has an obligatory constraint  . 
Once it has bee ? determined that the given string belongs to the language  , we ca ? find the parse i ? away similar to the scheme adopted i ? CYK algorithm  . To make this process simpler and more efficient , we can use pointers from the new clement added to the elements which caused it to be put there  . For example , consider Casei of the algorithm ( step 10) . If we add a node Z to A(i . i , k , II , because of the pr~nce of its children X and ? i ? A\[ij  , k , mi and A(m , p , p . q respectively , then we add pointers from this node Zi ? A\[i , j , k , l \] to the nodes X , Yi ? Ai , j , k , mj and A\[m , p , p , l\[ . Once this has been done , the parse c , m be found by traversing the tree formed by these pointers  . 
A paner based o ? the techniques described above is currently being implemented madwi Ube reported at time of presentation  . 
4. CLOSUREPROPERTIESOFTAG's
I ? this6ectio ? , we present some closure resoits for TALe . We now informally sketch the proofs for the closure properties  . 
interested readers may refer to \[ Vijay-Shaakas mad  Jo6hi  , 1985\] for thee L , replete proofs . 
4.1. Closure undem Union
Let Gt and G . z be two TAGs generating LI and l . ~ respectively . 
We c~?e on strnct ' ~ TAGG snch that L ( G ) m'LtUL-a-Le*GI=-11 , At , NI , S ) , and G2 = ( I  ~ , A = , N  ~ . , S ) Without Io ~ of senerality , we may assume that the NINN : e = " h . 
Let G--(IlU12, AtLJA =, NtUN =, S) . We claim that L(G ) : ~ LlLetxELtUL-z . Then xELI or xEI ~ . If xELI , then it must be possible to generate the string x in G  , since 11 , At are in G . HencexEL(G ) . Similarly if xE\[q , we can show that xEL(G ) . 
Hence Lt UL ~ CL(G ) . If xEL(G ) , then x is derived using either only Ij , At or only l ~ , A : t since NII"1N , j = , , ~ . Hence , xEL to rXE t ~ Thus , L(G'--Lt UI ~ Therefore , L(G ) = - LtUL ~ Let Gt--(lt , At , N  ~ , St ) , G ,   , , ,  (\[~ . ~= , N  ~ , S ~) be two TAGs generating Lt , I ~ respectively , such that NII'1N ==-~ . We cam construct ? TAGG =-( I , A , N , S ) such that L(G ) = , , L ! .  !~ . We choo ~ S such that S is not in Nst , JN = . We let N--NtIJN , US , A , mAt UAn . For all ttE ! 1 , t ~ EI , , we add tl :~ to I , as shown in Fig 4 . 2 . 1 . Therefore , ! =-( tl =/ t!E It , t ~ ~ l ~) , where the nodes in the subtrees t t and t ~ of the tree t ~= have the same coustra ~ atmmmocinted with them us in the original grammars G ! and G  =  . it is easy to show that L(G ), mLI . L  ~ , once we note that there are no Nxifia ~ trees in G rooted with the symbol S  , and that NIf3N ,   , md ) . 
s ~ s ~ s t = I\t ~= I\
I\I\
I\I\f"t2:
S/\/\/\/\s,s ~
IXIX /*, t\/~s\
Fib , urn 42 . t4 . 3 . Cloeuru under Kle~negt . m ~ Let Gt = , ( iI , At , NI , S1) be a TAG generating Lt . We can show that we can construct a TAGG G such that L  ( G )  -  . L t * . Let S be a symbol not in Nt , and let NmNIUS . We let the set \[ of initial trees of G be ( re . where te is the tree shown in Fig 4 . 3~ . These to ( auxiliary tree , A is defined u
A = t ~ A / t t ? It UAt.
The treetlA is u shown in Fig 4 . 3b , with the coustraint montheroot of each tlA being the null adjoining constraint  , an constraint ~ on the foot , and the constraints on the nodes of the snb tree e tt of the tre ~ t t A being the same sm thee for the corresponding nodes in the inithd treett of GI  . 
To see why L(G ), mLt *, consider x ~ L(G ) . Obviously , the tree derived ( whose frontier is given by x ) must be of the form ~ how u in Fig 4 . 3? , where each tt ' is a sentent in J tree in GI~UC ht I'ED  ( ti )  , for zn initial tree ti inGt . Thus , L(G ) CLI * . 
On the other hand , if xELs *, then x = - W l . . . wu , wi ~ Lt for 1_<i<n . Let e , u ' hw then be the frontier of t ~ Jesententiai tree ti ' of Gt such that ti ' ~ D  ( t ; ) , tI ~ It . Obviously , we ca8 derive the tree T , using the initial tree t , , and have ? sequence of adjoining operations using the auxiliary trees tl  , ~ for I_<i_n . From Twec , - , obviously obtain the tree T ' the same amgiven by Fig  4  . 3?, using only the mtxifimry tre ~ in At . The fruntiee of T ' is obviously wl . . . w = . Henee , xI~G ) . Therefore , LI*EL(G ) . Thus L(G ) = ~ Us * . 
(*)% = S
In ( b ) ~ IA : $
IX/\
SSt/\/\,rt,t/\(c ) //

IX/X/~\*'~'t$
ISt
SI\
II\.-c',e
T ?
FIgure 4 . 3 4 . 4 . Cloeulm under Intemm ~ tlon with Relgul ~ ur Ima Ku Nlem Let LT be a TAL and LR be a regular language  . Let G be ? TAG generating LT and M = ( Q ,  ~  ,  6  , q0 , QV ) be a finite state automaton recognizing Lit . We can construct a 8ramma : G and will show that L ( GI ) uLTNLR . 
Let a be an elementary tree in G . We shall associate with each node a quadruple ( q t , q2 , % , q4) where q t , q2 , q . l , qiEQLet(qt , %, q . ~, q4) be mare ) tinted with a node X in (~ . Let us assume that a is an auxiliary tree , and that X is an ancestor of the foot node of a . and hence , the ancestor of the foot node of any derived tree " r in D  ( a )  . 
Let Y be the label of the root and foot nodes of ( ~ . If the frontier of 7 ( ' T in D ( o ) ) is w t w 2 Y w s w 4 , and the frontier of the snb tree of rooted at Z , which corresponds to the node X in a is w = Y w ~ . The idea of amso~iating ( qt , q~ , q3 , q  ~ ) with X is that it must be the case that 6? ( qz , w ~) =- q ~ , and ~( q ~ , w =) = , q s . When ~ becomes a part of the seutent i ~ I tree ~" whose frontier is given by u w I w  2 vws w4 w , then it must be the case that 6*( q ~ , v ) == cut . Following this remmoing , we must make q === q~ , if Z is not the ancestor of the foot node of % or if " ~ is in D  ( o ) for some initial tree ( ~ in G . 
We have assumed here , as in the case of the parting algorithm presenf ~edearlier  , that = ny node in ~ y elementary tree has ~ t most two children  . 
From G we cam obtain GI u follows . For each initial tree a , mmociate with the root the quadruple ( q0 , q , q , qr ) where q e is the initial state of the ~ q n i ~ state automaton M  , and ~ EQF . For each auxiliary tree  #of G , associate with the root the quadruple ( ql , q~ , qa , q4) , where q , ql , q= , ch , q 4 a ~ e some variables which will later be given values from Q  . Let X be some node in some elementary tree cL Let  ( ql , q= , o . s,q4) be ~ umocia U ~ l with X . Then , we have to consider the fol ~ ) ' ~ iag cues Cans I " X hi-t woch Udreu Y and Z . The left child y is the ancestor of the foot node of a  . Then zuoeiste with V the quadruple(p,q ~, o . .I , q ) , and ( q , r , r , s ) with Z , and ~ ssociate with X : the constraint that only throe trees whoue root has the quadruple  ( q t , P , s , q4) , among Shone which were allowed in the orism ~ grmmmus  , may be adjoined at this node . If q t p d p , or q4 ~ , is , then the constraint associated with X must be made obligatory  . Lf in the origin . lgruamar X had an obligatory constraint associated with it then we retmm the obligatory constraint regarcllelm of the relationship between q t and p  , mud q4 and s . if the constraint amsccinted with X is a null adjoining constraint  , we seaociate ( q t , q t , CL , , q ) , and ( q , r , r , q4) with Y and Z resp ~ tively , and a amcinte then uU adjoining enustramt with X . If the label o(Z is a . where sE ~ , then we c boous s ~ q such that 6(q , a ) Is . In then uII adjoining constr~ntc~ule , q is cheee u such that 6(q , a ) == q4 . 

CaN 2: This corresponds to the case where ? node X hu two child lt ~ Y and Z  , with ( q t , q~ , ql0qt ) as m?inted at X . \[stZ ( the right child ) be the aucestor of the the foot node the tree a . Then we shall smucint e(p , q , q , r ) , ( r , qs , qa , s ) with Y and Z . The am?s lated cotts traiat with X shaft be that only those trees amour those which were allowed in the nepalf ~ nmlmar may be adjoined provided their root has the quadruple  ( ql , p , s , q4) aaso?inted with it . If q t ~ P or q4 ~r then we make the constraint obligatory . If the original grammar had obfiptory constraint we wifl retm the obfiptory constraint  . NaB constraint in the original grammar will force us to use null constraint ud not consider the cases where it is not the case that q tIp and  q4 ms . If the label of Y is ? terminal'a'thenwe chouser such that  6*  ( p , a ) mr . If the constraint at X is snuU adjoining constraint  , hen ??( q t , a)-r . 
Case 3: This corresponds to the cue where ? either the left child V nor the right child Z of the node X is the ancestor of the foot node of a or if a is a initial tree  . Then qs ~ q8Iq . We will ammeiate with Y and 7 . the quadruples ( p , r , r , q ) and ( q , u , t ) reap . The constraints are assigned as before , in this cuse it is dictated by the quadruple ( ql , P , t , q t ) . \[fit is not the cue that ql " P and q4 umt , then it becomes an OA constraint . The OA and NA constraints at X are treated similar to the previous eMes  , and so is the cue if either Y o1' Z is labelled by a terminal symbol . 
Cuss 4: If ( ql , qt , q~bqt ) is assort ? ted with a node X , which hun only one child Y , then we can de ~ with the various cuse e as follows  . 
We will annotate with Y the q ? adruple(p , qs , q a ~ t ) and the constraint that root of the t ~ , e which can be adjoined at X should have the quadruple  ( q t , P~ , q t ) a mucinted with it amen8 the trees which were a flowed in the original grammar  , if it is to be adjoined stX . The cm where the original grammar bad null or obligatory constraint amocinted with this node or Y is labelled with a term in si symbol  , are treated similar to how we dealt with them in the previous cuses  . 
Once this has been done , let ql , --- , qm  be the independent variables for this elementary tree o  , then we produce as many co~of a so that ql ,  . .-,qm take ad possible value8 from Q . The only di Herenee ? meal the varions copies of cs so produced will be  eonsteaint8 u ~ with the nodes in the trees . Repeathe prose ? for aft the elementary trees in Ga  . Once this has been dome and each treely nn ~ unique name we can write the constraints in terms of them names  . We will now show why L~G1) mUT~LR . 
Let wEI~GI ) . Then there is a sequence of adjoining operations starting with uuinithd tree a to derive w  . Obviowdy , wEL . F , also since corresponding to ensh tree used in deriving w  , there is n corresponding tree in G , which diffem only in the constraints as m ? inted with its nodes  . Note , however , that the coutraints aloe inted with the nodes in tre ~ in Gz are just a reatric tion of the corresponding om in G  , or an obligatory constraint where there wunoes in G  . Now , if we can a mume ( by induction hypothesis ) that if aftern adjoining operation we cam derive "/' ED  ( a ' )  . the ? there is a corresponding tree ~ , ED(a ) in G , which bus the same tree structure as 7' but differm only in the constraints a asociated with the corl~sponding nodes  , then if we adjoin at some . . ode in "7' to obtain ~ t ' . we can adjoin in " T to obtain " f t ( corresponding to " it ' )  . 
Therefore , if w can be derived in Gt , the niteude finitely be derived in G . 
If we can a be 8 bow that l , ( Gt ) ~14 , then we eanconclude that L(GI)~LT/'1Lm . We can use induction to prove this . The induction hypothesis that if all derived trees obtained after k <_n adjein inlg operations have the prepethy P then so will the derived after n +  1 adjoin in p where P is defined as , Property P : If any node X in a derived tree-f bus the foot node of the tree  0 to which X belongs labeDed Y as ? descendant sucb that wzYw = is the fro?tier of the s ? b tree of ~ rooted at X  , then if ( ql , q~ , q . l , q4) had bee ? as ? oct?ted with X , 6* ( q t , wl ) mq = and 6"(q3 , ws)m q4 , and if w is the fro?tier of the subtree under the foot node of  0 i ? "/ is then 6*  ( q~ , w )  ~  q8- if X is not the ancestor of the foot ? ode of 0 then the subtree of 0 below is of the form wtws . 
Suppme X has a so ~ inted with it ( ql , q , q , q2) the ?6*( q t , wl ) -- q , 5* ( q , w , ) = q ,  . 
Actually what we mean by an adjoining operation is not ? eees sarily just one adjoining operation but the minimum number so that no obligatory constraints are am?tinted with any nodes in the derived trees  . Similarly , the base ease need not consider only elementary trees  , but the small eat ( in terms of the number of adjoining operations ) tree starting with elementary trees which h , mnoobligatory constraint annotated with anyo ( its nodes . The base cue can be see ? easily considering the why the grammar wse built  ( it can be shown far ? ally by induction on the height of the tree  ) The inductive step is obvious . Note that the derived tree we are gong to use for adjoining will have the property P  , and so will the trees t which we adjoin ; the former because of the way wed reig?ed the grammar and a miped coa at raints  , and the latter because of induction hypothesis . Thus so will the new derived tree . Once we have proved this , all we have to do to show that L ( GI ) C_LR is to consider those derived trees which axe soots ? t in trees and observe that the roots of these trees obey property P  . 
Now , if n string xELT f3L it , we can show that xEL(G ) . To do that , we make use of the following claim . 
let ~ besn an xilinry tree in G with root labelled Y and let " rED  ( B )  . We claim that the ~ is a B'inGt with the same structure u  0  , such ' that there is n ~ , ' in D ( beta ~ ) )' ) where q ' huthesame structure as % such that there is no OA constraint in ~'  . let X be a node in ~ t which wuused in deriving  ~  ,  . The ? there is n node X ' in ~' such that X ' belo ? p to the anxilliary tree  0 f ( with the same structure as 01- There are several rMes to consider-Case 1: X is the ancestor of the foot node of 01  , such that the fro?tier of the subtree of 0t rooted at X is wsYw 4 and the fro?tier of the subtree or 7 rooted at X is W WlZW ~ Wt . Let 6~( q t , w ) an q , 6* ( q , wt)--q , , 6*(qa , w2) nr , and 6* ( r , wt)--q4 . Then X ' will have ( ql , q , r , q t ) ase ocinted with it , and there will be no OA constraint in Case 2: X is the ancestor of the foot node o ( Of and the frontier of the subtree of 0t rooted at X is wsYw 4  . let the frontier of the subtree of " I rooted at X isWsWlW = Wt  . Then we claim that X'in 7' will have a mucinted with it the q ? adl ~ tple ( q t , q , r , q t ) , if 6* ( ql , wl ) mq , 6* ( q , wl ) mep , 60 ( p , w2) mer , and 6* ( r , wt ) uq4-Case 3: let ' . he frontier of the subtree of 0 t and a Jeo ~ ) rooted at X is W l W = . Let 6*( q , wl ) ap , ~( p , ws ) Ir . Then X ' will have associated with it the quadruple  ( q , p , p , r) . 
We shall prove o?r claim by induction o ? the number of ucl joi ? ins operations used to derive " T  . The buse case ( where -~= = 0 is obvious from the way the Irammar ( it wubuilt . We shall now a mume that for all derived trees % which have bee ? derived from  0 using k or less adjoln in s operatiou , have the proper tyure quire diao?r claim , let " f be a derived tree in 0 after k adjuuctious . By our inductive hypothesis we may ass?me the existence of the corresponding derived tree " T '   ( ED ( 0' ) derived in Gt . Let X bennode in-y as show ? in Fig .  4 . 4 . 1 . The ? the ? ode X ' in 7' corresponding to X will have associated with it the q ? adruple  ( ql ' , cht' , qs' , q t ") . Note we are nan ? in n here that the left child Y ' of X ' is the ancestor of the beasao ? inted with ?' and Z '  ( by the induction hypothesis )  . Let " h be derived from ~ by adjoining ~1 at X as in Fig .  4 . 4 . 2 . We have to chew the existence of ~ t ' in G 1 such that the root of this auxiliar7 tree husaso?ia to d with it the quadruple ( q , qt' , q4" , r ) . The exmtence el the tree follows from induction hypothesis  ( k = ffi0 )  . We have also got to show that there exists "/ t' with the same structure us " f but one that allows  ~1' to be adjoined at the required node . But this should be 8o , since from the way we obtained the tree , in G1 , there will exist ~ t " such that XI'h as the quadruple  ( q , q~' , qa' , r ) and the constraint * at Xl ' are dictated by the quadruple  ( q , qt' , q4e , r ) , b at such that the two children . of Xt ' will have the same quadruple as in 7' . We can no wad join ~ I ' in ~ I " to obtain " h' . It can be shown that ~ t ' has the required property to establish our clam  . 
/\/\/\/\/ x\//\\//\\x/\y // \ \ / \ / / \ \ / \ / / \ / \ \ / \ / / \ / \ \ /  \ / \ / / \ / \ \ / \ / \   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . /\ I\v ' ~ Tv ' = w*tn'=/\/\/x/\lr '! ~ W'  2   e?1 e * 2  ~*  ( q't . v't ) = q'=~*(p,v?t)--'pt&*(q'a . w'~)---p ~*( P t . e'=)=q',
Fl ~ furn 4 . 4 . 1 / \ / \ / \ / \ / \ / \ / \ / \ / / \ \ / / \ \ / / \ \ / / \ \  .   .   .   .   .   .   .   .  / \  .   .   .   .   .   .   .   . 
I \
I \
I \ ......../\ ........
~*( q . x ) fq't&*(q's.y)--r
Fi?~urn 4.4.2
Flatly , any node below the foot of Dr ' in 74' will satisfy our requieement ~ as they are the same as the corresponding odes in  71  * . 
Since BI's at is fies the requirement , it is simple to obas rve that the nodes in ~1' will , even after the adjunctiou of ~1' in " at ' . However , because the quadruple associated with XI ' are different  , the quadruples of the nodes above Xt " must reflect this cbuge  . It is easy to check the existence of an an xK in r ? tree such that the nodes above Xt's at is fy the requirements as ta~labove  . It canalan be argued am the basis of the design of gramme GI  , that there exisu trees which ailow this new auxiliary tree to be adjoined ~ t the appropriate place  . 
This then allows us to conclude that there exmt a derived tree foretch derived tree beiong into D  ( ~ ) as in our claim . The next step is to extend our claim to take into --count all derived trees  ( i . e . , including the sentential trees ) . This can be done in a manner similar to our treatment of derived trees belonging to D  ( ~ ) for some ~ dlinry tree ~ as above . Of course , we have to consider only the cue where the finite state automaton  start8 from the ini?i ~ dsta ~ q0  , and rez ~ be some final state qrouthe input which is the frontier o  ( some esnten * ial tree in G . This , then allow uusto conclude that L~rl'LRCL ( G1 )  . Hence , L(Gt)--LT ~ lLit . 
5. HEADG ~ SANDTAG's
In this section , we attemp to show that Head Grmmmmm ( HG ) are remarkably similar to Tree Adjoining Grammars  . It appes n that the basic intuition behind the two systems is more or less the same  . 
Head Grammars were introduced in ( Pollard , 1084\] , but we follow the notations used in \[ Roach , 10841 . It has been observed that TAG's and HG's share a lot of common formal propertie such as almost identical closure results  , similar pummping lemma . 
Consider the basic operation in Head Grammars - the Head Wrapping operation  . A derivation from n nonterminal produces a pair ( i , a1 . . . ai . . . a  ~ )   ( a more convenient representation for this pan is al  . . . ~ilLl+l . . . a ~) . The arrow denotes the head of the string , which in turn determines where the string is splitup when wrapping operation takes place  . For example , consider X->LL~(A , B ) , and let A = * whlx and B = ~* uglv . Then we say , X = * whugl v x . 
We shall define some functions used in the HG formalism  , which we need here . If A derives in 0 or more steps the headed string whx and B derives ugv  , then q , q , l ) if X->LLI(A . B ) L8a rule ~ utheg Ttmmmx ~ hen
X ds rl veuv hugv x2)L!X->LL~(A . B ) ts * ruln ? n ~ he grammar ~ hnu
X derl vesv hugv x 4.
3) if X->LCt(A . B ) Lsarulo In the grammar then
X dert vnuv hxug v4) if X->LC~(A . B ) in a rule \ [ n the granm ~ r then
X durl veev hxtt ~ r4 b
Nov consider hoeuder tv . tlon LnTAGs proceeds-Let ~ be an auxilliary tree and let ~ bensentential tree as in Fig  5  . 1 . Adjoining ~ at the root of the subtree ~ gives us the senteutia Jtree in Fig  5  . 1 . Weeros , now see how the string whx has ? wrapped around * the subtree i  . e , the stringugv . This seems to suggest that there is something similiarm the role played by the foot in an auxilliary tree and the head in a Head Grammar how the adjoining operations and head-wrapping operations operate on strings  . We could say that if X is the root of ~ auxilliary tree t ~ and al  . . . xiXa ~+ t . . . a ~ is the frontier o(a derived tree ~ ED(~ , then the derivation of 7 would correspond to a derivation from a nonterminal X to the string al  . . . a41 ai?t . . . a ~ in HG and the use of 7 in some senteutial tree would correspond to how the string sal  . . . a5 and ~? t . . . a ~ are used in deriving , string in HL . 
a = S/\/\/X\//-\\//---\ \~_~_'7 ugv$/\/\!\/x\ , hT-~-xu ~ ~= X/\/\/\/X\v h?ri ~ r , s . J1 relationship of TAL'o and HL's . It is more convin/ent for us to think of the headed string  ( i , at . . . sl ) as the string ? t . --~ with t be head pointing in between the symbok I  4 and 14+t rather than at the symbol 14  . The defmition of the dehvation ? per ? tom can be extended hi~stra/ghtforward manner  t4  ) take this into account . However , we c ' ~" ? cheers the S2rne effect by considering the dermitions of the Sl imier ? LLJ ~ C  , ete . Pollard suggests tha * cases such as IJ ~ , ~) be IcRu " dermed . We shrift-'~,ume thai if ~"--, . by then LI ~ . ~) ~ ,  ?  , h  ~ , LC ~) -- ~ , LC  ~ , ~) - - ~  , '- C , ~L ;) -- ~ , ~ C , (; , X ) -- ~ ,  = . ~ Lc , (~, ; ) = ~ . 
~' e , the ~ say that if G is n He~d Grammar , then wI-=w bx belongs ? 4 ) L ( G ) if and only if S derives the headed string wbx ' ror whXx  . 
With this new definition , wesh silshow , without givin ~ the proof , ~ hat the ci ~ of TAL's is ensnared hit he chum of HL's  . by systematically coever thi Sany TAGG to nHGG  '  . We shaft assume , without loss of general/t )' , that the constra/nts expressed at the nodes of elementary trees of G~re-I  ) Nothing can be ? de ? heeds t ? node ( NA )  ,  2 ) Any appropriat ~ tree ( ~mbob at the node and root of the ~* uxil limry tree must marsh  ) can be adjoined ( AA )  , or 3) Adjoining at the node is ? brig ? tory ( OA ) . 
It is e a ~?4 ) show that these constra/nts are enough , and that selective adjoinhig can be expressed in terms of these and additiom d nonterminals  . We know give ? proted nrzi deseriptioe of obtaining an equivalent Head Crammat from ? Tree * Adjoining Grammar  . The procedure works u follows . It k are eumve procedure ( Couvert_to_HG ) which takes in two patamets rs , the first representing the node o e which it k being ? pplied and the ~ e ~ ood the label appearing on the lefthand side of the HG productions for this node  . ffX is a ~ on terminal , for each auxiliary tree ~ whose root huthel a bel X  , we obtain ? sequence of production-such that the rmst one has X on the lefthand side  . Using these productions , we can defoe the string Wl ~ W ~ where n derived tree in D  ( ~ ) has ? frontier wiY w ~ . ffY is ? Y sode with with IsJ ) ei X in some tree where adjoining is allowed , we introduce the productions T '-> L~(x . r ) so then . s derived t . ree with root ln belXnnywrl ~8~' ovad the 8t . r in 4 derived from then b t . reobelow ? . hie node ~ r -> L~t(A1 .   .   .   .   . Aj )    anmu*4q that there exo J children of this node and the In k child t ? the ancestor of the foot node  . Bycedllngt . he procedure recurst vely for ill the Jch Lldren of T with At  . kr ~ nlrlng frox I throuKhJ , vecns derive from I1' the front . ?er of the subtreobe lo~YT'->I'thiniut ~ h and let*hn cue where no ad Juc ~ on~d~nsplace ? tT  ) If G is sTAG then we do the following-
Repeat for every In?t 182 tree
Convert to RG ( root , S ' )   ( S " will be the 8t 4u-t symbol of the nov Heed (  ; r e = , -- , ' . 
Repe&t * for o ~? hAmctll ta ~- ytr ~
Conret ~ mJ  ~( root . roo~lm lol ) where Cc are z ~ ~ oHG ( n~te . nwso ) Indettnsd- . . fo l lmm
L ! undo18 an index . a LlnodetJmncnsnII ! tJm~mstr~tntn~~hn node  t8 A & add product , ions$~I->LLu(node syubol . I ') . 
'-> LCt(At ', .   .   .   . A t ', .   .   .   . Aj ') S\]m->LCt(At' .   .   .   .   . A t ', .   .   .   . A ') ? here II ' . A t ', ~' .   .   .   . A ' are , , mr ? ou-ten Ltna ~ synbole , A ! .   .   .   .   . A correspond t . otheJ chlldre not the nodes adl=l If foot , node is not *? descund . .mt * of node else =1 ? u cht*h&t * the 1 ~ child of ? ode is an can ~ r of foot * node , J = u Qber of chiZ dreu of ? ode for Im-I coJsup I do Convert  , to HG ( k ~ child of ? ode . A t ') . 
Cue2 The conet.r~tnt*?t*~bn node LsJUt.
Sueu Cue1 except don't * add the product * lone
S~m->LLt(node8 ~ mbol.r).
II*->LCt(AI'.....A').
Cue 3The constrnints t , the node l ?0A.
Stsean CueI except , that * we don't , a4d
Syx->t . Ct(At ', . . . A j ') else if * . he node hu?ter nl?s3, synbol ? . 
then add the production gyx->~ , el ? eit 1? ? foot * node it the cons & taint * at , the foot . node is AA then , dd the product * io nn__
Syx->ill(nodesyxbol,~)/~it the con?t . rx . i a t * t ?0 A then add on X y the product . ion
Syu->l.t1(nodeslnt ~ I.~)
L ! the cgnetl " ~ nt*ilgA add the product.ion
S ~ w ->. ~
We sh~dl now xive so example of converting ? TAGC to sHG  . Gcoeta~s ? single initia Jtr~o , and ? single suxiliar 7 tree as in Fig .  5 . 2 . 
$ a = I ~ =
Ftf ~ ur . S . . ~2
I \
I\aS
It \
II\/I\bs(~)c
Obviou S , L ( Cl--so ~ c -/?_> 01 obtain the HG whose productions are given by-s'- ~ LL  ~  ( S , A)
A->s->L % ( B.?)
B->I\[c->LL~(S,D)/O0->I.Ct(Z.F.G)->'~
F -> " ~- ) - ~- vhtch can be re ~ r ~ t tenus ' -> s/~
S->LC t(a , X ') ~'-> LL~(S , ~c ) or ~'-> u~(s , ~ c ) It can be vurifte ~ ChatChing rums r generates exactly 

It is worth emphasising that the main point of this exercise wU to show the ~ imilarities between He ~ J Grammars and Tree Adjoining Grammars  . We have shown how a HGG' ( using our extended definitions ) can be obtained in a systematic fashion from a TAGG  . It is our belief that the extension of the definition may not necessar /  . Yet , this conversion proces should help us understand the similarities between the two formalisms  . 
6. OTHER MATHE MATICAL PROPERTIES
OFTAG's
Additional formal properties of TAG's have been discussed in Vijay-Shankat and Joshi  , 1085\] . Some of them are listed below t ) Pumping lemmn for TAG's2 ) TAL's are closed under sub6titution and homomorphisms 3  ) TAL's are not closed under the following operations a  ) intersection vt th TkL'8h )   . ntnrsoct ~ . on ntth CFL'nc ) coaple Mnt , att on Some other properties that have been considered in\[Vijay- 
Shank ~ r ~ d Joshi , 1985 jreu followst ) cloms rnunder the folloetng properttana ) tn verle hosollorphteib ) ~m ~ ptn~2 ) 8 eLtltnnLrttytadPart lrJ~-bouadndaan8 . 
Refer qene ~1 . Aho , A . V . , and Ullman , J . D . , 1073 " Theory nf Parsing , Translation tan__d Compiling , Volume 1: Pxrs in p; , Prentice-Hall , Englewood Cliffs , 
N . J ., 1973.
2 . Joshi , A . K . ,  1983 " How much context sensitivitys necessary for chare ~ terising structural descriptions-tree adjoining gramman " in Natural Lanpiua ~ ie ~- Th  #oretie alv Computational I and ~ ogie al Perspectives  ( ed . " D . ~ owty , L . Karttunen , A . Zwick ~ , Cambridge University Press , New York , ( originally presented in 1983) to appear in 1985 . 
3 . Joshi , A . K . , and Levy J ~ . S . , 1977 " Constraints on Structural Dc , seriptinns : Local Transformations s , SIAM\]ourual of Computinlt;
June 1977.
4 . Joshi , A . K . , Levy: . . S . , and Takahashi , M . , 1975 " Tree adjoining gramm=rs ' , Jo , rual of Comout ~ r ~" ~' ems and Sc . ; enees March 19755 . Kroch , T , and Joshi , A . K . ,  I~85 ? Linguistic relevance of tree adjoining grammars  '  , Technical ReportiMS-CIS-g . 5-18, Dept . of Computrr and ? ~ . formation Scteuee I University of P~nnsvlvania , April 6 . Poll:zrd , C , t984" Generalized Fhruse Structure Grammars , Head Grammars , and Naturall " nggage a , Ph . D dissertation t Stanford
Univer ~ itz , August 19847 . Ro~h .  !< . , 1084" Form ~ JP . -operties of Head Gra: , ~m  ~ rs ' , unpubl bhed manu ~' ript , Stanford University , also presented at the M- . th~ . mir ~ , ffl , anguage ~ workshop zt the University of Michigan , 
Ann Arbor , Oct .lg ~. l.
8 . Vijay-S ~', ankar , K . , Jnshi . A . K . .  1935 " Formal Properties ot Tree Adjolmug Grammars ' . Tm'hni ~ . ' il Report , D~pt . hi'Cnmp ,, ternailhz formationSrit,~rf . ~ Univ@r ~ ttv of Peoes vlvant ~, July 1985 . 

