The Replace Operator
Lauri Karttunen
Rank Xerox Research Centre
6, chemin de Maupertuis
F-38240 Meylan , France
lauri , kart tunen@xerox , fr
Abstract
This paper introduces to the calculus of regular expressions a replace operator and defines a set of replacement expressions that concisely encode alternate variations of the operation  . Replace expressions denote regula relations , defined in terms of other regular expression operators  . The basic case is unconditional obligatory replacement  . We develop several versions of conditional replacement that allow the operation to be constrained by context 
O . Introduction
Linguistic descriptions in phonology , morphology , and syntax typically make use of an operation that replace some symbol or sequence of symbols by another sequence or symbol  . We consider here the replacement operation in the context of finite-state grammars  . 
Our purpose in this paper is twofold . One is to define replacement in a very general way  , explicitly allowing replacement to be constrained by input and output contexts  , as in two-level rules ( Koskenniemi 1983) , but without the restriction of only single-symbol replacements  . The second objective is to define replacement within a general calculus of regular expressions so that replacements can be conveniently combined with other kinds of operations  , uchas composition and union , to form complex expressions . 
Our replacement operators are close relatives of the rewrite-operator defined in Kaplan and Kay  1994  , but they are not identical to it . We discuss their relationship n a section at the end of the paper  . 
0.1. Simple regular expressions
The replacement operators are defined by means of regular expressions  . Some of the operators we use to define them are specific to Xerox implementations of the finite -state calculus  , but equivalent formulations could easily be found in other notations  . 
The table below describes the types of expressions and special symbols that are used to define the replacement operators  . 
\[1\]  ( A ) option ( union of A with the empty string ) ~A complement ( negation ) \ A term complement ( any symbol other than A ) $A contains ( all strings containing at least one A ) 
A * Kleene star
A+Kleene plus
A/B ignore ( A interspersed with strings from B )
AB concatenation
A\[Bunion
A&B intersection
A-B relative complement ( minus )
A.x . B crossproduct ( Cartesian product)
A.o . B composition
Square brackets , \[ l , are used for grouping expressions . Thus\[AI is equivalent to A while ( A ) is not . 
The order in the above table corresponds to the precedence of the operations  . The prefix operators (- ,  \  , and $ ) bind more tightly than the postfix operators ( * ,  + , and /) , which in turn rank above concatenation . Union , intersection , and relative complement are considered weaker than concatenation but stronger than crossproduct and composition  . Operator sharing the same precedence are interpreted left-to-right  . Our new replacement operator goes in a class between the Boolean operators and composition  . Taking advantage of all these conventions , the fully bracketed expression \[2\] \[\[\[ ~\ [ all*\[\[b\]/x\]\]Iel . x . d ; ~ a * b/x I c . x . d\[31 Expressions that contain the crossproduct (  . x . ) or the composition ( . o .   ) operator describe regular relations rather than regular languages  . A regular relation is a mapping from one regular language to another one  . Regular languages correspond to simple finite -state automata  ; regula relations are modeled by finite-state transducers  . In the relation a . x . B , we call the first member , A , the upper language and the second member , B , the lower language . 
To make the notation less cumber some , we systematically ignore the distinction between the language A and the identity relation that maps every string of A to itself  . Correspondingly , a simple automaton may be thought of as representing a language or as a transducer for its identity relation  . 
For the sake of convenience , we also equate a language consisting of a single string with the string itself  . Thus the expression abcmay denote , depending on the context , ( i ) the string abc , ( ii ) the language consisting of the string abc , and ( iii ) the identity relation on that language . 
We recognize two kinds of symbols : simple symbols  ( a , b , c , etc . ) and fst pairs ( a : b , y : z , etc . ) . An fst pair a : b can be thought of as the crossproduct of a and b  , the minimal relation consisting of a ( the upper symbol ) and b ( the lower symbol )  . Because we regard the identity relation on A as equivalent to A  , we write a : a as just a . There are two special symbols \[4\]0 epsilon ( the empty string )  . 
? any symbol in the known alphabet and its extensions  . 
The escape character ,  % , allows letters that have a special meaning in the calculus to be used as ordinary symbols  . Thus %& denotes a literal ampers and as opposed to  &  , the intersection operator ; % 0 is the ordinary zero symbol . 
The following simple expressions appear frequently in our formulas :  \[5\] \[\] the empty string language . 
~$\[\] the null set.
?* the universal ( " sigma-star " ) language : all possible strings of any length including the empty string  . 
1. Unconditional replacement
To the regular-expression language described above  , we add the new replacement operator . The unconditional replacement of UPPER by LOWER is written  \[6\] 
UPPER->LOWER
Here UPPER and LOWER are any regular expressions that describe simple regular languages  . We define this replacement expression as \[71 \[NOUPPER\[UPPER . x . LOWER \]\]*
NOUP PER ; where NOUPPER abbreviates ~$\[ UPPER-\[\]\] . 
The defi ~ ion describes a regula relation whose members contain any number  ( including zero ) of iterations of \[ UPPER . x . LOWER\] , possibly alternating with strings not containing UPPER that are mapped to themselves  . 
1.1. Examples
We illustrate the meaning of the replacement operator with a few simple examples  . The regular expression \[8\] abIc -> x ;   ( same as \[\[ ab\]\[c\]->x ) describes a relation consisting of an infinite set of pairs such as  \[9\] abacax axaw here all occurrences of aband care mapped to x interspersed with unchanging pairings  . It also in-dudes all possible pairs like \[101 x axaxa that do not contain either abor canywhere  . 
Figure 1 shows the state diagram of a transducer that encodes this relation  . The transducer consists of states and arcs that indicate a transition from venience were present identity pairs by a single symbol  ; for example , we write a : a as a . The symbol ? represents here the identity pairs of symbols that are not explicitly present in the network  . In this case , ? stands for any identity pair other than a : a , b : b , c : c , and x : x . Transitions that differ only with respect othe label are collapsed into a single multiply labelled arc  . The state labeled 0 is the start state . Final states are distinguished by a double circle . 
? C : ~ a
C : X --
Figure 1: abIc -> x
Every pair of strings in the relation corresponds to a path from the initial  0 state of the transducer to a final state . The abacatox axapath is 0-1-0-2-02 , where the 20 transition is over ac : x arc . 
In case a given input string matches the replacement relation in two ways  , two outputs are produced . For example ,\[111 ab\]bc->x;c ?
Figure 2: ab\[bc->x maps abc to both ax and xc:ab c  , abc axx c \[121 The corresponding transducer paths in Figure 2 are 0   -1   -3   -0 and 0   -2   -0   -0   , where the last 00 transition is over a carc . 
If this ambiguity is not desirable , we may write two replacement expressions and compose them to indicate which replacement should be preferred if a choice has to be made  . For example , if the abmatch should have precedence , we write\[13\]ab->xo0obc->x;a : x
X X
Figure 3: ab->x.o.bc->x
This composite relation produces the same output as the previous one except for strings like abc where it unambiguously makes only the first replacement  , giving x c as the output . The abe to x c path in Figure 3 is 0-2-0-0 . 
1.2. Special cases
Let us illustrate the meaning of the replacement operator by considering what our definition implies in a few spedal cases  . 
If UPPER is the empty set , as in \[\]-> a\[b \[141 the expression compiles to a transducer that freely inserts as and bs in the input string  . 
If UPPER describes the null set , as in , ~$\[\]-> a\[b;\[151 replacement . This expression is a description of the sigma -star language  . 
If LOWER describes the empty set , replacement becomes deletion . For example ,   \[16\] a Ib ->\[\] removes all as and bs from the input  . 
If LOWER describes the null set , as in a\[b->~$\[\] ; \[17\] all strings containing UPPER , here a or b , are excluded from the upperside language . Everything else is mapped to iiself . An equivalent expression is ~$\[ a\[b\] . 
1.3. Inverse replacement
The inverse replacement operator.
UPPER <- LOWER \[18\] is defined as the inverse of the relation LOWER -> 

1.4. Optional replacement
An optional version of unconditional replacement is derived simply by augmenting LOWER with UP- 
PER in the replacement relation.

UPPER (->) LOWER is defined as
UPPER->\[LOWER\[UPPER\]\[20\]
The optional replacement relation maps UPPER to both LOWER and UPPER  . The optional version of <- is defined in the same way  . 
2. Conditional replacement
We now extend the notion of simple replacement by allowing the operation to be constrained by a left and a right context  . A conditional replacement expression has four components : UPPER  , LOWER , LEFT , and RIGHT . They must all be regular expressions that describe a simple language  . We write the replacement part UPPER->LOWER , as before , and the context part as LEFT_RIGHT , where the underscore indicates where the replacement takes place  . 
In addition , we need a separator between the replacement and the context part  . We use four alternate separators , \[ I ,  / /  , \\ and\/ , which gives rise to four types of conditional replacement expressions :  \[21l   ( 1 ) Upward-oriented :
UPPER->LOWERJ\[LEFTRIGHT ; (2) Right-oriented :
UPPER->LOWER//LEFTRIGHT ; (3) Left-oriented :
UPPER->LOWER\\LEFTRIGHT ; (4) Downward-oriented:
UPPER->LOWER\/LEFTRIGHT;
All four kinds of replacement expressions describe a relation that maps UPPER to LOWER between LEFT and RIGHT leaving everything else unchanged  . The difference is in the intelpretation of '% etween LEFT and RIGHT  . " 2 . 1 . Overview : divide and conquer We define UPPER -> LOWERl\[LEFTRIGHT and the other versions of conditional replacement in terms of expressions that are already in our regular expression language  , including the uncondi-tional version just defined  . Our general intention is to make the conditional replacement behave exactly like unconditional replacement excep that the operation does not take place unless the specified context is present  . 
This may seem a simple matter but it is not , as Kaplan and Kay 1994 show . There are several sources of complexity . One is that the part that is being replaced may at the same time serve as the context of another adjacent replacement  . Another complication is the fact just mentioned : there are several ways to constrain a replacement by a context  . 
We solve both problems using a technique that was originally invented for the implementation of phonological rewrite rules  ( Kaplan and Kay 1981 ,  1994 ) and later adapted for two-level rules ( Kaplan , Karttunen , Koskenniemi 1987 ; Kart tunen and complex relation into a set of relatively simple components  , define the components independently of one another  , and then define the whole operation as a composition of these auxiliary relations  . 
We need six intermediate relations , to be defined shortly :\[22\] ( 1 ) Insert Brackets ( 2 ) Constrain Brackets ( 3 ) Left Context ( 4 ) Right Context ( 5 ) Replace ( 6 ) Remove Brackets Relations ( 1 )  ,  (5) , and ( 6 ) involve the unconditional replacement operator defined in the previous section  . 
Two auxiliary symbols , < and > , are introduced in (1) and (6) . The left bracket ,  < , indicates the end of a left context . The right bracket ,  > , marks the beginning of a complete right context . The distribution of the auxiliary brackets is controlled by  ( 2 )  ,  (3) , and (4) . The relations ( 1 ) and ( 6 ) that introduce the brackets internal to the composition at the same time remove them from the result  . 
2.2. Basic definition
The full spedfication of the six component relations is given below  . Here UPPER , LOWER , LEFT , and RIGHT are placeholders for regular expressions of any complexity  . 
In each case we give a regular expression that precisely defines the component followed by an English sentence describing the same language or relation  . In our regular expression language , we have to prefix the auxiliary context markers with the escape symbol % to distinguish them from other uses of < and >  . 
\[23\](1) InsertBrackets\[\]<-%<1%> ; The relation that eliminates from the upper side language all context markers that appear on the lower side  . 
\[24\](2) ConstrainBrackets~$\[%<%>\] ; The language consisting of strings that do not contain <> anywhere  . 
\[2s\](3) Left Context-\[-\[ .   .   . LEFT\]\[< . . . \]\] & ~\[ \[ . . . LEFT\]~\[< . . . \]\]  ; The language in which any instance of < is immediately preceded by LEFT  , and every LEFT is ii ~ iedi-ately followed by < , ignoring irrelevant brackets . 
Here\[ .   .   . LEFT\]is an abbreviation for\[\[?*LEFT/\[% < I %>\]\]-  \[2"  %<\] \] , that is , any string ending in LEFT , ignoring all brackets except for a final < . Similarly , \[% < . .  . \] stands for\[%</%>?*\] , any string beginning with < , ignoring the other bracket . 
\[26\](4) Right Context ~\[\[ . . . >\] -\[ RIGHT . . . \] & ~\[~\[ . . . >\]\[ RIGHT . . . \]  ; The language in which any instance of > is immediately followed by RIGHT  , and any RIGHT is immediately preceded by > , ignoring irrelevant brackets . 
Here\[ .   .   . >\] abbreviates\[?*%>/%<\], and RIGHT .   .   . stands for\[RIGHT/\[%<1%>\]-\[%>?*\]\] , that is , any string beginning with RIGHT , ignoring all brackets except for an initial > . 
\[27\]  ( 5 ) Replace % < UPPER/\[%<I%>\]%>->%<LOWER/\[%< I %>\]% >  ; The unconditional replacement of < UPPER > by < LOWER >  , ignoring irrelevant brackets . 
The redundant brackets on the lower side are important for the other versions of the operation  . 
\[28\](6) RemoveBrackets %< t %>->\[\] ; guage to the same strings without any context markers  . 
The upperside brackets are eliminated by the inverse replacement defined in  ( 1 )  . 
2.3. Four ways of using contexts
The complete definition of the first version of conditional replacement is the composition of these six relations :  \[29\] 
UPPER->LOWER\[lLEFTRIGHT;
Insert Bracketso O.
Constrain Bracketso O.
Left Context ? O.
Right Context . Oo
Replace oO.
Remove Brackets;
The composition with the left and right context constraints prior to the replacement means that any instance of UPPER that is subject o replacement is surrounded by the proper context on the upper side  . Within this region , replacement operates just as it does in the unconditional case  . 
Three other versions of conditional replacement can be defined by applying one  , or the other , or both context constraints on the lower side of the relation  . It is done by varying the order of the three middle relations in the composition  . In the right-oriented version (//) , the left context is checked on the lower side of replacement :  \[30\] 
UPPER->LOWER // LEFTRIGHT ; ? o.
Right Context ? Oo
Replace o Oo
Left Context ?. o
The left-oriented version applies the constraints in the opposite order : 
UPPER->LOWER\\LEFTRIGHT\[31\].??
Left Context . O.
Replace . o.
Right Context ???
The first three versions roughly correspond to the three alternative interpretations of phonological rewrite rules discussed in Kaplan and Kay  1994  . 
The upward-oriented version corresponds to simultaneous rule application  ; the right-and left-oriented versions can model rightward or leftward iterating processes  , such as vowel harmony and assimilation . 
The fourth logical possibility is that the replacement operation is constrained by the lower context  . 

UPPER->LOWER\/LEFTRIGHT ; ? oo
Replace . O.
Left Contexto Oo
Right Context . ??
When the component relations are composed together in this manner  , UPPER gets mapped to LOWER just in case it ends up between LEFT and 
RIGHT in the output string.
2.4. Examples
Let us illustrate the consequences of these definitions with a few examples  . We consider four versions of the same replacement expression  , starting with the upward-oriented version \[331 ab->xII aba ; applied to the string a baba ba . The resulting relation is a bababa abxxa The second and the third occurrence of a bare replaced by x here because they are between ab and transducer for the relation is shown in Figure  4  . 
? xb ? lx ' <!/
Figure 4: ab -> xII ab_a
The path through the network that maps ababa bato abxxais  0   -1   -2   -5   -7   -5   -6   -3   . 
The right-oriented version , ab->x//aba ; ?9b

O--GC r
F igure5: ab->x//ab_agives us a different result : a bababa abxabab ? b ?  ( a:x
Figure 6: ab->x\\ab_a
With a bababa composed on the upper side , it yields \[38\] abababa ababxa \[35\] by the path 0   -1   -2   -3   -4   -5   -6   -3   . 
\ [36\] following the path 0   -1  -  2-   5-   6   -1  -  2  -  3  . The last occurrence of abmust remain unchanged because it does not have the required left context on the lower side  . 
The left-oriented version of the rule shows the opposite behavior because it constrains the left context on the upper side of the replacement relation and the right context on the lower side  . 
\[37\]ab->x\\aba;
The first two occurrences of a bremain unchanged because neither one has the properight context on the lower side to be replaced by x  . 
Finally , the downward-oriented fourth version : \[39\] ab->x\/aba ; a:x
Figure 7: ab->x\/ab_a
This time , surprisingly , we get two outputs from the same input : \[40\] abababa , abababa abxaba ababxaPath 0-1-2-5-6-1-2-3 yields abxaba , path 0-1-2-3-4-5-6-1 gives us a babxaIt is easy to see that if the constraint for the replacement pertains to the lower side  , then in this case it can be satisfied in two ways . 
22 3 . Comparisons 3 . 1 . Phonological rewrite rules Our definition of replacement is in its technical aspects very closely related to the way phonological rewrite -rules are defined in Kaplan and Kay  1994 but there are important differences . The initial motivation in their original 1981 presentation was to model a left-to-right deterministic process of rule application  . In the course of exploring the issues , Kaplan and Kay developed a more abstract notion of rewrite rules  , which we exploit here , but their 1994 pape retains the procedural point of view . 
Our paper has a very different starting point . The basic case for us is unconditional obligatory replacement  , defined in a purely relation alway without any consideration of how it might be applied  . By starting with obligatory replacement , we can easily define an optional version of the operator  . For Kaplan and Kay , the primary notion is optional rewriting . It is quite cumber some for them to provide an obligatory version  . The results are not equivalent . 
Although people may agree , in the case of simple phonological rewrite rules , what the outcome of a deterministic rewrite operation should be  , it is not clear that this is the case for replacement expressions that involve arbitrary regular languages  . For that reason , we prefer to define the replacement operator in relational terms without relying on an uncertain intuition about a particular procedure  . 
3.2. Two-level rules
Our definition of replacement also has a close connection to two-level rules  . A two-level rule always specifies whether a context element belongs to the input  ( = lexical ) or the output ( = surface ) context of the rule . The two-level model also shares our pure relational view of replacement as it is not concerned about the application procedure  . But the two-level formalism is only defined for symbol-to-symbol replacements  . 
4. Conclusion
The goal of this paper has been to introduce to the calculus of regular expressions are place operator  ,  -> , with a set of associated replacement expressions that concisely encode alternate variations of the operation  . 
We defined unconditional and conditional replacement  , taking the unconditional obligatory replacement as the basic case  . We provide a simple declarative definition for it  , easily expressed in terms of the other regular expression operators  , and extend it to the conditional case providing four ways to constrain replacement by a context  . 
These definitions have already been implemented.
The figures in this paper correspond exactly to the output of the regular expression compiler in the 
Xerox finite-state calculus.

This work is based on many years of productive collaboration with Ronald M  . Kaplan and Martin Kay . I am particularly indebted to Kaplan for writing a very helpful critique  , even though he strongly prefers the approach of Kaplan and Kay  1994  . Special thanks are also due to Kenneth R . 
Beesley for technical help on the definitions of the replace operators and for expert editorial advice  . I am grateful to Pasi Tapanainen , Jean-Pierre Chanod and Annie Zaenen for helping to correct many terminological ndrhetorical weaknesses of the initial draft  . 

Kaplan , Ronald M ., and Kay , Martin (1981).
Phonological Rules and Finite-State Transducers.
Paper presented at the Annual Meeting of the Linguistic Society of America  . New York . 
Kaplan , Ronald M . and Kay , Martin (1994) . Regular Models of Phonological Rule Systems . Computational Linguistics .  20:3 331-378 .  1994 . 
Karttunen , Lauri , Koskenniemi , Kimmo , and Kaplan , Ronald M .   ( 1987 ) A Compiler for Two-level Phonological Rules . In Report No . CSLI-87-108 . Center for the Study of Language and Information . Stanford University . 
Karttunen , Lauri and Beesley , Kenneth R .  (1992) . 
Two-level Rule Compiler . Technical Report . ISTL-92-2 . Xerox Palo Alto Research Center . 
Koskenniemi , Kimmo (1983) . Two-level Morphology : A General Computational Model for Word Form Recognition and Production  . Department of General
Linguistics . University of Helsinki.

