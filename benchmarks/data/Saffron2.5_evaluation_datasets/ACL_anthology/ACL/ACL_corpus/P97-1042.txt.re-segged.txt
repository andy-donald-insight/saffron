Compiling Regular Formalisms with Rule Features into 
Finite-State Automata
George Anton Kiraz
Bell Laboratories
Lucent Technologies
700 Mountain Ave.
Murray Hill , NJ 07974, USA
gkiraz@research , bell-labs , tom
Abstract
This paper presents an algorithm for the compilation of regular formalisms with rule features into finite-state automata  . Rule features are incorporated into the right context of rules  . This general notion can also be applied to other algorithms which compile regulare write rules into automata  . 
1 Introduction
The past few years have witnessed an increased interest in applying finite-state methods to language and speech problems  . This in turn generated interest in devising algorithms for compiling rules which describe regular languages/relations it of inite-state automata  . 
It has long been proposed that regular formalisms ( e . g . , rewrite rules , two-level formalisms ) accommodate rule features which provide for finer and more elegant descriptions  ( Bear ,  1988) . Without such a mechanism , writing complex grammars ( say two-level grammars for Syria cor Arabic morphology  ) would be difficult , if not impossible . Algorithms which compile regular grammars into automata  ( Kaplan and Kay , 1994; Mohri and Sproat , 1996; Grimley-Evans , Kiraz , and Pulman ,  1996 ) do not make use of this important mechanism . This paper presents a method for incorporating rule features in the resulting automata  . 
The following Syriac example is used here , with the infamous Semitic root ktb ' notion of writing '  . The verbal pa"el measure 1 , /katteb/~'wroteCAUSATIVE ACTIVE ' , is derived from the following 1Syriac verbs are classified under various measures ( i . e . , forms ) , the basic ones being p'al , pa"el and ' a /' el . 
2 Spirantization is ignored here ; for a discussion on Syriacspirantization , see ( Kiraz ,  1995) . 
morphemes : the pattern cvcvc ' verbal pattern ' , the above mentioned root , and the voeal is mae ' ACTIVE ' . The morphemes produce the following underlying form :  3 ae\[\[*/kateb/CVCVC
JIIktb/katteb/is derived then by the gemination  , implying CAUSATIVE , of the middle consonant , \[ t\] . 4 The current work assumes knowledge of regular relations  ( Kaplan and Kay ,  1994) . The following convention has been adopted . Lexical forms ( e . g . , morphemes in morphology ) appear in braces ,    , phonological segments in square brackets ,  \[\] , and elements of tuples in angle brackets ,  () . 
Section 2 describes a regular formalism with rule features . Section 3 introduce a number of mathematical operators used in the compilation process  . 
Sections 4 and 5 present our algorithm . Finally , section 6 provides an evaluation and some concluding remarks  . 
2 Regular Formalism with Rule

This work adopts the following notation for regular formalisms  , cf . ( Kaplan and Kay , 1994): r (= ~ ,  <= , < ~ A___p (1) where T , A and parenway regular expressions which describe same-length relations  )   ( An nway regular expression is a regular expression whose terms  3This analysis is along the lines of ( McCarthy ,  1981 ) -based on auto segmental phonology ( Goldsmith ,  1976) . 
4This derivation is based on the linguistic model proposed by  ( Kiraz ,  1996) . 
~ More ' user-friendly ' notations which allow mapping expressions of unequal length  ( e . g . , ( Grimley-Evans , Kiraz , and Pulman ,  1996 ) ) are mathematically equivalent to the above notation afterules are converted into same- 
R2 b:c3:b:0 = ?.__
R3a:v:0:a => ___
R4 e:v:0: e::~____
R5t:c2: t:0t:0:0:0?:~___(\[ cat=verb\] , \[ measure = pa"el\] ,  \[\])
R6 t:c~:t : 0 ? ? , ___(\[ cat=verb \] , \[ measure = p'al\] ,  \[\])
R70:v:0:a?:~___t:c2:t:0a:v:0:a
Figure 1: Simple Syriac Grammar aren-tuples of alphabetic symbols or the empty string e  . A same-length relation is devoid of e . For clarity , the elements of the n-tuple are separated by colons : e  . g . , a:b:c * q:r:s describes the 3-relation  ( amq , bmr , cms)\[m > 0 . Following current terminology , we call the first j elements ' surface '6 and the remaining elements ' lexical ' . ) The arrows correspond to context restriction ( CR )  , surface coercion ( SC ) and composite rules , respectively . A compound rule takes the form r ~ ,  ~ ,  ? , ~l___pl;~2__p2; . . . (2) To accommodate for rule features , each rule may be associated with an ( n-j ) -tuple of feature structures , each of the form \[ attribute l = v all , attribute , = val2 ,   .   .   . \] (3) i . e . , an unordered set of attribute=val pairs . An attribute is an atomic label . Aval can be an atomora variable drawn from a predefined finite set of possible values  , z The ith element in the tuple corresponds to the  ( jz_i ) the lement in rule expressions . As a way of illustration , consider the simplified grammar in Figure 1 with j = 1  . 
The four elements of the tuples are : surface , pattern , root , and vocalism .   R1 and R2 sanction the first and third consonants , respectively . R3 and R4 sanction vowels . R5 is the gemination rule ; it is only triggered if the given rule features are satisfied :\[ cat = verb \] for the first lexical element  ( i . e . , the pattern ) and\[measure=pa"el\]for the second element ( i . e . , the root ) . The rule also illustrates that r can be a sequence of tuples  . The derivation of/k atteb/is illustrated below : length descriptions at some preprocessing stage  . 
6In natural anguage , usually j = 1.
t it is also possible to extend the above formalism in order to allow val to be a category-feature structure  , though that takes us beyond finite-state power . 
Sublexic on Entry Feature Structure
Pattern Cl VC2 VC3\[cat=verb\]
Root ktb\[measure = ( p'al , pa"el)t\]
Voealismae\[voice=active , measure = pa"el\]aa\[voice=active , measure = p'al\]tParenthesis denote disjunction over the given values  . 
Figure 2: Simple Syriac Lexicon 0 \[ a 100 e 0 vocalism kI 0 I t0   0 broot clIv It20 v c3 pattern 1   3   5   4   2 \[k\]aleteb\]surface The numbers between the lexical expressions and the surface x pression denote the rules in Figure  1 which sanction the given lexical-surface mappings . 
Rule features play a role in the semantics of rules : a = ~ states that if the contexts and rule features are satisfied  , the rule is triggered ; a ?=: states that if the contexts , lexical expressions and rule features are satisfied  , then the rule is applied . For example , although R5 is devoid of context expressions , the rule is composite indicating that if the root measure is pa"el  , then gemination must occur and vice versa . 
Note that in a compound rule , each set of contexts is associated with a feature structure of its own  . 
What is meant by ' rule features are satisfied '? Regular grammars which make use of rule features normally interact with a lexicon  . In our model , the lexicon consists of ( n-j ) sublexica corresponding to the lexical elements in the formalism  . Each sub lexical entry is associate with a feature structure  . 
Rule features are satisfied if they match the feature structures of the lexical entries containing the lexical expressions in r  , respectively . Consider the lexicon in Figure 2 and rule R5 with 7" = t:c . ,:t:0 t:0:0:0 and the rule features ( \[ cat=verb \] , \[ measure = pa"el\] ,  \[\]) . 
The lexical entries containing rare clvc_ , vc3 and ktb , respectively . For the rule to be triggered , \[ cat=verb \] of the rule must match with \[ cat = verb \] of the lexical entry  clvc2vc3  , and\[measure=pa"el\]of the rule must match with \[ measure =  ( p'al , pa"el )\] of the lexical entry k tb . 
As a second illustration , R6 derives the simplep ' almeasure , / ktab/ . Note that in R5 and R6,1 . the lexical expressions in both rules ( ignoring 0s ) are equivalent ,  2 . both rules are composite , and In traditional rewrite formalism , such rules will be contradicting each other . However , this is not the case here since R5 and R6 have different rule features . The derivation of this measure is shown below (   R7 completes the derivation deleting the first vowel on the surface S  ) : la 101a   10 I ~ oc~tism 01t   i01b root cv Ic2! vIp . rnNote that in order to remain with infinite -state power  , both the attributes and the values in feature structures must be atomic  . The formalism allows a value to be a variable drawn from a predefined finite set of possible atomic values  . In the compilation process , such variables are taken as the disjunction of all possible predefined values  . 
Additionally , this version of rule feature matching does not cater for rules whoser span over two lexical forms  . It is possible , of course , to avoid this limitation by having rule features match the feature structures of both lexical entries in such cases  . 
3 Mathematical Preliminaries
We define here a number of operations which will be used in our compilation process  . 
If an operator 0 p takes a number of arguments ( at ,  ? ? . , ak ), the arguments are shown as a subscript , e . g . 0 p(a , , . . . ,~k ) -the parentheses are ignored if there is only one argument  . When the operator is mentioned without reference to arguments  , it appears on its own , e . g . 0 p . 
Operations which are defined on tuples of strings can be extended to sets of tuples and relations  . For example , if S is a tuple of strings and 0 p ( S ) is an operator defined on S , the operator can be extended to a relation R in the following manner op  ( n ) = Op ( 3 ) Isen Definition 3 . 1 ( Identity ) Let L be a regular language . I d , ( L ) = XIX is an n-tuple of the form ( x ,   .  -  . , x ), xEL is then way identity of L . 9 Remark 3 . 1 If Id is applied to a strings , we simply write Ida ( s ) to denote then-tuple ( s .   .   .   . , s . 
SShort vowels in open unstressed syllables are deleted in Syriac  . 
9This is a generalization of the operator Id in ( Kaplan and Kay ,  1994) . 
Definition 3 . 2  ( Insertion ) Let R be a regular relation over the alphabet E and let m be a set of symbols not necessarily in E  . I aser tm ( R ) inserts the relation Ida ( a ) for all a Em , freely throughout R . Insert ~ Io Insert m ( R ) = R removes all such instances if misdisjoint from E  . 1 ? Remark 3 . 2 We can define another form of Inser t where the elements in rnare tuples of symbols as fol-low S : Let R be a regular relation over the alphabet and let rn be a set of tuples of symbols not necessarily in E  . Insertm(R ) inserts a , for all a Em , freely throughout R . 
Definition 3 . 3  ( Substitution ) Let S and S ' be same-length n-tuples of strings over the alphabet  ( E ?''' XE )  , \[---- Ida(a ) for some a EE , and S = StIS ,   . I .   .   . Sk , k > 1, such that Si does not contain I-i . e . SiE((Ex- . . x E ) -  I ) ' . 
Substitute(s , i ) ( S ) = $1S'S, . S ' .   .   . Sk substitutes every occurrence of I in S with S ' . 
Definition 3 . 4 ( Projection ) Let S = ( st .   .   .   .   , s , ,) be a tuple of strings , projec'ci(S ) , for some i 61 .   .   .   .   . n , denotes the tuple elements i . 
Project ~- l(S ), for some iE 1 .   .   .   . , n , denotes the ( n-1)-tuple ( Sl .   .   .   . , si-1, si + l .   .   .   . , sn ) . 
The symbol , -r denotes ' feasible tuples ' , similar to ' feasible pairs ' in traditional two -level morphology  . 
The number of surface expressions , j is always 1.
The operator ore presents mathematical composition  , not necessarily the composition of transducers . 
4 Compilation without Rule

The current algorithm is motivated by the work of ( Grimley-Evans , Kiraz , and Puhnan ,  1996) . tt Intuitively , the automata is built by three approximations as follows:  1  . 

Accepting rsir respective of any context.
Adding context restriction ( =~ ) constraints making the automat accept only the sequences which appear in contexts described by the grammar  . 
. Forcing surface coercion constraints ( ?= ) making the automata accept all and only the sequences described by the grammar  . 
1 ? This is similar to the operator Intro in ( Kaplan and
Kay , 1994).
1 1The subtractive approach for compiling rules into FSAs was first suggested by Edmund Grimley-Evans  . 
331 4.1 Accepting rs
Let 7-be the set of all rs in a regular grammar , p be an auxiliary boundary symbol ( not in the grammar's alphabets ) and p '= Ida ( p )  . The first approximation is described by
Centers : U (4) rET
Centers accepts the symbols , p ' , followed by zero or morers , each ( if any ) followed by p ' . In other words , the machine accepts all centers described by the grammar  ( each center surrounded by p ' ) irrespective of their contexts . 
It is implementation dependent as to whether T includes other correspondences which are not explicitly given in rules  ( e . g . , a set of additional feasible centers ) . 
4.2 Context Restriction Rules
For a given compound rule , the set of relations in which r is invalid is Restrict  ( r ) = 7r " rTr*-U7r' ) ~ krPkTr * ( 5 ) k i . e . , r in any context minus r in all valid contexts . 
However , since in ?4 . 1 above , the symbol p appears freely , we need to introduce it in the above expression . The result becomes
Restrict(v ) = Insertoo (6) k
The above expression is only valid if r consists of only one tuple  . However , to allow it to be a sequence of such tuples as in  R5 in Figure 1  , it must be 1 . surrounded by p ~ on both sides , and 2 . devoid of p ~ . 
The first condition is accomplished by simply placing p ' to the left and right of r  . As for the second condition , we use an auxiliary symbol , w , as a placeholder representing r , introduce pfreely , then substituter in place of w . Formally , let w be an auxiliary symbol ( not in the grammar's alphabet )  , and let w~=Ida ( w ) be a placeholder representing r . The above expression becomes Restrict ( r ) = Substitute ( v , w ') o (7)
Insert ~ o , ' r*p~w ~ ~ o ~ , -r "- U 7 r * A k p ~ J p ~ p ' ~7 r * k For all rs , we subtract this expression from the automaton under construction  , yielding
CR = Centers-URestrict(')(S)

CR now accepts only the sequences of tuples which appear in contexts in the grammar  ( but including the partitioning symbols p ~ )  ; however , it does not force surface coercion constraints . 
4.3 Surface Coercion Rules
Let r ' represent the center of the rule with the correct lexical expressions and the incorrect surface expressions with respect o  , ' r * , r '= Proj'ectl ( r ? Project ~- l ( r )   ( 9 ) The coerce relation for a compound rule can be simply expressed by l~- 
Coerce(r ') = Insert po(10)
U,-r*A k p'r'p'pkl r*k
The twop~s surrounding r ~ ensure that coercion applies on at least one center of the rule  . 
For all such expressions , we subtract Coerce from the automaton under construction  , yielding
SC = CR-UCoerce(v ) (11)

SC now accepts all and only the sequences of tu -pies described by the grammar  ( but including the partitioning symbols p ~ )  . 
It remains only to remove all instances of p from the final machine  , determinize and minimize it . 
There are two methods for interpreting transducers  . When interpreted as acceptors with n-tuples of symbols on each transition  , they can be determinized using standard algorithms  ( Hopcroft and Ullman ,  1979) . When interpreted as a transduction that maps an input to an output  , they cannot always be turned into a deterministic form  ( see ( Mohri , 1994; Roche and Schabes ,  1995)) . 
5 Compi la t ion w i th Ru le Features This section shows how feature structures which are associated with rules and lexical entries can be incorporated into FSAs  . 
12A special case can be added for epenthetic rules . 

Entry Feature Structure abcd ./1 effagh if s
Figure 3: Lexicon Example 5 . 1 In tu i t i ve Descr ip t ion We shall describe our handling of rule features with a two-level example  . Consider the following analysis . 
la\[blcldI~te\[f!~\[glh\[i \]1~ \[Lexical 1   2   3   4   5   6   7   5   8   9105 \[ a ! blcldlOlelf ! O!g ! h!i ! Ol S " " Saee The lexical expression contains the lexical forms abcd  , ef and ghi , separated by a boundary symbol , b , which designates the end of a lexical entry . 
The numbers between the tapes represent the rules ( in some grammar ) which allow the given lexical-surface mappings . 
Assume that the above lexical forms are associated in the lexicon with the feature structures as in Figure  3  . Further , assume that each two-level rule m , 1 < m < 10 , above is associated with the feature structure Fro  . Hence , in order for the above two-level analysis to be valid  , the following feature structures must match
All the structures ... must match ...
F1, F2, F3, F4 fl
F6, F7 f2
Fs , Fg , Flo . 1:3
Usually , boundary rules , e . g . rule 5 above , are not associated with feature structures , though there is nothing stopping the grammar writer from doing so  . 
To match the feature structures associated with rules and those in the lexicon we proceed as follows  . 
Firstly , we suffix each lexical entry in the lexicon with the boundary symbol  ,  ~ , and it's feature structure . ( For simplicity , we consider a feature structure with instantiated values to be an atomic object of length one which can be a label of a transition in a FSA  . )  13 Hence the above lexical forms become : ' a b c d k f l  '  , ' efbf ~ . ', and ' ghi~f3' . Secondly , we incorporate a feature structure of a rule into the rule's right context  , p . For example , if p of rule 1 above is b : b c : c , the context becomes b : b c : c , ' r*0: F1 ( 12 )   ( this simplified version of the expression suffices for the moment  )  . In other words , in order for a : a to be sanctioned , it must be followed by the sequence : 13As to how this is done is a matter of implementation . 
1 . b:bc:c,i . e . , the original right context ; 2 . any feasible tuple ,,' r *; and 3 . the rule's feature structure which is deleted on the surface  , 0: F1 . 
This will succeed if only if F1 ( of rule 1 ) and fl ( of the lexical entry ) were identical . The above analysis is repeated below with the feature structures incorporated in top  . 
lalblcldl blS~lefl~lS~lghli!~!f~lL~ic~t 12345   675   89105 \[ alblcldlO!O ! eflOlOlghlilO!OiSuqaceAs indicated earlier  , in order to remain within finite-state power , all values in a feature structure must be instantiated  . Since the formalism allows values to be variables drawn from a predefined finite set of possible values  , variables entered by the user are replaced by a disjunction over all the possible values  . 
5.2 Compiling the Lexicon
Our aim is to construct a FSA which accepts any lexical entry from the ith sub lexicon on its j " ith tape  . 
A lexical entry #( e . g . , morpheme ) which is associated with a feature structure ? is simply expressed by /~?  , where k is a ( morpheme ) boundary symbol which is not in the alphabet of the lexicon  . The expression of sublexicon i with r entries becomes  , 
L , -- U  #% ? ~ (13) r
We also compute hefeasible feature structures of sublexiconitobez  , = U ( 14 ) r and the overall feasible feature structures on all sub lexicato be ? = O " x  F1 xF  ~ x . --  ( 15 ) The first element deletes all such features on the surface  . For convenience in later expressions , we incorporate features with ~ as follows ~?- , TU ? ( 16 ) The overall lexicon can be expressed by ,  14
Lexicon = LI?L~? . .  .   ( 17 )   14To make the lexicon describe qual-length relations , a special symbol , say 0 , is inserted throughout . 

The operator ? creates one large lexicon out of all the sublexica  . This lexicon can be substantially reduced by intersecting it with Project ~' l  ( ~0 )  . .
If a two-level grammar is compiled into an automaton  , denoted by Gram , and a lexicon is compiled into an automaton , denoted by Lez , the automaton which enforces lexical constraints on the language is expressed by L =  ( Proj , ctl ( ~ ) * ? Lex ) AGram ( 18 ) The first component above is a relation which accepts any surface symbol on its first tape and the lexicon on the remaining tapes  . 
5.3 Compiling Rules
A compound regular rule with m context-pairs and m rule features takes the form v == ~  , <== , ? ~ kl___pl ; k2--p2; . . . ; Am---pm\[?1, ?2, .   .   .   , ?-~\] (19) where v , A  ~ , and pk ,   1 < k < m are like before and ck is the tuple of feature structures associated with rule k  . 
The following modifications to the procedure given in section  4 are required . 
For getting contexts for the moment , our basic machines cans sequences of tuples ( from "/- )  , but requires that any sequence representing a lexical entry be followed by the entry's feature structure  ( from ? )  . This is achieved by modifying eq . 4 as follows:
Centers =\ [. J(20) vET
The expression accepts the symbols ,  9' , followed by zero or more occurrences of the following :  1  . one or more v , each followed by ~ a ', and 2 . a feature tuple in ? followed by p ' . 
In the second and third phases of the compilation process  , we need to incorporate members of ? I , freely throughout he contexts . For each Ak , we compute the new left context fk = Insert . ( A ~) (21) The right context is more complicated . It requires that the first feature structure to appear to the right of v is Ck  . This is achieved by the expression , 7"~k = Inserto ( pk ) CI ~'* ? k~r ~ ( 22 ) The intersection with a '*? k , ' r ; ensures that the first feature structure to appear to the right of v is Ck : zero or more feasible tuples  , followed by Ck , followed by zero or more feasible tuples or feature structures  . 
Now we are ready to modify the Restrict relation.
The first component ineq . 5 becomes
A = (; U~O ) * vTr ~ (23)
The expression allows ~ to appear in the left and right contexts of v  ; however , at the left of v , the expression ( TrtO~r ? ) puts the restriction that the first tuple at the left end must be in a '  , not in ? . 
The second component ineq .5 simply becomes
B = U"r ; ? krTCkTr ; (24) k
Hence , Restrict becomes ( after replacing v with w ' in eq . 23 and eq . 24) Restrict(r ) = Substitute(r , w ') o(25)
Insert ~ o

In a similar manner , the Coercer relation becomes
Coerce ( r ' ) = Insert ~ o ( 26 ) k 6 Conclusion and Future Work The above algorithm was implemented in Prolog and was tested successfully with a number of sample-type grammars  . In every case , the automata produced by the compiler were manually checked for correctness  , and the machines were executed in generation mode to ensure that they did not overgenerate  . 
It was mentioned that the algorithm presented here is based on the work of  ( Grimley-Evans , Kiraz , and Pulman , 1996) rather than ( Kaplan and Kay ,  1994) . It must be stated , however , that the intuitive ideas behind our compilation of rule features  , viz . the incorporation of rule features in contexts , are independent of the algorithm itself and can be also applied to  ( Kaplan and Kay , 1994) and ( Mohri and Sproat ,  1996) . 
One issue which remains to be resolved , however , is to determine which approach for compiling rules into automata is more efficient : the standard method of  ( Kaplan and Kay , 1994) ( also ( Mohri and Sproat ,  1996 ) which follows the same philosophy ) or ( N2 ) zation ( 2N ) KK ( n--i ) "J-3~in_-iki8~'\]~=1kiEKP 1?~"\] nn , i = tki1 . . t . ~ i=1 ki where n = number of rules in a grammar , and ki = number of contexts for rule i , 1 < i < n . 
Figure 4: Statistics of Complex Operation's dealt with at the morphotactic level using a unification based formalism  . 

I would like to thank Richard Sproat for commenting on an earlier draft  . Many of the anonymous reviewers ' comments proofed very useful  . Mistakes , as always , remain mine . 
the subtractive approach of ( Grimley-Evans , Kiraz , and Pulman ,  1996) . 
The statistics of the usage of computationally expensive operations-viz  . , intersection ( quadratic complexity ) and determinization ( exponential complexity ) -in both algorithms are summarized in Figure 4 ( KK = Kaplan and Kay , EKP=Grimley-Evans , Kiraz and Pulman ) . Note that complementation requires determinization  , and subtraction requires one intersection and one complementation since 
A-B = AnB(27)
Although statistically speaking the number of operations used in  ( Grimley-Evans , Kiraz , and Pulman ,  1996 ) is less than the ones used in ( Kaplan and Kay ,  1994) , only an empirical study can resolve the issue as the following example illustrates  . Consider the expression
A = al Ua 2U . . . Uan and the DeMor gan's law equivalent (28)
B = ~ n ~ n.-.n ~ . (29)
The former requires only one complement which results in one determinization  ( since the automata must be determinized before a complement is computed  )  . The latter not only requires n complements , but also n-1 intersections . The worst-case analysis clearly indicates that computing A is much less expensive than computing B  . Empirically , however , this is not the case when n is large and ai is small  , which is usually the case in rewrite rules . The reason lies in the fact that the determinization algorithm in the former expression applies on a machine which is by far larger than the small individual machines present in the latter expression  , is Another aspect of rule features concerns the morphotactic unification of lexical entries  . This is best a ST his important difference was pointed out by one of the anonymous reviewers whom I thank  . 
References
Bear , J .  1988 . Morphology with two-level rules and negative rule features  . In COLING-88: Papers Presented to the 12th International Conference on Computational Linguistics  , volume 1 , pages 28-31 . 
Goldsmith , J . 1976. Autosegmental Phonology.
Ph . D . thesis , MIT . Published as Autosegmental and Metrical Phonology  , Oxford 1990 . 
Grimley-Evans , E . , G . Kiraz , and S . Pulman .  1996 . 
Compiling a partition-based two-level formalism.
In COLING96: Papers Presented to the 16th International Conference on Computational Linguistics  . 
Hopcroft , J . and J . Ullman .  1979 . Introduction to Automata Theory , Languages , and Computation . 

Kaplan , R . and M . Kay .  1994 . Regular models of phonological rule systems . Computational Linguistics , 20(3):331-78 . 
Kiraz , G .  1995 . Introduction to Syriac Spirantiza-tion . Bar Hebraeus Verlag , The Netherlands . 
Kiraz , G .  \[1996\] . Syriac morphology : From a linguistic description to a computational implementation  . In R . Lavenant , editor , VI Itum Symposium Syriacum 1996 , Forthcoming in Orientalia Christiana Analecta . Pontificio Institutum Studio-rum Orientalium . 
Kiraz , G . \[ Forthcoming \] . Computational Approach to Nonlinear Morphology : with emphasis on Semitic languages  . Cambridge University

McCarthy , J .  1981 . A prosodic theory of nonconcatenative morphology . Linguistic Inquiry , 12(3):373-418 . 
Mohri , M .  1994 . On some applications of finite-state automata theory to natural anguage processing  . 
Technical report , Institut Gaspard Monge.

Mohri , M . and S . Sproat .  1996 . An efficient compiler for weighted rewrite rules . In Proceedings of the 3~th Annual Meeting of the Association for Computational Linguistics  , pages 231-8 . 
Roche , E . and Y . Schabes .  1995 . Deterministic part-of-speech tagging with finite -state transducers  . CL , 21(2):227-53 . 

