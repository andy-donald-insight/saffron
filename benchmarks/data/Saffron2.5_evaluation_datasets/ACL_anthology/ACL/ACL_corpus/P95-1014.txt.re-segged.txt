Memoization of Coroutined Constraints
Mark Johnson
Cognitive and Linguistic Sciences , Box 1978
Brown University
Providence , l~I02912, USA

Jochen D Srre *
Institut fiir maschinelle Sprachverarbeitung
Universit ~ it Stuttgart
D-70174 Stuttgart , Germany


Some linguistic constraints cannot be effectively resolved during parsing at the location in which they are most naturally introduced  . This paper shows how constraints can be propagated in a memoizing parser  ( such as a chart parser ) in much the same way that variable bindings are , providing a general treatment of constraint coroutining in memoization  . Prolog code for a simple application of our technique to Bouma and van Noord's  ( 1994 ) categorial grammar analysis of Dutch is provided . 
1 Introduction
As the examples discussed below show , some linguistic constraints cannot be effectively resolve du-ring parsing at the location in which they are most naturally introduced  . In a backtracking parser , a natural way of dealing with such constraints is to coroutine them with the other parsing processes  , reducing them only when the parse tree is sufficiently instantiated so that they can be deterministically resolved  . Such parsers are particularly easy to implement in extended versions of Prolog  ( such as Pro-logl I , SICStus Prolog and Eclipse ) which have such coroutining facilities builtin . Like all backtracking parsers , they can exhibit non-termination and exponential parse times in situations where memoizing parsers  ( such as chart parsers ) can terminate in po-lynomial time . Unfortunately , the coroutining approach , which requires that constraint share variables in order to communicate  , seems to be incompa-tible with standard memoization techniques  , which * This research was largely conducted at the Institutffir maschinelle Sprachverarbeitung in Stuttgart  . We would like to thank Andreas Eisele , Pascal van Hen-tenry ck , Martin Kay , Fernando Pereira , Edward Stabler and our colleagues at the Institut ffir maschinelle Sprachverarbeitung for helpful comments and suggestions  . All remaining errors are our own . The Prolog code presented in this paper is available via anonymous ftp from 
Ix . cog . brown . eduas/pub/lern rna . tar . Z require systematic variable-renaming ( i . e . , copying ) in order to avoid spurious variable binding . 
For generality , conciseness and precision , we formalize our approach to memoization and constraints within  H6hfeld and Smolka's ( 1988 ) general theory of Constraint Logic Programming ( CLP )  , but we discuss how our method can be applied to mote standard chart parsing as well  . This paper extends our previous work reported in DS rre  ( 1993 ) and Johnson ( 1993 ) by generalizing those methods to arbitrary constraint systems  ( including feature-structure constraints )  , even though for reasons of space such systems are not discussed here  . 
2 Lexical rules in Categorial

This section reviews Bouma and van Noord's ( 1994 )   ( B N henceforth ) constraint-based categorial grammar analysis of modification in Dutch  , which we use as our primary example in this paper  . However , the memoizing CLP interpreter presented below has also been applied to GB and HPSG parsing  , both of which benefit from constraint coroutining in parsing  . 
BN can explain a number of puzzling scope phenomena by proposing that heads  ( specifically , verbs ) subcategorize for adjuncts as well as arguments ( rat-her than allowing adjuncts to subcategorize for the arguments they modify  , as is standard in Categorial Grammar) . For example , the first reading of the
Dutch sentence ( 1 ) Fritsopzettelijk Marielijktte on twijken deliberately seems avoid ' Fritz deliberately seems to avoid Marie '' Fritz seems to deliberately avoid Marie ' is obtained by the analysis depicted in Figure  1  . The other reading of this sentence is produced by a derivation in which the adjunct addition rule ' A ' adds an adjunct to lijktre  , and applies vacuously to ont-wijken . 
It is easy to formalize this kind of grammar in pure Prolog  . In order to simplify the presentation of the proof procedure interpreter below  , we write clauses opzettelijk NP2   VPI\ADV\NP2 lijktte
VPt/VP . ___ . __ . ___~IA on twijken ( VPI\ADV\VPI"/yP1pI\ADV\NP2 ) NP2 ) /D ( VD v ( V~NP2 ) VP'\NP2A
Frits ADV VPt\ADV
NP 1 VP 1
Figure 1: The BN analysis of (1) . In this derivation ' VPI ' abbreviates ' S\NPI' , ' A ' is a lexieal rule which adds adjuncts to verbs  , ' D ' is a lexical ' division ' rule which enables a control or raising verb to combine with arguments of higher arity  , and ' D ' is a unary modal operator which diacritically marks infinitival verbs  . 
as ' H ::- B ' where H is an atom ( the head ) and B is a list of atoms ( the negative literals )  . 
The atom x ( Cat , Left , Right ) is true iff the substring between the two string positions Left and Right can be analyzed as belonging to category Cat  . 
( As is standard , we use suffixes of the input string for string positions  )  . 
The modal operator '~' is used to diacritically mark untensed verbs  ( e . g . , ontwijken ) , and prevent them from combining with their arguments  . Thus untensed verbs must combine with other verbs which subcategorize for them  ( e . g . , lijkt re ) , forcing all verbs to appear in a ' verb cluster ' at the end of a clause  . 
For simplicity we have not provided a semantics here  , but it is easy to add a ' semantic interpretation ' as a fourth argument in the usual manner  . The forward and backward application rules are specified as clauses of  x/3  . Note that the application rules are left -recursive  , so a topdown parser will in general fail to terminate with such a grammar  . 
:- op(990, xfx , ::-).
:- op (400, yfx,\).
:- op (300, fy , #).
X Clause operator
X Backward combinator
X Modal operator b ' x(X , Left , Right )::-\[~ Forward application x(X/Y , Left , Mid ) , x(Y , Mid , Right )\] . 
x(X , Left , Right )::-\[~ Backward application x(Y , Left , Mid ) , x(X\Y , Mid , Right )\] . 
x(I , \[ Word\[Words\] , Words )::-\[ lex(Word , X )\] . 
Lexical entries are formalized using a two place relation lex  ( W0rd , Cat ) , which is true if Cat is a category that the lexicon assigns to Word  . 
lex (' Frits ', np )::-~.
lex (' Marie ', np )::-\[\].
lex(opzettelijk , adv)::-D .
lex(ont2ijken , #I )::-\[ add_adjunots(s~np~np , I )\] . 
lex(lijkt_te , I/#Y ) : :-\[ add_adjuncts (   ( s\np )  /  ( s\np )   , IO ) , division(IO , I/Y )\] . 
The add_adjuncts/2 and division /2 predicates formalize the lexical rules ' A ' ( which adds adjuncts to verbs ) and ' D' ( the division rule )  . 
add_adjuncts(s ,)::-~.
add_adjuncts(I , Y\adv ) : :-\[ add_adjuncts(I , Y )\] . 
add_adjuncts(I\? , Y\A ) : :-\[ add_adjuncts(X , Y )\] . 
add_adjuncts(I/A , T/A ) : :-\[ add_adjunc~s(l , T ) 3 . 
division(I , I )::-\[\].
division(XO/YO , ( I\Z)/(Y\Z )) ::-\[ division(IO/YO , I/Y )\] . 
Note that the definitions of add_adjuncSs/2 and division/2 are recursive , and have an infinite number of solutions when only their first arguments are instantiated  . This is necessary because the number of adjuncts that can be associated with any given verb is unbounded  . Thus it is infeasible to enumerate all of the categories that could be associated with a verb when it is retrieved from the lexicon  , so following BN , we treat the predica-tes add_adjl mcts /2 and division /2 as coroutined constraints which are only resolved when their second arguments become sufficiently instantiated  . 
As noted above , this kind of constraint corouti-ning is builtin to a number of Prolog implementations  . Unfortunately , the left recursion inherent in the combinatory rules mentioned earlier dooms any standard backtracking topdown parser to non-termination  , omatter how coroutining is applied to parsers do not suffer from this deficiency  , and we present a memoizing interpreter below which does terminate  . 
3 The Lemma Table proof procedure
This section presents a coroutining , memoizing CLP proof procedure . The basic intuition behind our approach is quite natural in a CLP setting like the one of HShfeld and Smolka  , which we sketch now . 
A program is a set of definite clauses of the form p  ( x ) ql ( Xl )  ^  .   .   . ^ q . ( X . )^? where the Xi are vectors of variables , p ( X ) and qi ( Xi ) are relational atoms and ? is a basic cons-traint coming from a basic constraint language C  . ? ~ will typically refer to some ( or all ) of the variables mentioned . The language of basic constraintsiclo-sed under conjunction and comes with  ( computable ) notions of consistency ( of a constraint ) and entailment ( ?1 ~ c ? 2 ) which have to be invariant under variable renaming Given a program P and a goal G  , which is a conjunction of relational atoms and constraints  , a P-answer of G is defined as a consi-stent basic constraint ? such that ?--+ G is valid in every model of P  . SLD-resolution is generalized in this setting by performing resolution only on relational atoms and simplifying  ( conjunctions of ) basic constraints thus collected in the goal list  . When finally only a consistent basic constraint remains  , this is an answer constraint ? . Observe that this use of basic constraints generalizes the use of substitutions in ordinary logic programming and the  ( simplification of a ) conjunction of constraints generalizes unification  . Actually , pure Prolog can be viewed as a syntactically sugared variant of such a CLP language with equality constraints as basic constraints  , where a standard Prolog clause p(T ) ~- ql(T , )  ,   .   .   .   , qn(T , ) is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities p  ( X )   , - - - X = T , XI--T ,   ,   .   .   . , Xn = T , , q , ( x , ,) . 
Here the Xl are vectors of variables and the T/ are vectors of terms  . 
Now consider a standard memoizing proof procedure such as Earley Deduction  ( Pereira and Warren 1983 ) or the memoizing procedures described by Tamaki and Sato  ( 1986 )  , Vieille ( 1989 ) or Warren ( 1992 ) from this perspective . Each memoized goal is associated with a set of bindings for its arguments  ; so in CLP terms each memoized goal is a 1This essentially means that basic constraints can be recast as first-order predicates  . 
conjunction of a single relational atom and zero or more equality constraints  . A completed ( i . e . , ato-mic ) clause p ( T ) with an instantiated argument T abbreviates the non-atomic clause p  ( X ) ~X-T , where the equality constraint makes the instantiation specific  . Such equality constraints are ' in heri-ted'via resolution by any clause that resolves with the completed clause  . 
In the CLP perspective , variable-binding or equa-lity constraints have no special status  ; informally , all constraints can be treated in the same way that pure Prolog treats equality constraints  . This is the central insight behind the Lemma Table proof procedure : general constraints are permitted to propagate into and out of subcomputations i the same way that Earley Deduction propagates variable bindings  . 
Thus the Lemma Table proof procedure generalizes Earley Deduction in the following ways :  1  . Memoized goals are in general conjunctions of relational atoms and constraints  . This allows constraints to be passed into a memoized sub-computation  . 
We do not use this capability in the categorial grammar example  ( except to pass invariable bindings )  , but it is important in GB and HPSG parsing applications  . For example , memoized goals in our GB parser consist of conjunctions of X ' and ECP constraints  . Because the X'phrase-structure rules freely permit empty categories every string has infinitely many wellformed analyses that satisfy the X'constraints  , but the conjoined ECP constraint rules out all but a very few of these empty nodes  . 
2 . Completed clauses can contain arbitrary negative literals  ( rather than just equality cons-traints , as in Earley Deduction ) . This allows constraint so be passed out of a memoized sub-computation  . 
In the categorial grammar example , the add_adjuncts/2 and division /2 associated with a lexical entry cannot be finitely resolved  , as noted above , so e . g . , a clause x(#X , \[ onl:wijken\] , r-I ): :-\[ add_adjuncl ; s(s\np\np , Z )\] . 

is classified as a completed clause ; the add_adjuncts/2 constraint in its body is inherited by any clause which uses this lemma  . 
Subgoals can be selected in any order ( Earley Deduction always selects goals in left-to -right order  )  . This allows constraint e or outining within a memoized subcomputation  . 
In the categorial grammar example , a category becomes more instantiated when it combines with arguments  , allowing eventually the add_adjuncts/2 and division /2 to be deterministically resolved . Thus we use the flexibility never their arguments are sufficiently instantia-ted  , and delay them otherwise . 
4 . Memoization can be selectively applied ( Earley Deduction memoizes every computational step  )  . 
This can significantly improve overall efficiency.
In the categorial grammar example only x/3 goals are memoized ( and thus only these goals in curthe cost of table management  )  . 
The ' abstraction ' step , which is used in most me-moizing systems ( including complex feature grammar chart parsers where it is somewhat confusingly called ' restriction '  , as in Shieber 1985) , receives an elegan treatment in a CLP approach ; an ' abstrac-ted ' goal is merely one in which not all of the equality constraints associated with the variables appearing in the goal are selected with that goal  . 2 For example , because of the backward application rule and the left-to-right evaluation our parser uses  , eventually it will search at every left string position for an uninstantiated category  ( the variable Y in the clause )  , we might as well abstract all memoized goals of the form x  ( C , L , R ) to x(_ , L ,  _) , i . e . , goals in which the category and right string position are uninstan-tinted  . Making the equality constraints explicit , we see that the abstracted goal is obtained by merely selecting the underlined subset of these below : x  ( Xl , X2 , X3) , Xl = C , X2 = L , X a = R . 
While our formal presentation does not discuss abstraction  ( since it can be implemented in terms of constraint selection as just described  )  , because our implementation uses the underlying Prolog's unification mechanism to solve equality constraints over terms  , it provides an explicit abstraction operation . 
Now we turn to the specification of the algorithm itself  , beginning with the basic computational entities it uses  . 
Definition 1 A ( generalized ) goal is a multiset of relational atoms and constraints  . A ( generalized ) clause Ho 4-- Bo is an ordered pair of generalized goals , where/frocontains at least one relational atom  . A relational interpretation . 4  ( see HShfeld and Smolk a 1988 for definition ) satisfies a goal G iff . A satisfies each element of G , and it satisfies a clause H0*---B0 iff either . A fails to satisfy some element of B0 or . A satisfies each element of H0 . 
2 After this paper was accepted , we discovered that a more general formulation of abstraction is required for systems using a hierarchy of types  , such as typed feature structure constraints ( Carpenter 1992 )  . In applications of the Lemma Table Proof Procedure to such systems it may be desirable to abstract from a ' strong ' type cons-tralnt in the body of a clause to a logically ' weaker ' type constraint in the memoized goal  . Such a form of abstraction cannot be implemented using the selection rule alone  . 
This generalizes the standard notion of clause by allowing the head  H0 to consist of more than one at om . The head H0 is interpreted conjunctively ; i . e . , if each element of B0 is true , then so is each element of H0 . The standardef inition of resolution extends unproblematically to such clauses  . 
Definition 2 We say that a clause co- H0  ~  B0 resolves with a clause cl = Ht ~-- BI on a nonempty set of literals CC_Boiff there is a variant Cl~ofel of the form C*---BI'such that V  ( co ) NV ( B x ' ) CV ( C )   ( i . e . , the variables common to e0 and BI ~ also appear in C , so there is no accidental variable sharing ) . 
If Core solves with Clon C , then the clause H0 ~ ( B0-C ) UBx ' is called a resolvent of cowith
C 1 On C .
Now we define items , which are the basic computational units that appear on the agenda and in the lemma tables  , which record memoized subcomputations . 
Definition 3An item is a pair ( t , c ) where c is a clause and t is a tag , i . e . , one of program , solution or table ( B ) for some goal B . A lemma table for a goal G is a pair ( G , La ) where La is a finite list of items . 
The algorithm manipulates a set T of lemma tables which has the property that the first components of any two distinct members of T are distinct  . This justifies speaking of the ( unique ) lemma table in T for a goal G . 
Tags are associated with clauses by a user -specified control rule  , as described below . The tag associated with a clause in an item identifies the ope-ration that should be performed on that clause  . The solution tag labels ' completed ' clauses , the program tag directs the proof procedure to perform a non-memoizing resolution of one of the clanse's negative literals with program clauses  ( the particular negative literal is chosen by a user-specified selection rule  , as in standard SLD resolution ) , and the table ( B ) tag indicates that a subcomputation with root goal B  ( which is always a subset of the clause's negative literals  ) should be started . 
Definition 4 A control rule is a function from clauses G*--B to one of program  , solution or table ( C ) for some goal CCB . A selection rule is a function from clauses G *-- B where B contains at least one relational atom to relational atoms a  , where a appears in B . 
Because program steps do not require memoization and given the constraints on the control rule just mentioned  , the list LG associated with a lemma table ( G , LG ) will only contain items of the form ( t , G , -- B ) where t is either solution or table ( C ) for some goal CC_B . 
Definition 5To add an item an item e = ( t , H  ~ B ) to it stable means to replace the table ( H , L ) in T with ( H , JelL\]) . 

Input A nonempty goal G , a program P , a selection rule S , and a control rule R . 
OutputA set of goals G ' for which RiG ' ) = solution and P~G*--G' . 
Global Data Structures A set T of lemma tables and a set A of items called the agenda  . 
Algorithm Set T := ( G , 0) and A := (( program , G*--G ) . 
Until A is empty , do:
Remove an item e = it , c ) from A.
Caset of program For each clause pEP such that cresolves with p on S  ( c )  , choose a corresponding resolvent e ' and addiRic  '  )  , c ') to A . 
table ( B ) Adde to its table , s
If T contains a table ( B' , L ) where B'is a variant of B then for each item ( solution , d ) EL such that cresolves with d on B choose a corresponding resolvent d ' and addiR  ( c " )  , d ') to A . 
Otherwise , add a new table iB , ?) to T , and add ( program , B~--B ) to the agenda . 
solution Adde to its table.
Let e = H~B . Then for each item of the form ( tabh(H') , d ) in any table in T where H ' is a variant of H and c ' resolves with conH '  , choose a corresponding resolvent d ' and add ( R ( d ' )  , d ') to A . 
Set r := B : ( solution , G*--B ) EL , /G , L ) ET . 
Figure 2: The Lemma Table algorithm
The formal description of the Lemma Table proof procedure is given in Figure  2  . We prove the so-undness and completeness of the proof procedure in DSrre and Johnson  ( in preparation )  . In fact , so-undness is easy to show , since all of the operations are resolution steps . Completeness follows from the fact that Lemma Table proofs can be ' unfolded ' into standard SLD search trees  ( this unfolding is well-founded because the first step of every table-initiated subcomputation is required to be a program resolution  )  , so completeness follows from HShfeld and Smolka's completeness theorem for SLD resolution in CLP  . 
4 A worked example
Returning to the categorial grammar example above , the control rule and selection rule are specified by the Prolog code below  , which can be informally described as follows . All x/3 literals are classified as ' memo ' literals , and add_adjuncts /2 and division /2 whose second arguments are not sufficiently instantiated are classified as ' delay ' literals  . 
If the clause contain same moliteral G , then the control rule returns table i\[G\]) . Otherwise , if the clause contains any non-delay literals , then the control rule 3In order to handle the more general form of abstraction discussed in footnote  2which may be useful with ty-ped feature structure constraints  , replace B with a(B ) in this step , where a ( B ) is the result of applying the abstraction operation to B  . 
The abstraction operation should have the property that a  ( B ) is exactly the same as B , excep that zero or more constraints in B are replaced with logically weaker constraints  . 
returns program and the selection rule chooses the leftmost such literal  . If none of the above apply , the control rule returns solution . To simplify the interpreter code , the Prolog code for the selection rule and table iG  ) output of the control rule also return the remaining literals along with chosen goal  . 
:- ensure_loaded(library(lists )).
:- op(990, fx,\[delay , memo\]).
delay division(_ , X/Y ) :- var(l) , var(Y ) . 
delayadd_adjuncts(_,X/Y ) :- vat(X ), vat(Y).
memox (.....).
control(GsO , Control ) :- memo(G ) , select ( G , CeO , Gs ) -> Control = table(\[G\] , G s ); member(G , G s O ) , \+ delay(G ) -> Control = program;
Control = solution.
selection ( GsO , G , Gs ) :- select ( G1 , G s O , Gel ) , \+ delay(Gl ) -> G = Gl , Ca = Gel . 
Because we do not represent variable binding as explicit constraints  , we cannot implement ' abstraction ' by means of the control rule and require an explicit abstraction operation  . The abstraction operation here unbinds the first and third arguments of  x/3 goals , as discussed above . 
abetraction(\[x(_,Left,_)\],\[x(_,Left,_)\]).
104 0 . 1\[ o\]e 0 . 211 \] T 0 . 311 \] T 0 . 411 \] P 0 . 514 \] s 0 . 6\[2,5\]W1 . 716\]P 1 . 817 \] T 1 . 917\]T 1 . 1017\]P 1 . 111 101 S 0 . 1216, 11\] S 0 . 1312, 12\]W 2 . 14113\]P 2 . 15114\]W 2 . 161141 T 0 . 1713, 12\]T 1 . 1819, 11\]T 0 . 1913 , 5\]Tx(A , \[ l_t , o \] , B ) ~-- x(A , \[ l_t , o \] , B ) . 
x(A , \[ l_t , o \] , B ) ~ -- x(A/C , \[ l_t , o \] , D ) , x(C , D , B ) . 
x(A , \[ l_t , o \] , B ) ~ x(C , \[ l_t , o \] , D ) , x(A\C , D , B ) . 
x(A,\[l_t,o\],\[o\])*--lex(l_t,A).
x(A/#B , \[ l_t , o \] , \[ o \]) ~-- add ( s\np/(s\np) , C ) , div(C , A/B ) . 
x(A , \[ l_t , o \] , B ) ~ add ( s\np/(s\np) , C ) , div(C , A/D ) , x(#D , \[ o\] , B ) . 
x(A,\[o \], B ) ~ x(A,\[o \], S).
x(A , \[ o\] , B ) *-- x(A/C , \[ o\] , D ) , x(C , D , B ) . 
x(A , \[ o\] , B ) ~-- x(C , \[ o\] , D ) , x(A\C , D , S ) . 
x(A,\[o \],4) ~- lex(o,A).
x(#A,\[o\],~)~-add(s\np\np,A).
x(A , \[ l_t , o \] , 0) ~'- add ( s\np\np , S ) , add ( s\np/(s\np ) , C ) , div(C , A/B ) . 
x(A , \[ Lt , o \] , B )* -- add ( s\np\np , C ) , add ( s\np/(s\np ) , D ) , div(D , A/E/C ) , x(E , Q , B ) . 
x(A , 0, B ) ~- x(A , 0, B).
x(A,0,B ) ~- x(A/C,Q,D ), x(C,D,B).
x(h , 4, B ) + -- x(C , 4, D ), x(A\C,D,B).
x(A , \[ l_t , o \] , B ) ~-- add ( s\np\np , C ) , add ( s\np/(s\np ) , D ) , div(D , E/C ) , x(A\E ,  ~ , B ) . 
x(A , \[ o\] , B ) ~-- add ( s\np\np , C ) , x(A\#C ,  ~ , B ) . 
x(A , \[ l_t , o \] , B ) ~ add ( s\np/(s\np) , C ) , div(C , D/E ) , x(A\(D/#E ) , \[ o\] , B ) . 
Figure 3: The items produce during the proof of x ( ? , \[ lijkLte , on ~ wijken J , = ) using the control and selection rules specified in the text  . The prefix t . n\[a\]T identifies the tablet to which this item belongs  , assigns this item a unique identifying number n , provides the number ( s ) of the item ( s ) a which caused this item to be created , and displays its tag T ( P for ' program ' , T for ' table ' and S for ' solution ') . The selected literal(s ) are shown underlined . To save space , ' add_adjuncts ' i abbreviated by ' add ' , ' division ' by ' div ' , ' lijkt_te'by'It ' , and ' on twijken'by'o ' . 
Figure 3 depicts the proof of a parse of the verb clu-ster in  ( 1 )  . Item 1 is generated by the initial goal ; its sole negative literal is selected for program resolution  , producing items 24 corresponding to three program clauses for x/3  . Because items 2 and 3 contain ' memo ' literals , the control rule tags them table ; there already is a table for a variant of these goals  ( after abstraction )  . Item 4 is tagged program bec-ause it contains a negative literal that is not'memo'or'delay'  ; the resolution of this literal with the program clauses for  lex/3 produces item 5 containing the constraint literals associated with lijktre  . Both of these are classified as ' delay ' literals  , so item 5 is tagged solution , and both are ' inherited ' when item 5 resolves with the table-tagged items 2 and 3  , produ-cing items 6 ( corresponding to a right application analysis with lijkt teas functor  ) and item 19 ( corresponding to a left application analysis with ont  . 
wijken as functor ) respectively . Item 6 is tagged table , since it contain sax/3 literal ; because this goal's second argument ( i . e . , the left string position ) differs from that of the goal associated with table  0  , a new table ( table 1) is constructed , with item 7 as its first item . 
The three program clauses for x/3 are used to resolve the selected literal in item 7  , just as in item 1 , yielding items 810 . The lex/3 literal in item 10 is resolved with the appropriate program clause , producing item 11 . Just as in item 5 , the second argument of the single literal in item  11 is not sufficiently instantiated , so item 11 is tagged solution , and the unresolved literal is ' inherited ' by item  12  . Item 12 contains the partially resolved analysis of the verb complex  . Items 1316 analyze the empty string ; notice that there are no solution items for table  2  . 
Items 1719 represent partial alternative analyses of the verb cluster where the two verbs combine using other rules than forward application  ; again , these yield no solution items , so item 12 is the sole analysis of the verb cluster . 
5 A simple interpreter
This section describes an implementation of the Lemma Table proof procedure in Prolog  , designed for simplicity rather than efficiency . Tables are stored in the Prolog database , and no explicit agenda is used . The dynamic predicate goal_Cable(G , I ) records the initial goals G for each table subcompu-tation and that table's identifying index I  ( a number assigned to each table when it is created  )  . The dynamic predicate table_solution ( I , S ) records all of the solution items generated for table I so far  , and table_paxent(I , T ) records the table items T , called ' parent items ' below , which are ' waiting ' for additional solution items from table I  . 
The ' toplevel ' goal is prove(G , Cs ) , where G is a list of ( unresolved ) solution constraints ( different solutions are enumerated through backtracking  )  . 
p rove/2 starts by retracting the tables associa-ted with previous computations  , asserting the table entry associated with the initial goal  , and then calls take_action/2 to perform a program resolution on the initial goal  . After all succeeding steps are complete ,   prove/2 returns the solutions associated with table 0  . 
prove ( Goal , _Constraints ): - retract all ( goal_gable(_ ,  _) ) , retract all ( table_solution (_ ,  _) ) , retract all ( gable_parent(_ ,  _) ) , regract all ( counter(_)) , assert ( goal_gable(\[Goal\] , O )) , ? ake_acgion(proEram , \[Goal\]::-\[Goal\] , O ) , fail . 
prove ( Goal , Constraints ):- table_solution(O , \[Goal\]::-Constraints ) . 
The predicate take_action(L , C , I ) processes items . 
L is the item's label , Cits clause and I is the index of the table it belongs to  . The first clause calls complete/2 to resolve the solution clause with any parent items the table may have  , and the third clause constructs a parent item term  ( which enco-des both the clause , the tabled goal , and the index of the table the item belongs to ) and calls insert_into_table/2 to insert it into the appropriate table . 
take_action(solution , Clause , Index ) :- assert ( Cable_solution(Index , Clause )) , find all ( P , gable_parent(Index , P ) , 
Paren ? Items ) , member ( Parent Igem , ParenCItems ) , complete ( Parent Item , Clause ) . 
take_acCion(proEram , Head::-Goal , Index ) :- selection ( Goal , Selected , Bodyl ) , 
Selected : :- Hody O , append ( Body O , Bodyl , Body ) , control ( Body , Action ) , take_action(Action , Head : :- Body , Index ) . 
take_action(table(Goal , Other ), Head::-_Body,
Index ) :- inserr_into_table(Goal , ? able Item ( Head , Goal , Other , Index )) . 
c omplete/2 takes an item labeled table and a clause , resolves the head of the clause with the item , and calls control /2 and take_act ion/3 to process the resulting item . 
complete ( table Item ( Head , Goal , Body1, Index ),
Goal::-BodyO ) :- append(BodyO , Bodyl , Body ) , control ( Body , Action ) , take_action(Action , Head : :- Body , Index ) . 
The first clause insert_into_table /2 checks to see if a table for the goal to be tabled has already been constructed  (   numbervars/3 is used to ground a copy of the term )  . If an appropriate table does not exist , the second clause calls create_table /3 to construct one . 
insert_into_table(Goal , ParentItem):-copy_term(Goal , Goal Copy ) , number vars ( Goal Copy , O ,  _) , goal_table(GoalCopy , Index ) ,  ! , assert ( table_parent(Index , Parent Igem )) , find all ( Sol , table_solution(Index , Sol ) , 
Solutions ) ,  ! , member ( Solutlon , Solutions ) , complege ( Pareng Item , SQ lugion ) . 
insert_into_table(GoalO , ParentICem ) :- absgraction(GoalO , Goal ) ,  ! , create_gable(Goal , Pareng Item , Index ) , ? ake_action(proEram , Goal::-Goal , Index ) . 
create_table /3 performs the necessary database manipulations to construct a new table for the goal  , assigning a new index for the table , and adding appropriat entries to the indices . 
create_table ( Goal , Parent I ? ~ , Index ) :-( retract ( councer(IndexO )) -> true ; Index O = O) , 
Index is Index O+l , assert ( counter(Index )) , assert ( goal_ table ( Goal , Index )) , assert ( table_parent(Index , Parent Item )) . 
6 Conclusion
This paper has presented a general framework which allows both constraint coroutining and memoizs - tion  . To achieve maximum generality we stated the Lemma Table proof procedure in HShfeld and Smolka's  ( 1988 ) CLP framework , but the basic idea--that arbitrary constraints can be allowed to propagate in essentially the same way that variable bindings do--can be applied in most approaches to complex feature based parsing  . For example , the technique can be used in chart parsing : in such a system an edge consists not only of a dotted rule and associated variable bindings  ( i . e . , instantiated feature terms ) , but also contains zero or more as yet unresolved constraints that are propagated  ( and simplified if sufficiently instantiated ) uring application of the fundamental rule . 
At a more abstract level , the identical propagation of both variable bindings and more general cons-traints leads us to question whether there is any principled ifference between them  . While still preli-minary , our research suggests that it is often possible succinctly by using more general constraints  . 
References
G . Bouma and G . van Noord . Constraint-Based Ca-tegorial Grammar . In Proceedings of the 3Pnd Annual Meeting of the ACL , New Mexico State University , Las Cruces , New Mexico ,  1994 . 
B . Carpenter . The Logic of Typed Feature Structu-res . Cambridge Tracts in Theoretical Computer Science 32  . Cambridge University Press .  1992 . 
J . DS rre . Generalizing Earley deduction for constraint -based grammars  . In J . D6rre(ed . ) , Computational Aspects of Constraint-Based Linguistic Description I  , DYANA-2 deliverable RI . ~ . A . ESPRIT , Basic Research Project 6852,
July 1993.
J . DSrre and M . Johnson . Memoization and co-routined constraints , ms . Institut fiir maschinelle Sprachverarbeitung , Universit ~ it Stuttgart . 
M . HShfeld and G . Smolka . Definite Relations over Constraint Languages . LILOG Report 53 , IWBS , IBM Deutschland , Postfach 8008 80 , 7000 Stuttgart 80 , W . Germany , October 1988 . ( available online by anonymousftp from/duck . dfki . uni-sb . de:/pub/papers ) M . Johnson . Memoization in Constraint Logic Programming . Presented at First Workshop on Principles and Practice of Constraint Programming  , April P8-301993 , Newport , Rhode Island . 
F . C . Pereira and D . H . Warren . Parsing as Deduction . In Proceedings of the Plst Annual Meeting of the ACL  , Massachusetts Institute of Technology , pp . 137-144, Cambridge , Mass . , 1983 . 
S . M . Shieber . Using Restriction to Extend Par-sing Algorithms for Complex-Feature-Based Formalisms  . In Proceedings of the 23rd Annual Mee-ting of the Association for Computational Linguistics  , pp .  145-152, 1985 . 
Tamaki , H . and T . Sato . " OLDT resolution with tabulation " , in Proceedings of Third International Conference on Logic Programming  , Springer-
Verlag , Berlin , pages 84-98.1986.
Vieille , L . " Recursive query processing : the power of logic  "  , Theoretical Computer Science 69 , pages 153 .  1989 . 
Warren , D . S . " Memoing for logic programs " , in Communications of the ACM 35:3 , pages 94-111 . 


