Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP , pages 861?869,
Suntec , Singapore , 27 August 2009. c?2009 ACL and AFNLP
Semantic Tagging of Web Search Queries Mehdi Manshadi Xiao Li University of Rochester Microsoft Research Rochester , NY Redmond , WA mehdih@cs.rochester.edu xiaol@microsoft.com Abstract
We present a novel approach to parse web search queries for the purpose of automatic tagging of the queries . We will define a set of probabilistic contextfree rules , which generates bags ( i.e . multisets ) of words . Using this new type of rule in combination with the traditional probabilistic phrase structure rules , we define a hybrid grammar , which treats each search query as a bag of chunks ( i.e . phrases ). A hybrid probabilistic parser is used to parse the queries . In order to take contextual information into account , a discriminative model is used on top of the parser to rerank the nbest parse trees generated by the parser . Experiments show that our approach outperforms a basic model , which is based on Conditional Random Fields . 1 Introduction Understanding users ? intent from web search queries is an important step in designing an intelligent search engine . While it remains a challenge to have a scientific definition of '' intent '', many efforts have been devoted to automatically mapping queries into different domains i.e . topical classes such as product , job and travel ( Broder et al 2007; Li et al 2008). This work goes beyond query-level classification . We assume that the queries are already classified into the correct domain and investigate the problem of semantic tagging at the word level , which is to assign a label from a set of predefined semantic labels ( specific to the domain ) to every word in the query . For example , a search query in the product domain can be tagged as : cheap garmin streetpilot c340 gps | | | | | SortOrder Brand Model Model Type
Many specialized search engines build their indexes directly from relational databases , which contain highly structured information . Given a query tagged with the semantic labels , a search engine is able to compare the values of semantic labels in the query ( e.g ., Brand = ? garmin ?) with its counterpart values in documents , thereby providing users with more relevant search results . Despite this importance , there has been relatively little published work on semantic tagging of web search queries . Allan and Raghavan (2002) and Barr et al (2008) study the linguistic structure of queries by performing part-of-speech tagging . Pasca et al (2007) use queries as a source of knowledge for extracting prominent attributes for semantic concepts . On the other hand , there has been much work on extracting structured information from larger text segments , such as addresses ( Kushmerick 2001), bibliographic citations ( McCallum et al 1999), and classified advertisements ( Grenager et al 2005), among many others . The most widely used approaches to these problems have been sequential models including hidden Markov models ( HMMs ), maximum entropy Markov models ( MEMMs ) ( Mccallum 2000), and conditional random fields ( CRFs ) ( Lafferty et al 2001) These sequential models , however , are not optimal for processing web search queries for the following reasons .. The first problem is that the global constraints and long distance dependencies on state variables are difficult to capture using sequential models . Because of this limitation , Viola and Narasimhand (2007) use a discriminative contextfree ( phrase structure ) grammar for extracting information from semistructured data and report higher performances over CRFs . Secondly , sequential models treat the input text as an ordered sequence of words . A web search query , however , is often formulated by a user as a bag of keywords . For example , if a user is look-
861
ing for cheap garmin gps , it is possible that the query comes in any ordering of these three words . We are looking for a model that , once it observes this query , assumes that the other permutations of the words in this query are also likely . This model should also be able to handle cases where some local orderings have to be fixed as in the query buses from New York City to Boston , where the words in the phrases from New York city and to Boston have to come in the exact order . The third limitation is that the sequential models treat queries as unstructured ( linear ) sequences of words . The study by Barr et al (2008) on Yahoo ! query logs suggests that web search queries , to some degree , carry an underlying linguistic structure . As an example , consider a query about finding a local business near some location such as : seattle wa drugstore 24/7 98109 This query has two constituents : the Business that the user is looking for (24/7 drugstore ) and the Neighborhood ( seattle wa 98109). The model should not only be able to recognize the two constituents but it also needs to understand the structure of each constituent . Note that the arbitrary ordering of the words in the query is a big challenge to understanding the structure of the query . The problem is not only that the two constituents can come in either order , but also that a subconstituent such as 98109 can also be far from the other words belonging to the same constituent . We are looking for a model that is able to generate a hierarchical structure for this query as shown in figure (1). The last problem that we discuss here is that the two powerful sequential models i.e . MEMM and CRF are discriminative models ; hence they are highly dependent on the training data . Preparing labeled data , however , is very expensive . Therefore in cases where there is no or a small amount of labeled data available , these models do a poor job . In this paper , we define a hybrid , generative grammar model ( section 3) that generates bags of phrases ( also called chunks in this paper ). The chunks are generated by a set of phrase structure ( PS ) rules . At a higher level , a bag of chunks is generated from individual chunks by a second type of rule , which we call contextfree multiset generating rules . We define a probabilistic version of this grammar in which every rule has a probability associated with it . Our grammar model eliminates the local dependency assumption made by sequential models and the ordering constraints imposed by phrase structure grammars ( PSG ). This model better reflects the underlying linguistic structure of web search queries . The model?s power , however , comes at the cost of increased time complexity , which is exponential in the length of the query . This , is less of an issue for parsing web search queries , as they are usually very short (2.8 words/query in average ( Xue et al , 2004)). Yet another drawback of our approach is due to the contextfree nature of the proposed grammar model . Contextual information often plays a big role in resolving tagging ambiguities and is one of the key benefits of discriminative models such as CRFs . But such information is not straightforward to incorporate in our grammar model . To overcome this limitation , we further present a discriminative reranking module on top of the parser to rerank the nbest parse trees generated by the parser using contextual features . As seen later , in the case where there is not a large amount of labeled data available , the parser part is the dominant part of the module and performs reasonably well . In cases where there is a large amount of labeled data available , the discriminative reranking incorporates into the system and enhances the performance . We evaluate this model on the task of tagging search queries in the product domain . As seen later , preliminary experiments show that this hybrid genera-tive/discriminative model performs significantly better than a CRF-based module in both absence and presence of the labeled data . The structure of the paper is as follows . Section 2 introduces a linguistic grammar formalism that motivates our grammar model . In section 3, we define our grammar model . In section 4 we address the design and implementation of a parser for this kind of grammar . Section 5 gives an example of such a grammar designed for the purpose of automatic tagging of queries . Section 6 discusses motivations for and benefits of running a discriminative reranker on top of the parser . In section 7, we explain the evaluations Figure 1. A simple grammar for product domain the time-complexity is not a bottleneck as web search queries are usually very short (2.8 words per query in average ). Moreover , the nature of ID rules can be deceptive as it might appear that ID rules allow any reordering of the words in a valid sentence to occur as another vaild sentence of the language . But in general this is not the case . For example consider a grammar with only two ID rules given in (5) and consider S as the start symbol : (5) S ? B , c B ? d , e It can be easily verified that dec is a sentence of the language but dce is not . In fact , although the permutation of subconstituents of a constituent is allowed , a subconstituent can not be pulled out from its mother consitutent and freely move within the other constituents . This kind of movement however is a common behaviour in web search queries as shown in figure (1). It means that even ID rules are not powerful enough to model the free-word-order nature of web search queries . This leads us to define to a new type of grammar model . 3 Our Grammar Model 3.1 The basic model We propose a set of rules in the form : (6) S ? { B , c } B ? { D , E } D ? { d } E ? { e } which can be used to generate multisets of words . For the notation convenience and consistancy , throughout this paper , we show terminals and nonterminals by lowercase and uppercase letters , respectively and sets and multisets by bold font uppercase letters . Using the rules in (6) a sentence of the language ( which is a multiset in this model ) can be derived as follows : (7) S ? { B , c } ? { D , E , c } ? { D , e , c }? { d , e , c } Once the set is generated , it can be realized as any of the six permutation of d , e , and c . Therefore a single sequence of derivations can lead to six different strings of words . As another example consider the grammar in (8). (8) Query ? { Business , Location } Business ? { Attribute , Business } Location ? { City , State } Business ? { drugstore } | { Resturant } Attribute ? { Chinese } | {24/7} City ? { Seattle } | { Portland } State ? { WA } | { OR } definitions , parsing a multiset X means to find all ( if any ) the derivations of X from S . 2 3.2 Probabilisic CFSG Very often a sentence in the language has more than one derivation , that is the sentence is syntactically ambiguous . One natural way of resolving the ambiguity is using a probabilistic grammar . Analogous to PCFG ( Manning and Sch?tze 1999), we define the probabilistic version of a CFSG , in which every rule Ai?Xj has a probability P(Ai?Xj ) and for every nonterminal Ai , we have : (9) ? j P(Ai ? Xj ) = 1 Consider a sentence w1w2?wn , a parse tree T of this sentence , and an interior node v in T labeled with Av and assume that v1, v2, ? vk are the children of the node v in T . We define : (10) ?( v ) = P(Av ? { Av1? Avk})?(v1) ? ?( vk ) with the initial conditions ?( wi)=1. If u is the root of the tree T we have : (11) P(w1w2?wn , T ) = ?( u ) The parse tree that the probabilistic model assigns to the sentence is defined as : (12) Tmax = argmaxT ( P(w1w2?wn , T )) where T ranges over all possible parse trees of the sentence . 4 Parsing Algorithm 4.1 Deterministic parser The parsing algorithm for the CFSG is straightforward . We used a modified version of the Bot-tom-Up Chart Parser for the phrase structure grammars ( Allen 1995, see 3.4). Given the grammar G=(N,T,S,R ) and the query q=w1w2?wn , the algorithm in figure (4) is used to parse q . The algorithm is based on the concept of an active arc . An active arc is defined as a 3? 2 Every sentence of a language corresponds to a vector of | T | integers where the kth element represents how many times the kth terminal occurs in the multiset . In fact , the languages defined by grammars are not interesting but the derivations are.
Figure 2. A CFSG parse tree Figure 3. A CFSG parse tree c =( A , I , pc ) When extending ? using c , we have : (13) p ? ? p ? pc When creating c from the completed active arc ? : (14) pc ? p ? p(r ) Although search queries are usually short , the running time is still an issue when the length of the query exceeds 7 or 8. Therefore a couple of techniques have been used to make the na?ve algorithm more efficient . For example we have used pruning techniques to filter out structures with very low probability . Also , a dynamic programming version of the algorithm has been used , where for every subset I of the word positions and every nonterminal A only the highest-ranking constituent c=(A , I , p ) is kept and the rest are ignored . Note that although more efficient , the dynamic programming version is still exponential in the length of the query . 5 A grammar for semantic tagging As mentioned before , in our system queries are already classified into different domains like movies , books , products , etc . using an automatic query classifier . For every domain we have a schema , which is a set of predefined tags . For example figure (5) shows an example of a schema for the product domain . The task defined for this system is to automatically tag the words in the query with the tags defined in the schema : cheap garmin streetpilot c340 gps | | | | | SortOrder Brand Model Model Type Initialization : For each word wi in q add ( wi , { i }) to Chart and to Agenda For all r : A?X in R , create an active arc ( r , X , {}) and add it to the list of active arcs . Iteration Repeat Pull a constituent c = ( A , I ) from Agenda For every active arc ? =( r:B?X , U , I ) Extend ? using c if extendable If U =? add ( B , I ) to Chart and to Agenda Until Agenda is empty Termination For every item c=(S , {1..n }) in Chart , return the tree rooted at c . Figure 4. An algorithm for parsing deterministic CFSG lar expressions . The rest of the tags are simply preterminals generating word tokens . Note that we have a lexicon , e.g .., a Brand lexicon , for all the tags except Type and Attribute . The model , however , extends the lexicon by including words discovered from labeled data ( if available ). The gray color for a nonterminal on the righthand side ( RHS ) of some rule means that the nonterminal is optional ( see Query rule in figure (6)). We used the optional nonterminals to make the task of defining the grammar easier . For example if we consider a rule with n optional nonterminals on its RHS , without optional nonterminals we have to define 2n different rules to have an equivalent grammar . The parser can treat the optional nonterminals in different ways such as precompiling the rules to the equivalent set of rules with no optional nonterminal , or directly handling optional nonterminals during the parsing . The first approach results in exponentially many rules in the system , which causes sparsity issues when learning the probability of the rules . Therefore in our system the parser handles optional nonterminals directly . In fact , every nonterminal has its own probability for not occurring on the RHS of a rule , therefore the model learns n+1 probabilities for a rule with n optional nonterminals on its RHS : one for the rule itself and one for every nonterminal on its RHS . It means that instead of learning 2n probabilities for 2n different rules , the model only learns n+1 probabilities . That solves the sparsity problem , but causes another issue which we call short length preference . This occurs because we have assumed that the probability of a nonterminal being optional is independent of other optional nonterminals . Since for almost all nonterminals on the RHS of the query rule , the probability that the nonterminal does not exist in an instance of a query is higher than 0.5, a null query is the most likely query that the model generates ! We solve this problem by conditioning the probabilities on the length of queries . This brings a tradeoff between the two other alternatives : ignoring sparsity problem to prevent making many independence assumptions and making a lot of independence assumptions to address the sparsity issue . Unlike sequential models , the grammar model is able to capture critical global constraints . For example , it is very unlikely for a query to have more than one Type , Brand , etc . This is an important property of the product queries that can help to resolve the ambiguity in many cases . In practice , the probability that the model learns for a rule like : Query ? { Brand *, Product *, Model *, ?} Brand * ? { Brand } Brand * ? { Brand *, Brand } Type * ? { Type } Type * ? { Type *, Type } Model * ? { Model } Model * ? { Model *, Model } ? Figure 6. A simple grammar for product domain Type : Camera , Shoe , Cell phone , ? Brand : Canon , Nike , At&t , ? Model : dc1700, powershot , ipod nano Attribute : 1GB , 7mpixel , 3X , ? BuyingIntenet : Sale , deal , ? ResearchIntent : Review , compare , ? SortOrder : Best , Cheap , ? Merchant : Walmart , Target , ? Figure 5. Example of schema for product domain tences ( Collins and Koo 2005) have shown that if , instead of taking the most likely tree structure generated by a parser , the nbest parse trees are passed through a discriminative reranking module , the accuracy of the model will increase significantly . We use the same idea to improve the performance of our model . We run a Support Vector Machine ( SVM ) based reranking module on top of the parser . Several contextual features ( such as bigrams ) are defined to help in disambiguation . This combination provides a framework that benefits from the advantages of both generative and discriminative models . In particular , when there is no or a very small amount of labeled data , a parser could still work by using unsupervised learning approaches to learn the rules , or by simply using a set of handbuilt rules ( as we did above for the task of semantic tagging ). When there is enough labeled data , then a discriminative model can be trained on the labeled data to learn contextual information and to further enhance the tagging performance . 7 Evaluation Our resources are a set of 21000 manually labeled queries , a manually designed grammar , a lexicon for every tag ( except Type and Attribute ), and a set of regular expressions defined for Models and Attributes . Note that with a grammar similar to the one in figure (6), generating a parse tree from a labeled query is straightforward . Then the parser is trained on the trees to learn the parameters of the model ( probabilities in this case ). We randomly extracted 3000, out of 21000, queries as the test set and used the remaining 18000 for training . We created training sets with different sizes to evaluate the impact of training data size on tagging performance . Three modules were used in the evaluation : the CRF-based model4, the parser , and the parser plus the SVM-based reranking . Figure (8) shows the learning curve of the word-level Fscore for all the three modules . As seen in this plot , when there is a small amount of training data , the parser performs better than the CRF module and parser+SVM module performs better than the other two . With a large amount of training data , the CRF and parser almost have the same performance . Once again the parser+SVM module 4 The CRF module also uses the lexical resources and regular expressions . In fact , it applies a deterministic context free grammar to the query to find all the possible groupings of words into chunks and uses this information as a set of features in the system.
Figure 7. Two equivalent CFSG parse trees to take contextual information into account . We have used this system for automatic tagging of web search queries and have compared it with a CRF-based model designed for the same task . The parser performs much better when there is a small amount of training data , but an adequate lexicon for every tag . This is a big advantage of the parser model , because in practice providing labeled data is very expensive but very often the lexicons can be easily extracted from the structured data on the web ( for example extracting movie titles from imdb or book titles from Amazon ). Our hybrid model ( parser plus discriminative reranking ), on the other hand , outperforms the other two modules regardless of the size of the training data . The main drawback with our approach is to completely ignore the ordering . Note that although strict ordering constraints such as those imposed by PSG is not appropriate for modeling query structure , it might be helpful to take ordering information into account when resolving ambiguity . We leave this for future work . Another interesting and practically useful problem that we have left for future work is to design an unsupervised learning algorithm for CFSG similar to its phrase structure counterpart : insideoutside algorithm ( Baker 1979). Having such a capability , we are able to automatically learn the underlying structure of queries by processing the huge amount of available unlabeled queries . Acknowledgement We need to thank Ye-Yi Wang for his helpful advices . We also thank William de Beaumont for his great comments on the paper.
References
Allan , J . and Raghavan , H . (2002) Using Part-of-speech Patterns to Reduce Query Ambiguity , Proceedings of SIGIR 2002, pp . 307-314. Allen , J . F . (1995) Natural Language Understanding , Benjamin Cummings . Baker , J . K . (1979) Trainable grammars for speech recognition . In Jared J . Wolf and Dennis H . Klatt , editors , Speech communication papers presented at the 97th Meeting of the Acoustical Society of America , MIT , Cambridge , MA . Barton , E . (1985) On the complexity of ID/LP rules , Computational Linguistics , Volume 11, Pages 205-218.
Figure 8. The learning curve for the three modules Train?No?=?18000?Test?No?=?3000? P ? R ? F ? Q?CRF ? 0.815? 0.812? 0.813? 0.509?Parser ? 0.808? 0.814? 0.811? 0.494?Parser+SVM?(n?=?2)? 0.823? 0.827? 0.825? 0.531?Parser+SVM?(n?=?10)? 0.832? 0.835? 0.833? 0.555?Table 1. The results of evaluating the three modules
