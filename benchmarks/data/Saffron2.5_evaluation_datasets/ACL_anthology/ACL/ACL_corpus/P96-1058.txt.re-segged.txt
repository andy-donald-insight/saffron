Maximizing Top-down Constraints for Unification -based Systems 
Noriko Tomuro
School of Computer Science , Telecommunications and Information Systems
DePaul University
Chicago , IL 60604
cphdnt@ted.cs.depaul.edu
Abstract
A left-corner parsing algorithm with topdown filtering has been reported to show very efficient performance for unification-based systems  . However , due to the non-termination of parsing with left -recursive grammars  , topdown constraints must be weakened . In this paper , a general method of maximizing topdown constraints i proposed  . The method provides a procedure to dynamically compute * restrictor  . , a minimum set of features involved in an infinite loop for every propagation path  ; thus topdown constraints are maximally propagated . 
1 Introduction
A left-corner parsing algorithm with topdown filtering has been reported to show very efficient performance for unification-based systems  ( Carroll ,  1994) . 
In particular , topdown filtering seems to be very effective in increasing parse efficiency  ( Shann ,  1991) . 
Ideally all topdown expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earlies time  . 
However , in the context of unification-based parsing , left-recursive grammars have the formal power of a Turing machine  , therefore detection of all infinite loops due to left-recursion is impossible  ( Shieber ,  1992) . So , topdown constraints must be weakened in order for parsing to be guaranteed to terminate  . 
In order to solve the nontermination problem , Shieber (1985) proposes restrictor , a statically predefined set of features to consider in propagation  , and restriction , a filtering function which removes the features not in restrictor from topdown expectation  . However , not only does this approach fail to provide a method to automatically generate the restrictor set  , it may weaken the predicative power of topdown expectation more than necessary : a globally defined restrictor can only specify the least common features for all propagation paths  . 
In this paper , a general method of maximizing topdown constraints is proposed  . The method provides a procedure to dynamically compute * restrictor *  , a minimum set of features involved in an infinite loop  , for every propagation path . Features in this set are selected by the detection function  , and will be ignored in topdown propagation . 
Using . vestrictor . , only the relevant features particular to the propagation path are ignored  , thus topdown constraints are maximally propagated . 
2 Notation
We use notation from the PATR-II formalism ( Shieber , 1986) and ( Shieber ,  1992) . Directedaey cliegraphs ( dags ) are adopted as the representation model . The symbol -" is used to represent the equality relation in the unification equations  , and the symbol ? used in the form of pl ? p2 represents the path concatenation fpl and p2  . 
The subsumption relation is defined as " Dag D subsumes dag D ~ if D is more general than D '  . " The unification of D and D ~ is notated by DtJ D  ~  . 
The extraction function D/plextracts the subdag under path pl for a given D  , and the embedding function D\plinjects D into the enclosing dagD ' such that D '/ pl = D  . The filtering function p is similar to ( Shieber ,  1992 ) : p ( D ) returns a copy of D in which some features may be removed  . Note that in this paper . restrictor . specifies the features to be removed by p , whereas in ( Shieber ,  1985 ,  1992 ) restrictor specifies the features to be retained by restriction which is equivalent top  . 
3 Top-down Propagation
Top-down propagation can be precomputed to form a teach ability table  . Each entry in the table is a compiled ag which represent she relation between a nonterminal category and a rule used to rewrite the constituents in the teach ability relation  ( i . e . , reflexive , transitive closure of the left-corner path ) . 
For example , consider the following fragment of a grammar used in the syntax/semantics integrated system called LINK  ( Lytinen ,  1992):
D (1) em

Ic(~._.~eadowner

Figure 1: DAGs used in the example he?r Z=sere ~ owfler
D ( 4 ) rl:NPo-+NP1 POS NP2 ( NP ohead )  =  ( NP2 head )   ( Y Poheadsemowner )  -  ( NP1 head sem )   ( This rule is used to parse phrase such as " Kr is ' s desk "  . ) The dag D ( 1 ) in Figure 11 represents the initial application of rl to the category NP  . Note that the subdag under the lcarc is the rule used to rewrite the constituent on the left -corner path  , and the paths from the top node represent which topdown constraints are propagated to the lower level  . 
Top-down propagation works as follows : given a dad D that represents at each ability relation and a ruled adR whose lefthand side category  ( i . e . , root ) is the same as D's left-corner category ( i . e . , under its ( lc 1) path ) , the resulting dagis D1 = p(D')U(R\lc) , where D ' is a copy of D in which all the numbered arcs and lcarcare deleted and the subdag which used to be under the  ( lc1 ) path is promoted to lie under the lcarc . Dags after the next two recursive applications of rl  ( D ( 2 ) and D ( 3 ) respectively2 ) are shown in Figure 1 . 
Notice the filtering function p is applied only to D '  . In the case when p(D ') = nil , the top node in D1 will have no connections to the ruled a gunder the lcarc  . This means no topdown constraints are propagated to the lower level  , therefore the parsing becomes pure bottom-up . 
In many unification-based systems , subsumption is used to avoid redundancy : a dag is recorded in the table if it is not subsumed by any other one  . 
Therefore , if a newly created dag is incompatible or more general than existing dags  , rule application continues . In the above example , D ( 2 ) is incompatible with D ( 1 ) and therefore gets entered into the table . The owner arc keeps extending in the subsequent recursive applications  ( as in D ( 3 ) ) , thus the propagation goes into an infinite loop . 
1 Category symbols are directly indicated in the dad nodes for simplicity  . 
2 In this case , p is assumed to be an identity function . 
3.1 Proposed Method
Let A be a dag created by the first application of the rule R and B be a dad created by the second application during the topdown propagation  . 3 In the proposed method , A and B are first checked for subsumption . If B is subsumed by A , the propagation for this path terminates . Otherwise a possible loop is detected . The detection function ( described in the next subsection ) is called on A and B and selected features are added to the  . restrictor . set . 4 Then , using the updated * restrictor * , propagation is redone from A . 
When R is applied again yielding B ' , while B'is not subsumed by A , the following process is repeated : if B'is incompatible with A  , the detection function is called on A and B ' and propagation is redone from A  . If B'is more general than A , then A is replaced by B ' ( thereby keeping the most general dag for the path  ) and propagation is redone from B ' . Otherwise the process tops for this propagation path  . Thus , the propagation will terminate when enough features are detected  , or when * restrictor * includes all the ( finite number of ) features in the grammar . 5In the example , when the detection function is called on D ( 1 ) and D ( 2 ) after the first recursive application , the feature owner is selected and added to * restrictor *  . After the propagation is redone from D(1) , the resulting d ad D ( 4 ) becomes more general than O ( 1 )  . 6 Then D(1) is replaced by 0(4) , and the propagation is redone once again . This time it results the same D(4) , therefore the propagation 3 In the case of indirect recursion , there are some intervening rule applications between A and B  . 
4A separate * restrictor * must be kept for each propagation path  . 
51 n reality , category feature will never be in * restrictor * because the same rule R is applied to derive both A and B '  . 
6 Remember 0 ( 4 ) = p ( D ( 1 ) ' ) U ( rl\le ) where p filters out owner arc . 
382 terminates.
3.2 Detection Function
The detection function compares two dags X and Y by checking every constraint  ( unification equation ) x in X with any inconsistent or more general constrainty in Y  . If such a constraint is found , the function selects a path in x or y and detects its last arc/feature as being involved in the possible loop  .   7 If x is the path constraint pl- p2 where pl and p2 are paths of length > I , features may be detected in the following cases :   8  ?  ( case 1 ) If both pl and p2 exist in Y , and there exists a more general constrainty in Y in the form pl ?  p3  -  p2  -  p3   ( length of p3 is also > 1 )  , the path p3 is selected ; ?( case 2) If both pl and p2 exist in Y , but the subdag under pl and the subdag under p2 do not unify , or if neither pl nor p2 exists in Y , whichever of plor p2 does not contain the lcarc , or either if they both contain the lcarc , is selected ; and ? ( case 3 ) If either plorp 2 does not exist in Y , the one which does not exist in Y is selected . 
If x is the constant constraint pl-c ( where c is some constant )  , features may be detected in the following cases :  ?   ( case 4 ) If there exists an incompatible constrainty of the form pl-d where d  7~ c in Y , or if there is no path pl in Y , pl is selected ; and ? ( case 5 ) If there exists an incompatible constrainty of the form pl ?  p2 - c , then p2 is selected . 
4 Related Work
A similar solution to the nontermination problem with unification grammars in Prolog is proposed in  ( Samuelsson ,  1993) . In this method , an operation called anti-unification ( often referred to as generalization as the counterpart of unification  ) is applied to the root and leaf terms of acyclic propagation  , and the resulting term is stored in the reach ablity table as the result of applying restriction on both terms  . Another approach taken in ( Haas ,  1989 ) eliminates the cyclic propagation by replacing the features in the root and leaf terms with new variables  . 
The method proposed in this paper is more general than the above approaches : if the Selection ordering is imposed in the detection function  , features in . restrictor . can be collected incrementally as the cyclic propagations are repeated  . Thus , this method 7This scheme may be rather conservative . 
8Note the cases in this section do not represent all possible situations  . 
is able to create a less restrictive * restrictor . than these other approaches . 
5 Discussion and Future Work
The proposed method has an obvious difficulty : the complexity caused by the repeated propagations could become overwhelming for some grammars  . However , in the experiment on LINK system using a fairly broad grammar  ( over 130 rules )  , precompilation terminated with only a marginally longer processing time  . 
In the experiment , all features ( around 40 syntac-tic/semantic features ) except for one in the example in this paper were able to be used in propagation  . 
In the preliminary analysis , the number of edges entered into the chart has decreased by  30% compared to when only the category feature ( i . e . , contextfree backbone ) was used in propagation . 
For future work , we intend to apply the proposed method to other grammars  . By doing the empirical analysis of precompilation and parse efficiency for different grammars  , we will be able to conclude the practical applicability of the proposed method  . 
We also indend to do more exhaustive case analysis and investigate the selection ordering of the detection function  . Although the current definition covers most cases  , it is by no means complete . 

Carroll , J .  (1994) . Relating complexity to practical performance in parsing with wide-coverage unification grammars  . In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics  , pp .  287-293 . 
Haas , A .  (1989) . A parsing algorithm for unification grammar , Computational Linguistics ,  15(4) , pp . 

Lytinen , S .  (1992) . A unification-based , integrated natural language processing system . Computers and Mathematics with Applications ,  23(6-9) , pp . 

Samuelsson , C .  (1993) . Avoiding non-termination in unification grammars . In Proceedings of Natural Language Understanding and Logic Programming IV  , Nara , Japan . 
Shann , P .  (1991) . Experiments with GLR and chart parsing . In Tomita , M . Generalized LR Parsing . 
Boston : Kluwer Academic Publishers , p . 1734.
Shieber , S .  (1985) . Using restriction to extend parsing algorithms for complex-feature-based formalisms  . In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics  , Chicago , IL , pp .  145-152 . 
Shieber , S .  (1986) . An Introduction to Unification-Based Approaches to Grammar  . Stanford , CA : Center for the Study of Language and Information  . 
Shieber , S .  (1992) . Constraint-based Grammar Formalisms . Cambridge , MA : MIT Press . 

