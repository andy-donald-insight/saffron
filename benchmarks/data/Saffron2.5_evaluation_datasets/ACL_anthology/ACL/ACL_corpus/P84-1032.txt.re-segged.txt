CONCURRENT PARSING IN PROGRAM MABLE LOGIC ARRAY ( PLA- ) NETS
PROBLEM SAND PROPOSALS
Helmut Schnelle
RUHR - Universit ~ t Bochum
Sp ~ ach wissensch aft lichesInstitut
D-4630 Bo chum 1


This contribution attempts a conceptual and practical introduction into the principles of wiring or constructing special machines for language processing tasks instead of programming a universal machine  . Construction would in principle provide higher descriptive adequacy in com-putationally based linguistics  . After all , our heads do not apply programs on stored symbol arrays but are appropriately wired for understanding or producing language  . 
Introductor ~ Remarksi . Forme , computational linguistics is not primarily a technical discipline implementing performance processes for independently defined formal structures of linguistic competence  . 
Computational linguistics should be a foundatio -naldiscipline : It should be related to process -oriented linguistics as the theory of logical calculi is to formal linguistics  ( e . g . generative linguistics , Montague-grammars etc . ) . 
2 . As it stands , computational linguistics does not yet meet the requirements for a foundational discipline  . Searle's arguments against the claims of art if icial intelligence apply fully to computational linguistics : Programmed solutions of tasks may execute the task satisfactorily without giving a model of its execution in the orga-nism  . Our intentional linguistic acts are caused by and realized in complicated concurrent processes occ curring in networks of neurons and are experienced as spontaneous  . This also applies to special cases such as the recognition of syntactic structure  ( parsing )  . These processes are not controlled and executed by central processor units  . 
3 . Computational linguistics must meet the challenge to satisfy the double criterion of des -criptive adequacy : Adequacy in the description of what human being s do  ( e . g . parsing ) and adequacy in the description of ho__~w they do it  ( namely by spontaneous concurrent processes corresponding to unconscious intuitive understanding  )  . It must try to meet the challenge to provide the foundations for a descriptively and explanatori lyadequate process-oriented linguistic  , even when it is clear that the presently available conceptual means for describing complicated concurrent processes-mainly the elements of computer architecture-are far less understood than programming theory and programming technique  . 
4 . Note : It does not stand to question that there is any problem which  , in principle , could not be solved by programming . It is simply the case that almost all solutions are descriptively inadequate for representing and understanding what goes on in human beings even where they provide an adequate representation of input-output relations - and would thus passTuring's test  . 
5 . In my opinion , the main features to be realized in more adequate computational systems are-concurrency of local ized operations  ( instead of centrally controlled sequential processes  )  , and - signal processing ( instead of symbol manipulation )  . 
These features cannot be represented by a program on an ordinary von Neumann machine since this type of machine is by definition a sequential  , centrally controlled symbol manipulator . This does not exclude that programs may simulate concurrent processes  . For instance , programs for testing gate array designs are of this kind  . But simulating programs must clearly separate the features they simulate from the features which are only specific for their sequential operation  . 
Electronic worksheet programs ( in particular those used for planning and testing of gate arrays  ) are appropriate simulators of this type since their display on the monitor shows the network and signal flow whereas the specifics of program exe-cut/on are concealed from the user  . 
6 . How should computational linguistics be developed to meet the challenge ? I think that the general method has already been specified by y on Neumann and Burks in their attempt to compare behavior and structure in computers and brains in terms of cellular automata  . They have shown in this context that we have always two alternatives : Solutions for tasks can be realized by programs to be executed on an universal centrally controlled  ( von Neumann ) machine , or they can be realized by constructing a machine  . Since ordinary - i . e . non-cellular-von-Neumann machines-are sequential  , realization of concurrent processes can only be approached by constructing  ( or describing the construction of such a system , e . g . 
the brain).

My Approach 7 . In view of this , I have developed theoretical net-linguistics on the basis of neurological insights  . My primary intention was to gain insights into the principles of construction and function in ~  ( or structure and behavior ) more than to arrive at a very detailed descriptive neurological adequacy  ( as e . g . in H . Gigley's approach , cp . her contribution on this conference ) . 
8 . The method which tome seemed the most fruitful one for principled analysis is the one applied in systematic architecture for processor construction  . In setting up idealized architectures we should proceed in steps :- select appropriate  9~erat ional primitives , -build basic network modules and define their properties-construct complex networks from modules showing a behavior which is typical for the field to be described  . 
A possible choice is the following :- take logical operators of digital switching networks as primitives  ( and show how they are related to models of neurons  )  , -take AND-planes and OR-planes ( the constituents of progral mmable array logic -PLA  ) together with certain simple configurations such as shift-registers  , -show how linguistic processes ( such as gene-rators and parsers for CF grammars ) could be defined as a combination of basic modules  . 
9 . The method is described and applied in Mead / Conway  ( 1980 )  . They show how logical operators can be realized . Their combination into a com-binational logic module presents three types of design problems  ( cp . ibid . p .  77) , the first two being simple , the third being related to our problem : " a complex function must be implemented for which no direct mapping into a regular structure is known "   ( ibid . p .  79) . " Fortunately , there is a way to map irregular combinational functions onto regular structures  , using the progra/mnable logic array ( PLA ) . . . This technique of implementing combinational functions has a great advantage : functions may be significantly changed without requiring major changes in either the design or layout of the PLA structure  . \[ Figure 13 illus-trates the overall structure of a PLA . The diagram includes the input and output registers  , in order to show how easily these are integrated into the PLA design  . The inputs stored during\[clock sig-nal\]~l in the input register are run vertically through a matrix of circuit elements called the AND plane  . The AND plane generates specific logic combinations of the inputs  . The outputs of the AND plane leave at right angles to its input and run horizontally through another matrix called the OR plane  . The outputs of the OR plane then run vertically and are stored in the output re-gister during\[ clock signal \]  ~2"   ( ibid . p .  80) . 
F?"~~wl,lal,e~Pt " ~ I--ROgAster

I . . . . . . . . . . . . . . . I"----' lORpan q1 .   .   .   .   .   .   .   .   .   .   .   .   .   .   . l~'l ~ Ju , eI ; Ovegall stcuc Luro of Z , a PLA Icf . Mea , \]/ Conway , 1980,, .   81k " There is a very straightforward way to implement finite state machines in integrated systems : we use the PLA form of combinational logic and feedback some of the outputs to inputs  . . . The circuit's structure is topologically regular  , has a reasonable topological interface as a subsystem  , and is of a shape and size which are functions of the appropriate parameters  . The function of this circuit is determined by the ' programming ' of its 
PLA logic " ( ibid . p . 84).
iO . As a first example of the application of these methods  , it has been shown in Schnelle ( forthcoming ) how a complex PLA network composed from AND -planes  , OR-planes , ordinary registers , and shift registers can be derived by a general and formal method from any CF-grammar  , such that the network generates a sequence of control sig-nals  , triggering the production of a corresponding terminal symbol  ( or of a string of terminal symbols )  . The structure derived is a set of units , one for each nonterminal occurring in the grammar and one for each terminal symbol  . Before presenting the network realizing simple units of this type  , we give an informal indication of its functioning  . A unit for a nonterminal symbol occurring to the left of a narrow in the CFgra ~ muar to be real ized which allows m rule alternatives and occurs at n places to the right of the rule arrow has the form of figure  2a   . A unit for a terminal symbol-say " A "- occurr ing at n places to the right of a narrow has the form of figure  2b   . The " STORE "- units can be realized by OR -planes  , the " READ "- units by AND-planes . The flip-flops ( FF ) are simple register units and the shift register is a simple PLA network of wellknown structure  . The reader should note that the notions such as " store "  , " read " and " address " are metaphorical and chosen only to indicate the functioning : The boxes are no_~t subprograms or rules but circuits  . There are neither addresses no racts of selection , nor storing or reading of symbols . 

Ii ,
Illll Uls ( . ? cl/iter+le/++:l:till,jllmXti , . +  . , + m+i . +  . :, li\[uL(~"~%ll,Jr+s~l"-F .  - : -1  . . . .
Im
I_.L ..~; +-+ + ~ ~_~ I_
Ii .
Plgufc2a:(;+ll ? + l'al+\[o~moi ~ . 1111 . ++ alJzl*<j ~ illOl1-Le\[mtn ; l + y all x , Io+LII < ~ ( jl ~ Jlmlnr more complicated cases the signal flow cannot be properly organized by a schematic adaptation of the system realized for production  . I am therefore planning to investigate realiz at ions of concurrent signal flows for bottom-up processors  . At the moment I do not yet have a general method for specifying bottom-up processors in terms of networks  . 
12 . In order to illustrate concurrent information flow during parsing let me present two simple examples  . The first example provides details by an extremely simple wiring diagram of figure  3  , which realizes the " gran ~ mar " S + ; ~ , 
S+AC .
I,"?Ii_t~-_+~+~.l...._h ++ ; ...+_+_._.
++';,+.' L+L,;:,II.

III
I . . . . i ;+ , " .   .   .   .   .   .   . ;'c:";:'+rt :, T .   .   .   .   . 
. . . . . . . . . . . . t .   .   .   .   .  ?  .   .   .   .   . 1 ~! r,~-Il ~ Inlornctlv ~ tlnnx ~ ~ x#p ( . j s1 + r . 21++C . enormlrn , mo\[+~ . , st ? remll ~( n % l . L .   . mI . * ~ L~yml~-~lo(th . < Irm ~ r(tile . ~ymt *) !" ~"(, thl,~a~q ) ii . The complex networks definable by a general method from CF-gran unar specifications  , as shown in Schnelle ( forthcoming ) can be easily extended into a predictive top-to -bottom  , left-to-right parser such that the prediction paths are generated in parallel by concurrent signal flows  ( as will be illustrated below )  . At the real ? zations of a terminal symbol a TEST PREDICTION " a " is included  , as indicated in figure 2b . However , a detailed analysis of this system shows that in rl ~ ur ~  3 It illustrates the general type of wiring where the hyphenated units must be multiplied into n storage units  , whenever there are n inputs . The box for PRINT " a " or TESTPREDICTION " a " shows a multiplicity of  2 storage units marked 3 and 4 for the case of two input and output lines . For the details of PLA construction of such networks the reader is referred to Schnelle  ( forthcoming )  . 
13 . We shall now illustrate the signal flow occurr ing ? naPLA realization of the grammar : S + Ac  , S+aD , A ? a , A + ab , D + b d , D + d . A grammatically perspicuous topology of the network is shown in figure  4  . The double lines are wires , the boxes have an internal structure as explained above  . For a parse of the string abd the wiring realizes the following concurrent signal flow on in figure  4  . 
Gra ~ ar : S~Ac
S-aD



D-d315
Since the only possible generation derivable from this parse information is  $1  , DI , the structure is\[a\[bd\]D\]S whereas the informations AI and  A2 remain unused , i . e . nonconfirmed , by the complete parse . 
14 . We have presented only very simple illus -trations of concurrent information flow and their realizations in integrated circuits  . Much more research will be necessary . Our contribution tried to illustrate ( together with Schnelle forthcoming ) how current VLSI design methods - and simulation programs used in the context of such designs - could be applied  . It is hoped that several years of experience with designs of such types may lead to fruitful foundational concepts for process-oriented linguistics  , which solves its tasks by constructing descript ivelyadequate special machines instead of programming universaly on Neumann machines  . 

C . Mead , L . Conway (1980) Introduction to VLSI Design , Reading , Mass . : Addison Wesley H . Schnelle ( forthcoming ) Array logic for syntactic production processors - An exercise in structured net-linguistics -  . 
In : Ec . Hajicov &, J . Mey ( eds.),
Petr . Sgall Festschrift
Figure 4 ( Whenever a signal reaches a TESTPREDICTION " x " box via a line numbered y we write y  ( x )  ; " Ai " means : the ith rule-alternative at A) . 
Time Active lines ( i ) i , 2(a ) (2) 3(a ) , 4(a ) (3) Read " a " (4) 5 , 6(b ) , 7AI (5) iO(c ) , 8(b ) , 14 ( d ) (6) Read " (7) g ,  12 ( d ) A2 ( 8 ) lO ( c )   ( 9 ) Read " d " ( iO ) 13 D 1 ( 11 )  16 $2
Parse information
