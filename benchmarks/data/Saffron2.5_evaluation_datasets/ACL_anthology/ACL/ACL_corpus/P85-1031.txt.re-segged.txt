ANECLECTICAPPROACHTO
BUILDING NATURAL LANG UAGE IN TERFACES
Brian Phillips . Michael J . Freiling , James H . Alexander,
Steven L . Messick , Steve Rehfu ~, Sheldon Nichollt
Tektronix , Inc.
P.O . Box 500, M/S 50-662
Beavertoa , OR 97077

INKA is a natural language interface to facilitate knowledge acquisition during expert system development for electronic instrumentrouble -thooting  . The expert system design methodology develops a domain definition  , called GLIB , in the form of a semantic grammar . This grammar format enables GLIB to be used with the INGLISH interface  , which constrains users to create statements within a subset of English  . Incremental patting in INGLISH allows immediate remedial information to be generated if a user deviates from the sublanguage  . Sentences are translated into production rules using the methodology of lexical-functional grammar  . The system is written in Sms/ltalk and , in INK , A , produces rides for a
Prolog inference ngine.

The ides/natural anguage interface would let any user  , without any prior training , interact with a computer . Such an interface would be useful in the knowledge acquisition phase of expert system development where the diagnostic knowledge of a Hilled practitioner has to be elicited  . As technicians are not farnifiar with formal knowledge representation schemes  , a trained intermediary , a knowledgengineer , is generally employed to handcraft he interns/ format  . This process is time-consuming and expensive . 
INKA ( INglish Knowledge Acquisition ) permits task experts to express their knowledge in a subset of English  , and have it automatically translated into the appropriate representational formalism  . In particular , the version of INKA to be discussed here accepts input in a sublanguage called GLIB which permits the statement of facts and rules relevant othe troubleshooting of electronic systems  ( Freiling et al ,  1984) , and translates these statements into Prolog unit clauses for later proce ~ ng by a specialized inference mechanism  . Experiments with INKA to date have enabled us to construct mfflcient troubleshooting rules to build a localizing troubleshooter for a simple circuit  . 
INKA is designed as one of the tools of DETEKTR , an environment for building knowledge based electronic instru  . 
ment troubleshooters ( Freiling & Alexander ,  1984) . 
DETEKTR supports an expert system development methodology which is outlined below  . The design goal of INKA is that it serve as a natural anguage input system to facilitate transfer of knowledge during the knowledge acquisition phase of expert system development  . IIqKA is not intended to standalone as the sole mechanism for knowledge transfer  , but to be sup-tA summer intern at Tektronix , currently at the University of llfino is , Champs/gn-Urbana . 
ported by components capable of managing a coherent dis/o-gue with the task expert  . McKeown ( 1984 ) has po/nted out a number of important aspec ~ of the pragmatics that relate to the usage phase of an expert system  . Similar pragmatics are required to insure adequate construction of the system's knowledge base during the knowledge ac~n phase of an expert system's development  . The most important pragmatic facility is one to estimate the degree of epistemi ? coverage of the knowledge acquired so far  , and to promp the task expert for more knowledge in areas where the coverage is weak  . It is unfeasible to assume that any task expert can simply perform a ~ memory dump " of expertise into some natural language interface and be done with it  . 
This paper discusses the natural anguage technology used in building INKA  . The system incorporates a diverse collection of natural language technologies in its construction  . 
Specifically , INKA utilizes a semam/c grammar ( Burton , 1976) to characterize the domain sublanguage , lexical-functional sem ~ aics ( Kaplan & Bresnan ,  1982 ) to translate to the internal form of representation  , and an interface that includes left-corner parsitlg within line guidance to address the Linguistic coverage problem that aris ~ with sublanguages  . We feel this eclectic approach is a useful for building application-oriented natural language interfaces  . Although we are describing a knowledge acquisition application  , the methodology can be used for any application whose sublanguage can be stated in the prescribed grammar formalism  . 
Tereisias ( Davis ,  1977 ) provides a natural language environment for debugging a knowledge base  . INKA at present contains no facilities to modify an existing rule or to test the evolving knowledge base for some level of integr/ty  ; these are to be future additions . 
INKA is written in Small talk ( Goidberg & Robson ,  1983 ) and runs on both the Tekuroulx Magnolia Workstation and the  4404 Artificial Intelligence System . INKA makes extensive use of the bit-mapped is play and three-button mouse on these systems  . 
LANGUAGE ASAKNOWLED GEENGINEERING TOOL The major bottlenecks in building knowledge based systems have proven to be related to the definition and acquisition of knowledge to be processed  . 
The first bottleneck occurs in the knowledge definition phase of system development  , where symbolic structures are defined that represent the knowledge necessary to accomplish a particular task  . A bottle neckarises because of the ~ or tage of knowledgengineers  , who are skilled in defining these structures and using them to express relevant knowledge  . 

The second bottleneck occurs in the knowledge acquisition phase  , which involves the codification of the knowledge necessary for a system to function correctly  . A bottleneck arises here because in current practice  , the presence of the knowledge engineer is required throughout this time-consuming process  . 
In the course of defining a viable methodology for the construction of expert systems  ( Frelling & Alexander 1984 ; Alexander et al 1985) , we have identified cermia classes of problems where the task of definin $ the knowledge structures and the task of actually building them can be effectively separated  , with only the former being performed by a trained knowledge engineer  . The problem of building a large collection of knowledge-based troubleshooters for electronic instru-meats is an example  . In order to support he construct/on of a large class of such systems  , it makes sense to perform the knowledge definition step for the overall domain initially  , and to build domain-specific developmera tools , which include problem-oriented mbsets of Enghsh and special purpose graphical displays  , that can be reused in the development of each individual knowledge-based system  . 
Even in the context of such an approach , we have found that there is usually a shortage of capable knowledgengineers to carry out the knowledge defl nltio a phase  , and that a well-defined methodology can be of great value here in aiding non-linguistically oriented computer scientists to carry out this verbal elicitation task  . The major issue is how to gee started defining the forms into which knowledge is to be cast  . 
We have found it an effect/ve techniquet Obegin this pro-cemby recording statements made by task experts on tape  , and transcribing the set of airly natural En~)i ~ . When enough recording has been done , the statements begin to take on recognizable patterns  . It is then pom/ble to build a formal grammar for much of the relevant utterances  , using linguistic engineering technique such as semantic grammars The symbols of this grammar and the task specific vocabulary provide convenient points for defining formal substructures  , which are pieced together to define a complete symbolic representation  . 
Once the grammar is reasonably well-defined , the mapping to symbolic representation can be carried out with mapping tenh-niques such as the f-structure constraints of lexical-fuactio aal grammar  . 
Up to this point , we can imagine that the entire task has been carried out on paper  , or some machine-readable equivalent . Even in such a rudimentary form , the exercise is useful , because it provides a conveniently formal documentation for the knowledge representation decisions that have been made  . However , it is also the case that these formal definitions  , if appropriately constructed , provide all that is necessary to construct a problem specific interface for acquiring utter -antes expressed in this sublanguage  . In fact , the idea of using this technique to build acquisition interfaces  , using INGLISH , actually occurred as a result of wondering what to do with a grammar we had constructed simply in order to document our representation structures  ( Freiling et al 1984 )  . 
We do not intend to imply that it is possible in complex knowledge based system applications to simply build a gram  . 
mar and immediately begin acquir in ~ knowledge . Often the process leading to construction of the grammar can be quite complex  . In our case , it even involved building a simple prototype troubles hooting system before we had gained sufficient confidence in our representation structures to attempt a knowledge acquis/tion interface  . 
Nor do we intend to claim that all the knowledge necessary to build a complete expert system need be computed in this fashion  . Systems such as INKA can be justified on an economic bash if they make pom/ble only the transfer of a ~' ~ nificam fraction of the relevant knowledge  . 
GLIB-APROBLEM SPECH rIC SUBLAN GUAGE
The knowledge acquisition language developed for elec-tron/cdevine troubleshooting is called GLIB  ( General Language for Insumneat Behavior )  , and is aimed primarily at describing observations of the static and dynamic behavior of electrical signals as measured with oscillo scopes  , voltmeters , and other standard electronic test instruments ( Freiling et al 1984 )  . The grammatical structure of GLIB is that of a semantic grammar  , where nonterminal symbols represent units of interest to the problem domain rather than recognizable linguistic categories  . 
This semantic grammar formalism is an important part of the DETEKTR methodology because the construction of semantic grammars is a technique that is easily learned by the apprentice knowledge engineer  . It also ma~es possible the establishment of very strong constraints on the formal language developed by this process  . Two of the design constraints we find it advisable to impose are that the language be unambiguous  ( in the formal sense of a unique derivation for each legal sentence  ) and that it be contextfree . These constraints , as will be seen , make pom/ble features of the interface which cannot normally be delivered in other contexts  , such as menus from which to select all legal next terminal tokens  . While increasing complexity of the acquisition sublanguage may make these goals unfeas/ble past a certain point  , in simple systems they are features to be cherished  . 
Figure I shows a fragment of the GLIB grammar . In the DETEKTR version of INKA , sentences in this language are accepted , and mapped into Proiog terms for proceming by a Prolog based diagnostic inference ngine  . At present , theeric/-ration is unguided : responsibility res /des with the user to ensure that all relevant statements are generated  . We are still studying the issues involvedia determining completeness of a knowledge base and assimilating new knowledge  . One outcome of these studies should be means of guiding the user to areas of the knowledge base that are incomplete and warrant further elaboration  . Future enhancement so the system will include explanation and modification facilities  , so that knowledge may be added or changed after testing the inference engine  . 
THENATURALL ANGUAGE INTERFACE DESIGN
INGLISH-INter faceen GLISH ( Ph/Ilips & Nicholl ,  1984 ) -allows a user to create sentences either by menu selection  , by typing , or by a mixture of the two . This allows the self-paced transition from menu -driven to a typed mode of interact/on  . In line help is available . To assist the v/pist , automatic spelling correction , word completion , and automatic phrase completion are provided . INGLISH constrains users to create statements within a subset of English  , here GLIB . 
A statement can be entered as a sequence of menu -selections using only the mouse  . A mouse click brings up a menu of words and phrases that are valid extensions of the 
IF < condition > THEN < ? on ? lmma > < condifiou >  ::'  , < ? otltl = n independeln predicate > I < context independent predicate > WHEN ~'-  . m~-tund coatext > < conclusion > : :! , <fuection aJ context > < atonfi ? funct ~ nal context >::-< device > HASFAILEDI < device > B OK < f ~ conner >  ::1  . 
< atomic functional context >! < atomic functional context > AND < functional context > I < atomic functio ~ taJ context > OR < f  , ,r~tionaI context > < atOtUiC stt~tetugaJ contexL > ::~  , < device > ISREMOVED ~- JtfttCtttt~lCOtlteXt > ::1= < atom i ? struct m ' aJ context > I < atomic structural context > AND < structural context > < context independent prostate >: := < value predicate > < value predicat c > : := < valu expre ~ on > IS < valu expreslion > I < valu expt ~ mou > < comparator > < value c~im:smon > < coml ~ tralOf > ::~ 
ISEQUALTOI = I
ISGREATERTHANI>I
ISLESSTHANI < !
ISLESSTHANOREQUAL TOI <= I
ISGREATERTHANOREQUAL TOI>-I
ISNOTEQUALTOI ! : ,
Figure 1: A fragment of GLIB current sentence fragment . Once a selection is made from the menu using the mouse  , the fragment is extended . This sequence can be repeated until the sentence is completed  . 
Creating a sentence in this manner compares with the NLMENU system  ( Tennant et al .  , 1983) . Unlike NLME NU , keyboard entry is also possible with IHGLISH . Gilfoil ( 1982 ) found that users prefer a command form of entry to menu-driven dialogue as their experience increases  . When typing , a user who is unsure of the coverage can invoke a menu  , either by a mouse click or by typing a second space character  , to find out what INGLISH expects next without aborting the current statement  . Similarly , any unacceptable word causes the menu to appear , giving immediate feedback of a deviation and suggestions for correct continuation  . A choice from the menu can be typed or selected u ~ ng the mouse  . NGLISH in fact allows all actions to be performed from the keyboard or with the mouse and for them to be freely intermingled  . As only valid words are accepted , all completed sentences are wellformed and can be translated into the internal representation  . 
Figure 5 , in the " INGLISH " window , shows a complete sentence and its translation , and a partial sentence with a menu of continuations  . The numbers associated with each menu item provide a shorthand for entry  , i . e . , "~12" can be typed instead of " RESISTANCE " . As menu entries can be phrases , this can save significant typing effort . 
Input is processed on a word-by-word basis . Single spaces and punctuation character serve as word terminators  . Words are echoed as typed and overwritten in uppercase when accepted  . Thus , if lowercase is used for typing , the progress of the sentence is easily followed . An invalid entry remains visible along with the menu of acceptable continuations then is replaced when a selection is made  . 
The spelling corrector ( a Small talk system routine is used ) only corrects to words that would be acceptable in the current syntactic/semantic context  . As Carbonell and Hayes (1983) point out , this is more efficient and accurate than attempting to correct agains the whole application dictionary  . 
Word completion is provided with the " escape " character  ( cf . DEC , 1971) . When this is used , INGLISH attempts to complete the word on the basis of the characters of artyped  . 
If there are several possibilities , they are displayed in a menu . 
Automatic phrase completion occurs whenever the context permits no choice  . The completion will extend as far as poss/ble In an extreme case adngle word could yield a whole sentence ! The system will " soak-up " any words in the completion that have also been typed  . 
The spelling cot'rector and automatic phrase completion can interact in a disturbing manner  . Any word that is outside the coverage will be treated~s an error and an attempt will be made to correct it  . If there\[saviable correction , it will be made . Should phrase completion then be possible , a portion of a sentence could be constructed that is quite different from the one intended by the user  . Such behavior will probably be less evident in large gramman  . Nevertheless , it may be necessary to have a " cautious " and " trusting " mode  , as in Interlisp's DWIM ( Xerox ,  1983) , for users who resent the precocious impat/ence of the interface  . 
The system does not support anaphora , and ellipsis is offe:ed indirectly . The interface has two modes : " ENTRY " and " EDIT "  ( Figure 5 )  . These are selected by clicking the mouse while in the pane at the topright of the interface window  . Rules are normally entered in the Entermode . When in Edit mode , the window gives access to the Small taLk editor . 
This allows any text in the window to be modified to create a new statement  . After editing , a menu command is used to pass the sentence to the paner as if it were being typed  . Anyerrc ; " in the constructed sentence causes are medial menu to be displayed and the tail of the edited sentence to be thrown away  . 
The 1HGLISH interface alleviates the problem of linguistic coverage for designers and users of natural language interfaces  . A natural language interface user composes his entries bearing in mind a model of the interface 's capabilities  . If his model is not accurate , his interactions will be error-prone . He may excerd the coverage of the system and have his entry rejected  . If this happens frequently , use of the interface may be abandoned in frustration  . On the other hand he may form an overly conservative model of the system and failt our ~ ize the full capabifities of the interface  ( Tennant ,  1980) . An interface designer is confronted by many linguistic phenomena  , e . g . , noun groups , retative rlauses , ambiguity , reference , ellipsis , anaphora , and paraphrases . On account of performance requirements or on a lack of a theoretical understanding  , many of these constructions will not be in the interface  . 
INGLISH allows designers to rest more comfortably with the compromises they have made  , knowing that users can systematically discover the coverage of the interface  . 

THEIMPLEMENTATION OFINGLISH
INGLISH parses incrementally from left to right and performs all checking on each word as it is entered  . The parser follows the Left-Corner Algorithm ( Gr/ffiths & Petrick ,  1965) , modified to a pseudo-parallel format so that it can follow all parses simultaneously  ( Phillips ,  1984) . Th/s algorithm builds phrases bottom-up from the left-comer  , i . e . , rules are selected by the first symbol of their r/ght-hand-s/des  . For example , given a phrase initial category e , a rule of the form X--e--will be chosen . The remaining rule segments of the righthands/de are predictions about the structure of the remainder of the phrase and are processed left-to -right  . Subsequent inputs will directly match success/ve rule segments ff the latter are term/-aal symbols of the grammar  . When a nonterminal symbol is encountered , a subparse is initiated . The subparse is also constructed bottom-up from the left-corner  , following the rule selection process just described  . When an embedded rule is completed , the phrase formed may have the structure of the nonterminal category that or/ginated the subparse and so complete the subparse  . If there is no match , it will become the left-corner of a phrase that will eventually match the originating category  . 
The parser includes a Re , whabiliry Mmriz ( Griffiths & Petrick ,  1965 ) to provide topdown filtering of rule selection . 
The mntrix indicates when a category A can have a category B as a leftmost descendant in a passe tree  . The matrix is static and can be derived from the grammar in advance of any pan  . 
ing . It is computable as the transitive closure under multiplication of the boolean matrix of left daughters of nonterminal categories in the grammar  . It is used as a further constraint on rule selection  . For example , when the goal is to construct a sentence and the category of the lust word of input is e  , then rule selection , giving X-c-- , will also be constrained to have the property S * X -- The filtering is applicable whenever a rule is selected : during subparses the constraint is to reach the category originating the subparse  . 
A semantic grammar formalism is used in INGLISH , which make the grammar application dependent . As was mentioned earlier , this format was independently chosen a span of the knowledge engineering methodology for describing the avplication domain  . The rationale for the choice for INGLISH was that the simultaneou syntactic and semantic checking assists in achieving realtime processing  . A fragment of the grammar is shown in Figure 1 . 
Preprocessing on the grammar coasu'uc:s the terminal and nonterminal vocabularies of the grammar  , the reach abllity matrix , and an inverse dictionary . The set of all possible initia/words and phrases for sentences can also be precomputed  . 
The Smafl talk system contnin ~ controllers that manage activity on a variety of input devices and from these a controller was readily constructed " to coordinate mouse and key-?Small talk is an object-oriented language  . Instead of creating a procedure that controls system operation  , the user creates an object ( usually a data structure )  , and a set of methods ( operations that transform , and commun-icate with the object ) . Smalitalk programs create objects or send messages to other objects  . Once received , messages result in the execution of a method . 
Programmers do not create each object and its methods individually  . Instead , classes of objects are de-board activity in INGLISH  . Either form of entry increments an intermediate buffer which is inspected by the parser  . When a complete word is found in the buffer it is parsed  . 
Every phra ~ in an ongoing analys/s is contained in a Small talk object  . The final parse is a tree of objects . The intermediate state of a parse is represented by a set of objects containing partially instantiated phrases  . After the first word has established an initial set of phrase objects  , they are Dolled by the pa~er for their next segments  . From these and the rever ~; dictionary , a " look a headictionary " is estabfished that assoc/ates expected words with the phrasal objects that would accep them  . Using this dictionary an incoming word will only be sent to those ob ~' ts that will accept it  . If the word in not in the set of expected words , the dict/onary keyss reused to attempt spelling correction and  , iI correction fails , to make the menu to be displayed . If the dictionary contains only a single word , this indicates that automatic phrase completion should take place  . A new look ahea dictionary is then formed from the updated phrase objects  , and so On . 
KNOWLED GETRANS LATION
The internal form of a diagnostic role is a clause in Prolog  . Sentences are translated using functional stigmata  , as in lexicai-functioaal grammar . The functional schemata are attached to the phrase structure rules of GLIB  ( Figure 2 )  . 
( tFo a ~0 COND roItM ), 0 CNCI . FORM )) > ( tCOND)- . ( tCNCL)- . 
< ride > -> IF < condition > THEN < conclus/on >( . r-Oa Ml--< . ~ . (( ta ~) . (, SYAI"B ) . ~(, ~*( tSYAI"R ) - . 
< condition > -> < indicator > IS ~> ( . e ' OltM)--< . umn(( , oev ) , ~ m ') > ( , On V ) - , < conclus/on>--><device > HASFAILED Figure 2: GL/B rules with attached schemata Unlike lex/cal -functional grammar  , the schemata do not setup constraint equations as the interface and the semant/cgrammar ensure the well-formedne ~ and unamhigu/ty of the sentence  . 
As a result , propagation of functional structure is handled very quickly in a post-proce ~ ng step since the appficable grammati-ca/rules have already been chosen by the parsing process  . 
Further , by restricting the input to strictly prescribed sublanguage GLIB  , not Engl ~ hin general , the Ur~n ~ Intio a process is s/mplified . 
fined . A clam definition describes an object and the methods that it understands  . Classes are structured h/erare hically , and any class automatic a Uy/nher its methods from its superclass  . 
As a result of this hierarchy and code in her /tance  , applications may be wr/t ten by a dap ~ ng previously con-?strutted code to the ~ kath and  . Much of the appUca-t/on code can be inherited from prev/ously defined SmaIitalk code  . The programmer need only redefine differences by overriding the inappropriate code with custom/zed code  . ( Alexander & Freiling , 1985) . 

The parser constzvcts apar ~ tree with attached schemata  , referred to as a constituent-structure , or c-structure . 
Translation proceeds by instantiat in Sthemeta -vatiablns of the schemata of the c-struct m ~ created by INGLISH to form functional equations which ate solved to produce a functional structure  ( f - ~ e )   . The final rule form is obtained from the f -structure of the sentence when its sub  . structures are recursively trandormed according to the contents of each f-structure  . 
As an example , given the lexical-functioaal form of the semantic grammar in Figure  2 and the following sentence : IF LED-2 ISONTHEN TRANSISTOR-17 HASFAILED the ' c-structure in Figure 3 would be produced . This shows that a rule has a condition part , COND , and a conclus/on part , CNCL , that should become a clausal-form ~ Ule(COND , CNCL ) . ~ The meta-symbol t refers to the parent node and t to the node to which the schema is attached  . 
The final phase of INKA interprets the fstructures to produce Pm log clauses  . All of the information required to produce the clauses is contained in the FORM property in this example  . The FORM property is printed , with all variables instantiated , to produce the f'mal rule in the form of a Prolog clause  . The f-strucn tre of Figure 4 produces the Prolog clause rule ( state ( led-2 , on ) , ~ tatus ( transistor-17 , failed )
KNOWLED GEUSE
Translated rules are sent to a diagnostic engine that has been implemented iaPmiog  . The diagnosd cengine uses GLIB statements about he hierarchical structure of the device to build a strategy for successive localization of failures  . Starting at the highest level ( ' the circuit " in GLIB terminology )  , named sub-cimults are examined in turn , and diagnostic rules retrieved to determine correctness or failure of the sub-circuit < rule > 
IF < condition . :> THEN(taqD~/t\](t ~ nl , A ~) ~ . ( tSTA ~)) = ~< indicator > IS < state >
LED-2ON < conclusion > (* FOIt Ml--qmm ~ (* bey).
( , cev)-.
< device >. HASFAILED

TR . ANSISTOR-17
Figure 3: C-structure
The functional specifications of the example may be solved by instantiating the recta-symbols with actual nodes and assigning properties and values to the nodes according to the specifications  . In the example given , most specifications are of the form " ( tpmpert'y ) = value " where " value " is most often * . 
This form indicates that the node graphically indicated by tin ? the c-structure is the specified property of the parent node  ( pointed to by * )  . Specifications are left-=_~:o?_lative and have a functional semantic interpretation  . A specification of ( tCONDFORM ) refers to the FORM property of the parent node's COND property  . The f-~mcture for the example is given in Figure 4  . 
in question . If no specific determination can be made , the sub-circuits a . mumed to be functioning properly . 
A sample session including acquisition of a rule and a to-ning of a test diagnosis i shown in Figure  5  . The circuit used in this example consists of an oscillator wh/ch drives alight emitting diode  ( LED-2 in the schematic ) and a power supply ( LED-1 indicates when the power supply is on )  . The schematic diagram of the circuit is in the upperpane of the " Insu'ument Data " window  ; the circuit board layout is in the lower pane . Rules for diagnosing problems in the circuit IND  led-2 
COND\[STATE on\[FORM < sta~(OINDFORM) , ( tSTATEFORM )) >
CNCL\[DEV tr~i,~torol 7 tFORM < s~u . ?(( , DEV ) , fa~ed ) > tFORM < rule(OCOND ) ,  ( , CNCL )) >
Figure 4". F-structure
IFNODE 4 VOLTAGEISE QUAL TO NODE 5 VOLTAGETHEN RESISTOR 2 HASFAILED . " PARSED rula(comp(aq . voltage(nods(4)) . voltags ( nods (5))) . status ( componsnt(rssistor(2))0 failed ),-)
IFl OWERSURLY 1.
CURRENT ($3)
FREQUENCY (#4)
HASFAILED (#5)
IMPEDANCE (#6)
IS(ltT ~
POWER (#111
RESISTANCE(#12
VOLTAGE(#13) "' ABORT 1#14)
Isled number 2 not flashing ? yes
What is the voltage of node number 2?15
IS led numl : ) ef1 dim ? no
Is it true that the voltage of node number 4 is equal to the voltage of node number . 5? yes
Oscillator number 1 is failing.
Resist or number 2iS failing.
Instrument (3ate
I . No , .
555 I~~4 . oo ~-, ~ . ~ . ~: I , J , , , i " , ~='' c = InnannnnnnnE Ilnnnnnnnn nnn ~ ~''  ,   ,  .  ~',;_~ ? . V . ~nnnnEIIDl = e~l = l = lil = ~ ~ , ,, - .  -~  .  , . -, '  .  ,  .   .   , i i l l ~ l = l = i i I l n n n n n n ~ n n n nnnnn = ~  . ~ nnnn=~I = IOII ii Drrll . l ,, ~ . . . . ~,~ . ' ~=~= I==l=I=n Q"'~=131=0\[
I l n n n n n n ~ ~ n ~ n ~ n n n v t ~ n n n ? ~ l l l = n n n n n n i ! : -   . + ~' i .  ,! ;'::,, . ~ ni . , . .: . ~i ~ nnliqnli = . , ' t ~= n n n n n q l l l n n a n n a n i l i i . ; . ~ ::~ . . i . , . , ~ nB ~ , : ~ . ~ i ~! > . , , ~ anilnilnnnnnn , lIlnnnnann ~ . , '~, ~ n ~ nnnluinnn an nnql
Figure 5: An\[\]gKA ===/ on ( ' troubleshooting " rules ) are added to the system in the window labeled " INGLISH  . " The interface to the diagnnszi ? engine is in the " Prolog " window  . The " INGLISII " window shows a recently added rule  , with its Prolog translation immediately below it . It also shows a partially completed rule along with a menu of acceptable sentence continuations  . The user may select one of the menu items ( either a word or phrase ) to be append cd to the current sentence . The " Pmlog " window displays the results of a recentest diagnosis  . This test was run after the first rule in the ~ NGLISH " window was added  , but before the addition of the second rule was begun  . 
The last question asked during the diagnosis corresponds to the first rule  . Resistor 2 , in both the schematic and board diagrams of the = Instrument Data " window  , is highlighted as a result of running the diagnos /s : whenever the diagnnstic engine selects a specific component for consideration that component is highlighted on the display  . Some 20 statements and rules have been collected ' . ' or diagnosing the circuit ; Figure 6 lists a portion of them with their Prolog translation  . 

THECIRCUIT CONTAINS OSCILLATOR-1 AND POWERSUPPLY-1  . 
has_cemponent(block(circult ) , block ( oscillator(1))) . 
has_component(block(c/rcuit ) , block ( powetlup ply(1))) . 
RESISTOR-1 ISPARTOFOSCILLATOR-1.
has . xomponent ( block ( o ~- fllator(I)) , component ( resist or ( l ))) . 
IF LED-2 IS NOT FLAS HING AND THE VOLT AGEOF NODE-2 ISE QUAL TO 15 VOLTSTHEN OSCILLATOR-1 HASFAILED . 
rule(and(not(state(led(2) , flashing ))) , comp(voltage(node(2)) , If )) , status ( block ( oscillator(I )) , fa/led ) ,  \[\]) . 
IIF\[ . . , ED- , 1 IS DIM AND LED-2 ISOFFTHEN ~ ISTOR-1 HASFAILED . 
rule ( and ( state ( led(l ) , dim ) , state ( led(2) , off )) , status ( component ( resistor(1)) , failed ) ,  \[\]) . 
Figure 6: GLIB rules with Pm log translations

Informal observations show that subjects generally need only a few minutes of instruction to start using INGLISH  . Initially there is a preference to tt ~ the mouse to explore the coverage and then to begin to incorporate some typing  . We have not had any long term use ~ to observe their trends  . 
Use ~ could react negatively to limited language systems  ; even when the coverage is well-engineered users will occasionally encounter the boundaries  . Fortunately , Headier & Michaelis ( 1983 ) found that subjects were able to adap to limited language systems  . 
INGLISH does not let the designer off the hook lA umr can still have a statement in mind and not easily f'md a way to expre ~ it through the grammar  . Diligent engineering is still needed to prepare a grammar that will allow a user to be guided to a paraphrase of his or/ginal though LNevertheless  , the grammar design problem is simplified : when guidance is provided fewer paraphrases need be incorporated  . 
The use of a semantic grammar to define the fragment of English to be processe does impose limitations on the complexity of acceptable input  . In the INKA system as it is currently cen . mxtcted , however , them are two distinct ways in which the semantic or rectness of an input can be enforced  , tint in the parsing of the of the semantically ceRstralned grammar  , and second in the tran . qat/on process , as the ftmc-donal structures are built . 
In short , the our approach to building practical natural language inte ~  . -ees does not depend on a semantic grammar to ? oastra/ninput  . In the future we intend to explore the u ~ of a wider class of grammars that include a domain -independent kernel and a domain-specific component  , like GLIB . In this approach we are in substantial agreement with Winograd  ( 1984 ) who advocates a similar approach as an effective diroc  . 
finn for further naturul language resea~h.

Alexander , J . H . , & Freiling , MJ . Building an Expert System in SmalRalk-80 ( R ) . Systems and Software ,  1985 ,  4 ,  111-118 , Alexander , J . H . , Freiling , MJ . , Messick , S . L . , & Reh/uss , S . 
Efficient Expert System Development Through Domain -Specific Tools  . Proceedings of the F~fth International Work Jhop on Expert Systems and their Applications  , Avignon , France , Burton , R . R . Semamic Grammar : losEng~ncering Tecb , ni ~ for Consmac:ing Natural lamgaage UnderstmTding System  . v(Techni . 
caJ Report No .  3453) . Cambridge , MA : Bolt , Beranek , &
Newman Inc ., 1976.
Carbonell , J . G . , & Hayes , PJ . Recovery Strate ~ es for Parsing Extragrammatical Language  . American Journal of Computational Linguimics ,  1983 ,  34 ,  123 . 146 . 
Davis , R . Interactive Transfer of Expertise : Acquisition of New Inference Rules  . Proceedings of the Fifth International Joint Colrference on Art~iciai intelligence  , Cambridge , MA ,  1977 ,  321-328 . 
\[ DEC\]TOPS-20 Reference MammL Maynard , MAt Digital
Equipment Corporation , 1971.
Freiling , MJ . , & Alexander , J . H . Diagrams and Grammar : Tools for the Mass Production of Expert Systems  .   1EEE First Conference on Ar~ficial Intelligence Applications  . Denver,
Colorado , 1984.
Freiiing , M . , Alexander , J . , Feucht , D . , & Stubbs , D . GL/B-AL Anguage forgepreeent mg the Behavior of Electronic Devices  ( Technical Report CR-&t-12 )  . Beaverton , OR : Tektronix,
Inc ., 1984.
Gilfoil , D . M . Warming up to Computers : A Study of Cogni-five and Affective Interaction over Time  . Proceedings of the Haman Fncter x in Computer 5y~ema Conference , Gaithersburg , 
MD , 1982, 245-250.
Goldberg , A . & Robson , D . Small taik 80: Thel , a ~ guage and its lmpiemamt miom . Re-dlng , MA : Addison-Wesley , 1983 . 

Griffiths , T . , & Petr/ck , $ . R . " On the relative efficiency of coatext . free grammar recoe , niT ~ ru . ? Comm . ACM , 1965, 8, 289-300 . 
Headier , J . A . , & Michnefis , P . R . The Effects of Limited Grammar on Interactive Natural Language  . Proce Edings of tha Human Factors in Computer Systems Conference  , Bo ~ a , MA ,  1983 ,  190 . 192 . 
Kaplan , R . M . , & Bre , mnn , J . W . Lex/cal-Funct/onal Grammar : . 
A Formal System for Grammatical Represent at/o a . In J . 
Brecmm ( Ed . ), T~Ment ~ Representation fOr ~ Rein . 
r/ore . Cambridge , MA : MIT Press , 1982.
McKeowa , K . R . Natural Language for Expert Sy~ems : Corn-par/s on with databa ~ systems  . Proceedings of tha International Conference on Computation all  , in ~ rics , Stanford , CA ,  1984 ,  190-193 . 
Phillips , B . A a Ob~'t-or/ented Parser . laB . G . Barn & G . 
Gnida ( Eds . ), Computational Models of Natara ~ Langaage Pro . 
? Lu/nz . Amsterdam : North-Holland , 1984.
Phillips , B . , & NichoH , S . INGUSH : A Nanwal Language Inter . 
face ( Techn/cal Report CR-84-27) . Beaverton , OR : Tek-tronix , Inc . , 1984 . 
Tennant , H . R . Evaluation of Natural Language Processors ( Technical Report 1"-103 )  . Coordinated S?/eace Laboratory , University of Illinois , Urbana , IL ,  1980 . 
Tennaat , H . R . , Ross , K . M . , & Thompson , C . W . Usable Natural Language Interfaces Through Menu -Based Namra/Language Understanding  . Proceedings of the Human Factors in Computer ~ , , ystem . tConference , Boston , MA , 1983, 190-192 . 
Winograd , T . Mov/ng the Semans / ? Fu/o'um ( Techn/cal Report 84-17 )  . Center for the Study of Language and la format/an,
Stanford , CA , 1984.
\ [ Xerox \] Interlix p Reference Manual Palo Alto , CA : Xerox
Palo Alto Research Center , 1983.

