Transforming Lattices into Nondeterministic Automata with 
Optional Null Arcs
Mark Seligman , Christian Boitet , Boubaker Meddeb-Hamrouni
Universit 6 Joseph Fourier
GETA , CLIPS , IMAG-campus , BP53
150, rue de la Chimie
38041 Grenoble Cedex 9, France
seligman@cerf.net,
Christian . Boitet , Boubaker . Meddeb-Hamrouni@imag . fr

The problem of transforming a lattice into a nondeterministic finite state automaton is nontrivial  . We present a transformation algorithm which tracks  , for each node of an automaton under construction , the larcs which it reflects and the lattice nodes at their origins and extremities  . An extension of the algorithm permits the inclusion of null  , or epsilon , arcs in the output automaton . The algorithm has been successfully applied to lattices derived from dictionaries  , i . e . very large corpora of strings . 

Linguistic data -- grammars , speech recognition results , etc . -- are sometimes represented as lattices , and sometimes as equivalent finite state automata  . While the transformation of automata into lattices is straightforward  , we know of no algorithm in the current literature for transforming a lattice into a nondeterministic finite state automaton  . ( See e . g . Hopcroft et al (1979),
Aho et al (1982).)
We describe such an algorithm here . Its main feature is the maintenance of complete records of the relationships between objects in the input lattice and their images on an automaton as these are added during transformation  . An extension of the algorithm permits the inclusion of null  , or epsilon , arcs in the output automaton . 
The method we present is somewhat complex , but we have thus far been unable to discover a simpler one  . One suggestion illustrates the difficulties : this proposal was simply to slide lattice node labels leftward onto their incoming arcs  , and then , starting with the final lattice node , to merge nodes with identical outgoing arcsets . 
This strategy does successfully transform many lattices  , but fails on lattices like this one :
Figure 1
For this lattice , the sliding strategy fails to produce either of the following acceptable solutions  . To produce the epsilon arc of 2a or the bifurcation of Figure 2b   , more elaborate measures seem to be needed . 

ab . ~ Figure 2a
We present our data structures in Section 1 ; our basic algorithm in Section 2 ; and the modifications which enable inclusion of epsilon automaton arcs in Section  3  . Before concluding , we provide an extended example of the algorithm in operation in Section  4  . Complete pseudo code and source code ( in Common Lisp ) are available from the authors . 
1 Structures and terms
We begin with data structures and terminology . A lattice structure contains lists of l nodes ( lattice nodes )  , lares ( lattice arcs ) , and pointers to the lnitlal . lnode and flnal . in ode . Anl node has a label and lists of Incoming . lares and outgo-lng . lares . It also has a list of a-ares ( automaton extremity . Similarly , an automaton structure has a nodes ( automaton nodes )  , a-arcs , and pointers to the Initial . a node and final . anode . 
An a node has a label , a list of l ares which it reflects , and lists of Incoming . a-ares and outgo-lng . a-arcs Finally , an a-arch as a pointer to its l node , origin , extremity , and label . 
We said that an a node has a pointer to the list of lares which it reflects  . However , as will be seen , we must also partition these lares according to their shared origins and extremities in the lattice  . 
For this purpose , we include the field late . origin . groups in each a node . Its value is structured as follows: ( ( ( larclarc . . . ) l node ) (( larclarc . . . ) l node ) . .) Each group ( sublist ) within larc . orlgln . groups consists of ( 1 ) a list of larcs sharing an origin and ( 2 ) that originl node itself . Likewise , the late . extremity . groups field partitions reflected larcs according to their shared extremities  . 
During lattice-to-automaton ransformation , it is sometimes necessary to propose the merging of several a nodes  . The merged a node contains the union of the larcs reflected by the mergees  . 
When merging , however , we must avoid the generation of strings not in the language of the input lattice  , or parasites . An a node which would permit parasites is said to be ill-formed  . An a node is ill-formed if any larclist in an origing roup  ( that is , any list of reflected larcs sharing an origin ) fails to intersect with the larclist of every extremity group  ( that is , with each list of reflected larcs sharing an extremity  )  . Such an ill-formed a node would purport to be an image of lattice paths which do not in fact exist  , thus giving rise to parasites . 
2 The basic algorithm
We now describe our basic transformation procedures  . Modifications permitting the creation of epsilon arcs will be discussed below  . 
Lattice . to . automaton , our toplevel procedure , initializes two global variables and creates and initializes the new automaton  . The variables are * candidate . a-ares * ( a-arcs created to represent the current l node ) and * unconnee table . a-arcs * ( a-arcs which could not be connected when processing previous l nodes  ) During automaton initialization , an initial . a node is created and supplied with a full set of lares : all outgoing larcs of the initial l node are included  . We then visite ver ) ' l node in the lattice in topological order , and for each l node execute our central procedure , handle . eurrent . lnode . 
handle . current . lnode : This procedure creates an a-arc to represent the current l node and connects it  ( and any pending a-arcs previously uncon-nectable ) to the automaton under construction . 
We proceed as follows : (1) If eurrent . l node is the initial lattice node , do nothing and exit . (2) Otherwise , check whether anya-arcs remain on * unconnectable  . a-arcs * from previous processing If so , push them onto * candidate . a-arcs * . (3) Create a candidate automaton arc , or candidate . a-arc , and pushit onto * candidate . a-arcs * . 1 (4) Loop until * candidate . a-arcs * is exhausted . On each loop , pop a candidate . a-arc and try to connect it to the automaton as follows : Seek potential connecting  . a nodes on the automaton If none are found , push candi-date . a-arconto*unconnectable . a-arcs * , otherwise , try to merge the set of connect-Ing . a nodes . C Whether or not the merge succeeds , the result will be an updated set of connect-ing . a nodes . ) Finally , execute link . candidate ( below ) to connect candidate . a-arc to connect-lng . a nodes , Two aspects of this procedure require clarification  . 
First , what is the criterion for seeking potential connecing  . a nodes for candidate . a-arc ? These are nodes already on the automaton whose reflected larcs intersect with those of the origin of candidate  . a-arc . 
Second , what is the final criterion for the successor failure of an attempted merge among con-necting  , a nodes ? The resulting a node must not be ill -formed in the sense already outlined above  . A good merge indicates that the a-arcs leading to the merged a node compose a legitimate set of common prefixes for candidate  . a-arc . 
link . candidate : The final procedure to be explained has the following purpose : Given a can-didate  . a-arc and its connecting . a nodes ( the an-odes , already merged so far as possible , whose 1 The new a-arc receives the label of the \[ node which it reflects  . Its origin points to all of that \[ node's incoming larcs  , and its extremity points to all of its outgoing larcs  . Larc . origin . groups and l are . extremity . 
groups are computed for each new a node . None of the new automaton objects are entered on the automaton yet  . 
1 206 larcs intersect with the larcs of the a-arc origin  )  , seek a final connecting . a node , an a node to which the candidate . a-arc can attach ( see below ) . If there is no such a node , it will be necessary to split the candidate . a - are using the procedure split . a-arc . If there is such an a node , a we connect o it , possibly after one or more applications of split . a node to split the connect-ing . anode . 
A connecting . a node is one whose reflected larcs are a superset of those of the candidate  . a-arCs origin This condition assures that all of the l nodes to be reflected as incoming a-arcs of the connectable a node have outgoing lares leading to the l node to be reflected as candidate  . a-arc . 
Before stepping through the link . candidate procedure in detail , let us preview split . a-are and split . a node , the subprocedures which split can-didate . a-arc or connecting . a nodes , and their significance . 
split . a-arc : This subroutine is needed when ( 1 ) the origin of candidate . a-arc contains both initial and non-initial lares , or (2) no connect-ing . a node can be found whose larcs were a superset of the larcs of the origin of candidate  . a-are . In either case , we must split the current candidate . a-are into several new candidate . a-arcs , each of which can eventually connecto a connecting  . a node . In preparation , we sort the lares of the current candidate . a-art's origin according to the connecting . a nodes which contain them . Each grouping of l ares then serves as the lares set of the origin of a new candidate  . a-arc , now guaranteed to ( eventually ) connect . We create and return these candidate . a-arcs in a list , to be pushed onto * candidate . a-arcs * . The original candidate . a-are is discarded . 
split . a node . This subrout in esplits connect-ing . a node when either ( 1 ) it contains both final and nonfinal lares or ( 2 ) the attempted connection between the origin of candidate  . a-are and connecting . a node would give rise to an ill-formed a node . In case (1) , we separate final from nonfinal ares , and establish a new splittee a node for each partition  . The splittee containing only nonfinal larcs becomes the con-neclng  . a node for further processing . In case (2) , some larcoriging roups in the attempted merge do not intersect with alllarcextremity groups  . 
We separate the larcs in the non-intersecting origing roups from those in the intersecting origing roups and establish as plittee a node for each partition  . The splittee with only intersecting origing roups can now be connected to candi-date  . a-arc with no further problems . 
In either case , the original a node is discarded , and both splittees are ( re ) connected to the a-arcs of the automaton . ( See available pseudocode for details . ) We now describe link . candidate in detail . The procedure is as follows : Test whether connect-ing  . a node contains both initial and non-initial larcs ; if so , using split . a-arc , we split candi-date . a-arc , and push the splittees onto * candidate . a-arcs * Otherwise , seek a connect-ing . a node whose lares are a superset of the lares of the origin of a-arc If there is none  , then no connection is possible during the current procedure call  . Split candidate . a-are , push all splittee a-arcs onto * candidate . a-ares *, and exit . If there is a connecting . a node , then a connection can be made , possibly after one or more applications of split . a node . Check whether con-necting . a node contains both final and nonfinal larcs . If not , no splitting will be necessary , so connect candidate . a-arc to connecting . anode . 
But if so , split connecting . a node , sparating final from nonfinal lares The splitting procedure returns the splittee a node having only nonfinal lares  , and this a node becomes the connect-ing . a node Now attempt to connect candi-date . a-arc to connecting . a node . If the merged a node at the connection point would be ill-formed  , then split connecting . a node ( a second time , if necessary ) . In this case , split . a node returns a connectable a node as connecting . a node , and we connect candidate . a-are to it . 
A final detail in our description of lat-tice . to . automaton concerns the special handling of the flnal  . lnode . For this last stage of the procedure , the subroutine which makes a new can-didate . a-arc makes a dummy a-arc whose ( real ) origin is the final . a node . This a node is stocked with l ares reflecting all of the final larcs  . The dummy candidate . a-arc can then be processed as usual . When its origin has been connected to the automaton  , it becomes the final . a node , with all final a-arcs as its incoming a-arcs , and the automaton is complete . 
3 Epsilon ( null ) transitions
The basic algorithm described thus far does not permit the creation of epsilon transitions  , and thus yields automata which are not minimal . 
However , epsilon arcs can be enabled by varying the current procedure split  . a-arc , which breaks eventually connectable a-arcs and pushes them onto * candidate  . a-arcs* . 
In the splitting procedure described thus far , the a-arc is split by dividing its origin ; its label and extremity are duplicated . In the variant ( proposed by the third author ) which enables epsilona-arcs , however , if the antecedence condition ( below ) is verified for a given split teea-arc , then its label is instead 7 . ( epsilon ) ; and its extremity instead contains the larcs of a sibling splittee's origin  . This procedure insures that the sibling's origin will eventually connect with the epsilona-arc's extremity  . Splitteea-arcs with epsilon labels are placed at the top of the list pushed onto * candidate  . a-ares * to ensure that they will be connected before sibling splittees  . 
What is the antecedence condition ? Recall that during the presentests for split  . a-are , we partition the a-arc's originlarcs . The antecedence condition obtains when one such larc partition is antecedent to another partition  . Partition PI is antecedent to P2 if every larc in P1 is antecedent to every larc in P2  . And larclisantecedent to larc 2 if , moving leftward in the lattice from larc 2 , one can arrive at anl node where larclisan outgoing larc  . 
A final detail : the revised procedure can create duplicate epsilona-arcs  . We eliminate such redundancy at connection time : duplicate epsilona-arcs are discarded  , thus aborting the connection procedure . 
4 Extended example
We now step through an extended example showing the complete procedure in action  . Several epsilon arcs will be formed . 
We show a nodes containing numbers indicating their reflected lares We show lare  . origin . 
groups on the left side of a nodes when relevant , and larc . extremity . groups on the right . 
Consider the lattice of Arabic forms shown in Figure  3  . After initializing a new automaton , we proceed as follows : ? V is it lnode W , constructing this candi-date . a-arc : ? w + The a-arc is connected to the initial a node  . 
V is it l node F , constructing this date . a-are : candi-The only connecting . a node is that containing the label of the initial lnode  ,  >
After connection , we obtain :
W1
V is it l node L , constructing date . a-are : this ? and i-A nodes 1 and 2 in the automaton are con-necting . a nodes . We try to merge them , and get : The tentative merged a node is wellformed  , and the merge is completed . Thus , before connection , the automaton appears as follows . ( For graphic economy , we show two a-arcs with common terminals as a single a-arc with two labels  . )
I ?
Now , in link . candidate , we split candidate . a-arc so as to separate in it all arcs from other larcs  . The split yields two candidate . a-ares : the first contains arc 9 , since it departs from the originl node ; and the second contains the other arcs . 
@ L??L ?
Following our basic procedure , the connection of these two arcs would give the following automaton : However  , the augmented procedure will instead create one epsilon and one labeled transition  . 
Why ? Our split separated larc 9 and larcs (3 , 13) in the candidate . a-are . Butlarc 9 is antecedent to larcs 3 and 13 . So the splittee candidate . a-are whose origin contain slarc 9 becomes an epsilona-arc , which connects to the automaton at the initial a node  . The sibling splittee--thea-arc whose origin contains  ( 3 , 13) -- is processed as usual . Because the epsilona-arc's extremity was given the lares of this sibling's origin  , connection of the sibling will bring about a merge between that extremity and a node  1  . The result is as follows : 02~'_ . ~2L ? ? V is it lnode S , constructing this candidate . a-are:@s@A node 1 is the tentative connection point for the candidate  . a-are , since it slarc set has the intersection (4 , 14) ~ qth that of eandidate . a-are's origin . 
Once again , we split candidate . a-are , since it contain slarc 10 , one of the lares of the initial node . But larcl 0 is an antecedent of arcs 4 and 14 . We thus create an epsilona-arc with larc 10 in its origin which would connect to the initial a node  . Its extremity will contain larcs4 and 14 , and would again merge with a node 1 during the connection of the sibling splittee . However , the epsilona-arc is recognized as redundant , and eliminated at connection time . The sibling a-arc labeled Sconnects , to a node 1 , giving Visit lnode A , constructing this candidate . a-are

The two connecting . a nodes for the candidate . a-arc are 2 and 3 . Their merge succeeds , yielding : We now split the candidate . a-are , since it finds no a node containing a superset of its origin'slares : larcs  ( 12 ,  19 , 21) do not appear in the merged connecting . a node . Three splittee candi-larc sets in their origins :   ( 5 ,  18) ,  (12 ,  19) , and (21) . Butlarcs 12 and 19 are antecedents of larcs 5 and 18  . Thus one of the splittees will become an epsilon a-arc which will  , after all siblings have been connected , span from a node 1 to a node 2 . And since (21) is also antecedent to (5 ,  18 ) a second sibling will become an epsilona-arc from the initial a node to a node  2  . The third sibling splittee connects to the same a node  , giving Figure 4 . 
V is it l node N , constructing this candidate . a-are : The connecting . a node is a node 2 . Once again , a split is required , since this a node does not con-rain arcs 11 ,  16 , and 22 . Again , three candi-date . a-ares are composed , with larc sets (6 ,  17) ,  (11 , 16) and (22) . But the last two sets are antecedent to the first set  . Two epsilon arcs would thus be created , but both already exist . After connection of the third sibling splittee , the automaton of Figure 5 is obtained . 
? Visitl node K , constructing this candidate . a-arc : We find and successfully merge connect-ing . a nodes (3 and 4) . For reasons already discussed , the candidate . a-arc is split into two siblings . The first , with an origin containing larcs (15 ,  16) , will require our first application of split . a node to divide a node 1 . The division is necessary because the connecting merge would be ill-formed  , and connection would create the parasite path KTB  . The split creates a node 4 ( not shown ) as the extremity of a new pair of a-arcs W , F--a second a-arc pair departing the initial a node with this same label set  . 
The second splitteel arc contains in its origin statelares  7 and 8  . It connects to both a node 3 and a node 4 , which successfully merge , giving the automaton of Figure 6 . 
V is it l node T , constructing this candidate . a-are : The arc connects to the automaton at a node  5  . 
V is it l node B , making this candidate . a-arc : The arc connects to a node 6 , giving the final automaton of Figure 7 . 
Conclusion and Plans
The algorithm for transforming lattices into nondeterministic finite state automata which we have presented here has been successfully applied to lattices derived from dictionaries  , i . e . 
very large corpora of strings ( Med deb-
Hamrouni (1996), pages 205-217).
Applications of the algorithm to the parsing of speech recognition results are also planned : lattices of phones or words produced by speech recognizers can be converted into initialized charts suitable for chart parsing  . 

Aho , A . , J . E . Hopcroft , and J . D . Ullman .  1982 . 
Data Structures and Algorithms . Addison-
Wesley Publishing , 419p.
Hopcroft , J . E . and J . D . Ullman .  1979 . Introduction to Automata Theory , Languages , and Computation . Addison-Wesley Publishing , 418 p . 
Meddeb-Hamrouni , Boubaker .  1996 . Md thodset algorithmes de reprdsentation et de compression degrands dictionnaires deformes  . Doctoral thesis , GETA , Laboratoire CLIPS , F 6 deration IMAG(UJF , CNRS , INPG ) , Univer-sit 6 Joseph Fourier , Grenoble , France . 
1210\[I'"1915x\]
Figure 3

Figure 4z$~L,~3 Figure 5
FWI Figure 6 zE Figure 7
W , F "
