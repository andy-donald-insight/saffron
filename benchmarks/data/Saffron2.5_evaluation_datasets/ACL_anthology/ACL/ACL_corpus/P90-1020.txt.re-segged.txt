TYPESINFUNCTION ALUNIFICATION GRAMMARS
Michael Elhadad
Department of Computer Science
Columbia University
New York , NY 10027
Internet : Elhadad@cs.columbia.edu

Functional Unification Grammars ( FUGs ) are popular for natural anguage applications because the formalism uses very few primitives and is uniform and expressive  . In our work on text generation , we have found that it also has annoying limitations : it is not suited for the expression of simple  , yet very common , taxonomic relations and it does not allow the specification of completeness conditions  . We have implemented an extension of traditional functional unification  . This extension addresses these limitations while preserving the desirable properties of FUGs  . It is based on the notions of typed features and typed constituents  . We show the advantages of this extension in the context of a grammar used for text generation  . 
1 INTRODUCTION
Unification-based formalisms are increasingly used in linguistic theories  ( Shieber , 1986) and computation a linguistics . In particular , one type of unification formalism , functional unification grammar ( FUG ) is widely used for text generation ( Kay ,  1979 , McKeown ,  1985 , Appelt ,  1985 , Paris ,  1987 , McKeown & Elhadad ,  1990 ) and is beginning to be used for parsing ( Kay ,  1985 , Kasper ,  1987) . FUG enjoy such popularity mainly because it allies expressiveness with a simple economical formalism  . It uses very few primitives , has a clean semantics ( Pereira & Shieber ,  1984 , Kasper & Rounds ,  1986 , E1-hadad ,  1990) , is monotonic , and grants equal status to function and structure in the descriptions  . 
We have implemented a functional unifier ( EI-hadad ,  1988 ) covering all the features described in ( Kay , 1979) and ( McKeown & Paris ,  1987) . Having used this implementation extensively , we have found all these properties very useful , but we also have met with limitations . The functional unification ( FU ) formalism is not well suited for the expression of simple  , yet very common , taxonomic relations . The traditional way to implement such relations in FUG is verbose  , inefficient and unreadable . It is also impossible to express completeness constraints on descriptions  . 
In this paper , we present several extensions to the FU formalism that address these limitations  . These extensions are based on the formal semantics presented in  ( Elhadad ,  1990) . They have been implemented and tested on several applications  . 

We first introduce the notion of typed features . R allows the definition of a structure over the primitive symbols used in the grammar  . The unifier can take advantage of this structure in a manner similar to  ( Ait-Kaci ,  1984) . We then introduce the notion of typed constituents and the FSET construct  . It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions  . Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions  . It also provides more readable and better documented grammars  . 
Most work in computational linguistics using a unification-based formalism  ( e . g . , ( Sag & Pollard ,  1987 , Uszkoreit ,  1986 , Karttunen ,  1986 , Kay ,  1979 , Kaplan & Bresnan , 1982)) does not make use of explicit typing . In ( Ait-Kaci ,  1984) , Ait-Kaci introduced V-terms , which are very similar to feature structures , and introduced the use of type inheritance in unification  . W-terms were intended to be general-purpose programming constructs  . We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints  . We also integrate the idea of typing with the particulars of FUGs  ( notion of constituent , NONE , ANY and CSET constructs ) and show the relevance of typing for linguistic applications  . 
2 TRADITION ALFUNCTIONAL
UNIFICATION ALGORITHM
The Functional Unifier takes as input two descriptions  , called functional descriptions or FDs and produces a new FD if unification succeeds and failure otherwise  . 
An FD describes a set of objects ( most often linguistic entities ) that satisfy certain properties . It is represented by a set of pairs \ [ a : v\ ]   , called features , where a is an attribute ( the name of the property ) and v is a value , either an atomics 3 anbol or recursively an FD . An attribute a is allowed to appear at most once in a given FDF  , so that the phrase " the a of F " is always non ambiguous  ( Kay ,  1979) . 
It is possible to define a natural partial order over the set of FDs  . An FDX is more specific than the FDY if X contains at least all the features of Y  ( that is X_cY )  . Two FDs are compatible if they are not contradictory on the value of an attribute  . Let X and Y be two compatible FDs . The unification of X and Y is by definition the most general FD that is more specific than both X and Y  . For example , the unification of year : 88 , time : hour : 5 and time : mns : 22 , month:10 is year : 88 , month : i0 , time : hour : 5 , mns : 22 . 
When properties are simple ( all the values are atomic )  , unification is therefore very similar to the union of two sets : Xu Y is the smallest set containing both X and Y  . There are two problems that make unification different from set union : first  , in general , the union of two FDs is not a consistent FD ( it can contain two different values for the same label  )  ; second , values of features can be complex FDs . The mechanism of unification is therefore a little more complex than suggested  , but the FU mechanism is abstractly best understood as a union operation over FDs  ( cf ( Kay , 1979) for a full description of the algorithm ) . 
Note that contrary to structural unification ( SU , as used in Prolog for example ) , FU is not based on order and length . Therefore , a:1 , b:2 and b:2 , a : 1\] are equivalent in FU but not in SU , and a:1 and b:2 , a : l are compatible in FU but not in SU ( FDs have no fixed arity )   ( cf . (Knight , 1989, p . 105) for a comparison SU vs . FU ) . 
TERMINOLOGY : We introduce here terms that constitute a convenient vocabulary to describe our extensions  . In the rest of the paper , we consider the unification of two FDs that we call input and grammar  . We define L as a set of labels or attribute names and C as a set of constants  , or simple atomic values . A string of labels ( that is an element of L * ) is called a path , and is noted <11 . . . 11,> . A grammar defines a domain of admissible paths , AcL * . A defines the skeleton of wellformed FDs . 
? An FD can be an atom ( element of 6' ) or a set of features . One of the most attractive characteristics of FU is that non-atomic 
FDs can be abstractly viewed in two ways : either as a fiat list of equations or as a structure quivalent to a directed graph with labeled arcs  ( Karttunen ,  1984) . The possibility of using a non-structured representation removes the emphasis that has traditionally been placed on structure and constituency in language  . 
? The meta-FDs NONE and ANY are provided to refer to the status of a feature in a description rather than to its value  . 
\[ label:NONE \] indicates that label cannot have a ground value in the FD resulting from the unification  . 
\[ label:ANY \] indicates that label ~- must have a ground value in the resulting 
FD . Note that NONE is best viewed as imposing constraints on the definition of A : an equation < II  . . . ln >= NONE means that < ll . . . ln > ~ A . 
1 58 ? A constituent of a complex FD is a distinguished subset of features  . The special label CSET ( Constituent Set ) is used to identify constituents . The value of CSET is a list of paths leading to all the con-stitueuts of the FD  . Constituents rigger recursion in the FU algorithm  . Note that CSET is part of the formalism , and that its value is not a valid FD . A related construct of the formalism , PATTERN , implements ordering constraints on the strings denoted by the FDs  . 
Among the many unification-based formalisms , the constructs NONE , ANY , PA TrEKN , CSET and the notion of constituent are specific to FUGs  . A formal semantics of FUGs covering all these special constructs is presented in  ( Elhadad ,  1990) . 
3 TYPED FEATURES
ALIMITATION OF FUGS:NOST RUCTURE OVER
THESETOFVALUES : In FU , the set of constants C has no structure . It is a fiat collection of symbols with no relations between each other  . All constraints among symbols must be expressed in the grammar  . In linguistics , however , grammars assume a rich structure between properties : some groups of features are mutually exclusive  ; some features are only defined in the context of other features  . 

I Question
IPersonal
Pronoun--I
I Demonstrative \[ Quantified

ICount
Common---I
IMass
Figure l : A system for NPs
Let's consider a fragment of grammar describing noun phrases  ( NPs )   ( cf Figure 1 ) using the systemic notation given in ( Winograd ,  1983) . Systemic networks , such as this one , encode the choices that need to be made to produce a complex linguistic entity  . 
They indicate how features can be combined or whether features are inconsistent with other combinations  . The configuration illustrated by this fragment is typical  , and occurs very often in grammars .   1 The schema indicates that a noun can be either a pronoun  , a proper noun or a common noun . Note that these 1We have implemented a grammar similar to OVinograd ,  1983 , appendix B ) containing 111 systems . In this grammar , more than 40% of the systems are similar to the one described here  . 
(  ( cat noun )   ( alt ( (  ( noun pronoun )   ( pronoun (   ( alt ( question personal demonstrative quantified )   )   )   )   )   (   ( noun proper )   )   (   ( noun common )   ( common ( ( alt ( countmass ) ) ) ) ) ) ) ) Figure 2: A faulty FUG for the NP system ( ( alt ( (  ( noun pronoun )   ( common NONE )   ( pronoun (   ( alt ( question personal demonstrative quantified )   )   )   )   )   ( ( noun proper )   ( pronoun NONE )   ( common NONE ) )  (   ( noun common )   ( pronoun NONE )   ( common ( ( alt ( countmass ) ) ) ) ) ) ) ) The input FD describing a personal pronoun is then :  ( ( cat noun )   ( noun pronoun )   ( pronoun personal )   ) Figure 3: A correct FUG for the NP system three features are mutually exclusive  . Note also that the choice between the features question  , per-sonal , demonstrative , quantified is relevant only when the feature pronoun is selected  . 
This system therefore for bids combinations of the type pronoun  , proper and common , personal . 
The traditional technique for expressing these constraints in a FUG is to define a label for each nonterminal symbol in the ~ stem  . The resulting ram-2mar is shown in Figure 2 . This grammar is , however , incorrect , as it allows combinations of the type (   ( noun proper )   ( pronoun question )   ) or even worse (   ( noun proper )   ( pronoun zouzou )   )  . Because unification is similar to union of feature sets  , a feature ( pronoun question ) in the input would simply get added to the output  . In order to enforce the correct constraints , it is therefore necessary to use the meta-FD NONE  ( which prevents the addition of unwanted features ) as shown in Figure 3 . 
There are two problems with this corrected FUG implementation  . First , both the input FD describing a pronoun and the grammar are redundant and longer than needed  . Second , the branches of the alternations in the grammar are interdependent : you need to know in the branch for pronouns that common ouns can be subcategorized and what the other classes of nouns are  . This interdependence prvents any modularity : if a branch is added to an alternation  , all other branches 2ALT indicates that the lists that follow are alternative noun types  . 159 need to be modified . It is also an inefficient mechanism as the number of pairs processe during unification is O  ( n  ~ ) for a taxonomy of depthd with an average of n branches at each level  . 
TYPEDFEATURES : The problem thus is that FUGs do not grace fiilly implement mutual exclusion and hierarchical relations  . The system of nouns is a typical taxonomic relation  . The deeper the taxonomy , the more problems we have expressing it using traditional 

We propose extracting hierarchical information from the FUG and expressing it as a constraint over the symbols used  . The solution is to define a subsumption relation over the set of constants C  . One way to define this order is to define types of symbols  , as illustrated in Figure 4 . This is similar to V-terms defined in ( Ait-Kaci ,  1984) . 
Once types and a subsumption relation are defined , the unification algorithm must be modified . The atoms X and Y can be unified ff they are equal OR if one subsumes the other  . The resuR is the most specific of X and Y . The formal semantics of this extension is detailed in  ( Elhadad ,  1990) . 
With this new definition of unification , taking advantage of the structure over constants , the grammar and the input become much smaller and more readable as shown in Figure  4  . There is no need to introduce artificial labels . The input FD describing a pronoun is a simple (   ( cat personal-pronoun )   ) instead of the redundant chain down the hierarchy  (   ( cat noun )   ( noun pronoun )   ( pronoun ( define-type noun ( pronoun proper common ) )  ( define-type pronoun ( personal-pronoun question-pronoun demonstrative -pronoun quantified-pronoun  ) )  ( define-type common ( count-noun mass-noun ) )
The ~ amm ~ becomes: ( ( cat noun )   ( alt ( ( ( cat pronoun )   ( cat ( ( alt ( question-pronoun personal-pronoun demonstrative -pronoun quantified-pronoun  ) ) ) ) )   ( ( cat proper ) )  ( ( cat common )   ( cat ( ( alt ( count-noun mass-noun ) ) ) ) ) ) ) )
And them put : (( cat personal-pronoun ))
Figure 4: Using typed ~ atures
Typedeelar at ~ ns: ( define-constituent determiner ( definite distance demonstrative possessive ) )
Input FDd ~ cr ~ inga determiner : ( determiner ( ( definite yes )   ( distance far )   ( demonstrative no )   ( possessive no ) ) ) 
F ~ ure 5: A typed constitue ~ personal )) . Because values can now share the same label CAT , mutual exclusion is enforced without adding any pair \ [  1 : NONE\] . 3 Note that it is now possible to have several pairs\[a:vi\]in an FDF  , but that hephrase " the a of F " is still non -ambiguous : it refers to the most specific of the vi  . Finally , the fact that there is a taxonomy is explicitly stated in the type definition section whereas it used to be buried in the code of the FUG  . This taxonomy is used to document the grammar and to check the validity of input FDs  . 
4 TYPEDCONSTITUENTS : THEFSET

A natural extension of the notion of typed features is to type constituents : typing a feature restricts its possible values  ; typing a constituent restricts the possible features it can have  . 
Figure 5 illustrates the idea . The define constituent statement allows only the four given features to appear under the constituent determiner  . This statement declares what the 3In this example , the grammar could be a simple flat alternation ( ( cat ( ( alt ( noun pronoun personal-pronoun . . , common mass-noun count-noun )))) , but this expression would hide the structure of the gIan~n ~  . 160 grammar knows about determiners . Define constituent is a completeness constraint as defined in LFGs  ( Kaplan & Bresnan ,  1982) ; it says what the grammar needs in order to consider a constituent complete  . Without this construct , FDs can only express partial information . 
Note that expressing such a constraint ( a limit on the arity of a constituent ) is impossible in the traditional FU formalism . It would be the equivalent of putting a NONE in the attribute field of a pair as in 

In general , the set of features that are allowed under a certain constituent depends on the value of another feature  . Figure 6 illustrates the problem . The fragment of grammar shown defines what inherent roles are defined for differentypes of processes  ( it follows the classification provided in ( Halliday ,  1985)) . We also want to enforce the constraint that the set of inherent roles is " closed ": for an action  , the inherent roles are agent , medium and benef and nothing else . This constraint cannot be expressed by the standard FUG formalism  . A define constituent makes it possible , but nonetheless not very efficient : the set of possible features under the constituent inherent -roles depends on the value of the feature process-type  . The first part of Figure 6 shows how the correct constraint can be implemented with define constituent only : we need to exclude all the roles that are not defined 
Without FSET : ( define-constituent inherent-roles ( agent medium benef carrier attribute processor phenomenon  ) )  (   ( cat clause )   ( alt (   (   ( process-type action )   ( inherent-roles ( ( carrler NONE )   ( attribute NONE )   ( processor NONE )   ( phenomenon NONE )   )   )   )   (   ( process-type attributive )   ( inherent-roles (   ( agent NONE )   ( medium NONE )   ( benef NONE )   ( processor NONE )   ( phenomenon NONE )   )   )   )   (   ( process-type mental )   ( inherent-roles ( ( agent NONE )   ( medium NONE )   ( benef NONE )   ( carrier NONE )   ( attribute NONE )   )   )   )   )   )   ) 
With FSET : (   ( cat clause )   ( alt (   (   ( process-type action )   ( inherent-roles (   ( FEET ( agent medium benef )   )   )   )   )   (   ( process-type attributive )   ( inherent-roles (   ( FEET ( carrier attribute )   )   )   )   )   (   ( process-type mental )   ( inherent-roles (   ( FEET ( processor phenomenon )   )   )   )   )   )   )   ) 
Figure 6: The FSET Construct for the process-type . Note that the problems are very similar to those encountered on the pronoun system : explosion of NONE branches  , interdependent branches , long and inefficient grammar . 
To solve this problem , we introduce the construct FEET ( feature set ) . FEET specifies the complete set of legal features at a given level of an FD  . FEET adds constraints on the definition of the domain of admissible paths A  . The syntax is the same as CSET . Note that all the feature specified in FEET do not need to appear in an FD : only a subset of those can appear  . 
For example , to define the class of middle verbs ( e . g . , " to shine " which accepts only a medium as inherent role and no agent  )  , the following statement can be unified with the fragment of grammar given in Figure  6:   (   ( verb (   ( lex " shine " )   ) )  ( process-type action )   ( voice-class middle )   ( inherent-roles (   ( FSET ( medium ) )  )   )   ) The feature ( FEET ( medium ) ) can be unified vAth ( FSET ( agent medium benef ) ) and the result is ( FSET ( medium ) ) . 
Typing constituent sine cessary to implement the theoretical claim of LFG that the number of syntactic functions is limited  . It also has practical advantages .   161 The first advantage is good documentation of the grammar  . Typing also allows checking the validity of inputs as defined by the type declarations  . 
The second advantage is that it can be used to define more efficient data structures to represent FDs  . 
As suggested by the definition of FDs , two types of data structures can be used to internally represent FDs : a fi at list of equations  ( which is more appropriate for a language like Prolog  ) and a structured representation ( which is more natural for a language like Lisp )  . 
When all constituents are typed , it becomes possible to use arrays or hash tables to store FDs in L is p  , which is much more efficient We are currently investigating alternative internal representations for FDs  ( cf . ( Pereira ,  1985 , Karttunen ,  1985 , Boyer ,  1988 , Hirsh ,  1988 ) for discussions of data structures and compilation of FUGs  )  . 
5 CONCLUSION
Functional Descriptions are built from two components : a set C of primitives and a set L of labels  . 
Traditionally , all structuring of FDs is done using strings of labels  . We have shown in this paper that there is much to begained by delegating some of the structuring to a set of primitives  . The set C is no longer a fiat set of symbols , but is viewed as a richly structured world . The idea of typed-unification is not new ( Ait-Kaci ,  1984) , but we have integrated it for the first time in the context of FUGs and have shown its linguistic relevance  . We have also introduced the FSET construct , not previously used in unification , en-dowing FUGs with the capacity to represent and reason about complete information in certain situations  . 
The structure of C can be used as a meta -description of the grammar : the type declarations specify what the grammar knows  , and are used to check input FDs . It allows the writing of much more concise grammars  , which perform more efficiently . It is a great resource for documenting the grammar  . 
The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm  ( Elhadad ,  1988) , as suggested in ( Hu et ,  1976 , Ait-Kaci ,  1984 , Escalada-Imaz & Ghallab ,  1988 ) and is used in several research projects ( Smadja & McKeown ,  1990 , Elhadad et al 1989 , McKeown & Elhadad ,  1990 , McKeown et al 1991) . The source code for the unifier is available to other researchers  . 
Please contact the author for further details.
We are investigating other extensions to the FU formalism  , and particularly , ways to modify control over grammars : we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints  ( set union and intersection )  . 
We are now exploring ways to integrate these later extensions more tightly to the FUG formalism  . 

This work was supported by DARPA under contract # N00039-84-C-0165 and NSF grant IRT-84-51438  . I would like to thank Kathy McKeown for her guidance on my work and precious comments on earlier drafts of this paper  . Thanks to Tony Weida , Frank Smadja and Jacques Robin for their help in shaping this paper  . I also want to thank BobK asper for originally suggesting using types in 



Ait-Kaci , Hassan .  (1984) . A Lattice-theoretic Approach to Computation Based on a Calculus of Partially Ordered Type Structures  . Doctoral dissertation , University of Pennsylvania . UMI #8505030 . 
Appelt , Douglass E .  (1985) . Planning English Sentences . Studies in Natural Language Processing . Cambridge , England : Cambridge
University Press.
Boyer , Michel .  (1988) . Towards Functional Logic Grammars . In Dahl , V . and Saint-Dizier P . ( Ed . ) , Natural Language Programming and Logic Programming  , II . Amsterdam : North

Elhadad , Michael .  (1988) . The FUF Functional Unifier : User's manual . Technical Report
CUCS-408-88, Columbia University.
Elhadad , Michael .  (1990) . A Set-theoretic Semantics for Extended FUGs . Technical Report
CUCS-020-90, Columbia University.
Elhadad , Michael , Seligmann , Doree D . , Feiner , Steve and McKeown , Kathleen R .  (1989) . A Common Intention Description Language for Interactive Multimedia Systems  . Presented at the Workshop on Intelligent Interfaces  , IJCAI 89 . 
Detroit , MI.
Esealada-Imaz , G . and M . Ghallab .  (1988) . A Practically Efficient and Almost Linear Unification Algorithm  . Artificial Intelligence , 36, 249-263 . 
Halliday , Michael A . K .  (1985) . An Introduction to Functional Grammar . London : Edward Arnold . 
Hirsh , Susan .  (1988) . P-PATR : A Compiler for Unification-based Grammars  . In Dahl , V . and Saint-Dizier , P . fed . ) , Natural Language Understanding and Logic Programming  , II . 
Amsterdam : North Holland.
Huet , George .  (1976) . Resolution d ' Equations dans des langages d'or dre 1  , 2 ,  . . . , co . Doctoral dissertation , Universite de Paris VII , France . 
Kaplan , R . M . and J . Bresnan .  (1982) . Lexical-functional grammar : A formal system for grammatical representation  . In The Mental Representation of Grammatical Relations  . 
Cambridge , MA : MIT Press.
Karttunen , Lauri . ( July 1984) . Features and Values . 
Coling 84. Stanford , California : COLING , 28-33.
Karttunen , Lauri .  (1985) . Structure Sharing with Bi-meeting of the ACL . ACL , 133-137 . 
Karttunen , Lauri .  (1986) . Radical Lexicalism . Technical Report CSLI-86-66, CSLI-Stanford

Kasper , Robert .  (1987) . Systemic Grammar and Functional Unification Grammar  . In Benson & Greaves ( Ed . ) , Systemic Functional Perspectives on discourse : selected papers from the  12th International Systemic Workshop . Norwood , NJ : Ablex . 
Kasper , Robert and William Rounds . ( June 1986) . A Logical Semantics for Feature Structures . 
Proceedings of the 24th meeting of the ACL.
Columbia University , New York , NY : ACL ,  257-266 . 
Kay , M .  (1979) . Functional Grammar . Proceedings of the 5th meeting of the Berkeley Linguistics Society . Berkeley Linguistics Society . 
Kay , M .  (1985) . Parsing in Unification grammar . In Dowty , Karttunen & Zwickyfed . ), Natural
Language Parsing . Cambridge , England :
Cambridge University Press.
Knight , Kevin . ( March 1989) . Unification : a Multidisciplinary Survey . Computing Surveys , 21(1), 93-124 . 
McKeown , Kathleen R .  (1985) . Text Generation : Using Discourse Strategies and Focus Constraints to Generate Natural Language Text  . 
Studies in Natural Language Processing.
Cambridge , England : Cambridge University

McKeown , Kathleen and Michael Ethadad .  (1990) . A Contrastive Evaluation of Functional Unification Grammar for Surface Language Generators : A Case Study in Choice of Connectives  . In Cecile L . Paris , William R . Swartout and William C . Mann ( Eds . ) , Natural Language Generation in Artificial Intelligence and Computational Linguistics  . Kluwer Academic Publishers . ( to appear , also available as Technical Report CUCS-407-88 , Columbia University) . 
McKeown , Kathleen R . and Paris , Cecile L . ( July 1987) . Functional Unification Grammar Revisited . Proceedings of the ACL conference . 
ACL , 97-103.
McKeown , K . , Elhadad , M . , Fukumoto , Y . , Lira , J . , Lombardi , C . , Robin , J . and Smadja , F .  (1991) . 
Natural Language Generation iCOMET . In Dale , R . , Mellish , C . and Zock , M . ( Ed . ) , Proceedings of the second European Workshop on Natural Language Generation  . To appear . 
Paris , Cecile L .  (1987) . The Use of Explicit User models in Text Generation : Tailoring to a User's level of expertise  . Doctoral dissertation,
Columbia University.
Pereira , Fernando .  (1985) . A Structure Sharing For-realism for Unification -based Formalisms  . 
Proceedings of the 23rd annual meeting of the
ACL . ACL , 137-144.
Pereira , Fernando and Stuart Shieber . ( July 1984) . 
The Semantics of Grammar Formalisms Seenas Computer Languages  . Proceedings of the Tenth International Conference on Computational Linguistics  . Stanford University , Stanford , Ca:
ACL , 123-129.
Sag , I . A . and Pollard , C .  (1987) . Head-driven phrase structure grammar : an informal synopsis  . Technical Report CSLI-87-79 , Center for the Study of Language and Information . 
Shieber , Stuart .  (1986) . CSLI Lecture Notes . Vol .   4: An introduction to Unification-Based Approaches to Grammar  . Chicago , Ih University of Chicago Press . 
Smadja , Frank A . and McKeown , Kathleen R .  (1990) . 
Automatically Extracting and Representing Collocations for Language Generation  . 
Proceedings of the 28th annual meeting of the
ACL . Pittsburgh : ACL.
Uszkoreit , Hanz . (1986). Categorial Unification

Winograd , Terry .  (1983) . Language as a Cognitive Process . Reading , Ma . : Addison-Wesley . 

