FEATURE-BASED ALLOMORPHY *
Hans-Ulrich Krieger Hannes Pirker
German Research Center for
Artificial Intelligence ( DFKI)
Stuhls at zenhaus weg3
W-66 Saarbr/icken 11, Germany
krieger , pirker@dfki.uni-sb.de
John Nerbonne
Alfa Informatica , P.O . Box 716
Oude Kijkin't Jatstraat 41
Rijksuniversiteit Groningen
NL9700 AS Groningen , Holland
nerbonne@let.rug.nl
Abstract
Morphotactics and allomorphy are usually modeled in different components  , leading to interface problems . To describe both uniformly , we define finite automata ( FA ) for allomorphy in the same feature description language used for morphotactics  . Nonphonologically conditioned allomorphy is problematic in FA models but submits readily to treatment in a uniform formalism  . 
1 Background and Goals
ALLO MORPHY or MORPHOPHONEMICS describes the variation we find among the different forms of a morpheme  . For instance , the German second person singular presentending -st has three different allomorphs  , -st , - est , - t , determined by the stem it combines with :' say ' ' pray ' ' mix '  ( 1 ) lsg presind 2sg presind 3sg presind sag+es ag+st sag+t bet+ebet+est bet -/- etmix+emix+tmix+t MORPHOT ACTICS describes the arrangement of morphs in words  , including , e . g . , the properties of - st that it is a suffix ( and thus follows the stem it combines with )  , and that it combines with verbs . While allomorphy is normally described in finite automata  ( FA )  , morphotactics is generally described in syntax -oriented models  , e . g . , CFGs or feature-based grammars . 
The present paper describes both allomorphy and morphotactics in a feature-based language like that of Head-Driven Phrase Structure Grammar  ( HPSG )   ( Pollard and Sag 1987 )  . 
* This work was supported by research grant ITW 9002   0 from the German Bundesministeriumffir Forschung und Technologie to the DFKIDISCO project  . We are grateful to an anonymous ACL reviewer for helpful comments  . 
The technical kernel of the paper is a feature -based definition of FA  .   1 While it is unsurprising that the languages defined by FA may also be defined by feature description languages  ( FDL )  , our reduction goes beyond this , showing how the FA themselves may be defined . The significance of specifying the FA and not merely the language it generates i that it allows us to use FA technology in processing allomorphy  , even while keeping the interface to other grammar components maximally transparent  ( i . e . , there is NO interface--all inguistic information is specified via FDL  )  . 
Our motivation for exploring this application of typed feature logic is the opportunity it provides for integrating in a single descriptive formalism not only  ( i ) allomorphic and morphotactic information but also  ( ii ) coneate native and nonconcatenative allomorphy . The latter is particularly useful when concatenative and nonconcatenative allomorphy coexists in a single language  , as it does , e . g . , in German . 
2 Finite Automata as Typed
Feature Structures
An FAA is defined by a 5-tuple ( Q , E ,  5 , q0 , F ) , where Q is a finite set of STATES , ~a finite IN-PUTAL PHABET , ( ~: Qx~---yQ is the TRAN-SITION FUNCTION , q0EQ the INITIAL STATE , and F_CQ the set of FINAL STATES . 2 For reasons of simplicity and space , we only refer to the simplest form of FA , viz . , DETERMIN-ISTIC finite automata without e-moves which consume exactly one input symbol at a time  . 
This is of course not a restriction w . r . t , expressivity : given an arbitrary automaton , we can always construct a deterministic , equiva-ISee Krieger 1993b for the details and several extensions . 
2We assume a familiarity with automata theory ( e . g . , Hopcroft and Ullman 1979) . 
140 lent one which recognizes the same language ( see Hopcroft and Ullman 1979 )  . Fortunately , our approach is also capable of representing and processing directly nondeterministic FA with e -moves and allows for edges which are multiple -symbol consumers  . 
Specifying an automaton in our approach means introducing for every state qEQ a possibly recursive feature type with the same name as q  . We will call such a type a CONFIGURATION . 
Exactly the attributes EDGE , NEXT , and INPUT are appropriate for a configuration , where EDGE encodes disjunctively the outgoing edges of q  , NEXT the successor states of q , and INPUT the symbols which remain on the input list when reaching q  . S Note that a configuration does not model just a state of the automaton  , but an entire description at a point in computation  . 
\[ EDGE input-symb \] ( 2 ) proto-confi9_=NEXT config/INPUT list ( input-symb ) J We now define two natural subtypes of proto-con fig  . The first one represents the nonfinal states Q\ F  . Because we assume that exactly one input symbol is consumed every time an edge is taken  , we are allowed to separate the input list into the first element and the rest list in order to structure-share the first element with EDGE  ( the consumed input symbol ) and to pass the rest list one level deeper to the next state  . 
(3) non-final-conflg=_proto-config"\]
EDGE\[\]/
NEXTIINPUT\[\]/
INPUT(\[-i-\].\[\]) J
The other subtype encodes the final states of F which possess no outgoing edges and therefore no successor states  . To cope with this fact , we introduce a special subtype of T , called under , which is incompatible with every other type . In addition , successfully reaching a final state with no outgoing edge implies that the input list is empty  . 
(4) final-config = proto-config\]
EDGE undefl
NEXT undefl
INP (   ) JaNote that EDGE is not restricted in bearing only atomic symbols  , but can also be labeled with complex ones , i . e . , with a possibly underspecified feature structure  ( for instance in the case of 2-1evel morphology -- see below )  . 

Figure 1: A finite automaton A recognizing the language ? ( A )  =  ( a+b ) *c . 
Of course , there will be final states without going edges , but such states are subtypes of the following DISJUNCTIVE type specification :  ( 5 ) config=_non-final-con . fig VJ ~ in al-config To make the idea more concrete  , let us study a very small example , viz . , the FAA ( see Figure 1) . A consists of the two states X and Y , from which we define the types X and Y , where Y ( 7 ) is only an instantiation of final-config . 
In order to depict the states perspicuously , we shall make use of DISTRIBUTEDDISJUNCTIONS . 
DSrre and Eisele 1989 and Backofen et al 1990 introduce distributed disjunctions because they ( normally ) allow more efficient processing of disjunctions , sometimes obviating the need to expand to disjunctive normal form  . They add no expressive power to a feature formalism  ( assuming it has disjunction )  , but abbreviate some otherwise prolix disjunctions  :   $1 aV
PATH2$1 ~ Vfl =
PATH 3..,\]\[PA,a\]\[P,THlb\]
PATH2o ~ VPATH2fl
PATH3\[...\]PATH3\[...\]
The two disjunctions in the feature structure on the left bear the same name  '$1'  , indicating that they are a single alternation . The sets of disjuncts named covary , taken in order . 
This may be seen in the right hand side of the equivalence  . 4 We employ distribute disjunctions below ( 6 ) to capture the covariation between edges and 4Two of the advantages of distributed disjunctions may be seen in the artificial example above  . 
First , co-varying but nonidentical elements can be identified as such  , even if they occur remotely from one another in structure  , and second , feature struc-tures are abbreviated . The amount of abbreviation depends on the number of distribute disjunctions  , the lengths of the paths PATH1 and PATH2 , and -- in at least some competing formalisms -- on the size of the remaining structure  ( cf . PATH3\[ . .  . \] above ) . 
141 their successor states : if a is taken , we must take the type X ( and vice versa ) , if b is used , use again type X , but if c is chosen , choose the type Y . 
(6) " non-final-config\]
X--EDGE$1 a V b V c
NEXT$1 X VX VY ( 7 ) Y-\[final-config\]WhetheranFAAACCEPTS the input or not is equivalent in our approach to the question of FEATURETERMCONSISTENCY : if we wish to know whether w  ( a list of input symbols ) will be recognized by A , we must EXPAND the type which is associated with the initial state  q0 of A and say that its INPUT is w . Using the terminology of Carpenter 1992: ( 8 ) must be a TOTALLY
WELL-TYPED feature structure.
\[ q?\](8) INPUTW
Coming back to our example ( see Figure 1) , we might ask whether abc belongs to /2(A ) . 
We can decide this question , by expanding the type X with \[ INPUT(a , b , c)\] . This will lead us to the following consistent feature structure which moreove represents  , for free , the complete recognition history of abc , i . e . , all its solutions in the FA . 
// EDGE\[\]c ( 9 ) \] NEXT\[NEXTIEYGE under NEXT\]NEXT under
I\[INPUT\[\](>/INPUTr-~(~\] . ~\]) / LINPUT~<\[~'~
LINPUT < 5q "
Note that this special form of type expansion will always terminate  , either with a unification failure ( A does not accept w ) or with a fully expanded feature structure , representing a successful recognition . This idea leads us to the following ACCEPTANCE CRITERION :  ( 10 ) w ? ? ( A )  ?=~  ( NEXT ) "\[ NP ( ) where f ? F Notice too that the acceptance criterion does not need to be checked explicitly - -it's only a logical specification of the conditions under which a word is accepted by an FA  . Rather the effects of ( 10 ) are encoded in the type specifications of the states  ( subtypes of final-config , etc . ) . 
Now that we have demonstrated the feature-based encoding of automata  , we can abbrevi-ate them , using regular expressions as " feature templates " to stand for the initial states of the automaton derived from them as above  . 5 For example , we might write a feature specification \[ NORPHIFORN  ( a+b ) * c \] to designate words of the form accepted by our example automaton  . 
As a nice by product of our encoding technique , we can show that unification , disjunction , and negation in the underlying feature logic directly correspond to the intersection  , union , and complementation fFA . Note that this statement can be easily proved when assuming a clas-sical set-theoretical semantics for feature structures  ( e . g . , Smolka 1988) . To give the flavor of how this is accomplished , consider the two regular expressions 1 : ab * c and/22 -- a*b c . We model them via six types , one for each state of the automata . The initial state of/21 is A , that of/22 is X . The intersection of?1   and/22 is given by the unification of A and X . Unifying A and
X leads to the following structure : ( 11 ) : EDGEa\[NEXTBJ\[NEXT $1 XVYJ\[NEXTBA Now , testing whether w belongs to /21   N/22 is equivalent to the satisfiability ( consistency ) of ( 12 ) AAXA\[INPUTw\] , where type expansion yields a decision procedure . The same argumentation holds for the union and complementation fFA  . It has to be noted that the intersection and complementation of FA via unification do not work in general  5'Template ' is a mild a buse of terminology since we intend not only to designate the type corresponding to the initial state of automaton  , but also to suggest what other types are accessible  . 
142 for FA with e-moves ( Ritchie et al 1992 ,  33-35) . 
This restriction is due to the fact , that the intersected FA must run " in sync " ( Sproat 1992 ,  139-140) . 
The following closure properties are demonstrated fairly directly  . 
Let A1 = ( Qt , Et , 61 , qo , F t ) and As = ( Os ,  ~2 , ~ S , q ~) , F s ) . 
* Al f7As ~ qoAq~o ? At UAs ~ qo Vq to ? A1 ~- ~ qo In addition , a weak form of functional uncertainty ( Kaplan and Maxwell 1988 )  , represented through recursive type specifications  , is appropriate for the expression also concatenation ad Kleene closure of FA  . Krieger 1993b provides proofs using auxiliary definitions and apparatus we lack space for here  . 
3 Allom or phy
The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics  ; weesche where the discussion of alternative theories and concentrate on inflectional morphology  . We describe inflection using a word-and-paradigm ( WP ) specification of morphotactics ( Matthews 1972 ) and a two-level treatment of allomorphy ( Koskenniemi 1983 )  . We also indicate some potential advantages of mixed models of allomorphy--finite state and other  .  6 3 . 1 WP Morphotact l cs in FDL Several WORD-GRAMMARS use FDL morphotactics  ( Trost 1991 , Krieger and Nerbonne 1992 on derivation ) ; alternative models are also available . Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection . The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes  . Technically , this is realized through the specification of large disjunctions which unify with lexeme specifications  . The SThe choice of two-level allomorphy is justified both by the simplicity of two-level descriptions and by their status as a " lingua franca " among computational morphologists  . Two-level analyses in FDLs may also prove advantageous if they simplify the potential compilation into a hybrid two-level approach of the kind described in Trost  1991  . 
three elements of the paradigm in ( 1 ) would be described by the distribute disjunction in  ( 13 )  . 
(13) weak-paradigm-word
FORH , pp , nd(U , r)
STEN~NORPHIENDING , s1
SyNILOCIHEADIAGR\[NUH

This treatment provides face to syntactic/semantic helps realize the goal of linguistic knowledge in a  ( Pollard and Sag 1987 )  . 
(+ , e)V (+ , s , t > v(-I- , t ) sg , lv : v3 a seamless inter-information , and representing ALL single formalism Nevertheless  , the model lacks a treatment of allomorphy . The various allomorphs of-st in ( 1 ) are not distinguished in the FDL , and Krieger and Nerbonne 1992 for esaw an interface to an external module for allomorphy  . It would be possible--but scientifically poor--to distinguish all of the variants at the level of morphotactics  , providing a brute-force solution and multiplying paradigms greatly  .   7 The characterization in Section 2 above allows us to formulate WITHINFDL the missing allomorphy component  . 
3.2 Two-Level Allom or phy
Two-level morphology has become popular because it is a declarative  , bidirectional and efficient means of treating allomorphy  ( see Sproat 1992 for a comprehensive introduction )  . 
In general , two-level descriptions provide constraints on correspondences between underlying  ( lexical ) and surface levels . We shall use it to state constraints between morphemic units and their allomorphic realizations  . Because two-level automata characterize relations between two levels  , they are often referred to ( and often realized as ) transducers . The individual rules then represent constraints on the relation being transduced  . 
The different forms of the suffix in 2nd person singular in ( 1 ) are predictable given the phonological shape of the stem  , and the alternations can be described by the following  ( simplified ) two-level rules ( we have abstracted away from in essential restrictions here  , e . g . , that ( strong ) verbs with i/e-umlaut do not show epen thesis ) :rTzoukermann and Libermann 1990 show that multiplying paradigms need not degrade performance  , however . 
143 (14) e-epen thesis in the bet-case+:e . d , t_s , ts-deletion in the mix-cases : O ? : ~ s , z , z , ch+:Ot The colon':'indicates a correspondence between lexical and surface levels  . Thus the first rule states that a lexical morph boundary + must correspond to a surface e if it occurs afterdort and before sort  . The second specifies when lexicals is deleted ( corresponds to surface 0 )  . Two-level rules of this sort are then normally compiled into transducers  ( Dalrympl et al . 1987, p . 35-45) . 
3.3 FDL Specification of Two-Level
Morphology
Two-level descriptions of allomorphy can be specified in FDLs straightforwardly if we model not transducers  , but rather two-level acceptors ( of strings of symbol pairs )  , following Ritchie et al 1992 . We therefore employ FA over an alphabet consisting of pairs of symbols rather than single symbols  , The encoding of these FA in our approach requires only replacing the alphabet of atomic symbols with an alphabet of feature structures  , each of which bears the attributes LEX and SURF . 
A pair of segments appearing as values of these feature stand in the lexical-surface correspondence relation denoted by ':' in standard two-level formalisms  . The values of the attributes STEM and ENDING in ( 13 ) are then not lists of symbols but rather lists of  ( underspecified ) feature structures . Note that the italicized tetc . 
found in the sequences under MORPHIENDING ( 13 ) denote types defined by equations such as ( 16 ) or ( 17 )  .   ( To make formulas shorter we abbrevi-ate ' alphabet ' etymologically as ' aft '  . )(15) a\]~=\[LEX$1"a"V .   . "s " V " s " V '+" V "+"\]
SURF$d"a"V . " s " V 0 V " e " v 0 ( 16 ) t =^\[ LZX"t"\]=\]LEX"t "
SURF"t "(17) +=--(~ A\[LEX "+"\]: LEX "+"
SURF"e"v 0 a Since our formalisation of FA cannot allowe -transitions without losing important properties  , we are in fact forced to this position . 
It is the role of the collection of FA to restrict underspecifled lexical representations to those obeying allomorphicon straints  . This is the substance of the allomorphy constraint  ( 18 )  , which , together with the Acceptance Criterion (10) , guarantees that the input obeys the constraints of the associated  ( initial states of the ) 

NORPH\]FORM\[~\] ( 18 ) allomorphy=_INPUT\[\]Rules of the sort found in  ( 14 ) can be directly compiled into FA acceptors over strings of symbol pairs  ( Ritchie et al 1992 , p . 19) . Making use of the regular expression otation as templates  ( introduced in Section 2 above )  ,   ( 1921 ) display a compilation of the first rule in ( 14 )  . Here the composite rule is split up into three different constraints  . The first indicates that epen thesis is obligatory in the environment specified and the latter two that each half of the environment specification is necessary  . 9(19) epent h-1 =_
Nallomorphy\]0RPH\[FORM(11"*t , d + : 0 s , t7r*)\]J(20) epenth-2=_allomorphy (21) epenth . 3=_allomorphy+o3 . 4 Limits of Pure FA Morphology Finitestate morphology has been criticized  ( i ) for the strict finite-stateness of its handling of morphotactics  ( Sproat 1992 ,  43-66) ;   ( ii ) for making little or no use of the notion of inflectional paradigms and inheritance relations between morphological casses  ( Cahill 1990 )  ; and ( iii ) for its strict separation of phonology from morphology--i  . e . , standard two-level rules can only be sensitive to phonological contexts  ( including word and morpheme boundaries )  , and apply to all forms where these contexts hold . 
In fact , allomorphic variation is often " fos-silized " , having out lived its original phonological motivation  . Therefore some allomorphic rules 97r * denotes the Kleene closure over alphabet 11" and A the complement of A with respect o~r . 
144 are restricted in nonphonological ways , applying only to certain word classes , so that some stems admit idiosyncratic exceptions with respect othe applicability of rules  ( see Bear 1988 , 
Emele 1988, Trost 1991)?
To overcome the first difficulty , a number of researchers have suggested augmenting FA with " word grammars "  , expressed in terms of feature formalisms like PATRII  ( Bear 1986 ) or HPSG ( Trost 1990 )  . Our proposal follows theirs , improving only on the degree to which morphotactics may be integrated with allomorphy  . See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems  . 
We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy  . German epen the sizes schwa ( < e > ) at morph boundaries , but in a way which is sensitive to morphological environments  , and which thus behaves differently in adjectives and verbs ? The data in  ( 22 ) demonstrates some of these differences , comparing epen thesis in phonologically very similar forms ? free  , adj superfrei+stfreiest(22) free , v2s presbe+frei+st befreist woo , v 2s presfrei+s t freist While the rule stated in ( 14 )   ( and reformulated in ( 19 ) - ( 21 ) ) treats the verbal epenthesis correctly , it is not appropriate for adjectives , for it does not allow epen thesis to take place after vowels  . We thus have to state different rules for different morphological categories  . 
The original two-level formalism could only solve this problem by introducing arbitrary diacritic markers ? The most general solution is due to Trost  1991  , who associated two-level rules with arbitrary filters in form of feature structures  . These feature structures are unified with the underlying morphs in or phs in order to check the context restrictions  , and thus serve as an interface to information provided in the feature-based lexicon  . But Trost's two-level rules are a completely different data structure from the feature structures decorating transitions in FA  . 
We attack the problem head on by restricting allomorphic on straints to specific classes of lexical entries  , making use of the inheritance techniques available in structured lexicons ? The cases of epen thesis in  ( 22 ) is handled by defining not only the rule in ( 1921 ) for the verbal cases , but also a second , quite similarule for the more liberal epen thesis n adjectives  ) ? This frees the 1? In fact , the rules could be specified so that the
T?.?allom or phyepenth-1epenth-2epenth-3 word
Adj Verb ...
Figure 2: Nonphonological Conditioning of allomorphy is achieved by requiring that only some word classes obey the relevant constraints ? Adjectives inherit from two of the epen thesis constraints in the text  , and verbs ( withouti/eumlaut ) satisfy all three . This very natural means of restricting allomorphic variation to selected  , nonphonologically motivated classes is only made available through the expression of allomorphy in type hierarchy of the FDL  . ( The types denote the initial states of FA , as explained in Section 2 . ) rule from operating on a strictly phonological basis  , making it subject o lexical conditioning ?
This is illustrated in Figure 2.
But note that this example demonstrates not only how feature-based allomorphy can overcome the strictly phonological base of two-level morphology  ( criticism ( iii ) above )  , but it also makes use of the inheritance structure in modern lexicons as well  . 
4 Conclusions
In this section we examine our proposal vis-b . -visothers , suggest future directions , and provide a summary . 
4.1 Comparison to other Work
Computational morphology is a large and active field  , as recent text books ( Sproat 1992 and Ritchie et al 1992 ) testify ? This impedes the identification of particularly important predecessors  , among whom nonetheless three stand out . First , Trost 1991's use of two-level morphology in combination verbal rule inherited from the more general adjectival rule  , but pursuing this here would take us somewhat a field  . 
1 45 with feature-based filters was an important impetus  . Second , researchers at Edinburgh ( Calder 1988 , Bird 1992 ) first suggested using FDLs in phonological and morphological description  , and Bird 1992 suggests describing FA in FDL ( without showing how they might be so characterized  , however -- in particular , providing no FDL definition of what it means for an FA to accept a string  )  . 
Third , Cahill 1990 posed the critical question , viz . , how is one to link the work in lexical inheritance  ( on morphotactics ) with that in finite-state morphology ( on allomorphy )  . This earlier work retained a separation of formalisms for allomorphy  ( MOLUSC ) and morphotactics ( DATR )  . Cahill 1993 goes on to experiment with assuming all of the allomorphic specification i to the lexicon  , in just the spirit proposed here . 11 Our work differs from this later work ( i ) in that we use FDL while she uses DATR , which are similar but not identical ( cf . Nerbonne 1992) ; and ( ii ) in that we have been concerned with showing how the standard model of allomorphy  ( FA ) may be assumed into the inheritance hierarchy of the lexicon  , while Cahill has introduced syllable-based models . 
4.2 Future Work
At present only the minimal examples in
Section 2 above have actually been implemented , and we are interested in attempting more . Second , a compilation into genuine finite state models could be useful  . Third , we are concerned that , in restricting ourselves thus farto acceptors over two-level alphabets  , we may in curparsing problems , which a more direct approach through finite-state transducers can avoid  ( Sproat 1992 , p . 143) . See Ritchie et al 1992 ,   1933 for an approach to parsing using finite-state acceptors  , however . 
4.3 Summary
This paper proposes a treatment of allomorphy formulated and processable in typed feature logic  . There are several reasons for developing this approach to morphology  . First , we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed -- at least as long as we do not sacrifice processing efficiency  . This is an overarching goal of HPSG ( Pollard and Sag 1987 ) -- in which syntax and semantics i described in a feature formalism  , and in which strides toward descriptions of mor -photactics  ( Krieger 1993a , Riehemann 1993 , lICf . Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann  1993  ) and phonology ( Bird 1992 ) have been taken . This work is the first to show how allomorphy may be described here  . The proposal here would allow one to describe segments using features  , as well , but we have not explored this opportunity for reasons of space  . 
Second , the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms  . Obviously interesting cases for the extension of feature-based descriptions to other areas are those involving stress and intonation -- where phonological properties can determine the meaning  ( via focus ) and even syntactic wellformedness ( e . g . , of deviant word orders ) . Similarly , allomorphic variants covary in the style register they belong to : the German dative singular in- e  , dera Kinde , belongs to a formal register . 
Third , and more specifically , the feature-based treatment of allomorphy overcomes the bifurcation of morphology into lexical aspects -- which have mostly been treated in lexical inheritance schemes -- and phonological spects -- which are normally treated in finite -state morphology  . This division has long been recognized as problematic  . One symptom of the problem is seen in the treatment of nonphonologically conditioned allomorphy  , such as Germanumlaut , which ( Trost 1990 ) correctly criticizes as ad hoc in finite-state morphology because the latter deals only in phonological  ( or graphemic ) categories . We illustrated the benefits of the uniform formalism above where we showed how a similar nonphonologically motivated alternation  ( German schwaepenthesis ) is treated in a feature-based description , which may deal in several levels of linguistic description simultaneously  . 

Backofen , R . , L . Euler , and G . G 6 r z .  1990 . Towards the Integration of Functions , Relations and Types in an AI Programming Language  . In Proc . of
GWAI-90. Berlin . Springer.
Bear , J .  1986 . A Morphological Recognizer with Syntactic and Phonological Rules  . In Proc . of
COLING , 272-276.
Bear , J .  1988 . Morphology with Two-Level Rules and Negative Rule Features  . In Proc . of COLING , 28-31 . 
Bird , S .  1992 . FiniteState Phonology in HPSG . In
Proc . of COLING , 74-80.
Cahill , L . J .  1990 . Syllable-Based Morphology . In
Proc . of COLING , 48-53.
Cahill , L . J .  1993 . Morphonology in the Lexicon . In Proc . of the 7th European ACL , 87-96 . 

Calder , J .  1988 . Paradigmatic Morphology . In Proc . 
of the 5th European ACL.
Carpenter , B .  1992 . The Logic of Typed Feature Structures . No . 32 Tracts in Theoretical Computer Science . Cambridge : Cambridge University

Dalrymple , M . , R . Kaplan , L . Karttunen , K . Koskenniemi , S . Shaio , and M . Wescoat .  1987 . Tools for Morphological Analysis . Technical Report CSLI-1987-108, CSLI,
Stanford University.
D Srre , J . , and A . Eisele .  1989 . Determining Consistency of Feature Terms with Distributed Disjunc-tions  . In Proc . of GWAI-89 (15th German Workshop on AI ), ed . D . Metzing , 270-279 . Berlin . 

Emele , M .  1988 . Uber legungen zueiner Two-Level Morphologie fiir das Deutsche  . In Proc . der 4 . Osterreichischen Artificiai-lntelligence-Tagung und des WWWS  , ed . H . Trost , 156-163 . Berlin : Springer . Informatik-Fachberichte 176 . 
Gerdemann , D .  1993 . Complement Inheritance as Subcategorization Inheritance  . In German Grammar in HPSG , ed . J . Nerbonne , K . Netter , and
C . Ponard . Stanford : CSLI.
Hopcroft , J . E . , and J . D . Ullman .  1979 . Introduction to Automata Theory , Languages , and Computation . Reading , Massachusetts : Addison-

Kaplan , R . , and J . Maxwell .  1988 . An Algorithm for Functional Uncertainty . In Proc . of Coling 1988, 303-305 . Budapest . 
Koskenniemi , K .  1983 . Two-Level Model for Morphological Analysis . In Proc . of IJCAI , 683-685 . 
Krieger , H . - U . 1993a . Derivation Without Lexi-cad Rules . In Constraint Propagation , Linguistic Description and Computation , ed . R . Johnson , M . Rosner , and C . Rupp . Academic Press . 
Krieger , H . - U . 1993b . Representing and Processing Finite Automata Within Typed Feature Formalisms  . Technical report , Deutsches Forschungs institut fiir Ki inst fiche Intelligenz  , 
Saarbriicken , Germany.
Krieger , H . - U . , and J . Nerbonne .  1992 . Feature-Based Inheritance Networks for Computational Lexicons  . In Default Inheritance within Unification-Based Approaches to the Lexicon  , ed . 
T . Briscoe , A . Copestake , and V . de Paiva . Cambridge : Cambridge University Press . Also DFKI
Research Report RR-91-31.
Matthews , P .  1972 . Inflectional Morphology : A Theoretical Study Based on Aspects of Latin Verb Conjugation  . Cambridge , England : Cambridge
University Press.
Nerboune , J .  1992 . Feature-Based Lexicons -- An Example and a Comparison to DATR  . In Beitriige des ASL-Lexikon-Workshops , Wandlitz ( bei Berlin ) , ed . D . Reimann , 36-49 . also DFKI

Pollard , C . , and I . Sag .  1987 . Information-Based Syntax and Semantics , Vol . L Stanford : CSLI . 
Reinhard , S . , and D . Gibbon .  1991 . Prosodic Inheritance and Morphological Generalizations  . In Proc . of the 6th European ACL , 131-137 . 
Riehemarm , S .  1993 . Word Formation in Lexical Type Hierarchies . A Case Study of bar-Adjectives in German . Master's thesis , Eberhard-Karls-Universit ~ it Tiibingen , Seminarf/JrS prach wissenschaft . 
Ritchie , G . D . , G . J . Russell , A . W . Black , and S . G . 
Pulman .  1992 . Computational Morphology : Practical Mechanisms for the English Lexicon  . Cambridge : MIT Press . 
Smolka , G . 1988. A Feature Logic with Subsorts.
Technical Report 33, WTLILOG-IBM Germany.
Sproat , R . 1992. Morphology and Computation.
Cambridge : MIT Press.
Trost , H .  1990 . The Application of Two-Level Morphology to Nonconcatenative Grman Morphology  . In Proc . of COLING , 371-376 . 
Trost , H .  1991 .   X2MORF : A Morphological Component Based on Augmented Two-Level Morphology  . Technical Report RR-91-04, DFKI,
Saarbrficken , Germany.
Tzoukermann , E . , and M . Libermann .  1990 . A FiniteState Morphological Processor for Spanish . 
In Proc . of COLING , Vol . 3.

