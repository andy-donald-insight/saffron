USING %-CALCULUSTORE PRESENT MF~kNING SINLOGIC GRAMMARS * 
David Scott Warren
Computer Science Department
SUN Yat Stony Brook
Stony Brook , NY 11794

This paper descrlbes how meanings are represented in a semantic grammar for a fragment of English in the logic programming language Prolog  . 
The conventions of Definite Clause Grammars are used  . Previous work on DCGs with a semantic component has used essentially first-order formulas for representing meanings  . The system described here uses formulas of the typed ~- calculus  . The first section discusses general issues concerning the use of first-order logic or the h -calculus to represent meanings  , The second section describes howh-calculus meaning representations can be constructed and manipulated directly in Prolog  . This ' programmed ' representation motivates a suggestion  , discussed in the third section , for an extension to Prolog so that the language itself would include a mechanism for handling the ~- formulas directly  . 
Ih-CAL CULUS AND FOL AS MEANING
REPRESENTATION LANG UAGES
The initial phase of most computer programs for processing natural language is a translation system  . This phase takes the English text input and transforms it into structures in some internal meaning-representation language  . Most of these systems fall into one of two groups : those that use a variant of first-order logic  ( FOL ) as their representation language , and those that use the typed h-calculus ( LC ) for their representation language .   ( Systems based'on semantic nets or conceptual dependency structures would generally be calsslfied as using variants of FOL  , but see\[Jones and Warren ,   1982\] for an approach that views them as LC-based . ) The system considered here are several highly formalized grammar systems that concentrate on the translation of sentences of logical form  . The first-order logic systems are exemplified by those systems that have developed around  ( or gravitated to ) logic programming , and the Prolog language in particular . These include the systems described ill\[ Colmerauer  1982\]  , \[ Warren1981\] , \[Dahl1981\] , \[Simmons and Chester 1982\] , and \[ McCord 1982\] . 
The systems using the ~- calculus are those that * This material is based upon work supported by the National Science Foundation under grant ~  IST-80-They include the systems described in \[ Montague 1973\]  , \[Gawron et al1982\] , \[ Rosenschein and Sheiber 1982\] , \[Schubert and Pelletier 1982\] , and \[ Warren and Friedman 1981\] . For the purposes of this paper , no distinction is made between the intensional logic of Montague grammar and the typed h -calculus  . There is a mapping from intensional logic to a subset of a typed h-calculus \[ Gallin  1975\]  , \[Clifford 1981\] that shows they are essentially equivalent in expressive power  . 
All these grammar systems construct a formula to represent the meaning of a sentence compositionally over the syntax tree for the sentence  . 
They all use syntax directed translation . This is done by first associating a meaning structure with each word  . Then phrases are constructed by syntactically combining smaller phrases together using syntactic rules  . Corresponding to each syntactic rule is a semantic rule  , that forms the meaning structure for a compound phrase by combinging the mean in ~ structures of the component phrases  . This is clearly and explicitly the program used in Montague grammar  . It is also the program used in Prolog-based natural language grammars with a semantic component  ; the Prolog language itself essentially forces this methodology  . 
Let us consider more carefully the meaning structures for the two classes of systems of interest here : those based on FOL and those based on 

Each of the FOL systems , given a declarative sentence as input , produces a wellformed formula in a first-order logic to represent the meaning of the sentence  . This meaning representation lo~ic will be called the MRFOL  . The MILFOL has an intended interpretation based on the real world  . 
For example , individual variables range over objects in the world and unary predicate symbols are interpreted as properties holding of those realworld objects  . 
As a particular recent example , consider Dahl's system\[1981\] . Essentially the same approach was used in the Lunar System\[Woods  , et al .  1972\] . For the sentence ' E very man walks ' , Dahl's system would produce the expression : for ( X , and(man(X) , not walk(X )) , equal ( card(X ) , 0 ) ) where X is a variable that ranges over realworld and illustrates her meaning representation language  . The formula can be paraphrased as " the X's which man is true of and walk is not true of have ? ardinality zero  . "It is essentially first-order because the variables range over individuals  . 
(There would need to be some translation for the card function to work correctly  . ) This example also shows how Dahl uses a formula in her MRFOL as the meaning structure for a declarative sentence  . 
The meaning of the English sentence is identified with the meaning that the formula has in the intended interpretations for the MRFOL  . 
Consider mow the meaning structure Dahluses for phrases of a category other than sentence  , a noun phrase , for example . For the meaning of a noun phrase , Dahl uses a structure consisting of three components : a variable  , and two ' formulas ' . 
As an example , the noun phrase ' every man'has the following triple for its meaning structure :\[  X1  , X/ , for(Xl , and(man(Xl) , not(X2)) , eqnal(card(Xl ) , 0))\] . 
We can understand this structure informally by thinking of the third component as representing the meaning of ' every man '  . It is an object that needs a verb phrase meaning in order to become a sentence  . The X2 stands for that verb phrase meaning . For example , during constz ~ ction of the meaning of a sentence containing this noun phrase as the subject  , the meaning of the verb phrase of the sentence will be bound to  X2  . Notice that the components of this meaning structure are not themselves formulas in the MRFOL  . They look very much like FOL formulas that represent meanings  , but on closer inspection of the variables , we find that they cannot be .   X2 in the third component is in the position of a formula  , not a term ; ' not ' applies to truth values , not to individuals . Thus X2 cannot be a variable in the M1% FOL , because X2 would have to vary over truth values , and all FOL variables vary over individuals . So the third Component is not itself a MIRFOL formula that  ( in conjunction with the first two components ) represents the meaning of the noun phrase , ' every man ' . 
The intuitive meaning here is clear . The third compdnent is a formula fragment that participates in the final formula ultimately representing the meaning of the entire sentence of which this phrase is a subpart  . The way this fragment Dartic-ipates is indicated in part by the variable  X2  . 
It is important to notice that X2 is , in fact , a syntactic variable that varies over formulas , i , e . , it varies over certain terms in the MRFOL .   X2 will have as its value a formula with a free variable in it : a verb phrase waiting for a subject  . The X1 in the first component indicates what the free variable must become to match this noun phrase correctly  . Consider the operation of putting XI into the verb phrase formula and this into the noun phrase formula when a final sentence meaning is constructed  . In whatever order this is done , there must be an operation of substitution a formula with a free variable  ( XI ) in it , into the scope of a quantifier ( ' for ' ) that captures it . 
Semantically this is certainly adubious operation . 
The point here is not that this system is wrong or necessarily deficient  . Rather the representation language used to represent meanings for subsentential components is not precisely the MRFOL  . Meaning structures built fo ~ subcomponents are , in general , fra~rments of first-order formulas with some extranotation to be used in further formula construction  . This means , in general , that the meanings of subsentential phrases are not given a semantles by first-order model theory  ; the meanings of intermediate phrases are ( as far as traditional first-order logic is concerned  ) merely uninterpreted data structures . 
The point is that the system is building terms , syntactic objects , that will eventually be put together to represent meanings of sentences  . This works because these terms , the one sultimately associated with sentences , always turn out to be formulas in the MRFOL in just the right way  . However , some of the terms it builds on the way to a sentence  , terms that correspond to subcomponents of the sentence  , are not in the MRFOL , and so do not have a interpretation in its real world model  . 
Next let us move to a consideration of those systems which use the typed l-calculus  ( LC ) as their meaning representation language . Consider again the simple sentence ' Everyman walks '  . The grammar of \[ Montague 1973\] associates with this sentence the meaning : for ail  ( X , implies(man(X) , waik ( X ) ) )   ( We use an extensional fragment here for simplicity  . ) This formula looks very much like the first -order formula given above by the Dahl system for the same sentence  . This formula , also , is a formula of the typed X-calculus ( FOL is a subset of LC )  . Now consider a noun phrase and its associated meaning structure in the LC framework  . For ' every man ' the mean in ~ structure is:

This meaning structure is a formula in the k -calculus  . As such it has an interpretation in the intended model for the LC  , just as any other formula in the language has . This interpretation is a function from properties to truth-values  ; it takes properties that hold of every manto ' true ' and all other properties to ' false '  . This shows that in the LC framework , sentences and subsentential phrases are given meanings in the same way  , whereas in FOL systems only the sentences have meanings  . Meaning structures for sentences are wellformed LC formulas of type truth-value  ; those for other phrases are wellformed LC terms of other types  . 
Consider this k-formula for ' every man ' and compare it with the three-tuple meaning structure built for it in the Dahl system  . The ~- variable P plays a corresponding role to the  X2 variable of the triple ; it sultimate value comes from a verb phrase meaning encountered elsewhere in the sentence  . 
First-order logic is not quite expressive categories of phrases that can be subcomponents of sentences  . In systems based on first-order logic , this limitation is handled by explicitly construc-ting fragments of formulas  , with extranotation to indicate how they must later combine with other fragments to form a true first-order formula that correctly represents the meaning of the entire sentence  . In some sense the construction of the semantic representation is entirely syntactic until the full sentence meaning structure is constructed  , at which point it comes to a form that does have a semantic interpretation  . In contrast , in systems that use the typed l-calculus , actual formulas of the formal language are used at each step  , the language of the l-calculus is never left , and the building of the semantic representation can actually be understood as operations on semantic objects  . 
The general idea of how to handle the example sentence ' Every man walks ' in the two systems is essentially the same  . The major difference is how this idea is expressed in the available languages  . 
The LC system can express the entire idea in its meaning representation language  , because the typed l-calculus is a more expressive language  . 
The obvious question to ask is whether there is any need for semantically interpretable meaning representations at the subsentential level  . One important reason is that to do formal deduction on subsentential components  , their meanings must be represented in a formal meaning representation language  . LC provides such a language and FOL does not . And one thing the field seems to have learned from experience in natural language processing is that inferencing is useful at all levels of processing  , from words to entire texts . This points us toward something like the LC . The problem , of course , is that because the LC is so expressive , deduction in the full LC is extremely difficult . Some problems which are decidable in FOL become undecidable in the l-calculus  ; some problems that are semi-decidable in FOL do not even have partial decision procedures in the LC  . 
It is certainly clear that each language has limitations  ; the FOL is not quite expressive enough , and the LC is much too powerful . With this in mind , we next look at some of the implications of trying to use the LC as the mean in ~ representation language in a Proiog system  . 
IILCINPROLOG
PROLO ~ is extremely attractive as a lan~uaFe for express in E grammars  . ~tamor phosis ~ rammars\[Colmerauer 197g \] and Definite Clause Grammars ( DCGs ) \ [ Pereira and I Carren 1980\] are essentially conventions for representing grammars as logic programs  . DCGs can perhaps most easily be understood as an improved cersion of the Augmented Transition Network language \[ Woods  1970\]  . Other work on natural language in the PROLOG framework has used firs $- order meaning representation lang-uages  . The rest of this paper explores the implications of using the l-calculus as the meaning representation language for a system written in 
PROLOG using the DCG conventions.
The follow in ~ paragraphs describe a system that includes a very small grammar  . The point of this system is to investigate the use of PROLOG to construct meanings with the %- calculus as the meaning representation language  , and not to explore questions of l in Rulstic coverage  . The grammar is based on the grammar of \[ Montague  1973\]  , but is entirely extensional . Including inten-sionality would present no new problems in principle  . 
The idea is very simple . Each nonterminal in the grammar becomes a three -place predicate in the Prolog program  . The second and third places indicate locations in the input string  , and are normally suppressed when DCGs are displayed  . The first piece is the LC formulare presenting the meaning of the spanned syntactic component  . 
Lambda-formulas are represented by Prolo ~ terms . The crucial decision is how to represent variables in the h-formulas  . One'pure'way is to use a Prolog function symbol  , sayivar , of one argument , an integer . Then Ivar (37) would represental-variable . For our purposes , we need not explicitly encode the type of %- terms  , since aii the formulas that are constructed are correctly typed  . For other purposes it might be desirable to encode explicitly the type in a second argument of ivar  . Constants could easily be represented using another function symbol  , icon . Its first argument would identify the constant . A second argument could encode its type , if desired . Application of al-term to another is represented using the Prolog function symbol lapply  , which has two argument places , the first for the function term , the second for the argument term . Lambda abstraction is represented using a function symbol ~ with two arguments : the ~- variable  , and the function body . Other commonly used connectives , such as ' and ' and ' or ' , are represented by similarly named function symbols with the appropriate number of argument places  . With this encoding scheme , the h-term : % P ( 3x ( man ( x ) & P ( x ) ) would be represented by the ( perha Ds somewha tawkward-looking ) Prolo ~ term : lambda ( Ivar ( 3 )  , Ithereis(ivar(1) , l and ( lapply ( icon(man ) , l ~ r (1)) lapply ( ivar (3) , ivar ( 1 ) )  ) ) ) ~- reduction would be coded as a predicate i reduce  ( Form , Reduced ) , whose first argument is an arbitrary %- formula , and second is its ~- reduced form . 
This encoding requires one to generate new variables to create variants of terms in order to avoid collisions of %- variables  . The normal way to avoid collisions is with a global'gensym ' counter  , to insure the same variable is never used twice . One way to do this in Prolog is to include This can be done by including a parameter which will always be of the form gensym  ( Left , Right ) , where Left is the value of the gensym counter at the left end of the phrase spanned by the predicate and Right is the value at the right end  . Any use of a k-variable in building al-formula uses the counter and bumps it  . 
An alternative and more efficient way to encode k -terms as Prolog terms involves using Prolog variables for l-variables  . This makes the substitution trival , essentially using Prolog's built-lnfacility for manipulating variables  . It does , however , require the use of Prolog's meta-logical predicate varto test whether a Prolog variable is currently instantiated to a variable  . This is necessary to prevent the k-varlables from being used by Prolog as Prolog variables  , In the example below , we use Prolog variables for X-varlables and also modify the I confunction encoding of con-s = ants  , and let constants stand for themselves . 
This results in a need to use the meta-logical predicate atom  . This encod in E scheme might be considered as an efficiency hack to use Prolog's builtin variable-handllng facilities to speed the 

We give below the Prolog program that represents a small example grammar with a few rules  . 
This shows how meaning structures can be represented as l-formulas and manipulated in Prolog  . 
Notice the simple , regular structure of the rules . 
Each consists of a sequence of grammar predicates that constructs the meanings of the subcomponents  , followed by an instance of their educe predicate that constructs the compound meaning from the component meanings and l-reduces the result  . The syntactic manipulation of the formulas , which results for example in the relatively simple formula for the sentence ' Every man walks ' shown above  , is done in the h-reduct lonper formed by the i reduce predicate  . 
/**/ tS(M,X,Y):-te(Ml,X,Z).
iv(M2, Z,Y ), i reduce ( lapply ( Mi , M2), M).
te(M , X , Y ) :- det(Mi , X , Z ) , cn(M2 , Z , Y ) , l reduce ( lapply ( ~ , M2) , M) . 



det(lambda(P , lambda(Q , i for all ( Z , limplies ( lapply ( P , Z) , lapply(Q , Z ))))) , \[ every IX\] , X ) iv(M , X , Y ) :- tv(MI , X , Z ) , te(M2 , Z , Y ) , i reduce ( lapply ( Mi , M2) , M) . 
* / iv(walk,\[walkslX\],X).
tv(lambda(P , lambda(Q , lapply ( P , lambda(Y , lapply(lapply(love , Y) , Q ))))) , \[ loves\[X\] , X) . 

IIII-CAT . CULUSINTHEPROLOGINTERPRETER There are several deficiencies in this Prolog implementation of grammars using the X-calculus as a meaning representation language  . 
First , neither of the suggested implementations of X -reduction in Prolog are particularly attractive  . The first , which uses first-order constants to represent variables  , requires the addition of a messygensym argument place to every predicate to simulate the global counter  , This seems both inelegant and a duplication of effort  , since the Prolog interpreter has a similar kind of variable-handling mechanism built into it  . The second approach takes advantage of Prolog's built invariable facilities  , but requires the use of Prolog's meta-logical facilities to do so  . This is because Prolog variables are serving two functions  , as Prolog varlabies and ash-variables . 
The two kinds of variables function differently and must be differentiated  . 
Second , there is a problem with invertibility.
Many Prolog programs are invertible and may be run ' backwards '  . We should be able , for example , to evaluate the sentence grammar predicate giving the meaning of a sentence and have the system produce the sentence itself  . This ability to go from a meaning formula back to an English phrase that would produce it is one of the attractive properties of logic grammars  . The grammar presented here can also be run this way  . However , a careful look at this computation process reveals that with this implementation the Prolog interpreter performs essentially an exhaustive search  . It generates every subphrase , h-reduces it and checks to see if it has the desired meaning  . Aside from being theoretically unsatisfactory , for a grammar much larger than a trivially-small one  , this approach would not be computationally feasible  . 
So the question arises as to whether the Prolog interpreter might be enhanced to know about l -formulas and manipulate them directly  . Then the Prolog interpreter itself would handle the X-reduc-tion and would be responsible for avoiding variable collisions  . The logic grammars would look even simpler because their educe predicate would not need to be explicitly included in each grammar rule  . For example , the ts clause in the grammar in the figure above would become : ts  ( lapply ( MI , M2) , X , Y ) te(MI , X , Z ) , iv(M2 , Z , Y) . 

Declarations to the Prolog interpreter could be included to indicate the predicate argument places that contain l-terms  . Consider what would be involved in this modification to the Prolog system  . It might seem that all that is required is just the addition of al-reduction operator applied to l-arguments  . And indeed when executing in the forward direction  , this is essentially all that is involved . 
Consider what happens , however , if we wish to execute the grammar in the reverse direction  , i . e . , give a l-term that is a meaning , and have the Prolog system find the English phrase that has that meaning  . Now we find the need for a ' l-expan-sion ' ability  . 
Consider the situation in which we present
Prolog with the following goal : ts ( for all ( X , implies(man(X) , walk(X))) , S , \[\]) . 
Prolog would first try to match it with $ he head of the ts clause given above  . This would require matching the first terms , i . e . , forall(X , implies(lapply(man , X) , lapply(walk , X ))) and lapply ( Mi , M2 )   ( using our encoding of l-terms as Prolog terms . ) The marcher would have available the types of the variables and terms  . We would like it to be able to discover that by substituting the right terms for the variables  , in particular substituting lambda(P , forall(X , implies ( lapply ( man , X) , lapply(P , X )))) and walk for M2 for M1 in the second term , it becomes the same as the first term ( after reduction )  . These MI and M2 values would then be passed onto the tean div predicates  . The iv predicate , for example , can easily find in the facts the word to express the meaning of the term  , walk ; it is the work ' walks ' and is expressed by the factiv  ( walk , \[walksIX\] , X ) , shown above . For the predicate re , given the value of MI , the system would have to match it against the head of the teclause and then do further computation to eventually construct the sentence  . 
~at we require is a general algorithm for matching l-terms  . Just as Prolog uses unification of first-order terms for its parameter mechanism  , to enhance Prolog to include l-terms , we need general unification of l-~erms . The problem is that l-unlficatlon is much more complicated than first-order unification  . For a unifiable pair of first-order terms , there exists a unique ( up to change of bo~md variable ) most general unifier ( mgu ) for them . In the case of l-terms , this is not true ; there may be many unifiers , which are not generalizations of one another . Furthermore unification of l-terms is , in general , undecidable . 
These facts in themselves , while perhaps discouraging , need not force us to abandon hope . The fact that there is no unique mgujust contributes another place for nondeterminism to the Prolog interpreter  . And all interpreters which have the power of a universal Turing machine have undecidable properties  . Perhaps another source of unde-cidability can be accommodated  . Huet\[197~\]' , -s given a semi-decision procedure for unification in the typed l-calculus  . The question of whether this approach is feasible really comes down to the finer properties of the unification procedure  . It seems not unreasonable to hope that in the relatively simple cases we seem to have in our grammars  , this procedure can be made to perform adequately . 
Notice that , for parsing in the forward direction , the system will always be unifying al-term with a variable  , in which case the unification problem is trivial . We are in the process of programming Huet's algorithm to include it in a simple Prolog-like interpreter  . We intend to experiment with it to see how it performs on the l-terms used to represent meanings of natural language expressions  . 
Warren \[1982\] points out how some suggestions for incorporating l-calculus into Prolog are motivated by needs that can easily and naturally be met in Prolog itself  , unextended . Following his suggestions for how to represent l -expressions in in Prolo ~ directly  , we would represent the meaning of a sentence by a set of asserted Prolog clauses and an encoding atomic name  , which would have to be generated . While this might be an interesting alternate approach to meaning representations  , it is quite different from the ones discussed here  . 
IVCONCLUSIONS
We have discussed two alternatives for meaning representation languages for use in the context of lo~ic grammars  . We pointed out how one advantage of the typed l -calculus over first-order logic is its ability to represent directly meanings of phrases of all syntactic cate Bories  . We then showed how we could implement in Prologa logic grammar using the l-calculus as the meaning representation langua Ee  . Finally we discussed the possibility and some of the implications of trying to include part of the l-calculus in the logic programming system itself  . We suggested how such an integration might allow grammars to be executed backwards  , generating English sentences from input logical forms  . ~ intend to explore this further in future work . If the l-calculus can be smoothly incorporated in the way suggested  , then natural language grammar writers will find themselves ' programming ' in two languages  , the first-order language ( e . g . Prolog ) for syntax , and the typed l-calculus ( e . g . typed LISP ) for semantics . 
As a final note regarding meaning representation languages : we are still left with the feeling that the first-order languages are too weak to express the meanings of phrases of all categories  , and that the l-calculus is too expressive to be of languages that holds promise of solving both these difficulties  , the function-level languages that have recently been developed in the area of progranm ~ ing languages \[ Backus  1978\] \[$ hultis 1982\]  . 
These languages represent functions of various types and thus can be used to represent the meanings of subsentential phrases in a way similar to the l-calculus  . Deduction in these languages is currently an active area of research and much is beginning to be known about their algebraic properties  . Term rewriting systems seem to be a powerful tool for reasoning in these languages  . 
I would not be surprised if these funct lon-level languages were to strongly influence the formal meaning representation languages of the future  . 
VREFERENCES
Backus , J .   \[1978\] Can Programming Beliberated from they on Neumann Style ? A Functional Style and Its Algebra of Programs  , Co~unicatlons of the ACM , Vol 21 , No 8 , ( Aug 1978) ,  613-641 . 
Clark , K . L and S . -A . T ~ rnlund(eds . )\[1982\] Logic Programming , Academic Press , New York , 366 pp . 
Clifford , J .   \[1981\] ILs : A formulation of Montague's intenslonal logic that includes variables and constants over indices  . TR#81-029 , Department of Computer Science , SUNY , Stony
Brook , New York.
Colmerauer , A . \[1978\] Metamorphosis Grammars , in Natural Language Conm ~ unication with Computers  , Voli , Sprlnger Verlag ,  1978 ,  133-189 . 
Colmerauer , A .   \[1982\] An Interesting Subset of Natural Language , in Logic Pro~rarming , Clark , 
K . L and 3.-AT ~ rnlund ( eds .), 45-66.
Dahl , Veronica \[1981\] Translating Spanish into Logic through Logic , American Journal of Computational Linguistics , Vol 7 , No 3 , ( Jul-
Sep 1981), 149-164.
Gallln , D .   \[1975\] Intensional and Higher-order Modal Logic , North-Holl and Pubilshing Company , 

Gawron , J . M . , et . al . \[1982\] The GPSG Linguistic System , Proceedings 20th Annual Meet in ~ of the Association for Computational Linguistics  ,  7481 . 
Huet , G . P .   \[1975\] A Unification Algorithm for Typedl-Calculus , Theoretical Computer Science , Voli , 
Noi , 22-57.
Jones , M . A . , and Warren , D . S .   \[1982\] Conceptual Dependency and Montague Grammar : A step toward conciliation  , Proceedings of the National Conference  #nn A ~tificial Intelli~ence  , AAAI-82 ,  79-83 . 
McCord , M .   \[1982\] Using Slots and Modifiers in Logic Grammars for Natural Language  , Artifical
Intelligence , Vol 18, 327-367.
Montague , Richard \[1973\] The proper treatment of quantification in ordinary English  , ( PTQ ) , reprinted in Montague\[1974\] ,  246-270 . 
Montague , Richard \[1974\] Formal Philosophy : Selected Paper of Richard Montague  , edited and with an introduction by R . Thomason , Yale
University Press , New Haven.
Pereira , F . C . N . and Warren , D . H . D .   \[1980\] Definite Clause Grammars for Language Analysis - A survey of the formalism and a Comparison with Augmented Transition Networks  . Artificial Intelligence 13, 3(May 1980) 231-278 . 
Rosenschein , S . J . and Shieber , S . M . \[1982\] Translating English into Logical Form , Proceedings of the 20th Annual Meeting of the Association for Comp- ~ational Linguistics  , 
June 1982, Toronto , 18.
Schubert L . K . and Pelletier F . J .   \[1982\] From English to Logic : Context-free Computation of ' Conventional ' Logical Translation  , American Journal of Computational Linguistics , Vol 8 , 
NO1, ( Jan-Mar 1982), 27-44.
Shultls , J . \[1982\] Hierarchical Semantics , Reasoning , and Translation , Ph . D . Thesis , Department of Computer Science , SUNY , Stony
Brook , New York.
Simmons , R . F . and Chester , D .   \[1982\] Relating Sentences and Semantic Networks with Procedural Logic  , Communications of the ACM , Vol 25 , Num 8 , ( August ,  1982) ,  527-546 . 
Warren , D . H . D .   \[1981\] Efficient processing of interactive relational database queries expressed in logic  , Proceedings of the 7th Conference on Very Large Data Bases , Cannes ,  ~72-281 , Warren , D . H . D .   \[1982\] Higher-order extensions to PROLOG : are they needed ? Machine Intelligence i ~ I layes  , Michie , Pao , eds . Ellis Horwood Ltd . 

Warren , D . S . and Friedman , J .   \[1981\] Using Semantics in Noncontext-free Parsing of Montague Grammar  , TR#81-027 , Department of Computer Science , SUNY , Stony Brook , New York , ( to appear) . 
Woods , W . A .   \[1970\] Transition Network Grammars for Natural Language Analysis  , Communications of the
ACM , Voli , NoI0, ( Oct 1970).
Woods , W . A . , Kaplan , R . M . , and Nash-Webber , B . 
\ [19721 The Lunar Science Natural Language Information System : Final Report  , BBN Report No . 2378, Bolt Baranek and Newman , Cambridge,
