LFG ~ ystsminProlog
Hide ~ Ya ~ u ' ~ awa
The Second Laboratory
Institute for New Generation Computer Technology ( ICOT ) 
To~/o , 108, Japan

In order to design and maintain alat E?scale grammar  , the formal system for representing syntactic knowled Ee should be provided  . Lexlcal Functional Grammar ( LFG )\ [ Kaplan , Bresnan 82\] is a powerful formalism for that purpose , In this paper , the Prolog implementation of LFG system is described  . Prolog provides a Eood tools for the implementation of LFG  . LFG can be translated into DCG\[Perelra , II arren 80\] and functional structures ( fstructures ) are generated durlnK the parsing process . 
IINTRODUCTIOr ~
The fundamental purposes of syntactic analysis are to check the Eramnatl callty and to clari DI the mapping between semantic structures and syntactic constituents  . DCG provides tools for fulfill ln 6 these purposes . But , due to the fact that the arbitrary 9rolog programs can be embedded into DCG rules , the grammar becomes too complicated to understand  , debug and maintain . 
So , the develo~ent of the formal system to represent syntactic knowled~es is needed  . The main concern is to define the appropriate set of the descriptive primitives used to represent the syntactic knowledges  . LFG seems to be promising formalism from current llngul stlc theories which satisfies these requirements  . LFG is adopted for our prelimlna~yversion of the formal system and the Prolog implementation of LFG is described in this paper  . 
ii SII : ~ . ZOVER VI~OFLFG in this section , the simple overview of LF ~ is described ( See\[Eaplan , Bresnan 82\] for details) . LFG is an e :: tention of contextfree grammar ( C ~' G ) and has two-levels of representation , i . e . 
c-structures ( constituent structures ) and f-~tructures ( functional structures )  . Ac-structure is generated by CFG and represents the surfaceuord and phrase configurations in a ~ entence  , and the f-structure is generated by the functional equations a = sociated with the o ~ rammar rules and represents the conflo ~ uratlon of the surface ~ ra = matical functions  . F i  ~ . I shows the c-structure and f-structure for the sentence " a e ~ f  . rlh and ed the baby a to y "(\ [ Kaplan , Bresnan 82\]) . 

Idet---n

If as
I .... V p
Iv . . . . . . np - . . . . . . np det---n det--n glrl hands the baby a toy ( a ) c-structure subJspeca humngpred " glrl " tense past pred " h and <  ( Tsub J ) (T obJ2 ) (T obJ ) > " obJ spec the numsgpred " baby " obJ2 specanum sgpred " to y " ( b ) f-structure Fig . 1 The eY ~ mglec-structure and f-structure
As shown in Fig . I , f-structure is a hierarchical structure constructed by the pairs of at ~ rl but e and its value  . An attribute represents ~ ra = matl cal function or syntactic feature  . 
Lexlcal entries specify a direct mapp in E betueen semantic arguments and confizuratlons of surface grammatl cal functions  , and ~ rammar rules specify a direct mapping between these surface Cr~umatl cal functions and particular constituent structure conflguratlons  . To represent these Cra = matl cal relations , several devices and schemata are provided in LFG as shown below  . 
( a ) metavariables ( 1 ) T &$ ( immediate dominance )   ( i l )  ~ & ~  ( bounded dominance )   ( b ) functional notations a designator ( Tsubj ) indicates the a Subja attribute of the f- structure  . 
( c ) Equational schemall )   ( functional equation ) ii )  ~  ( set inclusion ) the va ! ue of mother node'si ) = c ( equational constraint )   ( ii ) d ( existential constraint ) where disades Ic nator ( ill ) negation of ( 1 ) and ( i l ) F i  ~ .   2 sh ~ #s thee ~ anple ~ ra ~ uar rules and le " ~ ical entries in LF ~  , wl~ch senerate the c-structure and the f -structure in Fig  .  1 . 
1 . s->npvp(TsubJ)=+T=+2 . np -> det n1 = ~ T = ~3 . vp -> v np np
T = +( TobJ ) = ~ CTobJ2 ) = + ~ . det->\[a\](Tspec):a(Tnum):s~5 . det->\[the\](Tspec ) = the 6 . n ->\ [ girl\] ( Tnu ~ ) : sg ( ' ~ pred ) : ' glrl "7 . n->\[baby\](Tnun):sg(Tpred ) =' baby"8 . n->\[toy\](rnum ) = sg(Tpred ) =' to y " 9 . v ->\[ handed\] ( T tense ) = past ( Tpred ) = ' h and < ( ~ subJ ) (T obJ2 ) (T obJ ) > " FiE .   2 Example ~ rammar rules and lex ~ oal entries of LFG  . ( from\[Kaplan , Bresnan82\])
Assh ~ ninFi ~ . ~, the prlnltlve store ~ resent ~ r3 ~ . atlcal relations are encoded in ~ ra ~: arrules and le~cal entries  . Each syntaotle node h~si~sownf-structure and the partial value of the f-structure is defined by the Equational ~ ch ~ m  . For exauple , the functional equation " ( ~sub ~ ) =$" associated with the dau ~ hter " np " node of ~ r ~ - u ~ r rule I  . of Fi ~ .   2 specifies that the value of the " sub ~" attribute of the f-structure of th ~~ other " s " node is the f-structure o/its d~u ~ ter " np " node  . ~nevalue constraints on the f-~tructure are specified by the Constraln ~ r ~ schema  , i : or e over , the o~rauatl callty of the sentence is defined by the three conditions shown bel ~  . 
( I ) ~nlqueness : a particular attribute may have at : cost one value in a ~ iven f-structure  . 
(2 ) Completeness : af-structure must contain all the ~ overnable ~ r ~ uatical functions ~ overned by 
It ~ predicate.
(~ ) Coherence : all the ~ overr ~ ble ~ ran ~ uatlcal functions that af-structure contain must be ~ overned by its predicates  . 
ZZZZ ; ~ L~L:TATIO:~OFL , .'GP~--~rTZVE ~
As indicated in section iI , two distinct ~ chenata ~ reenploy cd in the constructions of f-~trucbures  . In the current lupleuent at lon ,   f-3tructures are ~ enerated durl n ~ " the ~ arslr ~ process by execut in ~ the functional equations and ~ et inclusions associated with each syntactic node  . After ~ e . , ~ urslr ~ is done , the fstructures ~ . ~ checked whether their value assic r~ents are consistent ~ it h the value conutralnts on them  . 
The Completeness condition on ~ r ~ at lc~l ! ~ y is also checked after the pars ln ~  . ~ eL~'~J primitives are realized by the Prolo ~ procra ~ s and embedded into the DCG rules  . The Equational schema is executed durl n ~ the parsln ~ process by the execution of DCG rules  . The functional equation can be seen as the extension of ~ eunification Of Prolog by introduclr ~ equality on fstructures  . 
A . Representations of Data Types
The prlnltlve data types construct i . ~fstructures are symbols , semantic predicates , subsidiary fstructures , and sets of sy = bols , semantic predicates , or fstructures . In current implementation , these data types are represented as follows :
I ) symbol s == > atem or Inte ~ r2 ) semantic predicates ==> sea ( X ) where X is a predicate 3 ) f-structure ==> Id : Obtwhere the " Id " is an identifier variable  ( ID-varlable )  . Each syntactic node has unique ID-variable which is used to Identify its f-structure  . The " Obt " is a ordered blrmry tree each leaf contains the pair of an attribute and its value  . 
q ) set ==> element l , element2, . . . , element ; ! Af-structure can be seen as a partially defined data structure  , because its value is partially Emnarated by the Equational schema during the paralng process  . An ordered binary tree , obt for short , is suitable for represent ln~partially defined data  . An obt is a binary tree whose labels are ordered . A binary tree " Obt " is represented by an term of the following for u  . 
Obt = obt(v(Attr , Value ), Less , Greater)
The " v(Attr , Value ) " is a leaf node of the tree . The " Attr " is an attribute name and used as the label of the leaf node  , and the " Value " is its value . The " Less " and " Greater " are also binary t rees  . The " Obt " is ordered when the " Less " ( "Greater " ) is also ordered and each label of its leaf nodes is less  ( greater ) than the label of " ObtW , i . e . " Attr " . If none of the leaf of a tree is defined , it is represented by a logical variable , l~en its label is defined later , the logical variable is In~antlated . The insertion of a label and its value into an obt is done by only one unl fl cat lon  , without rewrlt ln ~ the tree . 
This is themeritinus lnE an ordered blna~jtree.
For mY-mple , the f-structure for the noun phrase " aglrl " , the value of the " subJ " in Fi ~ . 1(b ), can be ~- a ~ leally represented in Fig .  3 . 
The " Vi "' s in Fig .   3 are the variables representing the unlnstant lated subtrees  . 
B . Functional ! ~ ot at lonv ( nun , aS) .   .   .   .   .   .   .   .   .   .  +
I ~--..... v(per 3, 3) ~ i ~.3 + ....+
Vl v2   v3 v ~ the ~ raphical represent alon of an obt The functional notations are represented by ! D -variables instead of l~ta variables ~ and $  , i . e . ~Mt a variables must be replaced by the object level variable  . For example , the designator ( 7 subj ) associated with the category 3 , is described as \[ subJ , IdS\] , where Ida is the ZD-variable for S . ~ emeta variables for bounded dominance are represented by the terms controllee  ( Cat ) and controller ( Cat )  , where the " Cat " is the name of the syntactic category of the controller or ccntrollee  . 
C . Predicates for LFG Primitives
The predicates for each LFG primitives are as follows:  ( d , dl , d2 are designators , s is a set , and " is a negation symbol )
I ) dl = d2->equate(dl , d2 , 01d , New ) 2) d&s -> include(d , s , Old , New ) 3) dl = cd2->eonstrain(dl , d2 , 01dC , NewC)4) d->exlst(d , OldC , ~lewC)5)"(dl = cd2)->ne&_constraln(dl , d2 , 01dC , ~ ewC ) 6) " d->not_exist(d , OldC , ~ewC)
The " Old " and " New , are global value assIcn nent a . ~% ey are used to propagate the chan~es of ~ iobal value assignments made by the execution of each predicate  . The " OldC " and " ~ ; ewC " are constraint lists and used to gather all the constraints in the analysis  . 
Desides these predicates , the additional predicates are provided for checking a constraints durl n ~ the parsing process  . They are used to k~ll the parsing process zeneratlng in consistent result as soon as the inconsistency is found  . 
~e predicate " equate " gets the temporary values of the desi~nators dl and  d2  , consulting the global value assignments . Then " equate " performs the unification of their values  . The unification is similar to set-theoretl cunion except that it is only defined for sets of nondistlnct attributes  . Fig .   4 shows the example trace output of the " equate " in the course of analyzing the sentence " agirl hands the baby a ~ oy "  . 
in order to keep grammar rules highly understandable  , it would be better to hide unnecessary data , such as c!obal value assic r~ents or constraint lists  . The macro notations similar to the original notation of LFG are provided to users for that purpose  . The macro expander translates the macronotations into Prolog programs corresponding to the LFG primitives  . 
The value of the designator Det is spec the
The value of the designator ~! is humsgper 3 predaeu ( glrl ) 
Result of unification is spec the humsgper 3 pred sem ( glrl ) 
Fig . 4 Tracing results of equate.
This macro expansion results in considerable improvement of the wrltability and the understandability of the grammar  . 
The syntax of macro notations are : ( a ) dl = d2->eqCdl , d2) ( b ) des->InclCd , s)
Co ) dl = cd2->o(dl , d2 )   ( d ) d -> ex ( d )   ( e )  " ( dl = cd2 ) -> not_c ( dl , d2 )   ( f ) " d->not ~ ex ( d ) The semacro notations for LFG primitives are placed at the third arsument of the each predicate in DCG rules correspond ln ~ to syntactic categories as shown in Fig  . 5(a ), which corresponds to the grammar rule I . in Fig .  2 . 
s(s(Np , V p ) , Id_$ , \[\]) --> np(Np , I ~_ Np , \[eq(\[subJ , Id . .S\],Id . .:Ip \]), vp(Vp , Id_Vp,\[eq(I~_S , Id . .Vp)\]) . 
( a ) The DCG rule with macro for LF ~ s(s(Np , V p ) , I ~_$ , Old , : ; ew , 01 dO , I ~ ew C ) --> np(Np , IdJ1 p , Old , Oldl , Old C , Old C1) , equate (\[ subj , Id_S\] , Id_~Ip , Oldl , 01 d2) , v p(V p , Id__V p , Old 2 , 01d3 , Old C1 , ~ ewC ) , equate ( Id_S , Id_Vp , Old 3 , New ) . 
( b ) The result of macro expansion
Fig .   5 Example DCG rule for LFG analysis The variables " ~ d_S "  ,   , Idj Ip , , and " Id_Vp " are the ID-variables for each syntactic category  . 
For example , the ~ rs = mar rule in Fi ~ . 5(a ) is translated into the one shown in Fig . 5(b ) . 
~crodescriptions are translated Into the corresponding predicate in the case of a ~ r ~ ar rule  . In the case of ale : cical entry , macro descriptions are translated into the corresponding predicate  , which is executed furthermore and the f -structure of the lexical entry is generated  . 
D . Issues on the Implementation
Thoughf structures are constructed durin ~ the parsing process  , the execution of the Equational schema is independent of the parsing rules highly declarative  . There are some advantages of using Prolog in implement in ~ LFG  . 
First , the Uniqueness condition on a f-structure is fulfilled by theori ~ in a lunification of Prolog  . Second , an ordered binary tree is a good data structure for representing a f-structure  . 
The use of an ordered binary tree reduces the process in ~ time by  30 percents compared with the case using all st for representing a f-structure  . 
And third , the use of ID-varlable also effective , because the sharing of af-structure can be done oaly by one unification of the corresponding ! D -variables  . 
Though the computational complexity of the ~ quational schema is very expensive  , the LF~provides expressive and natural account for lin ~ ulstic evidence  . In order to overcome the inefficiency , the introduction of parallel or concurrent execution mechanism seems to be a promising approach  . The computation model of LFG is similar to the constraint model of computation \[ Steele  80\]  . 
~ qeProlos implementation of LF ~ by Reyle and Fray\[Reyle  , Frey 83\] aimed at more direct translation of functional equations into DCG  . 
Although their implementation is more efficient , it does not treat the Constraining schema , set inclusions , the compound functional equation such as ( " vco:~psubj )  , and the bounded dominance . And their zr ~ arrules seem to be too complex by direct encoding of fstructures into them  . In order to provide an formal system havl r ~ powerful description capabilities for representing syntactic knowled ~ es  , the more LFG primitives are realized than their implementation and the ~ rammar rules are more understandable and can be more easily modified in my implementation  . 
Time used in analysis is 972 ms . ( parsing ) 19 ms . ( check in ~ constraints ) ~ Ims .   ( for checF in ~ completeness ) subJspec then unsgper 3 pred sem ( glrl ) pred sam ( persuade ( \[ subj , A \] , \[ obJ , A \] , \[vcomp , A \] )   ) obj spec the numsg per 3 pred sam ( baby ) tense past vcompsubj speetheh Umsg per 3 pred sam ( baby ) 
Inf?predsam(so(\[subJ,B\])) to ? Fig . 6 The result of analyzi . ~ the sentence , ? the glrl persuaded the baby to So "
VII . AC~I ~ ! LEDGE ~ NTS
The author is thankful to Dr . K . Furuka ~ a , the chief of the second research laboratory of ICOT Research Center  , and theme , bars of the natural language processing ~ roup in ICOT Research Center  , both for their discussion . The author is grateful to Dr . E . Fuchl , Director of the ICOT Research Center , for providing the opportunity to conduct this research  . 
!' ~. ~ i'-"RESULTOFA~'EXPER~NT
Fig .   6 shows the result of analyzing the sentence " the ~ irl persuaded the baby to go "  . LFG system is written in Dec-10 Prolog\[Pereira , et . al . 
73\] and executed on Dec2060.
As shorn in Fi ~ .  6 , the functional control\[::a plan , Eresnan 82\] is realized in the f-structure of vp . ~ evalue of the " subj " attribute of the " vcoup " is functionally controlled by the " obJ " of i  ; hef-structure of the " s " node . The time used for syntactic analysis includes the time consumed by parsinj process and the time consumed ~ j ~ quational schema  . 
V . CO : ICLUSTON
The Prolog implementation of LFG is described . It is the first step of the formal nysteu for represent ! nz syntactic kno ~  ; ledzes . As "- result , it be co . & esquite obvious that Prolos is suitable for i : iD ! e : ~ entln  . -LFG . 
Further research on the for :: alsyster ~ will be carried by analyzing the wider variety of actual utt-rznce ~ to e ': tract the more pri : ~ it lves ~- eces ~  . r . " for the analyses , and to ~ ive the ; : ccesaary sc :- e : ~ a ca for tho ~ epri_~itives . 
VIII . REFEREIICE$\[Kaplan , Bresnan 82\] " Lexical-Functlonal Gr ~ ar : A Formal System for Grammatical Representation " in ~ lental Representation of Grammatical Relations "  , 
Bresnanads . , I ET Press , 1982\[Reyle , Frey 83\] " A Prolog T_mplementation of Lexlcal Functional Grammar "  , Pros . of L/CAI-83,
PP . 693-695, 1983\[Perelra , at . al . 78\]" User's Guide to D~C System-I0 Prolog " , Department of Artificial Intelligence , Univ . of Edlnbur-:h , 1978\ [ Pereira , ' . ;arren 30\] "Definite Clause Gr-~--_r for Language Analysis - - A Survey of the For ~  . . . all smanda Comparison with Au~ented Transition -' . ' etworks ", Artificial Intelligence , 13, PP .  231-278 ,   I%80 \ [ Steele 80\] " The Definition and ! mpl-~uentation of a Computer Progr - ~  . unin ~ . Lanzuase base ~ on
Constraints ", . ~ ETAI-TR-595, 19~0
