Efficient Normal-Form Parsing
for Combinatory Categorial Grammar *
Jason Eisner
Dept . of Computer and Information Science
University of Pennsylvania
200S . 33 rdSt . , Philadelphia , PA 19104-6389 , USA jeisner@linc , c is . upenn , edu
Abstract
Under categorial grammars that have powerful rules like composition  , a simplen word sentence can have exponentially many parses  . Generating all parses is inefficient and obscures whatever true semantic ambiguities are in the input  . This paper addresses the problem for a fairly general form of Combinatory Categorial Grammar  , by means of an efficient , correct , and easy to implement normal-form parsing technique  . The parser is proved to find exactly one parse in each semantic equivalence class of allowable parses  ; that is , spurious ambiguity ( as carefully defined ) is shown to be both safely and completely eliminated  . 
1 Introduction
Combinatory Categorial Grammar ( Steedman ,  1990) , like other " flexible " categorial grammars , suffers from spurious ambiguity ( Wittenburg ,  1986) . 
The nonstandard constituent shat are so crucial to CCG's analyses in  ( 1 )  , and in its account of intonational focus ( Prevost ~ Steedman ,  1994) , remain available ven in simpler sentences . This renders (2) syntactically ambiguous . 
(1) a . Coordination :\[\[ John likes\]s/NP , and\[Mary pretends to like \] s/NP\] , the biggaloot in the corner . 
b . Extraction : Everybody at this party\[whom\[ John likes \] s/NP\] is a bigg a loot  . 
(2) a . John\[likes Mary \] s\NP.
b.\[. John likes\]s/NP Mary.
The practical problem of " extra " parses in ( 2 ) becomes exponentially worse for longer strings , which can have up to a Catalan number of parses . An * This material is based upon work supported under a National Science Foundation Graduate Fellowship  . I have been grateful for the advice of Aravind Joshi  , Nobo Komagata , Seth Kulick , Michael Niv , Mark Steedman , and three anonymous reviewers . 
exhaustive parser serves up 252 CCG parses of (3) , which must be sifted through , at considerable cost , in order to identify the two distinct meanings for further processing  . 1 (3) the galoot in the corner
NP\]NN ( N\N ) /NP NP\]NN that I said Mary ( N\N ) \] ( S/NP ) S/ ( S\NP )   ( S\NP ) \]$ S\] ( S\NP ) pretends to ( S\NP ) \] ( S in f\NP )   ( S in f\NP ) / ( Sstem\NP ) like ( Sstem\NP ) /NP This paper presents a simple and flexible CCG parsing technique that prevents any such explosion of redundant CCG derivations  . In particular , it is proved in ?4 . 2 that the method constructs exactly one syntactic structure per semantic reading -- e  . g . , just two parses for (3) . All other parses are suppressed by simple normal -form constraints that are enforced throughout the parsing process  . This approach works because CCG's spurious ambiguities arise  ( as is shown ) in only a small set of circumstances . Although similar work has been attempted in the past  , with varying degrees of success ( Karttunen , 1986; Wittenburg , 1986; Pareschi & Steedman , 1987; Bouma , 1989; Hepple & Morrill , 1989; KSnig , 1989; Vijay-Shanker & Weir , 1990; Hepple , 1990; Moortgat , 1990; ttendriks , 1993; Niv ,  1994) , this appears to be the first full normal-form result for a categorial formalism having more than contextfree power  . 
2 Definitions and Related Work
CCG may be regarded as a generalization f contextfree grammar  ( CFG ) -- one where a grammar has infinitely many nonterminals and phrase-structure rules  . In addition to the familiar atomic nonterminal categories  ( typically S for sentences , N for 1Namely , Mary pretends to like the galoot in 168 parses and the corner in 84  . One might try a statistical approach to ambiguity resolution  , discarding the low-probability parses , but it is unclear how to model and train any probabilities when no single parse can be taken as the standard of correctness  . 
79 nouns , NP for noun phrases , etc . ), CCG allows in finitely many slashed categories . If z and y are categories , then x/y ( respectively z\y ) is the category of an incomplete x that is missing a y a t its right  ( respectively left )  . Thus verb phrases are analyzed as subjectless entences S\NP  , while " John likes " is an objectles sentence or S/NP  . A complex category like ( ( S\NP )  \  ( S\NP ) )/N may be written as S\NP\ ( S\NP ) /N , under a convention that slashes are left -associative  . 
The results here in apply to the TAG-equivalent CCG formalization given in  ( Joshiet M . , 1991) . 2 In this variety of CCG , every ( nonlexical ) phrase-structure rule is an instance of one of the following binary-rule templates  ( where n > 0 ) :  ( 4 ) Forward generalized composition > Bn : ; ~/ yy\[nzn''"\[2Z211Zl-'+ ; ~\[ nZn ''"\] 2Z2 11Zl
Backward generalized composition < Bn : yl . z .   .   . -12 z2I lzlx\yxI . z .   .   .   .   12z llzlInstances with n-- 0 are called application rules , and instances with n > 1 are called composition rules . In a given rule , x , y , zl .   .   . z ~ would be instantiated as categories like NP , S/I ~ P , or S\NP\(S\NP)/N . Each of \]1 through In would be instantiated as either/or \ . 
A fixed CCG grammar need not include every phrase -structure rule matching these templates  . Indeed , ( Joshi et al ,  1991 ) place certain restrictions on the rule set of a CCG grammar  , including a requirement that the rule degree n is bounded over the set  . The results of the present paper apply to such restricted grammars and also more generally  , to any CCG-style grammar with a decidable rule set  . 
Even as restricted by ( Joshi et al ,  1991) , CCGs have the " mildly context-sensitive " expressive power of Tree Adjoining Grammars  ( TAGs )  . Most work on spurious ambiguity has focused on categorial formalisms with substantially less power  . ( Hepple , 1990) and ( Hendriks ,  1993) , the most rigorous pieces of work , each establish a normal form for the syntactic calculus of  ( Lambek ,  1958) , which is weakly contextfree . ( Kbnig , 1989; Moortgat , 1990) have also studied the Lambek calculus case . ( Hepple & Morrill ,  1989) , who introduced the idea of normal-form parsing , consider only a small CCG fragment that lacks backward or order-changing composition  ; ( Niv ,  1994 ) extends this result but does not show completeness  . (Wittenburg ,  1987 ) assumes a CCG fragment lacking order-changing or higher-order composition  ; furthermore , his revision of the combinators creates new , conjoinable constituents that conventional CCG rejects  . ( Bouma ,  1989 ) proposes to replace composition with a new combinator  , but the resulting product-grammar scheme as-2This formalization sweeps any typeraising into the lexicon  , as has been proposed on linguistic grounds ( Dowty , 1988; Steedman ,  1991 , and others ) . It also treats conjunction lexically , by giving " and " the generalized category x\x /x and barring it from composition  . 
8 0 signs differentypes to " John likes " and " Mary pre-tends to like  , " thus losing the ability to conjoin such constituents or subcategorize for them as a class  . 
( Pareschi & Steedman , 1987) do tackle the CCG case , but ( Hepple , 1987) shows their algorithm to be incomplete . 
3 Overv iew o f the Pars ing S t ra tegy As is wellknown  , general CFG parsing methods can be applied directly to CCG  . Any sort of chart parser or nondeterministic shift-reduce parser will do  . Such a parser repeatedly decides whether two adjacent constituents  , uch as S/NP and I~P/N , should be combined into a larger constituent such as S/N  . 
The role of the grammar is to state which combinations are allowed  . The key to efficiency , we will see , is for the parser to be less permissive than the grammar -- for it to say " no  , redundant " in some cases where the grammar says " yes  , grammatical . "  ( 5 ) shows the constituents that untrammeled CCG will find in the course of parsing " John likes Mary  . " The spurious ambiguity problem is not that the grammar allows  ( 5c )  , but that the grammar allows both ( 5f ) and ( 5g ) --distinct parses of the same string , with the same meaning . 
(5) a .\[ John \] s/(s\sp)b.\[likes\](S\NP)/Np
C . \[ John likes \] s/NP d . \[ Mary \] NP e . \[ likes Mary \] s\NP f . \[\[ John likes\]Mary\]s ~ to be disallow edg , \[ John\[likes Mary \] Is The proposal is to construct all constituents shown in  ( 5 ) except for ( 5f )  . If we slightly constrain the use of the grammar ules  , the parser will still produce ( 5c ) and ( 5d ) -- constituents hat are indispensable in contexts like  ( 1 ) --while refusing to combine those constituents into  ( 5f )  . The relevant rule S/I ~ PNP--*S will actually be blocked when it attempts to construct  ( 5f )  . Although rule-blocking may eliminate an analysis of the sentence  , as it does here , a semantically equivalent analysi such as ( 5g ) will always be derivable along some other route . 
In general , our goal is to discover exactly one analysis for each < substring  , meaning > pair . By practicing " birth control " for each bottom -up generation of constituents in this way  , we avoid a population explosion of parsing options  . " John likes Mary " has only one reading semantically  , so just one of its analyses ( 5f ) - ( 5g ) is discovered while parsing ( 6 )  . Only that analysis , and not the other , is allowed to continue on and be built into the final parse of  ( 6 )  . 
(6 ) that galoot in the corner that thinks\[John likes Mary \] s For a chart parser  , where each chart cell stores the analyses of some substring  , this strategy says that all analyses in a cell are to be semantically distinct  . 
( Karttunen ,  1986 ) suggests enforcing that property directly--by comparing each new analysis semantically with existing analyses in the cell  , and refus-ing to add it if redundant--but ( Hepple & Morrill ,  1989 ) observe briefly that this is inefficient for large charts  .   3 The following sections how how to obtain effectively the same result without doing any semantic interpretation or comparison at all  . 
4A Normal Form for " Pure " CCG
It is convenient to begin with a special case . Suppose the CCG grammar includes not some but all instances of the binary rule templates in  ( 4 )  . ( As always , a separate lexicon specifies the possible categories of each word  . ) If we group a sentence's parses into semantic equivalence classes  , it always turns out that exactly one parse in each class satisfies the following simple declarative constraints :  ( 7 ) a . No constituent produced by > Bn , any n~1 , ever serves as the primary ( left ) argument to > Bn' , any n ' > 0 . 
b . No constituent produced by < Bn , any n > 1 , ever serves as the primary ( right ) argument to < Bn' , any n ' > 0 . 
The notation here is from (4) . More colloquially ,   ( 7 ) says that the output of rightward ( leftward ) composition may not compose or apply over anything to its right  ( left )  . A parse tree or subtree that satisfies ( 7 ) is said to be in normal form ( NF )  . 
As an example , consider the effect of these restrictions on the simple sentence " John likes Mary  . " Ignoring the tags-OT , -FC , and - Be for the moment , (8a ) is a normal-form parse . Its competitor (85) is not , nor is any larger tree containing (8b ) . But non-3How inefficient ? ( i ) has exponentially many semantically distinct parses : n =  10 yields 82  , 756 , 612 parses (2?) - - 48 , 620 equivalence classes . Kart tunen's in 10 method must therefore add 48 , 6 20 representative parses to the appropriate chart cell  , first comparing each one against all the previously added parses -- of which there are  48  , 6 20/2 on average--to ensure it is not semantically redundant  .   ( Additional comparisons are needed to reject parses other than the lucky  48  , 620 . ) Adding a parse can therefore take exponential time  . 
n(i ) ... S/S S/S S/S S S\S S\S S\S ...
Structure sharing does not appear to help : parses that are grouped in a parse forest have only their syntactic category in common  , not their meaning . Kart tunen's approach must tease such parses apart and compare their various meanings individually against each new candidate  . By contrast , the method proposed below is purely syntactic- - just like any " ordinary " parser--soit never needs to unpack a subforest  , and can run in polynomial time . 
standard constituents are allowed when necessary :   ( 8c ) is in normal form ( cf .  (1)) . 
(8) a . S-OT
S/(S ~ ~ IP-OT
John ( S\NP)/NP-OT~P-OT
II likes Mary b .   . forward application blocked by ( Ta ) ( eq , , i . alently , no fi ~ X . .~itted b ~ (10a ))
S/NP-FCI ~ P-OT\[

S/(S"\NP)-OT(S\NP)/IIP-OT
II
John likes ( N\N)/(S/NP)-OTS/NP-FC
Is ~ p whom
S/()/NP-OT
Il
Johnlikes
It is not hard to see that ( 7a ) eliminates all but right-branching parses of " forward chains " like A/B B/CC or A/B/CC/DD/E /F/GG/H  , and that ( Tb ) eliminates all but left-branching parses of " backward chains  . " ( Thus every functor will get its arguments , if possible , before it becomes an argument itself . ) But it is hardly obvious that ( 7 ) eliminates all of CCG's spurious ambiguity . One might worry about unexpected interactions involving crossing composition rules like A/B B\C -- ~ A\C  . Significantly , it turns out that (7) really does suffice ; the proof is in ?4 . 2 . 
It is trivial to modify any sort of CCG parser to find only the normal-form parses  . No semantics is necessary ; simply block any rule use that would violate (7) . In general , detecting violations will not hurt performance by more than a constant factor  . Indeed , one might implement ( 7 ) by modifying CCG's phrase-structure grammar . Each ordinary CCG category is split into three categories that bear the respective tags from  ( 9 )  . The 24 templates schematized in ( 10 ) replace the two templates of ( 4 )  . 
Any CFG-style method can still parse the resulting spuriosity-free grammar  , with tagged parses as in (8) . In particular , the polynomial-time , polynomial-space CCG chart parser of ( Vijay-Shanker & Weir ,  1993 ) can be trivially adapted to respect the constraints by tagging chart entries  . 
(9)-FC output of > Bn , some n > 1 ( a forward composition rule ) -BC output of < Bn , some n > 1 ( a backward composition rule ) -OT output of > B0 or < B0 ( an application rule )  , or lexical item (10) a . Forward application > BO : ~ x/y-OTy-Bet-'+x- -OTy-OT  ) b . Backward application < B0: y-Be~x\y-OTj " ~ x-OT 9-O'1"   ) yl , , z , , l~z ~ llz1-BC --- , xl , z , ~ . .- \]2z2 llz1-FC c . Fwd . composition > Bn(n > 1): x/y-OTY In z , ~12 z2IlZl-OTd . Bwd . composition < Bn(n >_1): YI , ~ z~12 z2Ilzl-BC--- , xInz , ''" I ~ . z2Ilzl--BC yI,z,I ~ . z2IlZl-OTx\y-OT(ii ) a . Syn/semfor > Bn(n_>0):=/yy?I . z .   .   .   . 
fg ~ Cl  ~ C2 . . . ~Cn . f(g(Cl ) ( C2) '"( Cn )) b . Syn/semfor < B,(,>0): yI . z . ---12 z2--*xI . z .   .   .   . 12 z2\[lZXgf)~Cl~C2 . . . ACn . f(g(Cl ) ( C2)''"( Cn )) (12) a . A/C/F
AIC lDD/F
AIBBICIDDIEE lFb . AIC lF
A/C/EE/F
A/C/DD/E
A/B B/C/D



A/B B/C/D fghk
It is interesting to note a rough resemblance between the tagged version of CCG in  ( 10 ) and the tagged Lambek cM culus L * , which ( Hendriks ,  1993 ) developed to eliminate spurious ambiguity from the Lambek calculus L  . Although differences between CCG and L mean that the details are quite different  , each system works by marking the output of certain rules  , to prevent such output from serving as input to certain other rules  . 
4.1 Semantic equivalence
We wish to establish that each semantic equivalence class contains exactly one NF parse  . But what does " semantically equivalent " mean ? Let us adopt a standard model theoretic view  . 
For each leaf ( i . e . , lexeme ) of a given syntax tree , the lexicon specifies a lexical interpretation from the model  . CCG then provides a derived interpretation in the model for the complete tree  . The standard CCG theory builds the semantics compositionally  , guided by the syntax , according to (11) . We may therefore regard a syntax tree as a static " recipe " for combining word meanings into a phrase meaning  . 

One might choose to say that two parses are semantically equivalent iff they derive the same phrase meaning  . However , such a definition would make spurious ambiguity sensitive to the finegrained semantics of the lexicon  . Are the two analyses of VP/VP VP VP\VP semantically equivalent ? If the lexemes involved are " softly knock twice  , " then yes , as softly ( twice ( knock ) ) and twice ( softly ( knock ) ) arguably denote a common function in the semantic model  . Yet for " intentionally knock twice " this is not the case : these adverbs do not commute  , and the semantics are distinct . 
It would be difficult to make such subtle distinctions rapidly  . Let us instead use a narrower , " intensional " definition of spurious ambiguity . The trees in ( 12 a-b ) will be considered equivalent because they specify the same " recipe  , " shown in (12c ) . No matter what lexical interpretations f , g , h , k are fed into the leaves A/B , B/C/D , D/E , E/F , both the trees end up with the same derived interpretation  , a mely a model element that can be determined from f  , g , h , k by calculating Ax~y . f(g(h(k(x)))(y)) . 
By contrast , the two readings of " softly knock twice " are considered to be distinct  , since the parses specify different recipes . That is , given a suitably free choice of meanings for the words  , the two parses can be made to pick out two different VP-type functions in the model  . The parser is therefore conservative and keeps both parses  .  4 4 . 2 Normal - fo rm pars ing is safe & complete The motivation for producing only NF parses  ( as defined by ( 7 ) ) lies in the following existence and uniqueness theorems for CCG  . 
Theorem 1 Assuming " pure CCG , " where all possible rules are in the grammar , any parse tree ~ is semantically equivalent to some NF parse tree NF  ( ~ )  . 
(This says the NF parser is safe for pure CCG : we will not lose any readings by generating just normal forms  . ) Theorem 2 Given distinct NF trees a # o / ( on the same sequence of leaves )  . Then a and at are not semantically equivalent . 
(This says that the NF parser is complete : generating only normal forms eliminates all spurious ambiguity  . ) Detailed proofs of these theorems are available on the cmp-lgarchive  , but can only be sketched here . 
Theorem 1 is proved by a constructive induction on the order of a  , given below and illustrated in ( 13 ) : ? For c ~ a leaf , put NF ( c ~) = a . 
?(< R ,  ~ ,   3'> denotes the parse tree formed by combining subtrees / ~  , 7 via rule R . )
If ~= < R , fl ,  7> , then take NF(c ~) = < R , gF ( f l ) , NF (7) > , which exists by inductive hypothesis , unless this is not an NF tree . In the latter case , WLOG , R is a forward rule and NF ( fl ) = < Q , ~l , flA > for some forward composition rule Q . Pure CCG turns out to provide forward rules S and T such that a ~= < S  , ill , NF (< T ,  ~2 ,  7> ) > is a constituent and is semantically equivalent to c ~  . Moreover , since fll serves as the primary subtree of the NF tree NF  ( fl )  , /31 cannot be the output of forward composition , and is NF besides . Therefore a ~ is NF : take NF ( o0 = o / . 
(13) If NF (/3) not output offwd . composition,
RR - -*--* def = A = NF ( ) 7iF(Z)NF (7)
RR_ . .+ - -# else ~ : ~ : :~ 7 NF~"7 t ( Hepple 8z Morrill , 1989; Hepple , 1990; Hendriks ,  1993 ) appear to share this view of semantic equivalence . 
Unlike ( Karttunen ,  1986) , they try to eliminate only parses whose denotations  ( or at least A-terms ) are systematically equivalent , not parses that happen to have the same denotation through an accident of the lexicon  . 

RS::~~def=Q-~7~1~1~'/72NF (  /72~7 ) = NF ( ~ ) This construction resembles a wellknown normal -form reduction procedure that  ( Hepple & Morrill ,  1989 ) propose ( without proving completeness ) for a small fragment of CCG . 
The proof of theorem 2 ( completeness ) is longer and more subtle . First it shows , by a simple induction , that since c ~ and ~' disagree they must disagree in at least one of these ways :  ( a ) There are trees / ? , 3' and rules R#R ' such that < R , fl , 7> is a subtree of a and < R ' , /3 , 7> is a subtree of a ' . ( For example , S/S S\S may form a constituent by either < Blx or > Blx  . )  ( b ) There is a tree 7 that appears as a subtree of both c ~ and cd , but combines to the left in one case and to the right in the other  . 
Either condition , the proof shows , leads to different " immediate scope " relations in the full trees ~ and ~'  ( in the sense in which f takes immediate scope over  9 inf ( g ( x ) ) but not in f ( h ( g ( x ) ) ) org ( f ( z ) ) )   . Condition ( a ) is straightforward . Condition ( b ) splits into a case where 7 serves as a secondary argument inside both cr and a '  , and a case where it is a primary argument in c ~ or a '  . The latter case requires consideration of 7's ancestors ; the NF properties crucially rule out counterexamples here  . 
The notion of scope is relevant because semantic interpretations for CCG constituents can be written as restricted lambda terms  , in such a way that constituents having distinct terms must have different interpretations in the model  ( for suitable interpretations of the words , as in ?4 . 1) . Theorem 2 is proved by showing that the terms for a and a ' differ somewhere  , so correspond to different semantic recipes . 
Similar theorems for the Lambek calculus were previously shown by  ( Hepple , 1990; ttendriks ,  1993) . 
The present proofs for CCG establish a result that has long been suspected : the spurious ambiguity problem is not actually very widespread in CCG  . 
Theorem 2 says all cases of spurious ambiguity can be eliminated through the construction given in theorem  1  . But that construction merely ensures a right -branching structure for " forward constituent chains "  ( suchash/BB/CC or h/B/CC/DD/E/F/GG/H )  , and a left-branching structure for backward constituent chains  . So these familiar chains are the only source of spurious ambiguity in 

5 Extend ing the Approach to " Rest r i c ted " CCG The " pure " CCG of  ?4 is a fiction . Real CCG grammars can and do choose a subset of the possible rules  . 
For instance , to rule out (14) , the ( crossing ) backward rule N/N ~ I\N---*I~N must be omitted from 
English grammar.
(14 ) \[ the NP/N\[\[big N/N\[that likes John \] N\N\] N/Ngaloot N\]N\]NP If some rules are removed from a " pure " CCG grammar  , some parses will become unavailable . 
Theorem 2 remains true (< 1NF per reading).
Whether theorem 1 ( >_1 NF per reading ) remains true depends on what set of rules is removed  . For most linguistically reasonable choices , the proof of theorem 1 will go through ,   5 so that the normal-form parser of ?4 remains safe . But imagine removing only the rule B/aC--~B : this leaves the string A/B B/CC with a left -branching parse that has no  ( legal ) 
NF equivalent.
In the sort of restricted grammar where theorem 1 does not obtain , can we still find one ( possibly non-NF ) parse per equivalence class ? Yes : a different kind of efficient parser can be built for this case  . 
Since the new parser must be able to generate a non-NF parse when no equivalent NF parse is available  , its method of controlling spurious ambiguity cannot be to enforce the constraints  ( 7 )  . The old parse refused to build non-NF constituents  ; the new parser will refuse to build constituents that are semantically equivalent to already-built constituents  . 
This idea originates with ( Karttunen , 1986).
However , we can take advantage of the core result of this paper  , theorems 1 and 2 , to do Karttunen's redundancy check in O ( 1 ) time--no worse than the normal-form parser's check for-FC and - Be tags  . 
(Karttunen's version takes worst-case exponential time for each redundancy check : see footnote  ?3  . ) The insight is that theorems 1 and 2 establish a one-to-one map between semantic equivalence classes and normal forms of the pure  ( unrestricted ) 
CCG : (15) Two parses a , ~' of the pure CCG are semantically equivalent iff they have the same normal form : gF  ( a ) = gF ( a' )  . 
The NF function is defined recursively by ?4 . 2' sproof of theorem 1 ; semantic equivalence is also defined independently of the grammar  . So (15) is meaningful and true even if a , a ' are produced by a restricted CCG . The tree NF ( a ) may not be a legal parse under the restricted grammar  . However , it is still a perfectly good data structure that can be maintained outside the parse chart  , to serve 5For the proof to work , the rules S and T must be available in the restricted grammar  , given that R and Q are . This is usually true : since ( 7 ) favors standard constituents and prefers application to composition  , most grammars will not block the NF derivation while allowing a non-NF one  . ( On the other hand , the NF parse of A/B B/C C/D/E uses > B2 twice , while the non-NF parse gets by with > B2 and > B1 . ) as a magnet for a ' s semantic class . The proof of theorem 1 ( see ( 13 ) ) actually shows how to construct NF ( a ) in O ( 1 ) time from the values of NF on smaller constituents  . Hence , an appropriate parser can compute and cache the NF of each parse in O  ( 1 ) time as it is added to the chart . It can detect redundant parses by noting ( via an O ( 1 ) array lookup ) that their NFs have been previously computed . 
Figure ( 1 ) gives an efficient CKY-style algorithm based on this insight  . ( Parsing strategies besides CKY would Mso work , in particular ( Vijay-Shanker & Weir ,  1993) . ) The management of cached NFs in steps 9 ,  12 , and especially 16 ensures that duplicate NFs never enter the old NFs array : thus any alternative copy of a  . nf has the same array coordinates used for a . nf itself , because it was built from identical subtrees . 
The function Pre:ferable To(~ , r )   ( step 15 ) provides flexibility about which parse represents its class  . Preferable To may be defined at whim to choose the parse discovered first  , the more left-branching parse , or the parse with fewer nonstandard constituents . Alternatively , Preferable To may call an intonation or discourse module to pick the parse that better reflects the topic-focus division of the sentence  .   ( A variant algorithm ignores Preferable To and constructs one parse forest per reading  . Each forest can later be unpacked into individual equivalent parse trees  , if desired . ) ( Vijay-Shanker & Weir ,  1990 ) also give a method for removing " one wellknown source " of spurious ambiguity from restricted CCGs  ;  ?4 . 2 above shows that this is in fact the only source  . However , their method relies on the grammaticality of certain intermediate forms  , and so can fail if the CCG rules can be arbitrarily restricted  . In addition , their method is less efficient than the present one : it considers parses in pairs  , not singly , and does not remove any parse until the entire parse forest has been built  . 
6 Extensions to the CCG Formalism
In addition to the Bn ( " generalized composition " ) rules given in ?2 , which give CCG power equivalent to TAG , rules based on the S ( " substitution " ) and T ( " typeraising " ) combinators can be linguistically useful . S provides another rule template , used in the analysis of parasitic gaps ( Steedman , 1987; Szabolcsi , 1989): (16) a . > s:x/yllzyllz?Ilz/gb . < S : yllzx\yIlz --* xIlz Although S interacts with Bn to produce another source of spurious ambiguity  , illustrated in (17) , the additional ambiguity is not hard to remove . It can be shown that when the restriction ( 18 ) is used together with ( 7 )  , the system again finds exactly one 2 . C\[i-1 , i \] := LexCats ( word\[i \] )   ( * wordist retches from point i-1 to point i * )  3 . for width := 2 to n 4 . for start := 0 to n-width 5 . end := start + width 6 . for mid := start+1 to end-17 . for each parse tree ~ = < R , /9 ,   7> that could be formed by combining some /9   6 C\[start , mia q with some 7 eC\[mid , ena ~ by a rule / ~ of the ( restricted ) grammar 8 . a . nf := NF ( a )   ( * can be computed in constantime using the . nf fields of f l ,  7 , and other constituents already in C . Subtrees are also NF trees .  *) 9 . ezisting NF := old NFs\[~ . nf . rule , c  ~ . nf . left child . seqno , a . nf . right child . seq no \] 10 . if undefined ( existing NF )   ( * the first parse with this NF * )  11 .  ~ . nf . seqno := ( counter := counter+1 )   ( * number the new NF ~ add it toold NFs * )  12 . old NFs\[c ~ . n f rule , c ~ . nf . lefl child . seqno , a . nf . right child . seq no \] := a . nf 13 . add ~ to C\[start , ena ~14 . a . nf . curr parse := c ~15 . els if P referable To(a , ezisting NF . currparse ) (* replace reigning parse ?*) 16 . a . nf := existing NF (* use cached copy of NF , not new one *) 17 . remove a . nf . curr parse from C\[start , en~18 . add ~ to C\[start , enaq19 .  ~ . nfocurr parse := 20 . return ( all parses from C\[0 , n \] having root category S ) Figure 1: Canonicalizing CCG parser that handles arbitrary restrictions on the ruleset  . ( In practice , a simpler normal-form parser will suffice for most grammars  . ) parse from every equivalence class . 
(17) a . VPo/NP (< Bx)
VPI/NP (< Sx)
VP2~P2/NP yesterday filed\[without-reading\]b . VPo/NP (< Sx)
VP2/NP VP0\VP2/NP(<B2)
VP I\V ~ VPI (18) a . No constituent produced by > Bn , any n_>2 , ever serves as the primary ( left ) argument to > S . 
b . No constituent produced by < Bn , any n > 2 , ever serves as the primary ( right ) argument to < S . 
Typeraising presents a greater problem . Various new spurious ambiguities arise if it is permitted freely in the grammar  . In principle one could proceed without grammatical typeraising :  ( Dowty , 1988; Steedman ,  1991 ) have argued on linguistic grounds that typeraising should be treated as a mere lexical redundancy property  . That is , whenever the lexicon contains an entry of a certain cate-  ( say ) category T/ ( T\X ) and interpretation Ap . p(z) . 
As one might expect , this move only sweeps the problem under the rug . If typeraising is lexical , then the definitions of this paper do not recognize  ( 19 ) as a spurious ambiguity , because the two parses are now , technically speaking , analyses of different sentences . Nor do they recognize the redundancy in (20) , because--just as for the example " softly knock twice " in  ?4  . 1--it is contingent on a kind of lexical coincidence  , namely that a type-raised subject com-mutes with a  ( generically ) type-raised object . Such ambiguities are left to future work . 
(19)\[ John N plefts\NP\]S vs . \[ Johns / ( S\NP ) lefts\NP\]S ( 20 ) \[ S/ ( S\NPs ) \[S\NPs/NPo/NPIT\ ( T/NPo ) \]\] S/SIVS . \[ S/ ( S\NPs ) S\NPs/NPo/NPI\]T\ ( T/NPO ) \] S/SI 7 Conclusions The main contribution of this work has been formal : to establish a normal form for parses of " pure " Combinatory Categorial Grammar  . Given a sentence , every reading that is available to the grammar has exactly one normal-form parse  , no matter how many parses it has into to . 
A result worthrem embering is that , although TAG-equivalent CCG allows free interaction among forward  , backward , and crossed composition rules of any degree , two simple constraints serve to eliminate all spurious ambiguity  . It turns out that all spurious ambiguity arises from associative " chains " such as A/BB/CC or A/B/CC/DD/E\F/GG/H  . (Wittenburg , 1987; Hepple & Morrill , 1989) anticipate this result , at least for some fragments of CCG , but leave the proof to future work . 
These normal-form results for pure CCG lead directly to useful parsers for real  , restricted CCG grammars . Two parsing algorithms have been presented for practical use  . One algorithm finds only normal forms ; this simply and safely eliminates spurious ambiguity undermost real CCG grammars  . 
The other , more complex algorithm solves the spurious ambiguity problem for any CCG grammar  , by using normal forms as an efficientool for grouping semantically equivalent parses  . Both algorithms are safe , complete , and efficient . 
In closing , it should be repeated that the results provided are for the TAG-equivalent Bn  ( generalized composition ) formalism of ( Joshi et al ,  1991) , optionally extended with the S ( substitution ) rules of ( Szabolcsi ,  1989) . The technique liminates all spurious ambiguities resulting from the interaction of these rules  . Future work should continue by eliminating the spurious ambiguities that arise from grammatical or lexical typeraising  . 
References
Gosse Bouma .  1989 . Efficient processing of flexible categorial grammar  . In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics  ,  1926 , University of Manchester , April . 
David Dowty .  1988 . Typeraising , functional composition , and nonconstituent conjunction . In R . 
Oehrle , E . Bach and D . Wheeler , editors , Categorial Grammars and Natural Language Structures  . 

Mark Hepple .  1987 . Methods for parsing combinatory categorial grammar and the spurious ambiguity problem  . Unpublished M . Sc . thesis , Centre for Cognitive Science , University of Edinburgh . 
Mark Hepple .  1990 . The Grammar and Processing of Order and Dependency : A Categorial Approach  . Ph . D . thesis , University of Edinburgh . 
Mark Hepple and Glyn Morrill .  1989 . Parsing and derivational equivalence . In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics  ,  1018 , 
University of Manchester , April.
Herman Hendriks .  1993 . Studied Flexibility : Categories and Types in Syntax and Semantics  . Ph . D . 
thesis , Institute for Logic , Language , and Computation , University of Amsterdam . 
Aravind Joshi , K . Vijay-Shanker , and David Weir . 
1991 . The convergence of mildly context-sensitive grammar formalisms  . In Foundational Issues in Natural Language Processing  , MIT Press . 
Lauri Karttunen .  1986 . Radica lexicalism . Report No . CSLI-86-68, CSLI , Stanford University . 
E . KS nig .  1989 . Parsing as natural deduction . In Proceedings of the 27lh Annual Meeting of the Association for Computational Linguistics  , Vancouver . 
J . Lambek .  1958 . The mathematics of sentence structure . American Mathematical Monthly 65: 154-169 . 
Michael Moortgat .  1990 . Unambiguous proof representations for the Lambek Calculus  . In Proceedings of the Seventh Amsterdam Colloquium  . 
Michael Niv .  1994 . A psycholinguistically motivated parser for CCG . In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics  , Las Cruces , NM , June . 
Remo Paresehi and Mark Steedman . Alazy way to chart parse with eombinatory grammars  . In Proceedings of the P5th Annual Meeting of the Association for Computational Linguistics  , Stanford
University , July.
Scott Prevost and Mark Steedman .  1994 . Specifying intonation from context for speech synthesis  . 
Speech Communication , 15:139-153.
Mark Steedman .  1990 . Gapping as constituent coordination . Linguistics and Philosophy , 13: 207-264 . 
Mark Steedman . 1991. Structure and intonation.
Language , 67:260-296.
Mark Steedman .  1987 . Combinatory grammars and parasitic gaps . Natural Language and Linguistic
Theory , 5:403-439.
Anna Szabolcsi .  1989 . Bound variables in syntax : Are there any ? In R . Bartsch , J . van Benthem , and P . van Emde Boas ( eds . ), Semantics and Contextual Expression , 295-318 . Forts , Dordrecht . 
K . Vijay-Shanker and David Weir .  1990 . Polynomial time parsing of combinatory ? ategorial grammars  . In Proceedings of the P8th Annual Meeting of the Association for Computational Linguistics  . 
K . Vijay-Shanker and David Weir .  1993 . Parsing some constrained grammar formalisms . Computational Linguistics , 19(4):591-636 . 
K . Vijay-Shanker and David Weir .  1994 . The equivalence of four extensions of contextfree grammars  . Mathematical Systems Theory , 27:511-546 . 
Kent Wittenburg .  1986 . Natural Language Parsing with Combinatory Calegorial Grammar in a Graph-Unification-Based Formalism  . Ph . D . thesis , University of Texas . 
Kent Wittenburg .  1987 . Predictive combinators : A method for efficient parsing of Combinatory Categorial Grammars  . In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics  , Stanford University , July . 

