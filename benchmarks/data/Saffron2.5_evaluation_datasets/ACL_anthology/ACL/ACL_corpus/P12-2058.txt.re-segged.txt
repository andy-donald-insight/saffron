Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics , pages 296?300,
Jeju , Republic of Korea , 814 July 2012. c?2012 Association for Computational Linguistics
Heuristic Cube Pruning in Linear Time
Andrea Gesmundo
Department of
Computer Science
University of Geneva
andrea.gesmundo@unige.ch
Giorgio Satta
Department of
Information Engineering
University of Padua
satta@dei.unipd.it
James Henderson
Department of
Computer Science
University of Geneva
james.henderson@unige.ch
Abstract
We propose a novel heuristic algorithm for Cube Pruning running in linear time in the beam size . Empirically , we show a gain in running time of a standard machine translation system , at a small loss in accuracy.
1 Introduction
Since its first appearance in ( Huang and Chiang , 2005), the Cube Pruning ( CP ) algorithm has quickly gained popularity in statistical natural language processing . Informally , this algorithm applies to scenarios in which we have the kbest solutions for two input subproblems , and we need to compute the kbest solutions for the new problem representing the combination of the two subproblems.
CP has applications in tree and phrase based machine translation ( Chiang , 2007; Huang and Chiang , 2007; Pust and Knight , 2009), parsing ( Huang and Chiang , 2005), sentence alignment ( Riesa and Marcu , 2010), and in general in all systems combining inexact beam decoding with dynamic programming under certain monotonic conditions on the definition of the scores in the search space.
Standard implementations of CP run in time O(k log(k )), with k being the size of the in-put/output beams ( Huang and Chiang , 2005). Gesmundo and Henderson (2010) propose Faster CP ( FCP ) which optimizes the algorithm but keeps the O(k log(k )) time complexity . Here , we propose a novel heuristic algorithm for CP running in time O(k ) and evaluate its impact on the efficiency and performance of a realworld machine translation system.
2 Preliminaries
Let L = ? x0, . . . , xk?1? be a list over R , that is , an ordered sequence of real numbers , possibly with repetitions . We write | L | = k to denote the length of L . We say that L is descending if xi ? xj for every i , j with 0 ? i < j < k . Let L1 = ? x0, . . . , xk?1? and L2 = ? y0, . . . , yk??1? be two descending lists over R . We write L1 ? L2 to denote the descending list with elements xi+yj for every i , j with 0 ? i < k and 0 ? j < k?.
In cube pruning ( CP ) we are given as input two descending lists L1, L2 over R with | L1| = | L2| = k , and we are asked to compute the descending list consisting of the first k elements of L1 ? L2.
A problem related to CP is the k-way merge problem ( Horowitz and Sahni , 1983). Given descending lists Li for every i with 0 ? i < k , we write mergek?1i=0 Li to denote the ? merge ? of all the lists Li , that is , the descending list with all elements from the lists Li , including repetitions.
For ? ? R we define shift(L ,?) = L ? ???. In words , shift(L ,?) is the descending list whose elements are obtained by ? shifting ? the elements of L by ?, preserving the order . Let L1,L2 be descending lists of length k , with L2 = ? y0, . . . , yk?1?.
Then we can express the output of CP on L1,L2 as the list mergek?1i=0 shift(L1, yi ) (1) truncated after the first k elements . This shows that the CP problem is a particular instance of the k-way merge problem , in which all input lists are related by k independent shifts.
296
Computation of the solution of the k-way merge problem takes time O(q log(k )), where q is the size of the output list . In case each input list has length k this becomes O(k2 log(k )), and by restricting the computation to the first k elements , as required by the CP problem , we can further reduce to O(k log(k )). This is the already known upper bound on the CP problem ( Huang and Chiang , 2005; Gesmundo and Henderson , 2010). Unfortunately , there seems to be no way to achieve an asymptotically faster algorithm by exploiting the restriction that the input lists are all related by some shifts . Nonetheless , in the next sections we use the above ideas to develop a heuristic algorithm running in time linear in k.
3 Cube Pruning With Constant Slope
Consider lists L1,L2 defined as in section 2. We say that L2 has constant slope if yi?1? yi = ? > 0 for every i with 0 < i < k . Throughout this section we assume that L2 has constant slope , and we develop an ( exact ) linear time algorithm for solving the CP problem under this assumption.
For each i ? 0, let Ii be the left-open interval ( x0 ? ( i + 1) ? ?, x0 ? i ? ?] of R . Let alo s = ?( x0 ? xk?1)/?? + 1. We split L1 into ( possibly empty ) sublists ? i , 0 ? i < s , called segments , such that each ? i is the descending sublist consisting of all elements fromL1 that belong to Ii . Thus , moving down one segment in L1 is the closest equivalent to moving down one element in L2.
Let t = min{k , s }; we define descending lists
Mi , 0 ? i < t , as follows . We set M0 = shift(?0, y0), and for 1 ? i < t we let Mi = merge{shift(?i , y0), shift(Mi?1,??)} (2) We claim that the ordered concatenation of M0, M1, . . . , Mt?1 truncated after the first k elements is exactly the output of CP on input L1,L2.
To prove our claim , it helps to visualize the descending list L1 ? L2 ( of size k2) as a k ? k matrix L whose jth column is shift(L1, yj ), 0 ? j < k.
For an interval I = ( x , x ?], we define shift(I , y ) = ( x + y , x ?+ y ]. Similarly to what we have done with L1, we can split each column of L into s segments.
For each i , j with 0 ? i < s and 0 ? j < k , we define the ith segment of the jth column , written ? i,j , as the descending sublist consisting of all elements of that column that belong to shift(Ii , yj ). Then we have ? i,j = shift(?i , yj).
For any d with 0 ? d < t , consider now all segments ? i,j with i + j = d , forming a sub-antidiagonal in L . We observe that these segments contain all and only those elements of L that belong to the interval Id . It is not difficult to show by induction that these elements are exactly the elements that appear in descending order in the list Mi defined in (2).
We can then directly use relation (2) to iteratively compute CP on two lists of length k , under our assumption that one of the two lists has constant slope.
Using the fact that the merge of two lists as in (2) can be computed in time linear in the size of the output list , it is not difficult to implement the above algorithm to run in time O(k).
4 Linear Time Heuristic Solution
In this section we further elaborate on the exact algorithm of section 3 for the constant slope case , and develop a heuristic solution for the general CP problem . Let L1,L2, L and k be defined as in sections 2 and 3. Despite the fact that L2 does not have a constant slope , we can still split each column of L into segments , as follows.
Let I?i , 0 ? i < k ? 1, be the left-open interval ( x0 + yi+1, x0+ yi ] of R . Note that , unlike the case of section 3, intervals I?i?s are not all of the same size now . Let alo I?k?1 = [ xk?1 + yk?1, x0 + yk?1].
For each i , j with 0 ? j < k and 0 ? i < k ? j , we define segment ?? i,j as the descending sublist consisting of all elements of the jth column of L that belong to I?i+j . In this way , the jth column of L is split into segments I?j , I?j+1, . . . , I?k?1, and we have a variable number of segments per column.
Note that segments ?? i,j with a constant value of i+j contain all and only those elements of L that belong to the left-open interval I?i+j .
Similarly to section 3, we define descending lists M?i , 0 ? i < k , by setting M?0 = ??0,0 and , for 1 ? i < k , by letting M?i = merge{??i,0 , path(M?i?1, L )} (3) Note that the function path(M?i?1, L ) should not return shift(M?i?1,??), for some value ?, as in the 2: L??.insert(L[0, 0]); 3: referColumn ? 0; 4: xfollow ? L[0, 1]; 5: xdeviate ? L[1, 0]; 6: C ? CircularList([0, 1]); 7: C-iterator ? C.begin (); 8: while | L ??| < k do 9: if xfollow > xdeviate then 10: L??.insert(xfollow ); 11: if C-iterator.current()=[0, 1] then 12: referColumn ++; 13: [ i , j ]? C-iterator.next (); 14: xfollow ? L[i,referColumn+j ]; 15: else 16: L??.insert(xdeviate ); 17: i ? xdeviate . row (); 18: C-iterator.insert([i,?referColumn ]); 19: xdeviate ? L[i + 1, 0]; case of (2). This is because input list L2 does not have constant slope in general . In an exact algorithm , path(M?i?1, L ) should return the descending list L?i?1 = mergeij=1 ?? i?j,j : Unfortunately , we do not know how to compute such a i-way merge without introducing a logarithmic factor.
Our solution is to define path(M?i?1, L ) in such a way that it computes a list L?i?1 which is a permutation of the correct solution L?i?1. To do this , we consider the ? relative ? path starting at x0+yi?1 that we need to follow in L in order to collect all the elements of M?i?1 in the given order . We then apply such a path starting at x0 + yi and return the list of collected elements . Finally , we compute the output list L ?? as the concatenation of all lists M?i up to the first k elements.
It is not difficult to see that when L2 has constant slope we have M?i = Mi for all i with 0 ? i < k , and list L ?? is the exact solution to the CP problem . When L2 does not have a constant slope , list L ?? might depart from the exact solution in two respects : it might not be a descending list , because of local variations in the ordering of the elements ; and it might not be a permutation of the exact solution , because of local variations at the end of the list . In the next section we evaluate the impact that                                                                       Figure 1: A running example for Algorithm 1.
our heuristic solution has on the performance of a realworld machine translation system.
Algorithm 1 implements the idea presented in (3).
The algorithm takes as input two descending lists L1,L2 of length k and outputs the list L ?? which approximates the desired solution . Element L[i , j ] denotes the combined value xi + yj , and is always computed on demand.
We encode a relative path ( mentioned above ) as a sequence of elements , called displacements , each of the form [ i , ?]. Here i is the index of the next row , and ? represents the relative displacement needed to reach the next column , to be summed to a variable called referColumn denoting the index of the column of the first element of the path . The reason why only the second coordinate is a relative value is that we shift paths only horizontally ( row indices are preserved ). The relative path is stored in a circular list C , with displacement [0, 1] marking the starting point ( paths are always shifted one element to the right ). When merging the list obtained through the path for M?i?1 with segment ?? i,0, as specified in (3), we update C accordingly , so that the new relative path can be used at the next round for M?i . The merge operator is implemented by the while cycle at lines 8 to 19 of algorithm 1. The if statement at line 9 tests whether the next step should follow the relative path for M?i?1 stored in C ( lines 10 to 14) or 1 10 100 1000 sc or e lo ss (% ) beam size
Baseline score loss over CP
LCP score loss over CP
FCP score loss over CP
Figure 2: Search-score loss relative to standard CP.
else depart visiting an element from ?? i,0 in the first column of L ( lines 16 to 19). In the latter case , we update C with the new displacement ( line 18), where the function insert () inserts a new element before the one currently pointed to . The function next () at line 13 moves the iterator to the next element and then returns its value.
A running example of algorithm 1 is reported in Figure 1. The input lists are L1 = ?12, 7, 5, 0?, L2 = ?9, 6, 3, 0?. Each of the picture in the sequence represents the state of the algorithm when the test at line 9 is executed . The value in the shaded cell in the first column is xdeviate , while the value in the other shaded cell is xfollow .
5 Experiments
We implement Linear CP ( LCP ) on top of Cdec ( Dyer et al , 2010), a widely-used hierarchical MT system that includes implementations of standard CP and FCP algorithms . The experiments were executed on the NIST 2003 ChineseEnglish parallel corpus . The training corpus contains 239k sentence pairs . A binary translation grammar was extracted using a suffix array rule extractor ( Lopez , 2007).
The model was tuned using MERT ( Och , 2003).
The algorithms are compared on the NIST03 test set , which contains 919 sentence pairs . The features used are basic lexical features , word penalty and a 3gram Language Model ( Heafield , 2011).
Since we compare decoding algorithms on the same search space , the accuracy comparison is done in terms of search score . For each algorithm we 1 10 100 1000 sp ee d ga in (% ) beam size
LCP speed gain over CP
LCP speed gain over FCP
Figure 3: Linear CP relative speed gain.
compute the average score of the best translation found for the test sentences . In Figure 2 we plot the score-loss relative to standard CP average score.
Note that the FCP loss is always < 3%, and the LCP loss is always < 7%. The dotted line plots the loss of a baseline linear time heuristic algorithm which assumes that both input lists have constant slope , and that scans L along parallel lines whose steep is the ratio of the average slope of each input list.
The baseline greatly deteriorates the accuracy : this shows that finding a reasonable linear time heuristic algorithm is not trivial . We can assume a bounded loss in accuracy , because for larger beam size all the algorithms tend to converge to exhaustive search.
We found that these differences in search score resulted in no significant variations in BLEU score ( e.g . with k = 30, CP reaches 32.2 while LCP 32.3).
The speed comparison is done in terms of algorithm runtime . Figure 3 plots the relative speed gain of LCP over standard CP and over FCP . Given the logscale used for the beam size k , the linear shape of the speed gain over FCP ( and CP ) in Figure 3 empirically confirms that LCP has a log(k ) asymptotic advantage over FCP and CP.
In addition to ChineseEnglish , we ran experiments on translating English to French ( from Europarl corpus ( Koehn , 2005)), and find that the LCP score-loss relative to CP is < 9% while the speed relative advantage of LCP over CP increases in average by 11.4% every time the beam size is multiplied by 10 ( e.g . with k = 1000 the speed advantage is 34.3%). These results confirm the bounded accuracy loss and log(k ) speed advantage of LCP.
299
References
David Chiang . 2007. Hierarchical phrasebased translation . Computational Linguistics , 33(2):201?228.
Chris Dyer , Adam Lopez , Juri Ganitkevitch , Jonathan Weese , Hendra Setiawan , Ferhan Ture , Vladimir Eidelman , Phil Blunsom , and Philip Resnik . 2010.
cdec : A decoder , alignment , and learning framework for finite-state and contextfree translation models.
In ACL ?10: Proceedings of the ACL 2010 System
Demonstrations , Uppsala , Sweden.
Andrea Gesmundo and James Henderson . 2010. Faster Cube Pruning . In IWSLT ?10: Proceedings of the 7th International Workshop on Spoken Language Translation , Paris , France.
Kenneth Heafield . 2011. KenLM : Faster and smaller language model queries . In WMT ?11: Proceedings of the 6th Workshop on Statistical Machine Translation,
Edinburgh , Scotland , UK.
E . Horowitz and S . Sahni . 1983. Fundamentals of data structures . Computer software engineering series . Computer Science Press.
Liang Huang and David Chiang . 2005. Better kbest parsing . In IWPT ?05: Proceedings of the 9th International Workshop on Parsing Technology , Vancouver,
British Columbia , Canada.
Liang Huang and David Chiang . 2007. Forest rescoring : Faster decoding with integrated language models . In ACL ?07: Proceedings of the 45th Conference of the Association for Computational Linguistics,
Prague , Czech Republic.
Philipp Koehn . 2005. Europarl : A parallel corpus for statistical machine translation . In Proceedings of the 10th Machine Translation Summit , Phuket , Thailand.
Adam Lopez . 2007. Hierarchical phrasebased translation with suffix arrays . In EMNLPCoNLL ?07: Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning , Prague , Czech
Republic.
Franz Josef Och . 2003. Minimum error rate training in statistical machine translation . In ACL ?03: Proceedings of the 41st Conference of the Association for Computational Linguistics , Sapporo , Japan.
Michael Pust and Kevin Knight . 2009. Faster MT decoding through pervasive laziness . In NAACL ?09: Proceedings of the 10th Conference of the North American Chapter of the Association for Computational Linguistics , Boulder , CO , USA.
Jason Riesa and Daniel Marcu . 2010. Hierarchical search for word alignment . In ACL ?10: Proceedings of the 48th Conference of the Association for Computational Linguistics , Uppsala , Sweden.
300
