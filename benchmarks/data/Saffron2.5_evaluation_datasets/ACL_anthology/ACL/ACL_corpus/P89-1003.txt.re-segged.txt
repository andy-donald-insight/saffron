ATHREE-VALUED INTERPRETATION OF NEGATION IN
FEATURESTRUCTUREDESCRIPTIONS
Anuj Dawar
Dept . of Comp . and Info . Science
University of Pennsylvania
Philadelphia , PA 19104
K . Vijay-Shanker
Dept . of Comp . and Info . Science
University of Delaware
Newark , DE 19718
April 20, 1989

Feature structures are informational elements that have been used in severalinguistic theories and in computational systems for natural language processing  . A logi-caJ calculus has been developed and used as a description language for feature structures  . In the present work , a framework in three-valued logic is suggested for defining the semantics of a feature structure description language  , allowing for a more complete set of logical operators  . In particular , the semantics of the negation and implication operators are examined  . Various proposed interpretations of negation and implication are compared within the suggested framework  . One particular interpretation of the description language with a negation operator is described and its computational spect studied  . 
1 Introduction and Background
A number of linguistic theories and computational approaches to parsing natural anguage have employed the notion of associating informational dements  , called feature structures , consisting of features and their values , with phrases . Rounds and Kasper\[KR 86 ,   RK86\] developed a logical calculus that serves as a description language for these structures  . 
Several researchers have expressed a need for extending this logic to include the operators of negation and implication  . Various interpretations have been suggested that define a semantics for these operators  ( see Section 1 . 2), but none has gained universal acceptance . In\[Per87\] , Pereira set forth certain properties that any such interpretation should satisfy  . 
In this paper we present an extended logical calculus  , with a semantics in three-valued logic ( based on Kleene's three-valued logic\[Kh52\] )  , that includes an interpretation of negation motivated by the approach given by Karttunen\[  Kar84\]  . We show that our logic meets the conditions stated by Pereira  . We also show that the three-valued framework is powerful enough to express most of the proposed definitions of negation and implication  . It therefore makes it possible to compare these different approaches  . 
1.1 Rounds-Kasper Logic
In\[Kas87\] and\[RK86\] , Rounds and Kasper introduced a logical formalism to describe feature structures with disjunctive specification  . The language is a form of modal propositional logic  ( with modal operator ":' )   . 
In order to define the semantics of this language , feature structures are formally defined in terms of a cyelic finite automata  . These are finite-state automata whose transition graphs are acyclic  . The formal definition may be found in \[ RK86\] . 
A fundamental property of the semantics i that the set of automata satisfying a given formula is upward-closed under the operation of subsumption  . This is important , because we consider a formula to be only a partial description of a feature structure  . The property is stated in the following theorem IRK86\]: Theorem 1  . 1 AC8 if and only i / for every formula ,  ~ , if A ~ ~ then B ~ cb . 
1 . 2 The Prob lem o f Add ing Negat ion Several researchers in the area have suggested that the logic described above should be extended to include negation and implication  . 
Karttunen \ [ Kar84\] provides examples of feature structures where a negation operator might be useful  . For instance , the most natural way to represent the number and person attributes of a verb such as sleep would be to say it as a disjunction of the other tive possibilities  . Kaxt tunen also suggests an implementation technique to handle negative information  . 
Johnson\[Joh87\] , defined an Attribute Value Logic ( AVL ) , similar to the Rounds-Kasper Logic , that included a classical form of negation . Kasper\[ Kas88\] discusses an interpretation f negation and implication in an implementation of Functional Unification Grammar\[  Kay79\] that includes conditionals . Kasper's semanticsic lassical , but his unification procedure uses notions similar to those of three-valued logica  . 
One aspect of the classical approach is that the property of upward-closure under subsumption is lost  . Thus the evaluation of negation may not be freely interleaved with unification  2 In \[ Kas88\]  , K as per localized the effects of negation by disallowing path expressions within the scope of a negation  . This restriction may not be linguistically warranted as can be seen by the following example from Pereira \ [  Per87\] which expresses the semantic on straint that the subject and object of a clause cannot be coreferential unless the object is a reflexive pronoun :  oh3 : type:reflezive V - ~ ( subj:ref ~ obj:ref ) Moshier and Rounds\[ MR87\] proposed an intuitionistic interpretation of negation that preserves upward-closure  . 
They replace the notion of saris/action with one of model-theoretic/arcing and escribed in Fitting  \[   Fit69\]  . They also provide a complete proof system for their logic  . The satis-liability problem for this logic was shown to be PSPACE-complete  . 
1.3 Outline of this Paper
In the following section we will present our proposed solution in a three-valued framework  , for defining the semantics of feature structure descriptions including negation  3  . 
This solution is a formalization of the notion of negation in Karttunen\[  Kar84\]  . In Section 3 we will show that the framework of three-valued logic is flexible enough to express most of the different interpretations of negation mentioned above  . In Section 4 we will show that the satis-fiability problem for the logic we propose is NP-complete  . 
l see Section 3 . 42 see Pereira\[Per87\]p . 1 006   3 We shall concentrate only on the problem of extending the logic to include the negation operator  , and later in Section 3 . 4 discuss Implication . 
2 Feature Structure Descriptions with

We will now present our extended version of the Rounds-Kasper logic including negation  . We do this by giving the semantics of the logic in a three-valued setting  . This provides an interpretation of negation that is intuitively appealing  , formally simple and computationally no harder than the original Rounds-Kasper logic  . 
With each formula we associate the set ( T set ) of automata that satis/y the formula , a set ( F set ) of automata that contradic tit and a set ( U set ) of automata which neither satisfy nor contradict i  4  . Different interpretations of negation are obtained by varying definitions of what constitutes " contradiction  . " In the semantics we will define , we choose a definition in which contradiction is equivalent to essential incompatibility  5  . We will define the T set and the F set so that they are upward-closed with respecto subsumption for all formulae  . Thus , we avoid the problems associated with the classical interpretation of negation  . In our logic , negation is defined so that an automaton , 4 satisfies - , ~ b if and only if it contra ? 1 icts ~ . 
2.1 The Syntax
The symbols in the descriptive language , other than the connectives : , v , A , - , and ~ are taken from two primitive domains : Atoms  ( A , and Labels ( L) . 
The set of wellformed formulae ( W ) , is given by : NIL ; TOP ; a ;  1 : @ ; ~ A  ~ b ; @ V  ~ b ; "-~ and pl~-P2 , where a EA ; 1EL ; ~ , ~EW and Pa , P2 EL ' . 
2.2 The Semantics
Formally , the semantics i defined over the domain of partial functions from a cycLic finite automata ~ to boolean values  . 
Definition 2 . 1 An acyclic finite automaton is a 7-tuple
A = < Q , E , r , 6, qo , F , A >, where : 1 . Q is a nonempty finite set ( of states ), ~ . E is a countable set ( the alphabet) , 4A similar notion was used by Kasper\[Kas88\] , who introduces the notion of compatibility . We shall comps . reth is approach with ou ~ in greeter detail in Section  3  . 4 . 
Sln general , a feature structure is incompatible with a formula i ? the information it contains is inconsistent with that in the formula  . 
We will distinguish two kinds of incompatibility . A feature structure is essential l~/incompatible with a formula if the information in it contradicts the information in the formula  . It is trivially incompatible with the formula if the inconsistency is due to an excess of m formts tion within the formula itself  . 
S in this paper we will not consider cyclic feature structures  4  . 6: Q?E-"Q is a finite partial/unction ( the transition function )  ,  5 . qo ~ Q ( the initial state ), 6 . FCQ ( the set of final states ), 7 . A : F "-* r is a total function ( the output function )  ,  8 . the directed graph(Q , E ) is acyclic , where pEq iff . for some 16Z , 6(p , l ) = q , 9 .   . for every q ~ Q , there exists a directed path from qo to q in ( Q , E ) , and 10 . for every q ~ F , 6( q , I ) is not defined for any I . 
A formula ~ over the set of labels L and the set of atoms A is chaxacterized by a partial function : ~ r  , :'41"4=< Q , L , A ,  6 , q0 , F , A > "7" True , False ~# , ('4) is True iff "4 satisfies ~ b . It is False if ' 4 contradicts ~ brand is undefined otherwise . The formal definition is given below . 
Definition 2 . 2 For any formula ? ~, the partial function . ~'? over the set of acyclic finite automata , "4 = < Q , L , A ,  6 , qo , F , A > , is defined as follows : 1 . if ~= NIL then ~('4) = True for all "4; ~ . if ~= TOP then ~( , 4) = False for all . 4; 3 . if Oma for some a ~ A then ~( . , 4) = True if . 4 is atomic and A(q0) = a:7: ( . 4 ) = False if "4 is atomic and A ( qo ) = b for some b , b#a ( see Note ~ . ) ~'~("4) is undefined otherwise ; 4 . if@fl:@t for some l ~ L and @ x 6 W then ~ r ~ (  "4  ) __~r ~ , ("4/l ) if . Aft is defined . 
( see Note 3 . ): F , ('4) is undefined otherwise ; r and therefore it satisfies the formula "-4 ,  5 . if ~= ~ aA~2 for some ~ bi , ~2EW then . ~'+('4) = True if ~ r + , ('4 ) = True and jr (  '4  ) = True y + ( '4 ) = False if ~ r ~ , ('4 ) = False or ~' ~ (  '4  ) -False ~ (  '4  ) is undefined otherwise ;  6 . 


V ~ b2 for some ~, , ~26 W then ? . ~ True if . ~'~ ,   ( '4 ) = True or 9 r ? 2 ( '4 ) = True=False if ~ x (  '4  ) = False and F~2 ( '4  ) = False is undefined otherwise ;  7 . if ~ b --" ~1 for some ~ hEW then : ~ (  '4 ) = True if Y : ~ , ('4) = False ~ r , # ( '4 ) = False if gr~x ( '4 ) = True ~ (  '4  ) is undefined otherwise ;  8 . if ? = m ~+ ('4) ~("4) 7+ ('4) ~ I ~ for some pa , p2EL " then=True if 6(qo , p , ) and 6 ( qo , p2) are defined and 6 ( q0 , pl ) ----6 ( qo , p2 ) = False if "4/pa and "4/P2 are both defined and are not unifiable is undefined otherwise  ( see Note 4 . ) . 
Notes:
I . We have not included an implication operator in the formal language  , since we find that defining im-pll cation in terms of negation and disjunction  ( i . e ~ b = ~ ~ b ~ - ~@ V ~ b ) yields a semantics for implication that corresponds exactly to our intuitive understanding of implication  . 
2 . As one would expect , an atomic formula is satisfied by the corresponding atomic feature structure  . On the other hand , only atomic feature structures are defined as contradicting an atomic formula  . Though a complex feature structure is clearly incompatible with an atomic formula we do not view it as being essentially incompatible with it  . An interpretation of negation that defines a complex feature structure as contradicting a  ( and hence satisfying - , a ) is also possible . However , our definition is motivated by the linguistic intention of the negation operator as given by Karttunen \ [  Kar84\]  . Thus , for instance , we require that an automaton satisfying the formula case : "  . dative have an atomic value for the case feature . 
3 . In J . above , we state that : ~'~('4) = jr' , ('4/1) if . Aft is defined . When "4/l is defined , ~t ('4/ I ) may still be True , False or undefined . In any of these cases , ~#( . A ) --~ I ( . A/I ) s . ~ r ~( . A ) is not defined if . All is not defined . Not only is this condition required to preserve upward-closure  , it is also linguistically motivated . 
Here again , we could have said that a formula of the form I : ~ bz is contradicted by any atomic feature structure  , but we have chosen not to do so for the reasons outlined in the previous note  . 
We have chosen to state that the set of automata that are incompatible with the formula pz ~  p2 is not the set of automata for which 6  ( qo , pl ) and 6(qo , p ~) axe defined and 8(q0 , pz)~6(q0 , p2) , since such an automaton could subsume one in which  6  ( qo , px ) = 6(q0 , p ~) . Thus , we would lose the property of upward-closure under subsumption  . However , an automaton, . 4 , in which 6 ( q0 , pl ) and 8(qo , p2) are defined and .   A/p1 is not unifiable 9 with ~4/p2 cannot subsume one in which 6  ( q0 , p a ) = 6 ( q0 , p2) . 
2.2.1 Upward-Closure
As has been stated before , the set of automata that satisfy a given formula in the logic defined above is upward-closed under subsumption  . This property is formally stated below . 
Theorem 2 . 1 Given a formula ~ b and two acyclie finite automata  . 4 and IJ , if ~( . A ) is defined and . 4 CB then y . ( B ) ~, defined and ; %( B ) = 7 . (~4) . 

The proof is by induction on the structure of the formula  . 
The details may be found in Dawar\[Daw88\].
2.3 Examples
We now take a look at the examples mentioned earlier and see how they are interpreted in the logic just defined  . The first example expressed the agreement attribute of the verb sleep by the following formula : agreement : " ~  ( person : third A number : singular )   ( 1 ) This formula is satisfied by any structure that has an agreement feature which  , in turn , either has a person feature with a value other than third or a number feature with a value other than singular  . Thus , for instance , the following two structure satisfy the given formula:agreement:\[person:second\] SE quality here is strong equality  ( i . e . if . g , x(A\]l ) is undefined then so is . ~',( . 4) . )  9Two automat are not unifiable if and only if they do not have a least upper bound\[\[pr  , on \]\] agreement : number : plural On the other hand  , for a structure to contradict formula ( 1 ) it must have an agreement feature defined for both person and number with values third and singula respectively  . All other automata would have an undefined truth value for formula  ( 1 )  . 
Turning to the other example mentioned earlier , the formula : obj:type:reflexivex /" ~ ( subj:ref ~ obj:ref )   ( 2 ) is satisfied by the first two of the following structures  , but is contradicted by the third ( here coindex boxes are used to indicate coreference or path-equivalence  )  . 
\[ obj . \[ type-reflexive\]\]\[obj:\[ref:\[\] \]\] subj:\[ref:\[\]\]j \] type: reflezive subj:\[  re1:  \ [ \ ] \]  3 Comparison with Other Interpretations of Negation As we have stated before  , the semantics for negation described in the previous section is motivated by the discussion of negation in Karttunen\[  Kar84\]  , and that it is closely related to the interpretation of Kssper\[  Kas88\]  . In this section , we take a look at the interpretations of negation that have been suggested and how they may be related to interpretations in a three-valued framework  . 
3.1 Classical Negation
By classical negation , we mean an interpretation i which an automaton . 4 satisfies a formula -~ b if and only if it does not satisfy ~ b  . This is , of course , a two-valued logic . Such an interpretation is used by Johnson in his Attribute Value Language\[  Joh87\]  . We can express it in our framework by making ~' ~ a total function such that wherever  9re  ( A ) was undefined , it is now defined to be False . 
Returning to our earlier example , we can observe that for formula ( 1 ) the structure \[ agreement : \[ person : third\] \] has a truth value of  . false in the classical semantics but has an undefined truth value in the semantics we define  . 
This illustrates the problem of nonmonotonicity in the classical semantic since this structure does subsume one that satisfies formula  ( 1 )  . 
21 3.2 Intultionistic Logic
In \[ MR87\] , Moshier and Rounds describe an extension of the Rounds-Kasper logic  , including an implication operator and hence , by extension , negation . The semantics is based on intnitionistic techniques  . The notion of satisfying is replaced by one of forcing  . Given a set of automata/C , a formula ~ b , and . A such that . 4 ~/ C , . A forces in IC " ~ b ( , 4 hn-~b ) if and only if for all B~/C such that A~B , B does not force ~ b in / ~ . Thus , in order to find if a formula , ~ b , is satisfiable , we have to find a set \] C and an automaton ~4 such that forces in IC ~ . 
Moshier and Rounds consider a version in which forcing is always done with respect to the set of all automata  , i . e . IC * . This means that the set of feature structures that satisfy--~b is the largest upward-closed set of feature structures that do not satisfy @  ( i . e . the set of feature structures incompatible with ~ b  )  . We can capture this in the three-valued framework described above by modifying the definition of ~ r ? to make it False for all automata that are incompatible  ( trivially or essentially ) with ~ b ( we call this new function ~ r ~ )  . The definition of ~'~ differs from that of ~ r + in the following cases : ?~ b = a~r ?  ( A ) = True if A is atomic and A ( q0 ) = a~r ~ ( A ) = False otherwise ~' ~ ( ~ t ) = True if ~' ~ (  . A ) - - -- True : ~ ( A ) = False if All is defined and vs ( wl/!~_B = ~ ~ , ,( B ) = False ) ~ r~( . A ) is undefined otherwise . 
~' ~( Ft ) = True if ~+ , ( . , 4) = True and . ~+~( . A ) = True : r ~ , ( A ) = False if VB(AE_S = ~~ r ~ t(B)#True or Y ; 2(B)#True ) ~( A ) is undefined otherwise ; ? ~= ~ v ~27 ;  (  , 4) = Tr . eif ~, ( . A ) = True or ~ r ~ a ( A ) = True ~ ( A ) = False if ? B (  . ACB ~';,( B)#True and Jr; . ( B ) #True ) ~ r ~( . 4) is undefined otherwise ; ?~= Pl~P 27; ( , 4) = True if 8(qo , p , ) and ~( qo , p2) are defined and ~( qo , pl ) = 6 ( qo , p2)
F ~( A ) = False if A/p1 and .   A/p2 are both defined and are not unifiable or if . 4 is atomic ~' ~( . 4) is undefined otherwise . 
In the other cases , the definition of ~' ~ parallels that of 7+ . 
To illustrate the difference between ~'~ and 3r ~ , we define the following ( somewhat contrived ) formula : cb = ( 11: avl 2: a ) AI2:b
We also define the automaton , 4=\[11:b\]We can now observe that F ~ ( A ) is undefined but 3r ~ ( A ) = False . To see how this arises , note that in either system , the truth value of , 4 is undefined with respect to each of the conjuncts of ? i  . This is so because , 4 can certainly be extended to satisfy either one of the conjuncts  , just as it can be extended to contradict either one of them  . But , for ~ c'~#( . A ) to be False, . 4 must have a truth value of False for one of the conjuncts and therefore  . ~'?( . 4) is undefined . 
On the other hand , since . 4 can never be extended to satisfy both conjuncts of ~ simultaneously  , it can never be extended to satisfy ~ b . Hence . 4 is certainly incompatible with ~ , but because this incompatibility is a result of the excess of information in the formula itself  , we say that it is only trivially incompatible with ~  . 
To see more clearly what is going on in the above example  , consider the formula-~b and apply distributivity and De Morgan's law  ( which is a valid equivalence in the logic described in the previous section  , but not in the in-tuitionistic logic of this section  ) which gives us :- , ~b = (-' la : aA " . /2: a ) V-~12: b We can now see why we do not wish . 4 to satisfy-~b , which would be the case if . ~'~#(~4) were False . 
One justification given for the use of forcing sets other than/C* is the interpretation of formulae such as -~ h:NIL  . It is argued that since h:NIL denotes all feature structures that have a feature labeled h  ,  - , h:NIL should denote those structures that do not have such a feature  . 
However , the formula-~h:NIL is unsatisfiable both in the interpretation given in the last section as well as in the/C * version of intuitionistic logic  . It is our opinion that the use of negation to assert the non-existence of features is an operation distinct from the use of negation to describe values mad should be described by a distinct operator  . The present work attempts to deal only with the latter notion of negation  . The authors expect to present in a forthcomi ~ ag paper a simple extension to the current semantics that will deal with issues of existence of features  . 
22 3 . 3 Kar t tunen ' s Imp lementat ion of Negat ion As mentioned earlier  , our approach was motivated by Karttunen's implementation as described in \[  Kax84\]  . In the unification algorithm given , negative constraints are attached to feature structures or automata  ( which themselves do not have any negative values )  . When the feature structure is extended to have enough information to determine whether it satisfies or falsifies I ? the formula then the constraints may be dropped  . We feel that our definition of the Use telegantly captures the notion of associating constraints with automata that do not have sufficient information to determine whether they satisfy or contradict a given formula  . 
3.4 Kasper's Interpretation of Negation and
Conditionals
As mentioned earlier , Kasper ~ Kas88\] used the operations of negation madimplication in extending Functional Unification Grammar  . Though the semantics defined for these operators is a classical one  , for the purposes of the algo . 
rithm K asper identified three chases of automata ssoci-ated with any formula : those that satisfy it  , those that are incompatible with it and those that are merely compatible with it  . We can observe that these are closely related to our Tact  , Fset and User respectively . For instance , K as per states that an automaton . A satisfies a formula f : v if it is defined for f with value v  ; it is incompatible with f : v if it is defined for f with value z  ( z  ~ v ) and it is merely compatible with f:vifitis not defined for f  . In three-valued logic , we incorporate these notions into the formal semantics  , thus providing a formal basis for the unification procedure given by Kasper  . Our logic also gives a more uniform treatment to the negation operator since we have removed the restriction that disallowed path equivalences in the scope of a negation  . 
4 Computational Issues
In this section , we will discuss some computational s-pects related to determining whether a formula is satisfiable or not  . We will Show that the satisfiability problem is NP-complete  , which is not surprising considering that the problem is NP-complete for the logic not involving negation  ( Rounds-Kasper logic )  . 
The NP-hardness of this problem is trivially shown if we observe that for any formula  , ~ b , without negation , T set ( ? ) is exactly the set of automata that satisfy ~ according to the definition of satisfaction given by Roundsl ? It is not clear whether falsification is equivalent to incomp ~- ibility or only essential incompatibility  , but from the examples in-volvin ~ ease and agreement  , we believe that only emJential in com-patibihty is intended  . 
and Kasper\[KR 86 , RK86\] in their original logic . Since the satisfiabllity problem in that logic is NP-complete  , the given problem is NP-haxd . 
In order to see that the given problem is in NP , we observe that a simple nondeterministic algorithm  11 can be given that is linear in the length of the input formula ~ b and that returns a minimal automaton which satisfies ~ b  , provided it is satisfiable . To see this , note that the size ( in terms of the number of states ) of a minimal automaton satisfying ~ b is linear in the length of ? and verifying whether a given automatisfies ~ b is a problem linear in the length of ~ b and the size of the automaton  . The details of the algorithm can be found in Dawar\[  DawS8\]  . 
5 Conclusions
A logical formalism with a complete set of logical operators has come to be accepted as a means of describing feature structures  . While the intended semantics of most of these operator si well understood  , the negation and implication operators have raised some problems  , leading to a variety of approaches in their interpretation  . In the present work , we have presented an interpretation that combines the following advantages : it is formally simple as well as uniform  ( it places no special restriction on the negation operator  )  ; it is motivated by the linguistic applications of feature structures  ; it takes into accoun the partial nature of feature structures by preserving the property of monotonicity under unification and it is computationally no harder than the Rounds-Kasper logic  . More significantly , perhaps , we have shown that most existing interpretations of negation can also be expressed within three -valued logic  . This framework therefore provides a means for comparing and evaluating various interpretations  . 
References\[Daw88\]\[Fit69\]
Anuj Dawar . The Semantics of Negation in Feature Structure Descriptions  . Master's thesis , University of Delaware , 1988 . 
Melvin Fitting . Intuitionistic Logic and Model Theoretic Forcing . North-Holland , Amsterdam , 1969 . 
\[ Joh87\] Mark Johnson . Attribute Value Logic and the Theory of Grammar . PhD thesis , Stanford University , August 1987 . 
\[ K ~84\] Lauri Karttunen . Features and values . In Pro . 
ceedings of the Tenth International Conference on
Computational Linguistics , July 1984.
ll this algorithm assumes that these ? of atoms is finite  . 
23\[Kas87\]RobertT . Kasper . Feature Structures : A Logical Theory with Application to Language Analysis  . 
PhD thesis , University of Michigan , 1987.
\[K as88\] Robert T . Kasper . Conditional descriptions in Functional Unification Grammar  . In Proceedings of the ~6th Annual Meetingo \] the Association/or Computational Linguistics  , pages 233-240 , June 1988 . 
\[Kay 79\]M . Kay . Functional grammax . In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society  ,  1979 . 
\[ Kle52\]S . C . Kleene . Introduction to Metamathematics . 
Van Nostrand , New York , 1952.
\[KR86\] Robert T . Ka~per and William C . Rounds . A logical semantics for feature structures . In Proceedingso/the~th Annual Meetingo . ( the Association for Computational Linguistics ,  1986 . 
\[ MR87\]M . Drew Moshier and William C . Rounds . A logic for partially specified data structures . In ACM Symposium on the Principleso ~ Program . 
ruing Languages , pages 156-167, ACM , 1987.
\[ Per87\] Fernando C . N . Pereira . Grammars and logics of partial information . In Jean-Louis Lassez , editor , Proceeding so \] the 4th International Conference on Logic Programming , pages 989-1013 , 
May 1987.
IRK86\]WilliamC . Rounds and Robert T . Kasper.
A complete logical culus for record structures representing linguistic information  . In IEEE Symposium on Logic in Computer Science , pages 34-43 , IEEE Computer Society , June 1986 . 

