Construct Algebra : Analytical Dialog Management
Alicia Abella and Allen L . Gorin
ATcT Labs Research
180 Park Ave . Bldg 103 Florham Park , NJ 07932

In this paper we describe a systematic approach for creating a dialog management system based on a Construct Algebra  , a collection of relations and operations on a task representation  . These relations and operations are analytical components for building higher level abstractions called dialog motivators  . The dialog manager , consisting of a collection of dialog motivators , is entirely built using the Construct Algebra . 
1 INTRODUCTION
The dialog manager described in this paper implements a novel approach to the problem of dialog management  . There are three major contributions : the task knowledge representation  , a Construct Algebra and a collection of dialog motivators  . The task knowledge representation exploits object -oriented paradigms  . The dialog motivators provide the dialog manager with the dialog strategies that governits behavior  . The Construct Algebra provides the building blocks needed to create new dialog motivators and analyze them  . 
The first main component of this dialog manager is the task knowledge representation  . The task knowledge is encoded in objects . These objects form an inheritance hierarchy that defines the relationships that exists among these objects  . The dialog manager exploits this inheritance hierarchy in determining what queries to pose to the user  . 
No explicit states and transitions need to be defined using this framework  ( Bennacef et al . , 1996; Mengand et . al . , 1996; Sadek et al . , 1996) . A change to the dialog does not require a change to the dialog manager  , but more simply , a change to the inheritance hierarchy . 
The second main component of this dialog manager is the collection of dialogmo-tivators  . The dialog motivators determine what actions need to be taken  ( e . g . ask a confirmation question ) . The dialog motiva-tors are founded on a theoretical framework called a Construct Algebra  . The Construct Algebra allows a designer to add new moti-vators in a principled way  . Creating a new application requires defining the inheritance hierarchy and perhaps additional dialogmo-tivators not encompassed in the existing collection  . 
This dialog manager has been used for two applications  . The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you ?  ( HMIHY )   ( Gorin et al ,  1997) . The system recognizes the words the customer has said  ( Riccardi and Bangalore ,  1998 ) and extracts the meaning of these words ( Wright et al , 1998) to determine what service they want , conducting a dialog ( Abella and Gorin , 1997; Abella et al ,  1996 ) to effectively engage the customer in a conversation that will result in providing the service they requested  . The second application is to Voice Post Query ( VPQ )   ( Buntschuh et al . , 1998 ) which provides spoken access to the information in large personnel database  ( > 120 , 000 entries ) . A user can ask for employee information such as phone number  , fax number , work location , or ask to call an employe e . These applications are signifi-dialog manager . 
2 Task Representation
Information about the task is defined using an object inheritance hierarchy  . The inheritance hierarchy defines the relationships that exist amongs the task knowledge  . Objects are defined to encode the hierarchy . 
This representation adheres to the principles of object-oriented design as described in  ( Booch ,  1994) . Each of the objects has three partitions . The first partition contains the name of the object  , the second contains a list of variables with associated values that are specific to the object  , and the third partition contains any methods associated with the object  . For simplicity of illustration we will not include any of the methods  . Each of the objects inherits its methods from a higher level object called the Construct  . The Construct's methods are the relations and operations that will be described in section  4  . 
The result of the speech recognizer is sent to the spoken language understanding  ( SLU ) module . The SLU module extracts the meaning of the user's utterance and produces a list of possible objects with associated confidence scores that is interpreted by the dialog manager  . The dialog manager then uses the inheritance hierarchy and an algorithm  1 fully described in ( Abella and Gorin ,  1997 ) to produce a set of semantically consistent inputs to be used by the dialog manager  . The input is represented as a boolean expression of constructs extracted from the utterance  . This input is then manipulated by the dialog motivators to produce an appropriate action  , which most often consists of playing a prompt to the user or generating a query to a database  . 
3 The Construct
A construct is the dialog knowledge representation manager's general vehicle  . The task 1An understanding of this algorithm is not necessary for the understanding of the work described in this paper  . 
DIAL FOR ME : ORWARDNUMBER 555-1234



Figure 1: A construct example for HMIHY knowledge is encoded as a hierarchy of constructs  . The construct itself is represented as a tree structure which allows for the building of a contain ment hierarchy  . It consists of two parts , a head and a body . Figure 1 illustrates a construct example for HMIHY . 
The DIAL_FOR_ME construct is the head and it has two constructs for its body  , FOR-
WARD_NUMBER and BILLING . These two constructs represent he two pieces of information necessary to complete a call  . If a user calls requesting to place a call it is the DIAL_FOR_ME construct that is created with the generic BILLING construct and the FORWARD_NUMBER construct with its value set to empty  . The dialog manager will the nask for the forward number and for the type of billing method  . In figure 1 the dialog manager has received a response to the forward numbe request  . 
4 Construct Algebra
The construct algebra defines a collection of elementary relations and operations on a set of constructs  . These relations and operations are then used to build the larger processing units that we call the dialogmoti-vators  . The set of dialog motivators defines the application  . In this section we formally define these relations and operations  . 
4.1 The Construct
Definition 1 Head
A head is an ordered pair < name , value > , where name belongs to some set of prede-set of predefined values  , V . A value may be
NULL ( not assigned a value).
Definition 2 Construct
A construct is defined recursively as an ordered pair < head  , body > where body is a ( possibly empty ) set of constructs . 
4.2 Relations
The Construct Algebra defines ix relations in the set of constructs  . In each of the definitions , Cl and c2 are constructs . Note that the symbols C and C , introduced here , should not be understood in their usual " subset " and " proper subset " interpretation but will be described in definitions  4 and 5  . 
Definition 3E quality
Two constructs are equal , denoted cl = c2 when head ( c1 ) = head ( c2 ) and body ( c1 ) = body ( c2 ) Definition 3 requires that the heads of c1 and c2 be equal . Recall that the head of a construct is an ordered pair < name  , value > which means that their names and values must be equal  . A value may be empty ( NULL ) and by definition be equal to any other value . The equality of bodies means that a bijective mapping exists from the body of clin to the body of  c2 such that elements associated with this mapping are equal  . 
Definition 4 Restriction
Cl is a restriction of c2 , denoted clCc ~ , when head ( c1 ) = head ( c2 ) and ( 3 f : body ( c1 ) - - + body ( c2 ) ) ( f is 1 to 1A ( Vbl ? body ( cl ) ) ( blC_f ( bl ) ) Intuitively , cl can be obtained by " pruning " elements of c2 . The second part of the definition , (3f : . . . ) is what differentiates C from = . It is required that a mapping f between the bodies of Cl and  c2 exist with the following properties : \[~ RSON

C <\ PERSON "" , , , . . . . . . . . ,
ADD~ESs
STREET . . . . . . . . . . . . . . . . . . . . . . . . . . . .  .   . -3 H(NENUMBE Ic 2
Figure 2: STREET and PHONE_NUMBER are " pruned " from c2 to obtain Cl . 
? f is 1 to 1 . In other words , different elements of the body of O , call them hi , are associated with different elements of the body of  c2  , call them b2 ? The elements of the body of c1 are restrictions of the elements of the body of c2  . In other words , blC_b2 , wherebl are elements from the body of Cl and b2 are elements from the body of c2  . 
Figure 2 illustrates an example.
Definition 5 Containment clis contained in c2 , denoted ClCc2 , when
ClC_c2 or (3b2 ? body(c2)) ( ClC52)
We assume that c1 C c2 either if Cl is a restriction of c2 or if Cl is contained in any element of the body of  c2  . Figure 3 gives an example . The AMBIGUITY construct represents the fact that the system is not sure whether the user has requested a 
COLLECT call or a CALLING_CARD call.
This would trigger a clarifying question from the dialog manager  . 
193 ? el

AMBIGUITI'k .   .   .   .   .   .   .   .   .   .   .   .   . ""?2~' ALLING_CARD
CARDNUMBEI ~


Figure 4: cj ? ---> c2
Figure 3: clCc2
Definition 6 Generalization c2 is a generalization of el , denoted c1~__ . ~c2, when
CALLING_CARDDIAL FOR_ME head ( cl ) c--+head ( c2 ) and ( 3 f : body ( c2 ) ~ body ( c1 ) )  ( f is 1 to 1A ( Vba ? body ( c2 ) ) ) (f ( b2 ) ~___b2 ) The generalization of heads means that the name of  c2 is on the inheritance path of cl and their values are equal  . Intuitively , c2 is an ancestor of Clor in object-oriented C ~ . terms ~ C1 is a , 2Note the similarity of this relation to C . Figure 4 illustrates an example . BILLING is a generalization of
CALLING_CARD , or in other words CALL-
ING_CARD is a BILLING.
Definition 7 Symmetric Generalization Cl is asymmetric generalization of  c2  , denoted cl~c2 , when
C1?--->C2 or c2?---~Cl
This definition simply removes the directionality of __?---~  . In other words , either ' tE1iS-aC2"

Clc2
Figure 5: cl ? --> c2 or ; ; c2 is ac1"
Definition 8 Containment Generalization Cl is a containment generalization of  c2  , denoted ci ? ---> c2 , when b2 is contained in c2 and cl is a symmetric generalization of b2  . An example is illustrated in figure 5 . BILLING is contained in DIAL_FOR_ME and is a symmetric generalization of CALLING_CARD  . 
4.3 Operations
The Construct Algebra consists of two operations union  , U and projection ,  \ . 
Definition 9 Union(U)
We will define this operation in several steps . Each step is a progression towards a more general definition  . 
Definition 9.1 Union of values ( vlUv2)
V1 UV2 =
Vl , Vl = v2 and vl#NULL v2 , Vl = v2 and Vl = NULL not defined , Vl#v2 Recall that by definition , NULL is equal to any other value . 
Definition 9.2 Union of heads
We define head ( c1 ) U head ( c2 ) only in the case c\]?-~c2 , which is all that is needed for a definition of U . 
head(cI)Uhead(c2): value(el ) Uvatue())
Definition 9.3 ( c,Uc2)
If c1~_~_c2,
C1UC2 = ( head(c1) U head(c2) , u ? body (   ) ubll bl ? body ( c1 ) A ( Vb2 ? body ( c2 ) ) ( bl #/ ( b2 ) ) ) In this definition the head of the resulting construct is the union of the heads of the oper and s  . The body of the resulting construct consists of two parts  . The first part is a set of unions ( denoted f ( b2 ) Ub2 in the definition above ) where b2 spans the body of the second oper and c2 and f is a mapping from Definition 6  . Recall that the mapping f associates elements of the body  ( c1 ) with elements of the body ( c2 ) such that f ( b2 ) ~- + b2 for b2 ? body ( c2 ) so the union f ( bjUb2 is ( recursively ) defined in Definition 9 . 3 . The second part of the body of the resulting construct consists of those elements bl of the body  ( c1 ) that no element from the body ( c2 ) maps into through the mapping f . In other words , the second part of the body consists of those elements " left 
CALLIN ?
CARD-NUMB 1
NUL Lu
EXPRATIO ~__299/
Cl_CARD : ALLI~1CARDNlYMB ~, 1239834 = c2
Figure 6: clUc2 if c1?-.-~c2
LINO_CARD ~ ARD_NUMBER 123 9834
EXPIRATIO 1~f . Figure 6 illustrates an example . The union operations results in a construct with the head CALLING_CARD and a body that contains both CARD_NUMBER and EXPIRATION  . The CARD_NUMBER construct from Cl and c2 can be combined because the value of CARD__NUMBER from clis NULL  . The construct EXPIRATION is added because it does not exist on the body of  c2  . 
Definition 9.4 ClUc2
If C1,-vC2, ciUc2, ci~-+c2
C1U?2 = C2Uel,C2~C1
Definition 9.5 clUc2
If cl~-+c2,
C1Uc2 =
C1 Uc2 , ( head(c2) , el Ub ~ lb ~? body ( c2 ) A cl ~ b2Ub 2152 ? body ( c2 ) ^Clb ? )  , 
C 1,"-'C2
C1  ~  C2
Figure 7 illustrates this union . The head of the resulting construct is the head of  c2 which is DIAL_FOR_ME . The resulting construct no longer has BILLING but

AL ~ ORWARD~NUMBFZ ~
BILLING\[
ClC2
DIAL_FOR_ME~LLING_CARD

EXPIRATION !
Figure 7: ClI . J C2 if cl  ~ c2 rather CALLING_CARD since BILLING is a generalization of CALLING_CARD  . In addition the resulting construct contains the construct FORWARD_NUMBER because it remains from DIAL_FOR_ME  . 
Definition 9.6 ClUe2
In the general case,
C1~C2-~-el\[,-Je2, c2\[ . . J Cl , (( REP , NULL ),  cl , c2),
C1 ~ C2 e2 ~ el
Cl ~ C2 and
C2 ~ Cl
In this definition REP is a construct used to represent the union of those constructs that do not satisfy any of the aforementioned conditions  . By definition REP has a value of NULL and the body consists of the constructs Cl and  e2  . 
Definition 10 Projection (\)
CI\C2~-.
(( AMBIGUITY , NULL ) , hiUc2161 Cc1 Abl~-c2) e2?-+ cl
ClC2 ~ el
Figure 8 illustrates an example of an ambiguous construct and the result of the 
FIRSTNA\]
C2C1\C2
Figure 8: Projection operation example projection operation  . The construct is
AMBIGUITY because all the elements of its body have the value of  6151 for DEPT . 
In this example , c2 contains the construct
LAST_NAME with the value of Smith.
There are 2 constructs on the body of Cl that are in the relation  b2 CC l , in other words have value for LAST_NAME of Smith . 
Therefore the result is an AMBIGUITY construct with two elements on its body  , both with the LAST_NAME value of Smith . 
5 Dialog Motivators
A dialog motivator determines what action the dialog manager needs to take in conducting its dialog with a user  . The dialog manager for HMIHY currently consists of  5 dialog motivators . They are disambiguation , confirmation , error handling ( recovery from misrecognition or misunderstanding and silence  )  , missing information and context switching . VPQ uses two additional motivators , they are continuation and cQE c
CA : User response
Dk(c , cigK ) = c,c ~ AMBIGUITY
Dk+l(c , CIDK ), CA ~__~_ERROR
Dk+l(C,CIDg(.JCQ ), cAIDK
C\CA,CA ? ----- C
CACA ~ C
Figure 9: Disambiguation Motivator database querying . 
The disambiguation motivator determines when there is ambiguou semantic information  , like conflicting billing methods . Confirmation is used when the SLU returns a result with low confidence  . Error handling takes on three forms . There is error recovery when the speech recognizer has likely misrecognized what the user has said  ( low confidence scores associated with the recognition results  )  , when the user falls silent , and when the user says something the SLU does not expect or does not handle  . Missing information determines what information to ask about in order to complete a transaction  . 
Context switching is the ability of the system to realize when the user has changed his/her mind or realizes that it has misunderstood and allows the user to correct it  . The continuation motivator determines when it is valid to offer the user the choice to query the system for additional information  . 
Database querying decides when the system has acquired enough information to query a database for the requested information  . 
5.1 Disambiguation Motivator
Figure 9 illustrate how the disambiguation motivator is created using the Construct Algebra  . The disambiguation motivator is called with the current construct c and a set of constructs called CIDg that represents information that the user does not know  ( IDK-"ID on't Know " )  , in other words , the user explicitly responds to a prompt with the phrase " I don't know " or its equivalents  . 
2 The phrases chosen are based on trials
Input : A sequence of semantic input from the SLU module in response to a prompt Output : Complete construct c  ( no need for further dialog ) 

For all dialog motivators DMI if DMi applies to c
Performaction(DMi , c)
Apply Dialog Manager to get CA
Using Construct Algebra , combine c and CA into c
Until no motivator applies
Return c
Figure 10: Dialog Manager algorithm
The motivato runs through several checks on the construct c  . The first is to check to see if in fact the motivator applies  , or in other words if c is a restriction of AMBIGUITY  . 
If it is not then the motivator simply return c without changing it  . The second step is to check to see if the ERROR construct is a generalization fCA where CA represents he user's response  . The ERROR construct represents an error condition like silence or misrecognition  . If it is , then it goes on to next motivator because this motivator does not apply to error conditions  . If CA equals the IDK construct then this means that the user did not know the answer to our query and we add the construct used for disambiguation  , cQ to the set of constructs ? IDK . If however , CA is in the containment generalization relation with c then the projection operation is applied and the result is returned  . If CA is not in this relation then this indicates a context switch on the part of the user and the disambiguation motiva to returns CA as the result  . 
All other motivators are constructed in a similar fashion  . An application can use these motivators or create new ones that are application specific using the operations and relations of the Construct Algebra  . 

System " VPQ . What can I do for you ?
User : I need the phone number for Klein.
System-I have more than 20 listings for Klein . Can you please say the first name ?
User : William.
System " I have 2 listings for William Klein.
Can you tell me the person's work location ?
User : Bedminster
System " The phone number for William
Klein is 97 33 45 54 32 . Would you like more information ?
User : No.
System " Thank you for using VPQ.
Figure 11: A sample dialog for VPQ 6 Dialog Manager The input to the dialog manager is a collection of semantic input generated by the SLU  . 
Figure 10 illustrates the algorithm used by the dialog manager  . The output is the complete construct c which no longer requires further dialog  . The algorithm loops through all the dialog motivators determining which one needs to be applied to c  . If it finds a mo-tivator that applies then it will perform the necessary action  ( e . g . play a promptor do a database lookup ) . The algorithm repeats itself to obtain CA ( the construct answer )  . In other words , the construct hat results from the action is subject to the dialog motiva-tors starting from the beginning  . Once CA has been found to be complete it is combined with cusing Construct Algebra to produce a new construct  . This new construct calsogoes through the loop of dialog motivators and the procedure continues until no moti-vator applies and the algorithm returns the final construct c  . 
6.1 Example
To illustrate how the dialog manager functions we will use an example from VPQ  . 
Figure 11 illustrates a sample dialog with the system . The sequence of motivators for VPQ is error handling  , confirmation , missing information , database querying and disambiguation . The construct hat is created as a result of the user's initial utterance is shown in figure  12  . All the information needed to do a database lookup is found in the user's utterance  , namely the piece of information the user is seeking and the name of the person  . Therefore the first motivator that applies is database querying  . This moti-vator creates the database query and based on the result creates the construct CA  . The construct CA is then searched by each of the motivators beginning again with error handling  . The motivator that applies to CA is the disambiguation motivator because there are more than  20 people in the database whose last name is pronounced Klein  , including Klein , Cline and Kline . The disambiguation motivator searches through CA to determine  , based on preset parameters , which piece of information is most useful for the disambiguation process as well as which piece of information the user is likely to know  , which is selected when the inheritance hierarchy is designed  . For VPQ this includes asking about the first name and work location  . In this example the dialog manager searches the databas entries and determines that the most discriminating piece of information is the first name  . Once the user responds with the first name there are still  2 possible candidates and it asks for the next piece of information which is work location  . 
Had the user not known the work location the system would have read out the phone number of both people since the total number of matches is less than  3  . If the number of entries after disambiguation remains greater than  3 the system refers the user to a live operator during work hours  . 
7 Conclusion
In this paper we have described a novel approach to dialog management  . The task knowledge representation defined intuitively and without the need to define call flows in the traditional finite-state approach  . The Construct Algebra serves as the building blocks from which the dialog motivators that drive the dialog system are comprised  . 
Building a new application will only require the designer to define the objects  ( e . g . COL-LECT , CREDIT etc . ) and the inheritance hierarchy . The Construct Algebra serves as an analytical tool that allows the dialogmo-tivators to be formally defined and analyzed and provides an abstraction hierarchy that hides the low-level details of the implementation and pieces together the dialog motiva-tors  . This same dialog manager is currently being used by two very different applications  ( HMIHY and VPQ )  . 
A.L . Gorin , G . Riccardi , and J . H . Wright.
1997. How May I Help You ? Speech Com-munciation.
Helen Meng and Senis Busay apong chaiet.
al .  1996 . Wheels : A conversational system in the automobile classifieds domain  . 
International Conference on Spoken Language Processing  . 
G . Riccardi and S . Bangalore .  1998 . Automatic acquisision of phrase grammars for stochastic language modeling  . In Proc . 
ACL Workshop on Very Large Corpora,

M.D . Sadek , A . Ferrieux , A . Cozannet,
P . Bretier , F . Panaget , and J . Simonin.
1996 . Effective Human Computer Cooperative Spoken Dialogue : the AGS Demonstrator  . International Conference on Spoken Language Processing  . 
Jerry Wright , Allen L . Gorin , and Alicia
Abella .  1998 . Spoken language understanding within dialogs using a graphical model of task structure  . In Proc . ICSLP

References /
Alicia Abella and Allen L . Gorin . 1997.
Generating semantically consistent inputs to a dialog manager  . In Proc . Euro Speech
Rhodes , Greece.
A . Abella , M.K . Brown , and B . Buntschuh.
1996 . Development principles for dialog-based interfaces  . European Conference on
Artificial Intelligence.
S . Bennacef , L . Devillers , S . Rosset , and
L . Lamel .  1996 . Dialog in the rail-teltelephone-based system . International Conference on Spoken Language Processing  . 
Grady Booch .  1994 . Object-Oriented Analysis and Design with Applications  . Benjamin Cummings . 
B . Buntschuh , C . Kamm , G . Di Fabbrizio,
A . Abella , M . Mohri , S . Narayan , I . Zelj-vokic , R . D . Sharp , J . Wright , S . Marcus , J . Shaffer , R . Duncan , and J . G . Wilpon . 
1998 . VPQ : A spoken language interface to large scale directory information  . In
Proc . ICSLP Sydney.

